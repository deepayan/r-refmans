<!DOCTYPE html><html><head><title>Help for package SteppedPower</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SteppedPower}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha012_to_RandEff'><p>Correlation structure: transform alpha to random effects</p></a></li>
<li><a href='#compute_glsPower'><p>Compute power via weighted least squares</p></a></li>
<li><a href='#compute_InfoContent'><p>Title  Formula-based calculation of information content</p></a></li>
<li><a href='#construct_CovBlk'><p>Construct a Single Block of the Covariance Matrix</p></a></li>
<li><a href='#construct_CovMat'><p>Construct a Covariance Matrix</p></a></li>
<li><a href='#construct_CovSubMat'><p>Construct a Block of the Covariance Matrix</p></a></li>
<li><a href='#construct_DesMat'><p>Construct the Design Matrix</p></a></li>
<li><a href='#construct_incompMat'><p>Constructs a matrix of 'NA' and '1' for unobserved and observed cluster periods, respectively.</p></a></li>
<li><a href='#construct_timeAdjust'><p>Construct the time period adjustment in the design matrix</p></a></li>
<li><a href='#construct_trtMat'><p>Construct Treatment Matrix</p></a></li>
<li><a href='#glsPower'><p>Compute power via weighted least squares</p></a></li>
<li><a href='#plot_CellWeights'><p>plot cell contributions (weights) of a gls object</p></a></li>
<li><a href='#plot_CovMat'><p>Visualise a Covariance Matrix</p></a></li>
<li><a href='#plot_InfoContent'><p>plot the information content of a gls object</p></a></li>
<li><a href='#plot.DesMat'><p>plot.DesMat</p></a></li>
<li><a href='#plot.glsPower'><p>plot an object of class 'glsPower'</p></a></li>
<li><a href='#print.DesMat'><p>print.DesMat</p></a></li>
<li><a href='#print.glsPower'><p>Print an object of class 'glsPower'</p></a></li>
<li><a href='#RandEff_to_alpha012'><p>Correlation structure: transform random effects to alpha</p></a></li>
<li><a href='#SteppedPower-pkg'><p>SteppedPower</p></a></li>
<li><a href='#tTestPwr'><p>Compute Power of a Wald Test</p></a></li>
<li><a href='#VarClosed_Kasza'><p>Closed formula for treatment variance in open cohort settings</p></a></li>
<li><a href='#VarClosed_Li'><p>Closed formula for treatment variance, with proportional decay</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Power Calculation for Stepped Wedge Designs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for power and sample size 
    calculation as well as design diagnostics for 
    longitudinal mixed model settings, with a focus on stepped wedge designs.
    All calculations are oracle estimates i.e. assume random effect variances 
    to be known (or guessed) in advance.  
    The method is introduced in Hussey and Hughes (2007) &lt;<a href="https://doi.org/10.1016%2Fj.cct.2006.05.007">doi:10.1016/j.cct.2006.05.007</a>&gt;,
    extensions are discussed in Li et al. (2020) &lt;<a href="https://doi.org/10.1177%2F0962280220932962">doi:10.1177/0962280220932962</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, plotly, Rfast, grDevices, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, swCRTdesign, testthat, pwr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-12 16:32:31 UTC; pm</td>
</tr>
<tr>
<td>Author:</td>
<td>Philipp Mildenberger
    <a href="https://orcid.org/0000-0002-7367-1708"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Federico Marini <a href="https://orcid.org/0000-0003-3252-7758"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philipp Mildenberger &lt;pmildenb@uni-mainz.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-13 00:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha012_to_RandEff'>Correlation structure: transform alpha to random effects</h2><span id='topic+alpha012_to_RandEff'></span>

<h3>Description</h3>

<p>Correlation structure: transform alpha to random effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha012_to_RandEff(alpha012, sigResid = NULL, sigMarg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha012_to_RandEff_+3A_alpha012">alpha012</code></td>
<td>
<p>A vector or a list of length 3. Each list element must have
the same dimension.</p>
</td></tr>
<tr><td><code id="alpha012_to_RandEff_+3A_sigresid">sigResid</code></td>
<td>
<p>Residual standard deviation on individual level. Either
residual sd or marginal sd needs to be specified.</p>
</td></tr>
<tr><td><code id="alpha012_to_RandEff_+3A_sigmarg">sigMarg</code></td>
<td>
<p>Marginal standard deviation on individual level. Either
residual sd or marginal sd needs to be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing four named elements (possibly matrices):
random cluster intercept 'tau', random time effect 'gamma', random subject
intercept and residual standard deviation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alpha012_to_RandEff(alpha012=c(.1,.1,.1), sigMarg=1)
alpha012_to_RandEff(alpha012=c(.1,.1,.1), sigResid=.9486833)

## The function is vectorised:
alpha012_to_RandEff(alpha012=list(matrix(c(0,.1,.1,.2), 2, 2),
                                  matrix(c(0,0,.1,.2) , 2, 2),
                                  matrix(c(0,0,.2,.2) , 2, 2)),
                    sigMarg=1)

</code></pre>

<hr>
<h2 id='compute_glsPower'>Compute power via weighted least squares</h2><span id='topic+compute_glsPower'></span>

<h3>Description</h3>

<p>This function is not intended to be used directly, but rather to be called
by 'glsPower' - the main function of this package.
It expects the design matrix as an input argument 'DesMat' and
construct the covariance matrix (if not given as well). These matrices are
used to calculate the variance of the treatment effect estimator which is
then used to calculate the power to detect the assumed treatment effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_glsPower(
  DesMat,
  EffSize,
  sigma,
  tau = 0,
  eta = NULL,
  AR = NULL,
  rho = NULL,
  gamma = NULL,
  psi = NULL,
  N = NULL,
  CovMat = NULL,
  dfAdjust = "none",
  sig.level = 0.05,
  INDIV_LVL = FALSE,
  INFO_CONTENT = FALSE,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_glsPower_+3A_desmat">DesMat</code></td>
<td>
<p>object of class 'DesMat'.</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_effsize">EffSize</code></td>
<td>
<p>raw effect, i.e. difference between mean under control and
mean under intervention</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_sigma">sigma</code></td>
<td>
<p>numeric, residual error of cluster means if no N given.</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_tau">tau</code></td>
<td>
<p>numeric, standard deviation of random intercepts</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_eta">eta</code></td>
<td>
<p>numeric (scalar or matrix), standard deviation of random slopes.
If 'eta' is given as scalar, 'trtMat' is needed as well.</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_ar">AR</code></td>
<td>
<p>numeric, vector containing up to three values, each between 0 and 1.
Defaults to NULL. It defines the AR(1)-correlation of random effects.
The first element corresponds to the cluster intercept, the second to the
treatment effect and the third to subject specific intercept.
If only one element is provided, autocorrelation of all random effects is
assumed to be the same.
*Currently not compatible with 'rho'!=0 !*</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_rho">rho</code></td>
<td>
<p>numeric (scalar), correlation of 'tau' and 'eta'. The default is no correlation.</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_gamma">gamma</code></td>
<td>
<p>numeric (scalar), random time effect</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_psi">psi</code></td>
<td>
<p>numeric (scalar), random subject specific intercept.
Leads to a closed cohort setting</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_n">N</code></td>
<td>
<p>numeric, number of individuals per cluster. Either a scalar, vector
of length #Clusters or a matrix of dimension #Clusters x timepoints.
Defaults to 1 if not passed.</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_covmat">CovMat</code></td>
<td>
<p>numeric, a positive-semidefinite matrix with
(#Clusters <code class="reqn">\cdot</code> timepoints) rows and columns. If 'CovMat' is given,
'sigma', 'tau', 'eta', 'rho', 'gamma' and 'psi' as well as 'alpha_0_1_2'
must be NULL.</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_dfadjust">dfAdjust</code></td>
<td>
<p>character, one of the following: &quot;none&quot;,&quot;between-within&quot;,
&quot;containment&quot;, &quot;residual&quot;.</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_sig.level">sig.level</code></td>
<td>
<p>numeric (scalar), significance level, defaults to 0.05</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_indiv_lvl">INDIV_LVL</code></td>
<td>
<p>logical, should the computation be conducted on an
individual level? This leads to longer run time and is
mainly for diagnostic purposes.</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_info_content">INFO_CONTENT</code></td>
<td>
<p>logical, should the information content of cluster cells be
computed? The default is 'TRUE' for designs with less or equal than 2500
cluster cells, otherwise 'FALSE'. Ignored if 'verbose=0'.</p>
</td></tr>
<tr><td><code id="compute_glsPower_+3A_verbose">verbose</code></td>
<td>
<p>integer, how much information should the function return?
See also under 'Value'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return depends on the 'verbose' parameter.
If 'verbose'=0, only the power is returned
If 'verbose'=1 (the default), a list containing power and the
parameters of the specific setting is returned.
If requested (by 'verbose'=2) this list also contains relevant matrices.
</p>

<hr>
<h2 id='compute_InfoContent'>Title  Formula-based calculation of information content</h2><span id='topic+compute_InfoContent'></span>

<h3>Description</h3>

<p>Title  Formula-based calculation of information content
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_InfoContent(CovMat = NULL, W = NULL, dsn, sumCl, tp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_InfoContent_+3A_covmat">CovMat</code></td>
<td>
<p>#' @param CovMat numeric, a positive-semidefinite matrix with
(#Clusters <code class="reqn">\cdot</code> timepoints) rows and columns.</p>
</td></tr>
<tr><td><code id="compute_InfoContent_+3A_w">W</code></td>
<td>
<p>numeric, the inverse of a covariance matrix. If CovMat is specified,
input for W is ignored</p>
</td></tr>
<tr><td><code id="compute_InfoContent_+3A_dsn">dsn</code></td>
<td>
<p>a matrix with  (#Clusters <code class="reqn">\cdot</code> #timepoints) rows and p
columns, where p are the degrees of freedom of fixed effects in a gls model.
This usually contains the intervention effect and some specification of the
time effect.</p>
</td></tr>
<tr><td><code id="compute_InfoContent_+3A_sumcl">sumCl</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="compute_InfoContent_+3A_tp">tp</code></td>
<td>
<p>number of time points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the information content for every cluster-period cell
</p>

<hr>
<h2 id='construct_CovBlk'>Construct a Single Block of the Covariance Matrix</h2><span id='topic+construct_CovBlk'></span>

<h3>Description</h3>

<p>Constructs the covariance matrix
for multiple measurements of the same cluster.
This function is usually called by 'construct_CovMat' and is
not designed to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_CovBlk(sigma, tau = NULL, eta = NULL, AR = NULL, rho = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_CovBlk_+3A_sigma">sigma</code></td>
<td>
<p>numeric (vector of length 'timepoints'),
residual error</p>
</td></tr>
<tr><td><code id="construct_CovBlk_+3A_tau">tau</code></td>
<td>
<p>numeric (vector of length 'timepoints'),
standard deviation of random intercepts</p>
</td></tr>
<tr><td><code id="construct_CovBlk_+3A_eta">eta</code></td>
<td>
<p>numeric (vector of length 'timepoints'),
standard deviation of random slope</p>
</td></tr>
<tr><td><code id="construct_CovBlk_+3A_ar">AR</code></td>
<td>
<p>numeric, vector containing up to three values, each between 0 and 1.
Defaults to NULL. It defines the AR(1)-correlation of random effects.
The first element corresponds to the cluster intercept, the second to the
treatment effect and the third to subject specific intercept.
If only one element is provided, autocorrelation of all random effects is
assumed to be the same.
*Currently not compatible with 'rho'!=0 !*</p>
</td></tr>
<tr><td><code id="construct_CovBlk_+3A_rho">rho</code></td>
<td>
<p>numeric (scalar), correlation of 'tau' and 'eta'. The default is no correlation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a block of a covariance matrix,
corresponding to intra-cluster covariance over time for one cluster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct_CovBlk(sigma=rep(2,5), tau=rep(1,5))

construct_CovBlk(sigma=rep(2,5),
                tau=rep(.5,5), eta=c(0,0,1,1,1),
                AR=c(.5, 1))
</code></pre>

<hr>
<h2 id='construct_CovMat'>Construct a Covariance Matrix</h2><span id='topic+construct_CovMat'></span>

<h3>Description</h3>

<p>constructs a (block diagonal) covariance matrix.
This function calls 'construct_CovBlk'
(or 'construct_CovSubMat' in case of repeated
observations of the same individuals) for each block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_CovMat(
  sumCl = NULL,
  timepoints = NULL,
  sigma,
  tau,
  eta = NULL,
  AR = NULL,
  rho = NULL,
  gamma = NULL,
  trtMat = NULL,
  N = NULL,
  CovBlk = NULL,
  psi = NULL,
  INDIV_LVL = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_CovMat_+3A_sumcl">sumCl</code></td>
<td>
<p>total number of clusters</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_timepoints">timepoints</code></td>
<td>
<p>numeric (scalar or vector), number of timepoints (periods).
If design is swd, timepoints defaults to length(Cl)+1.
Defaults to 1 for parallel designs.</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_sigma">sigma</code></td>
<td>
<p>numeric, residual error of cluster means if no N given.</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_tau">tau</code></td>
<td>
<p>numeric, standard deviation of random intercepts</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_eta">eta</code></td>
<td>
<p>numeric (scalar or matrix), standard deviation of random slopes.
If 'eta' is given as scalar, 'trtMat' is needed as well.</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_ar">AR</code></td>
<td>
<p>numeric, vector containing up to three values, each between 0 and 1.
Defaults to NULL. It defines the AR(1)-correlation of random effects.
The first element corresponds to the cluster intercept, the second to the
treatment effect and the third to subject specific intercept.
If only one element is provided, autocorrelation of all random effects is
assumed to be the same.
*Currently not compatible with 'rho'!=0 !*</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_rho">rho</code></td>
<td>
<p>numeric (scalar), correlation of 'tau' and 'eta'. The default is no correlation.</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_gamma">gamma</code></td>
<td>
<p>numeric (scalar), random time effect</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_trtmat">trtMat</code></td>
<td>
<p>a matrix of dimension *#Cluster* x *timepoints* as produced by
the function 'construct_trtMat', indicating the cluster-periods that receive
interventional treatment. Defaults to NULL. If trtMat is given, the arguments
'sumCl' and 'timepoints' are ignored (!).</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_n">N</code></td>
<td>
<p>numeric, number of individuals per cluster. Either a scalar, vector
of length #Clusters or a matrix of dimension #Clusters x timepoints.
Defaults to 1 if not passed.</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_covblk">CovBlk</code></td>
<td>
<p>a matrix of dimension *timepoints* x *timepoints*.</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_psi">psi</code></td>
<td>
<p>numeric (scalar), random subject specific intercept.
Leads to a closed cohort setting</p>
</td></tr>
<tr><td><code id="construct_CovMat_+3A_indiv_lvl">INDIV_LVL</code></td>
<td>
<p>logical, should the computation be conducted on an
individual level? This leads to longer run time and is
mainly for diagnostic purposes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a covariance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Two clusters, three timepoints,
## residual standard error sd=3, random slope sd=1.
construct_CovMat(sumCl=2, timepoints=3, sigma=3, tau=1)
##
##
## ... with random slope as AR-1 process
construct_CovMat(sumCl=2, timepoints=3, sigma=3, tau=1, AR=.8)
##
##
## ... with sigma and tau variing over time and between clusters:
construct_CovMat(sumCl=2,timepoints=3,
                 sigma=matrix(c(1,2,2,1,1,2),nrow=2, byrow=TRUE),
                 tau=matrix(c(.2,.1,.1,.2,.2,.1),nrow=2, byrow=TRUE),
                 N=c(3,4))
</code></pre>

<hr>
<h2 id='construct_CovSubMat'>Construct a Block of the Covariance Matrix</h2><span id='topic+construct_CovSubMat'></span>

<h3>Description</h3>

<p>Constructs the covariance matrix
for multiple measurements of the same cluster
if the same individuals are observed at all time periods.
This function is not designed to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_CovSubMat(
  N,
  timepoints,
  sigma,
  tau,
  eta = NULL,
  AR = NULL,
  rho = NULL,
  gamma = NULL,
  psi = NULL,
  INDIV_LVL = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_CovSubMat_+3A_n">N</code></td>
<td>
<p>Number of individuals per cluster</p>
</td></tr>
<tr><td><code id="construct_CovSubMat_+3A_timepoints">timepoints</code></td>
<td>
<p>numeric (scalar or vector), number of timepoints (periods).
If design is swd, timepoints defaults to length(Cl)+1.
Defaults to 1 for parallel designs.</p>
</td></tr>
<tr><td><code id="construct_CovSubMat_+3A_sigma">sigma</code></td>
<td>
<p>numeric (vector of length 'timepoints'),
residual error</p>
</td></tr>
<tr><td><code id="construct_CovSubMat_+3A_tau">tau</code></td>
<td>
<p>numeric (vector of length 'timepoints'),
standard deviation of random intercepts</p>
</td></tr>
<tr><td><code id="construct_CovSubMat_+3A_eta">eta</code></td>
<td>
<p>numeric (vector of length 'timepoints'),
standard deviation of random slope</p>
</td></tr>
<tr><td><code id="construct_CovSubMat_+3A_ar">AR</code></td>
<td>
<p>numeric, vector containing up to three values, each between 0 and 1.
Defaults to NULL. It defines the AR(1)-correlation of random effects.
The first element corresponds to the cluster intercept, the second to the
treatment effect and the third to subject specific intercept.
If only one element is provided, autocorrelation of all random effects is
assumed to be the same.
*Currently not compatible with 'rho'!=0 !*</p>
</td></tr>
<tr><td><code id="construct_CovSubMat_+3A_rho">rho</code></td>
<td>
<p>numeric (scalar), correlation of 'tau' and 'eta'. The default is no correlation.</p>
</td></tr>
<tr><td><code id="construct_CovSubMat_+3A_gamma">gamma</code></td>
<td>
<p>numeric (vector of length 'timepoints'),
standard deviation of a random time effect.</p>
</td></tr>
<tr><td><code id="construct_CovSubMat_+3A_psi">psi</code></td>
<td>
<p>numeric (scalar), random subject specific intercept.
Leads to a closed cohort setting</p>
</td></tr>
<tr><td><code id="construct_CovSubMat_+3A_indiv_lvl">INDIV_LVL</code></td>
<td>
<p>logical, should the computation be conducted on an
individual level? This leads to longer run time and is
mainly for diagnostic purposes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a block of a covariance matrix with two levels of clustering,
corresponding to intra-cluster covariance over time for one cluster
</p>

<hr>
<h2 id='construct_DesMat'>Construct the Design Matrix</h2><span id='topic+construct_DesMat'></span>

<h3>Description</h3>

<p>Constructs the design matrix with one column for every (fixed)
parameter to be estimated and one row for every cluster for every timepoint.
This function calls 'construct_trtMat' to construct a matrix that indicates
treatment status for each cluster at each timepoint.
This is then transformed into the first
column of the design matrix. 'construct_CovMat' further calls
'construct_timeAdjust' to get the fixed effect(s) of the timepoints.
</p>
<p>Note: Unlike the usual notation, the treatment effect is in the first column
(for easier access by higher level functions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_DesMat(
  Cl = NULL,
  trtDelay = NULL,
  dsntype = "SWD",
  timepoints = NULL,
  timeAdjust = "factor",
  period = NULL,
  trtmatrix = NULL,
  timeBlk = NULL,
  N = NULL,
  incomplete = NULL,
  INDIV_LVL = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_DesMat_+3A_cl">Cl</code></td>
<td>
<p>integer (vector), number of clusters per sequence group (in SWD),
or number in control and intervention (in parallel designs)</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_trtdelay">trtDelay</code></td>
<td>
<p>numeric (possibly vector), 'NA'(s) and/or value(s)
between '0' and '1'. 'NA' means that first (second, ... ) period after intervention
start is not observed. A value between '0' and '1' specifies the assumed proportion of intervention effect
in the first (second ... ) intervention period.</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_dsntype">dsntype</code></td>
<td>
<p>character, defines the type of design. Options are &quot;SWD&quot;,
&quot;parallel&quot; and &quot;parallel_baseline&quot;, defaults to &quot;SWD&quot;.</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_timepoints">timepoints</code></td>
<td>
<p>numeric (scalar or vector), number of timepoints (periods).
If design is swd, timepoints defaults to length(Cl)+1.
Defaults to 1 for parallel designs.</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_timeadjust">timeAdjust</code></td>
<td>
<p>character, specifies adjustment for time periods.
One of the following: &quot;factor&quot;, &quot;linear&quot;, &quot;none&quot;, &quot;periodic&quot;.
Defaults to &quot;factor&quot;.</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_period">period</code></td>
<td>
<p>numeric (scalar)</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_trtmatrix">trtmatrix</code></td>
<td>
<p>an optional user defined matrix
to define treatment allocation</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_timeblk">timeBlk</code></td>
<td>
<p>an optional user defined matrix that defines
the time adjustment in one cluster.
Is repeated for every cluster.</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_n">N</code></td>
<td>
<p>numeric, number of individuals per cluster. Either a scalar, vector
of length #Clusters or a matrix of dimension #Clusters x timepoints.
Defaults to 1 if not passed.</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_incomplete">incomplete</code></td>
<td>
<p>integer, either a scalar (only for SWD) or a matrix.
A vector defines the number of periods before and after the switch from
control to intervention that are observed. A matrix consists of '1's for
observed clusterperiods and '0's or 'NA' for unobserved clusterperiods.</p>
</td></tr>
<tr><td><code id="construct_DesMat_+3A_indiv_lvl">INDIV_LVL</code></td>
<td>
<p>logical, should the computation be conducted on an
individual level? This leads to longer run time and is
mainly for diagnostic purposes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class DesMat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct_DesMat(Cl=c(2,0,1))
construct_DesMat(Cl=c(2,0,1), N=c(1,3,2))

## manually defined time adjustment (same as above)
timeBlock &lt;- matrix(c(1,0,0,0,
                      1,1,0,0,
                      1,0,1,0,
                      1,0,0,1), 4, byrow=TRUE)
construct_DesMat(Cl=c(2,0,1), timeBlk=timeBlock)

</code></pre>

<hr>
<h2 id='construct_incompMat'>Constructs a matrix of 'NA' and '1' for unobserved and observed cluster periods, respectively.</h2><span id='topic+construct_incompMat'></span>

<h3>Description</h3>

<p>Mostly useful to build incomplete stepped wedge designs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_incompMat(incomplete, dsntype, timepoints, Cl, trtmatrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_incompMat_+3A_incomplete">incomplete</code></td>
<td>
<p>integer, either a scalar (only for SWD) or a matrix.
A vector defines the number of periods before and after the switch from
control to intervention that are observed. A matrix consists of '1's for
observed clusterperiods and '0's or 'NA' for unobserved clusterperiods.</p>
</td></tr>
<tr><td><code id="construct_incompMat_+3A_dsntype">dsntype</code></td>
<td>
<p>character, defines the type of design. Options are &quot;SWD&quot;,
&quot;parallel&quot; and &quot;parallel_baseline&quot;, defaults to &quot;SWD&quot;.</p>
</td></tr>
<tr><td><code id="construct_incompMat_+3A_timepoints">timepoints</code></td>
<td>
<p>numeric (scalar or vector), number of timepoints (periods).
If design is swd, timepoints defaults to length(Cl)+1.
Defaults to 1 for parallel designs.</p>
</td></tr>
<tr><td><code id="construct_incompMat_+3A_cl">Cl</code></td>
<td>
<p>integer (vector), number of clusters per sequence group (in SWD),
or number in control and intervention (in parallel designs)</p>
</td></tr>
<tr><td><code id="construct_incompMat_+3A_trtmatrix">trtmatrix</code></td>
<td>
<p>an optional user defined matrix
to define treatment allocation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='construct_timeAdjust'>Construct the time period adjustment in the design matrix</h2><span id='topic+construct_timeAdjust'></span>

<h3>Description</h3>

<p>Offers several options to adjust for secular trends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_timeAdjust(
  Cl,
  timepoints,
  timeAdjust = "factor",
  period = NULL,
  timeBlk = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_timeAdjust_+3A_cl">Cl</code></td>
<td>
<p>integer (vector), number of clusters per sequence group (in SWD),
or number in control and intervention (in parallel designs)</p>
</td></tr>
<tr><td><code id="construct_timeAdjust_+3A_timepoints">timepoints</code></td>
<td>
<p>numeric (scalar or vector), number of timepoints (periods).
If design is swd, timepoints defaults to length(Cl)+1.
Defaults to 1 for parallel designs.</p>
</td></tr>
<tr><td><code id="construct_timeAdjust_+3A_timeadjust">timeAdjust</code></td>
<td>
<p>character, specifies adjustment for time periods.
One of the following: &quot;factor&quot;, &quot;linear&quot;, &quot;none&quot;, &quot;periodic&quot;.
Defaults to &quot;factor&quot;.</p>
</td></tr>
<tr><td><code id="construct_timeAdjust_+3A_period">period</code></td>
<td>
<p>numeric (scalar)</p>
</td></tr>
<tr><td><code id="construct_timeAdjust_+3A_timeblk">timeBlk</code></td>
<td>
<p>an optional user defined matrix that defines
the time adjustment in one cluster.
Is repeated for every cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with one row for every cluster at every timepoint and number of columns
depending of adjustment type.
</p>

<hr>
<h2 id='construct_trtMat'>Construct Treatment Matrix</h2><span id='topic+construct_trtMat'></span>

<h3>Description</h3>

<p>Constructs a matrix of '#cluster' rows and '#timepoint' columns, indicating
treatment status in each cluster at each timepoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_trtMat(Cl, trtDelay, dsntype, timepoints = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_trtMat_+3A_cl">Cl</code></td>
<td>
<p>integer (vector), number of clusters per sequence group (in SWD),
or number in control and intervention (in parallel designs)</p>
</td></tr>
<tr><td><code id="construct_trtMat_+3A_trtdelay">trtDelay</code></td>
<td>
<p>numeric (possibly vector), 'NA'(s) and/or value(s)
between '0' and '1'. 'NA' means that first (second, ... ) period after intervention
start is not observed. A value between '0' and '1' specifies the assumed proportion of intervention effect
in the first (second ... ) intervention period.</p>
</td></tr>
<tr><td><code id="construct_trtMat_+3A_dsntype">dsntype</code></td>
<td>
<p>character, defines the type of design. Options are &quot;SWD&quot;,
&quot;parallel&quot; and &quot;parallel_baseline&quot;, defaults to &quot;SWD&quot;.</p>
</td></tr>
<tr><td><code id="construct_trtMat_+3A_timepoints">timepoints</code></td>
<td>
<p>numeric (scalar or vector), number of timepoints (periods).
If design is swd, timepoints defaults to length(Cl)+1.
Defaults to 1 for parallel designs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix trtMat, where rows and columns correspond to cluster
and timepoints, respectively
</p>


<h3>Examples</h3>

<pre><code class='language-R'>construct_trtMat(Cl=c(1,2,1), trtDelay=c(.2,.8), dsntype="SWD")


</code></pre>

<hr>
<h2 id='glsPower'>Compute power via weighted least squares</h2><span id='topic+glsPower'></span>

<h3>Description</h3>

<p>This is the main function of the SteppedPower package.
It calls the constructor functions for the design matrix and
covariance matrix, and then calculates the variance of the
intervention effect estimator. The latter is then used
to compute the power of a Wald test of a (given) intervention effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glsPower(
  Cl = NULL,
  timepoints = NULL,
  DesMat = NULL,
  trtDelay = NULL,
  incomplete = NULL,
  timeAdjust = "factor",
  period = NULL,
  dsntype = "SWD",
  mu0,
  mu1,
  marginal_mu = FALSE,
  sigma = NULL,
  tau = NULL,
  eta = NULL,
  AR = NULL,
  rho = NULL,
  gamma = NULL,
  psi = NULL,
  alpha_0_1_2 = NULL,
  CovMat = NULL,
  N = NULL,
  power = NULL,
  family = "gaussian",
  N_range = c(1, 1000),
  sig.level = 0.05,
  dfAdjust = "none",
  INDIV_LVL = FALSE,
  INFO_CONTENT = NULL,
  verbose = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glsPower_+3A_cl">Cl</code></td>
<td>
<p>integer (vector), number of clusters per sequence group (in SWD),
or number in control and intervention (in parallel designs)</p>
</td></tr>
<tr><td><code id="glsPower_+3A_timepoints">timepoints</code></td>
<td>
<p>numeric (scalar or vector), number of timepoints (periods).
If design is swd, timepoints defaults to length(Cl)+1.
Defaults to 1 for parallel designs.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_desmat">DesMat</code></td>
<td>
<p>Either an object of class 'DesMat' or a matrix indicating the
treatment status for each cluster at each timepoint. If supplied,
'timepoints','Cl','trtDelay' are ignored.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_trtdelay">trtDelay</code></td>
<td>
<p>numeric (possibly vector), 'NA'(s) and/or value(s)
between '0' and '1'. 'NA' means that first (second, ... ) period after intervention
start is not observed. A value between '0' and '1' specifies the assumed proportion of intervention effect
in the first (second ... ) intervention period.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_incomplete">incomplete</code></td>
<td>
<p>integer, either a scalar (only for SWD) or a matrix.
A vector defines the number of periods before and after the switch from
control to intervention that are observed. A matrix consists of '1's for
observed clusterperiods and '0's or 'NA' for unobserved clusterperiods.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_timeadjust">timeAdjust</code></td>
<td>
<p>character, specifies adjustment for time periods.
One of the following: &quot;factor&quot;, &quot;linear&quot;, &quot;none&quot;, &quot;periodic&quot;.
Defaults to &quot;factor&quot;.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_period">period</code></td>
<td>
<p>numeric (scalar)</p>
</td></tr>
<tr><td><code id="glsPower_+3A_dsntype">dsntype</code></td>
<td>
<p>character, defines the type of design. Options are &quot;SWD&quot;,
&quot;parallel&quot; and &quot;parallel_baseline&quot;, defaults to &quot;SWD&quot;.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_mu0">mu0</code></td>
<td>
<p>numeric (scalar), mean under control</p>
</td></tr>
<tr><td><code id="glsPower_+3A_mu1">mu1</code></td>
<td>
<p>numeric (scalar), mean under treatment</p>
</td></tr>
<tr><td><code id="glsPower_+3A_marginal_mu">marginal_mu</code></td>
<td>
<p>logical. Only relevant for non-gaussian outcome.
Indicates whether mu0 and mu1 are to be interpreted as marginal prevalence
under control  and under treatment, respectively, or whether they denote
the prevalence conditional on random effects being 0
(It defaults to the latter). *(experimental!)*</p>
</td></tr>
<tr><td><code id="glsPower_+3A_sigma">sigma</code></td>
<td>
<p>numeric, residual error of cluster means if no N given.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_tau">tau</code></td>
<td>
<p>numeric, standard deviation of random intercepts</p>
</td></tr>
<tr><td><code id="glsPower_+3A_eta">eta</code></td>
<td>
<p>numeric (scalar or matrix), standard deviation of random slopes.
If 'eta' is given as scalar, 'trtMat' is needed as well.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_ar">AR</code></td>
<td>
<p>numeric, vector containing up to three values, each between 0 and 1.
Defaults to NULL. It defines the AR(1)-correlation of random effects.
The first element corresponds to the cluster intercept, the second to the
treatment effect and the third to subject specific intercept.
If only one element is provided, autocorrelation of all random effects is
assumed to be the same.
*Currently not compatible with 'rho'!=0 !*</p>
</td></tr>
<tr><td><code id="glsPower_+3A_rho">rho</code></td>
<td>
<p>numeric (scalar), correlation of 'tau' and 'eta'. The default is no correlation.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_gamma">gamma</code></td>
<td>
<p>numeric (scalar), random time effect</p>
</td></tr>
<tr><td><code id="glsPower_+3A_psi">psi</code></td>
<td>
<p>numeric (scalar), random subject specific intercept.
Leads to a closed cohort setting</p>
</td></tr>
<tr><td><code id="glsPower_+3A_alpha_0_1_2">alpha_0_1_2</code></td>
<td>
<p>numeric vector or list of length 2 or 3, that consists of
alpha_0, alpha_1 and alpha_2. Can be used instead of random effects to define
the correlation structure, following Li et al. (2018). When omitting alpha_2,
this describes a cross-sectional design, where alpha_0 and alpha_1 define
the intracluster correlation and cluster autocorrelation, respectively - as
defined by Hooper et al. (2016).</p>
</td></tr>
<tr><td><code id="glsPower_+3A_covmat">CovMat</code></td>
<td>
<p>numeric, a positive-semidefinite matrix with
(#Clusters <code class="reqn">\cdot</code> timepoints) rows and columns. If 'CovMat' is given,
'sigma', 'tau', 'eta', 'rho', 'gamma' and 'psi' as well as 'alpha_0_1_2'
must be NULL.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_n">N</code></td>
<td>
<p>numeric, number of individuals per cluster. Either a scalar, vector
of length #Clusters or a matrix of dimension #Clusters x timepoints.
Defaults to 1 if not passed.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_power">power</code></td>
<td>
<p>numeric, a specified target power.
If supplied, the minimal 'N' is returned.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_family">family</code></td>
<td>
<p>character, distribution family. One of &quot;gaussian&quot;, &quot;binomial&quot;.
Defaults to &quot;gaussian&quot;</p>
</td></tr>
<tr><td><code id="glsPower_+3A_n_range">N_range</code></td>
<td>
<p>numeric, vector specifying the lower and upper bound for 'N',
ignored if 'power' is NULL.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_sig.level">sig.level</code></td>
<td>
<p>numeric (scalar), significance level, defaults to 0.05</p>
</td></tr>
<tr><td><code id="glsPower_+3A_dfadjust">dfAdjust</code></td>
<td>
<p>character, one of the following: &quot;none&quot;,&quot;between-within&quot;,
&quot;containment&quot;, &quot;residual&quot;.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_indiv_lvl">INDIV_LVL</code></td>
<td>
<p>logical, should the computation be conducted on an
individual level? This leads to longer run time and is
mainly for diagnostic purposes.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_info_content">INFO_CONTENT</code></td>
<td>
<p>logical, should the information content of cluster cells be
computed? The default is 'TRUE' for designs with less or equal than 2500
cluster cells, otherwise 'FALSE'. Ignored if 'verbose=0'.</p>
</td></tr>
<tr><td><code id="glsPower_+3A_verbose">verbose</code></td>
<td>
<p>integer, how much information should the function return?
See also under 'Value'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\theta:= \mu_1-\mu_0</code> the treatment effect under investigation.
The variance of the treatment effect estimator <code class="reqn">\hat\theta</code> can then be
estimated via weighted least squares (see also vignette 'Getting Started').
</p>


<h3>Value</h3>

<p>The return depends on the 'verbose' parameter.
If 'verbose'=0, only the power is returned
If 'verbose'=1 (the default), a list containing power, projection matrix and the
parameters of the specific setting is returned.
If explicitly requested (by 'verbose'=2) this list also contains
the 'DesMat'-object and the covariance matrix.
</p>
<p>If INFO_CONTENT= TRUE, the returned list contains a named list with four elements:
'Cells' is explicit computation of the information content in each cell;
'Cluster' is the information content of entire clusters;
'time' is thie information content of entire time periods and
'Closed' is a formula-based computation the information content in each cell,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See also vignette for more examples
##
##
## stepped wedge design with 5 Clusters in 5 sequences,
## residual standard deviation 2,
## cluster effect sd = 0.33, and 10 individuals per cluster.
## Further, let the mean under the null and alternative hypothesis 0 and 1,
## respectively.
glsPower(mu0=0, mu1=1, Cl=rep(1,5), sigma=2, tau=0.33, N=10)
##
##
## ... with auto-regressive cluster effect `AR=0.7`.
glsPower(mu0=0, mu1=1, Cl=rep(1,5), sigma=2, tau=0.33, AR=0.7, N=10)
##
##
## ... with varying cluster size
glsPower(mu0=0, mu1=1, Cl=rep(1,5), sigma=2, tau=0.33, N=c(12,8,10,9,14))
glsPower(mu0=0, mu1=1, Cl=rep(1,5), sigma=2, tau=0.33,
              N=matrix(c(12,8,10,9,14,
                         11,8,10,9,13,
                         11,7,11,8,12,
                         10,7,10,8,11,
                          9,7, 9,7,11,
                          9,6, 8,7,11),5,6))
##
##
## ... with random treatment effect (with standard deviation 0.2),
## which is correlated with the cluster effect with `rho`=0.25.
glsPower(mu0=0, mu1=1, Cl=rep(1,5), sigma=2, tau=0.33, eta=.2, rho=.25, N=10)
##
##
## ... with missing observations (a.k.a. incomplete stepped wedge design)
glsPower(mu0=0, mu1=1, Cl=rep(1,5), sigma=2, tau=0.33, N=10, incomplete=3)
glsPower(mu0=0, mu1=1, Cl=rep(1,5), sigma=2, tau=0.33, N=10,
             incomplete=matrix(c(1,1,1,0,0,
                                 1,1,1,1,0,
                                 1,1,1,1,1,
                                 1,1,1,1,1,
                                 0,1,1,1,1,
                                 0,0,1,1,1),5,6))
## -&gt; the same.
##
## ... with two levels of clustering. This arises if the patients are
## observed over the whole  study period
## (often referred to as closed cohort design) or if subclusters exist
## (such as wards within clinics). For
mod_aggr  &lt;- glsPower(mu0=0, mu1=1, Cl=rep(1,5),
                          sigma=2, tau=0.33, psi=.25,
                          N=10, incomplete=3, verbose=2)
mod_indiv &lt;- glsPower(mu0=0, mu1=1, Cl=rep(1,5),
                          sigma=2, tau=0.33, psi=.25,
                          N=10, incomplete=3, verbose=2, INDIV_LVL=TRUE)
mod_aggr
mod_indiv
## Compare covariance matrices of first cluster
mod_aggr$CovarianceMatrix[1:6,1:6] ; mod_indiv$CovarianceMatrix[1:60,1:60]
##
##
## stepped wedge design with 5 Clusters in 5 sequences, residual sd = 2,
## cluster effect sd = 0.33. How many Individuals are needed to achieve a
## power of 80% ?
glsPower(mu0=0, mu1=1, Cl=rep(1,5), sigma=2, tau=0.33, power=.8)
##
## ... How many are needed if we have a closed cohort design with a random
## individuum effect of .7?
glsPower(mu0=0, mu1=1, Cl=rep(1,5), sigma=2, tau=0.33, psi=.7, power=.8)
##
##
## longitudinal parallel design, with 5 time periods, 3 clusters in treatment
## and control arm each.
glsPower(mu0=0, mu1=1, Cl=c(3,3), sigma=2, tau=0.33, N=10,
              dsntype="parallel", timepoints=5)
##
##
##
## ... with one baseline period and four parallel periods
glsPower(mu0=0, mu1=1, Cl=c(3,3), sigma=2, tau=0.33, N=10,
              dsntype="parallel_baseline", timepoints=c(1,4))
##
##
##
## cross-over design with two timepoints before and two after the switch
glsPower(mu0=0, mu1=1, Cl=c(3,3), sigma=2, tau=0.33, N=10,
              dsntype="crossover", timepoints=c(2,2))
##
##
##
## stepped wedge design with 32 Individuals in 8 sequences, binomial outcome,
## 50% incidence under control, 25% incidence under interventional treatment.
## cluster effect sd = 0.5 (ICC of 1/3 under control),
## every individual is its own cluster.
## ... with incidences defined conditional on cluster effect=0
glsPower(mu0=0.5, mu1=0.25, Cl=rep(4,8), tau=0.5, N=1,
             family="binomial")
##
##
## ... with  marginally defined proportions
glsPower(mu0=0.5, mu1=0.25, Cl=rep(4,8), tau=0.5, N=1,
              family="binomial", marginal_mu=TRUE)

##
##

</code></pre>

<hr>
<h2 id='plot_CellWeights'>plot cell contributions (weights) of a gls object</h2><span id='topic+plot_CellWeights'></span>

<h3>Description</h3>

<p>plot cell contributions (weights) of a gls object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_CellWeights(
  x,
  annotations = NULL,
  annotation_size = NULL,
  show_colorbar = TRUE,
  marginal_plots = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_CellWeights_+3A_x">x</code></td>
<td>
<p>object of class glsPower</p>
</td></tr>
<tr><td><code id="plot_CellWeights_+3A_annotations">annotations</code></td>
<td>
<p>logical, should the cell contributions be annotated in the Plot?</p>
</td></tr>
<tr><td><code id="plot_CellWeights_+3A_annotation_size">annotation_size</code></td>
<td>
<p>font size of annotation in influence plots</p>
</td></tr>
<tr><td><code id="plot_CellWeights_+3A_show_colorbar">show_colorbar</code></td>
<td>
<p>logical, should the colorbars be shown?</p>
</td></tr>
<tr><td><code id="plot_CellWeights_+3A_marginal_plots">marginal_plots</code></td>
<td>
<p>should the influence of whole periods, clusters also be plotted?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plotly html widget
</p>

<hr>
<h2 id='plot_CovMat'>Visualise a Covariance Matrix</h2><span id='topic+plot_CovMat'></span>

<h3>Description</h3>

<p>Currently not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_CovMat(CovMat, show_colorbar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_CovMat_+3A_covmat">CovMat</code></td>
<td>
<p>A covariance matrix (possibly in sparse matrix notation)</p>
</td></tr>
<tr><td><code id="plot_CovMat_+3A_show_colorbar">show_colorbar</code></td>
<td>
<p>logical, should the colorbar be shown?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plotly object
</p>

<hr>
<h2 id='plot_InfoContent'>plot the information content of a gls object</h2><span id='topic+plot_InfoContent'></span>

<h3>Description</h3>

<p>plot the information content of a gls object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_InfoContent(
  IC,
  annotations = NULL,
  annotation_size = NULL,
  show_colorbar = TRUE,
  marginal_plots = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_InfoContent_+3A_ic">IC</code></td>
<td>
<p>a matrix with information content for each cluster at each time period</p>
</td></tr>
<tr><td><code id="plot_InfoContent_+3A_annotations">annotations</code></td>
<td>
<p>logical, should the cell contributions be annotated in the Plot?</p>
</td></tr>
<tr><td><code id="plot_InfoContent_+3A_annotation_size">annotation_size</code></td>
<td>
<p>font size of annotation in influence plots</p>
</td></tr>
<tr><td><code id="plot_InfoContent_+3A_show_colorbar">show_colorbar</code></td>
<td>
<p>logical, should the colorbars be shown?</p>
</td></tr>
<tr><td><code id="plot_InfoContent_+3A_marginal_plots">marginal_plots</code></td>
<td>
<p>should the influence of whole periods, clusters also be plotted?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plotly object
</p>

<hr>
<h2 id='plot.DesMat'>plot.DesMat</h2><span id='topic+plot.DesMat'></span>

<h3>Description</h3>

<p>plot.DesMat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DesMat'
plot(x, show_colorbar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DesMat_+3A_x">x</code></td>
<td>
<p>An object of class 'DesMat'</p>
</td></tr>
<tr><td><code id="plot.DesMat_+3A_show_colorbar">show_colorbar</code></td>
<td>
<p>logical, should the colorbar be shown?</p>
</td></tr>
<tr><td><code id="plot.DesMat_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plotly html widget, displaying the treatment status
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- construct_DesMat(C=c(2,2,2,0,2,2,2),.5)
</code></pre>

<hr>
<h2 id='plot.glsPower'>plot an object of class 'glsPower'</h2><span id='topic+plot.glsPower'></span>

<h3>Description</h3>

<p>Up to four plots (selectable by 'which') that visualise:
the contribution of each cluster-period cell to the treatment effect estimator,
the information content of each cluster-period cell,
the treatment status for each cluster for each time point and
the covariance matrix. By default, only the first two plots are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glsPower'
plot(
  x,
  which = NULL,
  show_colorbar = NULL,
  annotations = NULL,
  annotation_size = NULL,
  marginal_plots = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.glsPower_+3A_x">x</code></td>
<td>
<p>object of class glsPower</p>
</td></tr>
<tr><td><code id="plot.glsPower_+3A_which">which</code></td>
<td>
<p>Specify a subset of the numbers '1:4' to select plots. The default is
'1:2' or '1', depending on whether 'x' contains the information content.</p>
</td></tr>
<tr><td><code id="plot.glsPower_+3A_show_colorbar">show_colorbar</code></td>
<td>
<p>logical, should the colorbars be shown?</p>
</td></tr>
<tr><td><code id="plot.glsPower_+3A_annotations">annotations</code></td>
<td>
<p>logical, should the cell contributions be annotated in the Plot?</p>
</td></tr>
<tr><td><code id="plot.glsPower_+3A_annotation_size">annotation_size</code></td>
<td>
<p>font size of annotation in influence plots</p>
</td></tr>
<tr><td><code id="plot.glsPower_+3A_marginal_plots">marginal_plots</code></td>
<td>
<p>should the influence of whole periods, clusters also be plotted?</p>
</td></tr>
<tr><td><code id="plot.glsPower_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of plotly html widgets
</p>

<hr>
<h2 id='print.DesMat'>print.DesMat</h2><span id='topic+print.DesMat'></span>

<h3>Description</h3>

<p>print.DesMat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DesMat'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.DesMat_+3A_x">x</code></td>
<td>
<p>An object of class 'DesMat</p>
</td></tr>
<tr><td><code id="print.DesMat_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Messages with information about the design.
</p>

<hr>
<h2 id='print.glsPower'>Print an object of class 'glsPower'</h2><span id='topic+print.glsPower'></span>

<h3>Description</h3>

<p>Print an object of class 'glsPower'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glsPower'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.glsPower_+3A_x">x</code></td>
<td>
<p>object of class glsPower</p>
</td></tr>
<tr><td><code id="print.glsPower_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Messages, containing information about (at least) power and
significance level
</p>

<hr>
<h2 id='RandEff_to_alpha012'>Correlation structure: transform random effects to alpha</h2><span id='topic+RandEff_to_alpha012'></span>

<h3>Description</h3>

<p>Correlation structure: transform random effects to alpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandEff_to_alpha012(sigResid, tau, gamma, psi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RandEff_to_alpha012_+3A_sigresid">sigResid</code></td>
<td>
<p>Residual standard deviation on individual leve</p>
</td></tr>
<tr><td><code id="RandEff_to_alpha012_+3A_tau">tau</code></td>
<td>
<p>standard deviation of random cluster intercept</p>
</td></tr>
<tr><td><code id="RandEff_to_alpha012_+3A_gamma">gamma</code></td>
<td>
<p>standard deviation of random time effect</p>
</td></tr>
<tr><td><code id="RandEff_to_alpha012_+3A_psi">psi</code></td>
<td>
<p>standard deviation of random subject specific intercept</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing four named elements (possibly matrices):
'alpha0', 'alpha1', 'alpha2' specify a correlation structure and SigMarg
denotes the marginal standard deviation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RandEff_to_alpha012(sigResid=sqrt(11), tau=4, gamma=3, psi=2)

## The function is vectorised:
RandEff_to_alpha012(sigResid = matrix(c(0,1,2,3,4,5), 2, 3),
                    tau      = matrix(c(1,1,1,0,0,0), 2, 3),
                    gamma    = matrix(c(0,0,1,0,0,1), 2, 3),
                    psi      = matrix(c(0,1,1,0,0,1), 2, 3))
</code></pre>

<hr>
<h2 id='SteppedPower-pkg'>SteppedPower</h2><span id='topic+SteppedPower-pkg'></span><span id='topic+SteppedPower-package'></span>

<h3>Description</h3>

<p>SteppedPower offers tools for power and sample size
calculation as well as design diagnostics for
longitudinal mixed model settings, with a focus on stepped wedge designs.
All calculations are oracle estimates i.e. assume random effect variances
to be known (or guessed) in advance.
</p>


<h3>Author(s)</h3>

<p>Philipp Mildenberger <a href="mailto:pmildenb@uni-mainz.de">pmildenb@uni-mainz.de</a>
</p>

<hr>
<h2 id='tTestPwr'>Compute Power of a Wald Test</h2><span id='topic+tTestPwr'></span>

<h3>Description</h3>

<p>Computes the power of a scaled Wald test given a standard error,
an effect size, the degrees of freedom of the t-distribution and
a significance level.
Computes the exact power, see second example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tTestPwr(d, se, df, sig.level = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tTestPwr_+3A_d">d</code></td>
<td>
<p>numeric, raw effect</p>
</td></tr>
<tr><td><code id="tTestPwr_+3A_se">se</code></td>
<td>
<p>numeric, standard error</p>
</td></tr>
<tr><td><code id="tTestPwr_+3A_df">df</code></td>
<td>
<p>numeric, degrees of freedom of the t-distribution</p>
</td></tr>
<tr><td><code id="tTestPwr_+3A_sig.level">sig.level</code></td>
<td>
<p>numeric, significance level, defaults to 0.05</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tTestPwr(4,1,10) ; tTestPwr(4,1,30) ; tTestPwr(4,1,Inf)
</code></pre>

<hr>
<h2 id='VarClosed_Kasza'>Closed formula for treatment variance in open cohort settings</h2><span id='topic+VarClosed_Kasza'></span>

<h3>Description</h3>

<p>From Kasza et al &quot;Sample size and power calculations for open cohort
longitudinal cluster rondomized trials&quot; 2020
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarClosed_Kasza(trtMat, tau, gamma = 0, psi = 0, sigma, N, chi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarClosed_Kasza_+3A_trtmat">trtMat</code></td>
<td>
<p>a matrix trtMat to define treatment allocation,
where rows and columns correspond to cluster and timepoints, respectively</p>
</td></tr>
<tr><td><code id="VarClosed_Kasza_+3A_tau">tau</code></td>
<td>
<p>numeric, standard deviation of random intercepts</p>
</td></tr>
<tr><td><code id="VarClosed_Kasza_+3A_gamma">gamma</code></td>
<td>
<p>numeric, random time effect</p>
</td></tr>
<tr><td><code id="VarClosed_Kasza_+3A_psi">psi</code></td>
<td>
<p>numeric, random subject specific intercept.</p>
</td></tr>
<tr><td><code id="VarClosed_Kasza_+3A_sigma">sigma</code></td>
<td>
<p>numeric, residual error on subject level.</p>
</td></tr>
<tr><td><code id="VarClosed_Kasza_+3A_n">N</code></td>
<td>
<p>numeric, number of individuals per cluster.</p>
</td></tr>
<tr><td><code id="VarClosed_Kasza_+3A_chi">chi</code></td>
<td>
<p>Attrition factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, variance of the estimator for treatment effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  test setting, from Hussey&amp;Hughes 2007  ####
trtMat &lt;- construct_DesMat(c(6,6,6,6))$trtMat
tau &lt;- .025 ; sigma &lt;- sqrt(.041*.959) ; N &lt;- 100 ;
gamma &lt;- 0.01 ; psi &lt;- .1 ; chi &lt;- .7

tmp &lt;- VarClosed_Kasza(trtMat, tau=tau, sigma=sigma, gamma=0, psi=0, N=N, chi=0)
tTestPwr((.05-.032), sqrt(tmp), df = Inf)
glsPower(Cl = rep(6,4), N=N, mu0=.05, mu1=.032, verbose=0,
        sigma=sigma, gamma=0, tau=tau, psi=0)

tmp &lt;- VarClosed_Kasza(trtMat, tau=tau, sigma=sigma, gamma=gamma, psi=psi, N=N, chi=0)
tTestPwr((.05-.032), sqrt(tmp), df = Inf)
glsPower(Cl = rep(6,4), N=N, mu0=.05, mu1=.032, verbose=0,
        sigma=sigma, gamma=gamma, tau=tau, psi=psi)

tmp &lt;- VarClosed_Kasza(trtMat, tau=tau, sigma=sigma, gamma=gamma, psi=psi, N=N, chi=1)
tTestPwr((.05-.032), sqrt(tmp), df = Inf)
glsPower(Cl = rep(6,4), N=N, mu0=.05, mu1=.032, verbose=0,
         sigma=sigma, gamma=sqrt(gamma^2+psi^2/N), tau=tau, psi=0)

tmp &lt;- VarClosed_Kasza(trtMat, tau=tau, sigma=sigma, gamma=gamma, psi=psi, N=N, chi=chi)
tTestPwr((.05-.032), sqrt(tmp), df = Inf)
glsPower(Cl = rep(6,4), N=N, mu0=.05, mu1=.032, verbose=0,
         sigma=sigma, gamma=sqrt(gamma^2+chi*psi^2/N), tau=tau, psi=sqrt(1-chi)*psi)
</code></pre>

<hr>
<h2 id='VarClosed_Li'>Closed formula for treatment variance, with proportional decay</h2><span id='topic+VarClosed_Li'></span>

<h3>Description</h3>

<p>From Li et al &quot;Design and analysis considerations for cohort stepped wedge
cluster randomized trials with a decay correlation structure&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarClosed_Li(trtMat, tau, psi, N, AR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarClosed_Li_+3A_trtmat">trtMat</code></td>
<td>
<p>a matrix trtMat to define treatment allocation,
where rows and columns correspond to cluster and timepoints, respectively</p>
</td></tr>
<tr><td><code id="VarClosed_Li_+3A_tau">tau</code></td>
<td>
<p>numeric, standard deviation of random intercepts</p>
</td></tr>
<tr><td><code id="VarClosed_Li_+3A_psi">psi</code></td>
<td>
<p>numeric, random subject specific intercept.</p>
</td></tr>
<tr><td><code id="VarClosed_Li_+3A_n">N</code></td>
<td>
<p>numeric, number of individuals per cluster.</p>
</td></tr>
<tr><td><code id="VarClosed_Li_+3A_ar">AR</code></td>
<td>
<p>numeric (scalar), It defines the AR(1)-correlation of random effects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, variance of the estimator for treatment effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##  test setting, from Hussey&amp;Hughes 2007  ####
trtMat &lt;- construct_DesMat(c(6,6,6,6))$trtMat
tau &lt;- .025 ; N &lt;- 100 ; psi &lt;- .1 ; AR &lt;- .6
tmp &lt;- VarClosed_Li(trtMat, tau=tau, psi=psi, N=N, AR=AR)
tTestPwr((.05-.032), se=sqrt(tmp), Inf)
glsPower(Cl=rep(6,4), mu0=.05, mu1=.032, AR=AR,
         tau=tau, N=N, sigma=0, psi=psi, verbose=0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
