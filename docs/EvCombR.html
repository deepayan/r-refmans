<!DOCTYPE html><html lang="en"><head><title>Help for package EvCombR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EvCombR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EvCombR-package'>
<p>EvCombR - Evidence Combination in R</p></a></li>
<li><a href='#+5B-methods'><p>Methods for Function <code>[</code></p></a></li>
<li><a href='#+5B+5B-methods'><p>Methods for Function <code>[[</code></p></a></li>
<li><a href='#+5B+5B+26lt+3B+26ndash+3Bmethods'><p>Methods for Function <code>[[&lt;-</code></p></a></li>
<li><a href='#+5B+26lt+3B+26ndash+3Bmethods'><p>Methods for Function <code>[&lt;-</code></p></a></li>
<li><a href='#cComb'>
<p>Credal Combination Operator (restricted to intervals)</p></a></li>
<li><a href='#cComb-methods'><p>Methods for Function <code>cComb</code></p></a></li>
<li><a href='#credal'>
<p>Constructor Function for Credal Sets (based on intervals)</p></a></li>
<li><a href='#credal-class'><p>Class <code>"credal"</code></p></a></li>
<li><a href='#credal-methods'><p>Methods for Function <code>credal</code></p></a></li>
<li><a href='#dComb'>
<p>Dempster's Combination Operator</p></a></li>
<li><a href='#dComb-methods'><p>Methods for Function <code>dComb</code></p></a></li>
<li><a href='#disc'>
<p>Discounting Operator</p></a></li>
<li><a href='#disc-methods'><p>Methods for Function <code>disc</code></p></a></li>
<li><a href='#EvCombRLicense'>
<p>License information for EvCombR</p></a></li>
<li><a href='#extPoints'>
<p>Extreme Points of a Credal Set</p></a></li>
<li><a href='#extPoints-methods'><p>Methods for Function <code>extPoints</code></p></a></li>
<li><a href='#focal'>
<p>Focal Elements of a Mass Function</p></a></li>
<li><a href='#focal-methods'><p>Methods for Function <code>focal</code></p></a></li>
<li><a href='#focal+26lt+3B-'>
<p>Replacement Function for Focal Elements</p></a></li>
<li><a href='#focal+26lt+3B+26ndash+3Bmethods'><p>Methods for Function <code>focal&lt;-</code></p></a></li>
<li><a href='#lower'>
<p>Lower Bounds Based on Evidence Structure</p></a></li>
<li><a href='#lower-methods'><p>Methods for Function <code>lower</code></p></a></li>
<li><a href='#mass'>
<p>Constructor Function for Mass Functions</p></a></li>
<li><a href='#mass-class'><p>Class <code>"mass"</code></p></a></li>
<li><a href='#mass-methods'><p>Methods for Function <code>mass</code></p></a></li>
<li><a href='#massQ-class'><p>Class <code>"massQ"</code></p></a></li>
<li><a href='#mComb'>
<p>Modified Dempster's Combination Operator</p></a></li>
<li><a href='#mComb-methods'><p>Methods for Function <code>mComb</code></p></a></li>
<li><a href='#pign'>
<p>Pignistic Tranformation</p></a></li>
<li><a href='#pign-methods'><p>Methods for Function <code>pign</code></p></a></li>
<li><a href='#relPl'>
<p>Relative Plausibility Transform</p></a></li>
<li><a href='#relPl-methods'><p>Methods for Function <code>relPl</code></p></a></li>
<li><a href='#space'>
<p>State Space of and Evidence Structure</p></a></li>
<li><a href='#space-methods'><p>Methods for Function <code>space</code></p></a></li>
<li><a href='#space+26lt+3B-'>
<p>Replacement Function for State Space</p></a></li>
<li><a href='#space+26lt+3B+26ndash+3Bmethods'><p>Methods for Function <code>space&lt;-</code></p></a></li>
<li><a href='#upper'>
<p>Upper Bounds Based on Evidence Structure</p></a></li>
<li><a href='#upper-methods'><p>Methods for Function <code>upper</code></p></a></li>
<li><a href='#yComb'>
<p>Yager's Combination Operator</p></a></li>
<li><a href='#yComb-methods'><p>Methods for Function <code>yComb</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Evidence Combination in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Karlsson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Karlsson &lt;alexander.karlsson@his.se&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Alexander Karlsson</td>
</tr>
<tr>
<td>Description:</td>
<td>Combine pieces of evidence in the form of uncertainty representations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-21 07:10:02 UTC; karx</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-25 10:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='EvCombR-package'>
EvCombR - Evidence Combination in R
</h2><span id='topic+EvCombR-package'></span><span id='topic+EvCombR'></span>

<h3>Description</h3>

<p>Package for combining pieces of evidence. 
</p>


<h3>Details</h3>

<p>Implements Dempster's, Yager's, modified Dempster's, Bayesian, and credal combination (based on intervals). 
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>
<p>Maintainer: Alexander Karlsson &lt;alexander.karlsson@his.se&gt;
</p>


<h3>References</h3>

<p>Dempster, A. P. (1969), A generalization of Bayesian inference, <em>Journal of the Royal Statistical Society</em>, <b>30</b>, 205-247
</p>
<p>Shafer, G. (1976), A Mathematical Theory of Evidence Princeton University Press  
</p>
<p>Yager, R. (1987), On the Dempster-Shafer Framework and New Combination Rules,
<em>Information Sciences 41: 93-137</em>.
</p>
<p>Fixsen, D., Mahler, R. P. S. (1997), The modified Dempster-Shafer approach to classification, <em>IEEE Transactions on Systems, Man and Cybernetics, Part A: Systems and Humans</em>, <b>27</b>, 96-104
</p>
<p>Arnborg, S. (2006), Robust Bayesianism: Relation to Evidence Theory, <em>Journal of Advances in Information Fusion</em>, <b>1</b>, 63-74
</p>
<p>Karlsson, A., Johansson, R., and Andler, S. F. (2011), Characterization and Empirical Evaluation of Bayesian and Credal Combination Operators, <em>Journal of Advances in Information Fusion</em>, <b>6</b>, 150-166
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a state space
stateSpace &lt;- c("a", "b", "c")

# construct credal sets with the given state space
c1 &lt;- credal(c(0.1, 0.1, 0.1), c(0.8, 0.8, 0.8), stateSpace)
c2 &lt;- credal(c(0.2, 0.2, 0.2), c(0.9, 0.9, 0.9), stateSpace)

# combine the credal sets
cComb(c1, c2)

# construct mass functions
m1 &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)
m2 &lt;- mass(list("a"=0.2, "b"=0.2, "c"=0.2, "a/b/c"=0.4), stateSpace)

# combine the mass functin by using Dempster's combination
dComb(m1, m2)

# Yager's combination operator
yComb(m1, m2)

# modified Dempster's combination using uniform prior
mComb(m1, m2)

</code></pre>

<hr>
<h2 id='+5B-methods'>Methods for Function <code>[</code></h2><span id='topic++5B-methods'></span><span id='topic++5B+2Ccredal+2CANY+2CANY-method'></span><span id='topic++5B+2Cmass+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Extract part of evidence structure <code>[</code> 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "credal", i = "ANY", j="ANY", value="ANY")</code></dt><dd>
<p>Extract probabilities
</p>
</dd>
<dt><code>signature(x = "mass", i = "character", j="missing", value="ANY")</code></dt><dd>
<p>Extract focal element(s)
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alexander Karlsson</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a state space
stateSpace &lt;- c("a", "b", "c")

# construct credal sets with the given state space
c &lt;- credal(c(0.1, 0.1, 0.1), c(0.8, 0.8, 0.8), stateSpace) 

# extract first and second extreme point
c[1:2,]

# mass functions 
m &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)  

# extract focal elements
m[c("a","a/b/c")]
</code></pre>

<hr>
<h2 id='+5B+5B-methods'>Methods for Function <code>[[</code></h2><span id='topic++5B+5B-methods'></span><span id='topic++5B+5B+2Cmass+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for function <code>[[</code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x="mass", i="character", j="missing")</code></dt><dd>
<p>Extract a single focal element from the list of focal elements
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alexander Karlsson</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a state space
stateSpace &lt;- c("a", "b", "c")

#mass functions 
m &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)  

# extract focal element
m[["a"]]
</code></pre>

<hr>
<h2 id='+5B+5B+26lt+3B+26ndash+3Bmethods'>Methods for Function <code>[[&lt;-</code></h2><span id='topic++5B+5B+3C--methods'></span><span id='topic++5B+5B+3C-+2Cmass+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Replace part of an evidence structure
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x="mass", i="character", j="missing", value="ANY")</code></dt><dd>
<p>Replace focal element(s)
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alexander Karlsson</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a state space
stateSpace &lt;- c("a", "b", "c")

# mass function 
m &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)  

# obtain value only
m[["a"]]

</code></pre>

<hr>
<h2 id='+5B+26lt+3B+26ndash+3Bmethods'>Methods for Function <code>[&lt;-</code></h2><span id='topic++5B+3C--methods'></span><span id='topic++5B+3C-+2Ccredal+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2Cmass+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Replace part of an evidence structure
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x="credal", i="ANY", j="ANY", value="ANY")</code></dt><dd>
<p>Replace probabilities
</p>
</dd>
<dt><code>signature(x="mass", i="character", j="missing", value="ANY")</code></dt><dd>
<p>Replace focal element(s)
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alexander Karlsson</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a state space
stateSpace &lt;- c("a", "b", "c")

# construct credal sets with the given state space
c &lt;- credal(c(0.1, 0.1, 0.1), c(0.8, 0.8, 0.8), stateSpace) 

# replace first and second extreme point
c[1:2,] &lt;- rbind(c(0.1, 0.1, 0.8), c(0.2, 0.2, 0.6))

# mass function 
m &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)  

# switch mass on focal elements "b" and "a/b/c" 
temp &lt;- m["b"]
m["b"] &lt;- m["a/b/c"]
m["a/b/c"] &lt;- temp

</code></pre>

<hr>
<h2 id='cComb'>
Credal Combination Operator (restricted to intervals) 
</h2><span id='topic+cComb'></span>

<h3>Description</h3>

<p>Combine evidence in the form of credal sets (based on intervals) using the credal combination operator (also known as the robust Bayesian combination operator). The resulting credal set is approximated by using probability intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cComb(x,y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cComb_+3A_x">x</code></td>
<td>
 
<p>credal set or a list of credal sets  
</p>
</td></tr>
<tr><td><code id="cComb_+3A_y">y</code></td>
<td>
 
<p>credal set if <code>x</code> is a credal set, otherwise missing
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>credal set   
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Levi, I. (1983), The enterprise of knowledge, The MIT press
</p>
<p>Arnborg, S. (2006), Robust Bayesianism: Relation to Evidence Theory, <em>Journal of Advances in Information Fusion</em>, <b>1</b>, 63-74
</p>
<p>Karlsson, A., Johansson, R., and Andler, S. F. (2011), Characterization and Empirical Evaluation of Bayesian and Credal Combination Operators, <em>Journal of Advances in Information Fusion</em>, <b>6</b>, 150-166
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dComb">dComb</a>, <a href="#topic+yComb">yComb</a>, <a href="#topic+mComb">mComb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a state space
stateSpace &lt;- c("a", "b", "c")

# construct credal sets with the given state space
c1 &lt;- credal(c(0.1, 0.1, 0.1), c(0.8, 0.8, 0.8), stateSpace)
c2 &lt;- credal(c(0.2, 0.2, 0.2), c(0.9, 0.9, 0.9), stateSpace)

# combine the credal sets
cComb(c1, c2)
# or by
cComb(list(c1, c2))

</code></pre>

<hr>
<h2 id='cComb-methods'>Methods for Function <code>cComb</code></h2><span id='topic+cComb+2Ccredal+2Ccredal-method'></span><span id='topic+cComb+2Clist+2Cmissing-method'></span>

<h3>Description</h3>

<p>Combine credal sets (based on intervals) using the credal combination operator (also known as the robust Bayesian combination operator). For more detail see <code><a href="#topic+cComb">cComb</a></code>.     
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "credal", y = "credal")</code></dt><dd>
<p>Combine two credal sets using the credal combination operator
</p>
</dd>
<dt><code>signature(x = "list", y = "missing")</code></dt><dd>
<p>Combine a list of credal sets using the credal combination operator
</p>
</dd>
</dl>

<hr>
<h2 id='credal'>
Constructor Function for Credal Sets (based on intervals)
</h2><span id='topic+credal'></span>

<h3>Description</h3>

<p>Construct a credal set based on probability intervals or a single probability function. The algorithm used for finding the 
extreme points corresponding to lower and upper bounds is described in De Campos et al. (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>credal(x, y, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="credal_+3A_x">x</code></td>
<td>

<p>lower bounds of probability intervals (in the form of a numeric vector)
</p>
</td></tr>
<tr><td><code id="credal_+3A_y">y</code></td>
<td>

<p>upper bounds for probability intervals or missing (i.e., upper bound of <code>1</code>)
</p>
</td></tr>
<tr><td><code id="credal_+3A_z">z</code></td>
<td>

<p>character vector representing the state space 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A credal set represented by a set of extreme points.
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Levi, I. (1983), The enterprise of knowledge, The MIT press
</p>
<p>Arnborg, S. (2006), Robust Bayesianism: Relation to Evidence Theory, <em>Journal of Advances in Information Fusion</em>, <b>1</b>, 63-74
</p>
<p>Karlsson, A., Johansson, R., Andler, S. F. (2011), Characterization and Empirical Evaluation of Bayesian and Credal Combination Operators, <em>Journal of Advances in Information Fusion</em>, <b>6</b>, 150-166
</p>
<p>De Campos L. M., Huete, J. F., Moral S., Probability Intervals: a Tool for Uncertain Reasoning,<em>International Journal of Uncertainty, Fuzziness, and Knowledge-Based Systems</em>, <b>2</b>, 167-196
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cComb">cComb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# lower and upper bounds for probability intervals
c1 &lt;- credal(c(0.1, 0.1, 0.1), c(0.8, 0.8, 0.8), stateSpace)

# single probability function (lower and upper bounds of probability intervals are equal)
c2 &lt;- credal(c(0.1, 0.2, 0.7), c(0.1, 0.2, 0.7), stateSpace)

</code></pre>

<hr>
<h2 id='credal-class'>Class <code>"credal"</code></h2><span id='topic+credal-class'></span>

<h3>Description</h3>

<p>Represents a credal set by a set of extreme points. For more detail see <code><a href="#topic+credal">credal</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+credal">credal</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>extPoints</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Each row is an extreme point of the credal set.</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x="credal", i="ANY", j="ANY")</code>: extract an extreme point</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x="credal", i="ANY", j="ANY", value="ANY")</code>: replace and extreme point</p>
</dd>
<dt>cComb</dt><dd><p><code>signature(x = "credal", y = "credal")</code>: combine two credal sets </p>
</dd>
<dt>lower</dt><dd><p><code>signature(x = "credal", set = "character")</code>: calculate the lower bound for a specific set of states </p>
</dd>
<dt>lower</dt><dd><p><code>signature(x = "credal", set = "missing")</code>: calculate the lower bounds for all singleton states</p>
</dd>
<dt>upper</dt><dd><p><code>signature(x = "credal", set = "character")</code>: calculate the upper bound for a specific set of states  </p>
</dd>
<dt>upper</dt><dd><p><code>signature(x = "credal", set = "missing")</code>: calculate the upper bounds for all singleton states</p>
</dd>
<dt>extPoints</dt><dd><p><code>signature(x = "credal")</code>: access method for the slot points</p>
</dd>
<dt>space</dt><dd><p><code>signature(x = "credal")</code>: access method for names of singleton states</p>
</dd>
<dt>space&lt;-</dt><dd><p><code>signature(x = "credal")</code>: replace method for names of singleton states</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>

<hr>
<h2 id='credal-methods'>Methods for Function <code>credal</code></h2><span id='topic+credal-methods'></span><span id='topic+credal+2Cmatrix+2Ccharacter+2Cmissing-method'></span><span id='topic+credal+2Cnumeric+2Cmissing+2Ccharacter-method'></span><span id='topic+credal+2Cnumeric+2Cnumeric+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Methods for constructing a credal set. For more detail see <code><a href="#topic+credal">credal</a></code>. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "numeric", y = "missing", z = "character")</code></dt><dd>
<p>Construct a credal set based on the lower bounds of probability intervals for states (<code>1</code> will be the upper bound for all probability intervals)
</p>
</dd>
<dt><code>signature(x = "numeric", y = "numeric", z = "character")</code></dt><dd>
<p>Construct a credal based on probability intervals for states
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>

<hr>
<h2 id='dComb'>
Dempster's Combination Operator
</h2><span id='topic+dComb'></span>

<h3>Description</h3>

<p>Combine evidence in the form of mass functions using Dempster's combination operator. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dComb(x,y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dComb_+3A_x">x</code></td>
<td>

<p>single mass function or a list of mass functions
</p>
</td></tr>
<tr><td><code id="dComb_+3A_y">y</code></td>
<td>

<p>single mass function if <code>x</code> is a single mass function, otherwise missing    
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mass function
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Dempster, A. P. (1969), A generalization of Bayesian inference, 
<em>Journal of the Royal Statistical Society</em>, <b>30</b>, 205-247
</p>
<p>Shafer, G. (1976), A Mathematical Theory of Evidence Princeton University Press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+yComb">yComb</a>, <a href="#topic+mComb">mComb</a>, <a href="#topic+cComb">cComb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass functions 
m1 &lt;- mass(list("a"=0.1, "a/b/c"=0.9), stateSpace)
m2 &lt;- mass(list("a"=0.2, "a/b/c"=0.8), stateSpace)

# Dempster's combination
dComb(m1, m2)
# or 
dComb(list(m1, m2))
</code></pre>

<hr>
<h2 id='dComb-methods'>Methods for Function <code>dComb</code></h2><span id='topic+dComb-methods'></span><span id='topic+dComb+2Cmass+2Cmass-method'></span><span id='topic+dComb+2Clist+2Cmissing-method'></span>

<h3>Description</h3>

<p>Combine mass functions using Dempster's combination operator. For more detail
see <code><a href="#topic+dComb">dComb</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "mass", y = "mass")</code></dt><dd>
<p>Combine two mass functions using Dempster's combination operator
</p>
</dd> 
<dt><code>signature(x = "list", y = "missing")</code></dt><dd>
<p>Combine a list of mass functions using Dempster's combination operator
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alexander Karlsson</p>

<hr>
<h2 id='disc'>
Discounting Operator
</h2><span id='topic+disc'></span>

<h3>Description</h3>

<p>Discounts a mass function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disc(x,y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disc_+3A_x">x</code></td>
<td>

<p>a mass function
</p>
</td></tr>
<tr><td><code id="disc_+3A_y">y</code></td>
<td>

<p>degree of reliability
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mass function
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Smets, P. (2000), Data Fusion in the Transferable Belief Model, Proceedings of the Third International Conference on Information Fusion  
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass function 
m &lt;- mass(list("a"=0.1, "a/b/c"=0.9), stateSpace)

# source is only 80% reliable
mDisc &lt;- disc(m, 0.8)
</code></pre>

<hr>
<h2 id='disc-methods'>Methods for Function <code>disc</code></h2><span id='topic+disc-methods'></span><span id='topic+disc+2Cmass+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Discount an evidence structure. For more detail see <code><a href="#topic+disc">disc</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "mass", y = "numeric")</code></dt><dd>
<p>Discount a mass function.
</p>
</dd>
</dl>

<hr>
<h2 id='EvCombRLicense'>
License information for EvCombR
</h2><span id='topic+EvCombRLicense'></span>

<h3>Description</h3>

<p>Displays some license information about EvCombR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvCombRLicense()
</code></pre>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>EvCombRLicense()
</code></pre>

<hr>
<h2 id='extPoints'>
Extreme Points of a Credal Set
</h2><span id='topic+extPoints'></span>

<h3>Description</h3>

<p>Returns the extreme points of a credal set 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extPoints(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extPoints_+3A_x">x</code></td>
<td>

<p>a credal set
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix where the extreme points are stored by row
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lower">lower</a></code>, <code><a href="#topic+upper">upper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# construct credal set
c &lt;- credal(c(0.1, 0.1, 0.1), c(0.8, 0.8, 0.8), stateSpace)

# obtain extrem points
eMat &lt;- extPoints(c)

</code></pre>

<hr>
<h2 id='extPoints-methods'>Methods for Function <code>extPoints</code></h2><span id='topic+extPoints-methods'></span><span id='topic+extPoints+2Ccredal-method'></span>

<h3>Description</h3>

<p>Returns the set of extreme points of a credal set. For more detail see <code><a href="#topic+extPoints">extPoints</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "credal")</code></dt><dd>
<p>Returns the set of extreme points
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>

<hr>
<h2 id='focal'>
Focal Elements of a Mass Function
</h2><span id='topic+focal'></span>

<h3>Description</h3>

<p>Returns the set of focal elements of a mass function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focal(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="focal_+3A_x">x</code></td>
<td>

<p>a mass function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>focal elements of <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Dempster, A. P. (1969), A generalization of Bayesian inference, <em>Journal of the Royal Statistical Society</em>, <b>30</b>, 205-247
</p>
<p>Shafer, G., (1976), A Mathematical Theory of Evidence Princeton University Press, 1976
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+points">points</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass functions 
m &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)

# obtain focal elements
focal(m)
</code></pre>

<hr>
<h2 id='focal-methods'>Methods for Function <code>focal</code></h2><span id='topic+focal-methods'></span><span id='topic+focal+2Cmass-method'></span>

<h3>Description</h3>

<p>Methods for function <code>focal</code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "mass")</code></dt><dd>
<p>Access function for slot focal 
</p>
</dd>
</dl>


<h3>Note</h3>

<p>See further <code><a href="#topic+focal">focal</a></code></p>

<hr>
<h2 id='focal+26lt+3B-'>
Replacement Function for Focal Elements
</h2><span id='topic+focal+3C-'></span>

<h3>Description</h3>

<p>Replaces focal elements of a mass function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focal(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="focal+2B26lt+2B3B-_+3A_x">x</code></td>
<td>

<p>a mass function
</p>
</td></tr>
<tr><td><code id="focal+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>new focal elements for the mass function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mass function with focal elements replaced.
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Dempster, A. P. (1969), A generalization of Bayesian inference, <em>Journal of the Royal Statistical Society</em>, <b>30</b>, 205-247
</p>
<p>Shafer, G., (1976), A Mathematical Theory of Evidence Princeton University Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass functions 
m &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)

# replace focal elements
focal(m) &lt;- list("a/b"=1)
</code></pre>

<hr>
<h2 id='focal+26lt+3B+26ndash+3Bmethods'>Methods for Function <code>focal&lt;-</code></h2><span id='topic+focal+3C--methods'></span><span id='topic+focal+3C-+2Cmass+2Clist-method'></span>

<h3>Description</h3>

<p>Replacement function for focal elements. For more detail see <code><a href="#topic+focal+3C-">focal&lt;-</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "mass")</code></dt><dd>
<p>Replace focal elements
</p>
</dd>
</dl>

<hr>
<h2 id='lower'>
Lower Bounds Based on Evidence Structure
</h2><span id='topic+lower'></span>

<h3>Description</h3>

<p>Calculate the lower bounds for a vector of sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lower(x, sets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lower_+3A_x">x</code></td>
<td>

<p>credal set or mass function
</p>
</td></tr>
<tr><td><code id="lower_+3A_sets">sets</code></td>
<td>

<p>vector of sets where each set is represented by state names separated by &quot;/&quot;. If sets are missing, lower bounds on singletons are calculated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lower bound of mass or probability for each set in the vector sets or if sets is missing lower bounds on singletons
</p>


<h3>Note</h3>

<p>This is equivalent to belief in Dempster-Shafer theory
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Shafer, G., (1976), A Mathematical Theory of Evidence Princeton University Press
</p>
<p>Walley, P. (2000), Towards a unified theory of imprecise probability, <em>International Journal of Approximate Reasoning, <b>24</b>, 125-148
</em></p>


<h3>See Also</h3>

<p><code><a href="#topic+upper">upper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass function
m &lt;- mass(list("a"=0.1, "b"=0.1 , 
               "c"=0.4, "a/b/c"=0.4), stateSpace)

# credal set
c &lt;- credal(c(0.1, 0.1, 0.1), 
            c(0.8, 0.8, 0.8), stateSpace)

# calculate lower bounds
lower(m, c("a", "a/b"))
lower(c, c("a", "a/b"))

# lower bounds on singletons
lower(m)

</code></pre>

<hr>
<h2 id='lower-methods'>Methods for Function <code>lower</code></h2><span id='topic+lower-methods'></span><span id='topic+lower+2Ccredal+2Cmissing-method'></span><span id='topic+lower+2Cmass+2Cmissing-method'></span><span id='topic+lower+2Ccredal+2Ccharacter-method'></span><span id='topic+lower+2Cmass+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Calculate lower bounds for a vector of sets with respect to the evidence structure. For more detail see <code><a href="#topic+lower">lower</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "credal", sets = "character")</code></dt><dd>
<p>obtain lower bounds for a vector of sets
</p>
</dd>
<dt><code>signature(x = "credal", sets = "missing")</code></dt><dd>
<p>obtain lower bounds for all singleton states
</p>
</dd>
<dt><code>signature(x = "mass", sets = "character")</code></dt><dd>
<p>obtain the belief, or lower bounds, for a vector of sets
</p>
</dd>
<dt><code>signature(x = "mass", sets = "missing")</code></dt><dd>
<p>obtain the belief, or lower bounds, for all singleton states
</p>
</dd>
</dl>

<hr>
<h2 id='mass'>
Constructor Function for Mass Functions
</h2><span id='topic+mass'></span>

<h3>Description</h3>

<p>Construct a mass function based on a named list of focal elements or a <code><a href="#topic+massQ-class">massQ-class</a></code> object. For more information, see the details section. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mass_+3A_x">x</code></td>
<td>

<p>a named list of focal elements or a <code><a href="#topic+massQ-class">massQ-class</a></code> object            
</p>
</td></tr>
<tr><td><code id="mass_+3A_y">y</code></td>
<td>

<p>a character vector representing the state space or missing if <code>x</code> is an <code>massQ</code> object. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Focal elements are represented by the notation &quot;&lt;<em>s1</em>&gt;/.../&lt;<em>sn</em>&gt;&quot; where &lt;<em>s1</em>&gt;...&lt;<em>sn</em>&gt; are any states within the state space (see the examples below). Note that the word &quot;ES&quot; and the symbol &quot;/&quot; are reserved.
</p>


<h3>Value</h3>

<p>mass function
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Dempster, A. P. (1969), A generalization of Bayesian inference, 
<em>Journal of the Royal Statistical Society</em>, <b>30</b>, 205-247
</p>
<p>Shafer, G. (1976), A Mathematical Theory of Evidence Princeton University Press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dComb">dComb</a>, <a href="#topic+mComb">mComb</a>, <a href="#topic+yComb">yComb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# construct mass functions 
m1 &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)
m2 &lt;- mass(list("a"=0.1, "b"=0.1, "c"=0.1, "a/b"=0.1, "a/c"=0.1, 
                "b/c"=0.1, "a/b/c"=0.4), stateSpace)

# apply Yager's combination operator, m12 will be a massQ-object 
m12Q &lt;- yComb(m1,m2)

# contruct a mass function from an massQ-object
m12 &lt;- mass(m12Q)

</code></pre>

<hr>
<h2 id='mass-class'>Class <code>"mass"</code></h2><span id='topic+mass-class'></span>

<h3>Description</h3>

<p>Represents a mass function by a list of focal elements and corresponding mass. For more detail see <code><a href="#topic+mass">mass</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by <code><a href="#topic+credal">credal</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>focal</code>:</dt><dd><p>a list of focal elements represented by statenames seperated by &quot;/&quot;</p>
</dd>
<dt><code>space</code>:</dt><dd><p>the state space represented by a character vector</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "mass", i = "character", j = "missing")</code>: extract focal elements</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "mass", i = "character", j = "missing")</code>: extract a single focal element</p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x="mass", i="character", j="missing", value="ANY")</code>: replace focal elements</p>
</dd>    
<dt>[[&lt;-</dt><dd><p><code>signature(x="mass", i="character", j="missing", value="ANY")</code>: replace a single focal element</p>
</dd>
<dt>dComb</dt><dd><p><code>signature(x = "mass", y = "mass")</code>: combine two mass functions by Dempster's combination</p>
</dd>
<dt>focal</dt><dd><p><code>signature(x = "mass")</code>: access focal elements</p>
</dd>
<dt>focal&lt;-</dt><dd><p><code>signature(x = "mass")</code>: replace focal elements </p>
</dd>
<dt>lower</dt><dd><p><code>signature(x = "mass", set = "character")</code>: calculate the lower bounds for some focal element</p>
</dd>
<dt>lower</dt><dd><p><code>signature(x = "mass", set = "missing")</code>: calculate the lower bounds for singletons</p>
</dd>   
<dt>mComb</dt><dd><p><code>signature(x = "mass", y = "mass", z = "function")</code>: combine two mass functions by modified Dempster's combination using a prior distribution z </p>
</dd>
<dt>mComb</dt><dd><p><code>signature(x = "mass", y = "mass", z = "missing")</code>: combine two mass functions by modified Dempster's combination using a uniform prior distribution z</p>
</dd>
<dt>pign</dt><dd><p><code>signature(x = "mass")</code>: calculate the pignistic transformation for single states</p>
</dd>
<dt>relPl</dt><dd><p><code>signature(x = "mass")</code>: calculate the relative plausibility for single states</p>
</dd>
<dt>space</dt><dd><p><code>signature(x = "mass")</code>: access the state space (frame of discernment)</p>
</dd>
<dt>space&lt;-</dt><dd><p><code>signature(x = "mass")</code>: replace the state space (frame of discernment)</p>
</dd>
<dt>upper</dt><dd><p><code>signature(x = "mass", set = "character")</code>: calculate the upper bound for some focal element </p>
</dd>
<dt>upper</dt><dd><p><code>signature(x = "mass", set = "character")</code>: calculate the upper bounds for singletons</p>
</dd>    
<dt>yComb</dt><dd><p><code>signature(x = "mass", y = "mass")</code>: combine two mass functions using Yager's rule</p>
</dd>
<dt>disc</dt><dd><p><code>signature(x = "mass", y = "numeric")</code>: discount mass function</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Dempster, A. P. (1969), A generalization of Bayesian inference, <em>Journal of the Royal Statistical Society</em>, <b>30</b>, 205-247
</p>
<p>Shafer, G., (1976), A Mathematical Theory of Evidence Princeton University Press
</p>
<p>Yager, R. (1987), On the Dempster-Shafer Framework and New Combination Rules,
<em>Information Sciences 41: 93-137</em>.     
</p>
<p>Fixsen, D., Mahler, R. P. S. (1997), The modified Dempster-Shafer approach to classification, <em>IEEE Transactions on Systems, Man and Cybernetics, Part A: Systems and Humans</em>, <b>27</b>, 96-104   
</p>

<hr>
<h2 id='mass-methods'>Methods for Function <code>mass</code></h2><span id='topic+mass-methods'></span><span id='topic+mass+2Clist+2Ccharacter-method'></span><span id='topic+mass+2CmassQ+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for constructing a mass function. For more detail see <code><a href="#topic+mass">mass</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "list", y = "character")</code></dt><dd>
<p>Construct a mass functions by a named list of focal elements and a given state space
</p>
</dd>
<dt><code>signature(x = "massQ", y = "missing")</code></dt><dd>
<p>Construct a mass function from a <code><a href="#topic+massQ-class">massQ-class</a></code> object
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>

<hr>
<h2 id='massQ-class'>Class <code>"massQ"</code></h2><span id='topic+massQ-class'></span>

<h3>Description</h3>

<p>Class that maintains information about the mass on the empty set. The class is used for Yager's combination operator 
</p>


<h3>Objects from the Class</h3>

<p>A <code>massQ</code>-object is obtained as a result of Yager's combination operator <code><a href="#topic+yComb">yComb</a></code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>qEmpty</code>:</dt><dd><p>mass on the empty set with respect to the previous combination</p>
</dd>
<dt><code>focal</code>:</dt><dd><p>a list of focal elements represented by statenames seperated by &quot;/&quot;</p>
</dd>
<dt><code>space</code>:</dt><dd><p>the state space represented by a character vector</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+mass-class">mass</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>All methods inherited from <code><a href="#topic+mass-class">mass-class</a></code> and in addition:
</p>

<dl>
<dt>mass</dt><dd><p><code>signature(x = "massQ", y = "missing")</code>: convert the <code>massQ</code>-object to a <code>mass</code>-object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Yager, R. (1987), On the Dempster-Shafer Framework and New Combination Rules,
<em>Information Sciences 41: 93-137</em>.     
</p>

<hr>
<h2 id='mComb'>
Modified Dempster's Combination Operator
</h2><span id='topic+mComb'></span>

<h3>Description</h3>

<p>Combine evidence in the form of mass functions using modified Dempster's combination operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mComb(x,y,z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mComb_+3A_x">x</code></td>
<td>

<p>single mass function or a list of mass functions    
</p>
</td></tr>
<tr><td><code id="mComb_+3A_y">y</code></td>
<td>

<p>single mass function if <code>x</code> is a single mass function, a prior distribution  or missing if <code>x</code> is a list 
</p>
</td></tr>
<tr><td><code id="mComb_+3A_z">z</code></td>
<td>

<p>prior distribution if <code>x</code> and <code>y</code> are mass functions, otherwise missing
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prior distribution is provided in the form of a list where the names are equivalent to the state space. See the examples.
</p>


<h3>Value</h3>

<p>mass function
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Fixsen, D., Mahler, R. P. S. (1997), The modified Dempster-Shafer approach to classification, <em>IEEE Transactions on Systems, Man and Cybernetics, Part A: Systems and Humans</em>, <b>27</b>, 96-104
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dComb">dComb</a>, <a href="#topic+yComb">yComb</a>, <a href="#topic+cComb">cComb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass functions 
m1 &lt;- mass(list("a"=0.1, "a/b/c"=0.9), stateSpace)
m2 &lt;- mass(list("a"=0.2, "a/b/c"=0.8), stateSpace)

# modified Dempster's combination using the uniform prior
mComb(m1, m2)
# or 
mComb(list(m1, m2))     

# modified Dempster's combination using a specific prior
mComb(m1, m2, list("a"=0.1, "b"=0.1, "c"=0.8))
# or 
mComb(list(m1, m2), list("a"=0.1, "b"=0.1, "c"=0.8)) 
</code></pre>

<hr>
<h2 id='mComb-methods'>Methods for Function <code>mComb</code></h2><span id='topic+mComb-methods'></span><span id='topic+mComb+2Clist+2Clist+2Cmissing-method'></span><span id='topic+mComb+2Clist+2Cmissing+2Cmissing-method'></span><span id='topic+mComb+2Cmass+2Cmass+2Clist-method'></span><span id='topic+mComb+2Cmass+2Cmass+2Cmissing-method'></span>

<h3>Description</h3>

<p>Combine mass functions using modified Dempster's combination operator. For more detail
see <code><a href="#topic+mComb">mComb</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "mass", y = "mass", z = "list")</code></dt><dd>
<p>Combine two mass functions using modified Dempster's combination operator and a prior    
</p>
</dd> 
<dt><code>signature(x = "mass", y = "mass", z = "missing")</code></dt><dd>
<p>Combine two mass functions using modified Dempster's combination operator and the uniform prior
</p>
</dd> 
<dt><code>signature(x = "list", y = "list", z = "missing")</code></dt><dd>
<p>Combine a list of mass functions using modified Dempster's combination operator and a prior      
</p>
</dd>
<dt><code>signature(x = "list", y = "missing", z = "missing")</code></dt><dd>
<p>Combine a list of mass functions using modified Dempster's combination operator and the uniform prior
</p>
</dd>
</dl>

<hr>
<h2 id='pign'>
Pignistic Tranformation
</h2><span id='topic+pign'></span>

<h3>Description</h3>

<p>The pignistic transformation transforms a mass function into a probability function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pign(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pign_+3A_x">x</code></td>
<td>

<p>a mass function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a singleton credal set
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Smets, P. &amp; Kennes, R. (1994), The transferable belief model, <em>Artificial Intelligence</em>, <b>66</b>, 191-234
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relPl">relPl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass function 
m &lt;- mass(list("a"=0.1, "a/b/c"=0.9), stateSpace)

# obtaina singleton credal set
c &lt;- pign(m)

</code></pre>

<hr>
<h2 id='pign-methods'>Methods for Function <code>pign</code></h2><span id='topic+pign-methods'></span><span id='topic+pign+2Cmass-method'></span>

<h3>Description</h3>

<p>The pignistic transformation transform a mass function to probability function. For more detail see <code><a href="#topic+pign">pign</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "mass")</code></dt><dd>
<p>Apply the pignistic transformation on a mass function
</p>
</dd>
</dl>

<hr>
<h2 id='relPl'>
Relative Plausibility Transform
</h2><span id='topic+relPl'></span>

<h3>Description</h3>

<p>The relative plausibility transform transform a mass function to a probability function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relPl(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relPl_+3A_x">x</code></td>
<td>

<p>a mass function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a singleton credal set
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Cobb, B. &amp; Shenoy, P. (2006), On the plausibility transformation for translating belief function models to probability models, <em>International Journal of Approximate Reasoning</em>, <b>42</b>, 3, 314 - 330
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pign">pign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass function 
m &lt;- mass(list("a"=0.1, "a/b/c"=0.9), stateSpace)

# obtaina singleton credal set
c &lt;- relPl(m)
</code></pre>

<hr>
<h2 id='relPl-methods'>Methods for Function <code>relPl</code></h2><span id='topic+relPl-methods'></span><span id='topic+relPl+2Cmass-method'></span>

<h3>Description</h3>

<p>The relative plausability transform transforms a mass function to probability function. For more detail see <code><a href="#topic+relPl">relPl</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "mass")</code></dt><dd>
<p>Apply the relative plausability transform on a mass function
</p>
</dd>
</dl>

<hr>
<h2 id='space'>
State Space of and Evidence Structure
</h2><span id='topic+space'></span>

<h3>Description</h3>

<p>This functions returns the state space of an evidence structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="space_+3A_x">x</code></td>
<td>

<p>mass function or credal set
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector with the names within the state space
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# construct mass function 
m &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)

# obtain state space
space(m)

</code></pre>

<hr>
<h2 id='space-methods'>Methods for Function <code>space</code></h2><span id='topic+space-methods'></span><span id='topic+space+2Ccredal-method'></span><span id='topic+space+2Cmass-method'></span>

<h3>Description</h3>

<p>Returns the state space for an evidence structure. For more detail see <code><a href="#topic+space">space</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "credal")</code></dt><dd>
<p>Returns the state space for a credal set
</p>
</dd>
<dt><code>signature(x = "mass")</code></dt><dd>
<p>Returns the state space for a mass function
</p>
</dd>
</dl>

<hr>
<h2 id='space+26lt+3B-'>
Replacement Function for State Space
</h2><span id='topic+space+3C-'></span>

<h3>Description</h3>

<p>Replace the names of the state space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>space(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="space+2B26lt+2B3B-_+3A_x">x</code></td>
<td>

<p>mass function or credal set
</p>
</td></tr>
<tr><td><code id="space+2B26lt+2B3B-_+3A_value">value</code></td>
<td>

<p>new state space given as a character vector
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new mass function or credal set with the state space replaced
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>See Also</h3>

<p><code><a href="#topic+focal+3C-">focal&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# construct mass function 
m &lt;- mass(list("a"=0.1, "b"=0.1 , "c"=0.4, "a/b/c"=0.4), stateSpace)

# replace state space
space(m) &lt;- c("d", "e", "f")
</code></pre>

<hr>
<h2 id='space+26lt+3B+26ndash+3Bmethods'>Methods for Function <code>space&lt;-</code></h2><span id='topic+space+3C--methods'></span><span id='topic+space+3C-+2Ccredal+2Ccharacter-method'></span><span id='topic+space+3C-+2Cmass+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Replace the state space of an evidence structure. For more details see <code><a href="#topic+space">space</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "credal")</code></dt><dd>
<p>Replace state space of a credal set
</p>
</dd>
<dt><code>signature(x = "mass")</code></dt><dd>
<p>Replace the state space of a mass function
</p>
</dd>
</dl>

<hr>
<h2 id='upper'>
Upper Bounds Based on Evidence Structure
</h2><span id='topic+upper'></span>

<h3>Description</h3>

<p>Calculate the upper bounds for a vector of sets         
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upper(x, sets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="upper_+3A_x">x</code></td>
<td>

<p>credal set or mass function
</p>
</td></tr>
<tr><td><code id="upper_+3A_sets">sets</code></td>
<td>

<p>vector of sets where each set is represented by state names separated by &quot;/&quot;. If sets are missing, upper bounds on singletons are calculated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>upper bound of mass or probability for each set in the vector sets or if sets is missing upper bounds on singletons               
</p>


<h3>Note</h3>

<p>This is equivalent to Belief in Dempster-Shafer theory
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Shafer, G., (1976), A mathematical theory of evidence, Princeton University Press
</p>
<p>Walley, P. (2000), Towards a unified theory of imprecise probability, <em>International Journal of Approximate Reasoning, <b>24</b>, 125-148
</em></p>


<h3>See Also</h3>

<p><code><a href="#topic+upper">upper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass function
m &lt;- mass(list("a"=0.1, "b"=0.1 , 
               "c"=0.4, "a/b/c"=0.4), stateSpace)

# credal set
c &lt;- credal(c(0.1, 0.1, 0.1), 
            c(0.8, 0.8, 0.8), stateSpace)

# calculate upper bounds
upper(m, c("a", "a/b"))
upper(c, c("a", "a/b")) 

# upper bounds on singletons
upper(m)

</code></pre>

<hr>
<h2 id='upper-methods'>Methods for Function <code>upper</code></h2><span id='topic+upper-methods'></span><span id='topic+upper+2Ccredal+2Ccharacter-method'></span><span id='topic+upper+2Ccredal+2Cmissing-method'></span><span id='topic+upper+2Cmass+2Ccharacter-method'></span><span id='topic+upper+2Cmass+2Cmissing-method'></span>

<h3>Description</h3>

<p>Calculate lower bounds for a vector of sets with respect to the evidence structure. For more detail see <code><a href="#topic+upper">upper</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "credal", sets = "character")</code></dt><dd>
<p>obtain upper bounds for a vector of sets 
</p>
</dd>
<dt><code>signature(x = "credal", sets = "missing")</code></dt><dd>
<p>obtain upper bounds for all singletons 
</p>
</dd>     
<dt><code>signature(x = "mass", sets = "character")</code></dt><dd>
<p>obtain the plausability, or upper bounds, for a vector of sets     
</p>
</dd>
<dt><code>signature(x = "mass", sets = "missing")</code></dt><dd>
<p>obtain the plausability, or upper bounds, for all singletons    
</p>
</dd>  
</dl>

<hr>
<h2 id='yComb'>
Yager's Combination Operator
</h2><span id='topic+yComb'></span>

<h3>Description</h3>

<p>Combine evidence in the form of mass functions using Yager's combination operator. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yComb(x,y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yComb_+3A_x">x</code></td>
<td>

<p>single mass function or a list of mass functions      
</p>
</td></tr>
<tr><td><code id="yComb_+3A_y">y</code></td>
<td>

<p>single mass function if <code>x</code> is a single mass function, otherwise missing     
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mass function (<code><a href="#topic+massQ-class">massQ-class</a></code>) 
</p>


<h3>Note</h3>

<p>Yager's combination operator is quasi-associative and therefore we need to keep track of the mass on the empty set by using the class <code>massQ</code>.   
</p>


<h3>Author(s)</h3>

<p>Alexander Karlsson
</p>


<h3>References</h3>

<p>Yager, R. (1987), On the Dempster-Shafer Framework and New Combination Rules,
<em>Information Sciences 41: 93-137</em>.    
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dComb">dComb</a>, <a href="#topic+mComb">mComb</a>, <a href="#topic+cComb">cComb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># state space
stateSpace &lt;- c("a", "b", "c")

# mass functions 
m1 &lt;- mass(list("a"=0.1, "a/b/c"=0.9), stateSpace)
m2 &lt;- mass(list("b"=0.2, "a/b/c"=0.8), stateSpace)

# Yager's combination
yComb(m1, m2)
# or 
yComb(list(m1, m2)) 

</code></pre>

<hr>
<h2 id='yComb-methods'>Methods for Function <code>yComb</code></h2><span id='topic+yComb-methods'></span><span id='topic+yComb+2Cmass+2Cmass-method'></span><span id='topic+yComb+2Clist+2Cmissing-method'></span>

<h3>Description</h3>

<p>Combine mass functions using Yager's combination operator. For more detail
see <code><a href="#topic+yComb">yComb</a></code>.    
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "mass", y = "mass")</code></dt><dd>
<p>Combine two mass functions using Yager's combination operator  
</p>
</dd>
<dt><code>signature(x = "list", y = "missing")</code></dt><dd>
<p>Combine a list of mass functions using Yager's combination operator  
</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
