<!DOCTYPE html><html><head><title>Help for package QGA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QGA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#QGA'><p>Quantum Genetic Algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantum Genetic Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-29</td>
</tr>
<tr>
<td>Description:</td>
<td>Function that implements the Quantum Genetic Algorithm, first proposed by Han and Kim in 2000. This is an R implementation of the 'python' application developed by Lahoz-Beltra  (<a href="https://github.com/ResearchCodesHub/QuantumGeneticAlgorithms">https://github.com/ResearchCodesHub/QuantumGeneticAlgorithms</a>). Each optimization problem is represented as a maximization one, where each solution is a sequence of (qu)bits. Following the quantum paradigm, these qubits are in a superposition state: when measuring them, they collapse in a 0 or 1 state. After measurement, the fitness of the solution is calculated as in usual genetic algorithms. The evolution at each iteration is oriented by the application of two quantum gates to the amplitudes of the qubits: (1) a rotation gate (always); (2) a Pauli-X gate (optionally). The rotation is based on the theta angle values: higher values allow a quicker evolution, and lower values avoid local maxima. The Pauli-X gate is equivalent to the classical mutation operator and determines the swap between alfa and beta amplitudes of a given qubit. The package has been developed in such a way as to permit a complete separation between the engine, and the particular problem subject to combinatorial optimization. </td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-30 15:20:21 UTC; Giulio</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://barcaroli.github.io/QGA/">https://barcaroli.github.io/QGA/</a>,
<a href="https://github.com/barcaroli/QGA/">https://github.com/barcaroli/QGA/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/barcaroli/QGA/issues">https://github.com/barcaroli/QGA/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Giulio Barcaroli [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giulio Barcaroli &lt;gbarcaroli@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-31 18:42:49 UTC</td>
</tr>
</table>
<hr>
<h2 id='QGA'>Quantum Genetic Algorithm</h2><span id='topic+QGA'></span>

<h3>Description</h3>

<p>Main function to execute a Quantum Genetic Algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QGA(
  popsize = 20,
  generation_max = 200,
  nvalues_sol,
  Genome,
  thetainit = 3.1415926535 * 0.05,
  thetaend = 3.1415926535 * 0.025,
  pop_mutation_rate_init = NULL,
  pop_mutation_rate_end = NULL,
  mutation_rate_init = NULL,
  mutation_rate_end = NULL,
  mutation_flag = TRUE,
  plotting = TRUE,
  verbose = TRUE,
  progress = TRUE,
  eval_fitness,
  eval_func_inputs,
  stop_limit = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QGA_+3A_popsize">popsize</code></td>
<td>
<p>the number of generated solutions (population) to be evaluated at each iteration
(default is 20)</p>
</td></tr>
<tr><td><code id="QGA_+3A_generation_max">generation_max</code></td>
<td>
<p>the number of iterations to be performed
(default is 200)</p>
</td></tr>
<tr><td><code id="QGA_+3A_nvalues_sol">nvalues_sol</code></td>
<td>
<p>the number of possible integer values contained in each element (gene) of the solution</p>
</td></tr>
<tr><td><code id="QGA_+3A_genome">Genome</code></td>
<td>
<p>the length of the genome (or chromosome), representing a possible solution</p>
</td></tr>
<tr><td><code id="QGA_+3A_thetainit">thetainit</code></td>
<td>
<p>the angle (expressed in radiants) to be used when applying the rotation gate
when starting the iterations 
(default is pi * 0.05, where pi = 3.1415926535)</p>
</td></tr>
<tr><td><code id="QGA_+3A_thetaend">thetaend</code></td>
<td>
<p>the angle (expressed in radiants) to be used when applying the rotation gate 
at the end of the iterations
(default is pi * 0.025, where pi = 3.1415926535)</p>
</td></tr>
<tr><td><code id="QGA_+3A_pop_mutation_rate_init">pop_mutation_rate_init</code></td>
<td>
<p>initial mutation rate to be used when applying the X-Pauli gate, applied 
to each individual in the population (default is 1/(popsize+1))</p>
</td></tr>
<tr><td><code id="QGA_+3A_pop_mutation_rate_end">pop_mutation_rate_end</code></td>
<td>
<p>final mutation rate to be used when applying the X-Pauli gate, applied 
to each individual in the population (default is 1/(popsize+1))</p>
</td></tr>
<tr><td><code id="QGA_+3A_mutation_rate_init">mutation_rate_init</code></td>
<td>
<p>initial mutation rate to be used when applying the X-Pauli gate, applied 
to each element of the chromosome  (default is 1/(Genome+1)))</p>
</td></tr>
<tr><td><code id="QGA_+3A_mutation_rate_end">mutation_rate_end</code></td>
<td>
<p>final mutation rate to be used when applying the X-Pauli gate, applied 
to each element of the chromosome (default is 1/(Genome+1))</p>
</td></tr>
<tr><td><code id="QGA_+3A_mutation_flag">mutation_flag</code></td>
<td>
<p>flag indicating if the mutation gate is to be applied or not (default is TRUE)</p>
</td></tr>
<tr><td><code id="QGA_+3A_plotting">plotting</code></td>
<td>
<p>flag indicating plotting during iterations</p>
</td></tr>
<tr><td><code id="QGA_+3A_verbose">verbose</code></td>
<td>
<p>flag indicating printing fitness during iterations</p>
</td></tr>
<tr><td><code id="QGA_+3A_progress">progress</code></td>
<td>
<p>flag indicating progress bar during iterations</p>
</td></tr>
<tr><td><code id="QGA_+3A_eval_fitness">eval_fitness</code></td>
<td>
<p>name of the function that will be used to evaluate the fitness of each solution</p>
</td></tr>
<tr><td><code id="QGA_+3A_eval_func_inputs">eval_func_inputs</code></td>
<td>
<p>specific inputs required by the eval_fitness function</p>
</td></tr>
<tr><td><code id="QGA_+3A_stop_limit">stop_limit</code></td>
<td>
<p>value to stop the iterations if the fitness is higher</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the 'engine', which performs the quantum genetic algorithm calling
the function for the evaluation of the fitness that is specific for the particulare
problem to be optmized.
</p>


<h3>Value</h3>

<p>A numeric vector (positive integers) giving the best solution obtained by the QGA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------
# Fitness evaluation for Knapsack Problem
#----------------------------------------
KnapsackProblem &lt;- function(solution,
                            eval_func_inputs) {
  solution &lt;- solution - 1
  items &lt;- eval_func_inputs[[1]]
  maxweight &lt;- eval_func_inputs[[2]]
  tot_items &lt;- sum(solution)
  # Penalization
  if (sum(items$weight[solution]) &gt; maxweight) {
    tot_items &lt;- tot_items - (sum(items$weight[solution]) - maxweight)  
  }
  return(tot_items)
}
#----------------------------------------
# Prepare data for fitness evaluation
items &lt;- as.data.frame(list(Item = paste0("item",c(1:300)),
                            weight = rep(NA,300)))
set.seed(1234)
items$weight &lt;- rnorm(300,mean=50,sd=20)
hist(items$weight)
sum(items$weight)
maxweight = sum(items$weight) / 2
maxweight
#----------------------
# Perform optimization
popsize = 20
Genome = nrow(items)
solutionQGA &lt;- QGA(popsize = 20,
                generation_max = 500,
                nvalues_sol = 2,
                Genome = nrow(items),
                thetainit = 3.1415926535 * 0.05,
                thetaend = 3.1415926535 * 0.025,
                pop_mutation_rate_init = 1/(popsize + 1),
                pop_mutation_rate_end = 1/(popsize + 1),
                mutation_rate_init = 1,
                mutation_rate_end = 1,
                mutation_flag = TRUE,
                plotting = TRUE,
                verbose = FALSE,
                progress = TRUE,
                eval_fitness = KnapsackProblem,
                eval_func_inputs = list(items,
                                        maxweight))
#----------------------
# Analyze results
solution &lt;- solutionQGA[[1]]
solution &lt;- solution - 1
sum(solution)
sum(items$weight[solution])
maxweight

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
