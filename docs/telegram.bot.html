<!DOCTYPE html><html lang="en"><head><title>Help for package telegram.bot</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {telegram.bot}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#telegram.bot'><p>Develop a Telegram Bot with R</p></a></li>
<li><a href='#+2B.TelegramObject'><p>Constructing an Updater</p></a></li>
<li><a href='#add_error_handler'><p>Add an error handler</p></a></li>
<li><a href='#add_handler'><p>Add a handler</p></a></li>
<li><a href='#answerCallbackQuery'><p>Send answers to callback queries</p></a></li>
<li><a href='#answerInlineQuery'><p>Send answers to an inline query</p></a></li>
<li><a href='#BaseFilter'><p>The base of all filters</p></a></li>
<li><a href='#Bot'><p>Creating a Bot</p></a></li>
<li><a href='#bot_token'><p>Get a token from environment</p></a></li>
<li><a href='#CallbackQueryHandler'><p>Handling callback queries</p></a></li>
<li><a href='#check_update'><p>Check an update</p></a></li>
<li><a href='#clean_updates'><p>Clean any pending updates</p></a></li>
<li><a href='#CommandHandler'><p>Handling commands</p></a></li>
<li><a href='#deleteMessage'><p>Delete a message</p></a></li>
<li><a href='#deleteWebhook'><p>Remove webhook integration</p></a></li>
<li><a href='#Dispatcher'><p>The dispatcher of all updates</p></a></li>
<li><a href='#editMessageCaption'><p>Edit a caption</p></a></li>
<li><a href='#editMessageReplyMarkup'><p>Edit a reply markup</p></a></li>
<li><a href='#editMessageText'><p>Edit a text message</p></a></li>
<li><a href='#effective_chat'><p>Get the effective chat</p></a></li>
<li><a href='#effective_message'><p>Get the effective message</p></a></li>
<li><a href='#effective_user'><p>Get the effective user</p></a></li>
<li><a href='#ErrorHandler'><p>Handling errors</p></a></li>
<li><a href='#filtersLogic'><p>Combining filters</p></a></li>
<li><a href='#ForceReply'><p>Display a reply</p></a></li>
<li><a href='#forwardMessage'><p>Forward messages of any kind</p></a></li>
<li><a href='#from_chat_id'><p>Get an update's chat ID</p></a></li>
<li><a href='#from_user_id'><p>Get an update's user ID</p></a></li>
<li><a href='#getFile'><p>Prepare a file for downloading</p></a></li>
<li><a href='#getMe'><p>Check your bot's information</p></a></li>
<li><a href='#getUpdates'><p>Receive incoming updates</p></a></li>
<li><a href='#getUserProfilePhotos'><p>Get a user's profile photos</p></a></li>
<li><a href='#getWebhookInfo'><p>Get current webhook status</p></a></li>
<li><a href='#handle_update'><p>Handle an update</p></a></li>
<li><a href='#Handler'><p>The base of all handlers</p></a></li>
<li><a href='#InlineKeyboardButton'><p>Create an inline keyboard button</p></a></li>
<li><a href='#InlineKeyboardMarkup'><p>Create an inline keyboard markup</p></a></li>
<li><a href='#InlineQueryResult'><p>The base of inline query results</p></a></li>
<li><a href='#KeyboardButton'><p>Create a keyboard button</p></a></li>
<li><a href='#leaveChat'><p>Leave a chat</p></a></li>
<li><a href='#MessageFilters'><p>Filter message updates</p></a></li>
<li><a href='#MessageHandler'><p>Handling messages</p></a></li>
<li><a href='#ReplyKeyboardMarkup'><p>Create a keyboard markup</p></a></li>
<li><a href='#ReplyKeyboardRemove'><p>Remove a keyboard</p></a></li>
<li><a href='#running'><p>Retrieve the status of the Webhook.</p></a></li>
<li><a href='#sendAnimation'><p>Send animation files</p></a></li>
<li><a href='#sendAudio'><p>Send audio files</p></a></li>
<li><a href='#sendChatAction'><p>Send a chat action</p></a></li>
<li><a href='#sendDocument'><p>Send general files</p></a></li>
<li><a href='#sendLocation'><p>Send point on the map</p></a></li>
<li><a href='#sendMessage'><p>Send text messages</p></a></li>
<li><a href='#sendPhoto'><p>Send image files</p></a></li>
<li><a href='#sendSticker'><p>Send a sticker</p></a></li>
<li><a href='#sendVideo'><p>Send a video</p></a></li>
<li><a href='#sendVideoNote'><p>Send video messages</p></a></li>
<li><a href='#sendVoice'><p>Send voice files</p></a></li>
<li><a href='#set_token'><p>Change your bot's auth token</p></a></li>
<li><a href='#setWebhook'><p>Set a webhook</p></a></li>
<li><a href='#start_polling'><p>Start polling</p></a></li>
<li><a href='#start_server'><p>Start the webhook server.</p></a></li>
<li><a href='#stop_polling'><p>Stop polling</p></a></li>
<li><a href='#stop_server'><p>Stop the webhook server.</p></a></li>
<li><a href='#TelegramObject'><p>The base of telegram.bot objects</p></a></li>
<li><a href='#Update'><p>Represent an update</p></a></li>
<li><a href='#Updater'><p>Building a Telegram Bot with Update Polling</p></a></li>
<li><a href='#user_id'><p>Get a user from environment</p></a></li>
<li><a href='#Webhook'><p>Building a Telegram Bot with a Webhook</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Develop a 'Telegram Bot' with R</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a pure interface for the 'Telegram Bot API'
    <a href="http://core.telegram.org/bots/api">http://core.telegram.org/bots/api</a>. In addition to the pure API
    implementation, it features a number of tools to make the development of
    'Telegram' bots with R easy and straightforward, providing an easy-to-use
    interface that takes some work off the programmer.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ebeneditos/telegram.bot">https://github.com/ebeneditos/telegram.bot</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ebeneditos/telegram.bot/issues">https://github.com/ebeneditos/telegram.bot/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl, httpuv, httr, jsonlite, openssl, R6</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, devtools, knitr, promises, rmarkdown, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-07 13:32:07 UTC; Ernest Benedito</td>
</tr>
<tr>
<td>Author:</td>
<td>Ernest Benedito [aut, cre],
  Chris Stefano [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ernest Benedito &lt;ebeneditos@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-07 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='telegram.bot'>Develop a Telegram Bot with R</h2><span id='topic+telegram.bot'></span><span id='topic+telegram.bot-package'></span>

<h3>Description</h3>

<p>Provides a pure interface for the
<a href="https://core.telegram.org/bots/api">Telegram Bot API</a>. In addition to
the pure API implementation, it features a number of tools to make the
development of Telegram bots with R easy and straightforward, providing an
easy-to-use interface that takes some work off the programmer.
</p>


<h3>Details</h3>

<p>In <a href="https://ebeneditos.github.io/telegram.bot/">this page</a>
you can learn how to build a Bot quickly with this package.
</p>


<h3>Main Classes</h3>


<dl>
<dt><code><a href="#topic+Updater">Updater</a></code></dt><dd><p>Package main class. This class,
which employs the class <code><a href="#topic+Dispatcher">Dispatcher</a></code>, provides a
front-end to class <code><a href="#topic+Bot">Bot</a></code> to the programmer, so they can
focus on coding the bot. Its purpose is to receive the updates from
Telegram and to deliver them to said dispatcher.</p>
</dd>
<dt><code><a href="#topic+Bot">Bot</a></code></dt><dd><p>This object represents a Telegram Bot.</p>
</dd>
<dt><code><a href="#topic+Dispatcher">Dispatcher</a></code></dt><dd><p>This class dispatches all kinds of
updates to its registered handlers.</p>
</dd>
<dt><code><a href="#topic+Handler">Handler</a></code></dt><dd><p>The base class for all update handlers.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ernest Benedito <a href="mailto:ebeneditos@gmail.com">ebeneditos@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Chris Stefano <a href="mailto:virtualstaticvoid@gmail.com">virtualstaticvoid@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ebeneditos/telegram.bot">https://github.com/ebeneditos/telegram.bot</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ebeneditos/telegram.bot/issues">https://github.com/ebeneditos/telegram.bot/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(telegram.bot)

start &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = sprintf("Hello %s!", update$message$from$first_name)
  )
}

updater &lt;- Updater("TOKEN") + CommandHandler("start", start)

updater$start_polling() # Send '/start' to the bot

## End(Not run)
</code></pre>

<hr>
<h2 id='+2B.TelegramObject'>Constructing an Updater</h2><span id='topic++2B.TelegramObject'></span><span id='topic+add'></span>

<h3>Description</h3>

<p>With <code>+</code> you can add any kind of <code><a href="#topic+Handler">Handler</a></code> to
an <code><a href="#topic+Updater">Updater</a></code>'s <code>Dispatcher</code> (or directly to a
<code><a href="#topic+Dispatcher">Dispatcher</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TelegramObject'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B2B.TelegramObject_+3A_e1">e1</code></td>
<td>
<p>An object of class <code><a href="#topic+Updater">Updater</a></code> or
<code><a href="#topic+Dispatcher">Dispatcher</a></code>.</p>
</td></tr>
<tr><td><code id="+2B2B.TelegramObject_+3A_e2">e2</code></td>
<td>
<p>An object of class <code><a href="#topic+Handler">Handler</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+add_handler">add_handler</a></code> for further information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# You can chain multiple handlers
start &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = sprintf(
      "Hello %s!",
      update$message$from$first_name
    )
  )
}
echo &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = update$message$text
  )
}

updater &lt;- Updater("TOKEN") + CommandHandler("start", start) +
  MessageHandler(echo, MessageFilters$text)

# And keep adding...
caps &lt;- function(bot, update, args) {
  if (length(args &gt; 0L)) {
    text_caps &lt;- toupper(paste(args, collapse = " "))
    bot$sendMessage(
      chat_id = update$message$chat_id,
      text = text_caps
    )
  }
}

updater &lt;- updater + CommandHandler("caps", caps, pass_args = TRUE)

# Give it a try!
updater$start_polling()
# Send '/start' to the bot, '/caps foo' or just a simple text

## End(Not run)
</code></pre>

<hr>
<h2 id='add_error_handler'>Add an error handler</h2><span id='topic+add_error_handler'></span>

<h3>Description</h3>

<p>Registers an error handler in the <code><a href="#topic+Dispatcher">Dispatcher</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_error_handler(callback)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_error_handler_+3A_callback">callback</code></td>
<td>
<p>A function that takes <code>(bot, error)</code> as arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use <code><a href="#topic+add_handler">add_handler</a></code> to register error handlers
if the handler is of type <code><a href="#topic+ErrorHandler">ErrorHandler</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
updater &lt;- Updater(token = "TOKEN")

# Create error callback
error_callback &lt;- function(bot, error) {
  warning(simpleWarning(conditionMessage(error), call = "Updates polling"))
}

# Register it to the updater's dispatcher
updater$dispatcher$add_error_handler(error_callback)
# or
updater$dispatcher$add_handler(ErrorHandler(error_callback))
# or
updater &lt;- updater + ErrorHandler(error_callback)

## End(Not run)
</code></pre>

<hr>
<h2 id='add_handler'>Add a handler</h2><span id='topic+add_handler'></span>

<h3>Description</h3>

<p>Register a handler. A handler must be an instance of a subclass of
<code><a href="#topic+Handler">Handler</a></code>. All handlers are organized in groups with a numeric
value. The default group is 1. All groups will be evaluated for handling an
update, but only 0 or 1 handler per group will be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_handler(handler, group = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_handler_+3A_handler">handler</code></td>
<td>
<p>A <code>Handler</code> instance.</p>
</td></tr>
<tr><td><code id="add_handler_+3A_group">group</code></td>
<td>
<p>The group identifier, must be higher or equal to 1.
Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can use the <code><a href="#topic+add">add</a></code> (<code>+</code>) operator instead.
</p>
<p>The priority/order of handlers is determined as follows:
</p>

<ol>
<li><p>Priority of the group (lower group number = higher priority)
</p>
</li>
<li><p>The first handler in a group which should handle an update will be
used. Other handlers from the group will not be used.
The order in which handlers were added to the group defines the priority
(the first handler added in a group has the highest priority).

</p>
</li></ol>


<hr>
<h2 id='answerCallbackQuery'>Send answers to callback queries</h2><span id='topic+answerCallbackQuery'></span>

<h3>Description</h3>

<p>Use this method to send answers to callback queries sent from inline
keyboards. The answer will be displayed to the user as a notification at the
top of the chat screen or as an alert. On success, <code>TRUE</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>answerCallbackQuery(
  callback_query_id,
  text = NULL,
  show_alert = FALSE,
  url = NULL,
  cache_time = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="answerCallbackQuery_+3A_callback_query_id">callback_query_id</code></td>
<td>
<p>Unique identifier for the query to be answered.</p>
</td></tr>
<tr><td><code id="answerCallbackQuery_+3A_text">text</code></td>
<td>
<p>(Optional). Text of the notification. If not specified, nothing
will be shown to the user, 0-200 characters.</p>
</td></tr>
<tr><td><code id="answerCallbackQuery_+3A_show_alert">show_alert</code></td>
<td>
<p>(Optional). If <code>TRUE</code>, an alert will be shown by the
client instead of a notification at the top of the chat screen. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="answerCallbackQuery_+3A_url">url</code></td>
<td>
<p>(Optional). URL that will be opened by the user's client.</p>
</td></tr>
<tr><td><code id="answerCallbackQuery_+3A_cache_time">cache_time</code></td>
<td>
<p>(Optional). The maximum amount of time in seconds that the
result of the callback query may be cached client-side. Telegram apps
will support caching starting in version 3.14. Defaults to 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>answer_callback_query</code>.
</p>

<hr>
<h2 id='answerInlineQuery'>Send answers to an inline query</h2><span id='topic+answerInlineQuery'></span>

<h3>Description</h3>

<p>Use this method to send answers to an inline query. No more than 50 results
per query are allowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>answerInlineQuery(
  inline_query_id,
  results,
  cache_time = 300L,
  is_personal = NULL,
  next_offset = NULL,
  switch_pm_text = NULL,
  switch_pm_parameter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="answerInlineQuery_+3A_inline_query_id">inline_query_id</code></td>
<td>
<p>Unique identifier for the answered query.</p>
</td></tr>
<tr><td><code id="answerInlineQuery_+3A_results">results</code></td>
<td>
<p>A list of <code><a href="#topic+InlineQueryResult">InlineQueryResult</a></code> for the inline
query.</p>
</td></tr>
<tr><td><code id="answerInlineQuery_+3A_cache_time">cache_time</code></td>
<td>
<p>(Optional). The maximum amount of time in seconds that the
result of the inline query may be cached on the server.</p>
</td></tr>
<tr><td><code id="answerInlineQuery_+3A_is_personal">is_personal</code></td>
<td>
<p>(Optional). Pass <code>TRUE</code>, if results may be cached on
the server side only for the user that sent the query. By default,
results may be returned to any user who sends the same query.</p>
</td></tr>
<tr><td><code id="answerInlineQuery_+3A_next_offset">next_offset</code></td>
<td>
<p>(Optional). Pass the offset that a client should send in
the next query with the same text to receive more results. Pass an empty
string if there are no more results or if you don't support pagination.
Offset length can't exceed 64 bytes.</p>
</td></tr>
<tr><td><code id="answerInlineQuery_+3A_switch_pm_text">switch_pm_text</code></td>
<td>
<p>(Optional). If passed, clients will display a button
with specified text that switches the user to a private chat with the
bot and sends the bot a start message with the parameter
<code>switch_pm_parameter</code>.</p>
</td></tr>
<tr><td><code id="answerInlineQuery_+3A_switch_pm_parameter">switch_pm_parameter</code></td>
<td>
<p>(Optional). Deep-linking parameter for the
<code>/start</code> message sent to the bot when user presses the switch
button. 1-64 characters, only <code>A-Z</code>, <code>a-z</code>, <code>0-9</code>,
<code>_</code> and <code>-</code> are allowed.
</p>
<p><em>Example:</em> An inline bot that sends YouTube videos can ask the user
to connect the bot to their YouTube account to adapt search results
accordingly. To do this, it displays a 'Connect your YouTube account'
button above the results, or even before showing any. The user presses
the button, switches to a private chat with the bot and, in doing so,
passes a start parameter that instructs the bot to return an auth link.
Once done, the bot can offer a switch_inline button so that the user can
easily return to the chat where they wanted to use the bot's inline
capabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To enable this option, send the <code>/setinline</code> command to
<a href="https://t.me/botfather">@BotFather</a> and provide the placeholder text
that the user will see in the input field after typing your bot's name.
</p>
<p>You can also use it's snake_case equivalent <code>answer_inline_query</code>.
</p>

<hr>
<h2 id='BaseFilter'>The base of all filters</h2><span id='topic+BaseFilter'></span><span id='topic+as.BaseFilter'></span><span id='topic+is.BaseFilter'></span>

<h3>Description</h3>

<p>Base class for all Message Filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BaseFilter(filter)

as.BaseFilter(x, ...)

is.BaseFilter(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BaseFilter_+3A_filter">filter</code></td>
<td>
<p>If you want to create your own filters you can call this
generator passing by a <code>filter</code> function that takes a
<code>message</code> as input and returns a boolean: <code>TRUE</code> if the
message should be handled, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="BaseFilter_+3A_x">x</code></td>
<td>
<p>Object to be coerced or tested.</p>
</td></tr>
<tr><td><code id="BaseFilter_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+filtersLogic">filtersLogic</a></code> to know more about combining filter
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a filter function
text_or_command &lt;- function(message) !is.null(message$text)

# Make it an instance of BaseFilter with its generator:
text_or_command &lt;- BaseFilter(filter = text_or_command)

# Or by coercing it with as.BaseFilter:
text_or_command &lt;- as.BaseFilter(function(message) !is.null(message$text))

## End(Not run)
</code></pre>

<hr>
<h2 id='Bot'>Creating a Bot</h2><span id='topic+Bot'></span><span id='topic+is.Bot'></span>

<h3>Description</h3>

<p>This object represents a Telegram Bot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bot(token, base_url = NULL, base_file_url = NULL, request_config = NULL)

is.Bot(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bot_+3A_token">token</code></td>
<td>
<p>The bot's token given by the <em>BotFather</em>.</p>
</td></tr>
<tr><td><code id="Bot_+3A_base_url">base_url</code></td>
<td>
<p>(Optional). Telegram Bot API service URL.</p>
</td></tr>
<tr><td><code id="Bot_+3A_base_file_url">base_file_url</code></td>
<td>
<p>(Optional). Telegram Bot API file URL.</p>
</td></tr>
<tr><td><code id="Bot_+3A_request_config">request_config</code></td>
<td>
<p>(Optional). Additional configuration settings
to be passed to the bot's POST requests. See the <code>config</code>
parameter from <code>?httr::POST</code> for further details.
</p>
<p>The <code>request_config</code> settings are very
useful for the advanced users who would like to control the
default timeouts and/or control the proxy used for HTTP communication.</p>
</td></tr>
<tr><td><code id="Bot_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>To take full advantage of this library take a look at <code><a href="#topic+Updater">Updater</a></code>.
</p>
<p>You can also use its methods <code>snake_case</code> equivalent.
</p>


<h3>API Methods</h3>


<dl>
<dt><code><a href="#topic+answerCallbackQuery">answerCallbackQuery</a></code></dt><dd><p>Send
answers to callback queries</p>
</dd>
<dt><code><a href="#topic+answerInlineQuery">answerInlineQuery</a></code></dt><dd><p>Send answers to an inline query</p>
</dd>
<dt><code><a href="#topic+deleteMessage">deleteMessage</a></code></dt><dd><p>Delete a message</p>
</dd>
<dt><code><a href="#topic+deleteWebhook">deleteWebhook</a></code></dt><dd><p>Remove webhook integration</p>
</dd>
<dt><code><a href="#topic+editMessageText">editMessageText</a></code></dt><dd><p>Edit a text message</p>
</dd>
<dt><code><a href="#topic+editMessageCaption">editMessageCaption</a></code></dt><dd><p>Edit a caption</p>
</dd>
<dt><code><a href="#topic+editMessageReplyMarkup">editMessageReplyMarkup</a></code></dt><dd><p>Edit the reply
markup of a message</p>
</dd>
<dt><code><a href="#topic+forwardMessage">forwardMessage</a></code></dt><dd><p>Forward messages of any
kind</p>
</dd>
<dt><code><a href="#topic+getFile">getFile</a></code></dt><dd><p>Prepare a file for downloading</p>
</dd>
<dt><code><a href="#topic+getMe">getMe</a></code></dt><dd><p>Check your bot's information</p>
</dd>
<dt><code><a href="#topic+getUpdates">getUpdates</a></code></dt><dd><p>Receive incoming
updates</p>
</dd>
<dt><code><a href="#topic+getUserProfilePhotos">getUserProfilePhotos</a></code></dt><dd><p>Get a user's profile photos</p>
</dd>
<dt><code><a href="#topic+getWebhookInfo">getWebhookInfo</a></code></dt><dd><p>Get current webhook status</p>
</dd>
<dt><code><a href="#topic+leaveChat">leaveChat</a></code></dt><dd><p>Leave a chat</p>
</dd>
<dt><code><a href="#topic+sendAnimation">sendAnimation</a></code></dt><dd><p>Send animation files</p>
</dd>
<dt><code><a href="#topic+sendAudio">sendAudio</a></code></dt><dd><p>Send audio files</p>
</dd>
<dt><code><a href="#topic+sendChatAction">sendChatAction</a></code></dt><dd><p>Send a chat action</p>
</dd>
<dt><code><a href="#topic+sendDocument">sendDocument</a></code></dt><dd><p>Send general files</p>
</dd>
<dt><code><a href="#topic+sendLocation">sendLocation</a></code></dt><dd><p>Send point on the map</p>
</dd>
<dt><code><a href="#topic+sendMessage">sendMessage</a></code></dt><dd><p>Send text messages</p>
</dd>
<dt><code><a href="#topic+sendPhoto">sendPhoto</a></code></dt><dd><p>Send image files</p>
</dd>
<dt><code><a href="#topic+sendSticker">sendSticker</a></code></dt><dd><p>Send a sticker</p>
</dd>
<dt><code><a href="#topic+sendVideo">sendVideo</a></code></dt><dd><p>Send a video</p>
</dd>
<dt><code><a href="#topic+sendVideoNote">sendVideoNote</a></code></dt><dd><p>Send video messages</p>
</dd>
<dt><code><a href="#topic+sendVoice">sendVoice</a></code></dt><dd><p>Send voice files</p>
</dd>
<dt><code><a href="#topic+setWebhook">setWebhook</a></code></dt><dd><p>Set a webhook</p>
</dd>
</dl>



<h3>Other Methods</h3>


<dl>
<dt><code><a href="#topic+clean_updates">clean_updates</a></code></dt><dd><p>Clean any pending updates</p>
</dd>
<dt><code><a href="#topic+set_token">set_token</a></code></dt><dd><p>Change your bot's auth token</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = "TOKEN")

# In case you want to set a proxy (see ?httr:use_proxy)
bot &lt;- Bot(
  token = "TOKEN",
  request_config = httr::use_proxy(...)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='bot_token'>Get a token from environment</h2><span id='topic+bot_token'></span>

<h3>Description</h3>

<p>Obtain token from system variables (in <code>.Renviron</code>) set
according to the naming convention <code>R_TELEGRAM_BOT_X</code>
where <code>X</code> is the bot's name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bot_token(bot_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bot_token_+3A_bot_name">bot_name</code></td>
<td>
<p>The bot's name.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open the `.Renviron` file
file.edit(path.expand(file.path("~", ".Renviron")))
# Add the line (uncomment and replace &lt;bot-token&gt; by your bot TOKEN):
# R_TELEGRAM_BOT_RTelegramBot=&lt;bot-token&gt;
# Save and restart R

bot_token("RTelegramBot")

## End(Not run)
</code></pre>

<hr>
<h2 id='CallbackQueryHandler'>Handling callback queries</h2><span id='topic+CallbackQueryHandler'></span>

<h3>Description</h3>

<p><code><a href="#topic+Handler">Handler</a></code> class to handle Telegram callback queries. Optionally
based on a regex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CallbackQueryHandler(callback, pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CallbackQueryHandler_+3A_callback">callback</code></td>
<td>
<p>The callback function for this handler.
See <code><a href="#topic+Handler">Handler</a></code> for information about this function.</p>
</td></tr>
<tr><td><code id="CallbackQueryHandler_+3A_pattern">pattern</code></td>
<td>
<p>(Optional). Regex pattern to test.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>

<hr>
<h2 id='check_update'>Check an update</h2><span id='topic+check_update'></span>

<h3>Description</h3>

<p>This method is called to determine if an update should be handled by
this handler instance. It should always be overridden (see
<code><a href="#topic+Handler">Handler</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_update(update)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_update_+3A_update">update</code></td>
<td>
<p>The update to be tested.</p>
</td></tr>
</table>

<hr>
<h2 id='clean_updates'>Clean any pending updates</h2><span id='topic+clean_updates'></span>

<h3>Description</h3>

<p>Use this method to clean any pending updates on Telegram servers.
Requires no parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_updates()
</code></pre>

<hr>
<h2 id='CommandHandler'>Handling commands</h2><span id='topic+CommandHandler'></span>

<h3>Description</h3>

<p><code><a href="#topic+Handler">Handler</a></code> class to handle Telegram commands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CommandHandler(
  command,
  callback,
  filters = NULL,
  pass_args = FALSE,
  username = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CommandHandler_+3A_command">command</code></td>
<td>
<p>The command or vector of commands this handler
should listen for.</p>
</td></tr>
<tr><td><code id="CommandHandler_+3A_callback">callback</code></td>
<td>
<p>The callback function for this handler.
See <code><a href="#topic+Handler">Handler</a></code> for information about this function.</p>
</td></tr>
<tr><td><code id="CommandHandler_+3A_filters">filters</code></td>
<td>
<p>(Optional). Only allow updates with these filters. See
<code><a href="#topic+MessageFilters">MessageFilters</a></code> for a full list of all available filters.</p>
</td></tr>
<tr><td><code id="CommandHandler_+3A_pass_args">pass_args</code></td>
<td>
<p>(Optional). Determines whether the handler should be passed
<code>args</code>, received as a <code>vector</code>, split on spaces.</p>
</td></tr>
<tr><td><code id="CommandHandler_+3A_username">username</code></td>
<td>
<p>(Optional). Bot's username, you can retrieve it from
<code>bot$getMe()$username</code>. If this parameter is passed, then the
<code>CommandHandler</code> will also listen to the command
<code>/command@username</code>, as bot commands are often called this way.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Initialize bot
bot &lt;- Bot("TOKEN")
username &lt;- bot$getMe()$username
updater &lt;- Updater(bot = bot)

# Add a command
start &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = "Hi, I am a bot!"
  )
}

updater &lt;- updater + CommandHandler("start", start, username = username)

## End(Not run)
</code></pre>

<hr>
<h2 id='deleteMessage'>Delete a message</h2><span id='topic+deleteMessage'></span>

<h3>Description</h3>

<p>Use this method to delete a message. A message can only be deleted if it was
sent less than 48 hours ago. Any such recently sent outgoing message may be
deleted. Additionally, if the bot is an administrator in a group chat, it
can delete any message. If the bot is an administrator in a supergroup, it
can delete messages from any other user and service messages about people
joining or leaving the group (other types of service messages may only be
removed by the group creator). In channels, bots can only remove their own
messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteMessage(chat_id, message_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deleteMessage_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="deleteMessage_+3A_message_id">message_id</code></td>
<td>
<p>Identifier of the message to delete.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>delete_message</code>.
</p>

<hr>
<h2 id='deleteWebhook'>Remove webhook integration</h2><span id='topic+deleteWebhook'></span>

<h3>Description</h3>

<p>Use this method to remove webhook integration if you decide to switch back
to <code>getUpdates</code>. Requires no parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteWebhook()
</code></pre>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>delete_webhook</code>.
</p>

<hr>
<h2 id='Dispatcher'>The dispatcher of all updates</h2><span id='topic+Dispatcher'></span><span id='topic+is.Dispatcher'></span>

<h3>Description</h3>

<p>This class dispatches all kinds of updates to its registered handlers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dispatcher(bot)

is.Dispatcher(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Dispatcher_+3A_bot">bot</code></td>
<td>
<p>The bot object that should be passed to the handlers.</p>
</td></tr>
<tr><td><code id="Dispatcher_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+add_handler">add_handler</a></code></dt><dd><p>Registers a handler in the
<code>Dispatcher</code>.</p>
</dd>
<dt><code><a href="#topic+add_error_handler">add_error_handler</a></code></dt><dd><p>Registers an error handler in the
<code>Dispatcher</code>.</p>
</dd>
</dl>


<hr>
<h2 id='editMessageCaption'>Edit a caption</h2><span id='topic+editMessageCaption'></span>

<h3>Description</h3>

<p>Use this method to edit captions of messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editMessageCaption(
  chat_id = NULL,
  message_id = NULL,
  inline_message_id = NULL,
  caption = NULL,
  parse_mode = NULL,
  reply_markup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="editMessageCaption_+3A_chat_id">chat_id</code></td>
<td>
<p>(Optional). Unique identifier for the target chat or username
of the target channel.</p>
</td></tr>
<tr><td><code id="editMessageCaption_+3A_message_id">message_id</code></td>
<td>
<p>(Optional). Required if inline_message_id is not
specified. Identifier of the sent message.</p>
</td></tr>
<tr><td><code id="editMessageCaption_+3A_inline_message_id">inline_message_id</code></td>
<td>
<p>(Optional). Required if chat_id and message_id are
not specified. Identifier of the inline message.</p>
</td></tr>
<tr><td><code id="editMessageCaption_+3A_caption">caption</code></td>
<td>
<p>(Optional). New caption of the message.</p>
</td></tr>
<tr><td><code id="editMessageCaption_+3A_parse_mode">parse_mode</code></td>
<td>
<p>(Optional). Send 'Markdown' or 'HTML', if you want
Telegram apps to show bold, italic, fixed-width text or inline URLs in
your bot's message.</p>
</td></tr>
<tr><td><code id="editMessageCaption_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent
<code>edit_message_caption</code>.
</p>

<hr>
<h2 id='editMessageReplyMarkup'>Edit a reply markup</h2><span id='topic+editMessageReplyMarkup'></span>

<h3>Description</h3>

<p>Use this method to edit only the reply markup of messages sent by the bot or
via the bot (for inline bots).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editMessageReplyMarkup(
  chat_id = NULL,
  message_id = NULL,
  inline_message_id = NULL,
  reply_markup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="editMessageReplyMarkup_+3A_chat_id">chat_id</code></td>
<td>
<p>(Optional). Unique identifier for the target chat or username
of the target channel.</p>
</td></tr>
<tr><td><code id="editMessageReplyMarkup_+3A_message_id">message_id</code></td>
<td>
<p>(Optional). Required if inline_message_id is not
specified. Identifier of the sent message.</p>
</td></tr>
<tr><td><code id="editMessageReplyMarkup_+3A_inline_message_id">inline_message_id</code></td>
<td>
<p>(Optional). Required if chat_id and message_id are
not specified. Identifier of the inline message.</p>
</td></tr>
<tr><td><code id="editMessageReplyMarkup_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent
<code>edit_message_reply_markup</code>.
</p>

<hr>
<h2 id='editMessageText'>Edit a text message</h2><span id='topic+editMessageText'></span>

<h3>Description</h3>

<p>Use this method to edit text messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editMessageText(
  chat_id = NULL,
  message_id = NULL,
  inline_message_id = NULL,
  text,
  parse_mode = NULL,
  disable_web_page_preview = NULL,
  reply_markup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="editMessageText_+3A_chat_id">chat_id</code></td>
<td>
<p>(Optional). Unique identifier for the target chat or username
of the target channel.</p>
</td></tr>
<tr><td><code id="editMessageText_+3A_message_id">message_id</code></td>
<td>
<p>(Optional). Required if inline_message_id is not
specified. Identifier of the sent message.</p>
</td></tr>
<tr><td><code id="editMessageText_+3A_inline_message_id">inline_message_id</code></td>
<td>
<p>(Optional). Required if chat_id and message_id are
not specified. Identifier of the inline message.</p>
</td></tr>
<tr><td><code id="editMessageText_+3A_text">text</code></td>
<td>
<p>New text of the message.</p>
</td></tr>
<tr><td><code id="editMessageText_+3A_parse_mode">parse_mode</code></td>
<td>
<p>(Optional). Send 'Markdown' or 'HTML', if you want
Telegram apps to show bold, italic, fixed-width text or inline URLs in
your bot's message.</p>
</td></tr>
<tr><td><code id="editMessageText_+3A_disable_web_page_preview">disable_web_page_preview</code></td>
<td>
<p>(Optional). Disables link previews for links
in this message.</p>
</td></tr>
<tr><td><code id="editMessageText_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent
<code>edit_message_text</code>.
</p>

<hr>
<h2 id='effective_chat'>Get the effective chat</h2><span id='topic+effective_chat'></span>

<h3>Description</h3>

<p>The chat that this update was sent in, no matter what kind of
update this is. Will be <code>None</code> for <code>inline_query</code>,
<code>chosen_inline_result</code>, <code>callback_query</code> from inline messages,
<code>shipping_query</code> and <code>pre_checkout_query</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effective_chat()
</code></pre>

<hr>
<h2 id='effective_message'>Get the effective message</h2><span id='topic+effective_message'></span>

<h3>Description</h3>

<p>The message included in this update, no matter what kind of
update this is. Will be <code>None</code> for <code>inline_query</code>,
<code>chosen_inline_result</code>, <code>callback_query</code> from inline messages,
<code>shipping_query</code> and <code>pre_checkout_query</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effective_message()
</code></pre>

<hr>
<h2 id='effective_user'>Get the effective user</h2><span id='topic+effective_user'></span>

<h3>Description</h3>

<p>The user that sent this update, no matter what kind of update this
is. Will be <code>NULL</code> for <code>channel_post</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effective_user()
</code></pre>

<hr>
<h2 id='ErrorHandler'>Handling errors</h2><span id='topic+ErrorHandler'></span><span id='topic+is.ErrorHandler'></span>

<h3>Description</h3>

<p><code><a href="#topic+Handler">Handler</a></code> class to handle errors in the
<code><a href="#topic+Dispatcher">Dispatcher</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ErrorHandler(callback)

is.ErrorHandler(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ErrorHandler_+3A_callback">callback</code></td>
<td>
<p>A function that takes <code>(bot, error)</code> as arguments.</p>
</td></tr>
<tr><td><code id="ErrorHandler_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
updater &lt;- Updater(token = "TOKEN")

# Create error callback
error_callback &lt;- function(bot, error) {
  warning(simpleWarning(conditionMessage(error), call = "Updates polling"))
}

# Register it to the updater's dispatcher
updater$dispatcher$add_handler(ErrorHandler(error_callback))
# or
updater &lt;- updater + ErrorHandler(error_callback)

## End(Not run)
</code></pre>

<hr>
<h2 id='filtersLogic'>Combining filters</h2><span id='topic+filtersLogic'></span><span id='topic++21'></span><span id='topic++26'></span><span id='topic++7C'></span><span id='topic++21.BaseFilter'></span><span id='topic++26.BaseFilter'></span><span id='topic++7C.BaseFilter'></span>

<h3>Description</h3>

<p>Creates a function which returns the corresponding logical
operation between what <code>f</code> and <code>g</code> return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BaseFilter'
!f

## S3 method for class 'BaseFilter'
f &amp; g

## S3 method for class 'BaseFilter'
f | g
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filtersLogic_+3A_f">f</code>, <code id="filtersLogic_+3A_g">g</code></td>
<td>
<p>Arbitrary <code><a href="#topic+BaseFilter">BaseFilter</a></code> class functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+BaseFilter">BaseFilter</a></code> and <code><a href="#topic+MessageFilters">MessageFilters</a></code> for
further details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>not_command &lt;- !MessageFilters$command
text_and_reply &lt;- MessageFilters$text &amp; MessageFilters$reply
audio_or_video &lt;- MessageFilters$audio | MessageFilters$video
</code></pre>

<hr>
<h2 id='ForceReply'>Display a reply</h2><span id='topic+ForceReply'></span>

<h3>Description</h3>

<p>Upon receiving a message with this object, Telegram clients will display
a reply interface to the user (act as if the user has selected the bot's
message and tapped 'Reply').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ForceReply(force_reply = TRUE, selective = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ForceReply_+3A_force_reply">force_reply</code></td>
<td>
<p>Shows reply interface to the user, as if they manually
selected the bot's message and tapped 'Reply'. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ForceReply_+3A_selective">selective</code></td>
<td>
<p>(Optional). Use this parameter if you want to show the
keyboard to specific users only.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initialize bot
bot &lt;- Bot(token = "TOKEN")
chat_id &lt;- "CHAT_ID"

# Set input parameters
text &lt;- "Don't forget to send me the answer!"

# Send reply message
bot$sendMessage(chat_id, text, reply_markup = ForceReply())

## End(Not run)
</code></pre>

<hr>
<h2 id='forwardMessage'>Forward messages of any kind</h2><span id='topic+forwardMessage'></span>

<h3>Description</h3>

<p>Use this method to forward messages of any kind.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forwardMessage(chat_id, from_chat_id, message_id, disable_notification = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forwardMessage_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="forwardMessage_+3A_from_chat_id">from_chat_id</code></td>
<td>
<p>Unique identifier for the chat where the
original message was sent.</p>
</td></tr>
<tr><td><code id="forwardMessage_+3A_message_id">message_id</code></td>
<td>
<p>Message identifier in the chat specified in from_chat_id.</p>
</td></tr>
<tr><td><code id="forwardMessage_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>forward_message</code>.
</p>

<hr>
<h2 id='from_chat_id'>Get an update's chat ID</h2><span id='topic+from_chat_id'></span>

<h3>Description</h3>

<p>Get the <code>id</code> from the <code><a href="#topic+Update">Update</a></code>'s effective chat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_chat_id()
</code></pre>

<hr>
<h2 id='from_user_id'>Get an update's user ID</h2><span id='topic+from_user_id'></span>

<h3>Description</h3>

<p>Get the <code>id</code> from the <code><a href="#topic+Update">Update</a></code>'s effective user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_user_id()
</code></pre>

<hr>
<h2 id='getFile'>Prepare a file for downloading</h2><span id='topic+getFile'></span>

<h3>Description</h3>

<p>Use this method to get basic info about a file and prepare it for
downloading. For the moment, bots can download files of up to 20MB in size.
It is guaranteed that the link will be valid for at least 1 hour. When the
link expires, a new one can be requested by calling <code>getFile</code> again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFile(file_id, destfile = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFile_+3A_file_id">file_id</code></td>
<td>
<p>The file identifier.</p>
</td></tr>
<tr><td><code id="getFile_+3A_destfile">destfile</code></td>
<td>
<p>(Optional). If you want to save the file, pass by a
character string with the name where the downloaded file is saved.
See the <code>destfile</code> parameter from <code>?curl::curl_download</code> for
further details.</p>
</td></tr>
<tr><td><code id="getFile_+3A_...">...</code></td>
<td>
<p>(Optional). Additional parameters to be passed to
<code><a href="curl.html#topic+curl_download">curl_download</a></code>. It is not used if <code>destfile</code> is
<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>get_file</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")

photos &lt;- bot$getUserProfilePhotos(chat_id = chat_id)

# Download user profile photo
file_id &lt;- photos$photos[[1L]][[1L]]$file_id
bot$getFile(file_id, destfile = "photo.jpg")

## End(Not run)
</code></pre>

<hr>
<h2 id='getMe'>Check your bot's information</h2><span id='topic+getMe'></span>

<h3>Description</h3>

<p>A simple method for testing your bot's auth token. Requires no parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMe()
</code></pre>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>get_me</code>.
</p>

<hr>
<h2 id='getUpdates'>Receive incoming updates</h2><span id='topic+getUpdates'></span>

<h3>Description</h3>

<p>Use this method to receive incoming updates. It returns a
list of <code><a href="#topic+Update">Update</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUpdates(offset = NULL, limit = 100L, timeout = 0L, allowed_updates = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getUpdates_+3A_offset">offset</code></td>
<td>
<p>(Optional). Identifier of the first update to be returned.</p>
</td></tr>
<tr><td><code id="getUpdates_+3A_limit">limit</code></td>
<td>
<p>(Optional). Limits the number of updates to be retrieved.
Values between 1-100 are accepted. Defaults to 100.</p>
</td></tr>
<tr><td><code id="getUpdates_+3A_timeout">timeout</code></td>
<td>
<p>(Optional). Timeout in seconds for long polling. Defaults to
0, i.e. usual short polling. Should be positive, short polling should
be used for testing purposes only.</p>
</td></tr>
<tr><td><code id="getUpdates_+3A_allowed_updates">allowed_updates</code></td>
<td>
<p>(Optional). String or vector of strings with the
types of updates you want your bot to receive. For example, specify
<code>c("message", "edited_channel_post", "callback_query")</code> to only
receive updates of these types. See
<a href="https://core.telegram.org/bots/api#update">Update</a>
for a complete list of available update types. Specify an empty string
to receive all updates regardless of type (default). If not specified,
the previous setting will be used.
</p>
<p>Please note that this parameter doesn't affect updates created before
the call to the getUpdates, so unwanted updates may be received for a
short period of time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1. This method will not work if an outgoing webhook is set up.
</p>
<p>2. In order to avoid getting duplicate updates, recalculate offset after
each server response or use <code>Bot</code> method <code><a href="#topic+clean_updates">clean_updates</a></code>.
</p>
<p>3. To take full advantage of this library take a look at
<code><a href="#topic+Updater">Updater</a></code>.
</p>
<p>You can also use it's snake_case equivalent <code>get_updates</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))

updates &lt;- bot$getUpdates()

## End(Not run)
</code></pre>

<hr>
<h2 id='getUserProfilePhotos'>Get a user's profile photos</h2><span id='topic+getUserProfilePhotos'></span>

<h3>Description</h3>

<p>Use this method to get a list of profile pictures for a user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUserProfilePhotos(user_id, offset = NULL, limit = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getUserProfilePhotos_+3A_user_id">user_id</code></td>
<td>
<p>Unique identifier of the target user.</p>
</td></tr>
<tr><td><code id="getUserProfilePhotos_+3A_offset">offset</code></td>
<td>
<p>(Optional). Sequential number of the first photo to be
returned. By default, all photos are returned.</p>
</td></tr>
<tr><td><code id="getUserProfilePhotos_+3A_limit">limit</code></td>
<td>
<p>(Optional). Limits the number of photos to be retrieved. Values
between 1-100 are accepted. Defaults to 100.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>get_user_profile_photos</code>.
</p>
<p>See <code><a href="#topic+getFile">getFile</a></code> to know how to download files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")

photos &lt;- bot$getUserProfilePhotos(chat_id = chat_id)

## End(Not run)
</code></pre>

<hr>
<h2 id='getWebhookInfo'>Get current webhook status</h2><span id='topic+getWebhookInfo'></span>

<h3>Description</h3>

<p>Use this method to get current webhook status. Requires no parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWebhookInfo()
</code></pre>


<h3>Details</h3>

<p>If the bot is using <code>getUpdates</code>, will return an object with the url
field empty.
</p>
<p>You can also use it's snake_case equivalent <code>get_webhook_info</code>.
</p>

<hr>
<h2 id='handle_update'>Handle an update</h2><span id='topic+handle_update'></span>

<h3>Description</h3>

<p>This method is called if it was determined that an update should indeed
be handled by this instance. It should also be overridden (see
<code><a href="#topic+Handler">Handler</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_update(update, dispatcher)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="handle_update_+3A_update">update</code></td>
<td>
<p>The update to be handled.</p>
</td></tr>
<tr><td><code id="handle_update_+3A_dispatcher">dispatcher</code></td>
<td>
<p>The dispatcher to collect optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases <code>self$callback(dispatcher$bot, update)</code> can be called,
possibly along with optional arguments.
</p>

<hr>
<h2 id='Handler'>The base of all handlers</h2><span id='topic+Handler'></span><span id='topic+is.Handler'></span>

<h3>Description</h3>

<p>The base class for all update handlers. Create custom handlers by inheriting
from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Handler(
  callback,
  check_update = NULL,
  handle_update = NULL,
  handlername = NULL
)

is.Handler(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Handler_+3A_callback">callback</code></td>
<td>
<p>The callback function for this handler. Its inputs will be
<code>(bot, update)</code>,
where <code>bot</code> is a <code><a href="#topic+Bot">Bot</a></code> instance and <code>update</code> an
<code><a href="#topic+Update">Update</a></code> class.</p>
</td></tr>
<tr><td><code id="Handler_+3A_check_update">check_update</code></td>
<td>
<p>Function that will override the default
<code><a href="#topic+check_update">check_update</a></code> method. Use it if you want to create your own
<code>Handler</code>.</p>
</td></tr>
<tr><td><code id="Handler_+3A_handle_update">handle_update</code></td>
<td>
<p>Function that will override the default
<code><a href="#topic+handle_update">handle_update</a></code> method. Use it if you want to create your
own <code>Handler</code>.</p>
</td></tr>
<tr><td><code id="Handler_+3A_handlername">handlername</code></td>
<td>
<p>Name of the customized class, which will inherit from
<code>Handler</code>. If <code>NULL</code> (default) it will create a <code>Handler</code>
class.</p>
</td></tr>
<tr><td><code id="Handler_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+check_update">check_update</a></code></dt><dd><p>Called to determine if an update
should be handled by this handler instance.</p>
</dd>
<dt><code><a href="#topic+handle_update">handle_update</a></code></dt><dd><p>Called if it was determined that an
update should indeed be handled by this instance.</p>
</dd>
</dl>



<h3>Sub-classes</h3>


<dl>
<dt><code><a href="#topic+MessageHandler">MessageHandler</a></code></dt><dd><p>To handle Telegram messages.</p>
</dd>
<dt><code><a href="#topic+CommandHandler">CommandHandler</a></code></dt><dd><p>To handle Telegram commands.</p>
</dd>
<dt><code><a href="#topic+CallbackQueryHandler">CallbackQueryHandler</a></code></dt><dd><p>To handle Telegram callback
queries.</p>
</dd>
<dt><code><a href="#topic+ErrorHandler">ErrorHandler</a></code></dt><dd><p>To handle errors while polling for
updates.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example of a Handler
callback_method &lt;- function(bot, update) {
  chat_id &lt;- update$effective_chat()$id
  bot$sendMessage(chat_id = chat_id, text = "Hello")
}

hello_handler &lt;- Handler(callback_method)

# Customizing Handler
check_update &lt;- function(update) {
  TRUE
}

handle_update &lt;- function(update, dispatcher) {
  self$callback(dispatcher$bot, update)
}

foo_handler &lt;- Handler(callback_method,
  check_update = check_update,
  handle_update = handle_update,
  handlername = "FooHandler"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='InlineKeyboardButton'>Create an inline keyboard button</h2><span id='topic+InlineKeyboardButton'></span><span id='topic+is.InlineKeyboardButton'></span>

<h3>Description</h3>

<p>This object represents one button of an inline keyboard. You
<strong>must</strong> use exactly one of the optional fields. If all optional fields
are NULL, by defect it will generate <code>callback_data</code> with same data as
in <code>text</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InlineKeyboardButton(
  text,
  url = NULL,
  callback_data = NULL,
  switch_inline_query = NULL,
  switch_inline_query_current_chat = NULL
)

is.InlineKeyboardButton(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InlineKeyboardButton_+3A_text">text</code></td>
<td>
<p>Label text on the button.</p>
</td></tr>
<tr><td><code id="InlineKeyboardButton_+3A_url">url</code></td>
<td>
<p>(Optional). HTTP url to be opened when button is pressed.</p>
</td></tr>
<tr><td><code id="InlineKeyboardButton_+3A_callback_data">callback_data</code></td>
<td>
<p>(Optional). Data to be sent in a
<a href="https://core.telegram.org/bots/api#callbackquery">callback query</a>
to the bot when button is pressed, 1-64 bytes.</p>
</td></tr>
<tr><td><code id="InlineKeyboardButton_+3A_switch_inline_query">switch_inline_query</code></td>
<td>
<p>(Optional). If set, pressing the button will
prompt the user to select one of their chats, open that chat and insert
the bot's username and the specified inline query in the input field.
Can be empty, in which case just the bot's username will be inserted.</p>
</td></tr>
<tr><td><code id="InlineKeyboardButton_+3A_switch_inline_query_current_chat">switch_inline_query_current_chat</code></td>
<td>
<p>(Optional). If set, pressing the
button will insert the bot's username and the specified inline query in
the current chat's input field. Can be empty, in which case only the
bot's username will be inserted.</p>
</td></tr>
<tr><td><code id="InlineKeyboardButton_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note:</strong> After the user presses a callback button,
Telegram clients will display a progress bar until you call
<code><a href="#topic+answerCallbackQuery">answerCallbackQuery</a></code>. It is, therefore, necessary to
react by calling <code><a href="#topic+answerCallbackQuery">answerCallbackQuery</a></code> even if no notification
to the user is needed (e.g., without specifying any of the
optional parameters).
</p>

<hr>
<h2 id='InlineKeyboardMarkup'>Create an inline keyboard markup</h2><span id='topic+InlineKeyboardMarkup'></span>

<h3>Description</h3>

<p>This object represents an
<a href="https://core.telegram.org/bots#inline-keyboards-and-on-the-fly-updating">inline keyboard</a>
that appears right next to the message it belongs to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InlineKeyboardMarkup(inline_keyboard)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InlineKeyboardMarkup_+3A_inline_keyboard">inline_keyboard</code></td>
<td>
<p>List of button rows, each represented by a list of
<code><a href="#topic+InlineKeyboardButton">InlineKeyboardButton</a></code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note:</strong> After the user presses a callback button,
Telegram clients will display a progress bar until you call
<code><a href="#topic+answerCallbackQuery">answerCallbackQuery</a></code>. It is, therefore, necessary to
react by calling <code><a href="#topic+answerCallbackQuery">answerCallbackQuery</a></code> even if no notification
to the user is needed (e.g., without specifying any of the
optional parameters).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initialize bot
bot &lt;- Bot(token = "TOKEN")
chat_id &lt;- "CHAT_ID"

# Create Inline Keyboard
text &lt;- "Could you type their phone number, please?"
IKM &lt;- InlineKeyboardMarkup(
  inline_keyboard = list(
    list(
      InlineKeyboardButton(1),
      InlineKeyboardButton(2),
      InlineKeyboardButton(3)
    ),
    list(
      InlineKeyboardButton(4),
      InlineKeyboardButton(5),
      InlineKeyboardButton(6)
    ),
    list(
      InlineKeyboardButton(7),
      InlineKeyboardButton(8),
      InlineKeyboardButton(9)
    ),
    list(
      InlineKeyboardButton("*"),
      InlineKeyboardButton(0),
      InlineKeyboardButton("#")
    )
  )
)

# Send Inline Keyboard
bot$sendMessage(chat_id, text, reply_markup = IKM)

## End(Not run)
</code></pre>

<hr>
<h2 id='InlineQueryResult'>The base of inline query results</h2><span id='topic+InlineQueryResult'></span><span id='topic+is.InlineQueryResult'></span>

<h3>Description</h3>

<p>Baseclass for the InlineQueryResult* classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InlineQueryResult(type, id, ...)

is.InlineQueryResult(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InlineQueryResult_+3A_type">type</code></td>
<td>
<p>Type of the result. See the
<a href="https://core.telegram.org/bots/api#inlinequeryresult">documentation</a>
for a list of supported types.</p>
</td></tr>
<tr><td><code id="InlineQueryResult_+3A_id">id</code></td>
<td>
<p>Unique identifier for this result, 1-64 Bytes.</p>
</td></tr>
<tr><td><code id="InlineQueryResult_+3A_...">...</code></td>
<td>
<p>Additional parameters for the selected type. See the
<a href="https://core.telegram.org/bots/api#inlinequeryresult">documentation</a>
for the description of the
parameters depending on the <code>InlineQueryResult</code> type.</p>
</td></tr>
<tr><td><code id="InlineQueryResult_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
document_url &lt;- paste0(
  "https://github.com/ebeneditos/telegram.bot/raw/gh-pages/docs/",
  "telegram.bot.pdf"
)

result &lt;- InlineQueryResult(
  type = "document",
  id = 1,
  title = "Documentation",
  document_url = document_url,
  mime_type = "application/pdf"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='KeyboardButton'>Create a keyboard button</h2><span id='topic+KeyboardButton'></span><span id='topic+is.KeyboardButton'></span>

<h3>Description</h3>

<p>This object represents one button of the reply keyboard. Optional
fields are mutually exclusive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KeyboardButton(text, request_contact = NULL, request_location = NULL)

is.KeyboardButton(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KeyboardButton_+3A_text">text</code></td>
<td>
<p>Text of the button. If none of the optional
fields are used, it will be sent as a message when the button
is pressed.</p>
</td></tr>
<tr><td><code id="KeyboardButton_+3A_request_contact">request_contact</code></td>
<td>
<p>(Optional). If <code>TRUE</code>, the user's phone number
will be sent as a contact when the button is pressed. Available in
private chats only.</p>
</td></tr>
<tr><td><code id="KeyboardButton_+3A_request_location">request_location</code></td>
<td>
<p>(Optional). If <code>TRUE</code>, the user's current
location will be sent when the button is pressed. Available in private
chats only.</p>
</td></tr>
<tr><td><code id="KeyboardButton_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note:</strong> <code>request_contact</code> and <code>request_location</code>
options will only work in Telegram versions released after 9 April,
2016. Older clients will ignore them.
</p>

<hr>
<h2 id='leaveChat'>Leave a chat</h2><span id='topic+leaveChat'></span>

<h3>Description</h3>

<p>Use this method for your bot to leave a group, supergroup or channel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaveChat(chat_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leaveChat_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>leave_chat</code>.
</p>

<hr>
<h2 id='MessageFilters'>Filter message updates</h2><span id='topic+MessageFilters'></span>

<h3>Description</h3>

<p>Predefined filters for use as the <code>filter</code> argument of class
<code><a href="#topic+MessageHandler">MessageHandler</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MessageFilters
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with filtering functions.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+BaseFilter">BaseFilter</a></code> and <code><a href="#topic+filtersLogic">filtersLogic</a></code> for
advanced filters.
</p>


<h3>Functions</h3>


<ul>
<li><p><code>all</code>: All Messages.
</p>
</li>
<li><p><code>text</code>: Text Messages.
</p>
</li>
<li><p><code>command</code>: Messages starting with <code>/</code>.
</p>
</li>
<li><p><code>reply</code>: Messages that are a reply to another message.
</p>
</li>
<li><p><code>audio</code>: Messages that contain audio.
</p>
</li>
<li><p><code>document</code>: Messages that contain document.
</p>
</li>
<li><p><code>photo</code>: Messages that contain photo.
</p>
</li>
<li><p><code>sticker</code>: Messages that contain sticker.
</p>
</li>
<li><p><code>video</code>: Messages that contain video.
</p>
</li>
<li><p><code>voice</code>: Messages that contain voice.
</p>
</li>
<li><p><code>contact</code>: Messages that contain contact.
</p>
</li>
<li><p><code>location</code>: Messages that contain location.
</p>
</li>
<li><p><code>venue</code>: Messages that are forwarded.
</p>
</li>
<li><p><code>game</code>: Messages that contain game.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use to filter all video messages
video_handler &lt;- MessageHandler(callback_method, MessageFilters$video)

# To filter all contacts, etc.
contact_handler &lt;- MessageHandler(callback_method, MessageFilters$contact)

## End(Not run)
</code></pre>

<hr>
<h2 id='MessageHandler'>Handling messages</h2><span id='topic+MessageHandler'></span>

<h3>Description</h3>

<p><code><a href="#topic+Handler">Handler</a></code> class to handle Telegram messages. They might contain
text, media or status updates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MessageHandler(callback, filters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MessageHandler_+3A_callback">callback</code></td>
<td>
<p>The callback function for this handler.
See <code><a href="#topic+Handler">Handler</a></code> for information about this function.</p>
</td></tr>
<tr><td><code id="MessageHandler_+3A_filters">filters</code></td>
<td>
<p>(Optional). Only allow updates with these filters. Use
<code>NULL</code> (default) or <code>MessageFilters$all</code> for no filtering. See
<code><a href="#topic+MessageFilters">MessageFilters</a></code> for a full list of all available filters.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
callback_method &lt;- function(bot, update) {
  chat_id &lt;- update$message$chat_id
  bot$sendMessage(chat_id = chat_id, text = "Hello")
}

# No filtering
message_handler &lt;- MessageHandler(callback_method, MessageFilters$all)

## End(Not run)
</code></pre>

<hr>
<h2 id='ReplyKeyboardMarkup'>Create a keyboard markup</h2><span id='topic+ReplyKeyboardMarkup'></span>

<h3>Description</h3>

<p>This object represents a
<a href="https://core.telegram.org/bots#keyboards">custom keyboard</a> with reply
options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReplyKeyboardMarkup(
  keyboard,
  resize_keyboard = NULL,
  one_time_keyboard = NULL,
  selective = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReplyKeyboardMarkup_+3A_keyboard">keyboard</code></td>
<td>
<p>List of button rows, each represented by a list of
<code><a href="#topic+KeyboardButton">KeyboardButton</a></code> objects.</p>
</td></tr>
<tr><td><code id="ReplyKeyboardMarkup_+3A_resize_keyboard">resize_keyboard</code></td>
<td>
<p>(Optional). Requests clients to resize the keyboard
vertically for optimal fit. Defaults to <code>FALSE</code>, in which case the
custom keyboard is always of the same height as the app's standard
keyboard.</p>
</td></tr>
<tr><td><code id="ReplyKeyboardMarkup_+3A_one_time_keyboard">one_time_keyboard</code></td>
<td>
<p>(Optional). Requests clients to hide the keyboard
as soon as it's been used. The keyboard will still be available, but
clients will automatically display the usual letter-keyboard in the
chat - the user can press a special button in the input field to see the
custom keyboard again. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ReplyKeyboardMarkup_+3A_selective">selective</code></td>
<td>
<p>(Optional). Use this parameter if you want to show the
keyboard to specific users only.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initialize bot
bot &lt;- Bot(token = "TOKEN")
chat_id &lt;- "CHAT_ID"

# Create Custom Keyboard
text &lt;- "Aren't those custom keyboards cool?"
RKM &lt;- ReplyKeyboardMarkup(
  keyboard = list(
    list(KeyboardButton("Yes, they certainly are!")),
    list(KeyboardButton("I'm not quite sure")),
    list(KeyboardButton("No..."))
  ),
  resize_keyboard = FALSE,
  one_time_keyboard = TRUE
)

# Send Custom Keyboard
bot$sendMessage(chat_id, text, reply_markup = RKM)

## End(Not run)
</code></pre>

<hr>
<h2 id='ReplyKeyboardRemove'>Remove a keyboard</h2><span id='topic+ReplyKeyboardRemove'></span>

<h3>Description</h3>

<p>Upon receiving a message with this object, Telegram clients will
remove the current custom keyboard and display the default
letter-keyboard. By default, custom keyboards are displayed until
a new keyboard is sent by a bot. An exception is made for one-time
keyboards that are hidden immediately after the user presses a
button (see <code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReplyKeyboardRemove(remove_keyboard = TRUE, selective = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReplyKeyboardRemove_+3A_remove_keyboard">remove_keyboard</code></td>
<td>
<p>Requests clients to remove the custom keyboard.
(user will not be able to summon this keyboard; if you want to hide
the keyboard from sight but keep it accessible, use
<code>one_time_keyboard</code> in <code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>).
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ReplyKeyboardRemove_+3A_selective">selective</code></td>
<td>
<p>(Optional). Use this parameter if you want to show the
keyboard to specific users only.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initialize bot
bot &lt;- Bot(token = "TOKEN")
chat_id &lt;- "CHAT_ID"

# Create Custom Keyboard
text &lt;- "Don't forget to send me the answer!"
RKM &lt;- ReplyKeyboardMarkup(
  keyboard = list(
    list(KeyboardButton("Yes, they certainly are!")),
    list(KeyboardButton("I'm not quite sure")),
    list(KeyboardButton("No..."))
  ),
  resize_keyboard = FALSE,
  one_time_keyboard = FALSE
)

# Send Custom Keyboard
bot$sendMessage(chat_id, text, reply_markup = RKM)

# Remove Keyboard
bot$sendMessage(
  chat_id,
  "Okay, thanks!",
  reply_markup = ReplyKeyboardRemove()
)

## End(Not run)
</code></pre>

<hr>
<h2 id='running'>Retrieve the status of the Webhook.</h2><span id='topic+running'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> when listening for updates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>running()
</code></pre>

<hr>
<h2 id='sendAnimation'>Send animation files</h2><span id='topic+sendAnimation'></span>

<h3>Description</h3>

<p>Use this method to send animation files (GIF or H.264/MPEG-4 AVC video
without sound).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendAnimation(
  chat_id,
  animation,
  duration = NULL,
  width = NULL,
  height = NULL,
  caption = NULL,
  parse_mode = NULL,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendAnimation_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendAnimation_+3A_animation">animation</code></td>
<td>
<p>Animation to send. Pass a file_id as String to send an
animation that exists on the Telegram servers (recommended), pass an
HTTP URL as a String for Telegram to get an animation from the Internet,
or upload a local file by passing a file path.</p>
</td></tr>
<tr><td><code id="sendAnimation_+3A_duration">duration</code></td>
<td>
<p>(Optional). Duration of sent audio in seconds.</p>
</td></tr>
<tr><td><code id="sendAnimation_+3A_width">width</code></td>
<td>
<p>(Optional). Video width.</p>
</td></tr>
<tr><td><code id="sendAnimation_+3A_height">height</code></td>
<td>
<p>(Optional). Video height.</p>
</td></tr>
<tr><td><code id="sendAnimation_+3A_caption">caption</code></td>
<td>
<p>(Optional). Animation caption, 0-1024 characters.</p>
</td></tr>
<tr><td><code id="sendAnimation_+3A_parse_mode">parse_mode</code></td>
<td>
<p>(Optional). Send 'Markdown' or 'HTML', if you want
Telegram apps to show bold, italic, fixed-width text or inline URLs in
your bot's message.</p>
</td></tr>
<tr><td><code id="sendAnimation_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendAnimation_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendAnimation_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_animation</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")
animation_url &lt;- "http://techslides.com/demos/sample-videos/small.mp4"

bot$sendAnimation(
  chat_id = chat_id,
  animation = animation_url
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendAudio'>Send audio files</h2><span id='topic+sendAudio'></span>

<h3>Description</h3>

<p>Use this method to send audio files, if you want Telegram clients to display
them in the music player. Your audio must be in the .mp3 format. On success,
the sent Message is returned. Bots can currently send audio files of up to
50 MB in size, this limit may be changed in the future.
For sending voice messages, use the <code><a href="#topic+sendVoice">sendVoice</a></code> method instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendAudio(
  chat_id,
  audio,
  duration = NULL,
  performer = NULL,
  title = NULL,
  caption = NULL,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL,
  parse_mode = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendAudio_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendAudio_+3A_audio">audio</code></td>
<td>
<p>Audio file to send. Pass a file_id as String to send an audio
that exists on the Telegram servers (recommended), pass an HTTP URL as a
String for Telegram to get an audio from the Internet, or upload a local
audio file by passing a file path.</p>
</td></tr>
<tr><td><code id="sendAudio_+3A_duration">duration</code></td>
<td>
<p>(Optional). Duration of sent audio in seconds.</p>
</td></tr>
<tr><td><code id="sendAudio_+3A_performer">performer</code></td>
<td>
<p>(Optional). Performer.</p>
</td></tr>
<tr><td><code id="sendAudio_+3A_title">title</code></td>
<td>
<p>(Optional). Track name.</p>
</td></tr>
<tr><td><code id="sendAudio_+3A_caption">caption</code></td>
<td>
<p>(Optional). Audio caption, 0-1024 characters.</p>
</td></tr>
<tr><td><code id="sendAudio_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendAudio_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendAudio_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
<tr><td><code id="sendAudio_+3A_parse_mode">parse_mode</code></td>
<td>
<p>(Optional). Send 'Markdown' or 'HTML', if you want
Telegram apps to show bold, italic, fixed-width text or inline URLs in
your bot's message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_audio</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")
audio_url &lt;- "http://www.largesound.com/ashborytour/sound/brobob.mp3"

bot$sendAudio(
  chat_id = chat_id,
  audio = audio_url
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendChatAction'>Send a chat action</h2><span id='topic+sendChatAction'></span>

<h3>Description</h3>

<p>Use this method when you need to tell the user that something is happening
on the bot's side. The status is set for 5 seconds or less (when a message
arrives from your bot, Telegram clients clear its typing status).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendChatAction(chat_id, action)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendChatAction_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendChatAction_+3A_action">action</code></td>
<td>
<p>Type of action to broadcast. Choose one, depending on
what the user is about to receive:
</p>

<ul>
<li><p><code>typing</code> for text messages
</p>
</li>
<li><p><code>upload_photo</code> for photos
</p>
</li>
<li><p><code>upload_video</code> for videos
</p>
</li>
<li><p><code>record_video</code> for video recording
</p>
</li>
<li><p><code>upload_audio</code> for audio files
</p>
</li>
<li><p><code>record_audio</code> for audio file recording
</p>
</li>
<li><p><code>upload_document</code> for general files
</p>
</li>
<li><p><code>find_location</code> for location data
</p>
</li>
<li><p><code>upload_video_note</code> for video notes
</p>
</li>
<li><p><code>record_video_note</code> for video note recording
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_chat_action</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")

bot$sendChatAction(
  chat_id = chat_id,
  action = "typing"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendDocument'>Send general files</h2><span id='topic+sendDocument'></span>

<h3>Description</h3>

<p>Use this method to send general files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendDocument(
  chat_id,
  document,
  filename = NULL,
  caption = NULL,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL,
  parse_mode = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendDocument_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendDocument_+3A_document">document</code></td>
<td>
<p>File to send. Pass a file_id as String to send a file that
exists on the Telegram servers (recommended), pass an HTTP URL as a
String for Telegram to get a file from the Internet, or upload a local
file by passing a file path</p>
</td></tr>
<tr><td><code id="sendDocument_+3A_filename">filename</code></td>
<td>
<p>(Optional). File name that shows in telegram message.</p>
</td></tr>
<tr><td><code id="sendDocument_+3A_caption">caption</code></td>
<td>
<p>(Optional). Document caption, 0-1024 characters.</p>
</td></tr>
<tr><td><code id="sendDocument_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendDocument_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendDocument_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
<tr><td><code id="sendDocument_+3A_parse_mode">parse_mode</code></td>
<td>
<p>(Optional). Send 'Markdown' or 'HTML', if you want
Telegram apps to show bold, italic, fixed-width text or inline URLs in
your bot's message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_document</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")
document_url &lt;- paste0(
  "https://github.com/ebeneditos/telegram.bot/raw/gh-pages/docs/",
  "telegram.bot.pdf"
)

bot$sendDocument(
  chat_id = chat_id,
  document = document_url
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendLocation'>Send point on the map</h2><span id='topic+sendLocation'></span>

<h3>Description</h3>

<p>Use this method to send point on the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendLocation(
  chat_id,
  latitude,
  longitude,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendLocation_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendLocation_+3A_latitude">latitude</code></td>
<td>
<p>Latitude of location.</p>
</td></tr>
<tr><td><code id="sendLocation_+3A_longitude">longitude</code></td>
<td>
<p>Longitude of location.</p>
</td></tr>
<tr><td><code id="sendLocation_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendLocation_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendLocation_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_location</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")

bot$sendLocation(
  chat_id = chat_id,
  latitude = 51.521727,
  longitude = -0.117255
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendMessage'>Send text messages</h2><span id='topic+sendMessage'></span>

<h3>Description</h3>

<p>Use this method to send text messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendMessage(
  chat_id,
  text,
  parse_mode = NULL,
  disable_web_page_preview = NULL,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendMessage_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendMessage_+3A_text">text</code></td>
<td>
<p>Text of the message to be sent.</p>
</td></tr>
<tr><td><code id="sendMessage_+3A_parse_mode">parse_mode</code></td>
<td>
<p>(Optional). Send 'Markdown' or 'HTML', if you want
Telegram apps to show bold, italic, fixed-width text or inline URLs in
your bot's message.</p>
</td></tr>
<tr><td><code id="sendMessage_+3A_disable_web_page_preview">disable_web_page_preview</code></td>
<td>
<p>(Optional). Disables link previews for links
in this message.</p>
</td></tr>
<tr><td><code id="sendMessage_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendMessage_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendMessage_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_message</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")

bot$sendMessage(
  chat_id = chat_id,
  text = "foo *bold* _italic_",
  parse_mode = "Markdown"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendPhoto'>Send image files</h2><span id='topic+sendPhoto'></span>

<h3>Description</h3>

<p>Use this method to send photos.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendPhoto(
  chat_id,
  photo,
  caption = NULL,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL,
  parse_mode = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendPhoto_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendPhoto_+3A_photo">photo</code></td>
<td>
<p>Photo to send. Pass a file_id as String to send a photo that
exists on the Telegram servers (recommended), pass an HTTP URL as a
String for Telegram to get a photo from the Internet, or upload a local
photo by passing a file path.</p>
</td></tr>
<tr><td><code id="sendPhoto_+3A_caption">caption</code></td>
<td>
<p>(Optional). Photo caption (may also be used when re-sending
photos by file_id), 0-1024 characters.</p>
</td></tr>
<tr><td><code id="sendPhoto_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendPhoto_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendPhoto_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
<tr><td><code id="sendPhoto_+3A_parse_mode">parse_mode</code></td>
<td>
<p>(Optional). Send 'Markdown' or 'HTML', if you want
Telegram apps to show bold, italic, fixed-width text or inline URLs in
your bot's message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_photo</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")
photo_url &lt;- "https://telegram.org/img/t_logo.png"

bot$sendPhoto(
  chat_id = chat_id,
  photo = photo_url,
  caption = "Telegram Logo"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendSticker'>Send a sticker</h2><span id='topic+sendSticker'></span>

<h3>Description</h3>

<p>Use this method to send <code>.webp</code> stickers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendSticker(
  chat_id,
  sticker,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendSticker_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendSticker_+3A_sticker">sticker</code></td>
<td>
<p>Sticker to send. Pass a file_id as String to send a file that
exists on the Telegram servers (recommended), pass an HTTP URL as a
String for Telegram to get a <code>.webp</code> file from the Internet, or
upload a local one by passing a file path.</p>
</td></tr>
<tr><td><code id="sendSticker_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendSticker_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendSticker_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_sticker</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")
sticker_url &lt;- "https://www.gstatic.com/webp/gallery/1.webp"

bot$sendSticker(
  chat_id = chat_id,
  sticker = sticker_url
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendVideo'>Send a video</h2><span id='topic+sendVideo'></span>

<h3>Description</h3>

<p>Use this method to send video files, Telegram clients support mp4 videos
(other formats may be sent as Document).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendVideo(
  chat_id,
  video,
  duration = NULL,
  caption = NULL,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL,
  width = NULL,
  height = NULL,
  parse_mode = NULL,
  supports_streaming = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendVideo_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendVideo_+3A_video">video</code></td>
<td>
<p>Video file to send. Pass a file_id as String to send a video
that exists on the Telegram servers (recommended), pass an HTTP URL as a
String for Telegram to get a video from the Internet, or upload a local
video file by passing a file path.</p>
</td></tr>
<tr><td><code id="sendVideo_+3A_duration">duration</code></td>
<td>
<p>(Optional). Duration of sent audio in seconds.</p>
</td></tr>
<tr><td><code id="sendVideo_+3A_caption">caption</code></td>
<td>
<p>(Optional). Video caption, 0-1024 characters.</p>
</td></tr>
<tr><td><code id="sendVideo_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendVideo_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendVideo_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
<tr><td><code id="sendVideo_+3A_width">width</code></td>
<td>
<p>(Optional). Video width.</p>
</td></tr>
<tr><td><code id="sendVideo_+3A_height">height</code></td>
<td>
<p>(Optional). Video height.</p>
</td></tr>
<tr><td><code id="sendVideo_+3A_parse_mode">parse_mode</code></td>
<td>
<p>(Optional). Send 'Markdown' or 'HTML', if you want
Telegram apps to show bold, italic, fixed-width text or inline URLs in
your bot's message.</p>
</td></tr>
<tr><td><code id="sendVideo_+3A_supports_streaming">supports_streaming</code></td>
<td>
<p>(Optional). Pass <code>TRUE</code>, if the uploaded
video is suitable for streaming.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_video</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")
video_url &lt;- "http://techslides.com/demos/sample-videos/small.mp4"

bot$sendVideo(
  chat_id = chat_id,
  video = video_url
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendVideoNote'>Send video messages</h2><span id='topic+sendVideoNote'></span>

<h3>Description</h3>

<p>Use this method to send video messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendVideoNote(
  chat_id,
  video_note,
  duration = NULL,
  length = NULL,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendVideoNote_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendVideoNote_+3A_video_note">video_note</code></td>
<td>
<p>Video note file to send. Pass a file_id as String to send
a video note that exists on the Telegram servers (recommended), pass an
HTTP URL as a String for Telegram to get a video note from the Internet,
or upload a local video note file by passing a file path.</p>
</td></tr>
<tr><td><code id="sendVideoNote_+3A_duration">duration</code></td>
<td>
<p>(Optional). Duration of sent audio in seconds.</p>
</td></tr>
<tr><td><code id="sendVideoNote_+3A_length">length</code></td>
<td>
<p>(Optional). Video width and height.</p>
</td></tr>
<tr><td><code id="sendVideoNote_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendVideoNote_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendVideoNote_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_video_note</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")
video_note_url &lt;- "http://techslides.com/demos/sample-videos/small.mp4"

bot$sendVideoNote(
  chat_id = chat_id,
  video_note = video_note_url
)

## End(Not run)
</code></pre>

<hr>
<h2 id='sendVoice'>Send voice files</h2><span id='topic+sendVoice'></span>

<h3>Description</h3>

<p>Use this method to send audio files, if you want Telegram clients to display
the file as a playable voice message. For this to work, your audio must be
in an <code>.ogg</code> file encoded with OPUS (other formats may be sent with
<code><a href="#topic+sendAudio">sendAudio</a></code> or <code><a href="#topic+sendDocument">sendDocument</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendVoice(
  chat_id,
  voice,
  duration = NULL,
  caption = NULL,
  disable_notification = FALSE,
  reply_to_message_id = NULL,
  reply_markup = NULL,
  parse_mode = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sendVoice_+3A_chat_id">chat_id</code></td>
<td>
<p>Unique identifier for the target chat or username of
the target channel.</p>
</td></tr>
<tr><td><code id="sendVoice_+3A_voice">voice</code></td>
<td>
<p>Voice file to send. Pass a file_id as String to send a voice
file that exists on the Telegram servers (recommended), pass an HTTP URL
as a String for Telegram to get a voice file from the Internet, or
upload a local voice file file by passing a file path.</p>
</td></tr>
<tr><td><code id="sendVoice_+3A_duration">duration</code></td>
<td>
<p>(Optional). Duration of sent audio in seconds.</p>
</td></tr>
<tr><td><code id="sendVoice_+3A_caption">caption</code></td>
<td>
<p>(Optional). Voice message caption, 0-1024 characters.</p>
</td></tr>
<tr><td><code id="sendVoice_+3A_disable_notification">disable_notification</code></td>
<td>
<p>(Optional). Sends the message silently. Users
will receive a notification with no sound.</p>
</td></tr>
<tr><td><code id="sendVoice_+3A_reply_to_message_id">reply_to_message_id</code></td>
<td>
<p>(Optional). If the message is a reply, ID of the
original message.</p>
</td></tr>
<tr><td><code id="sendVoice_+3A_reply_markup">reply_markup</code></td>
<td>
<p>(Optional). A Reply Markup parameter object, it can be
either:
</p>

<ul>
<li><p><code><a href="#topic+ReplyKeyboardMarkup">ReplyKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+InlineKeyboardMarkup">InlineKeyboardMarkup</a></code>
</p>
</li>
<li><p><code><a href="#topic+ReplyKeyboardRemove">ReplyKeyboardRemove</a></code>
</p>
</li>
<li><p><code><a href="#topic+ForceReply">ForceReply</a></code></p>
</li></ul>
</td></tr>
<tr><td><code id="sendVoice_+3A_parse_mode">parse_mode</code></td>
<td>
<p>(Optional). Send 'Markdown' or 'HTML', if you want
Telegram apps to show bold, italic, fixed-width text or inline URLs in
your bot's message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can also use it's snake_case equivalent <code>send_voice</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
bot &lt;- Bot(token = bot_token("RTelegramBot"))
chat_id &lt;- user_id("Me")
ogg_url &lt;- "https://upload.wikimedia.org/wikipedia/commons/c/c8/Example.ogg"

bot$sendVoice(
  chat_id = chat_id,
  voice = ogg_url
)

## End(Not run)
</code></pre>

<hr>
<h2 id='set_token'>Change your bot's auth token</h2><span id='topic+set_token'></span>

<h3>Description</h3>

<p>Use this method to change your bot's auth token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_token(token)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_token_+3A_token">token</code></td>
<td>
<p>The bot's token given by the <em>BotFather</em>.</p>
</td></tr>
</table>

<hr>
<h2 id='setWebhook'>Set a webhook</h2><span id='topic+setWebhook'></span>

<h3>Description</h3>

<p>Use this method to specify a url and receive incoming updates via an
outgoing webhook. Whenever there is an update for the bot, we will send an
HTTPS POST request to the specified url, containing a JSON-serialized
<a href="https://core.telegram.org/bots/api#update">Update</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setWebhook(
  url = NULL,
  certificate = NULL,
  max_connections = 40L,
  allowed_updates = NULL,
  ip_address = NULL,
  drop_pending_updates = FALSE,
  secret_token = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setWebhook_+3A_url">url</code></td>
<td>
<p>HTTPS url to send updates to. Use an empty string to remove
webhook integration.</p>
</td></tr>
<tr><td><code id="setWebhook_+3A_certificate">certificate</code></td>
<td>
<p>(Optional). Upload your public key certificate so that
the root certificate in use can be checked. See Telegram's
<a href="https://core.telegram.org/bots/self-signed">self-signed guide</a> for
details.</p>
</td></tr>
<tr><td><code id="setWebhook_+3A_max_connections">max_connections</code></td>
<td>
<p>(Optional). Maximum allowed number of simultaneous
HTTPS connections to the webhook for update delivery, 1-100. Defaults to
40. Use lower values to limit the load on your bot's server, and higher
values to increase your bot's throughput.</p>
</td></tr>
<tr><td><code id="setWebhook_+3A_allowed_updates">allowed_updates</code></td>
<td>
<p>(Optional). String or vector of strings with the
types of updates you want your bot to receive. For example, specify
<code>c("message", "edited_channel_post", "callback_query")</code> to only
receive updates of these types. See
<a href="https://core.telegram.org/bots/api#update">Update</a>
for a complete list of available update types. Specify an empty string
to receive all updates regardless of type (default). If not specified,
the previous setting will be used.
</p>
<p>Please note that this parameter doesn't affect updates created before
the call to the get_updates, so unwanted updates may be received for a
short period of time.</p>
</td></tr>
<tr><td><code id="setWebhook_+3A_ip_address">ip_address</code></td>
<td>
<p>(Optional). The fixed IP address which will be used to
send webhook requests instead of the IP address resolved through DNS.</p>
</td></tr>
<tr><td><code id="setWebhook_+3A_drop_pending_updates">drop_pending_updates</code></td>
<td>
<p>(Optional). Pass True to drop all pending updates.</p>
</td></tr>
<tr><td><code id="setWebhook_+3A_secret_token">secret_token</code></td>
<td>
<p>(Optional). A secret token to be sent in a header
<code>X-Telegram-Bot-Api-Secret-Token</code> in every webhook request, 1-256
characters. Only characters A-Z, a-z, 0-9, _ and - are allowed. The
header is useful to ensure that the request comes from a webhook set by you.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you'd like to make sure that the webhook request comes from Telegram, we
recommend using a secret path in the URL, e.g.
<code>https://www.example.com/&lt;token&gt;</code>.
</p>
<p>You can also use it's snake_case equivalent <code>set_webhook</code>.
</p>

<hr>
<h2 id='start_polling'>Start polling</h2><span id='topic+start_polling'></span>

<h3>Description</h3>

<p>Starts polling updates from Telegram. You can stop the polling either by
using the the <code>interrupt R</code> command in the session menu or with the
<code><a href="#topic+stop_polling">stop_polling</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_polling(
  timeout = 10L,
  clean = FALSE,
  allowed_updates = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="start_polling_+3A_timeout">timeout</code></td>
<td>
<p>(Optional). Passed to <code><a href="#topic+getUpdates">getUpdates</a></code>.
Default is 10.</p>
</td></tr>
<tr><td><code id="start_polling_+3A_clean">clean</code></td>
<td>
<p>(Optional). Whether to clean any pending updates on Telegram
servers before actually starting to poll. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="start_polling_+3A_allowed_updates">allowed_updates</code></td>
<td>
<p>(Optional). Passed to <code><a href="#topic+getUpdates">getUpdates</a></code>.</p>
</td></tr>
<tr><td><code id="start_polling_+3A_verbose">verbose</code></td>
<td>
<p>(Optional). If <code>TRUE</code>, prints status of the polling.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Start polling example
start &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = sprintf(
      "Hello %s!",
      update$message$from$first_name
    )
  )
}

updater &lt;- Updater("TOKEN") + CommandHandler("start", start)

updater$start_polling(verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='start_server'>Start the webhook server.</h2><span id='topic+start_server'></span>

<h3>Description</h3>

<p>Starts the webhook for updates from Telegram. You can stop listening either by
using the RStudio's <code>interrupt R</code> command in the session menu or with the
<code><a href="#topic+stop_server">stop_server</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_server(host = "127.0.0.1", port = 5001, clean = FALSE, blocking = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="start_server_+3A_host">host</code></td>
<td>
<p>a string that is a valid IPv4 or IPv6 address that is owned by
this server, which the application will listen on. &quot;0.0.0.0&quot; represents
all IPv4 addresses and &quot;::/0&quot; represents all IPv6 addresses.
Default is &quot;127.0.0.1&quot;.</p>
</td></tr>
<tr><td><code id="start_server_+3A_port">port</code></td>
<td>
<p>a number or integer that indicates the server port that should
be listened on. Note that on most Unix-like systems including Linux and
Mac OS X, port numbers smaller than 1025 require root privileges.
Default is 5001.</p>
</td></tr>
<tr><td><code id="start_server_+3A_clean">clean</code></td>
<td>
<p>(Optional). Whether to clean any pending updates on Telegram
servers before actually starting to poll. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="start_server_+3A_blocking">blocking</code></td>
<td>
<p>(Optional). Determines whether the method blocks whilst listening
for updates from Telegram.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Start webhook example
start &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = sprintf(
      "Hello %s!",
      update$message$from$first_name
    )
  )
}

webhook &lt;- Webhook("https://example.com/webhook", "TOKEN") + CommandHandler("start", start)

webhook$start_server()

## End(Not run)
</code></pre>

<hr>
<h2 id='stop_polling'>Stop polling</h2><span id='topic+stop_polling'></span>

<h3>Description</h3>

<p>Stops the polling. Requires no parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_polling()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example of a 'kill' command
kill &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = "Bye!"
  )
  # Clean 'kill' update
  bot$getUpdates(offset = update$update_id + 1)
  # Stop the updater polling
  updater$stop_polling()
}

updater &lt;&lt;- updater + CommandHandler("kill", kill)

updater$start_polling(verbose = TRUE) # Send '/kill' to the bot

## End(Not run)
</code></pre>

<hr>
<h2 id='stop_server'>Stop the webhook server.</h2><span id='topic+stop_server'></span>

<h3>Description</h3>

<p>Stops listening on the webhook. Requires no parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_server()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example of a 'kill' command
kill &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = "Bye!"
  )
  # Stop the webhook
  webhook$stop_server()
}

webhook &lt;- Webhook("https://example.com/webhook", "TOKEN") + CommandHandler("start", start)

webhook$start_server()

## End(Not run)
</code></pre>

<hr>
<h2 id='TelegramObject'>The base of telegram.bot objects</h2><span id='topic+TelegramObject'></span><span id='topic+is.TelegramObject'></span>

<h3>Description</h3>

<p>Base class for most telegram objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.TelegramObject(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TelegramObject_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> generator object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TelegramObject-clone"><code>TelegramObject$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-TelegramObject-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TelegramObject$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Update'>Represent an update</h2><span id='topic+Update'></span><span id='topic+is.Update'></span>

<h3>Description</h3>

<p>This object represents an incoming
<a href="https://core.telegram.org/bots/api#update">Update</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Update(data)

is.Update(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Update_+3A_data">data</code></td>
<td>
<p>Data of the update.</p>
</td></tr>
<tr><td><code id="Update_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+from_chat_id">from_chat_id</a></code></dt><dd><p>To get the <code>id</code> from the update's
effective chat.</p>
</dd>
<dt><code><a href="#topic+from_user_id">from_user_id</a></code></dt><dd><p>To get the <code>id</code> from the update's
effective user.</p>
</dd>
<dt><code><a href="#topic+effective_chat">effective_chat</a></code></dt><dd><p>To get the chat that this
update was sent in, no matter what kind of update this is.</p>
</dd>
<dt><code><a href="#topic+effective_user">effective_user</a></code></dt><dd><p>To get the user that sent
this update, no matter what kind of update this is.</p>
</dd>
<dt><code><a href="#topic+effective_message">effective_message</a></code></dt><dd><p>To get the message
included in this update, no matter what kind of  update this is.</p>
</dd></dl>


<hr>
<h2 id='Updater'>Building a Telegram Bot with Update Polling</h2><span id='topic+Updater'></span><span id='topic+is.Updater'></span>

<h3>Description</h3>

<p>This class, which employs the class <code><a href="#topic+Dispatcher">Dispatcher</a></code>, provides a
front-end to class <code><a href="#topic+Bot">Bot</a></code> to the programmer, so you can focus on
coding the bot. Its purpose is to receive the updates from Telegram and to
deliver them to said dispatcher. The dispatcher supports
<code><a href="#topic+Handler">Handler</a></code> classes for different kinds of data: Updates from
Telegram, basic text commands and even arbitrary types. See
<code><a href="#topic+add">add</a></code> (<code>+</code>) to learn more about building your
<code>Updater</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Updater(
  token = NULL,
  base_url = NULL,
  base_file_url = NULL,
  request_config = NULL,
  bot = NULL
)

is.Updater(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Updater_+3A_token">token</code></td>
<td>
<p>(Optional). The bot's token given by the <em>BotFather</em>.</p>
</td></tr>
<tr><td><code id="Updater_+3A_base_url">base_url</code></td>
<td>
<p>(Optional). Telegram Bot API service URL.</p>
</td></tr>
<tr><td><code id="Updater_+3A_base_file_url">base_file_url</code></td>
<td>
<p>(Optional). Telegram Bot API file URL.</p>
</td></tr>
<tr><td><code id="Updater_+3A_request_config">request_config</code></td>
<td>
<p>(Optional). Additional configuration settings
to be passed to the bot's POST requests. See the <code>config</code>
parameter from <code>?httr::POST</code> for further details.
</p>
<p>The <code>request_config</code> settings are very
useful for the advanced users who would like to control the
default timeouts and/or control the proxy used for HTTP communication.</p>
</td></tr>
<tr><td><code id="Updater_+3A_bot">bot</code></td>
<td>
<p>(Optional). A pre-initialized <code><a href="#topic+Bot">Bot</a></code> instance.</p>
</td></tr>
<tr><td><code id="Updater_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p><strong>Note:</strong> You <strong>must</strong> supply either a <code>bot</code> or a
<code>token</code> argument.
</p>


<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+start_polling">start_polling</a></code></dt><dd><p>Starts polling updates from
Telegram.</p>
</dd>
<dt><code><a href="#topic+stop_polling">stop_polling</a></code></dt><dd><p>Stops the polling.</p>
</dd>
</dl>



<h3>References</h3>

<p><a href="https://core.telegram.org/bots">Bots: An
introduction for developers</a> and
<a href="https://core.telegram.org/bots/api">Telegram Bot API</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
updater &lt;- Updater(token = "TOKEN")

# In case you want to set a proxy (see ?httr:use_proxy)
updater &lt;- Updater(
  token = "TOKEN",
  request_config = httr::use_proxy(...)
)

# Add a handler
start &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = sprintf(
      "Hello %s!",
      update$message$from$first_name
    )
  )
}
updater &lt;- updater + CommandHandler("start", start)

# Start polling
updater$start_polling(verbose = TRUE) # Send '/start' to the bot

## End(Not run)
</code></pre>

<hr>
<h2 id='user_id'>Get a user from environment</h2><span id='topic+user_id'></span>

<h3>Description</h3>

<p>Obtain Telegram user id from system variables (in <code>.Renviron</code>) set
according to the naming convention <code>R_TELEGRAM_USER_X</code>
where <code>X</code> is the user's name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>user_id(user_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="user_id_+3A_user_name">user_name</code></td>
<td>
<p>The user's name.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Open the `.Renviron` file
file.edit(path.expand(file.path("~", ".Renviron")))
# Add the line (uncomment and replace &lt;user-id&gt; by your Telegram user ID):
# R_TELEGRAM_USER_Me=&lt;user-id&gt;
# Save and restart R

user_id("Me")

## End(Not run)
</code></pre>

<hr>
<h2 id='Webhook'>Building a Telegram Bot with a Webhook</h2><span id='topic+Webhook'></span><span id='topic+is.Webhook'></span>

<h3>Description</h3>

<p>This class, which employs the class <code><a href="#topic+Dispatcher">Dispatcher</a></code>, provides a
front-end to class <code><a href="#topic+Bot">Bot</a></code> to the programmer, so you can focus on
coding the bot. Its purpose is to receive updates via webhook from Telegram and
to deliver them to said dispatcher. The dispatcher supports
<code><a href="#topic+Handler">Handler</a></code> classes for different kinds of data: Updates from
Telegram, basic text commands and even arbitrary types. See
<code><a href="#topic+add">add</a></code> (<code>+</code>) to learn more about building your <code>Webhook</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Webhook(
  webhook_url,
  token = NULL,
  base_url = NULL,
  base_file_url = NULL,
  request_config = NULL,
  certificate = NULL,
  max_connections = NULL,
  allowed_updates = NULL,
  ip_address = NULL,
  drop_pending_updates = FALSE,
  verbose = FALSE,
  bot = NULL
)

is.Webhook(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Webhook_+3A_webhook_url">webhook_url</code></td>
<td>
<p>Webhook HTTPS url to send updates to. The url is conventionally
suffixed with the <code>/webhook</code> path.
</p>
<p><strong>Note</strong>: The url must be publicly accessible, since Telegram will need to make
HTTP <code>POST</code> requests to the end-point for each update.
</p>
<p>For example, if you are deploying to Heroku, you can use the app's hostname,
such as <code>https://[name of app].herokuapp.com/webhook</code>, or a
<a href="https://devcenter.heroku.com/articles/custom-domains">custom hostname</a>
for a domain that belongs to you, such as <code>https://app.yourcustomdomain.com/webhook</code>.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_token">token</code></td>
<td>
<p>(Optional). The bot's token given by the <em>BotFather</em>.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_base_url">base_url</code></td>
<td>
<p>(Optional). Telegram Bot API service URL.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_base_file_url">base_file_url</code></td>
<td>
<p>(Optional). Telegram Bot API file URL.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_request_config">request_config</code></td>
<td>
<p>(Optional). Additional configuration settings
to be passed to the bot's POST requests. See the <code>config</code>
parameter from <code>httr::POST</code> for further details.
</p>
<p>The <code>request_config</code> settings are very
useful for the advanced users who would like to control the
default timeouts and/or control the proxy used for HTTP communication.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_certificate">certificate</code></td>
<td>
<p>(Optional). Upload your public key certificate so that
the root certificate in use can be checked. See Telegram's
<a href="https://core.telegram.org/bots/self-signed">self-signed guide</a> for
details.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_max_connections">max_connections</code></td>
<td>
<p>(Optional). Maximum allowed number of simultaneous
HTTPS connections to the webhook for update delivery, 1-100. Defaults to
40. Use lower values to limit the load on your bot's server, and higher
values to increase your bot's throughput.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_allowed_updates">allowed_updates</code></td>
<td>
<p>(Optional). String or vector of strings with the
types of updates you want your bot to receive. For example, specify
<code>c("message", "edited_channel_post", "callback_query")</code> to only
receive updates of these types. See
<a href="https://core.telegram.org/bots/api#update">Update</a>
for a complete list of available update types. Specify an empty string
to receive all updates regardless of type (default). If not specified,
the previous setting will be used.
</p>
<p>Please note that this parameter doesn't affect updates created before
the call to the get_updates, so unwanted updates may be received for a
short period of time.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_ip_address">ip_address</code></td>
<td>
<p>(Optional). The fixed IP address which will be used to
send webhook requests instead of the IP address resolved through DNS.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_drop_pending_updates">drop_pending_updates</code></td>
<td>
<p>(Optional). Pass True to drop all pending updates.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_verbose">verbose</code></td>
<td>
<p>(Optional). If <code>TRUE</code>, prints status of the polling.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_bot">bot</code></td>
<td>
<p>(Optional). A pre-initialized <code><a href="#topic+Bot">Bot</a></code> instance.</p>
</td></tr>
<tr><td><code id="Webhook_+3A_x">x</code></td>
<td>
<p>Object to be tested.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An <code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>You <strong>must</strong> supply the <code>webhook_url</code> and either a <code>bot</code>
or a <code>token</code> argument.
</p>
<p>The <code>webhook_url</code> must be publicly accessible, since Telegram will
need to make HTTP <code>POST</code> requests to the end-point for each update.
</p>
<p><strong>Security Note</strong>: <code>Webhook</code> encapsulates generating a <code>secret_token</code> which
is used to validate that the request comes from a webhook set by you.
</p>


<h3>Methods</h3>


<dl>
<dt><code><a href="#topic+start_server">start_server</a></code></dt><dd><p>Starts listening for updates from
Telegram.</p>
</dd>
<dt><code><a href="#topic+stop_server">stop_server</a></code></dt><dd><p>Stops listening for updates.</p>
</dd>
<dt><code><a href="#topic+running">running</a></code></dt><dd><p>Returns <code>TRUE</code> when listening for updates.</p>
</dd>
</dl>



<h3>References</h3>

<p><a href="https://core.telegram.org/bots">Bots: An introduction for developers</a>,
<a href="https://core.telegram.org/bots/api">Telegram Bot API</a> and
<a href="https://core.telegram.org/bots/webhooks">Marvin's Marvellous Guide to All Things Webhook</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
webhook &lt;- Webhook("https://example.com/webhook", "TOKEN")

# In case you want to set a proxy
webhook &lt;- Webhook(
  webhook_url = "https://example.com/webhook",
  token = "TOKEN",
  request_config = httr::use_proxy(...),
  verbose = TRUE
)

# Add a handler
start &lt;- function(bot, update) {
  bot$sendMessage(
    chat_id = update$message$chat_id,
    text = sprintf(
      "Hello %s!",
      update$message$from$first_name
    )
  )
}
webhook &lt;- webhook + CommandHandler("start", start)

# Start polling
webhook$start_server() # Send '/start' to the bot

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
