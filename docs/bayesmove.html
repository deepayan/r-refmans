<!DOCTYPE html><html><head><title>Help for package bayesmove</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesmove}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#assign_behavior'><p>Assign behavior estimates to observations</p></a></li>
<li><a href='#assign_tseg'><p>Add segment numbers to observations</p></a></li>
<li><a href='#assign_tseg_internal'><p>Internal function that adds segment numbers to observations</p></a></li>
<li><a href='#behav_gibbs_sampler'><p>Internal function that runs RJMCMC on a single animal ID</p></a></li>
<li><a href='#behav_seg_image'><p>Internal function that transforms a vector of bin numbers to a</p>
presence-absence matrix</a></li>
<li><a href='#cluster_obs'><p>Cluster observations into behavioral states</p></a></li>
<li><a href='#cluster_segments'><p>Cluster time segments into behavioral states</p></a></li>
<li><a href='#CumSumInv'><p>Internal function that calculates the inverted cumsum</p></a></li>
<li><a href='#df_to_list'><p>Convert data frame to a list by animal ID</p></a></li>
<li><a href='#discrete_move_var'><p>Discretize movement variables</p></a></li>
<li><a href='#expand_behavior'><p>Expand behavior estimates from track segments to observations</p></a></li>
<li><a href='#extract_prop'><p>Extract behavior proportion estimates for each track segment</p></a></li>
<li><a href='#filter_time'><p>Filter observations for time interval of interest</p></a></li>
<li><a href='#find_breaks'><p>Find changes for integer variable</p></a></li>
<li><a href='#get_behav_hist'><p>Extract bin estimates from Latent Dirichlet Allocation or mixture model</p></a></li>
<li><a href='#get_breakpts'><p>Extract breakpoints for each animal ID</p></a></li>
<li><a href='#get_MAP'><p>Find the maximum a posteriori (MAP) estimate of the MCMC chain</p></a></li>
<li><a href='#get_MAP_internal'><p>Internal function to find the maximum a posteriori (MAP) estimate of the MCMC</p>
chain</a></li>
<li><a href='#get_summary_stats'><p>Internal function that calculates the sufficient statistics for the</p>
segmentation model</a></li>
<li><a href='#get.llk.mixmod'><p>Internal function to calculate the log-likelihood for iteration of mixture model</p></a></li>
<li><a href='#get.theta'><p>Internal function to calculate theta parameter</p></a></li>
<li><a href='#insert_NAs'><p>Insert NA gaps to regularize a time series</p></a></li>
<li><a href='#log_marg_likel'><p>Internal function that calculates the log marginal likelihood of each model</p>
being compared</a></li>
<li><a href='#plot_breakpoints'><p>Plot breakpoints over a time series of each movement variable</p></a></li>
<li><a href='#plot_breakpoints_behav'><p>Internal function for plotting breakpoints over each of the data streams</p></a></li>
<li><a href='#prep_data'><p>Calculate step lengths, turning angles, net-squared displacement, and time</p>
steps</a></li>
<li><a href='#prep_data_internal'><p>Internal function to calculate step lengths, turning angles, and time steps</p></a></li>
<li><a href='#rmultinom1'><p>Internal function that samples z's from a categorical distribution</p></a></li>
<li><a href='#rmultinom2'><p>Internal function that samples z's from a multinomial distribution</p></a></li>
<li><a href='#round_track_time'><p>Round time to nearest interval</p></a></li>
<li><a href='#samp_move'><p>Internal function for the Gibbs sampler within the reversible-jump MCMC</p>
algorithm</a></li>
<li><a href='#sample.gamma.mixmod'><p>Internal function to sample the gamma hyperparameter</p></a></li>
<li><a href='#sample.phi'><p>Internal function to sample bin estimates for each movement variable</p></a></li>
<li><a href='#sample.phi.mixmod'><p>Internal function to sample bin estimates for each movement variable</p></a></li>
<li><a href='#sample.v'><p>Internal function to sample parameter for truncated stick-breaking prior</p></a></li>
<li><a href='#sample.v.mixmod'><p>Internal function to sample parameter for truncated stick-breaking prior</p></a></li>
<li><a href='#sample.z'><p>Internal function to sample latent clusters</p></a></li>
<li><a href='#sample.z.mixmod'><p>Internal function to sample latent clusters (for observations)</p></a></li>
<li><a href='#SampleZAgg'><p>Internal function that samples z1 aggregate</p></a></li>
<li><a href='#segment_behavior'><p>Segmentation model to estimate breakpoints</p></a></li>
<li><a href='#shiny_tracks'><p>Dynamically explore tracks within Shiny app</p></a></li>
<li><a href='#StoreZ'><p>This function helps store z from all iterations after burn in</p></a></li>
<li><a href='#summarize_tsegs'><p>Summarize observations within bins per track segment</p></a></li>
<li><a href='#summarize1'><p>Internal function that summarizes bin distributions of track segments</p></a></li>
<li><a href='#SummarizeDat'><p>Internal function that generates nmat matrix to help with multinomial draws</p></a></li>
<li><a href='#traceplot'><p>View trace-plots of output from Bayesian segmentation model</p></a></li>
<li><a href='#tracks'><p>Simulated set of three tracks.</p></a></li>
<li><a href='#tracks.list'><p>Tracks discretized and prepared for segmentation.</p></a></li>
<li><a href='#tracks.seg'><p>Segmented tracks for all IDs.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Parametric Bayesian Analyses of Animal Movement</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for assessing animal movement from telemetry and biologging
    data using non-parametric Bayesian methods. This includes features for pre-
    processing and analysis of data, as well as the visualization of results
    from the models. This framework does not rely on standard parametric density
    functions, which provides flexibility during model fitting. Further details 
    regarding part of this framework can be found in Cullen et al. (2021) &lt;<a href="https://doi.org/10.1101%2F2020.11.05.369702">doi:10.1101/2020.11.05.369702</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.3), furrr (&ge; 0.2.0), ggplot2 (&ge; 3.3.0),
lubridate (&ge; 1.7.4), MCMCpack (&ge; 1.4.5), progress (&ge; 1.2.2),
purrr (&ge; 0.3.3), Rcpp, rlang, tictoc (&ge; 1.0), tidyr (&ge;
1.0.0), magrittr, future (&ge; 1.15.1), progressr, shiny,
dygraphs (&ge; 1.1.0), leaflet (&ge; 2.0.0), sf (&ge; 0.9-6)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/joshcullen/bayesmove">https://github.com/joshcullen/bayesmove</a>,
<a href="https://joshcullen.github.io/bayesmove/">https://joshcullen.github.io/bayesmove/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/joshcullen/bayesmove/issues">https://github.com/joshcullen/bayesmove/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, spelling, knitr, rmarkdown, ggforce,
RcppArmadillo, xts, htmltools, shinythemes, DT, datamods,
viridis</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-21 23:08:21 UTC; joshcullen</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Cullen <a href="https://orcid.org/0000-0002-6935-9340"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Denis Valle [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua Cullen &lt;joshcullen10@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-22 08:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='assign_behavior'>Assign behavior estimates to observations</h2><span id='topic+assign_behavior'></span>

<h3>Description</h3>

<p>Assign behavior estimates to observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_behavior(dat.orig, dat.seg.list, theta.estim.long, behav.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_behavior_+3A_dat.orig">dat.orig</code></td>
<td>
<p>A data frame that contains all of the original data for all
animal IDs. Must be same as was used to originally segment the tracks. Must
have columns <code>obs</code> and <code>time1</code> generated by
<code><a href="#topic+filter_time">filter_time</a></code>.</p>
</td></tr>
<tr><td><code id="assign_behavior_+3A_dat.seg.list">dat.seg.list</code></td>
<td>
<p>A list of data associated with each animal ID where names
of list elements are the ID names and tracks have already been segmented.
Must have columns <code>obs</code> and <code>time1</code> generated by
<code><a href="#topic+filter_time">filter_time</a></code>.</p>
</td></tr>
<tr><td><code id="assign_behavior_+3A_theta.estim.long">theta.estim.long</code></td>
<td>
<p>A data frame in long format where each observation
(<em>time1</em>) of each track segment (<em>tseg</em>) of each animal ID
(<em>id</em>) has separate rows for behavior proportion estimates per state.
Columns for behavior and proportion estimates should be labeled
<em>behavior</em> and <em>prop</em>, respectively. Date (in POSIXct format)
should also be included as a column labeled <em>date</em>.</p>
</td></tr>
<tr><td><code id="assign_behavior_+3A_behav.names">behav.names</code></td>
<td>
<p>character. A vector of names to label each state (in
order).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of all animal IDs where columns (with names from
<code>behav.names</code>) include proportions of each behavioral state per
observation, as well as a column that stores the dominant behavior within a
given track segment for which the observation belongs (<code>behav</code>). This
is merged with the original data frame <code>dat.orig</code>, so any observations
that were excluded (not at primary time interval) will show <code>NA</code> for
behavior estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#load original and segmented data
data(tracks)
data(tracks.seg)

#convert segmented dataset into list
tracks.list&lt;- df_to_list(dat = tracks.seg, ind = "id")

#select only id, tseg, SL, and TA columns
tracks.seg2&lt;- tracks.seg[,c("id","tseg","SL","TA")]

#summarize data by track segment
obs&lt;- summarize_tsegs(dat = tracks.seg2, nbins = c(5,8))

#cluster data with LDA
res&lt;- cluster_segments(dat = obs, gamma1 = 0.1, alpha = 0.1, ngibbs = 1000,
                       nburn = 500, nmaxclust = 7, ndata.types = 2)

#Extract proportions of behaviors per track segment
theta.estim&lt;- extract_prop(res = res, ngibbs = 1000, nburn = 500, nmaxclust = 7)

#Create augmented matrix by replicating rows (tsegs) according to obs per tseg
theta.estim.long&lt;- expand_behavior(dat = tracks.seg, theta.estim = theta.estim, obs = obs,
                               nbehav = 3, behav.names = c("Encamped","ARS","Transit"),
                               behav.order = c(1,2,3))

#Run function
dat.out&lt;- assign_behavior(dat.orig = tracks, dat.seg.list = tracks.list,
                          theta.estim.long = theta.estim.long,
                          behav.names = c("Encamped","ARS","Transit"))



</code></pre>

<hr>
<h2 id='assign_tseg'>Add segment numbers to observations</h2><span id='topic+assign_tseg'></span>

<h3>Description</h3>

<p>After breakpoints have been extracted for each animal ID, this function
assigns the associated segment number to observations for each animal ID.
These segments of observations will be used in the second stage of the model
framework to perform mixed-membership clustering by Latent Dirichlet
Allocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_tseg(dat, brkpts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_tseg_+3A_dat">dat</code></td>
<td>
<p>A list where each element stores the data for a unique animal ID.
Each element is a data frame that contains all data associated for a given
animal ID and must include a column labeled <code>time1</code> that numbers each
of the observations in consecutive order. This variable is automatically
generated by the <code><a href="#topic+filter_time">filter_time</a></code> function during data
preparation.</p>
</td></tr>
<tr><td><code id="assign_tseg_+3A_brkpts">brkpts</code></td>
<td>
<p>A data frame of breakpoints for each animal ID (as generated by
<code><a href="#topic+get_breakpts">get_breakpts</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that updates the original data object by including the
segment number associated with each observation in relation to the
extracted breakpoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load data
data(tracks.list)

#subset only first track
tracks.list&lt;- tracks.list[1]

#only retain id and discretized step length (SL) and turning angle (TA) columns
tracks.list2&lt;- purrr::map(tracks.list,
                   subset,
                  select = c(id, SL, TA))


set.seed(1)

# Define model params
alpha&lt;- 1
ngibbs&lt;- 1000
nbins&lt;- c(5,8)

#future::plan(future::multisession)  #run all MCMC chains in parallel
dat.res&lt;- segment_behavior(data = tracks.list2, ngibbs = ngibbs, nbins = nbins,
                           alpha = alpha)


# Determine MAP iteration for selecting breakpoints and store breakpoints
MAP.est&lt;- get_MAP(dat = dat.res$LML, nburn = ngibbs/2)
brkpts&lt;- get_breakpts(dat = dat.res$brkpts, MAP.est = MAP.est)


# Assign track segments to all observations by ID
tracks.seg&lt;- assign_tseg(dat = tracks.list, brkpts = brkpts)


</code></pre>

<hr>
<h2 id='assign_tseg_internal'>Internal function that adds segment numbers to observations</h2><span id='topic+assign_tseg_internal'></span>

<h3>Description</h3>

<p>After breakpoints have been extracted for each animal ID, this function
assigns the associated segment number to observations for each animal ID.
These segments of observations will be used in the second stage of the model
framework to perform mixed-membership clustering by Latent Dirichlet
Allocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_tseg_internal(dat, brkpts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_tseg_internal_+3A_dat">dat</code></td>
<td>
<p>A data frame that contains all data associated for a given animal
ID. Must include a column labeled <code>time1</code> that numbers each of the
observations in consecutive order, which is automatically generated by
<code><a href="#topic+filter_time">filter_time</a></code>.</p>
</td></tr>
<tr><td><code id="assign_tseg_internal_+3A_brkpts">brkpts</code></td>
<td>
<p>A data frame of breakpoints for each animal ID (as generated by
<code><a href="#topic+get_breakpts">get_breakpts</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that updates the original data object by including the
segment number associated with each observation in relation to the extracted
breakpoints.
</p>

<hr>
<h2 id='behav_gibbs_sampler'>Internal function that runs RJMCMC on a single animal ID</h2><span id='topic+behav_gibbs_sampler'></span>

<h3>Description</h3>

<p>This function serves as a wrapper for <code><a href="#topic+samp_move">samp_move</a></code> by running this
sampler for each iteration of the MCMC chain. It is called by
<code><a href="#topic+segment_behavior">segment_behavior</a></code> to run the RJMCMC on all animal IDs
simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>behav_gibbs_sampler(dat, ngibbs, nbins, alpha, breakpt, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="behav_gibbs_sampler_+3A_dat">dat</code></td>
<td>
<p>A data frame that only contains columns for the animal IDs and for
each of the discretized movement variables.</p>
</td></tr>
<tr><td><code id="behav_gibbs_sampler_+3A_ngibbs">ngibbs</code></td>
<td>
<p>numeric. The total number of iterations of the MCMC chain.</p>
</td></tr>
<tr><td><code id="behav_gibbs_sampler_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
movement variable. These must be in the same order as the columns within
<code>dat</code>.</p>
</td></tr>
<tr><td><code id="behav_gibbs_sampler_+3A_alpha">alpha</code></td>
<td>
<p>numeric. A single value used to specify the hyperparameter for
the prior distribution. A standard value for <code>alpha</code> is typically 1,
which corresponds with a vague prior on the Dirichlet distribution.</p>
</td></tr>
<tr><td><code id="behav_gibbs_sampler_+3A_breakpt">breakpt</code></td>
<td>
<p>numeric. A vector of breakpoints if pre-specifying where they
may occur, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="behav_gibbs_sampler_+3A_p">p</code></td>
<td>
<p>An object storing information from
<code>progressr::progessor</code> to produce a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the breakpoints, the number of breakpoints, and the log
marginal likelihood at each MCMC iteration, as well as the time it took the
model to finish running. This is only provided for the data of a single
animal ID.
</p>

<hr>
<h2 id='behav_seg_image'>Internal function that transforms a vector of bin numbers to a
presence-absence matrix</h2><span id='topic+behav_seg_image'></span>

<h3>Description</h3>

<p>Transforms vectors of bin numbers into full matrices for plotting as a
heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>behav_seg_image(dat, nbins)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="behav_seg_image_+3A_dat">dat</code></td>
<td>
<p>A data frame for a single animal ID that contains only columns for
the ID and each of the movement variables that were analyzed by
<code><a href="#topic+segment_behavior">segment_behavior</a></code>. The ID column must be first.</p>
</td></tr>
<tr><td><code id="behav_seg_image_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
movement variable. These must be in the same order as the columns within
<code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element stores the presence-absence matrix for each
of the movement variables.
</p>

<hr>
<h2 id='cluster_obs'>Cluster observations into behavioral states</h2><span id='topic+cluster_obs'></span>

<h3>Description</h3>

<p>This function uses a Gibbs sampler within a mixture model to estimate the
optimal number of behavioral states, the state-dependent distributions, and
to assign behavioral states to each observation. This model does not assume
an underlying mechanistic process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_obs(dat, alpha, ngibbs, nmaxclust, nburn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_obs_+3A_dat">dat</code></td>
<td>
<p>A data frame that **only** contains columns for the discretized
movement variables.</p>
</td></tr>
<tr><td><code id="cluster_obs_+3A_alpha">alpha</code></td>
<td>
<p>numeric. A single value used to specify the hyperparameter for
the prior distribution.</p>
</td></tr>
<tr><td><code id="cluster_obs_+3A_ngibbs">ngibbs</code></td>
<td>
<p>numeric. The total number of iterations of the MCMC chain.</p>
</td></tr>
<tr><td><code id="cluster_obs_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
<tr><td><code id="cluster_obs_+3A_nburn">nburn</code></td>
<td>
<p>numeric. The length of the burn-in phase.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mixture model analyzes all animal IDs pooled together, thus providing a
population-level estimate of behavioral states.
</p>


<h3>Value</h3>

<p>A list of model results is returned where elements include the
<code>phi</code> matrix for each data stream, <code>theta</code> matrix, log likelihood
estimates for each iteration of the MCMC chain <code>loglikel</code>, a list of
the MAP estimates of the latent states for each observation <code>z.MAP</code>, a
matrix of the whole posterior of state assignments per observation
<code>z.posterior</code>, and a vector <code>gamma1</code> of estimates for the gamma
hyperparameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(tracks.list)

#convert from list to data frame
tracks.list&lt;- dplyr::bind_rows(tracks.list)

#only retain id and discretized step length (SL) and turning angle (TA) columns
tracks&lt;- subset(tracks.list, select = c(SL, TA))


set.seed(1)

# Define model params
alpha=0.1
ngibbs=1000
nburn=ngibbs/2
nmaxclust=7

dat.res&lt;- cluster_obs(dat = tracks, alpha = alpha, ngibbs = ngibbs,
                           nmaxclust = nmaxclust, nburn = nburn)


</code></pre>

<hr>
<h2 id='cluster_segments'>Cluster time segments into behavioral states</h2><span id='topic+cluster_segments'></span>

<h3>Description</h3>

<p>This function performs a Gibbs sampler within the Latent Dirichlet Allocation
(LDA) model to estimate proportions of each behavioral state for all time
segments generated by <code><a href="#topic+segment_behavior">segment_behavior</a></code>. This is the second
stage of the two-stage Bayesian model that estimates proportions of
behavioral states by first segmenting individual tracks into relatively
homogeneous segments of movement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_segments(dat, gamma1, alpha, ngibbs, nmaxclust, nburn, ndata.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_segments_+3A_dat">dat</code></td>
<td>
<p>A data frame returned by <code><a href="#topic+summarize_tsegs">summarize_tsegs</a></code> that
summarizes the counts of observations per bin and movement variable for all
animal IDs.</p>
</td></tr>
<tr><td><code id="cluster_segments_+3A_gamma1">gamma1</code></td>
<td>
<p>numeric. A hyperparameter for the truncated stick-breaking
prior for estimating the <code>theta</code> matrix.</p>
</td></tr>
<tr><td><code id="cluster_segments_+3A_alpha">alpha</code></td>
<td>
<p>numeric. A hyperparameter for the Dirichlet distribution when
estimating the <code>phi</code> matrix.</p>
</td></tr>
<tr><td><code id="cluster_segments_+3A_ngibbs">ngibbs</code></td>
<td>
<p>numeric. The total number of iterations of the MCMC chain.</p>
</td></tr>
<tr><td><code id="cluster_segments_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
<tr><td><code id="cluster_segments_+3A_nburn">nburn</code></td>
<td>
<p>numeric. The length of the burn-in phase.</p>
</td></tr>
<tr><td><code id="cluster_segments_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize
each movement variable. These must be in the same order as the columns
within <code>dat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LDA model analyzes all animal IDs pooled together, thereby providing
population-level estimates of behavioral states.
</p>


<h3>Value</h3>

<p>A list of model results is returned where elements include the
<code>phi</code> matrix for each data stream, <code>theta</code> matrix, log likelihood
estimates for each iteration of the MCMC chain <code>loglikel</code>, and
matrices of the latent cluster estimates for each data stream <code>z.agg</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load data
data(tracks.seg)

#select only id, tseg, SL, and TA columns
tracks.seg2&lt;- tracks.seg[,c("id","tseg","SL","TA")]

#summarize data by track segment
obs&lt;- summarize_tsegs(dat = tracks.seg2, nbins = c(5,8))

#cluster data with LDA
res&lt;- cluster_segments(dat = obs, gamma1 = 0.1, alpha = 0.1, ngibbs = 1000,
                       nburn = 500, nmaxclust = 7, ndata.types = 2)


</code></pre>

<hr>
<h2 id='CumSumInv'>Internal function that calculates the inverted cumsum</h2><span id='topic+CumSumInv'></span>

<h3>Description</h3>

<p>Internal function that calculates the inverted cumsum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CumSumInv(ntsegm, nmaxclust, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CumSumInv_+3A_ntsegm">ntsegm</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="CumSumInv_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="CumSumInv_+3A_z">z</code></td>
<td>
<p>An integer matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='df_to_list'>Convert data frame to a list by animal ID</h2><span id='topic+df_to_list'></span>

<h3>Description</h3>

<p>Converts an object of class <code>data.frame</code> to a list where each element is
a separate animal ID. This function prepares the data for further analysis
and when mapping other functions onto the data for separate animal IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_to_list(dat, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_to_list_+3A_dat">dat</code></td>
<td>
<p>A data frame containing the data for each animal ID.</p>
</td></tr>
<tr><td><code id="df_to_list_+3A_ind">ind</code></td>
<td>
<p>character. The name of the column storing the animal IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element stores the data for a separate animal ID.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data
data(tracks)

#convert to list
dat.list&lt;- df_to_list(dat = tracks, ind = "id")


</code></pre>

<hr>
<h2 id='discrete_move_var'>Discretize movement variables</h2><span id='topic+discrete_move_var'></span>

<h3>Description</h3>

<p>Convert movement variables from continuous to discrete values for analysis by
<code><a href="#topic+segment_behavior">segment_behavior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete_move_var(dat, lims, varIn, varOut)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete_move_var_+3A_dat">dat</code></td>
<td>
<p>A data frame that contains the variable(s) of interest to convert
from continuous to discrete values.</p>
</td></tr>
<tr><td><code id="discrete_move_var_+3A_lims">lims</code></td>
<td>
<p>A list of the bin limits for each variable. Each element of the
list should be a vector of real numbers.</p>
</td></tr>
<tr><td><code id="discrete_move_var_+3A_varin">varIn</code></td>
<td>
<p>A vector of names for the continuous variable stored as columns
within <code>dat</code>.</p>
</td></tr>
<tr><td><code id="discrete_move_var_+3A_varout">varOut</code></td>
<td>
<p>A vector of names for the storage of the discrete variables
returned by the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with new columns of discretized variables as labeled by
<code>varOut</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data
data(tracks)

#subset only first track
tracks&lt;- tracks[tracks$id == "id1",]

#calculate step lengths and turning angles
tracks&lt;- prep_data(dat = tracks, coord.names = c("x","y"), id = "id")

#round times to nearest interval of interest (e.g. 3600 s or 1 hr)
tracks&lt;- round_track_time(dat = tracks, id = "id", int = 3600, tol = 180, time.zone = "UTC",
                                 units = "secs")

#create list from data frame
tracks.list&lt;- df_to_list(dat = tracks, ind = "id")

#filter observations to only 1 hr (or 3600 s)
tracks_filt.list&lt;- filter_time(dat.list = tracks.list, int = 3600)

#define bin number and limits for turning angles and step lengths
angle.bin.lims=seq(from=-pi, to=pi, by=pi/4)  #8 bins
dist.bin.lims=quantile(tracks[tracks$dt == 3600,]$step,
                      c(0,0.25,0.50,0.75,0.90,1), na.rm=TRUE)  #5 bins


# Assign bins to observations
tracks_disc.list&lt;- purrr::map(tracks_filt.list,
                      discrete_move_var,
                      lims = list(dist.bin.lims, angle.bin.lims),
                      varIn = c("step", "angle"),
                      varOut = c("SL", "TA"))


</code></pre>

<hr>
<h2 id='expand_behavior'>Expand behavior estimates from track segments to observations</h2><span id='topic+expand_behavior'></span>

<h3>Description</h3>

<p>Expand behavior estimates from track segments to observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_behavior(dat, theta.estim, obs, nbehav, behav.names, behav.order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_behavior_+3A_dat">dat</code></td>
<td>
<p>A data frame of the animal ID, track segment labels, and all other
data per observation. Animal ID, date, track segment, and observation
number columns must be labeled <em>id</em>, <em>date</em>, <em>tseg</em>, and
<em>time1</em>, respectively.</p>
</td></tr>
<tr><td><code id="expand_behavior_+3A_theta.estim">theta.estim</code></td>
<td>
<p>A matrix (returned by <code><a href="#topic+extract_prop">extract_prop</a></code>)
containing the proportions of each behavioral state as separate columns for
each track segment (rows).</p>
</td></tr>
<tr><td><code id="expand_behavior_+3A_obs">obs</code></td>
<td>
<p>A data frame summarizing the number of observations within each
bin per movement variable that is returned by
<code><a href="#topic+summarize_tsegs">summarize_tsegs</a></code>.</p>
</td></tr>
<tr><td><code id="expand_behavior_+3A_nbehav">nbehav</code></td>
<td>
<p>numeric. The number of behavioral states that will be retained
in 1 to nmaxclust.</p>
</td></tr>
<tr><td><code id="expand_behavior_+3A_behav.names">behav.names</code></td>
<td>
<p>character. A vector of names to label each state (in
order).</p>
</td></tr>
<tr><td><code id="expand_behavior_+3A_behav.order">behav.order</code></td>
<td>
<p>numeric. A vector that identifies the order in which the
user would like to rearrange the behavioral states. If satisfied with order
returned by the LDA model, this still must be specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new data frame that expands behavior proportions for each
observation within all track segments, including the columns labeled
<em>time1</em> and <em>date</em> from the original <code>dat</code> data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#load data
data(tracks.seg)

#select only id, tseg, SL, and TA columns
tracks.seg2&lt;- tracks.seg[,c("id","tseg","SL","TA")]

#summarize data by track segment
obs&lt;- summarize_tsegs(dat = tracks.seg2, nbins = c(5,8))

#cluster data with LDA
res&lt;- cluster_segments(dat = obs, gamma1 = 0.1, alpha = 0.1, ngibbs = 1000,
                       nburn = 500, nmaxclust = 7, ndata.types = 2)

#Extract proportions of behaviors per track segment
theta.estim&lt;- extract_prop(res = res, ngibbs = 1000, nburn = 500, nmaxclust = 7)

#Create augmented matrix by replicating rows (tsegs) according to obs per tseg
theta.estim.long&lt;- expand_behavior(dat = tracks.seg, theta.estim = theta.estim, obs = obs,
                               nbehav = 3, behav.names = c("Encamped","ARS","Transit"),
                               behav.order = c(1,2,3))



</code></pre>

<hr>
<h2 id='extract_prop'>Extract behavior proportion estimates for each track segment</h2><span id='topic+extract_prop'></span>

<h3>Description</h3>

<p>Calculates the mean of the posterior for the proportions of each behavior
within track segments. These results can be explored to determine the optimal
number of latent behavioral states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_prop(res, ngibbs, nburn, nmaxclust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_prop_+3A_res">res</code></td>
<td>
<p>A list of results returned by <code><a href="#topic+cluster_segments">cluster_segments</a></code>.
Element <code>theta</code> stores estimate for behavior proportions for all time
segments.</p>
</td></tr>
<tr><td><code id="extract_prop_+3A_ngibbs">ngibbs</code></td>
<td>
<p>numeric. The total number of iterations of the MCMC chain.</p>
</td></tr>
<tr><td><code id="extract_prop_+3A_nburn">nburn</code></td>
<td>
<p>numeric. The length of the burn-in phase.</p>
</td></tr>
<tr><td><code id="extract_prop_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that stores the proportions of each state/cluster (columns)
per track segment (rows).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#load data
data(tracks.seg)

#select only id, tseg, SL, and TA columns
tracks.seg2&lt;- tracks.seg[,c("id","tseg","SL","TA")]

#summarize data by track segment
obs&lt;- summarize_tsegs(dat = tracks.seg2, nbins = c(5,8))

#cluster data with LDA
res&lt;- cluster_segments(dat = obs, gamma1 = 0.1, alpha = 0.1, ngibbs = 1000,
                       nburn = 500, nmaxclust = 7, ndata.types = 2)

#Extract proportions of behaviors per track segment
theta.estim&lt;- extract_prop(res = res, ngibbs = 1000, nburn = 500, nmaxclust = 7)



</code></pre>

<hr>
<h2 id='filter_time'>Filter observations for time interval of interest</h2><span id='topic+filter_time'></span>

<h3>Description</h3>

<p>Selects observations that belong to the time interval of interest and removes
all others. This function also removes entire IDs from the dataset when there
is one or fewer observations at this time interval. This function works
closely with <code><a href="#topic+round_track_time">round_track_time</a></code> to only retain observations
sampled at a regular time interval, which is important for analyzing step
lengths and turning angles. Column storing the time intervals must be labeled
<code>dt</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_time(dat.list, int)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_time_+3A_dat.list">dat.list</code></td>
<td>
<p>A list of data associated with each animal ID where names of
list elements are the ID names.</p>
</td></tr>
<tr><td><code id="filter_time_+3A_int">int</code></td>
<td>
<p>numeric. The time interval of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where observations for each animal ID (element) has been
filtered for <code>int</code>. Two columns (<code>obs</code> and <code>time1</code>) are
added for each list element (ID), which store the original observation
number before filtering and the new observation number after filtering,
respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data
data(tracks)

#subset only first track
tracks&lt;- tracks[tracks$id == "id1",]

#calculate step lengths and turning angles
tracks&lt;- prep_data(dat = tracks, coord.names = c("x","y"), id = "id")

#round times to nearest interval of interest (e.g. 3600 s or 1 hr)
tracks&lt;- round_track_time(dat = tracks, id = "id", int = 3600, tol = 180, time.zone = "UTC",
                              units = "secs")

#create list from data frame
tracks.list&lt;- df_to_list(dat = tracks, ind = "id")

#filter observations to only 1 hr (or 3600 s)
tracks_filt.list&lt;- filter_time(dat.list = tracks.list, int = 3600)

</code></pre>

<hr>
<h2 id='find_breaks'>Find changes for integer variable</h2><span id='topic+find_breaks'></span>

<h3>Description</h3>

<p>Identify changes within a discrete variable. These values can be used to
pre-specify breakpoints within the segmentation model using
<code><a href="#topic+segment_behavior">segment_behavior</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_breaks(dat, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_breaks_+3A_dat">dat</code></td>
<td>
<p>A data frame containing the data for each animal ID.</p>
</td></tr>
<tr><td><code id="find_breaks_+3A_ind">ind</code></td>
<td>
<p>character. The name of the column storing the discrete variable of
interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of breakpoints is returned based on the data provided. If
wishing to identify separate breakpoints per animal ID, this function
should be mapped onto a list generated by <code><a href="#topic+df_to_list">df_to_list</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#simuluate data
var&lt;- sample(1:3, size = 50, replace = TRUE)
var&lt;- rep(var, each = 20)
id&lt;- rep(1:10, each = 100)

#create data frame
dat&lt;- data.frame(id, var)

#create list
dat.list&lt;- df_to_list(dat = dat, ind = "id")

#run function using purrr::map()
breaks&lt;- purrr::map(dat.list, ~find_breaks(dat = ., ind = "var"))

#or with lapply()
breaks1&lt;- lapply(dat.list, find_breaks, ind = "var")

</code></pre>

<hr>
<h2 id='get_behav_hist'>Extract bin estimates from Latent Dirichlet Allocation or mixture model</h2><span id='topic+get_behav_hist'></span>

<h3>Description</h3>

<p>Pulls model results for the estimates of bin proportions per movement
variable from the posterior distribution. This can be used for visualization
of movement variable distribution for each behavior estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_behav_hist(dat, nburn, ngibbs, nmaxclust, var.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_behav_hist_+3A_dat">dat</code></td>
<td>
<p>The list object returned by the LDA model
(<code><a href="#topic+cluster_segments">cluster_segments</a></code>) or mixture model
(<code><a href="#topic+cluster_obs">cluster_obs</a></code>). Used for extracting the element <em>phi</em>.</p>
</td></tr>
<tr><td><code id="get_behav_hist_+3A_nburn">nburn</code></td>
<td>
<p>numeric. The length of the burn-in phase.</p>
</td></tr>
<tr><td><code id="get_behav_hist_+3A_ngibbs">ngibbs</code></td>
<td>
<p>numeric. The total number of iterations of the MCMC chain.</p>
</td></tr>
<tr><td><code id="get_behav_hist_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. The maximum number of clusters on which to
attribute behaviors.</p>
</td></tr>
<tr><td><code id="get_behav_hist_+3A_var.names">var.names</code></td>
<td>
<p>character. A vector of names used for each of the movement
variables. Must be in the same order as were listed within the data frame
returned by <code><a href="#topic+summarize_tsegs">summarize_tsegs</a></code> (if running LDA model).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that contains columns for bin number, behavioral state,
proportion represented by a given bin, and movement variable name. This is
displayed in a long format, which is easier to visualize using
<code>ggplot2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#load data
data(tracks.seg)

#select only id, tseg, SL, and TA columns
tracks.seg2&lt;- tracks.seg[,c("id","tseg","SL","TA")]

#summarize data by track segment
obs&lt;- summarize_tsegs(dat = tracks.seg2, nbins = c(5,8))

#cluster data with LDA
res&lt;- cluster_segments(dat = obs, gamma1 = 0.1, alpha = 0.1, ngibbs = 1000,
                       nburn = 500, nmaxclust = 7, ndata.types = 2)

#Extract proportions of behaviors per track segment
theta.estim&lt;- extract_prop(res = res, ngibbs = 1000, nburn = 500, nmaxclust = 7)

#run function for clustered segments
behav.res&lt;- get_behav_hist(dat = res, nburn = 500, ngibbs = 1000, nmaxclust = 7,
                           var.names = c("Step Length","Turning Angle"))


</code></pre>

<hr>
<h2 id='get_breakpts'>Extract breakpoints for each animal ID</h2><span id='topic+get_breakpts'></span>

<h3>Description</h3>

<p>Extract breakpoints for each animal ID
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_breakpts(dat, MAP.est)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_breakpts_+3A_dat">dat</code></td>
<td>
<p>A list of lists where animal IDs are separated as well as the
breakpoints estimated for each iteration of the MCMC chain. This is stored
within <code>breakpts</code> of model results returned after running
<code><a href="#topic+segment_behavior">segment_behavior</a></code>.</p>
</td></tr>
<tr><td><code id="get_breakpts_+3A_map.est">MAP.est</code></td>
<td>
<p>numeric. A vector of values at which the maximum a posteriori
(MAP) estimate was identified for each of the animal IDs as returned by
<code><a href="#topic+get_MAP">get_MAP</a></code>. These must be in the same order as the data for the
IDs supplied to <code>segment_behavior()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where breakpoints are returned per animal ID within each
row. For animal IDs that have fewer breakpoints than the maximum number
that were estimated, <code>NA</code> values are used as place holders for these
breakpoints that do not exist.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load data
data(tracks.list)

#subset only first track
tracks.list&lt;- tracks.list[1]

#only retain id and discretized step length (SL) and turning angle (TA) columns
tracks.list2&lt;- purrr::map(tracks.list,
                   subset,
                  select = c(id, SL, TA))


set.seed(1)

# Define model params
alpha&lt;- 1
ngibbs&lt;- 1000
nbins&lt;- c(5,8)

#future::plan(future::multisession)  #run all MCMC chains in parallel
dat.res&lt;- segment_behavior(data = tracks.list2, ngibbs = ngibbs, nbins = nbins,
                           alpha = alpha)


# Determine MAP iteration for selecting breakpoints and store breakpoints
MAP.est&lt;- get_MAP(dat = dat.res$LML, nburn = ngibbs/2)
brkpts&lt;- get_breakpts(dat = dat.res$brkpts, MAP.est = MAP.est)


</code></pre>

<hr>
<h2 id='get_MAP'>Find the maximum a posteriori (MAP) estimate of the MCMC chain</h2><span id='topic+get_MAP'></span>

<h3>Description</h3>

<p>Identify the MCMC iteration that holds the MAP estimate. This will be used to
inform <code><a href="#topic+get_breakpts">get_breakpts</a></code> as to which breakpoints should be retained
on which to assign track segments to the observations of each animal ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_MAP(dat, nburn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_MAP_+3A_dat">dat</code></td>
<td>
<p>A data frame where each row holds the log marginal likelihood
values at each iteration of the MCMC chain.</p>
</td></tr>
<tr><td><code id="get_MAP_+3A_nburn">nburn</code></td>
<td>
<p>numeric. The size of the burn-in phase after which the MAP
estimate will be identified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of iterations at which the MAP estimate was found
for each animal ID.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load data
data(tracks.list)

#subset only first track
tracks.list&lt;- tracks.list[1]

#only retain id and discretized step length (SL) and turning angle (TA) columns
tracks.list2&lt;- purrr::map(tracks.list,
                   subset,
                  select = c(id, SL, TA))


set.seed(1)

# Define model params
alpha&lt;- 1
ngibbs&lt;- 1000
nbins&lt;- c(5,8)

#future::plan(future::multisession)  #run all MCMC chains in parallel
dat.res&lt;- segment_behavior(data = tracks.list2, ngibbs = ngibbs, nbins = nbins,
                           alpha = alpha)


# Determine MAP iteration for selecting breakpoints and store breakpoints
MAP.est&lt;- get_MAP(dat = dat.res$LML, nburn = ngibbs/2)


</code></pre>

<hr>
<h2 id='get_MAP_internal'>Internal function to find the maximum a posteriori (MAP) estimate of the MCMC
chain</h2><span id='topic+get_MAP_internal'></span>

<h3>Description</h3>

<p>Internal function to be used by a wrapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_MAP_internal(dat, nburn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_MAP_internal_+3A_dat">dat</code></td>
<td>
<p>numeric. A vector of log marginal likelihood values for a given
animal ID.</p>
</td></tr>
<tr><td><code id="get_MAP_internal_+3A_nburn">nburn</code></td>
<td>
<p>numeric. The size of the burn-in phase after which the MAP
estimate will be identified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value indicating the iteration after the burn-in phase that
holds the MAP estimate.
</p>

<hr>
<h2 id='get_summary_stats'>Internal function that calculates the sufficient statistics for the
segmentation model</h2><span id='topic+get_summary_stats'></span>

<h3>Description</h3>

<p>An internal function that calculates the sufficient statistics to be used
within the reversible-jump MCMC Gibbs sampler called by
<code>link{samp_move}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_summary_stats(breakpt, dat, max.time, nbins, ndata.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_summary_stats_+3A_breakpt">breakpt</code></td>
<td>
<p>numeric. A vector of breakpoints.</p>
</td></tr>
<tr><td><code id="get_summary_stats_+3A_dat">dat</code></td>
<td>
<p>A matrix that only contains columns storing discretized data for
each of the movement variables.</p>
</td></tr>
<tr><td><code id="get_summary_stats_+3A_max.time">max.time</code></td>
<td>
<p>numeric. The number of of the last observation of <code>dat</code>.</p>
</td></tr>
<tr><td><code id="get_summary_stats_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
movement variable. These must be in the same order as the columns within
<code>dat</code>.</p>
</td></tr>
<tr><td><code id="get_summary_stats_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. The length of <code>nbins</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the sufficient statistics associated with the provided
breakpoints for a given animal ID.
</p>

<hr>
<h2 id='get.llk.mixmod'>Internal function to calculate the log-likelihood for iteration of mixture model</h2><span id='topic+get.llk.mixmod'></span>

<h3>Description</h3>

<p>Calculates the log-likelihood of the mixture model based on estimates for
<em>theta</em> and <em>phi</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.llk.mixmod(phi, theta, ndata.types, dat, nobs, nmaxclust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.llk.mixmod_+3A_phi">phi</code></td>
<td>
<p>A list of proportion estimates that characterize distributions
(bins) for each data stream and possible behavioral state.</p>
</td></tr>
<tr><td><code id="get.llk.mixmod_+3A_theta">theta</code></td>
<td>
<p>numeric. A vector of values that sum to one.</p>
</td></tr>
<tr><td><code id="get.llk.mixmod_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. The number of data streams being analyzed.</p>
</td></tr>
<tr><td><code id="get.llk.mixmod_+3A_dat">dat</code></td>
<td>
<p>A data frame containing only columns of the discretized data
streams for all observations.</p>
</td></tr>
<tr><td><code id="get.llk.mixmod_+3A_nobs">nobs</code></td>
<td>
<p>numeric. The total number of rows in the dataset.</p>
</td></tr>
<tr><td><code id="get.llk.mixmod_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of the log-likelihood based upon the current values
for <em>phi</em> and <em>theta</em>.
</p>

<hr>
<h2 id='get.theta'>Internal function to calculate theta parameter</h2><span id='topic+get.theta'></span>

<h3>Description</h3>

<p>Calculates values of <em>theta</em> matrix within Gibbs sampler. Not for calling
directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.theta(v, nmaxclust, ntsegm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.theta_+3A_v">v</code></td>
<td>
<p>A matrix returned by <code><a href="#topic+sample.v">sample.v</a></code></p>
</td></tr>
<tr><td><code id="get.theta_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
<tr><td><code id="get.theta_+3A_ntsegm">ntsegm</code></td>
<td>
<p>numeric. The total number of time segments from all animal IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of proportion estimates that represent proportions of
different behavioral states per time segment.
</p>

<hr>
<h2 id='insert_NAs'>Insert NA gaps to regularize a time series</h2><span id='topic+insert_NAs'></span>

<h3>Description</h3>

<p>Insert NA gaps to regularize a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_NAs(data, int, units)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insert_NAs_+3A_data">data</code></td>
<td>
<p>A data frame that minimally contains columns for animal ID, date,
and time step. These must be labeled <code>id</code>, <code>date</code>, and <code>dt</code>,
respectively, where date is of class <code>POSIXct</code>.</p>
</td></tr>
<tr><td><code id="insert_NAs_+3A_int">int</code></td>
<td>
<p>integer. An integer that characterizes the desired interval on
which to insert new rows.</p>
</td></tr>
<tr><td><code id="insert_NAs_+3A_units">units</code></td>
<td>
<p>character. The units of the selected time interval <code>int</code>,
which can be selected from one of &quot;secs&quot;, &quot;mins&quot;, &quot;hours&quot;, &quot;days&quot;, or
&quot;weeks&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where new rows have been inserted to regularize the <code>date</code> column. This results in values provided for <code>id</code>, <code>date</code>, and dt while inserting NAs for all other columns. Additionally, observations with duplicate date-times are removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data
data(tracks)

#remove rows to show how function works (create irregular time series)
set.seed(1)
ind&lt;- sort(sample(2:15003, 500))

tracks.red&lt;- tracks[-ind,]

#calculate step lengths, turning angles, net-squared displacement, and time steps
tracks.red&lt;- prep_data(dat = tracks.red, coord.names = c("x","y"), id = "id")

#round times to nearest interval
tracks.red&lt;- round_track_time(dat = tracks.red, id = "id", int = c(3600, 7200, 10800, 14400),
                              tol = 300, units = "secs")

#insert NA gaps
dat.out&lt;- insert_NAs(tracks.red, int = 3600, units = "secs")


</code></pre>

<hr>
<h2 id='log_marg_likel'>Internal function that calculates the log marginal likelihood of each model
being compared</h2><span id='topic+log_marg_likel'></span>

<h3>Description</h3>

<p>An internal function that is used to calculate the log marginal likelihood of
models for the current and proposed sets of breakpoints. Called within
<code><a href="#topic+samp_move">samp_move</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_marg_likel(alpha, summary.stats, nbins, ndata.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_marg_likel_+3A_alpha">alpha</code></td>
<td>
<p>numeric. A single value used to specify the hyperparameter for
the prior distribution. A standard value for <code>alpha</code> is typically 1,
which corresponds with a vague prior on the Dirichlet distribution.</p>
</td></tr>
<tr><td><code id="log_marg_likel_+3A_summary.stats">summary.stats</code></td>
<td>
<p>A matrix of sufficient statistics returned from
<code><a href="#topic+get_summary_stats">get_summary_stats</a></code>.</p>
</td></tr>
<tr><td><code id="log_marg_likel_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
movement variable.</p>
</td></tr>
<tr><td><code id="log_marg_likel_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. The length of <code>nbins</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log marginal likelihood is calculated for a model with a given
set of breakpoints and the discretized data.
</p>

<hr>
<h2 id='plot_breakpoints'>Plot breakpoints over a time series of each movement variable</h2><span id='topic+plot_breakpoints'></span>

<h3>Description</h3>

<p>Visualize the breakpoints estimated by the segmentation model as they relate
to either the original (continuous) or discretized data. These plots assist
in determining whether too many or too few breakpoints were estimated as well
as whether the user needs to redefine how they discretized their data before
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_breakpoints(data, as_date = FALSE, var_names, var_labels = NULL, brkpts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_breakpoints_+3A_data">data</code></td>
<td>
<p>A list where each element stores a data frame for a given animal
ID. Each of these data frames contains columns for the ID, date or time1
generated by <code><a href="#topic+filter_time">filter_time</a></code>, as well as each of the movement
variables analyzed by <code><a href="#topic+segment_behavior">segment_behavior</a></code>.</p>
</td></tr>
<tr><td><code id="plot_breakpoints_+3A_as_date">as_date</code></td>
<td>
<p>logical. If <code>TRUE</code>, plots breakpoints and data streams
over the date. By default, this is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_breakpoints_+3A_var_names">var_names</code></td>
<td>
<p>A vector of the column names for the movement variables to
be plotted over time.</p>
</td></tr>
<tr><td><code id="plot_breakpoints_+3A_var_labels">var_labels</code></td>
<td>
<p>A vector of the labels to be plotted on the y-axis for each
movement variable.  Set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="plot_breakpoints_+3A_brkpts">brkpts</code></td>
<td>
<p>A data frame that contains the breakpoints associated with each
animal ID. This data frame is returned by <code><a href="#topic+get_breakpts">get_breakpts</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line plot per animal ID for each movement variable showing how the estimated
breakpoints relate to the underlying data. Depending on the user input for
<code>var_names</code>, this may either be on the scale of the original
continuous data or the discretized data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#load data
data(tracks.list)

#subset only first track
tracks.list&lt;- tracks.list[1]

#only retain id and discretized step length (SL) and turning angle (TA) columns
tracks.list2&lt;- purrr::map(tracks.list,
                   subset,
                  select = c(id, SL, TA))


set.seed(1)

# Define model params
alpha&lt;- 1
ngibbs&lt;- 1000
nbins&lt;- c(5,8)

#future::plan(future::multisession)  #run all MCMC chains in parallel
dat.res&lt;- segment_behavior(data = tracks.list2, ngibbs = ngibbs, nbins = nbins,
                           alpha = alpha)


# Determine MAP iteration for selecting breakpoints and store breakpoints
MAP.est&lt;- get_MAP(dat = dat.res$LML, nburn = ngibbs/2)
brkpts&lt;- get_breakpts(dat = dat.res$brkpts, MAP.est = MAP.est)


#run function
plot_breakpoints(data = tracks.list, as_date = FALSE, var_names = c("step","angle"),
    var_labels = c("Step Length (m)", "Turning Angle (rad)"), brkpts = brkpts)


</code></pre>

<hr>
<h2 id='plot_breakpoints_behav'>Internal function for plotting breakpoints over each of the data streams</h2><span id='topic+plot_breakpoints_behav'></span>

<h3>Description</h3>

<p>An internal function for plotting the results of the segmentation model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_breakpoints_behav(data, as_date, var_names, var_labels, brkpts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_breakpoints_behav_+3A_data">data</code></td>
<td>
<p>A data frame for a single animal ID that contains columns for the
ID, date or time variable, and each of the movement variables that were
analyzed by <code><a href="#topic+segment_behavior">segment_behavior</a></code>. Data streams can be in
continuous or discrete form.</p>
</td></tr>
<tr><td><code id="plot_breakpoints_behav_+3A_as_date">as_date</code></td>
<td>
<p>logical. If <code>TRUE</code>, plots breakpoints and data streams
over the date. By default, this is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_breakpoints_behav_+3A_var_names">var_names</code></td>
<td>
<p>A vector of the column names for the movement variables to
be plotted over time.</p>
</td></tr>
<tr><td><code id="plot_breakpoints_behav_+3A_var_labels">var_labels</code></td>
<td>
<p>A vector of the labels to be plotted on the y-axis for each
movement variable.  Set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="plot_breakpoints_behav_+3A_brkpts">brkpts</code></td>
<td>
<p>A data frame that contains the breakpoints associated with each
animal ID. This data frame is returned by <code><a href="#topic+get_breakpts">get_breakpts</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A line plot for each movement variable showing how the estimated
breakpoints relate to the underlying data. Depending on the user input for
<code>var_names</code>, this may either be on the scale of the original
continuous data or the discretized data.
</p>

<hr>
<h2 id='prep_data'>Calculate step lengths, turning angles, net-squared displacement, and time
steps</h2><span id='topic+prep_data'></span>

<h3>Description</h3>

<p>Calculates step lengths, turning angles, and net-squared displacement based
on coordinates for each animal ID and calculates time steps based on the
date-time. Provides a self-contained method to calculate these variables
without needing to rely on other R packages (e.g., <code>adehabitatLT</code>).
However, functions from other packages can also be used to perform this step
in data preparation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_data(dat, coord.names, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_data_+3A_dat">dat</code></td>
<td>
<p>A data frame that contains a column for animal IDs, the columns
associated with the x and y coordinates, and a column for the date. For
easier interpretation of the model results, it is recommended that
coordinates be stored in a UTM projection (meters) as opposed to
unprojected in decimal degrees (map units). Date-time should be of class
<code>POSIXct</code> and be labeled <code>date</code> within the data frame.</p>
</td></tr>
<tr><td><code id="prep_data_+3A_coord.names">coord.names</code></td>
<td>
<p>character. A vector of the column names under which the
coordinates are stored. The name for the x coordinate should be listed
first and the name for the y coordinate second.</p>
</td></tr>
<tr><td><code id="prep_data_+3A_id">id</code></td>
<td>
<p>character. The name of the column storing the animal IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where all original data are returned and new columns are
added for step length (<code>step</code>), turning angle (<code>angle</code>),
net-squared displacement (<code>NSD</code>), and time
step (<code>dt</code>). Names for coordinates are changed to <code>x</code> and
<code>y</code>. Units for <code>step</code> and <code>NSD</code> depend on the projection of the
coordinates, <code>angle</code> is returned in radians, and <code>dt</code> is
returned in seconds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data
data(tracks)

#subset only first track
tracks&lt;- tracks[tracks$id == "id1",]

#calculate step lengths and turning angles
tracks&lt;- prep_data(dat = tracks, coord.names = c("x","y"), id = "id")

</code></pre>

<hr>
<h2 id='prep_data_internal'>Internal function to calculate step lengths, turning angles, and time steps</h2><span id='topic+prep_data_internal'></span>

<h3>Description</h3>

<p>An internal function that calculates step lengths, turning angles, and time
steps for a given animal ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_data_internal(dat, coord.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_data_internal_+3A_dat">dat</code></td>
<td>
<p>A data frame that contains the columns associated with the x and y
coordinates as well as the date-time. For easier interpretation of the
model results, it is recommended that coordinates be stored after UTM
projection (meters) as opposed to unprojected in decimal degrees (map
units). Date-time should be of class <code>POSIXct</code> and be labeled
<code>date</code> within the data frame.</p>
</td></tr>
<tr><td><code id="prep_data_internal_+3A_coord.names">coord.names</code></td>
<td>
<p>character. A vector of the column names under which the
coordinates are stored. The name for the x coordinate should be listed
first and the name for the y coordinate second.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where all original data are returned and new columns are
added for step length (<code>step</code>), turning angle (<code>angle</code>),
net-squared displacement (<code>NSD</code>), and time step (<code>dt</code>).
</p>

<hr>
<h2 id='rmultinom1'>Internal function that samples z's from a categorical distribution</h2><span id='topic+rmultinom1'></span>

<h3>Description</h3>

<p>Internal function that samples z's from a categorical distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmultinom1(prob, randu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmultinom1_+3A_prob">prob</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="rmultinom1_+3A_randu">randu</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>

<hr>
<h2 id='rmultinom2'>Internal function that samples z's from a multinomial distribution</h2><span id='topic+rmultinom2'></span>

<h3>Description</h3>

<p>Internal function that samples z's from a multinomial distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmultinom2(prob, n, randu, nmaxclust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmultinom2_+3A_prob">prob</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="rmultinom2_+3A_n">n</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="rmultinom2_+3A_randu">randu</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="rmultinom2_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>An integer.</p>
</td></tr>
</table>

<hr>
<h2 id='round_track_time'>Round time to nearest interval</h2><span id='topic+round_track_time'></span>

<h3>Description</h3>

<p>Rounds sampling intervals that are close, but not exactly the time interval
of interest (e.g., 240 s instead of 300 s). This can be performed on multiple
time intervals, but only using a single tolerance value. This function
prepares the data to be analyzed by <code><a href="#topic+segment_behavior">segment_behavior</a></code>, which
requires that all time intervals exactly match the primary time interval when
analyzing step lengths and turning angles. Columns storing the time intervals
and dates must be labeled <code>dt</code> and <code>date</code>, respectively, where
dates are of class <code>POSIXct</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_track_time(dat, id, int, tol, time.zone = "UTC", units)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_track_time_+3A_dat">dat</code></td>
<td>
<p>A data frame that contains the sampling interval of the
observations.</p>
</td></tr>
<tr><td><code id="round_track_time_+3A_id">id</code></td>
<td>
<p>character. The name of the column storing the animal IDs.</p>
</td></tr>
<tr><td><code id="round_track_time_+3A_int">int</code></td>
<td>
<p>numeric. A vector of the time interval(s) of on which to perform
rounding.</p>
</td></tr>
<tr><td><code id="round_track_time_+3A_tol">tol</code></td>
<td>
<p>numeric. A single tolerance value on which to round any <code>int</code>
that were specified.</p>
</td></tr>
<tr><td><code id="round_track_time_+3A_time.zone">time.zone</code></td>
<td>
<p>character. Specify the time zone for which the date-times
were recorded. Set to UTC by default. Refer to <code>base::OlsonNames</code> to view
all possible time zones.</p>
</td></tr>
<tr><td><code id="round_track_time_+3A_units">units</code></td>
<td>
<p>character. The units of the selected time interval <code>int</code>,
which can be selected from one of &quot;secs&quot;, &quot;mins&quot;, &quot;hours&quot;, &quot;days&quot;, or
&quot;weeks&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where <code>dt</code> and <code>date</code> are both adjusted based
upon the rounding of time intervals according to the specified tolerance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data
data(tracks)

#subset only first track
tracks&lt;- tracks[tracks$id == "id1",]

#calculate step lengths and turning angles
tracks&lt;- prep_data(dat = tracks, coord.names = c("x","y"), id = "id")

#round times to nearest interval of interest (e.g. 3600 s or 1 hr)
tracks&lt;- round_track_time(dat = tracks, id = "id", int = 3600, tol = 180, time.zone = "UTC",
                          units = "secs")

</code></pre>

<hr>
<h2 id='samp_move'>Internal function for the Gibbs sampler within the reversible-jump MCMC
algorithm</h2><span id='topic+samp_move'></span>

<h3>Description</h3>

<p>This is RJMCMC algorithm that drives the proposal and selection of
breakpoints for the data based on the difference in log marginal likelihood.
This function is called within <code><a href="#topic+behav_gibbs_sampler">behav_gibbs_sampler</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samp_move(breakpt, max.time, dat, alpha, nbins, ndata.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samp_move_+3A_breakpt">breakpt</code></td>
<td>
<p>numeric. A vector of breakpoints.</p>
</td></tr>
<tr><td><code id="samp_move_+3A_max.time">max.time</code></td>
<td>
<p>numeric. The number of of the last observation of <code>dat</code>.</p>
</td></tr>
<tr><td><code id="samp_move_+3A_dat">dat</code></td>
<td>
<p>A matrix that only contains columns storing discretized data for
each of the movement variables used within <code><a href="#topic+get_summary_stats">get_summary_stats</a></code>.</p>
</td></tr>
<tr><td><code id="samp_move_+3A_alpha">alpha</code></td>
<td>
<p>numeric. A single value used to specify the hyperparameter for
the prior distribution. A standard value for <code>alpha</code> is typically 1,
which corresponds with a vague prior on the Dirichlet distribution.</p>
</td></tr>
<tr><td><code id="samp_move_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
movement variable. These must be in the same order as the columns within
<code>dat</code>.</p>
</td></tr>
<tr><td><code id="samp_move_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. The length of <code>nbins</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The breakpoints and log marginal likelihood are retained from the
selected model from the Gibbs sampler and returned as elements of a list.
This is performed for each iteration of the MCMC algorithm.
</p>

<hr>
<h2 id='sample.gamma.mixmod'>Internal function to sample the gamma hyperparameter</h2><span id='topic+sample.gamma.mixmod'></span>

<h3>Description</h3>

<p>Internal function to sample the gamma hyperparameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.gamma.mixmod(v, ngroup, gamma.possib)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.gamma.mixmod_+3A_v">v</code></td>
<td>
<p>numeric. A vector of proportions for each of the possible clusters.</p>
</td></tr>
<tr><td><code id="sample.gamma.mixmod_+3A_ngroup">ngroup</code></td>
<td>
<p>numeric. The total number of possible clusters.</p>
</td></tr>
<tr><td><code id="sample.gamma.mixmod_+3A_gamma.possib">gamma.possib</code></td>
<td>
<p>numeric. A vector of possible values that gamma can take
ranging between 0.1 and 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value for gamma that falls within
<code>gamma.possib</code> for calculation of the log-likelihood.
</p>

<hr>
<h2 id='sample.phi'>Internal function to sample bin estimates for each movement variable</h2><span id='topic+sample.phi'></span>

<h3>Description</h3>

<p>Estimates values of <em>phi</em> matrix for use in characterizing distributions
of the movement variables. Not for calling directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.phi(z.agg, alpha, nmaxclust, nbins, ndata.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.phi_+3A_z.agg">z.agg</code></td>
<td>
<p>A list of latent cluster estimates provided by
<code><a href="#topic+sample.z">sample.z</a></code>.</p>
</td></tr>
<tr><td><code id="sample.phi_+3A_alpha">alpha</code></td>
<td>
<p>numeric. A hyperparameter for the Dirichlet distribution.</p>
</td></tr>
<tr><td><code id="sample.phi_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
<tr><td><code id="sample.phi_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
movement variable. These must be in the same order as the columns within
<code>y</code>.</p>
</td></tr>
<tr><td><code id="sample.phi_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. The number of data streams being analyzed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of proportion estimates that characterize distributions
(bins) for each movement variable and possible behavioral state.
</p>

<hr>
<h2 id='sample.phi.mixmod'>Internal function to sample bin estimates for each movement variable</h2><span id='topic+sample.phi.mixmod'></span>

<h3>Description</h3>

<p>Estimates values of <em>phi</em> matrix for use in characterizing distributions
of the movement variables. Not for calling directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.phi.mixmod(alpha, nmaxclust, nbins, ndata.types, nmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.phi.mixmod_+3A_alpha">alpha</code></td>
<td>
<p>numeric. A hyperparameter for the Dirichlet distribution.</p>
</td></tr>
<tr><td><code id="sample.phi.mixmod_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
<tr><td><code id="sample.phi.mixmod_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
data stream. These must be in the same order as the columns within
<code>dat</code>.</p>
</td></tr>
<tr><td><code id="sample.phi.mixmod_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. The number of data streams being analyzed.</p>
</td></tr>
<tr><td><code id="sample.phi.mixmod_+3A_nmat">nmat</code></td>
<td>
<p>A list based on <code><a href="#topic+SummarizeDat">SummarizeDat</a></code> C++ function to help
with multinomial draws.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of proportion estimates that characterize distributions
(bins) for each data stream and possible behavioral state.
</p>

<hr>
<h2 id='sample.v'>Internal function to sample parameter for truncated stick-breaking prior</h2><span id='topic+sample.v'></span>

<h3>Description</h3>

<p>This function samples the latent <em>v</em> parameter within the Gibbs sampler.
Calls on the <code>CumSumInv</code> function written in C++. Not for calling
directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.v(z.agg, gamma1, ntsegm, ndata.types, nmaxclust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.v_+3A_z.agg">z.agg</code></td>
<td>
<p>A list of latent cluster estimates provided by
<code><a href="#topic+sample.z">sample.z</a></code>.</p>
</td></tr>
<tr><td><code id="sample.v_+3A_gamma1">gamma1</code></td>
<td>
<p>numeric. Hyperparameter for the truncated stick-breaking prior.</p>
</td></tr>
<tr><td><code id="sample.v_+3A_ntsegm">ntsegm</code></td>
<td>
<p>numeric. The total number of time segments from all animal IDs.</p>
</td></tr>
<tr><td><code id="sample.v_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. The number of data streams being analyzed.</p>
</td></tr>
<tr><td><code id="sample.v_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with estimates for <em>v</em> for each of the number of time
segments and possible states.
</p>

<hr>
<h2 id='sample.v.mixmod'>Internal function to sample parameter for truncated stick-breaking prior</h2><span id='topic+sample.v.mixmod'></span>

<h3>Description</h3>

<p>This function samples the latent <em>v</em> parameter within the Gibbs sampler.
Not for calling directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.v.mixmod(z, gamma1, nmaxclust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.v.mixmod_+3A_z">z</code></td>
<td>
<p>A vector of latent cluster estimates provided by
<code><a href="#topic+sample.z.mixmod">sample.z.mixmod</a></code>.</p>
</td></tr>
<tr><td><code id="sample.v.mixmod_+3A_gamma1">gamma1</code></td>
<td>
<p>numeric. Hyperparameter for the truncated stick-breaking prior.</p>
</td></tr>
<tr><td><code id="sample.v.mixmod_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with estimates for <em>v</em> and <em>theta</em> for each of the possible states.
</p>

<hr>
<h2 id='sample.z'>Internal function to sample latent clusters</h2><span id='topic+sample.z'></span>

<h3>Description</h3>

<p>This function samples the latent <em>z</em> parameter within the Gibbs sampler.
Calls on the <code>SampleZAgg</code> function written in C++. Not for calling
directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.z(ntsegm, nbins, y, nmaxclust, phi, ltheta, zeroes, ndata.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.z_+3A_ntsegm">ntsegm</code></td>
<td>
<p>numeric. The total number of time segments from all animal IDs.</p>
</td></tr>
<tr><td><code id="sample.z_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
movement variable. These must be in the same order as the columns within
<code>y</code>.</p>
</td></tr>
<tr><td><code id="sample.z_+3A_y">y</code></td>
<td>
<p>A list where each element stores separate aggregated count data per
bin per time segment for each movement variable being analyzed. These are
stored as matrices.</p>
</td></tr>
<tr><td><code id="sample.z_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
<tr><td><code id="sample.z_+3A_phi">phi</code></td>
<td>
<p>A list where each element stores separate proportions per bin per
time segment for each movement variable.</p>
</td></tr>
<tr><td><code id="sample.z_+3A_ltheta">ltheta</code></td>
<td>
<p>A matrix storing the log-transformed values from the
<code>theta</code> parameter.</p>
</td></tr>
<tr><td><code id="sample.z_+3A_zeroes">zeroes</code></td>
<td>
<p>A list of arrays that contain only zero values which are three
dimensional (ntsegm,nbins[i],nmaxclust).</p>
</td></tr>
<tr><td><code id="sample.z_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. The number of data streams being analyzed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with estimates for <em>z</em> where the number of elements is equal to
the number of movement variables.
</p>

<hr>
<h2 id='sample.z.mixmod'>Internal function to sample latent clusters (for observations)</h2><span id='topic+sample.z.mixmod'></span>

<h3>Description</h3>

<p>This function samples the latent <em>z</em> parameter within the Gibbs sampler.
Calls on the <code>rmultinom1</code> function written in C++. Not for calling
directly by users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.z.mixmod(nobs, nmaxclust, dat, ltheta, lphi, ndata.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.z.mixmod_+3A_nobs">nobs</code></td>
<td>
<p>numeric. The total number of rows in the dataset.</p>
</td></tr>
<tr><td><code id="sample.z.mixmod_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>numeric. A single number indicating the maximum number of
clusters to test.</p>
</td></tr>
<tr><td><code id="sample.z.mixmod_+3A_dat">dat</code></td>
<td>
<p>A data frame containing only columns of the discretized data
streams for all observations.</p>
</td></tr>
<tr><td><code id="sample.z.mixmod_+3A_ltheta">ltheta</code></td>
<td>
<p>numeric. A vector of log-transformed estimates for parameter
theta.</p>
</td></tr>
<tr><td><code id="sample.z.mixmod_+3A_lphi">lphi</code></td>
<td>
<p>A list containing log-transformed estimates for each data stream
of the phi parameter.</p>
</td></tr>
<tr><td><code id="sample.z.mixmod_+3A_ndata.types">ndata.types</code></td>
<td>
<p>numeric. The number of data streams being analyzed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with estimates for <em>z</em> for each observation within
<code>dat</code>.
</p>

<hr>
<h2 id='SampleZAgg'>Internal function that samples z1 aggregate</h2><span id='topic+SampleZAgg'></span>

<h3>Description</h3>

<p>Internal function that samples z1 aggregate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SampleZAgg(ntsegm, b1, y1, nmaxclust, lphi1, ltheta, zeroes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SampleZAgg_+3A_ntsegm">ntsegm</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="SampleZAgg_+3A_b1">b1</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="SampleZAgg_+3A_y1">y1</code></td>
<td>
<p>An integer matrix.</p>
</td></tr>
<tr><td><code id="SampleZAgg_+3A_nmaxclust">nmaxclust</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="SampleZAgg_+3A_lphi1">lphi1</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="SampleZAgg_+3A_ltheta">ltheta</code></td>
<td>
<p>A numeric matrix.</p>
</td></tr>
<tr><td><code id="SampleZAgg_+3A_zeroes">zeroes</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>

<hr>
<h2 id='segment_behavior'>Segmentation model to estimate breakpoints</h2><span id='topic+segment_behavior'></span>

<h3>Description</h3>

<p>This function performs the reversible-jump MCMC algorithm using a Gibbs
sampler, which estimates the breakpoints of the movement variables for each
of the animal IDs. This is the first stage of the two-stage Bayesian model that
estimates proportions of behavioral states by first segmenting individual
tracks into relatively homogeneous segments of movement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment_behavior(
  data,
  ngibbs,
  nbins,
  alpha,
  breakpt = purrr::map(names(data), ~NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segment_behavior_+3A_data">data</code></td>
<td>
<p>A list where each element stores the data for a separate animal
ID. List elements are data frames that only contain columns for the animal
ID and for each of the discretized movement variables.</p>
</td></tr>
<tr><td><code id="segment_behavior_+3A_ngibbs">ngibbs</code></td>
<td>
<p>numeric. The total number of iterations of the MCMC chain.</p>
</td></tr>
<tr><td><code id="segment_behavior_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
movement variable. These must be in the same order as the columns within
<code>data</code>.</p>
</td></tr>
<tr><td><code id="segment_behavior_+3A_alpha">alpha</code></td>
<td>
<p>numeric. A single value used to specify the hyperparameter for
the prior distribution. A standard value for <code>alpha</code> is typically 1,
which corresponds with a vague prior on the Dirichlet distribution.</p>
</td></tr>
<tr><td><code id="segment_behavior_+3A_breakpt">breakpt</code></td>
<td>
<p>A list where each element stores a vector of breakpoints if
pre-specifying where they may occur for each animal ID. By default this is
set to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model is run in parallel using the <code>future</code> package. To ensure that
the model is run in parallel, the <code><a href="future.html#topic+plan">plan</a></code> must be used
with <code>future::multisession</code> as the argument for most operating systems.
Otherwise, model will run sequentially by default if this is not set before
running <code>segment_behavior</code>.
</p>


<h3>Value</h3>

<p>A list of model results is returned where elements include the
breakpoints, number of breakpoints, and log marginal likelihood at each
iteration of the MCMC chain for all animal IDs. The time it took the model
to finish running for each animal ID are also stored and returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load data
data(tracks.list)

#subset only first track
tracks.list&lt;- tracks.list[1]

#only retain id and discretized step length (SL) and turning angle (TA) columns
tracks.list2&lt;- purrr::map(tracks.list,
                   subset,
                  select = c(id, SL, TA))


set.seed(1)

# Define model params
alpha&lt;- 1
ngibbs&lt;- 1000
nbins&lt;- c(5,8)

future::plan(future::multisession, workers = 3)  #run all MCMC chains in parallel

dat.res&lt;- segment_behavior(data = tracks.list2, ngibbs = ngibbs, nbins = nbins,
                               alpha = alpha)


future::plan(future::sequential)  #return to single core


</code></pre>

<hr>
<h2 id='shiny_tracks'>Dynamically explore tracks within Shiny app</h2><span id='topic+shiny_tracks'></span>

<h3>Description</h3>

<p>This Shiny application allows for the exploration of animal movement
patterns. Options are available to interactively filter the plotted tracks by
a selected time period of a given variable, which is then displayed on an
interactive map. Additionally, a data table is shown with options to filter
and export this table once satisfied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiny_tracks(data, epsg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shiny_tracks_+3A_data">data</code></td>
<td>
<p>A data frame that must contain columns labeled <code>id, x, y,
date</code>, but can include any other variables of interest.</p>
</td></tr>
<tr><td><code id="shiny_tracks_+3A_epsg">epsg</code></td>
<td>
<p>numeric. The coordinate reference system (CRS) as an EPSG code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the time series plot shown for the exploration of individual
tracks cannot display variables of class <code>character</code> or <code>factor</code>.
Therefore, these should be changed to numeric values if they are to be
plotted.
</p>
<p>If the data are stored as longitude and latitude (i.e., WGS84), the EPSG code
is 4326. All other codes will need to be looked up if they are not already
known.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#load data
data(tracks)

#run Shiny app
shiny_tracks(data = tracks, epsg = 32617)


## End(Not run)

</code></pre>

<hr>
<h2 id='StoreZ'>This function helps store z from all iterations after burn in</h2><span id='topic+StoreZ'></span>

<h3>Description</h3>

<p>This function helps store z from all iterations after burn in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoreZ(z, store_z, nobs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StoreZ_+3A_z">z</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="StoreZ_+3A_store_z">store_z</code></td>
<td>
<p>An integer matrix.</p>
</td></tr>
<tr><td><code id="StoreZ_+3A_nobs">nobs</code></td>
<td>
<p>An integer.</p>
</td></tr>
</table>

<hr>
<h2 id='summarize_tsegs'>Summarize observations within bins per track segment</h2><span id='topic+summarize_tsegs'></span>

<h3>Description</h3>

<p>Prepares the data that has already been segmented for clustering by Latent
Dirichlet Allocation. This function summarizes the counts observed per
movement variable bin within each track segment per animal ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_tsegs(dat, nbins)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_tsegs_+3A_dat">dat</code></td>
<td>
<p>A data frame of <strong>only</strong> the animal ID, track segment number,
and the discretized data for each movement variable. Animal ID and time
segment must be the first two columns of this data frame. This should be a
simplified form of the output from <code><a href="#topic+assign_tseg">assign_tseg</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_tsegs_+3A_nbins">nbins</code></td>
<td>
<p>numeric. A vector of the number of bins used to discretize each
movement variable. These must be in the same order as the columns within
<code>dat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new data frame that contains the animal ID, track segment number,
and the counts per bin for each movement variable. The names for each of
these bins are labeled according to the order in which the variables were
provided to <code>summarize_tsegs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load data
data(tracks.seg)

#select only id, tseg, SL, and TA columns
tracks.seg2&lt;- tracks.seg[,c("id","tseg","SL","TA")]

#run function
obs&lt;- summarize_tsegs(dat = tracks.seg2, nbins = c(5,8))


</code></pre>

<hr>
<h2 id='summarize1'>Internal function that summarizes bin distributions of track segments</h2><span id='topic+summarize1'></span>

<h3>Description</h3>

<p>Internal function that summarizes bin distributions of track segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize1(VecVals, Breakpts, nobs, nbins, nbreak)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize1_+3A_vecvals">VecVals</code></td>
<td>
<p>A vector of bin values.</p>
</td></tr>
<tr><td><code id="summarize1_+3A_breakpts">Breakpts</code></td>
<td>
<p>A vector if breakpoints.</p>
</td></tr>
<tr><td><code id="summarize1_+3A_nobs">nobs</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="summarize1_+3A_nbins">nbins</code></td>
<td>
<p>The number of bins for a given data stream.</p>
</td></tr>
<tr><td><code id="summarize1_+3A_nbreak">nbreak</code></td>
<td>
<p>The number of estimated breakpoints.</p>
</td></tr>
</table>

<hr>
<h2 id='SummarizeDat'>Internal function that generates nmat matrix to help with multinomial draws</h2><span id='topic+SummarizeDat'></span>

<h3>Description</h3>

<p>Internal function that generates nmat matrix to help with multinomial draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SummarizeDat(z, dat, ncateg, nbehav, nobs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SummarizeDat_+3A_z">z</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="SummarizeDat_+3A_dat">dat</code></td>
<td>
<p>An integer vector.</p>
</td></tr>
<tr><td><code id="SummarizeDat_+3A_ncateg">ncateg</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="SummarizeDat_+3A_nbehav">nbehav</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="SummarizeDat_+3A_nobs">nobs</code></td>
<td>
<p>An integer.</p>
</td></tr>
</table>

<hr>
<h2 id='traceplot'>View trace-plots of output from Bayesian segmentation model</h2><span id='topic+traceplot'></span>

<h3>Description</h3>

<p>Visualize trace-plots of the number of breakpoints estimated by the model as
well as the log marginal likelihood (LML) for each animal ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot(data, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot_+3A_data">data</code></td>
<td>
<p>A list of model results that is returned as output from <code><a href="#topic+segment_behavior">segment_behavior</a></code>.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_type">type</code></td>
<td>
<p>character. The type of data that are being plotted from the
Bayesian segmentation model results. Takes either 'nbrks' for the number of
breakpoints or 'LML' for the log marginal likelihood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Trace-plots for the number of breakpoints or the log marginal
likelihood are displayed for each of the animal IDs that were analyzed by
the segmentation model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load data
data(tracks.list)

#only retain id and discretized step length (SL) and turning angle (TA) columns
tracks.list2&lt;- purrr::map(tracks.list,
                   subset,
                  select = c(id, SL, TA))


set.seed(1)

# Define model params
alpha&lt;- 1
ngibbs&lt;- 1000
nbins&lt;- c(5,8)

future::plan(future::multisession, workers = 3)  #run all MCMC chains in parallel

dat.res&lt;- segment_behavior(data = tracks.list2, ngibbs = ngibbs, nbins = nbins,
                               alpha = alpha)

future::plan(future::sequential)  #return to single core


#run function
traceplot(data = dat.res, type = "nbrks")
traceplot(data = dat.res, type = "LML")


</code></pre>

<hr>
<h2 id='tracks'>Simulated set of three tracks.</h2><span id='topic+tracks'></span>

<h3>Description</h3>

<p>A dataset containing the IDs as well as x and y coordinates for three tracks
of 5001 observations each (15,003 in total).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracks
</code></pre>


<h3>Format</h3>

<p>A data frame with 15003 rows and 4 variables: </p>

<dl>
<dt>id</dt><dd><p>ID for each simulated track</p>
</dd>
<dt>date</dt><dd><p>date, recorded as datetime</p>
</dd>
<dt>x</dt><dd><p>x coordinate of tracks</p>
</dd>
<dt>y</dt><dd><p>y coordinate of tracks</p>
</dd> </dl>


<hr>
<h2 id='tracks.list'>Tracks discretized and prepared for segmentation.</h2><span id='topic+tracks.list'></span>

<h3>Description</h3>

<p>A dataset containing the prepared data after discretizing step lengths and
turning angles, as well as filtering observations at the primary time step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracks.list
</code></pre>


<h3>Format</h3>

<p>A list with three elements, each containing a data frame with ~4700
rows and 11 variables: </p>

<dl>
<dt>id</dt><dd><p>ID for each simulated track</p>
</dd>
<dt>date</dt><dd><p>date, recorded as datetime</p>
</dd>
<dt>x</dt><dd><p>x coordinate of tracks</p>
</dd>
<dt>y</dt><dd><p>y coordinate of tracks</p>
</dd>
<dt>step</dt><dd><p>the step length calculated as the distance between successive locations
measured in units</p>
</dd>
<dt>angle</dt><dd><p>the relative turning angle measured in radians</p>
</dd>
<dt>dt</dt><dd><p>the time step or sampling interval between datetimes of successive
observations</p>
</dd>
<dt>obs</dt><dd><p>the ordered number of observations per ID before filtering for the primary
time step</p>
</dd>
<dt>time1</dt><dd><p>the ordered number of observations per ID after filtering for the primary
time step</p>
</dd>
<dt>SL</dt><dd><p>discretized step lengths, separated into five bins</p>
</dd>
<dt>TA</dt><dd><p>discretized turning angles, separated into eight bins</p>
</dd>
</dl>


<hr>
<h2 id='tracks.seg'>Segmented tracks for all IDs.</h2><span id='topic+tracks.seg'></span>

<h3>Description</h3>

<p>A dataset containing the filtered track data with time segments assigned to
all observations on an individual basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracks.seg
</code></pre>


<h3>Format</h3>

<p>A data frame with 14096 rows and 12 variables: </p>

<dl>
<dt>id</dt><dd><p>ID for each simulated track</p>
</dd>
<dt>date</dt><dd><p>date, recorded as datetime</p>
</dd>
<dt>x</dt><dd><p>x coordinate of tracks</p>
</dd>
<dt>y</dt><dd><p>y coordinate of tracks</p>
</dd>
<dt>step</dt><dd><p>the step length calculated as the distance between successive
locations measured in units</p>
</dd>
<dt>angle</dt><dd><p>the relative turning angle measured in radians</p>
</dd>
<dt>dt</dt><dd><p>the time step or sampling interval between datetimes of successive observations</p>
</dd>
<dt>obs</dt><dd><p>the ordered number of observations per ID before filtering for the
primary time step</p>
</dd>
<dt>time1</dt><dd><p>the ordered number of observations per ID after filtering for
the primary time step</p>
</dd>
<dt>SL</dt><dd><p>discretized step lengths, separated into five bins</p>
</dd>
<dt>TA</dt><dd><p>discretized turning angles, separated into eight bins</p>
</dd>
<dt>tseg</dt><dd><p>time segment assigned to a given set of observations per ID</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
