<!DOCTYPE html><html lang="en"><head><title>Help for package PrevMap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PrevMap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust.sigma2'><p>Adjustment factor for the variance of the convolution of Gaussian noise</p></a></li>
<li><a href='#autocor.plot'><p>Plot of the autocorrelgram for posterior samples</p></a></li>
<li><a href='#binary.probit.Bayes'><p>Bayesian estimation for the two-levels binary probit model</p></a></li>
<li><a href='#binomial.logistic.Bayes'><p>Bayesian estimation for the binomial logistic model</p></a></li>
<li><a href='#binomial.logistic.MCML'><p>Monte Carlo Maximum Likelihood estimation for the binomial logistic model</p></a></li>
<li><a href='#coef.PrevMap'><p>Extract model coefficients</p></a></li>
<li><a href='#coef.PrevMap.ps'><p>Extract model coefficients from geostatistical linear model with preferentially sampled locations</p></a></li>
<li><a href='#continuous.sample'><p>Spatially continuous sampling</p></a></li>
<li><a href='#contour.pred.PrevMap'><p>Contour plot of a predicted surface</p></a></li>
<li><a href='#control.mcmc.Bayes'><p>Control settings for the MCMC algorithm used for Bayesian inference</p></a></li>
<li><a href='#control.mcmc.Bayes.SPDE'><p>Control settings for the MCMC algorithm used for Bayesian inference using SPDE</p></a></li>
<li><a href='#control.mcmc.MCML'><p>Control settings for the MCMC algorithm used for classical inference on a binomial logistic model</p></a></li>
<li><a href='#control.prior'><p>Priors specification</p></a></li>
<li><a href='#control.profile'><p>Auxliary function for controlling profile log-likelihood in the linear Gaussian model</p></a></li>
<li><a href='#create.ID.coords'><p>ID spatial coordinates</p></a></li>
<li><a href='#data_sim'><p>Simulated binomial data-set over the unit square</p></a></li>
<li><a href='#dens.plot'><p>Density plot for posterior samples</p></a></li>
<li><a href='#discrete.sample'><p>Spatially discrete sampling</p></a></li>
<li><a href='#galicia'><p>Heavy metal biomonitoring in Galicia</p></a></li>
<li><a href='#galicia.boundary'><p>Boundary of Galicia</p></a></li>
<li><a href='#glgm.LA'><p>Maximum Likelihood estimation for generalised linear geostatistical models via the Laplace approximation</p></a></li>
<li><a href='#Laplace.sampling'><p>Langevin-Hastings MCMC for conditional simulation</p></a></li>
<li><a href='#Laplace.sampling.lr'><p>Langevin-Hastings MCMC for conditional simulation (low-rank approximation)</p></a></li>
<li><a href='#Laplace.sampling.SPDE'><p>Independence sampler for conditional simulation of a Gaussian process using SPDE</p></a></li>
<li><a href='#linear.model.Bayes'><p>Bayesian estimation for the geostatistical linear Gaussian model</p></a></li>
<li><a href='#linear.model.MLE'><p>Maximum Likelihood estimation for the geostatistical linear Gaussian model</p></a></li>
<li><a href='#lm.ps.MCML'><p>Monte Carlo Maximum Likelihood estimation of the geostatistical linear model with preferentially sampled locations</p></a></li>
<li><a href='#loaloa'><p>Loa loa prevalence data from 197 village surveys</p></a></li>
<li><a href='#loglik.ci'><p>Profile likelihood confidence intervals</p></a></li>
<li><a href='#loglik.linear.model'><p>Profile log-likelihood or fixed parameters likelihood evaluation for the covariance parameters in the geostatistical linear model</p></a></li>
<li><a href='#matern.kernel'><p>Matern kernel</p></a></li>
<li><a href='#plot.pred.PrevMap'><p>Plot of a predicted surface</p></a></li>
<li><a href='#plot.pred.PrevMap.ps'><p>Plot of a predicted surface of geostatistical linear fits with preferentially sampled locations</p></a></li>
<li><a href='#plot.PrevMap.diagnostic'><p>Plot of the variogram-based diagnostics</p></a></li>
<li><a href='#plot.profile.PrevMap'><p>Plot of the profile log-likelihood for the covariance parameters of the Matern function</p></a></li>
<li><a href='#plot.shape.matern'><p>Plot of the profile likelihood for the shape parameter of the Matern covariance function</p></a></li>
<li><a href='#point.map'><p>Point map</p></a></li>
<li><a href='#poisson.log.MCML'><p>Monte Carlo Maximum Likelihood estimation for the Poisson model</p></a></li>
<li><a href='#set.par.ps'><p>Define the model coefficients of a geostatistical linear model with preferentially sampled locations</p></a></li>
<li><a href='#shape.matern'><p>Profile likelihood for the shape parameter of the Matern covariance function</p></a></li>
<li><a href='#spat.corr.diagnostic'><p>Diagnostics for residual spatial correlation</p></a></li>
<li><a href='#spatial.pred.binomial.Bayes'><p>Bayesian spatial prediction for the binomial logistic and binary probit models</p></a></li>
<li><a href='#spatial.pred.binomial.MCML'><p>Spatial predictions for the binomial logistic model using plug-in of MCML estimates</p></a></li>
<li><a href='#spatial.pred.linear.Bayes'><p>Bayesian spatial predictions for the geostatistical Linear Gaussian model</p></a></li>
<li><a href='#spatial.pred.linear.MLE'><p>Spatial predictions for the geostatistical Linear Gaussian model using plug-in of ML estimates</p></a></li>
<li><a href='#spatial.pred.lm.ps'><p>Spatial predictions for the geostatistical Linear Gaussian model using plug-in of ML estimates</p></a></li>
<li><a href='#spatial.pred.poisson.MCML'><p>Spatial predictions for the Poisson model with log link function, using plug-in of MCML estimates</p></a></li>
<li><a href='#summary.Bayes.PrevMap'><p>Summarizing Bayesian model fits</p></a></li>
<li><a href='#summary.PrevMap'><p>Summarizing likelihood-based model fits</p></a></li>
<li><a href='#summary.PrevMap.ps'><p>Summarizing fits of geostatistical linear models with preferentially sampled locations</p></a></li>
<li><a href='#trace.plot'><p>Trace-plots for posterior samples</p></a></li>
<li><a href='#trace.plot.MCML'><p>Trace-plots of the importance sampling distribution samples from the MCML method</p></a></li>
<li><a href='#trend.plot'><p>Plot of trends</p></a></li>
<li><a href='#variog.diagnostic.glgm'><p>Variogram-based validation for generalized linear geostatistical model fits (Binomial and Poisson)</p></a></li>
<li><a href='#variog.diagnostic.lm'><p>Variogram-based validation for linear geostatistical model fits</p></a></li>
<li><a href='#variogram'><p>The empirical variogram</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geostatistical Modelling of Spatially Referenced Prevalence Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Emanuele Giorgi, Peter J. Diggle</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emanuele Giorgi &lt;e.giorgi@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>splancs, lme4, truncnorm, methods, numDeriv</td>
</tr>
<tr>
<td>Depends:</td>
<td>maxLik, raster, pdist, Matrix</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for both likelihood-based
    and Bayesian analysis of spatially referenced prevalence data. For a tutorial on the use of the R package, see Giorgi and Diggle (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v078.i08">doi:10.18637/jss.v078.i08</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>geoR, R.rsp, INLA, knitr, rmarkdown</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing/">https://inla.r-inla-download.org/R/testing/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-07 08:46:40 UTC; giorgi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-07 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust.sigma2'>Adjustment factor for the variance of the convolution of Gaussian noise</h2><span id='topic+adjust.sigma2'></span>

<h3>Description</h3>

<p>This function computes the multiplicative constant used to adjust the value of <code>sigma2</code> in the low-rank approximation of a Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust.sigma2(knots.dist, phi, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust.sigma2_+3A_knots.dist">knots.dist</code></td>
<td>
<p>a matrix of the distances between the observed coordinates and the spatial knots.</p>
</td></tr>
<tr><td><code id="adjust.sigma2_+3A_phi">phi</code></td>
<td>
<p>scale parameter of the Matern covariance function.</p>
</td></tr>
<tr><td><code id="adjust.sigma2_+3A_kappa">kappa</code></td>
<td>
<p>shape parameter of the Matern covariance function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">U</code> denote the <code class="reqn">n</code> by <code class="reqn">m</code> matrix of the distances between the <code class="reqn">n</code> observed coordinates and <code class="reqn">m</code> pre-defined spatial knots. This function computes the following quantity
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{n}\sum_{i=1}^n \sum_{j=1}^m K(u_{ij}; \phi, \kappa)^2,</code>
</p>

<p>where <code class="reqn">K(.; \phi, \kappa)</code> is the Matern kernel (see <code><a href="#topic+matern.kernel">matern.kernel</a></code>) and <code class="reqn">u_{ij}</code> is the distance between the <code class="reqn">i</code>-th sampled location and the <code class="reqn">j</code>-th spatial knot.
</p>


<h3>Value</h3>

<p>A value corresponding to the adjustment factor for <code>sigma2</code>.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matern.kernel">matern.kernel</a></code>, <code><a href="pdist.html#topic+pdist">pdist</a></code>.
</p>

<hr>
<h2 id='autocor.plot'>Plot of the autocorrelgram for posterior samples</h2><span id='topic+autocor.plot'></span>

<h3>Description</h3>

<p>Plots the autocorrelogram for the posterior samples of the model parameters and spatial random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocor.plot(object, param, component.beta = NULL, component.S = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autocor.plot_+3A_object">object</code></td>
<td>
<p>an object of class 'Bayes.PrevMap'.</p>
</td></tr>
<tr><td><code id="autocor.plot_+3A_param">param</code></td>
<td>
<p>a character indicating for which component of the model the autocorrelation plot is required: <code>param="beta"</code> for the regression coefficients; <code>param="sigma2"</code> for the variance of the spatial random effect; <code>param="phi"</code> for the scale parameter of the Matern correlation function; <code>param="tau2"</code> for the variance of the nugget effect; <code>param="S"</code> for the spatial random effect.</p>
</td></tr>
<tr><td><code id="autocor.plot_+3A_component.beta">component.beta</code></td>
<td>
<p>if <code>param="beta"</code>, <code>component.beta</code> is a numeric value indicating the component of the regression coefficients; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="autocor.plot_+3A_component.s">component.S</code></td>
<td>
<p>if <code>param="S"</code>, <code>component.S</code> can be a numeric value indicating the component of the spatial random effect, or set equal to <code>"all"</code> if the autocorrelgram should be plotted for all the components. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='binary.probit.Bayes'>Bayesian estimation for the two-levels binary probit model</h2><span id='topic+binary.probit.Bayes'></span>

<h3>Description</h3>

<p>This function performs Bayesian estimation for a geostatistical binary probit model. It also allows to specify a two-levels model so as to include individual-level and household-level (or any other unit comprising a group of individuals, e.g. village, school, compound, etc...) variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary.probit.Bayes(
  formula,
  coords,
  data,
  ID.coords,
  control.prior,
  control.mcmc,
  kappa,
  low.rank = FALSE,
  knots = NULL,
  messages = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binary.probit.Bayes_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="binary.probit.Bayes_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the geographic coordinates.</p>
</td></tr>
<tr><td><code id="binary.probit.Bayes_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="binary.probit.Bayes_+3A_id.coords">ID.coords</code></td>
<td>
<p>vector of ID values for the unique set of spatial coordinates obtained from <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>. These must be provided in order to specify spatial random effects at household-level. <b>Warning</b>: the household coordinates must all be distinct otherwise see <code>jitterDupCoords</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="binary.probit.Bayes_+3A_control.prior">control.prior</code></td>
<td>
<p>output from <code><a href="#topic+control.prior">control.prior</a></code>.</p>
</td></tr>
<tr><td><code id="binary.probit.Bayes_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="binary.probit.Bayes_+3A_kappa">kappa</code></td>
<td>
<p>value for the shape parameter of the Matern covariance function.</p>
</td></tr>
<tr><td><code id="binary.probit.Bayes_+3A_low.rank">low.rank</code></td>
<td>
<p>logical; if <code>low.rank=TRUE</code> a low-rank approximation is required. Default is <code>low.rank=FALSE</code>.</p>
</td></tr>
<tr><td><code id="binary.probit.Bayes_+3A_knots">knots</code></td>
<td>
<p>if <code>low.rank=TRUE</code>, <code>knots</code> is a matrix of spatial knots used in the low-rank approximation. Default is <code>knots=NULL</code>.</p>
</td></tr>
<tr><td><code id="binary.probit.Bayes_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs Bayesian estimation for the parameters of the geostatistical binary probit model. Let <code class="reqn">i</code> and <code class="reqn">j</code> denote the indices of the <code class="reqn">i</code>-th household and <code class="reqn">j</code>-th individual within that household. The response variable <code class="reqn">Y_{ij}</code> is a binary indicator taking value 1 if the individual has been tested positive for the disease of interest and 0 otherwise. Conditionally on a zero-mean stationary Gaussian process <code class="reqn">S(x_{i})</code>, <code class="reqn">Y_{ij}</code> are mutually independent Bernoulli variables with probit link function <code class="reqn">\Phi^{-1}(\cdot)</code>, i.e.
</p>
<p style="text-align: center;"><code class="reqn">\Phi^{-1}(p_{ij}) = d_{ij}'\beta + S(x_{i}),</code>
</p>

<p>where <code class="reqn">d_{ij}</code> is a vector of covariates, both at individual- and household-level, with associated regression coefficients <code class="reqn">\beta</code>. The Gaussian process <code class="reqn">S(x)</code> has isotropic Matern covariance function (see <code>matern</code>) with variance <code>sigma2</code>, scale parameter <code>phi</code> and shape parameter <code>kappa</code>.
</p>
<p><b>Priors definition.</b> Priors can be defined through the function <code><a href="#topic+control.prior">control.prior</a></code>. The hierarchical structure of the priors is the following. Let <code class="reqn">\theta</code> be the vector of the covariance parameters <code>c(sigma2,phi)</code>; each component of <code class="reqn">\theta</code> has independent priors that can be freely defined by the user. However, in  <code><a href="#topic+control.prior">control.prior</a></code> uniform and log-normal priors are also available as default priors for each of the covariance parameters. The vector of regression coefficients <code>beta</code> has a multivariate Gaussian prior with mean <code>beta.mean</code> and covariance matrix <code>beta.covar</code>.
</p>
<p><b>Updating regression coefficents and random effects using auxiliary variables.</b> To update <code class="reqn">\beta</code> and <code class="reqn">S(x_{i})</code>, we use an auxiliary variable technique based on Rue and Held (2005). Let <code class="reqn">V_{ij}</code> denote a set of random variables that conditionally on <code class="reqn">\beta</code> and <code class="reqn">S(x_{i})</code>, are mutually independent Gaussian with mean <code class="reqn">d_{ij}'\beta + S(x_{i})</code> and unit variance. Then, <code class="reqn">Y_{ij}=1</code> if <code class="reqn">V_{ij} &gt; 0</code> and <code class="reqn">Y_{ij}=0</code> otherwise. Using this representation of the model, we use a Gibbs sampler to simulate from the full conditionals of <code class="reqn">\beta</code>, <code class="reqn">S(x_{i})</code> and <code class="reqn">V_{ij}</code>. See Section 4.3 of Rue and Held (2005) for more details.
</p>
<p><b>Updating the covariance parameters with a Metropolis-Hastings algorithm.</b> In the MCMC algorithm implemented in <code>binary.probit.Bayes</code>, the transformed parameters </p>
<p style="text-align: center;"><code class="reqn">(\theta_{1}, \theta_{2})=(\log(\sigma^2)/2,\log(\sigma^2/\phi^{2 \kappa}))</code>
</p>
<p> are independently updated using a Metropolis Hastings algorithm. At the <code class="reqn">i</code>-th iteration, a new value is proposed for each parameter from a univariate Gaussian distrubion with variance <code class="reqn">h_{i}^2</code>. This is tuned using the following adaptive scheme </p>
<p style="text-align: center;"><code class="reqn">h_{i} = h_{i-1}+c_{1}i^{-c_{2}}(\alpha_{i}-0.45),</code>
</p>
<p> where <code class="reqn">\alpha_{i}</code> is the acceptance rate at the <code class="reqn">i</code>-th iteration, 0.45 is the optimal acceptance rate for a univariate Gaussian distribution, whilst <code class="reqn">c_{1} &gt; 0</code> and <code class="reqn">0 &lt; c_{2} &lt; 1</code> are pre-defined constants. The starting values <code class="reqn">h_{1}</code> for each of the parameters <code class="reqn">\theta_{1}</code> and <code class="reqn">\theta_{2}</code> can be set using the function <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code> through the arguments <code>h.theta1</code>, <code>h.theta2</code> and <code>h.theta3</code>. To define values for <code class="reqn">c_{1}</code> and <code class="reqn">c_{2}</code>, see the documentation of <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code>.
</p>
<p><b>Low-rank approximation.</b>
In the case of very large spatial data-sets, a low-rank approximation of the Gaussian spatial process <code class="reqn">S(x)</code> might be computationally beneficial. Let <code class="reqn">(x_{1},\dots,x_{m})</code> and <code class="reqn">(t_{1},\dots,t_{m})</code> denote the set of sampling locations and a grid of spatial knots covering the area of interest, respectively. Then <code class="reqn">S(x)</code> is approximated as <code class="reqn">\sum_{i=1}^m K(\|x-t_{i}\|; \phi, \kappa)U_{i}</code>, where <code class="reqn">U_{i}</code> are zero-mean mutually independent Gaussian variables with variance <code>sigma2</code> and <code class="reqn">K(.;\phi, \kappa)</code> is the isotropic Matern kernel (see <code><a href="#topic+matern.kernel">matern.kernel</a></code>). Since the resulting approximation is no longer a stationary process (but only approximately), <code>sigma2</code> may take very different values from the actual variance of the Gaussian process to approximate. The function <code><a href="#topic+adjust.sigma2">adjust.sigma2</a></code> can then be used to (approximately) explore the range for <code>sigma2</code>. For example if the variance of the Gaussian process is <code>0.5</code>, then an approximate value for <code>sigma2</code> is <code>0.5/const.sigma2</code>, where <code>const.sigma2</code> is the value obtained with <code><a href="#topic+adjust.sigma2">adjust.sigma2</a></code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;Bayes.PrevMap&quot;.
The function <code><a href="#topic+summary.Bayes.PrevMap">summary.Bayes.PrevMap</a></code> is used to print a summary of the fitted model.
The object is a list with the following components:
</p>
<p><code>estimate</code>: matrix of the posterior samples of the model parameters.
</p>
<p><code>S</code>: matrix of the posterior samples for each component of the random effect.
</p>
<p><code>const.sigma2</code>: vector of the values of the multiplicative factor used to adjust the values of <code>sigma2</code> in the low-rank approximation.
</p>
<p><code>y</code>: binary observations.
</p>
<p><code>D</code>: matrix of covariarates.
</p>
<p><code>coords</code>: matrix of the observed sampling locations.
</p>
<p><code>kappa</code>: shape parameter of the Matern function.
</p>
<p><code>ID.coords</code>: set of ID values defined through the argument <code>ID.coords</code>.
</p>
<p><code>knots</code>: matrix of spatial knots used in the low-rank approximation.
</p>
<p><code>h1</code>: vector of values taken by the tuning parameter <code>h.theta1</code> at each iteration.
</p>
<p><code>h2</code>: vector of values taken by the tuning parameter <code>h.theta2</code> at each iteration.
</p>
<p><code>call</code>: the matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Giorgi, E. (2019). <em>Model-based Geostatistics for Global Public Health.</em> CRC/Chapman &amp; Hall.
</p>
<p>Giorgi, E., Diggle, P.J. (2017). <em>PrevMap: an R package for prevalence mapping.</em> Journal of Statistical Software. 78(8), 1-29. doi: 10.18637/jss.v078.i08
</p>
<p>Rue, H., Held, L. (2005). <em>Gaussian Markov Random Fields: Theory and Applications.</em> Chapman &amp; Hall, London.
</p>
<p>Higdon, D. (1998). <em>A process-convolution approach to modeling temperatures in the North Atlantic Ocean.</em> Environmental and Ecological Statistics 5, 173-190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code>,  <code><a href="#topic+control.prior">control.prior</a></code>,<code><a href="#topic+summary.Bayes.PrevMap">summary.Bayes.PrevMap</a></code>, <code>matern</code>, <code><a href="#topic+matern.kernel">matern.kernel</a></code>, <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>.
</p>

<hr>
<h2 id='binomial.logistic.Bayes'>Bayesian estimation for the binomial logistic model</h2><span id='topic+binomial.logistic.Bayes'></span>

<h3>Description</h3>

<p>This function performs Bayesian estimation for a geostatistical binomial logistic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial.logistic.Bayes(
  formula,
  units.m,
  coords,
  data,
  ID.coords = NULL,
  control.prior,
  control.mcmc,
  kappa,
  low.rank = FALSE,
  knots = NULL,
  messages = TRUE,
  mesh = NULL,
  SPDE = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binomial.logistic.Bayes_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_units.m">units.m</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the binomial denominators.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the geographic coordinates.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_id.coords">ID.coords</code></td>
<td>
<p>vector of ID values for the unique set of spatial coordinates obtained from <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>. These must be provided if, for example, spatial random effects are defined at household level but some of the covariates are at individual level. <b>Warning</b>: the household coordinates must all be distinct otherwise see <code>jitterDupCoords</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_control.prior">control.prior</code></td>
<td>
<p>output from <code><a href="#topic+control.prior">control.prior</a></code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_kappa">kappa</code></td>
<td>
<p>value for the shape parameter of the Matern covariance function.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_low.rank">low.rank</code></td>
<td>
<p>logical; if <code>low.rank=TRUE</code> a low-rank approximation is required. Default is <code>low.rank=FALSE</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_knots">knots</code></td>
<td>
<p>if <code>low.rank=TRUE</code>, <code>knots</code> is a matrix of spatial knots used in the low-rank approximation. Default is <code>knots=NULL</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_mesh">mesh</code></td>
<td>
<p>an object obtained as result of a call to the function <code>inla.mesh.2d</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.Bayes_+3A_spde">SPDE</code></td>
<td>
<p>logical; if <code>SPDE=TRUE</code> the SPDE approximation for the Gaussian spatial model is used. Default is <code>SPDE=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs Bayesian estimation for the parameters of the geostatistical binomial logistic model. Conditionally on a zero-mean stationary Gaussian process <code class="reqn">S(x)</code> and mutually independent zero-mean Gaussian variables <code class="reqn">Z</code> with variance <code>tau2</code>, the linear predictor assumes the form
</p>
<p style="text-align: center;"><code class="reqn">\log(p/(1-p)) = d'\beta + S(x) + Z,</code>
</p>

<p>where <code class="reqn">d</code> is a vector of covariates with associated regression coefficients <code class="reqn">\beta</code>. The Gaussian process <code class="reqn">S(x)</code> has isotropic Matern covariance function (see <code>matern</code>) with variance <code>sigma2</code>, scale parameter <code>phi</code> and shape parameter <code>kappa</code>.
</p>
<p><b>Priors definition.</b> Priors can be defined through the function <code><a href="#topic+control.prior">control.prior</a></code>. The hierarchical structure of the priors is the following. Let <code class="reqn">\theta</code> be the vector of the covariance parameters <code>c(sigma2,phi,tau2)</code>; then each component of <code class="reqn">\theta</code> has independent priors freely defined by the user. However, in  <code><a href="#topic+control.prior">control.prior</a></code> uniform and log-normal priors are also available as default priors for each of the covariance parameters. To remove the nugget effect <code class="reqn">Z</code>, no prior should be defined for <code>tau2</code>. Conditionally on <code>sigma2</code>, the vector of regression coefficients <code>beta</code> has a multivariate Gaussian prior with mean <code>beta.mean</code> and covariance matrix <code>sigma2*beta.covar</code>, while in the low-rank approximation the covariance matrix is simply <code>beta.covar</code>.
</p>
<p><b>Updating the covariance parameters with a Metropolis-Hastings algorithm.</b> In the MCMC algorithm implemented in <code>binomial.logistic.Bayes</code>, the transformed parameters </p>
<p style="text-align: center;"><code class="reqn">(\theta_{1}, \theta_{2}, \theta_{3})=(\log(\sigma^2)/2,\log(\sigma^2/\phi^{2 \kappa}), \log(\tau^2))</code>
</p>
<p> are independently updated using a Metropolis Hastings algorithm. At the <code class="reqn">i</code>-th iteration, a new value is proposed for each from a univariate Gaussian distrubion with variance <code class="reqn">h_{i}^2</code> that is tuned using the following adaptive scheme </p>
<p style="text-align: center;"><code class="reqn">h_{i} = h_{i-1}+c_{1}i^{-c_{2}}(\alpha_{i}-0.45),</code>
</p>
<p> where <code class="reqn">\alpha_{i}</code> is the acceptance rate at the <code class="reqn">i</code>-th iteration, 0.45 is the optimal acceptance rate for a univariate Gaussian distribution, whilst <code class="reqn">c_{1} &gt; 0</code> and <code class="reqn">0 &lt; c_{2} &lt; 1</code> are pre-defined constants. The starting values <code class="reqn">h_{1}</code> for each of the parameters <code class="reqn">\theta_{1}</code>, <code class="reqn">\theta_{2}</code> and <code class="reqn">\theta_{3}</code> can be set using the function <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code> through the arguments <code>h.theta1</code>, <code>h.theta2</code> and <code>h.theta3</code>. To define values for <code class="reqn">c_{1}</code> and <code class="reqn">c_{2}</code>, see the documentation of <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code>.
</p>
<p><b>Hamiltonian Monte Carlo.</b> The MCMC algorithm in <code>binomial.logistic.Bayes</code> uses a Hamiltonian Monte Carlo (HMC) procedure to update the random effect <code class="reqn">T=d'\beta + S(x) + Z</code>; see Neal (2011) for an introduction to HMC. HMC makes use of a postion vector, say <code class="reqn">t</code>, representing the random effect <code class="reqn">T</code>, and a momentum vector, say <code class="reqn">q</code>, of the same length of the position vector, say <code class="reqn">n</code>. Hamiltonian dynamics also have a physical interpretation where the states of the system are described by the position of a puck and its momentum (its mass times its velocity). The Hamiltonian function is then defined as a function of <code class="reqn">t</code> and <code class="reqn">q</code>, having the form <code class="reqn">H(t,q) = -\log\{f(t | y, \beta, \theta)\} + q'q/2</code>, where <code class="reqn">f(t | y, \beta, \theta)</code> is the conditional distribution of <code class="reqn">T</code> given the data <code class="reqn">y</code>, the regression parameters <code class="reqn">\beta</code> and covariance parameters <code class="reqn">\theta</code>. The system of Hamiltonian equations then defines the evolution of the system in time, which can be used to implement an algorithm for simulation from the posterior distribution of <code class="reqn">T</code>. In order to implement the Hamiltonian dynamic on a computer, the Hamiltonian equations must be discretised. The <em>leapfrog method</em> is then used for this purpose, where two tuning parameters should be defined: the stepsize <code class="reqn">\epsilon</code> and the number of steps <code class="reqn">L</code>. These respectively correspond to <code>epsilon.S.lim</code> and <code>L.S.lim</code> in the <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code> function. However, it is advisable to let <code class="reqn">epsilon</code> and <code class="reqn">L</code> take different random values at each iteration of the HCM algorithm so as to account for the different variances amongst the components of the posterior of <code class="reqn">T</code>. This can be done in <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code> by defning <code>epsilon.S.lim</code> and <code>L.S.lim</code> as vectors of two elements, each of which represents the lower and upper limit of a uniform distribution used to generate values for  <code>epsilon.S.lim</code> and <code>L.S.lim</code>, respectively.
</p>
<p><b>Using a two-level model to include household-level and individual-level information.</b>
When analysing data from household sruveys, some of the avilable information information might be at household-level (e.g. material of house, temperature) and some at individual-level (e.g. age, gender). In this case, the Gaussian spatial process <code class="reqn">S(x)</code> and the nugget effect <code class="reqn">Z</code> are defined at hosuehold-level in order to account for extra-binomial variation between and within households, respectively.
</p>
<p><b>Low-rank approximation.</b>
In the case of very large spatial data-sets, a low-rank approximation of the Gaussian spatial process <code class="reqn">S(x)</code> might be computationally beneficial. Let <code class="reqn">(x_{1},\dots,x_{m})</code> and <code class="reqn">(t_{1},\dots,t_{m})</code> denote the set of sampling locations and a grid of spatial knots covering the area of interest, respectively. Then <code class="reqn">S(x)</code> is approximated as <code class="reqn">\sum_{i=1}^m K(\|x-t_{i}\|; \phi, \kappa)U_{i}</code>, where <code class="reqn">U_{i}</code> are zero-mean mutually independent Gaussian variables with variance <code>sigma2</code> and <code class="reqn">K(.;\phi, \kappa)</code> is the isotropic Matern kernel (see <code><a href="#topic+matern.kernel">matern.kernel</a></code>). Since the resulting approximation is no longer a stationary process (but only approximately), <code>sigma2</code> may take very different values from the actual variance of the Gaussian process to approximate. The function <code><a href="#topic+adjust.sigma2">adjust.sigma2</a></code> can then be used to (approximately) explore the range for <code>sigma2</code>. For example if the variance of the Gaussian process is <code>0.5</code>, then an approximate value for <code>sigma2</code> is <code>0.5/const.sigma2</code>, where <code>const.sigma2</code> is the value obtained with <code><a href="#topic+adjust.sigma2">adjust.sigma2</a></code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;Bayes.PrevMap&quot;.
The function <code><a href="#topic+summary.Bayes.PrevMap">summary.Bayes.PrevMap</a></code> is used to print a summary of the fitted model.
The object is a list with the following components:
</p>
<p><code>estimate</code>: matrix of the posterior samples of the model parameters.
</p>
<p><code>S</code>: matrix of the posterior samples for each component of the random effect.
</p>
<p><code>const.sigma2</code>: vector of the values of the multiplicative factor used to adjust the values of <code>sigma2</code> in the low-rank approximation.
</p>
<p><code>y</code>: binomial observations.
</p>
<p><code>units.m</code>: binomial denominators.
</p>
<p><code>D</code>: matrix of covariarates.
</p>
<p><code>coords</code>: matrix of the observed sampling locations.
</p>
<p><code>kappa</code>: shape parameter of the Matern function.
</p>
<p><code>ID.coords</code>: set of ID values defined through the argument <code>ID.coords</code>.
</p>
<p><code>knots</code>: matrix of spatial knots used in the low-rank approximation.
</p>
<p><code>h1</code>: vector of values taken by the tuning parameter <code>h.theta1</code> at each iteration.
</p>
<p><code>h2</code>: vector of values taken by the tuning parameter <code>h.theta2</code> at each iteration.
</p>
<p><code>h3</code>: vector of values taken by the tuning parameter <code>h.theta3</code> at each iteration.
</p>
<p><code>acc.beta.S</code>: empirical acceptance rate for the regression coefficients and random effects (only if <code>SPDE=TRUE</code>).
</p>
<p><code>mesh</code>: the mesh used in the SPDE approximation.
</p>
<p><code>call</code>: the matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Giorgi, E. (2019). <em>Model-based Geostatistics for Global Public Health.</em> CRC/Chapman &amp; Hall.
</p>
<p>Giorgi, E., Diggle, P.J. (2017). <em>PrevMap: an R package for prevalence mapping.</em> Journal of Statistical Software. 78(8), 1-29. doi: 10.18637/jss.v078.i08
</p>
<p>Neal, R. M. (2011) <em>MCMC using Hamiltonian Dynamics</em>, In: Handbook of Markov Chain Monte Carlo (Chapter 5), Edited by Steve Brooks, Andrew Gelman, Galin Jones, and Xiao-Li Meng Chapman &amp; Hall / CRC Press.
</p>
<p>Higdon, D. (1998). <em>A process-convolution approach to modeling temperatures in the North Atlantic Ocean.</em> Environmental and Ecological Statistics 5, 173-190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code>,  <code><a href="#topic+control.prior">control.prior</a></code>,<code><a href="#topic+summary.Bayes.PrevMap">summary.Bayes.PrevMap</a></code>, <code>matern</code>, <code><a href="#topic+matern.kernel">matern.kernel</a></code>, <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>.
</p>

<hr>
<h2 id='binomial.logistic.MCML'>Monte Carlo Maximum Likelihood estimation for the binomial logistic model</h2><span id='topic+binomial.logistic.MCML'></span>

<h3>Description</h3>

<p>This function performs Monte Carlo maximum likelihood (MCML) estimation for the geostatistical binomial logistic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial.logistic.MCML(
  formula,
  units.m,
  coords,
  times = NULL,
  data,
  ID.coords = NULL,
  par0,
  control.mcmc,
  kappa,
  kappa.t = NULL,
  sst.model = NULL,
  fixed.rel.nugget = NULL,
  start.cov.pars,
  method = "BFGS",
  low.rank = FALSE,
  SPDE = FALSE,
  knots = NULL,
  mesh = NULL,
  messages = TRUE,
  plot.correlogram = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binomial.logistic.MCML_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_units.m">units.m</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the binomial denominators in the data.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the spatial coordinates in the data.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_times">times</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the times in the data, used in the spatio-temporal model.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_id.coords">ID.coords</code></td>
<td>
<p>vector of ID values for the unique set of spatial coordinates obtained from <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>. These must be provided if, for example, spatial random effects are defined at household level but some of the covariates are at individual level. <b>Warning</b>: the household coordinates must all be distinct otherwise see <code>jitterDupCoords</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_par0">par0</code></td>
<td>
<p>parameters of the importance sampling distribution: these should be given in the following order <code>c(beta,sigma2,phi,tau2)</code>, where <code>beta</code> are the regression coefficients, <code>sigma2</code> is the variance of the Gaussian process, <code>phi</code> is the scale parameter of the spatial correlation and <code>tau2</code> is the variance of the nugget effect (if included in the model).</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_kappa">kappa</code></td>
<td>
<p>fixed value for the shape parameter of the Matern covariance function.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_kappa.t">kappa.t</code></td>
<td>
<p>fixed value for the shape parameter of the Matern covariance function in the separable double-Matern spatio-temporal model.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_sst.model">sst.model</code></td>
<td>
<p>a character value that specifies the spatio-temporal correlation function.
</p>

<ul>
<li> <p><code>sst.model="DM"</code> separable double-Matern.
</p>
</li>
<li> <p><code>sst.model="GN1"</code> separable correlation functions. Temporal correlation: <code class="reqn">f(x) = 1/(1+x/\psi)</code>; Spatial correaltion: Matern function.
</p>
</li></ul>

<p>Deafault is <code>sst.model=NULL</code>, which is used when a purely spatial model is fitted.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_fixed.rel.nugget">fixed.rel.nugget</code></td>
<td>
<p>fixed value for the relative variance of the nugget effect; <code>fixed.rel.nugget=NULL</code> if this should be included in the estimation. Default is <code>fixed.rel.nugget=NULL</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_start.cov.pars">start.cov.pars</code></td>
<td>
<p>a vector of length two with elements corresponding to the starting values of <code>phi</code> and the relative variance of the nugget effect <code>nu2</code>, respectively, that are used in the optimization algorithm. If <code>nu2</code> is fixed through <code>fixed.rel.nugget</code>, then <code>start.cov.pars</code> represents the starting value for <code>phi</code> only.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_method">method</code></td>
<td>
<p>method of optimization. If <code>method="BFGS"</code> then the <code><a href="maxLik.html#topic+maxBFGS">maxBFGS</a></code> function is used; otherwise <code>method="nlminb"</code> to use the <code><a href="stats.html#topic+nlminb">nlminb</a></code> function. Default is <code>method="BFGS"</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_low.rank">low.rank</code></td>
<td>
<p>logical; if <code>low.rank=TRUE</code> a low-rank approximation of the Gaussian spatial process is used when fitting the model. Default is <code>low.rank=FALSE</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_spde">SPDE</code></td>
<td>
<p>logical; if <code>SPDE=TRUE</code> the SPDE approximation for the Gaussian spatial model is used. Default is <code>SPDE=FALSE</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_knots">knots</code></td>
<td>
<p>if <code>low.rank=TRUE</code>, <code>knots</code> is a matrix of spatial knots that are used in the low-rank approximation. Default is <code>knots=NULL</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_mesh">mesh</code></td>
<td>
<p>an object obtained as result of a call to the function <code>inla.mesh.2d</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="binomial.logistic.MCML_+3A_plot.correlogram">plot.correlogram</code></td>
<td>
<p>logical; if <code>plot.correlogram=TRUE</code> the autocorrelation plot of the samples of the random effect is displayed after completion of conditional simulation. Default is <code>plot.correlogram=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs parameter estimation for a geostatistical binomial logistic model. Conditionally on a zero-mean stationary Gaussian process <code class="reqn">S(x)</code> and mutually independent zero-mean Gaussian variables <code class="reqn">Z</code> with variance <code>tau2</code>, the observations <code>y</code> are generated from a binomial distribution with probability <code class="reqn">p</code> and binomial denominators <code>units.m</code>. A canonical logistic link is used, thus the linear predictor assumes the form
</p>
<p style="text-align: center;"><code class="reqn">\log(p/(1-p)) = d'\beta + S(x) + Z,</code>
</p>

<p>where <code class="reqn">d</code> is a vector of covariates with associated regression coefficients <code class="reqn">\beta</code>. The Gaussian process <code class="reqn">S(x)</code> has isotropic Matern covariance function (see <code>matern</code>) with variance <code>sigma2</code>, scale parameter <code>phi</code> and shape parameter <code>kappa</code>.
In the <code>binomial.logistic.MCML</code> function, the shape parameter is treated as fixed. The relative variance of the nugget effect, <code>nu2=tau2/sigma2</code>, can also be fixed through the argument <code>fixed.rel.nugget</code>; if <code>fixed.rel.nugget=NULL</code>, then the relative variance of the nugget effect is also included in the estimation.
</p>
<p><b>Monte Carlo Maximum likelihood.</b>
The Monte Carlo maximum likelihood method uses conditional simulation from the distribution of the random effect <code class="reqn">T(x) = d(x)'\beta+S(x)+Z</code> given the data <code>y</code>, in order to approximate the high-dimensiional intractable integral given by the likelihood function. The resulting approximation of the likelihood is then maximized by a numerical optimization algorithm which uses analytic epression for computation of the gradient vector and Hessian matrix. The functions used for numerical optimization are <code><a href="maxLik.html#topic+maxBFGS">maxBFGS</a></code> (<code>method="BFGS"</code>), from the <span class="pkg">maxLik</span> package, and <code><a href="stats.html#topic+nlminb">nlminb</a></code> (<code>method="nlminb"</code>).
</p>
<p><b>Using a two-level model to include household-level and individual-level information.</b>
When analysing data from household sruveys, some of the avilable information information might be at household-level (e.g. material of house, temperature) and some at individual-level (e.g. age, gender). In this case, the Gaussian spatial process <code class="reqn">S(x)</code> and the nugget effect <code class="reqn">Z</code> are defined at hosuehold-level in order to account for extra-binomial variation between and within households, respectively.
</p>
<p><b>Low-rank approximation.</b>
In the case of very large spatial data-sets, a low-rank approximation of the Gaussian spatial process <code class="reqn">S(x)</code> might be computationally beneficial. Let <code class="reqn">(x_{1},\dots,x_{m})</code> and <code class="reqn">(t_{1},\dots,t_{m})</code> denote the set of sampling locations and a grid of spatial knots covering the area of interest, respectively. Then <code class="reqn">S(x)</code> is approximated as <code class="reqn">\sum_{i=1}^m K(\|x-t_{i}\|; \phi, \kappa)U_{i}</code>, where <code class="reqn">U_{i}</code> are zero-mean mutually independent Gaussian variables with variance <code>sigma2</code> and <code class="reqn">K(.;\phi, \kappa)</code> is the isotropic Matern kernel (see <code><a href="#topic+matern.kernel">matern.kernel</a></code>). Since the resulting approximation is no longer a stationary process (but only approximately), the parameter <code>sigma2</code> is then multiplied by a factor <code>constant.sigma2</code> so as to obtain a value that is closer to the actual variance of <code class="reqn">S(x)</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;PrevMap&quot;.
The function <code><a href="#topic+summary.PrevMap">summary.PrevMap</a></code> is used to print a summary of the fitted model.
The object is a list with the following components:
</p>
<p><code>estimate</code>: estimates of the model parameters; use the function <code><a href="#topic+coef.PrevMap">coef.PrevMap</a></code> to obtain estimates of covariance parameters on the original scale.
</p>
<p><code>covariance</code>: covariance matrix of the MCML estimates.
</p>
<p><code>log.lik</code>: maximum value of the log-likelihood.
</p>
<p><code>y</code>: binomial observations.
</p>
<p><code>units.m</code>: binomial denominators.
</p>
<p><code>D</code>: matrix of covariates.
</p>
<p><code>coords</code>: matrix of the observed sampling locations.
</p>
<p><code>method</code>: method of optimization used.
</p>
<p><code>ID.coords</code>: set of ID values defined through the argument <code>ID.coords</code>.
</p>
<p><code>kappa</code>: fixed value of the shape parameter of the Matern function.
</p>
<p><code>kappa.t</code>: fixed value for the shape parameter of the Matern covariance function in the separable double-Matern spatio-temporal model.
</p>
<p><code>knots</code>: matrix of the spatial knots used in the low-rank approximation.
</p>
<p><code>mesh</code>: the mesh used in the SPDE approximation.
</p>
<p><code>const.sigma2</code>: adjustment factor for <code>sigma2</code> in the low-rank approximation.
</p>
<p><code>h</code>: vector of the values of the tuning parameter at each iteration of the Langevin-Hastings MCMC algorithm; see <code><a href="#topic+Laplace.sampling">Laplace.sampling</a></code>, or <code><a href="#topic+Laplace.sampling.lr">Laplace.sampling.lr</a></code> if a low-rank approximation is used.
</p>
<p><code>samples</code>: matrix of the random effects samples from the importance sampling distribution used to approximate the likelihood function.
</p>
<p><code>fixed.rel.nugget</code>: fixed value for the relative variance of the nugget effect.
</p>
<p><code>call</code>: the matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Giorgi, E. (2019). <em>Model-based Geostatistics for Global Public Health.</em> CRC/Chapman &amp; Hall.
</p>
<p>Giorgi, E., Diggle, P.J. (2017). <em>PrevMap: an R package for prevalence mapping.</em> Journal of Statistical Software. 78(8), 1-29. doi: 10.18637/jss.v078.i08
</p>
<p>Christensen, O. F. (2004). <em>Monte carlo maximum likelihood in model-based geostatistics.</em> Journal of Computational and Graphical Statistics 13, 702-718.
</p>
<p>Higdon, D. (1998). <em>A process-convolution approach to modeling temperatures in the North Atlantic Ocean.</em> Environmental and Ecological Statistics 5, 173-190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Laplace.sampling">Laplace.sampling</a></code>, <code><a href="#topic+Laplace.sampling.lr">Laplace.sampling.lr</a></code>, <code><a href="#topic+summary.PrevMap">summary.PrevMap</a></code>, <code><a href="#topic+coef.PrevMap">coef.PrevMap</a></code>, <code>matern</code>, <code><a href="#topic+matern.kernel">matern.kernel</a></code>,  <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>, <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>.
</p>

<hr>
<h2 id='coef.PrevMap'>Extract model coefficients</h2><span id='topic+coef.PrevMap'></span>

<h3>Description</h3>

<p><code>coef</code> extracts parameters estimates from models fitted with the functions <code><a href="#topic+linear.model.MLE">linear.model.MLE</a></code> and <code><a href="#topic+binomial.logistic.MCML">binomial.logistic.MCML</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PrevMap'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.PrevMap_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap&quot;.</p>
</td></tr>
<tr><td><code id="coef.PrevMap_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coefficients extracted from the model object <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='coef.PrevMap.ps'>Extract model coefficients from geostatistical linear model with preferentially sampled locations</h2><span id='topic+coef.PrevMap.ps'></span>

<h3>Description</h3>

<p><code>coef</code> extracts parameters estimates from models fitted with the functions <code><a href="#topic+lm.ps.MCML">lm.ps.MCML</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PrevMap.ps'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.PrevMap.ps_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap.ps&quot;.</p>
</td></tr>
<tr><td><code id="coef.PrevMap.ps_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of coefficients extracted from the model in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='continuous.sample'>Spatially continuous sampling</h2><span id='topic+continuous.sample'></span>

<h3>Description</h3>

<p>Draws a sample of spatial locations within a spatially continuous polygonal sampling region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous.sample(poly, n, delta, k = 0, rho = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="continuous.sample_+3A_poly">poly</code></td>
<td>
<p>boundary of a polygon.</p>
</td></tr>
<tr><td><code id="continuous.sample_+3A_n">n</code></td>
<td>
<p>number of events.</p>
</td></tr>
<tr><td><code id="continuous.sample_+3A_delta">delta</code></td>
<td>
<p>minimum permissible distance between any two events in preliminary sample.</p>
</td></tr>
<tr><td><code id="continuous.sample_+3A_k">k</code></td>
<td>
<p>number of locations in preliminary sample to be replaced by near neighbours of other preliminary sample locations in final sample (must be between 0 and <code>n/2</code>)</p>
</td></tr>
<tr><td><code id="continuous.sample_+3A_rho">rho</code></td>
<td>
<p>maximum distance between close pairs of locations in final sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To draw a sample of size <code>n</code>  from a spatially continuous region <code class="reqn">A</code>, with the property that the distance between any two sampled locations is at least <code>delta</code>, the following algorithm is used.
</p>

<ul>
<li><p>Step 1. Set <code class="reqn">i  = 1</code> and generate a point <code class="reqn">x_{1}</code>  uniformly distributed on <code class="reqn">A</code>.
</p>
</li>
<li><p>Step 2. Increase <code class="reqn">i</code>  by 1, generate a point <code class="reqn">x_{i}</code>  uniformly distributed on <code class="reqn">A</code> and calculate the minimum, <code class="reqn">d_{\min}</code>, of the distances from <code class="reqn">x_{i}</code> to all <code class="reqn">x_{j}: j &lt; i </code>.
</p>
</li>
<li><p>Step 3. If <code class="reqn">d_{\min} \ge \delta</code>, increase <code class="reqn">i</code>  by 1 and return to step 2 if <code class="reqn">i \le n</code>, otherwise stop;
</p>
</li>
<li><p>Step 4. If <code class="reqn">d_{\min} &lt; \delta</code>, return to step 2 without increasing <code class="reqn">i</code>.
</p>
</li></ul>

<p><b> Sampling close pairs of points.</b>  For some purposes, it is desirable that a spatial sampling scheme include pairs of closely spaced points. In this case, the above algorithm requires the following additional steps to be taken.
Let <code>k</code>  be the required number of close pairs. Choose a value <code>rho</code>  such that a close pair  of points will be a pair of points separated by a distance of at most <code>rho</code>.
</p>

<ul>
<li><p>Step 5. Set <code class="reqn">j  = 1</code> and draw a random sample of size 2 from the integers <code class="reqn">1,2,\ldots,n</code>, say <code class="reqn">(i_{1}; i_{2})</code>;
</p>
</li>
<li><p>Step 6. Replace <code class="reqn">x_{i_{1}}</code> by <code class="reqn">x_{i_{2}} + u</code> , where <code class="reqn">u</code>  is uniformly distributed on the disc with centre <code class="reqn">x_{i_{2}}</code> and radius <code>rho</code>, increase <code class="reqn">i</code> by 1 and return to step 5 if <code class="reqn">i \le k</code>, otherwise stop.
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix of dimension <code>n</code> by 2 containing event locations.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='contour.pred.PrevMap'>Contour plot of a predicted surface</h2><span id='topic+contour.pred.PrevMap'></span>

<h3>Description</h3>

<p><code>plot.pred.PrevMap</code> displays contours of predictions obtained from <code><a href="#topic+spatial.pred.linear.MLE">spatial.pred.linear.MLE</a></code>, <code><a href="#topic+spatial.pred.linear.Bayes">spatial.pred.linear.Bayes</a></code>,<code><a href="#topic+spatial.pred.binomial.MCML">spatial.pred.binomial.MCML</a></code> and <code><a href="#topic+spatial.pred.binomial.Bayes">spatial.pred.binomial.Bayes</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pred.PrevMap'
contour(x, type = NULL, summary = "predictions", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contour.pred.PrevMap_+3A_x">x</code></td>
<td>
<p>an object of class &quot;pred.PrevMap&quot;.</p>
</td></tr>
<tr><td><code id="contour.pred.PrevMap_+3A_type">type</code></td>
<td>
<p>a character indicating the type of prediction to display: 'prevalence', 'odds', 'logit' or 'probit'.</p>
</td></tr>
<tr><td><code id="contour.pred.PrevMap_+3A_summary">summary</code></td>
<td>
<p>character indicating which summary to display: 'predictions','quantiles', 'standard.errors' or 'exceedance.prob'; default is 'predictions'. If <code>summary="exceedance.prob"</code>, the argument <code>type</code> is ignored.</p>
</td></tr>
<tr><td><code id="contour.pred.PrevMap_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+contour">contour</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='control.mcmc.Bayes'>Control settings for the MCMC algorithm used for Bayesian inference</h2><span id='topic+control.mcmc.Bayes'></span>

<h3>Description</h3>

<p>This function defines the different tuning parameter that are used in the MCMC algorithm for Bayesian inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.mcmc.Bayes(
  n.sim,
  burnin,
  thin,
  h.theta1 = 0.01,
  h.theta2 = 0.01,
  h.theta3 = 0.01,
  L.S.lim = NULL,
  epsilon.S.lim = NULL,
  start.beta = "prior mean",
  start.sigma2 = "prior mean",
  start.phi = "prior mean",
  start.S = "prior mean",
  start.nugget = "prior mean",
  c1.h.theta1 = 0.01,
  c2.h.theta1 = 1e-04,
  c1.h.theta2 = 0.01,
  c2.h.theta2 = 1e-04,
  c1.h.theta3 = 0.01,
  c2.h.theta3 = 1e-04,
  linear.model = FALSE,
  binary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control.mcmc.Bayes_+3A_n.sim">n.sim</code></td>
<td>
<p>total number of simulations.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_burnin">burnin</code></td>
<td>
<p>initial number of samples to be discarded.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_thin">thin</code></td>
<td>
<p>value used to retain only evey <code>thin</code>-th sampled value.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_h.theta1">h.theta1</code></td>
<td>
<p>starting value of the tuning parameter of the proposal distribution for <code class="reqn">\theta_{1} = \log(\sigma^2)/2</code>. See 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_h.theta2">h.theta2</code></td>
<td>
<p>starting value of the tuning parameter of the proposal distribution for <code class="reqn">\theta_{2} = \log(\sigma^2/\phi^{2 \kappa})</code>. See 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_h.theta3">h.theta3</code></td>
<td>
<p>starting value of the tuning parameter of the proposal distribution for <code class="reqn">\theta_{3} = \log(\tau^2)</code>. See 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_l.s.lim">L.S.lim</code></td>
<td>
<p>an atomic value or a vector of length 2 that is used to define the number of steps used at each iteration in the Hamiltonian Monte Carlo algorithm to update the spatial random effect; if a single value is provided than the number of steps is kept fixed, otherwise if a vector of length 2 is provided the number of steps is simulated at each iteration as <code>floor(runif(1,L.S.lim[1],L.S.lim[2]+1))</code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_epsilon.s.lim">epsilon.S.lim</code></td>
<td>
<p>an atomic value or a vector of length 2 that is used to define the stepsize used at each iteration in the Hamiltonian Monte Carlo algorithm to update the spatial random effect; if a single value is provided than the stepsize is kept fixed, otherwise if a vector of length 2 is provided the stepsize is simulated at each iteration as <code>runif(1,epsilon.S.lim[1],epsilon.S.lim[2])</code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_start.beta">start.beta</code></td>
<td>
<p>starting value for the regression coefficients <code>beta</code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_start.sigma2">start.sigma2</code></td>
<td>
<p>starting value for <code>sigma2</code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_start.phi">start.phi</code></td>
<td>
<p>starting value for <code>phi</code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_start.s">start.S</code></td>
<td>
<p>starting value for the spatial random effect.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_start.nugget">start.nugget</code></td>
<td>
<p>starting value for the variance of the nugget effect; default is <code>NULL</code> if the nugget effect is not present.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_c1.h.theta1">c1.h.theta1</code></td>
<td>
<p>value of <code class="reqn">c_{1}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(sigma2)/2</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_c2.h.theta1">c2.h.theta1</code></td>
<td>
<p>value of <code class="reqn">c_{2}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(sigma2)/2</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_c1.h.theta2">c1.h.theta2</code></td>
<td>
<p>value of <code class="reqn">c_{1}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(sigma2.curr/(phi.curr^(2*kappa)))</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_c2.h.theta2">c2.h.theta2</code></td>
<td>
<p>value of <code class="reqn">c_{2}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(sigma2.curr/(phi.curr^(2*kappa)))</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_c1.h.theta3">c1.h.theta3</code></td>
<td>
<p>value of <code class="reqn">c_{1}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(tau2)</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_c2.h.theta3">c2.h.theta3</code></td>
<td>
<p>value of <code class="reqn">c_{2}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(tau2)</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_linear.model">linear.model</code></td>
<td>
<p>logical; if     <code>linear.model=TRUE</code>, the control parameters are set for the geostatistical linear model. Default is <code>linear.model=FALSE</code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes_+3A_binary">binary</code></td>
<td>
<p>logical; if <code>binary=TRUE</code>, the control parameters are set the binary geostatistical model. Default is <code>binary=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;mcmc.Bayes.PrevMap&quot;.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='control.mcmc.Bayes.SPDE'>Control settings for the MCMC algorithm used for Bayesian inference using SPDE</h2><span id='topic+control.mcmc.Bayes.SPDE'></span>

<h3>Description</h3>

<p>This function defines the different tuning parameter that are used in the MCMC algorithm for Bayesian inference using a SPDE approximation for the spatial Gaussian process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.mcmc.Bayes.SPDE(
  n.sim,
  burnin,
  thin,
  h.theta1 = 0.01,
  h.theta2 = 0.01,
  start.beta = "prior mean",
  start.sigma2 = "prior mean",
  start.phi = "prior mean",
  start.S = "prior mean",
  n.iter = 1,
  h = 1,
  c1.h.theta1 = 0.01,
  c2.h.theta1 = 1e-04,
  c1.h.theta2 = 0.01,
  c2.h.theta2 = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_n.sim">n.sim</code></td>
<td>
<p>total number of simulations.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_burnin">burnin</code></td>
<td>
<p>initial number of samples to be discarded.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_thin">thin</code></td>
<td>
<p>value used to retain only evey <code>thin</code>-th sampled value.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_h.theta1">h.theta1</code></td>
<td>
<p>starting value of the tuning parameter of the proposal distribution for <code class="reqn">\theta_{1} = \log(\sigma^2)/2</code>. See 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_h.theta2">h.theta2</code></td>
<td>
<p>starting value of the tuning parameter of the proposal distribution for <code class="reqn">\theta_{2} = \log(\sigma^2/\phi^{2 \kappa})</code>. See 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_start.beta">start.beta</code></td>
<td>
<p>starting value for the regression coefficients <code>beta</code>. If not provided the prior mean is used.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_start.sigma2">start.sigma2</code></td>
<td>
<p>starting value for <code>sigma2</code>. If not provided the prior mean is used.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_start.phi">start.phi</code></td>
<td>
<p>starting value for <code>phi</code>. If not provided the prior mean is used.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_start.s">start.S</code></td>
<td>
<p>starting value for the spatial random effect. If not provided the prior mean is used.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iteration of the Newton-Raphson procedure used to compute the mean and coviariance matrix of the Gaussian proposal in the MCMC; defaut is <code>n.iter=1</code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_h">h</code></td>
<td>
<p>tuning parameter for the covariance matrix of the Gaussian proposal. Default is <code>h=1</code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_c1.h.theta1">c1.h.theta1</code></td>
<td>
<p>value of <code class="reqn">c_{1}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(sigma2)/2</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_c2.h.theta1">c2.h.theta1</code></td>
<td>
<p>value of <code class="reqn">c_{2}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(sigma2)/2</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_c1.h.theta2">c1.h.theta2</code></td>
<td>
<p>value of <code class="reqn">c_{1}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(sigma2.curr/(phi.curr^(2*kappa)))</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.Bayes.SPDE_+3A_c2.h.theta2">c2.h.theta2</code></td>
<td>
<p>value of <code class="reqn">c_{2}</code> used to adaptively tune the variance of the Gaussian proposal for the transformed parameter <code>log(sigma2.curr/(phi.curr^(2*kappa)))</code>; see 'Details' in <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;mcmc.Bayes.PrevMap&quot;.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='control.mcmc.MCML'>Control settings for the MCMC algorithm used for classical inference on a binomial logistic model</h2><span id='topic+control.mcmc.MCML'></span>

<h3>Description</h3>

<p>This function defines the options for the MCMC algorithm used in the Monte Carlo maximum likelihood method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.mcmc.MCML(n.sim, burnin, thin = 1, h = NULL, c1.h = 0.01, c2.h = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control.mcmc.MCML_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="control.mcmc.MCML_+3A_burnin">burnin</code></td>
<td>
<p>length of the burn-in period.</p>
</td></tr>
<tr><td><code id="control.mcmc.MCML_+3A_thin">thin</code></td>
<td>
<p>only every <code>thin</code> iterations, a sample is stored; default is <code>thin=1</code>.</p>
</td></tr>
<tr><td><code id="control.mcmc.MCML_+3A_h">h</code></td>
<td>
<p>tuning parameter of the proposal distribution used in the Langevin-Hastings MCMC algorithm (see <code><a href="#topic+Laplace.sampling">Laplace.sampling</a></code> and <code><a href="#topic+Laplace.sampling.lr">Laplace.sampling.lr</a></code>); default is <code>h=NULL</code> and then set internally as <code class="reqn">1.65/n^(1/6)</code>, where <code class="reqn">n</code> is the dimension of the random effect.</p>
</td></tr>
<tr><td><code id="control.mcmc.MCML_+3A_c1.h">c1.h</code></td>
<td>
<p>value of <code class="reqn">c_{1}</code> used in the adaptive scheme for <code>h</code>; default is <code>c1.h=0.01</code>. See also 'Details' in <code><a href="#topic+binomial.logistic.MCML">binomial.logistic.MCML</a></code></p>
</td></tr>
<tr><td><code id="control.mcmc.MCML_+3A_c2.h">c2.h</code></td>
<td>
<p>value of <code class="reqn">c_{2}</code> used in the adaptive scheme for <code>h</code>; default is <code>c1.h=0.01</code>. See also 'Details' in <code><a href="#topic+binomial.logistic.MCML">binomial.logistic.MCML</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with processed arguments to be passed to the main function.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>control.mcmc &lt;- control.mcmc.MCML(n.sim=1000,burnin=100,thin=1,h=0.05)
str(control.mcmc)
</code></pre>

<hr>
<h2 id='control.prior'>Priors specification</h2><span id='topic+control.prior'></span>

<h3>Description</h3>

<p>This function is used to define priors for the model parameters of a Bayesian geostatistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.prior(
  beta.mean,
  beta.covar,
  log.prior.sigma2 = NULL,
  log.prior.phi = NULL,
  log.prior.nugget = NULL,
  uniform.sigma2 = NULL,
  log.normal.sigma2 = NULL,
  uniform.phi = NULL,
  log.normal.phi = NULL,
  uniform.nugget = NULL,
  log.normal.nugget = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control.prior_+3A_beta.mean">beta.mean</code></td>
<td>
<p>mean vector of the Gaussian prior for the regression coefficients.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_beta.covar">beta.covar</code></td>
<td>
<p>covariance matrix of the Gaussian prior for the regression coefficients.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_log.prior.sigma2">log.prior.sigma2</code></td>
<td>
<p>a function corresponding to the log-density of the prior distribution for the variance <code>sigma2</code> of the Gaussian process. <b>Warning:</b> if a low-rank approximation is used, then <code>sigma2</code> corresponds to the variance of the iid zero-mean Gaussian variables. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_log.prior.phi">log.prior.phi</code></td>
<td>
<p>a function corresponding to the log-density of the prior distribution for the scale parameter of the Matern correlation function; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_log.prior.nugget">log.prior.nugget</code></td>
<td>
<p>optional: a function corresponding to the log-density of the prior distribution for the variance of the nugget effect; default is <code>NULL</code> with no nugget incorporated in the model; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_uniform.sigma2">uniform.sigma2</code></td>
<td>
<p>a vector of length two, corresponding to the lower and upper limit of the uniform prior on <code>sigma2</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_log.normal.sigma2">log.normal.sigma2</code></td>
<td>
<p>a vector of length two, corresponding to the mean and standard deviation of the distribution on the log scale for the log-normal prior on <code>sigma2</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_uniform.phi">uniform.phi</code></td>
<td>
<p>a vector of length two, corresponding to the lower and upper limit of the uniform prior on <code>phi</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_log.normal.phi">log.normal.phi</code></td>
<td>
<p>a vector of length two, corresponding to the mean and standard deviation of the distribution on the log scale for the log-normal prior on <code>phi</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_uniform.nugget">uniform.nugget</code></td>
<td>
<p>a vector of length two, corresponding to the lower and upper limit of the uniform prior on <code>tau2</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.prior_+3A_log.normal.nugget">log.normal.nugget</code></td>
<td>
<p>a vector of length two, corresponding to the mean and standard deviation of the distribution on the log scale for the log-normal prior on <code>tau2</code>. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list corresponding the prior distributions for each model parameter.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>See Also</h3>

<p>See &quot;Priors definition&quot; in the Details section of the <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> function.
</p>

<hr>
<h2 id='control.profile'>Auxliary function for controlling profile log-likelihood in the linear Gaussian model</h2><span id='topic+control.profile'></span>

<h3>Description</h3>

<p>Auxiliary function used by <code><a href="#topic+loglik.linear.model">loglik.linear.model</a></code>. This function defines whether the profile-loglikelihood should be computed or evaluation of the likelihood is required by keeping the other parameters fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.profile(
  phi = NULL,
  rel.nugget = NULL,
  fixed.beta = NULL,
  fixed.sigma2 = NULL,
  fixed.phi = NULL,
  fixed.rel.nugget = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="control.profile_+3A_phi">phi</code></td>
<td>
<p>a vector of the different values that should be used in the likelihood evalutation for the scale parameter <code>phi</code>, or <code>NULL</code> if a single value is provided either as first argument in <code>start.par</code> (for profile likelihood maximization) or as fixed value in <code>fixed.phi</code>; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.profile_+3A_rel.nugget">rel.nugget</code></td>
<td>
<p>a vector of the different values that should be used in the likelihood evalutation for the relative variance of the nugget effect <code>nu2</code>, or <code>NULL</code> if a single value is provided either in <code>start.par</code> (for profile likelihood maximization) or as fixed value in <code>fixed.nu2</code>; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.profile_+3A_fixed.beta">fixed.beta</code></td>
<td>
<p>a vector for the fixed values of the regression coefficients <code>beta</code>, or <code>NULL</code> if profile log-likelihood is to be performed; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.profile_+3A_fixed.sigma2">fixed.sigma2</code></td>
<td>
<p>value for the fixed variance of the Gaussian process <code>sigma2</code>, or <code>NULL</code> if profile log-likelihood is to be performed; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.profile_+3A_fixed.phi">fixed.phi</code></td>
<td>
<p>value for the fixed scale parameter <code>phi</code> in the Matern function, or <code>NULL</code> if profile log-likelihood is to be performed; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="control.profile_+3A_fixed.rel.nugget">fixed.rel.nugget</code></td>
<td>
<p>value for the fixed relative variance of the nugget effect; <code>fixed.rel.nugget=NULL</code> if profile log-likelihood is to be performed; default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglik.linear.model">loglik.linear.model</a></code>
</p>

<hr>
<h2 id='create.ID.coords'>ID spatial coordinates</h2><span id='topic+create.ID.coords'></span>

<h3>Description</h3>

<p>Creates ID values for the unique set of coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.ID.coords(data, coords)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.ID.coords_+3A_data">data</code></td>
<td>
<p>a data frame containing the spatial coordinates.</p>
</td></tr>
<tr><td><code id="create.ID.coords_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the geographic coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of integers indicating the corresponding rows in <code>data</code> for each distinct coordinate obtained with the <code><a href="base.html#topic+unique">unique</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- runif(5)
x2 &lt;- runif(5)
data &lt;- data.frame(x1=rep(x1,each=3),x2=rep(x2,each=3))
ID.coords &lt;- create.ID.coords(data,coords=~x1+x2)
data[,c("x1","x2")]==unique(data[,c("x1","x2")])[ID.coords,]

</code></pre>

<hr>
<h2 id='data_sim'>Simulated binomial data-set over the unit square</h2><span id='topic+data_sim'></span>

<h3>Description</h3>

<p>This binomial data-set was simulated by generating a zero-mean Gaussian process over a 30 by 30 grid covering the unit square. The parameters used in the simulation are <code>sigma2=1</code>, <code>phi=0.15</code> and <code>kappa=2</code>. The nugget effect was not included, hence <code>tau2=0</code>.
The variables are as follows:
</p>

<ul>
<li><p> y binomial observations.
</p>
</li>
<li><p> units.m binomial denominators. 
</p>
</li>
<li><p> x1 horizontal coordinates.
</p>
</li>
<li><p> x2 vertical coordinates.
</p>
</li>
<li><p> S simulated values of the Gaussian process.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(data_sim)
</code></pre>


<h3>Format</h3>

<p>A data frame with 900 rows and 5 variables
</p>

<hr>
<h2 id='dens.plot'>Density plot for posterior samples</h2><span id='topic+dens.plot'></span>

<h3>Description</h3>

<p>Plots the autocorrelogram for the posterior samples of the model parameters and spatial random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens.plot(
  object,
  param,
  component.beta = NULL,
  component.S = NULL,
  hist = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dens.plot_+3A_object">object</code></td>
<td>
<p>an object of class 'Bayes.PrevMap'.</p>
</td></tr>
<tr><td><code id="dens.plot_+3A_param">param</code></td>
<td>
<p>a character indicating for which component of the model the density plot is required: <code>param="beta"</code> for the regression coefficients; <code>param="sigma2"</code> for the variance of the spatial random effect; <code>param="phi"</code> for the scale parameter of the Matern correlation function; <code>param="tau2"</code> for the variance of the nugget effect; <code>param="S"</code> for the spatial random effect.</p>
</td></tr>
<tr><td><code id="dens.plot_+3A_component.beta">component.beta</code></td>
<td>
<p>if <code>param="beta"</code>, <code>component.beta</code> is a numeric value indicating the component of the regression coefficients; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dens.plot_+3A_component.s">component.S</code></td>
<td>
<p>if <code>param="S"</code>, <code>component.S</code> can be a numeric value indicating the component of the spatial random effect. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dens.plot_+3A_hist">hist</code></td>
<td>
<p>logical; if <code>TRUE</code> a histrogram is added to density plot.</p>
</td></tr>
<tr><td><code id="dens.plot_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='discrete.sample'>Spatially discrete sampling</h2><span id='topic+discrete.sample'></span>

<h3>Description</h3>

<p>Draws a sub-sample from a set of units spatially located irregularly over some defined geographical region by imposing a minimum distance between any two sampled units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.sample(xy.all, n, delta, k = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrete.sample_+3A_xy.all">xy.all</code></td>
<td>
<p>set of locations from which the sample will be drawn.</p>
</td></tr>
<tr><td><code id="discrete.sample_+3A_n">n</code></td>
<td>
<p>size of required sample.</p>
</td></tr>
<tr><td><code id="discrete.sample_+3A_delta">delta</code></td>
<td>
<p>minimum distance between any two locations in preliminary sample.</p>
</td></tr>
<tr><td><code id="discrete.sample_+3A_k">k</code></td>
<td>
<p>number of locations in preliminary sample to be replaced by nearest neighbours of other preliminary sample locations in final sample (must be between 0 and <code>n/2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To draw a sample of size <code>n</code>  from a population of spatial locations <code class="reqn">X_{i}  : i  = 1,\ldots,N</code>, with the property that the distance between any two sampled locations is at least <code>delta</code>, the function implements the following algorithm.
</p>

<ul>
<li><p>Step 1. Draw an initial sample of size <code>n</code>  completely at random and call this <code class="reqn">x_{i}  : i  = 1,\dots, n</code>.
</p>
</li>
<li><p>Step 2. Set <code class="reqn">i  = 1</code> and calculate the minimum, <code class="reqn">d_{\min}</code>, of the distances from <code class="reqn">x_{i}</code>  to all other <code class="reqn">x_{j}</code>  in the initial sample.
</p>
</li>
<li><p>Step 3. If <code class="reqn">d_{\min} \ge \delta</code>, increase <code class="reqn">i</code>  by 1 and return to step 2 if <code class="reqn">i \le n</code>, otherwise stop.
</p>
</li>
<li><p>Step 4. If <code class="reqn">d_{\min} &lt; \delta</code>, draw an integer <code class="reqn">j</code>  at random from <code class="reqn">1,  2,\ldots,N</code>, set <code class="reqn">x_{i}  = X_{j}</code>  and return to step 3.
</p>
</li></ul>

<p>Samples generated in this way will exhibit a more regular spatial arrangement than would a random sample of the same size. The degree of regularity achievable will be influenced by the spatial arrangement of the population <code class="reqn">X_{i}  : i  = 1,\ldots,N</code>, the specified value of <code>delta</code>  and the sample size <code>n</code>. For any given population, if <code>n</code>  and/or <code>delta</code>  are too large, a sample of the required size with the distance between any two sampled locations at least <code>delta</code> will not be achievable; the suggested solution is then to run the algorithm with a smaller value of <code>delta</code>.
</p>
<p><b>Sampling close pairs of points</b>.
For some purposes, it is desirable that a spatial sampling scheme include pairs of closely spaced points. In this case, the above algorithm requires the following additional steps to be taken.
Let <code>k</code>  be the required number of close pairs.
</p>

<ul>
<li><p>Step 5. Set <code class="reqn">j  = 1</code> and draw a random sample of size 2 from the integers <code class="reqn">1,  2,\ldots,n</code>, say <code class="reqn">(i_{1}, i_{2} )</code>.
</p>
</li>
<li><p>Step 6. Find the integer <code class="reqn">r</code>  such that the distances from <code class="reqn">x_{i_{1}}</code>  to <code class="reqn">X_{r}</code> is the minimum of all <code class="reqn">N-1</code> distances from <code class="reqn">x_{i_{1}}</code>  to the <code class="reqn">X_{j}</code>.
</p>
</li>
<li><p>Step 7.  Replace <code class="reqn">x_{i_{2}}</code>  by <code class="reqn">X_{r}</code>, increase <code class="reqn">i</code>  by 1 and return to step 5 if <code class="reqn">i \le k</code>, otherwise stop.
</p>
</li></ul>



<h3>Value</h3>

<p>A matrix of dimension <code>n</code> by 2 containing the final sampled locations.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-0.015+0.03*(1:33)
xall&lt;-rep(x,33)
yall&lt;-c(t(matrix(xall,33,33)))
xy&lt;-cbind(xall,yall)+matrix(-0.0075+0.015*runif(33*33*2),33*33,2)
par(pty="s",mfrow=c(1,2))
plot(xy[,1],xy[,2],pch=19,cex=0.25,xlab="Easting",ylab="Northing",
   cex.lab=1,cex.axis=1,cex.main=1)

set.seed(15892)
# Generate spatially random sample
xy.sample&lt;-xy[sample(1:dim(xy)[1],50,replace=FALSE),]
points(xy.sample[,1],xy.sample[,2],pch=19,col="red")
points(xy[,1],xy[,2],pch=19,cex=0.25)
plot(xy[,1],xy[,2],pch=19,cex=0.25,xlab="Easting",ylab="Northing",
   cex.lab=1,cex.axis=1,cex.main=1)

set.seed(15892)
# Generate spatially regular sample
xy.sample&lt;-discrete.sample(xy,50,0.08)
points(xy.sample[,1],xy.sample[,2],pch=19,col="red")
points(xy[,1],xy[,2],pch=19,cex=0.25)

</code></pre>

<hr>
<h2 id='galicia'>Heavy metal biomonitoring in Galicia</h2><span id='topic+galicia'></span>

<h3>Description</h3>

<p>This data-set relates to two studies on lead concentration in moss samples,
in micrograms per gram dry weight, collected in Galicia, norther Spain. The data
are from two surveys, one conducted in October 1997 and on in July 2000.
The variables are as follows:
</p>

<ul>
<li><p> x x-coordinate of the spatial locations.
</p>
</li>
<li><p> y y-coordinate of the spatial locations.
</p>
</li>
<li><p> lead lead concentration.
</p>
</li>
<li><p> survey year of the survey (either 1997 or 2000).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(galicia)
</code></pre>


<h3>Format</h3>

<p>A data frame with 195 rows and 4 variables
</p>


<h3>Source</h3>

<p>Diggle, P.J., Menezes, R. and Su, T.-L. (2010). Geostatistical analysis under preferential
sampling (with Discussion). Applied Statistics, 59, 191-232.
</p>

<hr>
<h2 id='galicia.boundary'>Boundary of Galicia</h2><span id='topic+galicia.boundary'></span>

<h3>Description</h3>

<p>This data-set contains the geographical coordinates of the boundary of the Galicia
region in northern Spain.
</p>
<p>The variables are as follows:
</p>

<ul>
<li><p> x x-coordinate of the spatial locations.
</p>
</li>
<li><p> y y-coordinate of the spatial locations.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(galicia.boundary)
</code></pre>


<h3>Format</h3>

<p>A data frame with 42315 rows and 2 variables
</p>

<hr>
<h2 id='glgm.LA'>Maximum Likelihood estimation for generalised linear geostatistical models via the Laplace approximation</h2><span id='topic+glgm.LA'></span>

<h3>Description</h3>

<p>This function performs the Laplace method for maximum likelihood estimation of a generalised linear geostatistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glgm.LA(
  formula,
  units.m = NULL,
  coords,
  times = NULL,
  data,
  ID.coords = NULL,
  kappa,
  kappa.t = 0.5,
  fixed.rel.nugget = NULL,
  start.cov.pars,
  method = "nlminb",
  messages = TRUE,
  family,
  return.covariance = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glgm.LA_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_units.m">units.m</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the binomial denominators in the data.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the spatial coordinates in the data.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_times">times</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the times in the data, used in the spatio-temporal model.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_id.coords">ID.coords</code></td>
<td>
<p>vector of ID values for the unique set of spatial coordinates obtained from <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>. These must be provided if, for example, spatial random effects are defined at household level but some of the covariates are at individual level. <b>Warning</b>: the household coordinates must all be distinct otherwise see <code>jitterDupCoords</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_kappa">kappa</code></td>
<td>
<p>fixed value for the shape parameter of the Matern covariance function.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_kappa.t">kappa.t</code></td>
<td>
<p>fixed value for the shape parameter of the Matern covariance function in the separable double-Matern spatio-temporal model.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_fixed.rel.nugget">fixed.rel.nugget</code></td>
<td>
<p>fixed value for the relative variance of the nugget effect; <code>fixed.rel.nugget=NULL</code> if this should be included in the estimation. Default is <code>fixed.rel.nugget=NULL</code>.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_start.cov.pars">start.cov.pars</code></td>
<td>
<p>a vector of length two with elements corresponding to the starting values of <code>phi</code> and the relative variance of the nugget effect <code>nu2</code>, respectively, that are used in the optimization algorithm. If <code>nu2</code> is fixed through <code>fixed.rel.nugget</code>, then <code>start.cov.pars</code> represents the starting value for <code>phi</code> only.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_method">method</code></td>
<td>
<p>method of optimization. If <code>method="BFGS"</code> then the <code><a href="maxLik.html#topic+maxBFGS">maxBFGS</a></code> function is used; otherwise <code>method="nlminb"</code> to use the <code><a href="stats.html#topic+nlminb">nlminb</a></code> function. Default is <code>method="BFGS"</code>.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_family">family</code></td>
<td>
<p>character, indicating the conditional distribution of the outcome. This should be <code>"Gaussian"</code>, <code>"Binomial"</code> or <code>"Poisson"</code>.</p>
</td></tr>
<tr><td><code id="glgm.LA_+3A_return.covariance">return.covariance</code></td>
<td>
<p>logical; if <code>return.covariance=TRUE</code> then a numerical estimation of the covariance function for the model parameters is returned. Default is <code>return.covariance=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs parameter estimation for a generealized linear geostatistical model. Conditionally on a zero-mean stationary Gaussian process <code class="reqn">S(x)</code> and mutually independent zero-mean Gaussian variables <code class="reqn">Z</code> with variance <code>tau2</code>, the observations <code>y</code> are generated from a GLM
with link function <code class="reqn">g(.)</code> and linear predictor
</p>
<p style="text-align: center;"><code class="reqn">\eta = d'\beta + S(x) + Z,</code>
</p>

<p>where <code class="reqn">d</code> is a vector of covariates with associated regression coefficients <code class="reqn">\beta</code>. The Gaussian process <code class="reqn">S(x)</code> has isotropic Matern covariance function (see <code>matern</code>) with variance <code>sigma2</code>, scale parameter <code>phi</code> and shape parameter <code>kappa</code>.
The shape parameter is treated as fixed. The relative variance of the nugget effect, <code>nu2=tau2/sigma2</code>, can also be fixed through the argument <code>fixed.rel.nugget</code>; if <code>fixed.rel.nugget=NULL</code>, then the relative variance of the nugget effect is also included in the estimation.
</p>
<p><b>Laplace Approximation</b>
The Laplace approximation (LA) method uses a second-order Taylor expansion of the integrand expressing the likelihood function. The resulting approximation of the likelihood is then maximized by a numerical optimization as defined through the argument <code>method</code>.
</p>
<p><b>Using a two-level model to include household-level and individual-level information.</b>
When analysing data from household sruveys, some of the avilable information information might be at household-level (e.g. material of house, temperature) and some at individual-level (e.g. age, gender). In this case, the Gaussian spatial process <code class="reqn">S(x)</code> and the nugget effect <code class="reqn">Z</code> are defined at hosuehold-level in order to account for extra-binomial variation between and within households, respectively.
</p>


<h3>Value</h3>

<p>An object of class &quot;PrevMap&quot;.
The function <code><a href="#topic+summary.PrevMap">summary.PrevMap</a></code> is used to print a summary of the fitted model.
The object is a list with the following components:
</p>
<p><code>estimate</code>: estimates of the model parameters; use the function <code><a href="#topic+coef.PrevMap">coef.PrevMap</a></code> to obtain estimates of covariance parameters on the original scale.
</p>
<p><code>covariance</code>: covariance matrix of the MCML estimates.
</p>
<p><code>log.lik</code>: maximum value of the log-likelihood.
</p>
<p><code>y</code>: binomial observations.
</p>
<p><code>units.m</code>: binomial denominators.
</p>
<p><code>D</code>: matrix of covariates.
</p>
<p><code>coords</code>: matrix of the observed sampling locations.
</p>
<p><code>times</code>: vector of the time points used in a spatio-temporal model.
</p>
<p><code>method</code>: method of optimization used.
</p>
<p><code>ID.coords</code>: set of ID values defined through the argument <code>ID.coords</code>.
</p>
<p><code>kappa</code>: fixed value of the shape parameter of the Matern function.
</p>
<p><code>kappa.t</code>: fixed value for the shape parameter of the Matern covariance function in the separable double-Matern spatio-temporal model.
</p>
<p><code>fixed.rel.nugget</code>: fixed value for the relative variance of the nugget effect.
</p>
<p><code>call</code>: the matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Giorgi, E. (2019). <em>Model-based Geostatistics for Global Public Health.</em> CRC/Chapman &amp; Hall.
</p>
<p>Giorgi, E., Diggle, P.J. (2017). <em>PrevMap: an R package for prevalence mapping.</em> Journal of Statistical Software. 78(8), 1-29. doi: 10.18637/jss.v078.i08
</p>
<p>Christensen, O. F. (2004). <em>Monte carlo maximum likelihood in model-based geostatistics.</em> Journal of Computational and Graphical Statistics 13, 702-718.
</p>
<p>Higdon, D. (1998). <em>A process-convolution approach to modeling temperatures in the North Atlantic Ocean.</em> Environmental and Ecological Statistics 5, 173-190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Laplace.sampling">Laplace.sampling</a></code>, <code><a href="#topic+Laplace.sampling.lr">Laplace.sampling.lr</a></code>, <code><a href="#topic+summary.PrevMap">summary.PrevMap</a></code>, <code><a href="#topic+coef.PrevMap">coef.PrevMap</a></code>, <code>matern</code>, <code><a href="#topic+matern.kernel">matern.kernel</a></code>,  <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>, <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>.
</p>

<hr>
<h2 id='Laplace.sampling'>Langevin-Hastings MCMC for conditional simulation</h2><span id='topic+Laplace.sampling'></span>

<h3>Description</h3>

<p>This function simulates from the conditional distribution of a Gaussian random effect, given binomial or Poisson observations <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Laplace.sampling(
  mu,
  Sigma,
  y,
  units.m,
  control.mcmc,
  ID.coords = NULL,
  messages = TRUE,
  plot.correlogram = TRUE,
  poisson.llik = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Laplace.sampling_+3A_mu">mu</code></td>
<td>
<p>mean vector of the marginal distribution of the random effect.</p>
</td></tr>
<tr><td><code id="Laplace.sampling_+3A_sigma">Sigma</code></td>
<td>
<p>covariance matrix of the marginal distribution of the random effect.</p>
</td></tr>
<tr><td><code id="Laplace.sampling_+3A_y">y</code></td>
<td>
<p>vector of binomial/Poisson observations.</p>
</td></tr>
<tr><td><code id="Laplace.sampling_+3A_units.m">units.m</code></td>
<td>
<p>vector of binomial denominators, or offset if the Poisson model is used.</p>
</td></tr>
<tr><td><code id="Laplace.sampling_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="Laplace.sampling_+3A_id.coords">ID.coords</code></td>
<td>
<p>vector of ID values for the unique set of spatial coordinates obtained from <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>. These must be provided if, for example, spatial random effects are defined at household level but some of the covariates are at individual level. <b>Warning</b>: the household coordinates must all be distinct otherwise see <code>jitterDupCoords</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Laplace.sampling_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="Laplace.sampling_+3A_plot.correlogram">plot.correlogram</code></td>
<td>
<p>logical; if <code>plot.correlogram=TRUE</code> the autocorrelation plot of the conditional simulations is displayed.</p>
</td></tr>
<tr><td><code id="Laplace.sampling_+3A_poisson.llik">poisson.llik</code></td>
<td>
<p>logical; if <code>poisson.llik=TRUE</code> a Poisson model is used or, if <code>poisson.llik=FALSE</code>, a binomial model is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Binomial model.</b> Conditionally on the random effect <code class="reqn">S</code>, the data <code>y</code> follow a binomial distribution with probability <code class="reqn">p</code> and binomial denominators <code>units.m</code>. The logistic link function is used for the linear predictor, which assumes the form </p>
<p style="text-align: center;"><code class="reqn">\log(p/(1-p))=S.</code>
</p>

<p><b>Poisson model.</b> Conditionally on the random effect <code class="reqn">S</code>, the data <code>y</code> follow a Poisson distribution with mean <code class="reqn">m\lambda</code>, where <code class="reqn">m</code> is an offset set through the argument <code>units.m</code>. The log link function is used for the linear predictor, which assumes the form </p>
<p style="text-align: center;"><code class="reqn">\log(\lambda)=S.</code>
</p>

<p>The random effect <code class="reqn">S</code> has a multivariate Gaussian distribution with mean <code>mu</code> and covariance matrix <code>Sigma</code>.
</p>
<p><b>Laplace sampling.</b> This function generates samples from the distribution of <code class="reqn">S</code> given the data <code>y</code>. Specifically a Langevin-Hastings algorithm is used to update <code class="reqn">\tilde{S} = \tilde{\Sigma}^{-1/2}(S-\tilde{s})</code> where <code class="reqn">\tilde{\Sigma}</code> and <code class="reqn">\tilde{s}</code> are the inverse of the negative Hessian and the mode of the distribution of <code class="reqn">S</code> given <code>y</code>, respectively. At each iteration a new value <code class="reqn">\tilde{s}_{prop}</code> for <code class="reqn">\tilde{S}</code> is proposed from a multivariate Gaussian distribution with mean </p>
<p style="text-align: center;"><code class="reqn">\tilde{s}_{curr}+(h/2)\nabla \log f(\tilde{S} | y),</code>
</p>

<p>where <code class="reqn">\tilde{s}_{curr}</code> is the current value for <code class="reqn">\tilde{S}</code>, <code class="reqn">h</code> is a tuning parameter and <code class="reqn">\nabla \log f(\tilde{S} | y)</code> is the the gradient of the log-density of the distribution of <code class="reqn">\tilde{S}</code> given <code>y</code>. The tuning parameter <code class="reqn">h</code> is updated according to the following adaptive scheme: the value of <code class="reqn">h</code> at the <code class="reqn">i</code>-th iteration, say <code class="reqn">h_{i}</code>, is given by </p>
<p style="text-align: center;"><code class="reqn">h_{i} = h_{i-1}+c_{1}i^{-c_{2}}(\alpha_{i}-0.547),</code>
</p>

<p>where <code class="reqn">c_{1} &gt; 0</code> and <code class="reqn">0 &lt; c_{2} &lt; 1</code> are pre-defined constants, and <code class="reqn">\alpha_{i}</code> is the acceptance rate at the <code class="reqn">i</code>-th iteration (<code class="reqn">0.547</code> is the optimal acceptance rate for a multivariate standard Gaussian distribution).
The starting value for <code class="reqn">h</code>, and the values for <code class="reqn">c_{1}</code> and <code class="reqn">c_{2}</code> can be set through the function <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.
</p>
<p><b>Random effects at household-level.</b> When the data consist of two nested levels, such as households and individuals within households, the argument <code>ID.coords</code> must be used to define the household IDs for each individual. Let <code class="reqn">i</code> and <code class="reqn">j</code> denote the <code class="reqn">i</code>-th household and the <code class="reqn">j</code>-th person within that household; the logistic link function then assumes the form </p>
<p style="text-align: center;"><code class="reqn">\log(p_{ij}/(1-p_{ij}))=\mu_{ij}+S_{i}</code>
</p>
<p> where the random effects <code class="reqn">S_{i}</code> are now defined at household level and have mean zero. <b>Warning:</b> this modelling option is available only for the binomial model.
</p>


<h3>Value</h3>

<p>A list with the following components
</p>
<p><code>samples</code>: a matrix, each row of which corresponds to a sample from the predictive distribution.
</p>
<p><code>h</code>: vector of the values of the tuning parameter at each iteration of the Langevin-Hastings MCMC algorithm.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>, <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>.
</p>

<hr>
<h2 id='Laplace.sampling.lr'>Langevin-Hastings MCMC for conditional simulation (low-rank approximation)</h2><span id='topic+Laplace.sampling.lr'></span>

<h3>Description</h3>

<p>This function simulates from the conditional distribution of the random effects of binomial and Poisson models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Laplace.sampling.lr(
  mu,
  sigma2,
  K,
  y,
  units.m,
  control.mcmc,
  messages = TRUE,
  plot.correlogram = TRUE,
  poisson.llik = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Laplace.sampling.lr_+3A_mu">mu</code></td>
<td>
<p>mean vector of the linear predictor.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.lr_+3A_sigma2">sigma2</code></td>
<td>
<p>variance of the random effect.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.lr_+3A_k">K</code></td>
<td>
<p>random effect design matrix, or kernel matrix for the low-rank approximation.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.lr_+3A_y">y</code></td>
<td>
<p>vector of binomial/Poisson observations.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.lr_+3A_units.m">units.m</code></td>
<td>
<p>vector of binomial denominators, or offset if the Poisson model is used.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.lr_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.lr_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.lr_+3A_plot.correlogram">plot.correlogram</code></td>
<td>
<p>logical; if <code>plot.correlogram=TRUE</code> the autocorrelation plot of the conditional simulations is displayed.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.lr_+3A_poisson.llik">poisson.llik</code></td>
<td>
<p>logical; if <code>poisson.llik=TRUE</code> a Poisson model is used or, if <code>poisson.llik=FALSE</code>, a binomial model is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Binomial model.</b> Conditionally on <code class="reqn">Z</code>, the data <code>y</code> follow a binomial distribution with probability <code class="reqn">p</code> and binomial denominators <code>units.m</code>. Let <code class="reqn">K</code> denote the random effects design matrix; a logistic link function is used, thus the linear predictor assumes the form </p>
<p style="text-align: center;"><code class="reqn">\log(p/(1-p))=\mu + KZ</code>
</p>
<p> where <code class="reqn">\mu</code> is the mean vector component defined through <code>mu</code>.
<b>Poisson model.</b> Conditionally on <code class="reqn">Z</code>, the data <code>y</code> follow a Poisson distribution with mean <code class="reqn">m\lambda</code>, where <code class="reqn">m</code> is an offset set through the argument <code>units.m</code>. Let <code class="reqn">K</code> denote the random effects design matrix; a log link function is used, thus the linear predictor assumes the form </p>
<p style="text-align: center;"><code class="reqn">\log(\lambda)=\mu + KZ</code>
</p>
<p> where <code class="reqn">\mu</code> is the mean vector component defined through <code>mu</code>.
The random effect <code class="reqn">Z</code> has iid components distributed as zero-mean Gaussian variables with variance <code>sigma2</code>.
</p>
<p><b>Laplace sampling.</b> This function generates samples from the distribution of <code class="reqn">Z</code> given the data <code>y</code>. Specifically, a Langevin-Hastings algorithm is used to update <code class="reqn">\tilde{Z} = \tilde{\Sigma}^{-1/2}(Z-\tilde{z})</code> where <code class="reqn">\tilde{\Sigma}</code> and <code class="reqn">\tilde{z}</code> are the inverse of the negative Hessian and the mode of the distribution of <code class="reqn">Z</code> given <code>y</code>, respectively. At each iteration a new value <code class="reqn">\tilde{z}_{prop}</code> for <code class="reqn">\tilde{Z}</code> is proposed from a multivariate Gaussian distribution with mean </p>
<p style="text-align: center;"><code class="reqn">\tilde{z}_{curr}+(h/2)\nabla \log f(\tilde{Z} | y),</code>
</p>

<p>where <code class="reqn">\tilde{z}_{curr}</code> is the current value for <code class="reqn">\tilde{Z}</code>, <code class="reqn">h</code> is a tuning parameter and <code class="reqn">\nabla \log f(\tilde{Z} | y)</code> is the the gradient of the log-density of the distribution of <code class="reqn">\tilde{Z}</code> given <code>y</code>. The tuning parameter <code class="reqn">h</code> is updated according to the following adaptive scheme: the value of <code class="reqn">h</code> at the <code class="reqn">i</code>-th iteration, say <code class="reqn">h_{i}</code>, is given by </p>
<p style="text-align: center;"><code class="reqn">h_{i} = h_{i-1}+c_{1}i^{-c_{2}}(\alpha_{i}-0.547),</code>
</p>

<p>where <code class="reqn">c_{1} &gt; 0</code> and <code class="reqn">0 &lt; c_{2} &lt; 1</code> are pre-defined constants, and <code class="reqn">\alpha_{i}</code> is the acceptance rate at the <code class="reqn">i</code>-th iteration (<code class="reqn">0.547</code> is the optimal acceptance rate for a multivariate standard Gaussian distribution).
The starting value for <code class="reqn">h</code>, and the values for <code class="reqn">c_{1}</code> and <code class="reqn">c_{2}</code> can be set through the function <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.
</p>


<h3>Value</h3>

<p>A list with the following components
</p>
<p><code>samples</code>: a matrix, each row of which corresponds to a sample from the predictive distribution.
</p>
<p><code>h</code>: vector of the values of the tuning parameter at each iteration of the Langevin-Hastings MCMC algorithm.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.
</p>

<hr>
<h2 id='Laplace.sampling.SPDE'>Independence sampler for conditional simulation of a Gaussian process using SPDE</h2><span id='topic+Laplace.sampling.SPDE'></span>

<h3>Description</h3>

<p>This function simulates from the conditional distribution of a Gaussian process given binomial <code>y</code>.
The Guassian process is also approximated using SPDE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Laplace.sampling.SPDE(
  mu,
  sigma2,
  phi,
  kappa,
  y,
  units.m,
  coords,
  mesh,
  control.mcmc,
  messages = TRUE,
  plot.correlogram = TRUE,
  poisson.llik
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Laplace.sampling.SPDE_+3A_mu">mu</code></td>
<td>
<p>mean vector of the Gaussian process to approximate.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_sigma2">sigma2</code></td>
<td>
<p>variance of the Gaussian process to approximate.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_phi">phi</code></td>
<td>
<p>scale parameter of the Matern function for the Gaussian process to approximate.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_kappa">kappa</code></td>
<td>
<p>smothness parameter of the Matern function for the Gaussian process to approximate.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_y">y</code></td>
<td>
<p>vector of binomial observations.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_units.m">units.m</code></td>
<td>
<p>vector of binomial denominators.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_coords">coords</code></td>
<td>
<p>matrix of two columns corresponding to the spatial coordinates.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_mesh">mesh</code></td>
<td>
<p>mesh object set through <code>inla.mesh.2d</code>.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>control parameters of the Independence sampler set through <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_plot.correlogram">plot.correlogram</code></td>
<td>
<p>logical; if <code>plot.correlogram=TRUE</code> the autocorrelation plot of the conditional simulations is displayed.</p>
</td></tr>
<tr><td><code id="Laplace.sampling.SPDE_+3A_poisson.llik">poisson.llik</code></td>
<td>
<p>logical: if <code>poisson.llik=TRUE</code> then conditional conditional distribution of the data is Poisson; <code>poisson.llik=FALSE</code> then conditional conditional distribution of the data is Binomial.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Binomial model.</b> Conditionally on the random effect <code class="reqn">S</code>, the data <code>y</code> follow a binomial distribution with probability <code class="reqn">p</code> and binomial denominators <code>units.m</code>. The logistic link function is used for the linear predictor, which assumes the form </p>
<p style="text-align: center;"><code class="reqn">\log(p/(1-p))=S.</code>
</p>

<p>The random effect <code class="reqn">S</code> has a multivariate Gaussian distribution with mean <code>mu</code> and covariance matrix <code>Sigma</code>.
</p>


<h3>Value</h3>

<p>A list with the following components
</p>
<p><code>samples</code>: a matrix, each row of which corresponds to a sample from the predictive distribution.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.
</p>

<hr>
<h2 id='linear.model.Bayes'>Bayesian estimation for the geostatistical linear Gaussian model</h2><span id='topic+linear.model.Bayes'></span>

<h3>Description</h3>

<p>This function performs Bayesian estimation for the geostatistical linear Gaussian model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear.model.Bayes(
  formula,
  coords,
  data,
  kappa,
  control.mcmc,
  control.prior,
  low.rank = FALSE,
  knots = NULL,
  messages = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear.model.Bayes_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="linear.model.Bayes_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the geographic coordinates.</p>
</td></tr>
<tr><td><code id="linear.model.Bayes_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="linear.model.Bayes_+3A_kappa">kappa</code></td>
<td>
<p>shape parameter of the Matern covariance function.</p>
</td></tr>
<tr><td><code id="linear.model.Bayes_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="linear.model.Bayes_+3A_control.prior">control.prior</code></td>
<td>
<p>output from <code><a href="#topic+control.prior">control.prior</a></code>.</p>
</td></tr>
<tr><td><code id="linear.model.Bayes_+3A_low.rank">low.rank</code></td>
<td>
<p>logical; if <code>low.rank=TRUE</code> a low-rank approximation is fitted.</p>
</td></tr>
<tr><td><code id="linear.model.Bayes_+3A_knots">knots</code></td>
<td>
<p>if <code>low.rank=TRUE</code>, <code>knots</code> is a matrix of spatial knots used in the low-rank approximation. Default is <code>knots=NULL</code>.</p>
</td></tr>
<tr><td><code id="linear.model.Bayes_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs Bayesian estimation for the geostatistical linear Gaussian model, specified as
</p>
<p style="text-align: center;"><code class="reqn">Y = d'\beta + S(x) + Z,</code>
</p>

<p>where <code class="reqn">Y</code> is the measured outcome, <code class="reqn">d</code> is a vector of coavariates, <code class="reqn">\beta</code> is a vector of regression coefficients, <code class="reqn">S(x)</code> is a stationary Gaussian spatial process and <code class="reqn">Z</code> are independent zero-mean Gaussian variables with variance <code>tau2</code>. More specifically, <code class="reqn">S(x)</code> has an isotropic Matern covariance function with variance <code>sigma2</code>, scale parameter <code>phi</code> and shape parameter <code>kappa</code>. The shape parameter <code>kappa</code> is treated as fixed.
</p>
<p><b>Priors definition.</b> Priors can be defined through the function <code><a href="#topic+control.prior">control.prior</a></code>. The hierarchical structure of the priors is the following. Let <code class="reqn">\theta</code> be the vector of the covariance parameters <code class="reqn">(\sigma^2,\phi,\tau^2)</code>; then each component of <code class="reqn">\theta</code> can have independent priors freely defined by the user. However, uniform and log-normal priors are also available as default priors for each of the covariance parameters. To remove the nugget effect <code class="reqn">Z</code>, no prior should be defined for <code>tau2</code>. Conditionally on <code>sigma2</code>, the vector of regression coefficients <code>beta</code> has a multivariate Gaussian prior with mean <code>beta.mean</code> and covariance matrix <code>sigma2*beta.covar</code>, while in the low-rank approximation the covariance matrix is simply <code>beta.covar</code>.
</p>
<p><b>Updating the covariance parameters using a Metropolis-Hastings algorithm.</b> In the MCMC algorithm implemented in <code>linear.model.Bayes</code>, the transformed parameters </p>
<p style="text-align: center;"><code class="reqn">(\theta_{1}, \theta_{2}, \theta_{3})=(\log(\sigma^2)/2,\log(\sigma^2/\phi^{2 \kappa}), \log(\tau^2))</code>
</p>
<p> are independently updated using a Metropolis Hastings algorithm. At the <code class="reqn">i</code>-th iteration, a new value is proposed for each from a univariate Gaussian distrubion with variance, say <code class="reqn">h_{i}^2</code>, tuned according the following adaptive scheme </p>
<p style="text-align: center;"><code class="reqn">h_{i} = h_{i-1}+c_{1}i^{-c_{2}}(\alpha_{i}-0.45),</code>
</p>
<p> where <code class="reqn">\alpha_{i}</code> is the acceptance rate at the <code class="reqn">i</code>-th iteration (0.45 is the optimal acceptance rate for a univariate Gaussian distribution) whilst <code class="reqn">c_{1} &gt; 0</code> and <code class="reqn">0 &lt; c_{2} &lt; 1</code> are pre-defined constants. The starting values <code class="reqn">h_{1}</code> for each of the parameters <code class="reqn">\theta_{1}</code>, <code class="reqn">\theta_{2}</code> and <code class="reqn">\theta_{3}</code> can be set using the function <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code> through the arguments <code>h.theta1</code>, <code>h.theta2</code> and <code>h.theta3</code>. To define values for <code class="reqn">c_{1}</code> and <code class="reqn">c_{2}</code>, see the documentation of <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code>.
</p>
<p><b>Low-rank approximation.</b>
In the case of very large spatial data-sets, a low-rank approximation of the Gaussian spatial process <code class="reqn">S(x)</code> might be computationally beneficial. Let <code class="reqn">(x_{1},\dots,x_{m})</code> and <code class="reqn">(t_{1},\dots,t_{m})</code> denote the set of sampling locations and a grid of spatial knots covering the area of interest, respectively. Then <code class="reqn">S(x)</code> is approximated as <code class="reqn">\sum_{i=1}^m K(\|x-t_{i}\|; \phi, \kappa)U_{i}</code>, where <code class="reqn">U_{i}</code> are zero-mean mutually independent Gaussian variables with variance <code>sigma2</code> and <code class="reqn">K(.;\phi, \kappa)</code> is the isotropic Matern kernel (see <code><a href="#topic+matern.kernel">matern.kernel</a></code>). Since the resulting approximation is no longer a stationary process (but only approximately), <code>sigma2</code> may take very different values from the actual variance of the Gaussian process to approximate. The function <code><a href="#topic+adjust.sigma2">adjust.sigma2</a></code> can then be used to (approximately) explore the range for <code>sigma2</code>. For example if the variance of the Gaussian process is <code>0.5</code>, then an approximate value for <code>sigma2</code> is <code>0.5/const.sigma2</code>, where <code>const.sigma2</code> is the value obtained with <code><a href="#topic+adjust.sigma2">adjust.sigma2</a></code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;Bayes.PrevMap&quot;.
The function <code><a href="#topic+summary.Bayes.PrevMap">summary.Bayes.PrevMap</a></code> is used to print a summary of the fitted model.
The object is a list with the following components:
</p>
<p><code>estimate</code>: matrix of the posterior samples for each of the model parameters.
</p>
<p><code>S</code>: matrix of the posterior samplesfor each component of the random effect. This is only returned for the low-rank approximation.
</p>
<p><code>y</code>: response variable.
</p>
<p><code>D</code>: matrix of covariarates.
</p>
<p><code>coords</code>: matrix of the observed sampling locations.
</p>
<p><code>kappa</code>: vaues of the shape parameter of the Matern function.
</p>
<p><code>knots</code>: matrix of spatial knots used in the low-rank approximation.
</p>
<p><code>const.sigma2</code>: vector of the values of the multiplicative factor used to adjust the <code>sigma2</code> in the low-rank approximation.
</p>
<p><code>h1</code>: vector of values taken by the tuning parameter <code>h.theta1</code> at each iteration.
</p>
<p><code>h2</code>: vector of values taken by the tuning parameter <code>h.theta2</code> at each iteration.
</p>
<p><code>h3</code>: vector of values taken by the tuning parameter <code>h.theta3</code> at each iteration.
</p>
<p><code>call</code>: the matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Giorgi, E. (2019). <em>Model-based Geostatistics for Global Public Health.</em> CRC/Chapman &amp; Hall.
</p>
<p>Giorgi, E., Diggle, P.J. (2017). <em>PrevMap: an R package for prevalence mapping.</em> Journal of Statistical Software. 78(8), 1-29. doi: 10.18637/jss.v078.i08
</p>
<p>Higdon, D. (1998). <em>A process-convolution approach to modeling temperatures in the North Atlantic Ocean.</em> Environmental and Ecological Statistics 5, 173-190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+control.prior">control.prior</a></code>, <code><a href="#topic+control.mcmc.Bayes">control.mcmc.Bayes</a></code>, <code><a href="#topic+shape.matern">shape.matern</a></code>, <code><a href="#topic+summary.Bayes.PrevMap">summary.Bayes.PrevMap</a></code>, <code><a href="#topic+autocor.plot">autocor.plot</a></code>, <code><a href="#topic+trace.plot">trace.plot</a></code>, <code><a href="#topic+dens.plot">dens.plot</a></code>, <code>matern</code>, <code><a href="#topic+matern.kernel">matern.kernel</a></code>, <code><a href="#topic+adjust.sigma2">adjust.sigma2</a></code>.
</p>

<hr>
<h2 id='linear.model.MLE'>Maximum Likelihood estimation for the geostatistical linear Gaussian model</h2><span id='topic+linear.model.MLE'></span>

<h3>Description</h3>

<p>This function performs maximum likelihood estimation for the geostatistical linear Gaussian Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear.model.MLE(
  formula,
  coords = NULL,
  data,
  ID.coords = NULL,
  kappa,
  fixed.rel.nugget = NULL,
  start.cov.pars,
  method = "BFGS",
  low.rank = FALSE,
  knots = NULL,
  messages = TRUE,
  profile.llik = FALSE,
  SPDE = FALSE,
  mesh = NULL,
  SPDE.analytic.hessian = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear.model.MLE_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="stats.html#topic+formula">formula</a></code>&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the geographic coordinates.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_id.coords">ID.coords</code></td>
<td>
<p>vector of ID values for the unique set of spatial coordinates obtained from <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>. These must be provided in order to define a geostatistical model where locations have multiple observations. Default is <code>ID.coords=NULL</code>. See the <b>Details</b> section for more information.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_kappa">kappa</code></td>
<td>
<p>shape parameter of the Matern covariance function.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_fixed.rel.nugget">fixed.rel.nugget</code></td>
<td>
<p>fixed value for the relative variance of the nugget effect; default is <code>fixed.rel.nugget=NULL</code> if this should be included in the estimation.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_start.cov.pars">start.cov.pars</code></td>
<td>
<p>if <code>ID.coords=NULL</code>, a vector of length two with elements corresponding to the starting values of <code>phi</code> and the relative variance of the nugget effect <code>nu2</code>, respectively, that are used in the optimization algorithm; if <code>ID.coords</code> is provided, a third starting value for the relative variance of the individual unexplained variation <code>nu2.star = omega2/sigma2</code> must be provided. If <code>nu2</code> is fixed through <code>fixed.rel.nugget</code>, then start.cov.pars represents the starting value for <code>phi</code> only, if <code>ID.coords=NULL</code>, or for <code>phi</code> and <code>nu2.star</code>, otherwise.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_method">method</code></td>
<td>
<p>method of optimization. If <code>method="BFGS"</code> then the <code><a href="maxLik.html#topic+maxBFGS">maxBFGS</a></code> function is used; otherwise <code>method="nlminb"</code> to use the <code><a href="stats.html#topic+nlminb">nlminb</a></code> function. Default is <code>method="BFGS"</code>.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_low.rank">low.rank</code></td>
<td>
<p>logical; if <code>low.rank=TRUE</code> a low-rank approximation of the Gaussian spatial process is used when fitting the model. Default is <code>low.rank=FALSE</code>.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_knots">knots</code></td>
<td>
<p>if <code>low.rank=TRUE</code>, <code>knots</code> is a matrix of spatial knots that are used in the low-rank approximation. Default is <code>knots=NULL</code>.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_profile.llik">profile.llik</code></td>
<td>
<p>logical; if <code>profile.llik=TRUE</code> the maximization of the profile likelihood is carried out. If <code>profile.llik=FALSE</code> the full-likelihood is used. Default is <code>profile.llik=FALSE</code>.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_spde">SPDE</code></td>
<td>
<p>logical; if <code>SPDE=TRUE</code> the SPDE approximation for the Gaussian spatial model is used. Default is <code>SPDE=FALSE</code>.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_mesh">mesh</code></td>
<td>
<p>an object obtained as result of a call to the function <code>inla.mesh.2d</code>.</p>
</td></tr>
<tr><td><code id="linear.model.MLE_+3A_spde.analytic.hessian">SPDE.analytic.hessian</code></td>
<td>
<p>logical; if <code>SPDE.analytic.hessian=TRUE</code> computation of the hessian matrix using the SPDE approximation is carried out using analytical expressions, otherwise a numerical approximation is used. Defauls is <code>SPDE.analytic.hessian=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the parameters of a geostatistical linear Gaussian model, specified as
</p>
<p style="text-align: center;"><code class="reqn">Y = d'\beta + S(x) + Z,</code>
</p>

<p>where <code class="reqn">Y</code> is the measured outcome, <code class="reqn">d</code> is a vector of coavariates, <code class="reqn">\beta</code> is a vector of regression coefficients, <code class="reqn">S(x)</code> is a stationary Gaussian spatial process and <code class="reqn">Z</code> are independent zero-mean Gaussian variables with variance <code>tau2</code>. More specifically, <code class="reqn">S(x)</code> has an isotropic Matern covariance function with variance <code>sigma2</code>, scale parameter <code>phi</code> and shape parameter <code>kappa</code>. In the estimation, the shape parameter <code>kappa</code> is treated as fixed. The relative variance of the nugget effect, <code>nu2=tau2/sigma2</code>, can be fixed though the argument <code>fixed.rel.nugget</code>; if <code>fixed.rel.nugget=NULL</code>, then the variance of the nugget effect is also included in the estimation.
</p>
<p><b>Locations with multiple observations.</b>
If multiple observations are available at any of the sampled locations the above model is modified as follows. Let <code class="reqn">Y_{ij}</code> denote the random variable associated to the measured outcome for the j-th individual at location <code class="reqn">x_{i}</code>. The linear geostatistical model assumes the form </p>
<p style="text-align: center;"><code class="reqn">Y_{ij} = d_{ij}'\beta + S(x_{i}) + Z{i} + U_{ij},</code>
</p>
<p> where <code class="reqn">S(x_{i})</code> and <code class="reqn">Z_{i}</code> are specified as mentioned above, and <code class="reqn">U_{ij}</code> are i.i.d. zer0-mean Gaussian variable with variance <code class="reqn">\omega^2</code>. his model can be fitted by specifing a vector of ID for the unique set locations thourgh the argument <code>ID.coords</code> (see also <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>).
</p>
<p><b>Low-rank approximation.</b>
In the case of very large spatial data-sets, a low-rank approximation of the Gaussian spatial process <code class="reqn">S(x)</code> can be computationally beneficial. Let <code class="reqn">(x_{1},\dots,x_{m})</code> and <code class="reqn">(t_{1},\dots,t_{m})</code> denote the set of sampling locations and a grid of spatial knots covering the area of interest, respectively. Then <code class="reqn">S(x)</code> is approximated as <code class="reqn">\sum_{i=1}^m K(\|x-t_{i}\|; \phi, \kappa)U_{i}</code>, where <code class="reqn">U_{i}</code> are zero-mean mutually independent Gaussian variables with variance <code>sigma2</code> and <code class="reqn">K(.;\phi, \kappa)</code> is the isotropic Matern kernel (see <code><a href="#topic+matern.kernel">matern.kernel</a></code>). Since the resulting approximation is no longer a stationary process, the parameter <code>sigma2</code> is adjusted by a factor<code>constant.sigma2</code>. See <code><a href="#topic+adjust.sigma2">adjust.sigma2</a></code> for more details on the the computation of the adjustment factor <code>constant.sigma2</code> in the low-rank approximation.
</p>


<h3>Value</h3>

<p>An object of class &quot;PrevMap&quot;.
The function <code><a href="#topic+summary.PrevMap">summary.PrevMap</a></code> is used to print a summary of the fitted model.
The object is a list with the following components:
</p>
<p><code>estimate</code>: estimates of the model parameters; use the function <code><a href="#topic+coef.PrevMap">coef.PrevMap</a></code> to obtain estimates of covariance parameters on the original scale.
</p>
<p><code>covariance</code>: covariance matrix of the ML estimates.
</p>
<p><code>log.lik</code>: maximum value of the log-likelihood.
</p>
<p><code>y</code>: response variable.
</p>
<p><code>D</code>: matrix of covariates.
</p>
<p><code>coords</code>: matrix of the observed sampling locations.
</p>
<p><code>ID.coords</code>: set of ID values defined through the argument <code>ID.coords</code>.
</p>
<p><code>method</code>: method of optimization used.
</p>
<p><code>kappa</code>: fixed value of the shape parameter of the Matern function.
</p>
<p><code>knots</code>: matrix of the spatial knots used in the low-rank approximation.
</p>
<p><code>const.sigma2</code>: adjustment factor for <code>sigma2</code> in the low-rank approximation.
</p>
<p><code>fixed.rel.nugget</code>: fixed value for the relative variance of the nugget effect.
</p>
<p><code>mesh</code>: the mesh used in the SPDE approximation.
</p>
<p><code>call</code>: the matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Giorgi, E. (2019). <em>Model-based Geostatistics for Global Public Health.</em> CRC/Chapman &amp; Hall.
</p>
<p>Giorgi, E., Diggle, P.J. (2017). <em>PrevMap: an R package for prevalence mapping.</em> Journal of Statistical Software. 78(8), 1-29. doi: 10.18637/jss.v078.i08
</p>
<p>Higdon, D. (1998). <em>A process-convolution approach to modeling temperatures in the North Atlantic Ocean.</em> Environmental and Ecological Statistics 5, 173-190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape.matern">shape.matern</a></code>, <code><a href="#topic+summary.PrevMap">summary.PrevMap</a></code>, <code><a href="#topic+coef.PrevMap">coef.PrevMap</a></code>, <code>matern</code>, <code><a href="#topic+matern.kernel">matern.kernel</a></code>, <code><a href="maxLik.html#topic+maxBFGS">maxBFGS</a></code>, <code><a href="stats.html#topic+nlminb">nlminb</a></code>.
</p>

<hr>
<h2 id='lm.ps.MCML'>Monte Carlo Maximum Likelihood estimation of the geostatistical linear model with preferentially sampled locations</h2><span id='topic+lm.ps.MCML'></span>

<h3>Description</h3>

<p>This function performs Monte Carlo maximum likelihood (MCML) estimation for a geostatistical linear model with preferentially sampled locations.
For more details on the model, see below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.ps.MCML(
  formula.response,
  formula.log.intensity = ~1,
  coords,
  which.is.preferential = NULL,
  data.response,
  data.intensity = NULL,
  par0,
  control.mcmc,
  kappa1,
  kappa2,
  mesh,
  grid.intensity,
  start.par = NULL,
  method = "nlminb",
  messages = TRUE,
  plot.correlogram = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lm.ps.MCML_+3A_formula.response">formula.response</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic description of the sub-model for the response variable.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_formula.log.intensity">formula.log.intensity</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic description of the log-Gaussian Cox process sub-model.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the spatial coordinates in the data.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_which.is.preferential">which.is.preferential</code></td>
<td>
<p>a vector of 0 and 1, where 1 indicates a location in the data from a prefential sampling scheme and 0 from a non-preferential.
This option is used to fit a model with a mix of preferentally and non-preferentiall sampled locations. For more, details on the model structure see the 'Details' section.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_data.response">data.response</code></td>
<td>
<p>a data frame containing the variables in the sub-model of the response variable.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_data.intensity">data.intensity</code></td>
<td>
<p>a data frame containing the variables in the log-Gaussian Coz process sub-model. This data frame must be provided only when explanatory variables are used in the
log-Gaussian Cox process model. Each row in the data frame must correspond to a point in the grid provided through the argument 'grid.intensity'. Deafult is <code>data.intensity=NULL</code>,
which corresponds to a model with only the intercept.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_par0">par0</code></td>
<td>
<p>an object of class 'coef.PrevMap.ps'. This argument is used to define the parameters of the importance sampling distribution used in the MCML algorithm.
The input of this argument must be defined using the <code><a href="#topic+set.par.ps">set.par.ps</a></code> function.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code> which defined the control parameters of the Monte Carlo Markv chain algorithm.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_kappa1">kappa1</code></td>
<td>
<p>fixed value for the shape parameter of the Matern covariance function of the spatial process of the sampling intensity (currently only <code>kappa1=1</code> is implemented).</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_kappa2">kappa2</code></td>
<td>
<p>fixed value for the shape parameter of the Matern covariance function of the spatial process of the response variable.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_mesh">mesh</code></td>
<td>
<p>an object obtained as result of a call to the function <code>inla.mesh.2d</code>.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_grid.intensity">grid.intensity</code></td>
<td>
<p>a regular grid covering the geographical region of interest, used to approximate the density function of the log-Gaussian Cox process.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_start.par">start.par</code></td>
<td>
<p>starting value of the optimization algorithm. This is an object of class 'coef.PrevMap.ps' and must be defined using the function <code><a href="#topic+set.par.ps">set.par.ps</a></code>.
Default is <code>start.cov.pars=NULL</code>, so that the starting values are set automatically.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_method">method</code></td>
<td>
<p>method of optimization. If <code>method="BFGS"</code> then the <code><a href="maxLik.html#topic+maxBFGS">maxBFGS</a></code> function is used; otherwise <code>method="nlminb"</code> to use the <code><a href="stats.html#topic+nlminb">nlminb</a></code> function. Default is <code>method="BFGS"</code>.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="lm.ps.MCML_+3A_plot.correlogram">plot.correlogram</code></td>
<td>
<p>logical; if <code>plot.correlogram=TRUE</code> the autocorrelation plot of the samples of the random effect is displayed after completion of conditional simulation. Default is <code>plot.correlogram=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs parameter estimation for a geostatistical linear model with preferentially sampled locations. Let <code class="reqn">S_{1}</code> and <code class="reqn">S_{2}</code> denote two independent, stationary and isotropic Gaussian processes.
The overall model consists of two sub-models: the log-Gaussian Cox process model for the preferentially sampled locations, say <code class="reqn">X</code>;
the model for the response variable, say <code class="reqn">Y</code>. The model assumes that
</p>
<p style="text-align: center;"><code class="reqn">[X, Y, S_1, S_2] = [S_1][S_2] [X | S_1] [Y | X, S_1, S_2],</code>
</p>

<p>where <code class="reqn">[.]</code> denotes 'the distribution of .'.
Each of the two submodels has an associated linear predictor.
Let <code class="reqn">\Lambda(x)</code> denote the intensity of the Poisson process <code class="reqn">X</code>, continionally on <code class="reqn">S_1</code>. Then
</p>
<p style="text-align: center;"><code class="reqn">\log\{\Lambda(x)\} = d(x)'\alpha + S_1</code>
</p>
<p>,
where <code class="reqn">d(x)</code> is vector of explanatory variables with regression coefficient <code class="reqn">\alpha</code>. This linear predictor is defined through the argument <code>formula.log.intensity</code>.
The density of <code class="reqn">[X | S_1]</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\frac{\Lambda(x)}{\int_{A} \Lambda(u) du}</code>
</p>
<p>,
where <code class="reqn">A</code> is the region of interest. The integral at the denominator is intractable and is then approximated using a quadrature procedure.
The regular grid covering <code class="reqn">A</code>, used for the quadrature, must be provided through the argument <code>grid.intensity</code>.
Conditionally on <code class="reqn">X</code>, <code class="reqn">S_1</code> and <code class="reqn">S_2</code>, the response variable model is given by </p>
<p style="text-align: center;"><code class="reqn">Y = d(x)'\beta + S_2 + \gamma S_1,</code>
</p>

<p>where <code class="reqn">\beta</code> is another vector of regression coefficients and <code class="reqn">\gamma</code> is the preferentiality parameter. If <code class="reqn">\gamma=0</code> then we recover the standard geostatistical model.
More details on the fitting procedure can be found in Diggle and Giorgi (2016).
</p>
<p><b>When the data have a mix of preferentially and non-preferentially sampled locations.</b>
In some cases the set of locations may consist of a sub-set which is preferentially sampled, <code class="reqn">X</code>, and a standard
non-prefential sample, <code class="reqn">X^*</code>. Let <code class="reqn">Y</code> and <code class="reqn">Y^*</code> denote the measurments at locations <code class="reqn">X</code> and <code class="reqn">X^*</code>.
In the current implementation, the model has the following form
</p>
<p style="text-align: center;"><code class="reqn">[X, X^*, Y, Y^*, S_1, S_2, S_2^*] = [S_1][S_2][S_2^*] [X | S_1] [Y | X, S_1, S_2] [X^*] [Y^*|X^*, S_2^*],</code>
</p>

<p>where <code class="reqn">S_2</code> and <code class="reqn">S_2^*</code> are two independent Gaussian process but with shared parameters, associated with <code class="reqn">Y</code> and <code class="reqn">Y^*</code>, respectively.
The linear predictor for <code class="reqn">Y</code> is the same as above. The measurements <code class="reqn">Y^*</code>, instead, have linear predicotr
</p>
<p style="text-align: center;"><code class="reqn">Y^* = d(x)'\beta + S_2^*,</code>
</p>

<p>where <code class="reqn">\beta^*</code> is vector of regression coefficients, different from <code class="reqn">\beta</code>. The linear predictor for <code class="reqn">Y</code> and <code class="reqn">Y^*</code> is specified though <code>formula.response</code>.
For example, <code>response ~ x | x + z</code> defines a linear predictor for <code class="reqn">Y</code> with one explanatory variable <code>x</code> and a linear predictor for <code class="reqn">Y^*</code> with two explanatory variables
<code>x</code> and <code>z</code>. An example on the application of this model is given in Diggle and Giorgi (2016).
</p>


<h3>Value</h3>

<p>An object of class &quot;PrevMap.ps&quot;.
The function <code><a href="#topic+summary.PrevMap.ps">summary.PrevMap.ps</a></code> is used to print a summary of the fitted model.
The object is a list with the following components:
</p>
<p><code>estimate</code>: estimates of the model parameters; use the function <code><a href="#topic+coef.PrevMap.ps">coef.PrevMap.ps</a></code> to obtain estimates of covariance parameters on the original scale.
</p>
<p><code>covariance</code>: covariance matrix of the MCML estimates.
</p>
<p><code>log.lik</code>: maximum value of the approximated log-likelihood.
</p>
<p><code>y</code>: observed values of the response variable. If <code>which.is.preferential</code> has been provided, then <code>y</code> is a list with components
<code>y$preferential</code>, for the data with prefentially sampled locations, and <code>y$non.preferential</code>, for the remiaining.
</p>
<p><code>D.response</code>: matrix of covariates used to model the mean component of the response variable. If <code>which.is.preferential</code> has been provided, then <code>D.response</code> is a list with components
<code>D.response$preferential</code>, for the data with prefentially sampled locations, and <code>D.response$non.preferential</code>, for the remiaining.
</p>
<p><code>D.intensity</code>: matrix of covariates used to model the mean component of log-intensity of the log-Gaussian Cox process.
</p>
<p><code>grid.intensity</code>: grid of locations used to approximate the intractable integral of the log-Gaussian Cox process model.
</p>
<p><code>coords</code>: matrix of the observed sampling locations. If <code>which.is.preferential</code> has been provided, then <code>coords</code> is a list with components
<code>y$preferential</code>, for the data with prefentially sampled locations, and <code>y$non.preferential</code>, for the remiaining.
</p>
<p><code>method</code>: method of optimization used.
</p>
<p><code>ID.coords</code>: set of ID values defined through the argument <code>ID.coords</code>.
</p>
<p><code>kappa.response</code>: fixed value of the shape parameter of the Matern covariance function used to model the spatial process associated with the response variable.
</p>
<p><code>mesh</code>: the mesh used in the SPDE approximation.
</p>
<p><code>samples</code>: matrix of the random effects samples from the importance sampling distribution used to approximate the likelihood function.
</p>
<p><code>call</code>: the matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Giorgi, E. (2019). <em>Model-based Geostatistics for Global Public Health.</em> CRC/Chapman &amp; Hall.
</p>
<p>Giorgi, E., Diggle, P.J. (2017). <em>PrevMap: an R package for prevalence mapping.</em> Journal of Statistical Software. 78(8), 1-29. doi: 10.18637/jss.v078.i08
</p>
<p>Diggle, P.J., Giorgi, E. (2017). <em>Preferential sampling of exposures levels.</em> In: Handbook of Environmental and Ecological Statistics. Chapman &amp; Hall.
</p>
<p>Diggle, P.J., Menezes, R. and Su, T.-L. (2010). <em>Geostatistical analysis under preferential sampling (with Discussion).</em> Applied Statistics, 59, 191-232.
</p>
<p>Lindgren, F., Havard, R., Lindstrom, J. (2011). <em>An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach (with discussion).</em>
Journal of the Royal Statistical Society, Series B, 73, 423&ndash;498.
</p>
<p>Pati, D., Reich, B. J., and Dunson, D. B. (2011). <em>Bayesian geostatistical modelling with informative sampling locations.</em> Biometrika, 98, 35-48.
</p>

<hr>
<h2 id='loaloa'>Loa loa prevalence data from 197 village surveys</h2><span id='topic+loaloa'></span>

<h3>Description</h3>

<p>This data-set relates to a study of the prevalence of Loa loa (eyeworm) in a series of surveys undertaken in 197 villages in west Africa (Cameroon and southern Nigeria).
The variables are as follows:
</p>

<ul>
<li><p> ROW row id: 1 to 197.
</p>
</li>
<li><p> VILLCODE village id. 
</p>
</li>
<li><p> LONGITUDE Longitude in degrees.
</p>
</li>
<li><p> LATITUDE Latitude in degrees.
</p>
</li>
<li><p> NO_EXAM Number of people tested.
</p>
</li>
<li><p> NO_INF Number of positive test results.
</p>
</li>
<li><p> ELEVATION Height above sea-level in metres.
</p>
</li>
<li><p> MEAN9901 Mean of all NDVI values recorded at village location, 1999-2001
</p>
</li>
<li><p> MAX9901 Maximum of all NDVI values recorded at village location, 1999-2001
</p>
</li>
<li><p> MIN9901 Minimum of all NDVI values recorded at village location, 1999-2001
</p>
</li>
<li><p> MIN9901 Minimum of all NDVI values recorded at village location, 1999-2001
</p>
</li>
<li><p> STDEV9901 standard deviation of all NDVI values recorded at village location, 1999-2001
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(loaloa)
</code></pre>


<h3>Format</h3>

<p>A data frame with 197 rows and 11 variables
</p>


<h3>References</h3>

<p>Diggle, P.J., Thomson, M.C., Christensen, O.F., Rowlingson, B., Obsomer, V., Gardon, J., Wanji, S., Takougang, I., Enyong, P., Kamgno, J., Remme, H., Boussinesq, M. and Molyneux, D.H. (2007). Spatial modelling and prediction of Loa loa risk: decision making under uncertainty. Annals of Tropical Medicine and Parasitology, 101, 499-509.
</p>

<hr>
<h2 id='loglik.ci'>Profile likelihood confidence intervals</h2><span id='topic+loglik.ci'></span>

<h3>Description</h3>

<p>Computes confidence intervals based on the interpolated profile likelihood computed for a single covariance parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.ci(object, coverage = 0.95, plot.spline.profile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik.ci_+3A_object">object</code></td>
<td>
<p>object of class &quot;profile.PrevMap&quot; obtained from <code><a href="#topic+loglik.linear.model">loglik.linear.model</a></code>.</p>
</td></tr>
<tr><td><code id="loglik.ci_+3A_coverage">coverage</code></td>
<td>
<p>a value between 0 and 1 indicating the coverage of the confidence interval based on the interpolated profile likelihood. Default is <code>coverage=0.95</code>.</p>
</td></tr>
<tr><td><code id="loglik.ci_+3A_plot.spline.profile">plot.spline.profile</code></td>
<td>
<p>logical; if <code>TRUE</code> an interpolating spline of the profile-likelihood of for a univariate parameter is plotted. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements <code>lower</code> and <code>upper</code> for the upper and lower limits of the confidence interval, respectively.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='loglik.linear.model'>Profile log-likelihood or fixed parameters likelihood evaluation for the covariance parameters in the geostatistical linear model</h2><span id='topic+loglik.linear.model'></span>

<h3>Description</h3>

<p>Computes profile log-likelihood, or evaluatesx likelihood keeping the other paramaters fixed, for the scale parameter <code>phi</code> of the Matern function and the relative variance of the nugget effect <code>nu2</code> in the linear Gaussian model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik.linear.model(
  object,
  control.profile,
  plot.profile = TRUE,
  messages = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik.linear.model_+3A_object">object</code></td>
<td>
<p>an object of class 'PrevMap', which is the fitted linear model obtained with the function <code><a href="#topic+linear.model.MLE">linear.model.MLE</a></code>.</p>
</td></tr>
<tr><td><code id="loglik.linear.model_+3A_control.profile">control.profile</code></td>
<td>
<p>control parameters obtained with <code><a href="#topic+control.profile">control.profile</a></code>.</p>
</td></tr>
<tr><td><code id="loglik.linear.model_+3A_plot.profile">plot.profile</code></td>
<td>
<p>logical; if <code>TRUE</code> a plot of the computed profile likelihood is displayed.</p>
</td></tr>
<tr><td><code id="loglik.linear.model_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;profile.PrevMap&quot; which is a list with the following values
</p>
<p><code>eval.points.phi</code>: vector of the values used for <code>phi</code> in the evaluation of the likelihood.
</p>
<p><code>eval.points.rel.nugget</code>: vector of the values used for <code>nu2</code> in the evaluation of the likelihood.
</p>
<p><code>profile.phi</code>: vector of the values of the likelihood function evaluated at <code>eval.points.phi</code>.
</p>
<p><code>profile.rel.nugget</code>: vector of the values of the likelihood function evaluated at <code>eval.points.rel.nugget</code>.
</p>
<p><code>profile.phi.rel.nugget</code>: matrix of the values of the likelihood function evaluated at <code>eval.points.phi</code> and <code>eval.points.rel.nugget</code>.
</p>
<p><code>fixed.par</code>: logical value; <code>TRUE</code> is the evaluation if the likelihood is carried out by fixing the other parameters, and <code>FALSE</code> if the computation of the profile-likelihood was performed instead.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='matern.kernel'>Matern kernel</h2><span id='topic+matern.kernel'></span>

<h3>Description</h3>

<p>This function computes values of the Matern kernel for given distances and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matern.kernel(u, rho, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matern.kernel_+3A_u">u</code></td>
<td>
<p>a vector, matrix or array with values of the distances between pairs of data locations.</p>
</td></tr>
<tr><td><code id="matern.kernel_+3A_rho">rho</code></td>
<td>
<p>value of the (re-parametrized) scale parameter; this corresponds to the re-parametrization <code>rho = 2*sqrt(kappa)*phi</code>.</p>
</td></tr>
<tr><td><code id="matern.kernel_+3A_kappa">kappa</code></td>
<td>
<p>value of the shape parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Matern kernel is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
K(u; \phi, \kappa) = \frac{\Gamma(\kappa + 1)^{1/2}\kappa^{(\kappa+1)/4}u^{(\kappa-1)/2}}{\pi^{1/2}\Gamma((\kappa+1)/2)\Gamma(\kappa)^{1/2}(2\kappa^{1/2}\phi)^{(\kappa+1)/2}}\mathcal{K}_{\kappa}(u/\phi), u &gt; 0,
</code>
</p>

<p>where <code class="reqn">\phi</code> and <code class="reqn">\kappa</code> are the scale and shape parameters, respectively, and <code class="reqn">\mathcal{K}_{\kappa}(.)</code> is the modified Bessel function of the third kind of order <code class="reqn">\kappa</code>. The family is valid for <code class="reqn">\phi &gt; 0</code> and <code class="reqn">\kappa &gt; 0</code>.
</p>


<h3>Value</h3>

<p>A vector matrix or array, according to the argument u, with the values of the Matern kernel function for the given distances.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='plot.pred.PrevMap'>Plot of a predicted surface</h2><span id='topic+plot.pred.PrevMap'></span>

<h3>Description</h3>

<p><code>plot.pred.PrevMap</code> displays predictions obtained from <code><a href="#topic+spatial.pred.linear.MLE">spatial.pred.linear.MLE</a></code>, <code><a href="#topic+spatial.pred.linear.Bayes">spatial.pred.linear.Bayes</a></code>,<code><a href="#topic+spatial.pred.binomial.MCML">spatial.pred.binomial.MCML</a></code>, <code><a href="#topic+spatial.pred.binomial.Bayes">spatial.pred.binomial.Bayes</a></code> and <code><a href="#topic+spatial.pred.poisson.MCML">spatial.pred.poisson.MCML</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pred.PrevMap'
plot(x, type = NULL, summary = "predictions", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pred.PrevMap_+3A_x">x</code></td>
<td>
<p>an object of class &quot;PrevMap&quot;.</p>
</td></tr>
<tr><td><code id="plot.pred.PrevMap_+3A_type">type</code></td>
<td>
<p>a character indicating the type of prediction to display: 'prevalence','odds', 'logit' or 'probit' for binomial models; &quot;log&quot; or &quot;exponential&quot; for Poisson models. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot.pred.PrevMap_+3A_summary">summary</code></td>
<td>
<p>character indicating which summary to display: 'predictions','quantiles', 'standard.errors' or 'exceedance.prob'; default is 'predictions'. If <code>summary="exceedance.prob"</code>, the argument <code>type</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.pred.PrevMap_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+plot">plot</a></code> of the 'raster' package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='plot.pred.PrevMap.ps'>Plot of a predicted surface of geostatistical linear fits with preferentially sampled locations</h2><span id='topic+plot.pred.PrevMap.ps'></span>

<h3>Description</h3>

<p><code>plot.pred.PrevMap.ps</code> displays predictions obtained from <code><a href="#topic+lm.ps.MCML">lm.ps.MCML</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pred.PrevMap.ps'
plot(x, target = NULL, summary = "predictions", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pred.PrevMap.ps_+3A_x">x</code></td>
<td>
<p>an object of class &quot;PrevMap&quot;.</p>
</td></tr>
<tr><td><code id="plot.pred.PrevMap.ps_+3A_target">target</code></td>
<td>
<p>a integer value indicating the predictive target: <code>target=1</code> to visualize summaries of the surface associated with the response variable;
<code>target=2</code> to visualize summaries of the surface associated with the sampling intensity. If only one target has been predicted, this argument is ignored.</p>
</td></tr>
<tr><td><code id="plot.pred.PrevMap.ps_+3A_summary">summary</code></td>
<td>
<p>character indicating which summary to display: 'predictions','quantiles' or 'standard.errors'. Default is <code>summary='predictions'</code>. If <code>summary="exceedance.prob"</code>, the argument <code>type</code> is ignored.</p>
</td></tr>
<tr><td><code id="plot.pred.PrevMap.ps_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+plot">plot</a></code> of the 'raster' package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='plot.PrevMap.diagnostic'>Plot of the variogram-based diagnostics</h2><span id='topic+plot.PrevMap.diagnostic'></span>

<h3>Description</h3>

<p>Displays the results from a call to <code><a href="#topic+variog.diagnostic.lm">variog.diagnostic.lm</a></code> and <code><a href="#topic+variog.diagnostic.glgm">variog.diagnostic.glgm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PrevMap.diagnostic'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.PrevMap.diagnostic_+3A_x">x</code></td>
<td>
<p>an object of class &quot;PrevMap.diagnostic&quot;.</p>
</td></tr>
<tr><td><code id="plot.PrevMap.diagnostic_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+plot">plot</a></code> of the 'raster' package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+variog.diagnostic.lm">variog.diagnostic.lm</a></code>, <code><a href="#topic+variog.diagnostic.glgm">variog.diagnostic.glgm</a></code>
</p>

<hr>
<h2 id='plot.profile.PrevMap'>Plot of the profile log-likelihood for the covariance parameters of the Matern function</h2><span id='topic+plot.profile.PrevMap'></span>

<h3>Description</h3>

<p>This function displays a plot of the profile log-likelihood that is computed by the function <code><a href="#topic+loglik.linear.model">loglik.linear.model</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile.PrevMap'
plot(x, log.scale = FALSE, plot.spline.profile = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.profile.PrevMap_+3A_x">x</code></td>
<td>
<p>object of class &quot;profile.PrevMap&quot; obtained as output from <code><a href="#topic+loglik.linear.model">loglik.linear.model</a></code>.</p>
</td></tr>
<tr><td><code id="plot.profile.PrevMap_+3A_log.scale">log.scale</code></td>
<td>
<p>logical; if <code>log.scale=TRUE</code>, the profile likleihood is plotted on the log-scale of the parameter values.</p>
</td></tr>
<tr><td><code id="plot.profile.PrevMap_+3A_plot.spline.profile">plot.spline.profile</code></td>
<td>
<p>logical; if <code>TRUE</code> an interpolating spline of the profile-likelihood of for a univariate parameter is plotted. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.profile.PrevMap_+3A_...">...</code></td>
<td>
<p>further arugments passed to <code><a href="base.html#topic+plot">plot</a></code> if the profile log-likelihood is for only one parameter, or to <code><a href="graphics.html#topic+contour">contour</a></code> for the bi-variate profile-likelihood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is returned. No value is returned.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='plot.shape.matern'>Plot of the profile likelihood for the shape parameter of the Matern covariance function</h2><span id='topic+plot.shape.matern'></span>

<h3>Description</h3>

<p>This function plots the profile likelihood for the shape parameter of the Matern covariance function using the output from <code><a href="#topic+shape.matern">shape.matern</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'shape.matern'
plot(x, plot.spline = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.shape.matern_+3A_x">x</code></td>
<td>
<p>an object of class 'shape.matern' obtained as result of a call to <code><a href="#topic+shape.matern">shape.matern</a></code></p>
</td></tr>
<tr><td><code id="plot.shape.matern_+3A_plot.spline">plot.spline</code></td>
<td>
<p>logical; if <code>TRUE</code> an interpolating spline of the profile likelihood is added to the plot.</p>
</td></tr>
<tr><td><code id="plot.shape.matern_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not return any value.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shape.matern">shape.matern</a></code>
</p>

<hr>
<h2 id='point.map'>Point map</h2><span id='topic+point.map'></span>

<h3>Description</h3>

<p>This function produces a plot with points indicating the data locations. Arguments can control the points sizes, patterns and colors. These can be set to be proportional to data values, ranks or quantiles. Alternatively, points can be added to the current plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point.map(data, var.name, coords, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="point.map_+3A_data">data</code></td>
<td>
<p>an object of class &quot;data.frame&quot; containing the data.</p>
</td></tr>
<tr><td><code id="point.map_+3A_var.name">var.name</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> object indicating the variable to display.</p>
</td></tr>
<tr><td><code id="point.map_+3A_coords">coords</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> object indicating the geographical coordinates.</p>
</td></tr>
<tr><td><code id="point.map_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>points.geodata</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='poisson.log.MCML'>Monte Carlo Maximum Likelihood estimation for the Poisson model</h2><span id='topic+poisson.log.MCML'></span>

<h3>Description</h3>

<p>This function performs Monte Carlo maximum likelihood (MCML) estimation for the geostatistical Poisson model with log link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poisson.log.MCML(
  formula,
  units.m = NULL,
  coords,
  data,
  ID.coords = NULL,
  par0,
  control.mcmc,
  kappa,
  fixed.rel.nugget = NULL,
  start.cov.pars,
  method = "BFGS",
  low.rank = FALSE,
  knots = NULL,
  messages = TRUE,
  plot.correlogram = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="poisson.log.MCML_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_units.m">units.m</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the multiplicative offset for the mean of the Poisson model; if not specified this is then internally set as 1.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the geographic coordinates.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_id.coords">ID.coords</code></td>
<td>
<p>vector of ID values for the unique set of spatial coordinates obtained from <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>. These must be provided if, for example, spatial random effects are defined at location-level but some of the covariates are at individual level. <b>Warning</b>: the spatial coordinates must all be distinct otherwise see <code>jitterDupCoords</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_par0">par0</code></td>
<td>
<p>parameters of the importance sampling distribution: these should be given in the following order <code>c(beta,sigma2,phi,tau2)</code>, where <code>beta</code> are the regression coefficients, <code>sigma2</code> is the variance of the Gaussian process, <code>phi</code> is the scale parameter of the spatial correlation and <code>tau2</code> is the variance of the nugget effect (if included in the model).</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_kappa">kappa</code></td>
<td>
<p>fixed value for the shape parameter of the Matern covariance function.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_fixed.rel.nugget">fixed.rel.nugget</code></td>
<td>
<p>fixed value for the relative variance of the nugget effect; <code>fixed.rel.nugget=NULL</code> if this should be included in the estimation. Default is <code>fixed.rel.nugget=NULL</code>.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_start.cov.pars">start.cov.pars</code></td>
<td>
<p>a vector of length two with elements corresponding to the starting values of <code>phi</code> and the relative variance of the nugget effect <code>nu2</code>, respectively, that are used in the optimization algorithm. If <code>nu2</code> is fixed through <code>fixed.rel.nugget</code>, then <code>start.cov.pars</code> represents the starting value for <code>phi</code> only.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_method">method</code></td>
<td>
<p>method of optimization. If <code>method="BFGS"</code> then the <code><a href="maxLik.html#topic+maxBFGS">maxBFGS</a></code> function is used; otherwise <code>method="nlminb"</code> to use the <code><a href="stats.html#topic+nlminb">nlminb</a></code> function. Default is <code>method="BFGS"</code>.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_low.rank">low.rank</code></td>
<td>
<p>logical; if <code>low.rank=TRUE</code> a low-rank approximation of the Gaussian spatial process is used when fitting the model. Default is <code>low.rank=FALSE</code>.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_knots">knots</code></td>
<td>
<p>if <code>low.rank=TRUE</code>, <code>knots</code> is a matrix of spatial knots that are used in the low-rank approximation. Default is <code>knots=NULL</code>.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="poisson.log.MCML_+3A_plot.correlogram">plot.correlogram</code></td>
<td>
<p>logical; if <code>plot.correlogram=TRUE</code> the autocorrelation plot of the samples of the random effect is displayed after completion of conditional simulation. Default is <code>plot.correlogram=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs parameter estimation for a geostatistical Poisson model with log link function. Conditionally on a zero-mean stationary Gaussian process <code class="reqn">S(x)</code> and mutually independent zero-mean Gaussian variables <code class="reqn">Z</code> with variance <code>tau2</code>, the observations <code>y</code> are generated from a Poisson distribution with mean <code class="reqn">m\lambda</code>, where <code class="reqn">m</code> is an offset defined through the argument <code>units.m</code>. A canonical log link is used, thus the linear predictor assumes the form
</p>
<p style="text-align: center;"><code class="reqn">\log(\lambda) = d'\beta + S(x) + Z,</code>
</p>

<p>where <code class="reqn">d</code> is a vector of covariates with associated regression coefficients <code class="reqn">\beta</code>. The Gaussian process <code class="reqn">S(x)</code> has isotropic Matern covariance function (see <code>matern</code>) with variance <code>sigma2</code>, scale parameter <code>phi</code> and shape parameter <code>kappa</code>.
In the <code>poisson.log.MCML</code> function, the shape parameter is treated as fixed. The relative variance of the nugget effect, <code>nu2=tau2/sigma2</code>, can also be fixed through the argument <code>fixed.rel.nugget</code>; if <code>fixed.rel.nugget=NULL</code>, then the relative variance of the nugget effect is also included in the estimation.
</p>
<p><b>Monte Carlo Maximum likelihood.</b>
The Monte Carlo maximum likelihood method uses conditional simulation from the distribution of the random effect <code class="reqn">T(x) = d(x)'\beta+S(x)+Z</code> given the data <code>y</code>, in order to approximate the high-dimensiional intractable integral given by the likelihood function. The resulting approximation of the likelihood is then maximized by a numerical optimization algorithm which uses analytic epression for computation of the gradient vector and Hessian matrix. The functions used for numerical optimization are <code><a href="maxLik.html#topic+maxBFGS">maxBFGS</a></code> (<code>method="BFGS"</code>), from the <span class="pkg">maxLik</span> package, and <code><a href="stats.html#topic+nlminb">nlminb</a></code> (<code>method="nlminb"</code>).
</p>
<p><b>Low-rank approximation.</b>
In the case of very large spatial data-sets, a low-rank approximation of the Gaussian spatial process <code class="reqn">S(x)</code> might be computationally beneficial. Let <code class="reqn">(x_{1},\dots,x_{m})</code> and <code class="reqn">(t_{1},\dots,t_{m})</code> denote the set of sampling locations and a grid of spatial knots covering the area of interest, respectively. Then <code class="reqn">S(x)</code> is approximated as <code class="reqn">\sum_{i=1}^m K(\|x-t_{i}\|; \phi, \kappa)U_{i}</code>, where <code class="reqn">U_{i}</code> are zero-mean mutually independent Gaussian variables with variance <code>sigma2</code> and <code class="reqn">K(.;\phi, \kappa)</code> is the isotropic Matern kernel (see <code><a href="#topic+matern.kernel">matern.kernel</a></code>). Since the resulting approximation is no longer a stationary process (but only approximately), the parameter <code>sigma2</code> is then multiplied by a factor <code>constant.sigma2</code> so as to obtain a value that is closer to the actual variance of <code class="reqn">S(x)</code>.
</p>


<h3>Value</h3>

<p>An object of class &quot;PrevMap&quot;.
The function <code><a href="#topic+summary.PrevMap">summary.PrevMap</a></code> is used to print a summary of the fitted model.
The object is a list with the following components:
</p>
<p><code>estimate</code>: estimates of the model parameters; use the function <code><a href="#topic+coef.PrevMap">coef.PrevMap</a></code> to obtain estimates of covariance parameters on the original scale.
</p>
<p><code>covariance</code>: covariance matrix of the MCML estimates.
</p>
<p><code>log.lik</code>: maximum value of the log-likelihood.
</p>
<p><code>y</code>: observations.
</p>
<p><code>units.m</code>: offset.
</p>
<p><code>D</code>: matrix of covariates.
</p>
<p><code>ID.coords</code>: set of ID values defined through the argument <code>ID.coords</code>.
</p>
<p><code>coords</code>: matrix of the observed sampling locations.
</p>
<p><code>method</code>: method of optimization used.
</p>
<p><code>kappa</code>: fixed value of the shape parameter of the Matern function.
</p>
<p><code>knots</code>: matrix of the spatial knots used in the low-rank approximation.
</p>
<p><code>const.sigma2</code>: adjustment factor for <code>sigma2</code> in the low-rank approximation.
</p>
<p><code>h</code>: vector of the values of the tuning parameter at each iteration of the Langevin-Hastings MCMC algorithm; see <code><a href="#topic+Laplace.sampling">Laplace.sampling</a></code>, or <code><a href="#topic+Laplace.sampling.lr">Laplace.sampling.lr</a></code> if a low-rank approximation is used.
</p>
<p><code>samples</code>: matrix of the random effects samples from the importance sampling distribution used to approximate the likelihood function.
</p>
<p><code>fixed.rel.nugget</code>: fixed value for the relative variance of the nugget effect.
</p>
<p><code>call</code>: the matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>


<h3>References</h3>

<p>Diggle, P.J., Giorgi, E. (2019). <em>Model-based Geostatistics for Global Public Health.</em> CRC/Chapman &amp; Hall.
</p>
<p>Giorgi, E., Diggle, P.J. (2017). <em>PrevMap: an R package for prevalence mapping.</em> Journal of Statistical Software. 78(8), 1-29. doi: 10.18637/jss.v078.i08
</p>
<p>Christensen, O. F. (2004). <em>Monte carlo maximum likelihood in model-based geostatistics.</em> Journal of Computational and Graphical Statistics 13, 702-718.
</p>
<p>Higdon, D. (1998). <em>A process-convolution approach to modeling temperatures in the North Atlantic Ocean.</em> Environmental and Ecological Statistics 5, 173-190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Laplace.sampling">Laplace.sampling</a></code>, <code><a href="#topic+Laplace.sampling.lr">Laplace.sampling.lr</a></code>, <code><a href="#topic+summary.PrevMap">summary.PrevMap</a></code>, <code><a href="#topic+coef.PrevMap">coef.PrevMap</a></code>, <code>matern</code>, <code><a href="#topic+matern.kernel">matern.kernel</a></code>,  <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.
</p>

<hr>
<h2 id='set.par.ps'>Define the model coefficients of a geostatistical linear model with preferentially sampled locations</h2><span id='topic+set.par.ps'></span>

<h3>Description</h3>

<p><code>set.par.ps</code> defines the model coefficients of a geostatistical linear model with preferentially sampled locations.
The output of this function can be used to: 1) define the parameters of the importance sampling distribution in <code><a href="#topic+lm.ps.MCML">lm.ps.MCML</a></code>; 2) the starting values of the optimization algorithm in <code><a href="#topic+lm.ps.MCML">lm.ps.MCML</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.par.ps(p = 1, q = 1, intensity, response, preferentiality.par)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.par.ps_+3A_p">p</code></td>
<td>
<p>number of covariates used in the response variable model, including the intercept. Default is <code>p=1</code>.</p>
</td></tr>
<tr><td><code id="set.par.ps_+3A_q">q</code></td>
<td>
<p>number of covariates used in the log-Guassian Cox process model, including the intercept. Default is <code>q=1</code>.</p>
</td></tr>
<tr><td><code id="set.par.ps_+3A_intensity">intensity</code></td>
<td>
<p>a vector of parameters of the log-Gaussian Cox process model. These must be provided in the following order: regression coefficients of the explanatory variables; variance and scale of the spatial correlation for the isotropic Gaussian process.
In the case of a model with a mix of preferentially and non-preferentially sampled locations, the order of the regression coefficients should be the following: regression coefficients for the linear predictor with preferential sampling; regression coefficients for the linear predictor with non-preferential samples.</p>
</td></tr>
<tr><td><code id="set.par.ps_+3A_response">response</code></td>
<td>
<p>a vector of parameters of the response variable model. These must be provided in the following order: regression coefficients of the explanatory variables; variance and scale of the spatial correlation for the isotropic Gaussian process; and variance of the nugget effect.</p>
</td></tr>
<tr><td><code id="set.par.ps_+3A_preferentiality.par">preferentiality.par</code></td>
<td>
<p>value of the preferentiality paramter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of coefficients of class <code>coef.PrevMap.ps</code>.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='shape.matern'>Profile likelihood for the shape parameter of the Matern covariance function</h2><span id='topic+shape.matern'></span>

<h3>Description</h3>

<p>This function plots the profile likelihood for the shape parameter of the Matern covariance function used in the linear Gaussian model. It also computes confidence intervals of coverage <code>coverage</code> by interpolating the profile likelihood with a spline and using the asymptotic distribution of a chi-squared with one degree of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape.matern(
  formula,
  coords,
  data,
  set.kappa,
  fixed.rel.nugget = NULL,
  start.par,
  coverage = NULL,
  plot.profile = TRUE,
  messages = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape.matern_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="shape.matern_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the geographic coordinates.</p>
</td></tr>
<tr><td><code id="shape.matern_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="shape.matern_+3A_set.kappa">set.kappa</code></td>
<td>
<p>a vector indicating the set values for evluation of the profile likelihood.</p>
</td></tr>
<tr><td><code id="shape.matern_+3A_fixed.rel.nugget">fixed.rel.nugget</code></td>
<td>
<p>a value for the relative variance <code>nu2</code> of the nugget effect, that is then treated as fixed. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="shape.matern_+3A_start.par">start.par</code></td>
<td>
<p>starting values for the scale parameter <code>phi</code> and the relative variance of the nugget effect <code>nu2</code>; if <code>fixed.rel.nugget</code> is provided, then a starting value for <code>phi</code> only should be provided.</p>
</td></tr>
<tr><td><code id="shape.matern_+3A_coverage">coverage</code></td>
<td>
<p>a value between 0 and 1 indicating the coverage of the confidence interval based on the interpolated profile liklelihood for the shape parameter. Default is <code>coverage=NULL</code> and no confidence interval is then computed.</p>
</td></tr>
<tr><td><code id="shape.matern_+3A_plot.profile">plot.profile</code></td>
<td>
<p>logical; if <code>TRUE</code> the computed profile-likelihood is plotted together with the interpolating spline.</p>
</td></tr>
<tr><td><code id="shape.matern_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class 'shape.matern' that is a list with the following components
</p>
<p><code>set.kappa</code> set of values of the shape parameter used to evaluate the profile-likelihood.
</p>
<p><code>val.kappa</code> values of the profile likelihood.
</p>
<p>If a value for <code>coverage</code> is specified, the list also contains <code>lower</code>, <code>upper</code> and <code>kappa.hat</code> that correspond to the lower and upper limits of the confidence interval, and the maximum likelihood estimate for the shape parameter, respectively.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='spat.corr.diagnostic'>Diagnostics for residual spatial correlation</h2><span id='topic+spat.corr.diagnostic'></span>

<h3>Description</h3>

<p>This function performs two variogram-based tests for residual spatial correlation in real-valued and count (Binomial and Poisson) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spat.corr.diagnostic(
  formula,
  units.m = NULL,
  coords,
  data,
  likelihood,
  ID.coords = NULL,
  n.sim = 200,
  nAGQ = 1,
  uvec = NULL,
  plot.results = TRUE,
  lse.variogram = FALSE,
  kappa = 0.5,
  which.test = "both"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spat.corr.diagnostic_+3A_formula">formula</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_units.m">units.m</code></td>
<td>
<p>vector of binomial denominators, or offset if the Poisson model is used.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_coords">coords</code></td>
<td>
<p>an object of class <code><a href="stats.html#topic+formula">formula</a></code> indicating the geographic coordinates.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_data">data</code></td>
<td>
<p>an object of class &quot;data.frame&quot; containing the data.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_likelihood">likelihood</code></td>
<td>
<p>a character that can be set to &quot;Gaussian&quot;,&quot;Binomial&quot; or &quot;Poisson&quot;</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_id.coords">ID.coords</code></td>
<td>
<p>vector of ID values for the unique set of spatial coordinates obtained from <code><a href="#topic+create.ID.coords">create.ID.coords</a></code>.
These must be provided if, for example, spatial random effects are defined at
household level but some of the covariates are at individual level. <b>Warning</b>: the household coordinates must all be distinct
otherwise see <code>jitterDupCoords</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations used to perform the selected test(s) for spatial correlation.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_nagq">nAGQ</code></td>
<td>
<p>integer scalar (passed to <code><a href="lme4.html#topic+glmer">glmer</a></code>) - the number of points per axis for evaluating the adaptive Gauss-Hermite approximation to the log-likelihood.
Defaults to 1, corresponding to the Laplace approximation. Values greater than 1 produce greater accuracy in the evaluation of the
log-likelihood at the expense of speed. A value of zero uses a faster but less exact form of parameter estimation for GLMMs by optimizing
the random effects and the fixed-effects coefficients in the penalized iteratively reweighted least squares step.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_uvec">uvec</code></td>
<td>
<p>a vector with values used to define the variogram binning. If <code>uvec=NULL</code>, then <code>uvec</code> is then set to <code>seq(MIN_DIST,(MAX_DIST-MIN_DIST)/2,length=15)</code>
where <code>MIN_DIST</code> and <code>MAX_DIST</code> are the minimum and maximum observed distances.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_plot.results">plot.results</code></td>
<td>
<p>if <code>plot.results=TRUE</code>, a plot is returned showing the results for the selected test(s) for spatial correlation. By default <code>plot.results=TRUE</code>.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_lse.variogram">lse.variogram</code></td>
<td>
<p>if <code>lse.variogram=TRUE</code>, a weighted least square fit of a Matern function (with fixed <code>kappa</code>) to the empirical variogram is performed. If <code>plot.results=TRUE</code> and <code>lse.variogram=TRUE</code>, the
fitted weighted least square fit is displayed as a dashed line in the returned plot.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_kappa">kappa</code></td>
<td>
<p>smothness parameter of the Matern function for the Gaussian process to approximate. The deafault is <code>kappa=0.5</code>.</p>
</td></tr>
<tr><td><code id="spat.corr.diagnostic_+3A_which.test">which.test</code></td>
<td>
<p>a character specifying which test for residual spatial correlation is to be performed: &quot;variogram&quot;, &quot;test statistic&quot; or &quot;both&quot;. The default is <code>which.test="both"</code>. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first fits a generalized linear mixed model using the for an outcome <code class="reqn">Y_i</code> which, conditionally on i.i.d. random effects <code class="reqn">Z_i</code>, are mutually independent
GLMs with linear predictor
</p>
<p style="text-align: center;"><code class="reqn">g^{-1}(\eta_i)=d_i'\beta+Z_i</code>
</p>

<p>where <code class="reqn">d_i</code> is a vector of covariates which are specified through <code>formula</code>. Finally, the <code class="reqn">Z_i</code> are assumed to be zero-mean Gaussian variables with variance <code class="reqn">\sigma^2</code>
</p>
<p><b>Variogram-based graphical diagnostic</b>
</p>
<p>This graphical diagnostic is performed by setting <code>which.test="both"</code> or <code>which.test="variogram"</code>. The output are 95
(see below <code>lower.lim</code> and <code>upper.lim</code>) that are generated under the assumption of spatial indepdence through the following steps
</p>
<p>1. Fit a generalized linear mixed model as indicated by the equation above.
</p>
<p>2. Obtain the mode, say <code class="reqn">\hat{Z}_i</code>, of the <code class="reqn">Z_i</code> conditioned on the data <code class="reqn">Y_i</code>.
</p>
<p>3. Compute the empirical variogram using <code class="reqn">\hat{Z}_i</code>
</p>
<p>4. Permute the locations specified in <code>coords</code>, <code>n.sim</code> time while holding the <code class="reqn">\hat{Z}_i</code> fixed.
</p>
<p>5. For each of the permuted data-sets compute the empirical variogram based on the <code class="reqn">\hat{Z}_i</code>.
</p>
<p>6. From the <code>n.sim</code> variograms obtained in the previous step, compute the 95
</p>
<p>If the observed variogram (<code>obs.variogram</code> below), based on the un-permuted <code class="reqn">\hat{Z}_i</code>, falls within the 95
residual spatial correlation; if, instead, that partly falls outside the 95
</p>
<p><b>Test for spatial independence</b>
</p>
<p>This diagnostic test is performed if <code>which.test="both"</code> or <code>which.test="test statistic"</code>. Let <code class="reqn">\hat{v}(B)</code> denote the empirical variogram based on <code class="reqn">\hat{Z}_i</code> for the distance bin <code class="reqn">B</code>.
The test statistic used for testing residual spatial correlation is
</p>
<p style="text-align: center;"><code class="reqn">T = \sum_{B} N(B) \{v(B)-\hat{\sigma}^2\}</code>
</p>

<p>where <code class="reqn">N(B)</code> is the number of pairs of data-points falling within the distance bin <code class="reqn">B</code> (<code>n.bins</code> below) and <code class="reqn">\hat{\sigma}^2</code> is the estimate of <code class="reqn">\sigma^2</code>.
</p>
<p>To obtain the distribution of the test statistic <code class="reqn">T</code> under the null hypothesis of spatial independence, we use the simulated empirical variograms as obtained in step 5 of the iterative procedure described in &quot;Variogram-based graphical diagnostic.&quot;
The p-value for the test of spatial independence is then computed by taking the proportion of simulated values for <code class="reqn">T</code> under the null the hypothesis that are larger than the value of <code class="reqn">T</code> based on the original (un-permuted) <code class="reqn">\hat{Z}_i</code>
</p>


<h3>Value</h3>

<p>An object of class &quot;PrevMap.diagnostic&quot; which is a list containing the following components:
</p>
<p><code>obs.variogram</code>: a vector of length <code>length(uvec)-1</code> containing the values of the variogram for each of
the distance bins defined through <code>uvec</code>.
</p>
<p><code>distance.bins</code>: a vector of length <code>length(uvec)-1</code> containing the average distance within each of the distance bins
defined through <code>uvec</code>.
</p>
<p><code>n.bins</code>: a vector of length <code>length(uvec)-1</code> containing the number of pairs of data-points falling within each distance bin.
</p>
<p><code>lower.lim</code>: (available only if <code>which.test="both"</code> or <code>which.test="variogram"</code>) a vector of length <code>length(uvec)-1</code> containing the lower limits of the 95
generated under the assumption of absence of spatial correlation at each fo the distance bins  defined through <code>uvec</code>.
</p>
<p><code>upper.lim</code>: (available only if <code>which.test="both"</code> or <code>which.test="variogram"</code>) a vector of length <code>length(uvec)-1</code> containing the upper limits of the 95
generated under the assumption of absence of spatial correlation at each fo the distance bins  defined through <code>uvec</code>.
</p>
<p><code>mode.rand.effects</code>: the predictive mode of the random effects from the fitted non-spatial generalized linear mixed model.
</p>
<p><code>p.value</code>: (available only if <code>which.test="both"</code> or <code>which.test="test statistic"</code>) p-value of the test for residual spatial correlation.
</p>
<p><code>lse.variogram</code>: (available only if <code>lse.variogram=TRUE</code>) a vector of length <code>length(uvec)-1</code> containing the values of the estimated Matern variogram via a weighted least square fit.
</p>

<hr>
<h2 id='spatial.pred.binomial.Bayes'>Bayesian spatial prediction for the binomial logistic and binary probit models</h2><span id='topic+spatial.pred.binomial.Bayes'></span>

<h3>Description</h3>

<p>This function performs Bayesian spatial prediction for the binomial logistic and binary probit models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.pred.binomial.Bayes(
  object,
  grid.pred,
  predictors = NULL,
  type = "marginal",
  scale.predictions = "prevalence",
  quantiles = c(0.025, 0.975),
  standard.errors = FALSE,
  thresholds = NULL,
  scale.thresholds = NULL,
  messages = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_object">object</code></td>
<td>
<p>an object of class &quot;Bayes.PrevMap&quot; obtained as result of a call to <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+binary.probit.Bayes">binary.probit.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_grid.pred">grid.pred</code></td>
<td>
<p>a matrix of prediction locations.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_predictors">predictors</code></td>
<td>
<p>a data frame of the values of the explanatory variables at each of the locations in <code>grid.pred</code>; each column correspond to a variable and each row to a location. <b>Warning:</b> the names of the columns in the data frame must match those in the data used to fit the model. Default is <code>predictors=NULL</code> for models with only an intercept.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_type">type</code></td>
<td>
<p>a character indicating the type of spatial predictions: <code>type="marginal"</code> for marginal predictions or <code>type="joint"</code> for joint predictions. Default is <code>type="marginal"</code>. In the case of a low-rank approximation only joint predictions are available.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_scale.predictions">scale.predictions</code></td>
<td>
<p>a character vector of maximum length 3, indicating the required scale on which spatial prediction is carried out: &quot;logit&quot;, &quot;prevalence&quot;, &quot;odds&quot; and &quot;probit&quot;. Default is <code>scale.predictions="prevalence"</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector of quantiles used to summarise the spatial predictions.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_standard.errors">standard.errors</code></td>
<td>
<p>logical; if <code>standard.errors=TRUE</code>, then standard errors for each <code>scale.predictions</code> are returned. Default is <code>standard.errors=FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_thresholds">thresholds</code></td>
<td>
<p>a vector of exceedance thresholds; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_scale.thresholds">scale.thresholds</code></td>
<td>
<p>a character value (&quot;logit&quot;, &quot;prevalence&quot;, &quot;odds&quot; or &quot;probit&quot;) indicating the scale on which exceedance thresholds are provided.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.Bayes_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;pred.PrevMap&quot; object list with the following components: <code>logit</code>; <code>prevalence</code>; <code>odds</code>; <code>probit</code>;<code>exceedance.prob</code>, corresponding to a matrix of the exceedance probabilities where each column corresponds to a specified value in <code>thresholds</code>; <code>samples</code>, corresponding to a matrix of the posterior samples at each prediction locations for the linear predictor; <code>grid.pred</code> prediction locations.
Each of the three components <code>logit</code>, <code>prevalence</code>,  <code>odds</code> and <code>probit</code> is also a list with the following components:
</p>
<p><code>predictions</code>: a vector of the predictive mean for the associated quantity (logit, odds or prevalence).
</p>
<p><code>standard.errors</code>: a vector of prediction standard errors (if <code>standard.errors=TRUE</code>).
</p>
<p><code>quantiles</code>: a matrix of quantiles of the resulting predictions with each column corresponding to a quantile specified through the argument <code>quantiles</code>.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='spatial.pred.binomial.MCML'>Spatial predictions for the binomial logistic model using plug-in of MCML estimates</h2><span id='topic+spatial.pred.binomial.MCML'></span>

<h3>Description</h3>

<p>This function performs spatial prediction, fixing the model parameters at the Monte Carlo maximum likelihood estimates of a geostatistical binomial logistic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.pred.binomial.MCML(
  object,
  grid.pred,
  predictors = NULL,
  control.mcmc,
  type = "marginal",
  scale.predictions = c("logit", "prevalence", "odds"),
  quantiles = c(0.025, 0.975),
  standard.errors = FALSE,
  thresholds = NULL,
  scale.thresholds = NULL,
  plot.correlogram = FALSE,
  messages = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial.pred.binomial.MCML_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap&quot; obtained as result of a call to <code><a href="#topic+binomial.logistic.MCML">binomial.logistic.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_grid.pred">grid.pred</code></td>
<td>
<p>a matrix of prediction locations.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_predictors">predictors</code></td>
<td>
<p>a data frame of the values of the explanatory variables at each of the locations in <code>grid.pred</code>; each column correspond to a variable and each row to a location. <b>Warning:</b> the names of the columns in the data frame must match those in the data used to fit the model. Default is <code>predictors=NULL</code> for models with only an intercept.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_type">type</code></td>
<td>
<p>a character indicating the type of spatial predictions: <code>type="marginal"</code> for marginal predictions or <code>type="joint"</code> for joint predictions. Default is <code>type="marginal"</code>. In the case of a low-rank approximation only joint predictions are available.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_scale.predictions">scale.predictions</code></td>
<td>
<p>a character vector of maximum length 3, indicating the required scale on which spatial prediction is carried out: &quot;logit&quot;, &quot;prevalence&quot; and &quot;odds&quot;. Default is <code>scale.predictions=c("logit","prevalence","odds")</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector of quantiles used to summarise the spatial predictions.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_standard.errors">standard.errors</code></td>
<td>
<p>logical; if <code>standard.errors=TRUE</code>, then standard errors for each <code>scale.predictions</code> are returned. Default is <code>standard.errors=FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_thresholds">thresholds</code></td>
<td>
<p>a vector of exceedance thresholds; default is <code>thresholds=NULL</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_scale.thresholds">scale.thresholds</code></td>
<td>
<p>a character value indicating the scale on which exceedance thresholds are provided; <code>"logit"</code>, <code>"prevalence"</code> or <code>"odds"</code>. Default is <code>scale.thresholds=NULL</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_plot.correlogram">plot.correlogram</code></td>
<td>
<p>logical; if <code>plot.correlogram=TRUE</code> the autocorrelation plot of the conditional simulations is displayed.</p>
</td></tr>
<tr><td><code id="spatial.pred.binomial.MCML_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;pred.PrevMap&quot; object list with the following components: <code>logit</code>; <code>prevalence</code>; <code>odds</code>; <code>exceedance.prob</code>, corresponding to a matrix of the exceedance probabilities where each column corresponds to a specified value in <code>thresholds</code>; <code>samples</code>, corresponding to a matrix of the predictive samples at each prediction locations for the linear predictor of the binomial logistic model (if <code>scale.predictions="logit"</code> and neither the SPDE nor the low-rank approximations have been used, this component is <code>NULL</code>); <code>grid.pred</code> prediction locations.
Each of the three components <code>logit</code>, <code>prevalence</code> and  <code>odds</code> is also a list with the following components:
</p>
<p><code>predictions</code>: a vector of the predictive mean for the associated quantity (logit, odds or prevalence).
</p>
<p><code>standard.errors</code>: a vector of prediction standard errors (if <code>standard.errors=TRUE</code>).
</p>
<p><code>quantiles</code>: a matrix of quantiles of the resulting predictions with each column corresponding to a quantile specified through the argument <code>quantiles</code>.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='spatial.pred.linear.Bayes'>Bayesian spatial predictions for the geostatistical Linear Gaussian model</h2><span id='topic+spatial.pred.linear.Bayes'></span>

<h3>Description</h3>

<p>This function performs Bayesian prediction for a geostatistical linear Gaussian model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.pred.linear.Bayes(
  object,
  grid.pred,
  predictors = NULL,
  type = "marginal",
  scale.predictions = c("logit", "prevalence", "odds"),
  quantiles = c(0.025, 0.975),
  standard.errors = FALSE,
  thresholds = NULL,
  scale.thresholds = NULL,
  messages = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial.pred.linear.Bayes_+3A_object">object</code></td>
<td>
<p>an object of class &quot;Bayes.PrevMap&quot; obtained as result of a call to <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.Bayes_+3A_grid.pred">grid.pred</code></td>
<td>
<p>a matrix of prediction locations.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.Bayes_+3A_predictors">predictors</code></td>
<td>
<p>a data frame of the values of the explanatory variables at each of the locations in <code>grid.pred</code>; each column correspond to a variable and each row to a location. <b>Warning:</b> the names of the columns in the data frame must match those in the data used to fit the model. Default is <code>predictors=NULL</code> for models with only an intercept.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.Bayes_+3A_type">type</code></td>
<td>
<p>a character indicating the type of spatial predictions: <code>type="marginal"</code> for marginal predictions or <code>type="joint"</code> for joint predictions. Default is <code>type="marginal"</code>. In the case of a low-rank approximation only joint predictions are available.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.Bayes_+3A_scale.predictions">scale.predictions</code></td>
<td>
<p>a character vector of maximum length 3, indicating the required scale on which spatial prediction is carried out: &quot;logit&quot;, &quot;prevalence&quot; and &quot;odds&quot;. Default is <code>scale.predictions=c("logit","prevalence","odds")</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.Bayes_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector of quantiles used to summarise the spatial predictions.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.Bayes_+3A_standard.errors">standard.errors</code></td>
<td>
<p>logical; if <code>standard.errors=TRUE</code>, then standard errors for each <code>scale.predictions</code> are returned. Default is <code>standard.errors=FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.Bayes_+3A_thresholds">thresholds</code></td>
<td>
<p>a vector of exceedance thresholds; default is <code>thresholds=NULL</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.Bayes_+3A_scale.thresholds">scale.thresholds</code></td>
<td>
<p>a character value indicating the scale on which exceedance thresholds are provided: <code>"logit"</code>, <code>"prevalence"</code> or <code>"odds"</code>. Default is <code>scale.thresholds=NULL</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.Bayes_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;pred.PrevMap&quot; object list with the following components: <code>logit</code>; <code>prevalence</code>; <code>odds</code>; <code>exceedance.prob</code>, corresponding to a matrix of the exceedance probabilities where each column corresponds to a specified value in <code>thresholds</code>; <code>grid.pred</code> prediction locations.
Each of the three components <code>logit</code>, <code>prevalence</code> and  <code>odds</code> is also a list with the following components:
</p>
<p><code>predictions</code>: a vector of the predictive mean for the associated quantity (logit, odds or prevalence).
</p>
<p><code>standard.errors</code>: a vector of prediction standard errors (if <code>standard.errors=TRUE</code>).
</p>
<p><code>quantiles</code>: a matrix of quantiles of the resulting predictions with each column corresponding to a quantile specified through the argument <code>quantiles</code>.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='spatial.pred.linear.MLE'>Spatial predictions for the geostatistical Linear Gaussian model using plug-in of ML estimates</h2><span id='topic+spatial.pred.linear.MLE'></span>

<h3>Description</h3>

<p>This function performs spatial prediction, fixing the model parameters at the maximum likelihood estimates of a linear geostatistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.pred.linear.MLE(
  object,
  grid.pred,
  predictors = NULL,
  predictors.samples = NULL,
  type = "marginal",
  scale.predictions = c("logit", "prevalence", "odds"),
  quantiles = c(0.025, 0.975),
  n.sim.prev = 0,
  standard.errors = FALSE,
  thresholds = NULL,
  scale.thresholds = NULL,
  messages = TRUE,
  include.nugget = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial.pred.linear.MLE_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap&quot; obtained as result of a call to <code><a href="#topic+linear.model.MLE">linear.model.MLE</a></code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_grid.pred">grid.pred</code></td>
<td>
<p>a matrix of prediction locations.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_predictors">predictors</code></td>
<td>
<p>a data frame of the values of the explanatory variables at each of the locations in <code>grid.pred</code>; each column correspond to a variable and each row to a location. <b>Warning:</b> the names of the columns in the data frame must match those in the data used to fit the model. Default is <code>predictors=NULL</code> for models with only an intercept.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_predictors.samples">predictors.samples</code></td>
<td>
<p>a list of data frame objects. This argument is used to average over repeated simulations of the predictor variables in order to obtain an &quot;average&quot; map over the distribution of the explanatory variables in the model.
Each component of the list is a simulation. The number of simulations passed through <code>predictors.samples</code> must be the same as <code>n.sim.prev</code>. NOTE: This argument can currently only be used only for a linear regression model that does not use any approximation of the spatial Gaussian process.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_type">type</code></td>
<td>
<p>a character indicating the type of spatial predictions: <code>type="marginal"</code> for marginal predictions or <code>type="joint"</code> for joint predictions. Default is <code>type="marginal"</code>. In the case of a low-rank approximation only marginal predictions are available.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_scale.predictions">scale.predictions</code></td>
<td>
<p>a character vector of maximum length 3, indicating the required scale on which spatial prediction is carried out: &quot;logit&quot;, &quot;prevalence&quot; and &quot;odds&quot;. Default is <code>scale.predictions=c("logit","prevalence","odds")</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector of quantiles used to summarise the spatial predictions.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_n.sim.prev">n.sim.prev</code></td>
<td>
<p>number of simulation for non-linear predictive targets. Default is <code>n.sim.prev=0</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_standard.errors">standard.errors</code></td>
<td>
<p>logical; if <code>standard.errors=TRUE</code>, then standard errors for each <code>scale.predictions</code> are returned. Default is <code>standard.errors=FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_thresholds">thresholds</code></td>
<td>
<p>a vector of exceedance thresholds; default is <code>thresholds=NULL</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_scale.thresholds">scale.thresholds</code></td>
<td>
<p>a character value indicating the scale on which exceedance thresholds are provided; <code>"logit"</code>, <code>"prevalence"</code> or <code>"odds"</code>. Default is <code>scale.thresholds=NULL</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.linear.MLE_+3A_include.nugget">include.nugget</code></td>
<td>
<p>logical; if <code>include.nugget=TRUE</code> then the nugget effect is included in the predictions. This option is available only for fitted linear models with locations having multiple observations. Default is <code>include.nugget=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;pred.PrevMap&quot; object list with the following components: <code>logit</code>; <code>prevalence</code>; <code>odds</code>; <code>exceedance.prob</code>, corresponding to a matrix of the exceedance probabilities where each column corresponds to a specified value in <code>thresholds</code>; <code>grid.pred</code> prediction locations; <code>samples</code>, corresponding to the predictive samples of the linear predictor (only if <code>any(scale.predictions=="prevalence")</code>).
Each of the three components <code>logit</code>, <code>prevalence</code> and  <code>odds</code> is also a list with the following components:
</p>
<p><code>predictions</code>: a vector of the predictive mean for the associated quantity (logit, odds or prevalence).
</p>
<p><code>standard.errors</code>: a vector of prediction standard errors (if <code>standard.errors=TRUE</code>).
</p>
<p><code>quantiles</code>: a matrix of quantiles of the resulting predictions with each column corresponding to a quantile specified through the argument <code>quantiles</code>.
</p>
<p><code>samples</code>: If <code>n.sim.prev &gt; 0</code>, the function returns <code>n.sim.prev</code> samples of the linear predictor at each of the prediction locations.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='spatial.pred.lm.ps'>Spatial predictions for the geostatistical Linear Gaussian model using plug-in of ML estimates</h2><span id='topic+spatial.pred.lm.ps'></span>

<h3>Description</h3>

<p>This function performs spatial prediction, fixing the model parameters at the maximum likelihood estimates of a linear geostatistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.pred.lm.ps(
  object,
  grid.pred = NULL,
  predictors = NULL,
  predictors.intensity = NULL,
  control.mcmc = NULL,
  target = 3,
  type = "marginal",
  quantiles = NULL,
  standard.errors = FALSE,
  messages = TRUE,
  return.samples = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial.pred.lm.ps_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap&quot; obtained as result of a call to <code><a href="#topic+linear.model.MLE">linear.model.MLE</a></code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_grid.pred">grid.pred</code></td>
<td>
<p>a matrix of prediction locations. Default is <code>grid.pred=NULL</code>, in which case the grid used to approximate the intractable integral in the log-Gaussian Cox process model is used for prediction.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_predictors">predictors</code></td>
<td>
<p>a data frame of the values of the explanatory variables at each of the locations in <code>grid.pred</code>, for the response variable model; each column correspond to a variable and each row to a location. <b>Warning:</b> the names of the columns in the data frame must match those in the data used to fit the model. Default is <code>predictors=NULL</code> for models with only an intercept.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_predictors.intensity">predictors.intensity</code></td>
<td>
<p>a data frame of the values of the explanatory variables at each of the locations in <code>grid.pred</code>, for the log-Gaussian Cox process model; each column correspond to a variable and each row to a location. <b>Warning:</b> the names of the columns in the data frame must match those in the data used to fit the model. Default is <code>predictors=NULL</code> for models with only an intercept.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code> which defined the control parameters of the Monte Carlo Markv chain algorithm.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_target">target</code></td>
<td>
<p>an integeter indicating the predictive target: <code>target=1</code> if the predictive target is the linear predictor of the response; <code>target=2</code> is the predictive target is the sampling intensity of the preferentially sampled data; <code>target=3</code> if both of the above are the predictive targets. Default is <code>target=3</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_type">type</code></td>
<td>
<p>a character indicating the type of spatial predictions for <code>target=1</code>: <code>type="marginal"</code> for marginal predictions or <code>type="joint"</code> for joint predictions. Default is <code>type="marginal"</code>. Note that predictions for the sampling intensity (<code>target=2</code>) are always joint.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector of quantiles used to summarise the spatial predictions.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_standard.errors">standard.errors</code></td>
<td>
<p>logical; if <code>standard.errors=TRUE</code>, then standard errors for each <code>scale.predictions</code> are returned. Default is <code>standard.errors=FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.lm.ps_+3A_return.samples">return.samples</code></td>
<td>
<p>logical; if <code>return.samples=TRUE</code> a matrix of the predictive samples for the prediction target (as specified in <code>target</code>) are returned in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;pred.PrevMap.ps&quot; object list with the following components: <code>response</code> (if <code>target=1</code> or <code>target=3</code>) and <code>intensity</code> (if <code>target=2</code> pr <code>target=3</code>).
<code>grid.pred</code> prediction locations.
Each of the components <code>intensity</code> and <code>response</code> is a list with the following components:
</p>
<p><code>predictions</code>: a vector of the predictive mean for the corresponding target.
</p>
<p><code>standard.errors</code>: a vector of prediction standard errors (if <code>standard.errors=TRUE</code>).
</p>
<p><code>quantiles</code>: a matrix of quantiles of the resulting predictions with each column corresponding to a quantile specified through the argument <code>quantiles</code>.
</p>
<p><code>samples</code>: a matrix corresponding to the predictive samples of the predictive target (only if <code>return.samples=TRUE</code>), with each row corresponding to a samples and column to a prediction location.
In the case of a model with a mix of preferential and non-preferential data, if <code>target=1</code> or <code>target=3</code>, each of the above components will be a list with two components,
namely <code>preferential</code> and <code>non.preferential</code>, associated with <code>response</code>.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='spatial.pred.poisson.MCML'>Spatial predictions for the Poisson model with log link function, using plug-in of MCML estimates</h2><span id='topic+spatial.pred.poisson.MCML'></span>

<h3>Description</h3>

<p>This function performs spatial prediction, fixing the model parameters at the Monte Carlo maximum likelihood estimates of a geostatistical Poisson model with log link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.pred.poisson.MCML(
  object,
  grid.pred,
  predictors = NULL,
  control.mcmc,
  type = "marginal",
  scale.predictions = c("log", "exponential"),
  quantiles = c(0.025, 0.975),
  standard.errors = FALSE,
  thresholds = NULL,
  scale.thresholds = NULL,
  plot.correlogram = FALSE,
  messages = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial.pred.poisson.MCML_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap&quot; obtained as result of a call to <code><a href="#topic+poisson.log.MCML">poisson.log.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_grid.pred">grid.pred</code></td>
<td>
<p>a matrix of prediction locations.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_predictors">predictors</code></td>
<td>
<p>a data frame of the values of the explanatory variables at each of the locations in <code>grid.pred</code>; each column correspond to a variable and each row to a location. <b>Warning:</b> the names of the columns in the data frame must match those in the data used to fit the model. Default is <code>predictors=NULL</code> for models with only an intercept.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_control.mcmc">control.mcmc</code></td>
<td>
<p>output from <code><a href="#topic+control.mcmc.MCML">control.mcmc.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_type">type</code></td>
<td>
<p>a character indicating the type of spatial predictions: <code>type="marginal"</code> for marginal predictions or <code>type="joint"</code> for joint predictions. Default is <code>type="marginal"</code>. In the case of a low-rank approximation only joint predictions are available.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_scale.predictions">scale.predictions</code></td>
<td>
<p>a character vector of maximum length 2, indicating the required scale on which spatial prediction is carried out: &quot;log&quot; and &quot;exponential&quot;. Default is <code>scale.predictions=c("log","exponential")</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_quantiles">quantiles</code></td>
<td>
<p>a vector of quantiles used to summarise the spatial predictions.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_standard.errors">standard.errors</code></td>
<td>
<p>logical; if <code>standard.errors=TRUE</code>, then standard errors for each <code>scale.predictions</code> are returned. Default is <code>standard.errors=FALSE</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_thresholds">thresholds</code></td>
<td>
<p>a vector of exceedance thresholds; default is <code>thresholds=NULL</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_scale.thresholds">scale.thresholds</code></td>
<td>
<p>a character value indicating the scale on which exceedance thresholds are provided; <code>"log"</code> or <code>"exponential"</code>. Default is <code>scale.thresholds=NULL</code>.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_plot.correlogram">plot.correlogram</code></td>
<td>
<p>logical; if <code>plot.correlogram=TRUE</code> the autocorrelation plot of the conditional simulations is displayed.</p>
</td></tr>
<tr><td><code id="spatial.pred.poisson.MCML_+3A_messages">messages</code></td>
<td>
<p>logical; if <code>messages=TRUE</code> then status messages are printed on the screen (or output device) while the function is running. Default is <code>messages=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A &quot;pred.PrevMap&quot; object list with the following components: <code>log</code>; <code>exponential</code>; <code>exceedance.prob</code>, corresponding to a matrix of the exceedance probabilities where each column corresponds to a specified value in <code>thresholds</code>; <code>samples</code>, corresponding to a matrix of the predictive samples at each prediction locations for the linear predictor of the Poisson model (if <code>scale.predictions="log"</code> this component is <code>NULL</code>); <code>grid.pred</code> prediction locations.
Each of the three components <code>log</code> and  <code>exponential</code> is also a list with the following components:
</p>
<p><code>predictions</code>: a vector of the predictive mean for the associated quantity (log or exponential).
</p>
<p><code>standard.errors</code>: a vector of prediction standard errors (if <code>standard.errors=TRUE</code>).
</p>
<p><code>quantiles</code>: a matrix of quantiles of the resulting predictions with each column corresponding to a quantile specified through the argument <code>quantiles</code>.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='summary.Bayes.PrevMap'>Summarizing Bayesian model fits</h2><span id='topic+summary.Bayes.PrevMap'></span>

<h3>Description</h3>

<p><code>summary</code> method for the class &quot;Bayes.PrevMap&quot; that computes the posterior mean, median, mode and high posterior density intervals using samples from Bayesian fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Bayes.PrevMap'
summary(object, hpd.coverage = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Bayes.PrevMap_+3A_object">object</code></td>
<td>
<p>an object of class &quot;Bayes.PrevMap&quot; obatained as result of a call to <code><a href="#topic+binomial.logistic.Bayes">binomial.logistic.Bayes</a></code> or <code><a href="#topic+linear.model.Bayes">linear.model.Bayes</a></code>.</p>
</td></tr>
<tr><td><code id="summary.Bayes.PrevMap_+3A_hpd.coverage">hpd.coverage</code></td>
<td>
<p>value of the coverage of the high posterior density intervals; default is <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="summary.Bayes.PrevMap_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following values
</p>
<p><code>linear</code>: logical value that is <code>TRUE</code> if a linear model was fitted and <code>FALSE</code> otherwise.
</p>
<p><code>binary</code>: logical value that is <code>TRUE</code> if a binary model was fitted and <code>FALSE</code> otherwise.
</p>
<p><code>probit</code>: logical value that is <code>TRUE</code> if a binary model with probit link function was fitted and <code>FALSE</code> if with logistic link function.
</p>
<p><code>ck</code>: logical value that is <code>TRUE</code> if a low-rank approximation was fitted and <code>FALSE</code> otherwise.
</p>
<p><code>beta</code>: matrix of the posterior summaries for the regression coefficients.
</p>
<p><code>sigma2</code>: vector of the posterior summaries for <code>sigma2</code>.
</p>
<p><code>phi</code>: vector of the posterior summaries for <code>phi</code>.
</p>
<p><code>tau2</code>: vector of the posterior summaries for <code>tau2</code>.
</p>
<p><code>call</code>: matched call.
</p>
<p><code>kappa</code>: fixed value of the shape paramter of the Matern covariance function.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='summary.PrevMap'>Summarizing likelihood-based model fits</h2><span id='topic+summary.PrevMap'></span>

<h3>Description</h3>

<p><code>summary</code> method for the class &quot;PrevMap&quot; that computes the standard errors and p-values of likelihood-based model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PrevMap'
summary(object, log.cov.pars = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PrevMap_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap&quot; obatained as result of a call to <code><a href="#topic+binomial.logistic.MCML">binomial.logistic.MCML</a></code> or <code><a href="#topic+linear.model.MLE">linear.model.MLE</a></code>.</p>
</td></tr>
<tr><td><code id="summary.PrevMap_+3A_log.cov.pars">log.cov.pars</code></td>
<td>
<p>logical; if <code>log.cov.pars=TRUE</code> the estimates of the covariance parameters are given on the log-scale. Note that standard errors are also adjusted accordingly. Default is <code>log.cov.pars=TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.PrevMap_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<p><code>linear</code>: logical value; <code>linear=TRUE</code> if a linear model was fitted and <code>linear=FALSE</code> otherwise.
</p>
<p><code>poisson</code>: logical value; <code>poisson=TRUE</code> if a Poisson model was fitted and <code>poisson=FALSE</code> otherwise.
</p>
<p><code>ck</code>: logical value; <code>ck=TRUE</code> if a low-rank approximation was used and <code>ck=FALSE</code> otherwise.
</p>
<p><code>spde</code>: logical value; <code>spde=TRUE</code> if the SPDE approximation was used and <code>spde=FALSE</code> otherwise.
</p>
<p><code>coefficients</code>: matrix of the estimates, standard errors and p-values of the estimates of the regression coefficients.
</p>
<p><code>cov.pars</code>: matrix of the estimates and standard errors of the covariance parameters.
</p>
<p><code>log.lik</code>: value of likelihood function at the maximum likelihood estimates.
</p>
<p><code>kappa</code>: fixed value of the shape paramter of the Matern covariance function.
</p>
<p><code>kappa.t</code>: fixed value of the shape paramter of the Matern covariance function for the temporal covariance matrix, if a spatio-temporal model has been fitted.
</p>
<p><code>fixed.rel.nugget</code>: fixed value for the relative variance of the nugget effect.
</p>
<p><code>call</code>: matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='summary.PrevMap.ps'>Summarizing fits of geostatistical linear models with preferentially sampled locations</h2><span id='topic+summary.PrevMap.ps'></span>

<h3>Description</h3>

<p><code>summary</code> method for the class &quot;PrevMap&quot; that computes the standard errors and p-values of likelihood-based model fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PrevMap.ps'
summary(object, log.cov.pars = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.PrevMap.ps_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap.ps&quot; obatained as result of a call to <code><a href="#topic+lm.ps.MCML">lm.ps.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="summary.PrevMap.ps_+3A_log.cov.pars">log.cov.pars</code></td>
<td>
<p>logical; if <code>log.cov.pars=TRUE</code> the estimates of the covariance parameters are given on the log-scale. Note that standard errors are also adjusted accordingly. Default is <code>log.cov.pars=TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.PrevMap.ps_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<p><code>coefficients.response</code>: matrix of the estimates, standard errors and p-values of the estimates of the regression coefficients for the response variable.
</p>
<p><code>coefficients.intensity</code>: matrix of the estimates, standard errors and p-values of the estimates of the regression coefficients for the sampling intenisty of the log-Gaussian process.
</p>
<p><code>cov.pars.response</code>: matrix of the estimates and standard errors of the covariance parameters for the Gaussian process associated with the response.
</p>
<p><code>cov.pars.intenisty</code>: matrix of the estimates and standard errors of the covariance parameters for the Gaussian process associated with the log-Gaussian process.
</p>
<p><code>log.lik</code>: value of likelihood function at the maximum likelihood estimates.
</p>
<p><code>kappa.response</code>: fixed value of the shape paramter of the Matern covariance function.
</p>
<p><code>call</code>: matched call.
</p>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='trace.plot'>Trace-plots for posterior samples</h2><span id='topic+trace.plot'></span>

<h3>Description</h3>

<p>Displays the trace-plots for the posterior samples of the model parameters and spatial random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace.plot(object, param, component.beta = NULL, component.S = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace.plot_+3A_object">object</code></td>
<td>
<p>an object of class 'Bayes.PrevMap'.</p>
</td></tr>
<tr><td><code id="trace.plot_+3A_param">param</code></td>
<td>
<p>a character indicating for which component of the model the density plot is required: <code>param="beta"</code> for the regression coefficients; <code>param="sigma2"</code> for the variance of the spatial random effect; <code>param="phi"</code> for the scale parameter of the Matern correlation function; <code>param="tau2"</code> for the variance of the nugget effect; <code>param="S"</code> for the spatial random effect.</p>
</td></tr>
<tr><td><code id="trace.plot_+3A_component.beta">component.beta</code></td>
<td>
<p>if <code>param="beta"</code>, <code>component.beta</code> is a numeric value indicating the component of the regression coefficients; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="trace.plot_+3A_component.s">component.S</code></td>
<td>
<p>if <code>param="S"</code>, <code>component.S</code> can be a numeric value indicating the component of the spatial random effect. Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='trace.plot.MCML'>Trace-plots of the importance sampling distribution samples from the MCML method</h2><span id='topic+trace.plot.MCML'></span>

<h3>Description</h3>

<p>Trace-plots of the MCMC samples from the importance sampling distribution used in <code><a href="#topic+binomial.logistic.MCML">binomial.logistic.MCML</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace.plot.MCML(object, component = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace.plot.MCML_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap&quot; obatained as result of a call to <code><a href="#topic+binomial.logistic.MCML">binomial.logistic.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="trace.plot.MCML_+3A_component">component</code></td>
<td>
<p>a positive integer indicating the number of the random effect component for which a trace-plot is required. If <code>component=NULL</code>, then a component is selected at random. Default is <code>component=NULL</code>.</p>
</td></tr>
<tr><td><code id="trace.plot.MCML_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emanuele Giorgi <a href="mailto:e.giorgi@lancaster.ac.uk">e.giorgi@lancaster.ac.uk</a>
</p>
<p>Peter J. Diggle <a href="mailto:p.diggle@lancaster.ac.uk">p.diggle@lancaster.ac.uk</a>
</p>

<hr>
<h2 id='trend.plot'>Plot of trends</h2><span id='topic+trend.plot'></span>

<h3>Description</h3>

<p>This function produces a plot of the variable of interest against each of the two geographical coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trend.plot(data, var.name, coords, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trend.plot_+3A_data">data</code></td>
<td>
<p>an object of class &quot;data.frame&quot; containing the data.</p>
</td></tr>
<tr><td><code id="trend.plot_+3A_var.name">var.name</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> object indicating the variable to display.</p>
</td></tr>
<tr><td><code id="trend.plot_+3A_coords">coords</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> object indicating the geographical coordinates.</p>
</td></tr>
<tr><td><code id="trend.plot_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='variog.diagnostic.glgm'>Variogram-based validation for generalized linear geostatistical model fits (Binomial and Poisson)</h2><span id='topic+variog.diagnostic.glgm'></span>

<h3>Description</h3>

<p>This function performs model validation for generalized linear geostatistical models (Binomial and Poisson)
using Monte Carlo methods based on the variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variog.diagnostic.glgm(
  object,
  n.sim = 200,
  uvec = NULL,
  plot.results = TRUE,
  which.test = "both"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variog.diagnostic.glgm_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap&quot; obtained as an output from <code><a href="#topic+binomial.logistic.MCML">binomial.logistic.MCML</a></code> and <code><a href="#topic+poisson.log.MCML">poisson.log.MCML</a></code>.</p>
</td></tr>
<tr><td><code id="variog.diagnostic.glgm_+3A_n.sim">n.sim</code></td>
<td>
<p>integer indicating the number of simulations used for the variogram-based diagnostics.
Defeault is <code>n.sim=1000</code>.</p>
</td></tr>
<tr><td><code id="variog.diagnostic.glgm_+3A_uvec">uvec</code></td>
<td>
<p>a vector with values used to define the variogram binning. If <code>uvec=NULL</code>, then <code>uvec</code> is then set to <code>seq(MIN_DIST,(MAX_DIST-MIN_DIST)/2,length=15)</code></p>
</td></tr>
<tr><td><code id="variog.diagnostic.glgm_+3A_plot.results">plot.results</code></td>
<td>
<p>if <code>plot.results=TRUE</code>, a plot is returned showing the results for the selected test(s) for spatial correlation. By default <code>plot.results=TRUE</code>.
defined as the distance at which the fitted spatial correlation is no less than 0.05. Default is <code>range.fact=1</code></p>
</td></tr>
<tr><td><code id="variog.diagnostic.glgm_+3A_which.test">which.test</code></td>
<td>
<p>a character specifying which test for residual spatial correlation is to be performed: &quot;variogram&quot;, &quot;test statistic&quot; or &quot;both&quot;. The default is <code>which.test="both"</code>. See 'Details.'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes as an input through the argument <code>object</code> a fitted
generalized linear geostaistical model for an outcome <code class="reqn">Y_i</code>, with linear predictor
</p>
<p style="text-align: center;"><code class="reqn">\eta_i=d_i'\beta+S(x_i)+Z_i</code>
</p>

<p>where <code class="reqn">d_i</code> is a vector of covariates which are specified through <code>formula</code>, <code class="reqn">S(x_i)</code> is a spatial Gaussian process and the <code class="reqn">Z_i</code> are assumed to be zero-mean Gaussian.
The model validation is performed on the adopted satationary and isotropic Matern covariance function used for <code class="reqn">S(x_i)</code>.
More specifically, the function allows the users to select either of the following validation procedures.
</p>
<p><b>Variogram-based graphical validation</b>
</p>
<p>This graphical diagnostic is performed by setting <code>which.test="both"</code> or <code>which.test="variogram"</code>. The output are 95
(see below <code>lower.lim</code> and <code>upper.lim</code>) that are generated under the assumption that the fitted model did generate the analysed data-set.
This validation procedure proceed through the following steps.
</p>
<p>1. Obtain the mean, say <code class="reqn">\hat{Z}_i</code>, of the <code class="reqn">Z_i</code> conditioned on the data <code class="reqn">Y_i</code> and by setting <code class="reqn">S(x_i)=0</code> in the equation above.
</p>
<p>2. Compute the empirical variogram using <code class="reqn">\hat{Z}_i</code>
</p>
<p>3. Simulate <code>n.sim</code> data-sets under the fitted geostatistical model.
</p>
<p>4. For each of the simulated data-sets and obtain <code class="reqn">\hat{Z}_i</code> as in Step 1.
Finally, compute the empirical variogram based on the resulting <code class="reqn">\hat{Z}_i</code>.
</p>
<p>5. From the <code>n.sim</code> variograms obtained in the previous step, compute the 95
</p>
<p>If the observed variogram (<code>obs.variogram</code> below), based on the <code class="reqn">\hat{Z}_i</code> from Step 2, falls within the 95
evidence against the fitted spatial correlation model; if, instead, that partly falls outside the 95
correlation in the data.
</p>
<p><b>Test for suitability of the adopted correlation function</b>
</p>
<p>This diagnostic test is performed if <code>which.test="both"</code> or <code>which.test="test statistic"</code>. Let <code class="reqn">v_{E}(B)</code> and <code class="reqn">v_{T}(B)</code> denote the empirical and theoretical variograms based on <code class="reqn">\hat{Z}_i</code> for the distance bin <code class="reqn">B</code>.
The test statistic used for testing residual spatial correlation is
</p>
<p style="text-align: center;"><code class="reqn">T = \sum_{B} N(B) \{v_{E}(B)-v_{T}(B)\}</code>
</p>

<p>where <code class="reqn">N(B)</code> is the number of pairs of data-points falling within the distance bin <code class="reqn">B</code> (<code>n.bins</code> below).
</p>
<p>To obtain the distribution of the test statistic <code class="reqn">T</code> under the null hypothesis that the fitted model did generate the analysed data-set, we use the simulated empirical variograms as obtained in step 5 of the iterative procedure described in &quot;Variogram-based graphical validation.&quot;
The p-value for the test of suitability of the fitted spatial correlation function is then computed by taking the proportion of simulated values for <code class="reqn">T</code> that are larger than the value of <code class="reqn">T</code> based on the original <code class="reqn">\hat{Z}_i</code> in Step 1.
</p>


<h3>Value</h3>

<p>An object of class &quot;PrevMap.diagnostic&quot; which is a list containing the following components:
</p>
<p><code>obs.variogram</code>: a vector of length <code>length(uvec)-1</code> containing the values of the variogram for each of
the distance bins defined through <code>uvec</code>.
</p>
<p><code>distance.bins</code>: a vector of length <code>length(uvec)-1</code> containing the average distance within each of the distance bins
defined through <code>uvec</code>.
</p>
<p><code>n.bins</code>: a vector of length <code>length(uvec)-1</code> containing the number of pairs of data-points falling within each distance bin.
</p>
<p><code>lower.lim</code>: (available only if <code>which.test="both"</code> or <code>which.test="variogram"</code>) a vector of length <code>length(uvec)-1</code> containing the lower limits of the 95
generated under the assumption of absence of suitability of the fitted model  at each fo the distance bins  defined through <code>uvec</code>.
</p>
<p><code>upper.lim</code>: (available only if <code>which.test="both"</code> or <code>which.test="variogram"</code>) a vector of length <code>length(uvec)-1</code> containing the upper limits of the 95
generated under the assumption of absence of suitability of the fitted model at each fo the distance bins  defined through <code>uvec</code>.
</p>
<p><code>mode.rand.effects</code>: the predictive mode of the random effects from the fitted non-spatial generalized linear mixed model.
</p>
<p><code>p.value</code>: (available only if <code>which.test="both"</code> or <code>which.test="test statistic"</code>) p-value of the test for residual spatial correlation.
</p>
<p><code>lse.variogram</code>: (available only if <code>lse.variogram=TRUE</code>) a vector of length <code>length(uvec)-1</code> containing the values of the estimated Matern variogram via a weighted least square fit.
</p>

<hr>
<h2 id='variog.diagnostic.lm'>Variogram-based validation for linear geostatistical model fits</h2><span id='topic+variog.diagnostic.lm'></span>

<h3>Description</h3>

<p>This function performs model validation for linear geostatistical model
using Monte Carlo methods based on the variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variog.diagnostic.lm(
  object,
  n.sim = 1000,
  uvec = NULL,
  plot.results = TRUE,
  range.fact = 1,
  which.test = "both",
  param.uncertainty = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variog.diagnostic.lm_+3A_object">object</code></td>
<td>
<p>an object of class &quot;PrevMap&quot; obtained as an output from <code><a href="#topic+linear.model.MLE">linear.model.MLE</a></code>.</p>
</td></tr>
<tr><td><code id="variog.diagnostic.lm_+3A_n.sim">n.sim</code></td>
<td>
<p>integer indicating the number of simulations used for the variogram-based diagnostics.
Defeault is <code>n.sim=1000</code>.</p>
</td></tr>
<tr><td><code id="variog.diagnostic.lm_+3A_uvec">uvec</code></td>
<td>
<p>a vector with values used to define the variogram binning. If <code>uvec=NULL</code>, then <code>uvec</code> is then set to <code>seq(MIN_DIST,(MAX_DIST-MIN_DIST)/2,length=15)</code></p>
</td></tr>
<tr><td><code id="variog.diagnostic.lm_+3A_plot.results">plot.results</code></td>
<td>
<p>if <code>plot.results=TRUE</code>, a plot is returned showing the results for the selected test(s) for spatial correlation. By default <code>plot.results=TRUE</code>.</p>
</td></tr>
<tr><td><code id="variog.diagnostic.lm_+3A_range.fact">range.fact</code></td>
<td>
<p>a value between 0 and 1 used to disregard all distance bins provided through <code>uvec</code> that are larger than the (pr)x<code>range.fact</code>, where pr is the practical range,
defined as the distance at which the fitted spatial correlation is no less than 0.05. Default is <code>range.fact=1</code></p>
</td></tr>
<tr><td><code id="variog.diagnostic.lm_+3A_which.test">which.test</code></td>
<td>
<p>a character specifying which test for residual spatial correlation is to be performed: &quot;variogram&quot;, &quot;test statistic&quot; or &quot;both&quot;. The default is <code>which.test="both"</code>. See 'Details.'</p>
</td></tr>
<tr><td><code id="variog.diagnostic.lm_+3A_param.uncertainty">param.uncertainty</code></td>
<td>
<p>a logical indicating whether uncertainty in the model parameters should be incorporated in the selected diagnostic tests. Default is <code>param.uncertainty=FALSE</code>. See 'Details.'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes as an input through the argument <code>object</code> a fitted
linear geostaistical model for an outcome <code class="reqn">Y_i</code>, which is expressed as
</p>
<p style="text-align: center;"><code class="reqn">Y_i=d_i'\beta+S(x_i)+Z_i</code>
</p>

<p>where <code class="reqn">d_i</code> is a vector of covariates which are specified through <code>formula</code>, <code class="reqn">S(x_i)</code> is a spatial Gaussian process and the <code class="reqn">Z_i</code> are assumed to be zero-mean Gaussian.
The model validation is performed on the adopted satationary and isotropic Matern covariance function used for <code class="reqn">S(x_i)</code>.
More specifically, the function allows the users to select either of the following validation procedures.
</p>
<p><b>Variogram-based graphical validation</b>
</p>
<p>This graphical diagnostic is performed by setting <code>which.test="both"</code> or <code>which.test="variogram"</code>. The output are 95
(see below <code>lower.lim</code> and <code>upper.lim</code>) that are generated under the assumption that the fitted model did generate the analysed data-set.
This validation procedure proceed through the following steps.
</p>
<p>1. Obtain the mean, say <code class="reqn">\hat{Z}_i</code>, of the <code class="reqn">Z_i</code> conditioned on the data <code class="reqn">Y_i</code>.
</p>
<p>2. Compute the empirical variogram using <code class="reqn">\hat{Z}_i</code>
</p>
<p>3. Simulate <code>n.sim</code> data-sets under the fitted geostatistical model.
</p>
<p>4. For each of the simulated data-sets and obtain <code class="reqn">\hat{Z}_i</code> as in Step 1.
Finally, compute the empirical variogram based on the resulting <code class="reqn">\hat{Z}_i</code>.
</p>
<p>5. From the <code>n.sim</code> variograms obtained in the previous step, compute the 95
</p>
<p>If the observed variogram (<code>obs.variogram</code> below), based on the <code class="reqn">\hat{Z}_i</code> from Step 2, falls within the 95
evidence against the fitted spatial correlation model; if, instead, that partly falls outside the 95
correlation in the data.
</p>
<p><b>Test for suitability of the adopted correlation function</b>
</p>
<p>This diagnostic test is performed if <code>which.test="both"</code> or <code>which.test="test statistic"</code>. Let <code class="reqn">v_{E}(B)</code> and <code class="reqn">v_{T}(B)</code> denote the empirical and theoretical variograms based on <code class="reqn">\hat{Z}_i</code> for the distance bin <code class="reqn">B</code>.
The test statistic used for testing residual spatial correlation is
</p>
<p style="text-align: center;"><code class="reqn">T = \sum_{B} N(B) \{v_{E}(B)-v_{T}(B)\}</code>
</p>

<p>where <code class="reqn">N(B)</code> is the number of pairs of data-points falling within the distance bin <code class="reqn">B</code> (<code>n.bins</code> below).
</p>
<p>To obtain the distribution of the test statistic <code class="reqn">T</code> under the null hypothesis that the fitted model did generate the analysed data-set, we use the simulated empirical variograms as obtained in step 5 of the iterative procedure described in &quot;Variogram-based graphical validation.&quot;
The p-value for the test of suitability of the fitted spatial correlation function is then computed by taking the proportion of simulated values for <code class="reqn">T</code> that are larger than the value of <code class="reqn">T</code> based on the original <code class="reqn">\hat{Z}_i</code> in Step 1.
</p>


<h3>Value</h3>

<p>An object of class &quot;PrevMap.diagnostic&quot; which is a list containing the following components:
</p>
<p><code>obs.variogram</code>: a vector of length <code>length(uvec)-1</code> containing the values of the variogram for each of
the distance bins defined through <code>uvec</code>.
</p>
<p><code>distance.bins</code>: a vector of length <code>length(uvec)-1</code> containing the average distance within each of the distance bins
defined through <code>uvec</code>.
</p>
<p><code>n.bins</code>: a vector of length <code>length(uvec)-1</code> containing the number of pairs of data-points falling within each distance bin.
</p>
<p><code>lower.lim</code>: (available only if <code>which.test="both"</code> or <code>which.test="variogram"</code>) a vector of length <code>length(uvec)-1</code> containing the lower limits of the 95
generated under the assumption of absence of suitability of the fitted model  at each fo the distance bins  defined through <code>uvec</code>.
</p>
<p><code>upper.lim</code>: (available only if <code>which.test="both"</code> or <code>which.test="variogram"</code>) a vector of length <code>length(uvec)-1</code> containing the upper limits of the 95
generated under the assumption of absence of suitability of the fitted model at each fo the distance bins  defined through <code>uvec</code>.
</p>
<p><code>mode.rand.effects</code>: the predictive mode of the random effects from the fitted non-spatial generalized linear mixed model.
</p>
<p><code>p.value</code>: (available only if <code>which.test="both"</code> or <code>which.test="test statistic"</code>) p-value of the test for residual spatial correlation.
</p>
<p><code>lse.variogram</code>: (available only if <code>lse.variogram=TRUE</code>) a vector of length <code>length(uvec)-1</code> containing the values of the estimated Matern variogram via a weighted least square fit.
</p>

<hr>
<h2 id='variogram'>The empirical variogram</h2><span id='topic+variogram'></span>

<h3>Description</h3>

<p>This function computes sample (empirical) variograms with options for the classical or robust estimators. Output can be returned as a binned variogram, a variogram cloud or a smoothed variogram. Data transformation (Box-Cox) is allowed. Trends can be specified and are fitted by ordinary least squares in which case the variograms are computed using the residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogram(data, var.name, coords, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="variogram_+3A_data">data</code></td>
<td>
<p>an object of class &quot;data.frame&quot; containing the data.</p>
</td></tr>
<tr><td><code id="variogram_+3A_var.name">var.name</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> object indicating the variable to display.</p>
</td></tr>
<tr><td><code id="variogram_+3A_coords">coords</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> object indicating the geographical coordinates.</p>
</td></tr>
<tr><td><code id="variogram_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>variog</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class &quot;variogram&quot; which is list containing components as detailed in <code>variog</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
