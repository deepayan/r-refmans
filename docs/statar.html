<!DOCTYPE html><html><head><title>Help for package statar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {statar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#elapsed'><p>Elapsed dates (monthly, quarterly)</p></a></li>
<li><a href='#fill_gap'><p>Add rows corresponding to gaps in some variable</p></a></li>
<li><a href='#is.panel'><p>Check whether a data.frame is a panel</p></a></li>
<li><a href='#join'><p>Join two data frames together</p></a></li>
<li><a href='#n_narm'><p>Count number of non missing observations</p></a></li>
<li><a href='#pctile'><p>Weighted quantile of type 2 (similar to Stata _pctile)</p></a></li>
<li><a href='#stat_binmean'><p>Plot the mean of y over the mean of x within bins of x.</p></a></li>
<li><a href='#statar'><p>A package for applied research</p></a></li>
<li><a href='#sum_up'><p>Gives summary statistics (corresponds to Stata command summarize)</p></a></li>
<li><a href='#tab'><p>Returns cross tabulation</p></a></li>
<li><a href='#tempname'><p>Create unique names within a list, a data.frame, or an environment</p></a></li>
<li><a href='#tlead-tlag'><p>lead and lag with respect to a time variable</p></a></li>
<li><a href='#winsorize'><p>Winsorize a numeric vector</p></a></li>
<li><a href='#xtile'><p>Bin variable in groups (similar to Stata xtile)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tools Inspired by 'Stata' to Manipulate Tabular Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools inspired by 'Stata' to explore data.frames ('summarize',
    'tabulate', 'xtile', 'pctile', 'binscatter', elapsed quarters/month, lead/lag).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/matthieugomez/statar">https://github.com/matthieugomez/statar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/matthieugomez/statar/issues">https://github.com/matthieugomez/statar/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, tidyselect, dplyr (&ge; 1.0), ggplot2 (&ge; 2.0.0),
lazyeval, matrixStats, methods, rlang, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, lubridate, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 13:00:44 UTC; matthieugomez</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthieu Gomez [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthieu Gomez &lt;mg3901@columbia.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='elapsed'>Elapsed dates (monthly, quarterly)</h2><span id='topic+elapsed'></span><span id='topic+quarterly+2C'></span><span id='topic+monthly'></span><span id='topic+as.quarterly'></span><span id='topic+is.quarterly'></span><span id='topic+as.monthly'></span><span id='topic+is.monthly'></span>

<h3>Description</h3>

<p>Elapsed dates (monthly, quarterly)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.quarterly(x)

is.quarterly(x)

as.monthly(x)

is.monthly(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elapsed_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Monthly and quarterly dates are stored as integers, representing the number of elapsed calendar periods since 01/01/1970.  As <code>yearmonth</code> and <code>yearqtr</code> the package <code>zoo</code>, these dates are printed in a way that fits their frequency  (<code>YYY</code>q<code>q</code>, <code>YYY</code>m<code>MM</code>). The only difference is that, <code>monthly</code>, and <code>quarterly</code> are integers, which removes issues due to floating points (particularly important when merging). This also allows to use arithmetic on perios, ie <code>date</code> + 1 adds one period rather than one day.
</p>
<p>Methods to convert from and to Dates or POSIXlt are provided. In particular, you may use lubridate <code><a href="data.table.html#topic+week">week</a></code> <code><a href="data.table.html#topic+month">month</a></code> and <code><a href="data.table.html#topic+year">year</a></code> to extract information from elapsed dates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
library(dplyr)
date &lt;- mdy(c("04/03/1992", "01/04/1992", "03/15/1992"))  
datem &lt;- as.monthly(date)
is.monthly(datem)
as.quarterly(date)
as.character(datem)
datem + 1
df &lt;- tibble(datem)
# filter(df, month(datem) == 1)
seq(datem[1], datem[2])
as.Date(datem)
as.POSIXlt(datem)
as.POSIXct(datem)
week(datem)
</code></pre>

<hr>
<h2 id='fill_gap'>Add rows corresponding to gaps in some variable</h2><span id='topic+fill_gap'></span>

<h3>Description</h3>

<p>Add rows corresponding to gaps in some variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_gap(
  x,
  ...,
  full = FALSE,
  roll = FALSE,
  rollends = if (roll == "nearest") c(TRUE, TRUE) else if (roll &gt;= 0) c(FALSE, TRUE) else
    c(TRUE, FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_gap_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="fill_gap_+3A_...">...</code></td>
<td>
<p>a time variable</p>
</td></tr>
<tr><td><code id="fill_gap_+3A_full">full</code></td>
<td>
<p>A boolean. When full = FALSE (default), the function creates rows corresponding to all missing times between the min and max of <code>...</code> within each group. When full = TRUE, the function creates rows corresponding to all missing times between the min and max of <code>...</code> in the whole dataset.</p>
</td></tr>
<tr><td><code id="fill_gap_+3A_roll">roll</code></td>
<td>
<p>When roll is a positive number, values are carried forward. roll=TRUE is equivalent to roll=+Inf. When roll is a negative number, values are rolled backwards; i.e., next observation carried backwards (NOCB). Use -Inf for unlimited roll back. When roll is &quot;nearest&quot;, the nearest value is used. Default to FALSE (no rolling)</p>
</td></tr>
<tr><td><code id="fill_gap_+3A_rollends">rollends</code></td>
<td>
<p>A logical vector length 2 (a single logical is recycled). When rolling forward (e.g. roll=TRUE) if a value is past the last observation within each group defined by the join columns, rollends[2]=TRUE will roll the last value forwards. rollends[1]=TRUE will roll the first value backwards if the value is before it. If rollends=FALSE the value of i must fall in a gap in x but not after the end or before the beginning of the data, for that group defined by all but the last join column. When roll is a finite number, that limit is also applied when rolling the end</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(lubridate)
df &lt;- tibble(
    id    = c(1, 1, 1, 1),
    datem  = as.monthly(mdy(c("01/01/1992", "02/01/1992", "04/01/1992", "7/11/1992"))),
    value = c(4.1, 4.5, 3.3, 3.2)
)
df %&gt;% group_by(id) %&gt;% fill_gap(datem)
df %&gt;% group_by(id) %&gt;% fill_gap(datem, roll = 1)
df %&gt;% group_by(id) %&gt;% fill_gap(datem, roll = "nearest")
df %&gt;% group_by(id) %&gt;% fill_gap(datem, roll = "nearest", full = TRUE)
</code></pre>

<hr>
<h2 id='is.panel'>Check whether a data.frame is a panel</h2><span id='topic+is.panel'></span>

<h3>Description</h3>

<p>Check whether a data.frame is a panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.panel(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.panel_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="is.panel_+3A_...">...</code></td>
<td>
<p>a time variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>is.panel</code> check that there are no duplicate combinations of the variables in ... and that no observation is missing for the last variable in ... (the time variable).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- tibble(
    id1    = c(1, 1, 1, 2, 2),
    id2   = 1:5,
    year  = c(1991, 1993, NA, 1992, 1992),
    value = c(4.1, 4.5, 3.3, 3.2, 5.2)
)
df %&gt;% group_by(id1) %&gt;% is.panel(year)
df1 &lt;- df %&gt;% filter(!is.na(year))
df1 %&gt;% is.panel(year)
df1 %&gt;% group_by(id1) %&gt;% is.panel(year)
df1 %&gt;% group_by(id1, id2) %&gt;% is.panel(year)
</code></pre>

<hr>
<h2 id='join'>Join two data frames together</h2><span id='topic+join'></span>

<h3>Description</h3>

<p>Join two data frames together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join(
  x,
  y,
  kind,
  on = intersect(names(x), names(y)),
  suffixes = c(".x", ".y"),
  check = m ~ m,
  gen = FALSE,
  inplace = FALSE,
  update = FALSE,
  type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_+3A_x">x</code></td>
<td>
<p>The master data.frame</p>
</td></tr>
<tr><td><code id="join_+3A_y">y</code></td>
<td>
<p>The using data.frame</p>
</td></tr>
<tr><td><code id="join_+3A_kind">kind</code></td>
<td>
<p>The kind of (SQL) join among &quot;full&quot; (default), &quot;left&quot;, &quot;right&quot;, &quot;inner&quot;, &quot;semi&quot;, &quot;anti&quot; and &quot;cross&quot;.</p>
</td></tr>
<tr><td><code id="join_+3A_on">on</code></td>
<td>
<p>Character vectors specifying variables to match on. Default to common names between x and y.</p>
</td></tr>
<tr><td><code id="join_+3A_suffixes">suffixes</code></td>
<td>
<p>A character vector of length 2 specifying suffix of overlapping columns. Defaut to &quot;.x&quot; and &quot;.y&quot;.</p>
</td></tr>
<tr><td><code id="join_+3A_check">check</code></td>
<td>
<p>A formula checking for the presence of duplicates. Specifying 1~m (resp m~1, 1~1) checks that joined variables uniquely identify observations in x (resp y, both).</p>
</td></tr>
<tr><td><code id="join_+3A_gen">gen</code></td>
<td>
<p>Name of new variable to mark result, or the boolean FALSE (default) if no such variable should be created. The variable equals 1 for rows in master only, 2 for rows in using only, 3 for matched rows.</p>
</td></tr>
<tr><td><code id="join_+3A_inplace">inplace</code></td>
<td>
<p>A boolean. In case &quot;kind&quot;= &quot;left&quot; and RHS of check is 1, the merge can be one in-place.</p>
</td></tr>
<tr><td><code id="join_+3A_update">update</code></td>
<td>
<p>A boolean. For common variables in x and y not specified in &quot;on&quot;, replace missing observations by the non missing observations in y.</p>
</td></tr>
<tr><td><code id="join_+3A_type">type</code></td>
<td>
<p>Deprecated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame that joins rows in master and using datases. Importantly, if x or y are not keyed, the join may change their row orders.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
x &lt;- data.frame(a = rep(1:2, each = 3), b=1:6)
y &lt;- data.frame(a = 0:1, bb = 10:11)
join(x, y, kind = "full")
join(x, y, kind = "left", gen = "_merge")
join(x, y, kind = "right", gen = "_merge")
join(x, y, kind = "inner", check = m~1)
join(x, y, kind = "semi")
join(x, y, kind = "anti")
y &lt;- rename(y, b = bb)
join(x, y, kind = "full", on = "a")
join(x, y, kind = "full", on = "a", suffixes = c("",".i"))
y &lt;- data.frame(a = 0:1, bb = 10:11)
join(x, y, kind = "left", check = m~1)
x &lt;- data.frame(a = c(1,2), b=c(NA, 2))
y &lt;- data.frame(a = c(1,2), b = 10:11)
join(x, y, kind = "left", on = "a",  update = TRUE)
join(x, y, kind = "left", on = "a", check = m~1,  update = TRUE)
</code></pre>

<hr>
<h2 id='n_narm'>Count number of non missing observations</h2><span id='topic+n_narm'></span>

<h3>Description</h3>

<p>Count number of non missing observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_narm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_narm_+3A_...">...</code></td>
<td>
<p>a sequence of vectors, matrices and data frames.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>                         
n_narm(1:100, c(NA, 1:99))
</code></pre>

<hr>
<h2 id='pctile'>Weighted quantile of type 2 (similar to Stata _pctile)</h2><span id='topic+pctile'></span>

<h3>Description</h3>

<p>Weighted quantile of type 2 (similar to Stata _pctile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pctile(x, probs = c(0.25, 0.5, 0.75), wt = NULL, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pctile_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="pctile_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities</p>
</td></tr>
<tr><td><code id="pctile_+3A_wt">wt</code></td>
<td>
<p>A weight vector</p>
</td></tr>
<tr><td><code id="pctile_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be returned?</p>
</td></tr>
</table>

<hr>
<h2 id='stat_binmean'>Plot the mean of y over the mean of x within bins of x.</h2><span id='topic+stat_binmean'></span>

<h3>Description</h3>

<p>Plot the mean of y over the mean of x within bins of x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_binmean(
  mapping = NULL,
  data = NULL,
  geom = "point",
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  na.rm = FALSE,
  n = 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_binmean_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_binmean_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_binmean_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
<tr><td><code id="stat_binmean_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_binmean_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_binmean_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_binmean_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code> (the default), removes missing values with
a warning.  If <code>TRUE</code> silently removes missing values.</p>
</td></tr>
<tr><td><code id="stat_binmean_+3A_n">n</code></td>
<td>
<p>number of x-bins. Default to 20. Set to zero if you want to use distinct value of x for grouping.</p>
</td></tr>
<tr><td><code id="stat_binmean_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with additional columns:
</p>
<table>
<tr><td><code>xtile</code></td>
<td>
<p>bins for x</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>mean of x</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>mean of y</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
g &lt;- ggplot(iris, aes(x = Sepal.Width , y = Sepal.Length)) + stat_binmean(n = 10)
g + stat_smooth(method = "lm", se = FALSE)
ggplot(iris, aes(x = Sepal.Width , y = Sepal.Length, color = Species)) + stat_binmean(n = 10)
ggplot(iris, aes(x = Sepal.Width, y = Sepal.Length, weight = Petal.Length)) + stat_binmean(n = 10)
</code></pre>

<hr>
<h2 id='statar'>A package for applied research</h2><span id='topic+statar'></span><span id='topic+statar-package'></span>

<h3>Description</h3>

<p>A package for applied research
</p>

<hr>
<h2 id='sum_up'>Gives summary statistics (corresponds to Stata command summarize)</h2><span id='topic+sum_up'></span>

<h3>Description</h3>

<p>Gives summary statistics (corresponds to Stata command summarize)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_up(df, ..., d = FALSE, wt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_up_+3A_df">df</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="sum_up_+3A_...">...</code></td>
<td>
<p>Variables to include. Defaults to all non-grouping variables. See the <a href="dplyr.html#topic+select">select</a> documentation.</p>
</td></tr>
<tr><td><code id="sum_up_+3A_d">d</code></td>
<td>
<p>Should detailed summary statistics be printed?</p>
</td></tr>
<tr><td><code id="sum_up_+3A_wt">wt</code></td>
<td>
<p>Weights. Default to NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
N &lt;- 100
df &lt;- tibble(
  id = 1:N,
  v1 = sample(5, N, TRUE),
  v2 = sample(1e6, N, TRUE)
)
sum_up(df)
sum_up(df, v2, d = TRUE)
sum_up(df, v2, wt = v1)
df %&gt;% group_by(v1) %&gt;% sum_up(starts_with("v"))
</code></pre>

<hr>
<h2 id='tab'>Returns cross tabulation</h2><span id='topic+tab'></span>

<h3>Description</h3>

<p>Returns cross tabulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab(x, ..., wt = NULL, na.rm = FALSE, sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab_+3A_x">x</code></td>
<td>
<p>a vector or a data.frame</p>
</td></tr>
<tr><td><code id="tab_+3A_...">...</code></td>
<td>
<p>Variable(s) to include. If length is two, a special cross tabulation table is printed although a long data.frame is always (invisibly) returned.</p>
</td></tr>
<tr><td><code id="tab_+3A_wt">wt</code></td>
<td>
<p>Frequency weights. Default to NULL.</p>
</td></tr>
<tr><td><code id="tab_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove missing values. Default to FALSE</p>
</td></tr>
<tr><td><code id="tab_+3A_sort">sort</code></td>
<td>
<p>Boolean. Default to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame sorted by variables in ..., and with columns &quot;Freq.&quot;, &quot;Percent&quot;, and &quot;Cum.&quot; for counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># setup
library(dplyr)
N &lt;- 1e2 ; K = 10
df &lt;- tibble(
  id = sample(c(NA,1:5), N/K, TRUE),
  v1 =  sample(1:5, N/K, TRUE)                       
)
# one-way tabulation
df %&gt;% tab(id)
df %&gt;% tab(id, wt = v1)
# two-way tabulation
df %&gt;% tab(id, v1)
df %&gt;% filter(id &gt;= 3) %&gt;% tab(id)
</code></pre>

<hr>
<h2 id='tempname'>Create unique names within a list, a data.frame, or an environment</h2><span id='topic+tempname'></span>

<h3>Description</h3>

<p>Create unique names within a list, a data.frame, or an environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempname(where = globalenv(), n = 1, prefix = ".temp", inherits = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tempname_+3A_where">where</code></td>
<td>
<p>A chracter vector, list or an environment</p>
</td></tr>
<tr><td><code id="tempname_+3A_n">n</code></td>
<td>
<p>An integar that specifies length of the output</p>
</td></tr>
<tr><td><code id="tempname_+3A_prefix">prefix</code></td>
<td>
<p>A character vector that specifies prefix for new name</p>
</td></tr>
<tr><td><code id="tempname_+3A_inherits">inherits</code></td>
<td>
<p>Should the name unique also in the enclosing frames of the environment?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tempname(c("temp1", "temp3"), 4)
tempname(globalenv())
tempname(data.frame(temp = 1), n = 3)
</code></pre>

<hr>
<h2 id='tlead-tlag'>lead and lag with respect to a time variable</h2><span id='topic+tlead-tlag'></span><span id='topic+tlead'></span><span id='topic+tlag'></span>

<h3>Description</h3>

<p>lead and lag with respect to a time variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tlead(x, n = 1L, time, default = NA)

tlag(x, n = 1L, time, default = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tlead-tlag_+3A_x">x</code></td>
<td>
<p>a vector of values</p>
</td></tr>
<tr><td><code id="tlead-tlag_+3A_n">n</code></td>
<td>
<p>a positive integer of length 1, giving the number of positions to lead or lag by. When the package lubridate is loaded, it can be a period when using with time (see the lubridate function minutes, hours, days, weeks, months and years)</p>
</td></tr>
<tr><td><code id="tlead-tlag_+3A_time">time</code></td>
<td>
<p>time variable</p>
</td></tr>
<tr><td><code id="tlead-tlag_+3A_default">default</code></td>
<td>
<p>value used for non-existant rows. Defaults to <code>NA</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>date &lt;- c(1989, 1991, 1992)
value &lt;- c(4.1, 4.5, 3.3)
tlag(value, 1, time = date) #  returns value in year - 1
library(lubridate)
date &lt;- as.monthly(mdy(c("01/04/1992", "03/15/1992", "04/03/1992")))
tlag(value, time = date) 
library(dplyr)
df &lt;- tibble(
   id    = c(1, 2, 2),
   date  = date,
   value = value
)
df %&gt;% group_by(id) %&gt;% mutate(valuel = tlag(value, n = 1, time = date))
</code></pre>

<hr>
<h2 id='winsorize'>Winsorize a numeric vector</h2><span id='topic+winsorize'></span><span id='topic+winsorise'></span>

<h3>Description</h3>

<p>Winsorize a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsorize(
  x,
  probs = NULL,
  cutpoints = NULL,
  replace = c(cutpoints[1], cutpoints[2]),
  verbose = TRUE
)

winsorise(
  x,
  probs = NULL,
  cutpoints = NULL,
  replace = c(cutpoints[1], cutpoints[2]),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winsorize_+3A_x">x</code></td>
<td>
<p>A vector of values</p>
</td></tr>
<tr><td><code id="winsorize_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities that can be used instead of cutpoints. Quantiles are computed as the inverse of the empirical distribution function (type = 1)</p>
</td></tr>
<tr><td><code id="winsorize_+3A_cutpoints">cutpoints</code></td>
<td>
<p>Cutpoints under and above which are defined outliers. Default is (median - five times interquartile range, median + five times interquartile range). Compared to bottom and top percentile, this takes into account the whole distribution of the vector.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_replace">replace</code></td>
<td>
<p>Values by which outliers are replaced. Default to cutpoints. A frequent alternative is NA.</p>
</td></tr>
<tr><td><code id="winsorize_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. Should the percentage of replaced values printed?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>                         
v &lt;- c(1:4, 99)
winsorize(v)
winsorize(v, replace = NA)
winsorize(v, probs = c(0.01, 0.99))
winsorize(v, cutpoints = c(1, 50))
</code></pre>

<hr>
<h2 id='xtile'>Bin variable in groups (similar to Stata xtile)</h2><span id='topic+xtile'></span>

<h3>Description</h3>

<p>Bin variable in groups (similar to Stata xtile)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtile(x, n = NULL, probs = NULL, cutpoints = NULL, wt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtile_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="xtile_+3A_n">n</code></td>
<td>
<p>A numeric specifying number of quantiles. Can be used instead of cutpoints</p>
</td></tr>
<tr><td><code id="xtile_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities that an be used instead of cutpoints. Quantiles are computed as the inverse of the empirical distribution function (type = 1)</p>
</td></tr>
<tr><td><code id="xtile_+3A_cutpoints">cutpoints</code></td>
<td>
<p>Cutpoints to use when <code>nq</code> is not specified.  For instance <code>cutpoints = 0.4</code> creates two groups, one for observations equal or below 0.4, one for observations superior to 0.4.</p>
</td></tr>
<tr><td><code id="xtile_+3A_wt">wt</code></td>
<td>
<p>A variable specifying weight in case the option n_quantiles is specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector representing groups corresponding to cutpoints. Includes missing values when present in the original vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(NA, 1:10)                   
xtile(x, n = 3) # 3 groups based on terciles
xtile(x, probs = c(0.3, 0.7)) # 3 groups based on two quantiles
xtile(x, cutpoints = c(2, 3)) # 3 groups based on two cutpoints
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
