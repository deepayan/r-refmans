<!DOCTYPE html><html lang="en"><head><title>Help for package receptiviti</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {receptiviti}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#receptiviti'><p>Receptiviti API</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Text Analysis Through the 'Receptiviti' API</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Send text to the <a href="https://www.receptiviti.com">https://www.receptiviti.com</a> API to be scored
    by all available frameworks.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl, jsonlite, digest, progressr, stringi</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, future, arrow (&ge;
9.0.0), dplyr, future.apply</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://receptiviti.github.io/receptiviti-r/">https://receptiviti.github.io/receptiviti-r/</a>,
<a href="https://github.com/Receptiviti/receptiviti-r">https://github.com/Receptiviti/receptiviti-r</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Receptiviti/receptiviti-r/issues">https://github.com/Receptiviti/receptiviti-r/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-29 13:19:56 UTC; Admin</td>
</tr>
<tr>
<td>Author:</td>
<td>Receptiviti Inc. [fnd, cph],
  Kent English [cre],
  Micah Iserman [aut, ctr]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kent English &lt;kenglish@receptiviti.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-29 18:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='receptiviti'>Receptiviti API</h2><span id='topic+receptiviti'></span><span id='topic+receptiviti_status'></span>

<h3>Description</h3>

<p>The main function to access the <a href="https://www.receptiviti.com">Receptiviti</a> API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>receptiviti(text, output = NULL, id = NULL, text_column = NULL,
  id_column = NULL, files = NULL, dir = NULL, file_type = "txt",
  encoding = NULL, return_text = FALSE,
  api_args = getOption("receptiviti.api_args", list()),
  frameworks = getOption("receptiviti.frameworks", "all"),
  framework_prefix = TRUE, as_list = FALSE, bundle_size = 1000,
  bundle_byte_limit = 7500000, collapse_lines = FALSE, retry_limit = 50,
  clear_cache = FALSE, clear_scratch_cache = TRUE, request_cache = TRUE,
  cores = detectCores() - 1, use_future = FALSE, in_memory = TRUE,
  verbose = FALSE, overwrite = FALSE, compress = FALSE,
  make_request = TRUE, text_as_paths = FALSE,
  cache = Sys.getenv("RECEPTIVITI_CACHE"), cache_overwrite = FALSE,
  cache_format = Sys.getenv("RECEPTIVITI_CACHE_FORMAT", "parquet"),
  key = Sys.getenv("RECEPTIVITI_KEY"),
  secret = Sys.getenv("RECEPTIVITI_SECRET"),
  url = Sys.getenv("RECEPTIVITI_URL"),
  version = Sys.getenv("RECEPTIVITI_VERSION"),
  endpoint = Sys.getenv("RECEPTIVITI_ENDPOINT"))

receptiviti_status(url = Sys.getenv("RECEPTIVITI_URL"),
  key = Sys.getenv("RECEPTIVITI_KEY"),
  secret = Sys.getenv("RECEPTIVITI_SECRET"), verbose = TRUE,
  include_headers = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="receptiviti_+3A_text">text</code></td>
<td>
<p>A character vector with text to be processed, path to a directory containing files, or a vector of file paths.
If a single path to a directory, each file is collapsed to a single text. If a path to a file or files,
each line or row is treated as a separate text, unless <code>collapse_lines</code> is <code>TRUE</code> (in which case,
files will be read in as part of bundles at processing time, as is always the case when a directory).
Use <code>files</code> to more reliably enter files, or <code>dir</code> to more reliably specify a directory.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_output">output</code></td>
<td>
<p>Path to a <code>.csv</code> file to write results to. If this already exists, set <code>overwrite</code> to <code>TRUE</code>
to overwrite it.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_id">id</code></td>
<td>
<p>Vector of unique IDs the same length as <code>text</code>, to be included in the results.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_text_column">text_column</code>, <code id="receptiviti_+3A_id_column">id_column</code></td>
<td>
<p>Column name of text/id, if <code>text</code> is a matrix-like object, or a path to a csv file.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_files">files</code></td>
<td>
<p>A list of file paths, as alternate entry to <code>text</code>.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_dir">dir</code></td>
<td>
<p>A directory to search for files in, as alternate entry to <code>text</code>.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_file_type">file_type</code></td>
<td>
<p>File extension to search for, if <code>text</code> is the path to a directory containing files to be read in.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_encoding">encoding</code></td>
<td>
<p>Encoding of file(s) to be read in. If not specified, this will be detected, which can fail,
resulting in mis-encoded characters; for best (and fasted) results, specify encoding.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_return_text">return_text</code></td>
<td>
<p>Logical; if <code>TRUE</code>, <code>text</code> is included as the first column of the result.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_api_args">api_args</code></td>
<td>
<p>A list of additional arguments to pass to the API (e.g., <code>list(sallee_mode = "sparse")</code>). Defaults to the
<code>receptiviti.api_args</code> option.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_frameworks">frameworks</code></td>
<td>
<p>A vector of frameworks to include results from. Texts are always scored with all available framework &ndash;
this just specifies what to return. Defaults to <code>all</code>, to return all scored frameworks. Can be set by the
<code>receptiviti.frameworks</code> option (e.g., <code>options(receptiviti.frameworks = c("liwc", "sallee"))</code>).</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_framework_prefix">framework_prefix</code></td>
<td>
<p>Logical; if <code>FALSE</code>, will remove the framework prefix from column names, which may result in duplicates.
If this is not specified, and 1 framework is selected, or <code>as_list</code> is <code>TRUE</code>, will default to remove prefixes.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_as_list">as_list</code></td>
<td>
<p>Logical; if <code>TRUE</code>, returns a list with frameworks in separate entries.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_bundle_size">bundle_size</code></td>
<td>
<p>Number of texts to include in each request; between 1 and 1,000.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_bundle_byte_limit">bundle_byte_limit</code></td>
<td>
<p>Memory limit (in bytes) of each bundle, under <code>1e7</code> (10 MB, which is the API's limit).
May need to be lower than the API's limit, depending on the system's requesting library.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_collapse_lines">collapse_lines</code></td>
<td>
<p>Logical; if <code>TRUE</code>, and <code>text</code> contains paths to files, each file is treated as a single text.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_retry_limit">retry_limit</code></td>
<td>
<p>Maximum number of times each request can be retried after hitting a rate limit.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_clear_cache">clear_cache</code></td>
<td>
<p>Logical; if <code>TRUE</code>, will clear any existing files in the cache. Use <code>cache_overwrite</code> if
you want fresh results without clearing or disabling the cache. Use <code>cache = FALSE</code> to disable the cache.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_clear_scratch_cache">clear_scratch_cache</code></td>
<td>
<p>Logical; if <code>FALSE</code>, will preserve the bundles written when <code>in_memory</code> is <code>TRUE</code>, after
the request has been made.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_request_cache">request_cache</code></td>
<td>
<p>Logical; if <code>FALSE</code>, will always make a fresh request, rather than using the response
from a previous identical request.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_cores">cores</code></td>
<td>
<p>Number of CPU cores to split bundles across, if there are multiple bundles. See the Parallelization section.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_use_future">use_future</code></td>
<td>
<p>Logical; if <code>TRUE</code>, uses a <code>future</code> back-end to process bundles, in which case,
parallelization can be controlled with the <code><a href="future.html#topic+plan">plan</a></code> function (e.g., <code>plan("multisession")</code>
to use multiple cores); this is required to see progress bars when using multiple cores. See the Parallelization section.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_in_memory">in_memory</code></td>
<td>
<p>Logical; if <code>FALSE</code>, will write bundles to temporary files, and only load them as they are being requested.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_verbose">verbose</code></td>
<td>
<p>Logical; if <code>TRUE</code>, will show status messages.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical; if <code>TRUE</code>, will overwrite an existing <code>output</code> file.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_compress">compress</code></td>
<td>
<p>Logical; if <code>TRUE</code>, will save as an <code>xz</code>-compressed file.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_make_request">make_request</code></td>
<td>
<p>Logical; if <code>FALSE</code>, a request is not made. This could be useful if you want to be sure and
load from one of the caches, but aren't sure that all results exist there; it will error out if it encounters
texts it has no other source for.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_text_as_paths">text_as_paths</code></td>
<td>
<p>Logical; if <code>TRUE</code>, ensures <code>text</code> is treated as a vector of file paths. Otherwise, this will be
determined if there are no <code>NA</code>s in <code>text</code> and every entry is under 500 characters long.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_cache">cache</code></td>
<td>
<p>Path to a directory in which to save unique results for reuse; defaults to
<code>Sys.getenv(</code><code>"RECEPTIVITI_CACHE")</code>. See the Cache section for details.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_cache_overwrite">cache_overwrite</code></td>
<td>
<p>Logical; if <code>TRUE</code>, will write results to the cache without reading from it. This could be used
if you want fresh results to be cached without clearing the cache.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_cache_format">cache_format</code></td>
<td>
<p>Format of the cache database; see <code><a href="arrow.html#topic+FileFormat">FileFormat</a></code>.
Defaults to <code>Sys.getenv(</code><code>"RECEPTIVITI_CACHE_FORMAT")</code>.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_key">key</code></td>
<td>
<p>API Key; defaults to <code>Sys.getenv("RECEPTIVITI_KEY")</code>.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_secret">secret</code></td>
<td>
<p>API Secret; defaults to <code>Sys.getenv("RECEPTIVITI_SECRET")</code>.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_url">url</code></td>
<td>
<p>API URL; defaults to <code>Sys.getenv("RECEPTIVITI_URL")</code>, which defaults to
<code>"https://api.receptiviti.com/"</code>.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_version">version</code></td>
<td>
<p>API version; defaults to <code>Sys.getenv("RECEPTIVITI_VERSION")</code>, which defaults to
<code>"v1"</code>.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_endpoint">endpoint</code></td>
<td>
<p>API endpoint (path name after the version); defaults to <code>Sys.getenv("RECEPTIVITI_ENDPOINT")</code>,
which defaults to <code>"framework"</code>.</p>
</td></tr>
<tr><td><code id="receptiviti_+3A_include_headers">include_headers</code></td>
<td>
<p>Logical; if <code>TRUE</code>, <code>receptiviti_status</code>'s verbose message will include
the HTTP headers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns for <code>text</code> (if <code>return_text</code> is <code>TRUE</code>; the originally entered text),
<code>id</code> (if one was provided), <code>text_hash</code> (the MD5 hash of the text), a column each for relevant entries in <code>api_args</code>,
and scores from each included framework (e.g., <code>summary.word_count</code> and <code>liwc.i</code>). If <code>as_list</code> is <code>TRUE</code>,
returns a list with a named entry containing such a <code>data.frame</code> for each framework.
</p>


<h3>Cache</h3>

<p>If the <code>cache</code> argument is specified, results for unique texts are saved in an
<a href="https://arrow.apache.org">Arrow</a> database in the cache location
(<code>Sys.getenv(</code><code>"RECEPTIVITI_CACHE")</code>), and are retrieved with subsequent requests.
This ensures that the exact same texts are not re-sent to the API.
This does, however, add some processing time and disc space usage.
</p>
<p>If <code>cache</code> is <code>TRUE</code>, a default directory (<code>receptiviti_cache</code>) will be looked for
in the system's temporary directory (which is usually the parent of <code>tempdir()</code>).
If this does not exist, you will be asked if it should be created.
</p>
<p>The primary cache is checked when each bundle is processed, and existing results are loaded at
that time. When processing many bundles in parallel, and many results have been cached,
this can cause the system to freeze and potentially crash.
To avoid this, limit the number of cores, or disable parallel processing.
</p>
<p>The <code>cache_format</code> arguments (or the <code>RECEPTIVITI_CACHE_FORMAT</code> environment variable) can be used to adjust the format of the cache.
</p>
<p>You can use the cache independently with <code>open_database(Sys.getenv("RECEPTIVITI_CACHE"))</code>.
</p>
<p>You can also set the <code>clear_cache</code> argument to <code>TRUE</code> to clear the cache before it is used again, which may be useful
if the cache has gotten big, or you know new results will be returned. Even if a cached result exists, it will be
reprocessed if it does not have all of the variables of new results, but this depends on there being at least 1 uncached
result. If, for instance, you add a framework to your account and want to reprocess a previously processed set of texts,
you would need to first clear the cache.
</p>
<p>Either way, duplicated texts within the same call will only be sent once.
</p>
<p>The <code>request_cache</code> argument controls a more temporary cache of each bundle request. This is cleared when the
R session ends. You might want to set this to <code>FALSE</code> if a new framework becomes available on your account
and you want to process a set of text you already processed in the current R session without restarting.
</p>
<p>Another temporary cache is made when <code>in_memory</code> is <code>FALSE</code>, which is the default when processing
in parallel (when <code>cores</code> is over <code>1</code> or <code>use_future</code> is <code>TRUE</code>). This contains
a file for each unique bundle, which is read in as needed by the parallel workers.
</p>


<h3>Parallelization</h3>

<p><code>text</code>s are split into bundles based on the <code>bundle_size</code> argument. Each bundle represents
a single request to the API, which is why they are limited to 1000 texts and a total size of 10 MB.
When there is more than one bundle and either <code>cores</code> is greater than 1 or <code>use_future</code> is <code>TRUE</code> (and you've
externally specified a <code><a href="future.html#topic+plan">plan</a></code>), bundles are processed by multiple cores.
</p>
<p>If you have texts spread across multiple files, they can be most efficiently processed in parallel
if each file contains a single text (potentially collapsed from multiple lines). If files contain
multiple texts (i.e., <code>collapse_lines = FALSE</code>), then texts need to be read in before bundling
in order to ensure bundles are under the length limit.
</p>
<p>Whether processing in serial or parallel, progress bars can be specified externally with
<code><a href="progressr.html#topic+handlers">handlers</a></code>; see examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# check that the API is available, and your credentials work
receptiviti_status()

# score a single text
single &lt;- receptiviti("a text to score")

# score multiple texts, and write results to a file
multi &lt;- receptiviti(c("first text to score", "second text"), "filename.csv")

# score many texts in separate files
## defaults to look for .txt files
file_results &lt;- receptiviti(dir = "./path/to/txt_folder")

## could be .csv
file_results &lt;- receptiviti(
  dir = "./path/to/csv_folder",
  text_column = "text", file_type = "csv"
)

# score many texts from a file, with a progress bar
## set up cores and progress bar (only necessary if you want the progress bar)
future::plan("multisession")
progressr::handlers(global = TRUE)
progressr::handlers("progress")

## make request
results &lt;- receptiviti(
  "./path/to/largefile.csv",
  text_column = "text", use_future = TRUE
)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
