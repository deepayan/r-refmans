<!DOCTYPE html><html><head><title>Help for package disaggR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {disaggR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bflSmooth'><p>Smooth a time series</p></a></li>
<li><a href='#bflSmooth_matrices_factory'><p>Generating a clone for bflSmooth_matrices_impl</p></a></li>
<li><a href='#construction'><p>Total GFCF in construction at current prices</p></a></li>
<li><a href='#consumption_catering'><p>Total consumption in accommodation and food services at current prices</p></a></li>
<li><a href='#default_col_pal'><p>Default color palette</p></a></li>
<li><a href='#default_lty_pal'><p>Default linetype palette</p></a></li>
<li><a href='#default_margins'><p>Default margins</p></a></li>
<li><a href='#default_theme_ggplot'><p>Default ggplot theme</p></a></li>
<li><a href='#disaggR-class'><p>Virtual Class &quot;disaggR&quot; Class of disaggregations</p></a></li>
<li><a href='#disaggR-package'><p>Two-Steps Benchmarks for Time Series Disaggregation</p></a></li>
<li><a href='#distance'><p>Distance computation for disaggregations</p></a></li>
<li><a href='#extend_tsp'><p>Extend tsp with lf</p></a></li>
<li><a href='#hfserie_extrap'><p>Extrapolation function for the hfserie in a threeRuleSmooth</p></a></li>
<li><a href='#in_disaggr'><p>Comparing a disaggregation with the high-frequency input</p></a></li>
<li><a href='#in_revisions'><p>Comparing two disaggregations together</p></a></li>
<li><a href='#in_sample'><p>Producing the in sample predictions of a prais-lm regression</p></a></li>
<li><a href='#in_scatter'><p>Comparing the inputs of a praislm regression</p></a></li>
<li><a href='#model.list'><p>Extracting all the arguments submitted to generate an object</p></a></li>
<li><a href='#outliers'><p>Extracting the standard error</p></a></li>
<li><a href='#plot.twoStepsBenchmark'><p>Plotting disaggR objects</p></a></li>
<li><a href='#prais'><p>Extracting the regression of a twoStepsBenchmark</p></a></li>
<li><a href='#rePort'><p>Producing a report</p></a></li>
<li><a href='#residuals_extrap'><p>Extrapolation function for the residuals in a twoStepsBenchmark</p></a></li>
<li><a href='#reUseBenchmark'><p>Using an estimated benchmark model on another time series</p></a></li>
<li><a href='#reView'><p>A shiny app to reView and modify twoStepsBenchmarks</p></a></li>
<li><a href='#rho'><p>Extracting the autocorrelation parameter</p></a></li>
<li><a href='#se'><p>Extracting the standard error</p></a></li>
<li><a href='#smoothed.part'><p>Extracting the smoothed part of a twoStepsBenchmark</p></a></li>
<li><a href='#smoothed.rate'><p>Extracting the rate of a threeRuleSmooth</p></a></li>
<li><a href='#threeRuleSmooth'><p>Bends a time series with a lower frequency one by smoothing their rate</p></a></li>
<li><a href='#turnover'><p>Turnover indicator in construction</p></a></li>
<li><a href='#turnover_catering'><p>Turnover indicator in accommodation and food services</p></a></li>
<li><a href='#twoStepsBenchmark'><p>Regress and bends a time series with a lower frequency one</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Two-Steps Benchmarks for Time Series Disaggregation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The twoStepsBenchmark() and threeRuleSmooth() functions allow you to 
    disaggregate a low-frequency time series with higher frequency time series, 
    using the French National Accounts methodology. The aggregated sum of the 
    resulting time series is strictly equal to the low-frequency time series within the 
    benchmarking window. Typically, the low-frequency time series is an annual one, 
    unknown for the last year, and the high frequency one is either quarterly or 
    monthly. See "Methodology of quarterly national accounts", Insee Méthodes 
    N°126, by Insee (2012, ISBN:978-2-11-068613-8, <a href="https://www.insee.fr/en/information/2579410">https://www.insee.fr/en/information/2579410</a>).</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, RColorBrewer (&ge; 1.1-2), stats,
utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ggplot2 (&ge; 3.0.0), rmarkdown (&ge; 2.0.0), shiny (&ge;
1.5.0), shinytest2 (&ge; 0.1.0), testthat (&ge; 3.0.0), vdiffr (&ge;
1.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/InseeFr/disaggR/issues">https://github.com/InseeFr/disaggR/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'bflSmooth.R' 'data.R' 'disaggR.R' 'utils.R' 'in.R'
's4register.R' 'twoStepsBenchmark.R' 'methods.R' 'plot.R'
'praislm.R' 'reView.R' 'threeRuleSmooth.R'</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://inseefr.github.io/disaggR/">https://inseefr.github.io/disaggR/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 13:00:39 UTC; arnaud.feldmann</td>
</tr>
<tr>
<td>Author:</td>
<td>Arnaud Feldmann <a href="https://orcid.org/0000-0003-0109-7505"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (Creator and maintener of the package until the version
    1.0.2),
  Franck Arnaud [ctb] (barplot base graphics method for the mts class),
  Pauline Meinzel [cre],
  Institut national de la statistique et des études économiques [cph]
    (https://www.insee.fr/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pauline Meinzel &lt;pauline.meinzel@insee.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-09 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bflSmooth'>Smooth a time series</h2><span id='topic+bflSmooth'></span>

<h3>Description</h3>

<p>bflSmooth smoothes a time series into a time series of a higher frequency that
exactly aggregates into the higher one. The process followed is Boot, Feibes
and Lisman, which minimizes the squares of the variations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bflSmooth(lfserie, nfrequency, weights = NULL, lfserie.is.rate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bflSmooth_+3A_lfserie">lfserie</code></td>
<td>
<p>a time series to be smoothed</p>
</td></tr>
<tr><td><code id="bflSmooth_+3A_nfrequency">nfrequency</code></td>
<td>
<p>the new high frequency. It must be a multiple of the low
frequency.</p>
</td></tr>
<tr><td><code id="bflSmooth_+3A_weights">weights</code></td>
<td>
<p>NULL or a time series of the same size than the expected
high-frequency serie.</p>
</td></tr>
<tr><td><code id="bflSmooth_+3A_lfserie.is.rate">lfserie.is.rate</code></td>
<td>
<p>TRUE or FALSE. Only taken into account if weights isn't
NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>weights</code> isn't <code>NULL</code> the results depends of <code>lfserie.is.rate</code> :
</p>

<ul>
<li><p> if <code>FALSE</code> the rate output/weights is smoothed with the constraint that the
aggregated output is equal to the input lfserie.
</p>
</li>
<li><p> if <code>TRUE</code> the input lfserie is the rate to be smoothed, with the constraint
that the low-frequency weighted means of the output are equal to
lfserie.
</p>
</li></ul>



<h3>Value</h3>

<p>A time series of frequency nfrequency
</p>

<hr>
<h2 id='bflSmooth_matrices_factory'>Generating a clone for bflSmooth_matrices_impl</h2><span id='topic+bflSmooth_matrices_factory'></span>

<h3>Description</h3>

<p>This <em>function factory</em> returns a clone of bflSmooth_matrices_impl that gives
the same results than the original function but uses cache to store computed matrices,
which is useful when making a large number of similar calls, like calls to
<code>threeRuleSmooth()</code> with the same hfserie but different lfserie,
or to <code>twoStepsBenchmark()</code> with different lfserie of the same length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bflSmooth_matrices_factory(cache_size = 100L)
</code></pre>


<h3>Details</h3>

<p>bflSmooth_matrices_factory is only run at build time.
</p>

<hr>
<h2 id='construction'>Total GFCF in construction at current prices</h2><span id='topic+construction'></span>

<h3>Description</h3>

<p>An annual time series containing the french GFCF in construction from 2000
to 2019, as retrieved the 08/12/2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construction
</code></pre>


<h3>Format</h3>

<p>A time series of frequency 1
</p>


<h3>Source</h3>

<p><a href="https://www.insee.fr/fr/statistiques/2015361">https://www.insee.fr/fr/statistiques/2015361</a>
</p>

<hr>
<h2 id='consumption_catering'>Total consumption in accommodation and food services at current prices</h2><span id='topic+consumption_catering'></span>

<h3>Description</h3>

<p>An annual time series containing the consumption in accommodation and food services services from 1999
to 2021, as retrieved the 04/07/2022.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consumption_catering
</code></pre>


<h3>Format</h3>

<p>A time series of frequency 1
</p>


<h3>Source</h3>

<p><a href="https://www.insee.fr/en/statistiques/serie/010548586">https://www.insee.fr/en/statistiques/serie/010548586</a>
</p>

<hr>
<h2 id='default_col_pal'>Default color palette</h2><span id='topic+default_col_pal'></span>

<h3>Description</h3>

<p>The default color palette for the graphics, inspired from the package
<span class="pkg">scales</span> whose scales can also be used as alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_col_pal(object)
</code></pre>

<hr>
<h2 id='default_lty_pal'>Default linetype palette</h2><span id='topic+default_lty_pal'></span>

<h3>Description</h3>

<p>The default linetype palette for the graphics. The palette for the objects
with another class than <code>"in_scatter"</code> is taken from <code>linetype_pal</code> as seen
in the package <span class="pkg">scales</span>. Hence it is based on a set supplied by Richard
Pearson, University of Manchester.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_lty_pal(object)
</code></pre>

<hr>
<h2 id='default_margins'>Default margins</h2><span id='topic+default_margins'></span>

<h3>Description</h3>

<p>The default margins for the graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_margins(main, xlab, ylab)
</code></pre>

<hr>
<h2 id='default_theme_ggplot'>Default ggplot theme</h2><span id='topic+default_theme_ggplot'></span>

<h3>Description</h3>

<p>This is the default theme for the ggplot graphics produced with autoplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_theme_ggplot(object, start, end, show.legend, xlab, ylab, mar)
</code></pre>

<hr>
<h2 id='disaggR-class'>Virtual Class &quot;disaggR&quot; Class of disaggregations</h2><span id='topic+disaggR-class'></span><span id='topic+Ops+2CdisaggR+2Cmissing-method'></span><span id='topic+Ops+2CdisaggR+2Cvector-method'></span><span id='topic+Ops+2Cvector+2CdisaggR-method'></span><span id='topic+Ops+2CdisaggR+2Cts-method'></span><span id='topic+Ops+2Cts+2CdisaggR-method'></span><span id='topic+Ops+2CdisaggR+2CdisaggR-method'></span><span id='topic+Math2+2CdisaggR-method'></span><span id='topic+show+2CdisaggR-method'></span><span id='topic+threeRuleSmooth-class'></span><span id='topic+twoStepsBenchmark-class'></span>

<h3>Description</h3>

<p>The <code>"disaggR"</code> class is a class contained by the actual disaggregation
classes in the disaggR package. It is a “virtual” class.  disaggR classes are
minimalist S4 classes, containing disaggR and list. This allows Ops group
generic double dispatch but most of the package rather uses S3 methods.
</p>


<h3>See Also</h3>

<p>the functions <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a> and <a href="#topic+threeRuleSmooth">threeRuleSmooth</a>.
</p>

<hr>
<h2 id='disaggR-package'>Two-Steps Benchmarks for Time Series Disaggregation</h2><span id='topic+disaggR'></span><span id='topic+disaggR-package'></span>

<h3>Description</h3>

<p>The <code>twoStepsBenchmark()</code> and <code>threeRuleSmooth()</code> functions allow you to
disaggregate a low-frequency time series with higher frequency time series,
using the French National Accounts methodology. The aggregated sum of the
resulting time series is strictly equal to the low-frequency series within the
benchmarking window. Typically, the low-frequency series is an annual one,
unknown for the last year, and the high frequency one is either quarterly or
monthly.
</p>
<p>See &quot;Methodology of quarterly national accounts&quot;, Insee Méthodes
N°126, by Insee (2012, ISBN:978-2-11-068613-8,
https://www.insee.fr/en/information/2579410).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Laurent <a href="mailto:thomas.laurent@insee.fr">thomas.laurent@insee.fr</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Arnaud Feldmann <a href="mailto:arnaud.feldmann@gmail.com">arnaud.feldmann@gmail.com</a> (<a href="https://orcid.org/0000-0003-0109-7505">ORCID</a>) (Author, creator and maintener of the package until the version 1.0.2)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Franck Arnaud (barplot base graphics method for the mts class) [contributor]
</p>
</li>
<li><p> Institut national de la statistique et des études économiques <a href="mailto:comptes-trimestriels@insee.fr">comptes-trimestriels@insee.fr</a> (https://www.insee.fr/) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://inseefr.github.io/disaggR/">https://inseefr.github.io/disaggR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/InseeFr/disaggR/issues">https://github.com/InseeFr/disaggR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='distance'>Distance computation for disaggregations</h2><span id='topic+distance'></span>

<h3>Description</h3>

<p>This function <code>distance</code> computes the Minkowski distance of exponent p,
related to a tscomparison object, produced with <code>in_sample</code>, <code>in_disaggr</code> or
<code>in_revisions</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(x, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_x">x</code></td>
<td>
<p>an object of class <code>tscomparison</code></p>
</td></tr>
<tr><td><code id="distance_+3A_p">p</code></td>
<td>
<p>an integer greater than 1L, or Inf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The meaning depends on the tscomparison function :
</p>

<ul>
<li> <p><code>in_sample</code> will produce the low-frequency distance between the predicted
value and the response, on the coefficient calculation window.
</p>
</li>
<li> <p><code>in_disaggr</code> will produce the high-frequency distance between the inputs
(eventually, the sum of its contributions) and the benchmarked series.
</p>
</li>
<li> <p><code>in_revisions</code> will produce the high-frequency distance between the two
benchmarked series (contributions distance isn't permitted).
</p>
</li></ul>



<h3>Value</h3>

<p>a numeric of length 1, the distance.
</p>


<h3>See Also</h3>

<p>in_sample in_disaggr in_revisions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction,include.rho = TRUE)
distance(in_sample(benchmark,type="changes"))
distance(in_disaggr(benchmark,type="contributions"),p=1L)
distance(in_disaggr(benchmark,type="changes"),p=Inf)
</code></pre>

<hr>
<h2 id='extend_tsp'>Extend tsp with lf</h2><span id='topic+extend_tsp'></span>

<h3>Description</h3>

<p>This window is the smallest that is all around tsphf
that is compatible with the low frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_tsp(tsphf, lffreq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_tsp_+3A_tsphf">tsphf</code></td>
<td>
<p>a numeric of length 3, a tsp of high-frequency</p>
</td></tr>
<tr><td><code id="extend_tsp_+3A_lffreq">lffreq</code></td>
<td>
<p>a numeric of length 1, the low frequency</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric of length 3, a tsp of high-frequency.
</p>

<hr>
<h2 id='hfserie_extrap'>Extrapolation function for the hfserie in a threeRuleSmooth</h2><span id='topic+hfserie_extrap'></span>

<h3>Description</h3>

<p>This function replaces the incomplete low frequency cycles, at the start and
the end of the hfserie, with respectively the first and the last complete
cycles.
It may seem very raw, but it's only used for the weights in <code>bflSmooth</code>, in
order to get the high-frequency rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hfserie_extrap(hfserie, lffreq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hfserie_extrap_+3A_hfserie">hfserie</code></td>
<td>
<p>a time series, the high frequency series to extrapolate</p>
</td></tr>
<tr><td><code id="hfserie_extrap_+3A_lffreq">lffreq</code></td>
<td>
<p>an integer of length 1. The low frequency</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a time series, the extrapolated hfserie
</p>

<hr>
<h2 id='in_disaggr'>Comparing a disaggregation with the high-frequency input</h2><span id='topic+in_disaggr'></span>

<h3>Description</h3>

<p>The function <code>in_disaggr</code> takes a <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a> or a
<a href="#topic+threeRuleSmooth">threeRuleSmooth</a> object as an input. It produces a comparison between
the benchmarked time series and the high-frequency input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_disaggr(object, type = "changes")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_disaggr_+3A_object">object</code></td>
<td>
<p>an object of class <code>"twoStepsBenchmark"</code> or <code>"threeRuleSmooth"</code>.</p>
</td></tr>
<tr><td><code id="in_disaggr_+3A_type">type</code></td>
<td>
<p><code>"levels"</code>,<code>"levels-rebased"</code>, <code>"changes"</code> or <code>"contributions"</code>.
This defines the type of output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>plot</code> and <code>autoplot</code> can be used on this object to produce
graphics.
</p>


<h3>Value</h3>

<p>a named matrix time series of two columns, one for the response and the other
for the input.
A <code>tscomparison</code> class is added to the object.
</p>


<h3>See Also</h3>

<p><a href="#topic+in_sample">in_sample</a> <a href="#topic+in_revisions">in_revisions</a> <a href="#topic+in_scatter">in_scatter</a>
<a href="#topic+plot.tscomparison">plot.tscomparison</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction,include.rho = TRUE)
plot(in_disaggr(benchmark))
</code></pre>

<hr>
<h2 id='in_revisions'>Comparing two disaggregations together</h2><span id='topic+in_revisions'></span>

<h3>Description</h3>

<p>The function <code>in_revisions</code>takes two inputs, <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a> or a
<a href="#topic+threeRuleSmooth">threeRuleSmooth</a>, and produces a comparison between those.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_revisions(object, object_old, type = "changes")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_revisions_+3A_object">object</code></td>
<td>
<p>an object of class <code>"twoStepsBenchmark"</code> or <code>"threeRuleSmooth"</code>.</p>
</td></tr>
<tr><td><code id="in_revisions_+3A_object_old">object_old</code></td>
<td>
<p>an object of class <code>"twoStepsBenchmark"</code> or <code>"threeRuleSmooth"</code>.</p>
</td></tr>
<tr><td><code id="in_revisions_+3A_type">type</code></td>
<td>
<p><code>"levels"</code>,<code>"levels-rebased"</code>, <code>"changes"</code> or <code>"contributions"</code>.
This defines the type of output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>plot</code> and <code>autoplot</code> can be used on this object to produce
graphics.
</p>


<h3>Value</h3>

<p>a named matrix time series of two columns, one for the response and the other
for the predicted value.
A <code>tscomparison</code> class is added to the object.
</p>


<h3>See Also</h3>

<p><a href="#topic+in_sample">in_sample</a> <a href="#topic+in_disaggr">in_disaggr</a> <a href="#topic+in_scatter">in_scatter</a>
<a href="#topic+plot.tscomparison">plot.tscomparison</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction,include.rho = TRUE)
benchmark2 &lt;- twoStepsBenchmark(turnover,construction,include.differenciation = TRUE)
plot(in_revisions(benchmark,benchmark2))
</code></pre>

<hr>
<h2 id='in_sample'>Producing the in sample predictions of a prais-lm regression</h2><span id='topic+in_sample'></span>

<h3>Description</h3>

<p>The function <code>in_sample</code> returns in-sample predictions from a <a href="#topic+praislm">praislm</a>
or a <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_sample(object, type = "changes")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_sample_+3A_object">object</code></td>
<td>
<p>an object of class <code>"praislm"</code> or <code>"twoStepsBenchmark"</code>.</p>
</td></tr>
<tr><td><code id="in_sample_+3A_type">type</code></td>
<td>
<p><code>"changes"</code> or <code>"levels"</code>. The results are either returned
in changes or in levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>plot</code> and <code>autoplot</code> can be used on this object to produce
graphics.
</p>
<p>The predicted values are different from the fitted values :
</p>

<ul>
<li><p> they are eventually reintegrated.
</p>
</li>
<li><p> they contain the autocorrelated part of the residuals.
</p>
</li></ul>

<p>Besides, changes are relative to the latest benchmark value, not the latest
predicted value.
</p>


<h3>Value</h3>

<p>a named matrix time series of two columns, one for the response and the other
for the predicted value.
A <code>"tscomparison"</code> class is added to the object.
</p>


<h3>See Also</h3>

<p><a href="#topic+in_disaggr">in_disaggr</a> <a href="#topic+in_revisions">in_revisions</a> <a href="#topic+in_scatter">in_scatter</a>
<a href="#topic+plot.tscomparison">plot.tscomparison</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction,include.rho = TRUE)
plot(in_sample(benchmark))
</code></pre>

<hr>
<h2 id='in_scatter'>Comparing the inputs of a praislm regression</h2><span id='topic+in_scatter'></span>

<h3>Description</h3>

<p>The function <code>in_scatter</code> returns low-frequency comparisons of the inputs from
a <a href="#topic+praislm">praislm</a>, a <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a> or <a href="#topic+threeRuleSmooth">threeRuleSmooth</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_scatter(
  object,
  type = if (model.list(object)$include.differenciation) "changes" else "levels"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_scatter_+3A_object">object</code></td>
<td>
<p>an object of class <code>"praislm"</code>, <code>"twoStepsBenchmark"</code>
or <code>"threeRuleSmooth"</code>.</p>
</td></tr>
<tr><td><code id="in_scatter_+3A_type">type</code></td>
<td>
<p><code>"levels"</code> or <code>"changes"</code>.
This defines the type of output. A differencied model can't have a scatterplot
in levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>plot</code> and <code>autoplot</code> can be used on this object to produce
graphics.
</p>


<h3>Value</h3>

<p>a named matrix time series of two or three columns, one for the low-frequency serie
and the others for the high-frequency series (eventually differentiated if
<code>include.differenciation</code> is <code>TRUE</code>).
A <code>tscomparison</code> class is added to the object.
For a <code>twoStepsBenchmark</code> object, this matrix has three columns,
for the low-frequency series, the high-frequency on the regression span and
the high-frequency series on the benchmark span.
</p>
<p>If outlier effects are estimated, the contributions of the outliers are
substracted from the low-frequency series.
</p>


<h3>See Also</h3>

<p><a href="#topic+in_sample">in_sample</a> <a href="#topic+in_disaggr">in_disaggr</a> <a href="#topic+in_revisions">in_revisions</a>
<a href="#topic+plot.tscomparison">plot.tscomparison</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction,include.rho = TRUE)
plot(in_scatter(benchmark))
</code></pre>

<hr>
<h2 id='model.list'>Extracting all the arguments submitted to generate an object</h2><span id='topic+model.list'></span>

<h3>Description</h3>

<p>The function <code>model.list</code> returns the arguments submitted to the function
used to generate the object of class <code>"twoStepsBenchmark"</code>,
<code>"threeRuleSmooth"</code> or <code>"praislm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model.list(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.list_+3A_object">object</code></td>
<td>
<p>an object of class <code>"twoStepsBenchmark"</code>, <code>"threeRuleSmooth"</code>
or <code>"praislm"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are returned as they are after evaluation, model.list doesn't
return a call.
</p>


<h3>Value</h3>

<p>a list containing every evaluated arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction); model.list(benchmark)

</code></pre>

<hr>
<h2 id='outliers'>Extracting the standard error</h2><span id='topic+outliers'></span>

<h3>Description</h3>

<p>The function <code>outliers</code> returns the outliers
from either a <a href="#topic+praislm">praislm</a> or a <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliers(object, as.ts = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outliers_+3A_object">object</code></td>
<td>
<p>a praislm or twoStepsBenchmark object.</p>
</td></tr>
<tr><td><code id="outliers_+3A_as.ts">as.ts</code></td>
<td>
<p>a boolean of length 1. If <code>TRUE</code>, the returned
outliers are returned as a time series with (dim and colnames).
If <code>FALSE</code>, the returned outliers is the named list that was
submitted as a function argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list or a time series, depending of the
argument <code>"as.ts"</code>.
</p>

<hr>
<h2 id='plot.twoStepsBenchmark'>Plotting disaggR objects</h2><span id='topic+plot.twoStepsBenchmark'></span><span id='topic+plot.threeRuleSmooth'></span><span id='topic+plot.tscomparison'></span><span id='topic+autoplot.twoStepsBenchmark'></span><span id='topic+autoplot.threeRuleSmooth'></span><span id='topic+autoplot.tscomparison'></span>

<h3>Description</h3>

<p>Plot methods for objects of class <code>"tscomparison"</code>, <a href="#topic+threeRuleSmooth">threeRuleSmooth</a>
and <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a>. :
</p>

<ul>
<li> <p><code>plot</code> draws a plot with base graphics
</p>
</li>
<li> <p><code>autoplot</code> produces a ggplot object
</p>
</li></ul>

<p>Objects of class <code>tscomparison</code> can be produced with the functions
<a href="#topic+in_sample">in_sample</a>, <a href="#topic+in_scatter">in_scatter</a>, <a href="#topic+in_revisions">in_revisions</a>, <a href="#topic+in_disaggr">in_disaggr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'twoStepsBenchmark'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  start = NULL,
  end = NULL,
  col = default_col_pal(x),
  lty = default_lty_pal(x),
  show.legend = TRUE,
  main = NULL,
  mar = default_margins(main, xlab, ylab),
  ...
)

## S3 method for class 'threeRuleSmooth'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  start = NULL,
  end = NULL,
  col = default_col_pal(x),
  lty = default_lty_pal(x),
  show.legend = TRUE,
  main = NULL,
  mar = default_margins(main, xlab, ylab),
  ...
)

## S3 method for class 'tscomparison'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  start = NULL,
  end = NULL,
  col = default_col_pal(x),
  lty = default_lty_pal(x),
  show.legend = TRUE,
  main = NULL,
  mar = default_margins(main, xlab, ylab),
  ...
)

autoplot.twoStepsBenchmark(
  object,
  xlab = NULL,
  ylab = NULL,
  start = NULL,
  end = NULL,
  col = default_col_pal(object),
  lty = default_lty_pal(object),
  show.legend = TRUE,
  main = NULL,
  mar = NULL,
  theme = default_theme_ggplot(object, start, end, show.legend, xlab, ylab, mar),
  ...
)

autoplot.threeRuleSmooth(
  object,
  xlab = NULL,
  ylab = NULL,
  start = NULL,
  end = NULL,
  col = default_col_pal(object),
  lty = default_lty_pal(object),
  show.legend = TRUE,
  main = NULL,
  mar = NULL,
  theme = default_theme_ggplot(object, start, end, show.legend, xlab, ylab, mar),
  ...
)

autoplot.tscomparison(
  object,
  xlab = NULL,
  ylab = NULL,
  start = NULL,
  end = NULL,
  col = default_col_pal(object),
  lty = default_lty_pal(object),
  show.legend = TRUE,
  main = NULL,
  mar = NULL,
  theme = default_theme_ggplot(object, start, end, show.legend, xlab, ylab, mar),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.twoStepsBenchmark_+3A_x">x</code></td>
<td>
<p>(for the plot method) a tscomparison, a twoStepsBenchmark or a
threeRuleSmooth.</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_xlab">xlab</code></td>
<td>
<p>the title for the x axis</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_ylab">ylab</code></td>
<td>
<p>the title for the y axis</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_start">start</code></td>
<td>
<p>a numeric of length 1 or 2. The start of the plot.</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_end">end</code></td>
<td>
<p>a numeric of length 1 or 2. The end of the plot.</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_col">col</code></td>
<td>
<p>the color scale applied on the plot. Could be a vector of colors,
or a function from n to a color vector of size n.</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_lty">lty</code></td>
<td>
<p>the linetype scales applied on the plot. Could be a vector of
linetypes, or a function from n to a linetypes vector of size n.</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_show.legend">show.legend</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. Should an automatic legend be added to
the plot.</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_main">main</code></td>
<td>
<p>a character of length 1, the title of the plot</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_mar">mar</code></td>
<td>
<p>a numeric of length 4, the margins of the plot specified in the
form <code>c(bottom, left, top, right)</code>.</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_...">...</code></td>
<td>
<p>other arguments passed either to ggplot or plot</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_object">object</code></td>
<td>
<p>(for the autoplot method) a tscomparison, a twoStepsBenchmark
or a threeRuleSmooth.</p>
</td></tr>
<tr><td><code id="plot.twoStepsBenchmark_+3A_theme">theme</code></td>
<td>
<p>a ggplot theme object to replace the default one (only for
autoplot methods)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> for the plot methods, the ggplot object for the autoplot
methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction,include.rho = TRUE)
plot(benchmark)
plot(in_sample(benchmark))
if(require("ggplot2")) {
  autoplot(in_disaggr(benchmark,type="changes"),
           start=c(2015,1),
           end=c(2020,12))
}
plot(in_scatter(benchmark),xlab="title x",ylab="title y")
</code></pre>

<hr>
<h2 id='prais'>Extracting the regression of a twoStepsBenchmark</h2><span id='topic+prais'></span><span id='topic+praislm'></span>

<h3>Description</h3>

<p>prais extracts the regression, which is an object of class <code>"praislm"</code>, of a
twoStepsBenchmark object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prais(x)

praislm(X, y, include.rho, include.differenciation, set_coefficients, cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prais_+3A_x">x</code></td>
<td>
<p>a twoStepsBenchmark</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prais returns an object of class <code>"praislm"</code>.
</p>
<p>The functions that can be used on that class are almost the same than
for the class <code>twoStepsBenchmark</code>.
<code>summary</code>, <code>coefficients</code>, <code>residuals</code> will return the same values.
However, as for <code>fitted.values</code>, the accessor returns the fitted values
of the regression, not the high-frequency, eventually integrated, time series
contained in a twoStepsBenchmark.
</p>
<p>An object of class <code>"praislm"</code> is a list containing the following components :
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a time series, the fitted mean values</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>a named vector of standard errors.</p>
</td></tr>
<tr><td><code>df.residuals</code></td>
<td>
<p>the residual degrees of freedom.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>the autocorrelation coefficients of the residuals. It
is equal to zero if twoStepsBenchmark was called with <code>include.rho=FALSE</code></p>
</td></tr>
<tr><td><code>residuals.decorrelated</code></td>
<td>
<p>the residuals of the model after having been
transformed by rho in a least square model.</p>
</td></tr>
<tr><td><code>fitted.values.decorrelated</code></td>
<td>
<p>the fitted values of the model after
having been transformed by rho in a least square model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction); prais(benchmark)
</code></pre>

<hr>
<h2 id='rePort'>Producing a report</h2><span id='topic+rePort'></span>

<h3>Description</h3>

<p>This function takes an output of the <a href="#topic+reView">reView</a> <span class="pkg">shiny</span> application
and produces an html report with the same outputs than in shiny.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rePort(
  object,
  output_file = NULL,
  launch.browser = if (is.null(output_file)) TRUE else FALSE,
  hfserie_name = NULL,
  lfserie_name = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rePort_+3A_object">object</code></td>
<td>
<p>a twoStepsBenchmark with an univariate hfserie, a reViewOutput,
or a character of length 1 with the path of their RDS file. If a reViewOutput
is chosen, the former new benchmark is taken as the old one.</p>
</td></tr>
<tr><td><code id="rePort_+3A_output_file">output_file</code></td>
<td>
<p>The file in which the html should be saved. If <code>NULL</code>
the file is temporary, and opened in a tab of the default browser.</p>
</td></tr>
<tr><td><code id="rePort_+3A_launch.browser">launch.browser</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>. If TRUE, the output is opened in the
browser. Defaults to TRUE if output_file is NULL.</p>
</td></tr>
<tr><td><code id="rePort_+3A_hfserie_name">hfserie_name</code></td>
<td>
<p>a language object or a character of length 1. The name of
the hfserie, eventually its expression.</p>
</td></tr>
<tr><td><code id="rePort_+3A_lfserie_name">lfserie_name</code></td>
<td>
<p>a language object or a character of length 1. The name of
the lfserie, eventually its expression.</p>
</td></tr>
<tr><td><code id="rePort_+3A_...">...</code></td>
<td>
<p>other arguments passed to rmarkdown::render</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can also directly take a <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a> as an input.
</p>


<h3>See Also</h3>

<p>reView
</p>

<hr>
<h2 id='residuals_extrap'>Extrapolation function for the residuals in a twoStepsBenchmark</h2><span id='topic+residuals_extrap'></span>

<h3>Description</h3>

<p>This function is the rule to extrapolate the low-frequency residuals.
If include.differenciation is <code>TRUE</code>, u(n+1)-u(n) = rho*(u(n)-u(n-1))
Else u(n+1) = rho * u(n)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residuals_extrap(lfresiduals, rho, include.differenciation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_extrap_+3A_lfresiduals">lfresiduals</code></td>
<td>
<p>the residuals to extrapolate</p>
</td></tr>
<tr><td><code id="residuals_extrap_+3A_rho">rho</code></td>
<td>
<p>the autocorrelation parameter of the regression</p>
</td></tr>
<tr><td><code id="residuals_extrap_+3A_include.differenciation">include.differenciation</code></td>
<td>
<p>a boolean, the same as submitted
to twoStepsBenchmark</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric, the extrapolated sequence of residuals, to replace the NA of
the residuals
</p>

<hr>
<h2 id='reUseBenchmark'>Using an estimated benchmark model on another time series</h2><span id='topic+reUseBenchmark'></span>

<h3>Description</h3>

<p>This function reapplies the coefficients and parameters of a benchmark on new
time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reUseBenchmark(hfserie,benchmark,reeval.smoothed.part=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reUseBenchmark_+3A_hfserie">hfserie</code></td>
<td>
<p>the bended time series. If it is a matrix time series, it has to
have the same column names than the <code>hfserie</code> used for the benchmark.</p>
</td></tr>
<tr><td><code id="reUseBenchmark_+3A_benchmark">benchmark</code></td>
<td>
<p>a twoStepsBenchmark object, from which the parameters and
coefficients are taken.</p>
</td></tr>
<tr><td><code id="reUseBenchmark_+3A_reeval.smoothed.part">reeval.smoothed.part</code></td>
<td>
<p>a boolean of length 1. If <code>TRUE</code>, the smoothed
part is reevaluated, hence the aggregated benchmarked series is equal to the
low-frequency series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>reUseBenchmark</code> is primarily meant to be used on a series that is derived
from the previous one, after some modifications that would bias the
estimation otherwise. Working-day adjustment is a good example. Hence, by
default, the smoothed part of the first model isn't reevaluated ; the
aggregated benchmarked series isn't equal to the low-frequency series.
</p>


<h3>Value</h3>

<p><code>reUseBenchmark</code> returns an object of class <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction) 
turnover_modif &lt;- turnover
turnover_modif[2] &lt;- turnover[2]+2
benchmark2 &lt;- reUseBenchmark(turnover_modif,benchmark)
</code></pre>

<hr>
<h2 id='reView'>A shiny app to reView and modify twoStepsBenchmarks</h2><span id='topic+reView'></span>

<h3>Description</h3>

<p>reView allows the user to easily access diverse outputs in order to
review a benchmark object, made with <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a>.
</p>
<p>The <code>hfserie_name</code> and <code>lfserie_name</code> define :
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reView(object, hfserie_name = NULL, lfserie_name = NULL, compare = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reView_+3A_object">object</code></td>
<td>
<p>a twoStepsBenchmark with an univariate hfserie, a reViewOutput,
or a character of length 1 with the path of their RDS file. If a reViewOutput
is chosen, the former new benchmark is taken as the old one.</p>
</td></tr>
<tr><td><code id="reView_+3A_hfserie_name">hfserie_name</code></td>
<td>
<p>a language object or a character of length 1. The name of
the hfserie, eventually its expression.</p>
</td></tr>
<tr><td><code id="reView_+3A_lfserie_name">lfserie_name</code></td>
<td>
<p>a language object or a character of length 1. The name of
the lfserie, eventually its expression.</p>
</td></tr>
<tr><td><code id="reView_+3A_compare">compare</code></td>
<td>
<p>a boolean of length 1, that tells if the outputs of
the old benchmark should be displayed.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> the default file name of the RDS file
</p>
</li>
<li><p> the names of the series in the output <code>call</code> element
</p>
</li></ul>

<p>By default, these are set as defined in their <code>call</code> element.
</p>
<p>The app is made of <span class="pkg">shiny</span> modules in order to make it easy to integrate
it into a wider application. In the module part, every input are defined as
reactive variables.
</p>


<h3>Value</h3>

<p>a list, of class reViewOutput, containing the new benchmark,
the old one, the names of the series and the boolean compare.
This object can also be saved in RDS format through the app.
The reViewOutput object can be displayed as a html report with the same
informations than in shiny, with the <a href="#topic+rePort">rePort</a> method.
</p>


<h3>See Also</h3>

<p><a href="#topic+rePort">rePort</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
reView(twoStepsBenchmark(turnover,construction))

## End(Not run)

</code></pre>

<hr>
<h2 id='rho'>Extracting the autocorrelation parameter</h2><span id='topic+rho'></span>

<h3>Description</h3>

<p>The function <code>rho</code> returns the autocorrelation parameter
from either a <a href="#topic+praislm">praislm</a> or a <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a> object.
If <code>include.rho</code> is <code>FALSE</code>, <code>rho</code> returns zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rho_+3A_object">object</code></td>
<td>
<p>a praislm or twoStepsBenchmark object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a double of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction,include.rho = TRUE); rho(benchmark)

</code></pre>

<hr>
<h2 id='se'>Extracting the standard error</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>The function <code>se</code> returns the standard error of the coefficients
from either a <a href="#topic+praislm">praislm</a> or a <a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_object">object</code></td>
<td>
<p>a praislm or twoStepsBenchmark object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric, that is named the same way that the coefficients are.
If some coefficients are set by the user, they return <code>NA</code> as for
their standard error.
</p>

<hr>
<h2 id='smoothed.part'>Extracting the smoothed part of a twoStepsBenchmark</h2><span id='topic+smoothed.part'></span>

<h3>Description</h3>

<p>The function <code>smoothed.part</code> returns the smoothed part of a
<a href="#topic+twoStepsBenchmark">twoStepsBenchmark</a>. It derives from the residuals of the
aggregated regression, with some differences :
</p>

<ul>
<li><p> it is eventually integrated if <code>include.differenciation=TRUE</code>.
</p>
</li>
<li><p> it is extrapolated to match the domain window.
</p>
</li>
<li><p> it is smoothed using the <a href="#topic+bflSmooth">bflSmooth</a> function.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>smoothed.part(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothed.part_+3A_object">object</code></td>
<td>
<p>a twoStepsBenchmark object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a time series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- twoStepsBenchmark(turnover,construction); smoothed.part(benchmark)

</code></pre>

<hr>
<h2 id='smoothed.rate'>Extracting the rate of a threeRuleSmooth</h2><span id='topic+smoothed.rate'></span>

<h3>Description</h3>

<p>The function <code>smoothed.rate</code> returns the high-frequency rate
from a <a href="#topic+threeRuleSmooth">threeRuleSmooth</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothed.rate(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothed.rate_+3A_object">object</code></td>
<td>
<p>a threeRuleSmooth object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>benchmark &lt;- threeRuleSmooth(turnover,construction); smoothed.rate(benchmark)

</code></pre>

<hr>
<h2 id='threeRuleSmooth'>Bends a time series with a lower frequency one by smoothing their rate</h2><span id='topic+threeRuleSmooth'></span>

<h3>Description</h3>

<p>threeRuleSmooth bends a time series with a time series of a lower
frequency. The procedure involved is a proportional Denton benchmark.
</p>
<p>Therefore, the resulting time series is the product of the high frequency input
with a smoothed rate. This latter is extrapolated through an arithmetic
sequence.
</p>
<p>The resulting time series is equal to the low-frequency series after aggregation
within the benchmark window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threeRuleSmooth(
  hfserie,
  lfserie,
  start.benchmark = NULL,
  end.benchmark = NULL,
  start.domain = NULL,
  end.domain = NULL,
  start.delta.rate = NULL,
  end.delta.rate = NULL,
  set.delta.rate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threeRuleSmooth_+3A_hfserie">hfserie</code></td>
<td>
<p>the bended time series. It can be a matrix time series.</p>
</td></tr>
<tr><td><code id="threeRuleSmooth_+3A_lfserie">lfserie</code></td>
<td>
<p>a time series whose frequency divides the frequency of
<code>hfserie</code>.</p>
</td></tr>
<tr><td><code id="threeRuleSmooth_+3A_start.benchmark">start.benchmark</code></td>
<td>
<p>an optional start for <code>lfserie</code> to bend <code>hfserie</code>.
Should be a numeric of length 1 or 2, like a window for <code>lfserie</code>. If NULL,
the start is defined by lfserie's window.</p>
</td></tr>
<tr><td><code id="threeRuleSmooth_+3A_end.benchmark">end.benchmark</code></td>
<td>
<p>an optional end for <code>lfserie</code> to bend <code>hfserie</code>.
Should be a numeric of length 1 or 2, like a window for <code>lfserie</code>. If NULL,
the start is defined by lfserie's window.</p>
</td></tr>
<tr><td><code id="threeRuleSmooth_+3A_start.domain">start.domain</code></td>
<td>
<p>an optional start of the output high-frequency series. It
also defines the smoothing window :
The low-frequency residuals will be extrapolated until they contain the
smallest low-frequency window that is around the high-frequency domain
window.
Should be a numeric of length 1 or 2, like a window for <code>hfserie</code>. If NULL,
the start is defined by hfserie's window.</p>
</td></tr>
<tr><td><code id="threeRuleSmooth_+3A_end.domain">end.domain</code></td>
<td>
<p>an optional end of the output high-frequency series. It also
defines the smoothing window :
The low-frequency residuals will be extrapolated until they contain the
smallest low-frequency window that is around the high-frequency domain
window.</p>
</td></tr>
<tr><td><code id="threeRuleSmooth_+3A_start.delta.rate">start.delta.rate</code></td>
<td>
<p>an optional start for the mean of the rate difference.
It is required as a common difference for the arithmetical extrapolation of
the rate.
Should be a numeric of length 1 or 2, like a window for <code>lfserie</code>. If NULL,
the start is defined by lfserie's window.</p>
</td></tr>
<tr><td><code id="threeRuleSmooth_+3A_end.delta.rate">end.delta.rate</code></td>
<td>
<p>an optional end for the mean of the rate difference.
It is required as a common difference for the arithmetical extrapolation of
the rate.
Should be a numeric of length 1 or 2, like a window for <code>lfserie</code>. If NULL,
the end is defined by lfserie's window.</p>
</td></tr>
<tr><td><code id="threeRuleSmooth_+3A_set.delta.rate">set.delta.rate</code></td>
<td>
<p>an optional double, that allows the user to set the
delta mean instead of using a mean.</p>
</td></tr>
<tr><td><code id="threeRuleSmooth_+3A_...">...</code></td>
<td>
<p>if the dots contain a cl item, its value overwrites the value
of the returned call. This feature allows to build wrappers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to smooth the rate, threeRuleSmooth calls <a href="#topic+bflSmooth">bflSmooth</a>
and uses a modified and extrapolated version of hfserie as weights :
</p>

<ul>
<li><p> only the full cycles are kept
</p>
</li>
<li><p> the first and last full cycles are replicated respectively backwards and
forwards to fill the domain window.
</p>
</li></ul>



<h3>Value</h3>

<p>threeRuleSmooth returns an object of class <code>"threeRuleSmooth"</code>.
</p>
<p>The functions <code>plot</code> and <code>autoplot</code> (the generic from <span class="pkg">ggplot2</span>) produce
graphics of the benchmarked series and the bending series.
The functions <a href="#topic+in_disaggr">in_disaggr</a>, <a href="#topic+in_revisions">in_revisions</a>, <a href="#topic+in_scatter">in_scatter</a>
produce various comparisons on which plot and autoplot can also be used.
</p>
<p>The generic accessor functions <code>as.ts</code>, <code>model.list</code>, <code>smoothed.rate</code> extract
various useful features of the returned value.
</p>
<p>An object of class <code>"threeRuleSmooth"</code> is a list containing the following
components :
</p>
<table>
<tr><td><code>benchmarked.serie</code></td>
<td>
<p>a time series, that is the result of the
benchmark.</p>
</td></tr>
<tr><td><code>lfrate</code></td>
<td>
<p>a time series, that is the low-frequency rate of the
threeRuleSmooth.</p>
</td></tr>
<tr><td><code>smoothed.rate</code></td>
<td>
<p>the smoothed rate of the threeRuleSmooth.</p>
</td></tr>
<tr><td><code>hfserie.as.weights</code></td>
<td>
<p>the modified and extrapolated hfserie (see
details).</p>
</td></tr>
<tr><td><code>delta.rate</code></td>
<td>
<p>the low-frequency delta of the rate, used to extrapolate
the low-frequenccy rate time series. It is estimated as the mean value in
the specified window.</p>
</td></tr>
<tr><td><code>model.list</code></td>
<td>
<p>a list containing all the arguments submitted to the
function.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## How to use threeRuleSmooth

smooth &lt;- threeRuleSmooth(hfserie = turnover,
                          lfserie = construction)
as.ts(smooth)
coef(smooth)
summary(smooth)
library(ggplot2)
autoplot(in_disaggr(smooth))

</code></pre>

<hr>
<h2 id='turnover'>Turnover indicator in construction</h2><span id='topic+turnover'></span>

<h3>Description</h3>

<p>An monthly time series containing the turnover indicator in construction
from january 2000 to may 2020, as retrieved the 08/12/2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnover
</code></pre>


<h3>Format</h3>

<p>A time series of frequency 12
</p>


<h3>Source</h3>

<p><a href="https://www.insee.fr/fr/statistiques/4636032">https://www.insee.fr/fr/statistiques/4636032</a>
</p>

<hr>
<h2 id='turnover_catering'>Turnover indicator in accommodation and food services</h2><span id='topic+turnover_catering'></span>

<h3>Description</h3>

<p>An monthly time series containing the turnover indicator in accommodation and food services
from january 1999 to april 2022, as retrieved the 04/07/2022.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turnover_catering
</code></pre>


<h3>Format</h3>

<p>A time series of frequency 12
</p>


<h3>Source</h3>

<p><a href="https://www.insee.fr/en/statistiques/serie/010543406">https://www.insee.fr/en/statistiques/serie/010543406</a>
</p>

<hr>
<h2 id='twoStepsBenchmark'>Regress and bends a time series with a lower frequency one</h2><span id='topic+twoStepsBenchmark'></span><span id='topic+annualBenchmark'></span>

<h3>Description</h3>

<p>twoStepsBenchmark bends a time series with a time series of a lower frequency.
The procedure involved is a Prais-Winsten regression, then an additive
Denton benchmark.
</p>
<p>Therefore, the resulting time series is the sum of a regression fit and of a
smoothed part. The smoothed part minimizes the sum of squares of its
differences.
</p>
<p>The resulting time series is equal to the low-frequency series after aggregation
within the benchmark window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoStepsBenchmark(hfserie,lfserie,include.differenciation=FALSE,include.rho=FALSE,
                  set.coeff=NULL,set.const=NULL,
                  start.coeff.calc=NULL,end.coeff.calc=NULL,
                  start.benchmark=NULL,end.benchmark=NULL,
                  start.domain=NULL,end.domain=NULL,outliers=NULL,
                  ...)


annualBenchmark(hfserie,lfserie,
                include.differenciation=FALSE,include.rho=FALSE,
                set.coeff=NULL,set.const=NULL,
                start.coeff.calc=start(lfserie)[1L],
                end.coeff.calc=end(lfserie)[1L],
                start.benchmark=start(lfserie)[1L],
                end.benchmark=end.coeff.calc[1L]+1L,
                start.domain=start(hfserie),
                end.domain=c(end.benchmark[1L]+2L,frequency(hfserie)),
                outliers=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoStepsBenchmark_+3A_hfserie">hfserie</code></td>
<td>
<p>the bended time series. It can be a matrix time series.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_lfserie">lfserie</code></td>
<td>
<p>a time series whose frequency divides the frequency of <code>hfserie</code>.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_include.differenciation">include.differenciation</code></td>
<td>
<p>a boolean of length 1. If <code>TRUE</code>, <code>lfserie</code> and
<code>hfserie</code> are differentiated before the estimation of the regression.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_include.rho">include.rho</code></td>
<td>
<p>a boolean of length 1. If <code>TRUE</code>, the regression includes
an autocorrelation parameter for the residuals. The applied procedure is a
Prais-Winsten estimation.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_set.coeff">set.coeff</code></td>
<td>
<p>an optional numeric, that allows the user to set the
regression coefficients instead of evaluating them.
If hfserie is not a matrix, set.coeff can be an unnamed numeric of length 1.
Otherwise, <code>set.coeff</code> has to be a named numeric, which will set the
corresponding coefficients instead of evaluating them.
Each column name of hfserie and each outlier set with the <code>outlier</code> arg
initialize a coefficient with the same name, that can be set through set.coeff.
The default name for a non-matrix time series is then <code>"hfserie"</code>,
By example, a LS2003 and the time series can be set using
<code>set.coeff=c(hfserie=3,LS2003=1)</code>.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_set.const">set.const</code></td>
<td>
<p>an optional numeric of length 1, that sets the regression
constant.
The constant is actually an automatically added column to <code>hfserie</code>. Using
<code>set.constant=3</code> is equivalent to using <code>set.coeff=c(constant=3)</code>.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_start.coeff.calc">start.coeff.calc</code></td>
<td>
<p>an optional start for the estimation of the
coefficients of the regression.
Should be a numeric of length 1 or 2, like a window for <code>lfserie</code>. If NULL,
the start is defined by lfserie's window.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_end.coeff.calc">end.coeff.calc</code></td>
<td>
<p>an optional end for the estimation of the coefficients
of the regression.
Should be a numeric of length 1 or 2, like a window for <code>lfserie</code>. If NULL,
the end is defined by lfserie's window.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_start.benchmark">start.benchmark</code></td>
<td>
<p>an optional start for <code>lfserie</code> to bend <code>hfserie</code>.
Should be a numeric of length 1 or 2, like a window for <code>lfserie</code>. If NULL,
the start is defined by lfserie's window.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_end.benchmark">end.benchmark</code></td>
<td>
<p>an optional end for <code>lfserie</code> to bend <code>hfserie</code>.
Should be a numeric of length 1 or 2, like a window for <code>lfserie</code>. If NULL,
the start is defined by lfserie's window.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_start.domain">start.domain</code></td>
<td>
<p>an optional for the output high-frequency series. It also
defines the smoothing window :
The low-frequency residuals will be extrapolated until they contain the
smallest low-frequency window that is around the high-frequency domain
window.
Should be a numeric of length 1 or 2, like a window for <code>hfserie</code>. If NULL,
the start is defined by hfserie's window.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_end.domain">end.domain</code></td>
<td>
<p>an optional end for the output high-frequency series. It
also defines the smoothing window :
The low-frequency residuals will be extrapolated until they contain the
smallest low-frequency window that is around the high-frequency domain
window.
Should be a numeric of length 1 or 2, like a window for <code>hfserie</code>. If NULL,
the start is defined by hfserie's window.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_outliers">outliers</code></td>
<td>
<p>an optional named list of numeric vectors, whose pattern is
like <code>list(AO2008T2=c(0,0,3,2),LS2002=c(0.1,0.1,0.1,0.1))</code> where :
</p>

<ul>
<li> <p><code>"AO"</code> stands for additive outlier or <code>"LS"</code> for level shift
</p>
</li>
<li><p> The integer that follows stands for the outlier starting year
</p>
</li>
<li><p> an optional integer, preceded by the letter T, stands for the low-frequency
cycle of the outlier start.
</p>
</li>
<li><p> The numeric vector values stands for the disaggregated value of the outlier
and its length must be a multiple of hf / lf
</p>
</li></ul>

<p>The outliers coefficients are evaluated though the regression process, like
any coefficient. Therefore, if any outlier is outside of the coefficient
calculation window, it should be fixed using <code>set.coeff</code>.</p>
</td></tr>
<tr><td><code id="twoStepsBenchmark_+3A_...">...</code></td>
<td>
<p>if the dots contain a cl item, its value overwrites the value of
the returned call. This feature allows to build wrappers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>annualBenchmark is a wrapper of the main function, that applies more specifically
to annual series, and changes the default window parameters to the ones
that are commonly used by quarterly national accounts.
</p>


<h3>Value</h3>

<p>twoStepsBenchark returns an object of class &quot;<code>twoStepsBenchmark</code>&quot;.
</p>
<p>The function <code>summary</code> can be used to obtain and print a summary of the
regression used by the benchmark.
The functions <code>plot</code> and <code>autoplot</code> (the generic from <span class="pkg">ggplot2</span>) produce
graphics of the benchmarked serie and the bending serie.
The functions <a href="#topic+in_disaggr">in_disaggr</a>, <a href="#topic+in_revisions">in_revisions</a>, <a href="#topic+in_scatter">in_scatter</a>
produce comparisons on which plot and autoplot can also be used.
</p>
<p>The generic accessor functions <code>as.ts</code>, <code>prais</code>, <code>coefficients</code>, <code>residuals</code>,
<code>fitted.values</code>, <code>model.list</code>, <code>se</code>, <code>rho</code> extract various useful features of
the returned value.
</p>
<p>An object of class &quot;<code>twoStepsBenchmark</code>&quot; is a list containing the following
components :
</p>
<table>
<tr><td><code>benchmarked.serie</code></td>
<td>
<p>a time series, that is the result of the
benchmark. It is equal to <code>fitted.values + smoothed.part</code>.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a time series, that is the high-frequency series as it
is after having applied the regression coefficients. Compared to the fitted
values of the regression, which can be retrieved inside the regression
component, it has a high-frequency time series and can eventually be
integrated if <code>include.differenciation</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>regression</code></td>
<td>
<p>an object of class praislm, it is the regression on which
relies the benchmark. It can be extracted with the function <a href="#topic+prais">prais</a></p>
</td></tr>
<tr><td><code>smoothed.part</code></td>
<td>
<p>the smoothed part of the two-steps benchmark. It is
the smoothed difference between the <code>fitted.values</code> and lfserie.</p>
</td></tr>
<tr><td><code>model.list</code></td>
<td>
<p>a list containing all the arguments submitted to the
function.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call (either of twoStepsBenchmark or
annualBenchmark)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## How to use annualBenchmark or twoStepsBenchark

benchmark &lt;- twoStepsBenchmark(hfserie = turnover,
                               lfserie = construction,
                               include.differenciation = TRUE)
as.ts(benchmark)
coef(benchmark)
summary(benchmark)
library(ggplot2)
autoplot(in_sample(benchmark))

## How to manually set the coefficient

benchmark2 &lt;- twoStepsBenchmark(hfserie = turnover,
                                lfserie = construction,
                                include.differenciation = TRUE,
                                set.coeff = 0.1)
coef(benchmark2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
