<!DOCTYPE html><html><head><title>Help for package happign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {happign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#are_queryable'><p>are_queryable</p></a></li>
<li><a href='#cog_2023'><p>COG 2023</p></a></li>
<li><a href='#get_apicarto_cadastre'><p>Apicarto Cadastre</p></a></li>
<li><a href='#get_apicarto_codes_postaux'><p>Apicarto Codes Postaux</p></a></li>
<li><a href='#get_apicarto_gpu'><p>Apicarto module Geoportail de l'urbanisme</p></a></li>
<li><a href='#get_apicarto_rpg'><p>Apicarto RPG (Registre Parcellaire Graphique)</p></a></li>
<li><a href='#get_apicarto_viticole'><p>Apicarto Appellations viticoles</p></a></li>
<li><a href='#get_apikeys'><p>List of all API keys from IGN</p></a></li>
<li><a href='#get_last_news'><p>Print latest news from geoservice website</p></a></li>
<li><a href='#get_layers_metadata'><p>Metadata for one couple of apikey and data_type</p></a></li>
<li><a href='#get_location_info'><p>Retrieve additional information for wms layer</p></a></li>
<li><a href='#get_raw_lidar'><p>Download raw LIDAR data</p></a></li>
<li><a href='#get_wfs'><p>Download WFS layer</p></a></li>
<li><a href='#get_wfs_attributes'><p>get_wfs_attributes</p></a></li>
<li><a href='#get_wms_raster'><p>Download WMS raster layer</p></a></li>
<li><a href='#get_wmts'><p>Download WMTS raster tiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>R Interface to 'IGN' Web Services</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Carteron &lt;carteronpaul@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Automatic open data acquisition from resources of IGN
    ('Institut National de Information Geographique et forestiere')
    (<a href="https://www.ign.fr/">https://www.ign.fr/</a>). Available datasets include various types of
    raster and vector data, such as digital elevation models, state
    borders, spatial databases, cadastral parcels, and more. There also
    access to point clouds data ('LIDAR') and specifics API
    (<a href="https://apicarto.ign.fr/api/doc/">https://apicarto.ign.fr/api/doc/</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/paul-carteron">https://github.com/paul-carteron</a>,
<a href="https://paul-carteron.github.io/happign/">https://paul-carteron.github.io/happign/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paul-carteron/happign/issues">https://github.com/paul-carteron/happign/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>archive, dplyr, jsonlite, httr2, methods, sf (&ge; 1.0-7),
terra, units, xml2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, httptest2, knitr, rmarkdown, testthat (&ge; 3.0.0), tmap</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11, GDAL (&gt;= 2.0.1), GEOS (&gt;= 3.4.0), PROJ (&gt;=
4.8.0), sqlite3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-29 08:17:42 UTC; PaulCarteron</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Carteron <a href="https://orcid.org/0000-0002-6942-6662"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-29 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='are_queryable'>are_queryable</h2><span id='topic+are_queryable'></span>

<h3>Description</h3>

<p>Check if a wms layer is queryable with GetFeatureInfo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_queryable(apikey)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_queryable_+3A_apikey">apikey</code></td>
<td>
<p>API key from <code>get_apikeys()</code> or directly
from the <a href="https://geoservices.ign.fr/services-web-experts">IGN website</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> containing the name of the queryable layers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_location_info">get_location_info()</a></code>
</p>

<hr>
<h2 id='cog_2023'>COG 2023</h2><span id='topic+cog_2023'></span>

<h3>Description</h3>

<p>A dataset containing insee code and wording of commune as of January 1, 2023. COG mean
Code Officiel GÃ©ographique
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cog_2023
</code></pre>


<h3>Format</h3>



<h4><code>cog_2023</code></h4>

<p>A data frame with 34990 rows and 2 columns:
</p>

<dl>
<dt>COM</dt><dd><p>insee code</p>
</dd>
<dt>LIBELLE</dt><dd><p>Name of commune</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://www.insee.fr/fr/information/2115000">https://www.insee.fr/fr/information/2115000</a>
</p>

<hr>
<h2 id='get_apicarto_cadastre'>Apicarto Cadastre</h2><span id='topic+get_apicarto_cadastre'></span>

<h3>Description</h3>

<p>Implementation of the cadastre module from the
<a href="https://apicarto.ign.fr/api/doc/cadastre">IGN's apicarto</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_apicarto_cadastre(x,
                      type = "parcelle",
                      source = "PCI",
                      section = list(NULL),
                      numero = list(NULL),
                      code_arr = list(NULL),
                      code_abs = list(NULL),
                      code_com = list(NULL),
                      dTolerance = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_apicarto_cadastre_+3A_x">x</code></td>
<td>
<p>It can be a shape, insee codes or departement codes :
</p>

<ul>
<li><p> Shape : must be an object of class <code>sf</code> or <code>sfc</code>.
</p>
</li>
<li><p> Code insee : must be a <code>character</code> of length 5
</p>
</li>
<li><p> Code departement : must be a <code>character</code> of length  2 or 3 (DOM-TOM)
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_apicarto_cadastre_+3A_type">type</code></td>
<td>
<p>A <code>character</code> from <code>"parcelle"</code>, <code>"commune"</code>, <code>"feuille"</code>,
<code>"division"</code>, <code>"localisant"</code></p>
</td></tr>
<tr><td><code id="get_apicarto_cadastre_+3A_source">source</code></td>
<td>
<p>Can be &quot;BDP&quot; for BD Parcellaire or &quot;PCI&quot; for Parcellaire express.
See detail for more info.</p>
</td></tr>
<tr><td><code id="get_apicarto_cadastre_+3A_section">section</code></td>
<td>
<p>A <code>character</code> of length 2</p>
</td></tr>
<tr><td><code id="get_apicarto_cadastre_+3A_numero">numero</code></td>
<td>
<p>A <code>character</code> of length 4</p>
</td></tr>
<tr><td><code id="get_apicarto_cadastre_+3A_code_arr">code_arr</code></td>
<td>
<p>A <code>character</code> corresponding to district code for Paris,
Lyon, Marseille</p>
</td></tr>
<tr><td><code id="get_apicarto_cadastre_+3A_code_abs">code_abs</code></td>
<td>
<p>A <code>character</code> corresponding to the code of absorbed commune.
This prefix is useful to differentiate between communes that have merged</p>
</td></tr>
<tr><td><code id="get_apicarto_cadastre_+3A_code_com">code_com</code></td>
<td>
<p>A <code>character</code> of length 5 corresponding to the commune code. Only use with
<code>type = "division"</code> or <code>type = "feuille"</code></p>
</td></tr>
<tr><td><code id="get_apicarto_cadastre_+3A_dtolerance">dTolerance</code></td>
<td>
<p>numeric; Complex shape cannot be handle by API; using <code>dTolerance</code>
allow to simplify them. See <code>?sf::st_simplify</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>x</code>, <code>section</code>, <code>numero</code>, <code>code_arr</code>, <code>code_abs</code>, <code>code_com</code> can take vector of character.
In this case vector recycling is done. See the example section below.
</p>
<p><code>source</code>: BD Parcellaire is a discontinued product. Its use is no longer
recommended because it is no longer updated. The use of PCI Express is
strongly recommended and will become mandatory. More information on the
comparison of this two products can be found
<a href="https://geoservices.ign.fr/sites/default/files/2021-07/Comparatif_PEPCI_BDPARCELLAIRE.pdf">here</a>
</p>


<h3>Value</h3>

<p>Object of class <code>sf</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)

# shape from the town of penmarch
penmarch &lt;- read_sf(system.file("extdata/penmarch.shp", package = "happign"))

# get commune borders
## from shape
penmarch_borders &lt;- get_apicarto_cadastre(penmarch, type = "commune")

## from insee_code
border &lt;- get_apicarto_cadastre("29158", type = "commune")
borders &lt;- get_apicarto_cadastre(c("29158", "29165"), type = "commune")

# get cadastral parcels
## from shape
parcels &lt;- get_apicarto_cadastre(penmarch, section = "AX")

## from insee code
parcels &lt;- get_apicarto_cadastre("29158")

# Use parameter recycling
## get sections "AX" parcels from multiple insee_code
parcels &lt;- get_apicarto_cadastre(c("29158", "29165"), section = "AX")

## get parcels numbered "0001", "0010" of section "AX" and "BR"
section &lt;- c("AX", "BR")
numero &lt;- rep(c("0001", "0010"), each = 2)
parcels &lt;- get_apicarto_cadastre("29158", section = section, numero = numero)

## generalization with expand.grid
params &lt;- expand.grid(code_insee = c("29158", "29165"),
                      section = c("AX", "BR"),
                      numero = c("0001", "0010"),
                      stringsAsFactors = FALSE)
parcels &lt;- get_apicarto_cadastre(params$code_insee,
                                 section = params$section,
                                 numero = params$numero)


## End(Not run)

</code></pre>

<hr>
<h2 id='get_apicarto_codes_postaux'>Apicarto Codes Postaux</h2><span id='topic+get_apicarto_codes_postaux'></span>

<h3>Description</h3>

<p>Implementation of the &quot;Codes Postaux&quot; module from the
<a href="https://apicarto.ign.fr/api/doc/codes-postaux">IGN's apicarto</a>. This
API give information about commune from postal code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_apicarto_codes_postaux(code_post)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_apicarto_codes_postaux_+3A_code_post">code_post</code></td>
<td>
<p><code>character</code> corresponding to the postal code of a commune</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

info_commune &lt;- get_apicarto_codes_postaux("29760")

code_post &lt;- c("29760", "29260")
info_communes &lt;- get_apicarto_codes_postaux(code_post)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_apicarto_gpu'>Apicarto module Geoportail de l'urbanisme</h2><span id='topic+get_apicarto_gpu'></span>

<h3>Description</h3>

<p>Apicarto module Geoportail de l'urbanisme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_apicarto_gpu(x,
                 ressource = "zone-urba",
                 categorie = list(NULL),
                 dTolerance = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_apicarto_gpu_+3A_x">x</code></td>
<td>
<p>An object of class <code>sf</code> or <code>sfc</code> for geometric intersection. Otherwise
a <code>character</code> corresponding to <strong>GPU partition</strong> or
<strong>insee code</strong> when <code>ressource</code> is set to <code>municipality</code>.</p>
</td></tr>
<tr><td><code id="get_apicarto_gpu_+3A_ressource">ressource</code></td>
<td>
<p>A character from this list : &quot;document&quot;, &quot;zone-urba&quot;,
&quot;secteur-cc&quot;, &quot;prescription-surf&quot;, &quot;prescription-lin&quot;, &quot;prescription-pct&quot;,
&quot;info-surf&quot;, &quot;info-lin&quot;, &quot;info-pct&quot;. See detail for more info.</p>
</td></tr>
<tr><td><code id="get_apicarto_gpu_+3A_categorie">categorie</code></td>
<td>
<p>public utility easement according to the
<a href="https://www.geoinformations.developpement-durable.gouv.fr/nomenclature-nationale-des-sup-r1082.html">national nomenclature</a></p>
</td></tr>
<tr><td><code id="get_apicarto_gpu_+3A_dtolerance">dTolerance</code></td>
<td>
<p>numeric; Complex shape cannot be handle by API; using <code>dTolerance</code> allow to simplify them. See <code>?sf::st_simplify</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>/!\ For the moment the API cannot returned more than 5000 features.</strong>
</p>
<p>All existing parameters for <code>ressource</code> :
</p>

<ul>
<li><p> &quot;municipality : information on the communes (commune with RNU, merged commune)
</p>
</li>
<li><p> &quot;document' : information on urban planning documents (POS, PLU, PLUi, CC, PSMV)
</p>
</li>
<li><p> &quot;zone-urba&quot; : zoning of urban planning documents,
</p>
</li>
<li><p> &quot;secteur-cc&quot; : communal map sectors
</p>
</li>
<li><p> &quot;prescription-surf&quot;, &quot;prescription-lin&quot;, &quot;prescription-pct&quot; : its's a constraint or a possibility indicated in an urban planning document (PLU, PLUi, ...)
</p>
</li>
<li><p> &quot;info-surf&quot;, &quot;info-lin&quot;, &quot;info-pct&quot; : its's an information indicated in an urban planning document (PLU, PLUi, ...)
</p>
</li>
<li><p> &quot;acte-sup&quot; : act establishing the SUP
</p>
</li>
<li><p> &quot;generateur-sup-s&quot;, &quot;generateur-sup-l&quot;, &quot;generateur-sup-p&quot; : an entity (site or monument, watercourse, water catchment, electricity or gas distribution of electricity or gas, etc.) which generates on the surrounding SUP  (of passage, alignment, protection, land reservation, etc.)
</p>
</li>
<li><p> &quot;assiette-sup-s&quot;, &quot;assiette-sup-l&quot;, &quot;assiette-sup-p&quot; : spatial area to which SUP it applies.
</p>
</li></ul>



<h3>Value</h3>

<p>A object of class <code>sf</code> or <code>df</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)

# find if commune is under the RNU (national urbanism regulation)
rnu &lt;- get_apicarto_gpu("93014", "municipality")
rnu$is_rnu

# get urbanism document
x &lt;- get_apicarto_cadastre("93014", "commune")
document &lt;- get_apicarto_gpu(x, ressource = "document")
partition &lt;- document$partition

# get gpu features
## from shape
gpu &lt;- get_apicarto_gpu(x, ressource = "zone-urba")

## from partition
gpu &lt;- get_apicarto_gpu("DU_93014", ressource = "zone-urba")

# example : all prescriptions
ressources &lt;- c("prescription-surf",
                "prescription-lin",
                "prescription-pct")
prescriptions &lt;- get_apicarto_gpu("DU_93014",
                                  ressource = ressources)

# example : public utility servitude (SUP) assiette
assiette_sup_s &lt;- get_apicarto_gpu(x, ressource = "assiette-sup-s")
protection_forest &lt;- get_apicarto_gpu(x,
                                      ressource = "assiette-sup-s",
                                      categorie = "A7")

# example : public utility servitude (SUP) generateur
## /!\ a generator can justify several assiette
ressources &lt;- c("generateur-sup-p",
                "generateur-sup-l",
                "generateur-sup-s")
all_gen &lt;- get_apicarto_gpu(x, ressource = ressources)


## End(Not run)
</code></pre>

<hr>
<h2 id='get_apicarto_rpg'>Apicarto RPG (Registre Parcellaire Graphique)</h2><span id='topic+get_apicarto_rpg'></span>

<h3>Description</h3>

<p>Implementation of the &quot;RPG&quot; module from the
<a href="https://apicarto.ign.fr/api/doc/rpg">IGN's apicarto</a>. This function
is a wrapper around version 1 and 2 of the API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_apicarto_rpg(x,
                 annee,
                 code_cultu = list(NULL),
                 dTolerance = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_apicarto_rpg_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code>. Needs to be located in France.</p>
</td></tr>
<tr><td><code id="get_apicarto_rpg_+3A_annee">annee</code></td>
<td>
<p>numeric between 2010 and 2021</p>
</td></tr>
<tr><td><code id="get_apicarto_rpg_+3A_code_cultu">code_cultu</code></td>
<td>
<p>character corresponding to code culture, see detail.</p>
</td></tr>
<tr><td><code id="get_apicarto_rpg_+3A_dtolerance">dTolerance</code></td>
<td>
<p>numeric; tolerance parameter. The value of <code>dTolerance</code>
must be specified in meters, see detail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since 2014 the culture code has changed its format. Before it should be
a value ranging from &quot;01&quot; to &quot;28&quot;, after it should be a trigram (ex : &quot;MIE&quot;).
More info can be found at the
<a href="https://apicarto.ign.fr/api/doc/pdf/docUser_moduleRPG.pdf">documentation page</a>
</p>
<p><code>dTolerance</code> is needed when geometry are too complex. Its the same parameter
found in <code>sf::st_simlplify</code>.
</p>


<h3>Value</h3>

<p><code>list</code> or object of class <code>sf</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)

penmarch &lt;- get_apicarto_cadastre("29158", type = "commune")

# failure with too complex geom
rpg &lt;- get_apicarto_rpg(penmarch, 2020)

# avoid complex data by setting dTolerance
rpg &lt;- get_apicarto_rpg(penmarch, 2020, dTolerance = 10)

# multiple years after 2014
rpg &lt;- get_apicarto_rpg(x, 2020:2021, dTolerance = 10)

# years before and after 2014
# list is returned because attributs are different
rpg &lt;- get_apicarto_rpg(x, c(2010, 2021), dTolerance = 10)

# filter by code_cultu
rpg &lt;- get_apicarto_rpg(x, 2021, code_cultu = "MIE", dTolerance = 10)

# all "MIE" from 2020 and all "PPH" from 2021
rpg &lt;- get_apicarto_rpg(x, 2020:2021, code_cultu = c("MIE", "PPH"), dTolerance = 10)

# vectorization : all "MIE" from 2020 and 2021
rpg &lt;- get_apicarto_rpg(x, 2020:2021, code_cultu = "MIE", dTolerance = 10)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_apicarto_viticole'>Apicarto Appellations viticoles</h2><span id='topic+get_apicarto_viticole'></span>

<h3>Description</h3>

<p>Implementation of the &quot;Appellations viticoles&quot; module from the
<a href="https://apicarto.ign.fr/api/doc/codes-postaux">IGN's apicarto</a>. The module
uses a database maintained by FranceAgriMer. This database includes :
appellation d'origine contrÃ´lÃ©e (AOC) areas, protected geographical indication areas (IGP)
and wine growing areas without geographical indications (VSIG)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_apicarto_viticole(x,
                      dTolerance = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_apicarto_viticole_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code>. Needs to be located in France.</p>
</td></tr>
<tr><td><code id="get_apicarto_viticole_+3A_dtolerance">dTolerance</code></td>
<td>
<p>numeric; tolerance parameter. The value of <code>dTolerance</code>
must be specified in meters, see <code>?sf::st_simplify</code> for more info.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>/!\ For the moment the API cannot returned more than 1000 features.</strong>
</p>


<h3>Value</h3>

<p>Object of class <code>sf</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)

penmarch &lt;- read_sf(system.file("extdata/penmarch.shp", package = "happign"))

VSIG &lt;- get_apicarto_viticole(penmarch)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_apikeys'>List of all API keys from IGN</h2><span id='topic+get_apikeys'></span>

<h3>Description</h3>

<p>All API keys are manually extract from this
<a href="https://geoservices.ign.fr/documentation/services/tableau_ressources">table</a>
provided by IGN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_apikeys()
</code></pre>


<h3>Value</h3>

<p><code>character</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# One API key
get_apikeys()[1]

# All API keys
get_apikeys()

## End(Not run)

</code></pre>

<hr>
<h2 id='get_last_news'>Print latest news from geoservice website</h2><span id='topic+get_last_news'></span>

<h3>Description</h3>

<p>This function is a wrapper around the RSS feed of the
geoservice site to get the latest information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_last_news()
</code></pre>


<h3>Value</h3>

<p>message or error
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_last_news()

## End(Not run)

</code></pre>

<hr>
<h2 id='get_layers_metadata'>Metadata for one couple of apikey and data_type</h2><span id='topic+get_layers_metadata'></span>

<h3>Description</h3>

<p>Metadata are retrieved using the IGN APIs. The execution time can
be long depending on the size of the metadata associated with
the API key and the overload of the IGN servers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_layers_metadata(apikey, data_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_layers_metadata_+3A_apikey">apikey</code></td>
<td>
<p>API key from <code>get_apikeys()</code> or directly
from the <a href="https://geoservices.ign.fr/services-web-experts">IGN website</a></p>
</td></tr>
<tr><td><code id="get_layers_metadata_+3A_data_type">data_type</code></td>
<td>
<p>Should be <code>"wfs"</code> or <code>"wms"</code>. See details for more
information about these two Webservice formats.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_apikeys">get_apikeys()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
apikey &lt;- get_apikeys()[4]
metadata_table &lt;- get_layers_metadata(apikey, "wms")
layers &lt;- metadata_table$Name
one_abstract &lt;- metadata_table[1, "Abstract"]

# List every wfs layers (warning : it's quite long)
all_layers &lt;- lapply(get_apikeys(),
                     get_layers_metadata,
                     data_type = "wfs")

# Convert list to data.frame
all_layers &lt;- do.call(rbind, list_metadata)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_location_info'>Retrieve additional information for wms layer</h2><span id='topic+get_location_info'></span>

<h3>Description</h3>

<p>For some wms layer more information can be found with GetFeatureInfo request.
This function first check if info are available. If not, available layers
are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_location_info(x,
                  apikey = "ortho",
                  layer = "ORTHOIMAGERY.ORTHOPHOTOS",
                  read_sf = TRUE,
                  version = "1.3.0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_location_info_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code>. Only single point are supported for now.
Needs to be located in France.</p>
</td></tr>
<tr><td><code id="get_location_info_+3A_apikey">apikey</code></td>
<td>
<p><code>character</code>; API key from <code>get_apikeys()</code> or directly
from <a href="https://geoservices.ign.fr/services-web-experts">IGN website</a>.</p>
</td></tr>
<tr><td><code id="get_location_info_+3A_layer">layer</code></td>
<td>
<p><code>character</code>; layer name from
<code>get_layers_metadata(apikey, "wms")</code> or directly from
<a href="https://geoservices.ign.fr/services-web-experts">IGN website</a>.</p>
</td></tr>
<tr><td><code id="get_location_info_+3A_read_sf">read_sf</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code> an <code>sf</code> object is returned but
response times may be higher.</p>
</td></tr>
<tr><td><code id="get_location_info_+3A_version">version</code></td>
<td>
<p><code>character</code>; version of the service used. See details
for more info.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code> or <code>sf</code> containing additional information about the layer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
library(tmap)

# From single point
x &lt;- st_centroid(read_sf(system.file("extdata/penmarch.shp", package = "happign")))
location_info &lt;- get_location_info(x, "ortho", "ORTHOIMAGERY.ORTHOPHOTOS", read_sf = F)
location_info$date_vol

# From multiple point
x1 &lt;- st_sfc(st_point(c(-3.549957, 47.83396)), crs = 4326) # Carnoet forest
x2 &lt;- st_sfc(st_point(c(-3.745995, 47.99296)), crs = 4326) # Coatloch forest

forests &lt;- lapply(list(x1, x2),
                  get_location_info,
                  apikey = "environnement",
                  layer = "FORETS.PUBLIQUES",
                  read_sf = T)

qtm(forests[[1]]) + qtm(forests[[2]])

# Find all queryable layers
queryable_layers &lt;- lapply(get_apikeys(), are_queryable) |&gt; unlist()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_raw_lidar'>Download raw LIDAR data</h2><span id='topic+get_raw_lidar'></span>

<h3>Description</h3>

<p>Check if raw LIDAR data are available at the shape location.
The raw LIDAR data are not classified; they correspond to a cloud point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_raw_lidar(x, destfile = ".", grid_path = ".", quiet = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_raw_lidar_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code>. Needs to be located in
France.</p>
</td></tr>
<tr><td><code id="get_raw_lidar_+3A_destfile">destfile</code></td>
<td>
<p>Folder path where data are downloaded. By default set to &quot;.&quot; e.g. the current directory</p>
</td></tr>
<tr><td><code id="get_raw_lidar_+3A_grid_path">grid_path</code></td>
<td>
<p>Folder path where grid is downloaded. By default set to &quot;.&quot; e.g. the current directory</p>
</td></tr>
<tr><td><code id="get_raw_lidar_+3A_quiet">quiet</code></td>
<td>
<p>if TRUE download is silent</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_raw_lidar()</code> first download a grid containing the name of LIDAR tiles which is
then intersected with <code>x</code> to determine which ones will be uploaded.
The grid is downloaded to <code>grid_path</code> and lidar data to <code>destfile</code>. For both
directory, function check if grid or data already exist to avoid re-downloading them.
</p>


<h3>Value</h3>

<p>No object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)

# Create shape
x &lt;- st_polygon(list(matrix(c(8.852234, 42.55466,
                                  8.852234, 42.57289,
                                  8.860474, 42.57289,
                                  8.860474, 42.55466,
                                  8.852234, 42.55466),
                                 ncol = 2, byrow = TRUE)))
x &lt;- st_sfc(x, crs = st_crs(4326))

# Download data to current directory
get_raw_lidar(x)

# Check all .laz file
list.files(".", pattern = ".laz", recursive = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_wfs'>Download WFS layer</h2><span id='topic+get_wfs'></span>

<h3>Description</h3>

<p>Read simple features from IGN Web Feature Service (WFS).
Three minimal info are needed : a location, an apikey
and the name of layer. You can find those information from
<a href="https://geoservices.ign.fr/services-web-experts">IGN website</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wfs(x = NULL,
        apikey = NULL,
        layer = NULL,
        filename = NULL,
        spatial_filter = "bbox",
        ecql_filter = NULL,
        overwrite = FALSE,
        interactive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wfs_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code>. Needs to be located in
France.</p>
</td></tr>
<tr><td><code id="get_wfs_+3A_apikey">apikey</code></td>
<td>
<p><code>character</code>; API key from <code>get_apikeys()</code> or directly
from <a href="https://geoservices.ign.fr/services-web-experts">IGN website</a></p>
</td></tr>
<tr><td><code id="get_wfs_+3A_layer">layer</code></td>
<td>
<p><code>character</code>; name of the layer from <code>get_layers_metadata(apikey, "wfs")</code>
or directly from
<a href="https://geoservices.ign.fr/services-web-experts">IGN website</a></p>
</td></tr>
<tr><td><code id="get_wfs_+3A_filename">filename</code></td>
<td>
<p>Either a character string naming a file or a connection open
for writing. (ex : &quot;test.shp&quot; or &quot;~/test.shp&quot;)</p>
</td></tr>
<tr><td><code id="get_wfs_+3A_spatial_filter">spatial_filter</code></td>
<td>
<p><code>character</code>; spatial predicate from ECQL language.
See detail and examples for more info.</p>
</td></tr>
<tr><td><code id="get_wfs_+3A_ecql_filter">ecql_filter</code></td>
<td>
<p><code>character</code>; corresponding to an ECQL query.
See detail and examples for more info.</p>
</td></tr>
<tr><td><code id="get_wfs_+3A_overwrite">overwrite</code></td>
<td>
<p><code>logical</code>; if TRUE, file is overwrite.</p>
</td></tr>
<tr><td><code id="get_wfs_+3A_interactive">interactive</code></td>
<td>
<p><code>character</code>; if TRUE, no need to specify <code>apikey</code>
and <code>layer</code>, you'll be ask.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>get_wfs</code> use ECQL language : a query language created by the OpenGeospatial Consortium.
It provide multiple spatial filter : &quot;intersects&quot;, &quot;disjoint&quot;, &quot;contains&quot;, &quot;within&quot;, &quot;touches&quot;,
&quot;crosses&quot;, &quot;overlaps&quot;, &quot;equals&quot;, &quot;relate&quot;, &quot;beyond&quot;, &quot;dwithin&quot;. For &quot;relate&quot;, &quot;beyond&quot;,
&quot;dwithin&quot;, argument can be provide using vector like :
spatial_filter = c(&quot;dwithin&quot;, distance, units). More info about ECQL language
<a href="https://docs.geoserver.org/latest/en/user/filter/ecql_reference.html">here</a>.
Be aware that &quot;dwithin&quot; is broken and it doesn't accept units properly. Only degrees can be used.
To avoid this, create a buffer and then use &quot;within&quot; instead od &quot;dwithin&quot;.
</p>
</li>
<li><p> ECQL query can be provided to <code>ecql_filter</code>. This allows direct query of the IGN's WFS
geoservers. If <code>x</code> is set, then the <code>ecql_filter</code> comes in addition to the
<code>spatial_filter</code>. More info for writing ECQL
<a href="https://docs.geoserver.org/latest/en/user/tutorials/cql/cql_tutorial.html">here</a>
</p>
</li></ul>



<h3>Value</h3>

<p><code>sf</code> object from <code>sf</code> package or <code>NULL</code> if no data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_apikeys">get_apikeys()</a></code>, <code><a href="#topic+get_layers_metadata">get_layers_metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
library(tmap)

# Shape from the best town in France
penmarch &lt;- read_sf(system.file("extdata/penmarch.shp", package = "happign"))

# For quick testing, use interactive = TRUE
shape &lt;- get_wfs(x = penmarch,
                 interactive = TRUE)

# For specific use, choose apikey with get_apikey() and layer with get_layers_metadata()
## Getting borders of best town in France
apikey &lt;- get_apikeys()[1]
metadata_table &lt;- get_layers_metadata(apikey, "wfs")
layer &lt;- metadata_table[32,1] # LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune

# Downloading borders
borders &lt;- get_wfs(penmarch, apikey, layer)

# Plotting result
qtm(borders, fill = NULL, borders = "firebrick") # easy map

# Get forest_area of the best town in France
forest_area &lt;- get_wfs(x = borders,
                       apikey = "environnement",
                       layer = "LANDCOVER.FORESTINVENTORY.V1:resu_bdv1_shape")

qtm(forest_area, fill = "libelle")

# Using ECQL filters to query IGN server
## First find attributes of the layer
attrs &lt;- get_wfs_attributes(apikey, layer)

## e.g. : find all commune's name starting by "plou"
plou_borders &lt;- get_wfs(x = NULL, # When x is NULL, all France is query
                        apikey = "administratif",
                        layer = "LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune",
                        ecql_filter = "nom_m LIKE 'PLOU%'")
qtm(plou_borders)

## Combining ecql_filters
plou_borders_inf_2000 &lt;- get_wfs(x = NULL, # When x is NULL, all France is query
                                 apikey = "administratif",
                                 layer = "LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune",
                                 ecql_filter = "nom_m LIKE 'PLOU%' AND population &lt; 2000")
qtm(plou_borders)+ qtm(plou_borders_inf_2000, fill = "red")

## End(Not run)
</code></pre>

<hr>
<h2 id='get_wfs_attributes'>get_wfs_attributes</h2><span id='topic+get_wfs_attributes'></span>

<h3>Description</h3>

<p>Helper to write ecql filter. Retrieve all attributes from a layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wfs_attributes(apikey = NULL, layer = NULL, interactive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wfs_attributes_+3A_apikey">apikey</code></td>
<td>
<p><code>character</code>; API key from <code>get_apikeys()</code> or directly
from <a href="https://geoservices.ign.fr/services-web-experts">IGN website</a></p>
</td></tr>
<tr><td><code id="get_wfs_attributes_+3A_layer">layer</code></td>
<td>
<p><code>character</code>; name of the layer from <code>get_layers_metadata(apikey, "wfs")</code>
or directly from
<a href="https://geoservices.ign.fr/services-web-experts">IGN website</a></p>
</td></tr>
<tr><td><code id="get_wfs_attributes_+3A_interactive">interactive</code></td>
<td>
<p><code>character</code>; if TRUE, no need to specify <code>apikey</code>
and <code>layer</code>, you'll be ask.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>character</code>vector with layer attributes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

get_wfs_attributes("administratif", "LIMITES_ADMINISTRATIVES_EXPRESS.LATEST:commune")

# Interactive session
get_wfs_attributes(interactive = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='get_wms_raster'>Download WMS raster layer</h2><span id='topic+get_wms_raster'></span>

<h3>Description</h3>

<p>Download a raster layer from IGN Web Mapping Services (WMS).
To do that, it need a location giving by a shape, an apikey
and the name of layer. You can find those information from
<a href="https://geoservices.ign.fr/services-web-experts">IGN website</a>
or with <code>get_apikeys()</code> and <code>get_layers_metadata()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wms_raster(x,
               apikey = "altimetrie",
               layer = "ELEVATION.ELEVATIONGRIDCOVERAGE",
               res = 25,
               filename = tempfile(fileext = ".tif"),
               crs = 2154,
               overwrite = FALSE,
               version = "1.3.0",
               styles = "",
               interactive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wms_raster_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code>. Needs to be located in
France.</p>
</td></tr>
<tr><td><code id="get_wms_raster_+3A_apikey">apikey</code></td>
<td>
<p><code>character</code>; API key from <code>get_apikeys()</code> or directly
from <a href="https://geoservices.ign.fr/services-web-experts">IGN website</a>.</p>
</td></tr>
<tr><td><code id="get_wms_raster_+3A_layer">layer</code></td>
<td>
<p><code>character</code>; layer name from
<code>get_layers_metadata(apikey, "wms")</code> or directly from
<a href="https://geoservices.ign.fr/services-web-experts">IGN website</a>.</p>
</td></tr>
<tr><td><code id="get_wms_raster_+3A_res">res</code></td>
<td>
<p><code>numeric</code>; resolution in the unit of the coordinate system
(e.g. meter for 2154). See detail for more information about <code>res</code>.</p>
</td></tr>
<tr><td><code id="get_wms_raster_+3A_filename">filename</code></td>
<td>
<p><code>character</code> or <code>NULL</code>; filename or a open connection for
writing. (ex : &quot;test.tif&quot; or &quot;~/test.tif&quot;). If <code>NULL</code>, <code>layer</code> is used as
filename. Default drivers is &quot;.tif&quot; but all gdal drivers are supported,
see details for more info.</p>
</td></tr>
<tr><td><code id="get_wms_raster_+3A_crs">crs</code></td>
<td>
<p><code>numeric</code>, <code>character</code>, or object of class <code>sf</code> or <code>sfc</code>.
It is set to EPSG:2154 by default. See <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code> for more detail.</p>
</td></tr>
<tr><td><code id="get_wms_raster_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE, output raster is overwrite.</p>
</td></tr>
<tr><td><code id="get_wms_raster_+3A_version">version</code></td>
<td>
<p><code>character</code>; version of the service used. See details
for more info.</p>
</td></tr>
<tr><td><code id="get_wms_raster_+3A_styles">styles</code></td>
<td>
<p><code>character</code>; rendering style of the layer. Set to &quot;&quot;
by default. See details for more info.</p>
</td></tr>
<tr><td><code id="get_wms_raster_+3A_interactive">interactive</code></td>
<td>
<p><code>logical</code>; If TRUE, interactive menu ask for
<code>apikey</code> and <code>layer</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>res</code> : Warning, setting <code>res</code> higher than default layer resolution
multiplies the number of pixels without increasing
the precision. For example, the download of the BD Alti layer from
IGN will be optimal for a resolution of 25m.
</p>
</li>
<li> <p><code>version</code> and <code>styles</code> arguments are detailed on
<a href="https://geoservices.ign.fr/documentation/services/api-et-services-ogc/images-wms-ogc">IGN documentation</a>
</p>
</li>
<li> <p><code>filename</code> : All GDAL supported drivers can be found
<a href="https://gdal.org/drivers/raster/index.html">here</a>
</p>
</li>
<li> <p><code>overwrite</code> : <code style="white-space: pre;">&#8288;get_wms raster&#8288;</code> always checks that <code>filename</code> does not
already exist. If it does, it is imported into R without further downloading
unless <code>overwrite</code> is set to <code>TRUE</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>SpatRaster</code> object from <code>terra</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_apikeys">get_apikeys()</a></code>, <code><a href="#topic+get_layers_metadata">get_layers_metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
library(tmap)

# Shape from the best town in France
penmarch &lt;- read_sf(system.file("extdata/penmarch.shp", package = "happign"))

# For quick testing use interactive = TRUE
raster &lt;- get_wms_raster(x = penmarch, interactive = TRUE)

# For specific data, choose apikey with get_apikey() and layer with get_layers_metadata()
apikey &lt;- get_apikeys()[4]  # altimetrie
metadata_table &lt;- get_layers_metadata(apikey, "wms") # all layers for altimetrie wms
layer &lt;- metadata_table[2,1] # ELEVATION.ELEVATIONGRIDCOVERAGE

# Downloading digital elevation model from IGN
mnt_2154 &lt;- get_wms_raster(penmarch, apikey, layer, res = 25)

# If crs is set to 4326, res is in degrees
mnt_4326 &lt;- get_wms_raster(penmarch, apikey, layer, res = 0.0005, crs = 4326)

# Plotting result
tm_shape(mnt_4326)+
   tm_raster()+
tm_shape(penmarch)+
   tm_borders(col = "blue", lwd  = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_wmts'>Download WMTS raster tiles</h2><span id='topic+get_wmts'></span>

<h3>Description</h3>

<p>Download an RGB raster layer from IGN Web Map Tile Services (WMTS).
WMTS focuses on performance and can only query pre-calculated
tiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wmts(x,
         apikey = "ortho",
         layer = "ORTHOIMAGERY.ORTHOPHOTOS",
         zoom = 10L,
         crs = 2154,
         filename = tempfile(fileext = ".tif"),
         overwrite = FALSE,
         interactive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wmts_+3A_x">x</code></td>
<td>
<p>Object of class <code>sf</code> or <code>sfc</code>. Needs to be located in
France.</p>
</td></tr>
<tr><td><code id="get_wmts_+3A_apikey">apikey</code></td>
<td>
<p><code>character</code>; API key from <code>get_apikeys()</code> or directly
from <a href="https://geoservices.ign.fr/services-web-experts">IGN website</a>.</p>
</td></tr>
<tr><td><code id="get_wmts_+3A_layer">layer</code></td>
<td>
<p><code>character</code>; layer name from
<code>get_layers_metadata(apikey, "wms")</code> or directly from
<a href="https://geoservices.ign.fr/services-web-experts">IGN website</a>.</p>
</td></tr>
<tr><td><code id="get_wmts_+3A_zoom">zoom</code></td>
<td>
<p><code>integer</code> between 0 and 21; at low zoom levels, a small set of
map tiles covers a large geographical area. In other words, the smaller
the zoom level, the less precise the resolution. For conversion between zoom
level and resolution see
<a href="https://geoservices.ign.fr/documentation/services/api-et-services-ogc/images-tuilees-wmts-ogc">WMTS IGN Documentation</a></p>
</td></tr>
<tr><td><code id="get_wmts_+3A_crs">crs</code></td>
<td>
<p><code>numeric</code>, <code>character</code>, or object of class <code>sf</code> or <code>sfc</code>.
It is set to EPSG:2154 by default. See <code><a href="sf.html#topic+st_crs">sf::st_crs()</a></code> for more detail.</p>
</td></tr>
<tr><td><code id="get_wmts_+3A_filename">filename</code></td>
<td>
<p><code>character</code> or <code>NULL</code>; filename or a open connection for
writing. (ex : &quot;test.tif&quot; or &quot;~/test.tif&quot;). If <code>NULL</code>, <code>layer</code> is used as
filename. Default drivers is &quot;.tif&quot; but all gdal drivers are supported,
see details for more info.</p>
</td></tr>
<tr><td><code id="get_wmts_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE, output raster is overwrite.</p>
</td></tr>
<tr><td><code id="get_wmts_+3A_interactive">interactive</code></td>
<td>
<p><code>logical</code>; If TRUE, interactive menu ask for
<code>apikey</code> and <code>layer</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SpatRaster</code> object from <code>terra</code> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_apikeys">get_apikeys()</a></code>, <code><a href="#topic+get_layers_metadata">get_layers_metadata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
TO-DO

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
