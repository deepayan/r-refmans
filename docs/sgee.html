<!DOCTYPE html><html lang="en"><head><title>Help for package sgee</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sgee}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sgee-package'><p>sgee: Stagewise Generalized Estimating Equations</p></a></li>
<li><a href='#bisee'><p>Bi-Level Stagewise Estimating Equations Implementation</p></a></li>
<li><a href='#deltaFinder'><p>deltaFinder</p></a></li>
<li><a href='#deltaValue'><p>deltaValue</p></a></li>
<li><a href='#genCorMat'><p>Correlation Matrix Generator.</p></a></li>
<li><a href='#genData'><p>Response and  Covariate Data Generation</p></a></li>
<li><a href='#hisee'><p>Hierarchical Stagewise Estimating Equations Implementation.</p></a></li>
<li><a href='#isee'><p>Interaction stagewise estimating equations</p></a></li>
<li><a href='#miniSim'><p>Mini Simulator</p></a></li>
<li><a href='#plot.sgee'><p>Coefficient Traceplot Function</p></a></li>
<li><a href='#print.sgee'><p><code>print</code> function for sgee</p></a></li>
<li><a href='#print.sgeeSummary'><p><code>print</code> function for sgee summaries</p></a></li>
<li><a href='#samplingDistCalculation'><p>samplingDistCalculation</p></a></li>
<li><a href='#see'><p>Stagewise Estimating Equations Implementation</p></a></li>
<li><a href='#sgee.control'><p>Auxiliary for Controlling SGEE fitting</p></a></li>
<li><a href='#subsample'><p>subsample</p></a></li>
<li><a href='#summary.sgee'><p>Coefficient Path summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stagewise Generalized Estimating Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-01-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Stagewise techniques implemented with Generalized Estimating Equations to handle individual, group, bi-level, and interaction selection. Stagewise approaches start with an empty model and slowly build the model over several iterations, which yields a 'path' of candidate models from which model selection can be performed. This 'slow brewing' approach gives stagewise techniques a unique flexibility that allows simple incorporation of Generalized Estimating Equations; see Vaughan, G., Aseltine, R., Chen, K., Yan, J., (2017) &lt;<a href="https://doi.org/10.1111%2Fbiom.12669">doi:10.1111/biom.12669</a>&gt; for details.</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Vaughan [aut, cre],
    Kun Chen [ctb], Jun Yan [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Vaughan &lt;gvaughan@bentley.edu&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, copula, stats, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-08 15:36:33 UTC; vindel</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-08 18:34:38 UTC</td>
</tr>
</table>
<hr>
<h2 id='sgee-package'>sgee: Stagewise Generalized Estimating Equations</h2><span id='topic+sgee-package'></span><span id='topic+sgee'></span>

<h3>Description</h3>

<p>Provides functions to perform Boosting / Functional Gradient Descent /
Forward Stagewise regression with grouped covariates setting using
Generalized Estimating Equations.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> sgee</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.6-0</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2018-01-08</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 3)
</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>
<p> sgee provides several stagewise regression approaches
that are designed to address variable selection with grouped covariates
in the context of
Generalized Estimating Equations. Given a response and design matrix
stagewise techniques perform a sequence of small learning steps
wherein a subset of the covariates are selected as being the
most important at that iteration and are then subsequently updated
by a small amount, epsilon. different techniques this optimal update
in different ways that achieve different structural goals (i.e.
groups of covariates are fully included or not).
</p>
<p>The resulting path can then be analyzed to determine an optimal
model along the path of coefficient estimates. The
<code>analyzeCoefficientPath</code> function provides such
functionality based on various
possible metrics, primarily focused on the Mean Squared Error.
Furthermore, the <code>plot.sgee</code> function can be used to examine the
path of coefficient estimates versus the iteration number, or some
desired penalty.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan [aut, cre],
Kun Chen [ctb], Jun Yan [ctb]
</p>
<p>Maintainer: Gregory Vaughan &lt;gregory.vaughan@uconn.edu&gt;
</p>


<h3>References</h3>

<p>Vaughan, G., Aseltine, R., Chen, K., Yan, J., (2017). Stagewise
Generalized Estimating Equations with Grouped Variables. Biometrics 73,
1332-1342. URL: http://dx.doi.org/10.1111/biom.12669,
doi:10.1111/biom.12669.
</p>
<p>Vaughan, G., Aseltine, R., Chen, K., Yan, J., (2017). Efficient
interaction selection for clustered data via stagewise generalized
estimating equations.  Department of Statistics, University of
Connecticut. Technical Report.
</p>
<p>Wolfson, J. (2011). EEBoost: A general method for prediction
and variable selection based on estimating equations. Journal of the
American Statistical Association 106, 296&ndash;305.
</p>
<p>Tibshirani, R. J. (2015). A general framework for fast stagewise
algorithms. Journal of Machine Learning Research 16, 2543&ndash;2588.
</p>
<p>Simon, N., Friedman, J., Hastie, T., and Tibshirani, R. (2013). A
sparse-group lasso. Journal of Computational and Graphical
Statistics 22, 231&ndash;245.
</p>
<p>Hastie, T., Tibshirani, R., and Friedman, J. (2009). The Elements
of Statistical Learning: Data Mining, Inference, and Prediction.
Springer, New York.
</p>
<p>Liang, K.-Y. and Zeger, S. L. (1986). Longitudinal data analysis
using generalized linear models. Biometrika 73, 13&ndash;22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


#####################
## Generate test data
#####################

## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2.4,5),
          c(1.2, 0, 1.6, 0, .4),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 5
numGroups &lt;- length(beta)/groupSize


generatedData &lt;- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         numGroups = numGroups,
                         groupSize = groupSize,
                         groupRho = 0.3,
                         beta = beta,
                         family = gaussian(),
                         intercept = 0)


coefMat1 &lt;- hisee(y = generatedData$y, x = generatedData$x,
                  family = gaussian(),
                  clusterID = generatedData$clusterID,
                  groupID = generatedData$groupID, 
                  corstr="exchangeable",
                  control = sgee.control(maxIt = 100, epsilon = 0.2))

## interceptLimit allows for compatibility with older R versions
coefMat2 &lt;- bisee(y = generatedData$y, x = generatedData$x,
                  family = gaussian(),
                  clusterID = generatedData$clusterID,
                  groupID = generatedData$groupID, 
                  corstr="exchangeable", 
                  control = sgee.control(maxIt = 100, epsilon = 0.2,
                                         interceptLimit = 10),
                  lambda1 = .5,
                  lambda2 = .5)


par(mfrow = c(2,1))
plot(coefMat1)
plot(coefMat2)

</code></pre>

<hr>
<h2 id='bisee'>Bi-Level Stagewise Estimating Equations Implementation</h2><span id='topic+bisee'></span><span id='topic+bisee.formula'></span><span id='topic+bisee.default'></span><span id='topic+bisee.fit'></span><span id='topic+gsee'></span>

<h3>Description</h3>

<p>Function to perform BiSEE, a Bi-Level Boosting / Functional
Gradient Descent / Forward Stagewise regression in
the grouped covariates setting using
Generalized Estimating Equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisee(y, ...)

## S3 method for class 'formula'
bisee(formula, data = list(), clusterID, waves = NULL,
  lambda1, lambda2 = 1 - lambda1, contrasts = NULL, subset, ...)

## Default S3 method:
bisee(y, x, waves = NULL, lambda1, lambda2 = 1 - lambda1,
  ...)

## S3 method for class 'fit'
bisee(y, x, family, clusterID, waves = NULL, groupID,
  corstr = "independence", alpha = NULL, lambda1 = 0.5, lambda2 = 1 -
  lambda1, intercept = TRUE, offset = 0, control = sgee.control(maxIt =
  200, epsilon = 0.05, stoppingThreshold = min(length(y), ncol(x)) - intercept,
  undoThreshold = 0.005), standardize = TRUE, verbose = FALSE, ...)

gsee(y, x, family, clusterID, waves = NULL, groupID = 1:ncol(x),
  corstr = "independence", alpha = NULL, offset = 0, intercept = TRUE,
  control = sgee.control(maxIt = 200, epsilon = 0.05, stoppingThreshold =
  min(length(y), ncol(x)) - intercept, undoThreshold = 0.005),
  standardize = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bisee_+3A_y">y</code></td>
<td>
<p>Vector of response measures that corresponds with modeling family
given in 'family' parameter. <code>y</code> is assumed to be the same length as
<code>clusterID</code> and is assumed to be organized into clusters as dictated by
<code>clusterID</code>.</p>
</td></tr>
<tr><td><code id="bisee_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
<tr><td><code id="bisee_+3A_formula">formula</code></td>
<td>
<p>Object of class 'formula'; a symbolic description of
the model to be fitted</p>
</td></tr>
<tr><td><code id="bisee_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="bisee_+3A_clusterid">clusterID</code></td>
<td>
<p>Vector of integers that identifies the clusters of response
measures in <code>y</code>. Data and <code>clusterID</code> are assumed to
1) be of equal lengths,
2) sorted so that observations of a cluster are in contiguous rows, and 3)
organized so that <code>clusterID</code> is a vector of consecutive integers.</p>
</td></tr>
<tr><td><code id="bisee_+3A_waves">waves</code></td>
<td>
<p>An integer vector which identifies components in clusters.
The length of <code>waves</code> should be the same as the number of
observations. <code>waves</code> is automatically generated if none is supplied,
but when using <code>subset</code> parameter, the <code>waves</code> parameter must be
provided by the user for proper calculation.</p>
</td></tr>
<tr><td><code id="bisee_+3A_lambda1">lambda1</code></td>
<td>
<p>Mixing parameter used to indicate weight of $L_2$ Norm
(group selection). While not necessary, <code>lambda1</code> and
<code>lambda2</code> are
best set to sum to 1 as only the weights relative to each other matter.
Default value is set to .5.</p>
</td></tr>
<tr><td><code id="bisee_+3A_lambda2">lambda2</code></td>
<td>
<p>Mixing parameter used to indicate weight of $L_1$ Norm
(individual selection). While not necessary, <code>lambda1</code> and
<code>lambda2</code> are best set to sum
to 1 as only the weights relative to each other matter.  Default value is
set to <code>1-lambda1</code>.</p>
</td></tr>
<tr><td><code id="bisee_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list provided when using a formula.
similar to <code>contrasts</code> from <code>glm</code>.
See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="bisee_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="bisee_+3A_x">x</code></td>
<td>
<p>Design matrix of dimension <code>length(y)</code> x nvar,
the number of variables, where each row is
represents an observation of predictor variables.</p>
</td></tr>
<tr><td><code id="bisee_+3A_family">family</code></td>
<td>
<p>Modeling family that describes the marginal distribution of
the response. Assumed to be an object such as <code>gaussian()</code> or
<code>poisson()</code>.</p>
</td></tr>
<tr><td><code id="bisee_+3A_groupid">groupID</code></td>
<td>
<p>Vector of integeres that identifies the groups of the
covariates/coefficients (i.e. the columns of <code>x</code>).  <code>x</code>
and <code>groupID</code> are
assumed 1) to be of corresponding dimension, (i.e.
<code>ncol(x) == length(groupID)</code>),
2) sorted so that groups of covariates are in contiguous
columns, and 3) organized so that <code>groupID</code> is a vector of consecutive
integers.</p>
</td></tr>
<tr><td><code id="bisee_+3A_corstr">corstr</code></td>
<td>
<p>A character string indicating the desired working correlation
structure. The following are implemented : &quot;independence&quot; (default value),
&quot;exchangeable&quot;, and &quot;ar1&quot;.</p>
</td></tr>
<tr><td><code id="bisee_+3A_alpha">alpha</code></td>
<td>
<p>An initial guess for the correlation parameter value
between -1 and 1 . If left NULL (the default), the initial estimate is 0.</p>
</td></tr>
<tr><td><code id="bisee_+3A_intercept">intercept</code></td>
<td>
<p>Binary value indicating where an intercept term is
to be included in the model for estimation. Default is to include an
intercept.</p>
</td></tr>
<tr><td><code id="bisee_+3A_offset">offset</code></td>
<td>
<p>Vector of offset value(s) for the linear predictor.
<code>offset</code>
is assumed to be either of length one, or of the same length as <code>y</code>.
Default is to have no offset.</p>
</td></tr>
<tr><td><code id="bisee_+3A_control">control</code></td>
<td>
<p>A list of parameters used to contorl the path generation
process; see <code>sgee.control</code>.</p>
</td></tr>
<tr><td><code id="bisee_+3A_standardize">standardize</code></td>
<td>
<p>A logical parameter that indicates whether or not
the covariates need to be standardized before fitting.
If standardized before fitting, the unstandardized
path is returned as the default, with a <code>standardizedPath</code> and
<code>standardizedX</code> included
separately. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bisee_+3A_verbose">verbose</code></td>
<td>
<p>Logical parameter indicating whether output should be produced
while bisee is running. Default value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to implement BiSEE, a stagewise regression approach
that is designed to perform bi-level selection in the context of
Generalized Estimating Equations. Given a response <code>y</code> and
a design matrix <code>x</code>
(excluding intercept) BiSEE generates a path of stagewise regression
estimates for each covariate based on the provided step size epsilon,
and tuning parameters <code>lambda1</code> and <code>lambda2</code>. When
<code>lambda1 == 0</code> or <code>lambda2 == 0</code>, the simplified versions
of <code>bisee</code> called <code>see</code> and <code>gsee</code>, respectively,
will be called.
</p>
<p>The resulting path can then be analyzed to determine an optimal
model along the path of coefficient estimates. The
<code>summary.sgee</code> function provides such
functionality based on various
possible metrics, primarily focused on the Mean Squared Error.
Furthermore, the <code>plot.sgee</code> function can be used to examine the
path of coefficient estimates versus the iteration number, or some
desired penalty.
</p>
<p><code>bisee</code> makes use of the function uniroot in the stats package.
The <code>extendInt</code> parameter for <code>uniroot</code> is used, which may
cause issues for older versions of R.
</p>


<h3>Value</h3>

<p>Object of class <code>sgee</code> containing the path
of coefficient estimates,
the path of scale estimates, the path of correlation parameter
estimates, the iteration at which BiSEE terminated, and initial regression
values including <code>x</code>, <code>y</code>, codefamily, <code>clusterID</code>,
<code>groupID</code>, <code>offset</code>, <code>epsilon</code>, and <code>numIt</code>.
</p>


<h3>Note</h3>

<p>Function to execute BiSEE technique. Note that <code>lambda1</code>
and <code>lambda2</code> are tuning parameters. Though it is advised to
fix <code>lambda1 + lambda2 = 1</code>, this is not necessary. These parameters
can be tuned using various approaches including cross validation.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>References</h3>

<p>Vaughan, G., Aseltine, R., Chen, K., Yan, J., (2017). Stagewise
Generalized Estimating Equations with Grouped Variables. Biometrics 73,
1332-1342. URL: http://dx.doi.org/10.1111/biom.12669,
doi:10.1111/biom.12669.
</p>
<p>Wolfson, J. (2011). EEBoost: A general method for prediction
and variable selection based on estimating equations. Journal of the
American Statistical Association 106, 296&ndash;305.
</p>
<p>Tibshirani, R. J. (2015). A general framework for fast stagewise
algorithms. Journal of Machine Learning Research 16, 2543&ndash;2588.
</p>
<p>Simon, N., Friedman, J., Hastie, T., and Tibshirani, R. (2013). A
sparse-group lasso. Journal of Computational and Graphical
Statistics 22, 231&ndash;245.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#####################
## Generate test data
#####################

## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2,5),
          c(1, 0, 1.5, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 5
numGroups &lt;- length(beta)/groupSize


generatedData &lt;- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         numGroups = numGroups,
                         groupSize = groupSize,
                         groupRho = 0.3,
                         beta = beta,
                         family = gaussian(),
                         intercept = 1)


## Perform Fitting by providing y and x values
coefMat1 &lt;- bisee(y = generatedData$y, x = generatedData$x,
                 family = gaussian(),
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr = "exchangeable", 
                 control = sgee.control(maxIt = 50, epsilon = 0.5),
                 lambda1 = .5,
                 lambda2 = .5,
                 verbose = TRUE)


## Perform Fitting by providing formula and data
genDF &lt;- data.frame(generatedData$y, generatedData$x)
names(genDF) &lt;- c("Y", paste0("Cov", 1:p))
coefMat2 &lt;- bisee(formula(genDF), data = genDF,
                 family = gaussian(),
                 subset = Y &lt;1.5,
                 waves = rep(1:4, 50), 
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr = "exchangeable",
                 control = sgee.control(maxIt = 50, epsilon = 0.5),
                 lambda1 = 0.5,
                 lambda2 = 0.5,
                 verbose = TRUE)

par(mfrow = c(2,1))
plot(coefMat1)
plot(coefMat2)

</code></pre>

<hr>
<h2 id='deltaFinder'>deltaFinder</h2><span id='topic+deltaFinder'></span>

<h3>Description</h3>

<p>Function to find the appropriate group update. A potential
update value is given and then the corresponding sparse group
lasso penalty value is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaFinder(a, lambda1, lambda2, gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deltaFinder_+3A_a">a</code></td>
<td>
<p>Possbile update value.</p>
</td></tr>
<tr><td><code id="deltaFinder_+3A_lambda1">lambda1</code></td>
<td>
<p>Tuning parameter pertaining to importance of groups.</p>
</td></tr>
<tr><td><code id="deltaFinder_+3A_lambda2">lambda2</code></td>
<td>
<p>Tuning parameter pertaining to importance of individuals.</p>
</td></tr>
<tr><td><code id="deltaFinder_+3A_gamma">gamma</code></td>
<td>
<p>Scaling / thresholding value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function used by bisee.
</p>


<h3>Value</h3>

<p>L2 Norm minus one of a given delta group defined by
given lambda1, lambda2, and gamma.
</p>


<h3>Note</h3>

<p>Internal function.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>

<hr>
<h2 id='deltaValue'>deltaValue</h2><span id='topic+deltaValue'></span>

<h3>Description</h3>

<p>Function to calculate an update under a given configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaValue(a, lambda1, lambda2, gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deltaValue_+3A_a">a</code></td>
<td>
<p>Subvector of Estimating Equations that pertains to a particular
group.</p>
</td></tr>
<tr><td><code id="deltaValue_+3A_lambda1">lambda1</code></td>
<td>
<p>Tuning parameter pertaining to importance of groups.</p>
</td></tr>
<tr><td><code id="deltaValue_+3A_lambda2">lambda2</code></td>
<td>
<p>Tuning parameter pertaining to importance of individuals.</p>
</td></tr>
<tr><td><code id="deltaValue_+3A_gamma">gamma</code></td>
<td>
<p>Scaling / thresholding value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function used by bisee.
</p>


<h3>Value</h3>

<p>The form of a group update for given lambda1, lambda2, and gamma.
</p>


<h3>Note</h3>

<p>Internal function.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>

<hr>
<h2 id='genCorMat'>Correlation Matrix Generator.</h2><span id='topic+genCorMat'></span>

<h3>Description</h3>

<p>Function that generates a correlation matrix of a predefined type  and size
given appropriate correlation parameter(s), <code>rho</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCorMat(corstr = "independence", rho, maxClusterSize = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genCorMat_+3A_corstr">corstr</code></td>
<td>
<p>Structure of correlaiton matrix to be generated;
'independence', 'exchangeable', 'ar1', and 'unstructured' currently
implemented.</p>
</td></tr>
<tr><td><code id="genCorMat_+3A_rho">rho</code></td>
<td>
<p>Correlation parameter; assumed to be of length 1 or
<code>maxClusterSize * (maxClusterSize - 1) /2</code>.</p>
</td></tr>
<tr><td><code id="genCorMat_+3A_maxclustersize">maxClusterSize</code></td>
<td>
<p>size of the correlation matrix being generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation matrix of form matching corstr and of size
maxClusterSize.
</p>


<h3>Note</h3>

<p>Mostly intended for internal use, but could be useful to user.
Therefore, the function is exported.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Generates Correlation Matricies easily
## When corstr = "independence", the value of rho
## is irrelevant
mat1 &lt;- genCorMat(corstr = "independence", rho = .1, maxClusterSize = 3) 

## Exchangeable
mat2 &lt;- genCorMat(corstr = "exchangeable", rho = .3, maxClusterSize = 2) 

## AR-1
mat3 &lt;- genCorMat(corstr = "ar1", rho = .4, maxClusterSize = 4) 

## unstructured
mat3 &lt;- genCorMat(corstr = "unstructured",
                  rho = c(.3,.2,.1),
                  maxClusterSize = 3) 


</code></pre>

<hr>
<h2 id='genData'>Response and  Covariate Data Generation</h2><span id='topic+genData'></span>

<h3>Description</h3>

<p>Function to generate data that can be used to test Forward stagewise /
Penalized Regression techniques. Currently marginally Gaussian and
Poisson responses are possible.
</p>
<p>Function is provided to allow the user simple data generation as
<code>sgee</code> functions were designed for.
Various parameters controlling
aspects such as the response correlation, the covariate group
structure, the marginal response distribution, and the signal to
noise ratio for marginally gaussian responses are
provided to allow a great deal of specificity over the kind of data
that is generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genData(numClusters, clusterSize = 1, clusterRho = 0,
  clusterCorstr = "exchangeable", yVariance = NULL, xVariance = 1,
  numGroups = length(beta), groupSize = 1, groupRho = 0, beta = 0,
  numMainEffects = NULL, family = gaussian(), SNR = NULL, intercept = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genData_+3A_numclusters">numClusters</code></td>
<td>
<p>Number of clusters to be generated.</p>
</td></tr>
<tr><td><code id="genData_+3A_clustersize">clusterSize</code></td>
<td>
<p>Size of each cluster.</p>
</td></tr>
<tr><td><code id="genData_+3A_clusterrho">clusterRho</code></td>
<td>
<p>Correlation parameter for response.</p>
</td></tr>
<tr><td><code id="genData_+3A_clustercorstr">clusterCorstr</code></td>
<td>
<p>String indicating cluster Correlation structure.
Parameter is fed to <code>genCorMat</code>,
so all possible entries for <code>genCorMat</code> are allowed.</p>
</td></tr>
<tr><td><code id="genData_+3A_yvariance">yVariance</code></td>
<td>
<p>Optional scalar value specifying the marginal response
variance; overrides <code>SNR</code>.</p>
</td></tr>
<tr><td><code id="genData_+3A_xvariance">xVariance</code></td>
<td>
<p>Scalar value indicating marginal variance of the
covariates.</p>
</td></tr>
<tr><td><code id="genData_+3A_numgroups">numGroups</code></td>
<td>
<p>Number of covariate groups to be generated. Default
behavior is to generate groups of size 1 (effectively no groups).
If covariate groups are desired, <code>numGroups</code> and <code>groupSize</code>
must be given such that <code>length(beta)</code> equals
<code>numGroups</code> * <code>groupSize</code>.</p>
</td></tr>
<tr><td><code id="genData_+3A_groupsize">groupSize</code></td>
<td>
<p>Size of each group.</p>
</td></tr>
<tr><td><code id="genData_+3A_grouprho">groupRho</code></td>
<td>
<p>Within group correlation parameter.</p>
</td></tr>
<tr><td><code id="genData_+3A_beta">beta</code></td>
<td>
<p>Vector of coefficient values used to generate response.</p>
</td></tr>
<tr><td><code id="genData_+3A_nummaineffects">numMainEffects</code></td>
<td>
<p>An integer indicating that the first
<code>numMainEffects</code> terms in <code>beta</code> are to be treated
as main effects and the remaining terms are pairwise interaction effects,
which are in the same order as generated by <code>model.matrix</code>.
Default value of <code>NULL</code> indicates no interaction terms are included.
The use of <code>numMainEffects</code> overrides any covariate grouping structure
provided by the user.</p>
</td></tr>
<tr><td><code id="genData_+3A_family">family</code></td>
<td>
<p>Marginal response family; currently <code>gaussian()</code> and
<code>poisson()</code> are accepted.</p>
</td></tr>
<tr><td><code id="genData_+3A_snr">SNR</code></td>
<td>
<p>Scalar value that allows fixing the signal
to noise ratio as defined as the ratio of the (observed) variance in the
linear predictor to the variance of the response conditioned on the
covariates.</p>
</td></tr>
<tr><td><code id="genData_+3A_intercept">intercept</code></td>
<td>
<p>Scalar value indicating the true intercept value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the generated response, <code>y</code>, the generated
covariates, <code>x</code>, a vector identifying the responses clusters,
<code>clusterID</code>, and a vector identifying the covariate groups,
<code>groupID</code>.
</p>


<h3>Note</h3>

<p>Function is ued to generate both the desired covariate structure and
the desired response structure. To generate poisson responses, functions
from the R package <code>coupla</code> are used.
</p>
<p>Current implementation of interactions overwrites any previous grouping
structure; that is the number of groups becomes p and the group sizes
are set to 1.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## A resonse variance can be given,
dat1 &lt;- genData(numClusters = 10,
                clusterSize = 4,
                clusterRho = .5,
                clusterCorstr = "exchangeable",
                yVariance = 1,
                xVariance = 1,
                numGroups = 5,
                groupSize = 4,
                groupRho = .5,
                beta = c(rep(1,8), rep(0,12)),
                family = gaussian(),
                intercept = 1)

## or the signal to noise ratio can be fixed
dat2 &lt;- genData(numClusters = 10,
                clusterSize = 4,
                clusterRho = .5,
                clusterCorstr = "exchangeable",
                xVariance = 1,
                numGroups = 5,
                groupSize = 4,
                groupRho = .5,
                beta = c(rep(1,8), rep(0,12)),
                family = poisson(),
                SNR = 10,
                intercept = 1)

</code></pre>

<hr>
<h2 id='hisee'>Hierarchical Stagewise Estimating Equations Implementation.</h2><span id='topic+hisee'></span><span id='topic+hisee.formula'></span><span id='topic+hisee.default'></span><span id='topic+hisee.fit'></span>

<h3>Description</h3>

<p>Function to perform HiSEE, a Bi-Level Boosting / Functional Gradient
Descent / Forward Stagewise regression in the grouped covariates
setting using Generalized Estimating Equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hisee(y, ...)

## S3 method for class 'formula'
hisee(formula, data = list(), clusterID, waves = NULL,
  contrasts = NULL, subset, ...)

## Default S3 method:
hisee(y, x, waves = NULL, ...)

## S3 method for class 'fit'
hisee(y, x, family, clusterID, waves = NULL,
  groupID = 1:ncol(x), corstr = "independence", alpha = NULL,
  intercept = TRUE, offset = 0, control = sgee.control(maxIt = 200,
  epsilon = 0.05, stoppingThreshold = min(length(y), ncol(x)) - intercept,
  undoThreshold = 0), standardize = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hisee_+3A_y">y</code></td>
<td>
<p>Vector of response measures that corresponds with modeling family
given in 'family' parameter. 'y' is assumed to be the same length as
'clusterID' and is assumed to be organized into clusters as dictated by
'clusterID'.</p>
</td></tr>
<tr><td><code id="hisee_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
<tr><td><code id="hisee_+3A_formula">formula</code></td>
<td>
<p>Object of class 'formula'; a symbolic description of
the model to be fitted</p>
</td></tr>
<tr><td><code id="hisee_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="hisee_+3A_clusterid">clusterID</code></td>
<td>
<p>Vector of integers that identifies the clusters of response
measures in 'y'. Data and 'clusterID' are assumed to 1) be of equal lengths,
2) sorted so that observations of a cluster are in contiguous rows, and 3)
organized so that 'clusterID' is a vector of consecutive integers.</p>
</td></tr>
<tr><td><code id="hisee_+3A_waves">waves</code></td>
<td>
<p>An integer vector which identifies components in clusters.
The length of <code>waves</code> should be the same as the number of
observations. <code>waves</code> is automatically generated if none is supplied,
but when using <code>subset</code> parameter, the <code>waves</code> parameter must be
provided by the user for proper calculation.</p>
</td></tr>
<tr><td><code id="hisee_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list provided when using a formula.
similar to <code>contrasts</code> from <code>glm</code>.
See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="hisee_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="hisee_+3A_x">x</code></td>
<td>
<p>Design matrix of dimension length(y) x nvars where each row is
represents an obersvation of predictor variables. Assumed to be scaled.</p>
</td></tr>
<tr><td><code id="hisee_+3A_family">family</code></td>
<td>
<p>Modeling family that describes the marginal distribution of
the response. Assumed to be an object such as 'gaussian()' or 'poisson()'</p>
</td></tr>
<tr><td><code id="hisee_+3A_groupid">groupID</code></td>
<td>
<p>Vector of integeres that identifies the groups of the
covariates/coefficients (i.e. the columns of 'x').  'x' and 'groupID' are
assumed 1) to be of corresponding dimension, (i.e. ncol(x) ==
length(groupID)), 2) sorted so that groups of covariates are in contiguous
columns, and 3) organized so that 'groupID' is a vector of consecutive
integers.</p>
</td></tr>
<tr><td><code id="hisee_+3A_corstr">corstr</code></td>
<td>
<p>A character string indicating the desired working correlation
structure. The following are implemented : &quot;independence&quot; (default value),
&quot;exchangeable&quot;, and &quot;ar1&quot;.</p>
</td></tr>
<tr><td><code id="hisee_+3A_alpha">alpha</code></td>
<td>
<p>An initial guess for the correlation parameter value
between -1 and 1 . If left NULL (the default), the initial estimate is 0.</p>
</td></tr>
<tr><td><code id="hisee_+3A_intercept">intercept</code></td>
<td>
<p>Binary value indicating where an intercept term is
to be included in the model for estimation. Default is to include an
intercept.</p>
</td></tr>
<tr><td><code id="hisee_+3A_offset">offset</code></td>
<td>
<p>Vector of offset value(s) for the linear predictor. 'offset'
is assumed to be either of length one, or of the same length as 'y'.
Default is to have no offset.</p>
</td></tr>
<tr><td><code id="hisee_+3A_control">control</code></td>
<td>
<p>A list of parameters used to contorl the path generation
process; see <code>sgee.control</code>.</p>
</td></tr>
<tr><td><code id="hisee_+3A_standardize">standardize</code></td>
<td>
<p>A logical parameter that indicates whether or not
the covariates need to be standardized before fitting.
If standardized before fitting, the unstandardized
path is returned as the default, with a <code>standardizedPath</code> and
<code>standardizedX</code> included
separately. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hisee_+3A_verbose">verbose</code></td>
<td>
<p>Logical parameter indicating whether output should be produced
while hisee is running. Default value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to implement HiSEE, a stagewise regression approach
that is designed to perform hierarchical selection in the context of
Generalized Estimating Equations. Given A response Y, design matrix X
(excluding intercept) HiSEE generates a path of stagewise regression
estimates for each covariate based on the provided step size epsilon.
First an optimal group of covariates is identified, and then an
optimal covariate within that group is selected and then updated in each
iterative step.
</p>
<p>The resulting path can then be analyzed to determine an optimal
model along the path of coefficient estimates. The
<code>summary.sgee</code> function provides such functionality based on various
possible metrics, primarily focused on the Mean Squared Error.
Furthermore, the <code>plot.sgee</code> function can be used to examine the
path of coefficient estimates versus the iteration number, or some
desired penalty.
</p>


<h3>Value</h3>

<p>Object of class 'sgee' containing the path of coefficient estimates,
the path of scale estimates, the path of correlation parameter
estimates, and the iteration at which HiSEE terminated, and initial
regression
values including <code>x</code>, <code>y</code>, codefamily, <code>clusterID</code>,
<code>groupID</code>, <code>offset</code>, <code>epsilon</code>, and <code>numIt</code>.
</p>


<h3>Note</h3>

<p>Function to execute HiSEE Technique. Functionally equivalent
to SEE when all elements in groupID are unique.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>References</h3>

<p>Vaughan, G., Aseltine, R., Chen, K., Yan, J., (2017). Stagewise
Generalized Estimating Equations with Grouped Variables. Biometrics 73,
1332-1342. URL: http://dx.doi.org/10.1111/biom.12669,
doi:10.1111/biom.12669.
</p>
<p>Wolfson, J. (2011). EEBoost: A general method for prediction
and variable selection based on estimating equations. Journal of the
American Statistical Association 106, 296&ndash;305.
</p>
<p>Tibshirani, R. J. (2015). A general framework for fast stagewise
algorithms. Journal of Machine Learning Research 16, 2543&ndash;2588.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####################
## Generate test data
#####################

## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2,5),
          c(1, 0, 1.5, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 5
numGroups &lt;- length(beta)/groupSize


generatedData &lt;- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         numGroups = numGroups,
                         groupSize = groupSize,
                         groupRho = 0.3,
                         beta = beta,
                         family = gaussian(),
                         intercept = 1)

## Perform Fitting by providing y and x values
coefMat1 &lt;- hisee(y = generatedData$y, x = generatedData$x,
                  family = gaussian(),
                  clusterID = generatedData$clusterID,
                  groupID = generatedData$groupID, 
                  corstr="exchangeable", 
                  control = sgee.control(maxIt = 50, epsilon = 0.5))
 
## Perform Fitting by providing formula and data
genDF &lt;- data.frame(generatedData$y, generatedData$x)
names(genDF) &lt;- c("Y", paste0("Cov", 1:p))
coefMat2 &lt;- hisee(formula(genDF), data = genDF,
                  family = gaussian(),
                  subset = Y&lt;1,
                  waves = rep(1:4, 50),
                  clusterID = generatedData$clusterID,
                  groupID = generatedData$groupID, 
                  corstr="exchangeable", 
                  control = sgee.control(maxIt = 50, epsilon = 0.5))
 
par(mfrow = c(2,1))
plot(coefMat1)
plot(coefMat2)

</code></pre>

<hr>
<h2 id='isee'>Interaction stagewise estimating equations</h2><span id='topic+isee'></span><span id='topic+isee.formula'></span><span id='topic+isee.default'></span><span id='topic+acts.fit'></span><span id='topic+hila.fit'></span>

<h3>Description</h3>

<p>Perform model selection with clustered data while considering interaction
terms using one of two stagewise methods. The first (ACTS) uses an active set
approach in which interaction terms are only considered for a given update
if the corresponding main effects have already been added to the model.
The second approach (HiLa) approximates the regularized path for
hierarchical lasso with Generalized Estimating Equations. In this second
approach, the model hierarchy is guaranteed in each individual step, thus
ensuring the desired hierarchy throughout the path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isee(y, ...)

## S3 method for class 'formula'
isee(formula, data = list(), clusterID, waves = NULL,
  interactionID = NULL, contrasts = NULL, subset, method = "ACTS", ...)

## Default S3 method:
isee(y, x, waves = NULL, interactionID, method = "ACTS",
  ...)

acts.fit(y, x, interactionID, family, clusterID, waves = NULL,
  corstr = "independence", alpha = NULL, intercept = TRUE, offset = 0,
  control = sgee.control(maxIt = 200, epsilon = 0.05, stoppingThreshold =
  min(length(y), ncol(x)) - intercept, undoThreshold = 0), standardize = TRUE,
  verbose = FALSE, ...)

hila.fit(y, x, interactionID, family, clusterID, waves = NULL,
  corstr = "independence", alpha = NULL, intercept = TRUE, offset = 0,
  control = sgee.control(maxIt = 200, epsilon = 0.05, stoppingThreshold =
  min(length(y), ncol(x)) - intercept, undoThreshold = 0.005),
  standardize = TRUE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isee_+3A_y">y</code></td>
<td>
<p>Vector of response measures that corresponds with modeling family
given in 'family' parameter. 'y' is assumed to be the same length as
'clusterID' and is assumed to be organized into clusters as dictated by
'clusterID'.</p>
</td></tr>
<tr><td><code id="isee_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
<tr><td><code id="isee_+3A_formula">formula</code></td>
<td>
<p>Object of class 'formula'; a symbolic description of
the model to be fitted</p>
</td></tr>
<tr><td><code id="isee_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="isee_+3A_clusterid">clusterID</code></td>
<td>
<p>Vector of integers that identifies the clusters of response
measures in 'y'. Data and 'clusterID' are assumed to 1) be of equal lengths,
2) sorted so that observations of a cluster are in contiguous rows, and 3)
organized so that 'clusterID' is a vector of consecutive integers.</p>
</td></tr>
<tr><td><code id="isee_+3A_waves">waves</code></td>
<td>
<p>An integer vector which identifies components in clusters.
The length of <code>waves</code> should be the same as the number of
observations. <code>waves</code> is automatically generated if none is supplied,
but when using <code>subset</code> parameter, the <code>waves</code> parameter must be
provided by the user for proper calculation.</p>
</td></tr>
<tr><td><code id="isee_+3A_interactionid">interactionID</code></td>
<td>
<p>A (p^2+p)/2 x 2 matrix of interaction IDs. Main effects
have the same (unique) number in both columns for their corresponding row.
Interaction effects have each of their corresponding main effects in the
two columns. it is assumed that main effects are listed first. It is
assumed that the main effect IDs used start at 1 and go up tp the number
of main effects, p.</p>
</td></tr>
<tr><td><code id="isee_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list provided when using a formula.
similar to <code>contrasts</code> from <code>glm</code>.
See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="isee_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="isee_+3A_method">method</code></td>
<td>
<p>A character string indicating desired method to be used to
perform interaction selection. Value can either be &quot;ACTS&quot;, where an active
set approach is taken and interaction terms are considered for selection
only after main effects are brought in, or &quot;HiLa&quot;, where the hierarchical
lasso penalty is used to ensure hierarchy is maintained in each step.
Default Value is &quot;ACTS&quot;.</p>
</td></tr>
<tr><td><code id="isee_+3A_x">x</code></td>
<td>
<p>Design matrix of dimension length(y) x nvars where each row is
represents an obersvation of predictor variables. Assumed to be scaled.</p>
</td></tr>
<tr><td><code id="isee_+3A_family">family</code></td>
<td>
<p>Modeling family that describes the marginal distribution of
the response. Assumed to be an object such as 'gaussian()' or 'poisson()'</p>
</td></tr>
<tr><td><code id="isee_+3A_corstr">corstr</code></td>
<td>
<p>A character string indicating the desired working correlation
structure. The following are implemented : &quot;independence&quot; (default value),
&quot;exchangeable&quot;, and &quot;ar1&quot;.</p>
</td></tr>
<tr><td><code id="isee_+3A_alpha">alpha</code></td>
<td>
<p>An intial guess for the correlation parameter value
between -1 and 1 . If left NULL (the default), the initial estimate is 0.</p>
</td></tr>
<tr><td><code id="isee_+3A_intercept">intercept</code></td>
<td>
<p>Binary value indicating where an intercept term is
to be included in the model for estimation. Default is to include an
intercept.</p>
</td></tr>
<tr><td><code id="isee_+3A_offset">offset</code></td>
<td>
<p>Vector of offset value(s) for the linear predictor. 'offset'
is assumed to be either of length one, or of the same length as 'y'.
Default is to have no offset.</p>
</td></tr>
<tr><td><code id="isee_+3A_control">control</code></td>
<td>
<p>A list of parameters used to contorl the path generation
process; see <code>sgee.control</code>.</p>
</td></tr>
<tr><td><code id="isee_+3A_standardize">standardize</code></td>
<td>
<p>A logical parameter that indicates whether or not
the covariates need to be standardized before fitting (but after generating
interaction terms from main covariates).
If standardized before fitting, the unstandardized
path is returned as the default, with a <code>standardizedPath</code> and
<code>standardizedX</code> included
separately. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="isee_+3A_verbose">verbose</code></td>
<td>
<p>Logical parameter indicating whether output should be produced
while isee is running. Default value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class 'sgee' containing the path of coefficient estimates,
the path of scale estimates, the path of correlation parameter
estimates, and the iteration at which iSEE terminated, and initial regression
values including <code>x</code>, <code>y</code>, codefamily, <code>clusterID</code>,
<code>interactionID</code>, <code>offset</code>, <code>epsilon</code>, and <code>numIt</code>.
</p>


<h3>Note</h3>

<p>While the two different possible methods that can be used with
<code>isee</code> reflect two different &quot;styles&quot; of stagewise estimation,
both achieve a desired hierarchy in the resulting model paths.
</p>
<p>When considering models with interaction terms, there are three forms
of hierarchy that may be present. Strong hierarchy implies that
interaction effects are included in the model only if both of its
corresponding main effects are also included in the model. Weak hierarchy
implies that an interaction effect can be in the model only if AT LEAST
one of its corresponding main effects is also included. The third type
of hierarchy is simply a lack of hierarchy; that is an interaction term
can be included regardless of main effects.
</p>
<p>In practice strong hierarchy is usually what is desired as it is the
simplest to interpret, but requires a higher amount of computation when
performing model selection. Weak hierarchy is sometimes used as a compromise
between the interpret-ability of strong hierarchy and the computational ease
of no hierarchy. Both <code>isee</code> methods only implement strong hierarchy
as the use of stagewise procedures greatly reduces the computational burden.
</p>
<p>The active set appraoch, ACTS, tends to have slightly better predictive
and model selection performance when the true model is closer to a purely
strong hierarchy, but HiLa tends to do better if the true model hierarchy
is closer to having a purely weak hierarchy. Thus, in practice, it is
important to use external information and judgement to determine which
approach is more appropriate.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>References</h3>

<p>Vaughan, G., Aseltine, R., Chen, K., Yan, J., (2017). Efficient
interaction selection for clustered data via stagewise generalized
estimating equations.  Department of Statistics, University of
Connecticut. Technical Report.
</p>
<p>Zhu, R., Zhao, H., and Ma, S. (2014). Identifying
gene-environment and gene-gene interactions using a progressive
penalization approach. Genetic Epidemiology 38, 353&ndash;368.
</p>
<p>Bien, J., Taylor, J., and Tibshirani, R. (2013). A lasso
for hierarchical interactions. The Annals of Statistics 41, 1111&ndash;1141.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####################
## Generate test data
#####################

## Initialize covariate values
p &lt;- 5 
beta &lt;- c(1, 0, 1.5, 0, .5, ## Main effects
          rep(0.5,4), ## Interaction terms
          0.5, 0, 0.5,
          0,1,
          0)


generatedData &lt;- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         beta = beta,
                         numMainEffects = p,
                         family = gaussian(),
                         intercept = 1)

 
## Perform Fitting by providing formula and data
genDF &lt;- data.frame(Y = generatedData$y, X = generatedData$xMainEff)

## Using "ACTS" method
coefMat1 &lt;- isee(formula(paste0("Y~(",
                               paste0("X.", 1:p, collapse = "+"),
                                 ")^2")),
                  data = genDF,
                  family = gaussian(),
                  clusterID = generatedData$clusterID,
                  corstr = "exchangeable",
                  method = "ACTS",
                  control = sgee.control(maxIt = 50, epsilon = 0.5))

## Using "HiLa" method
coefMat2 &lt;- isee(formula(paste0("Y~(",
                               paste0("X.", 1:p, collapse = "+"),
                                 ")^2")),
                  data = genDF,
                  family = gaussian(),
                  clusterID = generatedData$clusterID,
                  corstr = "exchangeable",
                  method = "HiLa",
                  control = sgee.control(maxIt = 50, epsilon = 0.5))

</code></pre>

<hr>
<h2 id='miniSim'>Mini Simulator</h2><span id='topic+miniSim'></span>

<h3>Description</h3>

<p>Function to do a miniature simulation testing the various grouped stagewise
techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miniSim(sampleSize = 50, clusterSize = 4, responseCor = 0.4,
  groupSparsity = "No Sparsity", xVariance = 1, covariateCor = 0.4,
  intercept = 1, SNR = 10, techniques = c("SEE", "BiSEE", "GSEE",
  "HiSEE"), stepSize = 0.125, maxNumSteps = 400, reps = 200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="miniSim_+3A_samplesize">sampleSize</code></td>
<td>
<p>Number of clusters to be used in each replicate.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_clustersize">clusterSize</code></td>
<td>
<p>Size of each cluster.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_responsecor">responseCor</code></td>
<td>
<p>Correlation parameter for response.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_groupsparsity">groupSparsity</code></td>
<td>
<p>String specifying within group sparsity level;
currently takes values 'No Sparsity', 'Mod Sparsity', or
'High Sparsity'.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_xvariance">xVariance</code></td>
<td>
<p>Scalar value indicating marginal variance of the
covariates.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_covariatecor">covariateCor</code></td>
<td>
<p>Correlation parameter used for within group correlation.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_intercept">intercept</code></td>
<td>
<p>Scalar value indicating the true intercept value.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_snr">SNR</code></td>
<td>
<p>Optional scalar value that allows fixing the signal
to noise ratio as defined as the ratio of the variance in the
linear predictor to the variance of the response conditioned on the
covariates.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_techniques">techniques</code></td>
<td>
<p>Vector of all techniques to be used for comparison;
default value of <code>c("SEE", "BiSEE", "GSEE", "HiSEE")</code> currently contains
all possible values.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_stepsize">stepSize</code></td>
<td>
<p>Stepsize to be used in stagewise techniques.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_maxnumsteps">maxNumSteps</code></td>
<td>
<p>Maximum number of steps to be taken by stagewise
techniques.</p>
</td></tr>
<tr><td><code id="miniSim_+3A_reps">reps</code></td>
<td>
<p>Number of replicates to be used for simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is currently under development and is thus not exported. Function
is intended to allow for simple simulation implementation to explore
the provided stagewise regression functions.
</p>


<h3>Value</h3>

<p>Simulation results.
</p>


<h3>Note</h3>

<p>Currently still under development, so not exported.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>

<hr>
<h2 id='plot.sgee'>Coefficient Traceplot Function</h2><span id='topic+plot.sgee'></span><span id='topic+plot.sgeeSummary'></span>

<h3>Description</h3>

<p>Function to produce the coefficent traceplot, with capabilities to
account for covariate groups. Used in place of the <code>plot</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgee'
plot(x, y, penaltyFun = NULL, main = NULL,
  xlab = "Iterations", ylab = expression(beta), dropIntercept = FALSE,
  trueBeta = NULL, color = TRUE, manualLineColors = NULL,
  pointSpacing = 3, cutOff = NULL, ...)

## S3 method for class 'sgeeSummary'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sgee_+3A_x">x</code></td>
<td>
<p>Path of coefficient Estimates.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_y">y</code></td>
<td>
<p>Optional parameter inherited from <code>plot(x,y,...)</code>; not used
with sgee.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_penaltyfun">penaltyFun</code></td>
<td>
<p>Optional function that when provided results ina plot
of the coefficient estimates verus the corresponding penalty value.
When no <code>penaltyFun</code> value is given,
the plot generated is of the coefficent
estimates versus the iteration number.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_main">main</code></td>
<td>
<p>Optional title of plot.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_xlab">xlab</code></td>
<td>
<p>Label of x axis; default value is 'Iterations'.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_ylab">ylab</code></td>
<td>
<p>Label of y axis; default value is the beta symbol.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_dropintercept">dropIntercept</code></td>
<td>
<p>Logical parameter indicating whether the intercept
estimates should be dropped from the plot (i.e. not plotted). The default is
FALSE.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_truebeta">trueBeta</code></td>
<td>
<p>The true coefficient values. If the true coefficient
values can be provided, then coefficient estimates that are false positive
identifications as non-zero are marked in the plot.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_color">color</code></td>
<td>
<p>Logical parameter indicating that a plot using colors
to differentiate coefficients is desired.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_manuallinecolors">manualLineColors</code></td>
<td>
<p>Vector of desired line colors; must match dimension
of line colors needed (i.e. same number of colors as there are groups if
grouped covariates are sharing a color).</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_pointspacing">pointSpacing</code></td>
<td>
<p>Space between marks used to indicate a coefficient
is a false positive. Spacing is measured in terms of number of indices
of the path matrix between marks.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_cutoff">cutOff</code></td>
<td>
<p>Integer value indicating that only the first <code>cutOff</code>
steps are to be plotted. Default value is <code>NULL</code>, indicating all
steps are to be plotted.</p>
</td></tr>
<tr><td><code id="plot.sgee_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plot.sgee is meant to allow for easy visualization of paths of stagewise
(or regularized) coefficient estimates. A great deal of flexibility is
provided in terms of how the plot is presented. The poenaltyFun paramter
allows for a penalty function to be provided (such as the $L_1$ norm)
to plot the coefficietn estimates against. 
When given the trueBeta parameter, the plot marks the paths of coefficient
estimates that are falsely identified as being non zero. Finally, a switch
for black and white versus color plots is provided (<code>color</code>).
</p>


<h3>Note</h3>

<p>Function is intended to give a visual representation of the
coefficient estimates. Which x values to compare the estimates to can
depend on the situation, but typically the most versatile measure
to use is the sum of absolute values, the $L_1$ norm; especially when
comparing different coefficient paths from different techniques.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#####################
## Generate test data
#####################

## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2.4,5),
          c(1.3, 0, 1.7, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 1
numGroups &lt;- length(beta)/groupSize



generatedData &lt;- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         numGroups = numGroups,
                         groupSize = groupSize,
                         groupRho = 0.3,
                         beta = beta,
                         family = gaussian(),
                         intercept = 0)

genDF &lt;- data.frame(generatedData$y, generatedData$x)
coefMat &lt;- bisee(formula(genDF),
                 data = genDF,
                 lambda1 = 0,         ##effectively see
                 lambda2 = 1,
                 family = gaussian(),
                 clusterID = generatedData$clusterID, 
                 corstr="exchangeable", 
                 maxIt = 200,
                 epsilon = .1)
############################
## Various options for plots
############################

par(mfrow = c(2,2))

## plain useage
plot(coefMat, main = "Plain Usage")

## With penalty
plot(coefMat, penaltyFun = function(x){sum(abs(x))}, xlab
= expression(abs(abs(beta))[1]), main = "With Penalty")

## using true beta value to highlight misclassifications
plot(coefMat, trueBeta = beta, main = "ID Missclassification")

## black and white option
plot(coefMat, trueBeta = beta, color = FALSE, main =
"Black and White", pointSpacing = 5)



</code></pre>

<hr>
<h2 id='print.sgee'><code>print</code> function for sgee</h2><span id='topic+print.sgee'></span>

<h3>Description</h3>

<p>Provides implementation of <code>print</code> function for <code>sgee</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgee'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sgee_+3A_x">x</code></td>
<td>
<p>Object of class <code>sgee</code>, from which various path
information is pulled.</p>
</td></tr>
<tr><td><code id="print.sgee_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####################
## Generate test data
#####################

## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2,5),
          c(1, 0, 1.5, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 5
numGroups &lt;- length(beta)/groupSize


generatedData &lt;- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         numGroups = numGroups,
                         groupSize = groupSize,
                         groupRho = 0.3,
                         beta = beta,
                         family = gaussian(),
                         intercept = 1)

genDF &lt;- data.frame(generatedData$y, generatedData$x)
names(genDF) &lt;- c("Y", paste0("Cov", 1:p))
coefMat &lt;- hisee(formula(genDF), data = genDF,
                 family = gaussian(),
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr="exchangeable", 
                 maxIt = 50,
                 epsilon = .5)

print(coefMat)

</code></pre>

<hr>
<h2 id='print.sgeeSummary'><code>print</code> function for sgee summaries</h2><span id='topic+print.sgeeSummary'></span>

<h3>Description</h3>

<p>Provides implementation of <code>print</code> function for summaries of sgee
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgeeSummary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sgeeSummary_+3A_x">x</code></td>
<td>
<p>An object of the <code>sgeeSummary</code> class, produced by
applying the <code>summary</code> function to an object of class <code>sgee</code>.</p>
</td></tr>
<tr><td><code id="print.sgeeSummary_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####################
## Generate test data
#####################

## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2,5),
          c(1, 0, 1.5, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 5
numGroups &lt;- length(beta)/groupSize


generatedData &lt;- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         numGroups = numGroups,
                         groupSize = groupSize,
                         groupRho = 0.3,
                         beta = beta,
                         family = gaussian(),
                         intercept = 1)

genDF &lt;- data.frame(generatedData$y, generatedData$x)
names(genDF) &lt;- c("Y", paste0("Cov", 1:p))
coefMat &lt;- hisee(formula(genDF), data = genDF,
                 family = gaussian(),
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr="exchangeable", 
                 maxIt = 50,
                 epsilon = .5)

sgeeSum &lt;- summary(coefMat)
print(sgeeSum)

</code></pre>

<hr>
<h2 id='samplingDistCalculation'>samplingDistCalculation</h2><span id='topic+samplingDistCalculation'></span>

<h3>Description</h3>

<p>Internal function to set up subsampling distribution
to execute the stochastic version of a stagewise approach.
The subsampling is coducted at the cluster level, not the
individual observation level. Sampling probabilities are first
calculated or provided for each observation individually, and
then the sampling probability for each cluster is taken to be
the average probability across all observations in the cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplingDistCalculation(sampleProb, y, x, clusterID, waves, beta, beta0, phi,
  alpha, offset, meanLinkInv, varianceLink, corstr, mu.eta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="samplingDistCalculation_+3A_sampleprob">sampleProb</code></td>
<td>
<p>A user provided value for the probability associated
with each observation. <code>sampleProb</code> can be provided as 1) a vector of
fixed values of length equal to the resposne vector y, 2) a function
that takes in a list of values (full list of values given in details)
and returns a vector of length equal to the response vector y, or 3) the
default value of <code>NULL</code>, which results in a uniform distribution</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_y">y</code></td>
<td>
<p>The vector of the response values provided to the original
stagewise function</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_x">x</code></td>
<td>
<p>The covariate matrix provided to the original stagewise function</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_clusterid">clusterID</code></td>
<td>
<p>The vector of cluster ID numbers provided to the original
stagewise function</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_waves">waves</code></td>
<td>
<p>The waves parameter identifying the order of observations
within the clusters that is provided to the original stagewise function</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_beta">beta</code></td>
<td>
<p>The vector of the current estimates of the coefficients</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_beta0">beta0</code></td>
<td>
<p>The current estimate of the intercept</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_phi">phi</code></td>
<td>
<p>Current estimate of the scale parameter</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_alpha">alpha</code></td>
<td>
<p>Current estimate of the parameter affecting the within
cluster correlation</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_offset">offset</code></td>
<td>
<p>offset in the linear predictor provided to the original
stagewise function</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_meanlinkinv">meanLinkInv</code></td>
<td>
<p>The link inverse function from the <code>family</code>
object provided to the original stagewise function indicating what family
of mean and variance structure is assumed</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_variancelink">varianceLink</code></td>
<td>
<p>The variance link function from the <code>family</code>
object provided to the original stagewise function indicating what family
of mean and variance structure is assumed</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_corstr">corstr</code></td>
<td>
<p>The structure of the working correlation matrix that was
provided to the original stagewise function</p>
</td></tr>
<tr><td><code id="samplingDistCalculation_+3A_mu.eta">mu.eta</code></td>
<td>
<p>Derivative function of mu, the conditional mean of the
response, with respect to eta, the linear predictor, from the <code>family</code>
object provided to the original stagewise function indicating what family
of mean and variance structure is assumed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sampling distribution probabilities to be used for the sub
sampling. distribution is provided as a vector with length equal to the
number of clusters.
</p>


<h3>Note</h3>

<p>Internal function.
</p>
<p>The function provided to <code>sampleProb</code> (through the
<code>sgee.control</code> function) needs to calculate
probabilities for each observation in the response vector <code>y</code>.
How these calculations are done is up to the user and the following
values are provided to the <code>sampleProb</code> function as a list called
<code>values</code>: <code>y</code>, <code>x</code>, <code>clusterID</code>, <code>waves</code>,
<code>beta</code>, <code>beta0</code>, <code>phi</code>, <code>alpha</code>, <code>offset</code>,
<code>meanLinkInv</code>, <code>varianceLink</code>, <code>corstr</code>, <code>mu.eta</code>.
additionally, all of the values produced by <code>sampleProb</code> need to be
non-negative.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>

<hr>
<h2 id='see'>Stagewise Estimating Equations Implementation</h2><span id='topic+see'></span><span id='topic+see.formula'></span><span id='topic+see.default'></span><span id='topic+see.fit'></span>

<h3>Description</h3>

<p>Function to perform SEE, a  Forward Stagewise regression
approach for model selection / dimension reduction
using Generalized Estimating Equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>see(y, ...)

## S3 method for class 'formula'
see(formula, data = list(), clusterID, waves = NULL,
  contrasts = NULL, subset, ...)

## Default S3 method:
see(y, x, waves = NULL, ...)

## S3 method for class 'fit'
see(y, x, family, clusterID, waves = NULL,
  corstr = "independence", alpha = NULL, intercept = TRUE, offset = 0,
  control = sgee.control(maxIt = 200, epsilon = 0.05, stoppingThreshold =
  min(length(y), ncol(x)) - intercept, undoThreshold = 0), standardize = TRUE,
  verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="see_+3A_y">y</code></td>
<td>
<p>Vector of response measures that corresponds with modeling family
given in 'family' parameter. <code>y</code> is assumed to be the same length as
<code>clusterID</code> and is assumed to be organized into clusters as dictated by
<code>clusterID</code>.</p>
</td></tr>
<tr><td><code id="see_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
<tr><td><code id="see_+3A_formula">formula</code></td>
<td>
<p>Object of class 'formula'; a symbolic description of
the model to be fitted</p>
</td></tr>
<tr><td><code id="see_+3A_data">data</code></td>
<td>
<p>Optional data frame containing the variables in the model.</p>
</td></tr>
<tr><td><code id="see_+3A_clusterid">clusterID</code></td>
<td>
<p>Vector of integers that identifies the clusters of response
measures in <code>y</code>. Data and <code>clusterID</code> are assumed to
1) be of equal lengths,
2) sorted so that observations of a cluster are in contiguous rows, and 3)
organized so that <code>clusterID</code> is a vector of consecutive integers.</p>
</td></tr>
<tr><td><code id="see_+3A_waves">waves</code></td>
<td>
<p>An integer vector which identifies components in clusters.
The length of <code>waves</code> should be the same as the number of
observations. <code>waves</code> is automatically generated if none is supplied,
but when using <code>subset</code> parameter, the <code>waves</code> parameter must be
provided by the user for proper calculation.</p>
</td></tr>
<tr><td><code id="see_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list provided when using a formula.
similar to <code>contrasts</code> from <code>glm</code>.
See the <code>contrasts.arg</code> of <code>model.matrix.default</code>.</p>
</td></tr>
<tr><td><code id="see_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="see_+3A_x">x</code></td>
<td>
<p>Design matrix of dimension <code>length(y)</code> x nvar,
the number of variables, where each row is
represents an observation of predictor variables.</p>
</td></tr>
<tr><td><code id="see_+3A_family">family</code></td>
<td>
<p>Modeling family that describes the marginal distribution of
the response. Assumed to be an object such as <code>gaussian()</code> or
<code>poisson()</code>.</p>
</td></tr>
<tr><td><code id="see_+3A_corstr">corstr</code></td>
<td>
<p>A character string indicating the desired working correlation
structure. The following are implemented : &quot;independence&quot; (default value),
&quot;exchangeable&quot;, and &quot;ar1&quot;.</p>
</td></tr>
<tr><td><code id="see_+3A_alpha">alpha</code></td>
<td>
<p>An initial guess for the correlation parameter value
between -1 and 1 . If left NULL (the default), the initial estimate is 0.</p>
</td></tr>
<tr><td><code id="see_+3A_intercept">intercept</code></td>
<td>
<p>Binary value indicating where an intercept term is
to be included in the model for estimation. Default is to include an
intercept.</p>
</td></tr>
<tr><td><code id="see_+3A_offset">offset</code></td>
<td>
<p>Vector of offset value(s) for the linear predictor.
<code>offset</code>
is assumed to be either of length one, or of the same length as <code>y</code>.
Default is to have no offset.</p>
</td></tr>
<tr><td><code id="see_+3A_control">control</code></td>
<td>
<p>A list of parameters used to contorl the path generation
process; see <code>sgee.control</code>.</p>
</td></tr>
<tr><td><code id="see_+3A_standardize">standardize</code></td>
<td>
<p>A logical parameter that indicates whether or not
the covariates need to be standardized before fitting.
If standardized before fitting, the unstandardized
path is returned as the default, with a <code>standardizedPath</code> and
<code>standardizedX</code> included
separately. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="see_+3A_verbose">verbose</code></td>
<td>
<p>Logical parameter indicating whether output should be produced
while bisee is running. Default value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to implement SEE, a stagewise regression approach
that is designed to perform model selection in the context of
Generalized Estimating Equations. Given a response <code>y</code> and
a design matrix <code>x</code>
(excluding intercept) SEE generates a path of stagewise regression
estimates for each covariate based on the provided step size <code>epsilon</code>.
</p>
<p>The resulting path can then be analyzed to determine an optimal
model along the path of coefficient estimates. The
<code>summary.sgee</code> function provides such
functionality based on various
possible metrics, primarily focused on the Mean Squared Error.
Furthermore, the <code>plot.sgee</code> function can be used to examine the
path of coefficient estimates versus the iteration number, or some
desired penalty.
</p>
<p>A stochastic version of this function can also be called. using the
auxiliary function <code>sgee.control</code> the parameters <code>stochastic</code>,
<code>reSample</code>, and <code>withReplacement</code> can be given to <code>see</code>
to perform a sub sampling step in the procedure to make the SEE
implementation scalable for large data sets.
</p>


<h3>Value</h3>

<p>Object of class <code>sgee</code> containing the path
of coefficient estimates,
the path of scale estimates, the path of correlation parameter
estimates, the iteration at which SEE terminated, and initial regression
values including <code>x</code>, <code>y</code>, codefamily, <code>clusterID</code>,
<code>groupID</code>, <code>offset</code>, <code>epsilon</code>, and <code>numIt</code>.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>References</h3>

<p>Vaughan, G., Aseltine, R., Chen, K., Yan, J., (2017). Stagewise
Generalized Estimating Equations with Grouped Variables. Biometrics 73,
1332-1342. URL: http://dx.doi.org/10.1111/biom.12669,
doi:10.1111/biom.12669.
</p>
<p>Wolfson, J. (2011). EEBoost: A general method for prediction
and variable selection based on estimating equations. Journal of the
American Statistical Association 106, 296&ndash;305.
</p>
<p>Tibshirani, R. J. (2015). A general framework for fast stagewise
algorithms. Journal of Machine Learning Research 16, 2543&ndash;2588.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#####################
## Generate test data
#####################

## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2,5),
          c(1, 0, 1.5, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 1
numGroups &lt;- length(beta)/groupSize


generatedData &lt;- genData(numClusters = 50,
                         clusterSize = 4,
                         clusterRho = 0.6,
                         clusterCorstr = "exchangeable",
                         yVariance = 1,
                         xVariance = 1,
                         numGroups = numGroups,
                         groupSize = groupSize,
                         groupRho = 0.3,
                         beta = beta,
                         family = gaussian(),
                         intercept = 1)



## Perform Fitting by providing formula and data
genDF &lt;- data.frame(generatedData$y, generatedData$x)
names(genDF) &lt;- c("Y", paste0("Cov", 1:p))
coefMat1 &lt;- see(formula(genDF), data = genDF,
                 family = gaussian(),
                 waves = rep(1:4, 50), 
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr = "exchangeable",
                 control = sgee.control(maxIt = 50, epsilon = 0.5),
                 verbose = TRUE)

## set parameter 'stochastic' to 0.5 to implement the stochastic
## stagewise approach where a subsmaple of 50% of the data is taken
## before the path is calculation.
## See sgee.control for more details about the parameters for the
## stochastic stagewise approach

coefMat2 &lt;- see(formula(genDF), data = genDF,
                 family = gaussian(),
                 waves = rep(1:4, 50), 
                 clusterID = generatedData$clusterID,
                 groupID = generatedData$groupID, 
                 corstr = "exchangeable",
                 control = sgee.control(maxIt = 50, epsilon = 0.5,
                                        stochastic = 0.5), 
                 verbose = FALSE)

par(mfrow = c(2,1))
plot(coefMat1)
plot(coefMat2)

</code></pre>

<hr>
<h2 id='sgee.control'>Auxiliary for Controlling SGEE fitting</h2><span id='topic+sgee.control'></span>

<h3>Description</h3>

<p>Auxiliary function for <code>sgee</code> fitting functions. Specifies
parameters used by all <code>sgee</code> fitting functions in terms
of the path generation; i.e. step size <code>epsilon</code>, maximum number of
iterations <code>maxIt</code>, and the threshold for premature stopping
<code>stoppingthreshold</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgee.control(maxIt = 200, epsilon = 0.05, stoppingThreshold = NULL,
  undoThreshold = 0.005, interceptLimit = NULL, stochastic = 1,
  sampleProb = NULL, reSample = 1, withReplacement = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sgee.control_+3A_maxit">maxIt</code></td>
<td>
<p>Maximum number of iterations of the stagewise algorithm to be
executed. Default is 200.</p>
</td></tr>
<tr><td><code id="sgee.control_+3A_epsilon">epsilon</code></td>
<td>
<p>Step size to be used when incrementing coefficient value(s)
in each iteration. Default is 0.05.</p>
</td></tr>
<tr><td><code id="sgee.control_+3A_stoppingthreshold">stoppingThreshold</code></td>
<td>
<p>An integer value that indicates the maximum number
of allowed covariates in the model. Once the algorithm has reached the value
of <code>stoppingThreshold</code>, the algorithm will stop without completing any
remaining iterations. The number of covariates to be included cannot exceed
the number of observations. The default value is typically
the minimum of the number
of covariates and the number of observations, minus 1 if an intercept is
included.</p>
</td></tr>
<tr><td><code id="sgee.control_+3A_undothreshold">undoThreshold</code></td>
<td>
<p>A small value used to determine if consecutive
steps are sufficiently different. If consecutive steps effectively undo each
other (as indicated by having a sum with an absolute value less than
<code>undoThreshold</code>), then the steps are repeated and the stepsize is
reduced. A negative value for <code>undoThreshold</code> effectively prevents
this step. <code>undoThreshold</code> should only be big enough to allow for
some rounding error in steps and should be much smaller than the step size.
Default value is 0.005.</p>
</td></tr>
<tr><td><code id="sgee.control_+3A_interceptlimit">interceptLimit</code></td>
<td>
<p>sgee functions make use of the extendInt parameter
of uniroot to estimate the intercept in each iteration. This parameter
was recently implemented and thus may cause issues with older versions of R.
If a value is given for <code>interceptLimit</code>, then this extendInt parameter
is bypassed and a solution for the intercept estimating equation is sought
out between negative <code>interceptLimit</code> and positive
<code>interceptLimit</code>. The default value of <code>NULL</code> uses the
extendInt functionality.</p>
</td></tr>
<tr><td><code id="sgee.control_+3A_stochastic">stochastic</code></td>
<td>
<p>A numeric value between 0 (exclusive) and 1 (inclusive)
to indicate what proportion of the data should be subsampled
in the stochastic implementation of stagewise approached. The default value
of 1 implements the standard deterministic approach where no subsampling
is done.</p>
</td></tr>
<tr><td><code id="sgee.control_+3A_sampleprob">sampleProb</code></td>
<td>
<p>A user provided value dictating the
probability distribution for stochastic stagewise approaches.
<code>sampleProb</code> can be provided as 1) a vector of
fixed values of length equal to the resposne vector y, 2) a function
that takes in a list of values (full list of values given in details)
and returns a vector of length equal to the response vector y, or 3) the
default value of <code>NULL</code>, which results in a uniform distribution</p>
</td></tr>
<tr><td><code id="sgee.control_+3A_resample">reSample</code></td>
<td>
<p>Parameter indicating how frequently a subsample is
collected in stochastic stagewise approaches. If reSample == 1 then
a subsample is collected every iteration,if reSample == 2 a subsample
is collected every two (i.e every other) iteration. If reSample == 0,
(the default value) then a subsample is only collected once
before any iterations have been done.</p>
</td></tr>
<tr><td><code id="sgee.control_+3A_withreplacement">withReplacement</code></td>
<td>
<p>a Logical value indicating if the subsampling in
stochastic stagewise approaches should be done with or without replacement.
Default values is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing all of the parameter values.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>

<hr>
<h2 id='subsample'>subsample</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>Internal function to execute the subsampling component of
the stochastic stagewise approach. If a user provides a <code>stochastic</code>
value between 0 and 1, it is assumed that some proportion of subsampling
is desired. The <code>samplingDistCalculation</code> function calculates the
distribution of the clusters and the <code>subsample</code> function uses that
distribution to draw the actual subsample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(sampleDist, sampleSize, withReplacement, clusterIDs, clusterID)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subsample_+3A_sampledist">sampleDist</code></td>
<td>
<p>A vector whose length is equal to the number of clusters
that indicates the probability of sampling each cluster</p>
</td></tr>
<tr><td><code id="subsample_+3A_samplesize">sampleSize</code></td>
<td>
<p>A scalar value indicating how larger of a subsample is
being drawn</p>
</td></tr>
<tr><td><code id="subsample_+3A_withreplacement">withReplacement</code></td>
<td>
<p>A logical value indicating whether the
subsampling is beign done with or without replacement</p>
</td></tr>
<tr><td><code id="subsample_+3A_clusterids">clusterIDs</code></td>
<td>
<p>A vector of all of the UNIQUE cluster IDs</p>
</td></tr>
<tr><td><code id="subsample_+3A_clusterid">clusterID</code></td>
<td>
<p>A vector of length equal to the number of observations
indicating which cluster each observation is in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two variables: <code>subSampleIndicator</code>, which
indicates which observations are in the current subsample, and
<code>clusterIDCurr</code>, which indicates the clusterID for the subsample.
</p>


<h3>Note</h3>

<p>Internal function.
</p>
<p>While most of the subsample can be determined from the
<code>subSampleIndicator</code>, the <code>clusterIDCurr</code> value has to be
constructed inside the <code>subsample function</code> as the way the cluster
IDs is handled is different depending o n whether we are sampling with
or without replacement.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>

<hr>
<h2 id='summary.sgee'>Coefficient Path summary</h2><span id='topic+summary.sgee'></span>

<h3>Description</h3>

<p>Function to analyze  and summarize a path of coefficent values by
comparing them using
prediction error on a \&quot;new\&quot; data set (or fold in CV), or the
original data set if no comparison data is provided. The best point along
the path in terms of the prediction error is identified. All of the
prediction errors for each point along the path, the minimum prediction
error, and the index of the minimum are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgee'
summary(object, newX = NULL, newY = NULL, newOffset = NULL,
  trueBeta = NULL, trueIntercept = NULL, scale = NULL,
  classification = 0.5, averaged = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sgee_+3A_object">object</code></td>
<td>
<p>Object of class <code>sgee</code>, from which various path
information is pulled.</p>
</td></tr>
<tr><td><code id="summary.sgee_+3A_newx">newX</code></td>
<td>
<p>Design matrix to be used for model testing. It is assumed
that <code>newX</code> does not contain an intercept column. An intercept column
is appended by<code>sgee.summary</code> if an intercept was used to make
<code>object</code>.</p>
</td></tr>
<tr><td><code id="summary.sgee_+3A_newy">newY</code></td>
<td>
<p>Response vector to be used for model testing.</p>
</td></tr>
<tr><td><code id="summary.sgee_+3A_newoffset">newOffset</code></td>
<td>
<p>Vector of offsets to be used for model testing. Must be
same length as newY.</p>
</td></tr>
<tr><td><code id="summary.sgee_+3A_truebeta">trueBeta</code></td>
<td>
<p>For simulation use; true coefficient values can be provided
to get certain metrics.</p>
</td></tr>
<tr><td><code id="summary.sgee_+3A_trueintercept">trueIntercept</code></td>
<td>
<p>For simulation use; true intercept value to be used in
conjunction with trueBeta.</p>
</td></tr>
<tr><td><code id="summary.sgee_+3A_scale">scale</code></td>
<td>
<p>Scale value can be passed to allow for standardized error
measurements (poisson case only).</p>
</td></tr>
<tr><td><code id="summary.sgee_+3A_classification">classification</code></td>
<td>
<p>A numeric parameter from 0 to 1 indicating
cutoff to be used to determine classification rate in Binomial
setting. Default is 0.5. Values below 0 indicate that the
squared error, in either the observation
or the true linear predictor is the trueBeta is given, is to be used
instead of the classification rate.</p>
</td></tr>
<tr><td><code id="summary.sgee_+3A_averaged">averaged</code></td>
<td>
<p>Logical parameter indicating whether the mean of the
total error is to be used; assumed TRUE.</p>
</td></tr>
<tr><td><code id="summary.sgee_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prediction error used is dependent on the input. If the true Beta is
not given, then the sum squared error (or MSE; see parameter averaged)
in the response is used for gaussian (or non-poisson); for poisson
if the scale (or an estimate) is also given, then the sum squared Pearson
residuals are used, otherwise the deviance is used. If the true Beta is
provided then the sum squared error in the linear predictor is used instead.
</p>
<p>Furthermore, when true Beta is supplied, additional model selection metrics
are produced, including: False Positive Rate, False Discovery Rate,
False Negative Rate.
</p>
<p>The function is provided to allow for model selection; given
a path generated by a sgee function, the path can be fed into this function
with a testing data set to identify an optimal point along the path.
Cross validation can be performed by dividing the original data set
into k folds before hand and generating multiple coefficient paths and
applying this function to each path generated.
</p>


<h3>Value</h3>

<p>A list containing  1) a vector of prediction errors with
testing data set, 2) the smallest prediction error found along path,
3) the index of the smallest error, and if the trueBeta parameter is
provided the False Positive, False Discovery, and false negative
rates, and True positive and False Positive counts
at the index of the smallest error, along with the minimum
mis-classification and corresponding index, where the mis-classification
is the total of the coefficients incorrectly marked as important/unimportant.
</p>


<h3>Author(s)</h3>

<p>Gregory Vaughan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Initialize covariate values
p &lt;- 50 
beta &lt;- c(rep(2.4,5),
          c(1.3, 0, 1.7, 0, .5),
          rep(0.5,5),
          rep(0,p-15))
groupSize &lt;- 1
numGroups &lt;- length(beta)/groupSize



trainingData &lt;- genData(numClusters = 50,
                        clusterSize = 4,
                        clusterRho = 0.6,
                        clusterCorstr = "exchangeable",
                        yVariance = 1,
                        xVariance = 1,
                        numGroups = numGroups,
                        groupSize = groupSize,
                        groupRho = 0.3,
                        beta = beta,
                        family = gaussian(),
                        intercept = 1)

testingData &lt;- genData(numClusters = 50,
                       clusterSize = 4,
                       clusterRho = 0.6,
                       clusterCorstr = "exchangeable",
                       yVariance = 1,
                       xVariance = 1,
                       numGroups = numGroups,
                       groupSize = groupSize,
                       groupRho = 0.3,
                       beta = beta,
                       family = gaussian(),
                       intercept = 1)

coefMat &lt;- see(y = trainingData$y,
               x = trainingData$x,
                    family = gaussian(),
                    clusterID = trainingData$clusterID, 
                    corstr="exchangeable", 
                    maxIt = 200,
                    epsilon = .1)

analysisResults &lt;- summary(coefMat,
                           newX = testingData$x,
                           newY = testingData$y)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
