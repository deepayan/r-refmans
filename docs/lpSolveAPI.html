<!DOCTYPE html><html lang="en"><head><title>Help for package lpSolveAPI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lpSolveAPI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add.column'><p>Add Column</p></a></li>
<li><a href='#add.constraint'><p>Add Constraint</p></a></li>
<li><a href='#add.SOS'><p>Add A Special Ordered Set Constraint</p></a></li>
<li><a href='#delete.column'><p>Delete Column</p></a></li>
<li><a href='#delete.constraint'><p>Delete Constraint</p></a></li>
<li><a href='#delete.lp'><p>Delete Linear Program Model</p></a></li>
<li><a href='#dim.lpExtPtr'><p>Dimension of an Object</p></a></li>
<li><a href='#dimnames.lpExtPtr'><p>Dimnames of an Object</p></a></li>
<li><a href='#get.basis'><p>Get Basis</p></a></li>
<li><a href='#get.bounds'><p>Get Bounds</p></a></li>
<li><a href='#get.branch.mode'><p>Get Branch Mode</p></a></li>
<li><a href='#get.column'><p>Get Column</p></a></li>
<li><a href='#get.constr.type'><p>Get Constraint Type</p></a></li>
<li><a href='#get.constr.value'><p>Get Constraint Value</p></a></li>
<li><a href='#get.constraints'><p>Get Constraints</p></a></li>
<li><a href='#get.dual.solution'><p>Get Dual Solution</p></a></li>
<li><a href='#get.kind'><p>Get Kind</p></a></li>
<li><a href='#get.mat'><p>Get Matrix Element</p></a></li>
<li><a href='#get.objective'><p>Get Objective</p></a></li>
<li><a href='#get.primal.solution'><p>Get Primal Solution</p></a></li>
<li><a href='#get.rhs'><p>Get Right-Hand-Side</p></a></li>
<li><a href='#get.sensitivity.obj'><p>Get Sensitivity: Objective</p></a></li>
<li><a href='#get.sensitivity.objex'><p>Get Sensitivity: Objective Extended</p></a></li>
<li><a href='#get.sensitivity.rhs'><p>Get Sensitivity: Right-Hand-Side</p></a></li>
<li><a href='#get.solutioncount'><p>Get Solution Count</p></a></li>
<li><a href='#get.total.iter'><p>Get Total Iterations</p></a></li>
<li><a href='#get.total.nodes'><p>Get Total Nodes</p></a></li>
<li><a href='#get.type'><p>Get Type</p></a></li>
<li><a href='#get.variables'><p>Get Variables</p></a></li>
<li><a href='#guess.basis'><p>Guess Basis</p></a></li>
<li><a href='#lp.control'><p>lpSolve Control Parameters</p></a></li>
<li><a href='#lp.control.options'><p>Solver Control Options</p></a></li>
<li><a href='#make.lp'><p>Make LP</p></a></li>
<li><a href='#name.lp'><p>Name LP</p></a></li>
<li><a href='#plot.lpExtPtr'><p>lpExtPtr Plot Method</p></a></li>
<li><a href='#print.lpExtPtr'><p>lpSolve Print Method</p></a></li>
<li><a href='#read.lp'><p>Read LP</p></a></li>
<li><a href='#resize.lp'><p>Resize LP</p></a></li>
<li><a href='#row.add.mode'><p>Row Add Mode</p></a></li>
<li><a href='#select.solution'><p>Select Solution</p></a></li>
<li><a href='#set.basis'><p>Set Basis</p></a></li>
<li><a href='#set.bounds'><p>Set Bounds</p></a></li>
<li><a href='#set.branch.mode'><p>Set Branch Mode</p></a></li>
<li><a href='#set.branch.weights'><p>Set Branch Weights</p></a></li>
<li><a href='#set.column'><p>Set Column</p></a></li>
<li><a href='#set.constr.type'><p>Set Constraint Type</p></a></li>
<li><a href='#set.constr.value'><p>Set Constraint Value</p></a></li>
<li><a href='#set.mat'><p>Set Matrix Element</p></a></li>
<li><a href='#set.objfn'><p>Set Objective Function</p></a></li>
<li><a href='#set.rhs'><p>Set Right-Hand-Side</p></a></li>
<li><a href='#set.row'><p>Set Row</p></a></li>
<li><a href='#set.semicont'><p>Set Semicontinuous</p></a></li>
<li><a href='#set.type'><p>Set Type</p></a></li>
<li><a href='#solve.lpExtPtr'><p>Solve a Linear Program</p></a></li>
<li><a href='#write.lp'><p>Write Linear Program</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>5.5.2.0-17.12</td>
</tr>
<tr>
<td>Title:</td>
<td>R Interface to 'lp_solve' Version 5.5.2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>lp_solve &lt;https://lpsolve.sourceforge.net/&gt; [aut],
        Kjell Konis [aut],
        Florian Schwendinger [aut, cre],
        Kurt Hornik [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Schwendinger &lt;FlorianSchwendinger@gmx.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The lpSolveAPI package provides an R interface to 'lp_solve',
    a Mixed Integer Linear Programming (MILP) solver with support for pure
    linear, (mixed) integer/binary, semi-continuous and special ordered sets
    (SOS) models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-19 06:13:53 UTC; f</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-19 06:40:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='add.column'>Add Column</h2><span id='topic+add.column'></span>

<h3>Description</h3>

<p>Add a column to an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.column(lprec, x, indices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.column_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="add.column_+3A_x">x</code></td>
<td>
<p>a numeric vector containing the elements (only the nonzero elements if the <code>indices</code> argument is also provided) of the column to be added. The length of <code>x</code> must be equal to the number of constraints in <code>lprec</code> unless <code>indices</code> is provided.</p>
</td></tr>
<tr><td><code id="add.column_+3A_indices">indices</code></td>
<td>
<p>optional for sparse <code>x</code>. A numeric vector the same length as <code>x</code> of unique values from the set {0, ..., m} where m is the number of constraints in <code>lprec</code>; <code>x[i]</code> is entered into constraint <code>indices[i]</code> in the added column.  The coefficients for the constraints not in <code>indices</code> are set to zero.  In particular, index <code>0</code> is the objective function coefficient in the added column and is set to zero by default. This argument should be omitted when <code>length(x) == m</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds an additional column to an lpSolve linear program model object.  If multiple columns are to be added, performance can be improved by calling <code><a href="#topic+resize.lp">resize.lp</a></code> before adding the columns.
</p>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+resize.lp">resize.lp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 0)
add.column(lps.model, c(6,2,4,9))
add.column(lps.model, c(3,1,5), indices = c(1,2,4))
</code></pre>

<hr>
<h2 id='add.constraint'>Add Constraint</h2><span id='topic+add.constraint'></span>

<h3>Description</h3>

<p>Add a constraint to an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.constraint(lprec, xt, type = c("&lt;=", "=", "&gt;="), rhs, indices, lhs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.constraint_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_xt">xt</code></td>
<td>
<p>a numeric vector containing the constraint coefficients (only the nonzero coefficients if <code>indices</code> is also given). The length of <code>xt</code> must be equal to the number of decision variables in <code>lprec</code> unless <code>indices</code> is provided.</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_type">type</code></td>
<td>
<p>a numeric or character value from the set <code>{1 = "&lt;=", 2 = "&gt;=", 3 = "="}</code> specifying the type of the constraint.</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_rhs">rhs</code></td>
<td>
<p>a single numeric value specifying the right-hand-side of the constraint.</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_indices">indices</code></td>
<td>
<p>optional for sparse <code>xt</code>. A numeric vector the same length as <code>xt</code> of unique values from the set {1, ..., n} where n is the number of decision variables in <code>lprec</code>; <code>xt[i]</code> is entered into column <code>indices[i]</code> in the added constraint.  The coefficients for the columns not in <code>indices</code> are set to zero.  This argument should be omitted when <code>length(xt) == n</code>.</p>
</td></tr>
<tr><td><code id="add.constraint_+3A_lhs">lhs</code></td>
<td>
<p>optional. A single numeric value specifying the left-hand-side of the constraint.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying the objective function before adding constraints will improve the performance of this function.
</p>
<p>The use of this function should be avoided when possible. Building a model column-by-column rather than row-by-row will be on the order of 50 times faster (building the model - not solving the model).
</p>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 4)
set.objfn(lps.model, rep(1, 4))
add.constraint(lps.model, c(6,2,4,9), "&lt;=", 50)
add.constraint(lps.model, c(3,1,5), 2, 75, indices = c(1,2,4))
</code></pre>

<hr>
<h2 id='add.SOS'>Add A Special Ordered Set Constraint</h2><span id='topic+add.SOS'></span>

<h3>Description</h3>

<p>Add a Special Ordered Set (SOS) constraint to an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.SOS(lprec, name, type, priority, columns, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.SOS_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="add.SOS_+3A_name">name</code></td>
<td>
<p>a character string specifying a name for the SOS constraint.</p>
</td></tr>
<tr><td><code id="add.SOS_+3A_type">type</code></td>
<td>
<p>a positive integer specifying the type of the SOS constraint.</p>
</td></tr>
<tr><td><code id="add.SOS_+3A_priority">priority</code></td>
<td>
<p>an integer specifying the priority of the SOS constraint.</p>
</td></tr>
<tr><td><code id="add.SOS_+3A_columns">columns</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) indicating which decision variables belong to the special ordered set.</p>
</td></tr>
<tr><td><code id="add.SOS_+3A_weights">weights</code></td>
<td>
<p>a numeric vector the same length as <code>columns</code> specifying the variable weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the operation was successful: a single integer value containing the list index of the new special ordered set. A return value of <code>0</code> indicates an error.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='delete.column'>Delete Column</h2><span id='topic+delete.column'></span>

<h3>Description</h3>

<p>Delete a column from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.column(lprec, columns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete.column_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="delete.column_+3A_columns">columns</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying which columns should be deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 0)

x &lt;- c(6,2,4,9)
add.column(lps.model, x)

y &lt;- c(3,1,5)
ind &lt;- c(1,2,4)
add.column(lps.model, y, ind)

delete.column(lps.model, 1)
</code></pre>

<hr>
<h2 id='delete.constraint'>Delete Constraint</h2><span id='topic+delete.constraint'></span>

<h3>Description</h3>

<p>Delete a constraint from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.constraint(lprec, constraints)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete.constraint_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="delete.constraint_+3A_constraints">constraints</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., m}</code> (where <code>m</code> is the number of constraints in <code>lprec</code>) specifying which constraints should be deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 4)
set.objfn(lps.model, rep(1, 4))

xt &lt;- c(6,2,4,9)
add.constraint(lps.model, xt, "&lt;=", 50)

yt &lt;- c(3,1,5)
ind &lt;- c(1,2,4)
add.constraint(lps.model, yt, 2, 75, ind)

delete.constraint(lps.model, 1)
</code></pre>

<hr>
<h2 id='delete.lp'>Delete Linear Program Model</h2><span id='topic+delete.lp'></span>

<h3>Description</h3>

<p>Free all the resources used by an lpSolve linear program model object and set the value of the external pointer to <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.lp(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delete.lp_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used as a finalizer for lpSolve linear program model objects.
</p>


<h3>Value</h3>

<p><code>lprec</code> is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='dim.lpExtPtr'>Dimension of an Object</h2><span id='topic+dim.lpExtPtr'></span><span id='topic+dim+3C-.lpExtPtr'></span>

<h3>Description</h3>

<p>Retrieve the dimension (number of rows and columns) from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpExtPtr'
dim(x)
## S3 replacement method for class 'lpExtPtr'
dim(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dim.lpExtPtr_+3A_x">x</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="dim.lpExtPtr_+3A_value">value</code></td>
<td>
<p>assignment is not supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Setting the number of rows/columns is not supported.  See <code><a href="#topic+resize.lp">resize.lp</a></code>.
</p>


<h3>Value</h3>

<p>an integer vector of length two containing the number of rows and the number of columns in the lpSolve linear program model object.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+resize.lp">resize.lp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 0)

x &lt;- c(6,2,4,9)
add.column(lps.model, x)

y &lt;- c(3,1,5)
ind &lt;- c(1,2,4)
add.column(lps.model, y, ind)

dim(lps.model)
</code></pre>

<hr>
<h2 id='dimnames.lpExtPtr'>Dimnames of an Object</h2><span id='topic+dimnames.lpExtPtr'></span><span id='topic+dimnames+3C-.lpExtPtr'></span>

<h3>Description</h3>

<p>Retrieve or set the dimnames in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpExtPtr'
dimnames(x)
## S3 replacement method for class 'lpExtPtr'
dimnames(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dimnames.lpExtPtr_+3A_x">x</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="dimnames.lpExtPtr_+3A_value">value</code></td>
<td>
<p>a list containing two character vectors of lengths <code>m</code> and <code>n</code> specifying the row names and the column names for the lpSolve linear program model object.  The number of constraints in <code>x</code> is denoted by <code>m</code> and the number of decision variables by <code>n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two character vectors containing the row names and the column names in the lpSolve linear program model object.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 0)

x &lt;- c(6,2,4,9)
add.column(lps.model, x)

y &lt;- c(3,1,5)
ind &lt;- c(1,2,4)
add.column(lps.model, y, ind)

dimnames(lps.model) &lt;- list(c("alpha", "bravo", "charlie", "delta"),
                     c("whiskey", "tango"))
</code></pre>

<hr>
<h2 id='get.basis'>Get Basis</h2><span id='topic+get.basis'></span>

<h3>Description</h3>

<p>Retrieve the basis from a solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.basis(lprec, nonbasic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.basis_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.basis_+3A_nonbasic">nonbasic</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, the nonbasic variables are returned as well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector containing the indices of the basic (and nonbasic if requested) variables. If an error occurs (for instance when calling <code>get.basis</code> on a model that has not yet been solved) a <code>NULL</code> value is returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(3, 3)
## build and solve model ##
get.basis(lps.model)
</code></pre>

<hr>
<h2 id='get.bounds'>Get Bounds</h2><span id='topic+get.bounds'></span>

<h3>Description</h3>

<p>Retrieve the bounds on the decision variables from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.bounds(lprec, columns = 1:n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.bounds_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.bounds_+3A_columns">columns</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying the decision variables for which the bounds should be retrieved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components <code>lower</code> and <code>upper</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(3, 3)
get.bounds(lps.model)
</code></pre>

<hr>
<h2 id='get.branch.mode'>Get Branch Mode</h2><span id='topic+get.branch.mode'></span>

<h3>Description</h3>

<p>Retrieve the branch mode for one or more decision variables from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.branch.mode(lprec, columns = 1:n, as.char = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.branch.mode_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.branch.mode_+3A_columns">columns</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying for which decision variables the branch modes should be retrieved. If <code>NULL</code> branch modes are retrieved for all the decision variables.</p>
</td></tr>
<tr><td><code id="get.branch.mode_+3A_as.char">as.char</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the branch mode is returned as a character string, otherwise the integer code used directly in lpSolve is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a character vector or an integer vector containing the branch modes for the decision variables specified in <code>columns</code>. The possibilities are: <code>0 = "ceiling"</code>, <code>1 = "floor"</code> and <code>2 = "auto"</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(3, 3)
get.branch.mode(lps.model)
</code></pre>

<hr>
<h2 id='get.column'>Get Column</h2><span id='topic+get.column'></span>

<h3>Description</h3>

<p>Retrieve a column from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.column(lprec, column)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.column_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.column_+3A_column">column</code></td>
<td>
<p>a single numeric value from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying which column to retrieve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements <code>column</code> and <code>nzrow</code> such that <code>column[i]</code> contains the constraint coefficient in row <code>nzrow[i]</code>. Rows not present in <code>nzrow</code> have coefficient zero in <code>column</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 0)

x &lt;- c(6,2,4,9)
add.column(lps.model, x)

y &lt;- c(3,1,5)
ind &lt;- c(1,2,4)
add.column(lps.model, y, ind)

get.column(lps.model, 2)
</code></pre>

<hr>
<h2 id='get.constr.type'>Get Constraint Type</h2><span id='topic+get.constr.type'></span>

<h3>Description</h3>

<p>Retrieve constraint types from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.constr.type(lprec, constraints = 1:m, as.char = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.constr.type_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.constr.type_+3A_constraints">constraints</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., m}</code> (where <code>m</code> is the number of constraints in <code>lprec</code>) specifying the constraints for which the types will be retrieved.</p>
</td></tr>
<tr><td><code id="get.constr.type_+3A_as.char">as.char</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the constraint type is returned as a character string, otherwise the integer code used internally by lpSolve is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a character vector or an integer vector containing the types of the constraints specified in <code>constraints</code>. The possibilities are: <code>0 = "free"</code>, <code>1 = "&lt;="</code>, <code>2 = "&gt;="</code> and <code>3 = "="</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)

xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 15)

xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 15)

xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)

get.constr.type(lps.model)
</code></pre>

<hr>
<h2 id='get.constr.value'>Get Constraint Value</h2><span id='topic+get.constr.value'></span>

<h3>Description</h3>

<p>Retrieve constraint values from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.constr.value(lprec, side = c("rhs", "lhs"), constraints = 1:m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.constr.value_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.constr.value_+3A_side">side</code></td>
<td>
<p>either <code>"rhs"</code> (right-hand-side) or <code>"lhs"</code> (left-hand-side) - which constraint values to retrieve.</p>
</td></tr>
<tr><td><code id="get.constr.value_+3A_constraints">constraints</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., m}</code> (where <code>m</code> is the number of constraints in <code>lprec</code>) specifying the constraints for which the values will be retrieved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector containing the constraint values.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='get.constraints'>Get Constraints</h2><span id='topic+get.constraints'></span>

<h3>Description</h3>

<p>Retrieve the values of the constraints from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.constraints(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.constraints_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector containing the values of the constraints.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

solve(lps.model)
get.constraints(lps.model)
</code></pre>

<hr>
<h2 id='get.dual.solution'>Get Dual Solution</h2><span id='topic+get.dual.solution'></span>

<h3>Description</h3>

<p>Retrieve the values of the dual variables (the reduced costs) from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.dual.solution(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.dual.solution_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector containing the values of the dual variables. If an error occurs (for instance <code>lprec</code> has not been successfully solved) a <code>NULL</code> value is returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

solve(lps.model)
get.dual.solution(lps.model)
</code></pre>

<hr>
<h2 id='get.kind'>Get Kind</h2><span id='topic+get.kind'></span>

<h3>Description</h3>

<p>Retrieve the kind of a decision variable from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.kind(lprec, columns = 1:n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.kind_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.kind_+3A_columns">columns</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying the columns for which the kind will be retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Decision variables have both a type and a kind. The type is either <code>real</code> or <code>integer</code> and indicates the type of values the decision variable may take. The kind is one of <code>{standard, semi-continuous, SOS}</code>. Semi-continuous decision variables can take allowed values between their upper and lower bound as well as zero. Please see the link in the references for a discussion of special ordered set (SOS) constraints.
</p>


<h3>Value</h3>

<p>a character vector containing the kind of each decision variable specified in <code>columns</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

get.kind(lps.model)
</code></pre>

<hr>
<h2 id='get.mat'>Get Matrix Element</h2><span id='topic+get.mat'></span>

<h3>Description</h3>

<p>Retrieve a single element from the matrix of constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.mat(lprec, i, j)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.mat_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.mat_+3A_i">i</code></td>
<td>
<p>a single numeric value from the set {1, ..., m} (where <code>m</code> is the number of constraints in <code>lprec</code>) specifying the row of the matrix element.</p>
</td></tr>
<tr><td><code id="get.mat_+3A_j">j</code></td>
<td>
<p>a single numeric value from the set {1, ..., n} (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying the column of the matrix element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

get.mat(lps.model, 2, 2)
</code></pre>

<hr>
<h2 id='get.objective'>Get Objective</h2><span id='topic+get.objective'></span>

<h3>Description</h3>

<p>Retrieve the value of the objective function from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.objective(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.objective_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single numeric value containing the value of the objective function.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

solve(lps.model)
get.objective(lps.model)
</code></pre>

<hr>
<h2 id='get.primal.solution'>Get Primal Solution</h2><span id='topic+get.primal.solution'></span>

<h3>Description</h3>

<p>Retrieve the values of the primal variables from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.primal.solution(lprec, orig = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.primal.solution_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.primal.solution_+3A_orig">orig</code></td>
<td>
<p>a logical value. When presolve is active, the size of the lp may decrease during solve.  By default, the answer to this reduced problem is returned. Set this argument to <code>TRUE</code> to retrieve the solution to the original lp.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector containing the values of the primal variables. If an error occurs (for instance <code>lprec</code> has not been successfully solved) a <code>NULL</code> value is returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

solve(lps.model)
get.primal.solution(lps.model)
</code></pre>

<hr>
<h2 id='get.rhs'>Get Right-Hand-Side</h2><span id='topic+get.rhs'></span>

<h3>Description</h3>

<p>Retrieve right-hand-side values from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rhs(lprec, constraints = 1:m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.rhs_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.rhs_+3A_constraints">constraints</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., m}</code> specifying the constraints for which the right-hand-side values should be retrieved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector containing the right-hand-side values specified by <code>constraints</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

get.rhs(lps.model)
</code></pre>

<hr>
<h2 id='get.sensitivity.obj'>Get Sensitivity: Objective</h2><span id='topic+get.sensitivity.obj'></span>

<h3>Description</h3>

<p>Retrieve the sensitivity of the objective function from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sensitivity.obj(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.sensitivity.obj_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>
<table role = "presentation">
<tr><td><code>objfrom</code></td>
<td>
<p>a numeric vector of length <code>n</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) containing the values of the lower limits of the objective function.</p>
</td></tr>
<tr><td><code>objtill</code></td>
<td>
<p>a numeric vector of length <code>n</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) containing the values of the upper limits of the objective function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

solve(lps.model)
get.sensitivity.obj(lps.model)
</code></pre>

<hr>
<h2 id='get.sensitivity.objex'>Get Sensitivity: Objective Extended</h2><span id='topic+get.sensitivity.objex'></span>

<h3>Description</h3>

<p>Retrieve the sensitivity of the objective function from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sensitivity.objex(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.sensitivity.objex_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>
<table role = "presentation">
<tr><td><code>objfrom</code></td>
<td>
<p>a numeric vector of length <code>n</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) containing the values of the lower limits of the objective function.</p>
</td></tr>
<tr><td><code>objtill</code></td>
<td>
<p>a numeric vector of length <code>n</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) containing the values of the upper limits of the objective function.</p>
</td></tr>
<tr><td><code>objfromvalue</code></td>
<td>
<p>a numeric vector of length <code>n</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) containing the values of the variables at their lower limit. Only applicable when the value of the variable is 0 (rejected).</p>
</td></tr>
<tr><td><code>objtillvalue</code></td>
<td>
<p>not used in this version of lpSolve.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

solve(lps.model)
get.sensitivity.objex(lps.model)
</code></pre>

<hr>
<h2 id='get.sensitivity.rhs'>Get Sensitivity: Right-Hand-Side</h2><span id='topic+get.sensitivity.rhs'></span>

<h3>Description</h3>

<p>Retrieve the sensitivity of the constraints from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sensitivity.rhs(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.sensitivity.rhs_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components
</p>
<table role = "presentation">
<tr><td><code>duals</code></td>
<td>
<p>a numeric vector of length <code>m+n</code> (where <code>m</code> is the number of constraints in <code>m</code> and <code>n</code> is the number of decision variables in <code>lprec</code>) containing the values of the dual variables (reduced costs).</p>
</td></tr>
<tr><td><code>dualsfrom</code></td>
<td>
<p>a numeric vector of length <code>m+n</code> (where <code>m</code> is the number of constraints in <code>m</code> and <code>n</code> is the number of decision variables in <code>lprec</code>) containing the values of the lower limits on the dual variables.</p>
</td></tr>
<tr><td><code>dualstill</code></td>
<td>
<p>a numeric vector of length <code>m+n</code> (where <code>m</code> is the number of constraints in <code>m</code> and <code>n</code> is the number of decision variables in <code>lprec</code>) containing the values of the upper limits on the dual variables.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

solve(lps.model)
get.sensitivity.rhs(lps.model)
</code></pre>

<hr>
<h2 id='get.solutioncount'>Get Solution Count</h2><span id='topic+get.solutioncount'></span>

<h3>Description</h3>

<p>Computes the number of equal solutions in a successfully solved lpSolve linear program model object. This is only valid if there are integer, semi-continuous or SOS variables in the model so that the branch-and-bound algorithm is used. This count gives the number of solutions with the same optimal objective value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.solutioncount(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.solutioncount_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single integer value giving the number of solutions attaining the optimal objective value.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='get.total.iter'>Get Total Iterations</h2><span id='topic+get.total.iter'></span>

<h3>Description</h3>

<p>Retrieves the total number of iterations from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.total.iter(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.total.iter_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lprec</code> contains integer variables then this function returns the number of iterations to find a relaxed solution plus the number of iterations in the B&amp;B process. If <code>lprec</code> contains no integer variables then this function returns the number of iterations to find a solution.
</p>


<h3>Value</h3>

<p>a single integer value giving the total number of iterations.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='get.total.nodes'>Get Total Nodes</h2><span id='topic+get.total.nodes'></span>

<h3>Description</h3>

<p>Retrieves the total number of nodes processed in the branch-and-bound algorithm from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.total.nodes(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.total.nodes_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of this function is only applicable for models containing integer variables.
</p>


<h3>Value</h3>

<p>a single integer value giving the total number of nodes processed.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='get.type'>Get Type</h2><span id='topic+get.type'></span>

<h3>Description</h3>

<p>Retrieve the type of a decision variable from an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.type(lprec, columns = 1:n, as.char = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.type_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="get.type_+3A_columns">columns</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying the columns for which the type will be retrieved.</p>
</td></tr>
<tr><td><code id="get.type_+3A_as.char">as.char</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the constraint type is returned as a character string, otherwise the integer code used internally by lpSolve is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+set.type">set.type</a></code> can be used to set a decision variable as binary. A binary decision variable is simply an integer decision with an upper bound of one and a lower bound of zero - hence this function will report the type as integer.
</p>


<h3>Value</h3>

<p>either a character vector with elements from the set <code>{"real", "integer"}</code> indicating the type of each decision variable specified in <code>columns</code> or (if <code>as.char = FALSE</code>) a logical vector with <code>TRUE</code> elements corresponding to the integer decision variables specified in <code>columns</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+set.type">set.type</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
set.type(lps.model, 2, "binary")
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.type(lps.model, 3, "integer")
set.objfn(lps.model, c(-3,-4,-3))

get.type(lps.model)
</code></pre>

<hr>
<h2 id='get.variables'>Get Variables</h2><span id='topic+get.variables'></span>

<h3>Description</h3>

<p>Retrieve the values of the decision variables from a successfully solved lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.variables(lprec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.variables_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector containing the values of the decision variables corresponding to the optimal solution.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

solve(lps.model)
get.variables(lps.model)
</code></pre>

<hr>
<h2 id='guess.basis'>Guess Basis</h2><span id='topic+guess.basis'></span>

<h3>Description</h3>

<p>Attempt to find a feasible basis corresponding to a user provided feasible point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess.basis(lprec, guess)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guess.basis_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="guess.basis_+3A_guess">guess</code></td>
<td>
<p>a numeric vector of length <code>n</code> (the number of decision variables in <code>lprec</code>) containing a feasible point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if successful, a numeric vector containing the indices of a starting basis. This vector is suitable for use with the <code><a href="#topic+set.basis">set.basis</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+set.basis">set.basis</a></code></p>

<hr>
<h2 id='lp.control'>lpSolve Control Parameters</h2><span id='topic+lp.control'></span>

<h3>Description</h3>

<p>Set control parameters in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp.control(lprec, ..., reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lp.control_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="lp.control_+3A_...">...</code></td>
<td>
<p>control arguments to bet set in <code>lprec</code>.</p>
</td></tr>
<tr><td><code id="lp.control_+3A_reset">reset</code></td>
<td>
<p>a logical value. If <code>TRUE</code> all control parameters are reset to their default values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing all of the control parameters as set internally in <code>lprec</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lp.control.options">lp.control.options</a></code></p>

<hr>
<h2 id='lp.control.options'>Solver Control Options</h2><span id='topic+lp.control.options'></span>

<h3>Description</h3>

<p>A description of the various control options that can be set in an lpSolve linear program model object using the <code><a href="#topic+lp.control">lp.control</a></code> function.
</p>


<h3>Control Options</h3>


<dl>
<dt>anti.degen</dt><dd><p>a character vector containing one or more of the following options. If any element is &quot;none&quot; then no anti-degeneracy handling is used.
</p>

<table>
<tr>
 <td style="text-align: right;">
       <code>"none"</code>: </td><td style="text-align: left;"> No anti-degeneracy handling. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"fixedvars"</code>: </td><td style="text-align: left;"> Check if there are equality slacks in the basis and try to drive them out in order to reduce chance of degeneracy in Phase 1. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"columncheck"</code>: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"stalling"</code>: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"numfailure"</code>: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"lostfeas"</code>: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"infeasible"</code>: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"dynamic"</code>: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"duringbb"</code>: </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"rhsperturb"</code>: </td><td style="text-align: left;"> Perturbation of the working RHS at refactorization </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"boundflip"</code>: </td><td style="text-align: left;"> Limit bound flips that can sometimes contribute to degeneracy in some models. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>The default is <code>c("infeasible", "stalling", "fixedvars")</code>.</p>
</dd>
<dt>basis.crash</dt><dd><p>a character string specifying the basis crash mode to use. When no basis crash is done the initial basis from which lpSolve starts is the basis containing all slack or artificial variables. When basis crash is enabled, a heuristic <em>crash procedure</em> is executed before the first simplex iteration to quickly choose a basis matrix that has fewer artificial variables. This procedure tends to reduce the number of iterations required by the solver. The choices for this option are given in the following table.
</p>

<table>
<tr>
 <td style="text-align: right;">
       <code>"none"</code>: </td><td style="text-align: left;"> No basis crash. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"mostfeasible"</code>: </td><td style="text-align: left;"> Most feasible basis. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"leastdegenerate"</code>: </td><td style="text-align: left;"> Construct a basis that is in some sense the <em>least</em> degenerate. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>The default is <code>"none"</code>.</p>
</dd>
<dt>bb.depthlimit</dt><dd><p>a single integer value specifying the maximum branch-and-bound depth. A positive value means that the depth limit is absolute. A negative value means a relative branch-and-bound depth limit. The <em>order</em> of an MIP problem is defined to be 2 times the number of binary variables plus the number of semi-continuous (SC) and special-ordered-sets (SOS) variables. A relative value of <code>-x</code> results in a maximum depth of <code>x</code> times the order of the MIP problem.
</p>
<p>This control option only applies if there are integer, SC or SOS variables in the model (i.e., when the branch-and-bound algorithm is used). The branch-and-bound algorithm will not go deeper than this level. Limiting the depth speeds up the solving time but there is a chance that the solution obtained is sub-optimal. Be aware of this. Another possible consequence is that no solution will be found.
</p>
<p>The default value is <code>-50</code>; a value of zero implies no limit to the depth.</p>
</dd>
<dt>bb.floorfirst</dt><dd><p>a character string from among the following choices specifying which branch to take first in the branch-and-bound algorithm.
</p>

<table>
<tr>
 <td style="text-align: right;">
       <code>"ceiling"</code>: </td><td style="text-align: left;"> Take ceiling branch first. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"floor"</code>: </td><td style="text-align: left;"> Take floor branch first. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"auto"</code>: </td><td style="text-align: left;"> lpSolve decides which branch to take first. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>The value of this option can influence solving times considerably. However, the real-world performance will be model dependent. The default is <code>"auto"</code>.</p>
</dd>
<dt>bb.rule</dt><dd><p>a character vector specifying the branch-and-bound rule. The first element must be chosen from the following table.
</p>

<table>
<tr>
 <td style="text-align: right;">
       <code>"first"</code>: </td><td style="text-align: left;"> Select the lowest indexed non-integer column. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"gap"</code>: </td><td style="text-align: left;"> Selection based on the distance from the current bounds. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"range"</code>: </td><td style="text-align: left;"> Selection based on the largest current bound. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"fraction"</code>: </td><td style="text-align: left;"> Selection based on the largest fractional value. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"pseudocost"</code>: </td><td style="text-align: left;"> Simple, unweighted pseudo-cost of a variable. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"pseudononint"</code>: </td><td style="text-align: left;"> An extended pseudo-costing strategy based on minimizing the number of integer infeasibilities. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"pseudoratio"</code>: </td><td style="text-align: left;"> An extended pseudo-costing strategy based on maximizing the normal pseudo-cost divided by the number of infeasibilities. Effectively, it is similar to (the reciprocal of) a cost/benefit ratio. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>Additional modes (if any) may be appended to augment the rule specified in the first element of <code>bb.rule</code>.
</p>

<table>
<tr>
 <td style="text-align: right;">
       <code>"weightreverse"</code>: </td><td style="text-align: left;"> Select by criterion minimum (worst), rather than by criterion maximum (best). </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"branchreverse"</code>: </td><td style="text-align: left;"> When <code>bb.floorfirst</code> is <code>"auto"</code>, select the  direction (lower/upper branch) opposite to that chosen by lpSolve. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"greedy"</code>: </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"pseudocost"</code>: </td><td style="text-align: left;"> Toggle between weighting based on pseudocost or objective function value. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"depthfirst"</code>: </td><td style="text-align: left;"> Select the node that has been selected before the most number of times. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"randomize"</code>: </td><td style="text-align: left;"> Add a randomization factor to the score for all the node candidates. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"gub"</code>: </td><td style="text-align: left;"> This option is still in development and should not be used at this time. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"dynamic"</code>: </td><td style="text-align: left;"> When <code>"depthfirst"</code> is selected, switch it off once the first solution is found. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"restart"</code>: </td><td style="text-align: left;"> Regularly restart the pseudocost value calculations. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"breadthfirst"</code>: </td><td style="text-align: left;"> Select the node that has been selected the fewest number of times (or not at all). </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"autoorder"</code>: </td><td style="text-align: left;"> Create an <em>optimal</em> branch-and-bound variable ordering. Can speed up branch-and-bound algorithm. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"rcostfixing"</code>: </td><td style="text-align: left;"> Do bound tightening during branch-and-bound based on the reduced cost information. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"stronginit"</code>: </td><td style="text-align: left;"> Initialize pseudo-costs by strong branching. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>The value of this rule can influence solving times considerably. However, the real-world performance will be model dependent. The default value is <code>c("pseudononint", "greedy", "dynamic", "rcostfixing")</code>.</p>
</dd>
<dt>break.at.first</dt><dd><p>a logical value. If <code>TRUE</code> then the branch-and-bound algorithm stops at the first solution found. The default (<code>FALSE</code>) is to continue until an optimal solution is found.</p>
</dd>
<dt>break.at.value</dt><dd><p>a numeric value. The branch-and-bound algorithm stops if the objective function becomes better than this value. The default (<code class="reqn">\pm</code>infinity) is to continue until an optimal value is found.</p>
</dd>
<dt>epslevel</dt><dd><p>a character string providing a simplified way of specifying multiple tolerance thresholds in a <em>logically</em> consistent way. The following values are set: <code>epsel</code>, <code>epsb</code>, <code>epsd</code>, <code>epspivot</code>, <code>epsint</code> and <code>mip.gap</code>.
</p>

<table>
<tr>
 <td style="text-align: right;">
       <code>"tight"</code>: </td><td style="text-align: left;"> Use tight tolerance values. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"medium"</code>: </td><td style="text-align: left;"> Use medium tolerance values. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"loose"</code>: </td><td style="text-align: left;"> Use loose tolerance values. </td>
</tr>
<tr>
 <td style="text-align: right;">
       <code>"baggy"</code>: </td><td style="text-align: left;"> Use very loose tolerance values. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>The default is <code>"tight"</code>.</p>
</dd>
<dt>epsb</dt><dd><p>a single positive numeric value specifying the tolerance used to determine whether a right-hand-side value should be considered zero. Rounding error in floating-point calculations may result in a loss of precision. A very small value (for example, 1e-99) could be the result of such errors and should be considered zero by the solver. If the absolute value of a right-hand-side value is less than <code>epsb</code> then it is treated as zero by the solver. The default value is <code>1.0e-10</code>.</p>
</dd>
<dt>epsd</dt><dd><p>a single positive numeric value specifying the tolerance used to determine whether a computed reduced cost should be considered zero. Rounding error in floating-point calculations may result in a loss of precision. A very small value (for example, 1e-99) could be the result of such errors and should be considered zero by the solver. If the absolute value of a computed reduced cost is less than <code>epsd</code> then it is treated as zero by the solver. The default value is <code>1.0e-9</code>.</p>
</dd>
<dt>epsel</dt><dd><p>a single positive numeric value specifying the tolerance used for rounding values to zero. Rounding error in floating-point calculations may result in a loss of precision. A very small value (for example, 1e-99) could be the result of such errors and should be considered zero by the solver. If the absolute value of a computed value is less than <code>epsel</code> then it is rounded to zero by the solver. The default value is <code>1.0e-12</code>. This parameter is used in situations where none of <code>epsint</code>, <code>epsb</code>, <code>epsd</code>, <code>epspivot</code> nor<code>epsperturb</code> apply.</p>
</dd>
<dt>epsint</dt><dd><p>a single positive numeric value specifying the tolerance used to determine whether a floating-point number is an integer. This parameter only applies when there is at least one integer variable so that the branch and bound algorithm is used. Integer variables are internally stored as floating-point. A tolerance is therefore needed to determine whether a value should be considered an integer. If the absolute value of the variable minus the closest integer is less than <code>epsint</code> then it is considered an integer. The default value is <code>1.0e-7</code>.</p>
</dd>
<dt>epsperturb</dt><dd><p>a single positive numeric value specifying the perturbation scalar for degenerate problems. The default is <code>1.0e-5</code>.</p>
</dd>
<dt>epspivot</dt><dd><p>a single positive numeric value specifying the tolerance used to determine whether a pivot element is zero. Rounding error in floating-point calculations may result in a loss of precision. A very small value (for example, 1e-99) could be the result of such errors and should be considered zero by the solver. If the absolute value of a computed pivot element is less than <code>epspivot</code> then it is treated as zero by the solver. Pivots will be performed on elements smaller (in absolute terms) than <code>epspivot</code> when no other larger pivot element can be found. The default value is <code>2.0e-7</code>.</p>
</dd>
<dt>improve</dt><dd><p>a character vector specifying the iterative improvement level. The possible values are given in the following table.
</p>

<table>
<tr>
 <td style="text-align: right;">
        <code>"none"</code>: </td><td style="text-align: left;"> None. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"solution"</code>: </td><td style="text-align: left;"> Running accuracy measurement of solved equations based on <code class="reqn">Bx=r</code> (primal simplex), remedy is refactorization. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"dualfeas"</code>: </td><td style="text-align: left;"> Improve initial dual feasibility by bound flips (highly recommended). </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"thetagap"</code>: </td><td style="text-align: left;"> Low-cost accuracy monitoring in the dual, remedy is refactorization. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"bbsimplex"</code>: </td><td style="text-align: left;"> By default there is a check for primal/dual feasibility at the optimum only for the relaxed problem, this also activates the test at the node level. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>The default is <code>c("dualfeas", "thetagap")</code>.</p>
</dd>
<dt>infinite</dt><dd><p>a positive numeric value specifying the practical value for infinity. This value is used for very large numbers, for example the upper bound of a variable without an upper bound. The default is <code>1.0e30</code>.</p>
</dd>
<dt>maxpivot</dt><dd><p>a positive integer value specifying the maximum number of pivots between re-inversion of the matrix. For stability, lpSolve periodically re-inverts the matrix. However, the more often this is done, the slower the solver becomes. The default is <code>250</code>.</p>
</dd>
<dt>mip.gap</dt><dd><p>a numeric vector of length two specifying respectively the absolute and relative MIP gaps used in the branch-and-bound algorithm. This tolerance is the difference between the best-found solution yet and the current solution. If the difference is smaller than this tolerance then the solution (and all the sub-solutions) is rejected. This can result in faster solving times, but results in a solution which is not the perfect solution. The default is <code>1.0e-11</code>.</p>
</dd>
<dt>negrange</dt><dd><p>a nonpositive numeric value below which variables are split into negative and positive parts. The default is <code>-1.0e6</code>.</p>
</dd>
<dt>obj.in.bas</dt><dd><p>a logical value specifying whether the objective function is stored in the matrix. The default is to store the objective function in the top row of the constraint matrix. If <code>FALSE</code> then the objective function is moved to separate storage. When the objective function is not stored in the basis the computation of reduced costs is somewhat slower. In the later versions of v5.5 there is the option to calculate reduced cost in the textbook way: completely independently of the basis.</p>
</dd>
<dt>pivoting</dt><dd><p>a character vector specifying the pivot rule (the rule for selecting row and column entering/leaving) and mode. The first element of this vector must be one of the four pivot rules listed in the first table. Remaining elements (if any) specify modes that modify this rule. The rule/mode can influence solving times considerably.
</p>

<table>
<tr>
 <td style="text-align: right;">
        <code>"firstindex"</code>: </td><td style="text-align: left;"> Select first. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"dantzig"</code>: </td><td style="text-align: left;"> Select according to Dantzig. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"devex"</code>: </td><td style="text-align: left;"> Devex pricing from Paula Harris. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"steepestedge"</code>: </td><td style="text-align: left;"> Steepest edge. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
        <code>"primalfallback"</code>: </td><td style="text-align: left;"> When using the steepest edge rule, fall back to <code>"devex"</code> in the primal. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"multiple"</code>: </td><td style="text-align: left;"> A preliminary implementation of the multiple pricing scheme. Attractive candidate columns from one iteration may be used in subsequent iterations thus avoiding full updating of reduced costs. In the current implementation, lpSolve only reuses the second best entering column alternative. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"partial"</code>: </td><td style="text-align: left;"> Enables partial pricing. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"adaptive"</code>: </td><td style="text-align: left;"> Temporarily use an alternative strategy if cycling is detected. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"randomize"</code>: </td><td style="text-align: left;"> Adds a small randomization effect to the selected pricer. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"autopartial"</code>: </td><td style="text-align: left;"> Indicates automatic detection of segmented/staged/blocked models. It refers to partial pricing rather than full pricing. With full pricing, all non-basic columns are scanned, but with partial pricing only a subset is scanned for every iteration. This can speed up several models. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"loopleft"</code>: </td><td style="text-align: left;"> Scan entering/leaving columns left rather than right. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"loopalternate"</code>: </td><td style="text-align: left;"> Scan entering/leaving columns alternating left/right. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"harristwopass"</code>: </td><td style="text-align: left;"> Use Harris' primal pivot logic rather than the default. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"truenorminit"</code>: </td><td style="text-align: left;"> Use true norms for Devex and steepest edge initializations. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>The default is <code>c("devex", "adaptive")</code>.</p>
</dd>
<dt>presolve</dt><dd><p>a character vector specifying presolve steps to be carried out before solving. Presolve looks at the model and tries to simplify it so that solving times are shorter. For example a constraint on only one variable is converted to a bound on this variable (and the constraint is deleted) - the model dimensions can change because of this. Both rows and columns can be deleted by the presolve. Also, note that the <code>"lindep"</code> presolve option can result in the deletion of rows (the linear dependent ones). The <code><a href="#topic+get.constraints">get.constraints</a></code> function will then return only the values of the rows that are kept.
</p>
<p>The presolve options are given in the following table. If any element of <code>presolve</code> is <code>"none"</code> then no presolving is done.
</p>

<table>
<tr>
 <td style="text-align: right;">
        <code>"none"</code>: </td><td style="text-align: left;"> No presolve. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"rows"</code>: </td><td style="text-align: left;"> Presolve rows. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"cols"</code>: </td><td style="text-align: left;"> Presolve columns. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"lindep"</code>: </td><td style="text-align: left;"> Eliminate linearly dependent rows. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"sos"</code>: </td><td style="text-align: left;"> Convert constraints to special ordered sets (SOS), only SOS1 is handled. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"reducemip"</code>: </td><td style="text-align: left;"> Constraints found redundant in phase 1 are deleted. This is no longer active since it is rarely effective and also because it adds code complications and delayed presolve effects that are not captured properly. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"knapsack"</code>: </td><td style="text-align: left;"> Simplification of knapsack-type constraints through the addition of an extra variable. This also helps bound the objective function. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"elimeq2"</code>: </td><td style="text-align: left;"> Direct substitution of one variable in 2-element equality constraints; this requires changes to the constraint matrix. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"impliedfree"</code>: </td><td style="text-align: left;"> Identify implied free variables (releasing their explicit bounds). </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"reducegcd"</code>: </td><td style="text-align: left;"> Reduce (tighten) coefficients in integer models based on GCD argument. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"probefix"</code>: </td><td style="text-align: left;"> Attempt to fix binary variables at one of their bounds. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"probereduce"</code>: </td><td style="text-align: left;"> Attempt to reduce coefficients in binary models. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"rowdominate"</code>: </td><td style="text-align: left;"> Identify and delete qualifying constraints that are dominated by others, also fixes variables at a bound. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"coldominate"</code>: </td><td style="text-align: left;"> Delete variables (mainly binary) that are dominated by others (only one can be non-zero). </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"mergerows"</code>: </td><td style="text-align: left;"> Merges neighboring <code>&gt;=</code> or <code>&lt;=</code> constraints when the vectors are otherwise relatively identical into a single ranged constraint. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"impliedslk"</code>: </td><td style="text-align: left;"> Converts qualifying equalities to inequalities by converting a column singleton variable to a slack variable. The routine also detects implicit duplicate slacks from inequality constraints and fixes and removes the redundant variable. This removal also tends to reduce the risk of degeneracy. The combined function of this option can have a dramatic simplifying effect on some models. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"colfixdual"</code>: </td><td style="text-align: left;"> Variable fixing and removal based on the signs of the associated dual constraint. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"bounds"</code>: </td><td style="text-align: left;"> Bound tightening based on full-row constraint information. This can assist in tightening the objective function bound, eliminate variables and constraints. At the end of presolve, it is checked if any variables can be deemed free, thereby reducing any chance that degeneracy is introduced via this presolve option. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"duals"</code>: </td><td style="text-align: left;"> Calculate duals. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"sensduals"</code>: </td><td style="text-align: left;"> Calculate sensitivity if there are integer variables. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>The default is <code>c("none")</code>.</p>
</dd>
<dt>scalelimit</dt><dd><p>a numeric value specifying the relative scaling convergence criterion for the active scaling mode; the integer part specifies the maximum number of iterations. The default is <code>5</code>.</p>
</dd>
<dt>scaling</dt><dd><p>a character vector specifying the scaling algorithm used and zero or more augmentations. The first element must be one of the scaling algorithms given in the following table.
</p>

<table>
<tr>
 <td style="text-align: right;">
        <code>"none"</code>: </td><td style="text-align: left;"> No scaling (not advised). </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"extreme"</code>: </td><td style="text-align: left;"> Scale to convergence using largest absolute value. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"range"</code>: </td><td style="text-align: left;"> Scale based on the simple numerical range. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"mean"</code>: </td><td style="text-align: left;"> Numerical range-based scaling. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"geometric"</code>: </td><td style="text-align: left;"> Geometric scaling. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"curtisreid"</code>: </td><td style="text-align: left;"> Curtis-Reid scaling. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>Additional elements (if any) from the following table can be included to augment the scaling algorithm.
</p>

<table>
<tr>
 <td style="text-align: right;">
        <code>"quadratic"</code>: </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"logarithmic"</code>: </td><td style="text-align: left;"> Scale to convergence using logarithmic mean of all values. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"power2"</code>: </td><td style="text-align: left;"> Power scaling. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"equilibrate"</code>: </td><td style="text-align: left;"> Make sure that no scaled number is above <code>1</code>. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"integers"</code>: </td><td style="text-align: left;"> Scale integer variables. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"dynupdate"</code>: </td><td style="text-align: left;"> Recompute scale factors when resolving the model. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"rowsonly"</code>: </td><td style="text-align: left;"> Only scale rows. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"colsonly"</code>: </td><td style="text-align: left;"> Only scale columns. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

<p>By default, lpSolve computes scale factors once for the original model. If a solve is done again (most probably after changing some data in the model), the scaling factors are not recomputed. Instead, the scale factors from the original model are used. This is not always desirable, especially if the data has changed considerably. Including <code>"dynupdate"</code> among the scale algorithm augmentations instructs lpSolve to recompute the scale factors each time <code>solve</code> is called. Note that the scaling done by <code>"dynupdate"</code> is incremental and the resulting scale factors are typically different from those computed from scratch.
</p>
<p>The default is <code>c("geometric", "equilibrate", "integers")</code>.</p>
</dd>
<dt>sense</dt><dd><p>one of <code>"max"</code> or <code>"min"</code> specifying whether the model is a maximization or a minimization problem.</p>
</dd>
<dt>simplextype</dt><dd><p>a character vector of length one or two composed of <code>"primal"</code> and <code>"dual"</code>. If length two then the first element describes the simplex type used in phase 1 and the second element the simplex type used in phase 2. If length one then that simplex type is used for both phases. The default is <code>c("dual", "primal")</code>.</p>
</dd>
<dt>timeout</dt><dd><p>a positive integer value specifying the number of seconds after which a timeout will occur. If zero, then no timeout will occur.</p>
</dd>
<dt>verbose</dt><dd><p>a character string controlling the severity of messages reported by <code>lp_solve</code>. The possible choices are given in the table below. All errors/warnings in <code>lp_solve</code> have a particular severiy: for example, specifying a wrong row or column index is considered a severe error. All messages equal to and below the set level are reported (in the console).
</p>

<table>
<tr>
 <td style="text-align: right;">
        <code>"neutral"</code>: </td><td style="text-align: left;"> No reporting. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"critical"</code>: </td><td style="text-align: left;"> Only critical messages are reported. Hard errors like instability, out of memory, etc. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"severe"</code>: </td><td style="text-align: left;"> Only severe messages are reported. Errors. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"important"</code>: </td><td style="text-align: left;"> Only important messages are reported. Warnings and Errors. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"normal"</code>: </td><td style="text-align: left;"> Normal messages are reported. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"detailed"</code>: </td><td style="text-align: left;"> Detailed messages are reported. Like model size, continuing B&amp;B improvements, etc. </td>
</tr>
<tr>
 <td style="text-align: right;">
        <code>"full"</code>: </td><td style="text-align: left;"> All messages are reported. Useful for debugging purposes and small models. </td>
</tr>
<tr>
 <td style="text-align: right;">
      </td>
</tr>

</table>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+lp.control">lp.control</a></code></p>

<hr>
<h2 id='make.lp'>Make LP</h2><span id='topic+make.lp'></span>

<h3>Description</h3>

<p>Create a new lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.lp(nrow = 0, ncol = 0, verbose = "neutral")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.lp_+3A_nrow">nrow</code></td>
<td>
<p>a nonnegative integer value specifying the number of constaints in the linear program.</p>
</td></tr>
<tr><td><code id="make.lp_+3A_ncol">ncol</code></td>
<td>
<p>a nonnegative integer value specifying the number of decision variables in the linear program.</p>
</td></tr>
<tr><td><code id="make.lp_+3A_verbose">verbose</code></td>
<td>
<p>a character string controlling the level of error reporting. The default value <code>"neutral"</code> is no error reporting. Use <code>"normal"</code> or <code>"full"</code> for more comprehensive error reporting. See the <code>verbose</code> entry in <code><a href="#topic+lp.control.options">lp.control.options</a></code> for a complete description of this argument and its possible values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an lpSolve linear program model object. Specifically an R external pointer with class <code>lpExtPtr</code>.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 3)
</code></pre>

<hr>
<h2 id='name.lp'>Name LP</h2><span id='topic+name.lp'></span>

<h3>Description</h3>

<p>Set or retrieve the name of an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name.lp(lprec, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="name.lp_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="name.lp_+3A_name">name</code></td>
<td>
<p>an optional character string giving a new name for <code>lprec</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>name</code> is provided then this function sets the name of the lpSolve linear program model object. If <code>name</code> is missing then this function retrieves the name from <code>lprec</code>.
</p>


<h3>Value</h3>

<p>there is no return value if the <code>name</code> argument is given. Otherwise a character string containing the name of the lpSolve linear program model object.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

name.lp(lps.model, "Simple LP")
name.lp(lps.model)
</code></pre>

<hr>
<h2 id='plot.lpExtPtr'>lpExtPtr Plot Method</h2><span id='topic+plot.lpExtPtr'></span>

<h3>Description</h3>

<p>Plots the feasible set of a simple linear program with two decision variables. The decision variables must be real, nonnegative and must not have a finite upper bound. Only inequality constraints are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpExtPtr'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lpExtPtr_+3A_x">x</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="plot.lpExtPtr_+3A_y">y</code></td>
<td>
<p>this argument is ignored.</p>
</td></tr>
<tr><td><code id="plot.lpExtPtr_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>

<hr>
<h2 id='print.lpExtPtr'>lpSolve Print Method</h2><span id='topic+print.lpExtPtr'></span>

<h3>Description</h3>

<p>Display an lpSolve linear program model object in the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpExtPtr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lpExtPtr_+3A_x">x</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="print.lpExtPtr_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='read.lp'>Read LP</h2><span id='topic+read.lp'></span>

<h3>Description</h3>

<p>Read an lpSolve linear program model object from a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.lp(filename, type = c("lp", "mps", "freemps"), verbose = "neutral", 
        options)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.lp_+3A_filename">filename</code></td>
<td>
<p>a character string giving the name of the file which the linear programming model is to be read from.</p>
</td></tr>
<tr><td><code id="read.lp_+3A_type">type</code></td>
<td>
<p>the type of file provided in <code>filename</code>. If missing, <code>read.lp</code> will attempt to guess the file type by examining the file's suffix.</p>
</td></tr>
<tr><td><code id="read.lp_+3A_verbose">verbose</code></td>
<td>
<p>a character string controlling the level of error reporting. The default value <code>"neutral"</code> is no error reporting. Set to <code>"normal"</code> to enable error reporting or to <code>"full"</code> for a comprehensive parse log. See the <code>verbose</code> entry in <code><a href="#topic+lp.control.options">lp.control.options</a></code> for a complete description of this argument and its possible values.</p>
</td></tr>
<tr><td><code id="read.lp_+3A_options">options</code></td>
<td>
<p>a character vector of options for the (free)mps parser.  Possible values are
</p>

<dl>
<dt><code>free</code></dt><dd><p>Use the free MPS format even when <code>type = "mps"</code>. If not specified, the fixed MPS format is used. This option has no effect when <code>type = "freemps"</code> but will not result in an error or a warning.</p>
</dd>
<dt><code>ibm</code></dt><dd><p>Interpret integer variables without bounds as binary variables per the original IBM standard. By default, <code>lp_solve</code> interprets integer variables without bounds as having no upper bound.</p>
</dd>
<dt><code>negobjconst</code></dt><dd><p>Interpret the objective constant with an opposite sign. Some solvers interpret the objective constant as a value in the RHS and negate it when brought to the LHS. This option allows <code>lp_solve</code> to do this as well.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Value</h3>

<p>an lpSolve linear program model object.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='resize.lp'>Resize LP</h2><span id='topic+resize.lp'></span>

<h3>Description</h3>

<p>Resize the data structures in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resize.lp(lprec, nrow, ncol)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resize.lp_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="resize.lp_+3A_nrow">nrow</code></td>
<td>
<p>a single nonnegative integer value specifying the new number of rows for the lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="resize.lp_+3A_ncol">ncol</code></td>
<td>
<p>a single nonnegative integer value specifying the new number of rows for the lpSolve linear program model object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the new size of the model is smaller than the size of the current model, the excess rows and/or columns are deleted. If the new size is larger, no change will be immediately apparent. However, the internal structures of <code>lprec</code> will have been adjusted to accommodate the larger model. Efficiency of model building can be improved by calling this function before adding additional columns (for example).
</p>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 0)
resize.lp(lps.model, 4, 2)

x &lt;- c(6,2,4,9)
add.column(lps.model, x)

y &lt;- c(3,1,5)
ind &lt;- c(1,2,4)
add.column(lps.model, y, ind)
</code></pre>

<hr>
<h2 id='row.add.mode'>Row Add Mode</h2><span id='topic+row.add.mode'></span>

<h3>Description</h3>

<p>Switch to row entry mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row.add.mode(lprec, state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="row.add.mode_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="row.add.mode_+3A_state">state</code></td>
<td>
<p>optional: either <code>"on"</code> or <code>"off"</code>. This argument should be provided only to switch row entry mode on or off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best way to build a linear program model in lpSolve is column by column, hence row entry mode is turned off by default. If the model must be built by adding constraints, the performance of the <code><a href="#topic+add.constraint">add.constraint</a></code> function can be greatly improved by turning row entry mode on.
</p>
<p>There are several caveats associated with row entry mode. First, only use this function on lpSolve linear program models created by <code><a href="#topic+make.lp">make.lp</a></code>. Do not use this function on models read from a file. Second, add the objective function before adding the constraints. Third, do not call any other API functions while in row entry mode; no other data matrix access is allowed. After adding all the contraints, turn row entry mode off. Once turned off, you cannot switch back to row entry mode.
</p>


<h3>Value</h3>

<p><code>"on"</code> if row entry mode is on in <code>lprec</code>; otherwise <code>"off"</code>. 
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+add.constraint">add.constraint</a></code></p>

<hr>
<h2 id='select.solution'>Select Solution</h2><span id='topic+select.solution'></span>

<h3>Description</h3>

<p>Select which solution is returned by the lpSolve accessor methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.solution(lprec, solution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.solution_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="select.solution_+3A_solution">solution</code></td>
<td>
<p>optional. An integer between <code>1</code> and the number of optimal solutions to the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the branch and bound algorithm is used (i.e., when there are integer, semi-continuous or SOS variables in the model) there may be multiple optimal solutions.
</p>


<h3>Value</h3>

<p>a single integer value: the number of optimal solutions.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='set.basis'>Set Basis</h2><span id='topic+set.basis'></span>

<h3>Description</h3>

<p>Set the initial basis in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.basis(lprec, basis, nonbasic = FALSE, default = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.basis_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.basis_+3A_basis">basis</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., (m+n)}</code> (where <code>m</code> is the number of constraints and <code>n</code> is the number of decision variables) specifying the initial basis. The values may be positive or negative where a negative value indicates that the variable is at its lower bound and positive value indicates that the variable is at its upper bound. If <code>nonbasic</code> is <code>FALSE</code> then the <code>n</code> basic variables must be provided. If <code>nonbasic</code> is <code>TRUE</code> then the nonbasic variables must be provided as well.</p>
</td></tr>
<tr><td><code id="set.basis_+3A_nonbasic">nonbasic</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the nonbasic variables must be included in <code>basis</code> as well.</p>
</td></tr>
<tr><td><code id="set.basis_+3A_default">default</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the default (all slack variable) basis is used. In this case, the value of <code>basis</code> and <code>nonbasic</code> are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='set.bounds'>Set Bounds</h2><span id='topic+set.bounds'></span>

<h3>Description</h3>

<p>Set bounds on the decision variables in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.bounds(lprec, lower = NULL, upper = NULL, columns = 1:n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.bounds_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.bounds_+3A_lower">lower</code></td>
<td>
<p>a numeric vector of lower bounds to be set on the decision variables specified in <code>columns</code>. If <code>NULL</code> the lower bounds are not changed.</p>
</td></tr>
<tr><td><code id="set.bounds_+3A_upper">upper</code></td>
<td>
<p>a numeric vector of upper bounds to be set on the decision variables specified in <code>columns</code>. If <code>NULL</code> the upper bounds are not changed.</p>
</td></tr>
<tr><td><code id="set.bounds_+3A_columns">columns</code></td>
<td>
<p>a numeric vector of values from the set <code>{1, ..., n}</code> specifying the columns to have their bounds set. If <code>NULL</code> all columns are set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 4)

set.bounds(lps.model, lower = rep(-1.0, 4))
set.bounds(lps.model, upper = 1:4)

set.bounds(lps.model, lower = rep(0.0, 4), upper = rep(1.0, 4))
</code></pre>

<hr>
<h2 id='set.branch.mode'>Set Branch Mode</h2><span id='topic+set.branch.mode'></span>

<h3>Description</h3>

<p>Specify which branch to take first in the branch-and-bound algorithm for decision variables in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.branch.mode(lprec, columns, modes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.branch.mode_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.branch.mode_+3A_columns">columns</code></td>
<td>
<p>a numeric vector containing values from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying which columns to set the mode for.</p>
</td></tr>
<tr><td><code id="set.branch.mode_+3A_modes">modes</code></td>
<td>
<p>a character vector composed of the strings <code>{"ceiling", "floor", "auto", "default"}</code> giving the branch modes for the decision variables specified in <code>columns</code>.  Please see the reference for a description of these terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='set.branch.weights'>Set Branch Weights</h2><span id='topic+set.branch.weights'></span>

<h3>Description</h3>

<p>Set weights on the variables in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.branch.weights(lprec, weights)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.branch.weights_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.branch.weights_+3A_weights">weights</code></td>
<td>
<p>a numeric vector with <code>n</code> elements (where <code>n</code> is the number of decision variables in <code>lprec</code>) containing the weights for the decision variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='set.column'>Set Column</h2><span id='topic+set.column'></span>

<h3>Description</h3>

<p>Set a column in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.column(lprec, column, x, indices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.column_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.column_+3A_column">column</code></td>
<td>
<p>a single numeric value from the set <code>{1, ..., n}</code> specifying which column to set.</p>
</td></tr>
<tr><td><code id="set.column_+3A_x">x</code></td>
<td>
<p>a numeric vector containing the elements (only the nonzero elements if <code>indices</code> is also given) to be used in the added column. The length of <code>x</code> must be equal to the number of constraints in <code>lprec</code> unless <code>indices</code> is provided.</p>
</td></tr>
<tr><td><code id="set.column_+3A_indices">indices</code></td>
<td>
<p>optional for sparse <code>x</code>. A numeric vector the same length as <code>x</code> of unique values from the set {0, ..., m} where m is the number of constraints in <code>lprec</code>; <code>x[i]</code> is set in constraint <code>indices[i]</code> in the specified column.  The coefficients for the constraints not in <code>indices</code> are set to zero.  In particular, index <code>0</code> is the objective function coefficient in the specified column and is set to zero by default. This argument should be omitted when <code>length(x) == m</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 2)
set.column(lps.model, 2, c(6,2,4,9))
set.column(lps.model, 1, c(3,1,5), indices = c(1,2,4))
</code></pre>

<hr>
<h2 id='set.constr.type'>Set Constraint Type</h2><span id='topic+set.constr.type'></span>

<h3>Description</h3>

<p>Set constraint types in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.constr.type(lprec, types, constraints = 1:m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.constr.type_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.constr.type_+3A_types">types</code></td>
<td>
<p>either a numeric vector or a character vector containing elements from the set <code>{1 = "&lt;=", 2 = "&gt;=", 3 = "="}</code> specifying the types of constraints.  Additionally, the contraint type can be set to <em>free</em> uinsg the code <code>0</code>.</p>
</td></tr>
<tr><td><code id="set.constr.type_+3A_constraints">constraints</code></td>
<td>
<p>a numeric vector of unique values from the set {1, ..., m} (where m is the number of constraints in <code>lprec</code>) specifying which constraints to set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+resize.lp">resize.lp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 2)

x &lt;- c(6,2,4,9)
set.column(lps.model, 2, x)

y &lt;- c(3,1,5)
ind &lt;- c(1,2,4)
set.column(lps.model, 1, y, ind)

set.constr.type(lps.model, rep("&lt;=", 4))
</code></pre>

<hr>
<h2 id='set.constr.value'>Set Constraint Value</h2><span id='topic+set.constr.value'></span>

<h3>Description</h3>

<p>Set constraint values in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.constr.value(lprec, rhs = NULL, lhs = NULL, constraints = 1:m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.constr.value_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.constr.value_+3A_rhs">rhs</code></td>
<td>
<p>a numeric vector the same length as <code>constraints</code> containing the right-hand-side values to be set.  If <code>NULL</code> no right-hand-side values are set.</p>
</td></tr>
<tr><td><code id="set.constr.value_+3A_lhs">lhs</code></td>
<td>
<p>a numeric vector the same length as <code>constraints</code> containing the left-hand-side values to be set.  If <code>NULL</code> no left-hand-side values are set.</p>
</td></tr>
<tr><td><code id="set.constr.value_+3A_constraints">constraints</code></td>
<td>
<p>a numeric vector of unique values from the set {1, ..., m} (where m is the number of constraints in <code>lprec</code>) specifying which constraints to set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+resize.lp">resize.lp</a></code></p>

<hr>
<h2 id='set.mat'>Set Matrix Element</h2><span id='topic+set.mat'></span>

<h3>Description</h3>

<p>Set the value of a single matrix element in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.mat(lprec, i, j, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.mat_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.mat_+3A_i">i</code></td>
<td>
<p>a single numeric value from the set <code>{1, ..., m}</code> (where <code>m</code> is the number of constraints in <code>lprec</code>) specifying the row of the matrix.</p>
</td></tr>
<tr><td><code id="set.mat_+3A_j">j</code></td>
<td>
<p>a single numeric value from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying the column of the matrix.</p>
</td></tr>
<tr><td><code id="set.mat_+3A_value">value</code></td>
<td>
<p>a single numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+resize.lp">resize.lp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 2)
x &lt;- c(6,2,4,9)
set.column(lps.model, 2, x)
y &lt;- c(3,1,5)
ind &lt;- c(1,2,4)
set.column(lps.model, 1, y, ind)
set.constr.type(lps.model, rep("&lt;=", 4))

set.mat(lps.model, 3, 2, 4.5)
</code></pre>

<hr>
<h2 id='set.objfn'>Set Objective Function</h2><span id='topic+set.objfn'></span>

<h3>Description</h3>

<p>Set the objective function in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.objfn(lprec, obj, indices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.objfn_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.objfn_+3A_obj">obj</code></td>
<td>
<p>a numeric vector of length <code>n</code> (where n is the number of decision variables in <code>lprec</code>) containing the coefficients of the objective function. Alternatively, if <code>indices</code> is also provided, a numeric vector of the same length as <code>indices</code> containing only the nonzero coefficients.</p>
</td></tr>
<tr><td><code id="set.objfn_+3A_indices">indices</code></td>
<td>
<p>optional for sparse <code>obj</code>. A numeric vector the same length as <code>obj</code> of unique values from the set {1, ..., n} where n is the number of decision variables in <code>lprec</code>; <code>obj[i]</code> is entered into column <code>indices[i]</code> in objective function.  The coefficients for the columns not in <code>indices</code> are set to zero.  This argument should be omitted when <code>length(obj) == n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+resize.lp">resize.lp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(2, 4)
set.objfn(lps.model, c(1,2,3,4))
set.objfn(lps.model, c(5,7,6), indices = c(1,2,4))
</code></pre>

<hr>
<h2 id='set.rhs'>Set Right-Hand-Side</h2><span id='topic+set.rhs'></span>

<h3>Description</h3>

<p>Set elements on the right-hand-side of an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.rhs(lprec, b, constraints = 1:m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.rhs_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.rhs_+3A_b">b</code></td>
<td>
<p>a numeric vector of length <code>m</code> (where m is the number of constraints in <code>lprec</code>) </p>
</td></tr>
<tr><td><code id="set.rhs_+3A_constraints">constraints</code></td>
<td>
<p>a numeric vector containing unique elements from the set {1, ..., m} (where m is the number of constraints in <code>lprec</code>) identifying the constraints for which to set the right-hand-side value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(4, 2)
x &lt;- c(6,2,4,9)
set.column(lps.model, 2, x)
y &lt;- c(3,1,5)
ind &lt;- c(1,2,4)
set.column(lps.model, 1, y, ind)

set.rhs(lps.model, c(10, 20, 40, 80))
</code></pre>

<hr>
<h2 id='set.row'>Set Row</h2><span id='topic+set.row'></span>

<h3>Description</h3>

<p>Set a column in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.row(lprec, row, xt, indices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.row_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.row_+3A_row">row</code></td>
<td>
<p>a single numeric value from the set <code>{1, ..., m}</code> (where <code>m</code> is the number of constraints in <code>lprec</code>) specifying which column to set.</p>
</td></tr>
<tr><td><code id="set.row_+3A_xt">xt</code></td>
<td>
<p>a numeric vector containing the constraint coefficients (only the nonzero coefficients if <code>indices</code> is also given). The length of <code>xt</code> must be equal to the number of decision variables in <code>lprec</code> unless <code>indices</code> is provided.</p>
</td></tr>
<tr><td><code id="set.row_+3A_indices">indices</code></td>
<td>
<p>optional for sparse <code>xt</code>. A numeric vector the same length as <code>xt</code> of unique values from the set {1, ..., n} where n is the number of decision variables in <code>lprec</code>; <code>xt[i]</code> is set in column <code>indices[i]</code> in the specified row.  The coefficients for the columns not in <code>indices</code> are set to zero.  This argument should be omitted when <code>length(xt) == n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(2, 4)
set.row(lps.model, 2, c(6,2,4,9))
set.row(lps.model, 1, c(3,1,5), indices = c(1,2,4))
</code></pre>

<hr>
<h2 id='set.semicont'>Set Semicontinuous</h2><span id='topic+set.semicont'></span>

<h3>Description</h3>

<p>Set a decision variable as semicontinuous in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.semicont(lprec, columns, sc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.semicont_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.semicont_+3A_columns">columns</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying which variables should be made semicontinuous.</p>
</td></tr>
<tr><td><code id="set.semicont_+3A_sc">sc</code></td>
<td>
<p>a logical value. If <code>FALSE</code> the decision variables specified in <code>columns</code> will have their <code>kind</code> set to <code>standard</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Decision variables have both a type and a kind. The type is either <code>real</code> or <code>integer</code> and indicates the type of values the decision variable may take. The kind is one of <code>{standard, semi-continuous, SOS}</code>. Semi-continuous decision variables can take allowed values between their upper and lower bound as well as zero. Please see the link in the references for further details.
</p>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

<hr>
<h2 id='set.type'>Set Type</h2><span id='topic+set.type'></span>

<h3>Description</h3>

<p>Set the type of a decision variable in an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.type(lprec, columns, type = c("integer", "binary", "real"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.type_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="set.type_+3A_columns">columns</code></td>
<td>
<p>a numeric vector of unique values from the set <code>{1, ..., n}</code> (where <code>n</code> is the number of decision variables in <code>lprec</code>) specifying which variables are to have their type set.</p>
</td></tr>
<tr><td><code id="set.type_+3A_type">type</code></td>
<td>
<p>either <code>"integer"</code>, <code>"binary"</code> or <code>"real"</code>. The decision variables in <code>columns</code> will have their type set to this value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A binary decision variable is simply an integer decision with an upper bound of one and a lower bound of zero. When <code>type = "binary"</code> the type of the decision variable will be set to <code>"integer"</code> and the bounds will be set to zero and one respectively.
</p>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+set.type">set.type</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
set.type(lps.model, 2, "binary")
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.type(lps.model, 3, "integer")
set.objfn(lps.model, c(-3,-4,-3))

get.type(lps.model)
</code></pre>

<hr>
<h2 id='solve.lpExtPtr'>Solve a Linear Program</h2><span id='topic+solve.lpExtPtr'></span>

<h3>Description</h3>

<p>Attempt to compute the optimal solution of an lpSolve linear program model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpExtPtr'
solve(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solve.lpExtPtr_+3A_a">a</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="solve.lpExtPtr_+3A_b">b</code></td>
<td>
<p>this argument is ignored.</p>
</td></tr>
<tr><td><code id="solve.lpExtPtr_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single integer value containing the status code.
</p>


<h3>Status Codes</h3>


<table>
<tr>
 <td style="text-align: right;">
   0: </td><td style="text-align: left;"> "optimal solution found" </td>
</tr>
<tr>
 <td style="text-align: right;">
   1: </td><td style="text-align: left;"> "the model is sub-optimal" </td>
</tr>
<tr>
 <td style="text-align: right;">
   2: </td><td style="text-align: left;"> "the model is infeasible" </td>
</tr>
<tr>
 <td style="text-align: right;">
   3: </td><td style="text-align: left;"> "the model is unbounded" </td>
</tr>
<tr>
 <td style="text-align: right;">
   4: </td><td style="text-align: left;"> "the model is degenerate" </td>
</tr>
<tr>
 <td style="text-align: right;">
   5: </td><td style="text-align: left;"> "numerical failure encountered" </td>
</tr>
<tr>
 <td style="text-align: right;">
   6: </td><td style="text-align: left;"> "process aborted" </td>
</tr>
<tr>
 <td style="text-align: right;">
   7: </td><td style="text-align: left;"> "timeout" </td>
</tr>
<tr>
 <td style="text-align: right;">
   9: </td><td style="text-align: left;"> "the model was solved by presolve" </td>
</tr>
<tr>
 <td style="text-align: right;">
  10: </td><td style="text-align: left;"> "the branch and bound routine failed" </td>
</tr>
<tr>
 <td style="text-align: right;">
  11: </td><td style="text-align: left;"> "the branch and bound was stopped because of a break-at-first or break-at-value" </td>
</tr>
<tr>
 <td style="text-align: right;">
  12: </td><td style="text-align: left;"> "a feasible branch and bound solution was found" </td>
</tr>
<tr>
 <td style="text-align: right;">
  13: </td><td style="text-align: left;"> "no feasible branch and bound solution was found" </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>lps.model &lt;- make.lp(0, 3)
xt &lt;- c(6,2,4)
add.constraint(lps.model, xt, "&lt;=", 150)
xt &lt;- c(1,1,6)
add.constraint(lps.model, xt, "&gt;=", 0)
xt &lt;- c(4,5,4)
add.constraint(lps.model, xt, "=", 40)
set.objfn(lps.model, c(-3,-4,-3))

solve(lps.model)
</code></pre>

<hr>
<h2 id='write.lp'>Write Linear Program</h2><span id='topic+write.lp'></span>

<h3>Description</h3>

<p>Write an lpSolve linear program model object to a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.lp(lprec, filename, type = c("lp", "mps", "freemps"),
         use.names = c(TRUE, TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.lp_+3A_lprec">lprec</code></td>
<td>
<p>an lpSolve linear program model object.</p>
</td></tr>
<tr><td><code id="write.lp_+3A_filename">filename</code></td>
<td>
<p>a character string containing the name of the output file.</p>
</td></tr>
<tr><td><code id="write.lp_+3A_type">type</code></td>
<td>
<p>either <code>"lp"</code>, <code>"mps"</code> or <code>"freemps"</code>. The type of file to output. Please see the reference for a description of these formats.</p>
</td></tr>
<tr><td><code id="write.lp_+3A_use.names">use.names</code></td>
<td>
<p>a logical vector of length two specifying repectively whether row and column names should be written into the file. If <code>TRUE</code> then the names are written into the file, otherwise lpSolve's internal names are used. This can be useful if the model names do not comply with the syntax of the chosen file type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>Kjell Konis <a href="mailto:kjell.konis@me.com">kjell.konis@me.com</a></p>


<h3>References</h3>

<p><a href="https://lpsolve.sourceforge.net/5.5/index.htm">https://lpsolve.sourceforge.net/5.5/index.htm</a></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
