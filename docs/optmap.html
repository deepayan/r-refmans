<!DOCTYPE html><html><head><title>Help for package optmap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {optmap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alignment'><p> Optical Map Alignment</p></a></li>
<li><a href='#coveragePlot'>
<p>Whole genome coverage plot</p></a></li>
<li><a href='#optmapset'><p> The optmapset class and its methods</p></a></li>
<li><a href='#placement'>
<p>Functions to read and summarize optical map placement information</p></a></li>
<li><a href='#positive.density'><p> Density estimators for positive random variables</p></a></li>
<li><a href='#read.ommaps'><p> Functions to import and export optical map data</p></a></li>
<li><a href='#scaffold'>
<p>Functions to read contig scaffold  information</p></a></li>
<li><a href='#significance.rule'><p> Determine a significance rule from simulated data</p></a></li>
<li><a href='#simulate.ommaps'><p> Simulation of optical maps</p></a></li>
<li><a href='#window'>
<p>Overlapping Windows and Hit Counts</p></a></li>
<li><a href='#zscore'>
<p>Simple coverage score for overlapping bins</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2005/04/13</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyis of Optical Mapping Data</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Deepayan Sarkar &lt;deepayan@stat.wisc.edu&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Deepayan Sarkar</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to analyze Optical Mapping data, including
        input/output, simulation and alignment</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.1.0), lattice, grid</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.3.0; x86_64-pc-linux-gnu; 2022-08-22 08:13:29 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='alignment'> Optical Map Alignment </h2><span id='topic+align.mapset'></span><span id='topic+print.aligned.mapset'></span><span id='topic+plot.aligned.mapset'></span>

<h3>Description</h3>

<p>Functions related to alignment of an optical map set to a reference
restriction map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
align.mapset(refset, optset,
             scheme = c("soma", "deviance", "logodds"),
             penalized = TRUE,
             local = FALSE,
             allow.danglers = FALSE,
             orientation = c("both", "forward", "backward"),
             verbose = getOption("verbose"),
             control = list(),
             ktuple = FALSE,
             allow.missing = FALSE,
             ratio.summary = quote(median(x)),
             ...)
## S3 method for class 'aligned.mapset'
print(x, ...)
## S3 method for class 'aligned.mapset'
plot(x, which, type = 'l', ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignment_+3A_refset">refset</code></td>
<td>

<p>object of class &ldquo;optmapset&rdquo;, representing the reference to which
maps are to be aligned.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_optset">optset</code></td>
<td>

<p>object of class &ldquo;optmapset&rdquo;, representing the maps to be aligned.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_scheme">scheme</code></td>
<td>

<p>character string, describing scoring scheme to be used.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_penalized">penalized</code></td>
<td>

<p>logical, whether missing and false cuts should be penalized in the
score.  <code>penalized=FALSE</code> is mostly for academic interest.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_local">local</code></td>
<td>

<p>logical, whether alignment is local (default is global)
</p>
</td></tr>
<tr><td><code id="alignment_+3A_allow.danglers">allow.danglers</code></td>
<td>

<p>logical, whether alignments should allow danglers
</p>
</td></tr>
<tr><td><code id="alignment_+3A_orientation">orientation</code></td>
<td>

<p>Each map can be aligned in forward or backward orientations.  By
default, both are done.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_verbose">verbose</code></td>
<td>

<p>logical or integer, denoting amount of verbosity
</p>
</td></tr>
<tr><td><code id="alignment_+3A_control">control</code></td>
<td>

<p>list controlling various parameters used in scoring.  Passed to
<code>nusealControl</code> to modify the defaults.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_ktuple">ktuple</code></td>
<td>

<p>logical, specifying whether the k-tuple method of alignment should
be used.  If <code>FALSE</code> (the default), plain dynamic programming
used.  If <code>TRUE</code>, the search is broadened to include uniform
scaling of the optical maps.  Details of how this is done may
change.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_allow.missing">allow.missing</code></td>
<td>

<p>logical, specifying whether one missing cut should be allowed when
searching for k-tuples with small angles.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_ratio.summary">ratio.summary</code></td>
<td>

<p>quoted function used to summarize a vector of scale values into a
single number.  Relevant only when <code>ktuple = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_x">x</code></td>
<td>

<p>an object of class &ldquo;aligned.optmapset&rdquo;, to be plotted or printed.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_which">which</code></td>
<td>

<p>integer, which alignment to plot (index is treated as a vector index
to components <code>score</code>, <code>cutsite.index</code>, etc.).  Only one
alignment can be plotted at a time.
</p>
</td></tr>
<tr><td><code id="alignment_+3A_type">type</code></td>
<td>
<p> passed down to <code>xyplot</code> </p>
</td></tr>
<tr><td><code id="alignment_+3A_...">...</code></td>
<td>

<p>other arguments.  Ignored by the <code>print</code> method, passed down to
<code>xyplot</code> for the <code>plot</code> method.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>align.mapset</code> produces an object of class
&ldquo;aligned.mapset&rdquo;,stored as a list with the following components.
The last four components have a dim attribute of length 3, i.e.,
they are 3-dimensional arrays.  Each entry corresponds to the best
alignment of one optical map (2nd margin) against one reference
contig (1st margin), with the optical map either in forward or
backward orientation (3rd margin).
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p> call that produced the object </p>
</td></tr>
<tr><td><code>refset.name</code></td>
<td>

<p>deparsed name of the <code>refset</code> argument, may be used to retrieve
the reference mapset later.
</p>
</td></tr>
<tr><td><code>optset.name</code></td>
<td>

<p>similarly, deparsed name of the <code>optset</code> argument.
</p>
</td></tr>
<tr><td><code>nfrag</code></td>
<td>

<p>numeric vector as long as the number of maps aligned, giving the
number of fragments in each map.  Available for convenience
(plotting etc.), can be easily generated from the orinal
<code>optset</code>.
</p>
</td></tr>
<tr><td><code>glength</code></td>
<td>

<p>numeric vector as long as the number of maps aligned, giving the
total length of each map.
</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p> time taken for the alignment to complete. </p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p> numeric array, records best score </p>
</td></tr>
<tr><td><code>cutsite.index</code></td>
<td>

<p>list array. Each component is a nx2 matrix of cutsite indices that
define the best alignment.  Each row denotes a cutsite
correspondence, the first column represents cutsites on the
reference contig, the second column those on the optical map.
</p>
</td></tr>
<tr><td><code>fragment.length</code></td>
<td>

<p>Similar to <code>cutsite.index</code>, only this time the numbers recorded
are the lengths of aligned chunks.  This information is redundant,
in the sense that it could have been retrieved from the
<code>cutsite.index</code> component and the original maps used in the
alignment.
</p>
</td></tr>
<tr><td><code>ratios</code></td>
<td>

<p>available only in the case <code>ktuple=TRUE</code>; numeric array 
recording ratio for the best scoring alignment.  Note that
<code>fragment.length</code> records the unscaled lengths.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>

<hr>
<h2 id='coveragePlot'>
Whole genome coverage plot
</h2><span id='topic+coveragePlot'></span>

<h3>Description</h3>

<p>Plots a whole-genome view of coverage.  The &ldquo;coverage&rdquo; to be plotted
can be determined by various methods (as long as the results are in
the right format).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
coveragePlot(bins, scores,
             scaffold = NULL,
             layout = c(1, length(nm)),
             strip = FALSE,
             xlab = "",
             type = 'l',
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coveragePlot_+3A_bins">bins</code></td>
<td>
 
<p>list of bins, object of class &ldquo;ombinsList&rdquo;
</p>
</td></tr>
<tr><td><code id="coveragePlot_+3A_scores">scores</code></td>
<td>
 
<p>corresponding list of scores (to be plotted), object of class
&ldquo;zscoreList&rdquo; (or not)
</p>
</td></tr>
<tr><td><code id="coveragePlot_+3A_scaffold">scaffold</code></td>
<td>
 
<p>optional object of class &ldquo;scaffold&rdquo;
</p>
</td></tr>
<tr><td><code id="coveragePlot_+3A_layout">layout</code>, <code id="coveragePlot_+3A_strip">strip</code>, <code id="coveragePlot_+3A_type">type</code>, <code id="coveragePlot_+3A_xlab">xlab</code>, <code id="coveragePlot_+3A_...">...</code></td>
<td>
 
<p>passed along to underlying trellis call
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &ldquo;trellis&rdquo;, which when printed produces
anappropriate plot.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="optmap.html#topic+ombins">ombins</a></code>
</p>

<hr>
<h2 id='optmapset'> The optmapset class and its methods </h2><span id='topic+print.optmapset'></span><span id='topic+plot.optmapset'></span><span id='topic++5B.optmapset'></span>

<h3>Description</h3>

<p>Optical mapping data are represented in the optmap package as objects
of class &ldquo;optmapset&rdquo;.  This page documents this class and its
methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optmapset'
print(x, ...)
## S3 method for class 'optmapset'
plot(x, y = NULL,
     type = 'h',
     layout = c(1, length(x)),
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optmapset_+3A_x">x</code></td>
<td>
<p> Object of class &ldquo;optmapset&rdquo; </p>
</td></tr>
<tr><td><code id="optmapset_+3A_y">y</code></td>
<td>
<p> dummy variable, ignored </p>
</td></tr>
<tr><td><code id="optmapset_+3A_type">type</code>, <code id="optmapset_+3A_layout">layout</code></td>
<td>

<p>arguments to <code>xyplot</code>, included because the defaults are
different from those of <code>xyplot</code>
</p>
</td></tr>
<tr><td><code id="optmapset_+3A_...">...</code></td>
<td>

<p>For the <code>plot</code> method, extra arguments, passed on to
<code>xyplot</code> to further customize the plot.  Extra arguments to the
<code>print</code> method are ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print</code> and <code>plot</code> methods for &ldquo;optmapset&rdquo; objects.  The
print method only provides a brief summary, consider
<code>write.ommaps</code> for a full output.  These objects can be
large, so beware.  There is a subset method that preserves the class
and relevant attributes.
</p>


<h3>Value</h3>

<p>An &ldquo;optmapset&rdquo; object is simply a named list of numeric vectors
(representing restriction fragment lengths).  It has some additional
attributes describing its origin (e.g., whether it was simulated).
For a simulated mapset, each element has further attributes recording
its true origin.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="optmap.html#topic+read.ommaps">read.ommaps</a>, <a href="optmap.html#topic+simulate.ommaps">simulate.ommaps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
human.xy &lt;-
    read.ommaps(file = system.file("human.xy.maps", package = "optmap"))
human.xy
str(human.xy[1:4])
human.xy.sim &lt;-
    simulate.ommaps(ref = human.xy, n = 10, dig.rate = 0.77)
human.xy.sim
str(attributes(human.xy.sim))
plot(human.xy.sim, strip = FALSE)

</code></pre>

<hr>
<h2 id='placement'>
Functions to read and summarize optical map placement information
</h2><span id='topic+read.placement'></span><span id='topic++5B.placement'></span><span id='topic+print.placement'></span><span id='topic+summary.placement'></span><span id='topic+plot.placement'></span>

<h3>Description</h3>

<p>These functions are meant to read optical map placement information
from a (typically) comma-separated file with four columns giving map
id, chromosome in which map was placed, the start point and end point
(in base pair address within that chromosome).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.placement(file = stop("file must be specified"),
               what = list(id = NULL, chromosome = "", start = numeric(0), end = numeric(0)),
               sep = ",",
               ...)
## S3 method for class 'placement'
print(x, ...)
## S3 method for class 'placement'
summary(object, reorder = FALSE, ...)
## S3 method for class 'placement'
plot(x, plot.type = c("barchart", "densityplot"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="placement_+3A_file">file</code></td>
<td>
<p> The file from which placement data are to be read </p>
</td></tr>
<tr><td><code id="placement_+3A_what">what</code></td>
<td>

<p>controls what fields are available in the input file, and which of
them to read.  By default, the first field (map id) is ignored.  The
fields <code>chromosome</code>, <code>start</code> and <code>end</code> are required,
as they are used to construct the object returned.
</p>
</td></tr>
<tr><td><code id="placement_+3A_sep">sep</code></td>
<td>
<p> field separator, passed on to <code>scan</code> </p>
</td></tr>
<tr><td><code id="placement_+3A_x">x</code>, <code id="placement_+3A_object">object</code></td>
<td>
<p> an object of class &ldquo;placement&rdquo;</p>
</td></tr>
<tr><td><code id="placement_+3A_reorder">reorder</code></td>
<td>

<p>logical, whether to reorder the chromosomes when summarizing so that
those with more hits come first.  This argument also applies to the
<code>plot</code> method, as long as the <code>plot.type</code> is &ldquo;barchart&rdquo;.
</p>
</td></tr>
<tr><td><code id="placement_+3A_plot.type">plot.type</code></td>
<td>

<p>defines type of underlying plot.  <code>"densityplot"</code> can be slow.
</p>
</td></tr>
<tr><td><code id="placement_+3A_...">...</code></td>
<td>

<p>extra arguments, typically passed along to other functions: for
<code>read.placement</code>, <code>scan</code>; for the <code>plot</code> method, the
respective lattice high-level function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read.placement</code> produces an object of class &ldquo;placement&rdquo;, which
is essentially a named list of sorted hit locations (<code>(start +
    end) / 2</code>).  Each component corresponds to (ans is named by) a
unique value of the <code>chromosome</code> field.  The chromosomes are
ordered numerically by their names, and then alphabetically for
non-numeric names.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scan">scan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read a mapset from system.file (maybe just human X and Y)

## simulate 5 maps from it , write

</code></pre>

<hr>
<h2 id='positive.density'> Density estimators for positive random variables </h2><span id='topic+grenanderDensity'></span><span id='topic+densityPlus'></span>

<h3>Description</h3>

<p>Density estimators suitable for positive random variables and / or
random variables with a monotone density. <code>grenanderDensity</code>
produces the so-called Grenander estimator.  <code>densityPlus</code> is
like <code>density</code> (with less options), expect the kernels are
left-truncated at 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grenanderDensity(x, cdf = FALSE, concave = TRUE)
densityPlus(x, from = 0, to = max(x, na.rm = TRUE),
            h = diff(range(x)) / sqrt(length(x)),
            n = 51, which.kern = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="positive.density_+3A_x">x</code></td>
<td>
<p> numeric vector of data values </p>
</td></tr>
<tr><td><code id="positive.density_+3A_cdf">cdf</code></td>
<td>
<p> logical </p>
</td></tr>
<tr><td><code id="positive.density_+3A_concave">concave</code></td>
<td>

<p>logical, whether the density is monotone decreasing (i.e., CDF
concave) or increasing (CDF convex)
</p>
</td></tr>
<tr><td><code id="positive.density_+3A_from">from</code>, <code id="positive.density_+3A_to">to</code>, <code id="positive.density_+3A_n">n</code></td>
<td>

<p>defines grid where density is estimated, as in <code>density</code>
</p>
</td></tr>
<tr><td><code id="positive.density_+3A_h">h</code></td>
<td>
<p>bandwidth</p>
</td></tr>
<tr><td><code id="positive.density_+3A_which.kern">which.kern</code></td>
<td>
<p> kernel. Not too many options yet. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>grenanderDensity</code> returns either a step function representing
estimated density (is <code>cdf=FALSE</code>) or a piecewise linear
estimated CDF.
</p>
<p><code>densityPlus</code> returns an object of class &ldquo;density&rdquo;
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>


<h3>References</h3>

<p>Van der Vaart, Asymptotic Statistics, for the Grenander estimator
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>.  Another alternative provided by log-spline 
density estimation (no monotonicity).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rexp(1000)
gd &lt;- grenanderDensity(x)
plot(gd)
gf &lt;- grenanderDensity(x, cdf = TRUE)
plot(gf)
dp &lt;- densityPlus(x)
plot(dp)
</code></pre>

<hr>
<h2 id='read.ommaps'> Functions to import and export optical map data  </h2><span id='topic+read.ommaps'></span><span id='topic+write.ommaps'></span>

<h3>Description</h3>

<p>These functions are meant to write optical map data from and to files
(typically with extension .maps) used by LMCG/OpGen software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ommaps(file = stop("file must be specified"),
            info.re = "gi",
            only.length = FALSE,
            min.fragments = 3)
write.ommaps(data,
             contig.names,
             prefix = "noisy",
             digits = 6,
             enzyme = "SwaI",
             enzyme.abb = "S",
             index.min = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.ommaps_+3A_file">file</code></td>
<td>
<p> The file from which optical map data are to be read </p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_info.re">info.re</code></td>
<td>

<p>A regular expression that identifies the map identifier line (see
details below).  Matching lines are used as optical map identifiers
(names).  The immediately following lines are assumed to contain the
actual optical map lengths.
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_only.length">only.length</code></td>
<td>

<p>logical, whether only length data are stored in the file (which is
not always true).  It is fairly safe to leave this in its default
value (<code>FALSE</code>), since in that case the length data is
extracted irrespective of form (possibly at the cost of a minor loss
in efficiency).  All data except length data (if any) are currently
ignored.
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_min.fragments">min.fragments</code></td>
<td>

<p>The minimum number of fragments a map should have.  All other maps
are ignored.
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_data">data</code></td>
<td>

<p>An object of class &ldquo;optmapset&rdquo;, to be written out as a
.maps file.  Currently, only simulated maps can be exported (writing
out regular maps is not difficult, but usually pointless, since such
maps probably came into R as a .maps file in the first place).
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_contig.names">contig.names</code></td>
<td>

<p>character vector giving the identifiers (names) of the contigs from
which <code>data</code> was simulated.  Applicable only when writing
simulated maps.  Each simulated map originates from a contig in the
reference &ldquo;optmapset&rdquo; it was simulated from.  <code>data</code> retains
this information only as the index of this contig, whereas
<code>write.ommaps</code> needs to use the full identifier.
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_prefix">prefix</code></td>
<td>

<p>A (scalar) character string, used as a prefix for constructing
identifiers for simulated maps.
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_digits">digits</code></td>
<td>

<p>integer, used in <code>formatC</code>, controlling the number of digits
used in fields to store a serial number, start and end in
identifiers for simulated optical maps.
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_enzyme">enzyme</code></td>
<td>

<p>string, name for restriction enzyme used
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_enzyme.abb">enzyme.abb</code></td>
<td>

<p>one-letter abbreviation for the enzyme used
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_index.min">index.min</code></td>
<td>

<p>integer giving the number from which indexing (serial number) will
be started for simulated map.  Map identifiers consist of a
(increasing) serial number to make them unique.  When writing
separate mapsets into separate files, this argument can be used
start from where the previous one left off.
</p>
</td></tr>
<tr><td><code id="read.ommaps_+3A_...">...</code></td>
<td>

<p>extra arguments are passed to <code>cat</code> for printing,
most usefully <code>file</code> and <code>append</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In .maps files, each optical map is represented by two lines,
usually separated by a blank line. Lines starting with a '\#' are
comments.  The first line for each map is an identifier for the map.
The second is essentially a TAB-separated list of optical map lengths,
with the special property that the first three fields are a blank
(i.e., the line starts with a TAB), the name of the restriction
enzyme, and a single letter abbreviation for the enzyme.  Although it
is possible to store data for multiple enzymes in a single file, this
is rarely done.  Currently, this enzyme information is completely
ignored.
</p>
<p>The TAB separated fields do not always contain plain lengths,
sometimes they have added information (per fragment).  Usually, one
does not need to worry about this.
</p>
<p>When writing out a .maps file for simulated maps, it is necessary (or
at least useful) to have information on the origin of these maps
(i.e., their true location) available as part of the output.  This is
typically encoded as part of the map identifier.  Most of the
arguments to <code>write.ommaps</code> controls the details of how this
identifier is constructed.
</p>


<h3>Value</h3>

<p><code>read.ommaps</code> produces an object of class &ldquo;optmapset&rdquo;, which is
essentially a list of named numeric vectors.  The names are the map
identifiers, and each element is a vector of (ordered) optical map
lengths.  Special attributes store the name of the file the maps were
read from.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cat">cat</a></code>, <code><a href="base.html#topic+formatC">formatC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read a mapset from system.file (maybe just human X and Y)

## simulate 5 maps from it , write

</code></pre>

<hr>
<h2 id='scaffold'>
Functions to read contig scaffold  information
</h2><span id='topic+read.scaffold'></span>

<h3>Description</h3>

<p>These functions are meant to read scaffold information, i.e. which
parts of which chromosomes are covered by which contigs in an in
silico maps.  The input format is similar to that of (.locs) files
with placement information, but here we are interested in spread
rather than midpoint (actually interested in gaps between successive
contigs).  The input file is (typically) a comma-separated file with
four columns giving a contig id, chromosome to which the contig
belongs, the start point and end point (in base pair address within
that chromosome).  Some of this values can be -1, which indicates
something (I'm not sure what).  This function is not very mature yet,
and is currently used only for adding context to coverage plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.scaffold(file = stop("file must be specified"),
              what = list(id = NULL, chromosome = "",
              start = numeric(0), end = numeric(0)),
              sep = ",",
              ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaffold_+3A_file">file</code></td>
<td>
<p> The file from which placement data are to be read </p>
</td></tr>
<tr><td><code id="scaffold_+3A_what">what</code></td>
<td>

<p>controls what fields are available in the input file, and which of
them to read.  By default, the first field (map id) is ignored.  The
fields <code>chromosome</code>, <code>start</code> and <code>end</code> are required,
as they are used to construct the object returned.
</p>
</td></tr>
<tr><td><code id="scaffold_+3A_sep">sep</code></td>
<td>
<p> field separator, passed on to <code>scan</code> </p>
</td></tr>
<tr><td><code id="scaffold_+3A_...">...</code></td>
<td>

<p>extra arguments, typically passed along to other functions (in this
case, <code>scan</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read.scaffold</code> produces an object of class &ldquo;scaffold&rdquo;, which
is essentially a named list of sorted betwen-contig gap locations.
Each component corresponds to (ans is named by) a unique value of the
<code>chromosome</code> field.  The chromosomes are ordered numerically by
their names, and then alphabetically for non-numeric names.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scan">scan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read a mapset from system.file (maybe just human X and Y)

## simulate 5 maps from it , write

</code></pre>

<hr>
<h2 id='significance.rule'> Determine a significance rule from simulated data </h2><span id='topic+significance.rule'></span><span id='topic+combine.aligned.simulation'></span><span id='topic+evaluate.rule'></span><span id='topic+evaluate.constCutoff'></span><span id='topic+which.significant'></span><span id='topic+plot.significance.rule'></span>

<h3>Description</h3>

<p>Functions used to determine a significance rule and estimated
associated sensitivity, specificity, etc.
<code>combine.aligned.simulation</code> can combine two or more aligned
simulation results (possibly aligned in parallel).
<code>significance.rule</code> fits a regression model (possibly
non-parametric) to the spurious scores (details of this may change).
<code>evaluate.rule</code> uses such a regression model and a (possibly new)
simulated data set to estimate sensitivity and specificity associated
with various cutoffs (of the form <code>location + constant *
    scale</code>).  <code>evaluate.constCutoff</code> does the same, but with a
(varying) constant cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.aligned.simulation(...)
significance.rule(x, dim = 1,
                  model.location = c("linear", "loess"),
                  model.scale = c("linear", "loess"))
evaluate.rule(sim.aligned, sig.rule,
              mult.sigma = seq(from = 1, to = 5, length = 31))
evaluate.constCutoff(sim.aligned, 
                     cutoff = seq(from = 0, to = 100, length = 31))

which.significant(x, sig.rule = NULL, mult.sigma, cutoff)
## S3 method for class 'significance.rule'
plot(x, newdata, mult = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="significance.rule_+3A_x">x</code></td>
<td>

<p>for <code>significance.rule</code>, an object of class
&ldquo;aligned.simulation&rdquo;
</p>
</td></tr>
<tr><td><code id="significance.rule_+3A_dim">dim</code></td>
<td>

<p>1 or 2, indicating whether regression model should have just
<code>nfrag</code> or <code>glength</code> as well for predictors.
</p>
</td></tr>
<tr><td><code id="significance.rule_+3A_model.location">model.location</code></td>
<td>

<p>whether location should be estimated as a loess model, or a linear
model
</p>
</td></tr>
<tr><td><code id="significance.rule_+3A_model.scale">model.scale</code></td>
<td>

<p>whether scale should be estimated as a loess model, or a linear
model
</p>
</td></tr>
<tr><td><code id="significance.rule_+3A_sim.aligned">sim.aligned</code></td>
<td>

<p>an aligned simulation object, from which to evaluate sensitivity and
specificity
</p>
</td></tr> 
<tr><td><code id="significance.rule_+3A_sig.rule">sig.rule</code></td>
<td>

<p>for regression-based cutoff, the regression model to be evaluated
</p>
</td></tr> 
<tr><td><code id="significance.rule_+3A_mult.sigma">mult.sigma</code></td>
<td>

<p>sensitivity and specificity are to be evaluated for these values.
The cutoff is given by expected score + <code>mult.sigma</code> x
s.d.(score).  For <code>which.significant</code>, only one value is to be
supplied.
</p>
</td></tr> 
<tr><td><code id="significance.rule_+3A_cutoff">cutoff</code></td>
<td>

<p>sensitivity and specificity are to be evaluated for these cutoffs.
For <code>which.significant</code>, only one value is to be supplied.
</p>
</td></tr> 
<tr><td><code id="significance.rule_+3A_newdata">newdata</code></td>
<td>

<p>aligned simulation to be used.  The <code>plot</code> method isn't very
useful
</p>
</td></tr> 
<tr><td><code id="significance.rule_+3A_...">...</code></td>
<td>

<p>two or more aligned simulated datasets to be combined.
</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>~Describe the value returned
If it is a LIST, use
</p>
<table>
<tr><td><code>comp1</code></td>
<td>
<p>Description of 'comp1'</p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>Description of 'comp2'</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>

<hr>
<h2 id='simulate.ommaps'> Simulation of optical maps  </h2><span id='topic+simulate.ommaps'></span>

<h3>Description</h3>

<p>This function simulates optical maps from a given reference map
(typically an in silico restriction map). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
simulate.ommaps(ref, n,
                min.length = 0, mean.length = 418,
                dig.rate = NULL,
                false.rate = NULL,
                sigma = sqrt(0.306),
                alpha = 1/sigma^2,
                model = c("normal", "gamma"),
                scaling.sigma = 0,
                drop.negative = TRUE,
                desorb.rate = NULL,
                verbose = interactive(),
                seed = as.integer(2^31 * runif(1) - 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.ommaps_+3A_ref">ref</code></td>
<td>

<p>the reference mapset; an object of class &ldquo;optmapset&rdquo;
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_n">n</code></td>
<td>

<p>integer, the number of maps to be simulated
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_min.length">min.length</code></td>
<td>

<p>numeric, the minimum length in (kilo)bases of each simulated optical
map.  Optical map lengths are assumed to be exponential.
<code>min.length</code> serves as a left-truncation point, with the effect
that shorter maps are rejected.  Note that this is a filter on the
true underlying length, and after sizing and scaling errors, the
reported lengths may well be less than <code>min.length</code>.  Real
optical maps are typically filtered on the basis of observed length
and number of fragments.  No such filtering is built into
<code>simulate.ommaps</code>.
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_mean.length">mean.length</code></td>
<td>

<p>Mean length of optical maps.  In conjunction with <code>min.length</code>,
this determines the <code>rate</code> (the inverse of <code>mean.length -
      min.length</code>) of the exponential distribution used to model optical
map molecule lengths.
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_dig.rate">dig.rate</code></td>
<td>

<p>scalar between 0 and 1, representing the probability that a true
restriction site will be identified in the optical map.  These
events are modeled as intependent Bernoulli trials.  When
<code>NULL</code> (the default), optical maps contain no missing cuts.
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_false.rate">false.rate</code></td>
<td>

<p>positive scalar, giving the rate of a homogeneous Poisson process
that generates spurious (false) apparent restriction sites in
simulated optical maps.  <code>false.rate</code> is the number of false
cuts per unit length (typically kilobases) of DNA in the reference
map. When <code>NULL</code> (the default), optical maps contain no false
cuts.
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_model">model</code></td>
<td>

<p>character string, indicating choice between a Normal or Gamma model
for sizing errors.  In either case, the mean of an observed fragment
length (before scaling) is the underlying true fragment length, with
variance proportional to the mean (i.e. standard deviation
proportional to the square root of the mean).  The constant of
proportionality is determined by the arguments <code>sigma</code> and
<code>alpha</code>.  The two models are pretty much the same except for
small fragments (where both are probably inaccurate).  The Gamma
model is preferred because it always produces positive lengths.
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_sigma">sigma</code></td>
<td>

<p>positive scalar. The variance of an observed optical map fragment is
<code>sigma^2 * mu</code>, where <code>mu</code> is the underlying true fragment
length.  
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_alpha">alpha</code></td>
<td>

<p>plays the same role as <code>sigma</code>, but in a parametrization
suitable for the Gamma model.  It is OK to control this indirectly
through <code>sigma</code>, even when using the gamma model.
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_scaling.sigma">scaling.sigma</code></td>
<td>

<p>positive scalar, specifying the standard deviation of the factor
used to scale each map (which are modeled as normal with a mean of
1).
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_drop.negative">drop.negative</code></td>
<td>

<p>logical, whether negative fragments should be dropped.  Irrelevant
when <code>model = "gamma"</code>
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_desorb.rate">desorb.rate</code></td>
<td>

<p>The parameter <code>theta</code> in <code>1 - exp(-theta * x)</code>, which
specifies the probability that a fragment of length <code>x</code> is
retained in the final optical map.  If <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_verbose">verbose</code></td>
<td>

<p>logical, whether progress should be reported 
</p>
</td></tr>
<tr><td><code id="simulate.ommaps_+3A_seed">seed</code></td>
<td>

<p>A seed to be used in <code>set.seed</code> before simulation starts,
chosen randomly if unspecified.  In either case, <code>seed</code> is
stored in the returned object, and can be used to reproduce the data
later.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &ldquo;optmapset&rdquo;.  Each map encodes (as attributes)
its origins w.r.t. <code>ref</code> (though <code>ref</code> itself is not
stored).
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+set.seed">set.seed</a></code>,
<code><a href="optmap.html#topic+write.ommaps">write.ommaps</a></code> for an example.
</p>

<hr>
<h2 id='window'>
Overlapping Windows and Hit Counts
</h2><span id='topic+compute.bins'></span><span id='topic+ombins'></span><span id='topic+ombins.default'></span><span id='topic+ombins.placement'></span><span id='topic+print.ombins'></span><span id='topic+print.ombinsList'></span><span id='topic+plot.ombins'></span><span id='topic+count.hits'></span><span id='topic+lcount.hits'></span>

<h3>Description</h3>

<p>Functions to create possibly overlapping bins along one or more
chromosomes and count the number of aligned optical maps that fall
within.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.bins(sim.locs = NULL,
             proportion = 1,
             method = if (is.null(sim.locs)) "fixed" else "variable",
             end =
             switch(method,
                    fixed = max(sim.locs),
                    variable = length(sim.locs) * proportion),
             width = switch(method, fixed = 5e6, variable = 30),
             overlap = 0)
ombins(x, ...)
## Default S3 method:
ombins(x, ...)
## S3 method for class 'placement'
ombins(x, ...)

## S3 method for class 'ombins'
print(x, ...)
## S3 method for class 'ombinsList'
print(x, ...)
## S3 method for class 'ombins'
plot(x, ...)

count.hits(bins, locs)
lcount.hits(bins.list, locs.list)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_+3A_sim.locs">sim.locs</code></td>
<td>
<p> numeric vector of locations </p>
</td></tr>
<tr><td><code id="window_+3A_proportion">proportion</code></td>
<td>
</td></tr>
<tr><td><code id="window_+3A_method">method</code></td>
<td>
</td></tr>
<tr><td><code id="window_+3A_end">end</code></td>
<td>
</td></tr>
<tr><td><code id="window_+3A_width">width</code></td>
<td>
</td></tr>
<tr><td><code id="window_+3A_overlap">overlap</code></td>
<td>
</td></tr>
<tr><td><code id="window_+3A_x">x</code></td>
<td>
<p> object to be printed or plotted </p>
</td></tr>
<tr><td><code id="window_+3A_bins">bins</code></td>
<td>
<p> an object of class &ldquo;ombins&rdquo; </p>
</td></tr>
<tr><td><code id="window_+3A_locs">locs</code></td>
<td>
<p> sorted vector of locations </p>
</td></tr>
<tr><td><code id="window_+3A_bins.list">bins.list</code></td>
<td>
<p> an object of class &ldquo;ombinsList&rdquo; </p>
</td></tr>
<tr><td><code id="window_+3A_locs.list">locs.list</code></td>
<td>
<p> an object of class &ldquo;placement&rdquo; </p>
</td></tr>
<tr><td><code id="window_+3A_...">...</code></td>
<td>

<p>extra arguments, typically passed along to other functions: for
<code>read.placement</code>, <code>scan</code>; for the <code>plot</code> method, the
respective lattice high-level function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read.placement</code> produces an object of class &ldquo;placement&rdquo;, which
is essentially a named list of sorted hit locations (<code>(start +
    end) / 2</code>).  Each component corresponds to (ans is named by) a
unique value of the <code>chromosome</code> field.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scan">scan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read a mapset from system.file (maybe just human X and Y)

## simulate 5 maps from it , write

</code></pre>

<hr>
<h2 id='zscore'>
Simple coverage score for overlapping bins
</h2><span id='topic+adjust.score'></span><span id='topic+zscore'></span><span id='topic+lzscore'></span>

<h3>Description</h3>

<p>These functions are meant to convert observed and expected hit counts
into z-scores, possibly adjusted to account for multiple testing.  The
recommended adjustment is the Benjamini-Hochberg procedure that
controls the False Discovery Rate.  A few others are available for
comparison.  Note that z-scores (standard normal quantiles
corresponding to p-values) are reported instead of p-values solely for
ease of visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust.score(zscores,
             proc = c("BH", "BY", "Bonferroni", "Holm", "Hochberg"),
             ...)
zscore(hits,
       expected = 30,
       poisson = FALSE,
       adjust = TRUE,
       proc,
       ...)
lzscore(hits.list,
        expected = 30,
        adjust = c("none", "local", "global"),
        proc,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zscore_+3A_zscores">zscores</code></td>
<td>

<p>vector of z-scores to be adjusted for multiple testing
</p>
</td></tr>
<tr><td><code id="zscore_+3A_proc">proc</code></td>
<td>

<p>adjustment procedure
</p>
</td></tr>
<tr><td><code id="zscore_+3A_hits">hits</code></td>
<td>

<p>numeric (typically integer) vector of hit counts for bins along a
chromosome.  Interpreted as observations from a Poisson
distribution.
</p>
</td></tr>
<tr><td><code id="zscore_+3A_hits.list">hits.list</code></td>
<td>

<p>a named list of numeric vectors as above, typically obtained from
<code>lcount.hits</code>
</p>
</td></tr>
<tr><td><code id="zscore_+3A_expected">expected</code></td>
<td>

<p>the expected number of hits, usually scalar.  For <code>lzscore</code>,
this could optionally be a named list similar to <code>hits.list</code>,
but this has not been implemented yet.
</p>
</td></tr>
<tr><td><code id="zscore_+3A_poisson">poisson</code></td>
<td>

<p>logical, whether p-values to be determined using a Poisson
distribution, or whether to use a Normal approximation instead
</p>
</td></tr>
<tr><td><code id="zscore_+3A_adjust">adjust</code></td>
<td>

<p>whether to correct for multiple testing.  For <code>zscore</code>, this is
a logical, with type of adjustment determined by <code>proc</code>.  For
<code>lzscore</code>, the adjustment can be done locally (for each
chromosome) or globally (combining all chromosomes).  The latter is
naturally more severe.
</p>
</td></tr>
<tr><td><code id="zscore_+3A_...">...</code></td>
<td>

<p>extra arguments, typically passed along to other functions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>adjust.score</code> and <code>zscore</code> return a numeric vector of
z-scores.  <code>lzscore</code> returns an object of class &ldquo;zscoreList&rdquo;,
which is essentially a named list of z-score vectors, one for each
&lsquo;chromosome&rsquo;.
</p>


<h3>Author(s)</h3>

<p> Deepayan Sarkar <a href="mailto:deepayan@stat.wisc.edu">deepayan@stat.wisc.edu</a> </p>


<h3>See Also</h3>

<p><code><a href="optmap.html#topic+lcount.hits">lcount.hits</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
