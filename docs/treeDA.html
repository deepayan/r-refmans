<!DOCTYPE html><html><head><title>Help for package treeDA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treeDA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checkPredictorsAndTree'><p>Check predictors</p></a></li>
<li><a href='#coef.treeda'><p>Coefficients from treeda fit</p></a></li>
<li><a href='#combine_plot_and_tree'><p>Method for combining two ggplots</p></a></li>
<li><a href='#edgesToChildren'><p>Makes a hash table with nodes and their children</p></a></li>
<li><a href='#expand_background'><p>Expand the background of a gtable.</p></a></li>
<li><a href='#get_leaf_position'><p>Get leaf positions from a tree layout</p></a></li>
<li><a href='#getBranchLengths'><p>Make branch length vector</p></a></li>
<li><a href='#makeClassProperties'><p>Compute properties of the classes</p></a></li>
<li><a href='#makeDescendantMatrix'><p>Make descendant matrix</p></a></li>
<li><a href='#makeLeafCoefficients'><p>Make leaf coefficients</p></a></li>
<li><a href='#makeNodeAndLeafPredictors'><p>Make a matrix with predictors for each leaf and node</p></a></li>
<li><a href='#makeResponseMatrix'><p>Make response matrix</p></a></li>
<li><a href='#nodeToLeafCoefficients'><p>Node coefficients to leaf coefficients</p></a></li>
<li><a href='#plot_coefficients'><p>Plot the discriminating axes from treeda</p></a></li>
<li><a href='#plot.treedacv'><p>Plot a treedacv object</p></a></li>
<li><a href='#predict.treeda'><p>Predict using new data</p></a></li>
<li><a href='#print.treeda'><p>Print a treeda object</p></a></li>
<li><a href='#print.treedacv'><p>Print treedacv objects</p></a></li>
<li><a href='#treeda'><p>Tree-based sparse discriminant analysis</p></a></li>
<li><a href='#treeda_example'><p>Example dataset</p></a></li>
<li><a href='#treeDA-package'><p>Tree-based discriminant analysis</p></a></li>
<li><a href='#treedacv'><p>treeda cross validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tree-Based Discriminant Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs sparse discriminant analysis on a combination of
    node and leaf predictors when the predictor variables are
    structured according to a tree, as described in Fukuyama et
    al. (2017) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1005706">doi:10.1371/journal.pcbi.1005706</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sparseLDA (&ge; 0.1.9), Matrix (&ge; 1.2.10), mvtnorm (&ge; 1.0.6),
reshape2 (&ge; 1.4.2), gtable (&ge; 0.2.0), phyloseq (&ge; 1.22.3),
ggplot2 (&ge; 2.2.1), ape (&ge; 5.1), grid, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adaptiveGPCA (&ge; 0.1), knitr (&ge; 1.16), testthat (&ge; 2.0.0),
markdown, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jfukuyama/treeda">https://github.com/jfukuyama/treeda</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-14 20:15:48 UTC; jfukuyam</td>
</tr>
<tr>
<td>Author:</td>
<td>Julia Fukuyama [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julia Fukuyama &lt;julia.fukuyama@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-14 21:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='checkPredictorsAndTree'>Check predictors</h2><span id='topic+checkPredictorsAndTree'></span>

<h3>Description</h3>

<p>Checks whether the predictors are consistent with the tree
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPredictorsAndTree(predictors, tree)
</code></pre>

<hr>
<h2 id='coef.treeda'>Coefficients from treeda fit</h2><span id='topic+coef.treeda'></span>

<h3>Description</h3>

<p>Returns the coefficients from a treeda fit either in terms of the
leaves only or in terms of the nodes and leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treeda'
coef(object, type = c("leaves", "nodes"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.treeda_+3A_object">object</code></td>
<td>
<p>An object of class <code>treeda</code>.</p>
</td></tr>
<tr><td><code id="coef.treeda_+3A_type">type</code></td>
<td>
<p>Should the coefficients be in the leaf space or the
node space?</p>
</td></tr>
<tr><td><code id="coef.treeda_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> object containing the coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(treeda_example)
out.treeda = treeda(response = treeda_example$response,
    predictors = treeda_example$predictors,
    tree = treeda_example$tree,
    p = 1)
coef(out.treeda, type = "leaves")
coef(out.treeda, type = "nodes")
</code></pre>

<hr>
<h2 id='combine_plot_and_tree'>Method for combining two ggplots</h2><span id='topic+combine_plot_and_tree'></span>

<h3>Description</h3>

<p>This method takes a ggplot of some data along the tips of the tree
and a ggplot of a tree and combines them. It assumes that you are
putting the tree on top and that the x axis for the plot has the
leaves in the correct position (this can be found using the
function <code><a href="#topic+get_leaf_position">get_leaf_position</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_plot_and_tree(plot, tree.plot, tree.height = 5, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_plot_and_tree_+3A_plot">plot</code></td>
<td>
<p>A plot of data about the leaves with the x axis
corresponding to leaves.</p>
</td></tr>
<tr><td><code id="combine_plot_and_tree_+3A_tree.plot">tree.plot</code></td>
<td>
<p>A plot of the tree.</p>
</td></tr>
<tr><td><code id="combine_plot_and_tree_+3A_tree.height">tree.height</code></td>
<td>
<p>The relative amount of space in the plot the tree
should take up.</p>
</td></tr>
<tr><td><code id="combine_plot_and_tree_+3A_print">print</code></td>
<td>
<p>If true, the function will print the combined plot to
a graphics device, otherwise it will just return the gtable object
without printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>gtable</code> object.
</p>

<hr>
<h2 id='edgesToChildren'>Makes a hash table with nodes and their children</h2><span id='topic+edgesToChildren'></span>

<h3>Description</h3>

<p>Takes the edge matrix from a phylo-class object and turns it into a
list where the entries are nodes and the elements are vectors with
the children of the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgesToChildren(edges)
</code></pre>

<hr>
<h2 id='expand_background'>Expand the background of a gtable.</h2><span id='topic+expand_background'></span>

<h3>Description</h3>

<p>Expand the background of a gtable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_background(gtable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_background_+3A_gtable">gtable</code></td>
<td>
<p>A gtable object whose background needs to be expanded
to fill the whole space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gtable object with a bigger background.
</p>

<hr>
<h2 id='get_leaf_position'>Get leaf positions from a tree layout</h2><span id='topic+get_leaf_position'></span>

<h3>Description</h3>

<p>Takes a tree, returns a vector with names describing the leaves and
entries giving the position of that leaf in the tree layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_leaf_position(tree, ladderize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_leaf_position_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="get_leaf_position_+3A_ladderize">ladderize</code></td>
<td>
<p>FALSE for a non-ladderzied layout, TRUE or &quot;right&quot;
for a ladderized layout, &quot;left&quot; for a layout ladderized the other
way.</p>
</td></tr>
</table>

<hr>
<h2 id='getBranchLengths'>Make branch length vector</h2><span id='topic+getBranchLengths'></span>

<h3>Description</h3>

<p>Gets the branch lengths of the tree, with order the same as the
columns in makeDescendantMatrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBranchLengths(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBranchLengths_+3A_tree">tree</code></td>
<td>
<p>A tree object of class phylo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length ntips + nnodes, with ith element giving
the length of the branch above node i.
</p>

<hr>
<h2 id='makeClassProperties'>Compute properties of the classes</h2><span id='topic+makeClassProperties'></span>

<h3>Description</h3>

<p>For each class, computes the prior probabilities, means, and
variances for that class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClassProperties(response, projections)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClassProperties_+3A_response">response</code></td>
<td>
<p>A vector containing the response for each observation.</p>
</td></tr>
<tr><td><code id="makeClassProperties_+3A_projections">projections</code></td>
<td>
<p>A matrix giving the projections of each
observation onto the discriminating axes.</p>
</td></tr>
</table>

<hr>
<h2 id='makeDescendantMatrix'>Make descendant matrix</h2><span id='topic+makeDescendantMatrix'></span>

<h3>Description</h3>

<p>Make a matrix describing the ancestry structure of a tree. Element
(i,j) indicates whether leaf i is a descendant of node j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDescendantMatrix(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDescendantMatrix_+3A_tree">tree</code></td>
<td>
<p>A tree object of class phylo</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix describing the ancestry structure of a tree.
</p>

<hr>
<h2 id='makeLeafCoefficients'>Make leaf coefficients</h2><span id='topic+makeLeafCoefficients'></span>

<h3>Description</h3>

<p>For a set of coefficients defined on a matrix of (potentially
centered and scaled) leaf and node predictors, find the equivalent
set of coefficients on just the leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLeafCoefficients(sda.out, descendantMatrix, means, sds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeLeafCoefficients_+3A_sda.out">sda.out</code></td>
<td>
<p>A fitted sda object</p>
</td></tr>
<tr><td><code id="makeLeafCoefficients_+3A_descendantmatrix">descendantMatrix</code></td>
<td>
<p>A matrix describing the tree which was
used, element (i,j) indicates whether leaf i is a descendant of
node j.</p>
</td></tr>
<tr><td><code id="makeLeafCoefficients_+3A_means">means</code></td>
<td>
<p>If the original predictor matrix was centered, the
means of the original predictor matrix, otherwise NULL.</p>
</td></tr>
<tr><td><code id="makeLeafCoefficients_+3A_sds">sds</code></td>
<td>
<p>If the original predictor matrix was scaled, the sds of
the original predictor matrix, otherwise NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list giving the coefficients on the leaves for each of
the discriminating axes and the intercepts for each of the
discriminating axes.
</p>

<hr>
<h2 id='makeNodeAndLeafPredictors'>Make a matrix with predictors for each leaf and node</h2><span id='topic+makeNodeAndLeafPredictors'></span>

<h3>Description</h3>

<p>Make a matrix with one predictor for each leaf and node in the
tree, where the node predictors are the sum of the leaf predictors
descending from them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeNodeAndLeafPredictors(leafPredictors, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeNodeAndLeafPredictors_+3A_leafpredictors">leafPredictors</code></td>
<td>
<p>A predictor matrix for the leaves: rows are
samples, columns are leaves.</p>
</td></tr>
<tr><td><code id="makeNodeAndLeafPredictors_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree describing the relationships
between the species/leaves.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A predictor matrix for leaves and nodes together: rows are
samples, columns are leaf/node predictors.
</p>

<hr>
<h2 id='makeResponseMatrix'>Make response matrix</h2><span id='topic+makeResponseMatrix'></span>

<h3>Description</h3>

<p>Create a dummy variable matrix for the response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeResponseMatrix(response, class.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeResponseMatrix_+3A_response">response</code></td>
<td>
<p>A factor or character vector containing the
classes.</p>
</td></tr>
<tr><td><code id="makeResponseMatrix_+3A_class.names">class.names</code></td>
<td>
<p>A character vector giving the possible levels of
the factor. If NULL, it will be generated from the levels of
response.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dummy variable matrix with column names giving the class
names.
</p>

<hr>
<h2 id='nodeToLeafCoefficients'>Node coefficients to leaf coefficients</h2><span id='topic+nodeToLeafCoefficients'></span>

<h3>Description</h3>

<p>General-purpose function for going from a coefficient vector on the
nodes to a coefficient vector on the leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeToLeafCoefficients(coef.vec, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodeToLeafCoefficients_+3A_coef.vec">coef.vec</code></td>
<td>
<p>A vector containing coefficients on internal nodes plus leaves.</p>
</td></tr>
<tr><td><code id="nodeToLeafCoefficients_+3A_tree">tree</code></td>
<td>
<p>The phylogenetic tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing coefficients on the leaves.
</p>

<hr>
<h2 id='plot_coefficients'>Plot the discriminating axes from treeda</h2><span id='topic+plot_coefficients'></span>

<h3>Description</h3>

<p>Plots the leaf coefficients for the discriminating axes in a fitted
<code>treeda</code> model aligned under the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_coefficients(
  out.treeda,
  remove.bl = TRUE,
  ladderize = TRUE,
  tree.height = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_coefficients_+3A_out.treeda">out.treeda</code></td>
<td>
<p>The object resulting from a call to
<code><a href="#topic+treeda">treeda</a></code>.</p>
</td></tr>
<tr><td><code id="plot_coefficients_+3A_remove.bl">remove.bl</code></td>
<td>
<p>A logical, <code>TRUE</code> if the tree should be plotted
after setting all branch lengths equal to the same value or
not. The plots tend to look nicer when all the branch lengths
are the same, and the branch length information is not used in
the model.</p>
</td></tr>
<tr><td><code id="plot_coefficients_+3A_ladderize">ladderize</code></td>
<td>
<p>Layout parameter for the tree.</p>
</td></tr>
<tr><td><code id="plot_coefficients_+3A_tree.height">tree.height</code></td>
<td>
<p>The height of the tree relative to the height of
the plot below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the tree and the coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(treeda_example)
out.treeda = treeda(response = treeda_example$response,
    predictors = treeda_example$predictors,
    tree = treeda_example$tree,
    p = 1)
plot_coefficients(out.treeda)
</code></pre>

<hr>
<h2 id='plot.treedacv'>Plot a treedacv object</h2><span id='topic+plot.treedacv'></span>

<h3>Description</h3>

<p>Plots the cross-validation error with standard error bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treedacv'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.treedacv_+3A_x">x</code></td>
<td>
<p>An object of class <code>treedacv</code>.</p>
</td></tr>
<tr><td><code id="plot.treedacv_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(treeda_example)
out.treedacv = treedacv(response = treeda_example$response,
    predictors = treeda_example$predictors,
    tree = treeda_example$tree,
    pvec = 1:10)
plot(out.treedacv)
</code></pre>

<hr>
<h2 id='predict.treeda'>Predict using new data</h2><span id='topic+predict.treeda'></span>

<h3>Description</h3>

<p>Given a fitted <code><a href="#topic+treeda">treeda</a></code> model, get the predicted
classes and projections onto the discriminating axes for new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treeda'
predict(object, newdata, newresponse = NULL, check.consist = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.treeda_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+treeda">treeda</a></code> function.</p>
</td></tr>
<tr><td><code id="predict.treeda_+3A_newdata">newdata</code></td>
<td>
<p>New predictor matrix in the same format as the
<code>predictor</code> argument to treeda. A matrix of predictor
variables corresponding to the leaves of the tree and in the
same order as the leaves of the tree.</p>
</td></tr>
<tr><td><code id="predict.treeda_+3A_newresponse">newresponse</code></td>
<td>
<p>New response vector, not required.</p>
</td></tr>
<tr><td><code id="predict.treeda_+3A_check.consist">check.consist</code></td>
<td>
<p>Check the consistency between the tree and
predictor matrix?</p>
</td></tr>
<tr><td><code id="predict.treeda_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the projections of the new data onto the
discriminating axes (<code>projections</code>), the predicted classes
(<code>classes</code>), and the rss (<code>rss</code>, only included if the
ground truth for the responses is available).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(treeda_example)
out.treeda = treeda(response = treeda_example$response,
    predictors = treeda_example$predictors,
    tree = treeda_example$tree,
    p = 1)
## Here we are predicting on the training data, in general this
## would be done on a held out test set
preds = predict(out.treeda, newdata = treeda_example$predictors,
    newresponse = treeda_example$response)
## make a confusion matrix
table(preds$classes, treeda_example$response)
</code></pre>

<hr>
<h2 id='print.treeda'>Print a treeda object</h2><span id='topic+print.treeda'></span>

<h3>Description</h3>

<p>Print a treeda object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treeda'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.treeda_+3A_x">x</code></td>
<td>
<p><code>treeda</code> object.</p>
</td></tr>
<tr><td><code id="print.treeda_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='print.treedacv'>Print treedacv objects</h2><span id='topic+print.treedacv'></span>

<h3>Description</h3>

<p>Print treedacv objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'treedacv'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.treedacv_+3A_x">x</code></td>
<td>
<p><code>treedacv</code> object.</p>
</td></tr>
<tr><td><code id="print.treedacv_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>

<hr>
<h2 id='treeda'>Tree-based sparse discriminant analysis</h2><span id='topic+treeda'></span>

<h3>Description</h3>

<p>Performs tree-structured sparse discriminant analysis using an
augmented predictor matrix with additional predictors corresponding
to the nodes and then translating the parameters back in terms of
only the leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeda(
  response,
  predictors,
  tree,
  p,
  k = nclasses - 1,
  center = TRUE,
  scale = TRUE,
  class.names = NULL,
  check.consist = TRUE,
  A = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeda_+3A_response">response</code></td>
<td>
<p>A factor or character vector giving the class to be
predicted.</p>
</td></tr>
<tr><td><code id="treeda_+3A_predictors">predictors</code></td>
<td>
<p>A matrix of predictor variables corresponding to
the leaves of the tree and in the same order as the leaves of
the tree.</p>
</td></tr>
<tr><td><code id="treeda_+3A_tree">tree</code></td>
<td>
<p>A tree of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="treeda_+3A_p">p</code></td>
<td>
<p>The number of predictors to use.</p>
</td></tr>
<tr><td><code id="treeda_+3A_k">k</code></td>
<td>
<p>The number of components to use.</p>
</td></tr>
<tr><td><code id="treeda_+3A_center">center</code></td>
<td>
<p>Center the predictor variables?</p>
</td></tr>
<tr><td><code id="treeda_+3A_scale">scale</code></td>
<td>
<p>Scale the predictor variables?</p>
</td></tr>
<tr><td><code id="treeda_+3A_class.names">class.names</code></td>
<td>
<p>Optional argument giving the class names.</p>
</td></tr>
<tr><td><code id="treeda_+3A_check.consist">check.consist</code></td>
<td>
<p>Check consistency of the predictor matrix and
the tree.</p>
</td></tr>
<tr><td><code id="treeda_+3A_a">A</code></td>
<td>
<p>A matrix describing the tree structure. If it has been
computed before it can be passed in here and will not be
recomputed.</p>
</td></tr>
<tr><td><code id="treeda_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to sda</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>treeda</code>. Contains the coefficients
in the original predictor space (<code>leafCoefficients</code>), the
number of predictors used in the node + leaf space
(<code>nPredictors</code>), number of leaf predictors used
(<code>nLeafPredictors</code>), the projections of the samples onto
the discriminating axes (<code>projections</code>), and the sparse
discriminant analysis object that was used in the fit
(<code>sda</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(treeda_example)
out.treeda = treeda(response = treeda_example$response,
    predictors = treeda_example$predictors,
    tree = treeda_example$tree,
    p = 1)
out.treeda
</code></pre>

<hr>
<h2 id='treeda_example'>Example dataset</h2><span id='topic+treeda_example'></span>

<h3>Description</h3>

<p>A small example dataset with three components, stored as a list
with a vector containing the classes (<code>response</code>), a matrix
containing the predictor variables (<code>predictors</code>), and a tree
describing the relationships between the predictor variables
(<code>tree</code>). The dataset consists of 50 samples divided into two
classes and 100 taxa/predictor variables, related to each other by
a random tree (generated with <code>ape::rtree</code>). A set of 42 taxa
descending from one internal node are all over-represented in one
class and under-represented in the other. The <code>predictors</code>
element in the list contains real numbers, not counts, and is
supposed to reflect normalized taxon abundances (e.g.,
normalization using the variance-stabilizing transformation in
DESeq2).
</p>


<h3>Format</h3>

<p>A list containing response variables, predictor variables,
and a tree describing the relationship between the predictor
variables.
</p>

<hr>
<h2 id='treeDA-package'>Tree-based discriminant analysis</h2><span id='topic+treeDA'></span><span id='topic+treeDA-package'></span>

<h3>Description</h3>

<p>A package for performing sparse, tree-based discriminant analysis.
</p>


<h3>Details</h3>

<p>This package contains functions for building sparse,
tree-structured models for classification. The method is based on
the idea that when our predictors are structured according to a
tree, we can create an expanded feature space containing both the
original leaf predictors as well as node predictors, which
correspond to sums or averages across the leaves descending from
them. Without some sort of regularization this problem would be
unidentifiable, but with the regularization provided by sparse
discriminant analysis we get stable solutions.
</p>
<p>The package fits a sparse discriminant model in the expanded
feature space and translates the results back to the leaf space, so
that the interpretation can be purely in terms of the original
predictors. The package also includes functions to perform cross
validation to pick the sparsity level and plotting commands to
visualize the tree and the fitted coefficient vectors.
</p>
<p>The main function in this package is <code><a href="#topic+treeda">treeda</a></code>, which
fits a sparse tree-based discriminant model. Additional functions
provided are <code><a href="#topic+treedacv">treedacv</a></code>, which performs
cross-validation to determine the correct sparsity level, and
functions to plot the resulting coefficient vectors along the tree
(<code><a href="#topic+plot_coefficients">plot_coefficients</a></code>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Julia Fukuyama <a href="mailto:julia.fukuyama@gmail.com">julia.fukuyama@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jfukuyama/treeda">https://github.com/jfukuyama/treeda</a>
</p>
</li></ul>


<hr>
<h2 id='treedacv'>treeda cross validation</h2><span id='topic+treedacv'></span>

<h3>Description</h3>

<p>Performs cross-validation of a <code><a href="#topic+treeda">treeda</a></code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treedacv(
  response,
  predictors,
  tree,
  folds = 5,
  pvec = 1:tree$Nnode,
  k = nclasses - 1,
  center = TRUE,
  scale = TRUE,
  class.names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treedacv_+3A_response">response</code></td>
<td>
<p>The classes to be predicted.</p>
</td></tr>
<tr><td><code id="treedacv_+3A_predictors">predictors</code></td>
<td>
<p>A matrix of predictors corresponding to the tips
of the tree.</p>
</td></tr>
<tr><td><code id="treedacv_+3A_tree">tree</code></td>
<td>
<p>A tree object of class <code>phylo</code>.</p>
</td></tr>
<tr><td><code id="treedacv_+3A_folds">folds</code></td>
<td>
<p>Either a single number corresponding to the number of
folds of cross-validation to perform or a vector of integers
ranging from 1 to the number of folds desired giving the partition
of the dataset.</p>
</td></tr>
<tr><td><code id="treedacv_+3A_pvec">pvec</code></td>
<td>
<p>The values of p to use.</p>
</td></tr>
<tr><td><code id="treedacv_+3A_k">k</code></td>
<td>
<p>The number of discriminating axes to keep.</p>
</td></tr>
<tr><td><code id="treedacv_+3A_center">center</code></td>
<td>
<p>Center the predictors?</p>
</td></tr>
<tr><td><code id="treedacv_+3A_scale">scale</code></td>
<td>
<p>Scale the predictors?</p>
</td></tr>
<tr><td><code id="treedacv_+3A_class.names">class.names</code></td>
<td>
<p>A vector giving the names of the classes.</p>
</td></tr>
<tr><td><code id="treedacv_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+treeda">treeda</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the value of p with minimum cv error
(<code>p.min</code>), the minimum value of p with in 1 se of the
minimum cv error (<code>p.1se</code>), and a data frame containing
the loss for each fold, mean loss, and standard error of the
loss for each value of p (<code>loss.df</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(treeda_example)
out.treedacv = treedacv(response = treeda_example$response,
    predictors = treeda_example$predictors,
    tree = treeda_example$tree,
    pvec = 1:10)
out.treedacv
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
