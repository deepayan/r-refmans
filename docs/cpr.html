<!DOCTYPE html><html lang="en-us"><head><title>Help for package cpr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cpr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cpr-package'><p>cpr: Control Polygon Reduction</p></a></li>
<li><a href='#bsplineD'><p>B-spline Derivatives</p></a></li>
<li><a href='#bsplines'><p>B-Splines</p></a></li>
<li><a href='#btensor'><p>btensor</p></a></li>
<li><a href='#build_tensor'><p>Build Tensor</p></a></li>
<li><a href='#cn'><p>Control Nets</p></a></li>
<li><a href='#cnr'><p>Control Net Reduction</p></a></li>
<li><a href='#coef_vcov'><p>Extract Regression Coefficients for B-Splines and Tensor Products of B-splines</p></a></li>
<li><a href='#cp'><p>Control Polygons</p></a></li>
<li><a href='#cp_diff'><p>Vertical Difference between two Control Polygons</p></a></li>
<li><a href='#cp_value'><p>Control Polygon Value</p></a></li>
<li><a href='#cpr'><p>Control Polygon Reduction</p></a></li>
<li><a href='#cpr-defunct'><p>Defunct Functions</p></a></li>
<li><a href='#generate_cp_formula_data'><p>Generate Control Polygon Formula and Data</p></a></li>
<li><a href='#get_spline'><p>Get the Control Polygon and the Spline Function</p></a></li>
<li><a href='#get_surface'><p>Get Surface</p></a></li>
<li><a href='#iknots_or_df'><p>Internal Knots or Degrees of Freedom</p></a></li>
<li><a href='#influence_of_iknots'><p>Determine the influence of the internal knots of a control polygon</p></a></li>
<li><a href='#insert_a_knot'><p>Insert a Knot into a Control Polygon</p></a></li>
<li><a href='#knot_expr'><p>Knot Expressions</p></a></li>
<li><a href='#loglikelihood'><p>Determine the (quasi) Log Likelihood for a regression object.</p></a></li>
<li><a href='#matrix_rank'><p>Rank of a Matrix</p></a></li>
<li><a href='#newknots'><p>New Knots for CPs and CNs in CPR and CNR</p></a></li>
<li><a href='#order_statistics'><p>Distribution of Order Statistics</p></a></li>
<li><a href='#plot.cpr_bs'><p>Plot B-spline Basis</p></a></li>
<li><a href='#plot.cpr_cn'><p>Plotting Control Nets</p></a></li>
<li><a href='#plot.cpr_cnr'><p>Control Net Reduction Plots</p></a></li>
<li><a href='#plot.cpr_cp'><p>Plotting Control Polygons</p></a></li>
<li><a href='#plot.cpr_cpr'><p>Control Polygon Reduction Plots</p></a></li>
<li><a href='#plot.cpr_summary_cpr_cpr'><p>Plotting Summaries of Control Polygon Reductions</p></a></li>
<li><a href='#predict.cpr_cp'><p>Model Prediction</p></a></li>
<li><a href='#print.cpr_bs'><p>Print bsplines</p></a></li>
<li><a href='#sign_changes'><p>Sign Changes</p></a></li>
<li><a href='#spdg'><p>Simulated Pregnanediol glucuronide (PDG) Data</p></a></li>
<li><a href='#summary.cpr_cn'><p>Summary of Control Net</p></a></li>
<li><a href='#summary.cpr_cnr'><p>Summarize Control Net Reduction Objects</p></a></li>
<li><a href='#summary.cpr_cp'><p>Summarize a Control Polygon Object</p></a></li>
<li><a href='#summary.cpr_cpr'><p>Summarize a Control Polygon Reduction Object</p></a></li>
<li><a href='#trimmed_quantile'><p>Trimmed Quantiles</p></a></li>
<li><a href='#update_bsplines'><p>Update bsplines or btensor calls</p></a></li>
<li><a href='#us_covid_cases'><p>United States Laboratory Confirmed COVID-19 Cases</p></a></li>
<li><a href='#wiggle'><p>Wiggliness of a Spline function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Control Polygon Reduction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the Control Polygon Reduction and Control Net
    Reduction methods for finding parsimonious B-spline regression models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dewittpe/cpr/">https://github.com/dewittpe/cpr/</a>, <a href="http://www.peteredewitt.com/cpr/">http://www.peteredewitt.com/cpr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dewittpe/cpr/issues">https://github.com/dewittpe/cpr/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-us</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.0.0), lme4 (&ge; 1.1.35.1), plot3D, Rcpp (&ge;
1.0.11), rgl, scales</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix (&ge; 1.6-4), geepack, ggpubr, knitr, qwraps2 (&ge; 0.6.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 15:16:17 UTC; peterdewitt</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter DeWitt <a href="https://orcid.org/0000-0002-6391-0795"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Samantha MaWhinney [ths],
  Nichole Carlson [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter DeWitt &lt;dewittpe@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 15:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cpr-package'>cpr: Control Polygon Reduction</h2><span id='topic+cpr-package'></span>

<h3>Description</h3>

<p>The cpr package implements the control polygon reduction and control net
reduction methods for finding parsimonious B-spline regression models as
described in DeWitt (2017).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Peter DeWitt <a href="mailto:dewittpe@gmail.com">dewittpe@gmail.com</a> (<a href="https://orcid.org/0000-0002-6391-0795">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Samantha MaWhinney <a href="mailto:sam.mawhinney@ucdenver.edu">sam.mawhinney@ucdenver.edu</a> [thesis advisor]
</p>
</li>
<li><p> Nichole Carlson <a href="mailto:nichole.carlson@ucdenver.edu">nichole.carlson@ucdenver.edu</a> [thesis advisor]
</p>
</li></ul>



<h3>References</h3>

<p>DeWitt, Peter Edward. &ldquo;Parsimonious B-spline regression models via
control polygon and control net reduction for identifying factors explaining
variation in daily hormone profiles during the menopausal transition.&rdquo;
(2017).
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/dewittpe/cpr/">https://github.com/dewittpe/cpr/</a>
</p>
</li>
<li> <p><a href="http://www.peteredewitt.com/cpr/">http://www.peteredewitt.com/cpr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dewittpe/cpr/issues">https://github.com/dewittpe/cpr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bsplineD'>B-spline Derivatives</h2><span id='topic+bsplineD'></span>

<h3>Description</h3>

<p>Generate the first and second derivatives of a B-spline Basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsplineD(
  x,
  iknots = NULL,
  df = NULL,
  bknots = range(x),
  order = 4L,
  derivative = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsplineD_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="bsplineD_+3A_iknots">iknots</code></td>
<td>
<p>internal knots</p>
</td></tr>
<tr><td><code id="bsplineD_+3A_df">df</code></td>
<td>
<p>degrees of freedom: sum of the order and internal knots.  Ignored
if <code>iknots</code> is specified.</p>
</td></tr>
<tr><td><code id="bsplineD_+3A_bknots">bknots</code></td>
<td>
<p>boundary knot locations, defaults to <code>range(x)</code>.</p>
</td></tr>
<tr><td><code id="bsplineD_+3A_order">order</code></td>
<td>
<p>order of the piecewise polynomials, defaults to 4L.</p>
</td></tr>
<tr><td><code id="bsplineD_+3A_derivative">derivative</code></td>
<td>
<p>(integer) first or second derivative</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix
</p>


<h3>References</h3>

<p>C. de Boor, &quot;A practical guide to splines. Revised Edition,&quot; Springer, 2001.
</p>
<p>H. Prautzsch, W. Boehm, M. Paluszny, &quot;Bezier and B-spline Techniques,&quot; Springer, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsplines">bsplines</a></code> for bspline basis.  <code><a href="#topic+get_spline">get_spline</a></code>
will give you the spline or the derivative thereof for a control polygon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################################################################################
# Example 1 - pefectly fitting a cubic function
f &lt;- function(x) {
  x^3 - 2 * x^2 - 5 * x + 6
}

fprime &lt;- function(x) { # first derivatives of f(x)
  3 * x^2 - 4 * x - 5
}

fdoubleprime &lt;- function(x) { # second derivatives of f(x)
  6 * x - 4
}

# Build a spline to fit
bknots = c(-3, 5)

x     &lt;- seq(-3, 4.999, length.out = 200)
bmat  &lt;- bsplines(x, bknots = bknots)
theta &lt;- matrix(coef(lm(f(x) ~ bmat + 0)), ncol = 1)

bmatD1 &lt;- bsplineD(x, bknots = bknots, derivative = 1L)
bmatD2 &lt;- bsplineD(x, bknots = bknots, derivative = 2L)

# Verify that we have perfectly fitted splines to the function and its
# derivatives.
# check that the function f(x) is recovered
all.equal(f(x), as.numeric(bmat %*% theta))
all.equal(fprime(x), as.numeric(bmatD1 %*% theta))
all.equal(fdoubleprime(x), as.numeric(bmatD2 %*% theta))

# Plot the results
old_par &lt;- par()
par(mfrow = c(1, 3))
plot(x, f(x), type = "l", main = bquote(f(x)), ylab = "", xlab = "")
points(x, bmat %*% theta, col = 'blue')
grid()

plot(
    x
  , fprime(x)
  , type = "l"
  , main = bquote(frac(d,dx)~f(x))
  , ylab = ""
  , xlab = ""
)
points(x, bmatD1 %*% theta, col = 'blue')
grid()

plot(
    x
  , fdoubleprime(x)
  , type = "l"
  , main = bquote(frac(d^2,dx^2)~f(x))
  , ylab = ""
  , xlab = ""
)
points(x, bmatD2 %*% theta, col = 'blue')
grid()

par(old_par)

################################################################################
# Example 2
set.seed(42)

xvec &lt;- seq(0.1, 9.9, length = 1000)
iknots &lt;- sort(runif(rpois(1, 3), 1, 9))
bknots &lt;- c(0, 10)

# basis matrix and the first and second derivatives thereof, for cubic
# (order = 4) b-splines
bmat  &lt;- bsplines(xvec, iknots, bknots = bknots)
bmat1 &lt;- bsplineD(xvec, iknots, bknots = bknots, derivative = 1)
bmat2 &lt;- bsplineD(xvec, iknots, bknots = bknots, derivative = 2)

# control polygon ordinates
theta &lt;- runif(length(iknots) + 4L, -5, 5)

# plot data
plot_data &lt;-
  data.frame(
      Spline            = as.numeric(bmat %*% theta)
    , First_Derivative  = as.numeric(bmat1 %*% theta)
    , Second_Derivative = as.numeric(bmat2 %*% theta)
  )
plot_data &lt;- stack(plot_data)
plot_data &lt;- cbind(plot_data, data.frame(x = xvec))

ggplot2::ggplot(plot_data) +
ggplot2::theme_bw() +
ggplot2::aes(x = x, y = values, color = ind) +
ggplot2::geom_line() +
ggplot2::geom_hline(yintercept = 0) +
ggplot2::geom_vline(xintercept = iknots, linetype = 3)

</code></pre>

<hr>
<h2 id='bsplines'>B-Splines</h2><span id='topic+bsplines'></span>

<h3>Description</h3>

<p>An implementation of Carl de Boor's recursive algorithm for building
B-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsplines(x, iknots = NULL, df = NULL, bknots = range(x), order = 4L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsplines_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="bsplines_+3A_iknots">iknots</code></td>
<td>
<p>internal knots</p>
</td></tr>
<tr><td><code id="bsplines_+3A_df">df</code></td>
<td>
<p>degrees of freedom: sum of the order and internal knots.  Ignored
if <code>iknots</code> is specified.</p>
</td></tr>
<tr><td><code id="bsplines_+3A_bknots">bknots</code></td>
<td>
<p>boundary knot locations, defaults to <code>range(x)</code>.</p>
</td></tr>
<tr><td><code id="bsplines_+3A_order">order</code></td>
<td>
<p>order of the piecewise polynomials, defaults to 4L.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several differences between this function and
<code><a href="splines.html#topic+bs">bs</a></code>.
</p>
<p>The most important difference is how the two methods treat the right-hand end
of the support.  <code><a href="splines.html#topic+bs">bs</a></code> uses a pivot method to allow for
extrapolation and thus returns a basis matrix where non-zero values exist on
the <code>max(Boundary.knots)</code> (<code><a href="splines.html#topic+bs">bs</a></code> version of
<code>bsplines</code>'s <code>bknots</code>).  <code>bsplines</code> use a strict definition of
the splines where the support is open on the right hand side, that is,
<code>bsplines</code> return right-continuous functions.
</p>
<p>Additionally, the attributes of the object returned by <code>bsplines</code> are
different from the attributes of the object returned by
<code><a href="splines.html#topic+bs">bs</a></code>. See the <code>vignette(topic = "cpr", package =
"cpr")</code> for a detailed comparison between the <code>bsplines</code> and
<code><a href="splines.html#topic+bs">bs</a></code> calls and notes about B-splines in general.
</p>


<h3>References</h3>

<p>C. de Boor, &quot;A practical guide to splines. Revised Edition,&quot; Springer, 2001.
</p>
<p>H. Prautzsch, W. Boehm, M. Paluszny, &quot;Bezier and B-spline Techniques,&quot;
Springer, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cpr_bs">plot.cpr_bs</a></code> for plotting the basis,
<code><a href="#topic+bsplineD">bsplineD</a></code> for building the basis matrices for the first and
second derivative of a B-spline.
</p>
<p>See <code><a href="#topic+update_bsplines">update_bsplines</a></code> for info on a tool for updating a
<code>cpr_bs</code> object.  This is a similar method to the
<code><a href="stats.html#topic+update">update</a></code> function from the <code>stats</code> package.
</p>
<p><code>vignette(topic = "cpr", package = "cpr")</code> for details on B-splines and
the control polygon reduction method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># build a vector of values to transform
xvec &lt;- seq(-3, 4.9999, length = 100)

# cubic b-spline
bmat &lt;- bsplines(xvec, iknots = c(-2, 0, 1.2, 1.2, 3.0), bknots = c(-3, 5))
bmat

# plot the splines
plot(bmat)                # each spline will be colored by default
plot(bmat, color = FALSE) # black and white plot
plot(bmat, color = FALSE) + ggplot2::aes(linetype = spline) # add a linetype

# Axes
# The x-axis, by default, show the knot locations.  Other options are numeric
# values, and/or to use a second x-axis

plot(bmat, show_xi = TRUE,  show_x = FALSE) # default, knot, symbols, on lower
                                            # axis

plot(bmat, show_xi = FALSE, show_x = TRUE)  # Numeric value for the knot
                                            # locations

plot(bmat, show_xi = TRUE,  show_x = TRUE)  # symbols on bottom, numbers on top

# quadratic splines
bmat &lt;- bsplines(xvec, iknots = c(-2, 0, 1.2, 1.2, 3.0), order = 3L)
bmat
plot(bmat) + ggplot2::ggtitle("Quadratic B-splines")

</code></pre>

<hr>
<h2 id='btensor'>btensor</h2><span id='topic+btensor'></span>

<h3>Description</h3>

<p>Tensor products of B-splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btensor(x, df = NULL, iknots = NULL, bknots, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="btensor_+3A_x">x</code></td>
<td>
<p>a list of variables to build B-spline transforms of.  The tensor
product of these B-splines will be returned.</p>
</td></tr>
<tr><td><code id="btensor_+3A_df">df</code></td>
<td>
<p>degrees of freedom.  A list of the degrees of freedom for each
marginal.</p>
</td></tr>
<tr><td><code id="btensor_+3A_iknots">iknots</code></td>
<td>
<p>a list of internal knots for each x.  If omitted, the default
is to place no internal knots for all x.  If specified, the list needs to
contain the internal knots for all x.  If <code>df</code> and <code>iknots</code> are
both given, the <code>df</code> will take precedence.</p>
</td></tr>
<tr><td><code id="btensor_+3A_bknots">bknots</code></td>
<td>
<p>a list of boundary knots for each x.  As with the iknots, if
omitted the default will be to use the range of each x.  If specified, the
use must specify the bknots for each x.</p>
</td></tr>
<tr><td><code id="btensor_+3A_order">order</code></td>
<td>
<p>a list of the order for each x; defaults to 4L for all x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return form this function is the tensor product of the B-splines
transformations for the given variables.  Say we have variables X, Y, and Z
to build the tensor product of.  The columns of the returned matrix
correspond to the column products of the three B-splines:
</p>
<p>x1y1z1 x2y1z1 x3y1z1 x4y1z1 x1y2z1 x2y2z1 ... x4y4z4
</p>
<p>for three fourth order B-splines with no internal knots.  The columns of X
cycle the quickest, followed by Y, and then Z.  This would be the same result
as
<code> model.matrix( ~ bsplines(X) : bsplines(Y) : bsplines(Z) + 0) </code>.
</p>
<p>See <code>vignette(topic = "cnr", package = "cpr")</code> for more details.
</p>


<h3>Value</h3>

<p>A matrix with a class <code>cpr_bt</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsplines">bsplines</a></code>, <code>vignette(topic = "cnr", package = "cpr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tp &lt;- with(mtcars,
           btensor(x = list(d = disp, h = hp, m = mpg),
                   iknots = list(numeric(0), c(100, 150), numeric(0)))
           )
tp

</code></pre>

<hr>
<h2 id='build_tensor'>Build Tensor</h2><span id='topic+build_tensor'></span>

<h3>Description</h3>

<p>Tensor products of Matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_tensor(x = NULL, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_tensor_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="build_tensor_+3A_y">y</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="build_tensor_+3A_...">...</code></td>
<td>
<p>additional numeric matrices to build the tensor product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>
<p>A matrix
</p>


<h3>See Also</h3>

<p><code>vignette("cnr", package = "cpr")</code> for details on tensor products.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- matrix(1:4, nrow = 10, ncol = 20)
B &lt;- matrix(1:6, nrow = 10, ncol = 6)

# Two ways of building the same tensor product
tensor1 &lt;- build_tensor(A, B)
tensor2 &lt;- do.call(build_tensor, list(A, B))
all.equal(tensor1, tensor2)

# a three matrix tensor product
tensor3 &lt;- build_tensor(A, B, B)
str(tensor3)

</code></pre>

<hr>
<h2 id='cn'>Control Nets</h2><span id='topic+cn'></span><span id='topic+cn.cpr_bt'></span><span id='topic+cn.formula'></span>

<h3>Description</h3>

<p>Generate the control net for a uni-variable B-spline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cn(x, ...)

## S3 method for class 'cpr_bt'
cn(x, theta, ...)

## S3 method for class 'formula'
cn(
  formula,
  data,
  method = stats::lm,
  method.args = list(),
  keep_fit = TRUE,
  check_rank = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cn_+3A_x">x</code></td>
<td>
<p>a <code>cpr_bt</code> object</p>
</td></tr>
<tr><td><code id="cn_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
<tr><td><code id="cn_+3A_theta">theta</code></td>
<td>
<p>a vector of (regression) coefficients, the ordinates of the
control net.</p>
</td></tr>
<tr><td><code id="cn_+3A_formula">formula</code></td>
<td>
<p>a formula that is appropriate for regression method being used.</p>
</td></tr>
<tr><td><code id="cn_+3A_data">data</code></td>
<td>
<p>a required <code>data.frame</code></p>
</td></tr>
<tr><td><code id="cn_+3A_method">method</code></td>
<td>
<p>the regression method such as <code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>, etc.</p>
</td></tr>
<tr><td><code id="cn_+3A_method.args">method.args</code></td>
<td>
<p>a list of additional arguments to pass to the regression
method.</p>
</td></tr>
<tr><td><code id="cn_+3A_keep_fit">keep_fit</code></td>
<td>
<p>(logical, defaults to <code>FALSE</code>).  If <code>TRUE</code> the
regression model fit is retained and returned in the the <code>fit</code> element.
If <code>FALSE</code> the regression model is not saved and the <code>fit</code> element
will be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="cn_+3A_check_rank">check_rank</code></td>
<td>
<p>(logical, defaults to <code>TRUE</code>) if TRUE check that the
design matrix is full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cn</code> generates the control net for the given B-spline function.  There
are several methods for building a control net.
</p>


<h3>Value</h3>

<p>a <code>cpr_cn</code> object.  This is a list with the following elements.
Some of the elements are omitted when the using the <code>cn.cpr_bt</code> method.
</p>

<dl>
<dt>cn</dt><dd><p>the control net, <code>data.frame</code> with each row defining a vertex
of the control net</p>
</dd>
<dt>bspline_list</dt><dd><p>A list of the marginal B-splines</p>
</dd>
<dt>call</dt><dd><p>the call</p>
</dd>
<dt>keep_fit</dt><dd><p>logical, indicates if the regression models was retained</p>
</dd>
<dt>fit</dt><dd><p>if <code>isTRUE(keep_fit)</code> then the regression model is here,
else <code>NA</code>.</p>
</dd>
<dt>coefficients</dt><dd><p>regression coefficients, only the fixed effects if a
mixed effects model was used.</p>
</dd>
<dt>vcov</dt><dd><p>The variance-covariance matrix for the <code>coefficients</code></p>
</dd>
<dt>loglik</dt><dd><p>The log-likelihood for the regression model</p>
</dd>
<dt>rse</dt><dd><p>the residual standard error for the regression models</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+summary.cpr_cn">summary.cpr_cn</a></code>, <code><a href="#topic+cnr">cnr</a></code>,
<code><a href="#topic+plot.cpr_cn">plot.cpr_cn</a></code> for plotting control nets
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
acn &lt;- cn(log10(pdg) ~
              btensor(   x     = list(day, age)
                      , df     = list(30, 4)
                      , bknots = list(c(-1, 1), c(44, 53))
              )
           , data = spdg)
str(acn, max.level = 1)

</code></pre>

<hr>
<h2 id='cnr'>Control Net Reduction</h2><span id='topic+cnr'></span>

<h3>Description</h3>

<p>Run the Control Net Reduction Algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnr(x, margin, n_polycoef = 20L, progress = c("cnr", "influence", "none"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cnr_+3A_x">x</code></td>
<td>
<p>a <code>cnr_cn</code> object</p>
</td></tr>
<tr><td><code id="cnr_+3A_margin">margin</code></td>
<td>
<p>the margins to apply the CNR algorithm to.  Passed to
<code><a href="#topic+influence_weights">influence_weights</a></code>.</p>
</td></tr>
<tr><td><code id="cnr_+3A_n_polycoef">n_polycoef</code></td>
<td>
<p>the number of polynomial coefficients to use when assessing
the influence of each internal knot.</p>
</td></tr>
<tr><td><code id="cnr_+3A_progress">progress</code></td>
<td>
<p>controls the level of progress messaging.</p>
</td></tr>
<tr><td><code id="cnr_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cnr</code> runs the control net reduction algorithm.
</p>
<p><code>keep</code> will keep the regression fit as part of the <code>cnr\_cp</code> object
for models with up to and including keep fits.  For example, if <code>keep =
10</code> then the resulting <code>cnr\_cnr</code> object will have the regression fit
stored in the first <code>keep + 1</code> (zero internal knots, one internal knot,
..., <code>keep</code> internal knots) <code>cnr\_cp</code> objects in the list.  The
limit on the number of stored regression fits is to keep memory usage down.
</p>


<h3>Value</h3>

<p>A <code>cpr_cnr</code> object.  This is a list of <code>cpr_cn</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cn">cn</a></code> for defining a control net,
<code><a href="#topic+influence_weights">influence_weights</a></code> for finding the influence of the internal
knots, <code><a href="#topic+cpr">cpr</a></code> for the uni-variable version, Control Polygon
Reduction.
</p>
<p><code>vignette(topic = "cnr", package = "cpr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
acn &lt;- cn(log10(pdg) ~ btensor(list(day, age)
                               , df = list(10, 8)
                               , bknots = list(c(-1, 1), c(44, 53)))
         , data = spdg)
cnr0 &lt;- cnr(acn)
cnr0
summary(cnr0)
plot(cnr0)

</code></pre>

<hr>
<h2 id='coef_vcov'>Extract Regression Coefficients for B-Splines and Tensor Products of B-splines</h2><span id='topic+coef_vcov'></span>

<h3>Description</h3>

<p>An S3 method for extracting the regression coefficients of the
<code>bsplines</code> and <code>btensor</code> terms.  By Default this uses
<code>stats::coef</code> to extract all the regression coefficients.  A specific
method for <code>lmerMod</code> objects has been provided.  If you are using a
regression method which <code>stats::coef</code> will not return the regression
coefficients, you'll need to define an S3 method for <code>stats::coef</code> to do
so.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_vcov(fit, theta_idx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_vcov_+3A_fit">fit</code></td>
<td>
<p>a regression model fit</p>
</td></tr>
<tr><td><code id="coef_vcov_+3A_theta_idx">theta_idx</code></td>
<td>
<p>numeric index for the theta related coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are called in the <code><a href="#topic+cp">cp</a></code> and
<code><a href="#topic+cn">cn</a></code> calls.
</p>


<h3>Value</h3>

<p>A list with four elements
</p>

<dl>
<dt>theta</dt><dd><p>theta regression coefficients</p>
</dd>
<dt>coef</dt><dd><p>all regression coefficients</p>
</dd>
<dt>vcov_theta</dt><dd><p>subsection of variance-covariance matrix pertaining to the theta values</p>
</dd>
<dt>vcov</dt><dd><p>full variance-covariance matrix</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> <code><a href="#topic+cp">cp</a></code> <code><a href="#topic+cn">cn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cp0 &lt;- cp(log10(pdg) ~ bsplines(day, df = 6, bknots = c(-1, 1)) + age + ttm, data = spdg)
cv &lt;- cpr:::coef_vcov(cp0$fit)

summary(cv)

</code></pre>

<hr>
<h2 id='cp'>Control Polygons</h2><span id='topic+cp'></span><span id='topic+cp.cpr_bs'></span><span id='topic+cp.formula'></span>

<h3>Description</h3>

<p>Generate the control polygon for a uni-variable B-spline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp(x, ...)

## S3 method for class 'cpr_bs'
cp(x, theta, ...)

## S3 method for class 'formula'
cp(
  formula,
  data,
  method = stats::lm,
  method.args = list(),
  keep_fit = TRUE,
  check_rank = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cp_+3A_x">x</code></td>
<td>
<p>a <code>cpr_bs</code> object</p>
</td></tr>
<tr><td><code id="cp_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
<tr><td><code id="cp_+3A_theta">theta</code></td>
<td>
<p>a vector of (regression) coefficients, the ordinates of the control polygon.</p>
</td></tr>
<tr><td><code id="cp_+3A_formula">formula</code></td>
<td>
<p>a formula that is appropriate for regression method being used.</p>
</td></tr>
<tr><td><code id="cp_+3A_data">data</code></td>
<td>
<p>a required <code>data.frame</code></p>
</td></tr>
<tr><td><code id="cp_+3A_method">method</code></td>
<td>
<p>the regression method such as <code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="lme4.html#topic+lmer">lmer</a></code>, etc.</p>
</td></tr>
<tr><td><code id="cp_+3A_method.args">method.args</code></td>
<td>
<p>a list of additional arguments to pass to the regression
method.</p>
</td></tr>
<tr><td><code id="cp_+3A_keep_fit">keep_fit</code></td>
<td>
<p>(logical, default value is <code>TRUE</code>).  If <code>TRUE</code> the
regression model fit is retained and returned in as the <code>fit</code> element.
If <code>FALSE</code> the <code>fit</code> element with be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="cp_+3A_check_rank">check_rank</code></td>
<td>
<p>(logical, defaults to <code>TRUE</code>) if <code>TRUE</code> check
that the design matrix is full rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cp</code> generates the control polygon for the given B-spline function.
</p>


<h3>Value</h3>

<p>a <code>cpr_cp</code> object, this is a list with the element <code>cp</code>, a
data.frame reporting the x and y coordinates of the control polygon.
Additional elements include the knot sequence, polynomial order, and other
meta data regarding the construction of the control polygon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Support
xvec &lt;- runif(n = 500, min = 0, max = 6)
bknots &lt;- c(0, 6)

# Define the basis matrix
bmat1 &lt;- bsplines(x = xvec, iknots = c(1, 1.5, 2.3, 4, 4.5), bknots = bknots)
bmat2 &lt;- bsplines(x = xvec, bknots = bknots)

# Define the control vertices ordinates
theta1 &lt;- c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5)
theta2 &lt;- c(1, 3.4, -2, 1.7)

# build the two control polygons
cp1 &lt;- cp(bmat1, theta1)
cp2 &lt;- cp(bmat2, theta2)

# black and white plot
plot(cp1)
plot(cp1, show_spline = TRUE)

# multiple control polygons
plot(cp1, cp2, show_spline = TRUE)
plot(cp1, cp2, color = TRUE)
plot(cp1, cp2, show_spline = TRUE, color = TRUE)

# via formula
DF  &lt;- data.frame(x = xvec, y = sin((xvec - 2)/pi) + 1.4 * cos(xvec/pi))
cp3 &lt;- cp(y ~ bsplines(x, bknots = bknots), data = DF)

# plot the spline and target data.
plot(cp3, show_cp = FALSE, show_spline = TRUE) +
  ggplot2::geom_line(mapping = ggplot2::aes(x = x, y = y, color = "Target"),
                     data = DF, linetype = 2)

</code></pre>

<hr>
<h2 id='cp_diff'>Vertical Difference between two Control Polygons</h2><span id='topic+cp_diff'></span>

<h3>Description</h3>

<p>Vertical Difference between two Control Polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp_diff(cp1, cp2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cp_diff_+3A_cp1">cp1</code></td>
<td>
<p>a <code>cpr_cp</code> object</p>
</td></tr>
<tr><td><code id="cp_diff_+3A_cp2">cp2</code></td>
<td>
<p>a <code>cpr_cp</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vertical distance between the control vertices of cp1 to the
control polygon cp2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp">cp</a></code>, <code><a href="#topic+cp_value">cp_value</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xvec &lt;- runif(n = 500, min = 0, max = 6)

# Define the basis matrix
bmat1 &lt;- bsplines(x = xvec, iknots = c(1, 1.5, 2.3, 4, 4.5), bknots = c(0, 6))
bmat2 &lt;- bsplines(x = xvec, bknots = c(0, 6))

# Define the control vertices ordinates
theta1 &lt;- c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5)
theta2 &lt;- c(1, 3.4, -2, 1.7)

# build the two control polygons
cp1 &lt;- cp(bmat1, theta1)
cp2 &lt;- cp(bmat2, theta2)

cp_diff(cp1, cp2)

df &lt;- data.frame(x = cp1$cp$xi_star,
                 y = cp1$cp$theta,
                 yend = cp1$cp$theta + cp_diff(cp1, cp2))


plot(cp1, cp2) +
ggplot2::geom_segment(data = df
  , mapping = ggplot2::aes(x = x, xend = x, y = y, yend = yend)
  , color = "red"
  , inherit.aes = FALSE)

</code></pre>

<hr>
<h2 id='cp_value'>Control Polygon Value</h2><span id='topic+cp_value'></span>

<h3>Description</h3>

<p>Find the y value of a Control Polygon for a given x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cp_value(obj, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cp_value_+3A_obj">obj</code></td>
<td>
<p>a cpr_cp object or <code>data.frame</code> where the first column is the
abscissa and the second column is the ordinate for the control polygon
vertices.</p>
</td></tr>
<tr><td><code id="cp_value_+3A_x">x</code></td>
<td>
<p>abscissa at which to determine the ordinate on control polygon cp</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cp_value</code> returns the ordinate on the control polygon line segment for
the abscissa <code>x</code> given.  <code>x</code> could be a control vertex or on a
line segment defined by two control vertices of the control polygon
provided.
</p>
<p><code>cp_diff</code> returns the vertical distance between the control
vertices of cp1 to the control polygon cp2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp">cp</a></code>, <code><a href="#topic+cp_diff">cp_diff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xvec &lt;- seq(0, 6, length = 500)

# Define the basis matrix
bmat1 &lt;- bsplines(x = xvec, iknots = c(1, 1.5, 2.3, 4, 4.5))
bmat2 &lt;- bsplines(x = xvec)

# Define the control vertices ordinates
theta1 &lt;- c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5)
theta2 &lt;- c(1, 3.4, -2, 1.7)

# build the two control polygons
cp1 &lt;- cp(bmat1, theta1)
cp2 &lt;- cp(bmat2, theta2)

x &lt;- c(0.2, 0.8, 1.3, 1.73, 2.15, 3.14, 4.22, 4.88, 5.3, 5.9)
cp_value(cp1, x = x)

df &lt;- data.frame(x = x, y = cp_value(cp1, x = x))

plot(cp1, show_x = TRUE, show_spline = TRUE) +
ggplot2::geom_point(data = df
  , mapping = ggplot2::aes(x = x, y = y)
  , color = "red"
  , shape = 4
  , size = 3
  , inherit.aes = FALSE)

</code></pre>

<hr>
<h2 id='cpr'>Control Polygon Reduction</h2><span id='topic+cpr'></span>

<h3>Description</h3>

<p>Run the Control Polygon Reduction Algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpr(x, progress = c("cpr", "influence", "none"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpr_+3A_x">x</code></td>
<td>
<p>a <code>cpr_cp</code> object</p>
</td></tr>
<tr><td><code id="cpr_+3A_progress">progress</code></td>
<td>
<p>controls the level of progress messaging.  See Details.</p>
</td></tr>
<tr><td><code id="cpr_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cpr</code> runs the control polygon reduction algorithm.
</p>
<p>The algorithm is generally speaking fast, but can take a long time to run if
the number of interior knots of initial control polygon is high.  To help
track the progress of the execution you can have <code>progress = "cpr"</code>
which will show a progress bar incremented for each iteration of the CPR
algorithm.  <code>progress = "influence"</code> will use a combination of messages
and progress bars to report on each step in assessing the influence of all the
internal knots for each iteration of the CPR algorithm.  See
<code><a href="#topic+influence_of_iknots">influence_of_iknots</a></code> for more details.
</p>


<h3>Value</h3>

<p>a list of <code>cpr_cp</code> objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+influence_of_iknots">influence_of_iknots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# Example 1: find a model for log10(pdg) = f(day) from the spdg data set

# need the lme4 package to fit a mixed effect model
require(lme4)

# construct the initial control polygon.  Forth order spline with fifty
# internal knots.  Remember degrees of freedom equal the polynomial order
# plus number of internal knots.
init_cp &lt;- cp(log10(pdg) ~ bsplines(day, df = 24, bknots = c(-1, 1)) + (1|id),
              data = spdg, method = lme4::lmer)
cpr_run &lt;- cpr(init_cp)
plot(cpr_run, color = TRUE)

s &lt;- summary(cpr_run)
s
plot(s, type = "rse")

# preferable model is in index 5 by eye
preferable_cp &lt;- cpr_run[["cps"]][[5]]


#############################################################################
# Example 2: logistic regression
# simulate a binary response Pr(y = 1 | x) = p(x)
p &lt;- function(x) { 0.65 * sin(x * 0.70) + 0.3 * cos(x * 4.2) }

set.seed(42)
x &lt;- runif(2500, 0.00, 4.5)
sim_data &lt;- data.frame(x = x, y = rbinom(2500, 1, p(x)))

# Define the initial control polygon
init_cp &lt;- cp(formula = y ~ bsplines(x, df = 24, bknots = c(0, 4.5)),
              data    = sim_data,
              method  = glm,
              method.args = list(family  = binomial())
              )

# run CPR
cpr_run &lt;- cpr(init_cp)

# preferable model is in index 6
s &lt;- summary(cpr_run)
plot(s, color = TRUE, type = "rse")

plot(
    cpr_run
  , color = TRUE
  , from = 5
  , to = 7
  , show_spline = TRUE
  , show_cp = FALSE
  )


# plot the fitted spline and the true p(x)
sim_data$pred_select_p &lt;- plogis(predict(cpr_run[[7]], newdata = sim_data))
ggplot2::ggplot(sim_data) +
ggplot2::theme_bw() +
ggplot2::aes(x = x) +
ggplot2::geom_point(mapping = ggplot2::aes(y = y), alpha = 0.1) +
ggplot2::geom_line(
    mapping = ggplot2::aes(y = pred_select_p, color = "pred_select_p")
  ) +
ggplot2::stat_function(fun = p, mapping = ggplot2::aes(color = 'p(x)'))

# compare to gam and a binned average
sim_data$x2 &lt;- round(sim_data$x, digits = 1)
bin_average &lt;-
  lapply(split(sim_data, sim_data$x2), function(x) {
           data.frame(x = x$x2[1], y = mean(x$y))
         })
bin_average &lt;- do.call(rbind, bin_average)

ggplot2::ggplot(sim_data) +
ggplot2::theme_bw() +
ggplot2::aes(x = x) +
ggplot2::stat_function(fun = p, mapping = ggplot2::aes(color = 'p(x)')) +
ggplot2::geom_line(
    mapping = ggplot2::aes(y = pred_select_p, color = "pred_select_p")
  ) +
ggplot2::stat_smooth(mapping = ggplot2::aes(y = y, color = "gam"),
                     method = "gam",
                     formula = y ~ s(x, bs = "cs"),
                     se = FALSE,
                     n = 1000) +
ggplot2::geom_line(data = bin_average
                   , mapping = ggplot2::aes(y = y, color = "bin_average"))


</code></pre>

<hr>
<h2 id='cpr-defunct'>Defunct Functions</h2><span id='topic+cpr-defunct'></span><span id='topic+refine_ordinate'></span><span id='topic+coarsen_ordinate'></span><span id='topic+hat_ordinate'></span><span id='topic+insertion_matrix'></span><span id='topic+wiegh_iknots'></span><span id='topic+influence_of'></span><span id='topic+influence_weights'></span>

<h3>Description</h3>

<p>A major refactor of the package between v0.3.0 and v.0.4.0 took place and
many functions were made defunct.  The refactor was so extensive that moving
the functions to deprecated was not a viable option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refine_ordinate(...)

coarsen_ordinate(...)

hat_ordinate(...)

insertion_matrix(...)

wiegh_iknots(...)

influence_of(...)

influence_weights(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cpr-defunct_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
</table>

<hr>
<h2 id='generate_cp_formula_data'>Generate Control Polygon Formula and Data</h2><span id='topic+generate_cp_formula_data'></span>

<h3>Description</h3>

<p>Construct a <code>data.frame</code> and <code>formula</code> to be passed to the
regression modeling tool to generate a control polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_cp_formula_data(f, data, formula_only = FALSE, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_cp_formula_data_+3A_f">f</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="generate_cp_formula_data_+3A_data">data</code></td>
<td>
<p>the data set containing the variables in the formula</p>
</td></tr>
<tr><td><code id="generate_cp_formula_data_+3A_formula_only">formula_only</code></td>
<td>
<p>if TRUE then only generate the formula, when FALSE, then
generate and assign the data set too.</p>
</td></tr>
<tr><td><code id="generate_cp_formula_data_+3A_envir">envir</code></td>
<td>
<p>the environment the generated formula and data set will be
assigned too.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is expected to be called from within the <code>cp</code>
function and is not expected to be called by the end user directly.
</p>
<p><code>generate_cp_data</code> exists because of the need to build what could be
considered a varying means model.  <code>y ~ bsplines(x1) + x2</code> will generate
a rank deficient model matrix&mdash;the rows of the bspline basis matrix sum to
one with is perfectly collinear with the implicit intercept term.  Specifying
a formula <code>y ~ bsplines(x1) + x2 - 1</code> would work if <code>x2</code> is a
continuous variable.  If, however, <code>x2</code> is a factor, or coerced to a
factor, then the model matrix will again be rank deficient as a column for
all levels of the factor will be generated.  We need to replace the intercept
column of the model matrix with the bspline.  This also needs to be done for
a variety of possible model calls, <code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="lme4.html#topic+lmer">lmer</a></code>, etc.
</p>
<p>By returning an explicit <code>formula</code> and <code>data.frame</code> for use in the
fit, we hope to reduce memory use and increase the speed of the cpr method.
</p>
<p>We need to know the <code>method</code> and <code>method.args</code> to build the data
set.  For example, for a <code><a href="geepack.html#topic+geeglm">geeglm</a></code> the <code>id</code> variable
is needed in the data set and is part of the <code>method.args</code> not the
<code>formula</code>.
</p>


<h3>Value</h3>

<p>TRUE, invisibly.  The return isn't needed as the assignment happens
within the call.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data &lt;-
   data.frame(
                x1 = runif(20)
              , x2 = runif(20)
              , x3 = runif(20)
              , xf = factor(rep(c("l1","l2","l3","l4"), each = 5))
              , xc = rep(c("c1","c2","c3","c4", "c5"), each = 4)
              , pid = gl(n = 2, k = 10)
              , pid2 = rep(1:2, each = 10)
   )

 f &lt;- ~ bsplines(x1, bknots = c(0,1)) + x2 + xf + xc + (x3 | pid2)

 cpr:::generate_cp_formula_data(f, data)

 stopifnot(isTRUE(
   all.equal(
             f_for_use
             ,
             . ~ bsplines(x1, bknots = c(0, 1)) + x2 + (x3 | pid2) + xfl2 +
                 xfl3 + xfl4 + xcc2 + xcc3 + xcc4 + xcc5 - 1
             )
 ))

 stopifnot(isTRUE(identical(
   names(data_for_use)
   ,
   c("x1", "x2", "x3", "pid", "pid2", "xfl2", "xfl3", "xfl4"
     , "xcc2" , "xcc3", "xcc4", "xcc5")
 )))

</code></pre>

<hr>
<h2 id='get_spline'>Get the Control Polygon and the Spline Function</h2><span id='topic+get_spline'></span>

<h3>Description</h3>

<p>Generate <code>data.frame</code>s for interpolating and plotting a spline
function, given a <code>cpr_cp</code> or <code>cpr_cn</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_spline(x, margin = 1, at, n = 100, se = FALSE, derivative = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_spline_+3A_x">x</code></td>
<td>
<p>a <code>cpr_cp</code> or <code>cpr_cn</code> object.</p>
</td></tr>
<tr><td><code id="get_spline_+3A_margin">margin</code></td>
<td>
<p>an integer identifying the marginal of the control net to slice
along.  Only used when working <code>x</code> is a <code>cpr_cn</code> object.</p>
</td></tr>
<tr><td><code id="get_spline_+3A_at">at</code></td>
<td>
<p>point value for marginals not defined in the <code>margin</code>.  Only
used when <code>x</code> is a <code>cpr_cn</code> object.  Expected input is a list of
length <code>length(attr(x, "bspline_list"))</code>.  Entries for elements
<code>marginal</code> are ignored.  If omitted, the midpoint between the boundary
knots for each marginal is used.</p>
</td></tr>
<tr><td><code id="get_spline_+3A_n">n</code></td>
<td>
<p>the length of sequence to use for interpolating the spline function.</p>
</td></tr>
<tr><td><code id="get_spline_+3A_se">se</code></td>
<td>
<p>if <code>TRUE</code> return the estimated standard error for the spline
or the derivative.</p>
</td></tr>
<tr><td><code id="get_spline_+3A_derivative">derivative</code></td>
<td>
<p>A value of 0 (default) returns the spline, 1 the first
derivative, 2 the second derivative.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A control polygon, <code>cpr\_cp</code> object, has a spline function f(x).
<code>get_spline</code> returns a list of two <code>data.frame</code>.  The <code>cp</code>
element is a <code>data.frame</code> with the (x, y) coordinates control points and
the <code>spline</code> element is a <code>data.frame</code> with <code>n</code> rows for
interpolating f(x).
</p>
<p>For a control net, <code>cpr\_cn</code> object, the return is the same as for a
<code>cpr\_cp</code> object, but conceptually different.  Where a <code>cpr\_cp</code>
objects have a uni-variable spline function, <code>cpr\_cn</code> have
multi-variable spline surfaces.  <code>get_spline</code> returns a &quot;slice&quot; of the
higher dimensional object.  For example, consider a three-dimensional control
net defined on the unit cube with marginals <code>x1</code>, <code>x2</code>, and
<code>x3</code>.  The implied spline surface is the function f(x1, x2, x3).
<code>get_spline(x, margin = 2, at = list(0.2, NA, 0.5))</code> would
return the control polygon and spline surface for f(0.2, x, 0.5).
</p>
<p>See <code><a href="#topic+get_surface">get_surface</a></code> for taking a two-dimensional slice of a
three-plus dimensional control net, or, for generating a useful data set for
plotting the surface of a two-dimensional control net.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> <code>n</code> rows and two columns <code>x</code> and
<code>y</code>, the values for the spline.  A third column with the standard error
is returned if requested.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_surface">get_surface</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spdg, package = "cpr")

## Extract the control polygon and spline for plotting.  We'll use base R
## graphics for this example.
a_cp &lt;- cp(pdg ~ bsplines(day, df = 10, bknots = c(-1, 1)), data = spdg)

spline &lt;- get_spline(a_cp)
plot(spline$x, spline$y, type = "l")

# compare to the plot.cpr_cp method
plot(a_cp, show_spline = TRUE)

# derivatives
f0 &lt;- function(x) {
  #(x + 2) * (x - 1) * (x - 3)
  x^3 - 2 * x^2 - 5 * x + 6
}
f1 &lt;- function(x) {
  3 * x^2 - 4 * x - 5
}
f2 &lt;- function(x) {
  6 * x - 4
}

x &lt;- sort(runif(n = 100, min = -3, max = 5))
bknots = c(-3, 5)
bmat &lt;- bsplines(x, bknots = bknots)
theta &lt;- coef(lm(f0(x) ~ bsplines(x, bknots = bknots) + 0) )

cp0 &lt;- cp(bmat, theta)
spline0 &lt;- get_spline(cp0, derivative = 0)
spline1 &lt;- get_spline(cp0, derivative = 1)
spline2 &lt;- get_spline(cp0, derivative = 2)

old_par &lt;- par()

par(mfrow = c(1, 3))
plot(x, f0(x), type = "l", main = "spline")
points(spline0$x, spline0$y, pch = 2, col = 'blue')

plot(x, f1(x), type = "l", main = "first derivative")
points(spline1$x, spline1$y, pch = 2, col = 'blue')

plot(x, f2(x), type = "l", main = "second derivative")
points(spline2$x, spline2$y, pch = 2, col = 'blue')

par(old_par)

</code></pre>

<hr>
<h2 id='get_surface'>Get Surface</h2><span id='topic+get_surface'></span>

<h3>Description</h3>

<p>Get Two-Dimensional Control Net and Surface from n-dimensional Control Nets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_surface(x, margin = 1:2, at, n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_surface_+3A_x">x</code></td>
<td>
<p>a <code>cpr_cn</code> object</p>
</td></tr>
<tr><td><code id="get_surface_+3A_margin">margin</code></td>
<td>
<p>an integer identifying the marginal of the control net to slice
along.  Only used when working <code>x</code> is a <code>cpr_cn</code> object.</p>
</td></tr>
<tr><td><code id="get_surface_+3A_at">at</code></td>
<td>
<p>point value for marginals not defined in the <code>margin</code>.  Only
used when <code>x</code> is a <code>cpr_cn</code> object.  Expected input is a list of
length <code>length(attr(x, "bspline_list"))</code>.  Entries for elements
<code>marginal</code> are ignored.  If omitted, the midpoint between the boundary
knots for each marginal is used.</p>
</td></tr>
<tr><td><code id="get_surface_+3A_n">n</code></td>
<td>
<p>the length of sequence to use for interpolating the spline function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two elements
</p>

<dl>
<dt>cn</dt><dd><p>the control net</p>
</dd>
<dt>surface</dt><dd><p>a data.frame with three columns to define the surface</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+get_spline">get_spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Extract the control net and surface from a cpr_cn object.
a_cn &lt;- cn(log10(pdg) ~ btensor(list(day, age, ttm)
           , df = list(15, 3, 5)
           , bknots = list(c(-1, 1), c(45, 53), c(-9, -1))
           , order = list(3, 2, 3))
           , data = spdg)

cn_and_surface &lt;- get_surface(a_cn, n = 50)
str(cn_and_surface, max.level = 2)

old_par &lt;- par()
par(mfrow = c(1, 2))
with(cn_and_surface$cn,
     plot3D::persp3D(unique(Var1),
                     unique(Var2),
                     matrix(z,
                            nrow = length(unique(Var1)),
                            ncol = length(unique(Var2))),
                     main = "Control Net")
     )
with(cn_and_surface$surface,
     plot3D::persp3D(unique(Var1),
                     unique(Var2),
                     matrix(z,
                            nrow = length(unique(Var1)),
                            ncol = length(unique(Var2))),
                     main = "Surface")
     )

par(old_par)

</code></pre>

<hr>
<h2 id='iknots_or_df'>Internal Knots or Degrees of Freedom</h2><span id='topic+iknots_or_df'></span>

<h3>Description</h3>

<p>Check order, degrees of freedom (df) and iknots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iknots_or_df(x, iknots, df, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iknots_or_df_+3A_x">x</code></td>
<td>
<p>the support - a numeric vector</p>
</td></tr>
<tr><td><code id="iknots_or_df_+3A_iknots">iknots</code></td>
<td>
<p>internal knots - a numeric vector</p>
</td></tr>
<tr><td><code id="iknots_or_df_+3A_df">df</code></td>
<td>
<p>degrees of freedom - a numeric value of length 1</p>
</td></tr>
<tr><td><code id="iknots_or_df_+3A_order">order</code></td>
<td>
<p>polynomial order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function, not to be exported, and used in the calls for
<code><a href="#topic+bsplines">bsplines</a></code> and <code><a href="#topic+bsplineD">bsplineD</a></code>.
</p>
<p>Use <code>iknots</code> preferentially.  If iknots are not provided then return the
<code><a href="#topic+trimmed_quantile">trimmed_quantile</a></code> for the appropriate <code>df</code> and <code>order</code>
</p>


<h3>Value</h3>

<p>a numeric vector to use as the internal knots defining a B-spline.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsplines">bsplines</a></code>, <code><a href="#topic+bsplineD">bsplineD</a></code>,
<code><a href="#topic+trimmed_quantile">trimmed_quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
xvec &lt;- runif(600, min = 0, max = 3)

# return the iknots
cpr:::iknots_or_df(x = xvec, iknots = 1:2, df = NULL, order = NULL)

# return the iknots even when the df and order are provided
cpr:::iknots_or_df(x = xvec, iknots = 1:2, df = 56, order = 12)

# return numeric(0) when df &lt;= order (df &lt; order will also give a warning)
cpr:::iknots_or_df(x = xvec, iknots = NULL, df = 6, order = 6)

# return trimmed_quantile when df &gt; order
# probs = (df - order) / (df - order + 1)
cpr:::iknots_or_df(x = xvec, iknots = NULL, df = 10, order = 4)
cpr::trimmed_quantile(xvec, probs = 1:6 / 7)

</code></pre>

<hr>
<h2 id='influence_of_iknots'>Determine the influence of the internal knots of a control polygon</h2><span id='topic+influence_of_iknots'></span><span id='topic+influence_of_iknots.cpr_cn'></span>

<h3>Description</h3>

<p>Determine the influence of the internal knots of a control polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>influence_of_iknots(x, verbose = FALSE, ...)

## S3 method for class 'cpr_cn'
influence_of_iknots(
  x,
  verbose = FALSE,
  margin = seq_along(x$bspline_list),
  n_polycoef = 20L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="influence_of_iknots_+3A_x">x</code></td>
<td>
<p><code>cpr_cp</code> or <code>cpr_cn</code> object</p>
</td></tr>
<tr><td><code id="influence_of_iknots_+3A_verbose">verbose</code></td>
<td>
<p>print status messages</p>
</td></tr>
<tr><td><code id="influence_of_iknots_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
<tr><td><code id="influence_of_iknots_+3A_margin">margin</code></td>
<td>
<p>which margin(s) to consider the influence of iknots</p>
</td></tr>
<tr><td><code id="influence_of_iknots_+3A_n_polycoef">n_polycoef</code></td>
<td>
<p>number of polynomial coefficients to use when assessing the
influence of a iknot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>cpr_influence_of_iknots</code> object.  A list of six elements:
</p>

<dl>
<dt>original_cp</dt><dd></dd>
<dt>coarsened_cps</dt><dd></dd>
<dt>restored_cps</dt><dd></dd>
<dt>d</dt><dd></dd>
<dt>influence</dt><dd></dd>
<dt>chisq</dt><dd></dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(0 + 1/5000, 6 - 1/5000, length.out = 5000)
bmat &lt;- bsplines(x, iknots = c(1, 1.5, 2.3, 4, 4.5), bknots = c(0, 6))
theta &lt;- matrix(c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5), ncol = 1)
cp0 &lt;- cp(bmat, theta)

icp0 &lt;- influence_of_iknots(cp0)

plot(cp0, icp0$coarsened_cps[[1]], icp0$restored_cps[[1]], color = TRUE, show_spline = TRUE)
plot(cp0, icp0$restored_cps[[1]], color = TRUE, show_spline = TRUE)

plot(cp0, icp0$coarsened_cps[[2]], icp0$restored_cps[[2]], color = TRUE, show_spline = TRUE)
plot(cp0, icp0$restored_cps[[2]], color = TRUE, show_spline = TRUE)

plot(cp0, icp0$coarsened_cps[[3]], icp0$restored_cps[[3]], color = TRUE, show_spline = TRUE)
plot(cp0, icp0$restored_cps[[3]], color = TRUE, show_spline = TRUE)

plot(cp0, icp0$coarsened_cps[[4]], icp0$restored_cps[[4]], color = TRUE, show_spline = TRUE)
plot(cp0, icp0$restored_cps[[4]], color = TRUE, show_spline = TRUE)

plot(cp0, icp0$coarsened_cps[[5]], icp0$restored_cps[[5]], color = TRUE, show_spline = TRUE)
plot(cp0, icp0$restored_cps[[5]], color = TRUE, show_spline = TRUE)

# When the cp was defined by regression
df &lt;- data.frame(x = x, y = as.numeric(bmat %*% theta) + rnorm(5000, sd = 0.2))
cp1 &lt;- cp(y ~ bsplines(x, iknots = c(1, 1.5, 2.3, 3, 4, 4.5), bknots = c(0, 6)), data = df)
icp1 &lt;- influence_of_iknots(cp1)
icp1

</code></pre>

<hr>
<h2 id='insert_a_knot'>Insert a Knot into a Control Polygon</h2><span id='topic+insert_a_knot'></span>

<h3>Description</h3>

<p>Insert a knot into a control polygon without changing the spline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert_a_knot(x, xi_prime, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insert_a_knot_+3A_x">x</code></td>
<td>
<p>a <code>cpr_cp</code> object</p>
</td></tr>
<tr><td><code id="insert_a_knot_+3A_xi_prime">xi_prime</code></td>
<td>
<p>the value of the knot to insert</p>
</td></tr>
<tr><td><code id="insert_a_knot_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>cpr_cp</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(1e-5, 5.99999, length.out = 100)
bmat &lt;- bsplines(x, iknots = c(1, 1.5, 2.3, 4, 4.5), bknots = c(0, 6))
theta &lt;- matrix(c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5), ncol = 1)
cp0 &lt;- cp(bmat, theta)
cp1 &lt;- insert_a_knot(x = cp0, xi_prime = 3)
plot(cp0, cp1, color = TRUE, show_spline = TRUE)
</code></pre>

<hr>
<h2 id='knot_expr'>Knot Expressions</h2><span id='topic+knot_expr'></span>

<h3>Description</h3>

<p>Non-exported function used to build expressions for the knot sequences to be
labeled well on a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knot_expr(x, digits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knot_expr_+3A_x">x</code></td>
<td>
<p>a <code>cpr_cp</code> or <code>cpr_bs</code> object</p>
</td></tr>
<tr><td><code id="knot_expr_+3A_digits">digits</code></td>
<td>
<p>digits to the right of the decimal point to report</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bmat &lt;- bsplines(mtcars$hp, df = 8, bknots = c(50, 350))
ke &lt;- cpr:::knot_expr(bmat, digits = 1)
summary(ke)

plot(x = ke$breaks, y = rep(1, length(ke$breaks)), type = "n")
text(
       x = ke$breaks
     , y = rep(1, length(ke$breaks))
     , labels = parse(text = ke$xi_expr)
)

</code></pre>

<hr>
<h2 id='loglikelihood'>Determine the (quasi) Log Likelihood for a regression object.</h2><span id='topic+loglikelihood'></span>

<h3>Description</h3>

<p>Return, via <code><a href="stats.html#topic+logLik">logLik</a></code> or a custom S3 method, the (quasi)
log likelihood of a regression object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglikelihood_+3A_x">x</code></td>
<td>
<p>a regression fit object</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_...">...</code></td>
<td>
<p>passed through to <code><a href="stats.html#topic+logLik">logLik</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used by <code>cpr</code> and <code>cnr</code> to determine the
(quasi) log likelihood returned in the <code>cpr_cpr</code> and <code>cpr_cnr</code>
objects.
</p>
<p>Generally this function defaults to <code><a href="stats.html#topic+logLik">logLik</a></code>.  Therefore, if an S3
method for determining the (quasi) log likelihood exists in the workspace
everything should work.  If an S3 method does not exist you should define
one.
</p>
<p>See <code>methods(loglikelihood)</code> for a list of the provided methods.  The
default method uses <code><a href="stats.html#topic+logLik">logLik</a></code>.
</p>


<h3>Value</h3>

<p>the numeric value of the (quasi) log likelihood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpr">cpr</a></code> <code><a href="#topic+cnr">cnr</a></code> <code><a href="stats.html#topic+logLik">logLik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fit &lt;- lm(mpg ~ wt, data = mtcars)
stats::logLik(fit)
cpr:::loglikelihood(fit)

</code></pre>

<hr>
<h2 id='matrix_rank'>Rank of a Matrix</h2><span id='topic+matrix_rank'></span>

<h3>Description</h3>

<p>Determine the rank (number of linearly independent columns) of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_rank(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix_rank_+3A_x">x</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implementation via the Armadillo C++ linear algebra library.  The function
returns the rank of the matrix <code>x</code>.  The computation is based on the
singular value decomposition of the matrix; a std::runtime_error exception
will be thrown if the decomposition fails.  Any singular values less than
the tolerance are treated as zeros.  The tolerance is
<code>max(m, n) * max_sv * arma::datum::eps</code>, where <code>m</code> is the number
of rows of <code>x</code>, <code>n</code> is the number of columns of <code>x</code>,
<code>max_sv</code> is the maximal singular value of <code>x</code>, and
<code>arma::datum::eps</code> is the difference between 1 and the least value
greater than 1 that is representable.
</p>


<h3>Value</h3>

<p>the rank of the matrix as a numeric value.
</p>


<h3>References</h3>

<p>Conrad Sanderson and Ryan Curtin.  Armadillo: a template-based C++ library
for linear algebra.  Journal of Open Source Software, Vol. 1, pp. 26, 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Check the rank of a matrix
set.seed(42)
mat &lt;- matrix(rnorm(25000 * 120), nrow = 25000)
matrix_rank(mat) == ncol(mat)
matrix_rank(mat) == 120L

# A full rank B-spline basis
bmat &lt;- bsplines(seq(0, 1, length = 100), df = 15)
matrix_rank(bmat) == 15L

# A rank deficient B-spline basis
bmat &lt;- bsplines(seq(0, 1, length = 100), iknots = c(0.001, 0.002))
ncol(bmat) == 6L
matrix_rank(bmat) == 5L

</code></pre>

<hr>
<h2 id='newknots'>New Knots for CPs and CNs in CPR and CNR</h2><span id='topic+newknots'></span>

<h3>Description</h3>

<p>Non-exported function, <code>newknots</code> are used in the <code><a href="#topic+cpr">cpr</a></code> and
<code><a href="#topic+cnr">cnr</a></code> calls.  Used to create a new control polygon or control net
from with different internal knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newknots(form, nk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newknots_+3A_form">form</code></td>
<td>
<p>a <code>formula</code></p>
</td></tr>
<tr><td><code id="newknots_+3A_nk">nk</code></td>
<td>
<p>numeric vector, or a list of numeric vectors, to be used in a
<code><a href="#topic+bsplines">bsplines</a></code> or <code><a href="#topic+btensor">btensor</a></code> call, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Think of this function as an analogue to the <code><a href="stats.html#topic+stats">stats</a>{update}</code>
calls.  Where <code><a href="stats.html#topic+stats">stats</a>{update}</code> will modify a <code>call</code>, the
<code>newknots</code> will update just the <code>iknots</code> argument of a
<code>bsplines</code> or <code>btensor</code> call within the <code>formula</code> argument of
a <code><a href="#topic+cp">cp</a></code> or <code><a href="#topic+cn">cn</a></code> call.
</p>


<h3>Value</h3>

<p>Expected use is within the <code>cpr</code> and <code>cnr</code> calls.  The
return object a formula to define a control polygon/net
with different knots than then ones found within <code>form</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+update_bsplines">update_bsplines</a></code> for a more generic tool for the end
user.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cp0 &lt;- cp(log(pdg) ~ bsplines(day, iknots = c(-.25, 0, 0.25), bknots = c(-1, 1)), data = spdg)

new_knots &lt;- c(-0.85, 0, 0.25, 0.3)
f &lt;- cpr:::newknots(cp0$call$formula, nk = new_knots)
f
cp(f, data = spdg)

</code></pre>

<hr>
<h2 id='order_statistics'>Distribution of Order Statistics</h2><span id='topic+order_statistics'></span><span id='topic+d_order_statistic'></span><span id='topic+p_order_statistic'></span>

<h3>Description</h3>

<p>Density of distribution function for the jth order statistics from a sample
of size n from a known distribution function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_order_statistic(x, n, j, distribution, ...)

p_order_statistic(q, n, j, distribution, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_statistics_+3A_x">x</code>, <code id="order_statistics_+3A_q">q</code></td>
<td>
<p>vector or quantiles</p>
</td></tr>
<tr><td><code id="order_statistics_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="order_statistics_+3A_j">j</code></td>
<td>
<p>jth order statistics</p>
</td></tr>
<tr><td><code id="order_statistics_+3A_distribution">distribution</code></td>
<td>
<p>character string defining the distribution. See Details.</p>
</td></tr>
<tr><td><code id="order_statistics_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the density and distribution
function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a known distribution with defined density and distribution functions,
e.g., normal (<code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="stats.html#topic+pnorm">pnorm</a></code>), or
chisq (<code><a href="stats.html#topic+dchisq">dchisq</a></code>, <code><a href="stats.html#topic+pchisq">pchisq</a></code>), we define
the density function of of the jth order statistic, from a sample of size n,
to be
</p>
<p style="text-align: center;"><code class="reqn"> \frac{n!}{(j-1)!(n-j)!} f(x) F(x)^{j-1} (1 - F(x))^{n-j}</code>
</p>
<p>.
</p>
<p>and the distribution function to be
</p>
<p style="text-align: center;"><code class="reqn">\sum_{k = j}^{n} \binom{n}{k} \left[F(x)\right]^{k} \left[1-F(x)\right]^{n-k}</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>References</h3>

<p>George Casella and Roger L. Berger (2002). Statistical Inference. 2nd edition. Duxbury Thomson Learning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
# Find the distribution of the minimum from a sample of size 54 from a
# standard normal distribution

simulated_data &lt;- matrix(rnorm(n = 54 * 5000), ncol = 54)

# find all the minimums for each of the simulated samples of size 54
mins &lt;- apply(simulated_data, 1, min)

# get the density values
x &lt;- seq(-5, 0, length.out = 100)
d &lt;- d_order_statistic(x, n = 54, j = 1, distribution = "norm")

# plot the histogram and density
hist(mins, freq = FALSE)
points(x, d, type = "l", col = "red")

# plot the distribution function
plot(ecdf(mins))
points(x, p_order_statistic(q = x,  n = 54, j = 1, distribution = "norm"), col = "red")

# Example 2
# Find the density and distrubition of the fourth order statistic from a
# sample of size 12 from a chisq distribution with 3 degrees of freedom

simulated_data &lt;- matrix(rchisq(n = 12 * 5000, df = 3), ncol = 12)

os4 &lt;- apply(simulated_data, 1, function(x) sort(x)[4])

x &lt;- seq(min(os4), max(os4), length.out = 100)
d &lt;- d_order_statistic(x, n = 12, j = 4, distribution = "chisq", df = 3)
p &lt;- p_order_statistic(x, n = 12, j = 4, distribution = "chisq", df = 3)

hist(os4, freq = FALSE); points(x, d, type = "l", col = "red")
plot(ecdf(os4)); points(x, p, col = "red")

# Example 3
# For a set of j observations, find the values for each of the j order
# statistics
simulated_data &lt;- matrix(rnorm(n = 6 * 5000), ncol = 6)
simulated_data &lt;- apply(simulated_data, 1, sort)
xs &lt;- apply(simulated_data, 1, range)
xs &lt;- apply(xs, 2, function(x) {seq(x[1], x[2], length.out = 100)})
ds &lt;- apply(xs, 1, d_order_statistic, n = 6, j = 1:6, distribution = "norm")
ps &lt;- apply(xs, 1, p_order_statistic, n = 6, j = 1:6, distribution = "norm")

old_par &lt;- par() # save current settings

par(mfrow = c(2, 3))
for (i in 1:6) {
  hist(simulated_data[i, ]
       , freq = FALSE
       , main = substitute(Density~of~X[(ii)], list(ii = i))
       , xlab = ""
  )
  points(xs[, i], ds[i, ], type = "l", col = "red")
}

for (i in 1:6) {
  plot(ecdf(simulated_data[i, ])
       , main = substitute(CDF~of~X[(ii)], list(ii = i))
       , ylab = ""
       , xlab = ""
       )
  points(xs[, i], ps[i, ], type = "p", col = "red")
}

par(mfrow = c(1, 1))
plot(xs[, 1], ps[1, ], type = "l", col = 1, xlim = range(xs), ylab = "", xlab = "")
for(i in 2:6) {
  points(xs[, i], ps[i, ], type = "l", col = i)
}
legend("topleft", col = 1:6, lty = 1, legend =
       c(
         expression(CDF~of~X[(1)]),
         expression(CDF~of~X[(2)]),
         expression(CDF~of~X[(3)]),
         expression(CDF~of~X[(4)]),
         expression(CDF~of~X[(5)]),
         expression(CDF~of~X[(5)])
         ))

par(old_par) # reset par to setting prior to running this example

</code></pre>

<hr>
<h2 id='plot.cpr_bs'>Plot B-spline Basis</h2><span id='topic+plot.cpr_bs'></span>

<h3>Description</h3>

<p>Wrapper around several ggplot2 calls to plot a B-spline basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_bs'
plot(x, ..., show_xi = TRUE, show_x = FALSE, color = TRUE, digits = 2, n = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cpr_bs_+3A_x">x</code></td>
<td>
<p>a <code>cpr_bs</code> object</p>
</td></tr>
<tr><td><code id="plot.cpr_bs_+3A_show_xi">show_xi</code></td>
<td>
<p>logical, show the knot locations, using the Greek letter xi, on the x-axis</p>
</td></tr>
<tr><td><code id="plot.cpr_bs_+3A_show_x">show_x</code></td>
<td>
<p>logical, show the x values of the knots on the x-axis</p>
</td></tr>
<tr><td><code id="plot.cpr_bs_+3A_color">color</code></td>
<td>
<p>logical, if <code>TRUE</code> (default) the splines are plotted in
color.  If <code>FALSE</code> all splines are black lines.</p>
</td></tr>
<tr><td><code id="plot.cpr_bs_+3A_digits">digits</code></td>
<td>
<p>number of digits to the right of the decimal place to report
for the value of each knot.</p>
</td></tr>
<tr><td><code id="plot.cpr_bs_+3A_n">n</code></td>
<td>
<p>number of values to use to plot the splines, defaults to 100</p>
</td></tr>
<tr><td><code id="plot.cpr_bs_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsplines">bsplines</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bmat &lt;- bsplines(seq(-3, 2, length = 1000), iknots = c(-2, 0, 0.2))
plot(bmat, show_xi = TRUE,  show_x = TRUE)
plot(bmat, show_xi = FALSE, show_x = TRUE)
plot(bmat, show_xi = TRUE,  show_x = FALSE)  ## Default
plot(bmat, show_xi = FALSE, show_x = FALSE)
plot(bmat, show_xi = FALSE, show_x = FALSE)
plot(bmat, show_xi = FALSE, show_x = FALSE, color = FALSE)
</code></pre>

<hr>
<h2 id='plot.cpr_cn'>Plotting Control Nets</h2><span id='topic+plot.cpr_cn'></span>

<h3>Description</h3>

<p>Three-dimensional plots of control nets and/or surfaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_cn'
plot(
  x,
  ...,
  xlab = "",
  ylab = "",
  zlab = "",
  show_net = TRUE,
  show_surface = FALSE,
  get_surface_args,
  net_args,
  surface_args,
  rgl = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cpr_cn_+3A_x">x</code></td>
<td>
<p>a <code>cpr_cn</code> object</p>
</td></tr>
<tr><td><code id="plot.cpr_cn_+3A_...">...</code></td>
<td>
<p>common arguments which would be
used for both the plot of the control net and the surface, e.g., xlim, ylim,
zlim.</p>
</td></tr>
<tr><td><code id="plot.cpr_cn_+3A_xlab">xlab</code>, <code id="plot.cpr_cn_+3A_ylab">ylab</code>, <code id="plot.cpr_cn_+3A_zlab">zlab</code></td>
<td>
<p>labels for the axes.</p>
</td></tr>
<tr><td><code id="plot.cpr_cn_+3A_show_net">show_net</code></td>
<td>
<p>logical, show the control net</p>
</td></tr>
<tr><td><code id="plot.cpr_cn_+3A_show_surface">show_surface</code></td>
<td>
<p>logical, show the tensor product surface</p>
</td></tr>
<tr><td><code id="plot.cpr_cn_+3A_get_surface_args">get_surface_args</code></td>
<td>
<p>a list of arguments passed to the
<code><a href="#topic+get_surface">get_surface</a></code> call.  This call generates the needed data sets
used in the plotting.</p>
</td></tr>
<tr><td><code id="plot.cpr_cn_+3A_net_args">net_args</code></td>
<td>
<p>arguments to be used explicitly for the control net.  Ignored
if <code>show_net = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.cpr_cn_+3A_surface_args">surface_args</code></td>
<td>
<p>arguments to be used explicitly for the surface.  Ignored
if <code>show_surface = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.cpr_cn_+3A_rgl">rgl</code></td>
<td>
<p>If <code>TRUE</code>, the default, generate use <code>rgl::persp3d</code> to
generate the graphics.  If <code>FALSE</code>, use <code>plot3D::persp3D</code> to
generate the graphics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This plotting method generates three-dimensional plots of the control net,
surface, or both, for a <code>cpr_cn</code> objects.  The three-dimensional plots
are generated by either <code><a href="plot3D.html#topic+persp3D">persp3D</a></code> form the <code>plot3D</code>
package or <code><a href="rgl.html#topic+persp3d">persp3d</a></code> from the <code>rgl</code> package.
<code>rgl</code> graphics may or may not work on your system depending on support
for OpenGL.
</p>
<p>Building complex and customized graphics might be easier for you if you use
<code><a href="#topic+get_surface">get_surface</a></code> to generate the needed data for plotting.  See
<code>vignette(topic = "cnr", package = "cpr")</code> for examples of building
different plots.
</p>
<p>For <code>rgl</code> graphics, the <code>surface_args</code> and <code>net_args</code> are
lists of <code><a href="rgl.html#topic+rgl.material">rgl.material</a></code> and other arguments passed to
<code><a href="rgl.html#topic+persp3d">persp3d</a></code>. Defaults are <code>col = "black", front =
"lines", back = "lines"</code> for the <code>net_args</code> and
<code>col = "grey20", front = "fill", back = "lines"</code> for the
<code>surface_args</code>.
</p>
<p>For <code>plot3D</code> graphics there are no defaults values for the
<code>net_args</code> and <code>surface_args</code>.
</p>


<h3>Value</h3>

<p>the plotting data needed to generate the plot is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cpr_cp">plot.cpr_cp</a></code> for plotting control polygons and splines,
<code><a href="rgl.html#topic+persp3d">persp3d</a></code> and <code><a href="rgl.html#topic+rgl.material">rgl.material</a></code> for generating
and controlling rgl graphics. <code><a href="plot3D.html#topic+persp3D">persp3D</a></code> for building
plot3D graphics. <code><a href="#topic+get_surface">get_surface</a></code> for generating the data sets
needed for the plotting methods.
</p>
<p><code>vignette(topic = "cnr", package = "cpr")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 acn &lt;- cn(log10(pdg) ~ btensor(  x = list(day, age)
                                , df = list(30, 4)
                                , bknots = list(c(-1, 1), c(44, 53)))
           , data = spdg)

# plot3D
plot(acn, rgl = FALSE)

# rgl
if (require(rgl)) {
  plot(acn, rgl = TRUE)
}


</code></pre>

<hr>
<h2 id='plot.cpr_cnr'>Control Net Reduction Plots</h2><span id='topic+plot.cpr_cnr'></span>

<h3>Description</h3>

<p>A collection of function for the inspection and evaluation of the control
polygon reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_cnr'
plot(x, type = "rse", from = 1, to, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cpr_cnr_+3A_x">x</code></td>
<td>
<p>a <code>cpr_cnr</code> object</p>
</td></tr>
<tr><td><code id="plot.cpr_cnr_+3A_type">type</code></td>
<td>
<p>type of diagnostic plot.
<code>"loglik"</code> for the log likelihood by degrees of freedom,
<code>"rse"</code> for residual standard error by model index</p>
</td></tr>
<tr><td><code id="plot.cpr_cnr_+3A_from">from</code></td>
<td>
<p>the first index of <code>x</code> to plot</p>
</td></tr>
<tr><td><code id="plot.cpr_cnr_+3A_to">to</code></td>
<td>
<p>the last index of <code>x</code> to plot</p>
</td></tr>
<tr><td><code id="plot.cpr_cnr_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initial_cn &lt;- cn(log10(pdg) ~ btensor(list(day, age)
                        , df = list(10, 8)
                        , bknots = list(c(-1, 1), c(44, 53))
                        )
          , data = spdg)

cnr0 &lt;- cnr(initial_cn)

plot(cnr0)

</code></pre>

<hr>
<h2 id='plot.cpr_cp'>Plotting Control Polygons</h2><span id='topic+plot.cpr_cp'></span>

<h3>Description</h3>

<p>Plotting control polygon(s) and/or the associated spline(s) via ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_cp'
plot(
  x,
  ...,
  comparative,
  show_cp = TRUE,
  show_spline = FALSE,
  show_xi = TRUE,
  color = FALSE,
  n = 100,
  show_x = FALSE,
  digits = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cpr_cp_+3A_x">x</code></td>
<td>
<p>a <code>cpr_cp</code> object</p>
</td></tr>
<tr><td><code id="plot.cpr_cp_+3A_...">...</code></td>
<td>
<p>additional <code>cpr_cp</code> objects</p>
</td></tr>
<tr><td><code id="plot.cpr_cp_+3A_comparative">comparative</code></td>
<td>
<p>when <code>TRUE</code> use <code>color</code> to distinguish one spline from
another, when <code>FALSE</code> <code>color</code> to highlight the control polygon and
spline with different colors, and plot the knots the way
<code><a href="#topic+plot.cpr_bs">plot.cpr_bs</a></code> does.  When missing, the default if <code>TRUE</code> if
more than one <code>cpr_cp</code> object is passed in, and <code>FALSE</code> is only one
<code>cpr_cp</code> object is passed.</p>
</td></tr>
<tr><td><code id="plot.cpr_cp_+3A_show_cp">show_cp</code></td>
<td>
<p>logical (default <code>TRUE</code>), show the control polygon(s)?</p>
</td></tr>
<tr><td><code id="plot.cpr_cp_+3A_show_spline">show_spline</code></td>
<td>
<p>logical (default <code>FALSE</code>) to plot the spline
function?</p>
</td></tr>
<tr><td><code id="plot.cpr_cp_+3A_show_xi">show_xi</code></td>
<td>
<p>logical (default <code>TRUE</code>) use
<code><a href="ggplot2.html#topic+geom_rug">geom_rug</a></code> to show the location of the knots in the
respective control polygons.</p>
</td></tr>
<tr><td><code id="plot.cpr_cp_+3A_color">color</code></td>
<td>
<p>Boolean (default FALSE) if more than one <code>cpr_cp</code> object is
to be plotted, set this value to TRUE to have the graphic in color (line types
will be used regardless of the color setting).</p>
</td></tr>
<tr><td><code id="plot.cpr_cp_+3A_n">n</code></td>
<td>
<p>the number of data points to use for plotting the spline</p>
</td></tr>
<tr><td><code id="plot.cpr_cp_+3A_show_x">show_x</code></td>
<td>
<p>boolean, so x-values</p>
</td></tr>
<tr><td><code id="plot.cpr_cp_+3A_digits">digits</code></td>
<td>
<p>number of digits to the right of the decimal place to report
for the value of each knot. Only used when plotting on control polygon with
<code>comparative = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- runif(n = 500, 0, 6)
bmat &lt;- bsplines(x, iknots = c(1, 1.5, 2.3, 4, 4.5), bknots = c(0, 6))
theta1 &lt;- matrix(c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5), ncol = 1)
theta2 &lt;- theta1 + c(-0.15, -1.01, 0.37, 0.19, -0.53, -0.84, -0.19, 1.15, 0.17)
cp1 &lt;- cp(bmat, theta1)
cp2 &lt;- cp(bmat, theta2)

# compare two control polygons on one plot
plot(cp1, cp2)
plot(cp1, cp2, color = TRUE)
plot(cp1, cp2, color = TRUE, show_spline = TRUE)
plot(cp1, cp2, color = TRUE, show_cp = FALSE, show_spline = TRUE)

# Show one control polygon with knots on the axis instead of the rug and
# color/linetype for the control polygon and spline, instead of different
# control polygons
plot(cp1, comparative = FALSE)
plot(cp1, comparative = FALSE, show_spline = TRUE)
plot(cp1, comparative = FALSE, show_spline = TRUE, show_x = TRUE)
plot(cp2, comparative = FALSE, show_spline = TRUE, show_x = TRUE)


</code></pre>

<hr>
<h2 id='plot.cpr_cpr'>Control Polygon Reduction Plots</h2><span id='topic+plot.cpr_cpr'></span>

<h3>Description</h3>

<p>A wrapper around several ggplot2 calls to help evaluate results of a CPR run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_cpr'
plot(x, from = 1, to, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cpr_cpr_+3A_x">x</code></td>
<td>
<p>a <code>cpr_cpr</code> object</p>
</td></tr>
<tr><td><code id="plot.cpr_cpr_+3A_from">from</code></td>
<td>
<p>the first index of <code>x</code> to plot</p>
</td></tr>
<tr><td><code id="plot.cpr_cpr_+3A_to">to</code></td>
<td>
<p>the last index of <code>x</code> to plot</p>
</td></tr>
<tr><td><code id="plot.cpr_cpr_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>plot.cpr_cp</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cpr_cp">plot.cpr_cp</a></code>, <code><a href="#topic+cpr">cpr</a></code>, <code><a href="#topic+cp">cp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- seq(0 + 1/5000, 6 - 1/5000, length.out = 100)
bmat &lt;- bsplines(x, iknots = c(1, 1.5, 2.3, 4, 4.5), bknots = c(0, 6))
theta &lt;- matrix(c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5), ncol = 1)
DF &lt;- data.frame(x = x, truth = as.numeric(bmat %*% theta))
DF$y &lt;- as.numeric(bmat %*% theta + rnorm(nrow(bmat), sd = 0.3))

initial_cp0 &lt;-
  cp(y ~ bsplines(x, iknots = c(1, 1.5, 2.3, 3.0, 4, 4.5), bknots = c(0, 6))
     , data = DF
     , keep_fit = TRUE # default is FALSE
  )
cpr0 &lt;- cpr(initial_cp0)

plot(cpr0)
plot(cpr0, show_spline = TRUE, show_cp = FALSE, color = TRUE, from = 2, to = 4)

</code></pre>

<hr>
<h2 id='plot.cpr_summary_cpr_cpr'>Plotting Summaries of Control Polygon Reductions</h2><span id='topic+plot.cpr_summary_cpr_cpr'></span>

<h3>Description</h3>

<p>Plotting Summaries of Control Polygon Reductions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_summary_cpr_cpr'
plot(
  x,
  type = c("rse", "rss", "loglik", "wiggle", "fdsc", "Pr(&gt;w_(1))"),
  from = 1,
  to,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cpr_summary_cpr_cpr_+3A_x">x</code></td>
<td>
<p>a <code>cpr_summary_cpr_cpr</code> object</p>
</td></tr>
<tr><td><code id="plot.cpr_summary_cpr_cpr_+3A_type">type</code></td>
<td>
<p>response to plot by index</p>
</td></tr>
<tr><td><code id="plot.cpr_summary_cpr_cpr_+3A_from">from</code></td>
<td>
<p>the first index of <code>x</code> to plot</p>
</td></tr>
<tr><td><code id="plot.cpr_summary_cpr_cpr_+3A_to">to</code></td>
<td>
<p>the last index of <code>x</code> to plot</p>
</td></tr>
<tr><td><code id="plot.cpr_summary_cpr_cpr_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cpr_cpr">plot.cpr_cpr</a></code>, <code><a href="#topic+cpr">cpr</a></code>
<code><a href="#topic+summary.cpr_cpr">summary.cpr_cpr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- seq(0 + 1/5000, 6 - 1/5000, length.out = 100)
bmat &lt;- bsplines(x, iknots = c(1, 1.5, 2.3, 4, 4.5), bknots = c(0, 6))
theta &lt;- matrix(c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5), ncol = 1)
DF &lt;- data.frame(x = x, truth = as.numeric(bmat %*% theta))
DF$y &lt;- as.numeric(bmat %*% theta + rnorm(nrow(bmat), sd = 0.3))

initial_cp0 &lt;-
  cp(y ~ bsplines(x, iknots = c(1, 1.5, 2.3, 3.0, 4, 4.5), bknots = c(0, 6))
     , data = DF
     , keep_fit = TRUE # default is FALSE
  )
cpr0 &lt;- cpr(initial_cp0)
s0   &lt;- summary(cpr0)

plot(s0, type = "rse")
plot(s0, type = "rss")
plot(s0, type = "loglik")
plot(s0, type = "wiggle")
plot(s0, type = "fdsc")
plot(s0, type = "Pr(&gt;w_(1))")

</code></pre>

<hr>
<h2 id='predict.cpr_cp'>Model Prediction</h2><span id='topic+predict.cpr_cp'></span>

<h3>Description</h3>

<p>Model prediction for <code>cpr_cp</code> and <code>cpr_cn</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_cp'
predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cpr_cp_+3A_object">object</code></td>
<td>
<p>a <code>cpr_cp</code> or <code>cpr_cn</code> object</p>
</td></tr>
<tr><td><code id="predict.cpr_cp_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="stats.html#topic+predict">predict</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same as you would get from calling <code><a href="stats.html#topic+predict">predict</a></code>
on the <code>object$fit</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
acp &lt;- cp(log10(pdg) ~ bsplines(age, df = 12, bknots = c(45, 53))
           , data = spdg
          , keep_fit = TRUE)
acp_pred0 &lt;- predict(acp$fit, se.fit = TRUE)
acp_pred &lt;- predict(acp, se.fit = TRUE)
all.equal(acp_pred0, acp_pred)

</code></pre>

<hr>
<h2 id='print.cpr_bs'>Print bsplines</h2><span id='topic+print.cpr_bs'></span>

<h3>Description</h3>

<p>Print bsplines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_bs'
print(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cpr_bs_+3A_x">x</code></td>
<td>
<p>a <code>cpr_bs</code> object.</p>
</td></tr>
<tr><td><code id="print.cpr_bs_+3A_n">n</code></td>
<td>
<p>number of rows of the B-spline basis matrix to display, defaults to
6L.</p>
</td></tr>
<tr><td><code id="print.cpr_bs_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object <code>x</code> is returned invisibly
</p>

<hr>
<h2 id='sign_changes'>Sign Changes</h2><span id='topic+sign_changes'></span>

<h3>Description</h3>

<p>Count the number of times the first, or second, derivative of a spline
changes sign.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign_changes(
  object,
  lower = min(object$bknots),
  upper = max(object$bknots),
  n = 1000,
  derivative = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sign_changes_+3A_object">object</code></td>
<td>
<p>a <code>cpr_cp</code> object</p>
</td></tr>
<tr><td><code id="sign_changes_+3A_lower">lower</code></td>
<td>
<p>the lower limit of the integral</p>
</td></tr>
<tr><td><code id="sign_changes_+3A_upper">upper</code></td>
<td>
<p>the upper limit of the integral</p>
</td></tr>
<tr><td><code id="sign_changes_+3A_n">n</code></td>
<td>
<p>number of values to assess the derivative between <code>lower</code> and
<code>upper</code>.</p>
</td></tr>
<tr><td><code id="sign_changes_+3A_derivative">derivative</code></td>
<td>
<p>integer value denoted first or second derivative</p>
</td></tr>
<tr><td><code id="sign_changes_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of times the sign of the first or second derivative
changes within the specified interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wiggle">wiggle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xvec &lt;- seq(0, 6, length = 500)

# Define the basis matrix
bmat1 &lt;- bsplines(x = xvec, iknots = c(1, 1.5, 2.3, 4, 4.5))
bmat2 &lt;- bsplines(x = xvec)

# Define the control vertices ordinates
theta1 &lt;- c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5)
theta2 &lt;- c(1, 3.4, -2, 1.7)

# build the two control polygons
cp1 &lt;- cp(bmat1, theta1)
cp2 &lt;- cp(bmat2, theta2)
plot(cp1, cp2, show_cp = FALSE, show_spline = TRUE)

sign_changes(cp1)
sign_changes(cp2)


</code></pre>

<hr>
<h2 id='spdg'>Simulated Pregnanediol glucuronide (PDG) Data</h2><span id='topic+spdg'></span>

<h3>Description</h3>

<p>A Simulated data set based on the Study of Women's Health Across the Nation
(SWAN) Daily Hormone Study (DHS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spdg
</code></pre>


<h3>Format</h3>

<p>a <code>data.frame</code>. Variables in the data
set:
</p>

<dl>
<dt>id</dt><dd><p>Subject ID</p>
</dd>
<dt>age</dt><dd><p>Age, in years of the subject</p>
</dd>
<dt>ttm</dt><dd><p>Time-to-menopause, in years</p>
</dd>
<dt>ethnicity</dt><dd><p>Ethnicity, a factor with five levels: Caucasian, Black,
Chinese, Hispanic, and Japanese</p>
</dd>
<dt>bmi</dt><dd><p>Body Mass Index</p>
</dd>
<dt>day_from_dlt</dt><dd><p>A integer value for the number of days from Day of
Luteal Transition (DLT).  The DLT is <code>day_from_dlt == 0</code>.  Negative
values indicate the follicular phase, positive values for the luteal phase.</p>
</dd>
<dt>day_of_cycle</dt><dd><p>the day of cycle</p>
</dd>
<dt>day</dt><dd><p>A scaled day-of-cycle between [-1, 1] with 0 for the DLT.  See
Details</p>
</dd>
<dt>pdg</dt><dd><p>A simulated PDG value</p>
</dd>
</dl>



<h3>Details</h3>

<p>Pregnanediol glucuronide (PDG) is the urine metabolite of progesterone.  This
data set was simulated to have similar
characteristics to a subset of the SWAN DHS data.  The SWAN DHS data was the
motivating data set for the method development that lead to the <code>cpr</code>
package.  The DHS data cannot be made public, so this simulated data set has
been provided for use in examples and instructions for use of the <code>cpr</code>
package.
</p>


<h3>Source</h3>

<p>This is simulated data.  To see the script that generated the data
set please visit <a href="https://github.com/dewittpe/cpr">https://github.com/dewittpe/cpr</a> and look at the
scripts in the data-raw directory.
</p>


<h3>References</h3>

<p>Santoro, Nanette, et al. &quot;Body size and ethnicity are associated with
menstrual cycle alterations in women in the early menopausal transition: The
Study of Women's Health across the Nation (SWAN) Daily Hormone Study.&quot; The
Journal of Clinical Endocrinology &amp; Metabolism 89.6 (2004): 2622-2631.
</p>

<hr>
<h2 id='summary.cpr_cn'>Summary of Control Net</h2><span id='topic+summary.cpr_cn'></span>

<h3>Description</h3>

<p>Generate a summary of control net object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_cn'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cpr_cn_+3A_object">object</code></td>
<td>
<p>a <code>cpr_cn</code> object</p>
</td></tr>
<tr><td><code id="summary.cpr_cn_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
acn &lt;- cn(log10(pdg) ~ btensor(list(day, age)
                               , df = list(10, 8)
                               , bknots = list(c(-1, 1), c(44, 53)))
         , data = spdg)

summary(acn)

</code></pre>

<hr>
<h2 id='summary.cpr_cnr'>Summarize Control Net Reduction Objects</h2><span id='topic+summary.cpr_cnr'></span>

<h3>Description</h3>

<p>Summarize Control Net Reduction Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_cnr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cpr_cnr_+3A_object">object</code></td>
<td>
<p>a <code>cpr_cnr</code> object</p>
</td></tr>
<tr><td><code id="summary.cpr_cnr_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>cpr_summary_cpr_cnr</code> object, that is just a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
acn &lt;- cn(log10(pdg) ~ btensor(list(day, age)
                               , df = list(10, 8)
                               , bknots = list(c(-1, 1), c(44, 53)))
         , data = spdg)
cnr0 &lt;- cnr(acn)
cnr0
summary(cnr0)

</code></pre>

<hr>
<h2 id='summary.cpr_cp'>Summarize a Control Polygon Object</h2><span id='topic+summary.cpr_cp'></span>

<h3>Description</h3>

<p>Summarize a Control Polygon Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_cp'
summary(object, wiggle = TRUE, integrate.args = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cpr_cp_+3A_object">object</code></td>
<td>
<p>a <code>cpr_cp</code> object</p>
</td></tr>
<tr><td><code id="summary.cpr_cp_+3A_wiggle">wiggle</code></td>
<td>
<p>logical, if <code>TRUE</code> then the integral of the squared second
derivative of the spline function will be calculated via
<code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cpr_cp_+3A_integrate.args">integrate.args</code></td>
<td>
<p>a list of arguments passed to <code><a href="#topic+wiggle">wiggle</a></code> and
ultimately <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="summary.cpr_cp_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>cpr_summary_cpr_cp</code> object, that is just a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- seq(0 + 1/5000, 6 - 1/5000, length.out = 100)
bmat &lt;- bsplines(x, iknots = c(1, 1.5, 2.3, 4, 4.5), bknots = c(0, 6))
theta &lt;- matrix(c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5), ncol = 1)
DF &lt;- data.frame(x = x, truth = as.numeric(bmat %*% theta))
DF$y &lt;- as.numeric(bmat %*% theta + rnorm(nrow(bmat), sd = 0.3))

initial_cp &lt;-
  cp(y ~ bsplines(x, iknots = c(1, 1.5, 2.3, 3.0, 4, 4.5), bknots = c(0, 6))
     , data = DF
     , keep_fit = TRUE # default is FALSE
  )

summary(initial_cp)

</code></pre>

<hr>
<h2 id='summary.cpr_cpr'>Summarize a Control Polygon Reduction Object</h2><span id='topic+summary.cpr_cpr'></span>

<h3>Description</h3>

<p>Summarize a Control Polygon Reduction Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpr_cpr'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cpr_cpr_+3A_object">object</code></td>
<td>
<p>a <code>cpr_cpr</code> object</p>
</td></tr>
<tr><td><code id="summary.cpr_cpr_+3A_...">...</code></td>
<td>
<p>pass through</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> with the attribute <code>elbow</code> which is a
programmatic attempt to identify a useful trade-off between degrees of freedom
and fit statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)
x &lt;- seq(0 + 1/5000, 6 - 1/5000, length.out = 100)
bmat &lt;- bsplines(x, iknots = c(1, 1.5, 2.3, 4, 4.5), bknots = c(0, 6))
theta &lt;- matrix(c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5), ncol = 1)
DF &lt;- data.frame(x = x, truth = as.numeric(bmat %*% theta))
DF$y &lt;- as.numeric(bmat %*% theta + rnorm(nrow(bmat), sd = 0.3))

initial_cp &lt;-
  cp(y ~ bsplines(x, iknots = c(1, 1.5, 2.3, 3.0, 4, 4.5), bknots = c(0, 6))
     , data = DF
     , keep_fit = TRUE # default is FALSE
  )

cpr0 &lt;- cpr(initial_cp)
s &lt;- summary(cpr0)
s
plot(s, type = "rse")

</code></pre>

<hr>
<h2 id='trimmed_quantile'>Trimmed Quantiles</h2><span id='topic+trimmed_quantile'></span>

<h3>Description</h3>

<p>For data <code class="reqn">X = x_1, x_2, \ldots, x_n</code>, with order
statistics <code class="reqn">x_{(1)}, x_{(2)}, \ldots, x_{(r)}</code>
return the quantiles for a trimmed data set, e.g.,
<code class="reqn">\boldsymbol{X} \backslash \{x_{(1)}, x_{(r)}\}</code> (trim = 1), or
<code class="reqn">\boldsymbol{X} \backslash \{x_{(1)}, x_{(2)}, x_{(r-1)}, x_{(r)}\}</code> (trim = 2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimmed_quantile(x, trim = 1L, use_unique = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimmed_quantile_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="trimmed_quantile_+3A_trim">trim</code></td>
<td>
<p>defaults to 1, omitting the min and the max</p>
</td></tr>
<tr><td><code id="trimmed_quantile_+3A_use_unique">use_unique</code></td>
<td>
<p>logical, if true (defaults), base the quantiles on unique
values, if false, base the quantiles on all data, after trimming.</p>
</td></tr>
<tr><td><code id="trimmed_quantile_+3A_...">...</code></td>
<td>
<p>other arguments to pass to stats::quantile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector, the return from <code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trimmed_quantile(1:100, prob = 1:23 / 24, name = FALSE)

# Warning
# trimmed_quantile(1:100, trim = .3, prob = 1:23 / 24, name = FALSE)

# no warning
trimmed_quantile(1:100, trim = 3, prob = 1:23 / 24, name = FALSE)

</code></pre>

<hr>
<h2 id='update_bsplines'>Update bsplines or btensor calls</h2><span id='topic+update_bsplines'></span><span id='topic+update_btensor'></span>

<h3>Description</h3>

<p>Update <code>cpr_bs</code> and <code>cpr_bt</code> objects alone or within <code>cpr_cp</code>
and <code>cpr_cn</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_bsplines(object, ..., evaluate = TRUE)

update_btensor(object, ..., evaluate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_bsplines_+3A_object">object</code></td>
<td>
<p>an object to update.</p>
</td></tr>
<tr><td><code id="update_bsplines_+3A_...">...</code></td>
<td>
<p>arguments to update, expected to be <code>iknots</code>, <code>df</code>,
<code>bknots</code>, or <code>order</code>.</p>
</td></tr>
<tr><td><code id="update_bsplines_+3A_evaluate">evaluate</code></td>
<td>
<p>whether or not to evaluate the updated call.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>evaluate = TRUE</code> then a <code>cpr_bs</code> or <code>cpr_bt</code>
object is returned, else, an unevaluated call is returned.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+update">update</a></code>, <code><a href="#topic+bsplines">bsplines</a></code>,
<code><a href="#topic+btensor">btensor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>################################################################################
##                          Updating a cpr_bs object                          ##
# construct a B-spline basis
bmat &lt;- bsplines(runif(10, 1, 10), df = 5, order = 3, bknots = c(1, 10))

# look at the structure of the basis
str(bmat)

# change the order
str(update_bsplines(bmat, order = 4))

# change the order and the degrees of freedom
str(update_bsplines(bmat, df = 12, order = 4))

################################################################################
##                          Updating a cpr_bt object                          ##
# construct a tensor product
tpmat &lt;- btensor(list(x1 = seq(0, 1, length = 10), x2 = seq(0, 1, length = 10)),
                 df = list(4, 5))
tpmat

# update the degrees of freedom
update_btensor(tpmat, df = list(6, 7))

################################################################################
##      Updating bsplines or btensor on the right and side of a formula       ##

f1 &lt;- y ~ bsplines(x, df = 14) + var1 + var2
f2 &lt;- y ~ btensor(x = list(x1, x2), df = list(50, 31), order = list(3, 5))  + var1 + var2

update_bsplines(f1, df = 13, order = 5)
update_btensor(f2, df = list(13, 24), order = list(3, 8))

################################################################################
##                          Updating a cpr_cp object                          ##
data(spdg, package = "cpr")
init_cp &lt;- cp(pdg ~ bsplines(day, df = 30) + age + ttm, data = spdg)
updt_cp &lt;- update_bsplines(init_cp, df = 5)

################################################################################
##                          Updating a cpr_cn object                          ##
init_cn &lt;- cn(pdg ~ btensor(list(day, age), df = list(30, 4)) + ttm, data = spdg)
updt_cn &lt;- update_btensor(init_cn, df = list(30, 2), order = list(3, 2))

</code></pre>

<hr>
<h2 id='us_covid_cases'>United States Laboratory Confirmed COVID-19 Cases</h2><span id='topic+us_covid_cases'></span>

<h3>Description</h3>

<p>Number of laboratory-confirmed COVID-19 cases in the United States, as
reported by the Centers for Disease Control, between January 1 2020 and May
11, 2023, the end of the public health emergency declaration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>us_covid_cases
</code></pre>


<h3>Format</h3>

<p>a <code>data.frame</code> with two columns
</p>

<dl>
<dt>date</dt><dd><p>year, month, day</p>
</dd>
<dt>cases</dt><dd><p>number of reported laboratory-confirmed COVID-19 cases</p>
</dd>
</dl>



<h3>Source</h3>

<p>Download original data from
&lt;https://data.cdc.gov/Case-Surveillance/COVID-19-Case-Surveillance-Public-Use-Data/vbim-akqf&gt;
on December 5, 2023.  The reported data set was last updated on November 3,
2023.
</p>

<hr>
<h2 id='wiggle'>Wiggliness of a Spline function</h2><span id='topic+wiggle'></span>

<h3>Description</h3>

<p>Calculate the integral of the squared second derivative of the spline
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wiggle(object, lower, upper, stop.on.error = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wiggle_+3A_object">object</code></td>
<td>
<p>a <code>cpr_cp</code> object</p>
</td></tr>
<tr><td><code id="wiggle_+3A_lower">lower</code></td>
<td>
<p>the lower limit of the integral</p>
</td></tr>
<tr><td><code id="wiggle_+3A_upper">upper</code></td>
<td>
<p>the upper limit of the integral</p>
</td></tr>
<tr><td><code id="wiggle_+3A_stop.on.error">stop.on.error</code></td>
<td>
<p>default to <code>FALSE</code>, see <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="wiggle_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+integrate">integrate</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The wiggliness of the spline function is defined as
</p>
<p style="text-align: center;"><code class="reqn">\int \left( \frac{\mathrm{d}^2}{\mathrm{d}x^2} f \left(x \right)
\right)^2 \mathrm{d}x.</code>
</p>



<h3>Value</h3>

<p>Same as <code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cp">cp</a></code>, <code><a href="stats.html#topic+integrate">integrate</a></code>,
<code><a href="#topic+sign_changes">sign_changes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xvec &lt;- seq(0, 6, length = 500)

# Define the basis matrix
bmat1 &lt;- bsplines(x = xvec, iknots = c(1, 1.5, 2.3, 4, 4.5))
bmat2 &lt;- bsplines(x = xvec)

# Define the control vertices ordinates
theta1 &lt;- c(1, 0, 3.5, 4.2, 3.7, -0.5, -0.7, 2, 1.5)
theta2 &lt;- c(1, 3.4, -2, 1.7)

# build the two control polygons
cp1 &lt;- cp(bmat1, theta1)
cp2 &lt;- cp(bmat2, theta2)
plot(cp1, cp2, show_cp = FALSE, show_spline = TRUE)

wiggle(cp1)
wiggle(cp2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
