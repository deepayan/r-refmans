<!DOCTYPE html><html><head><title>Help for package ggdmc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggdmc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggdmc'><p>Bayeisan computation of response time models</p></a></li>
<li><a href='#BuildDMI'><p>Bind data and models</p></a></li>
<li><a href='#BuildModel'><p>Create a model object</p></a></li>
<li><a href='#BuildPrior'><p>Specifying Parameter Prior Distributions</p></a></li>
<li><a href='#check_pvec'><p>Does a model object specify a correct p.vector</p></a></li>
<li><a href='#ConvertChains'><p>Prepare posterior samples for plotting functions version 1</p></a></li>
<li><a href='#dbeta_lu'><p>A modified dbeta function</p></a></li>
<li><a href='#dcauchy_l'><p>A modified dcauchy functions</p></a></li>
<li><a href='#dconstant'><p>A pseudo constant function to get constant densities</p></a></li>
<li><a href='#deviance.model'><p>Calculate the statistics of model complexity</p></a></li>
<li><a href='#dgamma_l'><p>A modified dgamma function</p></a></li>
<li><a href='#DIC'><p>Deviance information criteria</p></a></li>
<li><a href='#dlnorm_l'><p>A modified dlnorm functions</p></a></li>
<li><a href='#dtnorm'><p>Truncated Normal Distribution</p></a></li>
<li><a href='#effectiveSize_hyper'><p>Calculate effective sample sizes</p></a></li>
<li><a href='#gelman'><p>Potential scale reduction factor</p></a></li>
<li><a href='#get_os'><p>Retrieve information of operating system</p></a></li>
<li><a href='#GetNsim'><p>Get a n-cell matrix</p></a></li>
<li><a href='#GetParameterMatrix'><p>Constructs a ns x npar matrix,</p></a></li>
<li><a href='#GetPNames'><p>Extract parameter names from a model object</p></a></li>
<li><a href='#iseffective'><p>Model checking functions</p></a></li>
<li><a href='#isflat'><p>Model checking functions</p></a></li>
<li><a href='#ismixed'><p>Model checking functions</p></a></li>
<li><a href='#isstuck'><p>Model checking functions</p></a></li>
<li><a href='#likelihood'><p>Calculate log likelihoods</p></a></li>
<li><a href='#mcmc_list.model'><p>Create a MCMC list</p></a></li>
<li><a href='#PickStuck'><p>Which chains get stuck</p></a></li>
<li><a href='#plot_prior'><p>Plot prior distributions</p></a></li>
<li><a href='#print.prior'><p>Print Prior Distribution</p></a></li>
<li><a href='#random'><p>Generate random numbers</p></a></li>
<li><a href='#rlba_norm'><p>Generate Random Deviates of the LBA Distribution</p></a></li>
<li><a href='#rprior'><p>Parameter Prior Distributions</p></a></li>
<li><a href='#simulate.model'><p>Simulate response time data</p></a></li>
<li><a href='#StartNewsamples'><p>Start new model fits</p></a></li>
<li><a href='#summary_mcmc_list'><p>Summary statistic for posterior samples</p></a></li>
<li><a href='#summary.model'><p>Summarise posterior samples</p></a></li>
<li><a href='#TableParameters'><p>Table response and parameter</p></a></li>
<li><a href='#theta2mcmclist'><p>Convert theta to a mcmc List</p></a></li>
<li><a href='#unstick_one'><p>Unstick posterios samples (One subject)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cognitive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Yi-Shin Lin [aut, cre], Andrew Heathcote [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yi-Shin Lin &lt;yishinlin001@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Hierarchical Bayesian models. The package provides tools to fit two response time models, using the population-based Markov Chain Monte Carlo. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yxlin/ggdmc">https://github.com/yxlin/ggdmc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yxlin/ggdmc/issues">https://github.com/yxlin/ggdmc/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.10), coda, stats, utils, ggplot2, matrixStats,
data.table (&ge; 1.10.4)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.10), RcppArmadillo (&ge; 0.7.100.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-28 22:51:49 UTC; yslin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-29 05:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggdmc'>Bayeisan computation of response time models</h2><span id='topic+ggdmc'></span><span id='topic+ggdmc-package'></span>

<h3>Description</h3>

<p><span class="pkg">ggdmc</span> uses the population-based Markov chain Monte Carlo to
conduct Bayesian computation on cognitive models.
</p>


<h3>Author(s)</h3>

<p>Yi-Shin Lin &lt;yishinlin001@gmail.com&gt; <br />
Andrew Heathcote &lt;andrew.heathcote@utas.edu.au&gt;
</p>


<h3>References</h3>

<p>Heathcote, A., Lin, Y.-S., Reynolds, A., Strickland, L., Gretton, M. &amp;
Matzke, D., (2018). Dynamic model of choice.
<em>Behavior Research Methods</em>.
https://doi.org/10.3758/s13428-018-1067-y. <br />
</p>
<p>Turner, B. M., &amp; Sederberg P. B. (2012). Approximate Bayesian computation
with differential evolution, <em>Journal of Mathematical Psychology</em>, 56,
375&ndash;385. <br />
</p>
<p>Ter Braak (2006). A Markov Chain Monte Carlo version of the genetic
algorithm Differential Evolution: easy Bayesian computing for real
parameter spaces. <em>Statistics and Computing</em>, 16, 239-249.
</p>

<hr>
<h2 id='BuildDMI'>Bind data and models</h2><span id='topic+BuildDMI'></span>

<h3>Description</h3>

<p>Binding a data set with a model object. The function also checks whether
they are compatible and adds attributes on a data model instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildDMI(x, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildDMI_+3A_x">x</code></td>
<td>
<p>data as in data frame</p>
</td></tr>
<tr><td><code id="BuildDMI_+3A_model">model</code></td>
<td>
<p>a model object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data model instance
</p>

<hr>
<h2 id='BuildModel'>Create a model object</h2><span id='topic+BuildModel'></span><span id='topic+print.model'></span><span id='topic+print.dmi'></span>

<h3>Description</h3>

<p>A model object consists of arraies with model attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildModel(p.map, responses, factors = list(A = "1"), match.map = NULL,
  constants = numeric(0), type = "norm", posdrift = TRUE,
  verbose = TRUE)

## S3 method for class 'model'
print(x, p.vector = NULL, ...)

## S3 method for class 'dmi'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildModel_+3A_p.map">p.map</code></td>
<td>
<p>parameter map. This option maps a particular factorial design
to model parameters</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_responses">responses</code></td>
<td>
<p>specifying the response names and levels</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_factors">factors</code></td>
<td>
<p>specifying a list of factors and their levels</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_match.map">match.map</code></td>
<td>
<p>match map. This option matches stimuli and responses</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_constants">constants</code></td>
<td>
<p>specifying the parameters with fixed values</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_type">type</code></td>
<td>
<p>specifying model type, either &quot;rd&quot; or &quot;norm&quot;.</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_posdrift">posdrift</code></td>
<td>
<p>a Boolean, switching between enforcing strict postive drift
rates by using truncated normal distribution. This option is only useful in
&quot;norm&quot; model type.</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_verbose">verbose</code></td>
<td>
<p>Print p.vector, constants and model type</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_x">x</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_p.vector">p.vector</code></td>
<td>
<p>parameter vector</p>
</td></tr>
<tr><td><code id="BuildModel_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- BuildModel(
        p.map     = list(a = "1", v = "1", z = "1", d = "1", t0 = "1",
                     sv = "1", sz = "1", st0 = "1"),
        constants = c(st0 = 0, d = 0, sz = 0, sv = 0),
        match.map = list(M = list(s1 = "r1", s2 = "r2")),
        factors   = list(S = c("s1", "s2")),
        responses = c("r1", "r2"),
        type      = "rd")
</code></pre>

<hr>
<h2 id='BuildPrior'>Specifying Parameter Prior Distributions</h2><span id='topic+BuildPrior'></span>

<h3>Description</h3>

<p><code>BuildPrior</code> sets up parameter prior distributions for each model
parameter. <code>p1</code> and <code>p2</code> refer to the first and second parameters
a prior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildPrior(p1, p2, lower = rep(NA, length(p1)), upper = rep(NA,
  length(p1)), dists = rep("tnorm", length(p1)),
  untrans = rep("identity", length(p1)), types = c("tnorm", "beta",
  "gamma", "lnorm", "unif", "constant", "tnorm2", NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BuildPrior_+3A_p1">p1</code></td>
<td>
<p>the first parameter of a distribution</p>
</td></tr>
<tr><td><code id="BuildPrior_+3A_p2">p2</code></td>
<td>
<p>the second parameter of a distribution</p>
</td></tr>
<tr><td><code id="BuildPrior_+3A_lower">lower</code></td>
<td>
<p>lower support (boundary)</p>
</td></tr>
<tr><td><code id="BuildPrior_+3A_upper">upper</code></td>
<td>
<p>upper support (boundary)</p>
</td></tr>
<tr><td><code id="BuildPrior_+3A_dists">dists</code></td>
<td>
<p>a vector of character string specifying a distribution.</p>
</td></tr>
<tr><td><code id="BuildPrior_+3A_untrans">untrans</code></td>
<td>
<p>whether to do log transformation. Default is not</p>
</td></tr>
<tr><td><code id="BuildPrior_+3A_types">types</code></td>
<td>
<p>available distribution types</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four distribution types are implemented:
</p>

<ol>
<li><p> Normal and truncated normal, where: p1 = mean, p2 = sd. It specifies
a normal distribution when bounds are set -Inf and Inf,
</p>
</li>
<li><p> Beta, where: p1 = shape1 and p2 = shape2 (see <a href="stats.html#topic+pbeta">pbeta</a>). Note the
uniform distribution is a special case of the beta with p1 and
p2 = 1),
</p>
</li>
<li><p> Gamma, where p1 = shape and p2 = scale (see <a href="stats.html#topic+pgamma">pgamma</a>). Note p2 is
scale, not rate,
</p>
</li>
<li><p> Lognormal, where p1 = meanlog and p2 = sdlog (see <a href="stats.html#topic+plnorm">plnorm</a>).
</p>
</li></ol>



<h3>Value</h3>

<p>a list of list
</p>

<hr>
<h2 id='check_pvec'>Does a model object specify a correct p.vector</h2><span id='topic+check_pvec'></span>

<h3>Description</h3>

<p>Check a parameter vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pvec(p.vector, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pvec_+3A_p.vector">p.vector</code></td>
<td>
<p>parameter vector</p>
</td></tr>
<tr><td><code id="check_pvec_+3A_model">model</code></td>
<td>
<p>a model object</p>
</td></tr>
</table>

<hr>
<h2 id='ConvertChains'>Prepare posterior samples for plotting functions version 1</h2><span id='topic+ConvertChains'></span>

<h3>Description</h3>

<p>Convert MCMC chains to a data frame for plotting functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvertChains(x, start = 1, end = NA, pll = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConvertChains_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="ConvertChains_+3A_start">start</code></td>
<td>
<p>which iteration to start</p>
</td></tr>
<tr><td><code id="ConvertChains_+3A_end">end</code></td>
<td>
<p>end at which iteration</p>
</td></tr>
<tr><td><code id="ConvertChains_+3A_pll">pll</code></td>
<td>
<p>a Boolean switch to make posterior log likelihood</p>
</td></tr>
</table>

<hr>
<h2 id='dbeta_lu'>A modified dbeta function</h2><span id='topic+dbeta_lu'></span>

<h3>Description</h3>

<p>A modified dbeta function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbeta_lu(x, p1, p2, lower, upper, lg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbeta_lu_+3A_x">x</code></td>
<td>
<p>quantile</p>
</td></tr>
<tr><td><code id="dbeta_lu_+3A_p1">p1</code></td>
<td>
<p>shape1 parameter</p>
</td></tr>
<tr><td><code id="dbeta_lu_+3A_p2">p2</code></td>
<td>
<p>shape2 parameter</p>
</td></tr>
<tr><td><code id="dbeta_lu_+3A_lower">lower</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="dbeta_lu_+3A_upper">upper</code></td>
<td>
<p>upper bound</p>
</td></tr>
<tr><td><code id="dbeta_lu_+3A_lg">lg</code></td>
<td>
<p>logical; if TRUE, return log density.</p>
</td></tr>
</table>

<hr>
<h2 id='dcauchy_l'>A modified dcauchy functions</h2><span id='topic+dcauchy_l'></span>

<h3>Description</h3>

<p>A modified dcauchy functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcauchy_l(x, p1, p2, lg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcauchy_l_+3A_x">x</code></td>
<td>
<p>quantile</p>
</td></tr>
<tr><td><code id="dcauchy_l_+3A_p1">p1</code></td>
<td>
<p>location parameter</p>
</td></tr>
<tr><td><code id="dcauchy_l_+3A_p2">p2</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="dcauchy_l_+3A_lg">lg</code></td>
<td>
<p>log density?</p>
</td></tr>
</table>

<hr>
<h2 id='dconstant'>A pseudo constant function to get constant densities</h2><span id='topic+dconstant'></span>

<h3>Description</h3>

<p>Used with constant prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dconstant(x, p1, p2, lower, upper, lg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dconstant_+3A_x">x</code></td>
<td>
<p>quantile</p>
</td></tr>
<tr><td><code id="dconstant_+3A_p1">p1</code></td>
<td>
<p>constant value</p>
</td></tr>
<tr><td><code id="dconstant_+3A_p2">p2</code></td>
<td>
<p>unused argument</p>
</td></tr>
<tr><td><code id="dconstant_+3A_lower">lower</code></td>
<td>
<p>dummy varlable</p>
</td></tr>
<tr><td><code id="dconstant_+3A_upper">upper</code></td>
<td>
<p>dummy varlable</p>
</td></tr>
<tr><td><code id="dconstant_+3A_lg">lg</code></td>
<td>
<p>log density?</p>
</td></tr>
</table>

<hr>
<h2 id='deviance.model'>Calculate the statistics of model complexity</h2><span id='topic+deviance.model'></span>

<h3>Description</h3>

<p>Calculate deviance for a model object for which a
log-likelihood value can be obtained, according to the formula
-2*log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model'
deviance(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.model_+3A_object">object</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="deviance.model_+3A_...">...</code></td>
<td>
<p>other plotting arguments passing through dot dot dot.</p>
</td></tr>
</table>

<hr>
<h2 id='dgamma_l'>A modified dgamma function</h2><span id='topic+dgamma_l'></span>

<h3>Description</h3>

<p>A modified dgamma function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgamma_l(x, p1, p2, lower, upper, lg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgamma_l_+3A_x">x</code></td>
<td>
<p>quantile</p>
</td></tr>
<tr><td><code id="dgamma_l_+3A_p1">p1</code></td>
<td>
<p>shape parameter</p>
</td></tr>
<tr><td><code id="dgamma_l_+3A_p2">p2</code></td>
<td>
<p>scale parameter</p>
</td></tr>
<tr><td><code id="dgamma_l_+3A_lower">lower</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="dgamma_l_+3A_upper">upper</code></td>
<td>
<p>upper bound</p>
</td></tr>
<tr><td><code id="dgamma_l_+3A_lg">lg</code></td>
<td>
<p>log density?</p>
</td></tr>
</table>

<hr>
<h2 id='DIC'>Deviance information criteria</h2><span id='topic+DIC'></span><span id='topic+BPIC'></span>

<h3>Description</h3>

<p>Calculate DIC and BPIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC(object, ...)

BPIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_+3A_object">object</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="DIC_+3A_...">...</code></td>
<td>
<p>other plotting arguments passing through dot dot dot.</p>
</td></tr>
</table>

<hr>
<h2 id='dlnorm_l'>A modified dlnorm functions</h2><span id='topic+dlnorm_l'></span>

<h3>Description</h3>

<p>A modified dlnorm functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlnorm_l(x, p1, p2, lower, upper, lg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlnorm_l_+3A_x">x</code></td>
<td>
<p>quantile</p>
</td></tr>
<tr><td><code id="dlnorm_l_+3A_p1">p1</code></td>
<td>
<p>meanlog parameter</p>
</td></tr>
<tr><td><code id="dlnorm_l_+3A_p2">p2</code></td>
<td>
<p>sdlog parameter</p>
</td></tr>
<tr><td><code id="dlnorm_l_+3A_lower">lower</code></td>
<td>
<p>lower bound</p>
</td></tr>
<tr><td><code id="dlnorm_l_+3A_upper">upper</code></td>
<td>
<p>upper bound</p>
</td></tr>
<tr><td><code id="dlnorm_l_+3A_lg">lg</code></td>
<td>
<p>log density?</p>
</td></tr>
</table>

<hr>
<h2 id='dtnorm'>Truncated Normal Distribution</h2><span id='topic+dtnorm'></span><span id='topic+rtnorm'></span><span id='topic+ptnorm'></span>

<h3>Description</h3>

<p>Random number generation, probability density and cumulative density
functions for truncated normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtnorm(x, p1, p2, lower, upper, lg = FALSE)

rtnorm(n, p1, p2, lower, upper)

ptnorm(q, p1, p2, lower, upper, lt = TRUE, lg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtnorm_+3A_x">x</code>, <code id="dtnorm_+3A_q">q</code></td>
<td>
<p>vector of quantiles;</p>
</td></tr>
<tr><td><code id="dtnorm_+3A_p1">p1</code></td>
<td>
<p>mean (must be scalar).</p>
</td></tr>
<tr><td><code id="dtnorm_+3A_p2">p2</code></td>
<td>
<p>standard deviation (must be scalar).</p>
</td></tr>
<tr><td><code id="dtnorm_+3A_lower">lower</code></td>
<td>
<p>lower truncation value (must be scalar).</p>
</td></tr>
<tr><td><code id="dtnorm_+3A_upper">upper</code></td>
<td>
<p>upper truncation value (must be scalar).</p>
</td></tr>
<tr><td><code id="dtnorm_+3A_lg">lg</code></td>
<td>
<p>log probability. If TRUE (default is FALSE) probabilities p are
given as <code>log(p)</code>.</p>
</td></tr>
<tr><td><code id="dtnorm_+3A_n">n</code></td>
<td>
<p>number of observations. n must be a scalar.</p>
</td></tr>
<tr><td><code id="dtnorm_+3A_lt">lt</code></td>
<td>
<p>lower tail. If TRUE (default) probabilities are <code>P[X &lt;= x]</code>,
otherwise, <code>P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a column vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## rtn example
dat1 &lt;- rtnorm(1e5, 0, 1, 0, Inf)
hist(dat1, breaks = "fd", freq = FALSE, xlab = "",
     main = "Truncated normal distributions")

## dtn example
x &lt;- seq(-5, 5, length.out = 1e3)
dat1 &lt;- dtnorm(x, 0, 1, -2, 2, 0)
plot(x, dat1, type = "l", lwd = 2, xlab = "", ylab= "Density",
     main = "Truncated normal distributions")

## ptn example
x &lt;- seq(-10, 10, length.out = 1e2)
mean &lt;- 0
sd &lt;- 1
lower &lt;- 0
upper &lt;- 5
dat1 &lt;- ptnorm(x, 0, 1, 0, 5, lg = TRUE)
</code></pre>

<hr>
<h2 id='effectiveSize_hyper'>Calculate effective sample sizes</h2><span id='topic+effectiveSize_hyper'></span><span id='topic+effectiveSize_many'></span><span id='topic+effectiveSize_one'></span><span id='topic+effectiveSize'></span>

<h3>Description</h3>

<p><code>effectiveSize</code> calls <code>effectiveSize</code> in <span class="pkg">coda</span> package to
calculate sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectiveSize_hyper(x, start, end, digits, verbose)

effectiveSize_many(x, start, end, verbose)

effectiveSize_one(x, start, end, digits, verbose)

effectiveSize(x, hyper = FALSE, start = 1, end = NA, digits = 0,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectiveSize_hyper_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="effectiveSize_hyper_+3A_start">start</code></td>
<td>
<p>starting iteration</p>
</td></tr>
<tr><td><code id="effectiveSize_hyper_+3A_end">end</code></td>
<td>
<p>ending iteraton</p>
</td></tr>
<tr><td><code id="effectiveSize_hyper_+3A_digits">digits</code></td>
<td>
<p>printing how many digits</p>
</td></tr>
<tr><td><code id="effectiveSize_hyper_+3A_verbose">verbose</code></td>
<td>
<p>printing more information</p>
</td></tr>
<tr><td><code id="effectiveSize_hyper_+3A_hyper">hyper</code></td>
<td>
<p>a Boolean switch to extract hyper attribute</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#################################40
## effectiveSize example
#################################40
## Not run: 
es1 &lt;- effectiveSize_one(hsam[[1]], 1, 100, 2, TRUE)
es2 &lt;- effectiveSize_one(hsam[[1]], 1, 100, 2, FALSE)
es3 &lt;- effectiveSize_many(hsam, 1, 100, TRUE)
es4 &lt;- effectiveSize_many(hsam, 1, 100, FALSE)
es5 &lt;- effectiveSize_hyper(hsam, 1, 100, 2, TRUE)
es6 &lt;- effectiveSize(hsam, TRUE, 1, 100, 2, TRUE)
es7 &lt;- effectiveSize(hsam, TRUE, 1, 100, 2, FALSE)
es8 &lt;- effectiveSize(hsam, FALSE, 1, 100, 2, TRUE)
es9 &lt;- effectiveSize(hsam, FALSE, 1, 100, 2, FALSE)
es10 &lt;- effectiveSize(hsam[[1]], FALSE, 1, 100, 2, TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='gelman'>Potential scale reduction factor</h2><span id='topic+gelman'></span><span id='topic+hgelman'></span>

<h3>Description</h3>

<p><code>gelman</code> function calls the function, <code>gelman.diag</code> in the
<span class="pkg">coda</span> package to calculates PSRF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gelman(x, hyper = FALSE, start = 1, end = NA, confidence = 0.95,
  transform = TRUE, autoburnin = FALSE, multivariate = TRUE,
  split = TRUE, subchain = FALSE, nsubchain = 3, digits = 2,
  verbose = FALSE, ...)

hgelman(x, start = 1, end = NA, confidence = 0.95,
  transform = TRUE, autoburnin = FALSE, split = TRUE,
  subchain = FALSE, nsubchain = 3, digits = 2, verbose = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gelman_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="gelman_+3A_hyper">hyper</code></td>
<td>
<p>a Boolean switch, indicating posterior samples are from
hierarchical modeling</p>
</td></tr>
<tr><td><code id="gelman_+3A_start">start</code></td>
<td>
<p>start iteration</p>
</td></tr>
<tr><td><code id="gelman_+3A_end">end</code></td>
<td>
<p>end iteration</p>
</td></tr>
<tr><td><code id="gelman_+3A_confidence">confidence</code></td>
<td>
<p>confident inteval</p>
</td></tr>
<tr><td><code id="gelman_+3A_transform">transform</code></td>
<td>
<p>turn on transform</p>
</td></tr>
<tr><td><code id="gelman_+3A_autoburnin">autoburnin</code></td>
<td>
<p>turn on auto burnin</p>
</td></tr>
<tr><td><code id="gelman_+3A_multivariate">multivariate</code></td>
<td>
<p>multivariate Boolean switch</p>
</td></tr>
<tr><td><code id="gelman_+3A_split">split</code></td>
<td>
<p>split whether split mcmc chains; When split is TRUE, the function
doubles the number of chains by spliting into 1st and 2nd halves.</p>
</td></tr>
<tr><td><code id="gelman_+3A_subchain">subchain</code></td>
<td>
<p>whether only calculate a subset of chains</p>
</td></tr>
<tr><td><code id="gelman_+3A_nsubchain">nsubchain</code></td>
<td>
<p>indicate how many chains in a subset</p>
</td></tr>
<tr><td><code id="gelman_+3A_digits">digits</code></td>
<td>
<p>print out how many digits</p>
</td></tr>
<tr><td><code id="gelman_+3A_verbose">verbose</code></td>
<td>
<p>print more information</p>
</td></tr>
<tr><td><code id="gelman_+3A_...">...</code></td>
<td>
<p>arguments passing to <code>coda</code> gelman.diag.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
rhat1 &lt;- hgelman(hsam); rhat1
rhat2 &lt;- hgelman(hsam, end = 51); rhat2
rhat3 &lt;- hgelman(hsam, confidence = .90); rhat3
rhat4 &lt;- hgelman(hsam, transform = FALSE); rhat4
rhat5 &lt;- hgelman(hsam, autoburnin = TRUE); rhat5
rhat6 &lt;- hgelman(hsam, split = FALSE); rhat6
rhat7 &lt;- hgelman(hsam, subchain = TRUE); rhat7
rhat8 &lt;- hgelman(hsam, subchain = TRUE, nsubchain = 4);
rhat9 &lt;- hgelman(hsam, subchain = TRUE, nsubchain = 4,
digits = 1, verbose = TRUE);

hat1 &lt;- gelman(hsam[[1]], multivariate = FALSE); hat1
hat2 &lt;- gelman(hsam[[1]], hyper = TRUE, verbose = TRUE); hat2
hat3 &lt;- gelman(hsam, hyper = TRUE, verbose = TRUE); hat3
hat4 &lt;- gelman(hsam, multivariate = TRUE, verbose = FALSE);
hat5 &lt;- gelman(hsam, multivariate = FALSE, verbose = FALSE);
hat6 &lt;- gelman(hsam, multivariate = FALSE, verbose = TRUE);
hat7 &lt;- gelman(hsam, multivariate = T, verbose = TRUE);

## End(Not run)
</code></pre>

<hr>
<h2 id='get_os'>Retrieve information of operating system</h2><span id='topic+get_os'></span>

<h3>Description</h3>

<p>A wrapper function to extract system information from <code>Sys.info</code>
and <code>.Platform</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_os()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>get_os()
## sysname
## "linux"
</code></pre>

<hr>
<h2 id='GetNsim'>Get a n-cell matrix</h2><span id='topic+GetNsim'></span>

<h3>Description</h3>

<p>Constructs a matrix, showing how many responses to in each
cell. The function checks whether the format of <code>n</code> and <code>ns</code>
conform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetNsim(model, n, ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetNsim_+3A_model">model</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="GetNsim_+3A_n">n</code></td>
<td>
<p>number of trials.</p>
</td></tr>
<tr><td><code id="GetNsim_+3A_ns">ns</code></td>
<td>
<p>number of subjects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>n</code> can be:
</p>

<ol>
<li><p> an integer for a balanced design,
</p>
</li>
<li><p> a matrix for an unbalanced design, where rows are subjects and
columns are cells. If the matrix is a row vector, all subjects
have the same <code>n</code> in each cell. If it is a column vector, all
cells have the same <code>n</code>. Otherwise each entry specifies the <code>n</code>
for a particular subject x cell combination. See below for concrete
examples.</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- BuildModel(
  p.map     = list(A = "1", B = "R", t0 = "1", mean_v = "M", sd_v = "M",
                  st0 = "1"),
  match.map = list(M = list(s1 = 1, s2 = 2)),
  constants = c(sd_v.false = 1, st0 = 0),
  factors   = list(S = c("s1","s2")),
  responses = c("r1", "r2"),
  type      = "norm")

#######################30
## Example 1
#######################30
GetNsim(model, ns = 2, n = 1)
#      [,1] [,2]
# [1,]    1    1
# [2,]    1    1

#######################30
## Example 2
#######################30
n &lt;- matrix(c(1:2), ncol = 1)
#      [,1]
# [1,]    1  ## subject 1 has 1 response for each cell
# [2,]    2  ## subject 2 has 2 responses for each cell

GetNsim(model, ns = 2, n = n)
#      [,1] [,2]
# [1,]    1    1
# [2,]    2    2

#######################30
## Example 3
#######################30
n &lt;- matrix(c(1:2), nrow = 1)
#      [,1] [,2]
# [1,]    1    2
GetNsim(model, ns = 2, n = n)
#     [,1] [,2]
# [1,]   1    2 ## subject 1 has 1 response for cell 1 and 2 responses for cell 2
# [2,]   1    2 ## subject 2 has 1 response for cell 1 and 2 responses for cell 2

#######################30
## Example 4
#######################30
n &lt;- matrix(c(1:4), nrow=2)
#      [,1] [,2]
# [1,]    1    3
# [2,]    2    4
ggdmc::GetNsim(model, ns = 2, n = n)
#      [,1] [,2]
# [1,]    1    3 ## subject 1 has 1 response for cell 1 and 3 responses for cell 2
# [2,]    2    4 ## subject 2 has 2 responses for cell 1 and 4 responses for cell 2
</code></pre>

<hr>
<h2 id='GetParameterMatrix'>Constructs a ns x npar matrix,</h2><span id='topic+GetParameterMatrix'></span>

<h3>Description</h3>

<p>The matrix is used to simulate data. Each row represents one set of
parameters for a participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetParameterMatrix(x, nsub, prior = NA, ps = NA, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetParameterMatrix_+3A_x">x</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="GetParameterMatrix_+3A_nsub">nsub</code></td>
<td>
<p>number of subjects.</p>
</td></tr>
<tr><td><code id="GetParameterMatrix_+3A_prior">prior</code></td>
<td>
<p>a prior object</p>
</td></tr>
<tr><td><code id="GetParameterMatrix_+3A_ps">ps</code></td>
<td>
<p>a vector or a matirx.</p>
</td></tr>
<tr><td><code id="GetParameterMatrix_+3A_seed">seed</code></td>
<td>
<p>an integer specifying a random seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One must enter either a vector or a matrix as true parameters
to the argument, <code>ps</code>, when presuming to simulate data based on a
fixed-effect model. When the assumption is to simulate data based on a
random-effect model, one must enter a prior object to the argument,
<code>prior</code> to first randomly generate a true parameter matrix.
</p>


<h3>Value</h3>

<p>a ns x npar matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- BuildModel(
p.map     = list(a ="1", v = "1",z = "1", d = "1", sz = "1", sv = "1",
            t0 = "1", st0 = "1"),
match.map = list(M = list(s1 = "r1", s2 ="r2")),
factors   = list(S = c("s1", "s2")),
constants = c(st0 = 0, d = 0),
responses = c("r1", "r2"),
type      = "rd")

p.prior &lt;- BuildPrior(
  dists = c("tnorm", "tnorm", "beta", "beta", "tnorm", "beta"),
  p1    = c(a = 1, v = 0, z = 1, sz = 1, sv = 1, t0 = 1),
  p2    = c(a = 1, v = 2, z = 1, sz = 1, sv = 1, t0 = 1),
  lower = c(0, -5, NA, NA, 0, NA),
  upper = c(2,  5, NA, NA, 2, NA))

## Example 1: Randomly generate 2 sets of true parameters from
## parameter priors (p.prior)
GetParameterMatrix(model, 2, p.prior)
##            a         v         z        sz       sv        t0
## [1,] 1.963067  1.472940 0.9509158 0.5145047 1.344705 0.0850591
## [2,] 1.512276 -1.995631 0.6981290 0.2626882 1.867853 0.1552828

## Example 2: Use a user-selected true parameters
true.vector  &lt;- c(a=1, v=1, z=0.5, sz=0.2, sv=1, t0=.15)
GetParameterMatrix(model, 2, NA, true.vector)
##      a v   z  sz sv   t0
## [1,] 1 1 0.5 0.2  1 0.15
## [2,] 1 1 0.5 0.2  1 0.15
GetParameterMatrix(model, 2, ps = true.vector)

## Example 3: When a user enter arbritary sequence of parameters.
## Note sv is before sz. It should be sz before sv
## See correct sequence, by entering "attr(model, 'p.vector')"
## GetParameterMatrix will rearrange the sequence.
true.vector  &lt;- c(a=1, v=1, z=0.5, sv=1, sz = .2, t0=.15)
GetParameterMatrix(model, 2, NA, true.vector)
##      a v   z  sz sv   t0
## [1,] 1 1 0.5 0.2  1 0.15
## [2,] 1 1 0.5 0.2  1 0.15

</code></pre>

<hr>
<h2 id='GetPNames'>Extract parameter names from a model object</h2><span id='topic+GetPNames'></span>

<h3>Description</h3>

<p>Extract parameter names from a model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetPNames(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetPNames_+3A_x">x</code></td>
<td>
<p>a model object</p>
</td></tr>
</table>

<hr>
<h2 id='iseffective'>Model checking functions</h2><span id='topic+iseffective'></span>

<h3>Description</h3>

<p>The function tests whether we have drawn enough samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iseffective(x, minN, nfun, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iseffective_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="iseffective_+3A_minn">minN</code></td>
<td>
<p>specify the size of minimal effective samples</p>
</td></tr>
<tr><td><code id="iseffective_+3A_nfun">nfun</code></td>
<td>
<p>specify to use the <code>mean</code> or <code>median</code> function to
calculate effective samples</p>
</td></tr>
<tr><td><code id="iseffective_+3A_verbose">verbose</code></td>
<td>
<p>print more information</p>
</td></tr>
</table>

<hr>
<h2 id='isflat'>Model checking functions</h2><span id='topic+isflat'></span>

<h3>Description</h3>

<p>The function tests whether Markov chains converge prematurelly:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isflat(x, p1 = 1/3, p2 = 1/3, cut_location = 0.25, cut_scale = Inf,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isflat_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="isflat_+3A_p1">p1</code></td>
<td>
<p>the range of the head of MCMC chains</p>
</td></tr>
<tr><td><code id="isflat_+3A_p2">p2</code></td>
<td>
<p>the range of the tail of the MCMC chains</p>
</td></tr>
<tr><td><code id="isflat_+3A_cut_location">cut_location</code></td>
<td>
<p>how far away a location chains been considered as stuck</p>
</td></tr>
<tr><td><code id="isflat_+3A_cut_scale">cut_scale</code></td>
<td>
<p>how far away a scale chains been considered as stuck</p>
</td></tr>
<tr><td><code id="isflat_+3A_verbose">verbose</code></td>
<td>
<p>print more information</p>
</td></tr>
</table>

<hr>
<h2 id='ismixed'>Model checking functions</h2><span id='topic+ismixed'></span>

<h3>Description</h3>

<p>The function tests whether Markov chains are mixed well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ismixed(x, cut = 1.01, split = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ismixed_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="ismixed_+3A_cut">cut</code></td>
<td>
<p>psrf criterion for well mixed</p>
</td></tr>
<tr><td><code id="ismixed_+3A_split">split</code></td>
<td>
<p>whether to split MCMC chains. This is an argument passing to
<code>gelman</code> function</p>
</td></tr>
<tr><td><code id="ismixed_+3A_verbose">verbose</code></td>
<td>
<p>print more information</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gelman">gelman</a></code>)
</p>

<hr>
<h2 id='isstuck'>Model checking functions</h2><span id='topic+isstuck'></span><span id='topic+CheckConverged'></span>

<h3>Description</h3>

<p>The function tests whether Markov chains encounter a parameter
region that is difficult to search. <code>CheckConverged</code> is
a wrapper function running the four checking functions,
<code>isstuck</code>, <code>isflat</code>, <code>ismixed</code> and <code>iseffective</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isstuck(x, hyper = FALSE, cut = 10, start = 1, end = NA,
  verbose = FALSE)

CheckConverged(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isstuck_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="isstuck_+3A_hyper">hyper</code></td>
<td>
<p>a Boolean switch, extracting hyper attribute.</p>
</td></tr>
<tr><td><code id="isstuck_+3A_cut">cut</code></td>
<td>
<p>the criteria for suggesting abnormal chains found</p>
</td></tr>
<tr><td><code id="isstuck_+3A_start">start</code></td>
<td>
<p>start iteration</p>
</td></tr>
<tr><td><code id="isstuck_+3A_end">end</code></td>
<td>
<p>end iteration</p>
</td></tr>
<tr><td><code id="isstuck_+3A_verbose">verbose</code></td>
<td>
<p>print more information</p>
</td></tr>
</table>

<hr>
<h2 id='likelihood'>Calculate log likelihoods</h2><span id='topic+likelihood'></span>

<h3>Description</h3>

<p>These function calculate log likelihoods. <code>likelihood_rd</code> implements
the equations in Voss, Rothermund, and Voss (2004). These equations
calculate diffusion decision model (Ratcliff &amp; Mckoon, 2008). Specifically,
this function implements Voss, Rothermund, and Voss's (2004) equations A1
to A4 (page 1217) in C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood(pvector, data, min_lik = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_+3A_pvector">pvector</code></td>
<td>
<p>a parameter vector</p>
</td></tr>
<tr><td><code id="likelihood_+3A_data">data</code></td>
<td>
<p>data model instance</p>
</td></tr>
<tr><td><code id="likelihood_+3A_min_lik">min_lik</code></td>
<td>
<p>minimal likelihood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector
</p>


<h3>References</h3>

<p>Voss, A., Rothermund, K., &amp; Voss, J. (2004).  Interpreting the
parameters of the diffusion model: An empirical validation.
<em>Memory &amp; Cognition</em>, <b>32(7)</b>, 1206-1220. <br /><br />
Ratcliff, R. (1978). A theory of memory retrival. <em>Psychological
Review</em>, <b>85</b>, 238-255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- BuildModel(
p.map     = list(A = "1", B = "1", t0 = "1", mean_v = "M", sd_v = "1",
            st0 = "1"),
match.map = list(M = list(s1 = 1, s2 = 2)),
factors   = list(S = c("s1", "s2")),
constants = c(st0 = 0, sd_v = 1),
responses = c("r1", "r2"),
type      = "norm")

p.vector &lt;- c(A = .25, B = .35,  t0 = .2, mean_v.true = 1, mean_v.false = .25)
dat &lt;- simulate(model, 1e3,  ps = p.vector)
dmi &lt;- BuildDMI(dat, model)
den &lt;- likelihood(p.vector, dmi)

model &lt;- BuildModel(
p.map     = list(a = "1", v = "1", z = "1", d = "1", t0 = "1", sv = "1",
            sz = "1", st0 = "1"),
constants = c(st0 = 0, d = 0),
match.map = list(M = list(s1 = "r1", s2 = "r2")),
factors   = list(S = c("s1", "s2")),
responses = c("r1", "r2"),
type      = "rd")

p.vector &lt;- c(a = 1, v = 1, z = 0.5, sz = 0.25, sv = 0.2, t0 = .15)
dat &lt;- simulate(model, 1e2, ps = p.vector)
dmi &lt;- BuildDMI(dat, model)
den &lt;- likelihood (p.vector, dmi)

</code></pre>

<hr>
<h2 id='mcmc_list.model'>Create a MCMC list</h2><span id='topic+mcmc_list.model'></span>

<h3>Description</h3>

<p>Create a MCMC list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_list.model(x, start = 1, end = NA, pll = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_list.model_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="mcmc_list.model_+3A_start">start</code></td>
<td>
<p>start from which iteration</p>
</td></tr>
<tr><td><code id="mcmc_list.model_+3A_end">end</code></td>
<td>
<p>end at which iteration</p>
</td></tr>
<tr><td><code id="mcmc_list.model_+3A_pll">pll</code></td>
<td>
<p>a Boolean switch for calculating posterior log-likelihood</p>
</td></tr>
</table>

<hr>
<h2 id='PickStuck'>Which chains get stuck</h2><span id='topic+PickStuck'></span>

<h3>Description</h3>

<p>Calculate each chain separately for the mean (across many MCMC iterations)
of posterior log-likelihood. If the difference of the means and
the median (across chains) of the mean of posterior is greater than the
<code>cut</code>, chains are considered stuck. The default value for <code>cut</code>
is 10. <code>unstick</code> manually removes stuck chains from posterior samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PickStuck(x, hyper = FALSE, cut = 10, start = 1, end = NA,
  verbose = FALSE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PickStuck_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="PickStuck_+3A_hyper">hyper</code></td>
<td>
<p>whether x are hierarhcial samples</p>
</td></tr>
<tr><td><code id="PickStuck_+3A_cut">cut</code></td>
<td>
<p>a criterion deciding if a chain is stuck.</p>
</td></tr>
<tr><td><code id="PickStuck_+3A_start">start</code></td>
<td>
<p>start to evaluate from which iteration.</p>
</td></tr>
<tr><td><code id="PickStuck_+3A_end">end</code></td>
<td>
<p>end at which iteration for evaeuation.</p>
</td></tr>
<tr><td><code id="PickStuck_+3A_verbose">verbose</code></td>
<td>
<p>a boolean switch to print more information</p>
</td></tr>
<tr><td><code id="PickStuck_+3A_digits">digits</code></td>
<td>
<p>print how many digits. Default is 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PickStuck</code> gives an index vector; <code>unstick</code> gives a DMC
sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model &lt;- BuildModel(
p.map     = list(A = "1", B = "1", t0 = "1", mean_v = "M", sd_v = "1", st0 = "1"),
match.map = list(M = list(s1 = 1, s2 = 2)),
factors   = list(S = c("s1", "s2")),
constants = c(st0 = 0, sd_v = 1),
responses = c("r1", "r2"),
type      = "norm")
p.vector &lt;- c(A = .75, B = .25, t0 = .2, mean_v.true = 2.5, mean_v.false = 1.5)

p.prior &lt;- BuildPrior(
  dists = c("tnorm", "tnorm", "beta", "tnorm", "tnorm"),
  p1    = c(A = .3, B = .3, t0 = 1, mean_v.true = 1, mean_v.false = 0),
  p2    = c(1, 1,   1, 3, 3),
  lower = c(0,  0,  0, NA, NA),
  upper = c(NA,NA,  1, NA, NA))

## Not run: 
dat &lt;- simulate(model, 30, ps = p.vector)
dmi &lt;- BuildDMI(dat, model)
sam &lt;- run(StartNewsamples(dmi, p.prior))
bad &lt;- PickStuck(sam)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_prior'>Plot prior distributions</h2><span id='topic+plot_prior'></span><span id='topic+plot.prior'></span>

<h3>Description</h3>

<p><code>plot_prior</code> plots one member in a prior object. <code>plot.prior</code>
plots all members in a prior object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_prior(i, prior, xlim = NA, natural = TRUE, npoint = 100,
  trans = NA, save = FALSE, ...)

## S3 method for class 'prior'
plot(x, save = FALSE, ps = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_prior_+3A_i">i</code></td>
<td>
<p>an integer or a character string indicating which parameter to plot</p>
</td></tr>
<tr><td><code id="plot_prior_+3A_prior">prior</code></td>
<td>
<p>a prior object</p>
</td></tr>
<tr><td><code id="plot_prior_+3A_xlim">xlim</code></td>
<td>
<p>set the range of on x axis. This is usually the range for each
parameter.</p>
</td></tr>
<tr><td><code id="plot_prior_+3A_natural">natural</code></td>
<td>
<p>default TRUE.</p>
</td></tr>
<tr><td><code id="plot_prior_+3A_npoint">npoint</code></td>
<td>
<p>default to plot 100</p>
</td></tr>
<tr><td><code id="plot_prior_+3A_trans">trans</code></td>
<td>
<p>default NA. trans can be a scalar or vector.</p>
</td></tr>
<tr><td><code id="plot_prior_+3A_save">save</code></td>
<td>
<p>whether to save the data out</p>
</td></tr>
<tr><td><code id="plot_prior_+3A_...">...</code></td>
<td>
<p>other plotting arguments passing through dot dot dot.</p>
</td></tr>
<tr><td><code id="plot_prior_+3A_x">x</code></td>
<td>
<p>a prior object</p>
</td></tr>
<tr><td><code id="plot_prior_+3A_ps">ps</code></td>
<td>
<p>true parameter vectors or matrix in the case of many observation
units</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p.prior &lt;- BuildPrior(
           dists = rep("tnorm", 7),
           p1    = c(a = 2,   v.f1 = 4,  v.f2 = 3,  z = 0.5, sv = 1,
                     sz = 0.3, t0 = 0.3),
           p2    = c(a = 0.5, v.f1 = .5, v.f2 = .5, z = 0.1, sv = .3,
                     sz = 0.1, t0 = 0.05),
           lower = c(0,-5, -5, 0, 0, 0, 0),
           upper = c(5, 7,  7, 1, 2, 1, 1))

plot_prior("a", p.prior)
plot_prior(2, p.prior)
plot(p.prior)
</code></pre>

<hr>
<h2 id='print.prior'>Print Prior Distribution</h2><span id='topic+print.prior'></span>

<h3>Description</h3>

<p>a convenient function to rearrange <code>p.prior</code> or an element in a
<code>pp.prior</code> as a data frame for inspection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prior'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.prior_+3A_x">x</code></td>
<td>
<p>a list of prior distributions list, usually created by
<code>BuildPrior</code></p>
</td></tr>
<tr><td><code id="print.prior_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame listing prior distributions and their settings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pop.mean  &lt;- c(a=1,  v.f1=1,  v.f2=.2, z=.5, sz=.3,  sv.f1=.25, sv.f2=.23,
               t0=.3)
pop.scale &lt;- c(a=.2, v.f1=.2, v.f2=.2, z=.1, sz=.05, sv.f1=.05, sv.f2=.05,
               t0=.05)

p.prior &lt;- BuildPrior(
  dists = rep("tnorm", 8),
  p1    = pop.mean,
  p2    = pop.scale,
  lower = c(0, -5, -5, 0, 0, 0, 0, 0),
  upper = c(2,  5,  5, 1, 2, 2, 1, 1))

print(p.prior)
</code></pre>

<hr>
<h2 id='random'>Generate random numbers</h2><span id='topic+random'></span>

<h3>Description</h3>

<p>A wrapper function for generating random numbers of either
the model type, <code>rd</code>, or <code>norm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random(type, pmat, n, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_+3A_type">type</code></td>
<td>
<p>a character string of the model type</p>
</td></tr>
<tr><td><code id="random_+3A_pmat">pmat</code></td>
<td>
<p>a matrix of response x parameter</p>
</td></tr>
<tr><td><code id="random_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="random_+3A_seed">seed</code></td>
<td>
<p>an integer specifying a random seed</p>
</td></tr>
</table>

<hr>
<h2 id='rlba_norm'>Generate Random Deviates of the LBA Distribution</h2><span id='topic+rlba_norm'></span>

<h3>Description</h3>

<p><code>rlba_norm</code>, only slightly faster than <code>maker</code>, calls C++
function directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlba_norm(n, A, b, mean_v, sd_v, t0, st0, posdrift)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlba_norm_+3A_n">n</code></td>
<td>
<p>is the numbers of observation.</p>
</td></tr>
<tr><td><code id="rlba_norm_+3A_a">A</code></td>
<td>
<p>start point upper bound, a vector of a scalar.</p>
</td></tr>
<tr><td><code id="rlba_norm_+3A_b">b</code></td>
<td>
<p>decision threshold, a vector or a scalar.</p>
</td></tr>
<tr><td><code id="rlba_norm_+3A_mean_v">mean_v</code></td>
<td>
<p>mean drift rate vector</p>
</td></tr>
<tr><td><code id="rlba_norm_+3A_sd_v">sd_v</code></td>
<td>
<p>standard deviation of drift rate vector</p>
</td></tr>
<tr><td><code id="rlba_norm_+3A_t0">t0</code></td>
<td>
<p>nondecision time, a vector.</p>
</td></tr>
<tr><td><code id="rlba_norm_+3A_st0">st0</code></td>
<td>
<p>nondecision time variation, a vector.</p>
</td></tr>
<tr><td><code id="rlba_norm_+3A_posdrift">posdrift</code></td>
<td>
<p>if exclude negative drift rates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a n x 2 matrix of RTs (first column) and responses (second column).
</p>

<hr>
<h2 id='rprior'>Parameter Prior Distributions</h2><span id='topic+rprior'></span>

<h3>Description</h3>

<p>Probability density functions and random generation for parameter prior
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rprior(prior, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rprior_+3A_prior">prior</code></td>
<td>
<p>a list of list usually created by BuildPrior to store the
information about parameter prior distributions.</p>
</td></tr>
<tr><td><code id="rprior_+3A_n">n</code></td>
<td>
<p>number of observations/random draws</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>p.prior &lt;- BuildPrior(
 dists = c("tnorm", "tnorm", "beta", "tnorm", "beta", "beta"),
 p1    = c(a = 1, v = 0, z = 1, sz = 1, sv = 1, t0 = 1),
 p2    = c(a = 1, v = 2, z = 1, sz = 1, sv = 1, t0 = 1),
 lower = c(0,-5, NA, NA, 0, NA),
 upper = c(2, 5, NA, NA, 2, NA))

rprior(p.prior, 9)
##               a           v         z         sz        sv         t0
## [1,] 0.97413686  0.78446178 0.9975199 -0.5264946 0.5364492 0.55415052
## [2,] 0.72870190  0.97151662 0.8516604  1.6008591 0.3399731 0.96520848
## [3,] 1.63153685  1.96586939 0.9260939  0.7041254 0.4138329 0.78367440
## [4,] 1.55866180  1.43657110 0.6152371  0.1290078 0.2957604 0.23027759
## [5,] 1.32520281 -0.07328408 0.2051155  2.4040387 0.9663111 0.06127237
## [6,] 0.49628528 -0.19374770 0.5142829  2.1452972 0.4335482 0.38410626
## [7,] 0.03655549  0.77223432 0.1739831  1.4431507 0.6257398 0.63228368
## [8,] 0.71197612 -1.15798082 0.8265523  0.3813370 0.4465184 0.23955415
## [9,] 0.38049166  3.32132034 0.9888108  0.9684292 0.8437480 0.13502154

pvec &lt;- c(a=1, v=1, z=0.5, sz=0.25, sv=0.2,t0=.15)
p.prior  &lt;- BuildPrior(
  dists = rep("tnorm", 6),
  p1    = c(a=2,   v=2.5, z=0.5, sz=0.3, sv=1,  t0=0.3),
  p2    = c(a=0.5, v=.5,  z=0.1, sz=0.1, sv=.3, t0=0.05) * 5,
  lower = c(0,-5, 0, 0, 0, 0),
  upper = c(5, 7, 2, 2, 2, 2))

</code></pre>

<hr>
<h2 id='simulate.model'>Simulate response time data</h2><span id='topic+simulate.model'></span>

<h3>Description</h3>

<p>Simulate response time data either for one subject or multiple subjects.
The simulation is based on a model object. For one subject, one must supply
a true parameter vector to the <code>ps</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model'
simulate(object, nsim = NA, seed = NULL, nsub = NA,
  prior = NA, ps = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.model_+3A_object">object</code></td>
<td>
<p>a model object.</p>
</td></tr>
<tr><td><code id="simulate.model_+3A_nsim">nsim</code></td>
<td>
<p>number of trials / responses. <code>n</code> can be a single number
for a balanced design or a matrix for an unbalanced design, where rows
are subjects and columns are design cells. If the matrix has one row then
all subjects have the same <code>n</code> in each cell, if it has one column then
all cells have the same <code>n</code>; Otherwise each entry specifies the
<code>n</code> for a particular subject x design cell combination.</p>
</td></tr>
<tr><td><code id="simulate.model_+3A_seed">seed</code></td>
<td>
<p>a user specified random seed.</p>
</td></tr>
<tr><td><code id="simulate.model_+3A_nsub">nsub</code></td>
<td>
<p>number of subjects</p>
</td></tr>
<tr><td><code id="simulate.model_+3A_prior">prior</code></td>
<td>
<p>a prior object</p>
</td></tr>
<tr><td><code id="simulate.model_+3A_ps">ps</code></td>
<td>
<p>a true parameter vector or matrix.</p>
</td></tr>
<tr><td><code id="simulate.model_+3A_...">...</code></td>
<td>
<p>additional optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For multiple subjects, one can enter a matrix (or a row vector) as true
parameters. Each row is to generate data separately for a subject.  This is
the fixed-effect model. To generate data based on a random-effect
model, one must supply a prior object.  In this case, <code>ps</code> argument
is unused. Note in some cases, a random-effect model may fail to draw data
from the model, because true parameters are randomly drawn from
a prior object.  This would happen sometimes in diffusion model, because
certain parameter combinations are considered invalid.
</p>
<p><code>ps</code> can be a row vector, in which case each subject has identical
parameters.  It can also be a matrix with one row per subject, in which
case it must have <code>ns</code> rows. The true values will be saved as
<code>parameters</code> attribute in the output object.
</p>


<h3>Value</h3>

<p>a data frame
</p>

<hr>
<h2 id='StartNewsamples'>Start new model fits</h2><span id='topic+StartNewsamples'></span><span id='topic+run'></span>

<h3>Description</h3>

<p>Fit a hierarchical or a fixed-effect model, using Bayeisan
optimisation.  We use a specific type of pMCMC algorithm, the DE-MCMC. This
particular sampling method includes crossover and two different migration
operators. The migration operators are similar to random-walk algorithm.
They wouold be less efficient to find the target parameter space, if been
used alone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StartNewsamples(data, prior = NULL, nmc = 200, thin = 1,
  nchain = NULL, report = 100, rp = 0.001, gammamult = 2.38,
  pm0 = 0.05, pm1 = 0.05, block = TRUE, ncore = 1)

run(samples, nmc = 500, thin = 1, report = 100, rp = 0.001,
  gammamult = 2.38, pm0 = 0, pm1 = 0, block = TRUE, ncore = 1,
  add = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StartNewsamples_+3A_data">data</code></td>
<td>
<p>data model instance(s)</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_prior">prior</code></td>
<td>
<p>prior objects.  For hierarchical model, this must be a
list with three sets of prior distributions. Each is respectively named,
&quot;pprior&quot;, &quot;location&quot;, and &quot;scale&quot;.</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_nmc">nmc</code></td>
<td>
<p>number of Monte Carlo samples</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_thin">thin</code></td>
<td>
<p>thinning length</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_nchain">nchain</code></td>
<td>
<p>number of chains</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_report">report</code></td>
<td>
<p>progress report interval</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_rp">rp</code></td>
<td>
<p>tuning parameter 1</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_gammamult">gammamult</code></td>
<td>
<p>tuning parameter 2. This is the step size.</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_pm0">pm0</code></td>
<td>
<p>probability of migration type 0 (Hu &amp; Tsui, 2010)</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_pm1">pm1</code></td>
<td>
<p>probability of migration type 1 (Turner et al., 2013)</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_block">block</code></td>
<td>
<p>Only for hierarchical modeling. A Boolean switch for update one
parameter at a time</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_ncore">ncore</code></td>
<td>
<p>Only for non-hierarchical, fixed-effect models with many
subjects.</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_samples">samples</code></td>
<td>
<p>posterior samples.</p>
</td></tr>
<tr><td><code id="StartNewsamples_+3A_add">add</code></td>
<td>
<p>Boolean whether to add new samples</p>
</td></tr>
</table>

<hr>
<h2 id='summary_mcmc_list'>Summary statistic for posterior samples</h2><span id='topic+summary_mcmc_list'></span>

<h3>Description</h3>

<p>Calculate summary statistics for posterior samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_mcmc_list(object, prob = c(0.025, 0.25, 0.5, 0.75, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_mcmc_list_+3A_object">object</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="summary_mcmc_list_+3A_prob">prob</code></td>
<td>
<p>summary quantile summary</p>
</td></tr>
<tr><td><code id="summary_mcmc_list_+3A_...">...</code></td>
<td>
<p>other arguments passing in</p>
</td></tr>
</table>

<hr>
<h2 id='summary.model'>Summarise posterior samples</h2><span id='topic+summary.model'></span>

<h3>Description</h3>

<p>This calls seven different variants of summary function to summarise
posterior samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'model'
summary(object, hyper = FALSE, start = 1, end = NA,
  hmeans = FALSE, hci = FALSE, prob = c(0.025, 0.25, 0.5, 0.75,
  0.975), recovery = FALSE, ps = NA, type = 1, verbose = FALSE,
  digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.model_+3A_object">object</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="summary.model_+3A_hyper">hyper</code></td>
<td>
<p>whether to summarise hyper parameters</p>
</td></tr>
<tr><td><code id="summary.model_+3A_start">start</code></td>
<td>
<p>start from which iteration.</p>
</td></tr>
<tr><td><code id="summary.model_+3A_end">end</code></td>
<td>
<p>end at which iteration. For example, set
<code>start = 101</code> and <code>end = 1000</code>, instructs the function to
calculate from 101 to 1000 iteration.</p>
</td></tr>
<tr><td><code id="summary.model_+3A_hmeans">hmeans</code></td>
<td>
<p>a boolean switch indicating to calculate mean of hyper
parameters</p>
</td></tr>
<tr><td><code id="summary.model_+3A_hci">hci</code></td>
<td>
<p>boolean switch; whether to calculate credible intervals of
hyper parameters</p>
</td></tr>
<tr><td><code id="summary.model_+3A_prob">prob</code></td>
<td>
<p>a numeric vector, indicating the quantiles to calculate</p>
</td></tr>
<tr><td><code id="summary.model_+3A_recovery">recovery</code></td>
<td>
<p>a boolean switch indicating if samples are from a recovery
study</p>
</td></tr>
<tr><td><code id="summary.model_+3A_ps">ps</code></td>
<td>
<p>true parameter values.  This is only for recovery studies</p>
</td></tr>
<tr><td><code id="summary.model_+3A_type">type</code></td>
<td>
<p>calculate type 1 or 2 hyper parameters</p>
</td></tr>
<tr><td><code id="summary.model_+3A_verbose">verbose</code></td>
<td>
<p>print more information</p>
</td></tr>
<tr><td><code id="summary.model_+3A_digits">digits</code></td>
<td>
<p>printing digits</p>
</td></tr>
<tr><td><code id="summary.model_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
est1 &lt;- summary(hsam[[1]], FALSE)
est2 &lt;- summary(hsam[[1]], FALSE, 1, 100)

est3 &lt;- summary(hsam)
est4 &lt;- summary(hsam, verbose = TRUE)
est5 &lt;- summary(hsam, verbose = FALSE)

hest1 &lt;- summary(hsam, TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='TableParameters'>Table response and parameter</h2><span id='topic+TableParameters'></span>

<h3>Description</h3>

<p><code>TableParameters</code> arranges the values in a parameter
vector and creates a response x parameter matrix. The matrix is used
by the likelihood function, assigning a trial to a cell for calculating
probability densities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TableParameters(p.vector, cell, model, n1order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TableParameters_+3A_p.vector">p.vector</code></td>
<td>
<p>a parameter vector</p>
</td></tr>
<tr><td><code id="TableParameters_+3A_cell">cell</code></td>
<td>
<p>a string or an integer indicating a design cell, e.g.,
<code>s1.f1.r1</code> or 1. Note the integer cannot exceed the number of cell.
One can check this by entering <code>length(dimnames(model))</code>.</p>
</td></tr>
<tr><td><code id="TableParameters_+3A_model">model</code></td>
<td>
<p>a model object</p>
</td></tr>
<tr><td><code id="TableParameters_+3A_n1order">n1order</code></td>
<td>
<p>a Boolean switch, indicating using node 1 ordering. This is
only for LBA-like models and its n1PDF likelihood function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>each row corresponding to the model parameter for a response.
When <code>n1.order</code> is FALSE, TableParameters returns a martix without
rearranging into node 1 order.  For example, this is used in
the <code>simulate</code> function. By default <code>n1.order</code> is TRUE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- BuildModel(
  p.map     = list(a = "1", v = "F", z = "1", d = "1", sz = "1", sv = "F",
                   t0 = "1", st0 = "1"),
  match.map = list(M = list(s1 = "r1", s2 = "r2")),
  factors   = list(S = c("s1", "s2"), F = c("f1","f2")),
  constants = c(st0 = 0, d = 0),
  responses = c("r1","r2"),
  type      = "rd")

m2 &lt;- BuildModel(
  p.map = list(A = "1", B = "1", mean_v = "M", sd_v = "1",
    t0 = "1", st0 = "1"),
  constants = c(st0 = 0, sd_v = 1),
  match.map = list(M = list(s1 = 1, s2 = 2)),
  factors   = list(S = c("s1", "s2")),
  responses = c("r1", "r2"),
  type      = "norm")

pvec1 &lt;- c(a = 1.15, v.f1 = -0.10, v.f2 = 3, z = 0.74, sz = 1.23,
           sv.f1 = 0.11, sv.f2 = 0.21, t0 = 0.87)
pvec2 &lt;- c(A = .75, B = .25, mean_v.true = 2.5, mean_v.false = 1.5,
           t0 = .2)

print(m1, pvec1)
print(m2, pvec2)

accMat1 &lt;- TableParameters(pvec1, "s1.f1.r1", m1, FALSE)
accMat2 &lt;- TableParameters(pvec2, "s1.r1",    m2, FALSE)

##    a    v   t0    z d   sz   sv st0
## 1.15 -0.1 0.87 0.26 0 1.23 0.11   0
## 1.15 -0.1 0.87 0.26 0 1.23 0.11   0

##    A b  t0 mean_v sd_v st0
## 0.75 1 0.2    2.5    1   0
## 0.75 1 0.2    1.5    1   0
</code></pre>

<hr>
<h2 id='theta2mcmclist'>Convert theta to a mcmc List</h2><span id='topic+theta2mcmclist'></span><span id='topic+phi2mcmclist'></span>

<h3>Description</h3>

<p>Extracts the parameter array (ie theta) from posterior samples of a
partiipant and convert it to a <span class="pkg">coda</span> mcmc.list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta2mcmclist(x, start = 1, end = NA, split = FALSE,
  subchain = FALSE, nsubchain = 3, thin = NA)

phi2mcmclist(x, start = 1, end = NA, split = FALSE,
  subchain = FALSE, nsubchain = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta2mcmclist_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="theta2mcmclist_+3A_start">start</code></td>
<td>
<p>start iteration</p>
</td></tr>
<tr><td><code id="theta2mcmclist_+3A_end">end</code></td>
<td>
<p>end iteraton</p>
</td></tr>
<tr><td><code id="theta2mcmclist_+3A_split">split</code></td>
<td>
<p>whether to divide one MCMC sequence into two sequences.</p>
</td></tr>
<tr><td><code id="theta2mcmclist_+3A_subchain">subchain</code></td>
<td>
<p>boolean swith convert only a subset of chains</p>
</td></tr>
<tr><td><code id="theta2mcmclist_+3A_nsubchain">nsubchain</code></td>
<td>
<p>indicate the number of chains in the subset</p>
</td></tr>
<tr><td><code id="theta2mcmclist_+3A_thin">thin</code></td>
<td>
<p>thinning lenght of the posterior samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>phi2mcmclist</code> extracts the phi parameter array, which stores
the location and scale parameters at the hyper level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model &lt;- BuildModel(
p.map     = list(a = "RACE", v = c("S", "RACE"), z = "RACE", d = "1",
            sz = "1", sv = "1", t0 = c("S", "RACE"), st0 = "1"),
match.map = list(M = list(gun = "shoot", non = "not")),
factors   = list(S = c("gun", "non"), RACE = c("black", "white")),
constants = c(st0 = 0, d = 0, sz = 0, sv = 0),
responses = c("shoot", "not"),
type      = "rd")

pnames &lt;- GetPNames(model)
npar   &lt;- length(pnames)
pop.mean  &lt;- c(1, 1, 2.5, 2.5, 2.5, 2.5, .50, .50, .4, .4, .4, .4)
pop.scale &lt;- c(.15, .15, 1, 1, 1, 1, .05, .05, .05, .05, .05, .05)
names(pop.mean)  &lt;- pnames
names(pop.scale) &lt;- pnames
pop.prior &lt;- BuildPrior(
  dists = rep("tnorm", npar),
  p1    = pop.mean,
  p2    = pop.scale,
  lower = c(rep(0, 2), rep(-5, 4), rep(0, 6)),
  upper = c(rep(5, 2), rep(7, 4), rep(2, 6)))
p.prior &lt;- BuildPrior(
  dists = rep("tnorm", npar),
  p1    = pop.mean,
  p2    = pop.scale*10,
  lower = c(rep(0, 2), rep(-5, 4), rep(0, 6)),
  upper = c(rep(10, 2), rep(NA, 4), rep(5, 6)))
mu.prior &lt;- BuildPrior(
  dists = rep("tnorm", npar),
  p1    = pop.mean,
  p2    = pop.scale*10,
  lower = c(rep(0,  2), rep(-5, 4), rep(0, 6)),
  upper = c(rep(10, 2), rep(NA, 4), rep(5, 6)))
sigma.prior &lt;- BuildPrior(
  dists = rep("beta", npar),
  p1    = rep(1, npar),
  p2    = rep(1, npar),
  upper = rep(2, npar))
names(sigma.prior) &lt;- GetPNames(model)
priors &lt;- list(pprior=p.prior, location=mu.prior, scale=sigma.prior)
dat    &lt;- simulate(model, nsim = 10, nsub = 10, prior = pop.prior)
dmi    &lt;- BuildDMI(dat, model)
ps     &lt;- attr(dat, "parameters")

fit0 &lt;- StartNewsamples(dmi, priors)
fit  &lt;- run(fit0)

tmp1 &lt;- theta2mcmclist(fit[[1]])
tmp2 &lt;- theta2mcmclist(fit[[2]], start = 10, end = 90)
tmp3 &lt;- theta2mcmclist(fit[[3]], split = TRUE)
tmp4 &lt;- theta2mcmclist(fit[[4]], subchain = TRUE)
tmp5 &lt;- theta2mcmclist(fit[[5]], subchain = TRUE, nsubchain = 4)
tmp6 &lt;- theta2mcmclist(fit[[6]], thin = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='unstick_one'>Unstick posterios samples (One subject)</h2><span id='topic+unstick_one'></span>

<h3>Description</h3>

<p>Unstick posterios samples (One subject)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unstick_one(x, bad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstick_one_+3A_x">x</code></td>
<td>
<p>posterior samples</p>
</td></tr>
<tr><td><code id="unstick_one_+3A_bad">bad</code></td>
<td>
<p>a numeric vector, indicating which chains to remove</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
