<!DOCTYPE html><html><head><title>Help for package Rmpfr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rmpfr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rmpfr-package'><p>R MPFR - Multiple Precision Floating-Point Reliable</p></a></li>
<li><a href='#array_or_vector-class'><p>Auxiliary Class &quot;array_or_vector&quot;</p></a></li>
<li><a href='#asNumeric-methods'><p>Methods for <code>asNumeric(&lt;mpfr&gt;)</code></p></a></li>
<li><a href='#atomicVector-class'><p>Virtual Class &quot;atomicVector&quot; of Atomic Vectors</p></a></li>
<li><a href='#Bernoulli'><p>Bernoulli Numbers in Arbitrary Precision</p></a></li>
<li><a href='#Bessel_mpfr'><p>Bessel functions of Integer Order in multiple precisions</p></a></li>
<li><a href='#bind-methods'><p>&quot;mpfr&quot; '...' - Methods for Functions cbind(), rbind()</p></a></li>
<li><a href='#chooseMpfr'><p>Binomial Coefficients and Pochhammer Symbol aka Rising Factorial</p></a></li>
<li><a href='#factorialMpfr'><p>Factorial 'n!'  in Arbitrary Precision</p></a></li>
<li><a href='#formatHex'><p>Flexibly Format Numbers in Binary, Hex and Decimal Format</p></a></li>
<li><a href='#formatMpfr'><p>Formatting MPFR (multiprecision) Numbers</p></a></li>
<li><a href='#frexpMpfr'><p>Base-2 Representation and Multiplication of Mpfr Numbers</p></a></li>
<li><a href='#gmp-conversions'><p>Conversion Utilities gmp &lt;-&gt; Rmpfr</p></a></li>
<li><a href='#hjkMpfr'><p>Hooke-Jeeves Derivative-Free Minimization R (working for MPFR)</p></a></li>
<li><a href='#igamma'><p>Incomplete Gamma Function</p></a></li>
<li><a href='#integrateR'><p>One-Dimensional Numerical Integration - in pure R</p></a></li>
<li><a href='#is.whole'><p>Whole (&quot;Integer&quot;) Numbers</p></a></li>
<li><a href='#log1mexp'><p>Compute  f(a) = <code class="reqn">\mathrm{log}</code>(1 +/- <code class="reqn">\mathrm{exp}</code>(-a))</p>
Numerically Optimally</a></li>
<li><a href='#matmult'><p>(MPFR) Matrix (Vector) Multiplication</p></a></li>
<li><a href='#Mnumber-class'><p>Class &quot;Mnumber&quot; and &quot;mNumber&quot; of &quot;mpfr&quot; and regular numbers and arrays from them</p></a></li>
<li><a href='#mpfr'><p>Create &quot;mpfr&quot; Numbers (Objects)</p></a></li>
<li><a href='#mpfr-class'><p>Class &quot;mpfr&quot; of Multiple Precision Floating Point Numbers</p></a></li>
<li><a href='#mpfr-distr-etc'><p>Distribution Functions with MPFR Arithmetic</p></a></li>
<li><a href='#mpfr-special-functions'><p>Special Mathematical Functions (MPFR)</p></a></li>
<li><a href='#mpfr-utils'><p>Rmpfr &ndash; Utilities for Precision Setting, Printing, etc</p></a></li>
<li><a href='#mpfr.utils'><p>MPFR Number Utilities</p></a></li>
<li><a href='#mpfrArray'><p>Construct &quot;mpfrArray&quot; almost as by 'array()'</p></a></li>
<li><a href='#mpfrMatrix'><p>Classes &quot;mpfrMatrix&quot; and &quot;mpfrArray&quot;</p></a></li>
<li><a href='#mpfrMatrix-utils'><p>Functions for mpfrMatrix Objects</p></a></li>
<li><a href='#optimizeR'><p>High Precision One-Dimensional Optimization</p></a></li>
<li><a href='#pbetaI'><p>Accurate Incomplete Beta / Beta Probabilities For Integer Shapes</p></a></li>
<li><a href='#pmax'><p>Parallel Maxima and Minima</p></a></li>
<li><a href='#qnormI'><p>Gaussian / Normal Quantiles <code>qnorm()</code> via Inversion</p></a></li>
<li><a href='#Rmpfr-workarounds'><p>Base Functions etc, as an Rmpfr version</p></a></li>
<li><a href='#roundMpfr'><p>Rounding to Binary bits, &quot;mpfr-internally&quot;</p></a></li>
<li><a href='#sapplyMpfr'><p>Apply a Function over a &quot;mpfr&quot; Vector</p></a></li>
<li><a href='#seqMpfr'><p>&quot;mpfr&quot; Sequence Generation</p></a></li>
<li><a href='#str.mpfr'><p>Compactly Show STRucture of Rmpfr Number Object</p></a></li>
<li><a href='#sumBinomMpfr'><p>(Alternating) Binomial Sums via Rmpfr</p></a></li>
<li><a href='#unirootR'><p>One Dimensional Root (Zero) Finding &ndash; in pure <span class="rlang"><b>R</b></span></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>R MPFR - Multiple Precision Floating-Point Reliable</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-20</td>
</tr>
<tr>
<td>DateNote:</td>
<td>Previous CRAN version 0.9-4 on 2023-12-04</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Description:</td>
<td>Arithmetic (via S4 classes and methods) for
  arbitrary precision floating point numbers, including transcendental
  ("special") functions.  To this end, the package interfaces to
  the 'LGPL' licensed 'MPFR' (Multiple Precision Floating-Point Reliable) Library
  which itself is based on the 'GMP' (GNU Multiple Precision) Library.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gmp (&gt;= 4.2.3), mpfr (&gt;= 3.0.0), pdfcrop (part of
TexLive) is required to rebuild the vignettes.</td>
</tr>
<tr>
<td>SystemRequirementsNote:</td>
<td>'MPFR' (MP Floating-Point Reliable Library,
https://www.mpfr.org/) and 'GMP' (GNU Multiple Precision
library, https://gmplib.org/), see &gt;&gt; README.md</td>
</tr>
<tr>
<td>Depends:</td>
<td>gmp (&ge; 0.6-1), R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, Bessel, polynom, sfsmisc (&ge; 1.1-14)</td>
</tr>
<tr>
<td>SuggestsNote:</td>
<td>MASS, polynom, sfsmisc: only for vignette;</td>
</tr>
<tr>
<td>Enhances:</td>
<td>dfoptim, pracma, DPQ</td>
</tr>
<tr>
<td>EnhancesNote:</td>
<td>mentioned in Rd xrefs | used in example</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rmpfr.r-forge.r-project.org/">https://rmpfr.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://r-forge.r-project.org/tracker/?group_id=386">https://r-forge.r-project.org/tracker/?group_id=386</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-20 16:10:31 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Richard M. Heiberger [ctb] (formatHex(), *Bin, *Dec),
  John C. Nash [ctb] (hjkMpfr(), origin of unirootR()),
  Hans W. Borchers [ctb] (optimizeR(*, "GoldenRatio"); origin of
    hjkMpfr())</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-21 12:22:45 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rmpfr-package'>R MPFR - Multiple Precision Floating-Point Reliable</h2><span id='topic+Rmpfr-package'></span><span id='topic+Rmpfr'></span>

<h3>Description</h3>

<p>Rmpfr provides S4 classes and methods for arithmetic
including transcendental (&quot;special&quot;) functions for arbitrary
precision floating point numbers, here often called &ldquo;mpfr -
numbers&rdquo;.  To this end, it interfaces to the LGPL'ed MPFR (Multiple
Precision Floating-Point Reliable) Library which itself is based on
the GMP (GNU Multiple Precision) Library.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> Rmpfr</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> R MPFR - Multiple Precision Floating-Point Reliable</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.9-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-20</td>
</tr>
<tr>
 <td style="text-align: left;">
DateNote: </td><td style="text-align: left;"> Previous CRAN version 0.9-4 on 2023-12-04</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Martin","Maechler", role = c("aut","cre"),
	     email = "maechler@stat.math.ethz.ch", comment = c(ORCID="0000-0002-8685-9910"))
	, person(c("Richard", "M."), "Heiberger", role = "ctb", email="rmh@temple.edu",
					comment = "formatHex(), *Bin, *Dec")
	, person(c("John", "C."), "Nash", role = "ctb", email="nashjc@uottawa.ca",
					comment = "hjkMpfr(), origin of unirootR()")
	, person(c("Hans", "W."), "Borchers", role = "ctb", email="hwborchers@googlemail.com",
					comment = "optimizeR(*, \"GoldenRatio\"); origin of hjkMpfr()")
	)</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Arithmetic (via S4 classes and methods) for
  arbitrary precision floating point numbers, including transcendental
  ("special") functions.  To this end, the package interfaces to
  the 'LGPL' licensed 'MPFR' (Multiple Precision Floating-Point Reliable) Library
  which itself is based on the 'GMP' (GNU Multiple Precision) Library.</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirements: </td><td style="text-align: left;"> gmp (&gt;= 4.2.3), mpfr (&gt;= 3.0.0),
pdfcrop (part of TexLive) is required to rebuild the vignettes.</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirementsNote: </td><td style="text-align: left;"> 'MPFR' (MP Floating-Point Reliable Library,
https://www.mpfr.org/) and 'GMP' (GNU Multiple Precision library,
https://gmplib.org/), see  &gt;&gt;  README.md</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> gmp (&gt;= 0.6-1), R (&gt;= 3.6.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> stats, utils, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> MASS, Bessel, polynom, sfsmisc (&gt;= 1.1-14)</td>
</tr>
<tr>
 <td style="text-align: left;">
SuggestsNote: </td><td style="text-align: left;"> MASS, polynom, sfsmisc: only for vignette;</td>
</tr>
<tr>
 <td style="text-align: left;">
Enhances: </td><td style="text-align: left;"> dfoptim, pracma, DPQ</td>
</tr>
<tr>
 <td style="text-align: left;">
EnhancesNote: </td><td style="text-align: left;"> mentioned in Rd xrefs | used in example</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://rmpfr.r-forge.r-project.org/</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://r-forge.r-project.org/tracker/?group_id=386</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Martin Maechler [aut, cre] (&lt;https://orcid.org/0000-0002-8685-9910&gt;),
  Richard M. Heiberger [ctb] (formatHex(), *Bin, *Dec),
  John C. Nash [ctb] (hjkMpfr(), origin of unirootR()),
  Hans W. Borchers [ctb] (optimizeR(*, "GoldenRatio"); origin of
    hjkMpfr())</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
.bigq2mpfr              Conversion Utilities gmp &lt;-&gt; Rmpfr
Bernoulli               Bernoulli Numbers in Arbitrary Precision
Bessel_mpfr             Bessel functions of Integer Order in multiple
                        precisions
Mnumber-class           Class "Mnumber" and "mNumber" of "mpfr" and
                        regular numbers and arrays from them
Rmpfr-package           R MPFR - Multiple Precision Floating-Point
                        Reliable
array_or_vector-class   Auxiliary Class "array_or_vector"
asNumeric-methods       Methods for 'asNumeric(&lt;mpfr&gt;)'
atomicVector-class      Virtual Class "atomicVector" of Atomic Vectors
c.mpfr                  MPFR Number Utilities
cbind                   "mpfr" '...' - Methods for Functions cbind(),
                        rbind()
chooseMpfr              Binomial Coefficients and Pochhammer Symbol aka
                        Rising Factorial
determinant.mpfrMatrix
                        Functions for mpfrMatrix Objects
factorialMpfr           Factorial 'n!'  in Arbitrary Precision
formatHex               Flexibly Format Numbers in Binary, Hex and
                        Decimal Format
formatMpfr              Formatting MPFR (multiprecision) Numbers
frexpMpfr               Base-2 Representation and Multiplication of
                        Mpfr Numbers
getPrec                 Rmpfr - Utilities for Precision Setting,
                        Printing, etc
hjkMpfr                 Hooke-Jeeves Derivative-Free Minimization R
                        (working for MPFR)
igamma                  Incomplete Gamma Function
integrateR              One-Dimensional Numerical Integration - in pure
                        R
is.whole.mpfr           Whole ("Integer") Numbers
log1mexp                Compute f(a) = log(1 +/- exp(-a)) Numerically
                        Optimally
matmult                 (MPFR) Matrix (Vector) Multiplication
mpfr                    Create "mpfr" Numbers (Objects)
mpfr-class              Class "mpfr" of Multiple Precision Floating
                        Point Numbers
mpfrArray               Construct "mpfrArray" almost as by 'array()'
mpfrMatrix-class        Classes "mpfrMatrix" and "mpfrArray"
optimizeR               High Precision One-Dimensional Optimization
outer                   Base Functions etc, as an Rmpfr version
pbetaI                  Accurate Incomplete Beta / Beta Probabilities
                        For Integer Shapes
pmax                    Parallel Maxima and Minima
pnorm                   Distribution Functions with MPFR Arithmetic
qnormI                  Gaussian / Normal Quantiles 'qnorm()' via
                        Inversion
roundMpfr               Rounding to Binary bits, "mpfr-internally"
sapplyMpfr              Apply a Function over a "mpfr" Vector
seqMpfr                 "mpfr" Sequence Generation
str.mpfr                Compactly Show STRucture of Rmpfr Number Object
sumBinomMpfr            (Alternating) Binomial Sums via Rmpfr
unirootR                One Dimensional Root (Zero) Finding - in pure R
zeta                    Special Mathematical Functions (MPFR)
</pre>

<p>Further information is available in the following vignettes:<br /><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>Maechler_useR_2011-abstr</code> </td><td style="text-align: left;"> useR-2011-abstract (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Rmpfr-pkg</code> </td><td style="text-align: left;"> Arbitrarily Accurate Computation with R Package Rmpfr (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>log1mexp-note</code> </td><td style="text-align: left;"> Accurately Computing log(1 - exp(.)) -- Assessed by Rmpfr (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The following (help pages) index does not really mention that we provide <em>many</em>
methods for mathematical functions, including
<code><a href="base.html#topic+gamma">gamma</a></code>, <code><a href="base.html#topic+digamma">digamma</a></code>, etc, namely, all of <span class="rlang"><b>R</b></span>'s (S4)
<code>Math</code> group (with the only exception of <code><a href="base.html#topic+trigamma">trigamma</a></code>),
see the list in the examples.
Additionally also <code><a href="#topic+pnorm">pnorm</a></code>, the &ldquo;error function&rdquo;,
and more, see the list in <code><a href="#topic+zeta">zeta</a></code>, and
further note the first vignette (below).
</p>
<p><b><em>Partial</em> index</b>:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+mpfr">mpfr</a></code>              </td><td style="text-align: left;">  Create "mpfr" Numbers (Objects) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+mpfrArray">mpfrArray</a></code>         </td><td style="text-align: left;">  Construct "mpfrArray" almost as by <code><a href="base.html#topic+array">array</a>()</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+mpfr-class">mpfr-class</a></code>        </td><td style="text-align: left;">  Class "mpfr" of Multiple Precision Floating Point Numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+mpfrMatrix-class">mpfrMatrix-class</a></code>  </td><td style="text-align: left;">  Classes "mpfrMatrix" and "mpfrArray" </td>
</tr>
<tr>
 <td style="text-align: left;">
				  </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+Bernoulli">Bernoulli</a></code>         </td><td style="text-align: left;">  Bernoulli Numbers in Arbitrary Precision </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+Bessel_mpfr">Bessel_mpfr</a></code>       </td><td style="text-align: left;">  Bessel functions of Integer Order in multiple precisions </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+c.mpfr">c.mpfr</a></code>            </td><td style="text-align: left;">  MPFR Number Utilities </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+cbind">cbind</a></code>             </td><td style="text-align: left;">  "mpfr" <code>...</code> - Methods for Functions cbind(), rbind() </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+chooseMpfr">chooseMpfr</a></code>        </td><td style="text-align: left;">  Binomial Coefficients and Pochhammer Symbol aka </td>
</tr>
<tr>
 <td style="text-align: left;">
				  </td><td style="text-align: left;">  Rising Factorial </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+factorialMpfr">factorialMpfr</a></code>     </td><td style="text-align: left;">  Factorial 'n!'  in Arbitrary Precision </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+formatMpfr">formatMpfr</a></code>        </td><td style="text-align: left;">  Formatting MPFR (multiprecision) Numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+getPrec">getPrec</a></code>           </td><td style="text-align: left;">  Rmpfr - Utilities for Precision Setting, Printing, etc </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+roundMpfr">roundMpfr</a></code>         </td><td style="text-align: left;">  Rounding to Binary bits, "mpfr-internally" </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+seqMpfr">seqMpfr</a></code>           </td><td style="text-align: left;">  "mpfr" Sequence Generation </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+sumBinomMpfr">sumBinomMpfr</a></code>      </td><td style="text-align: left;">  (Alternating) Binomial Sums via Rmpfr </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+zeta">zeta</a></code>              </td><td style="text-align: left;">  Special Mathematical Functions (MPFR) </td>
</tr>
<tr>
 <td style="text-align: left;">
				  </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+integrateR">integrateR</a></code>        </td><td style="text-align: left;">  One-Dimensional Numerical Integration - in pure R </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+unirootR">unirootR</a></code>          </td><td style="text-align: left;">  One Dimensional Root (Zero) Finding - in pure R </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+optimizeR">optimizeR</a></code>         </td><td style="text-align: left;">  High Precisione One-Dimensional Optimization </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+hjkMpfr">hjkMpfr</a></code>           </td><td style="text-align: left;">  Hooke-Jeeves Derivative-Free Minimization R (working for MPFR) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Further information is available in the following vignettes:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>Rmpfr-pkg</code> </td><td style="text-align: left;"> Arbitrarily Accurate Computation with R: The 'Rmpfr' package (source, pdf)</td>
</tr>
<tr>
 <td style="text-align: left;">

  <code>log1mexp-note</code> </td><td style="text-align: left;"> Acccurately Computing log(1 - exp(.)) -- Assessed by Rmpfr (source, pdf)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>MPFR (MP Floating-Point Reliable Library),
<a href="https://www.mpfr.org/">https://www.mpfr.org/</a>
</p>
<p>GMP (GNU Multiple Precision library),
<a href="https://gmplib.org/">https://gmplib.org/</a>
</p>
<p>and see the vignettes mentioned above.
</p>


<h3>See Also</h3>

<p>The <span class="rlang"><b>R</b></span> package <a href="https://CRAN.R-project.org/package=gmp"><span class="pkg">gmp</span></a> for big integer <span class="pkg"><a href="gmp.html#topic+biginteger">gmp</a></span>
and rational numbers (<code><a href="gmp.html#topic+bigrational">bigrational</a></code>) on which <span class="pkg">Rmpfr</span>
depends.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using  "mpfr" numbers instead of regular numbers...
n1.25 &lt;- mpfr(5, precBits = 256)/4
n1.25

## and then "everything" just works with the desired chosen precision:hig
n1.25 ^ c(1:7, 20, 30) ## fully precise; compare with
print(1.25 ^ 30, digits=19)

exp(n1.25)

## Show all math functions which work with "MPFR" numbers (1 exception: trigamma)
getGroupMembers("Math")

## We provide *many* arithmetic, special function, and other methods:
showMethods(classes = "mpfr")
showMethods(classes = "mpfrArray")
</code></pre>

<hr>
<h2 id='array_or_vector-class'>Auxiliary Class &quot;array_or_vector&quot;</h2><span id='topic+array_or_vector-class'></span>

<h3>Description</h3>

<p><code>"array_or_vector"</code> is the class union of
<code>c("array", "matrix", "vector")</code> and exists for its use in
signatures of method definitions.
</p>


<h3>Details</h3>

<p>Using <code>"array_or_vector"</code> instead of just <code>"vector"</code> in a
signature makes an important difference: E.g., if we had
<code>setMethod(crossprod, c(x="mpfr", y="vector"), function(x,y) CPR(x,y))</code>,
a call <code>crossprod(x, matrix(1:6, 2,3))</code> would extend into a call
of <code>CPR(x, as(y, "vector"))</code> such that <code>CPR()</code>'s second
argument would simply be a vector instead of the desired
<code class="reqn">2\times3</code> matrix.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be
created from it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> showClass("array_or_vector")
</code></pre>

<hr>
<h2 id='asNumeric-methods'>Methods for <code>asNumeric(&lt;mpfr&gt;)</code></h2><span id='topic+asNumeric-methods'></span><span id='topic+asNumeric+2Cmpfr-method'></span><span id='topic+asNumeric+2CmpfrArray-method'></span>

<h3>Description</h3>


<p>Methods for function <code><a href="gmp.html#topic+asNumeric">asNumeric</a></code> (in package <span class="pkg">gmp</span>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mpfrArray'
asNumeric(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asNumeric-methods_+3A_x">x</code></td>
<td>
<p>a &ldquo;number-like&rdquo; object, here, a
<code><a href="#topic+mpfr-class">mpfr</a></code> or typically
<code><a href="#topic+mpfrArray-class">mpfrArray</a></code>one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <span class="rlang"><b>R</b></span> object of type (<code><a href="base.html#topic+typeof">typeof</a></code>) <code>"numeric"</code>, a <code><a href="base.html#topic+matrix">matrix</a></code>
or <code><a href="base.html#topic+array">array</a></code> if <code>x</code> had non-NULL dimension <code><a href="base.html#topic+dim">dim</a>()</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "mpfrArray")</code></dt><dd><p>this method also dispatches
for <code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code> and returns a numeric array.</p>
</dd>
<dt><code>signature(x = "mpfr")</code></dt><dd><p>for non-array/matrix,
<code>asNumeric(x)</code> is basically the same as <code>as.numeric(x)</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p>our lower level (non-generic) <code><a href="#topic+toNum">toNum</a>()</code>. Further,
<code><a href="gmp.html#topic+asNumeric">asNumeric</a></code> (package <span class="pkg">gmp</span>),
standard <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+as.numeric">as.numeric</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- (0:7)/8 # (exact)
X &lt;- mpfr(x, 99)
stopifnot(identical(asNumeric(x), x),
	  identical(asNumeric(X), x))

m &lt;- matrix(1:6, 3,2)
(M &lt;- mpfr(m, 99) / 5) ##-&gt; "mpfrMatrix"
asNumeric(M) # numeric matrix
stopifnot(all.equal(asNumeric(M), m/5),
          identical(asNumeric(m), m))# remains matrix
</code></pre>

<hr>
<h2 id='atomicVector-class'>Virtual Class &quot;atomicVector&quot; of Atomic Vectors</h2><span id='topic+atomicVector-class'></span>

<h3>Description</h3>

<p>The <code><a href="base.html#topic+class">class</a></code> <code>"atomicVector"</code> is a
<em>virtual</em> class containing all atomic vector classes of base <span class="rlang"><b>R</b></span>,
as also implicitly defined via <code><a href="base.html#topic+is.atomic">is.atomic</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>In the <span class="pkg">Matrix</span> package, the &quot;atomicVector&quot; is used in signatures
where typically &ldquo;old-style&rdquo; &quot;matrix&quot; objects can be used and
can be substituted by simple vectors.
</p>


<h3>Extends</h3>


<p>The atomic classes
<code>"logical"</code>, <code>"integer"</code>, <code>"double"</code>, <code>"numeric"</code>,
<code>"complex"</code>, <code>"raw"</code> and <code>"character"</code> are extended
directly.  Note that <code>"numeric"</code> already contains <code>"integer"</code>
and <code>"double"</code>, but we want all of them to be direct subclasses of
<code>"atomicVector"</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.atomic">is.atomic</a></code>, <code><a href="base.html#topic+integer">integer</a></code>, <code><a href="base.html#topic+numeric">numeric</a></code>,
<code><a href="base.html#topic+complex">complex</a></code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("atomicVector")
</code></pre>

<hr>
<h2 id='Bernoulli'>Bernoulli Numbers in Arbitrary Precision</h2><span id='topic+Bernoulli'></span>

<h3>Description</h3>

<p>Computes the Bernoulli numbers in the desired (binary) precision.
The computation happens via the <code><a href="#topic+zeta">zeta</a></code> function and the
formula
</p>
<p style="text-align: center;"><code class="reqn">B_k = -k \zeta(1 - k),</code>
</p>

<p>and hence the only non-zero odd Bernoulli number is <code class="reqn">B_1 = +1/2</code>.
(Another tradition defines it, equally sensibly, as <code class="reqn">-1/2</code>.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bernoulli(k, precBits = 128)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bernoulli_+3A_k">k</code></td>
<td>
<p>non-negative integer vector</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_precbits">precBits</code></td>
<td>
<p>the precision in <em>bits</em> desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code><a href="#topic+mpfr-class">mpfr</a></code> class vector of the same length as
<code>k</code>, with i-th component the <code>k[i]</code>-th Bernoulli number.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Bernoulli_number">https://en.wikipedia.org/wiki/Bernoulli_number</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zeta">zeta</a></code> is used to compute them.
</p>
<p>The next version of package <a href="https://CRAN.R-project.org/package=gmp"><span class="pkg">gmp</span></a> is to contain 
<code>BernoulliQ()</code>, providing exact Bernoulli numbers as
big rationals (class <code>"bigq"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Bernoulli(0:10)
plot(as.numeric(Bernoulli(0:15)), type = "h")

curve(-x*zeta(1-x), -.2, 15.03, n=300,
      main = expression(-x %.% zeta(1-x)))
legend("top", paste(c("even","odd  "), "Bernoulli numbers"),
       pch=c(1,3), col=2, pt.cex=2, inset=1/64)
abline(h=0,v=0, lty=3, col="gray")
k &lt;- 0:15; k[1] &lt;- 1e-4
points(k, -k*zeta(1-k), col=2, cex=2, pch=1+2*(k%%2))

## They pretty much explode for larger k :
k2 &lt;- 2*(1:120)
plot(k2, abs(as.numeric(Bernoulli(k2))), log = "y")
title("Bernoulli numbers exponential growth")

Bernoulli(10000)# - 9.0494239636 * 10^27677
</code></pre>

<hr>
<h2 id='Bessel_mpfr'>Bessel functions of Integer Order in multiple precisions</h2><span id='topic+Bessel_mpfr'></span><span id='topic+Ai'></span><span id='topic+j0'></span><span id='topic+j1'></span><span id='topic+jn'></span><span id='topic+y0'></span><span id='topic+y1'></span><span id='topic+yn'></span>

<h3>Description</h3>

<p>Bessel functions of integer orders, provided via arbitrary precision
algorithms from the MPFR library.
</p>
<p>Note that the computation can be very slow when <code>n</code> <em>and</em>
<code>x</code> are large (and of similar magnitude).

</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ai(x)
j0(x)
j1(x)
jn(n, x, rnd.mode = c("N","D","U","Z","A"))
y0(x)
y1(x)
yn(n, x, rnd.mode = c("N","D","U","Z","A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bessel_mpfr_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="#topic+mpfr-class">mpfr</a></code> vector.</p>
</td></tr>
<tr><td><code id="Bessel_mpfr_+3A_n">n</code></td>
<td>
<p>non-negative integer (vector).</p>
</td></tr>
<tr><td><code id="Bessel_mpfr_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see <code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Computes multiple precision versions of the Bessel functions of
<em>integer</em> order, <code class="reqn">J_n(x)</code> and <code class="reqn">Y_n(x)</code>,
and&mdash;when using MPFR library 3.0.0 or newer&mdash;also of the Airy function
<code class="reqn">Ai(x)</code>.  Note that currently <code>Ai(x)</code> is very slow to compute
for large <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+besselJ">besselJ</a></code>, and <code><a href="base.html#topic+besselY">besselY</a></code> compute the
same bessel functions but for arbitrary <em>real</em> order and only
precision of a bit more than ten digits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- (0:100)/8 # (have exact binary representation)
stopifnot(exprs = {
   all.equal(besselY(x, 0), bY0 &lt;- y0(x))
   all.equal(besselJ(x, 1), bJ1 &lt;- j1(x))
   all.equal(yn(0,x), bY0)
   all.equal(jn(1,x), bJ1)
})

mpfrVersion() # now typically 4.1.0
if(mpfrVersion() &gt;= "3.0.0") { ## Ai() not available previously
  print( aix &lt;- Ai(x) )
  plot(x, aix, log="y", type="l", col=2)
  stopifnot(
    all.equal(Ai (0) , 1/(3^(2/3) * gamma(2/3)))
    , # see https://dlmf.nist.gov/9.2.ii
    all.equal(Ai(100), mpfr("2.6344821520881844895505525695264981561e-291"), tol=1e-37)
  )
  two3rd &lt;- 2/mpfr(3, 144)
  print( all.equal(Ai(0), 1/(3^two3rd * gamma(two3rd)), tol=0) ) # 1.7....e-40
  if(Rmpfr:::doExtras()) withAutoprint({ # slowish:
     system.time(ai1k &lt;- Ai(1000)) # 1.4 sec (on 2017 lynne)
     stopifnot(all.equal(print(log10(ai1k)),
                         -9157.031193409585185582, tol=2e-16)) # seen 8.8..e-17 | 1.1..e-16
  })
} # ver &gt;= 3.0
</code></pre>

<hr>
<h2 id='bind-methods'>&quot;mpfr&quot; '...' - Methods for Functions cbind(), rbind()</h2><span id='topic+cbind'></span><span id='topic+rbind'></span><span id='topic+cbind-methods'></span><span id='topic+rbind-methods'></span><span id='topic+cbind+2CANY-method'></span><span id='topic+cbind+2CMnumber-method'></span><span id='topic+rbind+2CANY-method'></span><span id='topic+rbind+2CMnumber-method'></span>

<h3>Description</h3>

<p><code><a href="#topic+cbind">cbind</a></code> and <code><a href="#topic+rbind">rbind</a></code> methods for signature
<code>...</code> (see <code><a href="methods.html#topic+dotsMethods">dotsMethods</a></code>
are provided for class <code><a href="#topic+Mnumber-class">Mnumber</a></code>, i.e., for binding
numeric vectors and class <code>"<a href="#topic+mpfr-class">mpfr</a>"</code> vectors and
matrices (<code>"<a href="#topic+mpfrMatrix-class">mpfrMatrix</a>"</code>) together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cbind(..., deparse.level = 1)
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind-methods_+3A_...">...</code></td>
<td>
<p>matrix-/vector-like <span class="rlang"><b>R</b></span> objects to be bound together, see
the <span class="pkg">base</span> documentation, <code><a href="base.html#topic+cbind">cbind</a></code>.
</p>
</td></tr>
<tr><td><code id="bind-methods_+3A_deparse.level">deparse.level</code></td>
<td>
<p>integer determining under which circumstances
column and row names are built from the actual arguments'
&lsquo;expression&rsquo;, see <code><a href="#topic+cbind">cbind</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>typically a &lsquo;matrix-like&rsquo; object, here typically of
<code><a href="base.html#topic+class">class</a> "<a href="#topic+mpfrMatrix-class">mpfrMatrix</a>"</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>... = &quot;Mnumber&quot;</dt><dd><p>is used to (c|r)bind multiprecision &ldquo;numbers&rdquo;
(inheriting from class <code>"<a href="#topic+mpfr-class">mpfr</a>"</code>)
together, maybe combined with simple numeric vectors.</p>
</dd>
<dt>... = &quot;ANY&quot;</dt><dd><p>reverts to <code><a href="base.html#topic+cbind">cbind</a></code> and <code>rbind</code>
from package <span class="pkg">base</span>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+cbind2">cbind2</a></code>, <code><a href="#topic+cbind">cbind</a></code>,
Documentation in base <span class="rlang"><b>R</b></span>'s <span class="pkg">methods</span> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  cbind(1, mpfr(6:3, 70)/7, 3:0)
</code></pre>

<hr>
<h2 id='chooseMpfr'>Binomial Coefficients and Pochhammer Symbol aka Rising Factorial</h2><span id='topic+chooseMpfr'></span><span id='topic+chooseMpfr.all'></span><span id='topic+pochMpfr'></span>

<h3>Description</h3>

<p>Compute binomial coefficients, <code>chooseMpfr(a,n)</code> being
mathematically the same as <code><a href="base.html#topic+choose">choose</a>(a,n)</code>, but using high
precision (MPFR) arithmetic.
</p>
<p><code>chooseMpfr.all(n)</code> means the vector <code><a href="base.html#topic+choose">choose</a>(n, 1:n)</code>,
using enough bits for exact computation via MPFR.
However, <code>chooseMpfr.all()</code> is now <b>deprecated</b> in favor of
<code><a href="gmp.html#topic+chooseZ">chooseZ</a></code> from package <span class="pkg">gmp</span>, as that is now
vectorized.
</p>
<p><code>pochMpfr()</code> computes the Pochhammer symbol or &ldquo;rising
factorial&rdquo;, also called the &ldquo;Pochhammer function&rdquo;,
&ldquo;Pochhammer polynomial&rdquo;, &ldquo;ascending factorial&rdquo;,
&ldquo;rising sequential product&rdquo; or &ldquo;upper factorial&rdquo;,
</p>
<p style="text-align: center;"><code class="reqn">x^{(n)}=x(x+1)(x+2)\cdots(x+n-1)= \frac{(x+n-1)!}{(x-1)!} = \frac{\Gamma(x+n)}{\Gamma(x)}.
  </code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>chooseMpfr (a, n, rnd.mode = c("N","D","U","Z","A"))
chooseMpfr.all(n, precBits=NULL, k0=1, alternating=FALSE)
pochMpfr(a, n, rnd.mode = c("N","D","U","Z","A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseMpfr_+3A_a">a</code></td>
<td>
<p>a numeric or <code><a href="#topic+mpfr-class">mpfr</a></code> vector.</p>
</td></tr>
<tr><td><code id="chooseMpfr_+3A_n">n</code></td>
<td>
<p>an <code><a href="base.html#topic+integer">integer</a></code> vector; if not of length one,
<code>n</code> and <code>a</code> are recycled to the same length.</p>
</td></tr>
<tr><td><code id="chooseMpfr_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see <code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
<tr><td><code id="chooseMpfr_+3A_precbits">precBits</code></td>
<td>
<p>integer or NULL for increasing the default precision
of the result.</p>
</td></tr>
<tr><td><code id="chooseMpfr_+3A_k0">k0</code></td>
<td>
<p>integer scalar</p>
</td></tr>
<tr><td><code id="chooseMpfr_+3A_alternating">alternating</code></td>
<td>
<p>logical, for <code>chooseMpfr.all()</code>, indicating if
<em>alternating sign</em> coefficients should be returned, see below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For
</p>

<dl>
<dt><code>chooseMpfr()</code>, <code>pochMpfr()</code>:</dt><dd><p>an
<code><a href="#topic+mpfr-class">mpfr</a></code> vector of length <code>max(length(a),
	length(n))</code>;</p>
</dd>
<dt><code>chooseMpfr.all(n, k0)</code>:</dt><dd><p>a <code>mpfr</code> vector of length
<code>n-k0+1</code>, of binomial coefficients <code class="reqn">C_{n,m}</code>
or, if <code>alternating</code> is true, <code class="reqn">(-1)^m\cdot C_{n,m}</code>
for <code class="reqn">m \in</code> <code>k0:n</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Currently this works via a (C level) <code>for(i in 1:n)</code>-loop which
really slow for large <code>n</code>, say <code class="reqn">10^6</code>, with computational cost
<code class="reqn">O(n^2)</code>.  In such cases, if you need high precision
<code>choose(a,n)</code> (or Pochhammer(a,n)) for large <code>n</code>, preferably
work with the corresponding <code><a href="base.html#topic+factorial">factorial</a>(mpfr(..))</code>, or
<code><a href="base.html#topic+gamma">gamma</a>(mpfr(..))</code> terms.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+choose">choose</a>(n,m)</code> (<span class="pkg">base</span> <span class="rlang"><b>R</b></span>) computes the binomial coefficient
<code class="reqn">C_{n,m}</code> which can also be expressed via Pochhammer
symbol as
<code class="reqn">C_{n,m} = (n-m+1)^{(m)}/m!</code>.
</p>
<p><code><a href="gmp.html#topic+chooseZ">chooseZ</a></code> from package <span class="pkg">gmp</span>;
for now, 
<code><a href="#topic+factorialMpfr">factorialMpfr</a></code>.
</p>
<p>For (alternating) binomial sums, directly use
<code><a href="#topic+sumBinomMpfr">sumBinomMpfr</a></code>, as that is potentially 
more efficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pochMpfr(100, 4) == 100*101*102*103 # TRUE
a &lt;- 100:110
pochMpfr(a, 10) # exact (but too high precision)
x &lt;- mpfr(a, 70)# should be enough
(px &lt;- pochMpfr(x, 10)) # the same as above (needing only 70 bits)
stopifnot(pochMpfr(a, 10) == px,
          px[1] ==prod(mpfr(100:109, 100)))# used to fail

(c1 &lt;- chooseMpfr(1000:997, 60)) # -&gt; automatic "correct" precision
stopifnot(all.equal(c1, choose(1000:997, 60), tolerance=1e-12))

## --- Experimenting &amp; Checking
n.set &lt;- c(1:10, 20, 50:55, 100:105, 200:203, 300:303, 500:503,
           699:702, 999:1001)
if(!Rmpfr:::doExtras()) { ## speed up: smaller set
  n. &lt;- n.set[-(1:10)]
  n.set &lt;- c(1:10, n.[ c(TRUE, diff(n.) &gt; 1)])
}
C1 &lt;- C2 &lt;- numeric(length(n.set))
for(i.n in seq_along(n.set)) {
  cat(n &lt;- n.set[i.n],":")
  C1[i.n] &lt;- system.time(c.c &lt;- chooseMpfr.all(n) )[1]
  C2[i.n] &lt;- system.time(c.2 &lt;- chooseMpfr(n, 1:n))[1]
  stopifnot(is.whole(c.c), c.c == c.2,
            if(n &gt; 60) TRUE else all.equal(c.c, choose(n, 1:n), tolerance = 1e-15))
  cat(" [Ok]\n")
}
matplot(n.set, cbind(C1,C2), type="b", log="xy",
        xlab = "n", ylab = "system.time(.)  [s]")
legend("topleft", c("chooseMpfr.all(n)", "chooseMpfr(n, 1:n)"),
       pch=as.character(1:2), col=1:2, lty=1:2, bty="n")

## Currently, chooseMpfr.all() is faster only for large n (&gt;= 300)
## That would change if we used C-code for the *.all() version

## If you want to measure more:
measureMore &lt;- TRUE
measureMore &lt;- FALSE
if(measureMore) { ## takes ~ 2 minutes (on "lynne", Intel i7-7700T, ~2019)
  n.s &lt;- 2^(5:20)
  r &lt;- lapply(n.s, function(n) {
      N &lt;- ceiling(10000/n)
      cat(sprintf("n=%9g =&gt; N=%d: ",n,N))
      ct &lt;- system.time(C &lt;- replicate(N, chooseMpfr(n, n/2)))
      cat("[Ok]\n")
      list(C=C, ct=ct/N)
  })
  print(ct.n &lt;- t(sapply(r, `[[`, "ct")))
  hasSfS &lt;- requireNamespace("sfsmisc")
  plot(ct.n[,"user.self"] ~ n.s, xlab=quote(n), ylab="system.time(.) [s]",
       main = "CPU Time for  chooseMpfr(n, n/2)",
       log ="xy", type = "b", axes = !hasSfS)
  if(hasSfS) for(side in 1:2) sfsmisc::eaxis(side)
  summary(fm &lt;- lm(log(ct.n[,"user.self"]) ~ log(n.s), subset = n.s &gt;= 10^4))
  ## --&gt; slope ~= 2  ==&gt;  It's  O(n^2)
  nn &lt;- 2^seq(11,21, by=1/16) ; Lcol &lt;- adjustcolor(2, 1/2)
  bet &lt;- coef(fm)
  lines(nn, exp(predict(fm, list(n.s = nn))), col=Lcol, lwd=3)
  text(500000,1, substitute(AA %*% n^EE,
                            list(AA = signif(exp(bet[1]),3),
                                 EE = signif(    bet[2], 3))), col=2)
} # measure more
</code></pre>

<hr>
<h2 id='factorialMpfr'>Factorial 'n!'  in Arbitrary Precision</h2><span id='topic+factorialMpfr'></span>

<h3>Description</h3>

<p>Efficiently compute <code class="reqn">n!</code> in arbitrary precision,
using the MPFR-internal implementation.
This is mathematically (but not numerically) the same as
<code class="reqn">\Gamma(n+1)</code>.
</p>
<p><code><a href="gmp.html#topic+factorialZ">factorialZ</a></code> (package <span class="pkg">gmp</span>) should typically be
used <em>instead</em> of <code>factorialMpfr()</code> nowadays. Hence,
<code>factorialMpfr</code> now is somewhat <b>deprecated</b>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorialMpfr(n, precBits = max(2, ceiling(lgamma(n+1)/log(2))),
              rnd.mode = c("N","D","U","Z","A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorialMpfr_+3A_n">n</code></td>
<td>
<p>non-negative integer (vector).</p>
</td></tr>
<tr><td><code id="factorialMpfr_+3A_precbits">precBits</code></td>
<td>
<p>desired precision in bits (&ldquo;binary digits&rdquo;);
the default sets the precision high enough for the result to be <em>exact</em>.</p>
</td></tr>
<tr><td><code id="factorialMpfr_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see <code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number of (S4) class <code><a href="#topic+mpfr-class">mpfr</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factorial">factorial</a></code> and <code><a href="base.html#topic+gamma">gamma</a></code> in base <span class="rlang"><b>R</b></span>.
</p>
<p><code><a href="gmp.html#topic+factorialZ">factorialZ</a></code> (package <span class="pkg">gmp</span>), to <em>replace</em>
<code>factorialMpfr</code>, see above.
</p>
<p><code>chooseMpfr()</code> and <code><a href="#topic+pochMpfr">pochMpfr</a>()</code> (on the same page).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>factorialMpfr(200)

n &lt;- 1000:1010
f1000 &lt;- factorialMpfr(n)
stopifnot(1e-15 &gt; abs(as.numeric(1 - lfactorial(n)/log(f1000))))

## Note that---astonishingly--- measurements show only
## *small* efficiency gain of ~ 10% : over using the previous "technique"
system.time(replicate(8, f1e4 &lt;- factorialMpfr(10000)))
system.time(replicate(8, f.1e4 &lt;- factorial(mpfr(10000,
                            prec=1+lfactorial(10000)/log(2)))))
</code></pre>

<hr>
<h2 id='formatHex'>Flexibly Format Numbers in Binary, Hex and Decimal Format</h2><span id='topic+formatHex'></span><span id='topic+formatBin'></span><span id='topic+formatDec'></span><span id='topic+print.Ncharacter'></span>

<h3>Description</h3>

<p>Show numbers in binary, hex and decimal format.  The resulting
character-like objects can be back-transformed to <code>"mpfr"</code>
numbers via <code><a href="#topic+mpfr">mpfr</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatHex(x, precBits = min(getPrec(x)), style = "+", expAlign = TRUE)

formatBin(x, precBits = min(getPrec(x)), scientific = TRUE,
          left.pad = "_", right.pad = left.pad, style = "+", expAlign = TRUE)
formatDec(x, precBits = min(getPrec(x)), digits = decdigits,
          nsmall = NULL, scientific = FALSE, style = "+",
          decimalPointAlign = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatHex_+3A_x">x</code></td>
<td>
<p>a <code>numeric</code> or <code><a href="#topic+mpfr">mpfr</a></code> <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="formatHex_+3A_precbits">precBits</code></td>
<td>
<p>integer, the number of bits of precision, typically
derived from <code>x</code>, see <code><a href="#topic+getPrec">getPrec</a></code>.  Numeric, i.e.,
double precision numbers have 53 bits.  For more detail, see
<code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
<tr><td><code id="formatHex_+3A_style">style</code></td>
<td>
<p>a single character, to be used in <code><a href="base.html#topic+sprintf">sprintf</a></code>'s
format (<code>fmt</code>), immediately after the &quot;
sets a sign in the output, i.e., <code>"+"</code> or <code>"-"</code>, where as
<code>style = " "</code> may seem more standard.</p>
</td></tr>
<tr><td><code id="formatHex_+3A_expalign">expAlign</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if for scientific
(&ldquo;exponential&rdquo;) representations the exponents should be
aligned to the same width, i.e., zero-padded to the same number of
digits.</p>
</td></tr>
<tr><td><code id="formatHex_+3A_scientific">scientific</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating that
<code>formatBin</code> should display the binary representation in
scientific notation (<code>mpfr(3, 5)</code> is displayed as
<code>+0b1.1000p+1</code>).  When <code>FALSE</code>, <code>formatBin</code> will
display the binary representation in regular format shifted to align
binary points (<code>mpfr(3, 5)</code> is displayed <code>+0b11.000</code>).</p>
</td></tr>
<tr><td><code id="formatHex_+3A_...">...</code></td>
<td>
<p>additional optional arguments.

<code>formatHex</code>, <code>formatBin</code>: <code>precBits</code> is the only
<code>...</code> argument acted on.  Other <code>...</code> arguments are ignored.
</p>
<p><code>formatDec</code>: <code>precBits</code> is acted on.  Any argument
accepted by <code><a href="base.html#topic+format">format</a></code> (except <code>nsmall</code>) is
acted on.  Other <code>...</code> arguments are ignored.
</p>
</td></tr>
<tr><td><code id="formatHex_+3A_left.pad">left.pad</code>, <code id="formatHex_+3A_right.pad">right.pad</code></td>
<td>
<p>characters (one-character strings) that
will be used for left- and right-padding of the formatted string
when <code>scientific=FALSE</code>.  <em>Do not change these unless for
display-only purpose !!</em></p>
</td></tr>
<tr><td><code id="formatHex_+3A_nsmall">nsmall</code></td>
<td>
<p>only used when <code>scientific</code> is false, then passed
to <code><a href="base.html#topic+format">format</a>()</code>.  If <code>NULL</code>, the default is computed
from the range of the non-zero values of <code>x</code>.</p>
</td></tr>
<tr><td><code id="formatHex_+3A_digits">digits</code></td>
<td>
<p>integer; the number of decimal digits displayed is the
larger of this argument and the internally generated value that is a
function of <code>precBits</code>.  This is related to but different than
<code>digits</code> in <code><a href="base.html#topic+format">format</a></code>.</p>
</td></tr>
<tr><td><code id="formatHex_+3A_decimalpointalign">decimalPointAlign</code></td>
<td>
<p>logical indicating if padding should be used
to ensure that the resulting strings align on the decimal point
(<code>"."</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the hexadecimal representation, when the precision is not larger
than double precision, <code><a href="base.html#topic+sprintf">sprintf</a>()</code> is used directly,
otherwise <code><a href="#topic+formatMpfr">formatMpfr</a>()</code> is used and post processed.
For the binary representation, the hexadecimal value is calculated and
then edited by
substitution of the binary representation of the hex characters coded
in the <code>HextoBin</code> vector.  For binary with <code>scientific=FALSE</code>, the
result of the <code>scientific=TRUE</code> version is edited to align binary
points.  For the decimal representation, the hexadecimal value is
calculated with the specified precision and then sent to the
<code>format</code> function for <code>scientific=FALSE</code> or to the sprintf
function for <code>scientific=TRUE</code>.
</p>


<h3>Value</h3>

<p>a character vector (or matrix) like <code>x</code>, say <code>r</code>, containing
the formatted represention of <code>x</code>, with a <code><a href="base.html#topic+class">class</a></code>
(unless <code>left.pad</code> or <code>right.pad</code> were not <code>"_"</code>).  In
that case, <code>formatHex()</code> and <code>formatBin()</code> return class
<code>"Ncharacter"</code>; for that,
<code><a href="#topic+mpfr">mpfr</a>(.)</code> has a method and will basically return <code>x</code>,
i.e., work as <em>inverse</em> function.
</p>
<p>Since <span class="pkg">Rmpfr</span> version <code>0.6-2</code>, the S3 class
<code>"Ncharacter"</code> extends <code>"character"</code>.
(<code>class(.)</code> is now of length two and <code>class(.)[2]</code> is
<code>"character"</code>.).  There are simple <code>[</code> and <code><a href="base.html#topic+print">print</a></code>
methods; modifying or setting <code>dim</code> works as well.
</p>


<h3>Author(s)</h3>

<p>Richard M. Heiberger <a href="mailto:rmh@temple.edu">rmh@temple.edu</a>, with minor tweaking
by Martin M.</p>


<h3>References</h3>

<p>R FAQ 7.31:  Why doesn't R think these numbers are equal?
<code>system.file("../../doc/FAQ")</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpfr">mpfr</a></code>, <code><a href="base.html#topic+sprintf">sprintf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FourBits &lt;- mpfr(matrix(0:31, 8, 4, dimnames = list(0:7, c(0,8,16,24))),
                 precBits=4) ## 4 significant bits
FourBits

formatHex(FourBits)
formatBin(FourBits, style = " ")
formatBin(FourBits, scientific=FALSE)
formatDec(FourBits)

## as "Ncharacter"  'inherits from' "character", this now works too :
data.frame(Dec = c( formatDec(FourBits) ), formatHex(FourBits),
           Bin = formatBin(FourBits, style = " "))

FBB &lt;- formatBin(FourBits) ; clB &lt;- class(FBB)
(nFBB &lt;- mpfr(FBB))
stopifnot(class(FBB)[1] == "Ncharacter",
          all.equal(nFBB, FourBits, tol=0))

FBH &lt;- formatHex(FourBits) ; clH &lt;- class(FBH)
(nFBH &lt;- mpfr(FBH))
stopifnot(class(FBH)[1] == "Ncharacter",
          all.equal(nFBH, FourBits, tol=0))

## Compare the different "formattings"  (details will change, i.e. improve!)%% FIXME
M &lt;- mpfr(c(-Inf, -1.25, 1/(-Inf), NA, 0, .5, 1:2, Inf), 3)
data.frame(fH = formatHex(M), f16 = format(M, base=16),
           fB = formatBin(M), f2  = format(M, base= 2),
           fD = formatDec(M), f10 = format(M), # base = 10 is default
           fSci= format(M, scientific=TRUE),
           fFix= format(M, scientific=FALSE))

## Other methods ("[", t()) also work :
stopifnot(dim(F1 &lt;- FBB[, 1, drop=FALSE]) == c(8,1), identical(class(  F1), clB),
          dim(t(F1)) == c(1,8),                      identical(class(t(F1)),clB),
          is.null(dim(F.2 &lt;- FBB[,2])),              identical(class( F.2), clB),
          dim(F22 &lt;- FBH[1:2, 3:4]) == c(2,2), identical(class(F22),  clH),
          identical(class(FBH[2,3]), clH), is.null(dim(FBH[2,3])),
          identical(FBH[2,3:4], F22[2,]),
          identical(FBH[2,3], unname(FBH[,3][2])),
          TRUE)

TenFrac &lt;- matrix((1:10)/10, dimnames=list(1:10, expression(1/x)))
TenFrac9 &lt;- mpfr(TenFrac, precBits=9) ## 9 significant bits
TenFrac9
formatHex(TenFrac9)
formatBin(TenFrac9)
formatBin(TenFrac9, scientific=FALSE)
formatDec(TenFrac9)
formatDec(TenFrac9, precBits=10)
</code></pre>

<hr>
<h2 id='formatMpfr'>Formatting MPFR (multiprecision) Numbers</h2><span id='topic+formatMpfr'></span><span id='topic+formatN.mpfr'></span><span id='topic+.mpfr2str'></span>

<h3>Description</h3>

<p>Flexible formatting of &ldquo;multiprecision numbers&rdquo;, i.e., objects
of class <code><a href="#topic+mpfr-class">mpfr</a></code>.  <code>formatMpfr()</code> is also the
<code>mpfr</code> method of the generic <code><a href="base.html#topic+format">format</a></code> function.
</p>
<p>The <code>formatN()</code> methods for <code><a href="#topic+mpfr-class">mpfr</a></code> numbers
renders them differently than their double precision equivalents, by
appending <code>"_M"</code>.
</p>
<p>Function <code>.mpfr2str()</code> is the low level work horse for
<code>formatMpfr()</code> and hence all <code><a href="base.html#topic+print">print</a>()</code>ing of
<code>"<a href="#topic+mpfr-class">mpfr</a>"</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatMpfr(x, digits = NULL, trim = FALSE, scientific = NA,
           maybe.full = (!is.null(digits) &amp;&amp; is.na(scientific)) || isFALSE(scientific),
           base = 10, showNeg0 = TRUE, max.digits = Inf,
           big.mark = "", big.interval = 3L,
           small.mark = "", small.interval = 5L,
           decimal.mark = ".",
           exponent.char = if(base &lt;= 14) "e" else if(base &lt;= 36) "E" else "|e",
           exponent.plus = TRUE,
           zero.print = NULL, drop0trailing = FALSE, ...)

## S3 method for class 'mpfr'
formatN(x, drop0trailing = TRUE, ...)

.mpfr2str(x, digits = NULL, maybe.full = !is.null(digits), base = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatMpfr_+3A_x">x</code></td>
<td>
<p>an MPFR number (vector or array).</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_digits">digits</code></td>
<td>
<p>how many significant digits (in the <code>base</code> chosen!)
are to be used in the result.  The default, <code>NULL</code>, uses enough
digits to represent the full precision, often one or two digits more
than &ldquo;you&rdquo; would expect.  For <code>base</code>s 2,4,8,16, or 32,
MPFR requires <code>digits</code> at least 2.  For such bases,
<code>digits = 1</code> is changed into <code>2</code>, with a message.</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_trim">trim</code></td>
<td>
<p>logical; if <code>FALSE</code>, numbers are right-justified to a
common width: if <code>TRUE</code> the leading blanks for justification
are suppressed.</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_scientific">scientific</code></td>
<td>
<p>either a logical specifying whether
MPFR numbers should be encoded in scientific
format (&ldquo;exponential representation&rdquo;), or an integer penalty
(see <code><a href="base.html#topic+options">options</a>("scipen")</code>).
Missing values correspond to the current default penalty.</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_maybe.full">maybe.full</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code>, passed to <code><a href="#topic+.mpfr2str">.mpfr2str</a>()</code>.</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_base">base</code></td>
<td>
<p>an integer in <code class="reqn">2,3,..,62</code>; the base (&ldquo;basis&rdquo;)
in which the numbers should be represented.  Apart from the default
base 10, binary (<code>base = 2</code>) or hexadecimal (<code>base = 16</code>)
are particularly interesting.</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_showneg0">showNeg0</code></td>
<td>
<p>logical indicating if &ldquo;<b>neg</b>ative&rdquo; zeros
should be shown with a <code>"-"</code>.  The default, <code>TRUE</code> is
intentially different from <code><a href="base.html#topic+format">format</a>(&lt;numeric&gt;)</code>.</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_exponent.char">exponent.char</code></td>
<td>
<p>the &ldquo;exponent&rdquo; character to be used in
scientific notation.  The default takes into account that for
<code>base</code> <code class="reqn">B \ge 15</code>, <code>"e"</code> is part of the
(mantissa) digits and the same is true for <code>"E"</code> when
<code class="reqn">B \ge 37</code>.</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_exponent.plus">exponent.plus</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> indicating if <code>"+"</code>
should be for positive exponents in exponential (aka
&ldquo;scientific&rdquo;) representation.  This used to be hardcoded to
<code>FALSE</code>; the new default is compatible to <span class="rlang"><b>R</b></span>'s
<code><a href="base.html#topic+format">format</a>()</code>ing of numbers and helps to note visually when
exponents are in use.</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_max.digits">max.digits</code></td>
<td>
<p>a (large) positive number to limit the number of
(mantissa) digits, notably when <code>digits</code> is <code>NULL</code> (as by
default).  Otherwise, a numeric <code>digits</code> is <em>preferred</em> to
setting <code>max.digits</code> (which should not be smaller than
<code>digits</code>).</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_big.mark">big.mark</code>, <code id="formatMpfr_+3A_big.interval">big.interval</code>, <code id="formatMpfr_+3A_small.mark">small.mark</code>, <code id="formatMpfr_+3A_small.interval">small.interval</code>, <code id="formatMpfr_+3A_decimal.mark">decimal.mark</code>, <code id="formatMpfr_+3A_zero.print">zero.print</code>, <code id="formatMpfr_+3A_drop0trailing">drop0trailing</code></td>
<td>

<p>used for prettying decimal sequences, these are passed to
<code><a href="base.html#topic+prettyNum">prettyNum</a></code> and that help page explains the details.</p>
</td></tr>
<tr><td><code id="formatMpfr_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector or array, say <code>cx</code>, of the same length as
<code>x</code>.  Since Rmpfr version 0.5-3 (2013-09), if <code>x</code> is an
<code><a href="#topic+mpfrArray-class">mpfrArray</a></code>, then <code>cx</code> is a character
<code><a href="base.html#topic+array">array</a></code> with the same <code><a href="base.html#topic+dim">dim</a></code> and
<code><a href="base.html#topic+dimnames">dimnames</a></code> as <code>x</code>.
</p>
<p>Note that in scientific notation, the integer exponent is always in
<em>decimal</em>, i.e., base 10 (even when <code>base</code> is not 10), but
of course meaning <code>base</code> powers, e.g., in base 32,
<code>"u.giE3"</code>is the same as <code>"ugi0"</code> which is <code class="reqn">32^3</code> times
<code>"u.gi"</code>. This is in contrast, e.g., with
<code><a href="base.html#topic+sprintf">sprintf</a>("%a", x)</code> where the powers after <code>"p"</code> are
powers of <code class="reqn">2</code>.
</p>


<h3>Note</h3>

<p>Currently, <code>formatMpfr(x, scientific = FALSE)</code> does <em>not work
correctly</em>, e.g., for <code>x &lt;- Const("pi", 128) * 2^c(-200,200)</code>, i.e., it
uses the scientific / exponential-style format.
This is considered bogous and hopefully will change.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>The MPFR manual's description of &lsquo;<span class="samp">&#8288;mpfr_get_str()&#8288;</span>&rsquo; which is the
C-internal workhorse for <code>.mpfr2str()</code> (on which <code>formatMpfr()</code>
builds).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpfr">mpfr</a></code> for creation and
the <code><a href="#topic+mpfr-class">mpfr</a></code> class description with its many methods.
The <code><a href="base.html#topic+format">format</a></code> generic, and the <code><a href="base.html#topic+prettyNum">prettyNum</a></code>
utility on which <code>formatMpfr</code> is based as well.
The S3 generic function <code><a href="gmp.html#topic+formatN">formatN</a></code> from package
<span class="pkg">gmp</span>.
</p>
<p><code><a href="#topic+.mpfr_formatinfo">.mpfr_formatinfo</a>(x)</code> provides the (cheap) non-string parts of
<code>.mpfr2str(x)</code>; the (base 2) <code>exp</code> exponents are also available
via   <code><a href="#topic+.mpfr2exp">.mpfr2exp</a>(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Printing of MPFR numbers  uses formatMpfr() internally.
 ## Note how each components uses the "necessary" number of digits:
 ( x3 &lt;- c(Const("pi", 168), mpfr(pi, 140), 3.14) )
 format(x3[3], 15)
 format(x3[3], 15, drop0 = TRUE)# "3.14" .. dropping the trailing zeros
 x3[4] &lt;- 2^30
 x3[4] # automatically drops trailing zeros
 format(x3[1], dig = 41, small.mark = "'") # (41 - 1 = ) 40 digits after "."

 rbind(formatN(           x3,  digits = 15),
       formatN(as.numeric(x3), digits = 15))

 (Zero &lt;- mpfr(c(0,1/-Inf), 20)) # 0 and "-0"
 xx &lt;- c(Zero, 1:2, Const("pi", 120), -100*pi, -.00987)
 format(xx, digits = 2)
 format(xx, digits = 1, showNeg0 = FALSE)# "-0" no longer shown

## Output in other bases :
formatMpfr(mpfr(10^6, 40), base=32, drop0trailing=TRUE)
## "ugi0"
mpfr("ugi0", base=32) #-&gt; 1'000'000


## This now works: The large number shows "as" large integer:
x &lt;- Const("pi", 128) * 2^c(-200,200)
formatMpfr(x, scientific = FALSE) # was 1.955...e-60  5.048...e+60

i32 &lt;- mpfr(1:32, precBits = 64)
format(i32,   base=  2, drop0trailing=TRUE)
format(i32,   base= 16, drop0trailing=TRUE)
format(1/i32, base=  2, drop0trailing=TRUE)# using scientific notation for [17..32]
format(1/i32, base= 32)
format(1/i32, base= 62, drop0trailing=TRUE)
format(mpfr(2, 64)^-(1:16), base=16, drop0trailing=TRUE)
</code></pre>

<hr>
<h2 id='frexpMpfr'>Base-2 Representation and Multiplication of Mpfr Numbers</h2><span id='topic+frexpMpfr'></span><span id='topic+ldexpMpfr'></span>

<h3>Description</h3>

<p>MPFR - versions of the C99 (and POSIX) standard C (and C++) mathlib
functions <code>frexp()</code> and <code>ldexp()</code>.
</p>
<p><code>frexpMpfr(x)</code> computes base-2 exponent <code>e</code> and &ldquo;mantissa&rdquo;,
or <em>fraction</em> <code>r</code>, such that <code class="reqn">x = r * 2^e</code>, where <code class="reqn">r \in
    [0.5, 1)</code> (unless when <code>x</code> is in <code>c(0, -Inf, Inf, NaN)</code>
where <code>r == x</code> and <code>e</code> is 0),
and <code class="reqn">e</code> is integer valued.
</p>
<p><code>ldexpMpfr(f, E)</code> is the <em>inverse</em> of <code>frexpMpfr()</code>: Given
fraction or mantissa <code>f</code> and integer exponent <code>E</code>, it returns
<code class="reqn">x = f * 2^E</code>.
Viewed differently, it's the fastest way to multiply or divide MPFR
numbers with <code class="reqn">2^E</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frexpMpfr(x,    rnd.mode = c("N", "D", "U", "Z", "A"))
ldexpMpfr(f, E, rnd.mode = c("N", "D", "U", "Z", "A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frexpMpfr_+3A_x">x</code></td>
<td>
<p>numeric (coerced to <code>double</code>) vector.</p>
</td></tr>
<tr><td><code id="frexpMpfr_+3A_f">f</code></td>
<td>
<p>numeric fraction (vector), in <code class="reqn">[0.5, 1)</code>.</p>
</td></tr>
<tr><td><code id="frexpMpfr_+3A_e">E</code></td>
<td>
<p>integer valued, exponent of <code>2</code>, i.e., typically in
<code>(-1024-50):1024</code>, otherwise the result will underflow to 0 or
overflow to <code>+/- Inf</code>.</p>
</td></tr>
<tr><td><code id="frexpMpfr_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see <code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>frexpMpfr</code> returns a <code><a href="base.html#topic+list">list</a></code> with named components <code>r</code>
(of class <code>mpfr</code>) and <code>e</code> (integer valued, of type
<code>integer</code> is small enough, <code>"double"</code> otherwise).
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>On unix-alikes, typically <code>man frexp</code> and <code>man ldexp</code>
</p>


<h3>See Also</h3>

<p>Somewhat related, <code><a href="#topic+.mpfr2exp">.mpfr2exp</a>()</code>.
<code><a href="DPQ.html#topic+frexp">frexp</a>()</code> and <code>ldexp()</code> in package <a href="https://CRAN.R-project.org/package=DPQ"><span class="pkg">DPQ</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(47)
x &lt;- c(0, 2^(-3:3), (-1:1)/0,
       sort(rlnorm(2^12, 10, 20) * sample(c(-1,1), 512, replace=TRUE)))
head(xM &lt;- mpfr(x, 128), 11)
str(rFM &lt;- frexpMpfr(xM))
d.fr &lt;- with(rFM, data.frame(x=x, r=asNumeric(r), e=e))
head(d.fr , 16)
tail(d.fr)
ar &lt;- abs(rFM$r)
stopifnot(0.5 &lt;= ar[is.finite(x) &amp; x != 0], ar[is.finite(x)] &lt; 1,
          is.integer(rFM$e))
ldx &lt;- with(rFM, ldexpMpfr(r, e))
(iN &lt;- which(is.na(x))) # 10
stopifnot(exprs = {
  all.equal(xM, ldx, tol = 2^-124) # allow 4 bits loss, but apart from the NA, even:
  identical(xM[-iN], ldx[-iN])
  is.na(xM [iN])
  is.na(ldx[iN])
})
</code></pre>

<hr>
<h2 id='gmp-conversions'>Conversion Utilities gmp &lt;-&gt; Rmpfr</h2><span id='topic+.bigq2mpfr'></span><span id='topic+.bigz2mpfr'></span><span id='topic+.mpfr2bigz'></span><span id='topic+.mpfr2bigq'></span><span id='topic+coerce+2Cbigq+2Cmpfr-method'></span><span id='topic+coerce+2Cbigz+2Cmpfr-method'></span>

<h3>Description</h3>

<p>Coerce from and to big integers (<code><a href="gmp.html#topic+bigz">bigz</a></code>) and
<code><a href="#topic+mpfr">mpfr</a></code> numbers.
</p>
<p>Further, coerce from big rationals (<code><a href="gmp.html#topic+bigq">bigq</a></code>) to
<code><a href="#topic+mpfr">mpfr</a></code> numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.bigz2mpfr(x, precB = NULL, rnd.mode = c('N','D','U','Z','A'))
.bigq2mpfr(x, precB = NULL, rnd.mode = c('N','D','U','Z','A'))
.mpfr2bigz(x, mod = NA)
.mpfr2bigq(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmp-conversions_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object of class <code>bigz</code>, <code>bigq</code> or <code>mpfr</code>
respectively.</p>
</td></tr>
<tr><td><code id="gmp-conversions_+3A_precb">precB</code></td>
<td>
<p>precision in bits for the result.  The default,
<code>NULL</code>, means to use the <em>minimal</em> precision necessary for
correct representation.</p>
</td></tr>
<tr><td><code id="gmp-conversions_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see details of
<code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
<tr><td><code id="gmp-conversions_+3A_mod">mod</code></td>
<td>
<p>a possible modulus, see <code><a href="gmp.html#topic+as.bigz">as.bigz</a></code> in
package <span class="pkg">gmp</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that we also provide the natural (S4) coercions,
<code>as(x, "mpfr")</code> for <code>x</code> inheriting from class <code>"bigz"</code>
or <code>"bigq"</code>.
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as <code>x</code>, of the desired class.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpfr">mpfr</a>()</code>, <code><a href="gmp.html#topic+as.bigz">as.bigz</a></code> and
<code><a href="gmp.html#topic+as.bigq">as.bigq</a></code> in package <span class="pkg">gmp</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> S &lt;- gmp::Stirling2(50,10)
 show(S)
 SS &lt;- S * as.bigz(1:3)^128
 stopifnot(all.equal(log2(SS[2]) - log2(S), 128, tolerance=1e-15),
           identical(SS, .mpfr2bigz(.bigz2mpfr(SS))))

 .bigz2mpfr(S)            # 148 bit precision
 .bigz2mpfr(S, precB=256) # 256 bit

 ## rational --&gt; mpfr:
 sq &lt;- SS / as.bigz(2)^100
 MP &lt;- as(sq, "mpfr")
 stopifnot(identical(MP, .bigq2mpfr(sq)),
           SS == MP * as(2, "mpfr")^100)

 ## New since 2024-01-20:   mpfr --&gt; big rational "bigq"
 Pi &lt;- Const("pi", 128)
 m &lt;- Pi* 2^(-5:5)
 (m &lt;- c(m, mpfr(2, 128)^(-5:5)))

 getDenom &lt;- Rmpfr:::getDenom
 stopifnot(is.whole(m * (d.m &lt;- getDenom(m))))
 stopifnot(all.equal(m, mpfr(.mpfr2bigq(m), 130), tolerance = 2^-130)) # I see even
 all.equal(m, mpfr(.mpfr2bigq(m), 130), tolerance = 0) # TRUE

 m &lt;- m * mpfr(2, 128)^200 # quite a bit larger
 stopifnot(is.whole(m * (d.m &lt;- getDenom(m))))
 stopifnot(all.equal(m, mpfr(.mpfr2bigq(m), 130), tolerance = 2^-130)) # I see even
 all.equal(m, mpfr(.mpfr2bigq(m), 130), tolerance = 0) # TRUE

 m2 &lt;- m * mpfr(2, 128)^20000 ## really huge
 stopifnot(is.whole(m2 * (d.m2 &lt;- getDenom(m2))))
 stopifnot(all.equal(m2, mpfr(.mpfr2bigq(m2), 130), tolerance = 2^-130)) # I see even
           all.equal(m2, mpfr(.mpfr2bigq(m2), 130), tolerance = 0) # TRUE
</code></pre>

<hr>
<h2 id='hjkMpfr'>Hooke-Jeeves Derivative-Free Minimization R (working for MPFR)</h2><span id='topic+hjkMpfr'></span>

<h3>Description</h3>

<p>An implementation of the Hooke-Jeeves algorithm for derivative-free
optimization.

</p>
<p>This is a slight adaption <code><a href="dfoptim.html#topic+hjk">hjk</a>()</code> from package
<a href="https://CRAN.R-project.org/package=dfoptim"><span class="pkg">dfoptim</span></a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hjkMpfr(par, fn, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hjkMpfr_+3A_par">par</code></td>
<td>
<p>Starting vector of parameter values.    The initial vector may lie on the boundary. If <code>lower[i]=upper[i]</code>
for some <code>i</code>, the <code>i</code>-th component of the solution vector will
simply be kept fixed.</p>
</td></tr>
<tr><td><code id="hjkMpfr_+3A_fn">fn</code></td>
<td>
<p>Nonlinear objective function that is to be optimized.
A scalar function that takes a real vector as argument and
returns a scalar that is the value of the function at that point.</p>
</td></tr>
<tr><td><code id="hjkMpfr_+3A_control">control</code></td>
<td>
<p><code><a href="base.html#topic+list">list</a></code> of control parameters.  See
<b>Details</b> for more information.</p>
</td></tr>
<tr><td><code id="hjkMpfr_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>control</code> is a list specifing changes to default values of
algorithm control parameters.
Note that parameter names may be abbreviated as long as they are unique.
</p>
<p>The list items are as follows:
</p>

<dl>
<dt><code>tol</code></dt><dd><p>Convergence tolerance. Iteration is terminated when the
step length of the main loop becomes smaller than <code>tol</code>. This does
<em>not</em> imply that the optimum is found with the same accuracy.
Default is 1.e-06.</p>
</dd>
<dt><code>maxfeval</code></dt><dd><p>Maximum number of objective function evaluations
allowed. Default is Inf, that is no restriction at all.</p>
</dd>
<dt><code>maximize</code></dt><dd><p>A logical indicating whether the objective function
is to be maximized (TRUE) or minimized (FALSE). Default is FALSE.</p>
</dd>
<dt><code>target</code></dt><dd><p>A real number restricting the absolute function value.
The procedure stops if this value is exceeded.
Default is Inf, that is no restriction.</p>
</dd>
<dt><code>info</code></dt><dd><p>A logical variable indicating whether the step number,
number of function calls, best function value, and the first component of
the solution vector will be printed to the console. Default is FALSE.</p>
</dd>
</dl>

<p>If the minimization process threatens to go into an infinite loop, set
either <code>maxfeval</code> or <code>target</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with the following components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>Best estimate of the parameter vector found by the algorithm.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>value of the objective function at termination.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>indicates convergence (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>feval</code></td>
<td>
<p>number of times the objective <code>fn</code> was evaluated.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of iterations (&ldquo;steps&rdquo;) in the main loop.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This algorithm is based on the Matlab code of Prof. C. T. Kelley, given
in his book &ldquo;Iterative methods for optimization&rdquo;.
It has been implemented for package <span class="pkg">dfoptim</span> with the permission
of Prof. Kelley.
</p>
<p>This version does not (yet) implement a cache for storing function values
that have already been computed as searching the cache makes it slower.
</p>


<h3>Author(s)</h3>

<p>Hans W Borchers <a href="mailto:hwborchers@googlemail.com">hwborchers@googlemail.com</a>; for <span class="pkg">Rmpfr</span>:
John Nash, June 2012.   Modifications by Martin Maechler.</p>


<h3>References</h3>

<p>C.T. Kelley (1999), Iterative Methods for Optimization, SIAM.
</p>
<p>Quarteroni, Sacco, and Saleri (2007), Numerical Mathematics, Springer.
</p>


<h3>See Also</h3>

<p>Standard <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+optim">optim</a></code>;
<code><a href="#topic+optimizeR">optimizeR</a></code> provides <em>one</em>-dimensional minimization
methods that work with <code><a href="#topic+mpfr-class">mpfr</a></code>-class numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple smooth example:
ff &lt;- function(x) sum((x - c(2:4))^2)
str(rr &lt;- hjkMpfr(rep(mpfr(0,128), 3), ff, control=list(info=TRUE)))

doX &lt;- Rmpfr:::doExtras(); cat("doExtras: ", doX, "\n") # slow parts only if(doX)

## Hooke-Jeeves solves high-dim. Rosenbrock function  {but slowly!}
rosenbrock &lt;- function(x) {
    n &lt;- length(x)
    sum (100*((x1 &lt;- x[1:(n-1)])^2 - x[2:n])^2 + (x1 - 1)^2)
}
par0 &lt;- rep(0, 10)
str(rb.db &lt;- hjkMpfr(rep(0, 10), rosenbrock, control=list(info=TRUE)))
if(doX) {
## rosenbrook() is quite slow with mpfr-numbers:
str(rb.M. &lt;- hjkMpfr(mpfr(numeric(10), prec=128), rosenbrock,
                     control = list(tol = 1e-8, info=TRUE)))
}


##  Hooke-Jeeves does not work well on non-smooth functions
nsf &lt;- function(x) {
  f1 &lt;- x[1]^2 + x[2]^2
  f2 &lt;- x[1]^2 + x[2]^2 + 10 * (-4*x[1] - x[2] + 4)
  f3 &lt;- x[1]^2 + x[2]^2 + 10 * (-x[1] - 2*x[2] + 6)
  max(f1, f2, f3)
}
par0 &lt;- c(1, 1) # true min 7.2 at (1.2, 2.4)
h.d &lt;- hjkMpfr(par0,            nsf) # fmin=8 at xmin=(2,2)
if(doX) {
## and this is not at all better (but slower!)
h.M &lt;- hjkMpfr(mpfr(c(1,1), 128), nsf, control = list(tol = 1e-15))
}
## --&gt; demo(hjkMpfr) # -&gt; Fletcher's chebyquad function m = n -- residuals
</code></pre>

<hr>
<h2 id='igamma'>Incomplete Gamma Function</h2><span id='topic+igamma'></span>

<h3>Description</h3>


<p>For MPFR version &gt;= 3.2.0, the following MPFR library function is provided:
<code>mpfr_gamma_inc(a,x)</code>, the <span class="rlang"><b>R</b></span> interface of which is <code>igamma(a,x)</code>, where
<code>igamma(a,x)</code> is the &ldquo;upper&rdquo; incomplete gamma function

</p>
<p style="text-align: center;"><code class="reqn">\Gamma(a,x) :=: \Gamma(a) - \gamma(a,x),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\gamma(a,x) := \int_0^x      t^{a-1} e^{-t} dt,</code>
</p>

<p>and hence
</p>
<p style="text-align: center;"><code class="reqn">\Gamma(a,x) := \int_x^\infty t^{a-1} e^{-t} dt,</code>
</p>

<p>and </p>
<p style="text-align: center;"><code class="reqn">\Gamma(a) := \gamma(a, \infty).</code>
</p>

<p>As <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+pgamma">pgamma</a>(x,a)</code> is
</p>
<p style="text-align: center;"><code class="reqn">\code{pgamma(x, a)} := \gamma(a,x) / \Gamma(a),</code>
</p>

<p>we get </p>
<pre>        igamma(a,x) ==  gamma(a) * pgamma(x, a, lower.tail=FALSE)</pre>


<h3>Usage</h3>

<pre><code class='language-R'>igamma(a, x, rnd.mode = c("N", "D", "U", "Z", "A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igamma_+3A_a">a</code>, <code id="igamma_+3A_x">x</code></td>
<td>
<p>an object of class <code>mpfr</code> or <code><a href="base.html#topic+numeric">numeric</a></code>.</p>
</td></tr>
<tr><td><code id="igamma_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see <code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of &ldquo;common length&rdquo;, recyling along <code>a</code> and <code>x</code>.
</p>


<h3>Author(s)</h3>

<p><span class="rlang"><b>R</b></span> interface: Martin Maechler</p>


<h3>References</h3>

<p>NIST Digital Library of Mathematical Functions, section 8.2.
<a href="https://dlmf.nist.gov/8.2.i">https://dlmf.nist.gov/8.2.i</a>
</p>
<p>Wikipedia (2019). <em>Incomplete gamma function</em>;
<a href="https://en.wikipedia.org/wiki/Incomplete_gamma_function">https://en.wikipedia.org/wiki/Incomplete_gamma_function</a>
</p>



<h3>See Also</h3>

<p><span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+gamma">gamma</a></code> (function) and <code><a href="stats.html#topic+pgamma">pgamma</a></code> (probability distribution).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## show how close pgamma() is :
x &lt;- c(seq(0,20, by=1/4), 21:50, seq(55, 100, by=5))
if(mpfrVersion() &gt;= "3.2.0") { print(
all.equal(igamma(Const("pi", 80), x),
          pgamma(x, pi, lower.tail=FALSE) * gamma(pi),
          tol=0, formatFUN = function(., ...) format(., digits = 7)) #-&gt; 2.75e-16 (was 3.13e-16)
)
## and ensure *some* closeness:
stopifnot(exprs = {
   all.equal(igamma(Const("pi", 80), x),
             pgamma(x, pi, lower.tail=FALSE) * gamma(pi),
             tol = 1e-15)
})
} # only if MPFR version &gt;= 3.2.0
</code></pre>

<hr>
<h2 id='integrateR'>One-Dimensional Numerical Integration - in pure R</h2><span id='topic+integrateR'></span><span id='topic+print.integrateR'></span><span id='topic+show+2CintegrateR-method'></span>

<h3>Description</h3>

<p>Numerical integration of one-dimensional functions in pure <span class="rlang"><b>R</b></span>,
with care so it also works for <code>"mpfr"</code>-numbers.
</p>
<p>Currently, only classical Romberg integration of order <code>ord</code> is
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateR(f, lower, upper, ..., ord = NULL,
           rel.tol = .Machine$double.eps^0.25, abs.tol = rel.tol,
           max.ord = 19, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrateR_+3A_f">f</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> function taking a numeric or <code>"mpfr"</code> first
argument and returning a numeric (or <code>"mpfr"</code>) vector of the
same length.  Returning a non-finite element will generate an error.
</p>
</td></tr>
<tr><td><code id="integrateR_+3A_lower">lower</code>, <code id="integrateR_+3A_upper">upper</code></td>
<td>
<p>the limits of integration.  Currently <em>must</em>
be finite.  Do use <code>"mpfr"</code>-numbers to get higher than double
precision, see the examples.</p>
</td></tr>
<tr><td><code id="integrateR_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>f</code>.</p>
</td></tr>
<tr><td><code id="integrateR_+3A_ord">ord</code></td>
<td>
<p>integer, the order of Romberg integration to be used.  If
this is <code>NULL</code>, as per default, and either <code>rel.tol</code> or
<code>abs.tol</code> are specified, the order is increased until
convergence.</p>
</td></tr>
<tr><td><code id="integrateR_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative accuracy requested.  The default is 1.2e-4,
about 4 digits only, see the Note.</p>
</td></tr>
<tr><td><code id="integrateR_+3A_abs.tol">abs.tol</code></td>
<td>
<p>absolute accuracy requested.</p>
</td></tr>
<tr><td><code id="integrateR_+3A_max.ord">max.ord</code></td>
<td>
<p>only used, when neither <code>ord</code> or one of
<code>rel.tol</code>, <code>abs.tol</code> are specified:  Stop Romberg
iterations after the order reaches <code>max.ord</code>; may prevent
infinite loops or memory explosion.</p>
</td></tr>
<tr><td><code id="integrateR_+3A_verbose">verbose</code></td>
<td>
<p>logical or integer, indicating if and how much
information should be printed during computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that arguments after <code>...</code> must be matched exactly.
</p>
<p>For convergence, <em>both</em> relative and absolute changes must be
smaller than <code>rel.tol</code> and <code>abs.tol</code>, respectively.
</p>
<p><code>rel.tol</code> cannot be less than <code>max(50*.Machine$double.eps,
    0.5e-28)</code> if <code>abs.tol &lt;= 0</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"integrateR"</code> (as from standard <span class="rlang"><b>R</b></span>'s
<code><a href="stats.html#topic+integrate">integrate</a>()</code>) with a <code><a href="base.html#topic+print">print</a></code> method and components
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>the final estimate of the integral.</p>
</td></tr>
<tr><td><code>abs.error</code></td>
<td>
<p>estimate of the modulus of the absolute error.</p>
</td></tr>
<tr><td><code>subdivisions</code></td>
<td>
<p>for Romberg, the number of function evaluations.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p><code>"OK"</code> or a character string giving the error message.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>f</code> must accept a vector of inputs and produce a vector of function
evaluations at those points.  The <code><a href="base.html#topic+Vectorize">Vectorize</a></code> function
may be helpful to convert <code>f</code> to this form.
</p>
<p>If you want to use higher accuracy, you <em>must</em> set <code>lower</code> or
<code>upper</code> to <code>"<a href="#topic+mpfr">mpfr</a>"</code> numbers (and typically lower the
relative tolerance, <code>rel.tol</code>), see also the examples.
</p>
<p>Note that the default tolerances (<code>rel.tol</code>, <code>abs.tol</code>) are
not very accurate, but the same as for <code><a href="stats.html#topic+integrate">integrate</a></code>, which
however often returns considerably more accurate results than
requested.  This is typically <em>not</em> the case for
<code>integrateR()</code>.
</p>


<h3>Note</h3>

<p>We use practically the same <code>print</code> S3 method as
<code><a href="stats.html#topic+print.integrate">print.integrate</a></code>, provided by <span class="rlang"><b>R</b></span>,
with a difference when the <code>message</code> component is not <code>"Ok"</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Bauer, F.L. (1961)
Algorithm 60 &ndash; Romberg Integration,
<em>Communications of the ACM</em> <b>4</b>(6), p.255.
</p>


<h3>See Also</h3>

<p><span class="rlang"><b>R</b></span>'s standard, <code><a href="stats.html#topic+integrate">integrate</a></code>, is much more adaptive,
also allowing infinite integration boundaries, and typically
considerably faster for a given accuracy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## See more  from  ?integrate
## this is in the region where  integrate() can get problems:
integrateR(dnorm,0,2000)
integrateR(dnorm,0,2000, rel.tol=1e-15)
(Id &lt;- integrateR(dnorm,0,2000, rel.tol=1e-15, verbose=TRUE))
Id$value == 0.5 # exactly

## Demonstrating that 'subdivisions' is correct:
Exp &lt;- function(x) { .N &lt;&lt;- .N+ length(x); exp(x) }
.N &lt;- 0; str(integrateR(Exp, 0,1, rel.tol=1e-10), digits=15); .N

### Using high-precision functions -----

## Polynomials are very nice:
integrateR(function(x) (x-2)^4 - 3*(x-3)^2, 0, 5, verbose=TRUE)
# n= 1, 2^n=        2 | I =            46.04, abs.err =      98.9583
# n= 2, 2^n=        4 | I =               20, abs.err =      26.0417
# n= 3, 2^n=        8 | I =               20, abs.err =  7.10543e-15
## 20 with absolute error &lt; 7.1e-15
## Now, using higher accuracy:
I &lt;- integrateR(function(x) (x-2)^4 - 3*(x-3)^2, 0, mpfr(5,128),
                rel.tol = 1e-20, verbose=TRUE)
I ; I$value  ## all fine

## with floats:
integrateR(exp,      0     , 1, rel.tol=1e-15, verbose=TRUE)
## with "mpfr":
(I &lt;- integrateR(exp, mpfr(0,200), 1, rel.tol=1e-25, verbose=TRUE))
(I.true &lt;- exp(mpfr(1, 200)) - 1)
## true absolute error:
stopifnot(print(as.numeric(I.true - I$value)) &lt; 4e-25)

## Want absolute tolerance check only (=&gt; set 'rel.tol' very high, e.g. 1):
(Ia &lt;- integrateR(exp, mpfr(0,200), 1, abs.tol = 1e-6, rel.tol=1, verbose=TRUE))

## Set 'ord' (but no  '*.tol') --&gt; Using 'ord'; no convergence checking
(I &lt;- integrateR(exp, mpfr(0,200), 1,  ord = 13, verbose=TRUE))

</code></pre>

<hr>
<h2 id='is.whole'>Whole (&quot;Integer&quot;) Numbers</h2><span id='topic+is.whole.mpfr'></span>

<h3>Description</h3>

<p>Check which elements of <code>x[]</code> are integer valued aka
&ldquo;whole&rdquo; numbers,including MPFR
numbers (class <code><a href="#topic+mpfr-class">mpfr</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpfr'
is.whole(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.whole_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> vector, here of <code><a href="base.html#topic+class">class</a></code> <code><a href="#topic+mpfr-class">mpfr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector of the same length as <code>x</code>, indicating where
<code>x[.]</code> is integer valued.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+is.integer">is.integer</a>(x)</code> (<span class="pkg">base</span> package) checks for the
<em>internal</em> mode or class, not if <code>x[i]</code> are integer valued.
</p>
<p>The <code><a href="gmp.html#topic+is.whole">is.whole</a>()</code> methods in package <span class="pkg">gmp</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> is.integer(3) # FALSE, it's internally a double
 is.whole(3)   # TRUE
 x &lt;- c(as(2,"mpfr") ^ 100, 3, 3.2, 1000000, 2^40)
 is.whole(x) # one FALSE, only

</code></pre>

<hr>
<h2 id='log1mexp'>Compute  f(a) = <code class="reqn">\mathrm{log}</code>(1 +/- <code class="reqn">\mathrm{exp}</code>(-a))
Numerically Optimally</h2><span id='topic+log1pexp'></span><span id='topic+log1mexp'></span>

<h3>Description</h3>

<p>Compute f(a) = log(1 - exp(-a)), respectively
g(x) = log(1 + exp(x))  quickly numerically accurately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log1mexp(a, cutoff = log(2))
log1pexp(x, c0 = -37, c1 = 18, c2 = 33.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log1mexp_+3A_a">a</code></td>
<td>
<p>numeric (or <code><a href="#topic+mpfr">mpfr</a></code>) vector of positive values.</p>
</td></tr>
<tr><td><code id="log1mexp_+3A_x">x</code></td>
<td>
<p>numeric vector, may also be an <code>"<a href="#topic+mpfr">mpfr</a>"</code> object.</p>
</td></tr>
<tr><td><code id="log1mexp_+3A_cutoff">cutoff</code></td>
<td>
<p>positive number; <code>log(2)</code> is &ldquo;optimal&rdquo;,

but the exact value is unimportant, and anything in
<code class="reqn">[0.5, 1]</code> is fine.</p>
</td></tr>
<tr><td><code id="log1mexp_+3A_c0">c0</code>, <code id="log1mexp_+3A_c1">c1</code>, <code id="log1mexp_+3A_c2">c2</code></td>
<td>
<p>cutoffs for <code>log1pexp</code>; see below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p style="text-align: center;"><code class="reqn">log1mexp(a) := f(a) = \log(1 - \exp(-a)) = \mathrm{log1p}(-\exp(-a)) = \log(-\mathrm{expm1}(-a))</code>
</p>

<p>or, respectively,
</p>
<p style="text-align: center;"><code class="reqn">log1pexp(x) := g(x) = \log(1 + \exp(x)) = \mathrm{log1p}(\exp(x))</code>
</p>

<p>computed accurately and quickly.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, May 2002; <code>log1pexp()</code> in 2012</p>


<h3>References</h3>


<p>Martin Mächler (2012).
Accurately Computing <code class="reqn">\log(1-\exp(-|a|))</code>;
<a href="https://CRAN.R-project.org/package=Rmpfr/vignettes/log1mexp-note.pdf">https://CRAN.R-project.org/package=Rmpfr/vignettes/log1mexp-note.pdf</a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>fExpr &lt;- expression(
          DEF   = log(1 - exp(-a)),
          expm1 = log(-expm1(-a)),
          log1p = log1p(-exp(-a)),
          F     = log1mexp(a))
a. &lt;- 2^seq(-58, 10, length = 256)
a &lt;- a. ; str(fa &lt;- do.call(cbind, as.list(fExpr)))
head(fa)# expm1() works here
tail(fa)# log1p() works here

## graphically:
lwd &lt;- 1.5*(5:2); col &lt;- adjustcolor(1:4, 0.4)
op &lt;- par(mfcol=c(1,2), mgp = c(1.25, .6, 0), mar = .1+c(3,2,1,1))
  matplot(a, fa, type = "l", log = "x", col=col, lwd=lwd)
  legend("topleft", fExpr, col=col, lwd=lwd, lty=1:4, bty="n")
  # expm1() &amp; log1mexp() work here

  matplot(a, -fa, type = "l", log = "xy", col=col, lwd=lwd)
  legend("left", paste("-",fExpr), col=col, lwd=lwd, lty=1:4, bty="n")
  # log1p() &amp; log1mexp() work here
par(op)

aM &lt;- 2^seqMpfr(-58, 10, length=length(a.)) # =&gt; default prec = 128
a &lt;- aM; dim(faM &lt;- do.call(cbind, as.list(fExpr))) # 256 x 4, "same" as 'fa'
## Here, for small 'a' log1p() and even 'DEF' is still good enough
l_f &lt;- asNumeric(log(-faM))
all.equal(l_f[,"F"], l_f[,"log1p"], tol=0) # see TRUE (Lnx 64-bit)
io &lt;- a. &lt; 80 # for these, the differences are small
all.equal(l_f[io,"F"], l_f[io,"expm1"], tol=0) # see 6.662e-9
all.equal(l_f[io,"F"], l_f[io, "DEF" ], tol=0)
stopifnot(exprs = {
  all.equal(l_f[,"F"], l_f[,"log1p"],     tol= 1e-15)
  all.equal(l_f[io,"F"], l_f[io,"expm1"], tol= 1e-7)
  all.equal(l_f[io,"F"], l_f[io, "DEF" ], tol= 1e-7)
})
## For 128-bit prec, if we go down to 2^-130, "log1p" is no longer ok:
aM2 &lt;- 2^seqMpfr(-130, 10, by = 1/2)
a &lt;- aM2; fa2 &lt;- do.call(cbind, as.list(fExpr))
head(asNumeric(fa2), 12)
tail(asNumeric(fa2), 12)

matplot(a, log(-fa2[,1:3]) -log(-fa2[,"F"]),  type="l", log="x",
        lty=1:3, lwd=2*(3:1)-1, col=adjustcolor(2:4, 1/3))
legend("top", colnames(fa2)[1:3], lty=1:3, lwd=2*(3:1)-1, col=adjustcolor(2:4, 1/3))

cols &lt;- adjustcolor(2:4, 1/3); lwd &lt;- 2*(3:1)-1
matplot(a, 1e-40+abs(log(-fa2[,1:3]) -log(-fa2[,"F"])),  type="o", log="xy",
        main = "log1mexp(a) -- approximation rel.errors, mpfr(*, prec=128)",
        pch=21:23, cex=.6, bg=5:7, lty=1:2, lwd=lwd, col=cols)
legend("top", colnames(fa2)[1:3], bty="n", lty=1:2, lwd=lwd, col=cols,
        pch=21:23, pt.cex=.6, pt.bg=5:7)


## -------------------------- log1pexp() [simpler] --------------------

curve(log1pexp, -10, 10, asp=1)
abline(0,1, h=0,v=0, lty=3, col="gray")

## Cutoff c1 for log1pexp() -- not often "needed":
curve(log1p(exp(x)) - log1pexp(x), 16, 20, n=2049)
## need for *some* cutoff:
x &lt;- seq(700, 720, by=2)
cbind(x, log1p(exp(x)), log1pexp(x))

## Cutoff c2 for log1pexp():
curve((x+exp(-x)) - x, 20, 40, n=1025)
curve((x+exp(-x)) - x, 33.1, 33.5, n=1025)
</code></pre>

<hr>
<h2 id='matmult'>(MPFR) Matrix (Vector) Multiplication</h2><span id='topic+matmult'></span><span id='topic+.matmult.R'></span>

<h3>Description</h3>

<p>Matrix / vector multiplication of <code><a href="#topic+mpfr">mpfr</a></code> (and &ldquo;simple&rdquo;
<code><a href="base.html#topic+numeric">numeric</a></code>) matrices and vectors.
</p>
<p><code> matmult (x,y, fPrec = 2)</code> or
<code>crossprod(x,y, fPrec = 2)</code> use higher precision in underlying computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matmult(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matmult_+3A_x">x</code>, <code id="matmult_+3A_y">y</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code>-classed <span class="rlang"><b>R</b></span>
objects, i.e. semantically numeric matrices or vectors.</p>
</td></tr>
<tr><td><code id="matmult_+3A_...">...</code></td>
<td>
<p>arguments passed to the hidden underlying
<code>.matmult.R()</code> work horse which is also underlying the
<code><a href="base.html#topic++25+2A+25">%*%</a></code>, <code><a href="base.html#topic+crossprod">crossprod</a>()</code>, and <code><a href="base.html#topic+tcrossprod">tcrossprod</a>()</code>
methods, see the <code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code> class documentation:
</p>

<dl>
<dt>fPrec</dt><dd><p>a multiplication factor, a positive number determining
the number of bits <code>precBits</code> used for the underlying
multiplication and summation arithmetic.  The default is
<code>fPrec = 1</code>.  Setting <code>fPrec = 2</code> doubles the
precision which has been recommended, e.g., by John Nash.</p>
</dd>
<dt>precBits</dt><dd><p>the number of bits used for the underlying
multiplication and summation arithmetic; by default
<code>precBits = fPrec * max(getPrec(x), getPrec(y))</code> which
typically uses the same accuracy as regular
<code><a href="#topic+mpfr">mpfr</a></code>-arithmetic would use.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a (base <span class="rlang"><b>R</b></span>) <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code>,
depending on the classes of <code>x</code> and <code>y</code>.
</p>


<h3>Note</h3>

<p>Using <code>matmult(x,y)</code> instead of <code>x <a href="base.html#topic++25+2A+25">%*%</a> y</code>, makes sense
mainly <em>if</em> you use non-default <code>fPrec</code> or <code>precBits</code> arguments.
</p>
<p>The <code><a href="base.html#topic+crossprod">crossprod</a>()</code>, and <code><a href="base.html#topic+tcrossprod">tcrossprod</a>()</code> function
have the <em>identical</em> optional arguments <code>fPrec</code> or <code>precBits</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic++25+2A+25">%*%</a></code>,
<code><a href="base.html#topic+crossprod">crossprod</a></code>, <code><a href="base.html#topic+tcrossprod">tcrossprod</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## FIXME: add example

## 1)  matmult()  &lt;--&gt;  %*%

## 2)  crossprod() , tcrossprod()  %% &lt;--&gt; ./mpfrMatrix-class.Rd  examples  (!)
</code></pre>

<hr>
<h2 id='Mnumber-class'>Class &quot;Mnumber&quot; and &quot;mNumber&quot; of &quot;mpfr&quot; and regular numbers and arrays from them</h2><span id='topic+Mnumber-class'></span><span id='topic+mNumber-class'></span><span id='topic+numericVector-class'></span>

<h3>Description</h3>

<p>Classes <code>"Mnumber"</code>  <code>"mNumber"</code> are class unions of <code>"<a href="#topic+mpfr-class">mpfr</a>"</code>
and regular numbers and arrays from them.<br />
Its purpose is for method dispatch, notably defining a
<code>cbind(...)</code> method where <code>...</code> contains objects of one of
the member classes of <code>"Mnumber"</code>.
</p>
<p>Classes <code>"mNumber"</code> is considerably smaller is it does <em>not</em>
contain <code>"matrix"</code> and <code>"array"</code> since these also extend <code>"character"</code>
which is not really desirable for generalized numbers.
It extends the simple <code>"numericVector"</code> class by <code>mpfr*</code> classes.
</p>


<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature(x = "mpfrMatrix", y = "Mnumber")</code>: ... </p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "mpfr", y = "Mnumber")</code>: ... </p>
</dd>
<dt>tcrossprod</dt><dd><p><code>signature(x = "Mnumber", y = "mpfr")</code>: ...</p>
</dd>
</dl>

<p>etc.  These are documented with the classes <code><a href="#topic+mpfr-class">mpfr</a></code>
and or <code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code>.
</p>


<h3>See Also</h3>

<p>the <code><a href="#topic+array_or_vector-class">array_or_vector</a></code> sub class;
<code><a href="#topic+cbind-methods">cbind-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## "Mnumber" encompasses (i.e., "extends") quite a few
##  "vector / array - like" classes:
showClass("Mnumber")
stopifnot(extends("mpfrMatrix", "Mnumber"),
          extends("array",      "Mnumber"))

Mnsub &lt;- names(getClass("Mnumber")@subclasses)
(mNsub &lt;- names(getClass("mNumber")@subclasses))
## mNumber has *one* subclass which is not in Mnumber:
setdiff(mNsub, Mnsub)# namely "numericVector"
## The following are only subclasses of "Mnumber", but not of "mNumber":
setdiff(Mnsub, mNsub)
</code></pre>

<hr>
<h2 id='mpfr'>Create &quot;mpfr&quot; Numbers (Objects)</h2><span id='topic+mpfr'></span><span id='topic+is.mpfr'></span><span id='topic+mpfr.default'></span><span id='topic+mpfr.mpfr'></span><span id='topic+Const'></span>

<h3>Description</h3>

<p>Create multiple (i.e. typically <em>high</em>) precision numbers, to be
used in arithmetic and mathematical computations with <span class="rlang"><b>R</b></span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpfr(x, precBits, ...)
## Default S3 method:
mpfr(x, precBits, base = 10,
     rnd.mode = c("N","D","U","Z","A"), scientific = NA, ...)

Const(name = c("pi", "gamma", "catalan", "log2"), prec = 120L,
      rnd.mode = c("N","D","U","Z","A"))

is.mpfr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpfr_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code>, <code><a href="#topic+mpfr-class">mpfr</a></code>,
<code><a href="gmp.html#topic+bigz">bigz</a></code>, <code><a href="gmp.html#topic+bigq">bigq</a></code>, or
<code><a href="base.html#topic+character">character</a></code> vector or <code><a href="base.html#topic+array">array</a></code>.</p>
</td></tr>
<tr><td><code id="mpfr_+3A_precbits">precBits</code>, <code id="mpfr_+3A_prec">prec</code></td>
<td>
<p>a number, the maximal precision to be used, in
<b><em>bits</em></b>; i.e. <code>53</code> corresponds to double precision.
Must be at least 2.  If <code><a href="base.html#topic+missing">missing</a></code>,
<code><a href="#topic+getPrec">getPrec</a>(x)</code> determines a default precision.</p>
</td></tr>
<tr><td><code id="mpfr_+3A_base">base</code></td>
<td>
<p>(only when <code>x</code> is <code><a href="base.html#topic+character">character</a></code>) the base
with respect to which <code>x[i]</code> represent numbers; <code>base</code>
<code class="reqn">b</code> must fulfill <code class="reqn">2 \le b \le 62</code>.</p>
</td></tr>
<tr><td><code id="mpfr_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see details.</p>
</td></tr>
<tr><td><code id="mpfr_+3A_scientific">scientific</code></td>
<td>
<p>(used only when <code>x</code> is the result of
<code><a href="#topic+formatBin">formatBin</a>()</code>, i.e., of class <code>"Bcharacter"</code>:)
logical indicating that the binary representation of <code>x</code> is in
scientific notation.  When <code>TRUE</code>, <code>mpfr()</code> will substitute
<code>0</code> for <code>_</code>; when <code>NA</code>, <code>mpfr()</code> will guess, and
use <code>TRUE</code> when finding a <code>"p"</code> in <code>x</code>; see also
<code><a href="#topic+formatBin">formatBin</a></code>.</p>
</td></tr>
<tr><td><code id="mpfr_+3A_name">name</code></td>
<td>
<p>a string specifying the mpfrlib - internal constant
computation.  <code>"gamma"</code> is Euler's gamma (<code class="reqn">\gamma</code>), and
<code>"catalan"</code> Catalan's constant.</p>
</td></tr>
<tr><td><code id="mpfr_+3A_...">...</code></td>
<td>
<p>potentially further arguments passed to and from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"<a href="#topic+mpfr-class">mpfr</a>"</code> method of <code>mpfr()</code> is a simple
wrapper around <code><a href="#topic+roundMpfr">roundMpfr</a>()</code>.
</p>
<p>MPFR supports the following rounding modes,

</p>

<dl>
<dt>GMP_RND<b>N</b>:</dt><dd><p>round to <b>n</b>earest (roundTiesToEven in
IEEE 754-2008).</p>
</dd>
<dt>GMP_RND<b>Z</b>:</dt><dd><p>round toward <b>z</b>ero (roundTowardZero in
IEEE 754-2008).</p>
</dd>
<dt>GMP_RND<b>U</b>:</dt><dd><p>round toward plus infinity (&ldquo;Up&rdquo;,
roundTowardPositive in IEEE 754-2008).</p>
</dd>
<dt>GMP_RND<b>D</b>:</dt><dd><p>round toward minus infinity (&ldquo;Down&rdquo;,
roundTowardNegative in IEEE 754-2008).</p>
</dd>
<dt>GMP_RND<b>A</b>:</dt><dd><p>round <b>a</b>way from zero (new since MPFR 3.0.0).</p>
</dd>
</dl>

<p>The &lsquo;round to nearest&rsquo; (<code>"N"</code>) mode, the default here,
works as in the IEEE 754 standard: in case the number to be rounded
lies exactly in the middle of two representable numbers, it is rounded
to the one with the least significant bit set to zero.  For example,
the number 5/2, which is represented by (10.1) in binary, is rounded
to (10.0)=2 with a precision of two bits, and not to (11.0)=3.  This
rule avoids the &quot;drift&quot; phenomenon mentioned by Knuth in volume 2 of
The Art of Computer Programming (Section 4.2.2).
</p>
<p>When <code>x</code> is <code><a href="base.html#topic+character">character</a></code>, <code>mpfr()</code>
will detect the precision of the input object. 
</p>


<h3>Value</h3>

<p>an object of (S4) class <code><a href="#topic+mpfr-class">mpfr</a></code>, or for
<code>mpfr(x)</code> when <code>x</code> is an array,
<code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code>, or <code><a href="#topic+mpfrArray-class">mpfrArray</a></code>
which the user should just as a normal numeric vector or array.
</p>
<p><code>is.mpfr()</code> returns <code>TRUE</code> or <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>The MPFR team. (202x).
<em>GNU MPFR &ndash; The Multiple Precision Floating-Point Reliable
Library</em>; see <a href="https://www.mpfr.org/mpfr-current/#doc">https://www.mpfr.org/mpfr-current/#doc</a> or directly
<a href="https://www.mpfr.org/mpfr-current/mpfr.pdf">https://www.mpfr.org/mpfr-current/mpfr.pdf</a>.
</p>


<h3>See Also</h3>

<p>The class documentation <code><a href="#topic+mpfr-class">mpfr</a></code> contains more
details.  Use <code><a href="gmp.html#topic+asNumeric">asNumeric</a></code> to transform back to double
precision (&quot;<code><a href="base.html#topic+numeric">numeric</a></code>&quot;).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mpfr(pi, 120) ## the double-precision pi "translated" to 120-bit precision

pi. &lt;- Const("pi", prec = 260) # pi "computed" to correct 260-bit precision
pi. # nicely prints 80 digits [260 * log10(2) ~= 78.3 ~ 80]

Const("gamma",   128L) # 0.5772...
Const("catalan", 128L) # 0.9159...

x &lt;- mpfr(0:7, 100)/7 # a more precise version of  k/7, k=0,..,7
x
1 / x

## character input :
mpfr("2.718281828459045235360287471352662497757") - exp(mpfr(1, 150))
## ~= -4 * 10^-40
## Also works for  NA, NaN, ... :
cx &lt;- c("1234567890123456", 345, "NA", "NaN", "Inf", "-Inf")
mpfr(cx)

## with some 'base' choices :
print(mpfr("111.1111", base=2)) * 2^4

mpfr("af21.01020300a0b0c", base=16)
##  68 bit prec.  44833.00393694653820642

mpfr("ugi0", base = 32) == 10^6   ## TRUE

## --- Large integers from package 'gmp':
Z &lt;- as.bigz(7)^(1:200)
head(Z, 40)
## mfpr(Z) by default chooses the correct *maximal* default precision:
mZ. &lt;- mpfr(Z)
## more efficiently chooses precision individually
m.Z &lt;- mpfr(Z, precBits = frexpZ(Z)$exp)
## the precBits chosen are large enough to keep full precision:
stopifnot(identical(cZ &lt;- as.character(Z),
                    as(mZ.,"character")),
          identical(cZ, as(m.Z,"character")))

## compare mpfr-arithmetic with exact rational one:
stopifnot(all.equal(mpfr(as.bigq(355,113), 99),
                    mpfr(355, 99) / 113,	tol = 2^-98))

## look at different "rounding modes":
sapply(c("N", "D","U","Z","A"), function(RND)
       mpfr(c(-1,1)/5, 20, rnd.mode = RND), simplify=FALSE)

symnum(sapply(c("N", "D","U","Z","A"),
              function(RND) mpfr(0.2, prec = 5:15, rnd.mode = RND) &lt; 0.2 ))
</code></pre>

<hr>
<h2 id='mpfr-class'>Class &quot;mpfr&quot; of Multiple Precision Floating Point Numbers</h2><span id='topic+mpfr-class'></span><span id='topic+mpfr1-class'></span><span id='topic+summaryMpfr-class'></span><span id='topic++5B+5B+2Cmpfr-method'></span><span id='topic++5B+2Cmpfr+2CANY+2Cmissing+2Cmissing-method'></span><span id='topic++5B+3C-+2Cmpfr+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cmpfr+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2Cmpfr+2CANY+2Cmissing+2Cmpfr-method'></span><span id='topic+as.numeric+2Cmpfr-method'></span><span id='topic+as.vector+2CmpfrArray-method'></span><span id='topic+as.integer+2Cmpfr-method'></span><span id='topic+beta+2CANY+2Cmpfr-method'></span><span id='topic+beta+2CANY+2CmpfrArray-method'></span><span id='topic+beta+2Cmpfr+2CANY-method'></span><span id='topic+beta+2Cmpfr+2Cmpfr-method'></span><span id='topic+beta+2Cmpfr+2Cnumeric-method'></span><span id='topic+beta+2Cnumeric+2Cmpfr-method'></span><span id='topic+beta+2CmpfrArray+2CANY-method'></span><span id='topic+beta+2CmpfrArray+2CmpfrArray-method'></span><span id='topic+lbeta+2CANY+2Cmpfr-method'></span><span id='topic+lbeta+2CANY+2CmpfrArray-method'></span><span id='topic+lbeta+2Cmpfr+2CANY-method'></span><span id='topic+lbeta+2Cmpfr+2Cmpfr-method'></span><span id='topic+lbeta+2Cmpfr+2Cnumeric-method'></span><span id='topic+lbeta+2Cnumeric+2Cmpfr-method'></span><span id='topic+lbeta+2CmpfrArray+2CANY-method'></span><span id='topic+lbeta+2CmpfrArray+2CmpfrArray-method'></span><span id='topic+atan2+2CANY+2Cmpfr-method'></span><span id='topic+atan2+2CANY+2CmpfrArray-method'></span><span id='topic+atan2+2Cmpfr+2CANY-method'></span><span id='topic+atan2+2Cmpfr+2Cmpfr-method'></span><span id='topic+atan2+2Cmpfr+2Cnumeric-method'></span><span id='topic+atan2+2Cnumeric+2Cmpfr-method'></span><span id='topic+atan2+2CmpfrArray+2CANY-method'></span><span id='topic+atan2+2CmpfrArray+2CmpfrArray-method'></span><span id='topic+hypot'></span><span id='topic+coerce+2Cmpfr+2Ccharacter-method'></span><span id='topic+coerce+2Cmpfr+2Cnumeric-method'></span><span id='topic+coerce+2Cmpfr+2Cbigz-method'></span><span id='topic+coerce+2Cmpfr+2Cinteger-method'></span><span id='topic+coerce+2Cmpfr1+2Cnumeric-method'></span><span id='topic+coerce+2Cmpfr1+2Cmpfr-method'></span><span id='topic+coerce+2Cinteger+2Cmpfr-method'></span><span id='topic+coerce+2Clogical+2Cmpfr-method'></span><span id='topic+coerce+2Craw+2Cmpfr-method'></span><span id='topic+coerce+2Cnumeric+2Cmpfr-method'></span><span id='topic+coerce+2Cnumeric+2Cmpfr1-method'></span><span id='topic+coerce+2Carray+2Cmpfr-method'></span><span id='topic+coerce+2Ccharacter+2Cmpfr-method'></span><span id='topic+coerce+2Cmpfr+2Cmpfr1-method'></span><span id='topic+Ops+2Cmpfr+2CANY-method'></span><span id='topic+Ops+2CANY+2Cmpfr-method'></span><span id='topic+Ops+2Cmpfr+2Cbigq-method'></span><span id='topic+Ops+2Cbigq+2Cmpfr-method'></span><span id='topic+Ops+2Cmpfr+2Cbigz-method'></span><span id='topic+Ops+2Cbigz+2Cmpfr-method'></span><span id='topic+Ops+2Carray+2Cmpfr-method'></span><span id='topic+Ops+2Cmpfr+2Carray-method'></span><span id='topic+Ops+2Cmpfr+2Cvector-method'></span><span id='topic+Ops+2Cvector+2Cmpfr-method'></span><span id='topic+Arith+2Cmpfr+2Carray-method'></span><span id='topic+Arith+2Cmpfr+2Cmissing-method'></span><span id='topic+Arith+2Cmpfr+2Cmpfr-method'></span><span id='topic+Arith+2Cmpfr+2Cinteger-method'></span><span id='topic+Arith+2Cmpfr+2Cnumeric-method'></span><span id='topic+Arith+2Cinteger+2Cmpfr-method'></span><span id='topic+Arith+2Cnumeric+2Cmpfr-method'></span><span id='topic+Arith+2Carray+2Cmpfr-method'></span><span id='topic+Compare+2Cmpfr+2Cmpfr-method'></span><span id='topic+Compare+2Cmpfr+2Cinteger-method'></span><span id='topic+Compare+2Cmpfr+2Cnumeric-method'></span><span id='topic+Compare+2Cinteger+2Cmpfr-method'></span><span id='topic+Compare+2Cnumeric+2Cmpfr-method'></span><span id='topic+Compare+2Cmpfr+2Carray-method'></span><span id='topic+Compare+2Carray+2Cmpfr-method'></span><span id='topic+Logic+2Cmpfr+2Cmpfr-method'></span><span id='topic+Logic+2Cmpfr+2Cnumeric-method'></span><span id='topic+Logic+2Cnumeric+2Cmpfr-method'></span><span id='topic+Summary+2Cmpfr-method'></span><span id='topic+Math+2Cmpfr-method'></span><span id='topic+Math2+2Cmpfr-method'></span><span id='topic+abs+2Cmpfr-method'></span><span id='topic+log+2Cmpfr-method'></span><span id='topic+factorial+2Cmpfr-method'></span><span id='topic+sign+2Cmpfr-method'></span><span id='topic+Re+2Cmpfr-method'></span><span id='topic+Im+2Cmpfr-method'></span><span id='topic+Mod+2Cmpfr-method'></span><span id='topic+Arg+2Cmpfr-method'></span><span id='topic+Conj+2Cmpfr-method'></span><span id='topic+format+2Cmpfr-method'></span><span id='topic+is.finite+2Cmpfr-method'></span><span id='topic+is.infinite+2Cmpfr-method'></span><span id='topic+is.na+2Cmpfr-method'></span><span id='topic+is.nan+2Cmpfr-method'></span><span id='topic+is.finite+2CmpfrArray-method'></span><span id='topic+is.infinite+2CmpfrArray-method'></span><span id='topic+is.na+2CmpfrArray-method'></span><span id='topic+is.nan+2CmpfrArray-method'></span><span id='topic+unique+2Cmpfr-method'></span><span id='topic+unique+2Cmpfr+2CANY-method'></span><span id='topic+unique.mpfr'></span><span id='topic+all.equal+2Cmpfr+2Cmpfr-method'></span><span id='topic+all.equal+2Cmpfr+2CANY-method'></span><span id='topic+all.equal+2CANY+2Cmpfr-method'></span><span id='topic+mean+2Cmpfr-method'></span><span id='topic+median+2Cmpfr-method'></span><span id='topic+quantile+2Cmpfr-method'></span><span id='topic+summary+2Cmpfr-method'></span><span id='topic+dim+3C-+2Cmpfr-method'></span><span id='topic+t+2Cmpfr-method'></span><span id='topic++25+2A+25+2Carray_or_vector+2Cmpfr-method'></span><span id='topic++25+2A+25+2Cmpfr+2Carray_or_vector-method'></span><span id='topic+crossprod+2Carray_or_vector+2Cmpfr-method'></span><span id='topic+crossprod+2Cmpfr+2Carray_or_vector-method'></span><span id='topic+tcrossprod+2Carray_or_vector+2Cmpfr-method'></span><span id='topic+tcrossprod+2Cmpfr+2Carray_or_vector-method'></span><span id='topic+which.min+2Cmpfr-method'></span><span id='topic+which.max+2Cmpfr-method'></span><span id='topic+show+2Cmpfr-method'></span><span id='topic+show+2Cmpfr1-method'></span><span id='topic+show+2CsummaryMpfr-method'></span><span id='topic+print.mpfr1'></span><span id='topic+print.summaryMpfr'></span>

<h3>Description</h3>

<p><code>"mpfr"</code> is the class of <b>M</b>ultiple <b>P</b>recision
<b>F</b>loatingpoint numbers with <b>R</b>eliable arithmetic.
</p>
<p>sFor the high-level user, <code>"mpfr"</code> objects should behave
as standard <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+numeric">numeric</a></code> <em>vectors</em>. They would just
print differently and use the prespecified (typically high) precision
instead of the double precision of &lsquo;traditional&rsquo; <span class="rlang"><b>R</b></span> numbers
(with <code><a href="base.html#topic+class">class</a>(.) == "numeric"</code> and
<code><a href="base.html#topic+typeof">typeof</a>(.) == "double"</code>).
</p>
<p><code>hypot(x,y)</code> computes the hypothenuse length <code class="reqn">z</code> in a rectangular
triangle with &ldquo;leg&rdquo; side lengths <code class="reqn">x</code> and <code class="reqn">y</code>, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">z = hypot(x,y) = \sqrt{x^2 + y^2},</code>
</p>

<p>in a numerically stable way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypot(x,y, rnd.mode = c("N","D","U","Z","A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpfr-class_+3A_x">x</code>, <code id="mpfr-class_+3A_y">y</code></td>
<td>
<p>an object of class <code>mpfr</code>.</p>
</td></tr>
<tr><td><code id="mpfr-class_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see <code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>Objects are typically created by <code><a href="#topic+mpfr">mpfr</a>(&lt;number&gt;, precBits)</code>.
</p>
<p><code>summary(&lt;mpfr&gt;)</code> returns an object of class <code>"summaryMpfr"</code>
which contains <code>"mpfr"</code> but has its own <code><a href="base.html#topic+print">print</a></code> method.
</p>


<h3>Slots</h3>

<p>Internally, <code>"mpfr"</code> objects just contain standard <span class="rlang"><b>R</b></span>
<code><a href="base.html#topic+list">list</a></code>s where each list element is of class
<code>"mpfr1"</code>, representing <em>one</em> MPFR number, in a structure
with four slots, very much parallelizing the C <code>struc</code> in the
<code>mpfr</code> C library to which the <span class="pkg">Rmpfr</span> package interfaces.
</p>
<p>An object of class <code>"mpfr1"</code> has slots
</p>

<dl>
<dt><code>prec</code>:</dt><dd><p><code>"integer"</code> specifying the maxmimal
precision in <b>bits</b>.</p>
</dd>
<dt><code>exp</code>:</dt><dd><p><code>"integer"</code> specifying the base-<b>2</b>
exponent of the number.</p>
</dd>
<dt><code>sign</code>:</dt><dd><p><code>"integer"</code>, typically <code>-1</code> or
<code>1</code>, specifying the sign (i.e. <code><a href="base.html#topic+sign">sign</a>(.)</code>) of the
number.</p>
</dd>
<dt><code>d</code>:</dt><dd><p>an <code>"integer"</code> vector (of 32-bit
&ldquo;limbs&rdquo;) which corresponds to the full mantissa of the
number.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>abs</dt><dd><p><code>signature(x = "mpfr")</code>: ... </p>
</dd>
<dt>atan2</dt><dd><p><code>signature(y = "mpfr", x = "ANY")</code>, and</p>
</dd>
<dt>atan2</dt><dd><p><code>signature(x = "ANY", y = "mpfr")</code>: compute the
arc-tangent of two arguments: <code>atan2(y, x)</code> returns the angle
between the x-axis and the vector from the origin to <code class="reqn">(x, y)</code>,
i.e., for positive arguments <code>atan2(y, x) == <a href="base.html#topic+atan">atan</a>(y/x)</code>.</p>
</dd>
<dt>lbeta</dt><dd><p><code>signature(a = "ANY", b = "mpfrArray")</code>, is
<code class="reqn">\log(|B(a,b)|)</code> where <code class="reqn">B(a,b)</code> is the
Beta function, <code>beta(a,b)</code>.</p>
</dd>
<dt>beta</dt><dd><p><code>signature(a = "mpfr", b = "ANY")</code>,</p>
</dd>
<dt>beta</dt><dd><p><code>signature(a = "mpfr", b = "mpfr")</code>, ..., etc:
Compute the beta function <code class="reqn">B(a,b)</code>, using high precision,
building on internal <code><a href="base.html#topic+gamma">gamma</a></code> or <code><a href="base.html#topic+lgamma">lgamma</a></code>.
See the help for <span class="rlang"><b>R</b></span>'s base function <code><a href="base.html#topic+beta">beta</a></code> for
more.  Currently, there, <code class="reqn">a,b \ge 0</code> is required.
Here, we provide (non-<code><a href="base.html#topic+NaN">NaN</a></code>) for all numeric <code>a, b</code>.
</p>
<p>When either <code class="reqn">a</code>, <code class="reqn">b</code>, or <code class="reqn">a+b</code> is a negative
<em>integer</em>, <code class="reqn">\Gamma(.)</code> has a pole there and is undefined
(<code>NaN</code>).  However the Beta function can be defined there as
&ldquo;limit&rdquo;, in some cases.  Following other software such as
SAGE, Maple or Mathematica, we provide finite values in these
cases.  However, note that these are not proper limits
(two-dimensional in <code class="reqn">(a,b)</code>), but useful for some
applications.  E.g., <code class="reqn">B(a,b)</code> is defined as zero when
<code class="reqn">a+b</code> is a negative integer, but neither <code class="reqn">a</code> nor <code class="reqn">b</code> is.
Further, if <code class="reqn">a &gt; b &gt; 0</code> are integers, <code class="reqn">B(-a,b)= B(b,-a)</code>
can be seen as <code class="reqn">(-1)^b * B(a-b+1,b)</code>.
</p>
</dd>
<dt>dim&lt;-</dt><dd><p><code>signature(x = "mpfr")</code>: Setting a dimension
<code><a href="base.html#topic+dim">dim</a></code> on an <code>"mpfr"</code> object makes it into an object
of class <code>"<a href="#topic+mpfrArray-class">mpfrArray</a>"</code> or (more specifically)
<code>"mpfrMatrix"</code> for a length-2 dimension, see their help page;
note that <code>t(x)</code> (below) is a special case of this.</p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "mpfr", e2 = "ANY")</code>: ... </p>
</dd>
<dt>Ops</dt><dd><p><code>signature(e1 = "ANY", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "mpfr", e2 = "missing")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "mpfr", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "mpfr", e2 = "integer")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "mpfr", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "integer", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "numeric", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "mpfr", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "mpfr", e2 = "integer")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "mpfr", e2 = "numeric")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "integer", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "numeric", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Logic</dt><dd><p><code>signature(e1 = "mpfr", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Summary</dt><dd><p><code>signature(x = "mpfr")</code>: The S4
<code><a href="methods.html#topic+S4groupGeneric">Summary</a></code> group functions,
<code><a href="base.html#topic+max">max</a></code>, <code><a href="base.html#topic+min">min</a></code>, <code><a href="base.html#topic+range">range</a></code>,
<code><a href="base.html#topic+prod">prod</a></code>, <code><a href="base.html#topic+sum">sum</a></code>,
<code><a href="base.html#topic+any">any</a></code>, and <code><a href="base.html#topic+all">all</a></code>
are all defined for MPFR numbers.  <code><a href="base.html#topic+mean">mean</a>(x, trim)</code> for
non-0 <code>trim</code> works analogously to <code><a href="base.html#topic+mean.default">mean.default</a></code>.</p>
</dd>
<dt>median</dt><dd><p><code>signature(x = "mpfr")</code>: works via</p>
</dd>
<dt>quantile</dt><dd><p><code>signature(x = "mpfr")</code>: a simple wrapper of
the <code>quantile.default</code> method from <span class="pkg">stats</span>.</p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "mpfr")</code>: modeled after
<code><a href="base.html#topic+summary.default">summary.default</a></code>, ensuring to provide the full &quot;mpfr&quot;
range of numbers.</p>
</dd>
<dt>Math</dt><dd><p><code>signature(x = "mpfr")</code>: All the S4
<code><a href="methods.html#topic+S4groupGeneric">Math</a></code> group functions are
defined, using multiple precision (MPFR) arithmetic, from
<code><a href="methods.html#topic+getGroupMembers">getGroupMembers</a>("Math")</code>, these are (in alphabetical
order): 
</p>
<p><code><a href="base.html#topic+abs">abs</a></code>, <code><a href="base.html#topic+sign">sign</a></code>, <code><a href="base.html#topic+sqrt">sqrt</a></code>,
<code><a href="base.html#topic+ceiling">ceiling</a></code>, <code><a href="base.html#topic+floor">floor</a></code>, <code><a href="base.html#topic+trunc">trunc</a></code>,
<code><a href="base.html#topic+cummax">cummax</a></code>, <code><a href="base.html#topic+cummin">cummin</a></code>, <code><a href="base.html#topic+cumprod">cumprod</a></code>,
<code><a href="base.html#topic+cumsum">cumsum</a></code>, <code><a href="base.html#topic+exp">exp</a></code>, <code><a href="base.html#topic+expm1">expm1</a></code>,
<code><a href="base.html#topic+log">log</a></code>, <code><a href="base.html#topic+log10">log10</a></code>, <code><a href="base.html#topic+log2">log2</a></code>,
<code><a href="base.html#topic+log1p">log1p</a></code>, <code><a href="base.html#topic+cos">cos</a></code>, <code><a href="base.html#topic+cosh">cosh</a></code>,
<code><a href="base.html#topic+sin">sin</a></code>, <code><a href="base.html#topic+sinh">sinh</a></code>, <code><a href="base.html#topic+tan">tan</a></code>,
<code><a href="base.html#topic+tanh">tanh</a></code>, <code><a href="base.html#topic+acos">acos</a></code>, <code><a href="base.html#topic+acosh">acosh</a></code>,
<code><a href="base.html#topic+asin">asin</a></code>, <code><a href="base.html#topic+asinh">asinh</a></code>, <code><a href="base.html#topic+atan">atan</a></code>,
<code><a href="base.html#topic+atanh">atanh</a></code>,
<code><a href="base.html#topic+cospi">cospi</a></code>, <code><a href="base.html#topic+sinpi">sinpi</a></code>, <code><a href="base.html#topic+tanpi">tanpi</a></code>,
<code><a href="base.html#topic+gamma">gamma</a></code>, <code><a href="base.html#topic+lgamma">lgamma</a></code>,
<code><a href="base.html#topic+digamma">digamma</a></code>, and <code><a href="base.html#topic+trigamma">trigamma</a></code>.
</p>
<p>Currently, <code>trigamma</code> is not provided by
the MPFR library and hence not yet implemented.
<br />
Further, the <code>cum*()</code> methods are <em>not yet</em> implemented.</p>
</dd>
<dt>factorial</dt><dd><p><code>signature(x = "mpfr")</code>: this will
<code><a href="base.html#topic+round">round</a></code> the result when <code>x</code> is integer valued.
Note however that <code><a href="#topic+factorialMpfr">factorialMpfr</a>(n)</code> for integer
<code>n</code> is slightly more efficient, using the MPFR function
&lsquo;<span class="samp">&#8288;mpfr_fac_ui&#8288;</span>&rsquo;.</p>
</dd>
<dt>Math2</dt><dd><p><code>signature(x = "mpfr")</code>: <code><a href="base.html#topic+round">round</a>(x,
	digits)</code> and <code><a href="base.html#topic+signif">signif</a>(x, digits)</code> methods.  Note that
these do not change the formal precision (<code>'prec'</code> slot),
and you may often want to apply <code><a href="#topic+roundMpfr">roundMpfr</a>()</code> in
addition or preference.</p>
</dd>
<dt>as.numeric</dt><dd><p><code>signature(x = "mpfr")</code>: ... </p>
</dd>
<dt>as.vector</dt><dd><p><code>signature(x = "mpfrArray")</code>: as for standard
<code><a href="base.html#topic+array">array</a></code>s, this &ldquo;drops&rdquo; the <code>dim</code> (and
<code>dimnames</code>), i.e., transforms <code>x</code> into an &lsquo;MPFR&rsquo;
number vector, i.e., class <code><a href="#topic+mpfr-class">mpfr</a></code>.</p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "mpfr", i = "ANY")</code>, and</p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "mpfr", i = "ANY", j = "missing", drop = "missing")</code>:
subsetting aka &ldquo;indexing&rdquo; happens as for numeric vectors.</p>
</dd>
<dt>format</dt><dd><p><code>signature(x = "mpfr")</code>, further arguments
<code>digits = NULL, scientific = NA</code>, etc:
returns <code><a href="base.html#topic+character">character</a></code> vector of same length as <code>x</code>;
when <code>digits</code> is <code>NULL</code>, with <em>enough</em> digits to
recreate <code>x</code> accurately.  For details, see
<code><a href="#topic+formatMpfr">formatMpfr</a></code>.</p>
</dd>
<dt>is.finite</dt><dd><p><code>signature(x = "mpfr")</code>: ... </p>
</dd>
<dt>is.infinite</dt><dd><p><code>signature(x = "mpfr")</code>: ... </p>
</dd>
<dt>is.na</dt><dd><p><code>signature(x = "mpfr")</code>: ... </p>
</dd>
<dt>is.nan</dt><dd><p><code>signature(x = "mpfr")</code>: ... </p>
</dd>
<dt>log</dt><dd><p><code>signature(x = "mpfr")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "mpfr")</code>: ... </p>
</dd>
<dt>sign</dt><dd><p><code>signature(x = "mpfr")</code>: ... </p>
</dd>
<dt>Re, Im</dt><dd><p><code>signature(z = "mpfr")</code>: simply return <code>z</code>
or <code>0</code> (as <code>"mpfr"</code> numbers of correct precision), as mpfr
numbers are &lsquo;real&rsquo; numbers.</p>
</dd>
<dt>Arg, Mod, Conj</dt><dd><p><code>signature(z = "mpfr")</code>: these are
trivial for our &lsquo;real&rsquo; mpfr numbers, but defined to work
correctly when used in <span class="rlang"><b>R</b></span> code that also allows complex number input.</p>
</dd>
<dt>all.equal</dt><dd><p><code>signature(target = "mpfr", current = "mpfr")</code>,</p>
</dd>
<dt>all.equal</dt><dd><p><code>signature(target = "mpfr", current = "ANY")</code>, and</p>
</dd>
<dt>all.equal</dt><dd><p><code>signature(target = "ANY", current = "mpfr")</code>:
methods for numerical (approximate) equality,
<code><a href="base.html#topic+all.equal">all.equal</a></code> of multiple precision numbers.  Note
that the default <code>tolerance</code> (argument) is taken to correspond
to the (smaller of the two) precisions when both main arguments are
of class <code>"mpfr"</code>, and hence can be considerably less than
double precision machine epsilon <code><a href="base.html#topic+.Machine">.Machine</a>$double.eps</code>.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "numeric", to = "mpfr")</code>:
<code><a href="methods.html#topic+as">as</a>(., "mpfr")</code> coercion methods are available for
<code><a href="base.html#topic+character">character</a></code> strings, <code><a href="base.html#topic+numeric">numeric</a></code>, <code><a href="base.html#topic+integer">integer</a></code>,
<code><a href="base.html#topic+logical">logical</a></code>, and even <code><a href="base.html#topic+raw">raw</a></code>.  Note however,
that <code><a href="#topic+mpfr">mpfr</a>(., precBits, base)</code> is more flexible.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "mpfr", to = "bigz")</code>: coerces
to biginteger, see <code><a href="gmp.html#topic+bigz">bigz</a></code> in package <span class="pkg">gmp</span>.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "mpfr", to = "numeric")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "mpfr", to = "character")</code>: ... </p>
</dd>
<dt>unique</dt><dd><p><code>signature(x = "mpfr")</code>, and corresponding S3 method
(such that <code>unique(&lt;mpfr&gt;)</code> works inside <span class="pkg">base</span> functions),
see <code><a href="base.html#topic+unique">unique</a></code>.
</p>
<p>Note that <code><a href="base.html#topic+duplicated">duplicated</a>()</code> works for <code>"mpfr"</code> objects
without the need for a specific method.</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "mpfr")</code>: makes <code>x</code> into an <code class="reqn">n
	\times 1</code> <code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code>.</p>
</dd>
<dt>which.min</dt><dd><p><code>signature(x = "mpfr")</code>: gives the index of
the first minimum, see <code><a href="base.html#topic+which.min">which.min</a></code>.</p>
</dd>
<dt>which.max</dt><dd><p><code>signature(x = "mpfr")</code>: gives the index of
the first maximum, see <code><a href="base.html#topic+which.max">which.max</a></code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Many more methods (&ldquo;functions&rdquo;) automagically work for
<code>"mpfr"</code> number vectors (and matrices, see the
<code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code> class doc),
notably
<code><a href="base.html#topic+sort">sort</a></code>, <code><a href="base.html#topic+order">order</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>,
<code><a href="base.html#topic+rank">rank</a></code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p>The <code>"<a href="#topic+mpfrMatrix-class">mpfrMatrix</a>"</code> class, which extends the
<code>"mpfr"</code> one.
</p>
<p><code><a href="#topic+roundMpfr">roundMpfr</a></code> to <em>change</em> precision of an <code>"mpfr"</code>
object which is typically desirable <em>instead</em> of or in addition
to <code>signif()</code> or <code>round()</code>;
<code><a href="gmp.html#topic+is.whole">is.whole</a>()</code> etc.
</p>
<p>Special mathematical functions such as some Bessel ones, e.g., <code><a href="#topic+jn">jn</a></code>;
further, <code><a href="#topic+zeta">zeta</a>(.)</code> <code class="reqn">(= \zeta(.))</code>, <code>Ei()</code> etc.
<code><a href="#topic+Bernoulli">Bernoulli</a></code> numbers and the Pochhammer function
<code><a href="#topic+pochMpfr">pochMpfr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 30 digit precision
(x &lt;- mpfr(c(2:3, pi), prec = 30 * log2(10)))
str(x) # str() displays *compact*ly =&gt; not full precision
x^2
x[1] / x[2] # 0.66666... ~ 30 digits

## indexing - as with numeric vectors
stopifnot(exprs = {
   identical(x[2], x[[2]])
   ## indexing "outside" gives NA (well: "mpfr-NaN" for now):
   is.na(x[5])
   ## whereas "[[" cannot index outside:
   inherits(tryCatch(x[[5]], error=identity), "error")
   ## and only select *one* element:
   inherits(tryCatch(x[[2:3]], error=identity), "error")
})

## factorial() &amp; lfactorial would work automagically via [l]gamma(),
## but factorial() additionally has an "mpfr" method which rounds
f200 &lt;- factorial(mpfr(200, prec = 1500)) # need high prec.!
f200
as.numeric(log2(f200))# 1245.38 -- need precBits &gt;~ 1246 for full precision

##--&gt; see  factorialMpfr() for more such computations.

##--- "Underflow" **much** later -- exponents have 30(+1) bits themselves:

mpfr.min.exp2 &lt;- - (2^30 + 1)
two &lt;- mpfr(2, 55)
stopifnot(two ^ mpfr.min.exp2 == 0)
## whereas
two ^ (mpfr.min.exp2 * (1 - 1e-15))
## 2.38256490488795107e-323228497   ["typically"]

##--- "Assert" that {sort}, {order}, {quantile}, {rank}, all work :

p &lt;- mpfr(rpois(32, lambda=500), precBits=128)^10
np &lt;- as.numeric(log(p))
(sp &lt;- summary(p))# using the print.summaryMpfr() method
stopifnot(all(diff(sort(p)) &gt;= 0),
   identical(order(p), order(np)),
   identical(rank (p), rank (np)),
   all.equal(sapply(1:9, function(Typ) quantile(np, type=Typ, names=FALSE)),
      sapply(lapply(1:9, function(Typ) quantile( p, type=Typ, names=FALSE)),
	     function(x) as.numeric(log(x))),
      tol = 1e-3),# quantiles: interpolated in orig. &lt;--&gt; log scale
 TRUE)

m0 &lt;- mpfr(numeric(), 99)
xy &lt;- expand.grid(x = -2:2, y = -2:2) ; x &lt;- xy[,"x"] ; y &lt;- xy[,"y"]
a2. &lt;- atan2(y,x)

stopifnot(identical(which.min(m0), integer(0)),
	  identical(which.max(m0), integer(0)),
          all.equal(a2., atan2(as(y,"mpfr"), x)),
	  max(m0) == mpfr(-Inf, 53), # (53 is not a feature, but ok)
	  min(m0) == mpfr(+Inf, 53),
	  sum(m0) == 0, prod(m0) == 1)

## unique(), now even base::factor()  "works" on &lt;mpfr&gt; :
set.seed(17)
p &lt;- rlnorm(20) * mpfr(10, 100)^-999
pp &lt;- sample(p, 50, replace=TRUE)
str(unique(pp)) # length 18 .. (from originally 20)
## Class 'mpfr' [package "Rmpfr"] of length 18 and precision 100
## 5.56520587824e-999 4.41636588227e-1000 ..
facp &lt;- factor(pp)
str(facp) # the factor *levels* are a bit verbose :
# Factor w/ 18 levels "new(\"mpfr1\", ...........)" ...
# At least *some* factor methods work :
stopifnot(exprs = {
  is.factor(facp)
  identical(unname(table(facp)),
            unname(table(asNumeric(pp * mpfr(10,100)^1000))))
})

## ((unfortunately, the expressions are wrong; should integer "L"))
#
## More useful: levels with which to *invert* factor() :
## -- this is not quite ok:
## simplified from 'utils' :
deparse1 &lt;- function(x, ...) paste(deparse(x, 500L, ...), collapse = " ")
if(FALSE) {
 str(pp.levs &lt;- vapply(unclass(sort(unique(pp))), deparse1, ""))
 facp2 &lt;- factor(pp, levels = pp.levs)
}
</code></pre>

<hr>
<h2 id='mpfr-distr-etc'>Distribution Functions with MPFR Arithmetic</h2><span id='topic+pnorm'></span><span id='topic+dnorm'></span><span id='topic+dbinom'></span><span id='topic+dnbinom'></span><span id='topic+dgamma'></span><span id='topic+dpois'></span><span id='topic+dt'></span><span id='topic+mpfr-distr'></span>

<h3>Description</h3>

<p>For some <span class="rlang"><b>R</b></span> standard (probability) density, distribution or quantile
functions, we provide MPFR versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
dpois (x, lambda, log = FALSE, useLog = )
dbinom (x, size, prob,     log = FALSE, useLog = )
dnbinom(x, size, prob, mu, log = FALSE, useLog = any(x &gt; 1e6))
dnorm (x, mean = 0, sd = 1, log = FALSE)
dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE)
dt (x, df, ncp, log = FALSE)

pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpfr-distr-etc_+3A_x">x</code>, <code id="mpfr-distr-etc_+3A_q">q</code>, <code id="mpfr-distr-etc_+3A_lambda">lambda</code>, <code id="mpfr-distr-etc_+3A_size">size</code>, <code id="mpfr-distr-etc_+3A_prob">prob</code>, <code id="mpfr-distr-etc_+3A_mu">mu</code>, <code id="mpfr-distr-etc_+3A_mean">mean</code>, <code id="mpfr-distr-etc_+3A_sd">sd</code>, <code id="mpfr-distr-etc_+3A_shape">shape</code>, <code id="mpfr-distr-etc_+3A_rate">rate</code>, <code id="mpfr-distr-etc_+3A_scale">scale</code>, <code id="mpfr-distr-etc_+3A_df">df</code>, <code id="mpfr-distr-etc_+3A_ncp">ncp</code></td>
<td>

<p><code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="#topic+mpfr-class">mpfr</a></code> vectors.  
All of these are &ldquo;recycled&rdquo; to the length of the longest one.
For their meaning/definition, see the corresponding standard R
(<span class="pkg">stats</span> package) function.</p>
</td></tr>
<tr><td><code id="mpfr-distr-etc_+3A_log">log</code>, <code id="mpfr-distr-etc_+3A_log.p">log.p</code>, <code id="mpfr-distr-etc_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical, see
<code><a href="stats.html#topic+Normal">pnorm</a></code>,
<code><a href="stats.html#topic+Poisson">dpois</a></code>, etc.</p>
</td></tr>
<tr><td><code id="mpfr-distr-etc_+3A_uselog">useLog</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical</a></code> with default depending on <code>x</code>
etc, indicating if log-scale computation should be used even when
<code>log = FALSE</code>, for performance or against overflow / underflow.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pnorm()</code> is based on <code><a href="#topic+erf">erf</a>()</code> and <code>erfc()</code> which
have direct MPFR counter parts and are both reparametrizations
of <code>pnorm</code>, <code>erf(x) = 2*pnorm(sqrt(2)*x)</code> and
<code>erfc(x) = 2* pnorm(sqrt(2)*x, lower=FALSE)</code>.
</p>


<h3>Value</h3>

<p>A vector of the same length as the longest of <code>x,q, ...</code>,
of class <code><a href="#topic+mpfr-class">mpfr</a></code> with the high accuracy results of
the corresponding standard <span class="rlang"><b>R</b></span> function.
</p>


<h3>Note</h3>

<p>E.g., for <code>pnorm(*, log.p = TRUE)</code> to be useful, i.e., not to
underflow or overflow, you may want to extend the exponential range of
MPFR numbers, using <code><a href="#topic+.mpfr_erange_set">.mpfr_erange_set</a>()</code>, see the examples.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">pnorm</a></code>,
<code><a href="stats.html#topic+dt">dt</a></code>,
<code><a href="stats.html#topic+dbinom">dbinom</a></code>,
<code><a href="stats.html#topic+dnbinom">dnbinom</a></code>,
<code><a href="stats.html#topic+dgamma">dgamma</a></code>,
<code><a href="stats.html#topic+dpois">dpois</a></code> in standard package <span class="pkg">stats</span>.
</p>
<p><code><a href="#topic+pbetaI">pbetaI</a>(x, a,b)</code> is a <code><a href="#topic+mpfr">mpfr</a></code> version of
<code><a href="stats.html#topic+pbeta">pbeta</a></code> only for <em>integer</em> <code>a</code> and <code>b</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1400+ 0:10
print(dpois(x, 1000), digits =18) ## standard R's double precision
(px &lt;- dpois(mpfr(x, 120), 1000))## more accuracy for the same
px. &lt;- dpois(mpfr(x, 120), 1000, useLog=TRUE)# {failed in 0.8-8}
stopifnot(all.equal(px, px., tol = 1e-31))
dpois(0:5, mpfr(10000, 80)) ## very small exponents (underflowing in dbl.prec.)

print(dbinom(0:8, 8, pr = 4 / 5), digits=18)
      dbinom(0:8, 8, pr = 4/mpfr(5, 99)) -&gt; dB; dB

print(dnorm(     -5:5), digits=18)
      dnorm(mpfr(-5:5, prec=99))

## For pnorm() in the extreme tails, need an exponent range
## larger than the (MPFR and Rmpfr) default:
(old_eranges &lt;- .mpfr_erange()) # typically -/+ 2^30:
log2(abs(old_eranges))   # 30  30
.mpfr_erange_set(value = (1-2^-52)*.mpfr_erange(c("min.emin","max.emax")))
log2(abs(.mpfr_erange()))# 62  62  *if* setup -- 2023-01: *not* on Winbuilder, nor
## other Windows where long is 4 bytes (32 bit) and the erange typically cannot be extended.
tens &lt;- mpfr(10^(4:7), 128)
pnorm(tens, lower.tail=FALSE, log.p=TRUE) # "works" (iff ...)
## "the" boundary:
pnorm(mpfr(- 38581.371, 128), log.p=TRUE) # still does not underflow {but *.372 does}
## -744261105.599283824811986753129188937418  (iff ...)
.mpfr_erange()*log(2) # the boundary
##          Emin          Emax
## -3.196577e+18  3.196577e+18 (iff ...)

## reset to previous
.mpfr_erange_set( , old_eranges)
pnorm(tens, lower.tail=FALSE, log.p=TRUE) # all but first underflow to -Inf
</code></pre>

<hr>
<h2 id='mpfr-special-functions'>Special Mathematical Functions (MPFR)</h2><span id='topic+zeta'></span><span id='topic+Ei'></span><span id='topic+Li2'></span><span id='topic+erf'></span><span id='topic+erfc'></span>

<h3>Description</h3>

<p>Special Mathematical Functions, supported by the MPFR Library.
</p>
<p>Note that additionally, all the <code><a href="base.html#topic+Math">Math</a></code> and
<code><a href="methods.html#topic+Math2">Math2</a></code> group member functions are &ldquo;mpfr-ified&rdquo;, too;
ditto, for many more standard <span class="rlang"><b>R</b></span> functions.  See see the methods listed
in <code><a href="#topic+mpfr-class">mpfr</a></code> (aka <code>?`<a href="#topic+mpfr-class">mpfr-class</a>`</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeta(x)
Ei(x)
Li2(x)

erf(x)
erfc(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpfr-special-functions_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="#topic+mpfr-class">mpfr</a></code> vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zeta(x)</code> computes Riemann's Zeta function
<code class="reqn">\zeta(x)</code> important in analytical number theory and
related fields. The traditional definition is
</p>
<p style="text-align: center;"><code class="reqn">\zeta(x) = \sum_{n=1}^\infty \frac{1}{n^x}.</code>
</p>

<p><code>Ei(x)</code> computes the <b>e</b>xponential integral,
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^{x} \frac{e^t}{t} \; dt.</code>
</p>

<p><code>Li2(x)</code> computes the dilogarithm,
</p>
<p style="text-align: center;"><code class="reqn">\int_{0}^{x} \frac{-log(1-t)}{t} \; dt.</code>
</p>

<p><code>erf(x)</code> and <code>erfc(x)</code> are the error, respectively
<b>c</b>omplementary error function which are both reparametrizations
of <code><a href="#topic+pnorm">pnorm</a></code>, <code>erf(x) = 2*pnorm(sqrt(2)*x)</code> and
<code>erfc(x) = 2* pnorm(sqrt(2)*x, lower=FALSE)</code>,
and hence <span class="pkg">Rmpfr</span> provides its own version of <code><a href="#topic+pnorm">pnorm</a></code>.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code>, of class <code><a href="#topic+mpfr-class">mpfr</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">pnorm</a></code> in standard package <span class="pkg">stats</span>;
the class description <code><a href="#topic+mpfr-class">mpfr</a></code> mentioning the
generic arithmetic and mathematical functions (<code>sin</code>, <code>log</code>,
..., etc) for which <code>"mpfr"</code> methods are available.
</p>
<p>Note the (integer order, non modified) Bessel functions <code class="reqn">j_0()</code>,
<code class="reqn">y_n()</code>, etc, named <code><a href="#topic+j0">j0</a>, <a href="#topic+yn">yn</a></code> etc, and Airy
function <code class="reqn">Ai()</code> in <a href="#topic+Bessel_mpfr">Bessel_mpfr</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>curve(Ei,  0, 5, n=2001)

## As we now require (mpfrVersion() &gt;= "2.4.0"):
curve(Li2,  0,    5, n=2001)
curve(Li2, -2,   13, n=2000); abline(h=0,v=0, lty=3)
curve(Li2, -200,400, n=2000); abline(h=0,v=0, lty=3)

curve(erf, -3,3, col = "red", ylim = c(-1,2))
curve(erfc, add = TRUE, col = "blue")
abline(h=0, v=0, lty=3)
legend(-3,1, c("erf(x)", "erfc(x)"), col = c("red","blue"), lty=1)
</code></pre>

<hr>
<h2 id='mpfr-utils'>Rmpfr &ndash; Utilities for Precision Setting, Printing, etc</h2><span id='topic+getPrec'></span><span id='topic+.getPrec'></span><span id='topic+getD'></span><span id='topic+mpfr_default_prec'></span><span id='topic+mpfr2array'></span><span id='topic+mpfrImport'></span><span id='topic+mpfrXport'></span><span id='topic+print.mpfr'></span><span id='topic+print.mpfrArray'></span><span id='topic+toNum'></span><span id='topic+.mpfr2d'></span><span id='topic+.mpfr2i'></span><span id='topic+.mpfr2list'></span><span id='topic+.mpfr_formatinfo'></span><span id='topic+.mpfr2exp'></span><span id='topic+.mpfr_erange'></span><span id='topic+.mpfr_erange_set'></span><span id='topic+.mpfr_erange_kinds'></span><span id='topic+.mpfr_erange_is_int'></span><span id='topic+.mpfr_maxPrec'></span><span id='topic+.mpfr_minPrec'></span><span id='topic+.mpfr_gmp_numbbits'></span><span id='topic+.mpfrVersion'></span><span id='topic+..bigq2mpfr'></span><span id='topic+..bigz2mpfr'></span><span id='topic+.getSign'></span><span id='topic+.mpfr_negative'></span><span id='topic+.mpfr_sign'></span><span id='topic+.mpfr'></span><span id='topic+.mpfr.'></span>

<h3>Description</h3>

<p>This page documents utilities from package <span class="pkg">Rmpfr</span> which are
typically not called by the user, but may come handy in some
situations.
</p>
<p>Notably, the (base-2) maximal (and minimal) precision and the
&ldquo;erange&rdquo;, the range of possible (base-2) exponents of
<code><a href="#topic+mpfr">mpfr</a></code>-numbers can be queried and partly extended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPrec(x, base = 10, doNumeric = TRUE, is.mpfr = NA, bigq. = 128L)
.getPrec(x)
getD(x)
mpfr_default_prec(prec)
## S3 method for class 'mpfrArray'
print(x, digits = NULL, drop0trailing = FALSE,
      right = TRUE,
      max.digits = getOption("Rmpfr.print.max.digits", 999L),
      exponent.plus = getOption("Rmpfr.print.exponent.plus", TRUE),
      ...)
## S3 method for class 'mpfr'
print(x, digits = NULL, drop0trailing = TRUE,
      right = TRUE,
      max.digits = getOption("Rmpfr.print.max.digits", 999L),
      exponent.plus = getOption("Rmpfr.print.exponent.plus", TRUE),
      ...)
toNum(from, rnd.mode = c('N','D','U','Z','A'))
.mpfr2d(from)
.mpfr2i(from)

mpfr2array(x, dim, dimnames = NULL, check = FALSE)

.mpfr2list(x, names = FALSE)

mpfrXport(x, names = FALSE)
mpfrImport(mxp)

.mpfr_formatinfo(x)
.mpfr2exp(x)

.mpfr_erange(kind = c("Emin", "Emax"), names = TRUE)
.mpfr_erange_set(kind = c("Emin", "Emax"), value)
.mpfr_erange_kinds
.mpfr_erange_is_int()
.mpfr_maxPrec()
.mpfr_minPrec()

.mpfr_gmp_numbbits()
.mpfrVersion()

## Really Internal and low level, no error checking (for when you know ..)
.mpfr (x, precBits)
.mpfr.(x, precBits, rnd.mode)
.getSign(x)

.mpfr_negative(x)
.mpfr_sign(x)

..bigq2mpfr(x, precB = NULL, rnd.mode = c("N", "D", "U", "Z", "A"))
..bigz2mpfr(x, precB = NULL, rnd.mode = c("N", "D", "U", "Z", "A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpfr-utils_+3A_x">x</code>, <code id="mpfr-utils_+3A_from">from</code></td>
<td>
<p>typically, an <span class="rlang"><b>R</b></span> object of class <code>"<a href="#topic+mpfr-class">mpfr</a>"</code>, or
<code>"<a href="#topic+mpfrArray-class">mpfrArray</a>"</code>, respectively.  For
<code>getPrec()</code>, any number-like <span class="rlang"><b>R</b></span> object, or <code><a href="base.html#topic+NULL">NULL</a></code>.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_base">base</code></td>
<td>
<p>(only when <code>x</code> is <code><a href="base.html#topic+character">character</a></code>) the base
with respect to which <code>x[i]</code> represent numbers; <code>base</code>
<code class="reqn">b</code> must fulfill <code class="reqn">2 \le b \le 62</code>.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_donumeric">doNumeric</code></td>
<td>
<p>logical indicating <code><a href="base.html#topic+integer">integer</a></code> or
<code><a href="base.html#topic+double">double</a></code> typed <code>x</code> should be accepted and a default
precision be returned.  Should typically be kept at default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_is.mpfr">is.mpfr</code></td>
<td>
<p>logical indicating if <code><a href="base.html#topic+class">class</a>(x)</code> is already
known to be <code>"mpfr"</code>; typically should be kept at default, <code>NA</code>.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_bigq.">bigq.</code></td>
<td>
<p>for <code>getPrec()</code>, the precision to use for a big
rational (class <code>"bigq"</code>); if not specified gives warning when used.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_prec">prec</code>, <code id="mpfr-utils_+3A_precb">precB</code>, <code id="mpfr-utils_+3A_precbits">precBits</code></td>
<td>
<p>a positive integer, or missing.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_drop0trailing">drop0trailing</code></td>
<td>
<p>logical indicating if trailing <code>"0"</code>s should
be omitted.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_right">right</code></td>
<td>
<p>logical indicating <code>print()</code>ing should right
justify the strings; see <code><a href="base.html#topic+print.default">print.default</a>()</code> to which it
is passed.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_digits">digits</code>, <code id="mpfr-utils_+3A_...">...</code></td>
<td>
<p>further arguments to print methods.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_max.digits">max.digits</code></td>
<td>
<p>a number (possibly <code>Inf</code>) to limit the number
of (mantissa) digits to be printed, simply passed to
<code><a href="#topic+formatMpfr">formatMpfr</a>()</code>.  The default is finite to protect from
printing very long strings which is often undesirable, notably in
<code><a href="base.html#topic+interactive">interactive</a></code> use.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_exponent.plus">exponent.plus</code></td>
<td>
<p>logical, simply passed to <code><a href="#topic+formatMpfr">formatMpfr</a>()</code>.
Was <code>FALSE</code> hardwired in Rmpfr versions before 0.8-0, and hence is
allowed to be tweaked by an <code><a href="base.html#topic+options">options</a>()</code> setting.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see details of
<code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_dim">dim</code>, <code id="mpfr-utils_+3A_dimnames">dimnames</code></td>
<td>
<p>for <code>"<a href="#topic+mpfrArray-class">mpfrArray</a>"</code>
construction.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_check">check</code></td>
<td>
<p>logical indicating if the mpfrArray construction should
happen with internal safety check.  Previously, the implicit default
used to be true.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_names">names</code></td>
<td>
<p>(for <code>.mpfr2list()</code>) <code><a href="base.html#topic+logical">logical</a></code> or
<code><a href="base.html#topic+character">character</a></code> vector, indicating if the list returned
should have <code><a href="base.html#topic+names">names</a></code>.  If character, it specifies the
names; if true, the names are set to <code>format(x)</code>.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_mxp">mxp</code></td>
<td>
<p>an <code>"mpfrXport"</code> object, as resulting from
<code>mpfrXport()</code>.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_kind">kind</code></td>
<td>
<p>a <code><a href="base.html#topic+character">character</a></code> string or vector, specifying the
kind of &ldquo;erange&rdquo; value; must be an element of
<code>.mpfr_erange_kinds</code>, i.e., one of <code>"Emin"</code>, <code>"Emax"</code>,
<code>"min.emin"</code>, <code>"max.emin"</code>, <code>"min.emax"</code>, <code>"max.emax"</code>.</p>
</td></tr>
<tr><td><code id="mpfr-utils_+3A_value">value</code></td>
<td>
<p><code><a href="base.html#topic+numeric">numeric</a></code>, for <code>.mpfr_erange_set()</code> one
number per <code>kind</code>.  Must be in range specified by the
<code>*."emin"</code> and <code>*."emax"</code> erange values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method is currently built on the <code><a href="base.html#topic+format">format</a></code>
method for class <code><a href="#topic+mpfr-class">mpfr</a></code>.  This, currently does
<em>not</em> format columns jointly which leads to suboptimally looking
output.  There are plans to change this.
</p>
<p>Note that <code><a href="#topic+formatMpfr">formatMpfr</a>()</code> which is called by <code>print()</code>
(or <code>show()</code> or <span class="rlang"><b>R</b></span>'s implicit printing) uses <code>max.digits =
    Inf</code>, differing from our <code>print()</code>'s default on purpose.
If you do want to see the full accuracy even in cases it is large, use
<code><a href="base.html#topic+options">options</a>(Rmpfr.print.max.digits = Inf)</code> or
<code>(.. = 1e7)</code>, say.
</p>
<p>The <code>.mpfr_erange*</code> functions (and variable) allow to query and set
the allowed range of values for the base-2 <em>exponents</em> of
<code>"mpfr"</code> numbers.
See the examples below and GNU MPFR library documentation on the C functions
<code>mpfr_get_emin()</code>, <code>mpfr_set_emin(.)</code>,
<code>mpfr_get_emin_min()</code>, and <code>mpfr_get_emin_max()</code>,
(and those four with &lsquo;_emin&rsquo; replaced by &lsquo;_emax&rsquo; above).
</p>


<h3>Value</h3>

<p><code>getPrec(x)</code> returns a <code><a href="base.html#topic+integer">integer</a></code> vector of length one or
the same length as <code>x</code> when that is positive, whereas
<code>getPrec(NULL)</code> returns <code>mpfr_default_prec()</code>, see below.

If you need to <em>change</em> the precision of <code>x</code>, i.e., need
something like &ldquo;setPrec&rdquo;, use <code><a href="#topic+roundMpfr">roundMpfr</a>()</code>.
</p>
<p><code>.getPrec(x)</code> is a simplified version of <code>getPrec()</code> which only
works for <code>"mpfr"</code> objects <code>x</code>.
</p>
<p><code>getD(x)</code> is intended to be a fast version of <code>x@.Data</code>,
and should not be used outside of lower level functions.
</p>
<p><code>mpfr_default_prec()</code> returns the current MPFR default precision,
an <code><a href="base.html#topic+integer">integer</a></code>.  This is currently 
not made use of much in package <span class="pkg">Rmpfr</span>, where functions have
their own default precision where needed, and otherwise we'd rather not
be dependent of such a <em>global</em> setting.
<br />
<code>mpfr_default_prec(prec)</code> <em>sets</em> the current MPFR default
precision and returns the previous one; see above.
</p>
<p><code>.mpfr_maxPrec()</code> and (less interestingly) <code>.mpfr_minPrec()</code>
give the maximal and minimal base-2 precision allowed in the current
version of the MPFR library linked to by <span class="rlang"><b>R</b></span> package <span class="pkg">Rmpfr</span>.
The maximal precision is typically <code class="reqn">2^{63}</code>, i.e.,
</p>
<pre> all.equal(.mpfr_maxPrec(), 2^63) </pre>
<p>is typically true.
</p>
<p><code>toNum(m)</code> returns a numeric <code><a href="base.html#topic+array">array</a></code> or
<code><a href="base.html#topic+matrix">matrix</a></code>, when <code>m</code> is of class
<code>"<a href="#topic+mpfrArray-class">mpfrArray</a>"</code> or <code>"<a href="#topic+mpfrMatrix-class">mpfrMatrix</a>"</code>,
respectively.  It should be equivalent to <code>as(m, "array")</code> or
<code>... "matrix"</code>.   Note that the slightly more general
<code><a href="gmp.html#topic+asNumeric">asNumeric</a>()</code> is preferred now.
<code>.mpfr2d()</code> is similar to but simpler than <code>toNum()</code>, whereas
<code>.mpfr2i()</code> is an analogue low level utility for
<code><a href="base.html#topic+as.integer">as.integer</a>(&lt;mpfr&gt;)</code>.
</p>
<p><code>mpfr2array()</code> a slightly more flexible alternative to
<code>dim(.) &lt;- dd</code>.
</p>
<p><code>.mpfr2exp(x)</code> returns the base-2 (integer valued) exponents of
<code>x</code>, i.e., it is the <span class="rlang"><b>R</b></span> interface to MPFR C's <code>mpfr_get_exp()</code>.
The result is <code><a href="base.html#topic+integer">integer</a></code>  iff <code>.mpfr_erange_is_int()</code>
is true, otherwise <code><a href="base.html#topic+double">double</a></code>.  Note that the MPFR (4.0.1)
manual says about <code>mpfr_get_exp()</code>: <em>The behavior for NaN,
infinity or zero is undefined</em>.
</p>
<p><code>.mpfr_erange_is_int()</code> returns <code>TRUE</code> iff the
<code>.mpfr_erange(c("Emin","Emax"))</code> range lies inside the range of <span class="rlang"><b>R</b></span>'s
<code><a href="base.html#topic+integer">integer</a></code> limits, i.e., has absolute values not larger than
<code><a href="base.html#topic+.Machine">.Machine</a>$integer.max</code> (<code class="reqn"> = 2^{31} - 1</code>).
</p>
<p><code>.mpfr_erange_set()</code> <em>invisibly</em> (see <code><a href="base.html#topic+invisible">invisible</a>()</code>)
returns <code>TRUE</code> iff the change was successful.
</p>
<p><code>.mpfr_gmp_numbbits()</code> returns the &lsquo;<span class="file">GMP</span>&rsquo; library &ldquo;numb&rdquo;
size, which is either 32 or 64 bit (as <code><a href="base.html#topic+integer">integer</a></code>, i.e.,
<code>64L</code> or <code>32L</code>).  If it is <em>not</em> 64, you typically
cannot enlarge the exponential range of mpfr numbers via
<code>.mpfr_erange()</code>, see above.
</p>
<p><code>.mpfrVersion()</code> returns a string, the version of the &lsquo;<span class="file">MPFR</span>&rsquo;
library we are linking to.
</p>
<p><code>.mpfr_formatinfo(x)</code> returns conceptually a subset of
<code><a href="#topic+.mpfr2str">.mpfr2str</a>()</code>'s result, a list with three components
</p>

<dl>
<dt>exp</dt><dd><p>the base-2 exponents of <code>x</code>, identical to <code>.mpfr2exp(x)</code>.</p>
</dd>
<dt>finite</dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> identical to <code><a href="base.html#topic+is.finite">is.finite</a>(x)</code>.</p>
</dd>
<dt>is.0</dt><dd><p><code><a href="base.html#topic+logical">logical</a></code> indicating if the corresponding
<code>x[i]</code> is zero; identical to <code><a href="#topic+mpfrIs0">mpfrIs0</a>(x)</code>.</p>
</dd></dl>

<p>(Note that <code><a href="#topic+.mpfr2str">.mpfr2str</a>(x, .., base)$exp</code> is wrt <code>base</code>
<em>and</em> is not undefined but ...)
</p>
<p><code>.mpfr_sign(x)</code> only works for <code>mpfr</code> objects, then identical
to <code><a href="base.html#topic+sign">sign</a>(x)</code>.  Analogously, <code>.mpfr_negative(x)</code> is
<code>-x</code> in that case.
<code>.getSign(x)</code> is a low-level version of <code><a href="base.html#topic+sign">sign</a>(x)</code>
returning -1 or +1, but not 0.
<br />
Finally, <code>..bigq2mpfr(x, ..)</code> and <code>..bigz2mpfr(x, ..)</code> are fast
ways to coerce <code>bigz</code> and <code>bigq</code> number objects (created by
package <a href="https://CRAN.R-project.org/package=gmp"><span class="pkg">gmp</span></a>'s functionality) to our <code>"mpfr"</code> class.
</p>


<h3>Note</h3>

<p><code>mpfrXport()</code> and <code>mpfrImport()</code> are <b>experimental</b> and
used to explore reported platform incompatibilities of
<code><a href="base.html#topic+save">save</a>()</code>d and <code><a href="base.html#topic+load">load</a>()</code>ed <code>"mpfr"</code>
objects between Windows and non-Windows platforms.
</p>
<p>In other words, the format of the result of <code>mpfrXport()</code> and
hence the <code>mxp</code> argument to <code>mpfrImport()</code> are considered
internal, not part of the API and subject to change.
</p>


<h3>See Also</h3>

<p>Start using <code><a href="#topic+mpfr">mpfr</a>(..)</code>, and compute with these numbers.
</p>
<p><code><a href="#topic+mpfrArray">mpfrArray</a>(x)</code> is for numeric (&ldquo;non-mpfr&rdquo;)
<code>x</code>, whereas <code>mpfr2array(x)</code> is for <code>"mpfr"</code> classed
<code>x</code>, only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getPrec(as(c(1,pi), "mpfr")) # 128 for both

(opr &lt;- mpfr_default_prec()) ## typically  53, the MPFR system default
stopifnot(opr == (oprec &lt;- mpfr_default_prec(70)),
          70  == mpfr_default_prec())
## and reset it:
mpfr_default_prec(opr)

## Explore behavior of rounding modes 'rnd.mode':
x &lt;- mpfr(10,99)^512 # too large for regular (double prec. / numeric):
sapply(c("N", "D", "U", "Z", "A"), function(RM)
       sapply(list(-x,x), function(.) toNum(., RM)))
##    N             D              U              Z    A
## -Inf          -Inf -1.797693e+308 -1.797693e+308 -Inf
##  Inf 1.797693e+308            Inf  1.797693e+308  Inf

## Printing of "MPFR" matrices is less nice than R's usual matrix printing:
m &lt;- outer(c(1, 3.14, -1024.5678), c(1, 1e-3, 10,100))
m[3,3] &lt;- round(m[3,3])
m
mpfr(m, 50)

B6 &lt;- mpfr2array(Bernoulli(1:6, 60), c(2,3),
                 dimnames = list(LETTERS[1:2], letters[1:3]))
B6

## Ranges of (base 2) exponents of MPFR numbers:
.mpfr_erange() # the currently active range of possible base 2 exponents:

## A factory fresh setting fulfills
.mpfr_erange(c("Emin","Emax")) == c(-1,1) * (2^30 - 1)

## There are more 'kind's, the latter 4 showing how you could change the first two :
.mpfr_erange_kinds
.mpfr_erange(.mpfr_erange_kinds)
eLimits &lt;- .mpfr_erange(c("min.emin", "max.emin", "min.emax", "max.emax"))
## Typically true in MPFR versions *iff* long is 64-bit, i.e. *not* on Windows
if(.Machine$sizeof.long == 8L) {
    eLimits == c(-1,1, -1,1) * (2^62 - 1)
} else if(.Machine$sizeof.long == 4L) # on Windows
    eLimits == c(-1,1, -1,1) * (2^30 - 1)


## Looking at internal representation [for power users only!]:

i8 &lt;- mpfr(-2:5, 32)
x4 &lt;- mpfr(c(NA, NaN, -Inf, Inf), 32)
stopifnot(exprs = {
    identical(x4[1], x4[2])
    is.na(x4[1] == x4[2]) # &lt;- was *wrong* in Rmpfr &lt;= 0.9-4
    is.na(x4[1] != x4[2]) #  (ditto)
    identical(x4 &lt; i8[1:4], c(NA,NA, TRUE,FALSE))
    !is.finite(x4)
    identical(is.infinite(x4), c(FALSE,FALSE, TRUE,TRUE))
})
## The output of the following depends on the GMP "numb" size
## (32 bit vs. 64 bit), *and* additionally
## on sizeof.long (mostly non-Windows &lt;-&gt; Windows, see above):
str( .mpfr2list(i8) )
str( .mpfr2list(x4, names = TRUE) )

str(xp4 &lt;- mpfrXport(x4, names = TRUE))
stopifnot(identical(x4, mpfrImport(mpfrXport(x4))),
          identical(i8, mpfrImport(mpfrXport(i8))))
## FIXME, need c(.), as dim(.)  "get lost":
stopifnot(identical(c(B6), mpfrImport(mpfrXport(B6))))
</code></pre>

<hr>
<h2 id='mpfr.utils'>MPFR Number Utilities</h2><span id='topic+c.mpfr'></span><span id='topic+diff.mpfr'></span><span id='topic+mpfrIs0'></span><span id='topic+.mpfr.is.whole'></span><span id='topic+mpfrVersion'></span><span id='topic+mpfr.is.0'></span><span id='topic+mpfr.is.integer'></span>

<h3>Description</h3>

<p><code>mpfrVersion()</code> returns the version of the MPFR library which
<span class="pkg">Rmpfr</span> is currently linked to.
</p>
<p><code><a href="base.html#topic+c">c</a>(x,y,...)</code> can be used to combine MPFR numbers in the
same way as regular numbers <b>IFF</b> the first argument <code>x</code> is
of class <code><a href="#topic+mpfr-class">mpfr</a></code>.
</p>
<p><code>mpfrIs0(.)</code> uses the MPFR library in the documented way to
check if (a vector of) MPFR numbers are zero.  It was called
<code>mpfr.is.0</code> which is strongly deprecated now.
</p>
<p><code>.mpfr.is.whole(x)</code> uses the MPFR library in the documented way to
check if (a vector of) MPFR numbers is integer <em>valued</em>.  This is
equivalent to <code>x == round(x)</code>, but <em>not</em> at all to
<code>is.integer(as(x, "numeric"))</code>.<br />
You should typically rather use (the <code>"mpfr"</code> method of the
generic function) <code><a href="gmp.html#topic+is.whole">is.whole</a>(x)</code> instead.
The former name <code>mpfr.is.integer</code> is deprecated now.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpfrVersion()
mpfrIs0(x)
## S3 method for class 'mpfr'
c(...)
## S3 method for class 'mpfr'
diff(x, lag = 1L, differences = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpfr.utils_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+mpfr-class">mpfr</a></code>.</p>
</td></tr>
<tr><td><code id="mpfr.utils_+3A_...">...</code></td>
<td>
<p>for <code>diff</code>, further <code><a href="#topic+mpfr-class">mpfr</a></code> class
objects or simple numbers (<code><a href="base.html#topic+numeric">numeric</a></code> vectors) which are coerced to
<code>mpfr</code> with default precision of 128 bits.</p>
</td></tr>
<tr><td><code id="mpfr.utils_+3A_lag">lag</code>, <code id="mpfr.utils_+3A_differences">differences</code></td>
<td>
<p>for <code>diff()</code>: exact same meaning as in
<code><a href="base.html#topic+diff">diff</a>()</code>'s default method, <code><a href="base.html#topic+diff.default">diff.default</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mpfrIs0</code> returns a logical vector of length <code>length(x)</code>
with values <code>TRUE</code> iff the corresponding <code>x[i]</code> is an MPFR
representation of zero (<code>0</code>).
<br /> Similarly, <code>.mpfr.is.whole</code> and <code>is.whole</code> return a
logical vector of length <code>length(x)</code>.
</p>
<p><code>mpfrVersion</code> returns an object of S3 class
<code>"<a href="base.html#topic+numeric_version">numeric_version</a>"</code>, so it can be used in comparisons.
</p>
<p>The other functions return MPFR number (vectors), i.e., extending
class <code><a href="#topic+mpfr-class">mpfr</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+str.mpfr">str.mpfr</a></code> for the <code><a href="utils.html#topic+str">str</a></code> method.
<code><a href="#topic+erf">erf</a></code> for special mathematical functions on MPFR.
</p>
<p>The class description <code><a href="#topic+mpfr-class">mpfr</a></code> page mentions many
generic arithmetic and mathematical functions for which <code>"mpfr"</code>
methods are available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mpfrVersion()

(x &lt;- c(Const("pi", 64), mpfr(-2:2, 64)))
mpfrIs0(x)    # one of them is
x[mpfrIs0(x)] # but it may not have been obvious..
str(x)

x &lt;- rep(-2:2, 5)
stopifnot(is.whole(mpfr(2, 500) ^ (1:200)),
          all.equal(diff(x), diff(as.numeric(x))))
</code></pre>

<hr>
<h2 id='mpfrArray'>Construct &quot;mpfrArray&quot; almost as by 'array()'</h2><span id='topic+mpfrArray'></span>

<h3>Description</h3>

<p>Utility to construct an <span class="rlang"><b>R</b></span> object of class
<code><a href="#topic+mpfrArray-class">mpfrArray</a></code>, very analogously to the numeric
<code><a href="base.html#topic+array">array</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpfrArray(x, precBits, dim = length(x), dimnames = NULL,
          rnd.mode = c("N","D","U","Z","A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpfrArray_+3A_x">x</code></td>
<td>
<p>numeric(like) vector, typically of length <code>prod(dim)</code> or
shorter in which case it is recycled.</p>
</td></tr>
<tr><td><code id="mpfrArray_+3A_precbits">precBits</code></td>
<td>
<p>a number, the maximal precision to be used, in
<b><em>bits</em></b>; i.e., <code>53</code> corresponds to double precision.
Must be at least 2.</p>
</td></tr>
<tr><td><code id="mpfrArray_+3A_dim">dim</code></td>
<td>
<p>the dimension of the array to be created, that is a
vector of length one or more giving the maximal indices in
each dimension.</p>
</td></tr>
<tr><td><code id="mpfrArray_+3A_dimnames">dimnames</code></td>
<td>
<p>either <code>NULL</code> or the names for the
dimensions.  This is a list with one component for each dimension,
either <code>NULL</code> or a character vector of the length given by
<code>dim</code> for that dimension.</p>
</td></tr>

<tr><td><code id="mpfrArray_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see details of
<code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"<a href="#topic+mpfrArray-class">mpfrArray</a>"</code>, specifically
<code>"<a href="#topic+mpfrMatrix-class">mpfrMatrix</a>"</code> when <code>length(dim) == 2</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpfr">mpfr</a></code>, <code><a href="base.html#topic+array">array</a></code>;
<code><a href="gmp.html#topic+asNumeric">asNumeric</a>()</code> as &ldquo;inverse&rdquo; of <code>mpfrArray()</code>,
to get back a numeric array.
</p>
<p><code><a href="#topic+mpfr2array">mpfr2array</a>(x)</code> is for <code>"mpfr"</code> classed <code>x</code>,
only, whereas <code>mpfrArray(x)</code> is for numeric (&ldquo;non-mpfr&rdquo;)
<code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## preallocating is possible here too
ma &lt;- mpfrArray(NA, prec = 80, dim = 2:4)
validObject(A2 &lt;- mpfrArray(1:24, prec = 64, dim = 2:4))

## recycles, gives an "mpfrMatrix" and dimnames :
mat &lt;- mpfrArray(1:5, 64, dim = c(5,3), dimnames=list(NULL, letters[1:3]))
mat
asNumeric(mat)
stopifnot(identical(asNumeric(mat),
                    matrix(1:5 +0, 5,3, dimnames=dimnames(mat))))

## Testing the apply() method :
apply(mat, 2, range)
apply(A2, 1:2, range)
apply(A2, 2:3, max)
(fA2 &lt;- apply(A2, 2, fivenum))
a2 &lt;- as(A2, "array")
stopifnot(as(apply(A2, 2, range), "matrix") ==
             apply(a2, 2, range)
        , all.equal(fA2, apply(a2, 2, fivenum))
        , all.equal(apply(A2, 2, quantile),
                    apply(a2, 2, quantile))
        , all.equal(A2, apply(A2, 2:3, identity) -&gt; aA2, check.attributes=FALSE)
        , dim(A2) == dim(aA2)
)

</code></pre>

<hr>
<h2 id='mpfrMatrix'>Classes &quot;mpfrMatrix&quot; and &quot;mpfrArray&quot;</h2><span id='topic+mpfrMatrix-class'></span><span id='topic+mpfrArray-class'></span><span id='topic+Arith+2CmpfrArray+2Cmpfr-method'></span><span id='topic+Arith+2CmpfrArray+2CmpfrArray-method'></span><span id='topic+Arith+2Cmpfr+2CmpfrArray-method'></span><span id='topic+Arith+2CmpfrArray+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2CmpfrArray-method'></span><span id='topic+Compare+2CmpfrArray+2Cmpfr-method'></span><span id='topic+Compare+2CmpfrArray+2Cnumeric-method'></span><span id='topic+Compare+2Cmpfr+2CmpfrArray-method'></span><span id='topic+Compare+2Cnumeric+2CmpfrArray-method'></span><span id='topic+apply+2CmpfrArray-method'></span><span id='topic+colSums+2CmpfrArray-method'></span><span id='topic+colMeans+2CmpfrArray-method'></span><span id='topic+rowSums+2CmpfrArray-method'></span><span id='topic+rowMeans+2CmpfrArray-method'></span><span id='topic+as.vector+2CmpfrArray+2Cmissing-method'></span><span id='topic+coerce+2CmpfrArray+2Carray-method'></span><span id='topic+coerce+2Carray+2CmpfrArray-method'></span><span id='topic+coerce+2CmpfrArray+2Cmatrix-method'></span><span id='topic+coerce+2CmpfrMatrix+2Cmatrix-method'></span><span id='topic+coerce+2Cmatrix+2CmpfrMatrix-method'></span><span id='topic+coerce+2CmpfrArray+2Cvector-method'></span><span id='topic+coerce+3C-+2CmpfrArray+2Cvector-method'></span><span id='topic+diag+2CmpfrMatrix-method'></span><span id='topic+diag+3C-+2CmpfrMatrix-method'></span><span id='topic++5B+3C-+2CmpfrArray+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CmpfrArray+2CANY+2CANY+2Cmpfr-method'></span><span id='topic++5B+3C-+2CmpfrArray+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CmpfrArray+2CANY+2Cmissing+2Cmpfr-method'></span><span id='topic++5B+3C-+2CmpfrArray+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CmpfrArray+2Cmissing+2CANY+2Cmpfr-method'></span><span id='topic++5B+3C-+2CmpfrArray+2Cmissing+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CmpfrArray+2Cmissing+2Cmissing+2Cmpfr-method'></span><span id='topic++5B+3C-+2CmpfrArray+2Cmatrix+2Cmissing+2CANY-method'></span><span id='topic++5B+3C-+2CmpfrArray+2Cmatrix+2Cmissing+2Cmpfr-method'></span><span id='topic++5B+2CmpfrArray+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CmpfrArray+2CANY+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CmpfrArray+2Cmatrix+2Cmissing+2Cmissing-method'></span><span id='topic++25+2A+25+2CMnumber+2Cmpfr-method'></span><span id='topic++25+2A+25+2CmpfrMatrix+2Cmpfr-method'></span><span id='topic++25+2A+25+2CmpfrMatrix+2CmpfrMatrix-method'></span><span id='topic++25+2A+25+2Cmpfr+2CMnumber-method'></span><span id='topic++25+2A+25+2Cmpfr+2Cmpfr-method'></span><span id='topic++25+2A+25+2Cmpfr+2CmpfrMatrix-method'></span><span id='topic+crossprod+2Cmpfr+2Cmissing-method'></span><span id='topic+crossprod+2CmpfrMatrix+2Cmpfr-method'></span><span id='topic+crossprod+2CmpfrMatrix+2CmpfrMatrix-method'></span><span id='topic+crossprod+2Cmpfr+2CMnumber-method'></span><span id='topic+crossprod+2Cmpfr+2Cmpfr-method'></span><span id='topic+crossprod+2Cmpfr+2CmpfrMatrix-method'></span><span id='topic+crossprod+2CMnumber+2Cmpfr-method'></span><span id='topic+tcrossprod+2Cmpfr+2Cmissing-method'></span><span id='topic+tcrossprod+2CmpfrMatrix+2Cmpfr-method'></span><span id='topic+tcrossprod+2CmpfrMatrix+2CmpfrMatrix-method'></span><span id='topic+tcrossprod+2Cmpfr+2CMnumber-method'></span><span id='topic+tcrossprod+2Cmpfr+2Cmpfr-method'></span><span id='topic+tcrossprod+2Cmpfr+2CmpfrMatrix-method'></span><span id='topic+tcrossprod+2CMnumber+2Cmpfr-method'></span><span id='topic+dim+2CmpfrArray-method'></span><span id='topic+dimnames+3C-+2CmpfrArray-method'></span><span id='topic+dimnames+2CmpfrArray-method'></span><span id='topic+norm+2CANY+2Cmissing-method'></span><span id='topic+norm+2CmpfrMatrix+2Ccharacter-method'></span><span id='topic+show+2CmpfrArray-method'></span><span id='topic+sign+2CmpfrArray-method'></span><span id='topic+t+2CmpfrMatrix-method'></span><span id='topic+aperm+2CmpfrArray-method'></span>

<h3>Description</h3>

<p>The classes <code>"mpfrMatrix"</code> and <code>"mpfrArray"</code> are,
analogously to the <span class="pkg">base</span> <code><a href="base.html#topic+matrix">matrix</a></code> and <code><a href="base.html#topic+array">array</a></code>
functions and classes simply &ldquo;numbers&rdquo; of class
<code><a href="#topic+mpfr-class">mpfr</a></code> with an additional <code>Dim</code> and
<code>Dimnames</code> slot.
</p>


<h3>Objects from the Class</h3>

<p>Objects should typically be created by <code><a href="#topic+mpfrArray">mpfrArray</a>()</code>, but
can also be created by
<code>new("mpfrMatrix", ...)</code> or <code>new("mpfrArray", ...)</code>, or also
by <code>t(x)</code>, <code>dim(x) &lt;- dd</code>, or <code><a href="#topic+mpfr2array">mpfr2array</a>(x,
    dim=dd)</code> where <code>x</code> is a an <code><a href="#topic+mpfr-class">mpfr</a></code>
&ldquo;number vector&rdquo;.
</p>
<p>A (slightly more flexible) alternative to <code>dim(x) &lt;- dd</code> is
<code><a href="#topic+mpfr2array">mpfr2array</a>(x, dd, dimnames)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>as for the <code><a href="#topic+mpfr-class">mpfr</a></code> class, a
<code>"list"</code> of  <code><a href="#topic+mpfr1-class">mpfr1</a></code> numbers.</p>
</dd>
<dt><code>Dim</code>:</dt><dd><p>of class <code>"integer"</code>, specifying the array
dimension.</p>
</dd>
<dt><code>Dimnames</code>:</dt><dd><p>of class <code>"list"</code> and the same length
as <code>Dim</code>, each list component either <code><a href="base.html#topic+NULL">NULL</a></code> or a
<code><a href="base.html#topic+character">character</a></code> vector of length <code>Dim[j]</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"mpfrMatrix"</code> extends <code>"mpfrArray"</code>, directly.
</p>
<p>Class <code>"mpfrArray"</code> extends
class <code>"<a href="#topic+mpfr-class">mpfr</a>"</code>, by class &quot;mpfrArray&quot;, distance 2;
class <code>"<a href="methods.html#topic+list-class">list</a>"</code>, by class &quot;mpfrArray&quot;, distance 3;
class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;mpfrArray&quot;, distance 4.
</p>


<h3>Methods</h3>


<dl>
<dt>Arith</dt><dd><p><code>signature(e1 = "mpfr", e2 = "mpfrArray")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "numeric", e2 = "mpfrArray")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "mpfrArray", e2 = "mpfrArray")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "mpfrArray", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Arith</dt><dd><p><code>signature(e1 = "mpfrArray", e2 = "numeric")</code>: ... </p>
</dd>
<dt>as.vector</dt><dd><p><code>signature(x = "mpfrArray", mode =
	"missing")</code>: drops the dimension &lsquo;attribute&rsquo;, i.e.,
transforms <code>x</code> into a simple <code><a href="#topic+mpfr-class">mpfr</a></code>
vector.  This is an inverse of <code>t(.)</code> or <code>dim(.) &lt;- *</code>
on such a vector.</p>
</dd>
<dt>atan2</dt><dd><p><code>signature(y = "ANY", x = "mpfrArray")</code>: ... </p>
</dd>
<dt>atan2</dt><dd><p><code>signature(y = "mpfrArray", x = "mpfrArray")</code>: ... </p>
</dd>
<dt>atan2</dt><dd><p><code>signature(y = "mpfrArray", x = "ANY")</code>: ... </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "mpfrArray", i = "ANY", j = "ANY", value = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "mpfrArray", i = "ANY", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "mpfrArray", i = "ANY", j = "missing", drop = "missing")</code>:
<code>"mpfrArray"</code>s can be subset (&ldquo;indexed&rdquo;) as regular <span class="rlang"><b>R</b></span>
<code><a href="base.html#topic+array">array</a></code>s.</p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "mpfr", y = "mpfrMatrix")</code>: Compute
the matrix/vector product <code class="reqn">x y</code> when the dimensions
(<code><a href="base.html#topic+dim">dim</a></code>) of <code>x</code> and <code>y</code> match.  If <code>x</code>
is not a matrix, it is treated as a 1-row or 1-column matrix (aka
&ldquo;row vector&rdquo; or &ldquo;column vector&rdquo;) depending on which
one makes sense, see the documentation of the <span class="pkg">base</span>
function <code><a href="base.html#topic+matmult">%*%</a></code>.</p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "mpfr", y = "Mnumber")</code>: method
definition for cases with one <code><a href="#topic+mpfr-class">mpfr</a></code> and any
&ldquo;number-like&rdquo; argument are to use MPFR arithmetic as well.</p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "mpfrMatrix", y = "mpfrMatrix")</code>,</p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "mpfrMatrix", y = "mpfr")</code>, etc.
Further method definitions with identical semantic.</p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "mpfr", y = "missing")</code>:
Computes <code class="reqn">x'x</code>, i.e., <code>t(x) %*% x</code>, typically more efficiently.</p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "mpfr", y = "mpfrMatrix")</code>:
Computes <code class="reqn">x'y</code>, i.e., <code>t(x) %*% y</code>, typically more efficiently.</p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "mpfrMatrix", y = "mpfrMatrix")</code>: ... </p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "mpfrMatrix", y = "mpfr")</code>: ... </p>
</dd>
<dt>tcrossprod</dt><dd><p><code>signature(x = "mpfr", y = "missing")</code>:
Computes <code class="reqn">xx'</code>, i.e., <code>x %*% t(x)</code>, typically more efficiently.</p>
</dd>
<dt>tcrossprod</dt><dd><p><code>signature(x = "mpfrMatrix", y = "mpfrMatrix")</code>:
Computes <code class="reqn">xy'</code>, i.e., <code>x %*% t(y)</code>, typically more efficiently.</p>
</dd>
<dt>tcrossprod</dt><dd><p><code>signature(x = "mpfrMatrix", y = "mpfr")</code>: ... </p>
</dd>
<dt>tcrossprod</dt><dd><p><code>signature(x = "mpfr", y = "mpfrMatrix")</code>: ... </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "mpfrArray", to = "array")</code>:
coerces <code>from</code> to a <em>numeric</em> array of the same dimension.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "mpfrArray", to = "vector")</code>:
as for standard <code><a href="base.html#topic+array">array</a></code>s, this &ldquo;drops&rdquo; the
<code>dim</code> (and <code>dimnames</code>), i.e., returns an
<code><a href="#topic+mpfr-class">mpfr</a></code> vector.</p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "mpfr", e2 = "mpfrArray")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "numeric", e2 = "mpfrArray")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "mpfrArray", e2 = "mpfr")</code>: ... </p>
</dd>
<dt>Compare</dt><dd><p><code>signature(e1 = "mpfrArray", e2 = "numeric")</code>: ... </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "mpfrArray")</code>: ... </p>
</dd>
<dt>dimnames&lt;-</dt><dd><p><code>signature(x = "mpfrArray")</code>: ... </p>
</dd>
<dt>dimnames</dt><dd><p><code>signature(x = "mpfrArray")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "mpfrArray")</code>: ... </p>
</dd>
<dt>sign</dt><dd><p><code>signature(x = "mpfrArray")</code>: ... </p>
</dd>
<dt>norm</dt><dd><p><code>signature(x = "mpfrMatrix", type = "character")</code>:
computes the matrix norm of <code>x</code>, see <code><a href="base.html#topic+norm">norm</a></code>
or the one in package <span class="pkg">Matrix</span>.</p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "mpfrMatrix")</code>: tranpose the mpfrMatrix.</p>
</dd>
<dt>aperm</dt><dd><p><code>signature(a = "mpfrArray")</code>: <code>aperm(a,
	perm)</code> is a generalization of <code>t(.)</code> to <em>perm</em>ute the
dimensions of an mpfrArray; it has the same semantics as the
standard <code><a href="base.html#topic+aperm">aperm</a>()</code> method for simple <span class="rlang"><b>R</b></span> <code><a href="base.html#topic+array">array</a></code>s.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpfrArray">mpfrArray</a></code>, also for more examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("mpfrMatrix")

validObject(mm &lt;- new("mpfrMatrix"))
validObject(aa &lt;- new("mpfrArray"))

v6 &lt;- mpfr(1:6, 128)
m6 &lt;- new("mpfrMatrix", v6, Dim = c(2L, 3L))
validObject(m6)
m6
which(m6 == 3, arr.ind = TRUE) # |--&gt;  (1, 2)
## Coercion back to "vector": Both of these work:
stopifnot(identical(as(m6, "mpfr"), v6),
	  identical(as.vector(m6), v6)) # &lt; but this is a "coincidence"

S2 &lt;- m6[,-3] # 2 x 2
S3 &lt;- rbind(m6, c(1:2,10)) ; s3 &lt;- asNumeric(S3)
det(S2)
str(determinant(S2))
det(S3)
stopifnot(all.equal(det(S2), det(asNumeric(S2)), tol=1e-15),
	  all.equal(det(S3), det(s3), tol=1e-15))

## 2-column matrix indexing and replacement:
(sS &lt;- S3[i2 &lt;- cbind(1:2, 2:3)])
stopifnot(identical(asNumeric(sS), s3[i2]))
C3 &lt;- S3; c3 &lt;- s3
C3[i2] &lt;- 10:11
c3[i2] &lt;- 10:11
stopifnot(identical(asNumeric(C3), c3))

AA &lt;- new("mpfrArray", as.vector(cbind(S3, -S3)), Dim=c(3L,3:2))
stopifnot(identical(AA[,,1] , S3), identical(AA[,,2] , -S3))
aa &lt;- asNumeric(AA)

i3 &lt;- cbind(3:1, 1:3, c(2L, 1:2))
ii3 &lt;- Rmpfr:::.mat2ind(i3, dim(AA), dimnames(AA))
stopifnot(aa[i3] == new("mpfr", getD(AA)[ii3]))
stopifnot(identical(aa[i3], asNumeric(AA[i3])))
CA &lt;- AA; ca &lt;- aa
ca[i3] &lt;- ca[i3] ^ 3
CA[i3] &lt;- CA[i3] ^ 3

## scale():
S2. &lt;- scale(S2)
stopifnot(all.equal(abs(as.vector(S2.)), rep(sqrt(1/mpfr(2, 128)), 4),
		    tol = 1e-30))

## norm() :
norm(S2)
stopifnot(identical(norm(S2), norm(S2, "1")),
          norm(S2, "I") == 6,
          norm(S2, "M") == 4,
          abs(norm(S2, "F") - 5.477225575051661) &lt; 1e-15)
</code></pre>

<hr>
<h2 id='mpfrMatrix-utils'>Functions for mpfrMatrix Objects</h2><span id='topic+determinant.mpfrMatrix'></span>

<h3>Description</h3>

<p><code>determinant(x, ..)</code> computes the determinant of the mpfr square
matrix <code>x</code>.  May work via coercion to <code>"numeric"</code>, i.e., compute
<code>determinant(<a href="gmp.html#topic+asNumeric">asNumeric</a>(x), logarithm)</code>, if
<code>asNumeric</code> is true, by default, if the dimension is larger
than three.  Otherwise, use precision <code>precBits</code> for the
&ldquo;accumulator&rdquo; of the result, and use the
recursive mathematical definition of the determinant (with
computational complexity <code class="reqn">n!</code>, where <code class="reqn">n</code> is the matrix
dimension, i.e., <b>very</b> inefficient for all but small matrices!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpfrMatrix'
determinant(x, logarithm = TRUE,
            asNumeric = (d[1] &gt; 3), precBits = max(.getPrec(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpfrMatrix-utils_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code> object of <em>square</em> dimension.</p>
</td></tr>
<tr><td><code id="mpfrMatrix-utils_+3A_logarithm">logarithm</code></td>
<td>
<p>logical indicating if the <code><a href="base.html#topic+log">log</a></code> of the
absolute determinant should be returned.
</p>
</td></tr>
<tr><td><code id="mpfrMatrix-utils_+3A_asnumeric">asNumeric</code></td>
<td>
<p>logical .. .. if rather
<code>determinant(<a href="gmp.html#topic+asNumeric">asNumeric</a>(x), ...)</code> should be computed.
</p>
</td></tr>
<tr><td><code id="mpfrMatrix-utils_+3A_precbits">precBits</code></td>
<td>
<p>the number of binary digits for the result (and the
intermediate accumulations).</p>
</td></tr>
<tr><td><code id="mpfrMatrix-utils_+3A_...">...</code></td>
<td>
<p>unused (potentially further arguments passed to methods).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as <code><a href="base.html#topic+determinant">determinant</a>()</code>, an object of S3 class <code>"det"</code>, a
<code><a href="base.html#topic+list">list</a></code> with components
</p>
<table>
<tr><td><code>modulus</code></td>
<td>
<p>the (logarithm of) the absolute value
(<code><a href="base.html#topic+abs">abs</a></code>) of the determinant of <code>x</code>.</p>
</td></tr>
<tr><td><code>sign</code></td>
<td>
<p>the sign of the determinant.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+determinant">determinant</a></code> in base <span class="rlang"><b>R</b></span>, which relies on a fast LU decomposition.
<code><a href="#topic+mpfrMatrix-class">mpfrMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m6 &lt;- mpfrArray(1:6, prec=128, dim = c(2L, 3L))
m6
S2 &lt;- m6[,-3] # 2 x 2
S3 &lt;- rbind(m6, c(1:2,10))
det(S2)
str(determinant(S2))
det(S3)
stopifnot(all.equal(det(S2), det(asNumeric(S2)), tolerance=1e-15),
	  all.equal(det(S3), det(asNumeric(S3)), tolerance=1e-15))
</code></pre>

<hr>
<h2 id='optimizeR'>High Precision One-Dimensional Optimization</h2><span id='topic+optimizeR'></span>

<h3>Description</h3>

<p><code>optimizeR</code> searches the interval from
<code>lower</code> to <code>upper</code> for a minimum 
of the function <code>f</code> with respect to its first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizeR(f, lower, upper, ..., tol = 1e-20,
          method = c("Brent", "GoldenRatio"),
          maximum = FALSE,
          precFactor = 2.0, precBits = -log2(tol) * precFactor,
          maxiter = 1000, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeR_+3A_f">f</code></td>
<td>
<p>the function to be optimized. <code>f(x)</code> must work
&ldquo;in <span class="pkg">Rmpfr</span> arithmetic&rdquo; for <code>optimizer()</code> to make sense.
The function is either minimized or maximized over its first argument
depending on the value of <code>maximum</code>.</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_...">...</code></td>
<td>
<p>additional named or unnamed arguments to be passed
to <code>f</code>.</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_lower">lower</code></td>
<td>
<p>the lower end point of the interval to be searched.</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_upper">upper</code></td>
<td>
<p>the upper end point of the interval to be searched.</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy, typically higher than double
precision, i.e., <code>tol &lt; 2e-16</code>.</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_method">method</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> string specifying the
optimization method.</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_maximum">maximum</code></td>
<td>
<p>logical indicating if <code class="reqn">f()</code> should be maximized or
minimized (the default).</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_precfactor">precFactor</code></td>
<td>
<p>only for default <code>precBits</code> construction: a factor
to multiply with the number of bits directly needed for <code>tol</code>.</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_precbits">precBits</code></td>
<td>
<p>number of bits to be used for
<code><a href="#topic+mpfr">mpfr</a></code> numbers used internally.</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_maxiter">maxiter</code></td>
<td>
<p>maximal number of iterations to be used.</p>
</td></tr>
<tr><td><code id="optimizeR_+3A_trace">trace</code></td>
<td>
<p>integer or logical indicating if and how iterations
should be monitored; if an integer <code class="reqn">k</code>, print every <code class="reqn">k</code>-th
iteration.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>"Brent"</code>:</dt><dd><p>Brent(1973)'s simple and robust algorithm
is a hybrid, using a combination of the golden ratio and local
quadratic (&ldquo;parabolic&rdquo;) interpolation.  This is the same
algorithm as standard <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+optimize">optimize</a>()</code>, adapted to
high precision numbers.
</p>
<p>In smooth cases, the convergence is considerably faster than the golden
section or Fibonacci ratio algorithms.
</p>
</dd>
<dt><code>"GoldenRatio"</code>:</dt><dd><p>The golden ratio method, aka
&lsquo;golden-section search&rsquo; works as follows:
from a given interval containing the solution, it constructs the
next point in the golden ratio between the interval boundaries.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="base.html#topic+list">list</a></code> with components <code>minimum</code> (or <code>maximum</code>)
and <code>objective</code> which give the location of the minimum (or maximum)
and the value of the function at that point;
<code>iter</code> specifiying the number of iterations, the logical
<code>convergence</code> indicating if the iterations converged and
<code>estim.prec</code> which is an estimate or an upper bound of the final
precision (in <code class="reqn">x</code>).
<code>method</code> the string of the method used.
</p>


<h3>Author(s)</h3>

<p><code>"GoldenRatio"</code> is based on Hans Werner Borchers'
<code><a href="pracma.html#topic+golden_ratio">golden_ratio</a></code> (package <a href="https://CRAN.R-project.org/package=pracma"><span class="pkg">pracma</span></a>);
modifications and <code>"Brent"</code> by Martin Maechler.
</p>


<h3>See Also</h3>

<p><span class="rlang"><b>R</b></span>'s standard <code><a href="stats.html#topic+optimize">optimize</a></code>;
for multivariate optimization, <span class="pkg">Rmpfr</span>'s <code><a href="#topic+hjkMpfr">hjkMpfr</a>()</code>;
for root finding, <span class="pkg">Rmpfr</span>'s <code><a href="#topic+unirootR">unirootR</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The minimum of the Gamma (and lgamma) function (for x &gt; 0):
Gmin &lt;- optimizeR(gamma, .1, 3, tol = 1e-50)
str(Gmin, digits = 8)
## high precision chosen for "objective"; minimum has "estim.prec" = 1.79e-50
Gmin[c("minimum","objective")]
## it is however more accurate to 59 digits:
asNumeric(optimizeR(gamma, 1, 2, tol = 1e-100)$minimum - Gmin$minimum)


iG5 &lt;- function(x) -exp(-(x-5)^2/2)
curve(iG5, 0, 10, 200)
o.dp  &lt;- optimize (iG5, c(0, 10)) #-&gt;  5 of course
oM.gs &lt;- optimizeR(iG5, 0, 10, method="Golden")
oM.Br &lt;- optimizeR(iG5, 0, 10, method="Brent", trace=TRUE)
oM.gs$min ; oM.gs$iter
oM.Br$min ; oM.Br$iter
(doExtras &lt;- Rmpfr:::doExtras())
if(doExtras) {## more accuracy {takes a few seconds}
 oM.gs &lt;- optimizeR(iG5, 0, 10, method="Golden", tol = 1e-70)
 oM.Br &lt;- optimizeR(iG5, 0, 10,                  tol = 1e-70)
}
rbind(Golden = c(err = as.numeric(oM.gs$min -5), iter = oM.gs$iter),
      Brent  = c(err = as.numeric(oM.Br$min -5), iter = oM.Br$iter))

## ==&gt; Brent is orders of magnitude more efficient !

## Testing on the sine curve with 40 correct digits:
sol &lt;- optimizeR(sin, 2, 6, tol = 1e-40)
str(sol)
sol &lt;- optimizeR(sin, 2, 6, tol = 1e-50,
                 precFactor = 3.0, trace = TRUE)
pi.. &lt;- 2*sol$min/3
print(pi.., digits=51)
stopifnot(all.equal(pi.., Const("pi", 256), tolerance = 10*1e-50))

if(doExtras) { # considerably more expensive

## a harder one:
f.sq &lt;- function(x) sin(x-2)^4 + sqrt(pmax(0,(x-1)*(x-4)))*(x-2)^2
curve(f.sq, 0, 4.5, n=1000)
msq &lt;- optimizeR(f.sq, 0, 5, tol = 1e-50, trace=5)
str(msq) # ok
stopifnot(abs(msq$minimum - 2) &lt; 1e-49)

## find the other local minimum: -- non-smooth ==&gt; Golden ratio -section is used
msq2 &lt;- optimizeR(f.sq, 3.5, 5, tol = 1e-50, trace=10)
stopifnot(abs(msq2$minimum - 4) &lt; 1e-49)

## and a local maximum:
msq3 &lt;- optimizeR(f.sq, 3, 4, maximum=TRUE, trace=2)
stopifnot(abs(msq3$maximum - 3.57) &lt; 1e-2)

}#end {doExtras}


##----- "impossible" one to get precisely ------------------------

ff &lt;- function(x) exp(-1/(x-8)^2)
curve(exp(-1/(x-8)^2), -3, 13, n=1001)
(opt. &lt;- optimizeR(function(x) exp(-1/(x-8)^2), -3, 13, trace = 5))
## -&gt; close to 8 {but not very close!}
ff(opt.$minimum) # gives 0
if(doExtras) {
 ## try harder ... in vain ..
 str(opt1 &lt;- optimizeR(ff, -3,13, tol = 1e-60, precFactor = 4))
 print(opt1$minimum, digits=20)
 ## still just  7.99998038 or 8.000036655 {depending on method}
}
</code></pre>

<hr>
<h2 id='pbetaI'>Accurate Incomplete Beta / Beta Probabilities For Integer Shapes</h2><span id='topic+pbetaI'></span>

<h3>Description</h3>

<p>For integers <code class="reqn">a</code>, <code class="reqn">b</code>, <code class="reqn">I_x(a,b)</code> aka
<code>pbeta(x, a,b)</code> is a polynomial in x with rational coefficients,
and hence arbitarily accurately computable.
</p>
<p>TODO (<em>not yet</em>):
It's sufficient for <em>one</em> of <code class="reqn">a,b</code> to be integer
such that the result is a <em>finite sum</em> (but the coefficients will no
longer be rational, see Abramowitz and Stegun, 26.5.6 and *.7, p.944).

</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pbetaI(q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE,
       precBits = NULL,
       useRational = !log.p &amp;&amp; !is.mpfr(q) &amp;&amp; is.null(precBits) &amp;&amp; int2,
       rnd.mode = c("N","D","U","Z","A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbetaI_+3A_q">q</code></td>
<td>
<p>called <code class="reqn">x</code>, above; vector of quantiles, in <code class="reqn">[0,1]</code>; can
be <code><a href="base.html#topic+numeric">numeric</a></code>, or of class <code>"<a href="#topic+mpfr">mpfr</a>"</code> or also
<code>"<a href="gmp.html#topic+bigq">bigq</a>"</code> (&ldquo;big rational&rdquo; from package
<a href="https://CRAN.R-project.org/package=gmp"><span class="pkg">gmp</span></a>); in the latter case, if <code>log.p = FALSE</code> as by
default, <em>all computations</em> are exact, using big rational
arithmetic.</p>
</td></tr>
<tr><td><code id="pbetaI_+3A_shape1">shape1</code>, <code id="pbetaI_+3A_shape2">shape2</code></td>
<td>
<p>the positive Beta &ldquo;shape&rdquo; parameters,
called <code class="reqn">a, b</code>, above. <b>Must</b> be integer valued for this
function.</p>
</td></tr>
<tr><td><code id="pbetaI_+3A_ncp">ncp</code></td>
<td>
<p>unused, only for compatibility with <code><a href="stats.html#topic+pbeta">pbeta</a></code>,
must be kept at its default, 0.</p>
</td></tr>
<tr><td><code id="pbetaI_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="pbetaI_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="pbetaI_+3A_precbits">precBits</code></td>
<td>
<p>the precision (in number of bits) to be used in
<code><a href="#topic+sumBinomMpfr">sumBinomMpfr</a>()</code>.</p>
</td></tr>
<tr><td><code id="pbetaI_+3A_userational">useRational</code></td>
<td>
<p>optional <code><a href="base.html#topic+logical">logical</a></code>, specifying if we
should try to do everything in exact <em>rational arithmetic</em>, i.e,
using package <a href="https://CRAN.R-project.org/package=gmp"><span class="pkg">gmp</span></a> functionality only, and return
<code><a href="gmp.html#topic+bigq">bigq</a></code> numbers instead of <code><a href="#topic+mpfr">mpfr</a></code> numbers.</p>
</td></tr>
<tr><td><code id="pbetaI_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see <code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>"<a href="#topic+mpfr-class">mpfr</a>"</code> vector of the same length as <code>q</code>.
</p>


<h3>Note</h3>

<p>For upper tail probabilities, i.e., when <code>lower.tail=FALSE</code>,
we may need large <code>precBits</code>, because the implicit or explicit
<code class="reqn">1 - P</code> computation suffers from severe cancellation.



</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>References</h3>

<p>Abramowitz, M. and Stegun, I. A. (1972)
<em>Handbook of Mathematical Functions</em>. New York: Dover.
<a href="https://en.wikipedia.org/wiki/Abramowitz_and_Stegun">https://en.wikipedia.org/wiki/Abramowitz_and_Stegun</a> provides
links to the full text which is in public domain.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pbeta">pbeta</a></code>, <code><a href="#topic+sumBinomMpfr">sumBinomMpfr</a></code> <code><a href="gmp.html#topic+chooseZ">chooseZ</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- (0:12)/16 # not all the way up ..
a &lt;- 7; b &lt;- 788

p.  &lt;- pbetaI(x, a, b) ## a bit slower:
system.time(
pp  &lt;- pbetaI(x, a, b, precBits = 2048)
) # 0.23 -- 0.50 sec
## Currently, the lower.tail=FALSE  are computed "badly":
lp  &lt;- log(pp)    ## = pbetaI(x, a, b, log.p=TRUE)
lIp &lt;- log1p(-pp) ## = pbetaI(x, a, b, lower.tail=FALSE, log.p=TRUE)
 Ip &lt;- 1 - pp     ## = pbetaI(x, a, b, lower.tail=FALSE)

if(Rmpfr:::doExtras()) { ## somewhat slow
   stopifnot(
     all.equal(lp,  pbetaI(x, a, b, precBits = 2048, log.p=TRUE)),
     all.equal(lIp, pbetaI(x, a, b, precBits = 2048, lower.tail=FALSE, log.p=TRUE),
               tol = 1e-230),
     all.equal( Ip, pbetaI(x, a, b, precBits = 2048, lower.tail=FALSE))
   )
}

rErr &lt;- function(approx, true, eps = 1e-200) {
    true &lt;- as.numeric(true) # for "mpfr"
    ifelse(Mod(true) &gt;= eps,
           ## relative error, catching '-Inf' etc :
	   ifelse(true == approx, 0, 1 - approx / true),
           ## else: absolute error (e.g. when true=0)
	   true - approx)
}

rErr(pbeta(x, a, b), pp)
rErr(pbeta(x, a, b, lower=FALSE), Ip)
rErr(pbeta(x, a, b, log = TRUE),  lp)
rErr(pbeta(x, a, b, lower=FALSE, log = TRUE),  lIp)

a.EQ &lt;- function(..., tol=1e-15) all.equal(..., tolerance=tol)
stopifnot(
  a.EQ(pp,  pbeta(x, a, b)),
  a.EQ(lp,  pbeta(x, a, b, log.p=TRUE)),
  a.EQ(lIp, pbeta(x, a, b, lower.tail=FALSE, log.p=TRUE)),
  a.EQ( Ip, pbeta(x, a, b, lower.tail=FALSE))
 )

## When 'q' is a  bigrational (i.e., class "bigq", package 'gmp'), everything
## is computed *exactly* with bigrational arithmetic:
(q4 &lt;- as.bigq(1, 2^(0:4)))
pb4 &lt;- pbetaI(q4, 10, 288, lower.tail=FALSE)
stopifnot( is.bigq(pb4) )
mpb4 &lt;- as(pb4, "mpfr")
mpb4[1:2]
getPrec(mpb4) # 128 349 1100 1746 2362
(pb. &lt;- pbeta(asNumeric(q4), 10, 288, lower.tail=FALSE))
stopifnot(mpb4[1] == 0,
          all.equal(mpb4, pb., tol=4e-15))

qbetaI. &lt;- function(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE,
    precBits = NULL, rnd.mode = c("N", "D", "U", "Z", "A"),
    tolerance = 1e-20, ...)
{
    if(is.na(a &lt;- as.integer(shape1))) stop("a = shape1 is not coercable to finite integer")
    if(is.na(b &lt;- as.integer(shape2))) stop("b = shape2 is not coercable to finite integer")
    unirootR(function(q) pbetaI(q, a, b, lower.tail=lower.tail, log.p=log.p,
                                precBits=precBits, rnd.mode=rnd.mode) - p,
             interval = if(log.p) c(-double.xmax, 0) else 0:1,
             tol = tolerance, ...)
} # end{qbetaI}

(p &lt;- 1 - mpfr(1,128)/20) # 'p' must be high precision
q95.1.3 &lt;- qbetaI.(p, 1,3, tolerance = 1e-29) # -&gt; ~29 digits accuracy
str(q95.1.3) ; roundMpfr(q95.1.3$root, precBits = 29 * log2(10))
## relative error is really small:
(relE &lt;- asNumeric(1 - pbetaI(q95.1.3$root, 1,3) / p))
stopifnot(abs(relE) &lt; 1e-28)
</code></pre>

<hr>
<h2 id='pmax'>Parallel Maxima and Minima</h2><span id='topic+pmax'></span><span id='topic+pmin'></span><span id='topic+pmax-methods'></span><span id='topic+pmin-methods'></span><span id='topic+pmax+2CANY-method'></span><span id='topic+pmax+2CmNumber-method'></span><span id='topic+pmin+2CANY-method'></span><span id='topic+pmin+2CmNumber-method'></span>

<h3>Description</h3>

<p>Returns the parallel maxima and minima of the input values.
</p>
<p>The functions <code>pmin</code> and <code>pmax</code> have been made S4 generics,
and this page documents the &ldquo;<code>...</code> method for class
<code>"mNumber"</code>&rdquo;, i.e., for arguments that are numeric or from
<code><a href="base.html#topic+class">class</a> "<a href="#topic+mpfr-class">mpfr</a>"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmax(..., na.rm = FALSE)
pmin(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmax_+3A_...">...</code></td>
<td>
<p>numeric or arbitrary precision numbers (class
<code><a href="#topic+mpfr-class">mpfr</a></code>).</p>
</td></tr>
<tr><td><code id="pmax_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be
removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="base.html#topic+Extremes">pmax</a></code>, the documentation of the base
functions, i.e., default methods.
</p>


<h3>Value</h3>

<p>vector-like, of length the longest of the input vectors; typically of
class <code><a href="#topic+mpfr-class">mpfr</a></code>, for the methods here.
</p>


<h3>Methods</h3>


<dl>
<dt>... = &quot;ANY&quot;</dt><dd><p>the default method, really just
<code><a href="base.html#topic+Extremes">base::pmin</a></code> or <code>base::pmax</code>,
respectively.</p>
</dd>
<dt>... = &quot;mNumber&quot;</dt><dd><p>the method for <code><a href="#topic+mpfr-class">mpfr</a></code>
arguments, mixed with numbers; designed to follow the same semantic as
the default method.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>The documentation of the <span class="pkg">base</span> functions,
<code><a href="base.html#topic+Extremes">pmin</a></code> and <code>pmax</code>; also
<code><a href="base.html#topic+min">min</a></code> and <code>max</code>; further,
</p>
<p><code><a href="base.html#topic+range">range</a></code> (<em>both</em> min and max).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> (pm &lt;- pmin(1.35, mpfr(0:10, 77)))
 stopifnot(pm == pmin(1.35, 0:10))
</code></pre>

<hr>
<h2 id='qnormI'>Gaussian / Normal Quantiles <code>qnorm()</code> via Inversion</h2><span id='topic+qnormI'></span>

<h3>Description</h3>

<p>Compute Gaussian or Normal Quantiles <code><a href="stats.html#topic+qnorm">qnorm</a>(p, *)</code> via
inversion of our &ldquo;mpfr-ified&rdquo; arbitrary accurate
<code><a href="#topic+pnorm">pnorm</a>()</code>, using our <code><a href="#topic+unirootR">unirootR</a>()</code> root
finder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
qnormI(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE,
       trace = 0, verbose = as.logical(trace),
       tol,
       useMpfr = any(prec &gt; 53),
       give.full = FALSE,
       ...)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="qnormI_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="qnormI_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="qnormI_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="qnormI_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="qnormI_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>

<tr><td><code id="qnormI_+3A_trace">trace</code></td>
<td>
<p>integer passed to <code><a href="#topic+unirootR">unirootR</a>()</code>.  If positive,
information about a search interval extension will be printed to the console.</p>
</td></tr>
<tr><td><code id="qnormI_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if progress details should be printed
to the console.</p>
</td></tr>
<tr><td><code id="qnormI_+3A_tol">tol</code></td>
<td>
<p>optionally the desired accuracy (convergence tolerance); if
missing or not finite, it is computed as <code class="reqn">2^-{pr+2}</code> where the
precision <code class="reqn">pr</code> is basically <code>max(<a href="#topic+getPrec">getPrec</a>(p+mean+sd))</code>.</p>
</td></tr>
<tr><td><code id="qnormI_+3A_usempfr">useMpfr</code></td>
<td>
<p>logical indicating if <code><a href="#topic+mpfr">mpfr</a></code> arithmetic should
be used.</p>
</td></tr>
<tr><td><code id="qnormI_+3A_give.full">give.full</code></td>
<td>
<p>logical indicating if the <em>full</em> result of
<code><a href="#topic+unirootR">unirootR</a>()</code> should be returned (when applicable).</p>
</td></tr>
<tr><td><code id="qnormI_+3A_...">...</code></td>
<td>
<p>optional further arguments passed to <code><a href="#topic+unirootR">unirootR</a>()</code>
such as <code>maxiter</code>, <code>verbDigits</code>, <code>check.conv</code>,
<code>warn.no.convergence</code>, and <code>epsC</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>give.full</code> is true, return a <code><a href="base.html#topic+list">list</a></code>, say <code>r</code>, of
<code><a href="#topic+unirootR">unirootR</a>(.)</code> results, with <code>length(r) == length(p)</code>.
</p>
<p>Otherwise, return a &ldquo;numeric vector&rdquo; like <code>p</code>, e.g., of
<code>class "mpfr"</code> when <code>p</code> is.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p>Standard <span class="rlang"><b>R</b></span>'s <code><a href="stats.html#topic+qnorm">qnorm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>doX &lt;- Rmpfr:::doExtras() # slow parts only if(doX)
cat("doExtras: ", doX, "\n")
p  &lt;- (0:32)/32
lp &lt;- -c(1000, 500, 200, 100, 50, 20:1, 2^-(1:8))
if(doX) {
  tol1 &lt;- 2.3e-16
  tolM &lt;- 1e-20
  tolRIlog &lt;- 4e-14
} else { # use one more than a third of the points:
   ip &lt;- c(TRUE,FALSE, rep_len(c(TRUE,FALSE,FALSE), length(p)-2L))
   p &lt;-  p[ip]
  lp &lt;- lp[ip]
  tol1 &lt;- 1e-9
  tolM &lt;- 1e-12
  tolRIlog &lt;- 25*tolM
}

f.all.eq &lt;- function(a,b)
  sub("^Mean relative difference:", '', format(all.equal(a, b, tol=0)))
for(logp  in c(FALSE,TRUE)) {
  pp &lt;- if(logp) lp else p
  mp &lt;- mpfr(pp, precBits = if(doX) 80 else 64) # precBits = 128 gave "the same" as 80
  for(l.tail in c(FALSE,TRUE)) {
      qn &lt;- qnorm (pp, lower.tail = l.tail, log.p = logp)
     qnI &lt;- qnormI(pp, lower.tail = l.tail, log.p = logp, tol = tol1)
     qnM &lt;- qnormI(mp, lower.tail = l.tail, log.p = logp, tol = tolM)
     cat(sprintf("Accuracy of qnorm(*, lower.t=%-5s, log.p=%-5s): %s || qnI: %s\n",
                 l.tail, logp, f.all.eq(qnM, qn ),
                               f.all.eq(qnM, qnI)))
     stopifnot(exprs = {
        all.equal(qn,  qnI, tol = if(logp) tolRIlog else 4*tol1)
        all.equal(qnM, qnI, tol = tol1)
     })
  }
}

## useMpfr, using mpfr()  :
if(doX) {
  p2 &lt;- 2^-c(1:27, 5*(6:20), 20*(6:15))
  e2 &lt;- 88
} else {
  p2 &lt;- 2^-c(1:2, 7, 77, 177, 307)
  e2 &lt;- 60
}
system.time( pn2 &lt;- pnorm(qnormI(mpfr(p2, e2))) ) # 4.1 or 0.68
           all.equal(p2, pn2, tol = 0) # 5.48e-29 // 5.2e-18
2^-e2
stopifnot(all.equal(p2, pn2, tol = 6 * 2^-e2)) # '4 *' needed


## Boundary -- from limits in mpfr maximal exponent range!
## 1) Use maximal ranges:
(old_eranges &lt;- .mpfr_erange()) # typically -/+ 2^30
(myERng &lt;- (1-2^-52) * .mpfr_erange(c("min.emin","max.emax")))
(doIncr &lt;- !isTRUE(all.equal(unname(myERng), unname(old_eranges)))) # ==&gt;
## TRUE only if long is 64-bit, i.e., *not* on Windows
if(doIncr) .mpfr_erange_set(value = myERng)

log2(abs(.mpfr_erange()))# 62 62 if(doIncr) i.e. not on Windows
(lrgOK &lt;- all(log2(abs(.mpfr_erange())) &gt;= 62)) # FALSE on Windows
## The largest quantile for which our mpfr-ized qnorm() does *NOT* underflow :
cM &lt;- if(doX) { "2528468770.343293436810768159197281514373932815851856314908753969469064"
      } else    "2528468770.34329343681"
##               1 3 5 7 9  1 3 5 7 9 1 3 5 7 9 1 3 5 7 9 1 3 5 7 9 1 3 5 7 9 1 3 5 7 9 1 3
##                       10         20        30        40        50        60        70
(qM &lt;- mpfr(cM))
(pM &lt;- pnorm(-qM)) # precision   if(doX) 233 else 70  bits of precision ;
## |--&gt; 0 on Windows {limited erange}; otherwise and if(doX) :
## 7.64890682545699845135633468495894619457903458325606933043966616334460003e-1388255822130839040
log(pM) # 233 bits: -3196577161300663205.8575919621115614148120323933633827052786873078552904

if(lrgOK) withAutoprint({
  
  try( qnormI(pM) ) ## Error: lower &lt; upper not fulfilled (evt. TODO)
  ## but this works
  print(qnI &lt;- qnormI(log(pM), log.p=TRUE)) #  -2528468770.343293436
  all.equal(-qM, qnI, tol = 0) # &lt;&lt; show how close; seen  1.084202e-19
  stopifnot( all.equal(-qM, qnI, tol = 1e-18) )
})

if(FALSE) # this (*SLOW*) gives 21 x the *same* (wrong) result --- FIXME!
  qnormI(log(pM) * (2:22), log.p=TRUE)
if(doX) ## Show how bad it is (currently ca. 220 iterations, and then *wrong*)
 str(qnormI(round(log(pM)), log.p=TRUE, trace=1, give.full = TRUE))
if(requireNamespace("DPQ"))
  new("mpfr", as(DPQ::qnormR(pM, trace=1), "mpfr")) # as(*, "mpfr") also works for +/- Inf
  # qnormR1(p=         0, m=0, s=1, l.t.= 1, log= 0): q = -0.5
  #    somewhat close to 0 or 1: r := sqrt(-lp) =  1.7879e+09
  #    r &gt; 5, using rational form R_3(t), for t=1.787897e+09  -- that is *not* accurate
  # [1] -94658744.369295865460462720............

## reset to previous status if needed
if(doIncr) .mpfr_erange_set( , old_eranges)
</code></pre>

<hr>
<h2 id='Rmpfr-workarounds'>Base Functions etc, as an Rmpfr version</h2><span id='topic+outer'></span>

<h3>Description</h3>

<p>Functions from <span class="pkg">base</span> etc which need a <em>copy</em> in the
<span class="pkg">Rmpfr</span> namespace so they correctly dispatch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outer(X, Y, FUN = "*", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rmpfr-workarounds_+3A_x">X</code>, <code id="Rmpfr-workarounds_+3A_y">Y</code>, <code id="Rmpfr-workarounds_+3A_fun">FUN</code>, <code id="Rmpfr-workarounds_+3A_...">...</code></td>
<td>
<p>See <span class="pkg">base</span> package help: <code><a href="base.html#topic+outer">outer</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+outer">outer</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>outer(1/mpfr(1:10, 70), 0:2)
</code></pre>

<hr>
<h2 id='roundMpfr'>Rounding to Binary bits, &quot;mpfr-internally&quot;</h2><span id='topic+roundMpfr'></span><span id='topic+setPrec'></span>

<h3>Description</h3>

<p>Rounding to binary bits, not decimal digits.  Closer to the number
representation, this also allows to <em>increase</em> or decrease a number's
precBits.  In other words, it acts as <code>setPrec()</code>, see
<code><a href="#topic+getPrec">getPrec</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundMpfr(x, precBits, rnd.mode = c("N","D","U","Z","A"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roundMpfr_+3A_x">x</code></td>
<td>
<p>an mpfr number (vector)</p>
</td></tr>
<tr><td><code id="roundMpfr_+3A_precbits">precBits</code></td>
<td>
<p>integer specifying the desired precision in bits.</p>
</td></tr>
<tr><td><code id="roundMpfr_+3A_rnd.mode">rnd.mode</code></td>
<td>
<p>a 1-letter string specifying how <em>rounding</em>
should happen at C-level conversion to MPFR, see <code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an mpfr number as <code>x</code> but with the new 'precBits' precision</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+mpfr-class">mpfr</a></code> class group method <code>Math2</code>
implements a method for <code><a href="base.html#topic+round">round</a>(x, digits)</code> which rounds to
<em>decimal</em> digits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> (p1 &lt;- Const("pi", 100)) # 100 bit prec
 roundMpfr(p1, 120) # 20 bits more, but "random noise"
 Const("pi", 120)   # same "precision", but really precise

</code></pre>

<hr>
<h2 id='sapplyMpfr'>Apply a Function over a &quot;mpfr&quot; Vector</h2><span id='topic+sapplyMpfr'></span>

<h3>Description</h3>

<p>Users may be disappointed to note that <code><a href="base.html#topic+sapply">sapply</a>()</code> or
<code><a href="base.html#topic+vapply">vapply</a>()</code> typically do not work with <code>"mpfr"</code>
numbers.
</p>
<p>This is a simple (but strong) approach to work around the problem,
based on <code><a href="base.html#topic+lapply">lapply</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sapplyMpfr(X, FUN, ..., drop_1_ = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sapplyMpfr_+3A_x">X</code></td>
<td>
<p>a vector, possibly of class <code>"<a href="#topic+mpfr-class">mpfr</a>"</code>.</p>
</td></tr>
<tr><td><code id="sapplyMpfr_+3A_fun">FUN</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> returning an <code>"<a href="#topic+mpfr-class">mpfr</a>"</code>
vector or even an <code>"<a href="#topic+mpfrArray-class">mpfrArray</a>"</code>.  May also be a
function returning a <code><a href="base.html#topic+numeric">numeric</a></code> vector or array for numeric
<code>X</code>, <em>and</em> which returns <code>"mpfr(Array)"</code> for an <code>X</code>
argument inheriting from <code>"<a href="#topic+mpfr-class">mpfr</a>"</code>.</p>
</td></tr>
<tr><td><code id="sapplyMpfr_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+lapply">lapply</a></code>,
typically further arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="sapplyMpfr_+3A_drop_1_">drop_1_</code></td>
<td>
<p>logical (with unusual name on purpose!) indicating if
1-column matrices (<code>"mpfrMatrix"</code>) should be &ldquo;dropped&rdquo; to
vectors (<code>"mpfr"</code>), the same as in base <span class="rlang"><b>R</b></span>'s own <code><a href="base.html#topic+sapply">sapply</a></code>.
This has been implicitly <code>FALSE</code> in <span class="pkg">Rmpfr</span> versions 0.8-5 to
0.8-9 (Oct 2021 to June 2022), accidentally.
Since <span class="pkg">Rmpfr</span> 0.9-0, this has been made an argument with default
<code>TRUE</code> to be compatible by default with <span class="rlang"><b>R</b></span>'s <code><a href="base.html#topic+sapply">sapply</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case <code>FUN(&lt;length-1&gt;)</code> returns an <code><a href="base.html#topic+array">array</a></code> or <code>"mpfrArray"</code>, i.e.,
with two or more dimensions, <code>sapplyMpfr()</code> returns an
<code>"mpfrArray"</code>; this is analogous to <code><a href="base.html#topic+sapply">sapply</a>(X, FUN, simplify = "array")</code>
(rather than the default <code>sapply()</code> behaviour which returns a
<code>matrix</code> also when a higher array would be more &ldquo;logical&rdquo;.)
</p>


<h3>Value</h3>

<p>an  <code>"<a href="#topic+mpfr-class">mpfr</a>"</code> vector, typically of the same length
as <code>X</code>.
</p>


<h3>Note</h3>

<p>This may still not always work as well as <code><a href="base.html#topic+sapply">sapply</a>()</code> does for
atomic vectors.  The examples seem to indicate that it typically does
work as desired, since <span class="pkg">Rmpfr</span> version 0.9-0.
</p>
<p>If you want to transform back to regular numbers anyway, it maybe simpler
and more efficient to use </p>
<pre>
    res &lt;- lapply(....)
    sapply(res, asNumeric, simplify = "array")
  </pre>
<p>instead of <code>sapplyMpfr()</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sapply">sapply</a></code>, <code><a href="base.html#topic+lapply">lapply</a></code>, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sapplyMpfr0 &lt;- ## Originally, the function was simply defined as
  function (X, FUN, ...) new("mpfr", unlist(lapply(X, FUN, ...), recursive = FALSE))

(m1 &lt;- sapply    (     3,      function(k) (1:3)^k)) # 3 x 1  matrix (numeric)
(p1 &lt;- sapplyMpfr(mpfr(3, 64), function(k) (1:3)^k))
stopifnot(m1 == p1, is(p1, "mpfrMatrix"), dim(p1) == c(3,1), dim(p1) == dim(m1))
k.s &lt;- c(2, 5, 10, 20)
(mk &lt;- sapply    (     k.s,      function(k) (1:3)^k)) # 3 x 4    "       "
(pm &lt;- sapplyMpfr(mpfr(k.s, 64), function(k) (1:3)^k))
stopifnot(mk == pm, is(pm, "mpfrMatrix"), dim(pm) == 3:4, 3:4 == dim(mk))
## was *wrongly* 4x3  in Rmpfr 0.8-x
f5k  &lt;- function(k) outer(1:5, k+0:2, `^`)# matrix-valued
(mk5 &lt;- sapply    (     k.s,      f5k))  # sapply()'s default; not "ideal"
(ak5 &lt;- sapply    (     k.s,      f5k, simplify = "array")) # what we want
(pm5 &lt;- sapplyMpfr(mpfr(k.s, 64), f5k))
stopifnot(c(mk5) == c(ak5), ak5 == pm5, is(pm5, "mpfrArray"), is.array(ak5),
          dim(pm5) == dim(ak5), dim(pm5) == c(5,3, 4))
if(require("Bessel")) { # here X, is simple
  bI1 &lt;- function(k) besselI.nuAsym(mpfr(1.31e9, 128), 10, expon.scaled=TRUE, k.max=k)
  bImp1 &lt;- sapplyMpfr (0:4, bI1, drop_1_ = FALSE) # 1x5 mpfrMatrix -- as in DPQ 0.8-8
  bImp  &lt;- sapplyMpfr (0:4, bI1, drop_1_ = TRUE ) # 5 "mpfr" vector {by default}
  bImp0 &lt;- sapplyMpfr0(0:4, bI1) # 5-vector
  stopifnot(identical(bImp, bImp0), bImp == bImp1,
            is(bImp, "mpfr"), is(bImp1, "mpfrMatrix"), dim(bImp1) == c(1, 5))
}# {Bessel}
</code></pre>

<hr>
<h2 id='seqMpfr'>&quot;mpfr&quot; Sequence Generation</h2><span id='topic+seqMpfr'></span>

<h3>Description</h3>

<p>Generate &lsquo;regular&rsquo;, i.e., arithmetic sequences.  This is in
lieu of methods for <code><a href="base.html#topic+seq">seq</a></code> (dispatching on all three of
<code>from</code>, <code>to</code>, and <code>by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqMpfr(from = 1, to = 1, by = ((to - from)/(length.out - 1)),
        length.out = NULL, along.with = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqMpfr_+3A_from">from</code>, <code id="seqMpfr_+3A_to">to</code></td>
<td>
<p>the starting and (maximal) end value (numeric or
<code>"<a href="#topic+mpfr-class">mpfr</a>"</code>) of the sequence.</p>
</td></tr>
<tr><td><code id="seqMpfr_+3A_by">by</code></td>
<td>
<p>number (numeric or <code>"<a href="#topic+mpfr-class">mpfr</a>"</code>): increment
of the sequence.</p>
</td></tr>
<tr><td><code id="seqMpfr_+3A_length.out">length.out</code></td>
<td>
<p>desired length of the sequence.  A non-negative
number, which will be rounded up if fractional.</p>
</td></tr>
<tr><td><code id="seqMpfr_+3A_along.with">along.with</code></td>
<td>
<p>take the length from the length of this argument.</p>
</td></tr>
<tr><td><code id="seqMpfr_+3A_...">...</code></td>
<td>
<p>arguments passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="base.html#topic+seq">seq</a></code> (default method in package <span class="pkg">base</span>),
whose semantic we want to replicate (almost).
</p>


<h3>Value</h3>

<p>a &lsquo;vector&rsquo; of class <code>"<a href="#topic+mpfr-class">mpfr</a>"</code>, when one of
the first three arguments was.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p>The documentation of the <span class="pkg">base</span> function <code><a href="base.html#topic+seq">seq</a></code>;
<code><a href="#topic+mpfr">mpfr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seqMpfr(0, 1, by = mpfr(0.25, prec=88))

seqMpfr(7, 3) # -&gt; default prec.

</code></pre>

<hr>
<h2 id='str.mpfr'>Compactly Show STRucture of Rmpfr Number Object</h2><span id='topic+str.mpfr'></span>

<h3>Description</h3>

<p>The <code><a href="utils.html#topic+str">str</a></code> method for objects of class
<code><a href="#topic+mpfr-class">mpfr</a></code> produces a bit more useful output than
the default method <code><a href="utils.html#topic+str.default">str.default</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpfr'
str(object, nest.lev, internal = FALSE,
    give.head = TRUE, digits.d = 12, vec.len = NULL, drop0trailing=TRUE,
    width = getOption("width"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str.mpfr_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+mpfr-class">mpfr</a></code>.</p>
</td></tr>
<tr><td><code id="str.mpfr_+3A_nest.lev">nest.lev</code></td>
<td>
<p>for <code><a href="utils.html#topic+str">str</a>()</code>, typically only used when
called by a higher level <code>str()</code>.</p>
</td></tr>
<tr><td><code id="str.mpfr_+3A_internal">internal</code></td>
<td>
<p>logical indicating if the low-level internal structure
should be shown; if true (not by default), uses <code>str(object@.Data)</code>.</p>
</td></tr>
<tr><td><code id="str.mpfr_+3A_give.head">give.head</code></td>
<td>
<p>logical indicating if the &ldquo;header&rdquo; should be
printed.</p>
</td></tr>
<tr><td><code id="str.mpfr_+3A_digits.d">digits.d</code></td>
<td>
<p>the number of digits to be used, will be passed
<code><a href="#topic+formatMpfr">formatMpfr</a>()</code> and hence <code>NULL</code> will use &ldquo;as
many as needed&rdquo;, i.e. often too many.  If this is a number, as per
default, less digits will be used in case the precision
(<code><a href="#topic+getPrec">getPrec</a>(object)</code>) is smaller.</p>
</td></tr>
<tr><td><code id="str.mpfr_+3A_vec.len">vec.len</code></td>
<td>
<p>the number of <em>elements</em> that will be shown.  The
default depends on the precision of <code>object</code> and <code>width</code>
(since <span class="pkg">Rmpfr</span> 0.6-0, it was <code>3</code> previously).</p>
</td></tr>
<tr><td><code id="str.mpfr_+3A_drop0trailing">drop0trailing</code></td>
<td>
<p>logical, passed to <code><a href="#topic+formatMpfr">formatMpfr</a>()</code> (with a
different default here).</p>
</td></tr>
<tr><td><code id="str.mpfr_+3A_width">width</code></td>
<td>
<p>the (approximately) desired width of output, see
<code><a href="base.html#topic+options">options</a>(width = .)</code>.</p>
</td></tr>
<tr><td><code id="str.mpfr_+3A_...">...</code></td>
<td>
<p>further arguments, passed to <code><a href="#topic+formatMpfr">formatMpfr</a>()</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+.mpfr2list">.mpfr2list</a>()</code> puts the internal structure into a
<code><a href="base.html#topic+list">list</a></code>, and its help page documents many more (low level) utilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- c(Const("pi", 64), mpfr(-2:2, 64)))
str(x)
str(list(pi = pi, x.mpfr = x))
str(x ^ 1000)
str(x ^ -1e4, digits=NULL) # full precision

str(x, internal = TRUE) # internal low-level (for experts)

uu &lt;- Const("pi", 16)# unaccurate
str(uu) # very similar to just   'uu'
</code></pre>

<hr>
<h2 id='sumBinomMpfr'>(Alternating) Binomial Sums via Rmpfr</h2><span id='topic+sumBinomMpfr'></span>

<h3>Description</h3>

<p>Compute (alternating) binomial sums via high-precision arithmetic.
If <code class="reqn">sBn(f, n) :=</code><code>sumBinomMpfr(n, f)</code>, (default
<code>alternating</code> is true, and <code>n0 = 0</code>),
</p>
<p style="text-align: center;"><code class="reqn">sBn(f,n) = \sum_{k = n0}^n (-1)^(n-k) {n \choose k}\cdot f(k) = \Delta^n f,</code>
</p>

<p>see Details for the <code class="reqn">n</code>-th forward difference operator
<code class="reqn">\Delta^n f</code>.  If <code>alternating</code> is false, the
<code class="reqn">(-1)^(n-k)</code> factor is dropped (or replaced by <code class="reqn">1</code>) above.
</p>
<p>Such sums appear in different contexts and are typically challenging,
i.e., currently impossible, to evaluate reliably as soon as <code class="reqn">n</code> is
larger than around <code class="reqn">50--70</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumBinomMpfr(n, f, n0 = 0, alternating = TRUE, precBits = 256,
             f.k = f(mpfr(k, precBits=precBits)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumBinomMpfr_+3A_n">n</code></td>
<td>
<p>upper summation index (integer).</p>
</td></tr>
<tr><td><code id="sumBinomMpfr_+3A_f">f</code></td>
<td>
<p><code><a href="base.html#topic+function">function</a></code> to be evaluated at <code class="reqn">k</code> for
<code>k in n0:n</code> (and which must return <em>one</em> value per <code>k</code>).</p>
</td></tr>
<tr><td><code id="sumBinomMpfr_+3A_n0">n0</code></td>
<td>
<p>lower summation index, typically <code>0</code> (= default) or <code>1</code>.</p>
</td></tr>
<tr><td><code id="sumBinomMpfr_+3A_alternating">alternating</code></td>
<td>
<p>logical indicating if the sum is alternating, see below.</p>
</td></tr>
<tr><td><code id="sumBinomMpfr_+3A_precbits">precBits</code></td>
<td>
<p>the number of bits for MPFR precision, see
<code><a href="#topic+mpfr">mpfr</a></code>.</p>
</td></tr>
<tr><td><code id="sumBinomMpfr_+3A_f.k">f.k</code></td>
<td>
<p>can be specified instead of <code>f</code> and <code>precBits</code>,
and must contain the equivalent of its default,
<code>f(mpfr(k, precBits=precBits))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alternating binomial sum <code class="reqn">sB(f,n) := sumBinom(n, f, n0=0)</code> is
equal to the <code class="reqn">n</code>-th forward difference operator <code class="reqn">\Delta^n f</code>,
</p>
<p style="text-align: center;"><code class="reqn">sB(f,n) = \Delta^n f,</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">\Delta^n f = \sum_{k=0}^{n} (-1)^{n-k}{n \choose k}\cdot f(k),</code>
</p>

<p>is the <code class="reqn">n</code>-fold iterated forward difference
<code class="reqn">\Delta f(x) = f(x+1) - f(x)</code> (for <code class="reqn">x = 0</code>).
</p>
<p>The current implementation might be improved in the future, notably
for the case where
<code class="reqn">sB(f,n)=</code><code>sumBinomMpfr(n, f, *)</code> is to be computed for a whole sequence
<code class="reqn">n = 1,\dots,N</code>.
</p>


<h3>Value</h3>

<p>an <code><a href="#topic+mpfr-class">mpfr</a></code> number of precision <code>precBits</code>.
<code class="reqn">s</code>. If <code>alternating</code> is true (as per default),
</p>
<p style="text-align: center;"><code class="reqn">s = \sum_{k = n0}^n (-1)^k {n \choose k}\cdot f(k),</code>
</p>

<p>if <code>alternating</code> is false, the <code class="reqn">(-1)^k</code> factor is dropped (or
replaced by <code class="reqn">1</code>) above.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler, after conversations with Christophe Dutang.</p>


<h3>References</h3>

<p>Wikipedia (2012)
The N\&quot;orlund-Rice integral,
<a href="https://en.wikipedia.org/wiki/Rice_integral">https://en.wikipedia.org/wiki/Rice_integral</a>
</p>
<p>Flajolet, P. and Sedgewick, R. (1995)
Mellin Transforms and Asymptotics: Finite Differences and Rice's Integrals,
<em>Theoretical Computer Science</em> <b>144</b>, 101&ndash;124.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chooseMpfr">chooseMpfr</a></code>, <code><a href="gmp.html#topic+chooseZ">chooseZ</a></code> from package <span class="pkg">gmp</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## "naive" R implementation:
sumBinom &lt;- function(n, f, n0=0, ...) {
  k &lt;- n0:n
  sum( choose(n, k) * (-1)^(n-k) * f(k, ...))
}

## compute  sumBinomMpfr(.) for a whole set of 'n' values:
sumBin.all &lt;- function(n, f, n0=0, precBits = 256, ...)
{
  N &lt;- length(n)
  precBits &lt;- rep(precBits, length = N)
  ll &lt;- lapply(seq_len(N), function(i)
           sumBinomMpfr(n[i], f, n0=n0, precBits=precBits[i], ...))
  sapply(ll, as, "double")
}
sumBin.all.R &lt;- function(n, f, n0=0, ...)
   sapply(n, sumBinom, f=f, n0=n0, ...)

n.set &lt;- 5:80
system.time(res.R   &lt;- sumBin.all.R(n.set, f = sqrt)) ## instantaneous..
system.time(resMpfr &lt;- sumBin.all  (n.set, f = sqrt)) ## ~ 0.6 seconds

matplot(n.set, cbind(res.R, resMpfr), type = "l", lty=1,
        ylim = extendrange(resMpfr, f = 0.25), xlab = "n",
        main = "sumBinomMpfr(n, f = sqrt)  vs.  R double precision")
legend("topleft", leg=c("double prec.", "mpfr"), lty=1, col=1:2, bty = "n")
</code></pre>

<hr>
<h2 id='unirootR'>One Dimensional Root (Zero) Finding &ndash; in pure <span class="rlang"><b>R</b></span></h2><span id='topic+unirootR'></span>

<h3>Description</h3>

<p>The function <code>unirootR</code> searches the interval from <code>lower</code>
to <code>upper</code> for a root (i.e., zero) of the function <code>f</code> with
respect to its first argument.
</p>
<p><code>unirootR()</code> is &ldquo;clone&rdquo; of <code><a href="stats.html#topic+uniroot">uniroot</a>()</code>,
written entirely in <span class="rlang"><b>R</b></span>, in a way that it works with
<code><a href="#topic+mpfr-class">mpfr</a></code>-numbers as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unirootR(f, interval, ...,
        lower = min(interval), upper = max(interval),
        f.lower = f(lower, ...), f.upper = f(upper, ...),
        extendInt = c("no", "yes", "downX", "upX"),
        trace = 0, verbose = as.logical(trace),
        verbDigits = max(3, min(20, -log10(tol)/2)),
        tol = .Machine$double.eps^0.25, maxiter = 1000L,
        check.conv = FALSE,
        warn.no.convergence = !check.conv,
        epsC = NULL)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="unirootR_+3A_f">f</code></td>
<td>
<p>the function for which the root is sought.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval
to be searched for the root.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_...">...</code></td>
<td>
<p>additional named or unnamed arguments to be passed
to <code>f</code></p>
</td></tr>
<tr><td><code id="unirootR_+3A_lower">lower</code>, <code id="unirootR_+3A_upper">upper</code></td>
<td>
<p>the lower and upper end points of the interval to
be searched.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_f.lower">f.lower</code>, <code id="unirootR_+3A_f.upper">f.upper</code></td>
<td>
<p>the same as <code>f(upper)</code> and
<code>f(lower)</code>, respectively.  Passing these values from the caller
where they are often known is more economical as soon as <code>f()</code>
contains non-trivial computations.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_extendint">extendInt</code></td>
<td>
<p>character string specifying if the interval
<code>c(lower,upper)</code> should be extended or directly produce an error
when <code>f()</code> does not have differing signs at the endpoints.  The
default, <code>"no"</code>, keeps the search interval and hence produces
an error.  Can be abbreviated.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_trace">trace</code></td>
<td>
<p>integer number; if positive, tracing information is
produced.  Higher values giving more details.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_verbose">verbose</code></td>
<td>
<p>logical (or integer) indicating if (and how much)
verbose output should be produced during the iterations.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_verbdigits">verbDigits</code></td>
<td>
<p>used only if <code>verbose</code> is true, indicates the
number of digits numbers should be printed with, using
<code><a href="base.html#topic+format">format</a>(., digits=verbDigits)</code>.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_tol">tol</code></td>
<td>
<p>the desired accuracy (convergence tolerance).</p>
</td></tr>
<tr><td><code id="unirootR_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_check.conv">check.conv</code></td>
<td>
<p>logical indicating whether non convergence
should be caught as an error, notably non-convergence in <code>maxiter</code>
iterations should be an error instead of a warning.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_warn.no.convergence">warn.no.convergence</code></td>
<td>
<p>if set to <code>FALSE</code> there's no warning
about non-convergence.  Useful to just run a few iterations.</p>
</td></tr>
<tr><td><code id="unirootR_+3A_epsc">epsC</code></td>
<td>
<p>positive number or <code>NULL</code> in which case a smart
default is sought.  This should specify the &ldquo;achievable
machine precision&rdquo; <em>for</em> the given numbers and their
arithmetic.
</p>
<p>The default will set this to <code><a href="base.html#topic+.Machine">.Machine</a>$double.eps</code> for
double precision numbers, and will basically use
<code>2 ^ - min(getPrec(f.lower), getPrec(f.upper))</code> when that works
(as, e.g., for <code><a href="#topic+mpfr-class">mpfr</a></code>-numbers) otherwise.
</p>
<p>This is factually a lower bound for the achievable lower bound, and
hence, setting <code>tol</code> smaller than <code>epsC</code> is typically
non-sensical and produces a warning.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that arguments after <code>...</code> must be matched exactly.
</p>
<p>Either <code>interval</code> or both <code>lower</code> and <code>upper</code> must be
specified: the upper endpoint must be strictly larger than the lower
endpoint.  The function values at the endpoints must be of opposite
signs (or zero), for <code>extendInt="no"</code>, the default.  Otherwise, if
<code>extendInt="yes"</code>, the interval is extended on both sides, in
search of a sign change, i.e., until the search interval <code class="reqn">[l,u]</code>
satisfies <code class="reqn">f(l) \cdot f(u) \le 0</code>.
</p>
<p>If it is <em>known how</em> <code class="reqn">f</code> changes sign at the root
<code class="reqn">x_0</code>, that is, if the function is increasing or decreasing there,
<code>extendInt</code> can (and typically should) be specified as
<code>"upX"</code> (for &ldquo;upward crossing&rdquo;) or <code>"downX"</code>,
respectively.  Equivalently, define <code class="reqn">S := \pm 1</code>, to
require <code class="reqn">S = \mathrm{sign}(f(x_0 + \epsilon))</code> at the solution.  In that case, the search interval <code class="reqn">[l,u]</code>
possibly is extended to be such that <code class="reqn">S\cdot f(l)\le 0</code> and <code class="reqn">S \cdot f(u) \ge 0</code>.
</p>
<p>The function only uses <span class="rlang"><b>R</b></span> code with basic arithmetic, such that it
should also work with &ldquo;generalized&rdquo; numbers (such as
<code><a href="#topic+mpfr-class">mpfr</a></code>-numbers) as long the necessary
<code><a href="base.html#topic+Ops">Ops</a></code> methods are defined for those.
</p>
<p>The underlying algorithm assumes a continuous function (which then is
known to have at least one root in the interval).
</p>
<p>Convergence is declared either if <code>f(x) == 0</code> or the change in
<code>x</code> for one step of the algorithm is less than <code>tol</code> (plus an
allowance for representation error in <code>x</code>).
</p>
<p>If the algorithm does not converge in <code>maxiter</code> steps, a warning
is printed and the current approximation is returned.
</p>
<p><code>f</code> will be called as <code>f(<var>x</var>, ...)</code> for a (generalized)
numeric value of <var>x</var>.
</p>


<h3>Value</h3>

<p>A list with four components: <code>root</code> and <code>f.root</code> give the
location of the root and the value of the function evaluated at that
point. <code>iter</code> and <code>estim.prec</code> give the number of iterations
used and an approximate estimated precision for <code>root</code>.  (If the
root occurs at one of the endpoints, the estimated precision is
<code>NA</code>.)
</p>


<h3>Source</h3>

<p>Based on <code>zeroin()</code> (in package <span class="pkg">rootoned</span>) by John Nash who
manually translated the C code in <span class="rlang"><b>R</b></span>'s <code>zeroin.c</code> and on
<code><a href="stats.html#topic+uniroot">uniroot</a>()</code> in <span class="rlang"><b>R</b></span>'s sources.
</p>


<h3>References</h3>

<p>Brent, R. (1973),   see <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
</p>


<h3>See Also</h3>

<p><span class="rlang"><b>R</b></span>'s own (<span class="pkg">stats</span> package) <code><a href="stats.html#topic+uniroot">uniroot</a></code>.
<code><a href="base.html#topic+polyroot">polyroot</a></code> for all complex roots of a polynomial;
<code><a href="stats.html#topic+optimize">optimize</a></code>, <code><a href="stats.html#topic+nlm">nlm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(utils) # for str

## some platforms hit zero exactly on the first step:
## if so the estimated precision is 2/3.
f &lt;- function (x,a) x - a
str(xmin &lt;- unirootR(f, c(0, 1), tol = 0.0001, a = 1/3))

## handheld calculator example: fixpoint of cos(.):
rc &lt;- unirootR(function(x) cos(x) - x, lower=-pi, upper=pi, tol = 1e-9)
rc$root

## the same with much higher precision:
rcM &lt;- unirootR(function(x) cos(x) - x,
                 interval= mpfr(c(-3,3), 300), tol = 1e-40)
rcM
x0 &lt;- rcM$root
stopifnot(all.equal(cos(x0), x0,
                    tol = 1e-40))## 40 digits accurate!

str(unirootR(function(x) x*(x^2-1) + .5, lower = -2, upper = 2,
            tol = 0.0001), digits.d = 10)
str(unirootR(function(x) x*(x^2-1) + .5, lower = -2, upper = 2,
            tol = 1e-10 ), digits.d = 10)

## A sign change of f(.), but not a zero but rather a "pole":
tan. &lt;- function(x) tan(x * (Const("pi",200)/180))# == tan( &lt;angle&gt; )
(rtan &lt;- unirootR(tan., interval = mpfr(c(80,100), 200), tol = 1e-40))
## finds 90 {"ok"}, and now gives a warning


## Find the smallest value x for which exp(x) &gt; 0 (numerically):
r &lt;- unirootR(function(x) 1e80*exp(x)-1e-300, c(-1000,0), tol = 1e-15)
str(r, digits.d = 15) ##&gt; around -745, depending on the platform.

exp(r$root)     # = 0, but not for r$root * 0.999...
minexp &lt;- r$root * (1 - 10*.Machine$double.eps)
exp(minexp)     # typically denormalized

## --- using mpfr-numbers :

## Find the smallest value x for which exp(x) &gt; 0 ("numerically");
## Note that mpfr-numbers underflow *MUCH* later than doubles:
## one of the smallest mpfr-numbers {see also ?mpfr-class } :
(ep.M &lt;- mpfr(2, 55) ^ - ((2^30 + 1) * (1 - 1e-15)))
r &lt;- unirootR(function(x) 1e99* exp(x) - ep.M, mpfr(c(-1e20, 0), 200))
r # 97 iterations; f.root is very similar to ep.M

## interval extension 'extendInt'  --------------

f1 &lt;- function(x) (121 - x^2)/(x^2+1)
f2 &lt;- function(x) exp(-x)*(x - 12)
tools::assertError(unirootR(f1, c(0,10)), verbose=TRUE)
##--&gt; error: f() .. end points not of opposite sign

## where as  'extendInt="yes"'  simply first enlarges the search interval:
u1 &lt;- unirootR(f1, c(0,10),extendInt="yes", trace=1)
u2 &lt;- unirootR(f2, mpfr(c(0,2), 128), extendInt="yes", trace=2, verbose=FALSE, tol = 1e-25)
stopifnot(all.equal(u1$root, 11, tolerance = 1e-5),
          all.equal(u2$root, 12, tolerance = 1e-23))

## The *danger* of interval extension:
## No way to find a zero of a positive function, but
## numerically, f(-|M|) becomes zero :
u3 &lt;- unirootR(exp, c(0,2), extendInt="yes", trace=TRUE)

## Nonsense example (must give an error):
tools::assertCondition( unirootR(function(x) 1, 0:1, extendInt="yes"),
                       "error", verbose=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
