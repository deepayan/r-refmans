<!DOCTYPE html><html><head><title>Help for package sarp.snowprofile</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sarp.snowprofile}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sarp.snowprofile-package'><p>sarp.snowprofile: Snow Profile Analysis for Snowpack and Avalanche Research</p></a></li>
<li><a href='#+5B.snowprofileSet'><p>Extract method</p></a></li>
<li><a href='#char2numAspect'><p>Conversion of character Aspects to numeric Aspects</p></a></li>
<li><a href='#char2numHHI'><p>Conversion of Hand Hardness Index (HHI)</p></a></li>
<li><a href='#computeRTA'><p>Compute Relative Threshold Sum approach (RTA)</p></a></li>
<li><a href='#computeSLABrho'><p>Compute mean density of slab</p></a></li>
<li><a href='#computeSLABrhogs'><p>Compute 'density over grain size' averaged over slab</p></a></li>
<li><a href='#computeTSA'><p>Compute Threshold Sum Approach (TSA, lemons, yellow flags, 'Nieten')</p></a></li>
<li><a href='#deriveDatetag'><p>Derive datetag from deposition dates in simulated profiles</p></a></li>
<li><a href='#export.snowprofileCsv'><p>Export or write a snowprofile object to a CSV table</p></a></li>
<li><a href='#findPWL'><p>Find layers of interest (e.g. PWLs) in snowprofile(Layers)</p></a></li>
<li><a href='#format_snowprofileLayers'><p>Format snowprofileLayers</p></a></li>
<li><a href='#getColoursDensity'><p>Gets colours for plotting snow density values</p></a></li>
<li><a href='#getColoursGrainSize'><p>Gets colours for plotting grain size values</p></a></li>
<li><a href='#getColoursGrainType'><p>Gets colours for plotting snow grain types</p></a></li>
<li><a href='#getColoursHardness'><p>Gets colours for plotting snow hardness values</p></a></li>
<li><a href='#getColoursLWC'><p>Gets colours for plotting LWC values</p></a></li>
<li><a href='#getColoursPercentage'><p>Gets colours for plotting the snow layer property 'percentage'</p></a></li>
<li><a href='#getColoursSnowTemp'><p>Gets colours for plotting snow temperature values</p></a></li>
<li><a href='#getColoursStability'><p>Gets colours for plotting snow stability indices</p></a></li>
<li><a href='#grainDict'><p>A data.frame storing the grain type colours</p></a></li>
<li><a href='#hasUnobservedBasalLayer'><p>Check whether a profile is observed down to ground or not</p></a></li>
<li><a href='#importRDefaultPackages'><p>Import R_DEFAULT_PACKAGES</p></a></li>
<li><a href='#insertUnobservedBasalLayer'><p>Insert a special layer at the bottom to indicate a snow profile that's unobserved from a specific point down to the ground</p>
internal function, not exported. used in snowprofileLayers</a></li>
<li><a href='#is.snowprofile'><p>Check class snowprofile</p></a></li>
<li><a href='#is.snowprofileInstabilitySigns'><p>Check class snowprofileInstabilitySigns</p></a></li>
<li><a href='#is.snowprofileLayers'><p>Check class snowprofileLayers</p></a></li>
<li><a href='#is.snowprofileSet'><p>Check class snowprofileSet</p></a></li>
<li><a href='#is.snowprofileTests'><p>Check class snowprofileTests</p></a></li>
<li><a href='#new_snowprofile'><p>Low-level constructor function for a snowprofile object</p></a></li>
<li><a href='#numberOfPWLsPerVerticalLevel'><p>Count number of PWLs per vertical level</p></a></li>
<li><a href='#plot.snowprofile'><p>Plot hardness profile</p></a></li>
<li><a href='#plot.snowprofileSet'><p>Plot a single layer property in multiple profiles side-by-side</p></a></li>
<li><a href='#print.snowprofile'><p>Print snowprofile object</p></a></li>
<li><a href='#rbind.snowprofile'><p>Convert snowprofile into data.frame with columns for metadata</p></a></li>
<li><a href='#rbind.snowprofileSet'><p>Concatenate snowprofileSet into a large data.frame with a row for each layer</p></a></li>
<li><a href='#readSmet'><p>Parse a SMET file</p></a></li>
<li><a href='#reformat_snowprofile'><p>Reformat a malformatted snowprofile object</p></a></li>
<li><a href='#scanProfileDates'><p>Read profile dates from prf/pro file</p></a></li>
<li><a href='#sd_sample_uncorrected'><p>fast uncorrected sample standard deviation</p>
https://en.wikipedia.org/wiki/Standard_deviation#Rapid_calculation_methods</a></li>
<li><a href='#setColoursGrainType'><p>Set colour scale for grain types</p></a></li>
<li><a href='#simplifyGtypes'><p>Simplify detailed grain types to parent classes</p></a></li>
<li><a href='#snowprofile'><p>High-level constructor for a snowprofile object</p></a></li>
<li><a href='#snowprofileCaaml'><p>Read a Caaml file into a snowprofile object</p></a></li>
<li><a href='#snowprofileCsv'><p>Read csv file into a snowprofile object</p></a></li>
<li><a href='#snowprofileCsv_advanced'><p>Read routine for advanced csv tables containing various snowprofile information</p></a></li>
<li><a href='#snowprofileInstabilitySigns'><p>Constructor for a snowprofileInstabilitySigns object</p></a></li>
<li><a href='#snowprofileLayers'><p>Constructor for a snowprofileLayers object</p></a></li>
<li><a href='#snowprofilePrf'><p>Construct snowprofile object from PRF file</p></a></li>
<li><a href='#snowprofilePro'><p>Construct snowprofile object from PRO file</p></a></li>
<li><a href='#snowprofileSet'><p>Constructor for class snowprofileSet</p></a></li>
<li><a href='#snowprofileSno'><p>Construct snowprofile object from SNO file</p></a></li>
<li><a href='#snowprofileTests'><p>Constructor for a snowprofileTests object</p></a></li>
<li><a href='#SPgroup'><p>Example group of snowprofiles from a mountain drainage</p></a></li>
<li><a href='#SPmalformatted'><p>Malformatted example profiles</p></a></li>
<li><a href='#SPpairs'><p>Pairs of example snowprofiles</p></a></li>
<li><a href='#SPtimeline'><p>Timeseries of snowprofiles</p>
#'</a></li>
<li><a href='#summary.snowprofile'><p>Summary of a single snowprofile</p></a></li>
<li><a href='#summary.snowprofileSet'><p>Summarize multiple snowprofiles</p></a></li>
<li><a href='#swisscode'><p>Numerical, Swiss Grain Type Code</p></a></li>
<li><a href='#validate_snowprofile'><p>Validate correctness of snowprofile object</p></a></li>
<li><a href='#validate_snowprofileLayers'><p>Validate correctness of snowprofileLayers object</p></a></li>
<li><a href='#writeSmet'><p>Write a SMET file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-02</td>
</tr>
<tr>
<td>Title:</td>
<td>Snow Profile Analysis for Snowpack and Avalanche Research</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis and plotting tools for snow profile data produced from manual snowpack 
  observations and physical snowpack models. The functions in this package support snowpack 
  and avalanche research by reading various formats of data (including CAAML, SMET,
  generic csv, and outputs from the snow cover model SNOWPACK), manipulate the data, and 
  produce graphics such as stratigraphy and time series profiles. Package developed by 
  the Simon Fraser University Avalanche Research Program <a href="http://www.avalancheresearch.ca">http://www.avalancheresearch.ca</a>. 
  Graphics apply visualization concepts from Horton, Nowak, and Haegeli (2020, 
  &lt;<a href="https://doi.org/10.5194%2Fnhess-20-1557-2020">doi:10.5194/nhess-20-1557-2020</a>&gt;).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.avalancheresearch.ca">http://www.avalancheresearch.ca</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-CA</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, methods, xml2,</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, stringr, sarp.snowprofile.alignment</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-08 12:08:10 UTC; flo</td>
</tr>
<tr>
<td>Author:</td>
<td>Pascal Haegeli [aut, cre],
  Simon Horton [aut],
  Florian Herla [aut],
  SFU Avalanche Research Program [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pascal Haegeli &lt;pascal_haegeli@sfu.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-08 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sarp.snowprofile-package'>sarp.snowprofile: Snow Profile Analysis for Snowpack and Avalanche Research</h2><span id='topic+sarp.snowprofile'></span><span id='topic+sarp.snowprofile-package'></span>

<h3>Description</h3>

<p>Analysis and plotting tools for snow profile data produced from manual snowpack observations and physical snowpack models. The functions in this package support snowpack and avalanche research by reading various formats of data (including CAAML, SMET, generic csv, and outputs from the snow cover model SNOWPACK), manipulate the data, and produce graphics such as stratigraphy and time series profiles. Package developed by the Simon Fraser University Avalanche Research Program <a href="http://www.avalancheresearch.ca">http://www.avalancheresearch.ca</a>. Graphics apply visualization concepts from Horton, Nowak, and Haegeli (2020, <a href="https://doi.org/10.5194/nhess-20-1557-2020">doi:10.5194/nhess-20-1557-2020</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pascal Haegeli <a href="mailto:pascal_haegeli@sfu.ca">pascal_haegeli@sfu.ca</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Simon Horton <a href="mailto:shorton@sfu.ca">shorton@sfu.ca</a>
</p>
</li>
<li><p> Florian Herla <a href="mailto:fherla@sfu.ca">fherla@sfu.ca</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> SFU Avalanche Research Program [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://www.avalancheresearch.ca">http://www.avalancheresearch.ca</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.snowprofileSet'>Extract method</h2><span id='topic++5B.snowprofileSet'></span>

<h3>Description</h3>

<p>Extract method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snowprofileSet'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.snowprofileSet_+3A_x">x</code></td>
<td>
<p>object from which to extract element(s) or in which to replace element(s).</p>
</td></tr>
<tr><td><code id="+2B5B.snowprofileSet_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract or replace</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+snowprofileSet">snowprofileSet</a> object
</p>

<hr>
<h2 id='char2numAspect'>Conversion of character Aspects to numeric Aspects</h2><span id='topic+char2numAspect'></span>

<h3>Description</h3>

<p>Convert character aspects (of snow profile locations) to numeric values.
For example, Aspect &quot;N&quot; (north) becomes 0 degrees azimuth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2numAspect(charAspect)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char2numAspect_+3A_charaspect">charAspect</code></td>
<td>
<p>Character string of aspect location, i.e., one of
</p>

<ul>
<li> <p><code>c("N", "NE", "NNE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW")</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Float value of numeric aspect location, North = 0 degree, S = 180 degree
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char2numAspect("W")
char2numAspect("WNW")

char2numAspect(c("N", NA, "NA", "NE"))

</code></pre>

<hr>
<h2 id='char2numHHI'>Conversion of Hand Hardness Index (HHI)</h2><span id='topic+char2numHHI'></span>

<h3>Description</h3>

<p>Convert character hand hardness index (HHI) of snow layers to numeric values.
For example, hand hardness Fist becomes 1, Ice becomes 6.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2numHHI(charHHI)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char2numHHI_+3A_charhhi">charHHI</code></td>
<td>
<p>Character string of hand hardness level, i.e., one of
</p>

<ul>
<li><p> Fist 'F', 4 Fingers '4F', 1 Finger '1F', Pencil 'P', Knife 'K', or Ice 'I'
</p>
</li>
<li><p> intermediate values allowed, e.g. 'F+', '1F-', 'F-4F'
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Float value of numeric hand hardness level between 1 and 6.
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char2numHHI('F+')
char2numHHI('F-')
char2numHHI('F-4F')

## not meaningful:
this_throws_error &lt;- TRUE
if (!this_throws_error) {
char2numHHI('F-P')
}

</code></pre>

<hr>
<h2 id='computeRTA'>Compute Relative Threshold Sum approach (RTA)</h2><span id='topic+computeRTA'></span><span id='topic+computeRTA.snowprofileSet'></span><span id='topic+computeRTA.snowprofile'></span>

<h3>Description</h3>

<p>The function can compute the RTA index for layers and for interfaces. The calculation follows the example in Monti (2013),
referenced below. The six individual relative lemons are computed as follows. To compute the RTA index for layers,
the layer properties are combined with the interface properties of the weakest interface below or above the layer.
To compute the RTA index for interfaces, the interface properties are combined with the weakest layer properties below
or above the interface. The six properties considered in the index are
</p>

<ul>
<li><p> grain size, hardness, grain type (layer properties)
</p>
</li>
<li><p> difference of grain sizes and hardness (at the interface)
</p>
</li>
<li><p> depth (at the top interface of the layer)
</p>
</li></ul>

<p>Instead of implementing a static threshold for the depth weighting, the depth is scaled with a weibull function
that is corrected for potential crusts and their stabilizing effects (Monti and Mitterer, personal communication).
</p>
<p>Note that due to the crust correction, the results from this function will only be correct if applied to profiles
that have not yet been resampled (such as by functions from sarp.snowprofile.alignment: <code>resampleSP</code>, <code>resampleSPpairs</code>,
<code>dtw</code>, <code>averageSP</code>).
</p>
<p>The RTA index ranges between <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>, with the weakest layer/interface euqal to 1. Values &gt; 0.8 indicate layers/interfaces with a poor structural stability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeRTA(x, target = c("interface", "layer"))

## S3 method for class 'snowprofileSet'
computeRTA(x, target = c("interface", "layer"))

## S3 method for class 'snowprofile'
computeRTA(x, target = c("interface", "layer"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeRTA_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+snowprofile">snowprofile</a> or <a href="#topic+snowprofileSet">snowprofileSet</a>. Profile layer properties must be known for all layers (i.e., no NAs in gtype, hardness, gsize allowed!)</p>
</td></tr>
<tr><td><code id="computeRTA_+3A_target">target</code></td>
<td>
<p>Do you want to compute the index for the layers or for the layer interfaces? defaults to both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object will be returned with the new layer properties <code>rta</code>/<code>rta_interface</code> describing the RTA index added to the profile layers.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>computeRTA(snowprofileSet)</code>: for <a href="#topic+snowprofileSet">snowprofileSet</a>s
</p>
</li>
<li> <p><code>computeRTA(snowprofile)</code>: for <a href="#topic+snowprofile">snowprofile</a>s
</p>
</li></ul>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>References</h3>

<p>Monti, F., &amp; Schweizer, J. (2013). A relative difference approach to detect potential weak layers within a snow profile.
Proceedings of the 2013 International Snow Science Workshop, Grenoble, France, 339–343. Retrieved from https://arc.lib.montana.edu/snow-science/item.php?id=1861
</p>


<h3>See Also</h3>

<p><a href="#topic+computeTSA">computeTSA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## apply function to snowprofileSet
profileset &lt;- computeRTA(SPgroup)

## apply function to snowprofile and plot output
sp &lt;- computeRTA(SPpairs$B_modeled1)
plot(sp, TempProfile = FALSE, main = "RTA")
lines(sp$layers$rta*5, sp$layers$height - 0.5*sp$layers$thickness, type = "b", xlim = c(0, 5))
lines(sp$layers$rta_interface*5, sp$layers$height, type = "b", xlim = c(0, 5), col = "red")
abline(h = sp$layers$height, lty = "dotted", col = "grey")
abline(v = 0.8*5, lty = "dashed")
</code></pre>

<hr>
<h2 id='computeSLABrho'>Compute mean density of slab</h2><span id='topic+computeSLABrho'></span>

<h3>Description</h3>

<p>For each layer, compute the average density of all layers above, i.e. <code style="white-space: pre;">&#8288;&lt;rho&gt;_slab&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSLABrho(profile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSLABrho_+3A_profile">profile</code></td>
<td>
<p><a href="#topic+snowprofile">snowprofile</a> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>snowprofile object with added layers column <code style="white-space: pre;">&#8288;$slab_rho&#8288;</code>. Note that topmost layer is always <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>fherla
</p>

<hr>
<h2 id='computeSLABrhogs'>Compute 'density over grain size' averaged over slab</h2><span id='topic+computeSLABrhogs'></span>

<h3>Description</h3>

<p>For each layer, compute the average density over grain size of all layers above, i.e. <code style="white-space: pre;">&#8288;&lt;rho/gs&gt;_slab&#8288;</code>.
This variable has been found to characterize the cohesion of slabs: new snow slabs tend to consist of low density &amp; large grains, and
more cohesive slabs of older snow tend to consist of higher density &amp; smaller grains (Mayer et al, 2022 in review).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSLABrhogs(profile, implementation = c("pub", "literal")[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSLABrhogs_+3A_profile">profile</code></td>
<td>
<p><a href="#topic+snowprofile">snowprofile</a> object</p>
</td></tr>
<tr><td><code id="computeSLABrhogs_+3A_implementation">implementation</code></td>
<td>
<p><code>"pub"</code> for <code style="white-space: pre;">&#8288;&lt;rho/gs&gt;_slab&#8288;</code>, <code>"literal"</code> for 'mean density of slab over mean grain size of slab' <code style="white-space: pre;">&#8288;&lt;rho&gt;_slab / &lt;gs&gt;_slab&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>snowprofile object with added layers column <code style="white-space: pre;">&#8288;$slab_rhogs&#8288;</code>. Note that topmost layer is always <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>fherla
</p>

<hr>
<h2 id='computeTSA'>Compute Threshold Sum Approach (TSA, lemons, yellow flags, 'Nieten')</h2><span id='topic+computeTSA'></span><span id='topic+computeTSA.snowprofileSet'></span><span id='topic+computeTSA.snowprofile'></span>

<h3>Description</h3>

<p>This routine computes the traditional lemons (German 'Nieten') based on absolute thresholds. Since the thresholds are
defined in Monti (2014) with different thresholds for manual versus observed profiles, this routine switches between the appropriate
thresholds based on the <code style="white-space: pre;">&#8288;$type&#8288;</code> field of the input profile. While <code>manual</code> and <code>whiteboard</code> profiles get one set of thresholds,
<code>modeled</code>, <code>vstation</code>, and <code>aggregate</code> type profiles get another set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeTSA(x, target = c("interface", "layer"))

## S3 method for class 'snowprofileSet'
computeTSA(x, target = c("interface", "layer"))

## S3 method for class 'snowprofile'
computeTSA(x, target = c("interface", "layer"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeTSA_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+snowprofile">snowprofile</a> or <a href="#topic+snowprofileSet">snowprofileSet</a></p>
</td></tr>
<tr><td><code id="computeTSA_+3A_target">target</code></td>
<td>
<p>Do you want to compute the index for the layers or for the layer interfaces? defaults to both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New layer properties <code>tsa</code>/<code>tsa_interface</code> describing the threshold sums are added to the profile layers. The TSA sums up to 6 indicators,
whereas &gt;= 5 indicators indicate structurally unstable layers/interfaces.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>computeTSA(snowprofileSet)</code>: for <a href="#topic+snowprofileSet">snowprofileSet</a>s
</p>
</li>
<li> <p><code>computeTSA(snowprofile)</code>: for <a href="#topic+snowprofile">snowprofile</a>s
</p>
</li></ul>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>References</h3>

<p>Schweizer, J., &amp; Jamieson, J. B. (2007). A threshold sum approach to stability evaluation of manual snow profiles.
Cold Regions Science and Technology, 47(1–2), 50–59. https://doi.org/10.1016/j.coldregions.2006.08.011
</p>
<p>Monti, F., Schweizer, J., &amp; Fierz, C. (2014). Hardness estimation and weak layer detection in simulated snow stratigraphy.
Cold Regions Science and Technology, 103, 82–90. https://doi.org/10.1016/j.coldregions.2014.03.009
</p>


<h3>See Also</h3>

<p><a href="#topic+computeRTA">computeRTA</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## apply function to snowprofileSet
profileset &lt;- computeTSA(SPgroup)

## apply function to snowprofile and plot output
sp &lt;- computeTSA(SPpairs$B_modeled1)
plot(sp, TempProfile = FALSE, main = "TSA")
lines(sp$layers$tsa/6*5,
      sp$layers$height - 0.5*sp$layers$thickness, type = "b", xlim = c(0, 5))
lines(sp$layers$tsa_interface/6*5, sp$layers$height, type = "b", xlim = c(0, 5), col = "red")
abline(h = sp$layers$height, lty = "dotted", col = "grey")
abline(v = 5/6*5, lty = "dashed")
</code></pre>

<hr>
<h2 id='deriveDatetag'>Derive datetag from deposition dates in simulated profiles</h2><span id='topic+deriveDatetag'></span><span id='topic+deriveDatetag.snowprofileSet'></span><span id='topic+deriveDatetag.snowprofile'></span><span id='topic+deriveDatetag.snowprofileLayers'></span>

<h3>Description</h3>

<p>This routine derives the datetags of simulated snow profile layers from deposition dates. Datetags usually are deposition dates
for crust layers, and burial dates for other weak layers (e.g., SH, FC). If no datetags can be derived, a datetag column of NAs will
nevertheless be added to the snowprofile layers. The routine also adds a <code>bdate</code> column for burial dates that are calculated along the way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deriveDatetag(x, adjust_bdates = TRUE, ...)

## S3 method for class 'snowprofileSet'
deriveDatetag(x, adjust_bdates = TRUE, ...)

## S3 method for class 'snowprofile'
deriveDatetag(x, adjust_bdates = TRUE, ...)

## S3 method for class 'snowprofileLayers'
deriveDatetag(x, adjust_bdates = TRUE, checkMonotonicity = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriveDatetag_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+snowprofileSet">snowprofileSet</a>, <a href="#topic+snowprofile">snowprofile</a> or <a href="#topic+snowprofileLayers">snowprofileLayers</a> object</p>
</td></tr>
<tr><td><code id="deriveDatetag_+3A_adjust_bdates">adjust_bdates</code></td>
<td>
<p>boolean switch to compute bdates similar to human interpretation. see Details.</p>
</td></tr>
<tr><td><code id="deriveDatetag_+3A_...">...</code></td>
<td>
<p>passed on to subsequent methods</p>
</td></tr>
<tr><td><code id="deriveDatetag_+3A_checkmonotonicity">checkMonotonicity</code></td>
<td>
<p>check ascending order of layers. This acts as a check for whether multiple layers objects are stacked, which is not allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bdate</code>s are computed by taking the <code>ddate</code> of the overlying layer. For snowpack simulations with thin layer
resolution, this approach yields very similar <code>ddate</code>s and <code>bdate</code>s for most layers, since most layers form and
instantly get buried by another layer of the same storm. To make <code>bdate</code>s more similar to human interpretation,
<code>bdate</code>s can be adjusted, so that (similar) layers with the same <code>ddate</code> (i.e., same storm) inherit the same <code>bdate</code>
(similar means: identical gtype &amp; hardness).
</p>


<h3>Value</h3>

<p>The input object will be returned with the columns <code>datetag</code> and <code>bdate</code> added to the profile layers
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>deriveDatetag(snowprofileSet)</code>: for <a href="#topic+snowprofileSet">snowprofileSet</a>s
</p>
</li>
<li> <p><code>deriveDatetag(snowprofile)</code>: for <a href="#topic+snowprofile">snowprofile</a>s
</p>
</li>
<li> <p><code>deriveDatetag(snowprofileLayers)</code>: for <a href="#topic+snowprofileLayers">snowprofileLayers</a>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This is not the most meaningful example, but it nicely illustrates the routine:
print(SPpairs$A_manual)

(A_addedDatetags &lt;- deriveDatetag(SPpairs$A_manual))

</code></pre>

<hr>
<h2 id='export.snowprofileCsv'>Export or write a snowprofile object to a CSV table</h2><span id='topic+export.snowprofileCsv'></span>

<h3>Description</h3>

<p>Export or write a snowprofile object to a CSV table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.snowprofileCsv(
  profile,
  filename = stop("filename must be provided"),
  sep = ",",
  export.all = "Layers",
  variables = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export.snowprofileCsv_+3A_profile">profile</code></td>
<td>
<p><a href="#topic+snowprofile">snowprofile</a> object</p>
</td></tr>
<tr><td><code id="export.snowprofileCsv_+3A_filename">filename</code></td>
<td>
<p>character string, e.g. 'path/to/file.csv'</p>
</td></tr>
<tr><td><code id="export.snowprofileCsv_+3A_sep">sep</code></td>
<td>
<p>csv column separator as character string</p>
</td></tr>
<tr><td><code id="export.snowprofileCsv_+3A_export.all">export.all</code></td>
<td>
<p>one of <code>TRUE</code>, <code>FALSE</code>, <code>'Layers'</code>: export all variables of the snowprofile object to the csv table?
</p>
<p>If <code>'Layers'</code>, then all layer variables of the snowprofile will be exported.</p>
</td></tr>
<tr><td><code id="export.snowprofileCsv_+3A_variables">variables</code></td>
<td>
<p>A tag-value list of the format, e.g. height = 'height_top', to specify column names of specific variables,
to customize column order, and/or to include specific profile meta data if <code>export.all == 'Layers'</code>
(e.g. easily include the meta data <code>station_id</code>). Note that the
tags of the tag-value list need to correspond to elements of the snowprofile object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that existing files with the specified filename will be <strong>overwritten</strong> without warning!
</p>


<h3>Value</h3>

<p>Writes csv file to disk, no return value in R
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofileCsv">snowprofileCsv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## export an entire snowprofile object:

export.snowprofileCsv(SPpairs$A_manual, filename = file.path(tempdir(), 'file.csv'),
                      export.all = TRUE)


## export only the layer properties of a snowprofile object,
#  and change the column order with few column names:
#  All layer variables will be exported, but the three ones provided in 'variables'
#  will be the first three columns of the csv table, and their column names will be changed
#  accordingly.

export.snowprofileCsv(SPpairs$A_manual, filename = file.path(tempdir(), 'file.csv'),
                      export.all = 'Layers',
                      variables = list(height = 'height_top', hardness = 'hardness',
                                       gtype = 'gt1'))


## export all layer properties of a snowprofile object plus the station ID:

export.snowprofileCsv(SPpairs$A_manual, filename = file.path(tempdir(), 'file.csv'),
                      export.all = 'Layers', variables = list(station_id = 'station_id'))

## check the content of the exported csv file:
csv_content &lt;- read.csv(file.path(tempdir(), 'file.csv'))
head(csv_content)

## or re-import the csv file as snowprofile object:
csv_snowprofile &lt;- snowprofileCsv(file.path(tempdir(), 'file.csv'))
print(csv_snowprofile)

</code></pre>

<hr>
<h2 id='findPWL'>Find layers of interest (e.g. PWLs) in snowprofile(Layers)</h2><span id='topic+findPWL'></span><span id='topic+labelPWL'></span>

<h3>Description</h3>

<p>Find one or more layers of interest, such as persistent weak layers (PWL) in a snowprofile or snowprofileLayers object based on combinations of grain type, datetag, grain size,
and stability indices (TSA/ RTA/ critical crack length/ p_unstable) of the layer. The routine can also be used for searching for crusts (or any other grain types).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPWL(
  x,
  pwl_gtype = c("SH", "DH"),
  pwl_date = NA,
  date_range = c(-5, 0),
  date_range_earlier = as.difftime(date_range[1], units = "days"),
  date_range_later = as.difftime(date_range[2], units = "days"),
  bdate_range = c(-1, 1),
  bdate_range_earlier = as.difftime(bdate_range[1], units = "days"),
  bdate_range_later = as.difftime(bdate_range[2], units = "days"),
  threshold_gtype = pwl_gtype,
  threshold_gsize = NA,
  threshold_TSA = NA,
  threshold_RTA = NA,
  threshold_SK38 = NA,
  threshold_RC = NA,
  threshold_PU = NA
)

labelPWL(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPWL_+3A_x">x</code></td>
<td>
<p><a href="#topic+snowprofile">snowprofile</a> or <a href="#topic+snowprofileLayers">snowprofileLayers</a> object</p>
</td></tr>
<tr><td><code id="findPWL_+3A_pwl_gtype">pwl_gtype</code></td>
<td>
<p>a vector of grain types of interest</p>
</td></tr>
<tr><td><code id="findPWL_+3A_pwl_date">pwl_date</code></td>
<td>
<p>a date of interest given as character ('YYYY-MM-DD') or as POSIXct; set to <code>NA</code> to ignore dates. If given as POSIXct, time comparison between layer dates and pwl_date
will consider the times of day (i.e., hours, etc). Otherwise only consider year/month/days.</p>
</td></tr>
<tr><td><code id="findPWL_+3A_date_range">date_range</code></td>
<td>
<p>a numeric array of length 2 that defines a date search window around <code>pwl_date</code>. This date range is applied to <code>ddate</code>s (deposition dates),
or if these are not available to <code>datetag</code>s.</p>
</td></tr>
<tr><td><code id="findPWL_+3A_date_range_earlier">date_range_earlier</code></td>
<td>
<p>a <a href="base.html#topic+difftime">difftime</a> object of <code>date_range[1]</code> (must be negative).</p>
</td></tr>
<tr><td><code id="findPWL_+3A_date_range_later">date_range_later</code></td>
<td>
<p>a <a href="base.html#topic+difftime">difftime</a> object of <code>date_range[2]</code> (must be positive).</p>
</td></tr>
<tr><td><code id="findPWL_+3A_bdate_range">bdate_range</code></td>
<td>
<p>a numeric array of length 2 that defines a date search window around <code>pwl_date</code>. This date range is applied to <code>bdate</code>s (burial dates)</p>
</td></tr>
<tr><td><code id="findPWL_+3A_bdate_range_earlier">bdate_range_earlier</code></td>
<td>
<p>a <a href="base.html#topic+difftime">difftime</a> object of <code>bdate_range[1]</code> (must be negative).</p>
</td></tr>
<tr><td><code id="findPWL_+3A_bdate_range_later">bdate_range_later</code></td>
<td>
<p>a <a href="base.html#topic+difftime">difftime</a> object of <code>bdate_range[2]</code> (must be positive).</p>
</td></tr>
<tr><td><code id="findPWL_+3A_threshold_gtype">threshold_gtype</code></td>
<td>
<p>specific grain types that are only deemed a PWL if they pass one or multiple thresholds (see next parameters)</p>
</td></tr>
<tr><td><code id="findPWL_+3A_threshold_gsize">threshold_gsize</code></td>
<td>
<p>a threshold grain size in order to deem <code>threshold_gtype</code> a PWL; set to <code>NA</code> to ignore grain sizes.</p>
</td></tr>
<tr><td><code id="findPWL_+3A_threshold_tsa">threshold_TSA</code></td>
<td>
<p>a threshold TSA value (see <a href="#topic+computeTSA">computeTSA</a>) in order to deem <code>threshold_gtype</code> a PWL; set to <code>NA</code> to ignore TSA.</p>
</td></tr>
<tr><td><code id="findPWL_+3A_threshold_rta">threshold_RTA</code></td>
<td>
<p>a threshold RTA value (see <a href="#topic+computeRTA">computeRTA</a>) in order to deem <code>threshold_gtype</code> a PWL; set to <code>NA</code> to ignore RTA.</p>
</td></tr>
<tr><td><code id="findPWL_+3A_threshold_sk38">threshold_SK38</code></td>
<td>
<p>a threshold SK38 in order to deem <code>threshold_gtype</code> a PWL; set to <code>NA</code> to ignore this threshold.</p>
</td></tr>
<tr><td><code id="findPWL_+3A_threshold_rc">threshold_RC</code></td>
<td>
<p>a threshold critical crack length in order to deem <code>threshold_gtype</code> a PWL; set to <code>NA</code> to ignore this threshold.</p>
</td></tr>
<tr><td><code id="findPWL_+3A_threshold_pu">threshold_PU</code></td>
<td>
<p>a threshold value for p_unstable in order to deem <code>threshold_gtype</code> a PWL; set to <code>NA</code> to ignore this threshold.</p>
</td></tr>
<tr><td><code id="findPWL_+3A_...">...</code></td>
<td>
<p>passed on to <a href="#topic+findPWL">findPWL</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case date considerations are included in your search, either one of the date window conditions needs to be satisfied to return a given layer:
</p>

<ul>
<li> <p><code>ddate</code> or <code>datetag</code> within <code>date_range</code>, <strong>or</strong>
</p>
</li>
<li> <p><code>bdate</code> within <code>bdate_range</code>
</p>
</li></ul>

<p>If the input object contains deposition dates (<code>ddate</code>, mostly in simulated profiles),
but no <code>bdates</code>, they are automatically computed by <a href="#topic+deriveDatetag">deriveDatetag</a>;
otherwise the date window is applied to the <code>datetag</code> (mostly for manual profiles).
</p>
<p>If you apply thresholds to your search, only layers are returned that satisfy <em>at least one</em> of the provided thresholds.
</p>
<p>The <code>labelPWL</code> wrapper function is primarily used by <code>sarp.snowprofile.alignment::averageSP</code>.
</p>


<h3>Value</h3>

<p><code>findPWL</code>: An index vector of PWLs that match the desired requirements
</p>
<p><code>labelPWL</code>: The input object with an extra boolean column appended to the layer object, called <code style="white-space: pre;">&#8288;$layerOfInterest&#8288;</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>findPWL()</code>: Find layers of interest (e.g., PWLs) in <code>snowprofile</code> or <code>snowprofileLayers</code>
</p>
</li>
<li> <p><code>labelPWL()</code>: Label layers of interest (e.g., weak layers) in <code>snowprofile</code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get index vector:
findPWL(SPpairs$A_modeled)

## get layers subset:
SPpairs$A_manual$layers[findPWL(SPpairs$A_manual), ]
SPpairs$A_manual$layers[findPWL(SPpairs$A_manual, threshold_gsize = 2.2,
                        threshold_gtype = c("FC", "FCxr")), ]
## all (SH, DH), and (FC, FCxr) &gt;= 1 mm grain size:
SPpairs$A_modeled$layers[findPWL(SPpairs$A_modeled, pwl_gtype = c("SH", "DH", "FC", "FCxr"),
                                 threshold_gsize = 1, threshold_gtype = c("FC", "FCxr")), ]
## use TSA threshold:
SPpairs$A_modeled &lt;- computeTSA(SPpairs$A_modeled)
SPpairs$A_modeled$layers[findPWL(SPpairs$A_modeled, pwl_gtype = c("SH", "DH", "FC", "FCxr"),
                                 threshold_TSA = 4, threshold_gtype = c("FC", "FCxr")), ]

## searching for a specific pwl_date:
## let's construct one layer and an array of pwl_dates
tl &lt;- snowprofileLayers(height = 1, gtype = "SH",
                        ddate = as.POSIXct("2020-12-15"),
                        bdate = as.POSIXct("2020-12-20"))
pwl_dates &lt;- paste0("2020-12-", seq(14, 22))
## which pwl_date will 'find' that layer?
sapply(pwl_dates, function(dt) length(findPWL(tl, pwl_date = dt)) &gt; 0)
## same example, but with bdate being NA:
tl &lt;- snowprofileLayers(height = 1, gtype = "SH",
                        ddate = as.POSIXct("2020-12-15"),
                        bdate = as.POSIXct(NA), dropNAs = FALSE)
sapply(pwl_dates, function(dt) length(findPWL(tl, pwl_date = dt)) &gt; 0)

## pwl_date example with proper profile:
sp &lt;- deriveDatetag(SPpairs$A_manual)
sp$layers
pwl_dates &lt;- paste0("2019-02-", seq(18, 26))
names(pwl_dates) &lt;- pwl_dates
## which pwl_date will 'find' the two layers with (b)date labels?
list(pwl_date = lapply(pwl_dates, function(dt) {
  sp$layers[findPWL(sp, pwl_gtype = c("SH", "FC"), pwl_date = dt),
            c("height", "gtype", "ddate", "bdate")]
}))

## same example as above, but including TSA threshold:
sp &lt;- computeTSA(sp)
## the SH layer has TSA 5, the FC layer has TSA 4:
list(pwl_date = lapply(pwl_dates, function(dt) {
  sp$layers[findPWL(sp, pwl_gtype = c("SH", "FC"), pwl_date = dt, threshold_TSA = 5),
            c("height", "gtype", "ddate", "bdate")]
}))
## --&gt; no more FC layer in output since its TSA value is below the threshold!

## can also be used to search for crusts:
SPpairs$A_manual$layers[findPWL(SPpairs$A_manual, pwl_gtype = "MFcr"), ]

</code></pre>

<hr>
<h2 id='format_snowprofileLayers'>Format snowprofileLayers</h2><span id='topic+format_snowprofileLayers'></span>

<h3>Description</h3>

<p>Calculate missing data.frame columns based on the given ones, if possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_snowprofileLayers(
  obj,
  target = "all",
  hs = NA,
  maxObservedDepth = NA,
  validate = TRUE,
  dropNAs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_snowprofileLayers_+3A_obj">obj</code></td>
<td>
<p>snowprofileLayers object</p>
</td></tr>
<tr><td><code id="format_snowprofileLayers_+3A_target">target</code></td>
<td>
<p>string, indicating which fields are auto-filled ('all', 'height', 'depth', 'thickness', 'none')</p>
</td></tr>
<tr><td><code id="format_snowprofileLayers_+3A_hs">hs</code></td>
<td>
<p>total snow height (cm) if not deductible from given fields</p>
</td></tr>
<tr><td><code id="format_snowprofileLayers_+3A_maxobserveddepth">maxObservedDepth</code></td>
<td>
<p>the observed depth of the profile from the snow surface downwards.
Will only be used, if no <code>height</code> or <code>thickness</code> exist in <code>obj</code>, or if <code>hs</code> is not given.</p>
</td></tr>
<tr><td><code id="format_snowprofileLayers_+3A_validate">validate</code></td>
<td>
<p>Validate <code>obj</code> with <a href="#topic+validate_snowprofileLayers">validate_snowprofileLayers</a>?</p>
</td></tr>
<tr><td><code id="format_snowprofileLayers_+3A_dropnas">dropNAs</code></td>
<td>
<p>Do you want to drop all columns consisting of NAs only?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>copy of obj with auto-filled columns
</p>

<hr>
<h2 id='getColoursDensity'>Gets colours for plotting snow density values</h2><span id='topic+getColoursDensity'></span>

<h3>Description</h3>

<p>Gets colours for plotting snow density values in snowprofiles. Colours are consistent with niViz at https://niviz.org
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColoursDensity(Values, Resolution = 101, Verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColoursDensity_+3A_values">Values</code></td>
<td>
<p>Density values (kg/m3)</p>
</td></tr>
<tr><td><code id="getColoursDensity_+3A_resolution">Resolution</code></td>
<td>
<p>Resolution of colour scale. Default is 100.</p>
</td></tr>
<tr><td><code id="getColoursDensity_+3A_verbose">Verbose</code></td>
<td>
<p>Switch for writing out value and html colour tuplets for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with HTML colour codes
</p>


<h3>Author(s)</h3>

<p>phaegeli
</p>


<h3>See Also</h3>

<p><a href="#topic+getColoursGrainSize">getColoursGrainSize</a>, <a href="#topic+getColoursGrainType">getColoursGrainType</a>, <a href="#topic+getColoursHardness">getColoursHardness</a>, <a href="#topic+getColoursLWC">getColoursLWC</a>, <a href="#topic+getColoursSnowTemp">getColoursSnowTemp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Density &lt;- seq(0,700, by=10)
plot(x = rep(1,length(Density)), y = Density, col = getColoursDensity(Density), pch = 19, cex = 3)

</code></pre>

<hr>
<h2 id='getColoursGrainSize'>Gets colours for plotting grain size values</h2><span id='topic+getColoursGrainSize'></span>

<h3>Description</h3>

<p>Gets colours for plotting grain size values in snowprofiles. Colours are consistent with niViz at https://niviz.org
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColoursGrainSize(Values, Resolution = 101, Verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColoursGrainSize_+3A_values">Values</code></td>
<td>
<p>Liquid water content values</p>
</td></tr>
<tr><td><code id="getColoursGrainSize_+3A_resolution">Resolution</code></td>
<td>
<p>Resolution of colour scale. Default is 100.</p>
</td></tr>
<tr><td><code id="getColoursGrainSize_+3A_verbose">Verbose</code></td>
<td>
<p>Switch for writing out value and html colour tuplets for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with HTML colour codes
</p>


<h3>Author(s)</h3>

<p>phaegeli
</p>


<h3>See Also</h3>

<p><a href="#topic+getColoursDensity">getColoursDensity</a>, <a href="#topic+getColoursGrainType">getColoursGrainType</a>, <a href="#topic+getColoursHardness">getColoursHardness</a>, <a href="#topic+getColoursLWC">getColoursLWC</a>, <a href="#topic+getColoursSnowTemp">getColoursSnowTemp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
GrainSize &lt;- seq(0,6, by=0.1)
plot(x = rep(1,length(GrainSize)), y = GrainSize,
     col = getColoursGrainSize(GrainSize), pch = 19, cex = 3)

</code></pre>

<hr>
<h2 id='getColoursGrainType'>Gets colours for plotting snow grain types</h2><span id='topic+getColoursGrainType'></span>

<h3>Description</h3>

<p>Grain colours are defined in the <code>grainDict</code> data.frame and the definitions can be changed with <code>setColoursGrainType</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColoursGrainType(Grains, grainDict. = grainDict)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColoursGrainType_+3A_grains">Grains</code></td>
<td>
<p>grain type (character or list of characters)</p>
</td></tr>
<tr><td><code id="getColoursGrainType_+3A_graindict.">grainDict.</code></td>
<td>
<p>lookup table to use. Note, the easiest and best way to do this is via <code>setColoursGrainType</code>. This input variable here
is only a hack to change the grainDict explicitly when calling <code>plot.snowprofile</code> via <code>Col</code>, and beforehand computing
<code>Col = Col &lt;- sapply(Profile$layers$gtype, function(x) getColoursGrainType(x, grainDict = setColoursGrainType('sarp-reduced')))</code>;
This is only necessary in specific environments (e.g. a shiny app)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with HTML colour codes
</p>


<h3>Author(s)</h3>

<p>phaegeli, shorton, fherla
</p>


<h3>See Also</h3>

<p><a href="#topic+setColoursGrainType">setColoursGrainType</a>, <a href="#topic+getColoursDensity">getColoursDensity</a>, <a href="#topic+getColoursGrainSize">getColoursGrainSize</a>, <a href="#topic+getColoursHardness">getColoursHardness</a>, <a href="#topic+getColoursLWC">getColoursLWC</a>, <a href="#topic+getColoursSnowTemp">getColoursSnowTemp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Grains &lt;- c('PP', 'DF', 'RG', 'FC', 'FCxr', 'DH', 'SH', 'MF', 'MFcr', 'IF')
Colours &lt;- getColoursGrainType(Grains)
Colours

plot(1:length(Grains), col = Colours, pch = 20, cex = 3)
text(1:length(Grains), 1:length(Grains), Grains, pos = 1)

</code></pre>

<hr>
<h2 id='getColoursHardness'>Gets colours for plotting snow hardness values</h2><span id='topic+getColoursHardness'></span>

<h3>Description</h3>

<p>Gets colours for plotting snow hardness values in snowprofiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColoursHardness(Values, Resolution = 101, Verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColoursHardness_+3A_values">Values</code></td>
<td>
<p>Hardness values</p>
</td></tr>
<tr><td><code id="getColoursHardness_+3A_resolution">Resolution</code></td>
<td>
<p>Resolution of colour scale. Default is 100.</p>
</td></tr>
<tr><td><code id="getColoursHardness_+3A_verbose">Verbose</code></td>
<td>
<p>Switch for writing out value and html colour tuplets for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with HTML colour codes
</p>


<h3>Author(s)</h3>

<p>phaegeli
</p>


<h3>See Also</h3>

<p><a href="#topic+getColoursDensity">getColoursDensity</a>, <a href="#topic+getColoursGrainSize">getColoursGrainSize</a>, <a href="#topic+getColoursGrainType">getColoursGrainType</a>, <a href="#topic+getColoursLWC">getColoursLWC</a>, <a href="#topic+getColoursSnowTemp">getColoursSnowTemp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Hardness &lt;- c(1:5)
plot(x = rep(1,length(Hardness)), y = Hardness,
     col = getColoursHardness(Hardness), pch = 19,cex = 3)

</code></pre>

<hr>
<h2 id='getColoursLWC'>Gets colours for plotting LWC values</h2><span id='topic+getColoursLWC'></span>

<h3>Description</h3>

<p>Gets colours for plotting LWC values in snowprofiles. Colours are consistent with niViz at https://niviz.org
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColoursLWC(Values, Resolution = 101, Verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColoursLWC_+3A_values">Values</code></td>
<td>
<p>Liquid water content values</p>
</td></tr>
<tr><td><code id="getColoursLWC_+3A_resolution">Resolution</code></td>
<td>
<p>Resolution of colour scale. Default is 100.</p>
</td></tr>
<tr><td><code id="getColoursLWC_+3A_verbose">Verbose</code></td>
<td>
<p>Switch for writing out value and html colour tuplets for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with HTML colour codes
</p>


<h3>Author(s)</h3>

<p>phaegeli
</p>


<h3>See Also</h3>

<p><a href="#topic+getColoursDensity">getColoursDensity</a>, <a href="#topic+getColoursGrainSize">getColoursGrainSize</a>, <a href="#topic+getColoursGrainType">getColoursGrainType</a>, <a href="#topic+getColoursHardness">getColoursHardness</a>, <a href="#topic+getColoursSnowTemp">getColoursSnowTemp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
LWC &lt;- seq(0,6, by = 0.1)
plot(x = rep(1,length(LWC)), y = LWC, col = getColoursLWC(LWC), pch = 19, cex = 3)

</code></pre>

<hr>
<h2 id='getColoursPercentage'>Gets colours for plotting the snow layer property 'percentage'</h2><span id='topic+getColoursPercentage'></span>

<h3>Description</h3>

<p>Gets colours for plotting the snow layer property 'percentage', as used for example for distributions from 0&ndash;1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColoursPercentage(
  Values,
  Resolution = 101,
  Min = 0,
  Max = 1,
  ClrRamp = c("Blues", "Greys", "Greys_transparent")[1]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColoursPercentage_+3A_values">Values</code></td>
<td>
<p>of the 'percentage' variable</p>
</td></tr>
<tr><td><code id="getColoursPercentage_+3A_resolution">Resolution</code></td>
<td>
<p>Resolution of colour scale. Default is 100.</p>
</td></tr>
<tr><td><code id="getColoursPercentage_+3A_min">Min</code></td>
<td>
<p>Minimum values of the percentage (for colouring)</p>
</td></tr>
<tr><td><code id="getColoursPercentage_+3A_max">Max</code></td>
<td>
<p>Maximum &ndash;=&ndash;</p>
</td></tr>
<tr><td><code id="getColoursPercentage_+3A_clrramp">ClrRamp</code></td>
<td>
<p>Three different colourmaps can be chosen from: &quot;Blues&quot;, &quot;Greys&quot;, &quot;Greys_transparent&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with HTML colour codes
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>See Also</h3>

<p><a href="#topic+getColoursGrainSize">getColoursGrainSize</a>, <a href="#topic+getColoursGrainType">getColoursGrainType</a>, <a href="#topic+getColoursHardness">getColoursHardness</a>, <a href="#topic+getColoursLWC">getColoursLWC</a>, <a href="#topic+getColoursSnowTemp">getColoursSnowTemp</a>, <a href="#topic+getColoursStability">getColoursStability</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
prct &lt;- seq(0, 1, by=0.1)
plot(x = rep(1,length(prct)), y = prct,
     col = getColoursPercentage(prct), pch = 19, cex = 3)

plot(x = rep(1,length(prct)), y = prct,
     col = getColoursPercentage(prct, ClrRamp = "Greys"), pch = 19, cex = 3)


</code></pre>

<hr>
<h2 id='getColoursSnowTemp'>Gets colours for plotting snow temperature values</h2><span id='topic+getColoursSnowTemp'></span>

<h3>Description</h3>

<p>Gets colours for plotting snow temperature values in snowprofiles. Colours are consistent with niViz at https://niviz.org
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColoursSnowTemp(Values, Resolution = 101, Verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColoursSnowTemp_+3A_values">Values</code></td>
<td>
<p>Snow temperature values</p>
</td></tr>
<tr><td><code id="getColoursSnowTemp_+3A_resolution">Resolution</code></td>
<td>
<p>Resolution of colour scale. Default is 100.</p>
</td></tr>
<tr><td><code id="getColoursSnowTemp_+3A_verbose">Verbose</code></td>
<td>
<p>Switch for writing out value and html colour tuplets for debugging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with HTML colour codes
</p>


<h3>Author(s)</h3>

<p>phaegeli
</p>


<h3>See Also</h3>

<p><a href="#topic+getColoursDensity">getColoursDensity</a>, <a href="#topic+getColoursGrainSize">getColoursGrainSize</a>, <a href="#topic+getColoursGrainType">getColoursGrainType</a>, <a href="#topic+getColoursHardness">getColoursHardness</a>, <a href="#topic+getColoursLWC">getColoursLWC</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SnowTemp &lt;- c(-25:0)
plot(x = rep(1,length(SnowTemp)), y = SnowTemp,
     col = getColoursSnowTemp(SnowTemp), pch = 19,cex = 3)

</code></pre>

<hr>
<h2 id='getColoursStability'>Gets colours for plotting snow stability indices</h2><span id='topic+getColoursStability'></span>

<h3>Description</h3>

<p>Gets colours for plotting snow stability indices in snowprofiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getColoursStability(
  Values,
  StabilityIndexThreshold = 0.77,
  StabilityIndexRange = c(0, 1),
  invers = FALSE,
  Resolution = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getColoursStability_+3A_values">Values</code></td>
<td>
<p>Stability index values</p>
</td></tr>
<tr><td><code id="getColoursStability_+3A_stabilityindexthreshold">StabilityIndexThreshold</code></td>
<td>
<p>A scalar threshold that defines the transition from medium to poor stability.
The color scheme will be adjusted so that this threshold becomes apparent from the colours.</p>
</td></tr>
<tr><td><code id="getColoursStability_+3A_stabilityindexrange">StabilityIndexRange</code></td>
<td>
<p>The range the index spans, e.g. for TSA <code style="white-space: pre;">&#8288;[0, 6]&#8288;</code>, for RTA and p_unstable <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>, for critical crack length <code style="white-space: pre;">&#8288;[0, 3]&#8288;</code>, etc..</p>
</td></tr>
<tr><td><code id="getColoursStability_+3A_invers">invers</code></td>
<td>
<p>Indices like TSA/ RTA/ p_unstable increase the poorer layer stability gets. For indices with revers behaviour (e.g.,, critical crack length) switch this flag to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="getColoursStability_+3A_resolution">Resolution</code></td>
<td>
<p>Resolution of colour scale. Default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with HTML colour codes
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>See Also</h3>

<p><a href="#topic+getColoursGrainSize">getColoursGrainSize</a>, <a href="#topic+getColoursGrainType">getColoursGrainType</a>, <a href="#topic+getColoursHardness">getColoursHardness</a>, <a href="#topic+getColoursLWC">getColoursLWC</a>, <a href="#topic+getColoursSnowTemp">getColoursSnowTemp</a>, <a href="#topic+getColoursPercentage">getColoursPercentage</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p_unstable &lt;- seq(0, 1, by=0.1)
plot(x = rep(1,length(p_unstable)), y = p_unstable,
     col = getColoursStability(p_unstable), pch = 19, cex = 3)

critical_crack_length &lt;- c(seq(0.2, 0.8, by=0.1), 1.5, 2.5)
plot(x = rep(1,length(critical_crack_length)), y = critical_crack_length, pch = 19, cex = 3,
     col = getColoursStability(critical_crack_length, StabilityIndexThreshold = 0.4,
                               StabilityIndexRange = c(0, 3), invers = TRUE))

</code></pre>

<hr>
<h2 id='grainDict'>A data.frame storing the grain type colours</h2><span id='topic+grainDict'></span>

<h3>Description</h3>

<p>The colours can be changed by calling the function <a href="#topic+setColoursGrainType">setColoursGrainType</a>, see examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grainDict
</code></pre>


<h3>Format</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
print(grainDict)

## change colours for subsequent plots:
grainDict &lt;- setColoursGrainType('sarp-reduced')

</code></pre>

<hr>
<h2 id='hasUnobservedBasalLayer'>Check whether a profile is observed down to ground or not</h2><span id='topic+hasUnobservedBasalLayer'></span>

<h3>Description</h3>

<p>Check whether a profile is observed down to ground or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasUnobservedBasalLayer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasUnobservedBasalLayer_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+snowprofile">snowprofile</a>, or <a href="#topic+snowprofileLayers">snowprofileLayers</a> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean TRUE/FALSE
</p>

<hr>
<h2 id='importRDefaultPackages'>Import R_DEFAULT_PACKAGES</h2><span id='topic+importRDefaultPackages'></span>

<h3>Description</h3>

<p>Import R_DEFAULT_PACKAGES
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importRDefaultPackages()
</code></pre>

<hr>
<h2 id='insertUnobservedBasalLayer'>Insert a special layer at the bottom to indicate a snow profile that's unobserved from a specific point down to the ground
internal function, not exported. used in snowprofileLayers</h2><span id='topic+insertUnobservedBasalLayer'></span>

<h3>Description</h3>

<p>Insert a special layer at the bottom to indicate a snow profile that's unobserved from a specific point down to the ground
internal function, not exported. used in snowprofileLayers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insertUnobservedBasalLayer(object, basal_offset, setBasalThicknessNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insertUnobservedBasalLayer_+3A_object">object</code></td>
<td>
<p><a href="#topic+snowprofileLayers">snowprofileLayers</a> object</p>
</td></tr>
<tr><td><code id="insertUnobservedBasalLayer_+3A_basal_offset">basal_offset</code></td>
<td>
<p>a positive numeric scalar indicating the thickness of the basal unobserved layer(s)</p>
</td></tr>
<tr><td><code id="insertUnobservedBasalLayer_+3A_setbasalthicknessna">setBasalThicknessNA</code></td>
<td>
<p>boolean TRUE/FALSE indicating whether the thickness of the inserted layer should be <code>basal_offset</code> or <code>NA</code>.
Setting the thickness to NA corresponds to setting a flag that the depth of the profile (i.e., the unobserved basal layers) is unknown.
This often happens in manual profiles which only observe the uppermost meter (or so) of the snowpack</p>
</td></tr>
</table>


<h3>Value</h3>

<p>same object with basal layer inserted as individual row in the data.frame
</p>


<h3>Author(s)</h3>

<p>fherla
</p>

<hr>
<h2 id='is.snowprofile'>Check class snowprofile</h2><span id='topic+is.snowprofile'></span>

<h3>Description</h3>

<p>Check if object is of class <a href="#topic+snowprofile">snowprofile</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.snowprofile(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.snowprofile_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='is.snowprofileInstabilitySigns'>Check class snowprofileInstabilitySigns</h2><span id='topic+is.snowprofileInstabilitySigns'></span>

<h3>Description</h3>

<p>Check if object is of class <a href="#topic+snowprofileInstabilitySigns">snowprofileInstabilitySigns</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.snowprofileInstabilitySigns(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.snowprofileInstabilitySigns_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='is.snowprofileLayers'>Check class snowprofileLayers</h2><span id='topic+is.snowprofileLayers'></span>

<h3>Description</h3>

<p>Check if object is of class snowprofileLayers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.snowprofileLayers(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.snowprofileLayers_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='is.snowprofileSet'>Check class snowprofileSet</h2><span id='topic+is.snowprofileSet'></span>

<h3>Description</h3>

<p>Check if object is of class <a href="#topic+snowprofileSet">snowprofileSet</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.snowprofileSet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.snowprofileSet_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='is.snowprofileTests'>Check class snowprofileTests</h2><span id='topic+is.snowprofileTests'></span>

<h3>Description</h3>

<p>Check if object is of class <a href="#topic+snowprofileTests">snowprofileTests</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.snowprofileTests(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.snowprofileTests_+3A_x">x</code></td>
<td>
<p>object to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean
</p>

<hr>
<h2 id='new_snowprofile'>Low-level constructor function for a snowprofile object</h2><span id='topic+new_snowprofile'></span>

<h3>Description</h3>

<p>Low-cost, efficient constructor function to be used by users who know what they're doing. If that's not you,
use the high-level constructor <a href="#topic+snowprofile">snowprofile</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_snowprofile(
  station = character(),
  station_id = character(),
  datetime = as.POSIXct(NA),
  latlon = as.double(c(NA, NA)),
  elev = double(),
  angle = double(),
  aspect = double(),
  hs = double(),
  maxObservedDepth = double(),
  type = character(),
  band = character(),
  zone = character(),
  comment = character(),
  hn24 = double(),
  hn72 = double(),
  ski_pen = double(),
  layers = snowprofileLayers(),
  tests = snowprofileTests(),
  instabilitySigns = snowprofileInstabilitySigns()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_snowprofile_+3A_station">station</code></td>
<td>
<p>character string</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_station_id">station_id</code></td>
<td>
<p>character string</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_datetime">datetime</code></td>
<td>
<p>date and time as class POSIXct in most meaningful timezone (timezone can be converted very easily:
e.g. <code>print(profile$datetime, tz = 'EST')</code>.</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_latlon">latlon</code></td>
<td>
<p>2-element vector latitude (first), longitude (second)</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_elev">elev</code></td>
<td>
<p>profile elevation (m)</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_angle">angle</code></td>
<td>
<p>slope angle (degree)</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_aspect">aspect</code></td>
<td>
<p>slope aspect (degree)</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_hs">hs</code></td>
<td>
<p>total snow height (cm); if not provided, the field will be derived from the profile layers.</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_maxobserveddepth">maxObservedDepth</code></td>
<td>
<p>equivalent to <code>hs</code> for full profiles that go down to the ground. for test profiles that only
observe the upper part of the snowpack this value refers to the maximum depth of the profile observation.</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_type">type</code></td>
<td>
<p>character string, must be either 'manual', 'modeled', 'vstation', 'aggregate', or 'whiteboard'</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_band">band</code></td>
<td>
<p>character string describing elevation band as ALP, TL, BTL (alpine, treeline, below treeline)</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_zone">zone</code></td>
<td>
<p>character string describing the zone or region of the profile location (e.g., BURNABY_MTN)</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_comment">comment</code></td>
<td>
<p>character string with any text comments</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_hn24">hn24</code></td>
<td>
<p>height of new snow within 24 h</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_hn72">hn72</code></td>
<td>
<p>height of new snow within 72 h</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_ski_pen">ski_pen</code></td>
<td>
<p>skier penetration depth (m)</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_layers">layers</code></td>
<td>
<p><a href="#topic+snowprofileLayers">snowprofileLayers</a> object</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_tests">tests</code></td>
<td>
<p><a href="#topic+snowprofileTests">snowprofileTests</a> object</p>
</td></tr>
<tr><td><code id="new_snowprofile_+3A_instabilitysigns">instabilitySigns</code></td>
<td>
<p><a href="#topic+snowprofileInstabilitySigns">snowprofileInstabilitySigns</a> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>snowprofile object
</p>

<hr>
<h2 id='numberOfPWLsPerVerticalLevel'>Count number of PWLs per vertical level</h2><span id='topic+numberOfPWLsPerVerticalLevel'></span>

<h3>Description</h3>

<p>This is a wrapper function to bin several weak layers (or crusts) into vertical levels.
The layers to be binned can be controlled with a provided index vector for full customization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numberOfPWLsPerVerticalLevel(x, pwl_idx, depth_breaks = c(0, 30, 80, 150, Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numberOfPWLsPerVerticalLevel_+3A_x">x</code></td>
<td>
<p><a href="#topic+snowprofile">snowprofile</a> or <a href="#topic+snowprofileLayers">snowprofileLayers</a> object</p>
</td></tr>
<tr><td><code id="numberOfPWLsPerVerticalLevel_+3A_pwl_idx">pwl_idx</code></td>
<td>
<p>an index vector that corresponds to the layers of interest. Tip: this can also be a call to <a href="#topic+findPWL">findPWL</a>, see examples.</p>
</td></tr>
<tr><td><code id="numberOfPWLsPerVerticalLevel_+3A_depth_breaks">depth_breaks</code></td>
<td>
<p>a vector of break points referring to absolute depth values. <code>Inf</code> is a placeholder for max depth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a <code>table</code> object
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SH_idx &lt;- findPWL(SPpairs$C_day1, pwl_gtype = "SH")
numberOfPWLsPerVerticalLevel(SPpairs$C_day1, SH_idx)

numberOfPWLsPerVerticalLevel(SPpairs$C_day2, findPWL(SPpairs$C_day2))

</code></pre>

<hr>
<h2 id='plot.snowprofile'>Plot hardness profile</h2><span id='topic+plot.snowprofile'></span>

<h3>Description</h3>

<p>Plot hardness profile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snowprofile'
plot(
  x,
  TempProfile = TRUE,
  xlimTemp = NULL,
  Col = "auto",
  TopDown = "auto",
  axes = TRUE,
  xlab = "",
  emphasizeLayers = FALSE,
  emphasis = "95",
  failureLayers = FALSE,
  failureLayers.cex = 1,
  failureLayers.col = "red",
  nYTicks = 4,
  ymax = max(c(x$maxObservedDepth, x$hs), na.rm = TRUE),
  alignWithBottomUpPlot = FALSE,
  highlightUnobservedBasalLayers = TRUE,
  label.datetags = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.snowprofile_+3A_x">x</code></td>
<td>
<p><a href="#topic+snowprofile">snowprofile</a> object</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_tempprofile">TempProfile</code></td>
<td>
<p>draw unscaled temperature profile (default = TRUE)? Temperature data needs to be included in the
snowprofile object either under <code>x$layers$temperature</code>, or in a separate <code>x$temperatureProfile</code> data.frame providing
a vertical grid independent from the snow layers.</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_xlimtemp">xlimTemp</code></td>
<td>
<p>the x limits in degrees Celsius for the temperature profile (if left empty it scales to the range of temperature values)</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_col">Col</code></td>
<td>
<p>vector of colours corresponding to the grain types in the profile (defaults to a lookup table)</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_topdown">TopDown</code></td>
<td>
<p>Option to plot by depth instead of height with zero depth on top of plot (default = FALSE)</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_axes">axes</code></td>
<td>
<p>Should axes be printed?</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, defaults to an empty string</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_emphasizelayers">emphasizeLayers</code></td>
<td>
<p>index OR character vector (grain types) of layers to be emphasized (i.e. all other layers become slightly transparent)</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_emphasis">emphasis</code></td>
<td>
<p>2 digit quoted number between <code>'01'</code>-<code>'99'</code> to control the degree of emphasis; the higher the stronger</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_failurelayers">failureLayers</code></td>
<td>
<p>height vector of failure layers that will be indicated with an arrow</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_failurelayers.cex">failureLayers.cex</code></td>
<td>
<p>factor to shrink or enlarge the arrow</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_failurelayers.col">failureLayers.col</code></td>
<td>
<p>color of arrow, can also be a vector of same length as <code>failureLayers</code> to color different arrows differently</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_nyticks">nYTicks</code></td>
<td>
<p>number of tick marks at yaxis</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_ymax">ymax</code></td>
<td>
<p>the maximum ylim value</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_alignwithbottomupplot">alignWithBottomUpPlot</code></td>
<td>
<p>useful when aligning the yaxis grids of bottom up profileSet plots and top down hardness plots.</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_highlightunobservedbasallayers">highlightUnobservedBasalLayers</code></td>
<td>
<p>draw sine wave at lowest observed layer to highlight unobserved layers below</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_label.datetags">label.datetags</code></td>
<td>
<p>label the datetags of the snowprofile layers? (Won't produce a pretty plot, but give you some more information for analysis)</p>
</td></tr>
<tr><td><code id="plot.snowprofile_+3A_...">...</code></td>
<td>
<p>other parameters to barplot</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+plot.snowprofileSet">plot.snowprofileSet</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(SPpairs$A_manual)
plot(SPpairs$A_manual, Col = 'black')
plot(SPpairs$A_manual, emphasizeLayers = c(5, 11),
     failureLayers = SPpairs$A_manual$layers$height[5], failureLayers.cex = 1.5)
plot(SPpairs$A_manual, emphasizeLayers = 'SH')
plot(SPpairs$A_manual, TopDown = TRUE)
plot(SPpairs$A_modeled, TempProfile = TRUE, xlimTemp = c(-30,10))

# highlight unobserved basal layers:
plot(snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                                               hardness = c(2, 3, 1),
                                               gtype = c('FC', NA, 'PP'),
                                               hs = 70,
                                               maxObservedDepth = 50)), TopDown = TRUE, ymax = 80)

</code></pre>

<hr>
<h2 id='plot.snowprofileSet'>Plot a single layer property in multiple profiles side-by-side</h2><span id='topic+plot.snowprofileSet'></span>

<h3>Description</h3>

<p>A flexible function to plot multiple snowprofiles either in a timeseries or various types of groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snowprofileSet'
plot(
  x,
  SortMethod = c("time", "unsorted", "hs", "elev", "presorted"),
  ColParam = c("gtype", "hardness", "density", "temp", "gsize", "ssi", "p_unstable",
    "crit_cut_length", "rta", "percentage"),
  TopDown = FALSE,
  DateStart = NA,
  DateEnd = NA,
  Timeseries_labels = c("weekly", "monthly", NA),
  ylim = NULL,
  OutlineLyrs = FALSE,
  emphasizeLayers = NULL,
  colAlpha = NA,
  colEmphasis = NA,
  OutlineProfile = NULL,
  HorizGrid = TRUE,
  VerticalGrid = TRUE,
  yaxis = TRUE,
  main = NA,
  ylab = NA,
  xlab = NA,
  box = TRUE,
  xticklabels = FALSE,
  xtick.las = 2,
  yPadding = 10,
  xPadding = 0.5,
  hardnessResidual = 1,
  hardnessScale = 1,
  hardnessOffset = -0.5,
  k = NULL,
  offset = as.Date(NA),
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.snowprofileSet_+3A_x">x</code></td>
<td>
<p>An object of class <a href="#topic+snowprofileSet">snowprofileSet</a></p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_sortmethod">SortMethod</code></td>
<td>
<p>How to arrange profiles along the x-axis. Options include timeseries (default = 'time'), in existing order of Profiles list ('unsorted'), sorted by HS ('hs'), or elevation ('elev')</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_colparam">ColParam</code></td>
<td>
<p>What parameter to show with colour. So far the following types are available: &quot;gtype&quot;, &quot;hardness&quot;, &quot;density&quot;, &quot;temp&quot;, &quot;gsize&quot;, &quot;ssi&quot;, &quot;p_unstable&quot;, &quot;crit_cut_length&quot;, &quot;rta&quot;, &quot;percentage&quot;.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_topdown">TopDown</code></td>
<td>
<p>Option to plot by depth instead of height with zero depth on top of plot (default = FALSE)</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_datestart">DateStart</code></td>
<td>
<p>Start date for timeseries plots (<code>SortMethod = 'time'</code>). If not provided, the function takes the date range from Profiles (default = NA).</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_dateend">DateEnd</code></td>
<td>
<p>End date for timeseries plots (<code>SortMethod = 'time'</code>). If not provided, the function takes the date range from Profiles (default = NA).</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_timeseries_labels">Timeseries_labels</code></td>
<td>
<p>Label Saturdays &quot;weekly&quot;, &quot;monthly&quot;, or <code>NA</code></p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_ylim">ylim</code></td>
<td>
<p>Vertical range of plot</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_outlinelyrs">OutlineLyrs</code></td>
<td>
<p>Switch for outlining layers (default = FALSE)</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_emphasizelayers">emphasizeLayers</code></td>
<td>
<p>emphasize layers with different transparency than others, or a different color altogether? then set this argument to <code>TRUE</code> if you want to emphasize all
labeled layers of interest (aka weak layers), or provide a named list with arguments to a function call to <a href="#topic+findPWL">findPWL</a> to define which layers to emphasize.
Set either <code>colAlpha</code> or <code>colEmphasis</code> to make the emphasis apparent.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_colalpha">colAlpha</code></td>
<td>
<p>the transparency setting for all layers (except the ones to be emphasized if you want to emphasize any). This can be useful for example
if you want to overplot the grain type sequences with another variable, e.g. a percentage from a distribution.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_colemphasis">colEmphasis</code></td>
<td>
<p>the color of the layers to be emphasized (only if you want a different color than defined by <code>ColParam</code>)</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_outlineprofile">OutlineProfile</code></td>
<td>
<p>vector of profile indices that will be outlined to highlight them</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_horizgrid">HorizGrid</code></td>
<td>
<p>Draw horizontal grid at layer heights (default = TRUE)</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_verticalgrid">VerticalGrid</code></td>
<td>
<p>Draw vertical grid at xticks (default = TRUE)</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_yaxis">yaxis</code></td>
<td>
<p>draw a y-axis? (either <code>FALSE</code>, <code>TRUE</code> draws yaxis left, <code>"right"</code> draws yaxis on the right plot side)
<em>Note</em> that in case of <code>"right"</code> you need to adjust <code>par(mar = ...)</code>, disable <code>ylab</code> and manually draw an xlab with <code>mtext</code>.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_main">main</code></td>
<td>
<p>Main title</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label; disable ylab by providing an empty string (i.e., ylab = &rdquo;)</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label; disable xlab by providing an empty string (i.e., xlab = &rdquo;)</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_box">box</code></td>
<td>
<p>Draw a box around the plot (default = TRUE)</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_xticklabels">xticklabels</code></td>
<td>
<p>Label the profiles with their &quot;names&quot;, &quot;originalIndices&quot; (prior to sorting), &quot;dates&quot;, or a custom character array</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_xtick.las">xtick.las</code></td>
<td>
<p>Orientation of labels if xticklabels is specified.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_ypadding">yPadding</code></td>
<td>
<p>Padding between ylim and limits of data, default = 10.
Note that R will still put padding by default. If you want to prohibit that entirely, specify <code>xaxs ='i'</code>, or <code>yaxs = 'i'</code>.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_xpadding">xPadding</code></td>
<td>
<p>Padding between xlim and limits of data, default = 0.5.
Note that R will still put padding by default. If you want to prohibit that entirely, specify <code>xaxs = 'i'</code>, or <code>yaxs = 'i'</code>. For xPadding, you can provide either a scalar, or
a length 2 numeric for left and right hand side, respectively.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_hardnessresidual">hardnessResidual</code></td>
<td>
<p>Value within <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code> to control the minimum horizontal space of each layer that will be colored
irrespective of the layer's hardness. A value of <code>1</code> corresponds to no hardness being shown.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_hardnessscale">hardnessScale</code></td>
<td>
<p>A scaling factor that exaggerates the hardness profile to subsequent cells on the x-axis. Useful
for time series of sparse profile observations. Note that this scaling factor is unused when <code>hardnessScale = 1</code> and that
it gets more influential the smaller <code>hardnessScale</code> gets. Also note, that a <code>hardnessScale &gt; 1</code> can lead to profiles overlapping.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_hardnessoffset">hardnessOffset</code></td>
<td>
<p>offsets the profile location on the x-axis</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_k">k</code></td>
<td>
<p>a sorting vector if <code>SortMethod = "presorted"</code>.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_offset">offset</code></td>
<td>
<p>Provide a Date or POSIXct offset if you want to offset the vertical snow height/depth axis so that the offset date aligns with snow depth/height 0.</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_add">add</code></td>
<td>
<p>add the plot to an existing plot, or create new plot?</p>
</td></tr>
<tr><td><code id="plot.snowprofileSet_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to plot()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine allows you to plot coloured sequences only, or to include hardness profile information as well. See parameter
<code>hardnessResidual</code> and the examples for more details.
To change the font size of labels etc, use <code>par()</code> with the parameters <code>cex.lab</code>, <code>cex.axis</code>, etc.
</p>


<h3>Author(s)</h3>

<p>shorton, fherla, phaegeli
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.snowprofile">plot.snowprofile</a>, <a href="#topic+SPgroup">SPgroup</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Standard profile timeline (e.g. https://niviz.org)
plot(SPtimeline)

## Group of profiles with same timestamp
plot(SPgroup, SortMethod = 'unsorted')  # sorted in same order as list
plot(SPgroup, SortMethod = 'hs') # sorted by snow height
plot(SPgroup, SortMethod = 'elev') # sorted by elevation

## Colour layers by other properties
plot(SPtimeline, ColParam = 'density')

## Align layers by depth instead of height
plot(SPtimeline, TopDown = TRUE)

## Timelines with specific date ranges
plot(SPtimeline, DateEnd = '2017-12-17')
plot(SPtimeline, DateStart = '2017-12-15', DateEnd = '2017-12-17')

## Show hardness profile, too:
plot(SPtimeline, hardnessResidual = 0.5)

## Additional examples of plot dimensions and labelling
## Label the indices of the profiles in the list:
plot(SPgroup, SortMethod = 'elev', xticklabels = "originalIndices")
##  ... and with minimized axis limits and their station ID names:
plot(SPgroup, SortMethod = 'elev', xticklabels = sapply(SPgroup, function(x) x$station_id),
       yPadding = 0, xPadding = 0, xaxs = 'i', yaxs = 'i')
##  sorted by depth, and without box:
plot(SPgroup, SortMethod = 'hs', TopDown = TRUE, box = FALSE)

## Apply a date offset to investigate which layers formed around that day of interest:
pwl_exists &lt;- sapply(SPgroup, function(sp)
  {length(findPWL(sp, pwl_date = "2019-01-21", pwl_gtype = c("SH", "DH"),
                  date_range_earlier = as.difftime(2, unit = "days"))) &gt; 0})
k &lt;- order(pwl_exists, decreasing = TRUE)
plot(SPgroup, SortMethod = 'presorted', k = k, xticklabels = "originalIndices",
     offset = as.Date("2019-01-21"), xlab = "&lt;-- Jan 21 PWL exists | does not exist --&gt;")
abline(v = max(which(pwl_exists[k]))+0.5, lty = "dashed")

## Emphasize specific layers
## (i) all labeled layers of interest:
SPgroup &lt;- snowprofileSet(lapply(SPgroup, labelPWL))  # label layers with default settings
plot(SPgroup, SortMethod = "hs", emphasizeLayers = TRUE, colAlpha = 0.3)
## (ii) specific individual layers:
plot(SPgroup, SortMethod = "hs",
     emphasizeLayers = list(pwl_gtype = c("SH", "DH"), pwl_date = "2019-01-21"),
     colAlpha = 0.3, colEmphasis = "black")


</code></pre>

<hr>
<h2 id='print.snowprofile'>Print snowprofile object</h2><span id='topic+print.snowprofile'></span>

<h3>Description</h3>

<p>Print snowprofile object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snowprofile'
print(x, pretty = TRUE, nLayers = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.snowprofile_+3A_x">x</code></td>
<td>
<p><a href="#topic+snowprofile">snowprofile</a> object</p>
</td></tr>
<tr><td><code id="print.snowprofile_+3A_pretty">pretty</code></td>
<td>
<p>pretty print the object (data.frame-like instead of list-like)</p>
</td></tr>
<tr><td><code id="print.snowprofile_+3A_nlayers">nLayers</code></td>
<td>
<p>only print the first few layers (cf., <a href="utils.html#topic+head">head</a>)</p>
</td></tr>
<tr><td><code id="print.snowprofile_+3A_...">...</code></td>
<td>
<p>passed to <a href="base.html#topic+print.default">print.default</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object gets printed to console
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## pretty print
SPpairs$A_manual
## or alternatively:
print(SPpairs$A_manual)
## reduce number of layers printed:
print(SPpairs$A_manual, nLayers = 6)

## print profile non-pretty (i.e., like the data is stored):
print(SPpairs$A_manual, pretty = FALSE)

</code></pre>

<hr>
<h2 id='rbind.snowprofile'>Convert snowprofile into data.frame with columns for metadata</h2><span id='topic+rbind.snowprofile'></span>

<h3>Description</h3>

<p>Convert snowprofile object into data.frame with a row for each layer and additional columns with metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snowprofile'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.snowprofile_+3A_...">...</code></td>
<td>
<p>Object of class <a href="#topic+snowprofile">snowprofile</a></p>
</td></tr>
<tr><td><code id="rbind.snowprofile_+3A_deparse.level">deparse.level</code></td>
<td>
<p>Argument for generic rbind method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Metadata columns are calculated with <a href="#topic+summary.snowprofile">summary.snowprofile</a>
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.snowprofile">summary.snowprofile</a>, <a href="#topic+rbind.snowprofileSet">rbind.snowprofileSet</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Profile &lt;- SPgroup[[1]]
ProfileTable &lt;- rbind(Profile)
head(ProfileTable)

</code></pre>

<hr>
<h2 id='rbind.snowprofileSet'>Concatenate snowprofileSet into a large data.frame with a row for each layer</h2><span id='topic+rbind.snowprofileSet'></span>

<h3>Description</h3>

<p>A wrapper to apply <a href="#topic+rbind.snowprofile">rbind.snowprofile</a> to each profile in a <a href="#topic+snowprofileSet">snowprofileSet</a> then concatenate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snowprofileSet'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.snowprofileSet_+3A_...">...</code></td>
<td>
<p>Object of class <a href="#topic+snowprofileSet">snowprofileSet</a></p>
</td></tr>
<tr><td><code id="rbind.snowprofileSet_+3A_deparse.level">deparse.level</code></td>
<td>
<p>Argument for generic rbind method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a large data.frame with a row for each layer and additional columns with metadata (calculated with <a href="#topic+summary.snowprofile">summary.snowprofile</a>)
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.snowprofile">summary.snowprofile</a>, <a href="#topic+rbind.snowprofile">rbind.snowprofile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create rbind table
ProfileTable &lt;- rbind(SPgroup)
head(ProfileTable)

## Filter by layer properties
SHlayers &lt;- subset(ProfileTable, gtype == 'SH')
summary(SHlayers)
plot(elev ~ gsize, SHlayers)

</code></pre>

<hr>
<h2 id='readSmet'>Parse a SMET file</h2><span id='topic+readSmet'></span>

<h3>Description</h3>

<p>Read contents of a SMET file https://models.slf.ch/docserver/meteoio/SMET_specifications.pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSmet(Filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSmet_+3A_filename">Filename</code></td>
<td>
<p>Path to a smet file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing metadata and data
</p>


<h3>Author(s)</h3>

<p>shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+writeSmet">writeSmet</a>, <a href="#topic+snowprofileSno">snowprofileSno</a>, <a href="#topic+snowprofilePrf">snowprofilePrf</a>, <a href="#topic+snowprofilePro">snowprofilePro</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Path to example smet
Filename &lt;- system.file('extdata', 'example.smet', package = 'sarp.snowprofile')
Wx = readSmet(Filename)
str(Wx)

</code></pre>

<hr>
<h2 id='reformat_snowprofile'>Reformat a malformatted snowprofile object</h2><span id='topic+reformat_snowprofile'></span>

<h3>Description</h3>

<p>Reformat a malformatted snowprofile object. A malformatted object may use field names that deviate from our
suggested field names (e.g., <code>grain_type</code> instead of <code>gtype</code>), or it may use data types that are different than
what we suggest to use (e.g., <code>ddate</code> as type <code>Date</code> instead of <code>POSIXct</code>). Basically, if your snowprofile object
fails the test of <a href="#topic+validate_snowprofile">validate_snowprofile</a> due to the above reason this function should fix it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reformat_snowprofile(profile, currentFields = NULL, targetFields = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reformat_snowprofile_+3A_profile">profile</code></td>
<td>
<p><a href="#topic+snowprofile">snowprofile</a> object</p>
</td></tr>
<tr><td><code id="reformat_snowprofile_+3A_currentfields">currentFields</code></td>
<td>
<p>array of character strings specifying the current field names that you want to change</p>
</td></tr>
<tr><td><code id="reformat_snowprofile_+3A_targetfields">targetFields</code></td>
<td>
<p>array of same size than <code>currentFields</code> specifying the new field names</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## check the malformatted profile:
this_throws_error &lt;- TRUE
if (!this_throws_error) {
validate_snowprofile(SPmalformatted[[1]])
}
## i.e., we see that elev and ddate are of wrong data type,
## and a warning that grain_type is an unknown layer property.

## reformat field types, but not the field name:
betterProfile &lt;- reformat_snowprofile(SPmalformatted[[1]])
## i.e., no error is raised anymore, but only the grain_type warning

## so let's reformat also the field names:
optimalProfile &lt;- reformat_snowprofile(SPmalformatted[[1]], "grain_type", "gtype")



## reformat a list of profiles with the same configuration:
SPmalformatted_reformatted &lt;- lapply(SPmalformatted, reformat_snowprofile,
                                     currentFields = "grain_type", targetFields = "gtype")

## the malformatted profile set finally is correctly formatted:
lapply(SPmalformatted_reformatted, validate_snowprofile)


</code></pre>

<hr>
<h2 id='scanProfileDates'>Read profile dates from prf/pro file</h2><span id='topic+scanProfileDates'></span>

<h3>Description</h3>

<p>Before reading entire SNOWPACK output it can be helpful to  scan the profile timestamps first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scanProfileDates(Filename, tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scanProfileDates_+3A_filename">Filename</code></td>
<td>
<p>filename</p>
</td></tr>
<tr><td><code id="scanProfileDates_+3A_tz">tz</code></td>
<td>
<p>time zone (default = 'UTC')</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of as.POSIXct timestamps
</p>


<h3>Author(s)</h3>

<p>shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofilePrf">snowprofilePrf</a>, <a href="#topic+snowprofilePro">snowprofilePro</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Path to example prf file
Filename &lt;- system.file('extdata', 'example.prf', package = 'sarp.snowprofile')

## Scan dates in file
Dates &lt;- scanProfileDates(Filename)
print(Dates)

</code></pre>

<hr>
<h2 id='sd_sample_uncorrected'>fast uncorrected sample standard deviation
https://en.wikipedia.org/wiki/Standard_deviation#Rapid_calculation_methods</h2><span id='topic+sd_sample_uncorrected'></span>

<h3>Description</h3>

<p>fast uncorrected sample standard deviation
https://en.wikipedia.org/wiki/Standard_deviation#Rapid_calculation_methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_sample_uncorrected(x, xbar = mean(x), na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_sample_uncorrected_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sd_sample_uncorrected_+3A_xbar">xbar</code></td>
<td>
<p>arithmetic mean of x</p>
</td></tr>
<tr><td><code id="sd_sample_uncorrected_+3A_na.rm">na.rm</code></td>
<td>
<p>remove any NAs before computation of standard deviation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>uncorrected sample standard deviation (i.e., a numeric scalar)
</p>


<h3>Author(s)</h3>

<p>fherla
</p>

<hr>
<h2 id='setColoursGrainType'>Set colour scale for grain types</h2><span id='topic+setColoursGrainType'></span>

<h3>Description</h3>

<p>Currently, you can choose between 'iacs', 'iacs2', 'sarp', or 'sarp-reduced'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setColoursGrainType(ScaleName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setColoursGrainType_+3A_scalename">ScaleName</code></td>
<td>
<p>Name of graintype colour scale
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;iacs:&#8288;</code> scale defined by the <em>International Classification of Seasonal Snow on the Ground</em>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;iacs2:&#8288;</code> scale defined by the <em>International Classification of Seasonal Snow on the Ground</em> with a dark red colour for MFcr layers so that MF and MFcr layers can be better distinguished.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;sarp:&#8288;</code> hazard adjusted colours for grain types based on Horton et al. (2020)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;sarp-reduced:&#8288;</code> hazard adjusted colours for groups of grain types based on Horton et al. (2020)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing the new colour values stored in <code>grainDict</code>
</p>


<h3>References</h3>

<p>Horton, S., Nowak, S., and Haegeli, P.: Enhancing the operational value of snowpack models with visualization design principles,
Nat. Hazards Earth Syst. Sci., 20, 1557–1572, <a href="https://doi.org/10.5194/nhess-20-1557-2020">doi:10.5194/nhess-20-1557-2020</a>, 2020.
</p>


<h3>See Also</h3>

<p><a href="#topic+grainDict">grainDict</a>, <a href="#topic+getColoursGrainType">getColoursGrainType</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Current/default grain type colours
grainDict
plot(SPpairs$A_manual, main = 'Snow profile with default colours')

## Change to IACS colours
grainDict &lt;- setColoursGrainType('IACS')
grainDict
plot(SPpairs$A_manual, main = 'Snow profile with IACS colours')

## Change to IACS colours with adjusted MFcr (darkred)
grainDict &lt;- setColoursGrainType('IACS2')
grainDict
plot(SPpairs$A_manual, main = 'Snow profile with IACS colours and adjusted darkred MFcr')

## Change to SARP colours
grainDict &lt;- setColoursGrainType('SARP')
grainDict
plot(SPpairs$A_manual, main = 'Snow profile with SARP colours')

## Change to reduced SARP colours
grainDict &lt;- setColoursGrainType('SARP-reduced')
grainDict
plot(SPpairs$A_manual, main = 'Snow profile with a reduced set of SARP colours')

</code></pre>

<hr>
<h2 id='simplifyGtypes'>Simplify detailed grain types to parent classes</h2><span id='topic+simplifyGtypes'></span>

<h3>Description</h3>

<p>The IACS records grain types in major and minor classes, e.g. precipitation particles PP can be subclassified into
stellar dendrites PPsd. Some of these subclasses are not supported in this R package and so this function simplifies
the unsupported gran type subclasses into their supported main classes. If a given grain type cannot be simplified,
a NA value is returned for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplifyGtypes(gtypes, supported_gtypes = grainDict$gtype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplifyGtypes_+3A_gtypes">gtypes</code></td>
<td>
<p>an array of character grain types following IACS standards</p>
</td></tr>
<tr><td><code id="simplifyGtypes_+3A_supported_gtypes">supported_gtypes</code></td>
<td>
<p>an array of supported grain types that will determine the simplification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the modified input array
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create an array of gtypes
gtypes &lt;- c('FCxr', 'RGxf', 'PPsd', 'PP', 'IFrc', "KKfx")

## sinplify gtypes to supported_gtypes:
simplifyGtypes(gtypes)

</code></pre>

<hr>
<h2 id='snowprofile'>High-level constructor for a snowprofile object</h2><span id='topic+snowprofile'></span>

<h3>Description</h3>

<p>Conveniently create a snowprofile object. Calls low-level constructor (only available internally: <a href="#topic+new_snowprofile">new_snowprofile</a>), asserts correctness
through a snowprofile validator function (<a href="#topic+validate_snowprofile">validate_snowprofile</a>) and yields meaningful error messages. Use low-level constructor if you generate many (!) profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofile(
  station = as.character(NA),
  station_id = as.character(NA),
  datetime = as.POSIXct(NA),
  latlon = as.double(c(NA, NA)),
  elev = as.double(NA),
  angle = as.double(NA),
  aspect = as.double(NA),
  hs = as.double(NA),
  maxObservedDepth = as.double(NA),
  type = "manual",
  band = as.character(NA),
  zone = as.character(NA),
  comment = as.character(NA),
  hn24 = as.double(NA),
  hn72 = as.double(NA),
  ski_pen = as.double(NA),
  layers = snowprofileLayers(dropNAs = FALSE, validate = FALSE),
  tests = snowprofileTests(dropNAs = FALSE),
  instabilitySigns = snowprofileInstabilitySigns(dropNAs = FALSE),
  validate = TRUE,
  dropNAs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofile_+3A_station">station</code></td>
<td>
<p>character string</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_station_id">station_id</code></td>
<td>
<p>character string</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_datetime">datetime</code></td>
<td>
<p>date and time as class POSIXct in most meaningful timezone (timezone can be converted very easily:
e.g. <code>print(profile$datetime, tz = 'EST')</code>.</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_latlon">latlon</code></td>
<td>
<p>2-element vector latitude (first), longitude (second)</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_elev">elev</code></td>
<td>
<p>profile elevation (m)</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_angle">angle</code></td>
<td>
<p>slope angle (degree)</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_aspect">aspect</code></td>
<td>
<p>slope aspect (degree)</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_hs">hs</code></td>
<td>
<p>total snow height (cm); if not provided, the field will be derived from the profile layers.</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_maxobserveddepth">maxObservedDepth</code></td>
<td>
<p>equivalent to <code>hs</code> for full profiles that go down to the ground. for test profiles that only
observe the upper part of the snowpack this value refers to the maximum depth of the profile observation.</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_type">type</code></td>
<td>
<p>character string, must be either 'manual', 'modeled', 'vstation', 'aggregate', or 'whiteboard'</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_band">band</code></td>
<td>
<p>character string describing elevation band as ALP, TL, BTL (alpine, treeline, below treeline)</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_zone">zone</code></td>
<td>
<p>character string describing the zone or region of the profile location (e.g., BURNABY_MTN)</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_comment">comment</code></td>
<td>
<p>character string with any text comments</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_hn24">hn24</code></td>
<td>
<p>height of new snow within 24 h</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_hn72">hn72</code></td>
<td>
<p>height of new snow within 72 h</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_ski_pen">ski_pen</code></td>
<td>
<p>skier penetration depth (m)</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_layers">layers</code></td>
<td>
<p><a href="#topic+snowprofileLayers">snowprofileLayers</a> object</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_tests">tests</code></td>
<td>
<p><a href="#topic+snowprofileTests">snowprofileTests</a> object</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_instabilitysigns">instabilitySigns</code></td>
<td>
<p><a href="#topic+snowprofileInstabilitySigns">snowprofileInstabilitySigns</a> object</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_validate">validate</code></td>
<td>
<p>Validate the object with <a href="#topic+validate_snowprofile">validate_snowprofile</a>?</p>
</td></tr>
<tr><td><code id="snowprofile_+3A_dropnas">dropNAs</code></td>
<td>
<p>Do you want to drop non-mandatory <code>snowprofile</code> and <code>snowprofileLayers</code> fields that are <code>NA</code> only?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>snowprofile object
</p>


<h3>Author(s)</h3>

<p>shorton, fherla
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.snowprofile">summary.snowprofile</a>, <a href="#topic+plot.snowprofile">plot.snowprofile</a>, <a href="#topic+snowprofileLayers">snowprofileLayers</a>, <a href="#topic+snowprofileTests">snowprofileTests</a>, <a href="#topic+snowprofileInstabilitySigns">snowprofileInstabilitySigns</a>, <a href="#topic+SPpairs">SPpairs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Empty snowprofile:
snowprofile()

## Test profile:
testProfile &lt;- snowprofile(station = 'SARPstation', station_id = 'SARP007',
                           datetime = as.POSIXct('2019/04/01 10:00:00', tz = 'PDT'),
                           latlon = c(49.277223, -122.915084), aspect = 180,
                           layers = snowprofileLayers(height = c(10, 25, 50),
                                                      hardness = c(3, 2, 1),
                                                      gtype = c('FC', NA, 'PP')))
summary(testProfile)
plot(testProfile)

</code></pre>

<hr>
<h2 id='snowprofileCaaml'>Read a Caaml file into a snowprofile object</h2><span id='topic+snowprofileCaaml'></span>

<h3>Description</h3>

<p>Note, that this function only provides a starting point for loading caaml files into R. Currently, caaml files exported from
niviz.org, or snowpilot.org should be compatible with this routine. However, this routine only extracts some metadata
and some of the most important layer characteristics. While a temperature profile (that is independent from the layers)
is extracted, no other variables that can be written into a caaml file are currently being read (such as stability test results, etc).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofileCaaml(
  caamlFile,
  sourceType = NA,
  readStabilityTests = TRUE,
  validate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofileCaaml_+3A_caamlfile">caamlFile</code></td>
<td>
<p>'path/to/file.caaml'</p>
</td></tr>
<tr><td><code id="snowprofileCaaml_+3A_sourcetype">sourceType</code></td>
<td>
<p>choose 'manual', 'modeled', 'vstation', 'aggregate' or 'whiteboard'; while this routine has some
functionality built in to detect sourceTypes under certain circumstances, it needs to be provided in most cases.</p>
</td></tr>
<tr><td><code id="snowprofileCaaml_+3A_readstabilitytests">readStabilityTests</code></td>
<td>
<p>boolean (this is still beta version and can throw errors sometimes)</p>
</td></tr>
<tr><td><code id="snowprofileCaaml_+3A_validate">validate</code></td>
<td>
<p>Should the resulting snowprofile object be validated by <a href="#topic+validate_snowprofile">validate_snowprofile</a>?</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> There is still a bug related to non-numeric aspects (e.g., E instead of 90).
</p>
</li>
<li><p> The <a href="#topic+snowprofileCsv">snowprofileCsv</a> function provides a lot more flexibility to read in data, if you can choose the format of your
underlying data. Don't hesitate to reach out though if your caaml files throw errors and you need help! If you extend this
routine, please also reach out and let us know, so we can update this package with your code extensions.
</p>
</li></ul>



<h3>Value</h3>

<p>snowprofile object
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load example caaml file that ships with package:
caamlFile &lt;- system.file('extdata', 'example.caaml', package = 'sarp.snowprofile')

## read caaml file:
profile &lt;- snowprofileCaaml(caamlFile, sourceType = 'vstation')

## other file with slighlty different xml namespace, structure, etc (including stability test):
caamlFile2 &lt;- system.file('extdata', 'example2.caaml', package = 'sarp.snowprofile')
profile2 &lt;- snowprofileCaaml(caamlFile2, sourceType = 'manual')

</code></pre>

<hr>
<h2 id='snowprofileCsv'>Read csv file into a snowprofile object</h2><span id='topic+snowprofileCsv'></span>

<h3>Description</h3>

<p>Read csv file into a snowprofile object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofileCsv(
  path,
  header = TRUE,
  sep = ",",
  use.swisscode = FALSE,
  height = "height",
  gtype = "gtype",
  hardness = "hardness",
  ...,
  crust.val = 2,
  tz = "UTC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofileCsv_+3A_path">path</code></td>
<td>
<p>'path/to/file.csv'</p>
</td></tr>
<tr><td><code id="snowprofileCsv_+3A_header">header</code></td>
<td>
<p>is there a header line in the csv file to explain the column names? If not, specify a character vector of column names in the correct order.</p>
</td></tr>
<tr><td><code id="snowprofileCsv_+3A_sep">sep</code></td>
<td>
<p>csv column separator as string</p>
</td></tr>
<tr><td><code id="snowprofileCsv_+3A_use.swisscode">use.swisscode</code></td>
<td>
<p>boolean; are grain types given as (numeric) <code>swisscode</code> (<code>TRUE</code>) or as character strings (<code>FALSE</code>)? If <code>TRUE</code>, grain types can be given
as three-digit code (gt1|gt2|gt3), or as one-digit code specifying the primary grain type <em>if</em> another column is provided that specifies crusts.
See Details and Examples for more information.</p>
</td></tr>
<tr><td><code id="snowprofileCsv_+3A_height">height</code></td>
<td>
<p>character string referring to the csv column of the top layer interfaces</p>
</td></tr>
<tr><td><code id="snowprofileCsv_+3A_gtype">gtype</code></td>
<td>
<p>character string referring to the csv column of the grain types</p>
</td></tr>
<tr><td><code id="snowprofileCsv_+3A_hardness">hardness</code></td>
<td>
<p>character string referring to the csv column of the layer hardnesses</p>
</td></tr>
<tr><td><code id="snowprofileCsv_+3A_...">...</code></td>
<td>
<p>provide name-value pairs of additional csv columns (in the form <code>gsize = 'csv-GrainSize-ColName'</code>), e.g.
</p>

<ul>
<li><p> profile specific info: <code>station</code>, <code>station_id</code>, <code>datetime</code>, <code>latlon</code>, <code>elev</code>, <code>angle</code>, <code>aspect</code>, <code>type</code> (see <a href="#topic+snowprofile">snowprofile</a>)
</p>
</li>
<li><p> layer specific info: deposition date, grain size, ssi, ... (see <a href="#topic+snowprofileLayers">snowprofileLayers</a>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="snowprofileCsv_+3A_crust.val">crust.val</code></td>
<td>
<p>If a column 'crust' is provided, what value of 'crust' defines MFcr? Mostly, either 2 (default) or 1. See Details.</p>
</td></tr>
<tr><td><code id="snowprofileCsv_+3A_tz">tz</code></td>
<td>
<p>time zone (default = 'UTC')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum information required to construct a valid <a href="#topic+snowprofile">snowprofile</a> object is <code>height</code>, <code>gtype</code> and <code>hardness</code>. Currently, substituting <code>height</code> with
a depth vector is not supported.
</p>
<p>If profile specific information is provided in the csv table, it can only be included into the snowprofile object through the exact field names (see above).
However, layer specific information can be named arbitrarily (except for the three required fields).
</p>
<p>Regarding <strong>swisscode</strong>: The SNOWPACK documentation specifies that MFcr are encoded as (gt1|gt2|gt3) = (7|x|2), i.e. gt1 == 7 and gt3 == 2. This is
also how this routine handles the grain type encoding per default. However, some csv tables might be provided using swisscode encoding and
providing gt1, gt2, and gt3 as individual one-digit columns. In those cases, gt3 could be defined as a boolean (0 or 1), where gt1 == 7 and gt3 == 1
represent crusts, instead of the aforementioned standard definition of gt1 == 7 and gt3 == 2. To handle these cases, <code>crust.val</code> can be set to 1, instead
of its default <code>crust.val = 2</code>.
</p>


<h3>Value</h3>

<p>snowprofile object
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofileCsv_advanced">snowprofileCsv_advanced</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## imagine a csv table with a very straightforward format,
## similar to the following data.frame:
(DF &lt;- data.frame(height = c(50, 80, 100), gtype = c('FC', 'RG', 'PP'), hardness = c(1, 3, 2)))
## write DF to a temporary file:
write.csv(DF, file = file.path(tempdir(), 'file.csv'))

## read this file very easily by
profile &lt;- snowprofileCsv(file.path(tempdir(), 'file.csv'))
profile


## imagine a csv table that requires a bit more customization,
## similar to the following data.frame:
(DF &lt;- data.frame(ID = rep(1234, times = 3), layer_top = c(10.5, 15, 55.0), gt1 = c(5, 7, 2),
                  gs = c(5.0, 1.5, 1.0), crust = c(0, 1, 0), hardness = c('F', 'P', '4F+')))
write.csv(DF, file = file.path(tempdir(), 'file.csv'))

profile &lt;- snowprofileCsv(file.path(tempdir(), 'file.csv'), height = 'layer_top', gtype = 'gt1',
                          use.swisscode = TRUE, gsize = 'gs', crust.val = 1)
profile
## Note that the csv column 'crust', which specifies whether a MF layer is actually
#  a MFcr layer, is already named correctly (i.e., 'crust'). If it were named 'freeze-crust',
#  we would need to add to the function call: `crust = 'freeze-crust'`.
# Also note, that we need to provide `crust.val = 1`, since we're not using the standard definition
# of swisscode MFcr encoding (see Details).

## let's assume you want to read the csv file an customize some names, e.g. GrainSIZE:
profile &lt;- snowprofileCsv(file.path(tempdir(), 'file.csv'), height = 'layer_top', gtype = 'gt1',
                          use.swisscode = TRUE, GrainSIZE = 'gs')
profile

## Note that generally in a snowprofile object layer properties can be custom named,
#  meta information, e.g. station_id, can not! I.e. you need to use the prescribed names.


</code></pre>

<hr>
<h2 id='snowprofileCsv_advanced'>Read routine for advanced csv tables containing various snowprofile information</h2><span id='topic+snowprofileCsv_advanced'></span>

<h3>Description</h3>

<p>This routine reads blocks of snowprofile metadata, layers, tests, and stability signs. Columns contain different variables,
rows different observations. While metadata only contains one row, layers, tests, and signs consist of potentially multiple
rows. Within each block of information, mind the correct alignment of rows. Missing values (i.e., NA) need to be left blank
or called <code>NA</code>. See the examples below including the example file shipped with the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofileCsv_advanced(
  csvFile,
  meta = c("uid", "hs", "maxObservedDepth", "comment"),
  layers = c("depth", "height", "gtype", "hardness", "datetag", "gsize", "gtype_sec",
    "layer_comment"),
  tests = c("test", "result", "fract_char", "score", "test_depth", "test_comment"),
  instabilitySigns = c("instabilitySign_type", "instabilitySign_present",
    "instabilitySign_comment"),
  sep = ",",
  elev.units = "ft",
  tz = "UTC"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofileCsv_advanced_+3A_csvfile">csvFile</code></td>
<td>
<p>'path/to/file.csv'</p>
</td></tr>
<tr><td><code id="snowprofileCsv_advanced_+3A_meta">meta</code></td>
<td>
<p>column names of block metadata</p>
</td></tr>
<tr><td><code id="snowprofileCsv_advanced_+3A_layers">layers</code></td>
<td>
<p>column names of block <a href="#topic+snowprofileLayers">snowprofileLayers</a></p>
</td></tr>
<tr><td><code id="snowprofileCsv_advanced_+3A_tests">tests</code></td>
<td>
<p>column names of block <a href="#topic+snowprofileTests">snowprofileTests</a></p>
</td></tr>
<tr><td><code id="snowprofileCsv_advanced_+3A_instabilitysigns">instabilitySigns</code></td>
<td>
<p>column names of block <a href="#topic+snowprofileInstabilitySigns">snowprofileInstabilitySigns</a></p>
</td></tr>
<tr><td><code id="snowprofileCsv_advanced_+3A_sep">sep</code></td>
<td>
<p>csv column separator</p>
</td></tr>
<tr><td><code id="snowprofileCsv_advanced_+3A_elev.units">elev.units</code></td>
<td>
<p>if set to &quot;ft&quot;, the routine will convert to &quot;m&quot;. Set to &quot;m&quot; (or anything else) if it should be unchanged</p>
</td></tr>
<tr><td><code id="snowprofileCsv_advanced_+3A_tz">tz</code></td>
<td>
<p>time zone (default = 'UTC')</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load example csv file that ships with package:
csvFile &lt;- system.file('extdata', 'example_adv.csv', package = 'sarp.snowprofile')

profile &lt;- snowprofileCsv_advanced(csvFile, meta = c("uid", "hs", "maxObservedDepth", "comment",
                                                     "datetime", "zone", "station",
                                                     "station_id", "aspect", "elev", "angle"))

plot(profile)

</code></pre>

<hr>
<h2 id='snowprofileInstabilitySigns'>Constructor for a snowprofileInstabilitySigns object</h2><span id='topic+snowprofileInstabilitySigns'></span>

<h3>Description</h3>

<p>Create a snowprofileInstabilitySigns object. Instability signs can for example be whumpfs, cracking, natural avalanches, skier accidental release, ski cutting, etc.
For more information, see
Canadian Avalanche Association. (2016). Observation Guidelines and Recording Standards for Weather, Snowpack, and Avalanches. Revelstoke, BC, Canada.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofileInstabilitySigns(
  signsFrame = data.frame(type = as.character(NA), present = as.character(NA), comment =
    as.character(NA)),
  dropNAs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofileInstabilitySigns_+3A_signsframe">signsFrame</code></td>
<td>
<p>a data.frame listing snowpack stability signs. Rows correspond to individual observations of instability signs
and columns describe at least the fields <code>c("type", "present")</code>.
</p>

<ul>
<li><p> type: Sc, Sa, Na, whumpf, crack, ...
</p>
</li>
<li><p> present: Was the instability sign present (TRUE), not present (FALSE), or unknown (NA), for example
</p>

<ul>
<li><p> natural avalanches occurred (i.e., Na TRUE), did not occur (i.e., Na FALSE), no observations were carried out (i.e., Na NA)
</p>
</li>
<li><p> skiing the slope led to an avalanche (i.e., Sa TRUE)
</p>
</li>
<li><p> ski cutting did not release avalanche (i.e., Sc FALSE)
</p>
</li>
<li><p> etc
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="snowprofileInstabilitySigns_+3A_dropnas">dropNAs</code></td>
<td>
<p>Should empty, non-mandatory columns be dropped from the final snowprofileInstabilitySigns object?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This class might be a temporary solution to digitize instability signs observed in proximity to snowprofiles.
The information contained here, might be ported to a more general field observations class that is both independent from
snowprofile objects and that is more in line with existing field observation standards.
</p>


<h3>Value</h3>

<p>snowprofileInstabilitySigns object
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofile">snowprofile</a>, <a href="#topic+snowprofileLayers">snowprofileLayers</a>, <a href="#topic+snowprofileTests">snowprofileTests</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a data.frame with instability sign observations
(signsFrame &lt;- data.frame(type = c("Na", "whumpf", "cracking", "Sa"),
                         present = c(FALSE, TRUE, FALSE, FALSE)))

## create snowprofileInstabilitySigns object
instabilitySigns &lt;- snowprofileInstabilitySigns(signsFrame)

## create snowprofile object containing instability signs and check resulting object:
snowprofile(instabilitySigns = instabilitySigns)

</code></pre>

<hr>
<h2 id='snowprofileLayers'>Constructor for a snowprofileLayers object</h2><span id='topic+snowprofileLayers'></span>

<h3>Description</h3>

<p>Helper function to conveniently create a snowprofileLayers object, i.e. data.frame with mandatory column fields height (or depth) that provides vertical position of layers.
Layers need to be ordered in a sequential manner, and the routine will rearrange the layers so that the last row of the resulting dataframe corresponds to the snow surface.
If the vertical location of the layers is given by depth, make sure to provide <code>hs</code> if it's known. Otherwise, provide the field <code>maxObservedDepth</code> or layer thicknesses.
Providing only depth will issue a warning and set the corresponding lowest layer thickness to NA.
The resulting dataframe will contain all three fields <code>height</code>, <code>depth</code>, and <code>thickness</code>, which will be auto-filled if not provided (see <a href="#topic+format_snowprofileLayers">format_snowprofileLayers</a>).
If the columns that describe layer properties are not of equal
lengths, their values will be recycled (default data.frame mechanism). Instead of individual layer characteristics, a data.frame can be provided, which will be converted into a snowprofileLayers class.
The constructor asserts correctness of the layers object by a call to <a href="#topic+validate_snowprofileLayers">validate_snowprofileLayers</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofileLayers(
  height = as.double(NA),
  temperature = as.double(NA),
  density = as.double(NA),
  lwc = as.double(NA),
  gsize = as.double(NA),
  gsize_max = as.double(NA),
  gsize_avg = as.double(NA),
  gtype = as.factor(NA),
  gtype_sec = as.factor(NA),
  hardness = as.double(NA),
  ddate = as.POSIXct(NA),
  bdate = as.POSIXct(NA),
  datetag = as.Date(NA),
  ssi = as.double(NA),
  sphericity = as.double(NA),
  v_strain_rate = as.double(NA),
  crit_cut_length = as.double(NA),
  tsa = as.double(NA),
  tsa_interface = as.double(NA),
  rta = as.double(NA),
  rta_interface = as.double(NA),
  layerOfInterest = as.logical(NA),
  comment = as.character(NA),
  ...,
  hs = as.double(NA),
  maxObservedDepth = as.double(NA),
  layerFrame = NA,
  validate = TRUE,
  dropNAs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofileLayers_+3A_height">height</code></td>
<td>
<p>height vector (cm) referring to the top layer interface. Instead of <code>height</code>, <code>depth</code> can also be given and should be accompanied by
an array specifying the <code>thickness</code> of the layers, or alternatively, the total snow depth <code>hs</code> and/or the maximum observed depth <code>maxObservedDepth</code>
should be provided. Note, that also the <code>depth</code> refers to the top layer interface. <strong>See examples!</strong></p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_temperature">temperature</code></td>
<td>
<p>snow temperature (deg C)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_density">density</code></td>
<td>
<p>layer density (kg/m3)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_lwc">lwc</code></td>
<td>
<p>liquid water content (%)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_gsize">gsize</code></td>
<td>
<p>grain size (mm)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_gsize_max">gsize_max</code></td>
<td>
<p>maximum grain size (mm)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_gsize_avg">gsize_avg</code></td>
<td>
<p>average grain size (mm)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_gtype">gtype</code></td>
<td>
<p>grain type (character or factor)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_gtype_sec">gtype_sec</code></td>
<td>
<p>secondary grain type (character or factor)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_hardness">hardness</code></td>
<td>
<p>numeric hand hardness (use <a href="#topic+char2numHHI">char2numHHI</a> to convert from character hardness)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_ddate">ddate</code></td>
<td>
<p>deposition date of layer (POSIXct format). WARNING: if you provide character format, the time zone of your computer system will be assumed.</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_bdate">bdate</code></td>
<td>
<p>burial date of layer (POSIXct format). WARNING: if you provide character format, the time zone of your computer system will be assumed.</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_datetag">datetag</code></td>
<td>
<p>of layer (i.e., usually corresponds to <code>ddate</code> for 'MFcr', and to <code>bdate</code> for all other grain types.)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_ssi">ssi</code></td>
<td>
<p>snow stability index (numeric)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_sphericity">sphericity</code></td>
<td>
<p>between 0 and 1</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_v_strain_rate">v_strain_rate</code></td>
<td>
<p>viscous deformation rate (s^-1)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_crit_cut_length">crit_cut_length</code></td>
<td>
<p>critical crack length (m)</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_tsa">tsa</code></td>
<td>
<p>threshold sum approach for structural instability (also called lemons); valid for the layer, i.e., the weakest interface adjacent to the layer. see <a href="#topic+computeTSA">computeTSA</a>.</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_tsa_interface">tsa_interface</code></td>
<td>
<p>same as tsa, but valid for top interface of corresponding layer</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_rta">rta</code></td>
<td>
<p>relative threshold sum approach (following Monti et al 2013, ISSW paper); valid for the layer, i.e., the weakest interface adjacent to the layer. see <a href="#topic+computeRTA">computeRTA</a>.</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_rta_interface">rta_interface</code></td>
<td>
<p>same as rta, but valid for top interface of corresponding layer</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_layerofinterest">layerOfInterest</code></td>
<td>
<p>a boolean column to label specific layers of interest, e.g. weak layers. see <a href="#topic+labelPWL">labelPWL</a>.</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_comment">comment</code></td>
<td>
<p>character string</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_...">...</code></td>
<td>
<p>columns to include in the layers object. Note, that they need to correspond to the according height/depth array.
e.g. hardness (can use character hardness or numeric hardness via <a href="#topic+char2numHHI">char2numHHI</a>), ddate (class POSIX), bdate (class Date) gtype (character or factor), density, temperature, gsize, lwc, gsize_max, gtype_sec, ssi, depth, thickness</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_hs">hs</code></td>
<td>
<p>total snow height (cm), if not deductible from <code>height</code> vector. Particularly important when only a depth grid is provided!</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_maxobserveddepth">maxObservedDepth</code></td>
<td>
<p>the observed depth of the profile from the snow surface downwards. Will only be used, if
no <code>height</code>, <code>thickness</code>, or <code>hs</code> is given.</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_layerframe">layerFrame</code></td>
<td>
<p>a data.frame that's converted to a snowprofileLayers class if no other layer characteristics are provided</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_validate">validate</code></td>
<td>
<p>Validate <code>obj</code> with <a href="#topic+validate_snowprofileLayers">validate_snowprofileLayers</a>?</p>
</td></tr>
<tr><td><code id="snowprofileLayers_+3A_dropnas">dropNAs</code></td>
<td>
<p>Do you want to drop all columns consisting of NAs only?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>snowprofileLayers object as data.frame with strings as factors
</p>


<h3>Author(s)</h3>

<p>shorton, fherla
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofile">snowprofile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Empty layers object:
snowprofileLayers()


## simple layers example that recycles the hardness 1F+: with warning issued!
## Try what happens if you provide ddate as character array without a timezone.
snowprofileLayers(height = c(10, 25, 50),
                  hardness = char2numHHI('1F+'),
                  gtype = c('FC', NA, 'PP'),
                  ddate = as.POSIXct(c(NA, NA, "2020-02-15 10:45:00"),
                                     tz = "Etc/GMT+7"))

## create snowprofileLayers object from data.frame
## and feed it into a snowprofile object:
df &lt;- data.frame(height = c(10, 25, 50),
                  hardness = c(2, 3, 1),
                  gtype = c('FC', NA, 'PP'),
                  stringsAsFactors = TRUE)

spL &lt;- snowprofileLayers(layerFrame = df)
(sp &lt;- snowprofile(layers = spL))


##### Create top-down recorded snowprofileLayers ####
## check out how the fields 'hs' and 'maxObservedDepth' are auto-filled in the
## resulting snowprofile object!
## 1.) Specify depth and hs:
## In that case the routine will assume that the deepest layer extends down to the ground
(sp1 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                                               hardness = c(2, 3, 1),
                                               gtype = c('FC', NA, 'PP'),
                                               hs = 50)))
## note that sp and sp1 are the same profiles:
all(sapply(names(sp$layers), function(cols) {sp$layers[cols] == sp1$layers[cols]}), na.rm = TRUE)

## 2.) Specify depth, hs and thickness or maxObservedDepth:
## This will include a basal layer of NAs to fill the unobserved space down to the ground.
(sp2 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                                               hardness = c(2, 3, 1),
                                               gtype = c('FC', NA, 'PP'),
                                               hs = 70,
                                               maxObservedDepth = 50)))

## 3.) Specify depth and maxObservedDepth:
## This will include a basal layer of NAs which is 1 cm thick to flag the unknown basal layers.
(sp3 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                         hardness = c(2, 3, 1),
                         gtype = c('FC', NA, 'PP'),
                         gsize = c(2, NA, NA),
                         maxObservedDepth = 50)))

## 4.) Specify depth and thickness:
## This is equivalent to the example spL3 above!
## This will include a basal layer of NAs which is 1 cm thick to flag the unknown basal layers.
(sp4 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                         thickness = c(10, 15, 25),
                         hardness = c(2, 3, 1),
                         gtype = c('FC', NA, 'PP'))))

## 5.) Specify only depth: issues warning!
(sp5 &lt;- snowprofile(layers = snowprofileLayers(depth = c(40, 25, 0),
                         hardness = c(2, 3, 1),
                         gtype = c('FC', NA, 'PP'))))

## plot all 5 top.down-recorded profiles:
set &lt;- snowprofileSet(list(sp1, sp2, sp3, sp4, sp5))
plot(set, SortMethod = "unsorted", xticklabels = "originalIndices",
     hardnessResidual = 0.1, hardnessScale = 1.5, TopDown = TRUE,
     main = "TopDown Plot")

plot(set, SortMethod = "unsorted", xticklabels = "originalIndices",
     hardnessResidual = 0.1, hardnessScale = 1.5, TopDown = FALSE,
     main = "BottomUp Plot")

</code></pre>

<hr>
<h2 id='snowprofilePrf'>Construct snowprofile object from PRF file</h2><span id='topic+snowprofilePrf'></span>

<h3>Description</h3>

<p>Read .prf files from SNOWPACK model output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofilePrf(Filename, ProfileDate = NA, tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofilePrf_+3A_filename">Filename</code></td>
<td>
<p>path to prf file</p>
</td></tr>
<tr><td><code id="snowprofilePrf_+3A_profiledate">ProfileDate</code></td>
<td>
<p>read a single profile from file (default = NA will read all profiles)</p>
</td></tr>
<tr><td><code id="snowprofilePrf_+3A_tz">tz</code></td>
<td>
<p>time zone (default = 'UTC')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several SNOWPACK model output formats exist see <a href="https://models.slf.ch/docserver/snowpack/html/snowpackio.html">SNOWPACK documentation</a>
</p>
<p>Definitions of PRF files are provided at <a href="https://models.slf.ch/docserver/snowpack/html/prf_format.html">https://models.slf.ch/docserver/snowpack/html/prf_format.html</a>
</p>
<p>PRF files typically contain profiles from the same station at multiple time steps. If a specific <code>ProfileDate</code> is provided a single snowprofile object is returned (search available dates with <code>scanProfileDates</code>), otherwise all profiles are read and a list of snowprofile objects is returned.
</p>


<h3>Value</h3>

<p>a single snowprofile object of list of multiple snowprofile objects
</p>


<h3>Author(s)</h3>

<p>shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofilePro">snowprofilePro</a>, <a href="#topic+scanProfileDates">scanProfileDates</a>, <a href="#topic+snowprofileSno">snowprofileSno</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Path to example prf file
Filename &lt;- system.file('extdata', 'example.prf', package = 'sarp.snowprofile')

## Scan dates in file
Dates &lt;- scanProfileDates(Filename)
print(Dates)

## Read a single profile by date and plot
ProfileDate &lt;- Dates[3]
Profile &lt;- snowprofilePrf(Filename, ProfileDate = ProfileDate)
plot(Profile)

## Read entire time series and plot
Profiles &lt;- snowprofilePrf(Filename)
plot(Profiles, main = 'Timeseries read from example.prf')

</code></pre>

<hr>
<h2 id='snowprofilePro'>Construct snowprofile object from PRO file</h2><span id='topic+snowprofilePro'></span>

<h3>Description</h3>

<p>Read .pro files from SNOWPACK model output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofilePro(
  Filename,
  ProfileDate = NA,
  tz = "UTC",
  remove_soil = TRUE,
  suppressWarnings = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofilePro_+3A_filename">Filename</code></td>
<td>
<p>path to pro file</p>
</td></tr>
<tr><td><code id="snowprofilePro_+3A_profiledate">ProfileDate</code></td>
<td>
<p>read a single profile from file (default = NA will read all profiles)</p>
</td></tr>
<tr><td><code id="snowprofilePro_+3A_tz">tz</code></td>
<td>
<p>time zone (default = 'UTC')</p>
</td></tr>
<tr><td><code id="snowprofilePro_+3A_remove_soil">remove_soil</code></td>
<td>
<p>if soil layers are present in PRO file, remove them from snowprofile objects?</p>
</td></tr>
<tr><td><code id="snowprofilePro_+3A_suppresswarnings">suppressWarnings</code></td>
<td>
<p>boolean switch</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several SNOWPACK model output formats exist see <a href="https://models.slf.ch/docserver/snowpack/html/snowpackio.html">SNOWPACK documentation</a>
</p>
<p>Definitions of PRO files are provided at <a href="https://models.slf.ch/docserver/snowpack/html/pro_format.html">https://models.slf.ch/docserver/snowpack/html/pro_format.html</a> and an example file is available at <a href="https://run.niviz.org/?file=resources%2Fexample.pro">niViz</a>
</p>
<p>PRO files typically contain profiles from the same station at multiple time steps. If a specific <code>ProfileDate</code> is provided a single snowprofile object is returned (search available dates with <code>scanProfileDates</code>), otherwise all profiles are read and a list of snowprofile objects is returned.
</p>


<h3>Value</h3>

<p>a single snowprofile object of list of multiple snowprofile objects
</p>


<h3>Author(s)</h3>

<p>shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofilePrf">snowprofilePrf</a>, <a href="#topic+scanProfileDates">scanProfileDates</a>, <a href="#topic+snowprofileSno">snowprofileSno</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Path to example pro file
Filename &lt;- system.file('extdata', 'example.pro', package = 'sarp.snowprofile')

## Download example pro file from niViz
#Filename &lt;- tempfile(fileext = '.pro')
#download.file('https://niviz.org/resources/example.pro', Filename)

## Scan dates in file
Dates &lt;- scanProfileDates(Filename)
print(Dates)

## Read a single profile by date and plot
ProfileDate &lt;- Dates[3]
Profile &lt;- snowprofilePro(Filename, ProfileDate = ProfileDate)
plot(Profile)

## Read entire time series and plot
Profiles &lt;- snowprofilePro(Filename)
plot(Profiles, main = 'Timeseries read from example.pro')

</code></pre>

<hr>
<h2 id='snowprofileSet'>Constructor for class snowprofileSet</h2><span id='topic+snowprofileSet'></span>

<h3>Description</h3>

<p>Constructor for class snowprofileSet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofileSet(x = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofileSet_+3A_x">x</code></td>
<td>
<p>list of <a href="#topic+snowprofile">snowprofile</a> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a snowprofileSet
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofile">snowprofile</a>, <a href="#topic+summary.snowprofileSet">summary.snowprofileSet</a>
</p>

<hr>
<h2 id='snowprofileSno'>Construct snowprofile object from SNO file</h2><span id='topic+snowprofileSno'></span>

<h3>Description</h3>

<p>Read .sno files from SNOWPACK model input/output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofileSno(Filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofileSno_+3A_filename">Filename</code></td>
<td>
<p>path to sno file</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several SNOWPACK model output formats exist see <a href="https://models.slf.ch/docserver/snowpack/html/snowpackio.html">SNOWPACK documentation</a>
</p>
<p>Definitions of SNO files are provided at <a href="https://models.slf.ch/docserver/snowpack/html/smet.html">https://models.slf.ch/docserver/snowpack/html/smet.html</a>
</p>


<h3>Value</h3>

<p>a <a href="#topic+snowprofile">snowprofile</a> object
</p>


<h3>Author(s)</h3>

<p>shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofilePro">snowprofilePro</a>, <a href="#topic+snowprofilePrf">snowprofilePrf</a>, <a href="#topic+snowprofileCsv">snowprofileCsv</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Path to example prf file
Filename &lt;- system.file('extdata', 'example.sno', package = 'sarp.snowprofile')

## Read snowprofile object
Profile &lt;- snowprofileSno(Filename)

## Note: plot.snowprofile won't work because sno files don't have harndess

## Plot a temperautre profile
plot(snowprofileSet(list(Profile)), ColParam = 'temp')

</code></pre>

<hr>
<h2 id='snowprofileTests'>Constructor for a snowprofileTests object</h2><span id='topic+snowprofileTests'></span>

<h3>Description</h3>

<p>Create a snowprofileTests object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snowprofileTests(
  testsFrame = data.frame(type = as.character(NA), result = as.character(NA), score =
    as.double(NA), fract_char = as.character(NA), depth = as.double(NA), comment =
    as.character(NA)),
  dropNAs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snowprofileTests_+3A_testsframe">testsFrame</code></td>
<td>
<p>a data.frame listing snowpack stability tests. Rows correspond to individual tests and columns describe at least the
fields <code>c("type", "result", "fract_char", "score", "depth")</code>.
</p>

<ul>
<li><p> Test <strong>type</strong> and <strong>result</strong> yield the standard 'data code' for reporting snowpack tests according to the OGRS (see Details).
Following type and result combinations are allowed:
</p>

<ul>
<li><p> STV, STE, STM, STH, STN, and mixed forms STE-M, STM-H
</p>
</li>
<li><p> CTV, CTE, CTM, CTH, CTN, and mixed forms CTE-M, CTM-H
</p>
</li>
<li><p> DTV, DTE, DTM, DTH, DTN, and mixed forms DTE-M, DTM-H
</p>
</li>
<li><p> ECTPV, ECTP, ECTN, ECTX
</p>
</li>
<li><p> RB, PST, DT tests are currently not supported.
</p>
</li></ul>

</li>
<li> <p><strong>score</strong>: numeric, number of taps (for CT, ECT)
</p>
</li>
<li> <p><strong>fract_char</strong> corresponds to the fracture character, e.g., SP, SC, PC, RP, BRK, ...
</p>
</li>
<li> <p><strong>depth</strong>: vertical location of corresponding snowpack layer (from surface)
</p>
</li>
<li><p> potential test comment column
</p>
</li></ul>
</td></tr>
<tr><td><code id="snowprofileTests_+3A_dropnas">dropNAs</code></td>
<td>
<p>Should empty, non-mandatory columns be dropped from the final snowprofileTests object?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more information, see
Canadian Avalanche Association. (2016). Observation Guidelines and Recording Standards for Weather, Snowpack, and Avalanches (OGRS). Revelstoke, BC, Canada.
</p>


<h3>Value</h3>

<p>snowprofileTests object
</p>


<h3>Author(s)</h3>

<p>fherla
</p>


<h3>See Also</h3>

<p><a href="#topic+snowprofile">snowprofile</a>, <a href="#topic+snowprofileLayers">snowprofileLayers</a>, <a href="#topic+snowprofileInstabilitySigns">snowprofileInstabilitySigns</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a data.frame with test observations
(testsFrame &lt;- data.frame(type = c("CT", "ST", "ECT"),
                         result = c("E-M", "M", "P"),
                         score = c(10, NA, 12),
                         fract_char = c("SP", NA, NA),
                         depth = c(40, 40, 40),
                         comment = c("some comment on first test", "", "")))

## create snowprofileTests object
tests &lt;- snowprofileTests(testsFrame)

## create snowprofile object containing test results and check resulting object:
snowprofile(tests = tests)

</code></pre>

<hr>
<h2 id='SPgroup'>Example group of snowprofiles from a mountain drainage</h2><span id='topic+SPgroup'></span>

<h3>Description</h3>

<p>A list of 12 snowprofile objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPgroup
</code></pre>


<h3>Format</h3>

<p>A list with 12 entries, that are of class <a href="#topic+snowprofile">snowprofile</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+SPpairs">SPpairs</a>, <a href="#topic+SPtimeline">SPtimeline</a>, <a href="#topic+plot.snowprofileSet">plot.snowprofileSet</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(SPgroup, SortMethod = 'unsorted', xticklabels = "originalIndices")
plot(SPgroup, SortMethod = 'hs', xticklabels = "originalIndices")

</code></pre>

<hr>
<h2 id='SPmalformatted'>Malformatted example profiles</h2><span id='topic+SPmalformatted'></span>

<h3>Description</h3>

<p>A list with two entries, each containing a snowprofile object. Both are malformatted, check out the examples in
<a href="#topic+validate_snowprofile">validate_snowprofile</a> and <a href="#topic+reformat_snowprofile">reformat_snowprofile</a> to learn how to fix it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPmalformatted
</code></pre>


<h3>Format</h3>

<p>A list with several entries, that are of class <a href="#topic+snowprofile">snowprofile</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+validate_snowprofile">validate_snowprofile</a>, <a href="#topic+reformat_snowprofile">reformat_snowprofile</a>, <a href="#topic+SPpairs">SPpairs</a>, <a href="#topic+SPgroup">SPgroup</a>, <a href="#topic+SPtimeline">SPtimeline</a>
</p>

<hr>
<h2 id='SPpairs'>Pairs of example snowprofiles</h2><span id='topic+SPpairs'></span>

<h3>Description</h3>

<p>A list with several entries, each containing a snowprofile object. Pairs of similar profiles are grouped by their names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPpairs
</code></pre>


<h3>Format</h3>

<p>A list with several entries, that are of class <a href="#topic+snowprofile">snowprofile</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+SPgroup">SPgroup</a>, <a href="#topic+SPtimeline">SPtimeline</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Each name refers to one snowprofile:
names(SPpairs)

opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
plot(SPpairs$A_manual, main = 'SPpairs$A_manual')
plot(SPpairs$A_modeled, main = 'SPpairs$A_modeled')
par(opar)

</code></pre>

<hr>
<h2 id='SPtimeline'>Timeseries of snowprofiles
#'</h2><span id='topic+SPtimeline'></span>

<h3>Description</h3>

<p>Timeseries of snowprofiles
#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SPtimeline
</code></pre>


<h3>Format</h3>

<p>A list with several entries, that are of class <a href="#topic+snowprofile">snowprofile</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+SPgroup">SPgroup</a>, <a href="#topic+SPpairs">SPpairs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(SPtimeline)
plot(SPtimeline)
</code></pre>

<hr>
<h2 id='summary.snowprofile'>Summary of a single snowprofile</h2><span id='topic+summary.snowprofile'></span>

<h3>Description</h3>

<p>Summary of a single snowprofile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snowprofile'
summary(object, fast = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.snowprofile_+3A_object">object</code></td>
<td>
<p>snowprofile object</p>
</td></tr>
<tr><td><code id="summary.snowprofile_+3A_fast">fast</code></td>
<td>
<p>boolean switch for twice as fast computation. downside: keep only length-1 meta data, i.e., discard latlon, or nlayers..</p>
</td></tr>
<tr><td><code id="summary.snowprofile_+3A_...">...</code></td>
<td>
<p>additional arguments for generic method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a one row data.frame where each column contains metadata.
</p>
<p>Metadata is determines as elements of the snowprofile object list that are length = 1. An exception is made for latlon where separate columns for lat and lon are produces.
</p>
<p>A derived value <code>nLayers</code> is derived by counting the number of rows in $layers.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.snowprofileSet">summary.snowprofileSet</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Profile &lt;- SPgroup[[1]]
names(Profile)
summary(Profile)
lapply(SPgroup, summary)

</code></pre>

<hr>
<h2 id='summary.snowprofileSet'>Summarize multiple snowprofiles</h2><span id='topic+summary.snowprofileSet'></span>

<h3>Description</h3>

<p>Wrapper for <a href="#topic+summary.snowprofile">summary.snowprofile</a>, which only returns metadata for a single snowprofile object. summary.snowprofileSet provides metadata for multiple snowprofiles, which is useful for subsetting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snowprofileSet'
summary(object, fast = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.snowprofileSet_+3A_object">object</code></td>
<td>
<p>list of snowprofile objects</p>
</td></tr>
<tr><td><code id="summary.snowprofileSet_+3A_fast">fast</code></td>
<td>
<p>boolean switch to speed up computations, see <a href="#topic+summary.snowprofile">summary.snowprofile</a></p>
</td></tr>
<tr><td><code id="summary.snowprofileSet_+3A_...">...</code></td>
<td>
<p>additional arguments for generic method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+summary.snowprofile">summary.snowprofile</a>, <a href="#topic+rbind.snowprofileSet">rbind.snowprofileSet</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Extract metadata for a group of profiles
Metadata &lt;- summary(SPgroup)
head(Metadata)

## Subsetting profiles with Metadata
Alpine &lt;- SPgroup[Metadata$elev &gt; 2000]
summary(Alpine)
Shallow &lt;- SPgroup[Metadata$hs &lt; 150]
summary(Shallow)
Week2 &lt;- SPtimeline[summary(SPtimeline)$date &gt; '2017-12-15']


## time comparison of fast--slow implementation
## expect 20 sec runtime
# rbenchmark::benchmark(fast = {Metadata &lt;- summary(SPgroup, fast = TRUE)},
#                       slow = {Metadata &lt;- summary(SPgroup, fast = FALSE)},
#                       replications = 10**3)

</code></pre>

<hr>
<h2 id='swisscode'>Numerical, Swiss Grain Type Code</h2><span id='topic+swisscode'></span>

<h3>Description</h3>

<p>A character array of grain types that can be translated into a numerical code by their indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swisscode
</code></pre>


<h3>Format</h3>

<p>A character array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(swisscode)

## see numerical code for each grain type:
rbind(swisscode, seq(length(swisscode)))
</code></pre>

<hr>
<h2 id='validate_snowprofile'>Validate correctness of snowprofile object</h2><span id='topic+validate_snowprofile'></span>

<h3>Description</h3>

<p>Validator function that checks if snowprofile standards are being met and raises an error if mandatory fields are
missing or data types are incorrect. The function raises a warning when unknown field names are encountered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_snowprofile(object, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_snowprofile_+3A_object">object</code></td>
<td>
<p>a <a href="#topic+snowprofile">snowprofile</a> object to be validated</p>
</td></tr>
<tr><td><code id="validate_snowprofile_+3A_silent">silent</code></td>
<td>
<p>remain silent upon error (i.e., don't raise error, but only print it)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Per default an error is raised when discovered, if <code>silent = TRUE</code> the error is only printed and the
error message returned (Note: a warning is never returned but only printed!).
If the function is applied to multiple objects, the function returns <code>NULL</code> for each object if no error
is encountered (see examples below).
</p>


<h3>See Also</h3>

<p><a href="#topic+reformat_snowprofile">reformat_snowprofile</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Validate individual snowprofile and raise an error
## in case of a malformatted profile:

## (1) no error
validate_snowprofile(SPgroup[[1]])

## (2) malformatted profile --&gt; error
this_throws_error &lt;- TRUE
if (!this_throws_error) {
validate_snowprofile(SPmalformatted[[1]])
}

## Validate a list of snowprofiles and raise an error
## when the first error is encountered:
## (i.e., stop subsequent execution)

## (1) no error
lapply(SPgroup, validate_snowprofile)

## (2) malformatted profile --&gt; error
if (!this_throws_error) {
lapply(SPmalformatted, validate_snowprofile)
}

## Validate a list of snowprofiles and continue execution,
## so that you get a comprehensive list of errors of all profiles:
if (!this_throws_error) {
errorlist &lt;- lapply(SPmalformatted, validate_snowprofile, silent = TRUE)
errorlist[sapply(errorlist, function(item) !is.null(item))]  # print profiles that caused errors
}

</code></pre>

<hr>
<h2 id='validate_snowprofileLayers'>Validate correctness of snowprofileLayers object</h2><span id='topic+validate_snowprofileLayers'></span>

<h3>Description</h3>

<p>Validator function that checks if class standards are being met and raises an error if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_snowprofileLayers(object, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_snowprofileLayers_+3A_object">object</code></td>
<td>
<p>to be tested</p>
</td></tr>
<tr><td><code id="validate_snowprofileLayers_+3A_silent">silent</code></td>
<td>
<p>remain silent upon error (i.e., don't throw error, but only print it)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Per default an error is raised when discovered, if <code>silent = TRUE</code> the error is only printed and the
error message returned.
</p>

<hr>
<h2 id='writeSmet'>Write a SMET file</h2><span id='topic+writeSmet'></span>

<h3>Description</h3>

<p>Write data into a SMET file https://models.slf.ch/docserver/meteoio/SMET_specifications.pdf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeSmet(smet, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeSmet_+3A_smet">smet</code></td>
<td>
<p>A data structure that resembles a smet file (i.e., list containing metadata and a
data.frame, see example in <a href="#topic+readSmet">readSmet</a>)</p>
</td></tr>
<tr><td><code id="writeSmet_+3A_filename">filename</code></td>
<td>
<p>Filepath to be written</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates smet file
</p>


<h3>Author(s)</h3>

<p>fherla, shorton
</p>


<h3>See Also</h3>

<p><a href="#topic+readSmet">readSmet</a>, <a href="#topic+snowprofileSno">snowprofileSno</a>, <a href="#topic+snowprofilePrf">snowprofilePrf</a>, <a href="#topic+snowprofilePro">snowprofilePro</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First read example smet file provided in package
(Wx = readSmet(system.file('extdata', 'example.smet', package = 'sarp.snowprofile')))

## Then write Wx to a new temp file and show the file
writeSmet(Wx, filename = file.path(tempdir(), 'file.smet'))
file.show(file.path(tempdir(), 'file.smet'))

## Check whether it can be read back in
(WxNew &lt;- readSmet(file.path(tempdir(), 'file.smet')))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
