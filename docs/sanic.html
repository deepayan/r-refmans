<!DOCTYPE html><html><head><title>Help for package sanic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sanic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arnoldi'><p>Krylov Subspace Spectral Decomposition</p></a></li>
<li><a href='#eigen2'><p>Spectral Decomposition</p></a></li>
<li><a href='#sanic'><p>Solving Ax = b Nimbly in C++</p></a></li>
<li><a href='#solve_cg'><p>Solve Systems of Equations Using Iterative Methods</p></a></li>
<li><a href='#solve_chol'><p>Solve Systems of Equations Using Direct Methods</p></a></li>
<li><a href='#solve2'><p>Solve Systems of Equations</p></a></li>
<li><a href='#sparsify'><p>Transform a Matrix to Be Sparse.</p></a></li>
<li><a href='#svd2'><p>Singular Value Decomposition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Solving Ax = b Nimbly in C++</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolas Kuschnig <a href="https://orcid.org/0000-0002-6642-2543"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Lukas Vashold <a href="https://orcid.org/0000-0002-3562-3414"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Yixuan Qiu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nikolas Kuschnig &lt;nikolas.kuschnig@wu.ac.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for solving large systems of linear equations and
  eigenproblems in R. Direct and iterative solvers from the Eigen C++ library
  are made available. Solvers include Cholesky, LU, QR, and Krylov subspace
  methods (Conjugate Gradient, BiCGSTAB). Dense and sparse problems are
  supported.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nk027/sanic">https://github.com/nk027/sanic</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nk027/sanic/issues">https://github.com/nk027/sanic/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), Matrix, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-23 10:23:09 UTC; nikolas</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-23 16:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='arnoldi'>Krylov Subspace Spectral Decomposition</h2><span id='topic+arnoldi'></span><span id='topic+lanczos'></span>

<h3>Description</h3>

<p>Arnoldi iteration and Lanczos method to iteratively approximate the
Hessenberg or tridiagonal form of a matrix <code class="reqn">A</code> and find its
eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arnoldi(
  a,
  b,
  symmetric,
  iter = nrow(a),
  tol = .Machine$double.eps,
  eigen = TRUE,
  orthogonalise = TRUE
)

lanczos(
  a,
  b,
  iter = nrow(a),
  tol = .Machine$double.eps,
  eigen = TRUE,
  orthogonalise = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arnoldi_+3A_a">a</code></td>
<td>
<p>Square numeric matrix.</p>
</td></tr>
<tr><td><code id="arnoldi_+3A_b">b</code></td>
<td>
<p>Arbitrary numeric non-zero vector used to construct the basis.</p>
</td></tr>
<tr><td><code id="arnoldi_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical scalar indicating whether 'a' is symmetric. By
default symmetry is checked up to machine precision, which may take a long
time for symmetric matrices.</p>
</td></tr>
<tr><td><code id="arnoldi_+3A_iter">iter</code></td>
<td>
<p>Integer scalar with the maximum number of iterations. Defaults
to the theoretical maximum, i.e. the number of columns in 'a'.</p>
</td></tr>
<tr><td><code id="arnoldi_+3A_tol">tol</code></td>
<td>
<p>Numeric scalar with the desired tolerance. Defaults to the
machine precision.</p>
</td></tr>
<tr><td><code id="arnoldi_+3A_eigen">eigen</code></td>
<td>
<p>Logical scalar indicating whether to compute eigenvalues from
the decomposition.</p>
</td></tr>
<tr><td><code id="arnoldi_+3A_orthogonalise">orthogonalise</code></td>
<td>
<p>Logical scalar indicating whether to use plain Lanczos
or full reorthogonalisation. Defaults to reorthogonalisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with slots <code>"H"</code> for the Hessenberg form of 'a'
or slots <code>"diagonal"</code> and <code>"subdiagonal"</code> for its triangular form,
slot <code>"Q"</code> with the orthonormal basis, and, if requested, eigenvalues
in the slot <code>"values"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Compute Hessenberg of a square matrix
A &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)
ks &lt;- arnoldi(A, symmetric = FALSE)

# Compute tridiagonal of a symmetric matrix
A &lt;- crossprod(matrix(rnorm(9), nrow = 3, ncol = 3))
ks &lt;- lanczos(A)
ks &lt;- arnoldi(A, symmetric = TRUE) # Short-hand

</code></pre>

<hr>
<h2 id='eigen2'>Spectral Decomposition</h2><span id='topic+eigen2'></span>

<h3>Description</h3>

<p>Solvers for eigenproblems around the matrix <code class="reqn">A</code>. Compute eigenvalues
<code class="reqn">\lambda</code> and eigenvectors <code class="reqn">v</code> of <code class="reqn">A</code>, such that
<code class="reqn">Av = \lambda v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen2(a, symmetric, vectors = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen2_+3A_a">a</code></td>
<td>
<p>Square numeric matrix.</p>
</td></tr>
<tr><td><code id="eigen2_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical scalar indicating whether 'a' is symmetric. By
default symmetry is checked up to machine precision, which may take a long
time for symmetric matrices.</p>
</td></tr>
<tr><td><code id="eigen2_+3A_vectors">vectors</code></td>
<td>
<p>Logical scalar indicating whether eigenvectors should be
computed and returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solves the eigenproblem and returns a list with eigenvalues in
the <code>"values"</code> slot and, if requested, eigenvectors in the slot
<code>"vectors"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Compute eigenvalues and eigenvectors for a square matrix
A &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)
ev &lt;- eigen2(A, symmetric = FALSE)

# Compute eigenvalues and eigenvectors for a symmetric matrix
A &lt;- crossprod(matrix(rnorm(9), nrow = 3, ncol = 3))
ev &lt;- eigen2(A, symmetric = TRUE)
# Check reconstruction
norm(A %*% ev$vectors - ev$vectors %*% diag(ev$values))

</code></pre>

<hr>
<h2 id='sanic'>Solving Ax = b Nimbly in C++</h2><span id='topic+sanic'></span>

<h3>Description</h3>

<p>Routines for solving large systems of linear equations in R.
Direct and iterative solvers from the Eigen C++ library are made available.
Solvers include Cholesky, LU, QR, and Krylov subspace methods (Conjugate
Gradient, BiCGSTAB). Both dense and sparse problems are supported.
</p>

<hr>
<h2 id='solve_cg'>Solve Systems of Equations Using Iterative Methods</h2><span id='topic+solve_cg'></span>

<h3>Description</h3>

<p>Iterative solvers using the Conjugate Gradient method for sparse systems of
equations <code class="reqn">Ax = b</code>. Three different types are available: (1)
stabilized bi-conjugate gradient (BiCGSTAB) for square matrices, (2)
conjugate gradient for rectangular least-squares (LSCG), and (3) classic
conjugate gradient (CG) for symmetric positive definite matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_cg(
  a,
  b,
  x0,
  type = c("BiCGSTAB", "LSCG", "CG"),
  iter,
  tol,
  precond = 1L,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_cg_+3A_a">a</code></td>
<td>
<p>Square numeric matrix with the coefficients of the linear system.
Dense and sparse matrices are supported, but the format must be sparse (see
<code><a href="#topic+sparsify">sparsify</a></code>). Dense matrices are coerced automatically.</p>
</td></tr>
<tr><td><code id="solve_cg_+3A_b">b</code></td>
<td>
<p>Numeric vector or matrix at the right-hand side of the linear
system. If missing, 'b' is set to an identity matrix and 'a' is
inverted.</p>
</td></tr>
<tr><td><code id="solve_cg_+3A_x0">x0</code></td>
<td>
<p>Numeric vector or matrix with an initial guess. Must be of the
same dimension as 'b'.</p>
</td></tr>
<tr><td><code id="solve_cg_+3A_type">type</code></td>
<td>
<p>Character scalar. Whether to use the BiCGSTAB, least squares
CG or classic CG method.</p>
</td></tr>
<tr><td><code id="solve_cg_+3A_iter">iter</code></td>
<td>
<p>Integer scalar with the maximum number of iterations. Defaults
to the theoretical maximum, i.e. the number of columns in 'a'.</p>
</td></tr>
<tr><td><code id="solve_cg_+3A_tol">tol</code></td>
<td>
<p>Numeric scalar with the desired tolerance. Defaults to the
machine precision.</p>
</td></tr>
<tr><td><code id="solve_cg_+3A_precond">precond</code></td>
<td>
<p>Integer scalar indicating the type of preconditioner to be
used. Defaults to diagonal preconditioning. See the Details for further
information.</p>
</td></tr>
<tr><td><code id="solve_cg_+3A_verbose">verbose</code></td>
<td>
<p>Logical scalar. Whether to print iterations and tolerance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preconditioners can be set to <code>0</code> for no / identity preconditioning,
<code>1</code> (default) for Jacobi / diagonal preconditioning, or <code>2</code> for
incomplete factorisation. Not all schemes are available for every type:
</p>
<p>* <code>type = "BiCGSTAB"</code> The default is <code>precond = 1</code> for diagonal
preconditioning. Set <code>precond = 0</code> for no preconditioning, or
<code>precond = 2</code> for an incomplete LUT preconditioner.
* <code>type = "LSCG"</code> The default is <code>precond = 1</code> for diagonal least
squares preconditioning. Set <code>precond = 0</code> for no preconditioning.
* <code>type = "CG"</code> The default is <code>precond = 1</code> for diagonal
preconditioning. Set <code>precond = 0</code> for no preconditioning, or
<code>precond = 2</code> for an incomplete Cholesky preconditioner.
</p>


<h3>Value</h3>

<p>Solves for <code class="reqn">x</code> and returns a numeric matrix with the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- rnorm(3)

# Solve via BiCGSTAB for square matrices
A &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)
b &lt;- A %*% x
norm(solve_cg(A, b, type = "B") - x)

# Solve via LSCG for rectangular matrices
A &lt;- matrix(rnorm(12), nrow = 4, ncol = 3)
b &lt;- A %*% x
norm(solve_cg(A, b, type = "LS") - x)

# Solve via classic CG for symmetric matrices
A &lt;- crossprod(matrix(rnorm(9), nrow = 3, ncol = 3))
b &lt;- A %*% x
norm(solve_cg(A, b, type = "CG") - x)

# The input matrix A should always be in sparse format
A &lt;- sparsify(crossprod(matrix(rnorm(9), nrow = 3, ncol = 3)))
# The right-hand side should be a dense matrix
b &lt;- as.matrix(A %*% x)

# We can check the speed of convergence and quality directly
solve_cg(A, b, verbose = TRUE)
# And provide guesses as starting value
solve_cg(A, b, x0 = x, verbose = TRUE)

</code></pre>

<hr>
<h2 id='solve_chol'>Solve Systems of Equations Using Direct Methods</h2><span id='topic+solve_chol'></span><span id='topic+solve_lu'></span><span id='topic+solve_qr'></span>

<h3>Description</h3>

<p>Direct solvers using Cholesky, LU, or QR decompositions for systems of
equations <code class="reqn">Ax = b</code>. Dense or sparse methods are used depending
on the format of the input matrix (see <code><a href="#topic+sparsify">sparsify</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_chol(a, b, pivot = 1L, ordering = 0L)

solve_lu(a, b, pivot = 1L, ordering = 1L)

solve_qr(a, b, pivot = 1L, ordering = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve_chol_+3A_a">a</code></td>
<td>
<p>Square numeric matrix with the coefficients of the linear system.
Both dense and sparse matrices are supported (see <code><a href="#topic+sparsify">sparsify</a></code>).</p>
</td></tr>
<tr><td><code id="solve_chol_+3A_b">b</code></td>
<td>
<p>Numeric vector or matrix at the right-hand side of the linear
system. If missing, 'b' is set to an identity matrix and 'a' is
inverted.</p>
</td></tr>
<tr><td><code id="solve_chol_+3A_pivot">pivot</code></td>
<td>
<p>Integer scalar indicating the pivoting scheme to be used.
Defaults to partial pivoting. See the Details for further information.</p>
</td></tr>
<tr><td><code id="solve_chol_+3A_ordering">ordering</code></td>
<td>
<p>Integer scalar indicating the ordering scheme to be used.
See the Details for further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pivoting schemes for dense matrices can be set to <code>0</code> for no pivoting,
<code>1</code> (default) for partial pivoting, or <code>2</code> for full pivoting. Not
all schemes are available for every decomposition:
</p>
<p>* <code>solve_chol()</code> The default is <code>pivot = 1</code> for the robust LDLT
decomposition of <code class="reqn">A</code>, such that <code class="reqn">A = P'LDL^*P</code>. For
the LDLT <code class="reqn">A</code> needs to be positive or negative semidefinite. Set
<code>pivot = 0</code> for the plain LLT decomposition of <code class="reqn">A</code>, such that
<code class="reqn">A = LL^* = U^*U</code>. For the LLT <code class="reqn">A</code> needs to be
positive definite and preferably numerically stable.
* <code>solve_lu()</code> The default is <code>pivot = 1</code> for the partial pivoting
LU decomposition of <code class="reqn">A</code>, such that <code class="reqn">A = PLU</code>. For this
scheme <code class="reqn">A</code> needs to be invertible and preferably numerically stable. Set
<code>pivot = 2</code> for the complete pivoting LU decomposition of <code class="reqn">A</code>,
such that <code class="reqn">A = P^{-1}LUQ^{-1}</code>. This scheme is applicable to
square matrices, rank-revealing, and stable.
<code>solve_qr()</code> The default is <code>pivot = 1</code> for the column pivoting
Householder QR decomposition of <code class="reqn">A</code>, such that <code class="reqn">AP = QR</code>.
This scheme is generally applicable, rank-revealing, and stable. Set
<code>pivot = 2</code> for the full pivoting Householder QR decomposition of
<code class="reqn">A</code>, such that <code class="reqn">PAP' = QR</code>. This scheme is generally
applicable, rank-revealing, and optimally stable. Set <code>pivot = 0</code> for
an unpivoted Householder QR decomposition of <code class="reqn">A</code>, such that
<code class="reqn">A = QR</code>. This scheme is generally applicable, but not as stable
as pivoted variants.
</p>
<p>Ordering schemes for sparse matrices can be set to <code>0</code> for approximate
minimum degree (AMD) ordering, <code>1</code> for column approximate minimum degree
(COLAMD) ordering, or <code>2</code> for natural ordering. Not all orderings are
available for every decomposition:
</p>
<p>* <code>solve_chol()</code> The default is <code>ordering = 0</code> for AMD ordering.
Set <code>ordering = 2</code> for natural ordering.
* <code>solve_lu()</code> The default is <code>ordering = 1</code> for COLAMD ordering.
Set <code>ordering = 0</code> for AMD or <code>ordering = 2</code> for natural ordering.
* <code>solve_qr()</code> The default is <code>ordering = 1</code> for COLAMD ordering.
Set <code>ordering = 0</code> for AMD or <code>ordering = 2</code> for natural ordering.
</p>


<h3>Value</h3>

<p>Solves for <code class="reqn">x</code> and returns a numeric matrix with the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- rnorm(3)

# Solve via QR for general matrices
A &lt;- matrix(rnorm(12), nrow = 4, ncol = 3)
b &lt;- A %*% x
norm(solve_qr(A, b) - x)

# Solve via LU for square matrices
A &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)
b &lt;- A %*% x
norm(solve_lu(A, b) - x)

# Solve via Cholesky for symmetric matrices
A &lt;- crossprod(matrix(rnorm(9), nrow = 3, ncol = 3))
b &lt;- A %*% x
norm(solve_chol(A, b) - x)

# Sparse methods are available for the 'dgCMatrix' class from Matrix
A &lt;- crossprod(matrix(rnorm(9), nrow = 3, ncol = 3))
b &lt;- A %*% x
norm(solve_qr(sparsify(A), b))
norm(solve_lu(sparsify(A), b))
norm(solve_chol(sparsify(A), b))

</code></pre>

<hr>
<h2 id='solve2'>Solve Systems of Equations</h2><span id='topic+solve2'></span>

<h3>Description</h3>

<p>Solve systems of equations <code class="reqn">Ax = b</code> using an automatically
chosen direct method (see <code><a href="#topic+solve_chol">solve_chol</a></code>). Methods are chosen for
speed at reasonable accuracy. Please choose a suitable method manually if
numerical stability is the main consideration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve2(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solve2_+3A_a">a</code></td>
<td>
<p>Square numeric matrix with the coefficients of the linear system.
Both dense and sparse matrices are supported (see <code><a href="#topic+sparsify">sparsify</a></code>).</p>
</td></tr>
<tr><td><code id="solve2_+3A_b">b</code></td>
<td>
<p>Numeric vector or matrix at the right-hand side of the linear
system. If missing, 'b' is set to an identity matrix and 'a' is
inverted.</p>
</td></tr>
<tr><td><code id="solve2_+3A_...">...</code></td>
<td>
<p>Dispatched to methods in the solvers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solves for <code class="reqn">x</code> and returns a numeric matrix with the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- rnorm(3)

# Solve using a general matrix
A &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)
b &lt;- A %*% x
norm(solve2(A, b) - x)

# Solve using a symmetric matrix
A &lt;- crossprod(matrix(rnorm(9), nrow = 3, ncol = 3))
b &lt;- A %*% x
norm(solve2(A, b) - x)

# Solve using a square matrix
A &lt;- matrix(rnorm(12), nrow = 4, ncol = 3)
b &lt;- A %*% x
norm(solve2(A, b) - x)

</code></pre>

<hr>
<h2 id='sparsify'>Transform a Matrix to Be Sparse.</h2><span id='topic+sparsify'></span>

<h3>Description</h3>

<p>Concise function to transform dense to sparse matrices of class
<code>dgCMatrix</code> (see <a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsify_+3A_x">x</code></td>
<td>
<p>Numeric matrix to transform to a sparse 'dgCMatrix'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns 'x' as <code>dgCMatrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sparsify(matrix(rnorm(9L), 3L))
</code></pre>

<hr>
<h2 id='svd2'>Singular Value Decomposition</h2><span id='topic+svd2'></span>

<h3>Description</h3>

<p>Solvers for generalized eigenproblems around the matrix <code class="reqn">A</code>. Compute
singular values <code class="reqn">\Sigma</code>, left singular vectors <code class="reqn">U</code> and
right singular vectors <code class="reqn">V</code> of <code class="reqn">A</code>, such that
<code class="reqn">A = U \Sigma V^*</code>. Two different types are available: (1)
bidiagonal divide and conquer strategy (BDC) SVD, and (2) two-sided Jacobi
SVD for small matrices (&lt;16) and high accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svd2(a, type = c("BDC", "Jacobi"), vectors = TRUE, thin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svd2_+3A_a">a</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
<tr><td><code id="svd2_+3A_type">type</code></td>
<td>
<p>Character scalar. Whether to use BDC or Jacobi SVD.</p>
</td></tr>
<tr><td><code id="svd2_+3A_vectors">vectors</code></td>
<td>
<p>Logical scalar indicating whether singular vectors should be
computed and returned.</p>
</td></tr>
<tr><td><code id="svd2_+3A_thin">thin</code></td>
<td>
<p>Logical scalar indicating whether singular vectors should be
returned in thinned or full format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solves the generalised eigenproblem and returns a list with
singular values in the <code>"d"</code> component and, if requested, singular
vectors in the components <code>"u"</code> and <code>"v"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
# Compute singular values and vectors using BDC
A &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)
sv &lt;- svd2(A)

# Compute singular values using Jacobi
A &lt;- matrix(rnorm(9), nrow = 3, ncol = 3)
sv &lt;- svd2(A, type = "J", vectors = FALSE)

# Compute singular values and full vectors using BDC
A &lt;- matrix(rnorm(12), nrow = 4, ncol = 3)
sv &lt;- svd2(A, type = "B", thin = FALSE)
A &lt;- matrix(rnorm(12), nrow = 3, ncol = 4)
sv &lt;- svd2(A, type = "B", thin = FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
