<!DOCTYPE html><html lang="en"><head><title>Help for package SpatialNP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialNP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SpatialNP-package'>
<p>Multivariate nonparametric tests and estimates based on spatial signs and ranks.</p></a></li>
<li><a href='#Independence+20tests'><p>Multivariate test of independence based on spatial signs or</p>
ranks</a></li>
<li><a href='#Location+20tests'><p>Spatial sign and rank tests of multivariate location</p></a></li>
<li><a href='#mvhuberM'><p>Multivariate Huber's M-estimator and its symmetrized version</p></a></li>
<li><a href='#Shape+20matrices'><p>Shape matrices based on spatial ranks and signed ranks</p></a></li>
<li><a href='#Spatial+20location'><p>Multivariate location estimates based on spatial signs and signed ranks</p></a></li>
<li><a href='#Spatial+20sign+20and+20rank+20covariance+20matrices'><p>Spatial sign and rank covariance matrices</p></a></li>
<li><a href='#Spatial+20signs+2C+20symmetrized+20signs+2C+20ranks+20and+20signed+20ranks'><p>Spatial signs, symmetrized signs, ranks and signed ranks</p></a></li>
<li><a href='#Sphericity+20tests'><p>Sphericity tests</p></a></li>
<li><a href='#symm.mvtmle'><p>Symmetrized M-estimators of scatter with the weights of the t-distribution</p></a></li>
<li><a href='#to.shape'><p>Rescale a matrix to a shape matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Nonparametric Methods Based on Spatial Signs and
Ranks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-12-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Nordhausen &lt;klaus.k.nordhausen@jyu.fi&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ICSNP, MNM</td>
</tr>
<tr>
<td>Description:</td>
<td>Test and estimates of location, tests of independence, tests of sphericity and several estimates of shape all based on spatial signs, symmetrized signs, ranks and signed ranks. For details, see Oja and Randles (2004) &lt;<a href="https://doi.org/10.1214%2F088342304000000558">doi:10.1214/088342304000000558</a>&gt; and Oja (2010) &lt;<a href="https://doi.org/10.1007%2F978-1-4419-0468-3">doi:10.1007/978-1-4419-0468-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-08 06:30:19 UTC; knordhau</td>
</tr>
<tr>
<td>Author:</td>
<td>Seija Sirkia [aut],
  Jari Miettinen <a href="https://orcid.org/0000-0002-3270-7014"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Hannu Oja [aut],
  Sara Taskinen <a href="https://orcid.org/0000-0001-9470-7258"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-08 12:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='SpatialNP-package'>
Multivariate nonparametric tests and estimates based on spatial signs and ranks.
</h2><span id='topic+SpatialNP-package'></span><span id='topic+SpatialNP'></span>

<h3>Description</h3>

<p>Test and estimates of location, tests of independence, tests of sphericity and several estimates of shape all based on spatial signs, symmetrized signs, ranks and signed ranks. For details, see Oja and Randles (2004) &lt;doi:10.1214/088342304000000558&gt; and Oja (2010)  &lt;doi:10.1007/978-1-4419-0468-3&gt;.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SpatialNP</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2021-12-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>There are three functions for inference,
<code><a href="#topic+sr.loc.test">sr.loc.test</a></code>, <code><a href="#topic+sr.indep.test">sr.indep.test</a></code> and
<code><a href="#topic+sr.sphere.test">sr.sphere.test</a></code>, for location, independence and
sphericity tests. The so called <a href="#topic+rank.shape">inner</a> and
<a href="#topic+SCov">outer</a> standardization matrices are also available as
well as the actual <a href="#topic+spatial.rank">sign and rank</a> score
functions, together with a utility function <code><a href="#topic+to.shape">to.shape</a></code>.  </p>


<h3>Author(s)</h3>

<p>Seija Sirkia, Jari Miettinen, Klaus Nordhausen, Hannu Oja, Sara Taskinen <br />
Maintainer: Klaus Nordhausen, <a href="mailto:klaus.k.nordhausen@jyu.fi">klaus.k.nordhausen@jyu.fi</a></p>


<h3>See Also</h3>

<p>package <span class="pkg"><a href="ICSNP.html#topic+ICSNP-package">ICSNP</a></span> <br />
package <span class="pkg"><a href="MNM.html#topic+MNM-package">MNM</a></span></p>

<hr>
<h2 id='Independence+20tests'>Multivariate test of independence based on spatial signs or
ranks</h2><span id='topic+sr.indep.test'></span>

<h3>Description</h3>

<p> Test of independence between two sets of
variables. Inference is based on the spatial signs of the
observations, symmetrized signs of the observations or spatial signed
ranks of the observations.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> sr.indep.test(X, Y = NULL, g = NULL, score = c("sign", 
"symmsign", "rank"), regexp = FALSE, cond = FALSE, cond.n = 1000, 
na.action = na.fail) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Independence+2B20tests_+3A_x">X</code></td>
<td>
<p>a matrix or a data frame</p>
</td></tr>
<tr><td><code id="Independence+2B20tests_+3A_y">Y</code></td>
<td>
<p>an optional matrix or a data frame</p>
</td></tr>
<tr><td><code id="Independence+2B20tests_+3A_g">g</code></td>
<td>
<p>a factor giving the two sets of variables, or numeric vector or vector of column names giving the first set of variables. See details</p>
</td></tr>
<tr><td><code id="Independence+2B20tests_+3A_score">score</code></td>
<td>
<p>a character string indicating which transformation of the observations should be used</p>
</td></tr>
<tr><td><code id="Independence+2B20tests_+3A_regexp">regexp</code></td>
<td>
<p>logical. Is <code>g</code> a regular expression?</p>
</td></tr>
<tr><td><code id="Independence+2B20tests_+3A_cond">cond</code></td>
<td>
<p>logical. Should the conditionally distribution free test be used?</p>
</td></tr>
<tr><td><code id="Independence+2B20tests_+3A_cond.n">cond.n</code></td>
<td>
<p>Number of permutations to use in the conditionally distribution free test</p>
</td></tr>
<tr><td><code id="Independence+2B20tests_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should contain the first set of variables and
<code>Y</code> the second with matching rows. Alternatively, <code>X</code> should
contain both sets and <code>g</code> should be a factor of length equal to
number of columns of <code>X</code>, or, <code>g</code> should be a numeric or
character vector naming the variables in the first set. If <code>g</code> is
a character vector it is assumed to name all wanted columns exactly,
unless <code>regexp</code> is <code>TRUE</code>.</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the statistic or the number of replications if conditionally distribution free p-value was used</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the measure of dependence (always 0)</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data (and grouping vector)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seija Sirkia, <a href="mailto:seija.sirkia@iki.fi">seija.sirkia@iki.fi</a></p>


<h3>References</h3>

<p><cite>Taskinen, S., Oja, H., Randles R. (2004) Multivariate Nonparametric Tests of Independence. <em>JASA</em>, 100, 916-925</cite></p>


<h3>See Also</h3>

<p><a href="#topic+spatial.rank">Spatial signs and ranks</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3)
X&lt;-matrix(rnorm(3000),ncol=3)%*%t(A)
Y&lt;-cbind(X+runif(3000,-1,1),runif(1000))
sr.indep.test(X,Y)
#alternative calls:
Z&lt;-cbind(X,Y)
colnames(Z)&lt;-c("a1","a2","a3","b1","b2","b3","b4")
g&lt;-factor(c(rep(1,3),rep(2,4)))
sr.indep.test(Z,g=g)
sr.indep.test(Z,g=c("b"),regexp=TRUE)
sr.indep.test(Z,g=1:3)

</code></pre>

<hr>
<h2 id='Location+20tests'>Spatial sign and rank tests of multivariate location</h2><span id='topic+sr.loc.test'></span>

<h3>Description</h3>

<p> Multivariate tests of location of one or more samples
based on spatial signs and (signed) ranks. In case of one sample the
null hypothesis about a given location is tested. In case of several
samples the null hypothesis is that all samples have the same
location.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> sr.loc.test(X, Y = NULL, g = NULL, score = c("sign", "rank"),
nullvalue = NULL, cond = FALSE, cond.n = 1000,
na.action = na.fail,...)  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Location+2B20tests_+3A_x">X</code></td>
<td>
<p>a matrix or a data frame </p>
</td></tr>
<tr><td><code id="Location+2B20tests_+3A_y">Y</code></td>
<td>
<p>an optional matrix or a data frame </p>
</td></tr>
<tr><td><code id="Location+2B20tests_+3A_g">g</code></td>
<td>
<p>a factor giving the groups (may contain just one level) </p>
</td></tr>
<tr><td><code id="Location+2B20tests_+3A_score">score</code></td>
<td>
<p>a character string indicating which transformation of the observations should be used</p>
</td></tr>
<tr><td><code id="Location+2B20tests_+3A_nullvalue">nullvalue</code></td>
<td>
<p>location to be tested in the one sample case (ignored if there is more than one sample)</p>
</td></tr>
<tr><td><code id="Location+2B20tests_+3A_cond">cond</code></td>
<td>
<p>logical. Should the conditionally distribution free test be used? (Ignored if <code>score</code> is <code>"rank"</code>)</p>
</td></tr>
<tr><td><code id="Location+2B20tests_+3A_cond.n">cond.n</code></td>
<td>
<p>number of permutations to use in the conditionally distribution free test</p>
</td></tr>
<tr><td><code id="Location+2B20tests_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
<tr><td><code id="Location+2B20tests_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X</code> should contain the the whole data set and <code>g</code> should describe the groups, or, if there is only one group, <code>g</code> may be missing. Alternatively, if there are two samples <code>X</code> may contain only the first sample while the second sample is given in <code>Y</code> and <code>g</code> is ignored. Note that in the one sample case when <code>rank</code> is chosen as <code>score</code> the function in fact uses signed ranks.
</p>
<p>Note that the conditionally distribution free p-value is only provided for the sign based version of the test.
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the statistic or the number of replications if conditionally distribution free p-value was used</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the (common) location</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data (and grouping vector)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seija Sirkia, <a href="mailto:seija.sirkia@iki.fi">seija.sirkia@iki.fi</a></p>


<h3>References</h3>

<p><cite>Oja, H., Randles R. (2004) Multivariate Nonparametric Tests. <em>Statistical Science</em> 19, 598-605.</cite></p>


<h3>See Also</h3>

<p><a href="#topic+spatial.rank">Spatial signs and ranks</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3)
X&lt;-rbind(matrix(rnorm(1500),ncol=3),matrix(rnorm(750)+1,ncol=3))%*%t(A)
sr.loc.test(X,cond=TRUE)
X[1:250,]&lt;-X[1:250,]+1
g&lt;-factor(rep(c(1,2,3),each=250))
sr.loc.test(X,g=g,score="rank")
</code></pre>

<hr>
<h2 id='mvhuberM'>Multivariate Huber's M-estimator and its symmetrized version</h2><span id='topic+mvhuberM'></span><span id='topic+symmhuber'></span><span id='topic+symmhuber.inc'></span>

<h3>Description</h3>

<p>Iterative algorithms to estimate M-estimators of location and scatter as well as symmetrized M-estimator using Huber's weight functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvhuberM(X, qg = 0.9, fixed.loc = FALSE, location = NULL, init =
NULL, steps = Inf, eps = 1e-06, maxiter = 100, na.action = na.fail)

symmhuber(X, qg = 0.9, init = NULL, steps = Inf, eps = 1e-6, 
maxiter = 100, na.action = na.fail)

symmhuber.inc(X, qg=0.9, m=10, init=NULL, steps=Inf, permute=TRUE, 
eps=1e-6, maxiter=100, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvhuberM_+3A_x">X</code></td>
<td>
<p>a matrix or a data frame</p>
</td></tr>
<tr><td><code id="mvhuberM_+3A_qg">qg</code></td>
<td>
<p>a tuning parameter. The default is 0.9, see details</p>
</td></tr>
<tr><td><code id="mvhuberM_+3A_fixed.loc">fixed.loc</code></td>
<td>
<p>a logical, see details</p>
</td></tr>
<tr><td><code id="mvhuberM_+3A_location">location</code></td>
<td>
<p>an optional vector giving the location of the data or the initial value for the location if it is estimated</p>
</td></tr>
<tr><td><code id="mvhuberM_+3A_init">init</code></td>
<td>
<p>an optional starting value for scatter</p>
</td></tr>  
<tr><td><code id="mvhuberM_+3A_steps">steps</code></td>
<td>
<p>fixed number of iteration steps to take, if <code>Inf</code> iteration is repeated until convergence (or until <code>maxiter</code> steps)</p>
</td></tr>
<tr><td><code id="mvhuberM_+3A_m">m</code></td>
<td>
<p>a parameter in <code>symmhuber.inc</code> which defines how many pairwise differences are used, see details.</p>
</td></tr>
<tr><td><code id="mvhuberM_+3A_permute">permute</code></td>
<td>
<p>logical in <code>symmhuber.inc</code> which determines whether the rows of <code>X</code> are permuted randomly, see details.</p>
</td></tr>
<tr><td><code id="mvhuberM_+3A_eps">eps</code></td>
<td>
<p>tolerance for convergence</p>
</td></tr>
<tr><td><code id="mvhuberM_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iteration steps. Ignored if <code>steps</code> 
is finite</p>
</td></tr> 
<tr><td><code id="mvhuberM_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's. Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mvhuberM</code> computes multivariate M-estimators of location and scatter 
using Huber's weight functions. The tuning parameter <code>qg</code> defines cutoff-point c for weight functions so that <code class="reqn">c=F^{-1}(q)</code>, where F is the cdf of <code class="reqn">\chi^2</code>-distribution with p degrees of freedom. The estimators with maximal breakdown point are obtained with the choice qg=F(p+1). If <code>fixed.loc</code> is set TRUE, scatter estimator is computed with fixed location given by 
<code>location</code> (default is column means). 
</p>
<p><code>symmhuber</code> computes Huber's M-estimator of scatter using pairwise
differences of the data therefore avoiding location estimation.   
</p>
<p><code>symmhuber.inc</code> is a computationally lighter estimator to approximate symmetrized Huber's M-estimator of scatter. Only a subset of the pairwise 
differences are used in the computation in the incomplete case. The magnitude of the subset used is controlled by the argument <code>m</code> which is half 
of the number of how many differences each observation is part of. Differences of successive observations are used, and therefore random permutation 
of the rows of <code>X</code> is suggested and is the default choice in the function. For details see Miettinen et al., 2016.
</p>


<h3>Value</h3>

<p><code>mvhuberM</code> returns a list with components
</p>
<table role = "presentation">
<tr><td><code>location</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>
<p><code>symmhuber</code> returns a matrix.
</p>
<p><code>symmhuber.inc</code> returns a matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen, <a href="mailto:klaus.nordhausen@tuwien.ac.at">klaus.nordhausen@tuwien.ac.at</a>, <br />
Jari Miettinen, <a href="mailto:jari.p.miettinen@aalto.fi">jari.p.miettinen@aalto.fi</a></p>


<h3>References</h3>

<p><cite>Huber, P.J. (1981), Robust Statistics, Wiley, New York.</cite>
</p>
<p><cite>Lopuhaa, H.P. (1989). On the relation between S-estimators and M-estimators of multivariate location and covariance. <em>Annals of Statistics</em>, 17, 1662-1683.</cite>
</p>
<p><cite>Sirkia, S., Taskinen, S., Oja, H. (2007) Symmetrised M-estimators of scatter. <em>Journal of Multivariate Analysis</em>, 98, 1611-1629.</cite>
</p>
<p><cite>Miettinen, J., Nordhausen, K., Taskinen, S., Tyler, D.E. (2016) On the computation of symmetrized M-estimators of scatter. <em>In Agostinelli, C. Basu, A., Filzmoser, P. and Mukherje, D. (editors) &rdquo;Recent Advances in Robust Statistics: Theory and Application&rdquo;</em>, 131-149, Springer India, New Delhi.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3)
X&lt;-matrix(rnorm(1500),ncol=3)%*%t(A)
mvhuberM(X)
symmhuber(X)
symmhuber.inc(X, m=5)
symm.mvtmle.inc(X, m=5)
</code></pre>

<hr>
<h2 id='Shape+20matrices'>Shape matrices based on spatial ranks and signed ranks</h2><span id='topic+rank.shape'></span><span id='topic+signs.shape'></span><span id='topic+signrank.shape'></span><span id='topic+spatial.shape'></span><span id='topic+symmsign.shape'></span><span id='topic+symmsign.shape.inc'></span>

<h3>Description</h3>

<p> Iterative algorithms to find shape matrices based on
spatial signs and ranks and the k-step versions of these.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> 

spatial.shape(X, score = c("sign", "symmsign", "rank", "signrank"), 
fixed.loc = FALSE, location = NULL, init = NULL, steps = Inf, 
eps = 1e-06, maxiter = 100, na.action = na.fail)

signs.shape(X, fixed.loc = FALSE, location = NULL, init = NULL, 
steps = Inf, eps = 1e-6, maxiter = 100, na.action = na.fail) 

symmsign.shape(X, init = NULL, steps = Inf, eps = 1e-6, 
maxiter = 100, na.action = na.fail)

symmsign.shape.inc(X, m=10, init=NULL, steps=Inf, permute=TRUE, 
eps=1e-6, maxiter=100, na.action=na.fail)

rank.shape(X, init = NULL, steps = Inf, eps = 1e-06, 
maxiter = 100, na.action = na.fail)

signrank.shape(X, fixed.loc = FALSE, location = NULL, init = NULL, 
steps = Inf, eps = 1e-06, maxiter = 100, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Shape+2B20matrices_+3A_x">X</code></td>
<td>
<p>a matrix or a data frame </p>
</td></tr>
<tr><td><code id="Shape+2B20matrices_+3A_score">score</code></td>
<td>
<p>a character string indicating which transformation of the observations should be used</p>
</td></tr>
<tr><td><code id="Shape+2B20matrices_+3A_fixed.loc">fixed.loc</code></td>
<td>
<p>a logical, see details</p>
</td></tr> 
<tr><td><code id="Shape+2B20matrices_+3A_location">location</code></td>
<td>
<p>an optional vector giving the location of the data or the initial value for the location if it is estimated</p>
</td></tr> 
<tr><td><code id="Shape+2B20matrices_+3A_init">init</code></td>
<td>
<p>an optional starting value for the iteration</p>
</td></tr>
<tr><td><code id="Shape+2B20matrices_+3A_steps">steps</code></td>
<td>
<p>fixed number of iteration steps to take, if <code>Inf</code> iteration is repeated until convergence (or until <code>maxiter</code> steps)</p>
</td></tr>
<tr><td><code id="Shape+2B20matrices_+3A_m">m</code></td>
<td>
<p>a parameter in <code>symmsign.shape.inc</code> which defines how many pairwise differences are used, see details</p>
</td></tr>
<tr><td><code id="Shape+2B20matrices_+3A_permute">permute</code></td>
<td>
<p>logical in <code>symmsign.shape.inc</code> which determines whether the rows of <code>X</code> are permuted randomly, see details.</p>
</td></tr>
<tr><td><code id="Shape+2B20matrices_+3A_eps">eps</code></td>
<td>
<p>tolerance for convergence</p>
</td></tr>
<tr><td><code id="Shape+2B20matrices_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iteration steps. Ignored if <code>steps</code> 
is finite</p>
</td></tr> 
<tr><td><code id="Shape+2B20matrices_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sign.shape</code> is Tyler's shape matrix and <code>symmsign.shape</code> is Duembgen's shape matrix. Function
<code>symmsign.shape.inc</code> is for a computationally lighter estimator to approximate Duembgen's shape matrix. Only a subset of the pairwise differences are used 
in the computation in the incomplete case. The magnitude of the subset used is controlled by the argument <code>m</code> which is half of the number of how many 
differences each observation is part of. Differences of successive observations are used, and therefore random permutation of the rows of <code>X</code> is suggested 
and is the default choice in the function. For details see Miettinen et al., 2016.
<code>rank.shape</code> and <code>signrank.shape</code> are the so called inner standardization matrices of location etc. tests based on spatial signs and ranks. When data is standardized using these matrices the corresponding sign or rank scores will appear &ldquo;uncorrelated&rdquo;: the corresponding outer standardization matrices will be proportional to the identity matrix, see examples.
</p>
<p><code>spatial.shape</code> is a wrapper function for a unified access to all
four shape estimates (not including <code>symmsign.shape.inc</code>). The choice of estimate is done via <code>score</code>:
</p>

<ul>
<li> <p><code>"sign"</code> for <code>signs.shape</code> 
</p>
</li>
<li> <p><code>"symmsign"</code> for <code>symmsign.shape</code>
</p>
</li>
<li> <p><code>"rank"</code> for <code>rank.shape</code> 
</p>
</li>
<li> <p><code>"signrank"</code> for <code>signrank.shape</code>
</p>
</li></ul>

<p><code>signrank.shape</code> and <code>sign.shape</code> include options to compute the shape matrix either with respect to fixed location (<code>fixed.loc = TRUE</code>) or so that the location and the shape are estimated simultaneously (<code>fixed.loc = FALSE</code>).
</p>


<h3>Value</h3>

<p>The estimate matrix with the (final estimate of or given) location vector 
as attribute <code>"location"</code>.
</p>


<h3>Author(s)</h3>

<p>Seija Sirkia, <a href="mailto:seija.sirkia@iki.fi">seija.sirkia@iki.fi</a>, Jari Miettinen, <a href="mailto:jari.p.miettinen@aalto.fi">jari.p.miettinen@aalto.fi</a></p>


<h3>References</h3>

<p><cite>Oja, H., Randles R. (2004) Multivariate Nonparametric Tests. <em>Statistical Science</em> 19, 598-605.</cite>
</p>
<p><cite>Sirkia et al. (2009) Tests and estimates of shape based on spatial signs and ranks. <em>Journal of Nonparametric Statistics</em>, 21, 155-176.</cite>
</p>
<p><cite>Sirkia, S., Taskinen, S., Oja, H. (2007) Symmetrised M-estimators of scatter. <em>Journal of Multivariate Analysis</em>, 98, 1611-1629.</cite>
</p>
<p><cite>Miettinen, J., Nordhausen, K., Taskinen, S., Tyler, D.E. (2016) On the computation of symmetrized M-estimators of scatter. <em>In Agostinelli, C. Basu, A., Filzmoser, P. and Mukherje, D. (editors) &rdquo;Recent Advances in Robust Statistics: Theory and Application&rdquo;</em>, 131-149, Springer India, New Delhi.</cite></p>


<h3>See Also</h3>

<p><code><a href="ICSNP.html#topic+tyler.shape">tyler.shape</a></code>, <code><a href="ICSNP.html#topic+duembgen.shape">duembgen.shape</a></code>, also <a href="#topic+SCov">spatial sign and rank covariance matrices</a> and <a href="#topic+spatial.rank">spatial signs and ranks</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3)
X&lt;-matrix(rnorm(1500),ncol=3)%*%t(A)
symmsign.shape(X)
to.shape(symmsign.shape(X),trace=3)
spatial.shape(X,score="sign")
spatial.shape(X,score="sign",fixed.loc=TRUE)
to.shape(A%*%t(A))
# one-step shape estimate based on spatial ranks and covariance matrix:
spatial.shape(X,score="rank",init=cov(X),steps=1)
symmsign.shape.inc(X, m=5)
</code></pre>

<hr>
<h2 id='Spatial+20location'>Multivariate location estimates based on spatial signs and signed ranks</h2><span id='topic+ae.hl.estimate'></span><span id='topic+ae.spatial.median'></span><span id='topic+spatial.location'></span>

<h3>Description</h3>

<p> Iterative algorithms to find spatial median, multivariate Hodges-Lehmann estimate of
location, their affine equivariant versions and k-step versions of these. </p>


<h3>Usage</h3>

<pre><code class='language-R'>
spatial.location(X, score = c("sign", "signrank"), init = NULL, 
shape = TRUE, steps = Inf, maxiter = 500, eps = 1e-6, 
na.action = na.fail) 

ae.spatial.median(X, init = NULL, shape = TRUE, steps = Inf, 
maxiter = 500, eps = 1e-6, na.action = na.fail)

ae.hl.estimate(X, init = NULL, shape = TRUE, steps = Inf, 
maxiter = 500, eps = 1e-06, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Spatial+2B20location_+3A_x">X</code></td>
<td>
<p>a matrix or a data frame</p>
</td></tr>
<tr><td><code id="Spatial+2B20location_+3A_score">score</code></td>
<td>
<p>a character string indicating which transformation of the observations should be used</p>
</td></tr>
<tr><td><code id="Spatial+2B20location_+3A_init">init</code></td>
<td>
<p>an optional vector giving the initial point of the iteration</p>
</td></tr>
<tr><td><code id="Spatial+2B20location_+3A_shape">shape</code></td>
<td>
<p>logical, or a matrix. See details</p>
</td></tr>
<tr><td><code id="Spatial+2B20location_+3A_steps">steps</code></td>
<td>
<p>fixed number of iteration steps to take, if <code>Inf</code> iteration is repeated until convergence (or until <code>maxiter</code> steps)</p>
</td></tr>
<tr><td><code id="Spatial+2B20location_+3A_eps">eps</code></td>
<td>
<p>tolerance for convergence</p>
</td></tr>
<tr><td><code id="Spatial+2B20location_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iteration steps</p>
</td></tr>
<tr><td><code id="Spatial+2B20location_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spatial median and Hodges-Lehmann estimator (spatial median of the pairwise differences) are not affine equivariant. Affine
equivariance can be achieved by simultaneously estimating the
corresponding shape, as proposed for the spatial median by
Hettmansperger and Randles (2002). For spatial median the corresponding
shape is <code><a href="#topic+signs.shape">signs.shape</a></code> and for the Hodges-Lehmann estimate it
is <code><a href="#topic+signrank.shape">signrank.shape</a></code>.
</p>
<p><code>spatial.location</code> is a wrapper function for a unified access to
both location estimates. The choice of estimate is done via
<code>score</code>:
</p>

<ul>
<li> <p><code>"sign"</code> for spatial median 
</p>
</li>
<li> <p><code>"signrank"</code> for Hodges-Lehmann estimate 
</p>
</li></ul>

<p>If a matrix (must be symmetric and positive definite, but this is not
checked) is given as <code>shape</code> the location estimate is found with
respect to that shape and no further shape estimation is done. If a
logical <code>TRUE</code> is given as <code>shape</code> the shape is estimated
and consequently the affine equivariant version of the location
estimate is found.  If <code>shape</code> is <code>FALSE</code> then shape
estimation is not done and the non affine equivariant versions of the
location estimate, that is the spatial median and the Hodges-Lehmann estimate are found.
</p>


<h3>Value</h3>

<p>The estimate vector with the (final estimate of or given) shape matrix 
as attribute <code>"shape"</code>.
</p>


<h3>Author(s)</h3>

<p>Seija Sirkia, <a href="mailto:seija.sirkia@iki.fi">seija.sirkia@iki.fi</a>, Jari Miettinen, <a href="mailto:jari.p.miettinen@aalto.fi">jari.p.miettinen@aalto.fi</a></p>


<h3>References</h3>

<p>Hettmansperger, T. and Randles, R. (2002) A Practical Affine Equivariant Multivariate Median, Biometrika, 89, pp. 851-860</p>


<h3>See Also</h3>

<p><code><a href="ICSNP.html#topic+spatial.median">spatial.median</a></code>, <code><a href="#topic+signrank.shape">signrank.shape</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3)
X&lt;-matrix(rnorm(3000),ncol=3)%*%t(A)
spatial.location(X,score="signrank")
spatial.location(X,score="sign")
#compare with:
colMeans(X)
ae.hl.estimate(X,shape=A%*%t(A))
ae.hl.estimate(X,shape=FALSE)
</code></pre>

<hr>
<h2 id='Spatial+20sign+20and+20rank+20covariance+20matrices'>Spatial sign and rank covariance matrices</h2><span id='topic+SCov'></span><span id='topic+SSCov'></span><span id='topic+RCov'></span><span id='topic+SRCov'></span>

<h3>Description</h3>

<p>Functions to compute spatial sign, spatial symmetrized sign, spatial rank and 
spatial signed rank covariance matrices 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCov(X, location = NULL, na.action = na.fail)
SSCov(X, na.action = na.fail)
RCov(X, na.action = na.fail)
SRCov(X, location = NULL, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Spatial+2B20sign+2B20and+2B20rank+2B20covariance+2B20matrices_+3A_x">X</code></td>
<td>
<p>matrix or a data frame</p>
</td></tr>
<tr><td><code id="Spatial+2B20sign+2B20and+2B20rank+2B20covariance+2B20matrices_+3A_location">location</code></td>
<td>
<p>numeric vector (may be missing)</p>
</td></tr>
<tr><td><code id="Spatial+2B20sign+2B20and+2B20rank+2B20covariance+2B20matrices_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions compute the matrices of the form
</p>
<p style="text-align: center;"><code class="reqn">
ave \{S(x_i) S^T(x_i)\}
</code>
</p>

<p>where <code class="reqn">S(x_i)</code> are the appropriate scores of the data:
spatial signs, spatial symmetrized signs, spatial ranks or spatial
signed ranks. These are the so called outer standardization matrices
of location etc. tests based on spatial signs and ranks. They are
not affine equivariant.
</p>
<p><code>SCov</code> and <code>SRCov</code> require a location vector with respect
to which they are computed. If none is provided, <code>SCov</code> uses 
spatial median and <code>SRCov</code> uses Hodges-Lehmann estimator.
</p>


<h3>Author(s)</h3>

<p>Seija Sirkia, <a href="mailto:seija.sirkia@iki.fi">seija.sirkia@iki.fi</a></p>


<h3>References</h3>

<p><cite>Visuri, S., Koivunen, V. and Oja, H. (2000). Sign and rank covariance matrices. <em>J. Statistical Planning and Inference</em>, 91, 557-575.</cite></p>


<h3>See Also</h3>

<p><a href="#topic+spatial.rank">spatial
signs and ranks</a>, <a href="#topic+rank.shape">corresponding shape matrices</a>
(inner standardization matrices)</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3)
X&lt;-matrix(rt(150,1),ncol=3)%*%t(A) 
SCov(X) 
SSCov(X) 
RCov(X) 
SRCov(X)
to.shape(A%*%t(A),trace=1) 
</code></pre>

<hr>
<h2 id='Spatial+20signs+2C+20symmetrized+20signs+2C+20ranks+20and+20signed+20ranks'>Spatial signs, symmetrized signs, ranks and signed ranks</h2><span id='topic+spatial.signs'></span><span id='topic+spatial.rank'></span><span id='topic+spatial.symmsign'></span><span id='topic+spatial.signrank'></span>

<h3>Description</h3>

<p>Functions to compute spatial signs, symmetrized signs, ranks and
signed ranks.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.signs(X, center = TRUE, shape = TRUE, 
na.action = na.fail,...)
spatial.symmsign(X, shape = TRUE, na.action = na.fail, ...)
spatial.rank(X, shape = TRUE, na.action = na.fail, ...)
spatial.signrank(X, center = TRUE, shape = TRUE, 
na.action = na.fail,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Spatial+2B20signs+2B2C+2B20symmetrized+2B20signs+2B2C+2B20ranks+2B20and+2B20signed+2B20ranks_+3A_x">X</code></td>
<td>
<p>a matrix or a data frame</p>
</td></tr>
<tr><td><code id="Spatial+2B20signs+2B2C+2B20symmetrized+2B20signs+2B2C+2B20ranks+2B20and+2B20signed+2B20ranks_+3A_center">center</code></td>
<td>
<p>a vector or a logical, see details</p>
</td></tr>
<tr><td><code id="Spatial+2B20signs+2B2C+2B20symmetrized+2B20signs+2B2C+2B20ranks+2B20and+2B20signed+2B20ranks_+3A_shape">shape</code></td>
<td>
<p>a matrix or a logical, see details</p>
</td></tr>
<tr><td><code id="Spatial+2B20signs+2B2C+2B20symmetrized+2B20signs+2B2C+2B20ranks+2B20and+2B20signed+2B20ranks_+3A_...">...</code></td>
<td>
<p>arguments that can be passed on to function used for the
estimation of shape.</p>
</td></tr>
<tr><td><code id="Spatial+2B20signs+2B2C+2B20symmetrized+2B20signs+2B2C+2B20ranks+2B20and+2B20signed+2B20ranks_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The spatial signs of an observed vector is simply the
vector, possibly affinely transformed first, multiplied by its
Euclidian length. See <code><a href="ICSNP.html#topic+spatial.sign">spatial.sign</a></code> for a precise
definition. Symmetrized spatial signs are the spatial signs of the pairwise
differences of the data 
</p>
<p style="text-align: center;"><code class="reqn">||x_i-x_j||^{-1}(x_i-x_j)</code>
</p>

<p>(there are <code>n</code> over 2 of these). Spatial
rank of an observation is the average of the signs of the differences
of that observation and the others:
</p>
<p style="text-align: center;"><code class="reqn">R(x_i)=ave_j\{||x_i-x_j||^{-1}(x_i-x_j)\}</code>
</p>

<p>Spatial signed rank of an observation is defined as
</p>
<p style="text-align: center;"><code class="reqn">Q(x_i)=(R(x_i)+ave_j\{||x_i+x_j||^{-1}(x_i+x_j)\})/2</code>
</p>

<p>If a numerical value is given for <code>shape</code> and/or <code>center</code>
these are used to transform the data before the computation of signs
or ranks. A logical <code>TRUE</code> indicates that the shape or center should be
estimated. In this case an affine transformation that makes the
resulting signs or ranks have a covariance matrix equal or
proportional to the identity matrix and centerd on the origin is
found. A logical <code>FALSE</code> indicates that the null value, that is, the
identity matrix or the origin, should be used. Note that only signed
ranks depend on a center.
</p>
<p>The value of shape and/or location used are returned as attributes.
</p>


<h3>Author(s)</h3>

<p>Seija Sirkia, <a href="mailto:seija.sirkia@iki.fi">seija.sirkia@iki.fi</a></p>


<h3>References</h3>

<p><cite>Visuri, S., Koivunen, V. and Oja, H. (2000). Sign and rank covariance matrices. <em>J. Statistical Planning and Inference</em>, 91, 557-575.</cite></p>


<h3>See Also</h3>

<p><code><a href="ICSNP.html#topic+spatial.sign">spatial.sign</a></code> for the signs, <a href="#topic+rank.shape">spatial sign and rank covariance matrices</a> and <code><a href="#topic+spatial.shape">spatial.shape</a></code> for the standardizing transformations</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1,2,-3,4),ncol=2)
X&lt;-matrix(rnorm(100),ncol=2)%*%t(A)
def.par&lt;-par(no.readonly=TRUE) # for resetting
layout(matrix(1:4,ncol=2,nrow=2,byrow=TRUE))
plot(X,col=c(2,rep(1,19)))
plot(spatial.symmsign(X),col=c(2,rep(1,19)),xlim=c(-1,1),ylim=c(-1,1))
theta&lt;-seq(0,2*pi,length=1000)
lines(sin(theta),cos(theta))
plot(spatial.rank(X),col=c(2,rep(1,19)),xlim=c(-1,1),ylim=c(-1,1))
lines(sin(theta),cos(theta))
plot(spatial.signrank(X),col=c(2,rep(1,19)),xlim=c(-1,1),ylim=c(-1,1))
lines(sin(theta),cos(theta))
par(def.par)
</code></pre>

<hr>
<h2 id='Sphericity+20tests'>Sphericity tests</h2><span id='topic+sr.sphere.test'></span>

<h3>Description</h3>

<p>Tests of sphericity based on spatial signs and spatial signs of pairwise 
differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> sr.sphere.test(X, score = c("sign", "symmsign"), shape = NULL,
na.action = na.fail) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sphericity+2B20tests_+3A_x">X</code></td>
<td>
<p>a matrix or a data frame</p>
</td></tr>
<tr><td><code id="Sphericity+2B20tests_+3A_score">score</code></td>
<td>
<p>a character string indicating which transformation of the observations should be used</p>
</td></tr>
<tr><td><code id="Sphericity+2B20tests_+3A_shape">shape</code></td>
<td>
<p>a matrix with which the data should be standardized before the sphericity test</p>
</td></tr>
<tr><td><code id="Sphericity+2B20tests_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is for a null hypothesis of the form &ldquo;true
shape matrix is equal to the identity matrix&rdquo;. Effectively, giving a
matrix as <code>shape</code> will produce a test of whether the true shape
is equal (in fact, proportional, since the scale of <code>shape</code> will
have no effect) to it. In that case the test will still be for
sphericity but the data is standardized beforehand.</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the statistic</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the shape (always <code>diag(p)</code> where <code>p</code> is the number of dimensions)</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Seija Sirkia, <a href="mailto:seija.sirkia@iki.fi">seija.sirkia@iki.fi</a></p>


<h3>References</h3>

<p><cite>Sirkia et al. (2009) Tests and estimates of shape based on spatial signs and ranks. <em>Journal of Nonparametric Statistics</em>, 21, 155-176.</cite></p>


<h3>See Also</h3>

<p><a href="#topic+SCov">sign and rank covariance matrices</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3)
X&lt;-matrix(rnorm(600),ncol=3)%*%t(A)
sr.sphere.test(X,score="sign")
</code></pre>

<hr>
<h2 id='symm.mvtmle'>Symmetrized M-estimators of scatter with the weights of the t-distribution</h2><span id='topic+symm.mvtmle'></span><span id='topic+symm.mvtmle.inc'></span>

<h3>Description</h3>

<p>Iterative algorithms to estimate symmetrized M-estimators of scatter using weights of the t-distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symm.mvtmle(X, nu=1, init=NULL, steps=Inf, eps=1e-6, 
maxiter=100, na.action = na.fail)

symm.mvtmle.inc(X, nu=1, m=10, init=NULL, steps=Inf, permute=TRUE,
eps=1e-6, maxiter=100, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symm.mvtmle_+3A_x">X</code></td>
<td>
<p>a matrix or a data frame</p>
</td></tr>
<tr><td><code id="symm.mvtmle_+3A_nu">nu</code></td>
<td>
<p>the degrees of freedom of the t-distribution. The default is 1. Must be larger than 0.</p>
</td></tr>
<tr><td><code id="symm.mvtmle_+3A_init">init</code></td>
<td>
<p>an optional starting value for scatter</p>
</td></tr>  
<tr><td><code id="symm.mvtmle_+3A_steps">steps</code></td>
<td>
<p>fixed number of iteration steps to take, if <code>Inf</code> iteration is repeated until convergence (or until <code>maxiter</code> steps)</p>
</td></tr>
<tr><td><code id="symm.mvtmle_+3A_m">m</code></td>
<td>
<p>a parameter in <code>symm.mvtmle.inc</code> which defines how many pairwise differences are used, see details.</p>
</td></tr>
<tr><td><code id="symm.mvtmle_+3A_permute">permute</code></td>
<td>
<p>logical in <code>symm.mvtmle.inc</code> which determines whether the rows of <code>X</code> are permuted randomly, see details.</p>
</td></tr>
<tr><td><code id="symm.mvtmle_+3A_eps">eps</code></td>
<td>
<p>tolerance for convergence</p>
</td></tr>
<tr><td><code id="symm.mvtmle_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iteration steps. Ignored if <code>steps</code> 
is finite</p>
</td></tr> 
<tr><td><code id="symm.mvtmle_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's. Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>symm.mvtmle</code> computes M-estimator of scatter using weights of the t-distribution and pairwise
differences of the data. Hence, location estimation is not needed.   
</p>
<p><code>symm.mvtmle.inc</code> is a computationally lighter estimator to approximate symmetrized M-estimator of scatter which uses weights of the t-distribution. 
Only a subset of the pairwise differences are used in the computation in the incomplete case. The magnitude of the subset used is controlled
by the argument <code>m</code> which is half of the number of how many differences each observation is part of. Differences of successive observations are used, 
and therefore random permutation of the rows of <code>X</code> is suggested and is the default choice in the function. For details see Miettinen et al., 2016.
</p>


<h3>Value</h3>

<p><code>symm.mvtmle</code> returns a matrix.
</p>
<p><code>symm.mvtmle.inc</code> returns a matrix.
</p>


<h3>Author(s)</h3>

<p>Jari Miettinen, <a href="mailto:jari.p.miettinen@aalto.fi">jari.p.miettinen@aalto.fi</a>, <br />
Klaus Nordhausen, <a href="mailto:klaus.nordhausen@tuwien.ac.at">klaus.nordhausen@tuwien.ac.at</a>
</p>


<h3>References</h3>

<p><cite>Huber, P.J. (1981), Robust Statistics, Wiley, New York.</cite>
</p>
<p><cite>Sirkia, S., Taskinen, S., Oja, H. (2007) Symmetrised M-estimators of scatter. <em>Journal of Multivariate Analysis</em>, 98, 1611-1629.</cite>
</p>
<p><cite>Duembgen, L., Pauly, M., Schweizer, T. (2015) M-Functionals of multivariate scatter.
<em>Statistics Surveys 9</em>, 32-105.</cite>
</p>
<p><cite>Miettinen, J., Nordhausen, K., Taskinen, S., Tyler, D.E. (2016) On the computation of symmetrized M-estimators of scatter. <em>In Agostinelli, C. Basu, A., Filzmoser, P. and Mukherje, D. (editors) &rdquo;Recent Advances in Robust Statistics: Theory and Application&rdquo;</em>, 131-149, Springer India, New Delhi.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3)
X&lt;-matrix(rnorm(1500),ncol=3)%*%t(A)
symm.mvtmle(X, nu=2)
symm.mvtmle.inc(X, nu=2, m=20)
</code></pre>

<hr>
<h2 id='to.shape'>Rescale a matrix to a shape matrix</h2><span id='topic+to.shape'></span>

<h3>Description</h3>

<p>This function rescales a given matrix such that its determinant, trace or the value of the first diagonal element meets a criteria.</p>


<h3>Usage</h3>

<pre><code class='language-R'>to.shape(M, determ, trace, first)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to.shape_+3A_m">M</code></td>
<td>
<p>a matrix to be scaled</p>
</td></tr>
<tr><td><code id="to.shape_+3A_determ">determ</code></td>
<td>
<p>required value for determinant</p>
</td></tr>
<tr><td><code id="to.shape_+3A_trace">trace</code></td>
<td>
<p>required value for trace</p>
</td></tr>
<tr><td><code id="to.shape_+3A_first">first</code></td>
<td>
<p>required value of the first diagonal element</p>
</td></tr>
</table>


<h3>Details</h3>

<p> If <code>determ</code>, <code>trace</code> or <code>first</code> is given
<code>M</code> is scaled such that its determinant, trace or first diagonal
element, respectively, equals that value. If none of the three is
given <code>M</code> is scaled such that its determinant equals one. If more
than one criteria is given the first of them is used and the others
silently ignored.  </p>


<h3>Value</h3>

<p>The rescaled matrix
</p>


<h3>Note</h3>

<p>A shape matrix is symmetric and positive definite square matrix. In order for the result to be such the argument matrix <code>M</code> should also be symmetric and positive definite square matrix. However, the function does not check for this. Expect to see errors if <code>M</code> is of inappropriate type.</p>


<h3>Author(s)</h3>

<p>Seija Sirkia, <a href="mailto:seija.sirkia@iki.fi">seija.sirkia@iki.fi</a></p>


<h3>References</h3>

<p>Paindaveine D. (2008) A Canonical Definition of Shape. Statistics and Probability Letters 78, 2240-2247</p>


<h3>Examples</h3>

<pre><code class='language-R'>(A&lt;-matrix(c(1,2,-3,4,3,-2,-1,0,4),ncol=3))
to.shape(A%*%t(A))
to.shape(A%*%t(A),trace=3)
to.shape(A%*%t(A),first=1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
