<!DOCTYPE html><html><head><title>Help for package coconots</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coconots}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cocoBoot'><p>Bootstrap Based Model Assessment Procedure</p></a></li>
<li><a href='#coconots-package'>
<p>Concolution-closed Models for Time Series</p></a></li>
<li><a href='#cocoPit'><p>Probability Integral Transform Based Model Assessment Procedure</p></a></li>
<li><a href='#cocoReg'><p>cocoReg</p></a></li>
<li><a href='#cocoResid'><p>Residual Based Model Assessment Procedure</p></a></li>
<li><a href='#cocoScore'><p>Scoring Rule Based Model Assessment Procedure</p></a></li>
<li><a href='#cocoSim'><p>Simulation of Count Time Series</p></a></li>
<li><a href='#cuts'>
<p>Time Series of Monthly Counts of Claimants Collecting Wage Loss Benefit for Injuries in</p>
the Workplace</a></li>
<li><a href='#downloads'>
<p>Time Series of Daily Downloads of a TeX-Editor</p></a></li>
<li><a href='#goldparticle'>
<p>Time Series of Gold particles Counts in a well-efined Colloidal</p>
Solution</a></li>
<li><a href='#installJuliaPackages'><p>installJuliaPackages</p></a></li>
<li><a href='#predict.coco'><p>K-Step Ahead Forecast Bootstrapping</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#setJuliaSeed'><p>Set Seed for Julia's Random Number Generator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Convolution-Closed Models for Count Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-01</td>
</tr>
<tr>
<td>Description:</td>
<td>Useful tools for fitting, validating, and forecasting of practical convolution-closed time series models for low counts are provided. Marginal distributions of the data can be modeled via Poisson and Generalized Poisson innovations. Regression effects can be modelled via time varying innovation rates. The models are described in Jung and Tremayne (2011) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9892.2010.00697.x">doi:10.1111/j.1467-9892.2010.00697.x</a>&gt; and the model assessment tools are presented in Czado et al. (2009) &lt;<a href="https://doi.org/10.1111%2Fj.1541-0420.2009.01191.x">doi:10.1111/j.1541-0420.2009.01191.x</a>&gt;, Gneiting and Raftery (2007) &lt;<a href="https://doi.org/10.1198%2F016214506000001437">doi:10.1198/016214506000001437</a>&gt; and, Tsay (1992) &lt;<a href="https://doi.org/10.2307%2F2347612">doi:10.2307/2347612</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, forecast, numDeriv, HMMpa, stats, ggplot2, utils,
matrixStats, JuliaConnectoR</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, StanHeaders (&ge; 2.21.0), RcppParallel (&ge; 5.0.1)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-01 14:56:49 UTC; manuel</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel Huth [aut, cre],
  Robert C. Jung [aut],
  Andy Tremayne [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Manuel Huth &lt;manuel.huth@yahoo.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-01 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cocoBoot'>Bootstrap Based Model Assessment Procedure</h2><span id='topic+cocoBoot'></span>

<h3>Description</h3>

<p>Model checking procedure emphasizing reproducibility in fitted models to provide an overall evaluation of fit as proposed by Tsay (1992).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocoBoot(
  coco,
  numb.lags = 21,
  rep.Bootstrap = 1000,
  conf.alpha = 0.05,
  julia = FALSE,
  julia_seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cocoBoot_+3A_coco">coco</code></td>
<td>
<p>An object of class coco</p>
</td></tr>
<tr><td><code id="cocoBoot_+3A_numb.lags">numb.lags</code></td>
<td>
<p>Number of lags for which to compute autocorrelations</p>
</td></tr>
<tr><td><code id="cocoBoot_+3A_rep.bootstrap">rep.Bootstrap</code></td>
<td>
<p>Number of bootstrap replicates to use</p>
</td></tr>
<tr><td><code id="cocoBoot_+3A_conf.alpha">conf.alpha</code></td>
<td>
<p>Confidence level for the quantile intervals</p>
</td></tr>
<tr><td><code id="cocoBoot_+3A_julia">julia</code></td>
<td>
<p>if TRUE, the bootstrap is run with Julia.</p>
</td></tr>
<tr><td><code id="cocoBoot_+3A_julia_seed">julia_seed</code></td>
<td>
<p>Seed for the julia implementation. Only used if julia equals TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes bootstrap confidence intervals for the autocorrelations of a fitted model.
</p>


<h3>Value</h3>

<p>an object of class cocoBoot. It contains the bootstraped confidence intervals
of the autocorrelations and information on the model specifications.
</p>


<h3>References</h3>

<p>Tsay, R. S. (1992) Model checking via parametric bootstraps in time series analysis. <em>Applied Statistics</em> <b>41</b>, 1&ndash;15.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- 1
alpha &lt;- 0.4
set.seed(12345)
data &lt;- cocoSim(order = 1, type = "Poisson", par = c(lambda, alpha), length = 100)
fit &lt;- cocoReg(order = 1, type = "Poisson", data = data)

#assessment using bootstrap - R implementation
boot_r &lt;- cocoBoot(fit, rep.Bootstrap=400)
</code></pre>

<hr>
<h2 id='coconots-package'>
Concolution-closed Models for Time Series
</h2><span id='topic+Concolution-closed+20Models+20for+20Count+20Time+20Series'></span><span id='topic+coconots-package'></span>

<h3>Description</h3>

<p>Functions to analyse time series consisting of low counts are provided. The 
focus in the current version is on practical models that can  capture first 
and higher-order dependence based on the work of Joe (1996). Both equidispersed 
and overdispersed marginal distributions of data can be modelled. Regression 
effects can be included. Fast and efficient procedures for likelihood based 
inference and probabilistic forecasting are provided as well as useful tools 
for model validation and diagnostics. 
</p>


<h3>Details</h3>

<p>The package allows simulation of convolution-closed count time series models with the <code><a href="#topic+cocoSim">cocoSim</a></code>
function. Model fitting is performed with the <code><a href="#topic+cocoReg">cocoReg</a></code> routine. By passing a cocoReg-type object,
the S3 method <code>predict</code> computes the one-step ahead forecasting distribution. <code><a href="#topic+cocoBoot">cocoBoot</a></code>, <code><a href="#topic+cocoPit">cocoPit</a></code>,
<code><a href="#topic+cocoScore">cocoScore</a></code>, and <code><a href="#topic+cocoResid">cocoResid</a></code> provide routines for model assessment.
The main usage of the package is illustrated within the cocoReg function chapter. For more details
and examples of the functions see the respective sections within this vignette. 
</p>
<p>By default, our functions make use of an RCPP implementation. However, users
with a running Julia installation can choose to call Julia in the background
to run their functions by specifiying it in the R function input. This option
is particularly useful for the regression (<code><a href="#topic+cocoReg">cocoReg</a></code>), where a complex likelihood function
must be numerically evaluated to obtain parameter estimates. By leveraging
Julia's automatic differentiation capabilities,
our functions can take advantage of numerical gradients,
leading to increased numerical stability and faster convergence.
</p>
<p>As we find both, the Julia and RCPP
implementations produce qualitatively similar results in all our tests, we have decided to use the RCPP implementation as
the default option to make our package accessible to non-Julia users.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Manuel Huth &lt;manuel.huth@yahoo.com&gt;
</p>


<h3>References</h3>

<p>Czado, C., Gneiting, T. and Held, L. (2009) Predictive model assessment for count data. <em>Biometrics</em> <b>65</b>, 1254&ndash;61.
</p>
<p>Gneiting, T. and Raftery, A. E. (2007) Strictly proper scoring rules, prediction, and estimation. <em>Journal
of the American Statistical Association</em>, 102:359-378.
</p>
<p>R.C. Jung, A.R. Tremayne (2006) Coherent forecasting in integer time series models. 
<em>International Journal of Forecasting</em> <b>22</b>, 223&ndash;238
</p>
<p>Jung, R. C. and Tremayne, A. R. (2011) Convolution-closed models for count time series with applications. <em>Journal of Time Series Analysis</em>, <b>32</b>, 3, 268&ndash;280.
</p>
<p>Jung, Robert C., Brendan P. M. McCabe, and Andrew R. Tremayne. (2016). Model validation and diagnostics. <em>In Handbook of Discrete
Valued Time Series</em>. Edited by Richard A. Davis, Scott H. Holan, Robert Lund and Nalini Ravishanker. Boca Raton: Chapman and
Hall, pp. 189&ndash;218.
</p>
<p>Joe, H. (1996) Time series models with univariate margins in the convolution-closed infinitely divisible class. <em>Journal of Applied Probability</em>, 664&ndash;677.
</p>
<p>Tsay, R. S. (1992) Model checking via parametric bootstraps in time series analysis. <em>Applied Statistics</em> <b>41</b>, 1&ndash;15.
</p>
<p>Westgren, A. (1916) Die Veraenderungsgeschwindigkeit der lokalen
Teilchenkonzentration in kollioden Systemen (Erste Mitteilung).
<em>Arkiv foer Matematik, Astronomi och Fysik</em>, <b>11</b>, 1&ndash;24.
</p>

<hr>
<h2 id='cocoPit'>Probability Integral Transform Based Model Assessment Procedure</h2><span id='topic+cocoPit'></span>

<h3>Description</h3>

<p>Computes the probability integral transform (PIT) and provides
the non-randomized PIT histogram for assessing absolute performance of a
fitted model as proposed by Czado et al. (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocoPit(coco, J = 10, conf.alpha = 0.05, julia = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cocoPit_+3A_coco">coco</code></td>
<td>
<p>An object of class coco</p>
</td></tr>
<tr><td><code id="cocoPit_+3A_j">J</code></td>
<td>
<p>Number of bins for the histogram (default: 10)</p>
</td></tr>
<tr><td><code id="cocoPit_+3A_conf.alpha">conf.alpha</code></td>
<td>
<p>Confidence level for the confidence bands.</p>
</td></tr>
<tr><td><code id="cocoPit_+3A_julia">julia</code></td>
<td>
<p>if TRUE, the PIT is computed with Julia.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adequacy of a distributional assumption for a model is checked by
checking the cumulative non-randomized PIT distribution for uniformity.
A useful graphical device is the PIT histogram, which displays this
distribution to J equally spaced bins. We supplement the graph by
incorporating approximately <code class="reqn">100(1 - \alpha)\%</code> confidence intervals obtained
from a standard chi-square goodness-of-fit test of the null hypothesis that
the J bins of the histogram are drawn from a uniform distribution.
For details, see Jung, McCabe and Tremayne (2016).
</p>


<h3>Value</h3>

<p>an object of class cocoPit. It contains the The probability integral
transform values, its p-values and information on the model specifications.
</p>


<h3>Author(s)</h3>

<p>Manuel Huth
</p>


<h3>References</h3>

<p>Czado, C., Gneiting, T. and Held, L. (2009) Predictive model assessment for count data. <em>Biometrics</em> <b>65</b>, 1254&ndash;61.
</p>
<p>Jung, Robert C., Brendan P. M. McCabe, and Andrew R. Tremayne. (2016). Model validation and diagnostics. <em>In Handbook of Discrete
Valued Time Series</em>. Edited by Richard A. Davis, Scott H. Holan, Robert Lund and Nalini Ravishanker. Boca Raton: Chapman and
Hall, pp. 189&ndash;218.
</p>
<p>Jung, R. C. and Tremayne, A. R. (2011) Convolution-closed models for count time series with applications. <em>Journal of Time Series Analysis</em>, <b>32</b>, 3, 268&ndash;280.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- 1
alpha &lt;- 0.4
set.seed(12345)
data &lt;- cocoSim(order = 1, type = "Poisson", par = c(lambda, alpha), length = 100)
#julia_installed = TRUE ensures that the fit object
#is compatible with the julia cocoPit implementation 
fit &lt;- cocoReg(order = 1, type = "Poisson", data = data)

#PIT R implementation
pit_r &lt;- cocoPit(fit)
</code></pre>

<hr>
<h2 id='cocoReg'>cocoReg</h2><span id='topic+cocoReg'></span>

<h3>Description</h3>

<p>The function fits first and second order (Generalized) Poisson Autoregressive (G)PAR
models presented in (Jung and Tremayne, 2010). Autoregressive dependence on past counts is modelled by a special random operator that not only preserve integer status, but also, via the property of closure under
convolution, ensure that the marginal distribution of the observed counts is from the same family as the innovations. 
The models can be thought of as stationary Markov chains of finite order, where the distribution of the innovations can either be Poisson or Generalized Poisson, where the latter can account for overdispersed data.
Maximum likelihood is used for estimation and the user can choose to include linear constraints or
not. If linear constraints are not included, it cannot be guaranteed that the parameters will lie in the
theoretically feasible parameter space, but the optimization process might be faster.
The function uses method of moments estimators to obtain starting values for the numerical optimization,
but the user can also specify their own starting values if desired. 
</p>
<p>If Julia is installed, the user can choose whether the optimization is run in Julia
which might faster yield results and increased numeric stability due to the use of automatic differentiation.
See details for more information on the Julia implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocoReg(
  type,
  order,
  data,
  xreg = NULL,
  constrained.optim = TRUE,
  b.beta = -10,
  start = NULL,
  start.val.adjust = TRUE,
  method_optim = "Nelder-Mead",
  replace.start.val = 1e-05,
  iteration.start.val = 0.6,
  method.hessian = "Richardson",
  cores = 2,
  julia = FALSE,
  julia_installed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cocoReg_+3A_type">type</code></td>
<td>
<p>character string indicating the type of model to be fitted</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_order">order</code></td>
<td>
<p>integer vector indicating the order of the model</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_data">data</code></td>
<td>
<p>time series data to be used in the analysis</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_xreg">xreg</code></td>
<td>
<p>optional matrix of explanatory variables for use in a regression model</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_constrained.optim">constrained.optim</code></td>
<td>
<p>logical indicating whether optimization should be constrained, currently only available in the R version</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_b.beta">b.beta</code></td>
<td>
<p>numeric value indicating the lower bound for the parameters of the explanatory variables for the optimization, currently only available in the R version</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_start">start</code></td>
<td>
<p>optional numeric vector of starting values for the optimization</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_start.val.adjust">start.val.adjust</code></td>
<td>
<p>logical indicating whether starting values should be adjusted, currently only available in the R version</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_method_optim">method_optim</code></td>
<td>
<p>character string indicating the optimization method to be used, currently only available in the R version. In the julia implementation this is by default the LBFGS algorithm</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_replace.start.val">replace.start.val</code></td>
<td>
<p>numeric value indicating the value to replace any invalid starting values, currently only available in the R version</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_iteration.start.val">iteration.start.val</code></td>
<td>
<p>numeric value indicating the proportion of the interval to use as the new starting value, currently only available in the R version</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_method.hessian">method.hessian</code></td>
<td>
<p>character string indicating the method to be used to approximate the Hessian matrix, currently only available in the R version</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_cores">cores</code></td>
<td>
<p>numeric indicating the number of cores to use, currently only available in the R version</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_julia">julia</code></td>
<td>
<p>if TRUE, the model is estimated with Julia. This can improve the speed significantly since Julia makes use of derivatives using autodiff. In this case, only type, order, data, xreg, and start are used as other inputs.</p>
</td></tr>
<tr><td><code id="cocoReg_+3A_julia_installed">julia_installed</code></td>
<td>
<p>if TRUE, the model R output will contain a Julia compatible output element.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let a time series of counts be <code class="reqn">\{X_t\}</code> and be <code class="reqn">R(\cdot)</code> a random operator that differs between model specifications.
For more details on the random operator, see Jung and Tremayne (2011) and Joe (1996).
The general first-order model is of the form
</p>
<p style="text-align: center;"><code class="reqn">X_t = R(X_{t-1}) + I_t,</code>
</p>

<p>and the general second-order model of the form
</p>
<p style="text-align: center;"><code class="reqn">X_t = R(X_{t-1}, X_{t-2}) + I_t,</code>
</p>

<p>where <code class="reqn">I_t</code> are i.i.d Poisson (<code class="reqn">I_t \sim Po(\lambda_t)</code>) or Generalized
Poisson (<code class="reqn">I_t \sim GP(\lambda_t, \eta)</code>) innovations. Through closure under convolution
the marginal distributions of <code class="reqn">\{X_t\}</code> are therefore Poisson or Generalized Poisson distributions, respectively.
</p>
<p>If no covariates are used <code class="reqn">\lambda_t = \lambda</code> and if covariates are used
</p>
<p style="text-align: center;"><code class="reqn">\lambda_t = \exp{\left(\beta_0 + \sum_{j = 1}^k \beta_j \cdot z_{t,j} \right)},</code>
</p>

<p>whereby <code class="reqn">z_{t,j}</code> is the <code class="reqn">j</code>-th covariate at time <code class="reqn">t</code>.
</p>
<p>Standard errors are computed by the square root of the diagonal elements of the inverse Hessian.
</p>
<p>This function is implemented in 2 versions. The default runs on RCPP. 
An alternative version uses a Julia implementation which can be chosen by 
setting the argument julia to TRUE. In order to
use this feature, a running Julia installation is required on the system.
The RCPP implementation uses the derivative-free Nelder-Mead optimizer
to obtain parameter estimates. The Julia implementation makes use of Julia's
automatic differentiation in order to obtain gradients such that it can use the LBFGS algorithm for
optimization. This enhances the numeric stability of the optimization and yields 
an internal validation if both methods yield qualitatively same parameter estimates.
Furthermore, the Julia implementation can increase the computational speed
significantly, especially for large models. 
</p>
<p>The model assessment tools <code><a href="#topic+cocoBoot">cocoBoot</a></code>, <code><a href="#topic+cocoPit">cocoPit</a></code>, and <code><a href="#topic+cocoScore">cocoScore</a></code>
will use a Julia implementation as well, if the <code><a href="#topic+cocoReg">cocoReg</a></code> was run with Julia.
Additionally, one can make the RCPP output of <code><a href="#topic+cocoReg">cocoReg</a></code> compatible with the Julia
model assessments by setting julia_installed to true. In this case, the user can choose
between the RCPP and the Julia implementation for model assessment.
</p>


<h3>Value</h3>

<p>an object of class coco. It contains the parameter estimates, standard errors, the log-likelihood, 
and information on the model specifications. If Julia is used for parameter estimation or the Julia installation
parameter is set to TRUE, the results contain an additional Julia element that is called from the model Julia
assessment tools if they are run with the Julia implementation.
</p>


<h3>Author(s)</h3>

<p>Manuel Huth
</p>


<h3>References</h3>

<p>Jung, R. C. and Tremayne, A. R. (2011) Convolution-closed models for count timeseries with applications. <em>Journal of Time Series Analysis</em>, <b>32</b>, 3, 268&ndash;280.
</p>
<p>Joe, H. (1996) Time series models with univariate margins in the convolution-closed infinitely divisible class. <em>Journal of Applied Probability</em>, 664&ndash;677.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GP2 model without covariates
length &lt;- 1000
par &lt;- c(0.5,0.2,0.05,0.3,0.3)
data &lt;- cocoSim(order = 2, type = "GP", par = par, length = length)
fit &lt;- cocoReg(order = 2, type = "GP", data = data)

##Poisson1 model with covariates
length &lt;- 1000
period &lt;- 50
sin &lt;- sin(2*pi/period*(1:length))
cos &lt;- cos(2*pi/period*(1:length))
cov &lt;- cbind(sin, cos)
par &lt;- c(0.2, 0.2, -0.2)
data &lt;- cocoSim(order = 1, type = "Poisson", par = par, xreg = cov, length = length)
fit &lt;- cocoReg(order = 1, type = "Poisson", data = data, xreg = cov)
</code></pre>

<hr>
<h2 id='cocoResid'>Residual Based Model Assessment Procedure</h2><span id='topic+cocoResid'></span>

<h3>Description</h3>

<p>Calculates the (Pearson) residuals of a fitted model for model evaluation purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocoResid(coco, val.num = 1e-11)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cocoResid_+3A_coco">coco</code></td>
<td>
<p>An object of class &quot;coco</p>
</td></tr>
<tr><td><code id="cocoResid_+3A_val.num">val.num</code></td>
<td>
<p>A non-negative real number which is used to stop the calculation of</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pearson residuals are computed as the scaled
deviation of the observed count from its conditional expectation given the relevant 
past history, including covariates, if applicable. If a fitted model is correctly specified,
the Pearson residuals should exhibit mean zero, variance one, and no significant serial correlation.
</p>


<h3>Value</h3>

<p>a list that includes the (Pearson) residuals, conditional expectations, conditional variances,
and information on the model specifications.
</p>


<h3>Author(s)</h3>

<p>Manuel Huth
</p>

<hr>
<h2 id='cocoScore'>Scoring Rule Based Model Assessment Procedure</h2><span id='topic+cocoScore'></span>

<h3>Description</h3>

<p>The function calculates the log, quadratic and ranked probability scores for assessing relative performance of a fitted model as proposed by Czado et al. (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocoScore(coco, val.num = 1e-10, julia = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cocoScore_+3A_coco">coco</code></td>
<td>
<p>An object of class coco</p>
</td></tr>
<tr><td><code id="cocoScore_+3A_val.num">val.num</code></td>
<td>
<p>A non-negative real number which is used to stop the calculation
of the score in case of GP models. The default value is 1e-10</p>
</td></tr>
<tr><td><code id="cocoScore_+3A_julia">julia</code></td>
<td>
<p>if TRUE, the scores are computed with Julia.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Scoring rules assign a numerical score based on the predictive
distribution and the observed data  to measure the quality of probabilistic predictions.
They are provided here as a model selection tool and are computed as
averages over the relevant set of (in-sample) predictions. Scoring rules are, generally, negatively oriented
penalties that one seeks to minimize. The literature has developed a large number of scoring
rules and, unless there is a unique and clearly defined underlying decision problem,
there is no automatic choice of a (proper) scoring rule to be used in any given situation.
Therefore, the use of a variety of scoring rules may be appropriate to take advantage of
specific emphases and strengths. Three proper scoring rules
(for a definition of the concept of propriety see Gneiting and Raftery, 2007)
which Jung, McCabe and Tremayne (2016) found to be particularly useful are implemented.
For more information see the references listed below.
</p>


<h3>Value</h3>

<p>a list containing the log score, quadratic score and ranked probability score.
</p>


<h3>Author(s)</h3>

<p>Manuel Huth
</p>


<h3>References</h3>

<p>Czado, C. and Gneitling, T. and Held, L. (2009) Predictive Model Assessment for Count Data. <em>Biometrics</em>, <b>65</b>, 4, 1254&ndash;1261.
</p>
<p>Gneiting, T. and Raftery, A. E. (2007) Strictly proper scoring rules, prediction, and estimation. <em>Journal
of the American Statistical Association</em>, 102:359-378.
</p>
<p>Jung, Robert C., Brendan P. M. McCabe, and Andrew R. Tremayne. (2016). Model validation and diagnostics. <em>In Handbook of Discrete
Valued Time Series</em>. Edited by Richard A. Davis, Scott H. Holan, Robert Lund and Nalini Ravishanker. Boca Raton: Chapman and
Hall, pp. 189&ndash;218.
</p>
<p>Jung, R. C. and Tremayne, A. R. (2011) Convolution-closed models for count timeseries with applications. <em>Journal of Time Series Analysis</em>, <b>32</b>, 3, 268&ndash;280.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- 1
alpha &lt;- 0.4
set.seed(12345)
data &lt;- cocoSim(order = 1, type = "Poisson", par = c(lambda, alpha), length = 100)
#julia_installed = TRUE ensures that the fit object
#is compatible with the julia cocoScore implementation 
fit &lt;- cocoReg(order = 1, type = "Poisson", data = data)

#assessment using scoring rules - R implementation
score_r &lt;- cocoScore(fit)
</code></pre>

<hr>
<h2 id='cocoSim'>Simulation of Count Time Series</h2><span id='topic+cocoSim'></span>

<h3>Description</h3>

<p>The function generates a time series of low counts from the (G)PAR model class for a specified
innovation distribution, sample size, lag order,
and parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocoSim(
  type,
  order,
  par,
  length,
  xreg = NULL,
  init = NULL,
  julia = FALSE,
  julia_seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cocoSim_+3A_type">type</code></td>
<td>
<p>character, either &quot;Poisson&quot; or &quot;GP&quot; indicating the type of the innovation distribution</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_order">order</code></td>
<td>
<p>integer, either 1 or 2 indicating the order of the model</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_par">par</code></td>
<td>
<p>numeric vector, the parameters of the model, the number of elements
in the vector depends on the type and order specified.</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_length">length</code></td>
<td>
<p>integer, the number of observations in the generated time series</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_xreg">xreg</code></td>
<td>
<p>data.frame, data frame of control variables</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_init">init</code></td>
<td>
<p>numeric vector, initial data to use, default is NULL. See details
for more information on the usage.</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_julia">julia</code></td>
<td>
<p>If TRUE, the Julia implementation is used. In this case, init is ignored but it might be faster.</p>
</td></tr>
<tr><td><code id="cocoSim_+3A_julia_seed">julia_seed</code></td>
<td>
<p>Seed for the Julia implementation. Only used if Julia equals TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks for valid input of the type, order, parameters, and initial data
before generating the time series.
</p>
<p>The init parameter allows users to set a custom burn-in period
for the simulation. By default, when simulating with covariates, no burn-in
period is specified since there is no clear choice on the covariates.
However, the init argument gives users the flexibility to select an
appropriate burn-in period for the covariate case. One way to do this is to
simulate a time series using <code><a href="#topic+cocoSim">cocoSim</a></code> with appropriate covariates and pass the
resulting time series to the
init argument of a new <code><a href="#topic+cocoSim">cocoSim</a></code> run so that the first time series is used as
the burn-in period. 
If init is not specified for the covariate case, a warning will be returned
to prompt the user to specify a custom burn-in period. This helps ensure that
the simulation accurately captures the dynamics of the system being modeled.
</p>


<h3>Value</h3>

<p>a vector of the simulated time series.
</p>


<h3>Author(s)</h3>

<p>Manuel Huth
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- 1
alpha &lt;- 0.4
set.seed(12345)

# Simulate using the RCPP implementation
data_rcpp &lt;- cocoSim(order = 1, type = "Poisson", par = c(lambda, alpha), length = 100)
# Simulate using the Julia implementation
data_julia &lt;- cocoSim(order = 1, type = "Poisson", par = c(lambda, alpha), length = 100)
</code></pre>

<hr>
<h2 id='cuts'>
Time Series of Monthly Counts of Claimants Collecting Wage Loss Benefit for Injuries in
the Workplace
</h2><span id='topic+cuts'></span>

<h3>Description</h3>

<p>Monthly counts of claimants collecting wage loss benefit for injuries in
the workplace at one specific service delivery location of the Workers Compensation Board
of British Columbia, Canada in the period January 1985 to December 1994. Only injuries due to cuts and lacerations are considered. The data have been provided by Brendan McCabe. 
</p>

<hr>
<h2 id='downloads'>
Time Series of Daily Downloads of a TeX-Editor
</h2><span id='topic+downloads'></span>

<h3>Description</h3>

<p>The data represent the number of daily downloads of a TeX-editor between June 2006 and February
2007 and has a sample size of 267. The data have been provided by Christian Weiss. 
</p>

<hr>
<h2 id='goldparticle'>
Time Series of Gold particles Counts in a well-efined Colloidal
Solution
</h2><span id='topic+goldparticle'></span>

<h3>Description</h3>

<p>A sample of 370 counts of gold particles in a well-defined colloidal
solution at equidistant points in time, originally published
in Westgren (1916) and used in Jung and Tremanye (2006).  
</p>


<h3>Source</h3>

<p>R.C. Jung, A.R. Tremayne (2006) Coherent forecasting in integer time series models. 
<em>International Journal of Forecasting</em> <b>22</b>, 223&ndash;238
</p>
<p>Westgren, A. (1916) Die Veraenderungsgeschwindigkeit der lokalen
Teilchenkonzentration in kollioden Systemen (Erste Mitteilung).
<em>Arkiv foer Matematik, Astronomi och Fysik</em>, <b>11</b>, 1&ndash;24.
</p>

<hr>
<h2 id='installJuliaPackages'>installJuliaPackages</h2><span id='topic+installJuliaPackages'></span>

<h3>Description</h3>

<p>checks for needed Julia packages and installs them if not installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installJuliaPackages()
</code></pre>


<h3>Value</h3>

<p>no return value, called to install Julia packages in Julia.
</p>

<hr>
<h2 id='predict.coco'>K-Step Ahead Forecast Bootstrapping</h2><span id='topic+predict.coco'></span>

<h3>Description</h3>

<p>Computes the k-step ahead forecast using the models in the coconots package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coco'
predict(
  object,
  k = 1,
  number_simulations = 1000,
  alpha = 0.05,
  simulate_one_step_ahead = FALSE,
  max = NULL,
  epsilon = 1e-08,
  xcast = NULL,
  decimals = 4,
  julia = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.coco_+3A_object">object</code></td>
<td>
<p>An object that has been fitted previously, of class coco.</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_k">k</code></td>
<td>
<p>The number of steps ahead for which the forecast should be computed. Defaults to 3.</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_number_simulations">number_simulations</code></td>
<td>
<p>The number of simulation runs to compute. Defaults to 500.</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_alpha">alpha</code></td>
<td>
<p>Level of confidence that is used to construct the prediction intervals.</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_simulate_one_step_ahead">simulate_one_step_ahead</code></td>
<td>
<p>If FALSE, the one-step ahead prediciton is obtained using the analytical distribution. If TRUE, bootstrapping is used.</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_max">max</code></td>
<td>
<p>The maximum number of the forecast support for the plot. If NULL all values for which the cumulative distribution function is below 1- epsilon are used for the plot.</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_epsilon">epsilon</code></td>
<td>
<p>If max is NULL, epsilon determines the range of the support that is used by subsequent automatic plotting using R's plot() function.</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_xcast">xcast</code></td>
<td>
<p>An optional matrix of covariate values for the forecasting. If 'NULL', the function assumes no covariates.</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_decimals">decimals</code></td>
<td>
<p>Number of decimal places for the forecast probabilities</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_julia">julia</code></td>
<td>
<p>if TRUE, the estimate is predicted with Julia.</p>
</td></tr>
<tr><td><code id="predict.coco_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns forecasts for each mass point of the k-step ahead
distribution for the fitted model. The exact predictive distributions for
one-step ahead predicitons for
the models included here are provided in Jung and Tremayne (2011), maximum
likelihood estimates replace the true model parameters. Out-of-sample values
for covariates can be provided, if necessary.
</p>


<h3>Value</h3>

<p>A list of frequency tables. Each table represents a k-step ahead forecast frequency distribution based on the simulation runs.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+autoplot'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autoplot">autoplot</a></code>, <code><a href="ggplot2.html#topic+autoplot">autoplot</a></code>, <code><a href="ggplot2.html#topic+autoplot">autoplot</a></code>, <code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
</dl>

<hr>
<h2 id='setJuliaSeed'>Set Seed for Julia's Random Number Generator</h2><span id='topic+setJuliaSeed'></span>

<h3>Description</h3>

<p>Sets the seed for Julia's random number generator to ensure reproducibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setJuliaSeed(julia_seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setJuliaSeed_+3A_julia_seed">julia_seed</code></td>
<td>
<p>An integer seed value to be passed to Julia's random number generator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function initializes the necessary Julia functions and sets the random seed for Julia. 
If the provided seed is NULL, the function does nothing.
</p>


<h3>Author(s)</h3>

<p>Your Name (or the appropriate author's name)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
