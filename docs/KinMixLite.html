<!DOCTYPE html><html><head><title>Help for package KinMixLite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {KinMixLite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#KinMixLite-package'>
<p>Inference About Relationships from DNA Mixtures</p></a></li>
<li><a href='#add.child.meiosis.nodes'><p>Replace CPTs for mixture contributor a Father, given Child genotype, by MBN method</p></a></li>
<li><a href='#add.motherchild.likd.node'><p>Replace CPTs for mixture contributor a Father, given Child and Mother genotypes, by ALN method</p></a></li>
<li><a href='#add.relative.likd.node'><p>Replace CPTs for mixture contributor a Father, given Child genotype, by ALN method</p></a></li>
<li><a href='#as.gt'><p>Extract genotype profile for a single contributor from rGTs output</p></a></li>
<li><a href='#checkpeaks'><p>Check and modify database to have positive frequencies for all observed peaks/alleles</p></a></li>
<li><a href='#convertIBD'><p>Convert relationship information to IBD pattern distribution</p></a></li>
<li><a href='#delete.DQnodes'><p>Delete D and Q dummy nodes from all Bayes nets in mixture</p></a></li>
<li><a href='#emperors'><p>IBD pattern distribution in the Iulius-Claudius pedigree</p></a></li>
<li><a href='#expr.make.findings'><p>Coding additional findings as expression</p></a></li>
<li><a href='#formats'><p>Formats</p></a></li>
<li><a href='#gt2aca'><p>Converts genotype profiles to allele count arrays</p></a></li>
<li><a href='#intoMix'><p>Edit output from rGTs to omit individuals with NA amounts of DNA</p></a></li>
<li><a href='#logL.UKX'><p>Evaluates mixture log likelihood for unknown contributors with extra findings</p></a></li>
<li><a href='#logLX'><p>Evaluates mixture log likelihood when extra findings present</p></a></li>
<li><a href='#loop.rpt.IBD'><p>Analysis of DNA mixtures with familial relationships by looping</p></a></li>
<li><a href='#make.profile'><p>Convert genotype profile to reference profile format</p></a></li>
<li><a href='#mixMLX'><p>Maximises mixture likelihood when extra findings present</p></a></li>
<li><a href='#pedigreeIBD'><p>Construct IBD pattern distribution from pedigree</p></a></li>
<li><a href='#plot.IBD'><p>Plot IBD patterns and pattern distributions</p></a></li>
<li><a href='#protected'><p>Catch numerical errors, and return -Inf</p></a></li>
<li><a href='#protected.mixML'><p>Protect against numerical errors in maximum likelihood computation</p></a></li>
<li><a href='#require.compiled'><p>Force compilation of all BNs in a DNA mixture model</p></a></li>
<li><a href='#rGTs'><p>Simulate random genotype profiles and DNA samples for related individuals</p></a></li>
<li><a href='#rni'><p>Random number initialiser supporting spontaneous replication</p></a></li>
<li><a href='#rpt.AMEL'><p>Replace CPTs for AMEL marker in a DNA mixture</p></a></li>
<li><a href='#rpt.IBD'><p>Replacing CPTs for selected mixture contributors with familial relationships</p></a></li>
<li><a href='#rpt.UAF'><p>Replace CPTs in a DNA mixture to model uncertain allele frequencies</p></a></li>
<li><a href='#size'><p>Calculate and display total size of BN tables for a DNA mixture</p></a></li>
<li><a href='#test2data'><p>Small data set for demonstrating some capabilities of KinMix and KinMixLite</p></a></li>
<li><a href='#wlr'><p>Computes paternity LR using WLR method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference About Relationships from DNA Mixtures</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Green &lt;P.J.Green@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for inference about relationships between contributors to a DNA mixture and 
  other individuals of known genotype: a basic example would be testing whether a contributor to 
  a mixture is the father of a child of known genotype. This provides most of the functionality
  of the 'KinMix' package, but with some loss of efficiency and restriction on problem size,
  as the latter uses 'RHugin' as the Bayes net engine, while this package uses 'gRain'.
  The package implements the methods introduced in 
  Green, P. J. and Mortera, J. (2017) &lt;<a href="https://doi.org/10.1016%2Fj.fsigen.2017.02.001">doi:10.1016/j.fsigen.2017.02.001</a>&gt; and 
  Green, P. J. and Mortera, J. (2021) &lt;<a href="https://doi.org/10.1111%2Frssc.12498">doi:10.1111/rssc.12498</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>DNAmixturesLite, gRaven</td>
</tr>
<tr>
<td>Imports:</td>
<td>statnet.common, gRbase, Rsolnp, numDeriv, Matrix, ribd,
pedtools, methods</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://petergreenweb.wordpress.com/kinmix/">https://petergreenweb.wordpress.com/kinmix/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-09 09:33:57 UTC; peter</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Green [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-09 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='KinMixLite-package'>
Inference About Relationships from DNA Mixtures
</h2><span id='topic+KinMixLite-package'></span><span id='topic+KinMixLite'></span>

<h3>Description</h3>

<p>Methods for inference about relationships between contributors to a DNA mixture and 
  other individuals of known genotype: a basic example would be testing whether a contributor to 
  a mixture is the father of a child of known genotype. This provides most of the functionality
  of the 'KinMix' package, but with some loss of efficiency and restriction on problem size,
  as the latter uses 'RHugin' as the Bayes net engine, while this package uses 'gRain'.
  The package implements the methods introduced in 
  Green, P. J. and Mortera, J. (2017) &lt;doi:10.1016/j.fsigen.2017.02.001&gt; and 
  Green, P. J. and Mortera, J. (2021) &lt;doi:10.1111/rssc.12498&gt;.
</p>


<h3>Details</h3>

<p>This package is a toolkit for inference about mixtures and familial relationships, either between contributors or between a contributor and other typed individuals. It extends the functionality proposed in Green and Mortera (2017) by allowing more general relationships, specified in general by an IBD pattern distribution - the generalisation to more than two individuals of the coefficients of identity of Jacquard (1974). Details are in the paper by Green and Mortera (2021). <code>KinMixLite</code> extends the capability of the <span class="pkg">DNAmixturesLite</span> package, and intimately relies on that package; as with that package, instead of the <span class="pkg">RHugin</span> package, it uses <span class="pkg">gRaven</span> and <span class="pkg">gRain</span> for Bayes Net calculations. This version implements the ALN, MBN and WLR as well as RPT methods; see Green and Mortera (2017). 
</p>


<h3>Formats</h3>

<p>See <code><a href="#topic+formats">formats</a></code> for formats of the various data objects used in this package.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Peter Green &lt;P.J.Green@bristol.ac.uk&gt;
</p>


<h3>References</h3>

<p>Green, P. J. and Mortera, J. (2017). Paternity testing and other inference about relationships from DNA mixtures.
<em>Forensic Science International: Genetics</em>. &lt;doi:10.1016/j.fsigen.2017.02.001&gt;. 
</p>
<p>Green, P. J. and Mortera, J. (2021). Inference about complex relationships using peak height data from DNA mixtures.
<em>Applied Statistics</em>. &lt;doi:10.1111/rssc.12498&gt;.
</p>
<p>Jacquard, A. (1974) 
<em>The genetic structure of populations</em>. Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="DNAmixturesLite.html#topic+DNAmixturesLite-package">DNAmixturesLite</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ribd)
data(test2data)
data(NGMDyes)

C&lt;-50

## Fit 2-person mixture - baseline model

mixD&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db)
pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.7,U2=0.3)))
baseline&lt;-logL(mixD)(pars)

## Fit 2-person mixture model in which contributor 1 is parent of a typed individual Cgt

mixD&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db,triangulate=FALSE,compile=FALSE)
rpt.IBD(mixD,'parent',list(c=Cgt),targets=c('f','c'),contrib='f') 
log10LR&lt;-(logL(mixD)(pars)-baseline)/log(10)
cat('log10 LR',log10LR,'\n')

## Fit 2-person mixture, where contributors are siblings

mixD&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db)
pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.6,U2=0.3,U3=0.1)))
baseline&lt;-logL(mixD)(pars)

mixD&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db,triangulate=FALSE,compile=FALSE)
rpt.IBD(mixD,'sibs',targets=c('b1','b2'),contribs=c('b1','b2')) 
log10LR&lt;-(protected(logL(mixD)(pars))-baseline)/log(10)
cat('log10 LR',log10LR,'\n')
</code></pre>

<hr>
<h2 id='add.child.meiosis.nodes'>Replace CPTs for mixture contributor a Father, given Child genotype, by MBN method</h2><span id='topic+add.child.meiosis.nodes'></span>

<h3>Description</h3>

<p>loop over markers, and alleles within markers
to create nodes for child allele count nodes,
for paternity model with only Child genotyped
then compile all domains. Implements method MBN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.child.meiosis.nodes(mixture,aca,ind=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.child.meiosis.nodes_+3A_mixture">mixture</code></td>
<td>
<p>A compiled DNAmixture object</p>
</td></tr>
<tr><td><code id="add.child.meiosis.nodes_+3A_aca">aca</code></td>
<td>
<p>Child's genotype profile as an allele count array</p>
</td></tr>
<tr><td><code id="add.child.meiosis.nodes_+3A_ind">ind</code></td>
<td>
<p>Index of contributor regarded as Parent (or Child): which &lsquo;unknown&rsquo; contributor are we modelling by amending his/her CPTs?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To calculate the likelihood of this model, conditional on the child's genotype, a call to this function should be followed by (a) setting the finding of the child's genotype by defining <code>extra.findings</code>, (b) evaluating the loglikelihood using <code>logLX</code>, and (c) correcting the result by subtracting the log probability of the child's genotype, all as in the example below. Without (c), the value returned is the likelihood for the peak heights <em>and</em> the child's genotype.
</p>


<h3>Value</h3>

<p>No value is returned, the function is called for its side effect</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)

# set threshold C
C&lt;-0.001

mixD&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db)
pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.7,U2=0.3)))
baseline&lt;-logL(mixD)(pars)

mixMBN&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db,triangulate=FALSE,compile=FALSE)
cgtcaca&lt;-gt2aca(mixMBN,Cgt)
add.child.meiosis.nodes(mixMBN,cgtcaca,1)
log10LR&lt;-(logLX(mixMBN,
	expr.make.findings(list(
	list('Male',ind=1),
	list('Caca',aca='cgtcaca')
	))
	)(pars)-attr(cgtcaca,'logGt')-baseline)/log(10)
cat('log10 LR',log10LR,'\n')  
</code></pre>

<hr>
<h2 id='add.motherchild.likd.node'>Replace CPTs for mixture contributor a Father, given Child and Mother genotypes, by ALN method</h2><span id='topic+add.motherchild.likd.node'></span>

<h3>Description</h3>

<p>loop over markers, and alleles within markers
to create node Rlikd for relative likelihood for individual i,
for paternity model with Mother and Child genotyped
then compile all domains. Implements method ALN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.motherchild.likd.node(mixture,Cgt,Mgt,db,ind=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.motherchild.likd.node_+3A_mixture">mixture</code></td>
<td>
<p>A DNAmixture object</p>
</td></tr>
<tr><td><code id="add.motherchild.likd.node_+3A_cgt">Cgt</code></td>
<td>
<p>Child's genotype profile as a data frame containing variables <code>marker</code>, <code>allele1</code> and <code>allele2</code></p>
</td></tr>
<tr><td><code id="add.motherchild.likd.node_+3A_mgt">Mgt</code></td>
<td>
<p>Mother's genotype profile as a data frame containing variables <code>marker</code>, <code>allele1</code> and <code>allele2</code></p>
</td></tr>
<tr><td><code id="add.motherchild.likd.node_+3A_db">db</code></td>
<td>
<p>Allele frequency database</p>
</td></tr>
<tr><td><code id="add.motherchild.likd.node_+3A_ind">ind</code></td>
<td>
<p>Index of contributor regarded as Father: which &lsquo;unknown&rsquo; contributor are we modelling by amending his CPTs?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, the function is called for its side effect</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)

# set threshold C
C&lt;-0.001

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db)
pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.7,U2=0.3)))
baseline&lt;-logL(mixD)(pars)

mixD3&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db,triangulate=FALSE,compile=FALSE)
cgtcaca&lt;-gt2aca(mixD3,Cgt) 
add.motherchild.likd.node(mixD3,Cgt,Mgt,db,1)
log10LR&lt;-(logLX(mixD3,
	expr.make.findings(list(
	list('Male',ind=1),
	list('Rlikd',aca='cgtcaca',cgt='Cgt',evid='Revid')
	))
	)(pars)-baseline)/log(10)
cat('log10 LR',log10LR,'\n') 
</code></pre>

<hr>
<h2 id='add.relative.likd.node'>Replace CPTs for mixture contributor a Father, given Child genotype, by ALN method</h2><span id='topic+add.relative.likd.node'></span>

<h3>Description</h3>

<p>loop over markers, and alleles within markers
to create node Rlikd for relative likelihood for individual i,
for paternity model with only Child genotyped
then compile all domains. Implements method ALN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.relative.likd.node(mixture,aca,ind=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.relative.likd.node_+3A_mixture">mixture</code></td>
<td>
<p>A compiled DNAmixture object</p>
</td></tr>
<tr><td><code id="add.relative.likd.node_+3A_aca">aca</code></td>
<td>
<p>Child's genotype profile as an allele count array</p>
</td></tr>
<tr><td><code id="add.relative.likd.node_+3A_ind">ind</code></td>
<td>
<p>Index of contributor regarded as Parent (or Child): which &lsquo;unknown&rsquo; contributor are we modelling by amending his/her CPTs?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, the function is called for its side effect</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)

# set threshold C
C&lt;-0.001

mixD&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db)
pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.7,U2=0.3)))
baseline&lt;-logL(mixD)(pars)

mixALN&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db,triangulate=FALSE,compile=FALSE)
cgtcaca&lt;-gt2aca(mixALN,Cgt) 
add.relative.likd.node(mixALN,cgtcaca,1)
log10LR&lt;-(logLX(mixALN,
	expr.make.findings(list(
	list('Male',ind=1),
	list('Rlikd',aca='cgtcaca',cgt='Cgt',evid='Revid')
	))
	)(pars)-baseline)/log(10)
cat('log10 LR',log10LR,'\n') 
</code></pre>

<hr>
<h2 id='as.gt'>Extract genotype profile for a single contributor from rGTs output</h2><span id='topic+as.gt'></span>

<h3>Description</h3>

<p>Extract genotype profile for a single contributor from rGTs output</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.gt(res,ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.gt_+3A_res">res</code></td>
<td>
<p>Output from rGTs</p>
</td></tr>
<tr><td><code id="as.gt_+3A_ind">ind</code></td>
<td>
<p>Integer, which individual's genotype profile should be extracted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame, genotype profile for selected individual, for format see <code><a href="#topic+formats">formats</a></code>.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>

<hr>
<h2 id='checkpeaks'>Check and modify database to have positive frequencies for all observed peaks/alleles</h2><span id='topic+checkpeaks'></span>

<h3>Description</h3>

<p>Check whether database has positive frequencies for all peaks/alleles observed in epg and genotype profiles, and optionally modify db by addition of small positive frequencies so that it does, followed by renormalisation of frequencies for each allele to sum to 1.</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkpeaks(x,db,fix=0.003)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkpeaks_+3A_x">x</code></td>
<td>
<p>data frame, the epg or genotype profile; see <code><a href="#topic+formats">formats</a></code>.</p>
</td></tr>
<tr><td><code id="checkpeaks_+3A_db">db</code></td>
<td>
<p>data frame, the db; see <code><a href="#topic+formats">formats</a></code>.</p>
</td></tr>
<tr><td><code id="checkpeaks_+3A_fix">fix</code></td>
<td>
<p>numeric: if positive, increment to db frequency for each identified discrepant peak</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(possibly modified) db</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)

db&lt;-checkpeaks(epg,db)
db&lt;-checkpeaks(Cgt,db)

Xgt&lt;-data.frame(marker=c('D10','D12'),allele1=c(8,13),allele2=c(13,10))
db&lt;-checkpeaks(Xgt,db)
db
</code></pre>

<hr>
<h2 id='convertIBD'>Convert relationship information to IBD pattern distribution</h2><span id='topic+as.IBD'></span><span id='topic+convertIBD'></span>

<h3>Description</h3>

<p>Construct IBD pattern distribution from one of several alternative representations
of multi-person condensed coefficients of identity</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.IBD(x='sibs', targets=NULL, ped=FALSE) 
convertIBD(x='sibs', targets=NULL, ped=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertIBD_+3A_x">x</code></td>
<td>
<p>A string, a vector of length 3 or 9, a list with components <code>pr</code> and <code>patt</code>, or a list with two components, a pedigree and a vector of target id's; see Details</p>
</td></tr>
<tr><td><code id="convertIBD_+3A_targets">targets</code></td>
<td>
<p>character vector of individual tags</p>
</td></tr>
<tr><td><code id="convertIBD_+3A_ped">ped</code></td>
<td>
<p>logical, should complete pedigree be added as an attribute to the output, if available?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible formats for the input <code>x</code> are:
</p>

<ol>
<li><p> certain verbal mnemonics; currently one of the following (or an unambiguous partial match):
c('sibs','parent-child','half-sibs',
'cousins','half-cousins','second-cousins',
'double-first-cousins',
'quadruple-half-first-cousins',
'3cousins-cyclic','3cousins-star','trio')
</p>
</li>
<li><p> a vector of 3 kappas
</p>
</li>
<li><p> a vector of 9 Deltas
</p>
</li>
<li><p> a list with matrix or vector valued component <code>patt</code>, with or without component <code>pr</code>
</p>
</li>
<li><p> a list with 2 components, the first being a pedigree in the sense of the <code>pedtools</code> package, the second a vector of target id's
</p>
</li>
<li><p> a 3-column character matrix of individual tags, each row denoting a child/mother/triple - an alternative compact representation of a pedigree 
</p>
</li></ol>



<h3>Value</h3>

<p>IBD pattern distribution as a list with components <code>pr</code> and <code>patt</code></p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>See Also</h3>

<p><code><a href="pedtools.html#topic+pedtools">pedtools</a></code>, <code><a href="#topic+formats">formats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)

IBD&lt;-convertIBD('parent-child')

IBD&lt;-convertIBD(c(0.5,0.5,0.0))
</code></pre>

<hr>
<h2 id='delete.DQnodes'>Delete D and Q dummy nodes from all Bayes nets in mixture</h2><span id='topic+delete.DQnodes'></span>

<h3>Description</h3>

<p>Delete D and Q dummy nodes and associated edges from all Bayes nets in mixture, to save space; these nodes would 
only be needed for specific follow-up analyses</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.DQnodes(mixture,which="DQ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete.DQnodes_+3A_mixture">mixture</code></td>
<td>
<p>A compiled DNAmixture object</p>
</td></tr>
<tr><td><code id="delete.DQnodes_+3A_which">which</code></td>
<td>
<p>character string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function removes the D and/or Q nodes from the DNAmixture object, depending on whether <code>which</code> includes &quot;D&quot;, &quot;Q&quot; or both</p>


<h3>Value</h3>

<p>No value is returned, the function is called for its side effect</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db,dyes=list(NGMDyes),
	triangulate=FALSE,compile=FALSE)
delete.DQnodes(mixD)
replace.tables.for.UAF(mixD,40)
size(mixD)
</code></pre>

<hr>
<h2 id='emperors'>IBD pattern distribution in the Iulius-Claudius pedigree</h2><span id='topic+emperors'></span>

<h3>Description</h3>

<p>IBD pattern distribution in the Iulius-Claudius pedigree</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("emperors")</code></pre>


<h3>Format</h3>

<p>IBD object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+formats">formats</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emperors)
</code></pre>

<hr>
<h2 id='expr.make.findings'>Coding additional findings as expression</h2><span id='topic+expr.make.findings'></span>

<h3>Description</h3>

<p>Returns an expression that will be evaluated 
in logL.UKX whenever the likelihood of the model is calculated using the
current method, and encodes the additional findings needed to implement the 
method; the details of the model and the extra information needed are held in the list z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expr.make.findings(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expr.make.findings_+3A_z">z</code></td>
<td>
<p>A list specifying the additional findings; for the format, see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each component of the list <code>z</code> is a list encoding a particular type of additional finding: the first component of this (sub-)list being a character string specifying the type of finding, and the remainder of its components being named parameters giving details of the finding. The types of finding and the valid parameters of each are as follows:
</p>

<dl>
<dt><code>Male</code></dt><dd><p><code>ind</code>: index of relevant contributor: which &lsquo;unknown&rsquo; contributor are we modelling by amending his CPTs?</p>
</dd>
<dt><code>Female</code></dt><dd><p><code>ind</code>: index of relevant contributor</p>
</dd>
<dt><code>Rlikd</code></dt><dd><p><code>aca</code>: allele count array, <code>cgt</code>: character string naming genotype profile data frame, <code>evid</code>: character string naming list with one component for each marker, whose value is the evidence</p>
</dd>
<dt><code>Aca</code></dt><dd><p><code>ind</code>: index of relevant contributor, <code>aca</code>: allele count array</p>
</dd>
<dt><code>Caca</code></dt><dd><p><code>ind</code>: index of relevant contributor, <code>aca</code>: allele count array</p>
</dd>
<dt><code>Denom</code></dt><dd><p>no parameters</p>
</dd>
</dl>

<p>If <code>z</code> is NULL, then there are no additional findings.
</p>


<h3>Value</h3>

<p>Expression encoding the additional findings.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>

<hr>
<h2 id='formats'>Formats</h2><span id='topic+formats'></span>

<h3>Description</h3>

<p>Formats for data objects in KinMix and KinMixLite</p>


<h3>Formats</h3>

<p>An <b>allele frequency database</b> is a data frame containing variables <code>marker</code>, <code>allele</code> and <code>frequency</code> (character, numeric and numeric respectively).
</p>
<p>A <b>mixture profile</b> is a data frame containing variables <code>marker</code>, <code>allele</code> and <code>height</code> (character, numeric and numeric respectively).
</p>
<p>A <b>genotype profile</b> is a data frame containing variables <code>marker</code>, <code>allele1</code> and <code>allele2</code> (character, numeric and numeric respectively).
</p>
<p>Examples of these 3 data formats are objects <code>db</code>, <code>epg</code> and <code>Cgt</code>, respectively, in <code>test2data</code>.
</p>
<p>A <b>allele count array</b> is an alternative format for a genotype as a named list of vectors, one for each marker. Each vector gives the number of each allele in the genotype, with the alleles listed in the order in which they appear in the <code>data</code> component of the relevant mixture object. 
</p>
<p>An <b>IBD pattern distribution</b> or <b>IBD object</b> is a list with components <code>pr</code> (a numerical vector) and <code>patt</code> (an integer matrix with <code>nrow(patt)==length(pr)</code> and an even number of columns). The elements of <code>pr</code> are the probabilities of the IBD patterns in the corresponding rows of <code>patt</code>. Adjacent pairs of columns encode the genotypes of different individuals; equal elements in any row determine equality of the alleles; different elements denote independent draws from the gene pool. If the component <code>pr</code> is missing, functions <code>rpt.IBD</code> and <code>rpt.typed.relatives</code> assume the probabilities are equal.
</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>

<hr>
<h2 id='gt2aca'>Converts genotype profiles to allele count arrays</h2><span id='topic+gt2aca'></span>

<h3>Description</h3>

<p>Returns list of vectors of allele counts corresponding to genotype profile in gt</p>


<h3>Usage</h3>

<pre><code class='language-R'>gt2aca(mixture,gt,eps=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gt2aca_+3A_mixture">mixture</code></td>
<td>
<p>A compiled DNAmixture object</p>
</td></tr>
<tr><td><code id="gt2aca_+3A_gt">gt</code></td>
<td>
<p>Genotype profile as a data frame containing variables <code>marker</code>, <code>allele1</code> and <code>allele2</code></p>
</td></tr>
<tr><td><code id="gt2aca_+3A_eps">eps</code></td>
<td>
<p>If non-zero, the function creates the output allele count arrays in a different format, that mitigates subsequent propagation errors in some situations. Instead of a vector of allele counts, each element of the list is a matrix with 3 columns, corresponding to allele counts 0, 1 and 2, with entries 1 or <code>eps</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list of vectors of allele counts. The log probability for the genotype is returned in its attribute '<code>logGt</code>'.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)

# set threshold C
C&lt;-0.001

mixD&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db,dyes=list(NGMDyes))
cgtcaca&lt;-gt2aca(mixD,Cgt)

print(Cgt)
print(cgtcaca)
</code></pre>

<hr>
<h2 id='intoMix'>Edit output from rGTs to omit individuals with NA amounts of DNA</h2><span id='topic+intoMix'></span>

<h3>Description</h3>

<p>Edit output from rGTs to omit individuals with NA amounts of DNA</p>


<h3>Usage</h3>

<pre><code class='language-R'>intoMix(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intoMix_+3A_res">res</code></td>
<td>
<p>Output from <code>rGTs</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The edited data structure</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>

<hr>
<h2 id='logL.UKX'>Evaluates mixture log likelihood for unknown contributors with extra findings</h2><span id='topic+logL.UKX'></span>

<h3>Description</h3>

<p>Replacement for logL.UK in DNAmixtures that calls <code>extra.findings</code> immediately before 
propagating all findings and returning the normalising constant for the network.</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL.UKX(mixture, expr.extra.findings, initialize = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logL.UKX_+3A_mixture">mixture</code></td>
<td>
<p>Compiled DNAmixture object.</p>
</td></tr>
<tr><td><code id="logL.UKX_+3A_expr.extra.findings">expr.extra.findings</code></td>
<td>
<p>expression containing the extra findings</p>
</td></tr>
<tr><td><code id="logL.UKX_+3A_initialize">initialize</code></td>
<td>
<p>should all entered evidence be removed from the networks in <code>mixture</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log likelihood.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>See Also</h3>

<p>See also <code><a href="DNAmixturesLite.html#topic+logL.UK">logL.UK</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)

# set threshold C
C&lt;-0.001

pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.9,U2=0.1)))

mixMBN&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db,triangulate=FALSE,compile=FALSE)
cgtcaca&lt;-gt2aca(mixMBN,Cgt)
add.child.meiosis.nodes(mixMBN,cgtcaca,1)
logL.UKX(mixMBN,
	expr.make.findings(list(
	list('Male',ind=1),
	list('Caca',aca='cgtcaca')
	)))(pars)

</code></pre>

<hr>
<h2 id='logLX'>Evaluates mixture log likelihood when extra findings present</h2><span id='topic+logLX'></span>

<h3>Description</h3>

<p>Replacement for logL in DNAmixtures that calls calls LogL.UKX instead of logL.UK.</p>


<h3>Usage</h3>

<pre><code class='language-R'>logLX(mixture, expr.extra.findings, presence.only = FALSE, initialize = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLX_+3A_mixture">mixture</code></td>
<td>
<p>Compiled DNAmixture object.</p>
</td></tr>
<tr><td><code id="logLX_+3A_expr.extra.findings">expr.extra.findings</code></td>
<td>
<p>expression containing the extra findings</p>
</td></tr>
<tr><td><code id="logLX_+3A_presence.only">presence.only</code></td>
<td>
<p>Set to TRUE to ignore peak heights and evaluate the likelihood function considering peak presence and absence (heights above and below threshold) only. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="logLX_+3A_initialize">initialize</code></td>
<td>
<p>should all entered evidence be removed from the networks in <code>mixture</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log likelihood.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>See Also</h3>

<p>See also <code><a href="DNAmixturesLite.html#topic+logL">logL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)

# set threshold C
C&lt;-0.001

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db)
pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.7,U2=0.3)))
baseline&lt;-logL(mixD)(pars)

mixMBN&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db,triangulate=FALSE,compile=FALSE)
cgtcaca&lt;-gt2aca(mixMBN,Cgt)
add.child.meiosis.nodes(mixMBN,cgtcaca,1)
log10LR&lt;-(logLX(mixMBN,
	expr.make.findings(list(
	list('Male',ind=1),
	list('Caca',aca='cgtcaca')
	))
	)(pars)-attr(cgtcaca,'logGt')-baseline)/log(10)
cat('log10 LR',log10LR,'\n')
</code></pre>

<hr>
<h2 id='loop.rpt.IBD'>Analysis of DNA mixtures with familial relationships by looping</h2><span id='topic+loop.rpt.IBD'></span>

<h3>Description</h3>

<p>Analysis of DNA mixtures with familial relationships, by looping over traces, markers, and IBD patterns, to reduce total BN table size, at some price in execution time</p>


<h3>Usage</h3>

<pre><code class='language-R'>loop.rpt.IBD(listdata, pars, IBD, typed.gts = NULL, inds = 1, 
    jtyped = ncol(IBD$patt)/2 - length(typed.gts) + seq_along(typed.gts), 
    jcontr = seq_along(inds), targets = NULL, contribs, 
    quiet=FALSE, verbose=FALSE, presence.only=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loop.rpt.IBD_+3A_listdata">listdata</code></td>
<td>
<p>as in call to DNAmixture</p>
</td></tr>
<tr><td><code id="loop.rpt.IBD_+3A_pars">pars</code></td>
<td>
<p>parameter structure, in <code>mixpar</code> format</p>
</td></tr>
<tr><td><code id="loop.rpt.IBD_+3A_ibd">IBD</code></td>
<td>
<p>multi-person coefficients of identity, in any of the formats accepted by <code>convertIBD</code></p>
</td></tr>
<tr><td><code id="loop.rpt.IBD_+3A_typed.gts">typed.gts</code>, <code id="loop.rpt.IBD_+3A_inds">inds</code>, <code id="loop.rpt.IBD_+3A_jtyped">jtyped</code>, <code id="loop.rpt.IBD_+3A_jcontr">jcontr</code>, <code id="loop.rpt.IBD_+3A_targets">targets</code>, <code id="loop.rpt.IBD_+3A_contribs">contribs</code>, <code id="loop.rpt.IBD_+3A_quiet">quiet</code></td>
<td>
<p>as in call to rpt.IBD</p>
</td></tr>
<tr><td><code id="loop.rpt.IBD_+3A_verbose">verbose</code></td>
<td>
<p>should per-marker and overall log10LR's be reported?</p>
</td></tr>
<tr><td><code id="loop.rpt.IBD_+3A_presence.only">presence.only</code></td>
<td>
<p>Set to TRUE to ignore peak heights and evaluate the likelihood function considering peak presence and absence (heights above and below threshold) only. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="loop.rpt.IBD_+3A_...">...</code></td>
<td>
<p>other arguments to DNAmixture, particularly including <code>k</code>, <code>C</code>, <code>database</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the overall <code>log10 LR</code>, and the contributions of individual markers in the form of a vector-valued attribute 'log10LR', are returned invisibly; individual marker/pattern values are also printed out.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)

C&lt;-0.001

## Fit 3-person mixture - baseline model

mixD&lt;-DNAmixture(list(epg),k=3,C=rep(list(C),length(list(epg))),database=db)
pars3&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.6,U2=0.3,U3=0.1)))
baseline3&lt;-logL(mixD)(pars3)
size(mixD)

## Fit 3-person mixture - in which U1 and U2 have a parent-child relationship

mixD&lt;-DNAmixture(list(epg),k=3,C=rep(list(C),length(list(epg))),database=db,
	triangulate=FALSE,compile=FALSE)
delete.DQnodes(mixD)
rpt.IBD(mixD,IBD=c(0,1,0),typed.gts=list(),inds=1:2,jtyped=NULL)
size(mixD)
log10LR&lt;-(logL(mixD)(pars3)-baseline3)/log(10)
cat('log10 LR',log10LR,'\n')

## the same analysis by loop.rpt.IBD

listdata&lt;-list(epg)
print(loop.rpt.IBD(listdata,pars3,IBD=c(0,1,0),
	k=3,C=rep(list(C),length(listdata)),database=db,
	typed.gts=list(),inds=1:2,jtyped=NULL))
</code></pre>

<hr>
<h2 id='make.profile'>Convert genotype profile to reference profile format</h2><span id='topic+make.profile'></span>

<h3>Description</h3>

<p>Convert genotype profile to reference profile format</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.profile(gt,name='K')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.profile_+3A_gt">gt</code></td>
<td>
<p>genotype profile</p>
</td></tr>
<tr><td><code id="make.profile_+3A_name">name</code></td>
<td>
<p>character string used to name profile in output data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing reference profile</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
S1prof&lt;-make.profile(S1gt,'S1')
C&lt;-0.001
mixD&lt;-DNAmixture(list(epg),k=3,K='S1',reference.profile=S1prof,C=list(C),database=db)
</code></pre>

<hr>
<h2 id='mixMLX'>Maximises mixture likelihood when extra findings present</h2><span id='topic+mixMLX'></span>

<h3>Description</h3>

<p>Replacement for mixML in DNAmixtures that calls logLX instead of logL.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixMLX(mixture, expr.extra.findings, pars, constraints = NULL, phi.eq = FALSE, 
    val = NULL, trace = FALSE, order.unknowns = TRUE, initialize = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixMLX_+3A_mixture">mixture</code></td>
<td>
<p>Compiled DNAmixture object.</p>
</td></tr>
<tr><td><code id="mixMLX_+3A_expr.extra.findings">expr.extra.findings</code></td>
<td>
<p>expression containing the extra findings</p>
</td></tr>
<tr><td><code id="mixMLX_+3A_pars">pars</code></td>
<td>
<p>Parameters, in <code>mixpar</code> format.</p>
</td></tr>
<tr><td><code id="mixMLX_+3A_constraints">constraints</code></td>
<td>
<p>as in <code>mixML</code></p>
</td></tr>
<tr><td><code id="mixMLX_+3A_phi.eq">phi.eq</code></td>
<td>
<p>as in <code>mixML</code></p>
</td></tr>
<tr><td><code id="mixMLX_+3A_val">val</code></td>
<td>
<p>as in <code>mixML</code></p>
</td></tr>
<tr><td><code id="mixMLX_+3A_trace">trace</code></td>
<td>
<p>as in <code>mixML</code></p>
</td></tr>
<tr><td><code id="mixMLX_+3A_order.unknowns">order.unknowns</code></td>
<td>
<p>as in <code>mixML</code></p>
</td></tr>
<tr><td><code id="mixMLX_+3A_initialize">initialize</code></td>
<td>
<p>should all entered evidence be removed from the networks in <code>mixture</code></p>
</td></tr>
<tr><td><code id="mixMLX_+3A_...">...</code></td>
<td>
<p>as in <code>mixML</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>

<dl>
<dt>mle</dt><dd><p>The (suggested) MLE.</p>
</dd>
<dt>lik</dt><dd><p>The log of the likelihood (log e).</p>
</dd>
</dl>

<p>as well as the output from the optimisation.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>See Also</h3>

<p>See also <code><a href="DNAmixturesLite.html#topic+mixML">mixML</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)

# set threshold C
C&lt;-0.001

mixD&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db)

# find MLE's and maximised likelihood
# adding evidence individual 1 is Male 

expr.extra.findings&lt;-expr.make.findings(list(list('Male',ind=1)))

startpar&lt;-mixpar(rho=list(60),eta=list(24),xi=list(0.16),phi=list(c(U1=0.75,U2=0.25)))
mlDM&lt;-mixMLX(mixD,expr.extra.findings,startpar,trace=FALSE) 
pars&lt;-mlDM$mle
cat('\nBaseline model maximised likelihood:',mlDM$lik,'\n')
cat('and MLEs:\n')
print(mlDM$mle)
</code></pre>

<hr>
<h2 id='pedigreeIBD'>Construct IBD pattern distribution from pedigree</h2><span id='topic+pedigreeIBD'></span>

<h3>Description</h3>

<p>Construct IBD pattern distribution from a pedigree and a target list of individuals</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigreeIBD(x, targets, cond = TRUE, ped=FALSE, quiet = TRUE, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedigreeIBD_+3A_x">x</code></td>
<td>
<p>A pedigree in <code><a href="pedtools.html#topic+pedtools">pedtools</a></code> format</p>
</td></tr>
<tr><td><code id="pedigreeIBD_+3A_targets">targets</code></td>
<td>
<p>Character vector, some or all of the individual identifiers in the pedigree <code>x</code></p>
</td></tr>
<tr><td><code id="pedigreeIBD_+3A_cond">cond</code></td>
<td>
<p>should IBD pattern be condensed?</p>
</td></tr>
<tr><td><code id="pedigreeIBD_+3A_ped">ped</code></td>
<td>
<p>logical, should complete pedigree be added as an attribute to the output, if available?</p>
</td></tr>
<tr><td><code id="pedigreeIBD_+3A_quiet">quiet</code></td>
<td>
<p>should resulting IBD pattern distribution be printed?</p>
</td></tr>
<tr><td><code id="pedigreeIBD_+3A_verbose">verbose</code></td>
<td>
<p>should trace information be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the multi-person condensed coefficients of identity for an arbitrary set of individuals, in the sparse notation of the IBD pattern distribution of Green and Vigeland (2019).
</p>


<h3>Value</h3>

<p>IBD pattern distribution as a list with components <code>pr</code> and <code>patt</code></p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>References</h3>

<p><em>Multi-person condensed coefficients of identity</em>,
by Peter J. Green and Magnus Dehli Vigeland,
University of Bristol technical report, 2019.
</p>


<h3>See Also</h3>

<p><code><a href="pedtools.html#topic+pedtools">pedtools</a></code>, <code><a href="#topic+formats">formats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ribd)

id&lt;-c('gf','gm','b1','b2','m','c')
fid&lt;-c(0,0,'gf','gf',0,'b1')
mid&lt;-c(0,0,'gm','gm',0,'m')
sex&lt;-c(1,2,1,1,2,0)   
x&lt;-ped(id,fid,mid,sex)

IBD&lt;-pedigreeIBD(x,c('m','c','b1','b2'))

kappaIBD(x,c('m','c','b1','b2'))
</code></pre>

<hr>
<h2 id='plot.IBD'>Plot IBD patterns and pattern distributions</h2><span id='topic+plot.IBD'></span>

<h3>Description</h3>

<p>Plot IBD patterns and pattern distributions</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IBD'
plot(x,labels=NULL,probs=NULL,order=NULL,colrs=c('black','red','blue'), 
digits=3,nr=ceiling(sqrt(np)),...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.IBD_+3A_x">x</code></td>
<td>
<p>A matrix whose rows are IBD patterns, or a list whose components are <code>patt</code>, such a matrix, together with <code>pr</code>, a vector of the corresponding probabilities</p>
</td></tr>
<tr><td><code id="plot.IBD_+3A_labels">labels</code></td>
<td>
<p>Vector of numerical or character labels for the patterns, if <code>NA</code>, labels are constructed from the patterns by catenation, if <code>NULL</code>, the labels are not displayed.</p>
</td></tr>
<tr><td><code id="plot.IBD_+3A_probs">probs</code></td>
<td>
<p>Vector of probabilities of the patterns, if not provided as a component of <code>pattern</code>; if <code>NULL</code>, the probabilities are not displayed.</p>
</td></tr>
<tr><td><code id="plot.IBD_+3A_order">order</code></td>
<td>
<p>A character string, partially matched using <code>pmatch</code> to one of 'pattern', 'probs', or 'labels', requesting ordering diagram accordingly (in the case of <code>probs</code> in decreasing order, <strong>or</strong> a numeric, complex, character or logical vector of length the number of patterns, requesting ordering by this variable, <strong>or</strong> NULL (the default), requesting no re-ordering.</p>
</td></tr>
<tr><td><code id="plot.IBD_+3A_colrs">colrs</code></td>
<td>
<p>A vector of colours: ties in the ordering variable are indicated by coloured groups, with colours chosen cyclically from this vector.</p>
</td></tr>
<tr><td><code id="plot.IBD_+3A_digits">digits</code></td>
<td>
<p>Integer, overwriting default number of significant digits for <code>probs</code></p>
</td></tr>
<tr><td><code id="plot.IBD_+3A_nr">nr</code></td>
<td>
<p>Integer, overwriting default number of rows for plotted array, default a rounding up of the square root of the number of patterns.</p>
</td></tr>
<tr><td><code id="plot.IBD_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, the function is called for its side effect, a plot on the current display device.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ribd)
data(emperors)

plot.IBD(convertIBD('3cousins-star'),order='probs',col=c('blue','red','black'))

plot(attr(emperors,'ped'))

o&lt;-order(emperors$pr)[1:12]
plot.IBD(emperors$patt[o,],probs=emperors$pr[o],labels=NA,order='probs')
</code></pre>

<hr>
<h2 id='protected'>Catch numerical errors, and return -Inf</h2><span id='topic+protected'></span>

<h3>Description</h3>

<p>Attempts to catch numerical erros in evaluating the expression <code>x</code>, delivering a default result instead of NaN or other failures</p>


<h3>Usage</h3>

<pre><code class='language-R'>protected(x,default=-Inf) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protected_+3A_x">x</code></td>
<td>
<p>expression to be evaluated, typically the log-likelihood of a modified mixture model</p>
</td></tr>
<tr><td><code id="protected_+3A_default">default</code></td>
<td>
<p>value to be delivered if numerical errors are encountered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns -Inf in case of error, otherwise the value of <code>x</code></p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>

<hr>
<h2 id='protected.mixML'>Protect against numerical errors in maximum likelihood computation</h2><span id='topic+protected.mixML'></span>

<h3>Description</h3>

<p>Attempts to catch numerical errors in maximum likelihood computation, by replacing logL values by a default value instead of NaN or other failures</p>


<h3>Usage</h3>

<pre><code class='language-R'>protected.mixML(mixture, pars, constraints = NULL, phi.eq = FALSE, val = NULL,
  trace = FALSE, order.unknowns = TRUE, default=-999999, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protected.mixML_+3A_mixture">mixture</code></td>
<td>
<p>A DNAmixture object.</p>
</td></tr>
<tr><td><code id="protected.mixML_+3A_pars">pars</code></td>
<td>
<p>A mixpar parameter used as a starting value for the optimisation.</p>
</td></tr>
<tr><td><code id="protected.mixML_+3A_constraints">constraints</code></td>
<td>
<p>Equality constraint function as function of an array of parameters.</p>
</td></tr>
<tr><td><code id="protected.mixML_+3A_phi.eq">phi.eq</code></td>
<td>
<p>Should the mixture proportions be the same for all traces? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="protected.mixML_+3A_val">val</code></td>
<td>
<p>Vector of values to be satisfied for the equality constraints.</p>
</td></tr>
<tr><td><code id="protected.mixML_+3A_trace">trace</code></td>
<td>
<p>Print the evaluations of the likelihood-function during optimisation?</p>
</td></tr>
<tr><td><code id="protected.mixML_+3A_order.unknowns">order.unknowns</code></td>
<td>
<p>Should unknown contributors be ordered according to decreasing contributions? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="protected.mixML_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to solnp.</p>
</td></tr>
<tr><td><code id="protected.mixML_+3A_default">default</code></td>
<td>
<p>value of logL to be used if numerical errors are encountered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>mle</code></td>
<td>
<p>The (suggested) MLE.</p>
</td></tr>
<tr><td><code>lik</code></td>
<td>
<p>The log of the likelihood (log e).</p>
</td></tr>
</table>
<p>as well as the output from the optimisation.
</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>

<hr>
<h2 id='require.compiled'>Force compilation of all BNs in a DNA mixture model</h2><span id='topic+require.compiled'></span>

<h3>Description</h3>

<p>Scan all Bayes nets in mixture, and compile any that are not already compiled</p>


<h3>Usage</h3>

<pre><code class='language-R'>require.compiled(mixture)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="require.compiled_+3A_mixture">mixture</code></td>
<td>
<p>A DNAmixture object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, the function is called for its side effect</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db,dyes=list(NGMDyes),
	triangulate=FALSE,compile=FALSE)
replace.tables.for.UAF(mixD,40,compile=FALSE)
require.compiled(mixD)
</code></pre>

<hr>
<h2 id='rGTs'>Simulate random genotype profiles and DNA samples for related individuals</h2><span id='topic+rGTs'></span>

<h3>Description</h3>

<p>Simulate random genotype profiles and DNA samples for arbitrarily related individuals</p>


<h3>Usage</h3>

<pre><code class='language-R'>rGTs(nreps,IBD,db,DNA,sex=rep(0,ncontr),nU=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rGTs_+3A_nreps">nreps</code></td>
<td>
<p>Integer, number of replicates</p>
</td></tr>
<tr><td><code id="rGTs_+3A_ibd">IBD</code></td>
<td>
<p>Specification of relationships, as in <code>convertIBD</code></p>
</td></tr>
<tr><td><code id="rGTs_+3A_db">db</code></td>
<td>
<p>Data frame, database of alleles and their frequencies, for each marker; for format, see <code><a href="#topic+formats">formats</a></code>.</p>
</td></tr>
<tr><td><code id="rGTs_+3A_dna">DNA</code></td>
<td>
<p>Integer vector, numbers of DNA cells for the respective individuals, can be NA</p>
</td></tr>
<tr><td><code id="rGTs_+3A_sex">sex</code></td>
<td>
<p>Integer vector, sex of the respective contributors: 1=male, 2=female, 0=unspecified</p>
</td></tr>
<tr><td><code id="rGTs_+3A_nu">nU</code></td>
<td>
<p>Integer, include also this number of unrelated individuals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genotype profiles are generated randomly, using the allele frequency database <code>db</code>, under the relationships specified by the <code>IBD</code> argument. In accordance with the underlying biology, allele values for the AMEL marker (if this is one of the markers included) are not influenced by relationships with other individuals; however they are influenced by the sex of the individuals, where this is known. Information on sex can be specified by the optional argument <code>sex</code>: a male is given the profile X-Y, a female X-X, and an individual with unspecified sex X-X or X-Y with equal probabilities.
</p>


<h3>Value</h3>

<p>Data frame with variables <code>Sim</code>, <code>Sample.name</code>, <code>Marker</code>, <code>Allele</code>, and <code>DNA</code>, suitable for input to <code>simExtraction</code>, etc. See package <code>pcrsim</code>.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)
</code></pre>

<hr>
<h2 id='rni'>Random number initialiser supporting spontaneous replication</h2><span id='topic+rni'></span>

<h3>Description</h3>

<p>Random number initialiser supporting spontaneous replication</p>


<h3>Usage</h3>

<pre><code class='language-R'>rni(seed=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rni_+3A_seed">seed</code></td>
<td>
<p>Integer, seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience front end to <code>set.seed</code>. A non-zero value of <code>seed</code> is passed directly to <code>set.seed</code>. Given a zero value (the default), the function calls <code>Sys.time</code> to generate an unpredictable starting value &ndash; but the value ultimately passed to <code>set.seed</code> is both output using <code>cat</code> and returned invisibly, so can be used for unanticipated replica runs of a simulation.
</p>


<h3>Value</h3>

<p>Non-zero seed value that can be used to reproduce run subsequently</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rni(0)
runif(6)
rni(0)
runif(6)
rni(3456)
runif(6)
rni(3456)
runif(6)
keep&lt;-rni(0)
print(keep)
runif(6)
rni(keep)
runif(6)
</code></pre>

<hr>
<h2 id='rpt.AMEL'>Replace CPTs for AMEL marker in a DNA mixture</h2><span id='topic+rpt.AMEL'></span>

<h3>Description</h3>

<p>Used after a call to <code>DNAmixture</code> with <code>compile=FALSE,triangulate=FALSE</code>, this function replaces the CPTs for the genotype allele count arrays for the AMEL marker in a DNA mixture to specify sex of contributors</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpt.AMEL(mixture,sex,compile=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpt.AMEL_+3A_mixture">mixture</code></td>
<td>
<p>A DNAmixture object</p>
</td></tr>
<tr><td><code id="rpt.AMEL_+3A_sex">sex</code></td>
<td>
<p>Integer vector, sex of each contributor</p>
</td></tr>
<tr><td><code id="rpt.AMEL_+3A_compile">compile</code></td>
<td>
<p>Logical, should BN be compiled after modification?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sex of each contributor is coded as in <code>pedtools</code>, namely 0=unspecified, 1=male, 2=female.
</p>


<h3>Value</h3>

<p>No value is returned, the function is called for its side effect</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)

mixD&lt;-DNAmixture(list(epg),k=3,C=list(0.001),database=db,dyes=list(NGMDyes),
        triangulate=FALSE,compile=FALSE)
rpt.AMEL(mixD,c(1,2,0))  # the 3 contributors are male, female, and unspecified,respectively.
</code></pre>

<hr>
<h2 id='rpt.IBD'>Replacing CPTs for selected mixture contributors with familial relationships</h2><span id='topic+rpt.IBD'></span><span id='topic+rpt.typed.relatives'></span><span id='topic+rpt.typed.child'></span><span id='topic+replace.Ui.tables'></span><span id='topic+rpt.typed.parents'></span><span id='topic+rpt.typed.relative'></span>

<h3>Description</h3>

<p>Used after a call to <code>DNAmixture</code> with <code>compile=FALSE,triangulate=FALSE</code>, this function replaces the CPTs for the genotype allele count arrays for specified mixture contributors by those representing the specified relationship with each other and typed relatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpt.IBD(mixture, IBD="parent-child", typed.gts = NULL, inds = 1, 
jtyped = ncol(IBD$patt)/2 - length(typed.gts) + seq_along(typed.gts), 
jcontr = seq_along(inds), 
targets=attr(IBD,'targets'), contribs=NULL, quiet=FALSE, all.freq = NULL, compile = TRUE) 

rpt.typed.relatives(mixture, IBD="parent-child", typed.gts = NULL, inds = 1, 
jtyped = ncol(IBD$patt)/2 - length(typed.gts) + seq_along(typed.gts), 
jcontr = seq_along(inds), 
targets=attr(IBD,'targets'), contribs=NULL, quiet=FALSE, all.freq = NULL, compile = TRUE)

rpt.typed.child(mixture, aca, ind=1)

replace.Ui.tables(mixture, aca, ind=1)

rpt.typed.parents(mixture, Mgt, Fgt, ind=1, compile=TRUE)

rpt.typed.relative(mixture, Rgt, IBD=c(0.25,0.5,0.25), ind=1, compile=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpt.IBD_+3A_mixture">mixture</code></td>
<td>
<p>DNAmixtures object created by previous call to <code>DNAmixture</code> with <br />
<code>triangulate=FALSE,compile=FALSE</code></p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_ibd">IBD</code></td>
<td>
<p>relationships between the specified individuals, as multi-person condensed 
coefficients of identity, in one of several representation; see Details.</p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_typed.gts">typed.gts</code></td>
<td>
<p>list of 0 or more genotypes of relatives; the components of this list must
be named (with the id's of the relevant individuals) if <code>targets</code> and <code>contribs</code>
are used to code the correspondences (see Details).</p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_inds">inds</code></td>
<td>
<p>vector of 1 or more integers: which &lsquo;unknown&rsquo; contributors are we modelling by
amending their CPTs? The elements should be listed in the same order as the corresponding
pairs of columns of the IBD patterns in <code>IBD</code></p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_jtyped">jtyped</code></td>
<td>
<p>indices of pairs of columns of <code>IBD$patt</code> that correspond to the 
typed relatives (if any); default the last <code>length(typed.gts)</code> pairs of columns</p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_jcontr">jcontr</code></td>
<td>
<p>indices of pairs of columns of <code>IBD$patt</code> that correspond to the 
relevant mixture contributors; default the first <code>length(inds)</code> pairs of columns</p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_targets">targets</code></td>
<td>
<p>Character vector of the tags of the individuals referred to in <code>IBD</code></p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_contribs">contribs</code></td>
<td>
<p>Character vector of the tags of the individuals included in the mixture,
in order</p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_quiet">quiet</code></td>
<td>
<p>should calculated values of inds, jtyped and jcontr be reported?</p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_all.freq">all.freq</code></td>
<td>
<p>alternative allele frequency database(s), see Details.</p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_compile">compile</code></td>
<td>
<p>logical flag: should mixture object be compiled on exit?</p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_ind">ind</code></td>
<td>
<p>as <code>inds</code>, used above when only one allowed</p>
</td></tr>
<tr><td><code id="rpt.IBD_+3A_aca">aca</code>, <code id="rpt.IBD_+3A_mgt">Mgt</code>, <code id="rpt.IBD_+3A_fgt">Fgt</code>, <code id="rpt.IBD_+3A_rgt">Rgt</code></td>
<td>
<p>individual genotypes, as allele count arrays</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In using <code>rpt.IBD</code> or <code>rpt.typed.relatives</code> (which is identical), the correspondence between mixture contributors, specified relationships, and typed genotype profiles should be specified 
<strong>either</strong> (preferably)
using <code>targets</code>, <code>contribs</code> and through the names of the components in <code>typed.gts</code>,
<strong>or</strong> (to be deprecated)
with <code>inds</code>, <code>jcontr</code> and <code>jtyped</code>: 
the two representations should not be mixed up. If either <code>targets</code> or <code>contribs</code> specified, the former representation is assumed.
</p>
<p>Special cases are treated slightly more efficiently:
<code>rpt.typed.child</code>: single contributor, single typed relative, parent or child;
<code>rpt.typed.parents</code>: single contributor, both parents typed;
<code>rpt.typed.relative</code>: single contributor, single typed relative.
</p>
<p>Note that <code>IBD$patt</code> always has an even number of columns, two for each individual
in the joint relationship specified; <code>jtyped</code> and <code>jcontr</code> are vectors of
indices of these individuals, i.e. to pairs of adjacent columns of <code>IBD$patt</code>.
</p>
<p>Multiple functions in this group can validly be called sequentially (with all but the
last having <code>compile=FALSE</code>) providing they reference different sets of
contributors among the targets, <strong>and</strong> that these sets are conditionally
independent given the typed genotypes specified.
</p>
<p>There are multiple valid representations for relationships in the argument <code>IBD</code> &ndash;
as an IBD pattern distribution, via a pedigree, or. in the case of just two individuals.
via either a vector of 3 kappas or 9 Deltas (Jacquard's condensed coefficients of
identity). For full details, see <code><a href="#topic+convertIBD">convertIBD</a></code>.
If <code>IBD</code> is missing, the default value represents parent-child.
</p>
<p>In the interests of upward compatibility, in <code>rpt.typed.child</code> and 
<code>replace.Ui.tables</code> (which are identical), the argument <code>Cgt</code> can be given as
either a genotype profile data frame, or an allele count array.
</p>
<p>By default, the allele frequency database used for the founding genes is that
used when the <code>mixture</code> object is created, in an earlier call to <code>DNAmixture</code>.
A non-null value for the <code>all.freq</code> argument allows the
user to specify alternative database (s) for the founding genes. If its value
is an allele frequency database (in the format specified in 
<code><a href="#topic+formats">formats</a></code>) then that database is used for all founding genes; if the
value of the argument is a list of such databases, then component k of the
list is used for allele frequencies for the founding gene labelled k in the
<code>IBD</code> argument. Note that this option allows modelling of mixtures where
different contributors are drawn from different populations, whether or not
there are relationships among individuals. </p>


<h3>Value</h3>

<p>Vector of marker-specific probabilities of the typed genotypes.</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)

## Fit 2-person mixture - baseline model

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db)
pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.7,U2=0.3)))
baseline&lt;-logL(mixD)(pars)

## Fit 2-person mixture model in which contributor 1 is parent of a typed individual Cgt

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db,triangulate=FALSE,compile=FALSE)
rpt.IBD(mixD,,list(Cgt)) 
log10LR&lt;-(logL(mixD)(pars)-baseline)/log(10)
cat('log10 LR',log10LR,'\n')

## Fit 2-person mixture model in which contributor 1 is father of a typed individual Cgt 
## with mother Mgt

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db,triangulate=FALSE,compile=FALSE)
rpt.IBD(mixD,,list(Mgt,Cgt)) 
log10LR&lt;-(logL(mixD)(pars)-baseline)/log(10)
cat('log10 LR',log10LR,'\n')

## Fit 2-person mixture model in which contributors are two parents of a child with 
## genotype Cgt, and a parent of one of them has genotype Rgt. Note the encoding of allele 
## labels to reduce the complexity of the IBD pattern distribution IBD.

IBD&lt;-list(patt=rbind(c(1,3,2,4,1,2,1,5),c(1,3,2,4,1,2,3,5)))

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db,triangulate=FALSE,compile=FALSE)
rpt.IBD(mixD,IBD,list(Cgt,Rgt),1:2) 
log10LR&lt;-(logL(mixD)(pars)-baseline)/log(10)
cat('log10 LR',log10LR,'\n')

## the same, with individuals and relationships denoted by character tags

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db,triangulate=FALSE,compile=FALSE)
rpt.IBD(mixD,IBD,list(c=Cgt,gf=Rgt),targets=c('f','m','c','gf'),contribs=c('f','m')) 
log10LR&lt;-(logL(mixD)(pars)-baseline)/log(10)
cat('log10 LR',log10LR,'\n')
</code></pre>

<hr>
<h2 id='rpt.UAF'>Replace CPTs in a DNA mixture to model uncertain allele frequencies</h2><span id='topic+rpt.UAF'></span><span id='topic+replace.tables.for.UAF'></span>

<h3>Description</h3>

<p>Replace CPTs in a DNA mixture to model uncertainty in allele frequencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace.tables.for.UAF(mixture, M, compile = TRUE)

rpt.UAF(mixture, M, compile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rpt.UAF_+3A_mixture">mixture</code></td>
<td>
<p>DNAmixtures object created by previous call to <code>DNAmixture</code> with <br />
<code>triangulate=FALSE,compile=FALSE</code></p>
</td></tr>
<tr><td><code id="rpt.UAF_+3A_m">M</code></td>
<td>
<p>Size of allele frequency database</p>
</td></tr>
<tr><td><code id="rpt.UAF_+3A_compile">compile</code></td>
<td>
<p>logical flag: should mixture object be compiled on exit?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned, the function is called for its side effect</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)

## Fit 2-person mixture - baseline model

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db)
pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.7,U2=0.3)))
baseline&lt;-logL(mixD)(pars)

## Fit 2-person mixture model under assumption that database size was only 40

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db,triangulate=FALSE,compile=FALSE)
replace.tables.for.UAF(mixD,40)
log10LR&lt;-(logL(mixD)(pars)-baseline)/log(10)
cat('log10 LR',log10LR,'\n')
</code></pre>

<hr>
<h2 id='size'>Calculate and display total size of BN tables for a DNA mixture</h2><span id='topic+size'></span>

<h3>Description</h3>

<p>Calculate and display total size of BN tables for a DNA mixture</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(mixture)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_mixture">mixture</code></td>
<td>
<p>A compiled DNAmixture object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns total size, typically to be printed by bespoke method</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)

## Fit 2-person mixture - baseline model

mixD&lt;-DNAmixture(list(epg),k=2,C=list(0.001),database=db)
size(mixD)
</code></pre>

<hr>
<h2 id='test2data'>Small data set for demonstrating some capabilities of KinMix and KinMixLite</h2><span id='topic+test2data'></span><span id='topic+Cgt'></span><span id='topic+Fgt'></span><span id='topic+Mgt'></span><span id='topic+Rgt'></span><span id='topic+S1gt'></span><span id='topic+S2gt'></span><span id='topic+db'></span><span id='topic+epg'></span>

<h3>Description</h3>

<p>Small test data set (2 markers with 4 or 5 alleles each, plus AMEL), for demonstrating some capabilities of KinMix  and KinMixLite</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("test2data")</code></pre>


<h3>Format</h3>

<p>Data objects for demonstrating KinMix:
<code>epg</code> (DNAmixtures peak height data), 
<code>db</code> (DNAmixtures allele frequency database), 
and <code>Cgt, Fgt, Mgt, Rgt, S1gt, S2gt</code> potential relative genotype data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
</code></pre>

<hr>
<h2 id='wlr'>Computes paternity LR using WLR method</h2><span id='topic+wlr'></span>

<h3>Description</h3>

<p>Computes overall LR from Ugt-specific LR's using estimated Ugt genotype
profile in <code>sep</code> corresponding to contributor i in the mixture as Father; uses 
Child genotype information in <code>Cgt</code> data.frame and optionally Mother's genotype in <code>Mgt</code>.
Implements method WLR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wlr(sep, Cgt, db, ind=1, Mgt=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlr_+3A_sep">sep</code></td>
<td>
<p>Separation, a list of configurations of genotypes for some or all unknown contributors, output by <code>map.genotypes</code>.</p>
</td></tr>
<tr><td><code id="wlr_+3A_cgt">Cgt</code></td>
<td>
<p>Child's genotype profile as a data frame containing variables <code>marker</code>, <code>allele1</code> and <code>allele2</code></p>
</td></tr>
<tr><td><code id="wlr_+3A_db">db</code></td>
<td>
<p>Allele frequency database</p>
</td></tr>
<tr><td><code id="wlr_+3A_ind">ind</code></td>
<td>
<p>Index of contributor regarded as Father</p>
</td></tr>
<tr><td><code id="wlr_+3A_mgt">Mgt</code></td>
<td>
<p>(optionally) Mother's genotype profile as a data frame containing variables <code>marker</code>, <code>allele1</code> and <code>allele2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns LR for paternity</p>


<h3>Author(s)</h3>

<p>Peter Green (P.J.Green@bristol.ac.uk)
</p>


<h3>See Also</h3>

<p>See also <code><a href="DNAmixturesLite.html#topic+map.genotypes">map.genotypes</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(test2data)
data(NGMDyes)

# set threshold C
C&lt;-0.001

pars&lt;-mixpar(rho=list(2),eta=list(100),xi=list(0.1),phi=list(c(U1=0.9,U2=0.1)))

mixWLR&lt;-DNAmixture(list(epg),k=2,C=list(C),database=db,dyes=list(NGMDyes))
setPeakInfo(mixWLR,pars)
sepWLR&lt;-map.genotypes(mixWLR,type="all",pmin=0.0001,U=1)
LR&lt;-wlr(sepWLR,Cgt,db)
cat('\nWLR LR:',LR,'; log10(LR):',log10(LR),'\n')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
