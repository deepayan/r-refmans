<!DOCTYPE html><html><head><title>Help for package simputation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simputation}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#deparse'><p>A <code>deparse</code> replacement that always returns a length-1 vector</p></a></li>
<li><a href='#foretell'><p>Alternative to 'predict' returning values of correct type.</p></a></li>
<li><a href='#glimpse_na'><p>Show the number of (remaining) missing values.</p></a></li>
<li><a href='#impute'><p>Impute using a previously fitted model.</p></a></li>
<li><a href='#impute_cart'><p>Decision Tree Imputation</p></a></li>
<li><a href='#impute_hotdeck'><p>Hot deck imputation</p></a></li>
<li><a href='#impute_lm'><p>(Robust) Linear Regression Imputation</p></a></li>
<li><a href='#impute_median'><p>Impute (group-wise) medians</p></a></li>
<li><a href='#impute_multivariate'><p>Multivariate, model-based imputation</p></a></li>
<li><a href='#impute_proxy'><p>Impute by variable derivation</p></a></li>
<li><a href='#na_status'><p>Show the number of (remaining) missing values.</p></a></li>
<li><a href='#na.roughfix'><p>Rough imputation for handling missing predictors.</p></a></li>
<li><a href='#print.simputation.capabilities'><p>print output of simputation_capabilities</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#simputation'><p>simputation</p></a></li>
<li><a href='#simputation_capabilities'><p>Capabilities depending on suggested packages.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Mark van der Loo &lt;mark.vanderloo@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Simple Imputation</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Easy to use interfaces to a number of imputation methods
        that fit in the not-a-pipe operator of the 'magrittr' package.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, MASS, rpart, gower, VIM, randomForest, glmnet,
missForest, norm</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/markvanderloo/simputation">https://github.com/markvanderloo/simputation</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/markvanderloo/simputation/issues">https://github.com/markvanderloo/simputation/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, knitr, rmarkdown, dplyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-16 13:32:09 UTC; mark</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark van der Loo [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-16 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='deparse'>A <code>deparse</code> replacement that always returns a length-1 vector</h2><span id='topic+deparse'></span>

<h3>Description</h3>

<p>A <code>deparse</code> replacement that always returns a length-1 vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deparse(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deparse_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>base::deparse()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The deparsed string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>long_formula &lt;- this_is_a_formula_with_long_variables ~
  the_test_is_checking_if_deparse_will_return +
  multiple_strings_or_not
simputation:::deparse(long_formula)
</code></pre>

<hr>
<h2 id='foretell'>Alternative to 'predict' returning values of correct type.</h2><span id='topic+foretell'></span><span id='topic+foretell.default'></span><span id='topic+foretell.glm'></span><span id='topic+foretell.rpart'></span>

<h3>Description</h3>

<p>Te default <code>precict</code> function doesn't always return the
predicted variable by default. For example, when estimating
a binomial model using <code><a href="stats.html#topic+glm">glm</a></code>, by default the
log-odds are returned. <code>foretell</code> wraps <code>predict</code> while
setting options so that the actual predicted value is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foretell(object, ...)

## Default S3 method:
foretell(object, ...)

## S3 method for class 'glm'
foretell(object, newdata = NULL, type, ...)

## S3 method for class 'rpart'
foretell(object, newdata, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foretell_+3A_object">object</code></td>
<td>
<p>A model object,(<code>lm</code>, <code>glm</code>, ...)</p>
</td></tr>
<tr><td><code id="foretell_+3A_...">...</code></td>
<td>
<p>Furher arguments passed to <code>predict</code>.</p>
</td></tr>
<tr><td><code id="foretell_+3A_newdata">newdata</code></td>
<td>
<p><code>[data.frame]</code> a data frame in which to look
for variables with which to predict. For <code>glmnet</code> models
this argument is mandatory.</p>
</td></tr>
<tr><td><code id="foretell_+3A_type">type</code></td>
<td>
<p><code>[character]</code> Type of output. If missing, the type of
predicted variable is returned.</p>
</td></tr>
</table>

<hr>
<h2 id='glimpse_na'>Show the number of (remaining) missing values.</h2><span id='topic+glimpse_na'></span><span id='topic++25+3F+3E+25'></span>

<h3>Description</h3>

<p>Quick indication of the amount and location of missing values.
The function uses <code><a href="#topic+na_status">na_status</a></code> to print the missing values, but
returns the original <code>x</code> (invisibly) and therefore can be used in an imputation pipeline
to peek at the NA's status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glimpse_na(x, show_only_missing = TRUE, ...)

lhs %?&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glimpse_na_+3A_x">x</code></td>
<td>
<p>an R object caryying data (e.g. <code>data.frame</code>)</p>
</td></tr>
<tr><td><code id="glimpse_na_+3A_show_only_missing">show_only_missing</code></td>
<td>
<p>if <code>TRUE</code> only columns with <code>NA</code>'s will be
printed.</p>
</td></tr>
<tr><td><code id="glimpse_na_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+na_status">na_status</a></code>.</p>
</td></tr>
<tr><td><code id="glimpse_na_+3A_lhs">lhs</code></td>
<td>
<p>left hand side of pipe</p>
</td></tr>
<tr><td><code id="glimpse_na_+3A_rhs">rhs</code></td>
<td>
<p>right hand side of pipe</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>glimpse_na</code> is especially helpful when interactively adding imputation methods.
<code>glimpse_na</code> is named after <code><a href="dplyr.html#topic+glimpse">glimpse</a></code> in <code>dplyr</code>.
</p>
<p>Operator <code>%?&gt;%</code> is syntactic sugar: it inserts a <code>glimpse_na</code> in
the pipe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   
irisNA &lt;- iris
irisNA[1:3,1] &lt;- irisNA[3:7,2] &lt;- NA

# How many NA's?
na_status(irisNA)

# add an imputation method one at a time
iris_imputed &lt;-
  irisNA |&gt; 
  glimpse_na() # same as above

# ok, glimpse_na says "Sepal.Width" has NA's
# fix that:

iris_imputed &lt;-
  irisNA |&gt; 
  impute_const(Sepal.Width ~ 7) |&gt; 
  glimpse_na() # end NA

# Sepal.Length is having NA's

iris_imputed &lt;-
  irisNA |&gt; 
  impute_const(Sepal.Width ~ 7) |&gt;
  impute_cart(Sepal.Length ~ .) |&gt;  
  glimpse_na() # end NA

# in an existing imputation pipeline we can peek with
# glimpse_na or %?&gt;%

iris_imputed &lt;-
  irisNA |&gt; 
  glimpse_na() |&gt;     # shows the begin NA
  impute_const(Sepal.Width ~ 7) |&gt; 
  glimpse_na() |&gt;     # after 1 imputation
  impute_cart(Sepal.Length ~ .) |&gt;  
  glimpse_na()         # end NA
  
# or
iris_imputed &lt;-
  irisNA %?&gt;% 
  impute_const(Sepal.Width ~ 7) %?&gt;% 
  impute_cart(Sepal.Length ~ .)
  
na_status(iris_imputed)  

</code></pre>

<hr>
<h2 id='impute'>Impute using a previously fitted model.</h2><span id='topic+impute'></span><span id='topic+impute_'></span>

<h3>Description</h3>

<p>Impute one or more variables using a single R object representing a 
previously fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute(dat, formula, predictor = foretell, ...)

impute_(dat, variables, model, predictor = foretell, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_+3A_dat">dat</code></td>
<td>
<p><code>[data.frame]</code> The data to be imputed.</p>
</td></tr>
<tr><td><code id="impute_+3A_formula">formula</code></td>
<td>
<p><code>[formula]</code> object of the form 
<code>&lt;imputed variables&gt; ~ &lt;model object&gt;</code></p>
</td></tr>
<tr><td><code id="impute_+3A_predictor">predictor</code></td>
<td>
<p><code>[function]</code> with signature <code>object, newdata, ...</code>
that returns predicted values given a model <code>object</code> and a new dataset
<code>newdata</code>. By default <code><a href="#topic+foretell">foretell</a></code> is used.</p>
</td></tr>
<tr><td><code id="impute_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to <code>predictor</code></p>
</td></tr>
<tr><td><code id="impute_+3A_variables">variables</code></td>
<td>
<p><code>[character]</code> Names of columns in <code>dat</code> to impute.</p>
</td></tr>
<tr><td><code id="impute_+3A_model">model</code></td>
<td>
<p>A model object.</p>
</td></tr>
</table>


<h3>Model specification</h3>

<p>Formulas are of the form
</p>
<p><code>IMPUTED_VARIABLES ~ MODEL_OBJECT </code>
</p>
<p>The left-hand-side of the formula object lists the variable or variables to 
be imputed. The right-hand-side must be a model object for which an <code>S3</code>
<code>predict</code> method is implemented. Alternatively, one can specify a custom
predicting function. This function must accept at least a model and a
dataset, and return one predicted value for each row in the dataset.
</p>
<p><code><a href="#topic+foretell">foretell</a></code> implements usefull <code>predict</code> methods for cases
where by default the predicted output is not of the same type as the predicted
variable (e.g. when using certain link functions in <code>glm</code>)
</p>


<h3>Details</h3>

<p><code>impute_</code> is an explicit version of <code>impute</code> that works better in
programming contexts, especially in cases involving nonstandard evaluation.
</p>


<h3>See Also</h3>

<p>Other imputation: 
<code><a href="#topic+impute_cart">impute_cart</a>()</code>,
<code><a href="#topic+impute_hotdeck">impute_hotdeck</a></code>,
<code><a href="#topic+impute_lm">impute_lm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
irisNA &lt;- iris
iris[1:3,1] &lt;- NA
my_model &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data=iris)
impute(irisNA, Sepal.Length ~ my_model)

</code></pre>

<hr>
<h2 id='impute_cart'>Decision Tree Imputation</h2><span id='topic+impute_cart'></span><span id='topic+impute_rf'></span>

<h3>Description</h3>

<p>Imputation based on CART models or Random Forests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_cart(
  dat,
  formula,
  add_residual = c("none", "observed", "normal"),
  cp,
  na_action = na.rpart,
  ...
)

impute_rf(
  dat,
  formula,
  add_residual = c("none", "observed", "normal"),
  na_action = na.omit,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_cart_+3A_dat">dat</code></td>
<td>
<p><code>[data.frame]</code>, with variables to be imputed and their
predictors.</p>
</td></tr>
<tr><td><code id="impute_cart_+3A_formula">formula</code></td>
<td>
<p><code>[formula]</code> imputation model description (see Details below).</p>
</td></tr>
<tr><td><code id="impute_cart_+3A_add_residual">add_residual</code></td>
<td>
<p><code>[character]</code> Type of residual to add. <code>"normal"</code> 
means that the imputed value is drawn from <code>N(mu,sd)</code> where <code>mu</code>
and <code>sd</code> are estimated from the model's residuals (<code>mu</code> should equal
zero in most cases). If <code>add_residual = "observed"</code>, residuals are drawn
(with replacement) from the model's residuals. Ignored for non-numeric 
predicted variables.</p>
</td></tr>
<tr><td><code id="impute_cart_+3A_cp">cp</code></td>
<td>
<p>The complexity parameter used to <code><a href="rpart.html#topic+prune">prune</a></code> the CART model. If
omitted, no pruning takes place. If a single number, the same complexity parameter is
used for each imputed variable. If of length <code>#</code> of variables imputed, the complexity
parameters used must be in the same order as the predicted variables in the <code>model</code>
formula.</p>
</td></tr>
<tr><td><code id="impute_cart_+3A_na_action">na_action</code></td>
<td>
<p><code>[function]</code> what to do with missings in training data.
By default cases with missing values in predicted or predictors are omitted
(see &lsquo;Missings in training data&rsquo;).</p>
</td></tr>
<tr><td><code id="impute_cart_+3A_...">...</code></td>
<td>
<p>further arguments passed to 
</p>

<ul>
<li><p><code><a href="rpart.html#topic+rpart">rpart</a></code> for <code>impute_cart</code>
</p>
</li>
<li><p><code><a href="randomForest.html#topic+randomForest">randomForest</a></code> for <code>impute_rf</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Model specification</h3>

<p>Formulas are of the form
</p>
<p><code>IMPUTED_VARIABLES ~ MODEL_SPECIFICATION [ | GROUPING_VARIABLES ] </code>
</p>
<p>The left-hand-side of the formula object lists the variable or variables to 
be imputed. Variables on the right-hand-side are used as predictors in the
CART or random forest model.
</p>
<p>If grouping variables are specified, the data set is split according to the
values of those variables, and model estimation and imputation occur
independently for each group.
</p>
<p>Grouping using <code>dplyr::group_by</code> is also supported. If groups are 
defined in both the formula and using <code>dplyr::group_by</code>, the data is 
grouped by the union of grouping variables. Any missing value in one of the 
grouping variables results in an error.
</p>


<h3>Methodology</h3>

<p><b>CART imputation</b> by <code>impute_cart</code> can be used for numerical,
categorical, or mixed data. Missing values are estimated using a 
Classification and Regression Tree as specified by Breiman, Friedman and
Olshen (1984). This means that prediction is fairly robust agains missingess
in predictors.
</p>
<p><b>Random Forest imputation</b> with <code>impute_rf</code> can be used for numerical,
categorical, or mixed data. Missing values are estimated using a Random Forest
model as specified by Breiman (2001).
</p>


<h3>References</h3>

<p>Breiman, L., Friedman, J., Stone, C.J. and Olshen, R.A., 1984. Classification
and regression trees. CRC press.
</p>
<p>Breiman, L., 2001. Random forests. Machine learning, 45(1), pp.5-32.
</p>


<h3>See Also</h3>

<p>Other imputation: 
<code><a href="#topic+impute_hotdeck">impute_hotdeck</a></code>,
<code><a href="#topic+impute_lm">impute_lm</a>()</code>,
<code><a href="#topic+impute">impute</a>()</code>
</p>

<hr>
<h2 id='impute_hotdeck'>Hot deck imputation</h2><span id='topic+impute_hotdeck'></span><span id='topic+impute_rhd'></span><span id='topic+impute_shd'></span><span id='topic+impute_pmm'></span><span id='topic+impute_knn'></span>

<h3>Description</h3>

<p>Hot-deck imputation methods include random and sequential hot deck, 
k-nearest neighbours imputation and predictive mean matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_rhd(
  dat,
  formula,
  pool = c("complete", "univariate", "multivariate"),
  prob,
  backend = getOption("simputation.hdbackend", default = c("simputation", "VIM")),
  ...
)

impute_shd(
  dat,
  formula,
  pool = c("complete", "univariate", "multivariate"),
  order = c("locf", "nocb"),
  backend = getOption("simputation.hdbackend", default = c("simputation", "VIM")),
  ...
)

impute_pmm(
  dat,
  formula,
  predictor = impute_lm,
  pool = c("complete", "univariate", "multivariate"),
  ...
)

impute_knn(
  dat,
  formula,
  pool = c("complete", "univariate", "multivariate"),
  k = 5,
  backend = getOption("simputation.hdbackend", default = c("simputation", "VIM")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_hotdeck_+3A_dat">dat</code></td>
<td>
<p><code>[data.frame]</code>, with variables to be imputed and their
predictors.</p>
</td></tr>
<tr><td><code id="impute_hotdeck_+3A_formula">formula</code></td>
<td>
<p><code>[formula]</code> imputation model description (see Details below).</p>
</td></tr>
<tr><td><code id="impute_hotdeck_+3A_pool">pool</code></td>
<td>
<p><code>[character]</code> Specify donor pool when <code>backend="simputation"</code>
</p>

<ul>
<li><p><code>"complete"</code>. Only records for which the variables on the
left-hand-side of the model formula are complete are used as donors. If a
record has multiple missings, all imputations are taken from a single 
donor.
</p>
</li>
<li><p><code>"univariate"</code>. Imputed variables are treated one by one and
independently so the order of variable imputation is unimportant. If a 
record has multiple missings, separate donors are drawn for each missing 
value.
</p>
</li>
<li><p><code>"multivariate"</code>. A donor pool is created for each missing data 
pattern. If a record has multiple missings, all imputations are taken from 
a single donor.
</p>
</li></ul>
</td></tr>
<tr><td><code id="impute_hotdeck_+3A_prob">prob</code></td>
<td>
<p><code>[numeric]</code> Sampling probability weights (passed through to
<code><a href="base.html#topic+sample">sample</a></code>). Must be of length <code>nrow(dat)</code>.</p>
</td></tr>
<tr><td><code id="impute_hotdeck_+3A_backend">backend</code></td>
<td>
<p><code>[character]</code> Choose the backend for imputation. If 
<code>backend="VIM"</code> the variables used to sort the data (in case of
sequential hot deck) may not coincide with imputed variables.</p>
</td></tr>
<tr><td><code id="impute_hotdeck_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="VIM.html#topic+hotdeck">VIM::hotdeck</a></code>
if <code>VIM</code> is chosen as backend, otherwise they are passed to
</p>

<ul>
<li><p><code><a href="base.html#topic+order">order</a></code> for <code>impute_shd</code> and
<code>backend="simputation"</code> 
</p>
</li>
<li><p><code><a href="VIM.html#topic+hotdeck">VIM::hotdeck</a></code>
for <code>impute_shd</code> and <code>impute_rhd</code> when <code>backend="VIM"</code>.
</p>
</li>
<li><p><code><a href="VIM.html#topic+kNN">VIM:kNN</a></code> for <code>impute_knn</code> when 
<code>backend="VIM"</code>
</p>
</li>
<li><p>The <code>predictor</code> function for <code>impute_pmm</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="impute_hotdeck_+3A_order">order</code></td>
<td>
<p><code>[character]</code> Last Observation Carried Forward or Next
Observarion Carried Backward. Only for <code>backend="simputation"</code></p>
</td></tr>
<tr><td><code id="impute_hotdeck_+3A_predictor">predictor</code></td>
<td>
<p><code>[function]</code> Imputation to use for predictive part in
predictive mean matching. Any of the <code>impute_</code> functions of this
package (it makes no sense to use a hot-deck imputation).</p>
</td></tr>
<tr><td><code id="impute_hotdeck_+3A_k">k</code></td>
<td>
<p><code>[numeric]</code> Number of nearest neighbours to draw the donor from.</p>
</td></tr>
</table>


<h3>Model specification</h3>

<p>Formulas are of the form
</p>
<p><code>IMPUTED_VARIABLES ~ MODEL_SPECIFICATION [ | GROUPING_VARIABLES ] </code>
</p>
<p>The left-hand-side of the formula object lists the variable or variables to 
be imputed. The interpretation of the independent variables on the
right-hand-side depends on the imputation method.
</p>

<ul>
<li><p><code>impute_rhd</code> Variables in <code>MODEL_SPECIFICATION</code> and/or 
<code>GROUPING_VARIABLES</code> are used to split the data set into groups prior to
imputation. Use <code>~ 1</code> to specify that no grouping is to be applied.
</p>
</li>
<li><p><code>impute_shd</code> Variables in <code>MODEL_SPECIFICATION</code> are used to 
sort the data. When multiple variables are specified, each variable after
the first serves as tie-breaker for the previous one.
</p>
</li>
<li><p><code>impute_knn</code> The predictors are used to determine Gower's distance
between records (see <code><a href="gower.html#topic+gower_topn">gower_topn</a></code>). This may include the
variables to be imputed..
</p>
</li>
<li><p><code>impute_pmm</code> Predictive mean matching. The
<code>MODEL_SPECIFICATION</code> is passed through to the <code>predictor</code>
function.
</p>
</li></ul>
 
<p>If grouping variables are specified, the data set is split according to the
values of those variables, and model estimation and imputation occur
independently for each group.
</p>
<p>Grouping using <code>dplyr::group_by</code> is also supported. If groups are 
defined in both the formula and using <code>dplyr::group_by</code>, the data is 
grouped by the union of grouping variables. Any missing value in one of the 
grouping variables results in an error.
</p>


<h3>Methodology</h3>

<p><b>Random hot deck imputation</b> with <code>impute_rhd</code> can be applied to
numeric, categorical or mixed data. A missing value is copied from a sampled
record. Optionally samples are taken within a group, or with non-uniform
sampling probabilities. See Andridge and Little (2010) for an overview
of hot deck imputation methods.
</p>
<p><b>Sequential hot deck imputation</b> with <code>impute_rhd</code> can be applied
to numeric, categorical, or mixed data. The dataset is sorted using the
&lsquo;predictor variables&rsquo;. Missing values or combinations thereof are copied
from the previous record where the value(s) are available in the case
of LOCF and from the next record in the case of NOCF. 
</p>
<p><b>Predictive mean matching</b> with <code>impute_pmm</code> can be applied to
numeric data. Missing values or combinations thereof are first imputed using
a predictive model. Next, these predictions are replaced with observed
(combinations of) values nearest to the prediction. The nearest value is the
observed value with the smallest absolute deviation from the prediction.
</p>
<p><b>K-nearest neighbour imputation</b> with <code>impute_knn</code> can be applied 
to numeric, categorical, or mixed data. For each record containing missing 
values, the <code class="reqn">k</code> most similar completed records are determined based on
Gower's (1977) similarity coefficient. From these records the actual donor is
sampled.
</p>


<h3>Using the VIM backend</h3>

<p>The <a href="https://CRAN.R-project.org/package=VIM">VIM</a> package has efficient
implementations of several popular imputation methods. In particular, its 
random and sequential hotdeck implementation is faster and more
memory-efficient than that of the current package. Moreover, <span class="pkg">VIM</span> offers
more fine-grained control over the imputation process then <span class="pkg">simputation</span>.
</p>
<p>If you have this package installed, it can be used by setting
<code>backend="VIM"</code> for functions supporting this option. Alternatively, one
can set <code>options(simputation.hdbackend="VIM")</code> so it becomes the
default. 
</p>
<p>Simputation will map the simputation call to a function in the
<span class="pkg">VIM</span> package. In particular:
</p>

<ul>
<li><p><code>impute_rhd</code> is mapped to <code>VIM::hotdeck</code> where imputed
variables are passed to the <code>variable</code> argument and the union of
predictor and grouping variables are passed to <code>domain_var</code>.
Extra arguments in <code>...</code> are passed to <code>VIM::hotdeck</code> as well.
Argument <code>pool</code> is ignored.
</p>
</li>
<li><p><code>impute_shd</code> is mapped to <code>VIM::hotdeck</code> where
imputed variables are passed to the <code>variable</code> argument, predictor
variables to <code>ord_var</code> and grouping variables to <code>domain_var</code>.
Extra arguments in <code>...</code> are passed to <code>VIM::hotdeck</code> as well.
Arguments <code>pool</code> and <code>order</code> are ignored. In <code>VIM</code> the donor pool
is determined on a per-variable basis, equivalent to setting <code>pool="univariate"</code>
with the simputation backend. <span class="pkg">VIM</span> is LOCF-based. Differences between
<span class="pkg">simputation</span> and <code>VIM</code> likely occurr when the sorting variables contain missings.
</p>
</li>
<li><p><code>impute_knn</code> is mapped to <code>VIM::kNN</code> where imputed variables
are passed to <code>variable</code>, predictor variables are passed to <code>dist_var</code>
and grouping variables are ignored with a message. 
Extra arguments in <code>...</code> are passed to <code>VIM::kNN</code> as well.
Argument <code>pool</code> is ignored.
Note that simputation  adheres stricktly to the Gower's original
definition of the distance measure, while <span class="pkg">VIM</span> uses a generalized variant
that can take ordered factors into account.

</p>
</li></ul>

<p>By default, <span class="pkg">VIM</span>'s imputation functions add indicator variables to the
original data to trace what values have been imputed. This is switched off by
default for consistency with the rest of the simputation package, but it may
be turned on again by setting <code>imp_var=TRUE</code>.
</p>


<h3>References</h3>

<p>Andridge, R.R. and Little, R.J., 2010. A review of hot deck imputation for
survey non-response. International statistical review, 78(1), pp.40-64.
</p>
<p>Gower, J.C., 1971. A general coefficient of similarity and some of its
properties. Biometrics, pp.857&ndash;871.
</p>


<h3>See Also</h3>

<p>Other imputation: 
<code><a href="#topic+impute_cart">impute_cart</a>()</code>,
<code><a href="#topic+impute_lm">impute_lm</a>()</code>,
<code><a href="#topic+impute">impute</a>()</code>
</p>

<hr>
<h2 id='impute_lm'>(Robust) Linear Regression Imputation</h2><span id='topic+impute_lm'></span><span id='topic+impute_rlm'></span><span id='topic+impute_en'></span>

<h3>Description</h3>

<p>Regression imputation methods including linear regression, robust 
linear regression with <code class="reqn">M</code>-estimators, regularized regression
with lasso/elasticnet/ridge regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_lm(
  dat,
  formula,
  add_residual = c("none", "observed", "normal"),
  na_action = na.omit,
  ...
)

impute_rlm(
  dat,
  formula,
  add_residual = c("none", "observed", "normal"),
  na_action = na.omit,
  ...
)

impute_en(
  dat,
  formula,
  add_residual = c("none", "observed", "normal"),
  na_action = na.omit,
  family = c("gaussian", "poisson"),
  s = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_lm_+3A_dat">dat</code></td>
<td>
<p><code>[data.frame]</code>, with variables to be imputed and their
predictors.</p>
</td></tr>
<tr><td><code id="impute_lm_+3A_formula">formula</code></td>
<td>
<p><code>[formula]</code> imputation model description (See Model description)</p>
</td></tr>
<tr><td><code id="impute_lm_+3A_add_residual">add_residual</code></td>
<td>
<p><code>[character]</code> Type of residual to add. <code>"normal"</code> 
means that the imputed value is drawn from <code>N(mu,sd)</code> where <code>mu</code>
and <code>sd</code> are estimated from the model's residuals (<code>mu</code> should equal
zero in most cases). If <code>add_residual = "observed"</code>, residuals are drawn
(with replacement) from the model's residuals. Ignored for non-numeric 
predicted variables.</p>
</td></tr>
<tr><td><code id="impute_lm_+3A_na_action">na_action</code></td>
<td>
<p><code>[function]</code> what to do with missings in training data.
By default cases with missing values in predicted or predictors are omitted
(see &lsquo;Missings in training data&rsquo;).</p>
</td></tr>
<tr><td><code id="impute_lm_+3A_...">...</code></td>
<td>
<p>further arguments passed to 
</p>

<ul>
<li><p><code><a href="stats.html#topic+lm">lm</a></code> for <code>impute_lm</code>
</p>
</li>
<li><p><code><a href="MASS.html#topic+rlm">rlm</a></code> for <code>impute_rlm</code>
</p>
</li>
<li><p><code><a href="glmnet.html#topic+glmnet">glmnet</a></code> for <code>impute_en</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="impute_lm_+3A_family">family</code></td>
<td>
<p>Response type for elasticnet / lasso regression. For 
<code>family="gaussian"</code> the imputed variables are general numeric variables.
For <code>family="poisson"</code> the imputed variables are nonnegative counts.
See <code><a href="glmnet.html#topic+glmnet">glmnet</a></code> for details.</p>
</td></tr>
<tr><td><code id="impute_lm_+3A_s">s</code></td>
<td>
<p>The value of <code class="reqn">\lambda</code> to use when computing predictions for 
lasso/elasticnet regression (parameter <var>s</var> of 
<code><a href="glmnet.html#topic+predict.glmnet">predict.glmnet</a></code>). For <code>impute\_en</code>
the (optional) parameter <var>lambda</var> is passed to
<code><a href="glmnet.html#topic+glmnet">glmnet</a></code> when estimating
the model (which is advised against).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dat</code>, but imputed where possible.
</p>


<h3>Model specification</h3>

<p>Formulas are of the form
</p>
<p><code>IMPUTED_VARIABLES ~ MODEL_SPECIFICATION [ | GROUPING_VARIABLES ] </code>
</p>
<p>The left-hand-side of the formula object lists the variable or variables to 
be imputed. The right-hand side excluding the optional <code>GROUPING_VARIABLES</code> 
model specification for the underlying predictor.
</p>
<p>If grouping variables are specified, the data set is split according to the
values of those variables, and model estimation and imputation occur
independently for each group.
</p>
<p>Grouping using <code>dplyr::group_by</code> is also supported. If groups are 
defined in both the formula and using <code>dplyr::group_by</code>, the data is 
grouped by the union of grouping variables. Any missing value in one of the
grouping variables results in an error.
</p>
<p>Grouping is ignored for <code>impute_const</code>.
</p>


<h3>Methodology</h3>

<p><b>Linear regression model imputation</b> with <code>impute_lm</code> can be used 
to impute numerical variables based on numerical and/or categorical 
predictors. Several common imputation methods, including ratio and (group)
mean imputation can be expressed this way. See <code><a href="stats.html#topic+lm">lm</a></code> for
details on possible model specification.
</p>
<p><b>Robust linear regression through M-estimation</b> with
<code>impute_rlm</code> can be used to impute numerical variables employing
numerical and/or categorical predictors. In <code class="reqn">M</code>-estimation, the
minimization of the squares of residuals is replaced with an alternative
convex function of the residuals that decreases the influence of 
outliers.
</p>
<p>Also see e.g.  Huber (1981).
</p>
<p><b>Lasso/elastic net/ridge regression imputation</b> with <code>impute_en</code> 
can be used to impute numerical variables employing numerical and/or 
categorical predictors. For this method, the regression coefficients are 
found by minimizing the least sum of squares of residuals augmented with a 
penalty term depending on the size of the coefficients. For lasso regression 
(Tibshirani, 1996), the penalty term is the sum of squares of the 
coefficients. For ridge regression (Hoerl and Kennard, 1970), the penalty
term is the sum of absolute values of the coefficients. Elasticnet regression
(Zou and Hastie, 2010) allows switching from lasso to ridge by penalizing by
a weighted sum of the sum-of-squares and sum of absolute values term.
</p>


<h3>References</h3>

<p>Huber, P.J., 2011. Robust statistics (pp. 1248-1251). Springer Berlin Heidelberg.
</p>
<p>Hoerl, A.E. and Kennard, R.W., 1970. Ridge regression: Biased estimation for
nonorthogonal problems. Technometrics, 12(1), pp.55-67.
</p>
<p>Tibshirani, R., 1996. Regression shrinkage and selection via the lasso.
Journal of the Royal Statistical Society. Series B (Methodological),
pp.267-288.
</p>
<p>Zou, H. and Hastie, T., 2005. Regularization and variable selection via the
elastic net. Journal of the Royal Statistical Society: Series B (Statistical
Methodology), 67(2), pp.301-320.
</p>


<h3>See Also</h3>

<p><a href="../doc/intro.html">Getting started with simputation</a>,
</p>
<p>Other imputation: 
<code><a href="#topic+impute_cart">impute_cart</a>()</code>,
<code><a href="#topic+impute_hotdeck">impute_hotdeck</a></code>,
<code><a href="#topic+impute">impute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
irisNA &lt;- iris
irisNA[1:4, "Sepal.Length"] &lt;- NA
irisNA[3:7, "Sepal.Width"] &lt;- NA

# impute a single variable (Sepal.Length)
i1 &lt;- impute_lm(irisNA, Sepal.Length ~ Sepal.Width + Species)

# impute both Sepal.Length and Sepal.Width, using robust linear regression
i2 &lt;- impute_rlm(irisNA, Sepal.Length + Sepal.Width ~ Species + Petal.Length)

</code></pre>

<hr>
<h2 id='impute_median'>Impute (group-wise) medians</h2><span id='topic+impute_median'></span>

<h3>Description</h3>

<p>Impute medians of group-wise medians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_median(
  dat,
  formula,
  add_residual = c("none", "observed", "normal"),
  type = 7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_median_+3A_dat">dat</code></td>
<td>
<p><code>[data.frame]</code>, with variables to be imputed and their
predictors.</p>
</td></tr>
<tr><td><code id="impute_median_+3A_formula">formula</code></td>
<td>
<p><code>[formula]</code> imputation model description (See Model description)</p>
</td></tr>
<tr><td><code id="impute_median_+3A_add_residual">add_residual</code></td>
<td>
<p><code>[character]</code> Type of residual to add. <code>"normal"</code> 
means that the imputed value is drawn from <code>N(mu,sd)</code> where <code>mu</code>
and <code>sd</code> are estimated from the model's residuals (<code>mu</code> should equal
zero in most cases). If <code>add_residual = "observed"</code>, residuals are drawn
(with replacement) from the model's residuals. Ignored for non-numeric 
predicted variables.</p>
</td></tr>
<tr><td><code id="impute_median_+3A_type">type</code></td>
<td>
<p><code>[integer]</code> Specifies the algorithm to compute the median.
See the 'details' section of <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="impute_median_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Model Specification</h3>

<p>Formulas are of the form
</p>
<p><code>IMPUTED_VARIABLES ~ MODEL_SPECIFICATION [ | GROUPING_VARIABLES ] </code>
</p>
<p>The left-hand-side of the formula object lists the variable or variables to 
be imputed. Variables in <code>MODEL_SPECIFICATION</code> and/or 
<code>GROUPING_VARIABLES</code> are used to split the data set into groups prior to
imputation. Use <code>~ 1</code> to specify that no grouping is to be applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# group-wise median imputation
irisNA &lt;- iris
irisNA[1:3,1] &lt;- irisNA[4:7,2] &lt;- NA
a &lt;- impute_median(irisNA, Sepal.Length ~ Species)
head(a)

# group-wise median imputation, all variables except species

a &lt;- impute_median(irisNA, . - Species ~ Species)
head(a)

</code></pre>

<hr>
<h2 id='impute_multivariate'>Multivariate, model-based imputation</h2><span id='topic+impute_multivariate'></span><span id='topic+impute_em'></span><span id='topic+impute_mf'></span>

<h3>Description</h3>

<p>Models that simultaneously optimize imptuation of multiple variables.
Methods include imputation based on EM-estimation of multivariate normal
parameters, imputation based on iterative Random Forest estimates and
stochastic imptuation based on bootstrapped EM-estimatin of multivariate
normal parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_em(dat, formula, verbose = 0, ...)

impute_mf(dat, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_multivariate_+3A_dat">dat</code></td>
<td>
<p><code>[data.frame]</code> with variables to be imputed.</p>
</td></tr>
<tr><td><code id="impute_multivariate_+3A_formula">formula</code></td>
<td>
<p><code>[formula]</code> imputation model description</p>
</td></tr>
<tr><td><code id="impute_multivariate_+3A_verbose">verbose</code></td>
<td>
<p><code>[numeric]</code> Control amount of output printed to screen.
Higher values mean more output, typically per iteration.
</p>

<ul>
<li><p>0 or a number <code class="reqn">\geq 1</code> for <code>impute_em</code>
</p>
</li>
<li><p>0, 1, or 2 for <code>impute_emb</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="impute_multivariate_+3A_...">...</code></td>
<td>
<p>Options passed to 
</p>

<ul>
<li><p><code><a href="norm.html#topic+em.norm">norm::em.norm</a></code> for <code>impute_em</code> 
</p>
</li>
<li><p><code><a href="missForest.html#topic+missForest">missForest::missForest</a></code> for <code>impute_mf</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Model specification</h3>

<p>Formulas are of the form
</p>
<p><code>[IMPUTED_VARIABLES] ~ MODEL_SPECIFICATION [ | GROUPING_VARIABLES ] </code>
</p>
<p>When <code>IMPUTED_VARIABLES</code> is empty, every variable in 
<code>MODEL_SPECIFICATION</code> will be imputed. When <code>IMPUTED_VARIABLES</code> is 
specified, all variables in <code>IMPUTED_VARIABLES</code> and 
<code>MODEL_SPECIFICATION</code> are part of the model, but only the 
<code>IMPUTED_VARIABLES</code> are imputed in the output.
</p>
<p><code>GROUPING_VARIABLES</code> specify what categorical variables are used to
split-impute-combine the data. Grouping using <code>dplyr::group_by</code> is also
supported. If groups are defined in both the formula and using
<code>dplyr::group_by</code>, the data is grouped by the union of grouping
variables. Any missing value in one of the grouping variables results in an
error.
</p>


<h3>Methodology</h3>

<p><b>EM-based imputation</b> with <code>impute_em</code> only works for numerical
variables. These variables are assumed to follow a multivariate normal distribution
for which the means and covariance matrix is estimated based on the EM-algorithm
of Dempster Laird and Rubin (1977). The imputations are the expected values
for missing values, conditional on the value of the estimated parameters.
</p>
<p><b>Multivariate Random Forest imputation</b> with <code>impute_mf</code> works for
numerical, categorical or mixed data types. It is based on the algorithm
of Stekhoven and Buehlman (2012). Missing values are imputed using a
rough guess after which a predictive random forest is trained and used
to re-impute themissing values. This is iterated until convergence.
</p>


<h3>References</h3>

<p>Dempster, Arthur P., Nan M. Laird, and Donald B. Rubin. &quot;Maximum likelihood
from incomplete data via the EM algorithm.&quot; Journal of the royal statistical
society. Series B (methodological) (1977): 1-38.
</p>
<p>Stekhoven, D.J. and Buehlmann, P., 2012. MissForest&mdash;non-parametric missing 
value imputation for mixed-type data. Bioinformatics, 28(1), pp.112-118.
</p>

<hr>
<h2 id='impute_proxy'>Impute by variable derivation</h2><span id='topic+impute_proxy'></span><span id='topic+impute_const'></span>

<h3>Description</h3>

<p>Impute missing values by a constant, by copying another variable computing 
transformations from other variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_proxy(dat, formula, add_residual = c("none", "observed", "normal"), ...)

impute_const(dat, formula, add_residual = c("none", "observed", "normal"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_proxy_+3A_dat">dat</code></td>
<td>
<p><code>[data.frame]</code>, with variables to be imputed and their
predictors.</p>
</td></tr>
<tr><td><code id="impute_proxy_+3A_formula">formula</code></td>
<td>
<p><code>[formula]</code> imputation model description (See Model description)</p>
</td></tr>
<tr><td><code id="impute_proxy_+3A_add_residual">add_residual</code></td>
<td>
<p><code>[character]</code> Type of residual to add. <code>"normal"</code> 
means that the imputed value is drawn from <code>N(mu,sd)</code> where <code>mu</code>
and <code>sd</code> are estimated from the model's residuals (<code>mu</code> should equal
zero in most cases). If <code>add_residual = "observed"</code>, residuals are drawn
(with replacement) from the model's residuals. Ignored for non-numeric 
predicted variables.</p>
</td></tr>
<tr><td><code id="impute_proxy_+3A_...">...</code></td>
<td>
<p>Currently unused</p>
</td></tr>
</table>


<h3>Model Specification</h3>

<p>Formulas are of the form
</p>
<p><code>IMPUTED_VARIABLES ~ MODEL_SPECIFICATION [ | GROUPING_VARIABLES ] </code>
</p>
<p>The left-hand-side of the formula object lists the variable or variables to 
be imputed. 
</p>
<p>For <code>impute_const</code>, the <code>MODEL_SPECIFICATION</code> is a single
value and <code>GROUPING_VARIABLES</code> are ignored.
</p>
<p>For <code>impute_proxy</code>, the <code>MODEL_SPECIFICATION</code> is a variable or
expression in terms of variables in the dataset that must result in either a
single number of in a vector of length <code>nrow(dat)</code>.
</p>
<p>If grouping variables are specified, the data set is split according to the 
values of those variables, and model estimation and imputation occur 
independently for each group.
</p>
<p>Grouping using <code>dplyr::group_by</code> is also supported. If groups are 
defined in both the formula and using <code>dplyr::group_by</code>, the data is 
grouped by the union of grouping variables. Any missing value in one of the 
grouping variables results in an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irisNA &lt;- iris
irisNA[1:3,1] &lt;- irisNA[3:7,2] &lt;- NA

# impute a constant 

a &lt;- impute_const(irisNA, Sepal.Width ~ 7)
head(a)

a &lt;- impute_proxy(irisNA, Sepal.Width ~ 7)
head(a)

# copy a value from another variable (where available)
a &lt;- impute_proxy(irisNA, Sepal.Width ~ Sepal.Length)
head(a)

# group mean imputation
a &lt;- impute_proxy(irisNA
  , Sepal.Length ~ mean(Sepal.Length,na.rm=TRUE) | Species)
head(a)

# random hot deck imputation
a &lt;- impute_proxy(irisNA, Sepal.Length ~ mean(Sepal.Length, na.rm=TRUE)
, add_residual = "observed")

# ratio imputation (but use impute_lm for that)
a &lt;- impute_proxy(irisNA, 
  Sepal.Length ~ mean(Sepal.Length,na.rm=TRUE)/mean(Sepal.Width,na.rm=TRUE) * Sepal.Width)

</code></pre>

<hr>
<h2 id='na_status'>Show the number of (remaining) missing values.</h2><span id='topic+na_status'></span>

<h3>Description</h3>

<p>Quick indication of the amount and location of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na_status(
  x,
  show_only_missing = TRUE,
  sort_columns = show_only_missing,
  show_message = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na_status_+3A_x">x</code></td>
<td>
<p>an R object caryying data (e.g. <code>data.frame</code>)</p>
</td></tr>
<tr><td><code id="na_status_+3A_show_only_missing">show_only_missing</code></td>
<td>
<p>if <code>TRUE</code> only columns with <code>NA</code>'s will be
printed.</p>
</td></tr>
<tr><td><code id="na_status_+3A_sort_columns">sort_columns</code></td>
<td>
<p>If <code>TRUE</code> the columns are sorted descending 
by the number of missing values.</p>
</td></tr>
<tr><td><code id="na_status_+3A_show_message">show_message</code></td>
<td>
<p>if <code>TRUE</code> message will be printed.</p>
</td></tr>
<tr><td><code id="na_status_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the column and number of NA's
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glimpse_na">glimpse_na</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>irisNA &lt;- iris
irisNA[1:3,1] &lt;- irisNA[3:7,2] &lt;- NA
na_status(irisNA)

# impute a constant 
a &lt;- impute_const(irisNA, Sepal.Width ~ 7)
na_status(a)
</code></pre>

<hr>
<h2 id='na.roughfix'>Rough imputation for handling missing predictors.</h2><span id='topic+na.roughfix'></span>

<h3>Description</h3>

<p>This function is re-exported from
<code><a href="randomForest.html#topic+na.roughfix">randomForest:na.roughfix</a></code> when
available. Otherwise it will throw a warning and resort to
<code>options("na.action")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>na.roughfix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.roughfix_+3A_object">object</code></td>
<td>
<p>an R object caryying data (e.g. <code>data.frame</code>)</p>
</td></tr>
<tr><td><code id="na.roughfix_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.simputation.capabilities'>print output of simputation_capabilities</h2><span id='topic+print.simputation.capabilities'></span>

<h3>Description</h3>

<p>print output of simputation_capabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simputation.capabilities'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.simputation.capabilities_+3A_x">x</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="print.simputation.capabilities_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+na.rpart'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>rpart</dt><dd><p><code><a href="rpart.html#topic+na.rpart">na.rpart</a></code></p>
</dd>
</dl>

<hr>
<h2 id='simputation'>simputation</h2><span id='topic+simputation'></span>

<h3>Description</h3>

<p>A package to make imputation simpler.
</p>


<h3>Details</h3>

<p>To get started, see the <a href="../doc/intro.html">introductory vignette</a>.
</p>

<hr>
<h2 id='simputation_capabilities'>Capabilities depending on suggested packages.</h2><span id='topic+simputation_capabilities'></span><span id='topic+simputation_suggests'></span>

<h3>Description</h3>

<p>This function has bevome unnecessary as of <code>simputation</code> 0.2.8 and higher.
It will be removed from future versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simputation_capabilities()

simputation_suggests(lib.loc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simputation_capabilities_+3A_lib.loc">lib.loc</code></td>
<td>
<p>Where to check whether a package is installed (passed to
<code><a href="utils.html#topic+installed.packages">installed.packages</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>simputation_capabilities</code> A named <code>character</code> vector of class
<code>simputation.capabilities</code>. The class attribute allows pretty-printing
of the output.
</p>
<p>For <code>simputation_suggests</code> a <code>logical</code> vector, stating which
suggested packages are currently installed (<code>TRUE</code>) or not
(<code>FALSE</code>).
</p>


<h3>details</h3>

<p><code>simputation_capabilities</code> Calls every <code>impute_</code> function and
grabs the warning message (if any) stating that a package is missing.
</p>
<p><code>simputation_suggests</code> checks which of the suggested packages
implementing statistical models are available.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
