<!DOCTYPE html><html lang="en-US"><head><title>Help for package pdfCluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pdfCluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pdfCluster-package'><p>The pdfCluster package: summary information</p></a></li>
<li><a href='#adj.rand.index'>
<p>Adjusted Rand index</p></a></li>
<li><a href='#dbs'><p>Density-based silhouette information methods</p></a></li>
<li><a href='#dbs-class'><p>Class &quot;dbs&quot;</p></a></li>
<li><a href='#groups'><p>Extracts groups</p></a></li>
<li><a href='#h.norm'>
<p>Normal optimal choice of smoothing parameter in density estimation</p></a></li>
<li><a href='#hprop2f'>
<p>Sample smoothing parameters in adaptive density estimation</p></a></li>
<li><a href='#kepdf'>
<p>Kernel estimate of a probability density function.</p></a></li>
<li><a href='#kepdf-class'><p>Class &quot;kepdf&quot;</p></a></li>
<li><a href='#oliveoil'><p>Olive oil data</p></a></li>
<li><a href='#pdfClassification'>
<p>Classification of low density data</p></a></li>
<li><a href='#pdfCluster'><p> Clustering via nonparametric density estimation</p></a></li>
<li><a href='#pdfCluster-class'><p>Class &quot;pdfCluster&quot;</p></a></li>
<li><a href='#plot-methods'><p>Methods for function plot</p></a></li>
<li><a href='#plot+2Cdbs-method'>
<p>Plot objects of class dbs</p></a></li>
<li><a href='#plot+2Ckepdf-method'>
<p>Plot objects of class kepdf</p></a></li>
<li><a href='#plot+2CpdfCluster-method'>
<p>Plot objects of class pdfCluster</p></a></li>
<li><a href='#show-methods'><p>Methods for Function show</p></a></li>
<li><a href='#summary-methods'><p>Methods for Function summary</p></a></li>
<li><a href='#wine'><p>Wine data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cluster Analysis via Nonparametric Density Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Menardi Giovanna &lt;menardi@stat.unipd.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Cluster analysis via nonparametric density 
   estimation is performed. Operationally, the kernel method is used throughout to estimate
   the density. Diagnostics methods for evaluating the quality of the clustering 
   are available. The package includes also a routine to estimate the 
   probability density function obtained by the kernel method, given a set of
   data with arbitrary dimensions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>geometry, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cluster</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-01 16:50:50 UTC; giovanna</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-02 09:50:02 UTC</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Author:</td>
<td>Menardi Giovanna [aut, cre],
  Azzalini Adelchi [aut],
  Rosolin Tiziana [ctb] (up to version 0.1-13)</td>
</tr>
</table>
<hr>
<h2 id='pdfCluster-package'>The pdfCluster package: summary information</h2><span id='topic+pdfCluster-package'></span>

<h3>Description</h3>

<p>This package performs cluster analysis via kernel density estimation (Azzalini 
and Torelli, 2007; Menardi and Azzalini, 2014). 
Clusters are associated to the maximally connected components with estimated 
density above a threshold. As the threshold varies, these clusters may be 
represented according to a hierarchical structure in the form of a tree. 
Detection of the connected regions is conducted by means of the Delaunay 
tesselation when data dimensionality is low to moderate, following Azzalini
and Torelli (2007). For higher dimensional data, detection of connected regions
is performed according to the procedure described in Menardi and Azzalini (2013).
In both cases, after that a number of high-density cluster-cores is identified, 
lower density data are allocated by following a supervised classification-like
approach. The number of clusters, corresponding to the number of the modes of the 
estimated density, is automatically selected by the procedure. 
Diagnostics methods for evaluating the quality of clustering are also available
(Menardi, 2011). Moreover, the package provides a routine to estimate the 
probability density function by kernel methods, given a set of data with 
arbitrary dimension. The main features of the package are described and illustrated
in Azzalini and Menardi (2014).
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+pdfCluster-package">pdfCluster-package</a></code> makes use of classes and methods of the 
S4 system.
It includes some foreign functions written in the C language: two of them
compute the kernel density estimate of data and are interfaced by the R 
function <code><a href="#topic+kepdf">kepdf</a></code>. 
Other C routines included in the package allow for a quicker detection of the
connected components of the subgraphs associated with the level sets of the data.
Two of them are directly drawn from the homonymous ones in the <code><a href="spdep.html#topic+spdep">spdep</a></code> 
package. 
</p>
<p>Starting from version 1.0-0, new features have been introduced: 
</p>

<ul>
<li><p>kernel density estimation may be performed by using either a
a fixed or an adaptive bandwidth; moreover, the option of selecting 
a Student's <code class="reqn">t</code> kernel has been included, for computational convenience;
</p>
</li>
<li><p>detection of connected components of the level sets is performed
by means of the Delaunay triangulation when data dimensionality is 
up to 6, following Azzalini and Torelli (2007); 
for higher dimensional data a new procedure, which is less time-consuming,
is now adopted (Menardi and Azzalini, 2014);
</p>
</li>
<li><p>the order of classification of lower density data depends now also on
the standard error of the estimated density ratios; moreover, a cluster-specific 
bandwidth is the default option to classify low density data.
</p>
</li></ul>

<p>See examples below to understand how to set arguments of the main function
of the package, in order to obtain the same results as the ones obtained with
versions 0.1-x.
</p>


<h3>Author(s)</h3>

<p>Adelchi Azzalini, Giovanna Menardi, Tiziana Rosolin
</p>
<p>Maintainer: Giovanna Menardi &lt;menardi at stat.unipd.it&gt;
</p>


<h3>References</h3>

<p>Azzalini, A., Menardi, G. (2014). Clustering via Nonparametric Density Estimation: The R Package pdfCluster.
<em>Journal of Statistical Software</em>, 57(11), 1-26,
URL http://www.jstatsoft.org/v57/i11/.
</p>
<p>Azzalini A., Torelli N. (2007). Clustering via nonparametric density estimation.
<em>Statistics and Computing</em>, 17, 71-80.
</p>
<p>Menardi G. (2011). Density based Silhouette diagnostics for clustering methods.
<em>Statistics and Computing</em>, 21, 295-308.
</p>
<p>Menardi G., Azzalini, A. (2014). An advancement in clustering via nonparametric density estimation.
<em>Statistics and Computing</em>, DOI: 10.1007/s11222-013-9400-x, to appear.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(wine)
gr &lt;- wine[, 1]

# select a subset of variables
x &lt;- wine[, c(2, 5, 8)]

#density estimation
pdf &lt;- kepdf(x)
summary(pdf)
plot(pdf)

#clustering
cl &lt;- pdfCluster(x)
summary(cl)
plot(cl)

#comparison with original groups
table(groups(cl),gr)

#density based silhouette diagnostics
dsil &lt;- dbs(cl)
plot(dsil)

##########
# higher dimensions

x &lt;- wine[, -1]

#density estimation with adaptive bandwidth 
pdf &lt;- kepdf(x, bwtype="adaptive")
summary(pdf)
#density plot is not much clear for high- dimensional data
#select a few variables
plot(pdf, indcol = c(1,4,7))

#clustering
#when dimension is &gt;= 6, default method to find connected components is "pairs"
#density is better estimated by using an adaptive bandwidth
cl &lt;- pdfCluster(x, bwtype="adaptive")
summary(cl)
plot(cl)

########
# this example shows how to set the arguments in function pdfCluster
# in order to obtain the same results as the ones of versions 0.1-x.
x &lt;- wine[, c(2, 5, 8)]

# previous versions of the package 
# do not run
# old code: 
# cl &lt;- pdfCluster(x)

# same result is obtained now obtained as follows:
cl &lt;- pdfCluster(x, se=FALSE, hcores= TRUE, graphtype="delaunay", n.grid=50)
</code></pre>

<hr>
<h2 id='adj.rand.index'>
Adjusted Rand index</h2><span id='topic+adj.rand.index'></span>

<h3>Description</h3>

<p>Computes the adjusted Rand index to compare two alternative partitions of the same set. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj.rand.index(cl1, cl2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adj.rand.index_+3A_cl1">cl1</code></td>
<td>

<p>the vector containining the class labels of the first partition.</p>
</td></tr>
<tr><td><code id="adj.rand.index_+3A_cl2">cl2</code></td>
<td>

<p>the vector containining the class labels of the second partition.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adjusted Rand index is a correction of the Rand index that measures the similarity between two classifications of
the same objects by the proportions of agreements between the two partitions. The correction is obtained by subtracting from the Rand index its expected value. 
</p>


<h3>Value</h3>

<p>A numeric vector of length 1.    
</p>


<h3>References</h3>

<p>L. Hubert and P. Arabie (1985) Comparing partitions, <em>Journal of Classification</em>, 2, 193-218. </p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(wine)
#actual groups
gr &lt;- wine[, 1]

# select a subset of variables
x &lt;- wine[, c(2, 5, 8)]

#clustering
cl &lt;- pdfCluster(x)

#comparison with original groups
table(groups(cl), gr)
adj.rand.index(groups(cl), gr)
</code></pre>

<hr>
<h2 id='dbs'>Density-based silhouette information methods</h2><span id='topic+dbs'></span><span id='topic+dbs-methods'></span><span id='topic+dbs+2Cmatrix+2Cnumeric-method'></span><span id='topic+dbs+2CpdfCluster+2Cmissing-method'></span><span id='topic+dbs+2Cmatrix-method'></span><span id='topic+dbs+2CpdfCluster-method'></span>

<h3>Description</h3>

<p>Computes the density-based silhouette information of clustered data. Two methods are associated to this function. The first
method applies to two arguments: the matrix of data and the vector of cluster labels; the second method applies to objects of 
<code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
dbs(x, clusters, h.funct="h.norm", hmult=1, prior, ...)

## S4 method for signature 'pdfCluster'
dbs(x, h.funct="h.norm", hmult = 1, prior = 
   as.vector(table(x@cluster.cores)/sum(table(x@cluster.cores))), 
   stage=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbs_+3A_x">x</code></td>
<td>

<p>A matrix of data points partitioned by any density-based clustering method or an object of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.</p>
</td></tr>
<tr><td><code id="dbs_+3A_clusters">clusters</code></td>
<td>

<p>Cluster labels of grouped data. This argument has not to be set when <code>x</code> is a <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code> object.
</p>
</td></tr>
<tr><td><code id="dbs_+3A_h.funct">h.funct</code></td>
<td>

<p>Function to estimate the smoothing parameters. Default is <code><a href="#topic+h.norm">h.norm</a></code>. 
</p>
</td></tr>
<tr><td><code id="dbs_+3A_hmult">hmult</code></td>
<td>

<p>Shrink factor to be multiplied by the smoothing parameters. Default value is 1. 
</p>
</td></tr>
<tr><td><code id="dbs_+3A_prior">prior</code></td>
<td>

<p>Vector of prior probabilities of belonging to the groups. When <code>x</code> is of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>,
default value is set proportional to the cluster cores cardinalities. Otherwise, equal prior probabilities are 
given to the clusters by default. 
</p>
</td></tr>
<tr><td><code id="dbs_+3A_stage">stage</code></td>
<td>

<p>When <code>x</code> is a <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code> object, this is the stage of classification of low-density data at which the dbs has to be computed.
Default value is the number of stages of the procedure. Set it to 0 if the dbs has to be computed at cluster cores only.</p>
</td></tr>
<tr><td><code id="dbs_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to methods (see <code><a href="#topic+dbs-methods">dbs-methods</a></code>) or arguments to <code><a href="#topic+kepdf">kepdf</a></code>. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides diagnostics for a clustering produced by any density-based clustering method. The <code>dbs</code>
information is a suitable modification of the <code><a href="cluster.html#topic+silhouette">silhouette</a></code> information aimed at evaluating 
the cluster quality in a density based framework. It is based on the estimation of data posterior probabilities of belonging to the clusters. It may be 	 
used to measure the quality of data allocation to the clusters. High values of the <code class="reqn">\hat{dbs}</code> are evidence of a good quality clustering. 	 
</p>
<p>Define
</p>
<p style="text-align: center;"><code class="reqn">
\hat{\tau}_m(x_i)=\frac{\pi_{m} \hat{f}(x_i|x_ \in m)}{\sum_{m=1}^M \pi_{m}\hat{f}(x_i|x_i \in m)} \quad m=1,\ldots,M, 
</code>
</p>

<p>where <code class="reqn">\pi_{m}</code> is a prior probability of <code class="reqn">m</code> and <code class="reqn">\hat{f}(x_i|x_i \in m)</code> is a density estimate at <code class="reqn">x_i</code> evaluated with function <code><a href="#topic+kepdf">kepdf</a></code> by using the only data points in <code class="reqn">m</code>. Density estimation is performed with fixed bandwidths <code>h</code>, as evaluated by function <code>h.funct</code>, possibly multiplied by the shrink factor <code>hmult</code>.
</p>
<p>Density-based silhouette information of <code class="reqn">x_i</code>, the <code class="reqn">i^{th}</code> row of the data matrix <code>x</code>, is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">
\hat{dbs}_i=\frac{\log\left(\frac{\hat{\tau}_{m_{0}}(x_i)}{\hat{\tau}_{m_{1}}(x_i)}\right)}{{\max}_{x_i }\left| \log\left(\frac{\hat{\tau}_{m_{0}}(x_i)}{\hat{\tau}_{m_{1}}(x_i)}\right)\right|},
</code>
</p>

<p>where <code class="reqn">m_0</code> is the group where <code class="reqn">x_i</code> has been allocated and <code class="reqn">m_1</code> is the group for which <code class="reqn">\tau_m</code> is maximum, <code class="reqn">m\neq m_0</code>. 
</p>
<p><em>Note:</em> when there exists <code class="reqn">x_j</code> such that <code class="reqn">\hat{\tau}_{m_{1}}(x_j)</code> is zero, <code class="reqn">\hat{dbs}_j</code> is forced to 1 and <code class="reqn">{\max}_{x_i }\left| \log\left(\frac{\hat{\tau}_{m_{0}}(x_i)}{\hat{\tau}_{m_{1}}(x_i)}\right)\right|</code>
is computed by excluding <code class="reqn">x_j</code> from the data matrix <code>x</code>.
</p>
<p>See Menardi (2011) for a detailed treatment.</p>


<h3>Value</h3>

<p>An object of class <code>"dbs"</code>, with slots:  
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The matrix of clustered data points.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>The vector of prior probabilities of belonging to the groups.</p>
</td></tr>
<tr><td><code>dbs</code></td>
<td>
<p>A vector reporting the density-based silhouette information of the clustered data.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>Cluster labels of grouped data.</p>
</td></tr>
<tr><td><code>noc</code></td>
<td>
<p>Number of clusters</p>
</td></tr>
<tr><td><code>stage</code></td>
<td>
<p>If argument <code>x</code> of <code>dbs</code> is a  <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code> object, this slot provides the stage of the classification at which the dbs is computed.</p>
</td></tr>
</table>
<p>See <code><a href="#topic+dbs-class">dbs-class</a></code> for more details.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "matrix", clusters = "numeric")</code></dt><dd>
<p>Computes the density based silhouette information for objects partitioned 
according to any density-based clustering method.
</p>
</dd>
<dt><code>signature(x = "pdfCluster", clusters = "missing")</code></dt><dd>
<p>Computes the density based silhouette information for objects of class 
<code>"pdfCluster"</code></p>
</dd></dl>
<p>.
</p>


<h3>References</h3>

<p>Menardi, G. (2011) Density-based Silhouette diagnostics for clustering methods. <em>Statistics and Computing</em>, 21, 295-308.</p>


<h3>See Also</h3>

<p><code><a href="#topic+dbs-class">dbs-class</a></code>, <code><a href="#topic+plot+2Cdbs-method">plot,dbs-method</a></code>, <code><a href="cluster.html#topic+silhouette">silhouette</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example 1: no groups in data
#random generation of group labels
set.seed(54321)
x &lt;- rnorm(50)
groups &lt;- sample(1:2, 50, replace = TRUE)
groups
dsil &lt;- dbs(x = as.matrix(x), clusters=groups)
dsil
summary(dsil)
plot(dsil, labels=TRUE, lwd=6)

#example 2: wines data
# load data
data(wine)

# select a subset of variables
x &lt;- wine[, c(2,5,8)]

#clustering
cl &lt;- pdfCluster(x)
 
dsil &lt;- dbs(cl)
plot(dsil)

</code></pre>

<hr>
<h2 id='dbs-class'>Class &quot;dbs&quot;</h2><span id='topic+dbs-class'></span><span id='topic+summary.dbs'></span><span id='topic+show+2Cdbs-method'></span>

<h3>Description</h3>

<p>This class pertains to results of the application of function 
<code><a href="#topic+dbs">dbs</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("dbs", ...)</code> or as a 
result from calling function <code><a href="#topic+dbs">dbs</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code> reporting the matched 
call. </p>
</dd>   
<dt><code>x</code>:</dt><dd><p>Object of class <code>"matrix"</code> representing the clustered
data points. </p>
</dd>
<dt><code>prior</code>:</dt><dd><p>Object of class <code>"numeric"</code> being the prior 
probabilities of belonging to the groups. </p>
</dd>
<dt><code>dbs</code>:</dt><dd><p>Object of class <code>"numeric"</code> reporting the 
density-based silhouette information of the clustered data. </p>
</dd>
<dt><code>clusters</code>:</dt><dd><p>Object of class <code>"numeric"</code> reporting the 
group labels of grouped data. </p>
</dd>
<dt><code>noc</code>:</dt><dd><p>Object of class <code>"numeric"</code> indicating the number 
of clusters.</p>
</dd>
<dt><code>stage</code>:</dt><dd><p>Object of class <code>"ANY"</code> corresponding to the 
stage of the classification at which the density-based silhouette information
is computed when <code><a href="#topic+dbs">dbs</a></code> is applied to an object of 
<code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "dbs", y = "missing")</code>: 
</p>
<p>S4 method for plotting objects of <code><a href="#topic+dbs-class">dbs-class</a></code>. Data are partitioned
into the clusters, sorted in a decreasing order with respect to their dbs value
and displayed on a bar graph. See <code><a href="#topic+plot+2Cdbs-method">plot,dbs-method</a></code> for further details.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "dbs")</code>: 
</p>
<p>S4 method for showing objects of <code><a href="#topic+dbs-class">dbs-class</a></code>. The following 
elements are shown:
</p>

<ul>
<li> <p>the dbs index computed at the observed data;
</p>
</li>
<li> <p>The cluster membership of each data point;
</p>
</li></ul>
	</dd>
<dt>summary</dt><dd><p><code>signature(object = "dbs")</code>: 
</p>
<p>S4 method for summarizing objects of <code><a href="#topic+dbs-class">dbs-class</a></code>. The following
elements are shown:
</p>

<ul>
<li> <p>a summary (minimum, 1st quartile, median, mean, 3rd quartile, 
maximum) of the dbs values for each cluster;
</p>
</li>
<li> <p>a summary (minimum, 1st quartile, median, mean, 3rd quartile, 
maximum) of the dbs values for all the observations.
</p>
</li></ul>
	</dd>
</dl>
	 


<h3>See Also</h3>

<p><code><a href="#topic+dbs">dbs</a></code>, <code><a href="cluster.html#topic+silhouette">silhouette</a></code>,
<code><a href="#topic+plot+2Cdbs-method">plot,dbs-method</a></code>, <code><a href="#topic+plot-methods">plot-methods</a></code>, 
<code><a href="#topic+show-methods">show-methods</a></code>, <code><a href="#topic+summary-methods">summary-methods</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("dbs")

#wine example
#data loading
data(wine)

# select a subset of variables
x &lt;- wine[, c(2,5,8)]

#clustering
cl &lt;- pdfCluster(x)
 
dsil &lt;- dbs(cl)
dsil
summary(dsil)
</code></pre>

<hr>
<h2 id='groups'>Extracts groups</h2><span id='topic+groups'></span>

<h3>Description</h3>

<p>Extracts the detected groups from objects of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groups(obj, stage = length(obj@stages))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groups_+3A_obj">obj</code></td>
<td>

<p>An object of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>
</p>
</td></tr>
<tr><td><code id="groups_+3A_stage">stage</code></td>
<td>

<p>The stage of classification at which the clusters have to be extracted. Set this value to 0
to extract the cluster cores. Default value is the total number of classification stages, that is, 
the final partition is given. When <code>obj</code> contains the clusters cores only, these are given by default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an user-friendly version of command <code>obj@clusters</code>, now obsolete, to ease
extraction of groups from objects of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector containing the group labels. NA values are associated to points not classified at the
selected stage of the classification procedure.   
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdfCluster">pdfCluster</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(wine)

# select a subset of variables
x &lt;- wine[, c(2, 5, 8)]

#clustering
cl &lt;- pdfCluster(x)

groups(cl)

#equivalent to:
cl@clusters

#to extract the cluster cores
groups(cl, stage = 0)
</code></pre>

<hr>
<h2 id='h.norm'>
Normal optimal choice of smoothing parameter in density estimation
</h2><span id='topic+h.norm'></span>

<h3>Description</h3>

<p>This function computes the smoothing parameter to be used in kernel density estimation, as asymptotically optimal
when the underlying distribution is Normal. Unidimensional as well as multidimensional data
can be handled. When multidimensional data are supplied, a vector of smoothing parameters is computed having one element for each 
component. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h.norm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h.norm_+3A_x">x</code></td>
<td>

<p>vector, matrix or data-frame of data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The smoothing parameter of component <code class="reqn">j</code> of a <code class="reqn">n\times d</code> data matrix is estimated as follows:
</p>
<p style="text-align: center;"><code class="reqn">\sigma_j{\left(\frac{4}{(d+2)n }\right)}^{\frac{1}{d+4}}</code>
</p>

<p>where <code class="reqn">\sigma_j</code> is the estimated standard deviation of component <code class="reqn">j</code>.
See Section 2.4.2 of the reference below.
</p>


<h3>Value</h3>

<p>Returns a numeric vector with the same length as the number of columns of <code>x</code> or with length one if <code>x</code> is a vector. When <code>x</code> is a matrix,
a vector of smoothing parameters is provided having one element for each component.    
</p>


<h3>References</h3>

<p>Bowman, A.W. and Azzalini, A. (1997). <em>Applied smoothing techniques for data analysis: the kernel approach with S-Plus illustrations</em>. Oxford University Press, Oxford.
</p>


<h3>See Also</h3>

<p><code><a href="sm.html#topic+hnorm">hnorm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(30)
sm.par &lt;- h.norm(x)
pdf &lt;- kepdf(x, bwtype= "fixed", h = sm.par)
plot(pdf, eval.points=seq(-4,4,by=.2))
</code></pre>

<hr>
<h2 id='hprop2f'>
Sample smoothing parameters in adaptive density estimation
</h2><span id='topic+hprop2f'></span>

<h3>Description</h3>

<p>This function computes the sample smoothing parameters to be used in adaptive kernel density estimation, according to Silverman (1986).   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hprop2f(x, h = h.norm(x), alpha = 1/2, kernel = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hprop2f_+3A_x">x</code></td>
<td>

<p>Vector or matrix of data.</p>
</td></tr>
<tr><td><code id="hprop2f_+3A_h">h</code></td>
<td>

<p>Vector of smoothing parameters to be used to get a pilot estimate of the density function. It has length equal to <code>NCOL(x)</code>.
</p>
</td></tr>
<tr><td><code id="hprop2f_+3A_alpha">alpha</code></td>
<td>

<p>Sensitivity parameter satysfying <code class="reqn">0 \leq \alpha \leq 1</code>, giving the power to which raise the pilot density. Default value is 1/2.
See details.	
</p>
</td></tr>
<tr><td><code id="hprop2f_+3A_kernel">kernel</code></td>
<td>

<p>Kernel to be used to compute the pilot density estimate. It should be one of 
&quot;gaussian&quot; or &quot;t7&quot;. See <code><a href="#topic+kepdf">kepdf</a></code> for further details.	
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vector of smoothing parameters <code class="reqn">h_{i}</code> is chosen for each sample point <code class="reqn">x_i</code>, as follows:
</p>
<p style="text-align: center;"><code class="reqn">h_i = h \left(\frac{\hat{f}_h(x_i)}{g}\right)^{- \alpha }</code>
</p>

<p>where <code class="reqn">\hat{f}_h</code> is a pilot kernel density estimate of the density function <code class="reqn">f</code>, with vector of bandwidths <code>h</code>,
and <code class="reqn">g</code> is the geometric mean of <code class="reqn">\hat{f}_h(x_i)</code>,
<code class="reqn">i=1, ..., n</code>.
See Section 5.3.1 of the reference below.
</p>


<h3>Value</h3>

<p>Returns a matrix with the same dimensions of <code>x</code> where row <code class="reqn">i</code> provides
the vector of smoothing parameters for sample point <code class="reqn">x_i</code>.    
</p>


<h3>References</h3>

<p>Silverman, B. (1986). <em>Density estimation for statistics and data analysis</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code>h.norm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(10)

sm.par &lt;- hprop2f(x)
pdf &lt;- kepdf(x, bwtype= "adaptive")

pdf@par$hx
sm.par

plot(pdf,eval.points=seq(-4,4,by=.2))
</code></pre>

<hr>
<h2 id='kepdf'>
Kernel estimate of a probability density function. 
</h2><span id='topic+kepdf'></span>

<h3>Description</h3>

<p>Estimates density of uni- and multivariate data by the kernel method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kepdf(x, eval.points = x, kernel = "gaussian", 
      bwtype = "fixed", h = h.norm(x), hx = NULL, alpha = 1/2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kepdf_+3A_x">x</code></td>
<td>

<p>A vector, a matrix or data-frame of data whose density should be estimated.  
</p>
</td></tr>
<tr><td><code id="kepdf_+3A_eval.points">eval.points</code></td>
<td>

<p>A vector, a matrix or a data-frame of data points at which the density estimate should be evaluated.  
</p>
</td></tr>
<tr><td><code id="kepdf_+3A_kernel">kernel</code></td>
<td>

<p>Either 'gaussian' or 't7', it defines the kernel function to be used. See details below.
</p>
</td></tr>
<tr><td><code id="kepdf_+3A_bwtype">bwtype</code></td>
<td>

<p>Either 'fixed' or 'adaptive', corresponding to a kernel estimator with fixed or adaptive bandwidths respectively. 
See details below.
</p>
</td></tr>
<tr><td><code id="kepdf_+3A_h">h</code></td>
<td>

<p>A vector of length set to <code>NCOL(x)</code>, defining the smoothing parameters to be used either to estimate
the density in kernel estimation with fixed bandwidth or to estimate the pilot density in kernel estimation 
with adaptive bandwidths. Default value is the result of <code><a href="#topic+h.norm">h.norm</a></code> applied to <code>x</code>. 
</p>
</td></tr>
<tr><td><code id="kepdf_+3A_hx">hx</code></td>
<td>

<p>A matrix with the same number of rows and columns as <code>x</code>, where each row defines the vector of smoothing parameters 
specific for each sample point. To be used when <code>bwtype = "adaptive"</code>. Default value is the result of <code><a href="#topic+hprop2f">hprop2f</a></code> 
applied to <code>x</code>. Set to NULL when <code>bwtype= "fixed"</code>. 
</p>
</td></tr>
<tr><td><code id="kepdf_+3A_alpha">alpha</code></td>
<td>

<p>Sensitivity parameter to be given to <code><a href="#topic+hprop2f">hprop2f</a></code> when <code>bwtype= "adaptive"</code> and the vectors of smoothing parameters are computed according to Silverman's (1986) approach.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current version of <code><a href="#topic+pdfCluster-package">pdfCluster-package</a></code> allows for computing estimates by a kernel product 
estimator of the form: 
</p>
<p style="text-align: center;"><code class="reqn">\hat{f}(y)= \sum_{i=1}^n \frac{1}{n h_{i,1} \cdots h_{i,d}} \prod_{j=1}^d K\left(\frac{y_{j} - x_{i,j}}{h_{i,j}}\right).
</code>
</p>

<p>The kernel function <code class="reqn">K</code> can either be a Gaussian density (if <code>kernel = "gaussian"</code>) or a <code class="reqn">t_\nu</code> density, with <code class="reqn">\nu = 7</code> degrees of freedom (when <code>kernel = "t7"</code>).
Although uncommon, the option of selecting a <code class="reqn">t</code> kernel is motivated by computational efficiency reasons. Hence, its use is suggested when either <code>x</code> or <code>eval.points</code> have a huge number of rows.
</p>
<p>The vectors of bandwidths <code class="reqn">h_{i} = (h_{i,1} \cdots h_{i,d})'</code> are defined as follows: 
</p>

<dl>
<dt>Fixed bandwidth</dt><dd><p> When <code>bwtype='fixed'</code>, <code class="reqn">h_{i} = h</code> that is, a constant smoothing 
vector is used for all the observations <code class="reqn">x_i</code>. Default values are set as asymptotically optimal for a multivariate Normal distribution (e.g., Bowman and Azzalini, 1997).
See <code><a href="#topic+h.norm">h.norm</a></code> for further details.</p>
</dd>
<dt>Adaptive bandwidth</dt><dd><p>When <code>bwtype='adaptive'</code>, a vector of bandwidths <code class="reqn">h_i</code> is  
specified for each observation <code class="reqn">x_i</code>. Default values are selected according to Silverman 
(1986, Section 5.3.1). See <code><a href="#topic+hprop2f">hprop2f</a></code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>An S4 object of <code><a href="#topic+kepdf-class">kepdf-class</a></code> with slots:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>   
<tr><td><code>x</code></td>
<td>
<p>The data input, coerced to be a matrix.</p>
</td></tr> 
<tr><td><code>eval.points</code></td>
<td>
<p>The data points at which the density is evaluated.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>The values of the density estimate at the evaluation points.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>The selected kernel.</p>
</td></tr>
<tr><td><code>bwtype</code></td>
<td>
<p>The type of estimator.</p>
</td></tr> 
<tr><td><code>par</code></td>
<td>
<p>A list of parameters used to estimate the density, with elements:
</p>

<ul>
<li> <p><code>h</code> the smoothing parameters used to estimate either the density or the pilot density;
</p>
</li>
<li> <p><code>hx</code>  the matrix of sample smoothing parameters, when <code>bwtype='adaptive'</code>;
</p>
</li>
<li> <p><code>alpha</code>  sensitivity parameter used if <code>bwtype='adaptive'</code>.
</p>
</li></ul>

</td></tr>
</table>


<h3>References</h3>

<p>Bowman, A.W. and Azzalini, A. (1997). <em>Applied smoothing techniques for data analysis: the kernel approach with S-Plus illustrations</em>. Oxford University Press, Oxford.
</p>
<p>Silverman, B. (1986). <em>Density estimation for statistics and data analysis</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+h.norm">h.norm</a></code>, <code><a href="#topic+hprop2f">hprop2f</a></code>, <code><a href="#topic+kepdf-class">kepdf-class</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A 1-dimensional example
data(wine)
x &lt;- wine[,3] 
pdf &lt;- kepdf(x, eval.points=seq(0,7,by=.1))
plot(pdf, n.grid= 100, main="wine data")

## A 2-dimensional example
x &lt;- wine[,c(2,8)] 
pdf &lt;- kepdf(x)
plot(pdf, main="wine data", props=c(5,50,90), ylim=c(0,4))
plot(pdf, main="wine data", method="perspective", phi=30, theta=60)

### A 3-dimensional example
x &lt;- wine[,c(2,3,8)] 
pdf &lt;- kepdf(x)
plot(pdf, main="wine data", props=c(10,50,70), gap=0.2)
plot(pdf, main="wine data", method="perspective", gap=0.2, phi=30, theta=10)

### A 6-dimensional example
### adaptive kernel density estimate is preferable in high-dimensions
x &lt;- wine[,c(2,3,5,7,8,10)]
pdf &lt;- kepdf(x, bwtype="adaptive")
plot(pdf, main="wine data", props=c(10,50,70), gap=0.2)
plot(pdf, main="wine data", method="perspective", gap=0.2, phi=30, theta=10)

</code></pre>

<hr>
<h2 id='kepdf-class'>Class &quot;kepdf&quot;</h2><span id='topic+kepdf-class'></span><span id='topic+show+2Ckepdf-method'></span><span id='topic+summary.kepdf'></span>

<h3>Description</h3>

<p>This class encapsulates results of the application of function <code><a href="#topic+kepdf">kepdf</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("kepdf", ...)</code> or as a result of a call to <code><a href="#topic+kepdf">kepdf</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code>, corresponding to the matched call.</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"matrix"</code> representing the data points used to estimate the probability density function.</p>
</dd>
<dt><code>eval.points</code>:</dt><dd><p>Object of class <code>"matrix"</code> representing the data points at which the density is evaluated.</p>
</dd>
<dt>estimate </dt><dd><p>The values of the density estimate at the evaluation points.</p>
</dd>     
<dt><code>kernel</code>: </dt><dd><p>Object of class <code>"character"</code> giving the selected kernel.</p>
</dd>
<dt><code>bwtype</code>: </dt><dd><p>Object of class <code>"character"</code> giving the selected type of estimator.</p>
</dd> 
<dt><code>par</code>: </dt><dd><p>Object of class <code>"list"</code> providing the parameters used to estimate the density. Its elements are <code>h</code>, <code>hx</code>,
and possibly <code>alpha</code>.
</p>
</dd>
</dl>

<p>See <code><a href="#topic+kepdf">kepdf</a></code> for further details.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "kepdf", y = "ANY")</code> 
</p>
<p>Plots objects of <code><a href="#topic+kepdf-class">kepdf-class</a></code>. 
<code><a href="#topic+plot-methods">plot-methods</a></code> are available for density estimates of:
</p>

<ul>
<li> <p>one-dimensional data;
</p>
</li>
<li> <p>two-dimensional data: contour, image or perspective plots are available;
</p>
</li>
<li> <p>multi-dimensional data: matrix of plots of all the pairs of two-dimensional marginal kernel density estimates.
</p>
</li></ul>

<p>See <code><a href="#topic+plot+2Ckepdf-method">plot,kepdf-method</a></code> for further details.	</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "kepdf")</code> 
</p>
<p>Prints the following elements:
</p>

<ul>
<li> <p>the class of the object;
</p>
</li>
<li> <p>the selected kernel;
</p>
</li>
<li> <p>the selected type of estimator;
</p>
</li>
<li> <p>either the fixed smoothing parameters or the smoothing parameters of each observation;
</p>
</li>
<li> <p>the density estimates at the evaluation points.
</p>
</li></ul>
	</dd>
<dt>summary</dt><dd><p><code>signature(object = "kepdf")</code> 
</p>
<p>Provides a summary of <code><a href="#topic+kepdf-class">kepdf-class</a></code> object by printing
the highest density data point and the row or index position of a 
percentage top density data points, possibly given as optional argument
<code>prop</code>.     
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+h.norm">h.norm</a></code>, <code><a href="#topic+kepdf">kepdf</a></code>, <code><a href="#topic+plot+2Ckepdf-method">plot,kepdf-method</a></code>,
<code><a href="#topic+plot-methods">plot-methods</a></code>, <code><a href="#topic+show-methods">show-methods</a></code>, <code><a href="#topic+summary-methods">summary-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
showClass("kepdf")

#
data(wine)
#select only "Barolo"-type wines
x &lt;- wine[1:59,3] 
pdf &lt;- kepdf(x)
pdf
summary(pdf)
summary(pdf, props = 10*seq(1, 9, by = 1))

</code></pre>

<hr>
<h2 id='oliveoil'>Olive oil data</h2><span id='topic+oliveoil'></span>

<h3>Description</h3>

<p>This data set represents eight chemical measurements on different specimen of olive oil produced in various regions in Italy (northern Apulia, 
southern Apulia, Calabria, Sicily, inland Sardinia and coast Sardinia, eastern and western Liguria, Umbria) and further classifiable 
into three macro-areas: Centre-North, South, Sardinia. 
The data set is used to evaluate the <code>pdfCluster</code> ability of recunstructing the macro-area membership. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oliveoil)</code></pre>


<h3>Format</h3>

<p>This data frame contains 572 rows, each corresponding to a different specimen of olive oil, and 10 columns. 
The first and the second column correspond to the macro-area and the region of origin of the olive oils respectively; here, the term &quot;region&quot; refers to a geographical area and only partially to administrative borders. 
Columns 3-10 represent the following eight chemical measurements on the acid components for the oil specimens:
palmitic, palmitoleic, stearic, oleic, linoleic, linolenic, arachidic, eicosenoic.</p>


<h3>Details</h3>

<p>Since the raw data are of compositional nature, ideally totalling 10000, some preliminary transformations of data are advisable. In particular, Azzalini and Torelli (2007) 
adopt an additive log-ratio transformation (ALR). If <code class="reqn">x_j</code> denotes the <code class="reqn">j^{th}</code> chemical measurement <code class="reqn">(j=1,\ldots,8)</code>, the ALR transformation is <code class="reqn">y_j= \log x_j/x_k, j\neq k</code>,
where <code class="reqn">k</code> is an arbitrary but fixed variable.  
However, in this data set, the raw data do not always sum up exactly to 10000, because of measurement errors. Moreover, some 0's are present in the data, corresponding 
to measurements below the instrument sensitivity level. Therefore, it is suggested to add 1 to all raw data and normalize them by dividing each entry by the
corresponding row sum <code class="reqn">\sum_j (x_j+1)</code>.  
</p>


<h3>Source</h3>

<p>Forina, M., Lanteri, S. Armanino, C., Casolino, C., Casale, M., Oliveri, P. (2008). V-PARVUS. <em>An Extendible Package of programs for explorative data analysis, classification and regression analysis</em>. Dip. Chimica e Tecnologie Farmaceutiche ed Alimentari, Universit√† di Genova. 
</p>


<h3>References</h3>

<p>Azzalini A., Torelli N. (2007). Clustering via nonparametric density estimation.
<em>Statistics and Computing</em>, 17, 71-80.
</p>

<hr>
<h2 id='pdfClassification'>
Classification of low density data
</h2><span id='topic+pdfClassification'></span>

<h3>Description</h3>

<p>Allocates low density data points in a multi-stage procedure after that cluster cores have been detected 
by applying <code><a href="#topic+pdfCluster">pdfCluster</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdfClassification(obj, n.stage = 5, se = TRUE, hcores = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdfClassification_+3A_obj">obj</code></td>
<td>

<p>An object of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.</p>
</td></tr>
<tr><td><code id="pdfClassification_+3A_n.stage">n.stage</code></td>
<td>

<p>Allocation of low density data is performed by following a multi-stages procedure in <code>n.stage</code> stages. 
</p>
</td></tr>
<tr><td><code id="pdfClassification_+3A_se">se</code></td>
<td>

<p>Logical. Should the standard-error of the density estimates be taken into account to define the order of allocation? Default value is TRUE. 
See details below.
</p>
</td></tr>
<tr><td><code id="pdfClassification_+3A_hcores">hcores</code></td>
<td>

<p>Logical. Set this value to TRUE to build cluster density estimates by selecting the same bandwidths as the ones used to form 
the cluster cores. Otherwise, bandwidths specific for the clusters are selected. Default value is FALSE. See details below.   
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic idea of the classification stage of the procedure is as follows: for an unallocated data point <code class="reqn">x_0</code>,
compute the estimated density <code class="reqn">\hat{f}_m(x_0)</code> based on the data already assigned to group <code class="reqn">m, m = 1, 2, \ldots, M</code>,
and assign <code class="reqn">x_0</code> to the group with highest log ratio <code class="reqn">\hat{f}_m(x_0)/\max_m \hat{f}_m(x_0)</code>. 
</p>
<p>In case <code class="reqn">\hat{f}_m(x_0)</code>=0, for all <code class="reqn">m = 1, 2, \ldots, M</code>, <code class="reqn">x_0</code> is considered as an outlier. The procedure gives a warning 
message and the outlier remains unclassified. The cluster label of <code class="reqn">x_0</code> will be set to zero.   
</p>
<p>The current implementation of this idea proceeds in <code>n.stage</code> stages, allocating a block of points at a time,
updating the estimates <code class="reqn">\hat{f}_m(\cdot)</code> based on the new members of each group and then allocating a new block of points. 
When <code>se = TRUE</code>, classification is performed by further weighting the log-ratios inversely with their approximated standard
error, so that points whose density estimate has highest precision are allocated first.
</p>
<p>Each of the <code class="reqn">\hat{f}_m(\cdot)</code> is built by selecting either the same bandwidths <code class="reqn">h_0</code> as the ones used to form the cluster cores (when <code>hcores = TRUE</code>) or cluster-specific bandwidths, obtained as follows: 
</p>
<p style="text-align: center;"><code class="reqn">h_m^{*} = \exp [(1-a_m) \log(h_0) + a_m \log(h_m)],</code>
</p>

<p>where <code class="reqn">a_m</code> is the proportion of data points in the <code class="reqn">m</code>-th cluster core and <code class="reqn">h_m</code> are asymptotically optimal for a normal distribution of the <code class="reqn">m</code>-th cluster or computed according to the Silverman (1986) approach, if the kernel estimator has fixed or adaptive bandwidth, respectively. 
</p>


<h3>Value</h3>

<p>An object of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code> with slot <code>stages</code> of class <code>"list"</code> having length equal to <code>n.stage</code>. 
See <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code> for further details.  
</p>


<h3>Note</h3>

 
<p>Function <code><a href="#topic+pdfClassification">pdfClassification</a></code> is called internally, from <code><a href="#topic+pdfCluster">pdfCluster</a></code>, when the argument
<code>n.stage</code> is set to a value greater than zero. Alternatively, it may be called externally, by providing as 
argument an object of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.
</p>
<p>When <code><a href="#topic+pdfClassification">pdfClassification</a></code> is internally called from <code><a href="#topic+pdfCluster">pdfCluster</a></code> and one group only is detected, 
the slot <code>stages</code> is a list with <code>n.stage</code> elements, each of them being a vector with length equal to the number
of data points and all elements equal to 1.
</p>


<h3>References</h3>

<p>Azzalini A., Torelli N. (2007). Clustering via nonparametric density estimation. <em>Statistics and Computing</em>. 17, 71-80.
</p>
<p>Silverman, B. (1986). <em>Density estimation for statistics and data analysis</em>. Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdfCluster">pdfCluster</a></code>, <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(wine)

# select a subset of variables
x &lt;- wine[, c(2,5,8)]

#whole procedure, included the classification phase
cl &lt;- pdfCluster(x)
summary(cl)
table(groups(cl))

#use of bandwidths specific for the group 
cl1 &lt;- pdfClassification(cl, hcores= TRUE)
table(groups(cl1))
</code></pre>

<hr>
<h2 id='pdfCluster'> Clustering via nonparametric density estimation</h2><span id='topic+pdfCluster'></span><span id='topic+pdfCluster-methods'></span><span id='topic+pdfCluster+2Cdata.frame-method'></span><span id='topic+pdfCluster+2Cmatrix-method'></span><span id='topic+pdfCluster+2Cnumeric-method'></span><span id='topic+pdfCluster+2CpdfCluster-method'></span>

<h3>Description</h3>

<p>Cluster analysis is performed by the density-based procedures described in 
Azzalini and Torelli (2007) and Menardi and Azzalini (2014), and summarized
in Azzalini and Menardi (2014). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
pdfCluster(x, graphtype, hmult, Q = "QJ", lambda = 0.1, 
   grid.pairs = 10, n.grid = min(round((5 + sqrt(NROW(x))) * 4), NROW(x)), ...)

## S4 method for signature 'matrix'
pdfCluster(x, graphtype, hmult, Q = "QJ", lambda = 0.1, 
	grid.pairs = 10, n.grid = min(round((5 + sqrt(NROW(x))) * 4), NROW(x)), ...)

## S4 method for signature 'data.frame'
pdfCluster(x, graphtype, hmult, Q = "QJ", lambda = 0.1, 
	grid.pairs = 10, n.grid = min(round((5 + sqrt(NROW(x))) * 4), NROW(x)), ...)
	  
## S4 method for signature 'pdfCluster'
pdfCluster(x, graphtype, hmult, Q, lambda = 0.1, 
	grid.pairs, n.grid = min(round((5 + sqrt(NROW(x@x))) * 4), NROW(x@x)), ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdfCluster_+3A_x">x</code></td>
<td>

<p>A vector, a matrix or a data frame of numeric data to be partitioned. 
Since density-based clustering is designed for continuous data only, 
if discrete data are provided, a warning message is displayed.
Alternatively, <code>x</code> can be an object of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>
itself, obtained when <code>graphtype</code> is set to &quot;pairs&quot;. See Section Details below.  
</p>
</td></tr>
<tr><td><code id="pdfCluster_+3A_graphtype">graphtype</code></td>
<td>

<p>Either &quot;unidimensional&quot;, &quot;delaunay&quot; or &quot;pairs&quot;, it defines the procedure used 
to build the graph associated with the data. If missing, a &quot;delaunay&quot; graph is 
built for data having dimension less than 7, otherwise a &quot;pairs&quot; graph is built. 
See details below. This argument has not to be set when <code>x</code> is of
<code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>. 
</p>
</td></tr>
<tr><td><code id="pdfCluster_+3A_hmult">hmult</code></td>
<td>

<p>A shrink factor to be multiplied by the smoothing parameter <code>h</code> of function <code><a href="#topic+kepdf">kepdf</a></code>.
If missing, it is taken to be 1 when data have dimension greater than 6, 0.75 otherwise. 
</p>
</td></tr>
<tr><td><code id="pdfCluster_+3A_q">Q</code></td>
<td>

<p>Optional arguments to be given when <code>graphtype = "delaunay"</code>. See 
<code><a href="geometry.html#topic+delaunayn">delaunayn</a></code> in package <code>geometry</code> 
for further details. This argument has not to be set when <code>graphtype = "pairs"</code>, 
when <code>graphtype = "unidimensional"</code> or when <code>x</code> is of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.  
</p>
</td></tr>
<tr><td><code id="pdfCluster_+3A_lambda">lambda</code></td>
<td>

<p>Tolerance threshold to be used when <code>graphtype = "pairs"</code>. An edge is set 
between two observations if the density function, evaluated along the segment
linking them, does not exhibit any valley having a measure exceeding <code>lambda</code>.
Its range is <code class="reqn">[0,1)</code> but a value larger than 0.3 is not recommended; default value
is set to 0.10. This argument has not to be set when <code>graphtype = "delaunay"</code>
or <code>graphtype = "unidimensional"</code>.
</p>
</td></tr>
<tr><td><code id="pdfCluster_+3A_grid.pairs">grid.pairs</code></td>
<td>

<p>When <code>graphtype = "pairs"</code>, this arguments defines the length of the grid of
points along the segment linking each pair of observations, on which the density
is evaluated. Default is 10. This argument has not to be set when <code>graphtype = "delaunay"</code>, 
when <code>graphtype = "unidimensional"</code> or when <code>x</code> is of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.  
</p>
</td></tr>
<tr><td><code id="pdfCluster_+3A_n.grid">n.grid</code></td>
<td>

<p>Defines the length of the grid on which evaluating the connected 
components of the density level sets. The default value is set to the minimum
between the number of data rows <code class="reqn">n</code> and <code class="reqn">\lfloor{(5 + \sqrt(n))4 + 0.5}\rfloor</code>,
an empirical rule of thumb which indicates that the length of the grid grows with the square root
of the number of rows data.
</p>
</td></tr>
<tr><td><code id="pdfCluster_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to <code><a href="#topic+kepdf">kepdf</a></code> or to 
<code><a href="#topic+pdfClassification">pdfClassification</a></code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clusters are associated to the connected components of the level sets of the 
density underlying the data.
Density estimation is performed by kernel methods and the connected regions 
are approximated by the connected components of a graph built on data. 
Three alternative procedures to build the graph are adopted:
</p>

<dl>
<dt>Unidimensional procedure</dt><dd><p>When data are univariate an edge is set between
two observations when all the data points included in the segment between the two 
candidate observations belong to the same level set.</p>
</dd>
<dt>Delaunay triangulation</dt><dd><p>An edge is set between two observations when 
they are contiguous in the Voronoi diagram; see Azzalini and Torelli (2007). </p>
</dd>
<dt>Pairs evaluation</dt><dd><p>An edge is set between two observations when the 
density function, evaluated along the segment joining them, does not exhibit 
any valley having a relative amplitude greater than a tolerance threshold
<code class="reqn">0 \le \lambda &lt; 1</code>. Being a tolerance threshold, sensible values of 
<code class="reqn">\lambda</code> are, in practice, included in <code class="reqn">[0, 0.3]</code>; see Menardi and Azzalini (2013). </p>
</dd> 
</dl>

<p>As the level set varies, the number of detected components gives rise to the
tree of clusters, where each leave corresponds to a mode of the density 
function. Observations around these modes form a number of cluster cores, 
while the lower density observations are allocated according to a 
classification procedure; see also <code><a href="#topic+pdfClassification">pdfClassification</a></code>. 
</p>


<h3>Value</h3>

<p>An S4 object of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code> with slots:
</p>
<table role = "presentation">
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The matrix of data input. If a vector of data is provided as input,
a one-column matrix is returned as output.</p>
</td></tr>
<tr><td><code>pdf</code></td>
<td>
<p>An object of class <code>list</code> providing information about the 
density estimate. It includes: 
</p>

<ul>
<li> <p><code>kernel</code> character vector defining the kernel function used to 
estimate the density;
</p>
</li>
<li> <p><code>bwtype</code> character vector defining if a fixed or an adaptive kernel
estimator has been used;
</p>
</li>
<li> <p><code>par</code> list of components defining the parameters used in density 
estimation;
</p>
</li>
<li> <p><code>estimate</code> vector of density estimates evaluated at the data points.
</p>
</li></ul>

<p>See <code><a href="#topic+kepdf">kepdf</a></code> for further details.</p>
</td></tr> 
<tr><td><code>nc</code></td>
<td>
<p>An object of class <code>list</code> defining details about the 
identification of the connected regions. It includes:
</p>

<ul>
<li> <p><code>nc</code> number of connected sets for each density level set.
</p>
</li>
<li> <p><code>p</code>  vector of level sets, giving the proportions of data with 
estimated density below a threshold.
</p>
</li>
<li> <p><code>id</code> group label of each point at different sections of the 
density estimate. Negative values of <code>id</code> mean that the estimated 
density is below the considered threshold.
</p>
</li>
<li> <p><code>pq</code> for each <code>p</code> gives the corresponding quantile <code>q</code>
of the values of the density.
</p>
</li></ul>
</td></tr>
<tr><td><code>graph</code></td>
<td>
<p>An object of class <code>list</code> defining details about the graph 
built to find the connected sets of high density regions. Its length
depends on the value of its first element:
</p>

<ul>
<li> <p><code>type</code> either &quot;unidimensional&quot;, &quot;delaunay&quot; or &quot;pairs&quot;, 
defines the procedure used to set edges among the observations. 
In the last case only, the list includes also the following elements:
</p>
</li>
<li> <p><code>comp.area</code> a list containing the vector <code>area</code> and the 
matrix <code>pairs.ord</code>. The element <code class="reqn">i</code> of vector <code>area</code> is the
measure of the maximum valley in the density function linking the 
observations having row position as given in column <code class="reqn">i</code> of 
<code>pairs.ord</code>.  		 
</p>
</li>
<li> <p><code>lambda</code> tolerance threshold.    
</p>
</li></ul>

</td></tr>
<tr><td><code>cluster.cores</code></td>
<td>
<p>A vector with the same length as <code>NROW(x)</code>, defining
the cluster cores membership. <code>NA</code> values correspond to low density, 
unlabeled data, to be classified in the second phase of the procedure by the
intarnal call of <code><a href="#topic+pdfClassification">pdfClassification</a></code>.
</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>Cluster tree with leaves corresponding to the connected 
components associated to different sections of the density estimate.
The object is of class <code><a href="stats.html#topic+dendrogram">dendrogram</a></code>.
</p>
</td></tr>             
<tr><td><code>noc</code></td>
<td>
<p>Number of clusters.
</p>
</td></tr>
<tr><td><code>stages</code></td>
<td>
<p>List with elements corresponding to the data allocation to 
groups at the different stages of the classification procedure.
<code>NA</code> values correspond to unlabeled data.
</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>Set to <code>NULL</code> if <code>n.stages</code> = 0, that is, if data
belonging to the cluster cores only have been allocated. 
Otherwise it reports the final label groups. This component is obsolete. Use function
<code><a href="#topic+groups">groups</a></code>, instead.
</p>
</td></tr>	
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x="data.frame")</code></dt><dd>
<p>This method applies the <code>pdfCluster</code> procedure to objects of class 
<code>data.frame</code>.</p>
</dd>
<dt><code>signature(x="matrix")</code></dt><dd>
<p>This method applies the <code>pdfCluster</code> procedure to objects of class 
<code>matrix</code>.</p>
</dd>
<dt><code>signature(x="numeric")</code></dt><dd>
<p>This method applies the <code>pdfCluster</code> procedure to objects of class 
<code>numeric</code>.</p>
</dd>
<dt><code>signature(x="pdfCluster")</code></dt><dd>
<p>This method applies to objects of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code> when the graph
has been built according to the &quot;pairs&quot; procedure. It allows to save time and
computations if the user wants to compare results of cluster analysis for 
different values of the <code>lambda</code> parameter. See examples below.</p>
</dd>
</dl>


<h3>Warning </h3>

<p>It may happen that the variability of the estimated density is so high that not 
all jumps in the mode function can be detected by the selected grid scanning 
the density function. In that case, no output is produced and a message is displayed.
As this may be associated to the occurrence of some spurious connected components, 
which appear and disappear within the range between two subsequent values of the grid,
a natural solution is to increase the value of <code>n.grid</code>. 
Alternatively either <code>lambda</code> or <code>hmult</code> may be increased to alleviate
the chance of detecting spurious connected components.
</p>
<p>Using <code>graphtype= 'delaunay'</code> when the dimensionality <code class="reqn">d</code> of data is 
greater than 6 is highly time-consuming unless the number of rows <code class="reqn">n</code> 
is fairly small, since the number of operations to run the Delaunay triangulation 
grows exponentially with <code class="reqn">d</code>.
Use <code>graphtype= "pairs"</code>, instead, whose computational complexity grows quadratically 
with the number of observations.  
</p>


<h3>References</h3>

<p>Azzalini, A., Menardi, G. (2014). Clustering via nonparametric density estimation: the R package pdfCluster.
<em>Journal of Statistical Software</em>, 57(11), 1-26,
URL http://www.jstatsoft.org/v57/i11/.
</p>
<p>Azzalini A., Torelli N. (2007). Clustering via nonparametric density estimation.
<em>Statistics and Computing</em>. 17, 71-80.
</p>
<p>Menardi, G., Azzalini, A. (2014). An advancement in clustering via nonparametric
density estimation. <em>Statistics and Computing</em>. DOI: 10.1007/s11222-013-9400-x.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kepdf">kepdf</a></code>, <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>, <code><a href="#topic+pdfClassification">pdfClassification</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########
#example 1
###########
# not run here for time reasons
#loading data
data(oliveoil)

#preparing data
olive1 &lt;- 1 + oliveoil[, 3:10]
margin &lt;- apply(data.matrix(olive1),1,sum)
olive1 &lt;- olive1/margin
alr &lt;- (-log( olive1[, -4]/olive1[, 4]))
#select the first 5 principal components
x &lt;- princomp(alr, cor=TRUE)$scores[, 1:5]

#clustering
# not run here for time reasons
#cl &lt;- pdfCluster(x, h = h.norm(x), hmult=0.75)
#summary(cl)
#plot(cl)

#comparing groups with original macro-area membership
#groups &lt;- groups(cl)
#table(oliveoil$macro.area, groups)

#cluster cores
#table(groups(cl, stage = 0))

##########
#example 2
###########
# not run here for time reasons
# loading data
#data(wine)
#x &lt;-wine[ ,-1]
#gr &lt;- wine[ ,1]

# when data are high-dimensional, an adaptive kernel estimator is preferable 
# building the Delaunay graph entails a too high computational effort
# use option "pairs" to build the graph 
# it is the default option for dimension &gt;6 


# cl &lt;- pdfCluster(x, graphtype="pairs", bwtype="adaptive")
# summary(cl)
# plot(cl)

#comparison with original groups
#table(groups(cl),gr)

# a better classification is obtained with larger value of lambda
# not necessary to run the whole procedure again
# a pdfCluster method applies on pdfCluster-class objects!

#cl1 &lt;- pdfCluster(cl, lambda=0.25)
#table(gr, groups(cl1))
</code></pre>

<hr>
<h2 id='pdfCluster-class'>Class &quot;pdfCluster&quot;</h2><span id='topic+pdfCluster-class'></span><span id='topic+show+2CpdfCluster-method'></span><span id='topic+summary.pdfCluster'></span>

<h3>Description</h3>

<p>This class pertains to results of the application of function <code><a href="#topic+pdfCluster">pdfCluster</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("pdfCluster", ...)</code> or as a result to a call to <code><a href="#topic+pdfCluster">pdfCluster</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code> representing the matched call;</p>
</dd>
<dt><code>x</code>:</dt><dd><p>Object of class <code>"matrix"</code> representing the clustered data points; </p>
</dd>
<dt><code>pdf</code>:</dt><dd><p>Object of class <code>"list"</code> reporting details about the kernel density estimate at data points <code>x</code>. </p>
</dd>
<dt><code>nc</code>:</dt><dd><p>Object of class <code>"list"</code> summarizing the result of the connected components search for different sections of
the estimated density.</p>
</dd>
<dt><code>graph</code>:</dt><dd><p>An object of class <code>"list"</code> defining details about the graph built to find the connected sets 
of high density regions.</p>
</dd> 
<dt><code>cluster.cores</code>:</dt><dd><p>Object of class <code>"ANY"</code> reporting the group labels of the data allocated to the cluster cores. </p>
</dd>
<dt><code>tree</code>:</dt><dd><p>Object of class <code>"ANY"</code>, namely class <code>dendrogram</code> if the procedure detects more than one group, <code>list</code> otherwise.
It reports the cluster tree structure associated to the different connected components for different density levels.</p>
</dd>
<dt><code>noc</code>:</dt><dd><p>Object of class <code>"numeric"</code> giving the number of clusters. </p>
</dd>
<dt><code>stages</code>:</dt><dd><p>Object of class <code>"ANY"</code>, being <code>NULL</code> if the cluster cores only are detected, <code>"list"</code> when also the lower density data are allocated. 
The elements of the list correspond to the group labels at the different stages of the classification procedure.
<code>NA</code> values correspond to unlabeled data.  </p>
</dd>
<dt><code>clusters</code>:</dt><dd><p>Object of class <code>"ANY"</code> being <code>NULL</code> if the cluster cores only are detected, <code>"numeric"</code> when all the data are clustered. This slot is obsolete. Groups can be extracted by a call to function <code><a href="#topic+groups">groups</a></code>.</p>
</dd>
</dl>

<p>See <code><a href="#topic+pdfCluster">pdfCluster</a></code> for further details.  
</p>


<h3>Methods</h3>


<dl>
<dt>dbs</dt><dd><p><code>signature(x = "pdfCluster", clusters = "missing")</code>
</p>
<p>Computes the density based Silhouette diagnostics of 
clustered data. See <code><a href="#topic+dbs">dbs</a></code> for further details.	</p>
</dd>
<dt>pdfCluster</dt><dd><p><code>signature(x="pdfCluster")</code> 
</p>
<p>Speeds up time for re-running the <code><a href="#topic+pdfCluster">pdfCluster</a></code> procedure with different values of 
<code>tau</code> when <code>graphtype = "pairs"</code></p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "pdfCluster", y = "missing")</code> 
</p>
<p>Plots objects of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>. 
<code><a href="#topic+plot-methods">plot-methods</a></code> are available for:
</p>

<ul>
<li> <p>the mode function: gives the number of connected components when the proportion of data points with density above a threshold varies. 
Set argument <code>which</code> to 1 to display this plot.
</p>
</li>
<li> <p>the cluster tree: plot the hierarchical structure associated to the clusters detected by different sections of
the density estimate. Set argument <code>which</code> to 2 to display this plot.  
</p>
</li>
<li> <p>the data points: scatterplot of data or of all the possible couples of coordinates reporting the label group. Set 
argument <code>which</code> to 3 to display this plot. 
</p>
</li>
<li> <p>the density-based Silhouette information: graphical diagnostics
of the clustering. See <code><a href="#topic+plot+2Cdbs-method">plot,dbs-method</a></code>. 
Set argument <code>which</code> to 4 to display this plot. Not available when <code>noc</code>=1.
</p>
</li></ul>
<p> See <code><a href="#topic+plot+2CpdfCluster-method">plot,pdfCluster-method</a></code> for further details.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "pdfCluster")</code>.
</p>
<p>Prints the following elements:
</p>

<ul>
<li><p>the matched Call;
</p>
</li>
<li><p>the type of kernel estimator; 
</p>
</li>
<li><p>the type of graph built;  
</p>
</li>
<li><p>the groups tree (if available);
</p>
</li>
<li><p>the cluster cores; 
</p>
</li>
<li><p>the cluster labels at the different stages of the classification procedure;
</p>
</li>
<li><p>the final clustering.
</p>
</li></ul>
 </dd>
<dt>summary</dt><dd><p><code>signature(object = "pdfCluster")</code>.
</p>
<p>Provides a summary of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code> objects by printing
the following elements: 	
</p>

<ul>
<li> <p>the matched call to pdfCluster function
</p>
</li>
<li> <p>the frequency table of the cluster cores;
</p>
</li>
<li> <p>the frequency table of the final grouping;
</p>
</li>
<li> <p>the tree of clusters.
</p>
</li></ul>
 </dd>	
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+pdfCluster">pdfCluster</a></code>, <code><a href="#topic+plot+2CpdfCluster-method">plot,pdfCluster-method</a></code>, 
<code><a href="#topic+show-methods">show-methods</a></code>, <code><a href="#topic+summary-methods">summary-methods</a></code>   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("pdfCluster")

data(wine)
x &lt;-wine[ ,-1]
gr &lt;- wine[ ,1]

# clustering
cl &lt;- pdfCluster(x, graphtype="pairs", bwtype="adaptive")
summary(cl)
cl
plot(cl)
</code></pre>

<hr>
<h2 id='plot-methods'>Methods for function plot</h2><span id='topic+plot-methods'></span>

<h3>Description</h3>

<p>Methods for functions <code>plot</code> aimed at graphically displaying the S4 classes
included in the <code><a href="#topic+pdfCluster-package">pdfCluster-package</a></code>.  
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "kepdf", y = "ANY")</code></dt><dd>
<p>S4 method for plotting objects of <code><a href="#topic+kepdf-class">kepdf-class</a></code>. See 
<code><a href="#topic+plot+2Ckepdf-method">plot,kepdf-method</a></code> for further details.</p>
</dd>
<dt><code>signature(x = "dbs", y = "missing")</code></dt><dd>
<p>S4 method for plotting objects of <code><a href="#topic+kepdf-class">kepdf-class</a></code>. See 
<code><a href="#topic+plot+2Cdbs-method">plot,dbs-method</a></code> for further details.</p>
</dd>
<dt><code>signature(x = "pdfCluster", y = "missing")</code></dt><dd>
<p>S4 method for plotting objects of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>. See
<code><a href="#topic+plot+2CpdfCluster-method">plot,pdfCluster-method</a></code> for further details.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2Cdbs-method">plot,dbs-method</a></code>, <code><a href="#topic+plot+2Ckepdf-method">plot,kepdf-method</a></code>, 
<code><a href="#topic+plot+2CpdfCluster-method">plot,pdfCluster-method</a></code> 
</p>

<hr>
<h2 id='plot+2Cdbs-method'>
Plot objects of class dbs 
</h2><span id='topic+plot+2Cdbs-method'></span><span id='topic+plot.dbs'></span><span id='topic+plot+2Cdbs+2Cmissing-method'></span>

<h3>Description</h3>

<p>This function provides a graphical tool to display diagnostics 
of density-based cluster analysis by means of the density-based silhouette information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'dbs'
plot(x, y , xlab = "", ylab = "", col = NULL, lwd = 3, cex = 0.9, 
    cex.axis = 0.5, main = NULL, labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Cdbs-method_+3A_x">x</code></td>
<td>

<p>An object of <code><a href="#topic+dbs-class">dbs-class</a>;</code>
</p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_y">y</code></td>
<td>

<p>Not used; for compatibility with generic plot;
</p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis;</p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis;</p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_col">col</code></td>
<td>

<p>A specification for the plotting color. Default are colors in palette corresponding to the group labels;</p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_lwd">lwd</code></td>
<td>

<p>A specification for the width of the bars in the plot;</p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_cex">cex</code></td>
<td>

<p>A numerical value giving the amount by which plotting text and symbols should be magnified relative to the default; 
</p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_cex.axis">cex.axis</code></td>
<td>

<p>The magnification to be used for axis annotation relative to the current setting of cex;</p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_main">main</code></td>
<td>

<p>An overall title for the plot; </p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_labels">labels</code></td>
<td>

<p>Logical. Should row index of data be added to the plot? </p>
</td></tr>
<tr><td><code id="plot+2B2Cdbs-method_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After computing the density-based silhouette index by applying <code><a href="#topic+dbs-methods">dbs-methods</a></code>, data are partitioned 
into the clusters, sorted in a decreasing order with respect to their dbs value and displayed
on a bar graph.</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "dbs", y = "missing")</code></dt><dd>
<p>S4 method for plotting objects of <code><a href="#topic+dbs-class">dbs-class</a></code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+dbs">dbs</a></code>, <code><a href="#topic+dbs-class">dbs-class</a></code>, <code><a href="cluster.html#topic+silhouette">silhouette</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#example 1: no groups in data
#random generation of group labels
set.seed(54321)
x &lt;- rnorm(50)
groups &lt;- sample(1:2, 50, replace=TRUE)
groups
dsil &lt;- dbs(x=as.matrix(x), clusters=groups)
dsil
summary(dsil)
plot(dsil, labels=TRUE, lwd=6)

#example 2: wines data
# load data
data(wine)

gr &lt;- wine[,1]

# select a subset of variables
x &lt;- wine[, c(2,5,8)]

#clustering
cl &lt;- pdfCluster(x)
 
dsil &lt;- dbs(cl)
plot(dsil)
</code></pre>

<hr>
<h2 id='plot+2Ckepdf-method'>
Plot objects of class kepdf
</h2><span id='topic+plot.kepdf'></span><span id='topic+plot+2Ckepdf-method'></span><span id='topic+plot+2Ckepdf+2Cmissing-method'></span>

<h3>Description</h3>

<p>Functions and methods for plotting objects of <code><a href="#topic+kepdf-class">kepdf-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'kepdf'
plot(x, y, eval.points = NULL, n.grid = NULL,
		data = NULL, add = FALSE, main = NULL, xlab = NULL, ylab = NULL, 
		zlab = NULL, col = NULL, col.data=2, type="l", props = c(75,50,25), 
		method="contour", ticktype = "detailed", indcol = NULL, 
		text.diag.panel = NULL, gap = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2Ckepdf-method_+3A_x">x</code></td>
<td>

<p>An object of <code><a href="#topic+kepdf-class">kepdf-class</a></code>;
</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_y">y</code></td>
<td>

<p>Not used; for compatibility with generic plot;
</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_eval.points">eval.points</code></td>
<td>

<p>A matrix of data points at which the density to be plotted has to be
evaluated; the number of columns must correspond to the dimension of the
sample data used to estimate the density. If not provided, density is
evaluated on a grid defined on the range of sample data.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_n.grid">n.grid</code></td>
<td>

<p>A vector with length set to the number of column of sample data, defining the
length of the grid on which the density to be plotted is evaluated; this
argument is ignored when eval.points is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_data">data</code></td>
<td>
<p>Data to be optionally superimposed to the density plot.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_add">add</code></td>
<td>
<p>Logical. If <code>TRUE</code>, add to a current plot.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_main">main</code></td>
<td>
<p>An overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_zlab">zlab</code></td>
<td>
<p>A title for the z axis.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_col">col</code></td>
<td>
<p>A specification for the plotting color.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_col.data">col.data</code></td>
<td>
<p>A specification for the color of <code>data</code>. Ignored if <code>data</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_type">type</code></td>
<td>
<p>What type of plot should be drawn. This argument applies when kernel density estimate is performed on unidimensional data only. Default value is <code>"l"</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_props">props</code></td>
<td>
<p>A vector defining the fraction of the data to be included within each density level. This argument applies when kernel density estimate is performed on
multidimensional data only.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_method">method</code></td>
<td>
<p>One of <code>c("contour", "image", "perspective")</code>. To be used when two or higher dimensional data 
have been used to estimate the density.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_ticktype">ticktype</code></td>
<td>
<p>Character: &quot;simple&quot; draws just an arrow parallel to the axis to indicate direction of increase;
&quot;detailed&quot; draws normal ticks; to be used if <code>method="perspective"</code> only.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_indcol">indcol</code></td>
<td>
<p>Vector of the column positions to be plotted, when densities are estimated on higher than 2-dimensional data.</p>
</td></tr> 
<tr><td><code id="plot+2B2Ckepdf-method_+3A_text.diag.panel">text.diag.panel</code></td>
<td>
<p>Text to be displayed on the diagonal panels when plotting densities estimated on higher than 2-dimensional data.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_gap">gap</code></td>
<td>
<p>Distance between subplots, when plotting densities estimated of 2-dimensional data or higher-dimensional data.</p>
</td></tr>
<tr><td><code id="plot+2B2Ckepdf-method_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to <code>plot</code>, <code>image</code>, <code>contour</code>, <code>persp</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When density estimation is based on two or higher dimensional data, these functions make use of functions <code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="graphics.html#topic+image">image</a></code> and <code><a href="graphics.html#topic+persp">persp</a></code>. 
For densities estimated on higher than 2-d data, the pairwise marginal estimated densities are plotted for all
possible pairs of coordinates or a chosen selection of them.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>eval.points</code></td>
<td>
<p>data points at which the plotted density has been evaluated</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated density at <code>eval.points</code></p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "kepdf", y = "missing")</code></dt><dd>
<p>S4 method for plotting objects of <code><a href="#topic+kepdf-class">kepdf-class</a></code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+kepdf-class">kepdf-class</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, 
<code><a href="graphics.html#topic+contour">contour</a></code>, <code><a href="graphics.html#topic+image">image</a></code>, 
<code><a href="#topic+plot-methods">plot-methods</a></code>,<code><a href="graphics.html#topic+persp">persp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#1-d example
set.seed(123)
x1 &lt;- rnorm(50)

#normal optimal bandwidth
pdf1a &lt;- kepdf(x1)
#shrink the smoothing parameter
pdf1b &lt;- kepdf(x1, h=0.5*h.norm(x1))

plot(pdf1a, n.grid=50, data=x1, xlab="x1", ylim=c(0, max(c(pdf1a@estimate,
   pdf1b@estimate))))
plot(pdf1b, n.grid=50, lty=2, add=TRUE)

#2-d example
set.seed(123)
x2 &lt;- cbind(rnorm(50),rnorm(50))

pdf2 &lt;- kepdf(x2)

plot(pdf2, n.grid=c(50,50), data=x2)
plot(pdf2, n.grid=c(50,50), method="image")
plot(pdf2, n.grid=c(50,50), method="perspective", phi=30, theta=30)

#3-d example
set.seed(123)
x3 &lt;- cbind(rnorm(50), rnorm(50), rnorm(50))

pdf3 &lt;- kepdf(x3)

plot(pdf3, n.grid=c(50,50,50))
plot(pdf3, n.grid=c(50,50,50), method="image", col = terrain.colors(30))
plot(pdf3, n.grid=c(50,50,50), method="perspective", phi=30, theta=30)
</code></pre>

<hr>
<h2 id='plot+2CpdfCluster-method'>
Plot objects of class pdfCluster
</h2><span id='topic+plot.pdfCluster'></span><span id='topic+plot+2CpdfCluster-method'></span><span id='topic+plot+2CpdfCluster+2Cmissing-method'></span>

<h3>Description</h3>

<p>Functions and methods for plotting objects of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'pdfCluster'
plot(x, y, which = 1:4, stage = Inf, pch = NULL, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2CpdfCluster-method_+3A_x">x</code></td>
<td>

<p>An object of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>;
</p>
</td></tr>
<tr><td><code id="plot+2B2CpdfCluster-method_+3A_y">y</code></td>
<td>

<p>Not used; for compatibility with generic plot;
</p>
</td></tr>
<tr><td><code id="plot+2B2CpdfCluster-method_+3A_which">which</code></td>
<td>

<p>To be used to select the type of plot: </p>

<ul>
<li><p> when <code>which = 1</code> plots the mode function, corresponding to the number of modes for different proportions of data points with density above a threshold. 
</p>
</li>
<li><p> when <code>which = 2</code> plots the cluster tree associated to different sections of
the density estimate.
</p>
</li>
<li><p> when <code>which = 3</code> displays the scatterplot of data or of all the possible pairs of coordinates reporting the label group. 
</p>
</li>
<li><p> when <code>which = 4</code> the <code><a href="#topic+plot.dbs">plot.dbs</a></code> is displayed. 
</p>
</li></ul>

<p>Multiple choices are possible.  
</p>
</td></tr>
<tr><td><code id="plot+2B2CpdfCluster-method_+3A_stage">stage</code></td>
<td>

<p>Plots the data points at the indicated <code>stage</code> of the classification procedure. Unallocated data are indicated by 0s. This argument applies if <code>which=3</code> only. 
</p>
</td></tr>
<tr><td><code id="plot+2B2CpdfCluster-method_+3A_pch">pch</code></td>
<td>

<p>Either an integer specifying a symbol or a single character to be used in plotting points. If a vector of the same length as the number of groups is given, 
different symbols or characters are used for different groups. The default value denotes points as their 
group label. This argument applies if <code>which=3</code> only.
</p>
</td></tr>
<tr><td><code id="plot+2B2CpdfCluster-method_+3A_col">col</code></td>
<td>

<p>Colors to be used in plotting points. If a vector of the same length as the number of groups is given, 
different colors or characters are used for different groups. The default value use colors in palette corresponding to the the 
group labels of the data. This argument applies if <code>which=3</code> only.</p>
</td></tr>
<tr><td><code id="plot+2B2CpdfCluster-method_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed to <code><a href="#topic+plot-methods">plot-methods</a></code>.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt><code>signature(x = "pdfCluster", y = "missing")</code></dt><dd>
<p>S4 method for plotting objects of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code></p>
</dd>
</dl>



<h3>References</h3>

<p>Azzalini A., Torelli N. (2007). Clustering via nonparametric density estimation. <em>Statistics and Computing</em>. vol. 17, pp. 71-80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="#topic+plot-methods">plot-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
gr &lt;- wine[,1]

# select a subset of variables
x &lt;- wine[, c(2,5,8)]

#clustering
cl &lt;- pdfCluster(x)
plot(cl, which=3, stage=2)

table(cl@clusters, gr)
#set "B" for Barolo, "G" for Grignolino, "A" for Barbera
plot(cl,  pch=c("B", "G", "A"), col=c(3,4,5))
</code></pre>

<hr>
<h2 id='show-methods'>Methods for Function show</h2><span id='topic+show-methods'></span>

<h3>Description</h3>

<p>Methods for function <code>show</code> aimed at showing the S4 classes included in the
<code><a href="#topic+pdfCluster-package">pdfCluster-package</a></code>.  
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "kepdf")</code></dt><dd>
<p>S4 method for showing objects of <code><a href="#topic+kepdf-class">kepdf-class</a></code>.</p>
</dd>
<dt><code>signature(object = "dbs")</code></dt><dd>
<p>S4 method for showing objects of <code><a href="#topic+dbs-class">dbs-class</a></code>.</p>
</dd>
<dt><code>signature(object = "pdfCluster")</code></dt><dd>
<p>S4 method for showing objects of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+dbs-class">dbs-class</a></code>, <code><a href="#topic+kepdf-class">kepdf-class</a></code>, 
<code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>
</p>

<hr>
<h2 id='summary-methods'>Methods for Function summary</h2><span id='topic+summary-methods'></span><span id='topic+summary+2Cdbs-method'></span><span id='topic+summary+2Ckepdf-method'></span><span id='topic+summary+2CpdfCluster-method'></span>

<h3>Description</h3>

<p>Methods for function <code>summary</code> aimed at summarizing the S4 classes included in the <code><a href="#topic+pdfCluster-package">pdfCluster-package</a></code>.  
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(object = "dbs")</code></dt><dd>
<p>S4 method for summarizing objects of <code><a href="#topic+dbs-class">dbs-class</a></code>.</p>
</dd>
<dt><code>signature(object = "kepdf")</code></dt><dd>
<p>S4 method for summarizing objects of <code><a href="#topic+kepdf-class">kepdf-class</a></code>.</p>
</dd>
<dt><code>signature(object = "pdfCluster")</code></dt><dd>
<p>S4 method for summarizing objects of <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+dbs-class">dbs-class</a></code>, <code><a href="#topic+kepdf-class">kepdf-class</a></code>, <code><a href="#topic+pdfCluster-class">pdfCluster-class</a></code>.
</p>

<hr>
<h2 id='wine'>Wine data</h2><span id='topic+wine'></span>

<h3>Description</h3>

<p>These data are the results of a chemical analysis of wines grown in the same region in Italy but derived from three
different cultivars. The analysis determined the quantities of 13 constituents found in each of the three types of wine: Barolo, Grignolino, Barbera. 
The data set is used to evaluate the <code>pdfCluster</code> ability of understanding the type of wine, given the chemical measurement. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wine)</code></pre>


<h3>Format</h3>

<p>This data frame contains 178 rows, each corresponding to a different cultivar of wine produced in Piedmont (Italy), and 14 columns. 
The first column is the type of wine, a factor variable with the following levels: Barolo, Grignolino, Barbera.
The variables measured on the three types of wines are the following: Alcohol, Malic acid, Ash, Alcalinity, Magnesium, Phenols, Flavanoids,
Nonflavanoids, Proanthocyanins, Color intensity, Hue, OD280.OD315Dilution, Proline. All variables but the label class are continuous.</p>


<h3>Details</h3>

<p>The original data set comprises 27 variables. Here a subset of 14 variables only has been included.
</p>


<h3>Source</h3>

<p>Forina, M., Lanteri, S. Armanino, C., Casolino, C., Casale, M., Oliveri, P. (2008). V-PARVUS. <em>An Extendible Pachage of programs for 
esplorative data analysis, classification and regression analysis</em>. Dip. Chimica e Tecnologie Farmaceutiche ed Alimentari, Universit√† di Genova.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
