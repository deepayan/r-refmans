<!DOCTYPE html><html><head><title>Help for package fmdates</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fmdates}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#actual_360'><p>The years between two dates using the actual/360 day basis convention.</p></a></li>
<li><a href='#actual_365'><p>The years between two dates using the actual/365 (fixed) day basis</p>
convention.</a></li>
<li><a href='#actual_actual_isda'><p>The years between two dates using the Actual/Actual ISDA day basis</p>
convention</a></li>
<li><a href='#adjust'><p>Adjust to good dates</p></a></li>
<li><a href='#Calendar'><p>Build a calendar</p></a></li>
<li><a href='#easter_monday'><p>Easter Monday day of year</p></a></li>
<li><a href='#eom'><p>The end of month date</p></a></li>
<li><a href='#equinox'><p>March and September equinox</p></a></li>
<li><a href='#fmdates'><p>fmdates</p></a></li>
<li><a href='#generate_schedule'><p>Generate a date schedule</p></a></li>
<li><a href='#is'><p>Calendar class checkers</p></a></li>
<li><a href='#is_eom'><p>Checks whether dates are last day of month</p></a></li>
<li><a href='#is_good'><p>Good date checker</p></a></li>
<li><a href='#is_valid_bdc'><p>Business day conventions</p></a></li>
<li><a href='#is_valid_day_basis'><p>Day basis conventions</p></a></li>
<li><a href='#JointCalendar'><p>Joint calendars</p></a></li>
<li><a href='#julian_day_to_gregorian'><p>Determine Gregorian date from Julian day</p></a></li>
<li><a href='#locale'><p>Extract locale from calendars</p></a></li>
<li><a href='#shift'><p>Shifting dates to good dates</p></a></li>
<li><a href='#thirty_360'><p>The years between two dates using the 30/360 day basis convention.</p></a></li>
<li><a href='#thirty_360_eu'><p>The years between two dates using the 30/360 (EU) day basis convention.</p></a></li>
<li><a href='#thirty_360_eu_isda'><p>The years between two dates using the 30E/360 ISDA day basis convention.</p></a></li>
<li><a href='#thirty_360_eu_plus'><p>The years between two dates using the 30E+/360 day basis convention.</p></a></li>
<li><a href='#thirty_360_us'><p>The years between two dates using the 30/360 (US) day basis convention.</p></a></li>
<li><a href='#tz'><p>Extract time zone from calendars</p></a></li>
<li><a href='#year_frac'><p>The years between two dates for a given day basis convention</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Financial Market Date Calculations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements common date calculations relevant for specifying
  the economic nature of financial market contracts that are typically defined
  by International Swap Dealer Association (ISDA, <a href="http://www2.isda.org">http://www2.isda.org</a>) legal
  documentation. This includes methods to check whether dates are business
  days in certain locales, functions to adjust and shift dates and time length
  (or day counter) calculations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/imanuelcostigan/fmdates">https://github.com/imanuelcostigan/fmdates</a>,
<a href="https://imanuelcostigan.github.io/fmdates/">https://imanuelcostigan.github.io/fmdates/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/imanuelcostigan/fmdates/issues">https://github.com/imanuelcostigan/fmdates/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, lubridate (&ge; 1.7.0), methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-01-04 22:33:58 UTC; imanuel</td>
</tr>
<tr>
<td>Author:</td>
<td>Imanuel Costigan [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Imanuel Costigan &lt;i.costigan@me.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-01-04 23:07:49 UTC</td>
</tr>
</table>
<hr>
<h2 id='actual_360'>The years between two dates using the actual/360 day basis convention.</h2><span id='topic+actual_360'></span>

<h3>Description</h3>

<p>This calculates the years between two dates using the actual/360 day basis
convention. This convention counts the number of calendars between the start
and end dates and assumes a year consists of 360 days. This is also known
as the A/360, Act/360 or French day basis convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actual_360(date1, date2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actual_360_+3A_date1">date1</code></td>
<td>
<p>A date-time object</p>
</td></tr>
<tr><td><code id="actual_360_+3A_date2">date2</code></td>
<td>
<p>A date-time object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The year fraction is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{Number of calendar days}{360}</code>
</p>

<p>The order of <code>date1</code> and <code>date2</code> is not important. If <code>date1</code>
is less than <code>date2</code> then the result will be non-negative. Otherwise,
the result will be negative.
</p>


<h3>Value</h3>

<p>a numeric value representing the number of years between
<code>date1</code> and <code>date2</code>.
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_365">actual_365</a></code>,
<code><a href="#topic+actual_actual_isda">actual_actual_isda</a></code>,
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis</a></code>,
<code><a href="#topic+thirty_360_eu_isda">thirty_360_eu_isda</a></code>,
<code><a href="#topic+thirty_360_eu_plus">thirty_360_eu_plus</a></code>,
<code><a href="#topic+thirty_360_eu">thirty_360_eu</a></code>, <code><a href="#topic+thirty_360_us">thirty_360_us</a></code>,
<code><a href="#topic+thirty_360">thirty_360</a></code>, <code><a href="#topic+year_frac">year_frac</a></code>
</p>

<hr>
<h2 id='actual_365'>The years between two dates using the actual/365 (fixed) day basis
convention.</h2><span id='topic+actual_365'></span>

<h3>Description</h3>

<p>This calculates the years between two dates using the actual/365 (fixed)
day  basis convention. This convention counts the number of calendars
between the start and end dates and assumes a year consists of 365 days.
This is also known as the Act/365 fixed, A/365 fixed, A/365F and English
day basis convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actual_365(date1, date2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actual_365_+3A_date1">date1</code></td>
<td>
<p>A date-time object</p>
</td></tr>
<tr><td><code id="actual_365_+3A_date2">date2</code></td>
<td>
<p>A date-time object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The year fraction is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{Number of calendar days}{365}</code>
</p>

<p>The order of <code>date1</code> and <code>date2</code> is not important. If <code>date1</code>
is less than <code>date2</code> then the result will be non-negative. Otherwise,
the result will be negative.
</p>


<h3>Value</h3>

<p>a numeric value representing the number of years between
<code>date1</code> and <code>date2</code>.
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_360">actual_360</a></code>,
<code><a href="#topic+actual_actual_isda">actual_actual_isda</a></code>,
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis</a></code>,
<code><a href="#topic+thirty_360_eu_isda">thirty_360_eu_isda</a></code>,
<code><a href="#topic+thirty_360_eu_plus">thirty_360_eu_plus</a></code>,
<code><a href="#topic+thirty_360_eu">thirty_360_eu</a></code>, <code><a href="#topic+thirty_360_us">thirty_360_us</a></code>,
<code><a href="#topic+thirty_360">thirty_360</a></code>, <code><a href="#topic+year_frac">year_frac</a></code>
</p>

<hr>
<h2 id='actual_actual_isda'>The years between two dates using the Actual/Actual ISDA day basis
convention</h2><span id='topic+actual_actual_isda'></span>

<h3>Description</h3>

<p>This calculates the years between two dates using the Actual/Actual ISDA
day basis convention. This convention counts the number of calendars
between the start and end dates. The definition of a year is contingent on
whether the year is a leap year or not. The year fraction is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">
  \frac{d_1}{{dy}_1} + \frac{d_2}{{dy}_2} + y_2 - y_1 - 1
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>actual_actual_isda(date1, date2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="actual_actual_isda_+3A_date1">date1</code></td>
<td>
<p>A date-time object</p>
</td></tr>
<tr><td><code id="actual_actual_isda_+3A_date2">date2</code></td>
<td>
<p>A date-time object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>where:
</p>

<ul>
<li> <p><code class="reqn">d_1</code> is the remaining days in the first date's year including
both the start and end date
</p>
</li>
<li> <p><code class="reqn">d_2</code> is the number of days to the second date from the start
of that year
</p>
</li>
<li> <p><code class="reqn">{dy}_1</code> is 366 if the first date is in a leap year. Otherwise
it is 365
</p>
</li>
<li> <p><code class="reqn">{dy}_2</code> is 366 if the second date is in a leap year. Otherwise
it is 365
</p>
</li></ul>

<p>The order of <code>date1</code> and <code>date2</code> is not important. If <code>date1</code>
is less than <code>date2</code> then the result will be non-negative. Otherwise,
the result will be negative.
</p>


<h3>Value</h3>

<p>a numeric value representing the number of years between
<code>date1</code> and <code>date2</code>.
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_360">actual_360</a></code>,
<code><a href="#topic+actual_365">actual_365</a></code>,
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis</a></code>,
<code><a href="#topic+thirty_360_eu_isda">thirty_360_eu_isda</a></code>,
<code><a href="#topic+thirty_360_eu_plus">thirty_360_eu_plus</a></code>,
<code><a href="#topic+thirty_360_eu">thirty_360_eu</a></code>, <code><a href="#topic+thirty_360_us">thirty_360_us</a></code>,
<code><a href="#topic+thirty_360">thirty_360</a></code>, <code><a href="#topic+year_frac">year_frac</a></code>
</p>

<hr>
<h2 id='adjust'>Adjust to good dates</h2><span id='topic+adjust'></span>

<h3>Description</h3>

<p>One common financial markets date arithmetic requires a date needs to be
rolled to the closest business day following some convention (see
<code><a href="#topic+is_valid_bdc">is_valid_bdc()</a></code> for further details). Such rolled dates can be determined by
calling <code>adjust()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust(dates, bdc, calendar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_+3A_dates">dates</code></td>
<td>
<p>a vector of dates to adjust.</p>
</td></tr>
<tr><td><code id="adjust_+3A_bdc">bdc</code></td>
<td>
<p>the business day convention used to roll the <code>dates</code> if necessary</p>
</td></tr>
<tr><td><code id="adjust_+3A_calendar">calendar</code></td>
<td>
<p>an object that inherits from <code><a href="#topic+Calendar">Calendar</a></code> or <code><a href="#topic+JointCalendar">JointCalendar</a></code>
which is used to determine the goodness of <code>dates</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of adjusted dates - good days are unadjusted
</p>


<h3>See Also</h3>

<p>Other calendar methods: <code><a href="#topic+generate_schedule">generate_schedule</a></code>,
<code><a href="#topic+is_good">is_good</a></code>, <code><a href="#topic+is_valid_bdc">is_valid_bdc</a></code>,
<code><a href="#topic+is">is</a></code>, <code><a href="#topic+locale">locale</a></code>,
<code><a href="#topic+shift">shift</a></code>, <code><a href="#topic+tz">tz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ausy &lt;- AUSYCalendar()
adjust(lubridate::ymd("20120102"), "u", ausy)
adjust(lubridate::ymd("20120102"), "f", ausy)
adjust(lubridate::ymd("20120102"), "mf", ausy)
adjust(lubridate::ymd("20120102"), "p", ausy)
adjust(lubridate::ymd("20120102"), "mp", ausy)
adjust(lubridate::ymd("20120102"), "ms", ausy)
</code></pre>

<hr>
<h2 id='Calendar'>Build a calendar</h2><span id='topic+Calendar'></span><span id='topic+EmptyCalendar'></span><span id='topic+AUSYCalendar'></span><span id='topic+AUMECalendar'></span><span id='topic+CHZHCalendar'></span><span id='topic+EUTACalendar'></span><span id='topic+GBLOCalendar'></span><span id='topic+HKHKCalendar'></span><span id='topic+JPTOCalendar'></span><span id='topic+NOOSCalendar'></span><span id='topic+NZAUCalendar'></span><span id='topic+NZWECalendar'></span><span id='topic+USNYCalendar'></span>

<h3>Description</h3>

<p>Calendars are necessary for two reasons: they define whether a calendar day
is a good business day in a given locale and they are used to store the time
zone for the locale. Calendars can correspond to a single locale (usually a
city). These inherit from the <code>Calendar</code> class. The package implements a
number of calendars for key financial market locales such as
<code>AUSYCalendar</code>, <code>USNYCalendar</code> and <code>EUTACalendar</code> (TARGET). You can
also define a joint locale using <code><a href="#topic+JointCalendar">JointCalendar()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Calendar(locale, tz)

EmptyCalendar()

AUSYCalendar()

AUMECalendar()

CHZHCalendar()

EUTACalendar()

GBLOCalendar()

HKHKCalendar()

JPTOCalendar()

NOOSCalendar()

NZAUCalendar()

NZWECalendar()

USNYCalendar()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Calendar_+3A_locale">locale</code></td>
<td>
<p>a four letter string representing an abbreviation of the
locale. The package uses locale representations loosely based on
<a href="http://www.unece.org/cefact/locode/welcome.html">UN/LOCODE</a> (e.g.
Australia/Sydney is represented by <code>AUSY</code> rather than <code>AU/SYD</code> per the
LOCODE specification). The locale is used as a prefix to the calendar's
S3 class in the following manner: <code>&lt;locale&gt;Calendar</code> (e.g. <code>AUSYCalendar</code>).</p>
</td></tr>
<tr><td><code id="Calendar_+3A_tz">tz</code></td>
<td>
<p>the time zone associated with the given <code>locale</code> using
<code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code> (e.g. <code>Australia/Sydney</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Calendar()</code> returns a function that constructs an object inheriting
from the <code>Calendar</code> class. The calendar constructors provided by the
package returns an object that inherits from <code>Calendar</code>.
</p>


<h3>See Also</h3>

<p>Other calendar classes: <code><a href="#topic+JointCalendar">JointCalendar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Calendar(NA, NA) # Defined: EmptyCalendar()
Calendar("AUSY", "Australia/Sydney") # Defined: AUSYCalendar()
</code></pre>

<hr>
<h2 id='easter_monday'>Easter Monday day of year</h2><span id='topic+easter_monday'></span>

<h3>Description</h3>

<p>Determine the day of the year that the Western Easter Monday falls on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>easter_monday(years)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="easter_monday_+3A_years">years</code></td>
<td>
<p>a numeric vector of <code>years</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>

<hr>
<h2 id='eom'>The end of month date</h2><span id='topic+eom'></span>

<h3>Description</h3>

<p>The <code>dates</code> are rounded to the end of their respective months.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eom(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eom_+3A_dates">dates</code></td>
<td>
<p>a vector of dates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a date vector with the same class as <code>dates</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("lubridate")
eom(ymd(20120203, 20140203))
</code></pre>

<hr>
<h2 id='equinox'>March and September equinox</h2><span id='topic+equinox'></span>

<h3>Description</h3>

<p>Determine the date/time of March and September Equinoxes.
This implements Jean Meeus' algorithm (Astronomical Algorithms
1st Ed, 1991, Chapter 26).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equinox(years, season = "mar", tz = "UTC", want_dt = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equinox_+3A_years">years</code></td>
<td>
<p>a numeric vector of <code>years</code></p>
</td></tr>
<tr><td><code id="equinox_+3A_season">season</code></td>
<td>
<p>defines the Equinox sought. Can be <code>mar</code> (default) or
<code>sep</code>.</p>
</td></tr>
<tr><td><code id="equinox_+3A_tz">tz</code></td>
<td>
<p>time zone for which equinox instant should be returned (default:
<code>"UTC"</code>)</p>
</td></tr>
<tr><td><code id="equinox_+3A_want_dt">want_dt</code></td>
<td>
<p>a flag indicating whether the returned date should be in
dynamical time (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the date-time (UTC) of the Equinox (drop sub-minute precision)
</p>

<hr>
<h2 id='fmdates'>fmdates</h2><span id='topic+fmdates'></span><span id='topic+fmdates-package'></span>

<h3>Description</h3>

<p>Implements common date calculations relevant for specifying the economic
nature of financial market contracts that are typically defined by
International Swap Dealer Association (ISDA) legal documentation.
</p>


<h3>Details</h3>

<p>The key classes and methods introduced by this package are documented in
<code><a href="#topic+Calendar">Calendar</a></code>, <code><a href="#topic+JointCalendar">JointCalendar</a></code>, <code><a href="#topic+is_good">is_good()</a></code>, <code><a href="#topic+adjust">adjust()</a></code>, <code><a href="#topic+shift">shift()</a></code> and
<code><a href="#topic+year_frac">year_frac()</a></code>.
</p>

<hr>
<h2 id='generate_schedule'>Generate a date schedule</h2><span id='topic+generate_schedule'></span>

<h3>Description</h3>

<p>Generate a date schedule from <code>effective_date</code> to
<code>termination_date</code>. This code was derived from the Quantlib method
Schedule::Schedule. This can be used to generate the cash flow, fixing and
projection dates of an interest rate swap according to certain conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_schedule(effective_date, termination_date, tenor,
  calendar = EmptyCalendar(), bdc = "u", stub = "short_front",
  eom_rule = FALSE, first_date = effective_date,
  last_date = termination_date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_schedule_+3A_effective_date">effective_date</code></td>
<td>
<p>the date at which the schedule begins. For example, the
effective date of a swap. This should be <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.</p>
</td></tr>
<tr><td><code id="generate_schedule_+3A_termination_date">termination_date</code></td>
<td>
<p>the date at which the schedule ends. For example, the
termination date of a swap. This should be <code><a href="base.html#topic+POSIXct">POSIXct</a></code>.</p>
</td></tr>
<tr><td><code id="generate_schedule_+3A_tenor">tenor</code></td>
<td>
<p>the frequency of the events for which dates are generated. For
example, <code>month(3)</code> reflects events that occur quarterly. Should be an
atomic <code><a href="lubridate.html#topic+Period-class">Period-class</a></code> of length one</p>
</td></tr>
<tr><td><code id="generate_schedule_+3A_calendar">calendar</code></td>
<td>
<p>a <code><a href="#topic+Calendar">Calendar</a></code></p>
</td></tr>
<tr><td><code id="generate_schedule_+3A_bdc">bdc</code></td>
<td>
<p>a string representing one of the following business day
conventions: &quot;u&quot;, &quot;f&quot;, &quot;mf&quot;, &quot;p&quot;, &quot;mp&quot;, &quot;ms&quot; (unadjusted, following,
modified following, preceding, modified preceding and modified succeeding,
resp.)</p>
</td></tr>
<tr><td><code id="generate_schedule_+3A_stub">stub</code></td>
<td>
<p>a string representing one of the following stub types:
&quot;short_front&quot;, &quot;short_back&quot;, &quot;long_front&quot;, &quot;long_back&quot;.</p>
</td></tr>
<tr><td><code id="generate_schedule_+3A_eom_rule">eom_rule</code></td>
<td>
<p>a logical value defining whether the end-to-end convention
applies.</p>
</td></tr>
<tr><td><code id="generate_schedule_+3A_first_date">first_date</code></td>
<td>
<p>date of first payment for example. This defaults to
<code>effective_date</code> as is usually the case</p>
</td></tr>
<tr><td><code id="generate_schedule_+3A_last_date">last_date</code></td>
<td>
<p>date of last payment for example. This defaults to
<code>termination_date</code> as is usually the case</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>Interval</code> vector
</p>


<h3>See Also</h3>

<p>Other calendar methods: <code><a href="#topic+adjust">adjust</a></code>,
<code><a href="#topic+is_good">is_good</a></code>, <code><a href="#topic+is_valid_bdc">is_valid_bdc</a></code>,
<code><a href="#topic+is">is</a></code>, <code><a href="#topic+locale">locale</a></code>,
<code><a href="#topic+shift">shift</a></code>, <code><a href="#topic+tz">tz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library (lubridate)
effective_date &lt;- ymd('20120103')
termination_date &lt;- ymd('20121203')
tenor &lt;- months(3)
stub &lt;- 'short_front'
bdc &lt;- 'mf'
calendar &lt;- AUSYCalendar()
eom_rule &lt;- FALSE
generate_schedule(effective_date, termination_date, tenor, calendar,
 bdc, stub, eom_rule)
</code></pre>

<hr>
<h2 id='is'>Calendar class checkers</h2><span id='topic+is'></span><span id='topic+is.Calendar'></span><span id='topic+is.JointCalendar'></span>

<h3>Description</h3>

<p>Calendar class checkers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Calendar(x)

is.JointCalendar(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_+3A_x">x</code></td>
<td>
<p>object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> inherits from <code>Calendar</code> or <code>JointCalendar</code>
(<code>is.Calendar</code> and <code>is.JointCalendar</code> respectively) and <code>FALSE</code> otherwise.
</p>


<h3>See Also</h3>

<p>Other calendar methods: <code><a href="#topic+adjust">adjust</a></code>,
<code><a href="#topic+generate_schedule">generate_schedule</a></code>, <code><a href="#topic+is_good">is_good</a></code>,
<code><a href="#topic+is_valid_bdc">is_valid_bdc</a></code>, <code><a href="#topic+locale">locale</a></code>,
<code><a href="#topic+shift">shift</a></code>, <code><a href="#topic+tz">tz</a></code>
</p>

<hr>
<h2 id='is_eom'>Checks whether dates are last day of month</h2><span id='topic+is_eom'></span>

<h3>Description</h3>

<p>This checks whether the <code>dates</code> provided are the last day of a
month.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_eom(dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_eom_+3A_dates">dates</code></td>
<td>
<p>a vector of dates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("lubridate")
is_eom(ymd(20110228)) # TRUE
is_eom(ymd(20120229)) # TRUE
</code></pre>

<hr>
<h2 id='is_good'>Good date checker</h2><span id='topic+is_good'></span>

<h3>Description</h3>

<p>Checks whether dates are business days (good days) in a given locale
represented by a <code>Calendar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_good(dates, calendar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_good_+3A_dates">dates</code></td>
<td>
<p>a vector of dates</p>
</td></tr>
<tr><td><code id="is_good_+3A_calendar">calendar</code></td>
<td>
<p>an object inheriting from either <a href="#topic+Calendar">Calendar</a> or
<a href="#topic+JointCalendar">JointCalendar</a>. Dispatch to methods occurs on this argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>is_good</code> method must be written for each calendar. The default method
returns <code>TRUE</code> for all dates. Methods have been implemented for each of the
calendars inheriting from the <code>Calendar</code> class - see the method's code for
more details. The method implemented for the <code>JointCalendar</code> class checks
whether the supplied dates are good in each or any of the locales represented
by the joint calendar depending on the rule specified by the joint calendar.
</p>


<h3>Value</h3>

<p>a logical vector with <code>TRUE</code> if the date is good and <code>FALSE</code> if the
date is bad
</p>


<h3>See Also</h3>

<p>Calendar
</p>
<p>Other calendar methods: <code><a href="#topic+adjust">adjust</a></code>,
<code><a href="#topic+generate_schedule">generate_schedule</a></code>,
<code><a href="#topic+is_valid_bdc">is_valid_bdc</a></code>, <code><a href="#topic+is">is</a></code>,
<code><a href="#topic+locale">locale</a></code>, <code><a href="#topic+shift">shift</a></code>,
<code><a href="#topic+tz">tz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_good(lubridate::ymd(20160126, 20160411), AUSYCalendar())
is_good(lubridate::ymd(20160126), USNYCalendar())
</code></pre>

<hr>
<h2 id='is_valid_bdc'>Business day conventions</h2><span id='topic+is_valid_bdc'></span><span id='topic+businessdayconventions'></span>

<h3>Description</h3>

<p>Checks whether business day conventions are valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_bdc(bdc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_valid_bdc_+3A_bdc">bdc</code></td>
<td>
<p>a character vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supported day conventions are:
</p>

<ul>
<li><p> u - unadjusted. No adjustments made to a date.
</p>
</li>
<li><p> f - following. The date is adjusted to the following business day.
</p>
</li>
<li><p> mf - modified following. As per following convention. However,
if the following business day is in the month following the date, then the
date is adjusted to the preceding business day.
</p>
</li>
<li><p> p - preceding. The date is adjusted to the preceding business day.
</p>
</li>
<li><p> mp - modified preceding. As per preceding convention. However, if
the preceding business day is in the month prior to the date, then the
date is adjusted to the following business day.
</p>
</li>
<li><p> ms - modified succeeding. This convention applies to Australian
bank bills. Australian bank bills' maturities defined as either early
(prior to the 15th) or late month (after the 15th). If the maturity date
calculated straight from a bill's term crosses either the end of the month
or the 15th of the month, the bill's maturity is adjusted to the preceding
business day.
</p>
</li></ul>



<h3>Value</h3>

<p>a flag (<code>TRUE</code> or <code>FALSE</code>) if all the supplied business
day conventions are supported.
</p>


<h3>See Also</h3>

<p>Other calendar methods: <code><a href="#topic+adjust">adjust</a></code>,
<code><a href="#topic+generate_schedule">generate_schedule</a></code>, <code><a href="#topic+is_good">is_good</a></code>,
<code><a href="#topic+is">is</a></code>, <code><a href="#topic+locale">locale</a></code>,
<code><a href="#topic+shift">shift</a></code>, <code><a href="#topic+tz">tz</a></code>
</p>

<hr>
<h2 id='is_valid_day_basis'>Day basis conventions</h2><span id='topic+is_valid_day_basis'></span><span id='topic+daybasisconventions'></span>

<h3>Description</h3>

<p>Checks whether day basis conventions are valid. Supported day basis
conventions are documented in <code><a href="#topic+year_frac">year_frac()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_day_basis(day_basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_valid_day_basis_+3A_day_basis">day_basis</code></td>
<td>
<p>A character vector of day basis conventions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>will return <code>TRUE</code> for <code>day_basis</code> elements that are any of the
following: <code>30/360</code>, <code>30/360us</code>, <code>30e/360</code>,
<code>30e/360isda</code>, <code>30e+/360</code>, <code>act/360</code>, <code>act/365</code> and
<code>act/actisda</code>. Otherwise will return <code>FALSE</code>
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_360">actual_360</a></code>,
<code><a href="#topic+actual_365">actual_365</a></code>,
<code><a href="#topic+actual_actual_isda">actual_actual_isda</a></code>,
<code><a href="#topic+thirty_360_eu_isda">thirty_360_eu_isda</a></code>,
<code><a href="#topic+thirty_360_eu_plus">thirty_360_eu_plus</a></code>,
<code><a href="#topic+thirty_360_eu">thirty_360_eu</a></code>, <code><a href="#topic+thirty_360_us">thirty_360_us</a></code>,
<code><a href="#topic+thirty_360">thirty_360</a></code>, <code><a href="#topic+year_frac">year_frac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_valid_day_basis(c("act/360", "act/365f"))
</code></pre>

<hr>
<h2 id='JointCalendar'>Joint calendars</h2><span id='topic+JointCalendar'></span>

<h3>Description</h3>

<p>Sometimes the calendar governing a financial contract is defined by multiple
single locales. These joint calendars are represented by the <code>JointCalendar</code>
class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JointCalendar(calendars, rule = all)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JointCalendar_+3A_calendars">calendars</code></td>
<td>
<p>a list of at least one <code>Calendar()</code> objects</p>
</td></tr>
<tr><td><code id="JointCalendar_+3A_rule">rule</code></td>
<td>
<p>either <code>all</code> or <code>any</code> corresponding to a date being good if
it is good in all or any of the calendars supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>JointCalendar</code> when using <code>JointCalendar()</code>
</p>


<h3>See Also</h3>

<p>Other calendar classes: <code><a href="#topic+Calendar">Calendar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JointCalendar(list(AUSYCalendar(), AUMECalendar()), all)
JointCalendar(list(AUSYCalendar(), AUMECalendar()), any)
</code></pre>

<hr>
<h2 id='julian_day_to_gregorian'>Determine Gregorian date from Julian day</h2><span id='topic+julian_day_to_gregorian'></span>

<h3>Description</h3>

<p>Determine Gregorian date from Julian day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>julian_day_to_gregorian(julian_day)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="julian_day_to_gregorian_+3A_julian_day">julian_day</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a POSIXct vector of Gregorian dates at midnight UTC time.
</p>

<hr>
<h2 id='locale'>Extract locale from calendars</h2><span id='topic+locale'></span>

<h3>Description</h3>

<p>Extract locale from calendars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locale(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locale_+3A_x">x</code></td>
<td>
<p>an instance of a <code><a href="#topic+Calendar">Calendar</a></code> or <code><a href="#topic+JointCalendar">JointCalendar</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string representing the locale (e.g. &quot;AUSY&quot;)
</p>


<h3>See Also</h3>

<p>Other calendar methods: <code><a href="#topic+adjust">adjust</a></code>,
<code><a href="#topic+generate_schedule">generate_schedule</a></code>, <code><a href="#topic+is_good">is_good</a></code>,
<code><a href="#topic+is_valid_bdc">is_valid_bdc</a></code>, <code><a href="#topic+is">is</a></code>,
<code><a href="#topic+shift">shift</a></code>, <code><a href="#topic+tz">tz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>locale(AUSYCalendar())
locale(c(AUSYCalendar(), AUMECalendar()))
</code></pre>

<hr>
<h2 id='shift'>Shifting dates to good dates</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+adjust">adjust()</a></code> function rolls dates to the closest good dates. This function
shifts dates by a given <a href="lubridate.html#topic+period">period</a> and adjusting the
resulting dates to a closest good dates following the given business day
convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(dates, period, bdc = "u", calendar = EmptyCalendar(),
  eom_rule = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_dates">dates</code></td>
<td>
<p>a vector of dates to shift and adjust</p>
</td></tr>
<tr><td><code id="shift_+3A_period">period</code></td>
<td>
<p>an atomic instance of the <a href="lubridate.html#topic+Period-class">period
class</a> in the sense that only one of its slots
should be non-zero. It must also only be a day, month or year period type.</p>
</td></tr>
<tr><td><code id="shift_+3A_bdc">bdc</code></td>
<td>
<p>the business day convention used to roll the <code>dates</code> if necessary
(default: &quot;u&quot; - unadjusted)</p>
</td></tr>
<tr><td><code id="shift_+3A_calendar">calendar</code></td>
<td>
<p>an object that inherits from <code><a href="#topic+Calendar">Calendar</a></code> or
<code><a href="#topic+JointCalendar">JointCalendar</a></code> which is used to determine the goodness of <code>dates</code>
(default: <code>EmptyCalendar()</code>)</p>
</td></tr>
<tr><td><code id="shift_+3A_eom_rule">eom_rule</code></td>
<td>
<p>if one of the <code>dates</code> is the last business day of the month,
is being shifted by a month or year <code>period</code> and <code>eom_rule</code> is <code>TRUE</code> then
the shifted date is also the last business day of the month
(default: <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of shifted dates
</p>


<h3>See Also</h3>

<p>Other calendar methods: <code><a href="#topic+adjust">adjust</a></code>,
<code><a href="#topic+generate_schedule">generate_schedule</a></code>, <code><a href="#topic+is_good">is_good</a></code>,
<code><a href="#topic+is_valid_bdc">is_valid_bdc</a></code>, <code><a href="#topic+is">is</a></code>,
<code><a href="#topic+locale">locale</a></code>, <code><a href="#topic+tz">tz</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
ausy &lt;- AUSYCalendar()
shift(ymd("20120229"), months(1), "u", ausy, FALSE)
shift(ymd("20120229"), months(1), "u", ausy, TRUE)
</code></pre>

<hr>
<h2 id='thirty_360'>The years between two dates using the 30/360 day basis convention.</h2><span id='topic+thirty_360'></span>

<h3>Description</h3>

<p>This calculates the years between two dates using the 30/360 day basis
convention. This convention assumes that months consists of 30 days and
years consist of 360 calendar days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thirty_360(date1, date2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thirty_360_+3A_date1">date1</code></td>
<td>
<p>A date-time object.</p>
</td></tr>
<tr><td><code id="thirty_360_+3A_date2">date2</code></td>
<td>
<p>A date-time object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The day count is determined after making the following (ordered)
modifications:
</p>

<ol>
<li><p> If the start date is the 31st, set the start dates to the 30th.
</p>
</li>
<li><p> If the start date greater than the 29nd and the end date is the
31st then set the end dates to the 30th.
</p>
</li></ol>

<p>The year fraction is then calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{(d_2 - d_1) + (m_2 - m_1) \times 30 + (y_2 - y_1)
 \times 30}{360}</code>
</p>

<p>The order of <code>date1</code> and <code>date2</code> is not important. If <code>date1</code>
is less than <code>date2</code> then the result will be non-negative. Otherwise,
the result will be negative.
</p>
<p>This is also known as the bond basis.
</p>


<h3>Value</h3>

<p>A numeric value representing the number of years between
<code>date1</code> and <code>date2</code>.
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_360">actual_360</a></code>,
<code><a href="#topic+actual_365">actual_365</a></code>,
<code><a href="#topic+actual_actual_isda">actual_actual_isda</a></code>,
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis</a></code>,
<code><a href="#topic+thirty_360_eu_isda">thirty_360_eu_isda</a></code>,
<code><a href="#topic+thirty_360_eu_plus">thirty_360_eu_plus</a></code>,
<code><a href="#topic+thirty_360_eu">thirty_360_eu</a></code>, <code><a href="#topic+thirty_360_us">thirty_360_us</a></code>,
<code><a href="#topic+year_frac">year_frac</a></code>
</p>

<hr>
<h2 id='thirty_360_eu'>The years between two dates using the 30/360 (EU) day basis convention.</h2><span id='topic+thirty_360_eu'></span>

<h3>Description</h3>

<p>This calculates the years between two dates using the 30/360 (EU) day
basis convention. This convention assumes that months consists of 30 days
and years consist of 360 calendar days. This is also known as the 30/360
ICMA, Eurobond (ISDA 2006) and Special German basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thirty_360_eu(date1, date2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thirty_360_eu_+3A_date1">date1</code></td>
<td>
<p>A date-time object</p>
</td></tr>
<tr><td><code id="thirty_360_eu_+3A_date2">date2</code></td>
<td>
<p>A date-time object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The day count is determined after making the following (ordered)
modifications:
</p>

<ol>
<li><p> If the start date is the 31st, set the start date to the 30th
</p>
</li>
<li><p> If the end date is 31st, set the end date to the 30th
</p>
</li></ol>

<p>The year fraction is then calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{(d_2-d_1) + (m_2-m_1)\times 30 + (y_2-y_1)\times 360}{360}</code>
</p>

<p>The order of <code>date1</code> and <code>date2</code> is not important. If <code>date1</code>
is less than <code>date2</code> then the result will be non-negative. Otherwise,
the result will be negative.
</p>


<h3>Value</h3>

<p>a numeric value representing the number of years between
<code>date1</code> and <code>date2</code>.
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_360">actual_360</a></code>,
<code><a href="#topic+actual_365">actual_365</a></code>,
<code><a href="#topic+actual_actual_isda">actual_actual_isda</a></code>,
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis</a></code>,
<code><a href="#topic+thirty_360_eu_isda">thirty_360_eu_isda</a></code>,
<code><a href="#topic+thirty_360_eu_plus">thirty_360_eu_plus</a></code>,
<code><a href="#topic+thirty_360_us">thirty_360_us</a></code>, <code><a href="#topic+thirty_360">thirty_360</a></code>,
<code><a href="#topic+year_frac">year_frac</a></code>
</p>

<hr>
<h2 id='thirty_360_eu_isda'>The years between two dates using the 30E/360 ISDA day basis convention.</h2><span id='topic+thirty_360_eu_isda'></span>

<h3>Description</h3>

<p>This calculates the years between two dates using the 30E/360 ISDA day
basis convention. This convention assumes that months consists of 30 days
and years consist of 360 calendar days. This is also known as the Eurobond
(ISDA 2000) and German basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thirty_360_eu_isda(date1, date2, maturity_date)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thirty_360_eu_isda_+3A_date1">date1</code></td>
<td>
<p>A date-time object</p>
</td></tr>
<tr><td><code id="thirty_360_eu_isda_+3A_date2">date2</code></td>
<td>
<p>A date-time object</p>
</td></tr>
<tr><td><code id="thirty_360_eu_isda_+3A_maturity_date">maturity_date</code></td>
<td>
<p>the maturity date of the instrument</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The day count is determined after making the following (ordered)
modifications:
</p>

<ol>
<li><p> If the start date is the last day of the month, set the start date
to the 30th
</p>
</li>
<li><p> If the end date is the last day of the month, set the end date to
the 30th unless the end date is the maturity date and the end
month is February
</p>
</li></ol>

<p>The year fraction is then calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{(d_2-d_1) + (m_2-m_1)\times 30 + (y_2-y_1)\times 30}{360}</code>
</p>

<p>The order of <code>date1</code> and <code>date2</code> is not important. If <code>date1</code>
is less than <code>date2</code> then the result will be non-negative. Otherwise,
the result will be negative.
</p>


<h3>Value</h3>

<p>a numeric value representing the number of years between
<code>date1</code> and <code>date2</code>.
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_360">actual_360</a></code>,
<code><a href="#topic+actual_365">actual_365</a></code>,
<code><a href="#topic+actual_actual_isda">actual_actual_isda</a></code>,
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis</a></code>,
<code><a href="#topic+thirty_360_eu_plus">thirty_360_eu_plus</a></code>,
<code><a href="#topic+thirty_360_eu">thirty_360_eu</a></code>, <code><a href="#topic+thirty_360_us">thirty_360_us</a></code>,
<code><a href="#topic+thirty_360">thirty_360</a></code>, <code><a href="#topic+year_frac">year_frac</a></code>
</p>

<hr>
<h2 id='thirty_360_eu_plus'>The years between two dates using the 30E+/360 day basis convention.</h2><span id='topic+thirty_360_eu_plus'></span>

<h3>Description</h3>

<p>This calculates the years between two dates using the 30E+/360 day
basis convention. This convention assumes that months consists of 30 days
and years consist of 360 calendar days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thirty_360_eu_plus(date1, date2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thirty_360_eu_plus_+3A_date1">date1</code></td>
<td>
<p>A date-time object</p>
</td></tr>
<tr><td><code id="thirty_360_eu_plus_+3A_date2">date2</code></td>
<td>
<p>A date-time object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The day count is determined after making the following (ordered)
modifications:
</p>

<ol>
<li><p> If the start date is the 31st, set the start date to the 30th
</p>
</li>
<li><p> If the end date is the 31st, set the end date to the 1st of the
following month.
</p>
</li></ol>

<p>The year fraction is then calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{(d_2-d_1) + (m_2-m_1)\times 30 + (y_2-y_1)\times 360}{360}</code>
</p>

<p>The order of <code>date1</code> and <code>date2</code> is not important. If <code>date1</code>
is less than <code>date2</code> then the result will be non-negative. Otherwise,
the result will be negative.
</p>


<h3>Value</h3>

<p>a numeric value representing the number of years between
<code>date1</code> and <code>date2</code>.
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_360">actual_360</a></code>,
<code><a href="#topic+actual_365">actual_365</a></code>,
<code><a href="#topic+actual_actual_isda">actual_actual_isda</a></code>,
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis</a></code>,
<code><a href="#topic+thirty_360_eu_isda">thirty_360_eu_isda</a></code>,
<code><a href="#topic+thirty_360_eu">thirty_360_eu</a></code>, <code><a href="#topic+thirty_360_us">thirty_360_us</a></code>,
<code><a href="#topic+thirty_360">thirty_360</a></code>, <code><a href="#topic+year_frac">year_frac</a></code>
</p>

<hr>
<h2 id='thirty_360_us'>The years between two dates using the 30/360 (US) day basis convention.</h2><span id='topic+thirty_360_us'></span>

<h3>Description</h3>

<p>This calculates the years between two dates using the 30/360 (US) day basis
convention. This convention assumes that months consists of 30 days and
years consist of 360 calendar days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thirty_360_us(date1, date2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thirty_360_us_+3A_date1">date1</code></td>
<td>
<p>A date-time object.</p>
</td></tr>
<tr><td><code id="thirty_360_us_+3A_date2">date2</code></td>
<td>
<p>A date-time object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The day count is determined after making the following (ordered)
modifications:
</p>

<ol>
<li><p> If both the start and end dates are the last day of February, set
the end date to the 30th.
</p>
</li>
<li><p> If the start date is the last day of February, set the start date
to the 30th.
</p>
</li>
<li><p> If the end date is the 31st and the start date is either the 30th or
the 30th, set the end date to the 30th
</p>
</li>
<li><p> If the start date is the 31st, set the start date to the 30th.
</p>
</li></ol>

<p>The year fraction is then calculated as:
</p>
<p style="text-align: center;"><code class="reqn">\frac{(d_2 - d_1) + (m_2 - m_1) \times 30 + (y_2 - y_1)
 \times 30}{360}</code>
</p>

<p>The order of <code>date1</code> and <code>date2</code> is not important. If <code>date1</code>
is less than <code>date2</code> then the result will be non-negative. Otherwise,
the result will be negative.
</p>
<p>This is also known as the EOM adjusted bond basis.
</p>


<h3>Value</h3>

<p>A numeric value representing the number of years between
<code>date1</code> and <code>date2</code>.
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_360">actual_360</a></code>,
<code><a href="#topic+actual_365">actual_365</a></code>,
<code><a href="#topic+actual_actual_isda">actual_actual_isda</a></code>,
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis</a></code>,
<code><a href="#topic+thirty_360_eu_isda">thirty_360_eu_isda</a></code>,
<code><a href="#topic+thirty_360_eu_plus">thirty_360_eu_plus</a></code>,
<code><a href="#topic+thirty_360_eu">thirty_360_eu</a></code>, <code><a href="#topic+thirty_360">thirty_360</a></code>,
<code><a href="#topic+year_frac">year_frac</a></code>
</p>

<hr>
<h2 id='tz'>Extract time zone from calendars</h2><span id='topic+tz'></span><span id='topic+tz.Calendar'></span><span id='topic+tz.JointCalendar'></span>

<h3>Description</h3>

<p>Extract time zone from calendars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Calendar'
tz(x)

## S3 method for class 'JointCalendar'
tz(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tz_+3A_x">x</code></td>
<td>
<p>an instance of a <code><a href="#topic+Calendar">Calendar</a></code> or <code><a href="#topic+JointCalendar">JointCalendar</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string representing the time zone (e.g. &quot;Australia/Sydney&quot;) or
vector of time zones in the case of joint calendars
</p>


<h3>See Also</h3>

<p>Other calendar methods: <code><a href="#topic+adjust">adjust</a></code>,
<code><a href="#topic+generate_schedule">generate_schedule</a></code>, <code><a href="#topic+is_good">is_good</a></code>,
<code><a href="#topic+is_valid_bdc">is_valid_bdc</a></code>, <code><a href="#topic+is">is</a></code>,
<code><a href="#topic+locale">locale</a></code>, <code><a href="#topic+shift">shift</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lubridate::tz(AUSYCalendar())
lubridate::tz(c(AUSYCalendar(), AUMECalendar()))
</code></pre>

<hr>
<h2 id='year_frac'>The years between two dates for a given day basis convention</h2><span id='topic+year_frac'></span>

<h3>Description</h3>

<p>This calculates the years between two dates using the given day
basis convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>year_frac(date1, date2, day_basis, maturity_date = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="year_frac_+3A_date1">date1</code></td>
<td>
<p>A vector of dates. This will be coerced to a <code><a href="base.html#topic+Date">Date</a></code>
class.</p>
</td></tr>
<tr><td><code id="year_frac_+3A_date2">date2</code></td>
<td>
<p>A vector of dates. This will be coerced to a <code><a href="base.html#topic+Date">Date</a></code>
class.</p>
</td></tr>
<tr><td><code id="year_frac_+3A_day_basis">day_basis</code></td>
<td>
<p>The basis on which the year fraction is calculated. See
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis()</a></code></p>
</td></tr>
<tr><td><code id="year_frac_+3A_maturity_date">maturity_date</code></td>
<td>
<p>a vector of dates representing the maturity date of
the instrument. Only used for 30E/360 ISDA day basis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of <code>date1</code> and <code>date2</code> is not important. If <code>date1</code>
is less than <code>date2</code> then the result will be non-negative. Otherwise,
the result will be negative. The parameters will be repeated with recycling
such that each parameter's length is equal to maximum length of
any of the parameters.
</p>


<h3>Value</h3>

<p>a numeric vector representing the number of years between
<code>date1</code> and <code>date2</code>.
</p>


<h3>References</h3>

<p><a href="http://en.wikipedia.org/wiki/Day_count_convention">http://en.wikipedia.org/wiki/Day_count_convention</a>
</p>


<h3>See Also</h3>

<p>Other counter methods: <code><a href="#topic+actual_360">actual_360</a></code>,
<code><a href="#topic+actual_365">actual_365</a></code>,
<code><a href="#topic+actual_actual_isda">actual_actual_isda</a></code>,
<code><a href="#topic+is_valid_day_basis">is_valid_day_basis</a></code>,
<code><a href="#topic+thirty_360_eu_isda">thirty_360_eu_isda</a></code>,
<code><a href="#topic+thirty_360_eu_plus">thirty_360_eu_plus</a></code>,
<code><a href="#topic+thirty_360_eu">thirty_360_eu</a></code>, <code><a href="#topic+thirty_360_us">thirty_360_us</a></code>,
<code><a href="#topic+thirty_360">thirty_360</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(lubridate)
year_frac(ymd("2010-03-31"), ymd("2012-03-31"), "30/360us") # 2
year_frac(ymd("2010-02-28"), ymd("2012-03-31"), "act/360")  # 2.116667
year_frac(ymd("2010-02-28"), ymd("2012-03-31"), "act/365")  # 2.087671
year_frac(ymd("2010-02-28"), ymd("2012-03-31"), "act/actisda")  # 2.086998
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
