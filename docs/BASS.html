<!DOCTYPE html><html><head><title>Help for package BASS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BASS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bass'><p>Bayesian Adaptive Spline Surfaces (BASS)</p></a></li>
<li><a href='#bassBasis'><p>Bayesian Adaptive Spline Surfaces (BASS) with basis decomposition of response</p></a></li>
<li><a href='#bassPCA'><p>Bayesian Adaptive Spline Surfaces (BASS) with PCA decomposition of response</p></a></li>
<li><a href='#calibrate.bassBasis'><p>Calibrate a bassPCA or bassBasis Model to Data</p></a></li>
<li><a href='#plot.bass'><p>BASS Plot Diagnostics</p></a></li>
<li><a href='#plot.bassBasis'><p>BASS Plot Diagnostics</p></a></li>
<li><a href='#plot.bassSob'><p>Plot BASS sensitivity indices</p></a></li>
<li><a href='#predict.bass'><p>BASS Prediction</p></a></li>
<li><a href='#predict.bassBasis'><p>BASS Prediction</p></a></li>
<li><a href='#print.bass'><p>Print BASS Details</p></a></li>
<li><a href='#print.bassBasis'><p>Print BASS Details</p></a></li>
<li><a href='#sobol'><p>BASS Sensitivity Analysis</p></a></li>
<li><a href='#sobolBasis'><p>BASS Sensitivity Analysis</p></a></li>
<li><a href='#summary.bass'><p>Summarize BASS Details</p></a></li>
<li><a href='#summary.bassBasis'><p>Summarize BASS Details</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-7-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Adaptive Spline Surfaces</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian fitting and sensitivity analysis methods for adaptive
    spline surfaces described in &lt;<a href="https://doi.org/10.18637%2Fjss.v094.i08">doi:10.18637/jss.v094.i08</a>&gt;. Built to handle continuous and categorical inputs as well as
    functional or scalar output. An extension of the methodology in Denison, Mallick
    and Smith (1998) &lt;<a href="https://doi.org/10.1023%2FA%3A1008824606259">doi:10.1023/A:1008824606259</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, testthat (&ge; 2.1.0), parallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Imports:</td>
<td>truncdist, hypergeo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-01 17:36:04 UTC; dfrancom</td>
</tr>
<tr>
<td>Author:</td>
<td>Devin Francom [aut, cre],
  Bruno Sanso [ths],
  Kellin Rumsey [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Devin Francom &lt;devinfrancom@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-04 13:13:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='bass'>Bayesian Adaptive Spline Surfaces (BASS)</h2><span id='topic+bass'></span>

<h3>Description</h3>

<p>Fits a BASS model using RJMCMC.  Optionally uses parallel tempering to improve mixing.  Can be used with scalar or functional response.  Also can use categorical inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bass(
  xx,
  y,
  maxInt = 3,
  maxInt.func = 3,
  maxInt.cat = 3,
  xx.func = NULL,
  degree = 1,
  maxBasis = 1000,
  npart = NULL,
  npart.func = NULL,
  nmcmc = 10000,
  nburn = 9000,
  thin = 1,
  g1 = 0,
  g2 = 0,
  s2.lower = 0,
  h1 = 10,
  h2 = 10,
  a.tau = 0.5,
  b.tau = NULL,
  w1 = 5,
  w2 = 5,
  beta.prior = "g",
  temp.ladder = NULL,
  start.temper = NULL,
  curr.list = NULL,
  save.yhat = TRUE,
  small = FALSE,
  verbose = TRUE,
  ret.str = F
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bass_+3A_xx">xx</code></td>
<td>
<p>a data frame or matrix of predictors.  Categorical predictors should be included as factors.</p>
</td></tr>
<tr><td><code id="bass_+3A_y">y</code></td>
<td>
<p>a response vector (scalar response) or matrix (functional response).  Note: If <code>sum(y^2)</code> is large (i.e. <code>1e10</code>), please center/rescale (and rescale <code>g1</code> and <code>g2</code> if necessary).</p>
</td></tr>
<tr><td><code id="bass_+3A_maxint">maxInt</code></td>
<td>
<p>integer for maximum degree of interaction in spline basis functions.  Defaults to the number of predictors, which could result in overfitting.</p>
</td></tr>
<tr><td><code id="bass_+3A_maxint.func">maxInt.func</code></td>
<td>
<p>(functional response only) integer for maximum degree of interaction in spline basis functions describing the functional response.</p>
</td></tr>
<tr><td><code id="bass_+3A_maxint.cat">maxInt.cat</code></td>
<td>
<p>(categorical input only) integer for maximum degree of interaction of categorical inputs.</p>
</td></tr>
<tr><td><code id="bass_+3A_xx.func">xx.func</code></td>
<td>
<p>a vector, matrix or data frame of functional variables.</p>
</td></tr>
<tr><td><code id="bass_+3A_degree">degree</code></td>
<td>
<p>degree of splines.  Stability should be examined for anything other than 1.</p>
</td></tr>
<tr><td><code id="bass_+3A_maxbasis">maxBasis</code></td>
<td>
<p>maximum number of basis functions.  This should probably only be altered if you run out of memory.</p>
</td></tr>
<tr><td><code id="bass_+3A_npart">npart</code></td>
<td>
<p>minimum number of non-zero points in a basis function.  If the response is functional, this refers only to the portion of the basis function coming from the non-functional predictors. Defaults to 20 or 0.1 times the number of observations, whichever is smaller.</p>
</td></tr>
<tr><td><code id="bass_+3A_npart.func">npart.func</code></td>
<td>
<p>same as npart, but for functional portion of basis function.</p>
</td></tr>
<tr><td><code id="bass_+3A_nmcmc">nmcmc</code></td>
<td>
<p>number of RJMCMC iterations.</p>
</td></tr>
<tr><td><code id="bass_+3A_nburn">nburn</code></td>
<td>
<p>number of the <code>nmcmc</code> iterations to disregard.</p>
</td></tr>
<tr><td><code id="bass_+3A_thin">thin</code></td>
<td>
<p>keep every <code>thin</code> samples</p>
</td></tr>
<tr><td><code id="bass_+3A_g1">g1</code></td>
<td>
<p>shape for IG prior on <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_g2">g2</code></td>
<td>
<p>scale for IG prior on <code class="reqn">\sigma^2</code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_s2.lower">s2.lower</code></td>
<td>
<p>lower bound for s2. Turns IG prior for s2 into a truncated IG.</p>
</td></tr>
<tr><td><code id="bass_+3A_h1">h1</code></td>
<td>
<p>shape for gamma prior on <code class="reqn">\lambda</code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_h2">h2</code></td>
<td>
<p>rate for gamma prior on <code class="reqn">\lambda</code>.  This is the primary way to control overfitting.  A large value of <code>h2</code> favors fewer basis functions.</p>
</td></tr>
<tr><td><code id="bass_+3A_a.tau">a.tau</code></td>
<td>
<p>shape for gamma prior on <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code id="bass_+3A_b.tau">b.tau</code></td>
<td>
<p>rate for gamma prior on <code class="reqn">\tau</code>. Defaults to one over the number of observations, which centers the prior for the basis function weights on the unit information prior.</p>
</td></tr>
<tr><td><code id="bass_+3A_w1">w1</code></td>
<td>
<p>nominal weight for degree of interaction, used in generating candidate basis functions.  Should be greater than 0.</p>
</td></tr>
<tr><td><code id="bass_+3A_w2">w2</code></td>
<td>
<p>nominal weight for variables, used in generating candidate basis functions.  Should be greater than 0.</p>
</td></tr>
<tr><td><code id="bass_+3A_beta.prior">beta.prior</code></td>
<td>
<p>what type of prior to use for basis coefficients, &quot;g&quot; or &quot;jeffreys&quot;</p>
</td></tr>
<tr><td><code id="bass_+3A_temp.ladder">temp.ladder</code></td>
<td>
<p>temperature ladder used for parallel tempering.  The first value should be 1 and the values should increase.</p>
</td></tr>
<tr><td><code id="bass_+3A_start.temper">start.temper</code></td>
<td>
<p>when to start tempering (after how many MCMC iterations). Defaults to 1000 or half of burn-in, whichever is smaller.</p>
</td></tr>
<tr><td><code id="bass_+3A_curr.list">curr.list</code></td>
<td>
<p>list of starting models (one element for each temperature), could be output from a previous run under the same model setup.</p>
</td></tr>
<tr><td><code id="bass_+3A_save.yhat">save.yhat</code></td>
<td>
<p>logical; should predictions of training data be saved?</p>
</td></tr>
<tr><td><code id="bass_+3A_small">small</code></td>
<td>
<p>logical; if true, returns a smaller object by leaving out <code>curr.list</code> and other unnecessary objects.  Use in combination with <code>save.yhat</code> to get smaller memory footprint for very large models.</p>
</td></tr>
<tr><td><code id="bass_+3A_verbose">verbose</code></td>
<td>
<p>logical; should progress be displayed?</p>
</td></tr>
<tr><td><code id="bass_+3A_ret.str">ret.str</code></td>
<td>
<p>logical; return data and prior structures</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Explores BASS model space by RJMCMC.  The BASS model has </p>
<p style="text-align: center;"><code class="reqn">y = f(x) + \epsilon,  ~~\epsilon \sim N(0,\sigma^2)</code>
</p>
 <p style="text-align: center;"><code class="reqn">f(x) = a_0 + \sum_{m=1}^M a_m B_m(x)</code>
</p>
<p> and <code class="reqn">B_m(x)</code> is a BASS basis function (tensor product of spline basis functions). We use priors </p>
<p style="text-align: center;"><code class="reqn">a \sim N(0,\sigma^2/\tau (B'B)^{-1})</code>
</p>
 <p style="text-align: center;"><code class="reqn">M \sim Poisson(\lambda)</code>
</p>
<p> as well as the priors mentioned in the arguments above.
</p>


<h3>Value</h3>

<p>An object of class 'bass'.  The other output will only be useful to the advanced user.  Rather, users may be interested in prediction and sensitivity analysis, which are obtained by passing the entire object to the predict.bass or sobol functions.
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.bass">predict.bass</a> for prediction and <a href="#topic+sobol">sobol</a> for sensitivity analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
####################################################################################################
### univariate example
####################################################################################################
## simulate data (Friedman function)
f&lt;-function(x){
  10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
}
sigma&lt;-1 # noise sd
n&lt;-500 # number of observations
x&lt;-matrix(runif(n*10),n,10) #10 variables, only first 5 matter
y&lt;-rnorm(n,f(x),sigma)

## fit BASS, no tempering
mod&lt;-bass(x,y)
plot(mod)
## fit BASS, tempering
mod&lt;-bass(x,y,temp.ladder=1.3^(0:8),start.temper=1000)
plot(mod)

## prediction
npred&lt;-1000
xpred&lt;-matrix(runif(npred*10),npred,10)
pred&lt;-predict(mod,xpred,verbose=TRUE) # posterior predictive samples
true.y&lt;-f(xpred)
plot(true.y,colMeans(pred),xlab='true values',ylab='posterior predictive means')
abline(a=0,b=1,col=2)

## sensitivity
sens&lt;-sobol(mod)
plot(sens,cex.axis=.5)

####################################################################################################
### functional example
####################################################################################################
## simulate data (Friedman function with first variable as functional)
sigma&lt;-1 # noise sd
n&lt;-500 # number of observations
nfunc&lt;-50 # size of functional variable grid
xfunc&lt;-seq(0,1,length.out=nfunc) # functional grid
x&lt;-matrix(runif(n*9),n,9) # 9 non-functional variables, only first 4 matter
X&lt;-cbind(rep(xfunc,each=n),kronecker(rep(1,nfunc),x)) # to get y
y&lt;-matrix(f(X),nrow=n)+rnorm(n*nfunc,0,sigma)

## fit BASS
mod&lt;-bass(x,y,xx.func=xfunc)
plot(mod)

## prediction
npred&lt;-100
xpred&lt;-matrix(runif(npred*9),npred,9)
Xpred&lt;-cbind(rep(xfunc,each=npred),kronecker(rep(1,nfunc),xpred))
ypred&lt;-matrix(f(Xpred),nrow=npred)
pred&lt;-predict(mod,xpred) # posterior predictive samples (each is a curve)
matplot(ypred,apply(pred,2:3,mean),type='l',xlab='observed',ylab='mean prediction')
abline(a=0,b=1,col=2)
matplot(t(ypred),type='l') # actual
matplot(t(apply(pred,2:3,mean)),type='l') # mean prediction

## sensitivity
sens&lt;-sobol(mod,mcmc.use=1:10) # for speed, only use a few samples
plot(sens) # functional variable labelled "a"

sens.func&lt;-sobol(mod,mcmc.use=1:10,func.var=1)
plot(sens.func)

## End(Not run)

## minimal example for CRAN testing
mod&lt;-bass(1:2,1:2,nmcmc=2,nburn=1)
</code></pre>

<hr>
<h2 id='bassBasis'>Bayesian Adaptive Spline Surfaces (BASS) with basis decomposition of response</h2><span id='topic+bassBasis'></span>

<h3>Description</h3>

<p>Fits a BASS model to basis coefficients under the specified basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bassBasis(dat, n.cores = 1, parType = "fork", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bassBasis_+3A_dat">dat</code></td>
<td>
<p>list that includes elements <code>xx</code>, <code>n.pc</code> (number of basis functions), <code>basis</code> (dimension m x <code>n.pc</code>), <code>newy</code> (dimension <code>n.pc</code> x n), <code>trunc.error</code> (optional truncation error with dimension n x m), <code>y.m</code> (vector mean removed before basis decomposition with dimension m), <code>y.s</code> (vector sd scaled before basis decomposition with dimension m).  See the documentation of <code>bassPCA</code> for more details.</p>
</td></tr>
<tr><td><code id="bassBasis_+3A_n.cores">n.cores</code></td>
<td>
<p>integer number of cores (threads) to use</p>
</td></tr>
<tr><td><code id="bassBasis_+3A_partype">parType</code></td>
<td>
<p>either &quot;fork&quot; or &quot;socket&quot;.  Forking is typically faster, but not compatible with Windows. If <code>n.cores==1</code>, <code>parType</code> is ignored.</p>
</td></tr>
<tr><td><code id="bassBasis_+3A_...">...</code></td>
<td>
<p>arguements to be passed to <code>bass</code> function calls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under a user defined basis decomposition, fits a bass model to each PCA basis coefficient independently, <code>bass(dat$xx,dat$newy[i,],...)</code> for <code>i in 1 to n.pc</code>, possibly in parallel.  The basis does not need to be orthogonal, but independent modeling of basis coefficients should be sensible.
</p>


<h3>Value</h3>

<p>An object of class 'bassBasis' with two elements:
</p>
<table>
<tr><td><code>mod.list</code></td>
<td>
<p>list (of length <code>n.pc</code>) of individual bass models</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>same as dat above</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+predict.bassBasis">predict.bassBasis</a> for prediction and <a href="#topic+sobolBasis">sobolBasis</a> for sensitivity analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ## simulate data (Friedman function)
f&lt;-function(x){
  10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
}
## simulate data (Friedman function with first variable as functional)
sigma&lt;-.1 # noise sd
n&lt;-500 # number of observations
nfunc&lt;-50 # size of functional variable grid
xfunc&lt;-seq(0,1,length.out=nfunc) # functional grid
x&lt;-matrix(runif(n*9),n,9) # 9 non-functional variables, only first 4 matter
X&lt;-cbind(rep(xfunc,each=n),kronecker(rep(1,nfunc),x)) # to get y
y&lt;-matrix(f(X),nrow=n)+rnorm(n*nfunc,0,sigma)

## fit BASS
library(parallel)
mod&lt;-bassPCA(x,y,n.pc=5,n.cores=min(5,parallel::detectCores()))
plot(mod$mod.list[[1]])
plot(mod$mod.list[[2]])
plot(mod$mod.list[[3]])
plot(mod$mod.list[[4]])
plot(mod$mod.list[[5]])

hist(mod$dat$trunc.error)

## prediction
npred&lt;-100
xpred&lt;-matrix(runif(npred*9),npred,9)
Xpred&lt;-cbind(rep(xfunc,each=npred),kronecker(rep(1,nfunc),xpred))
ypred&lt;-matrix(f(Xpred),nrow=npred)
pred&lt;-predict(mod,xpred,mcmc.use=1:1000) # posterior predictive samples (each is a curve)
matplot(ypred,apply(pred,2:3,mean),type='l',xlab='observed',ylab='mean prediction')
abline(a=0,b=1,col=2)
matplot(t(ypred),type='l') # actual
matplot(t(apply(pred,2:3,mean)),type='l') # mean prediction

## sensitivity
sens&lt;-sobolBasis(mod,int.order = 2,ncores = max(parallel::detectCores()-2,1),
                 mcmc.use=1000) # for speed, only use a few samples
plot(sens)


## calibration
x.true&lt;-runif(9,0,1) # what we are trying to learn
yobs&lt;-f(cbind(xfunc,kronecker(rep(1,nfunc),t(x.true)))) +
  rnorm(nfunc,0,.1) # calibration data (with measurement error)
plot(yobs)

cal&lt;-calibrate.bassBasis(y=yobs,mod=mod,
                         discrep.mean=rep(0,nfunc),
                         discrep.mat=diag(nfunc)[,1:2]*.0000001,
                         sd.est=.1,
                         s2.df=50,
                         s2.ind=rep(1,nfunc),
                         meas.error.cor=diag(nfunc),
                         bounds=rbind(rep(0,9),rep(1,9)),
                         nmcmc=10000,
                         temperature.ladder=1.05^(0:30),type=1)

nburn&lt;-5000
uu&lt;-seq(nburn,10000,5)

pairs(rbind(cal$theta[uu,1,],x.true),col=c(rep(1,length(uu)),2),ylim=c(0,1),xlim=c(0,1))

pred&lt;-apply(predict(mod,cal$theta[uu,1,],nugget = T,trunc.error = T,
      mcmc.use = cal$ii[uu]),3,function(x) diag(x)+rnorm(length(uu),0,sqrt(cal$s2[uu,1,1])))
qq&lt;-apply(pred,2,quantile,probs=c(.025,.975))
matplot(t(qq),col='lightgrey',type='l')
lines(yobs,lwd=3)



## End(Not run)
## minimal example for CRAN testing
mod&lt;-bassPCA(1:10,matrix(1:20,10),n.pc=2,nmcmc=2,nburn=1)
</code></pre>

<hr>
<h2 id='bassPCA'>Bayesian Adaptive Spline Surfaces (BASS) with PCA decomposition of response</h2><span id='topic+bassPCA'></span>

<h3>Description</h3>

<p>Decomposes a multivariate or functional response onto a principal component basis and fits a BASS model to each basis coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bassPCA(
  xx = NULL,
  y = NULL,
  dat = NULL,
  n.pc = NULL,
  perc.var = 99,
  n.cores = 1,
  parType = "fork",
  center = T,
  scale = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bassPCA_+3A_xx">xx</code></td>
<td>
<p>a data frame or matrix of predictors with dimension n x p.  Categorical predictors should be included as factors.</p>
</td></tr>
<tr><td><code id="bassPCA_+3A_y">y</code></td>
<td>
<p>a response matrix (functional response) with dimension n x m.</p>
</td></tr>
<tr><td><code id="bassPCA_+3A_dat">dat</code></td>
<td>
<p>optional (for more control) list with elements <code>xx</code> (same as above), <code>y</code> (same as above), <code>n.pc</code> (number of principal components used), <code>basis</code> (principal components with dimension m x <code>n.pc</code>), <code>newy</code> (reduced dimension <code>y</code> with dimension <code>n.pc</code> x n), <code>trunc.error</code> (optional truncation error with dimension n x m), <code>y.m</code> (vector mean removed before PCA with dimension m), <code>y.s</code> (vector sd scaled before PCA with dimension m).  If <code>dat</code> is specified, <code>xx</code>, <code>y</code> and <code>n.pc</code> do not need to be specified.</p>
</td></tr>
<tr><td><code id="bassPCA_+3A_n.pc">n.pc</code></td>
<td>
<p>number of principal components to use</p>
</td></tr>
<tr><td><code id="bassPCA_+3A_perc.var">perc.var</code></td>
<td>
<p>optionally specify percent of variance to explain instead of n.pc</p>
</td></tr>
<tr><td><code id="bassPCA_+3A_n.cores">n.cores</code></td>
<td>
<p>integer number of cores (threads) to use</p>
</td></tr>
<tr><td><code id="bassPCA_+3A_partype">parType</code></td>
<td>
<p>either &quot;fork&quot; or &quot;socket&quot;.  Forking is typically faster, but not compatible with Windows. If <code>n.cores==1</code>, <code>parType</code> is ignored.</p>
</td></tr>
<tr><td><code id="bassPCA_+3A_center">center</code></td>
<td>
<p>logical whether to subtract the mean before getting the principal components, or else a numeric vector of dimension m for the center to be used</p>
</td></tr>
<tr><td><code id="bassPCA_+3A_scale">scale</code></td>
<td>
<p>logical whether to divide by the standard deviation before getting the principal components, or else a numeric vector of dimension m for the scale to be used</p>
</td></tr>
<tr><td><code id="bassPCA_+3A_...">...</code></td>
<td>
<p>arguements to be passed to <code>bass</code> function calls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gets the PCA decomposition of the response <code>y</code>, and fits a bass model to each PCA basis coefficient, <code>bass(dat$xx,dat$newy[i,],...)</code> for <code>i in 1 to n.pc</code>, possibly in parallel.
</p>


<h3>Value</h3>

<p>An object of class 'bassBasis' with two elements:
</p>
<table>
<tr><td><code>mod.list</code></td>
<td>
<p>list (of length <code>n.pc</code>) of individual bass models</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>same as dat above</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+predict.bassBasis">predict.bassBasis</a> for prediction and <a href="#topic+sobolBasis">sobolBasis</a> for sensitivity analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ## simulate data (Friedman function)
f&lt;-function(x){
  10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
}
## simulate data (Friedman function with first variable as functional)
sigma&lt;-.1 # noise sd
n&lt;-500 # number of observations
nfunc&lt;-50 # size of functional variable grid
xfunc&lt;-seq(0,1,length.out=nfunc) # functional grid
x&lt;-matrix(runif(n*9),n,9) # 9 non-functional variables, only first 4 matter
X&lt;-cbind(rep(xfunc,each=n),kronecker(rep(1,nfunc),x)) # to get y
y&lt;-matrix(f(X),nrow=n)+rnorm(n*nfunc,0,sigma)

## fit BASS
library(parallel)
mod&lt;-bassPCA(x,y,n.pc=5,n.cores=min(5,parallel::detectCores()))
plot(mod$mod.list[[1]])
plot(mod$mod.list[[2]])
plot(mod$mod.list[[3]])
plot(mod$mod.list[[4]])
plot(mod$mod.list[[5]])

hist(mod$dat$trunc.error)

## prediction
npred&lt;-100
xpred&lt;-matrix(runif(npred*9),npred,9)
Xpred&lt;-cbind(rep(xfunc,each=npred),kronecker(rep(1,nfunc),xpred))
ypred&lt;-matrix(f(Xpred),nrow=npred)
pred&lt;-predict(mod,xpred,mcmc.use=1:1000) # posterior predictive samples (each is a curve)
matplot(ypred,apply(pred,2:3,mean),type='l',xlab='observed',ylab='mean prediction')
abline(a=0,b=1,col=2)
matplot(t(ypred),type='l') # actual
matplot(t(apply(pred,2:3,mean)),type='l') # mean prediction

## sensitivity
sens&lt;-sobolBasis(mod,int.order = 2,ncores = max(parallel::detectCores()-2,1),
                 mcmc.use=1000) # for speed, only use a few samples
plot(sens)


## calibration
x.true&lt;-runif(9,0,1) # what we are trying to learn
yobs&lt;-f(cbind(xfunc,kronecker(rep(1,nfunc),t(x.true)))) +
  rnorm(nfunc,0,.1) # calibration data (with measurement error)
plot(yobs)

cal&lt;-calibrate.bassBasis(y=yobs,mod=mod,
                         discrep.mean=rep(0,nfunc),
                         discrep.mat=diag(nfunc)[,1:2]*.0000001,
                         sd.est=.1,
                         s2.df=50,
                         s2.ind=rep(1,nfunc),
                         meas.error.cor=diag(nfunc),
                         bounds=rbind(rep(0,9),rep(1,9)),
                         nmcmc=10000,
                         temperature.ladder=1.05^(0:30),type=1)

nburn&lt;-5000
uu&lt;-seq(nburn,10000,5)

pairs(rbind(cal$theta[uu,1,],x.true),col=c(rep(1,length(uu)),2),ylim=c(0,1),xlim=c(0,1))

pred&lt;-apply(predict(mod,cal$theta[uu,1,],nugget = T,trunc.error = T,
      mcmc.use = cal$ii[uu]),3,function(x) diag(x)+rnorm(length(uu),0,sqrt(cal$s2[uu,1,1])))
qq&lt;-apply(pred,2,quantile,probs=c(.025,.975))
matplot(t(qq),col='lightgrey',type='l')
lines(yobs,lwd=3)



## End(Not run)
## minimal example for CRAN testing
mod&lt;-bassPCA(1:10,matrix(1:20,10),n.pc=2,nmcmc=2,nburn=1)
</code></pre>

<hr>
<h2 id='calibrate.bassBasis'>Calibrate a bassPCA or bassBasis Model to Data</h2><span id='topic+calibrate.bassBasis'></span>

<h3>Description</h3>

<p>Robust modular calibration of a bassPCA or bassBasis emulator using adaptive Metropolis, tempering, and decorrelation steps in an effort to be free of any user-required tuning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrate.bassBasis(
  y,
  mod,
  type,
  sd.est,
  s2.df,
  s2.ind,
  meas.error.cor,
  bounds,
  discrep.mean,
  discrep.mat,
  nmcmc = 10000,
  temperature.ladder = 1.05^(0:30),
  decor.step.every = 100,
  verbose = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrate.bassBasis_+3A_y">y</code></td>
<td>
<p>vector of calibration data</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_mod">mod</code></td>
<td>
<p>a emulator of class bassBasis, whose predictions should match y (i.e., predictions from mod should be the same length as y)</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_type">type</code></td>
<td>
<p>one of c(1,2). 1 indicates a model that uses independent truncation error variance, no measurement error correlation, and discrepancy on a basis while type 2 indicates a model that uses a full truncation error covariance matrix, a full measurement error correlation matrix, a fixed full discrepancy covariance matrix, and a fixed discrepancy mean. 1 is for situations where computational efficiency is important (because y is dense), while 2 is only for cases where y is a short vector.</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_sd.est">sd.est</code></td>
<td>
<p>vector of prior estimates of measurement error standard deviation</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_s2.df">s2.df</code></td>
<td>
<p>vector of degrees of freedom for measurement error sd prior estimates</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_s2.ind">s2.ind</code></td>
<td>
<p>index vector, same length as y, indicating which sd.est goes with which y</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_meas.error.cor">meas.error.cor</code></td>
<td>
<p>a fixed correlation matrix for the measurement errors</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_bounds">bounds</code></td>
<td>
<p>a 2xp matrix of bounds for each input parameter, where p is the number of input parameters.</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_discrep.mean">discrep.mean</code></td>
<td>
<p>discrepancy mean (fixed), only used if type=2</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_discrep.mat">discrep.mat</code></td>
<td>
<p>discrepancy covariance (fixed, for type 2) or basis (if not square, for type 1)</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_nmcmc">nmcmc</code></td>
<td>
<p>number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_temperature.ladder">temperature.ladder</code></td>
<td>
<p>an increasing vector, all greater than 1, for tempering. Geometric spacing is recommended, so that you have (1+delta)^(0:ntemps), where delta is small (typically between 0.05 and 0.2) and ntemps is the number of elements in the vector.</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_decor.step.every">decor.step.every</code></td>
<td>
<p>integer number of MCMC iterations between decorrelation steps.</p>
</td></tr>
<tr><td><code id="calibrate.bassBasis_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether to print progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits a modular Bayesian calibration model, with </p>
<p style="text-align: center;"><code class="reqn">y = Kw(\theta) + Dv + \epsilon,  ~~\epsilon \sim N(0,\sigma^2 R)</code>
</p>
 <p style="text-align: center;"><code class="reqn">f(x) = a_0 + \sum_{m=1}^M a_m B_m(x)</code>
</p>
<p> and <code class="reqn">B_m(x)</code> is a BASS basis function (tensor product of spline basis functions). We use priors </p>
<p style="text-align: center;"><code class="reqn">a \sim N(0,\sigma^2/\tau (B'B)^{-1})</code>
</p>
 <p style="text-align: center;"><code class="reqn">M \sim Poisson(\lambda)</code>
</p>
<p> as well as the priors mentioned in the arguments above.
</p>


<h3>Value</h3>

<p>An object
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.bassBasis">predict.bassBasis</a> for prediction and <a href="#topic+sobolBasis">sobolBasis</a> for sensitivity analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  ## simulate data (Friedman function)
f&lt;-function(x){
  10*sin(pi*x[,1]*x[,2])+20*(x[,3]-.5)^2+10*x[,4]+5*x[,5]
}
## simulate data (Friedman function with first variable as functional)
sigma&lt;-.1 # noise sd
n&lt;-500 # number of observations
nfunc&lt;-50 # size of functional variable grid
xfunc&lt;-seq(0,1,length.out=nfunc) # functional grid
x&lt;-matrix(runif(n*9),n,9) # 9 non-functional variables, only first 4 matter
X&lt;-cbind(rep(xfunc,each=n),kronecker(rep(1,nfunc),x)) # to get y
y&lt;-matrix(f(X),nrow=n)+rnorm(n*nfunc,0,sigma)

## fit BASS
library(parallel)
mod&lt;-bassPCA(x,y,n.pc=5,n.cores=min(5,parallel::detectCores()))
plot(mod$mod.list[[1]])
plot(mod$mod.list[[2]])
plot(mod$mod.list[[3]])
plot(mod$mod.list[[4]])
plot(mod$mod.list[[5]])

hist(mod$dat$trunc.error)

## prediction
npred&lt;-100
xpred&lt;-matrix(runif(npred*9),npred,9)
Xpred&lt;-cbind(rep(xfunc,each=npred),kronecker(rep(1,nfunc),xpred))
ypred&lt;-matrix(f(Xpred),nrow=npred)
pred&lt;-predict(mod,xpred,mcmc.use=1:1000) # posterior predictive samples (each is a curve)
matplot(ypred,apply(pred,2:3,mean),type='l',xlab='observed',ylab='mean prediction')
abline(a=0,b=1,col=2)
matplot(t(ypred),type='l') # actual
matplot(t(apply(pred,2:3,mean)),type='l') # mean prediction

## sensitivity
sens&lt;-sobolBasis(mod,int.order = 2,ncores = max(parallel::detectCores()-2,1),
                 mcmc.use=1000) # for speed, only use a few samples
plot(sens)


## calibration
x.true&lt;-runif(9,0,1) # what we are trying to learn
yobs&lt;-f(cbind(xfunc,kronecker(rep(1,nfunc),t(x.true)))) +
  rnorm(nfunc,0,.1) # calibration data (with measurement error)
plot(yobs)

cal&lt;-calibrate.bassBasis(y=yobs,mod=mod,
                         discrep.mean=rep(0,nfunc),
                         discrep.mat=diag(nfunc)[,1:2]*.0000001,
                         sd.est=.1,
                         s2.df=50,
                         s2.ind=rep(1,nfunc),
                         meas.error.cor=diag(nfunc),
                         bounds=rbind(rep(0,9),rep(1,9)),
                         nmcmc=10000,
                         temperature.ladder=1.05^(0:30),type=1)

nburn&lt;-5000
uu&lt;-seq(nburn,10000,5)

pairs(rbind(cal$theta[uu,1,],x.true),col=c(rep(1,length(uu)),2),ylim=c(0,1),xlim=c(0,1))

pred&lt;-apply(predict(mod,cal$theta[uu,1,],nugget = T,trunc.error = T,
      mcmc.use = cal$ii[uu]),3,function(x) diag(x)+rnorm(length(uu),0,sqrt(cal$s2[uu,1,1])))
qq&lt;-apply(pred,2,quantile,probs=c(.025,.975))
matplot(t(qq),col='lightgrey',type='l')
lines(yobs,lwd=3)



## End(Not run)
## minimal example for CRAN testing
mod&lt;-bassPCA(1:10,matrix(1:20,10),n.pc=2,nmcmc=2,nburn=1)
</code></pre>

<hr>
<h2 id='plot.bass'>BASS Plot Diagnostics</h2><span id='topic+plot.bass'></span>

<h3>Description</h3>

<p>Generate diagnostic plots for BASS model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bass'
plot(x, quants = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bass_+3A_x">x</code></td>
<td>
<p>a <code>bass</code> object.</p>
</td></tr>
<tr><td><code id="plot.bass_+3A_quants">quants</code></td>
<td>
<p>quantiles for intervals, if desired.  NULL if not desired.</p>
</td></tr>
<tr><td><code id="plot.bass_+3A_...">...</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two plots are trace plots for diagnosing convergence.  The third plot is posterior predicted vs observed, with intervals for predictions.  The fourth plot is a histogram of the residuals (of the posterior mean model), with a red curve showing the assumed Normal density (using posterior mean variance).  If <code>bass</code> was run with <code>save.yhat = FALSE</code>, the third and fourth plots are omitted.
</p>


<h3>See Also</h3>

<p><a href="#topic+bass">bass</a>, <a href="#topic+predict.bass">predict.bass</a>, <a href="#topic+sobol">sobol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in bass documentation.

</code></pre>

<hr>
<h2 id='plot.bassBasis'>BASS Plot Diagnostics</h2><span id='topic+plot.bassBasis'></span>

<h3>Description</h3>

<p>Generate diagnostic plots for BASS model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bassBasis'
plot(x, quants = c(0.025, 0.975), pred = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bassBasis_+3A_x">x</code></td>
<td>
<p>a <code>bassBasis</code> object.</p>
</td></tr>
<tr><td><code id="plot.bassBasis_+3A_quants">quants</code></td>
<td>
<p>quantiles for intervals, if desired.  NULL if not desired.</p>
</td></tr>
<tr><td><code id="plot.bassBasis_+3A_pred">pred</code></td>
<td>
<p>logical, should predictive performance be plotted?</p>
</td></tr>
<tr><td><code id="plot.bassBasis_+3A_...">...</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two plots are trace plots for diagnosing convergence.  The third plot is posterior predicted vs observed, with intervals for predictions.  The fourth plot is a histogram of the residuals (of the posterior mean model).  If <code>pred = FALSE</code>, the third and fourth plots are omitted.
</p>


<h3>See Also</h3>

<p><a href="#topic+bassBasis">bassBasis</a>, <a href="#topic+bassPCA">bassPCA</a>, <a href="#topic+predict.bassBasis">predict.bassBasis</a>, <a href="#topic+sobolBasis">sobolBasis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in bassBasis documentation.

</code></pre>

<hr>
<h2 id='plot.bassSob'>Plot BASS sensitivity indices</h2><span id='topic+plot.bassSob'></span>

<h3>Description</h3>

<p>Generate plots for sensitivity analysis of BASS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bassSob'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bassSob_+3A_x">x</code></td>
<td>
<p>a <code>bassSob</code> object, returned from <code>sobol</code>.</p>
</td></tr>
<tr><td><code id="plot.bassSob_+3A_...">...</code></td>
<td>
<p>graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>func.var</code> in the call to <code>sobol</code> was <code>NULL</code>, this returns boxplots of sensitivity indices and total sensitivity indices.  If there were functional variables, they are labeled with letters alphabetically.  Thus, if I fit a model with 4 categorical/continuous inputs and 2 functional inputs, the functional inputs are labeled a and b.  If <code>func.var</code> was not <code>NULL</code>, then posterior mean functional sensitivity indices are plotted, along with the functional partitioned variance.  Variables and interactions that are excluded did not explain any variance.
</p>


<h3>See Also</h3>

<p><a href="#topic+bass">bass</a>, <a href="#topic+predict.bass">predict.bass</a>, <a href="#topic+sobol">sobol</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in bass documentation.

</code></pre>

<hr>
<h2 id='predict.bass'>BASS Prediction</h2><span id='topic+predict.bass'></span>

<h3>Description</h3>

<p>Predict function for BASS.  Outputs the posterior predictive samples based on the specified MCMC iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bass'
predict(
  object,
  newdata,
  newdata.func = NULL,
  mcmc.use = NULL,
  verbose = FALSE,
  nugget = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bass_+3A_object">object</code></td>
<td>
<p>a fitted model, output from the <code>bass</code> function.</p>
</td></tr>
<tr><td><code id="predict.bass_+3A_newdata">newdata</code></td>
<td>
<p>a matrix of new input values at which to predict.  The columns should correspond to the same variables used in the <code>bass</code> function.</p>
</td></tr>
<tr><td><code id="predict.bass_+3A_newdata.func">newdata.func</code></td>
<td>
<p>a matrix of new values of the functional variable.  If none, the same values will be used as in the training data.</p>
</td></tr>
<tr><td><code id="predict.bass_+3A_mcmc.use">mcmc.use</code></td>
<td>
<p>a vector indexing which MCMC iterations to use for prediction.</p>
</td></tr>
<tr><td><code id="predict.bass_+3A_verbose">verbose</code></td>
<td>
<p>logical; should progress be displayed?</p>
</td></tr>
<tr><td><code id="predict.bass_+3A_nugget">nugget</code></td>
<td>
<p>logical; should predictions include error? If FALSE, predictions will be for mean.</p>
</td></tr>
<tr><td><code id="predict.bass_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Efficiently predicts when two MCMC iterations have the same basis functions (but different weights).
</p>


<h3>Value</h3>

<p>If model output is a scalar, this returns a matrix with the same number of rows as <code>newdata</code> and columns corresponding to the the MCMC iterations <code>mcmc.use</code>.  These are samples from the posterior predictive distribution.  If model output is functional, this returns an array with first dimension corresponding to MCMC iteration, second dimension corresponding to the rows of <code>newdata</code>, and third dimension corresponding to the rows of <code>newdata.func</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+bass">bass</a> for model fitting and <a href="#topic+sobol">sobol</a> for sensitivity analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in bass documentation.

</code></pre>

<hr>
<h2 id='predict.bassBasis'>BASS Prediction</h2><span id='topic+predict.bassBasis'></span>

<h3>Description</h3>

<p>Predict function for BASS.  Outputs the posterior predictive samples based on the specified MCMC iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bassBasis'
predict(
  object,
  newdata,
  mcmc.use = NULL,
  trunc.error = FALSE,
  nugget = T,
  n.cores = 1,
  parType = "fork",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bassBasis_+3A_object">object</code></td>
<td>
<p>a fitted model, output from the <code>bass</code> function.</p>
</td></tr>
<tr><td><code id="predict.bassBasis_+3A_newdata">newdata</code></td>
<td>
<p>a matrix of new input values at which to predict.  The columns should correspond to the same variables used in the <code>bassBasis</code> or <code>bassPCA</code>  functions.</p>
</td></tr>
<tr><td><code id="predict.bassBasis_+3A_mcmc.use">mcmc.use</code></td>
<td>
<p>a vector indexing which MCMC iterations to use for prediction.</p>
</td></tr>
<tr><td><code id="predict.bassBasis_+3A_trunc.error">trunc.error</code></td>
<td>
<p>logical, use basis truncation error when predicting?</p>
</td></tr>
<tr><td><code id="predict.bassBasis_+3A_nugget">nugget</code></td>
<td>
<p>logical, use individual <code>bass</code> nugget variances when predicting?</p>
</td></tr>
<tr><td><code id="predict.bassBasis_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores, though 1 is often the fastest.</p>
</td></tr>
<tr><td><code id="predict.bassBasis_+3A_partype">parType</code></td>
<td>
<p>either &quot;fork&quot; or &quot;socket&quot;.  Forking is typically faster, but not compatible with Windows. If <code>n.cores==1</code>, <code>parType</code> is ignored.</p>
</td></tr>
<tr><td><code id="predict.bassBasis_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction combined across <code>bass</code> models.
</p>


<h3>Value</h3>

<p>An array with first dimension corresponding to MCMC iteration, second dimension corresponding to the rows of <code>newdata</code>, and third dimension corresponding to the multivariate/functional response.
</p>


<h3>See Also</h3>

<p><a href="#topic+bassPCA">bassPCA</a> and <a href="#topic+bassBasis">bassBasis</a> for model fitting and <a href="#topic+sobolBasis">sobolBasis</a> for sensitivity analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in bass documentation.

</code></pre>

<hr>
<h2 id='print.bass'>Print BASS Details</h2><span id='topic+print.bass'></span>

<h3>Description</h3>

<p>Print some of the details of a BASS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bass'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bass_+3A_x">x</code></td>
<td>
<p>a <code>bass</code> object, returned from <code>bass</code>.</p>
</td></tr>
<tr><td><code id="print.bass_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='print.bassBasis'>Print BASS Details</h2><span id='topic+print.bassBasis'></span>

<h3>Description</h3>

<p>Print some of the details of a BASS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bassBasis'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bassBasis_+3A_x">x</code></td>
<td>
<p>a <code>bassBasis</code> object, returned from <code>bassPCA</code> or <code>bassBasis</code>.</p>
</td></tr>
<tr><td><code id="print.bassBasis_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='sobol'>BASS Sensitivity Analysis</h2><span id='topic+sobol'></span>

<h3>Description</h3>

<p>Decomposes the variance of the BASS model into variance due to main effects, two way interactions, and so on, similar to the ANOVA decomposition for linear models.  Uses the Sobol' decomposition, which can be done analytically for MARS models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sobol(
  bassMod,
  prior = NULL,
  prior.func = NULL,
  mcmc.use = NULL,
  func.var = NULL,
  xx.func.var = NULL,
  verbose = TRUE,
  getEffects = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sobol_+3A_bassmod">bassMod</code></td>
<td>
<p>a fitted model output from the <code>bass</code> function.</p>
</td></tr>
<tr><td><code id="sobol_+3A_prior">prior</code></td>
<td>
<p>a list of priors; uniform, truncated mixture of Normals or Ts for continuous; vector of category weights for categorical.  Default is uniform over range of data.</p>
</td></tr>
<tr><td><code id="sobol_+3A_prior.func">prior.func</code></td>
<td>
<p>prior for functional variable.  In almost all cases, keep this as the uniform default.</p>
</td></tr>
<tr><td><code id="sobol_+3A_mcmc.use">mcmc.use</code></td>
<td>
<p>an integer vector indexing which MCMC iterations to use for sensitivity analysis.</p>
</td></tr>
<tr><td><code id="sobol_+3A_func.var">func.var</code></td>
<td>
<p>an integer indicating which functional variable to make sensitivity indices a function of.  Disregard if <code>bassMod</code> is non-functional or if scalar sensitivity indices are desired.</p>
</td></tr>
<tr><td><code id="sobol_+3A_xx.func.var">xx.func.var</code></td>
<td>
<p>grid for functional variable specified by <code>func.var</code>.  Disregard if <code>func.var</code> is not specified.  If <code>func.var</code> is specified and <code>xx.func.var</code> not specified, the grid used to fit <code>bass</code> will be used.</p>
</td></tr>
<tr><td><code id="sobol_+3A_verbose">verbose</code></td>
<td>
<p>logical; should progress be displayed?</p>
</td></tr>
<tr><td><code id="sobol_+3A_geteffects">getEffects</code></td>
<td>
<p>logical; should Sobols ANOVA decomposition be computed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs analytical Sobol' decomposition for each MCMC iteration in mcmc.use (each corresponds to a MARS model), yeilding a posterior distribution of sensitivity indices.  Can obtain Sobol' indices as a function of one functional variable.
</p>


<h3>Value</h3>

<p>If non-functional (<code>func.var = NULL</code>), a list with two elements:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>a data frame of sensitivity indices with number of rows matching the length of <code>mcmc.use</code>.  The columns are named with a particular main effect or interaction.  The values are the proportion of variance in the model that is due to each main effect or interaction.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>a data frame of total sensitivity indices with number of rows matching the length of <code>mcmc.use</code>.  The columns are named with a particular variable.</p>
</td></tr>
</table>
<p>Otherwise, a list with four elements:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>an array with first dimension corresponding to MCMC samples (same length as <code>mcmc.use</code>), second dimension corresponding to different main effects and interactions (labeled in <code>names.ind</code>), and third dimension corresponding to the grid used for the functional variable.  The elements of the array are sensitivity indices.</p>
</td></tr>
<tr><td><code>S.var</code></td>
<td>
<p>same as <code>S</code>, but scaled in terms of total variance rather than percent of variance.</p>
</td></tr>
<tr><td><code>names.ind</code></td>
<td>
<p>a vector of names of the main effects and interactions used.</p>
</td></tr>
<tr><td><code>xx</code></td>
<td>
<p>the grid used for the functional variable.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+bass">bass</a> for model fitting and <a href="#topic+predict.bass">predict.bass</a> for prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in bass documentation.

</code></pre>

<hr>
<h2 id='sobolBasis'>BASS Sensitivity Analysis</h2><span id='topic+sobolBasis'></span>

<h3>Description</h3>

<p>Decomposes the variance of the BASS model into variance due to main effects, two way interactions, and so on, similar to the ANOVA decomposition for linear models.  Uses the Sobol' decomposition, which can be done analytically for MARS models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sobolBasis(
  mod,
  int.order,
  prior = NULL,
  mcmc.use = NULL,
  nind = NULL,
  n.cores = 1,
  parType = "fork",
  plot = F,
  verbose = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sobolBasis_+3A_mod">mod</code></td>
<td>
<p>output from the <code>bassBasis</code> or <code>bassPCA</code> function.</p>
</td></tr>
<tr><td><code id="sobolBasis_+3A_int.order">int.order</code></td>
<td>
<p>an integer indicating the highest order of interactions to include in the Sobol decomposition.</p>
</td></tr>
<tr><td><code id="sobolBasis_+3A_prior">prior</code></td>
<td>
<p>a list with the same number of elements as there are inputs to mod.  Each element specifies the prior for the particular input.  Each prior is specified as a list with elements <code>dist</code> (one of <code>c("normal", "student", "uniform")</code>), <code>trunc</code> (a vector of dimension 2 indicating the lower and upper truncation bounds, taken to be the data bounds if omitted), and for &quot;normal&quot; or &quot;student&quot; priors, <code>mean</code> (scalar mean of the Normal/Student, or a vector of means for a mixture of Normals or Students), <code>sd</code> (scalar standard deviation of the Normal/Student, or a vector of standard deviations for a mixture of Normals or Students), <code>df</code> (scalar degrees of freedom of the Student, or a vector of degrees of freedom for a mixture of Students), and <code>weights</code> (a vector of weights that sum to one for the mixture components, or the scalar 1).  If unspecified, a uniform is assumed with the same bounds as are represented in the input to mod.</p>
</td></tr>
<tr><td><code id="sobolBasis_+3A_mcmc.use">mcmc.use</code></td>
<td>
<p>an integer indicating which MCMC iteration to use for sensitivity analysis. Defaults to the last iteration.</p>
</td></tr>
<tr><td><code id="sobolBasis_+3A_nind">nind</code></td>
<td>
<p>number of Sobol indices to keep (will keep the largest nind).</p>
</td></tr>
<tr><td><code id="sobolBasis_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use (nearly linear speedup for adding cores).</p>
</td></tr>
<tr><td><code id="sobolBasis_+3A_partype">parType</code></td>
<td>
<p>either &quot;fork&quot; or &quot;socket&quot;.  Forking is typically faster, but not compatible with Windows. If <code>n.cores==1</code>, <code>parType</code> is ignored.</p>
</td></tr>
<tr><td><code id="sobolBasis_+3A_plot">plot</code></td>
<td>
<p>logical; whether to plot results.</p>
</td></tr>
<tr><td><code id="sobolBasis_+3A_verbose">verbose</code></td>
<td>
<p>logical; print progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs analytical Sobol' decomposition for each MCMC iteration in mcmc.use (each corresponds to a MARS model), yeilding a posterior distribution of sensitivity indices.  Can obtain Sobol' indices as a function of one functional variable.
</p>


<h3>Value</h3>

<p>If non-functional (<code>func.var = NULL</code>), a list with two elements:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>a data frame of sensitivity indices with number of rows matching the length of <code>mcmc.use</code>.  The columns are named with a particular main effect or interaction.  The values are the proportion of variance in the model that is due to each main effect or interaction.</p>
</td></tr>
<tr><td><code>T</code></td>
<td>
<p>a data frame of total sensitivity indices with number of rows matching the length of <code>mcmc.use</code>.  The columns are named with a particular variable.</p>
</td></tr>
</table>
<p>Otherwise, a list with four elements:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>an array with first dimension corresponding to MCMC samples (same length as <code>mcmc.use</code>), second dimension corresponding to different main effects and interactions (labeled in <code>names.ind</code>), and third dimension corresponding to the grid used for the functional variable.  The elements of the array are sensitivity indices.</p>
</td></tr>
<tr><td><code>S.var</code></td>
<td>
<p>same as <code>S</code>, but scaled in terms of total variance rather than percent of variance.</p>
</td></tr>
<tr><td><code>names.ind</code></td>
<td>
<p>a vector of names of the main effects and interactions used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+bassPCA">bassPCA</a> and <a href="#topic+bassBasis">bassBasis</a> for model fitting and <a href="#topic+predict.bassBasis">predict.bassBasis</a> for prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples in bass documentation.
</code></pre>

<hr>
<h2 id='summary.bass'>Summarize BASS Details</h2><span id='topic+summary.bass'></span>

<h3>Description</h3>

<p>Summarize some of the details of a BASS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bass'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bass_+3A_object">object</code></td>
<td>
<p>a <code>bass</code> object, returned from <code>bass</code>.</p>
</td></tr>
<tr><td><code id="summary.bass_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.bassBasis'>Summarize BASS Details</h2><span id='topic+summary.bassBasis'></span>

<h3>Description</h3>

<p>Summarize some of the details of a BASS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bassBasis'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bassBasis_+3A_object">object</code></td>
<td>
<p>a <code>bassBasis</code> object, returned from <code>bassPCA</code> or <code>bassBasis</code>.</p>
</td></tr>
<tr><td><code id="summary.bassBasis_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
