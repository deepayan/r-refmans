<!DOCTYPE html><html><head><title>Help for package lgcp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lgcp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onAttach'><p>.onAttach function</p></a></li>
<li><a href='#add.list'><p>add.list function</p></a></li>
<li><a href='#addTemporalCovariates'><p>addTemporalCovariates function</p></a></li>
<li><a href='#affine.fromFunction'><p>affine.fromFunction function</p></a></li>
<li><a href='#affine.fromSPDF'><p>affine.fromSPDF function</p></a></li>
<li><a href='#affine.fromXYZ'><p>affine.fromXYZ function</p></a></li>
<li><a href='#affine.SpatialPolygonsDataFrame'><p>affine.SpatialPolygonsDataFrame function</p></a></li>
<li><a href='#affine.stppp'><p>affine.stppp function</p></a></li>
<li><a href='#aggCovInfo'><p>aggCovInfo function</p></a></li>
<li><a href='#aggCovInfo.ArealWeightedMean'><p>aggCovInfo.ArealWeightedMean function</p></a></li>
<li><a href='#aggCovInfo.ArealWeightedSum'><p>aggCovInfo.ArealWeightedSum function</p></a></li>
<li><a href='#aggCovInfo.Majority'><p>aggCovInfo.Majority function</p></a></li>
<li><a href='#aggregateCovariateInfo'><p>aggregateCovariateInfo function</p></a></li>
<li><a href='#aggregateformulaList'><p>aggregateformulaList function</p></a></li>
<li><a href='#andrieuthomsh'><p>andrieuthomsh function</p></a></li>
<li><a href='#as.array.lgcpgrid'><p>as.array.lgcpgrid function</p></a></li>
<li><a href='#as.fromXYZ'><p>as.fromXYZ function</p></a></li>
<li><a href='#as.fromXYZ.fromFunction'><p>as.fromXYZ.fromFunction function</p></a></li>
<li><a href='#as.im.fromFunction'><p>as.im.fromFunction function</p></a></li>
<li><a href='#as.im.fromSPDF'><p>as.im.fromSPDF function</p></a></li>
<li><a href='#as.im.fromXYZ'><p>as.im.fromXYZ function</p></a></li>
<li><a href='#as.list.lgcpgrid'><p>as.list.lgcpgrid function</p></a></li>
<li><a href='#as.owin.stapp'><p>as.owin.stapp function</p></a></li>
<li><a href='#as.owinlist'><p>as.owinlist function</p></a></li>
<li><a href='#as.owinlist.SpatialPolygonsDataFrame'><p>as.owinlist.SpatialPolygonsDataFrame function</p></a></li>
<li><a href='#as.owinlist.stapp'><p>as.owinlist.stapp function</p></a></li>
<li><a href='#as.ppp.mstppp'><p>as.ppp.mstppp function</p></a></li>
<li><a href='#as.ppp.stppp'><p>as.ppp.stppp function</p></a></li>
<li><a href='#as.SpatialGridDataFrame'><p>as.SpatialGridDataFrame function</p></a></li>
<li><a href='#as.SpatialGridDataFrame.fromXYZ'><p>as.SpatialGridDataFrame.fromXYZ function</p></a></li>
<li><a href='#as.SpatialPixelsDataFrame'><p>as.SpatialPixelsDataFrame function</p></a></li>
<li><a href='#as.SpatialPixelsDataFrame.lgcpgrid'><p>as.SpatialPixelsDataFrame.lgcpgrid function</p></a></li>
<li><a href='#as.stppp'><p>as.stppp function</p></a></li>
<li><a href='#as.stppp.stapp'><p>as.stppp.stapp function</p></a></li>
<li><a href='#assigninterp'><p>assigninterp function</p></a></li>
<li><a href='#at'><p>at function</p></a></li>
<li><a href='#autocorr'><p>autocorr function</p></a></li>
<li><a href='#autocorrMultitype'><p>autocorrMultitype function</p></a></li>
<li><a href='#BetaParameters'><p>BetaParameters function</p></a></li>
<li><a href='#betavals'><p>betavals function</p></a></li>
<li><a href='#blockcircbase'><p>blockcircbase function</p></a></li>
<li><a href='#blockcircbaseFunction'><p>blockcircbaseFunction function</p></a></li>
<li><a href='#bt.scalar'><p>bt.scalar function</p></a></li>
<li><a href='#checkObsWin'><p>checkObsWin function</p></a></li>
<li><a href='#chooseCellwidth'><p>chooseCellwidth function</p></a></li>
<li><a href='#circulant'><p>circulant function</p></a></li>
<li><a href='#circulant.matrix'><p>circulant.matrix function</p></a></li>
<li><a href='#circulant.numeric'><p>circulant.numeric function</p></a></li>
<li><a href='#clearinterp'><p>clearinterp function</p></a></li>
<li><a href='#computeGradtruncSpatial'><p>computeGradtruncSpatial function</p></a></li>
<li><a href='#computeGradtruncSpatioTemporal'><p>computeGradtruncSpatioTemporal function</p></a></li>
<li><a href='#condProbs'><p>condProbs function</p></a></li>
<li><a href='#constanth'><p>constanth function</p></a></li>
<li><a href='#constantInTime'><p>constantInTime function</p></a></li>
<li><a href='#constantInTime.numeric'><p>constantInTime.numeric function</p></a></li>
<li><a href='#constantInTime.stppp'><p>constantInTime.stppp function</p></a></li>
<li><a href='#cov.interp.fft'><p>cov.interp.fft function</p></a></li>
<li><a href='#CovarianceFct'><p>CovarianceFct function</p></a></li>
<li><a href='#covEffects'><p>covEffects function</p></a></li>
<li><a href='#CovFunction'><p>CovFunction function</p></a></li>
<li><a href='#CovFunction.function'><p>CovFunction.function function</p></a></li>
<li><a href='#CovParameters'><p>CovParameters function</p></a></li>
<li><a href='#Cvb'><p>Cvb function</p></a></li>
<li><a href='#d.func'><p>d.func function</p></a></li>
<li><a href='#density.stppp'><p>density.stppp function</p></a></li>
<li><a href='#discreteWindow'><p>discreteWindow function</p></a></li>
<li><a href='#discreteWindow.lgcpPredict'><p>discreteWindow.lgcpPredict function</p></a></li>
<li><a href='#dump2dir'><p>dump2dir function</p></a></li>
<li><a href='#eigenfrombase'><p>eigenfrombase function</p></a></li>
<li><a href='#etavals'><p>etavals function</p></a></li>
<li><a href='#EvaluatePrior'><p>EvaluatePrior function</p></a></li>
<li><a href='#exceedProbs'><p>exceedProbs function</p></a></li>
<li><a href='#exceedProbsAggregated'><p>exceedProbsAggregated function</p></a></li>
<li><a href='#expectation'><p>expectation function</p></a></li>
<li><a href='#expectation.lgcpPredict'><p>expectation.lgcpPredict function</p></a></li>
<li><a href='#expectation.lgcpPredictSpatialOnlyPlusParameters'><p>expectation.lgcpPredictSpatialOnlyPlusParameters function</p></a></li>
<li><a href='#exponentialCovFct'><p>exponentialCovFct function</p></a></li>
<li><a href='#extendspatialAtRisk'><p>extendspatialAtRisk function</p></a></li>
<li><a href='#extract'><p>extract function</p></a></li>
<li><a href='#extract.lgcpPredict'><p>extract.lgcpPredict function</p></a></li>
<li><a href='#Extract.mstppp'><p>Extract.mstppp function</p></a></li>
<li><a href='#Extract.stppp'><p>Extract.stppp function</p></a></li>
<li><a href='#fftgrid'><p>fftgrid function</p></a></li>
<li><a href='#fftinterpolate'><p>fftinterpolate function</p></a></li>
<li><a href='#fftinterpolate.fromFunction'><p>fftinterpolate.fromFunction function</p></a></li>
<li><a href='#fftinterpolate.fromSPDF'><p>fftinterpolate.fromSPDF function</p></a></li>
<li><a href='#fftinterpolate.fromXYZ'><p>interpolate.fromXYZ function</p></a></li>
<li><a href='#fftmultiply'><p>fftmultiply function</p></a></li>
<li><a href='#formulaList'><p>formulaList function</p></a></li>
<li><a href='#GAfinalise'><p>GAfinalise function</p></a></li>
<li><a href='#GAfinalise.MonteCarloAverage'><p>GAfinalise.MonteCarloAverage function</p></a></li>
<li><a href='#GAfinalise.nullAverage'><p>GAfinalise.nullAverage function</p></a></li>
<li><a href='#GAinitialise'><p>GAinitialise function</p></a></li>
<li><a href='#GAinitialise.MonteCarloAverage'><p>GAinitialise.MonteCarloAverage function</p></a></li>
<li><a href='#GAinitialise.nullAverage'><p>GAinitialise.nullAverage function</p></a></li>
<li><a href='#GammafromY'><p>GammafromY function</p></a></li>
<li><a href='#GAreturnvalue'><p>GAreturnvalue function</p></a></li>
<li><a href='#GAreturnvalue.MonteCarloAverage'><p>GAreturnvalue.MonteCarloAverage function</p></a></li>
<li><a href='#GAreturnvalue.nullAverage'><p>GAreturnvalue.nullAverage function##'</p></a></li>
<li><a href='#GAupdate'><p>GAupdate function</p></a></li>
<li><a href='#GAupdate.MonteCarloAverage'><p>GAupdate.MonteCarloAverage function</p></a></li>
<li><a href='#GAupdate.nullAverage'><p>GAupdate.nullAverage function</p></a></li>
<li><a href='#GaussianPrior'><p>GaussianPrior function</p></a></li>
<li><a href='#gDisjoint_wg'><p>gDisjoint_wg function</p></a></li>
<li><a href='#genFFTgrid'><p>genFFTgrid function</p></a></li>
<li><a href='#getCellCounts'><p>getCellCounts function</p></a></li>
<li><a href='#getCounts'><p>getCounts function</p></a></li>
<li><a href='#getCovParameters'><p>getCovParameters function</p></a></li>
<li><a href='#getCovParameters.GPrealisation'><p>getCovParameters.GPrealisation function</p></a></li>
<li><a href='#getCovParameters.list'><p>getCovParameters.list function</p></a></li>
<li><a href='#getinterp'><p>getinterp function</p></a></li>
<li><a href='#getlgcpPredictSpatialINLA'><p>getlgcpPredictSpatialINLA function</p></a></li>
<li><a href='#getLHSformulaList'><p>getLHSformulaList function</p></a></li>
<li><a href='#getpolyol'><p>getpolyol function</p></a></li>
<li><a href='#getRotation'><p>getRotation function</p></a></li>
<li><a href='#getRotation.default'><p>getRotation.default function</p></a></li>
<li><a href='#getRotation.stppp'><p>getRotation.stppp function</p></a></li>
<li><a href='#getup'><p>getup function</p></a></li>
<li><a href='#getZmat'><p>getZmat function</p></a></li>
<li><a href='#getZmats'><p>getZmats function</p></a></li>
<li><a href='#GFfinalise'><p>GFfinalise function</p></a></li>
<li><a href='#GFfinalise.dump2dir'><p>GFfinalise.dump2dir function</p></a></li>
<li><a href='#GFfinalise.nullFunction'><p>GFfinalise.nullFunction function</p></a></li>
<li><a href='#GFinitialise'><p>GFinitialise function</p></a></li>
<li><a href='#GFinitialise.dump2dir'><p>GFinitialise.dump2dir function</p></a></li>
<li><a href='#GFinitialise.nullFunction'><p>GFinitialise.nullFunction function</p></a></li>
<li><a href='#GFreturnvalue'><p>GFreturnvalue function</p></a></li>
<li><a href='#GFreturnvalue.dump2dir'><p>GFreturnvalue.dump2dir function</p></a></li>
<li><a href='#GFreturnvalue.nullFunction'><p>GFreturnvalue.nullFunction function</p></a></li>
<li><a href='#GFupdate'><p>GFupdate function</p></a></li>
<li><a href='#GFupdate.dump2dir'><p>GFupdate.dump2dir function</p></a></li>
<li><a href='#GFupdate.nullFunction'><p>GFupdate.nullFunction function</p></a></li>
<li><a href='#ginhomAverage'><p>ginhomAverage function</p></a></li>
<li><a href='#gIntersects_pg'><p>gIntersects_pg function</p></a></li>
<li><a href='#gOverlay'><p>gOverlay function</p></a></li>
<li><a href='#GPdrv'><p>GPdrv function</p></a></li>
<li><a href='#GPdrv2'><p>GPdrv2 function</p></a></li>
<li><a href='#GPdrv2_Multitype'><p>GPdrv2_Multitype function</p></a></li>
<li><a href='#GPlist2array'><p>GPlist2array function</p></a></li>
<li><a href='#GPrealisation'><p>GPrealisation function</p></a></li>
<li><a href='#grid2spdf'><p>grid2spdf function</p></a></li>
<li><a href='#grid2spix'><p>grid2spix function</p></a></li>
<li><a href='#grid2spoly'><p>grid2spoly function</p></a></li>
<li><a href='#grid2spts'><p>grid2spts function</p></a></li>
<li><a href='#gridav'><p>gridav function</p></a></li>
<li><a href='#gridav.lgcpPredict'><p>gridav.lgcpPredict function</p></a></li>
<li><a href='#gridfun'><p>gridfun function</p></a></li>
<li><a href='#gridfun.lgcpPredict'><p>gridfun.lgcpPredict function</p></a></li>
<li><a href='#gridInWindow'><p>gridInWindow function</p></a></li>
<li><a href='#gTouches_wg'><p>gTouches_wg function</p></a></li>
<li><a href='#gu'><p>gu function</p></a></li>
<li><a href='#guessinterp'><p>guessinterp function</p></a></li>
<li><a href='#hasNext'><p>generic hasNext method</p></a></li>
<li><a href='#hasNext.iter'><p>hasNext.iter function</p></a></li>
<li><a href='#hvals'><p>hvals function</p></a></li>
<li><a href='#hvals.lgcpPredict'><p>hvals.lgcpPredict function</p></a></li>
<li><a href='#identify.lgcpPredict'><p>identify.lgcpPredict function</p></a></li>
<li><a href='#identifygrid'><p>identifygrid function</p></a></li>
<li><a href='#image.lgcpgrid'><p>image.lgcpgrid function</p></a></li>
<li><a href='#initialiseAMCMC'><p>initialiseAMCMC function</p></a></li>
<li><a href='#initialiseAMCMC.andrieuthomsh'><p>initaliseAMCMC.andrieuthomsh function</p></a></li>
<li><a href='#initialiseAMCMC.constanth'><p>initaliseAMCMC.constanth function</p></a></li>
<li><a href='#integerise'><p>integerise function</p></a></li>
<li><a href='#integerise.mstppp'><p>integerise.mstppp function</p></a></li>
<li><a href='#integerise.stppp'><p>integerise.stppp function</p></a></li>
<li><a href='#intens'><p>intens function</p></a></li>
<li><a href='#intens.lgcpPredict'><p>intens.lgcpPredict function</p></a></li>
<li><a href='#intens.lgcpSimMultitypeSpatialPlusParameters'><p>intens.lgcpSimMultitypeSpatialPlusParameters function</p></a></li>
<li><a href='#intens.lgcpSimSpatialPlusParameters'><p>intens.lgcpSimSpatialPlusParameters function</p></a></li>
<li><a href='#interptypes'><p>interptypes function</p></a></li>
<li><a href='#inversebase'><p>inversebase function</p></a></li>
<li><a href='#is.burnin'><p>is this a burn-in iteration?</p></a></li>
<li><a href='#is.pow2'><p>is.pow2 function</p></a></li>
<li><a href='#is.retain'><p>do we retain this iteration?</p></a></li>
<li><a href='#is.SPD'><p>is.SPD function</p></a></li>
<li><a href='#iteration'><p>iteration number</p></a></li>
<li><a href='#KinhomAverage'><p>KinhomAverage function</p></a></li>
<li><a href='#lambdaEst'><p>lambdaEst function</p></a></li>
<li><a href='#lambdaEst.ppp'><p>lambdaEst.ppp function</p></a></li>
<li><a href='#lambdaEst.stppp'><p>lambdaEst.stppp function</p></a></li>
<li><a href='#lgcp-package'><p>lgcp</p></a></li>
<li><a href='#lgcpbayes'><p>lgcpbayes function</p></a></li>
<li><a href='#lgcpForecast'><p>lgcpForecast function</p></a></li>
<li><a href='#lgcpgrid'><p>lgcpgrid function</p></a></li>
<li><a href='#lgcpgrid.array'><p>lgcpgrid.array function</p></a></li>
<li><a href='#lgcpgrid.list'><p>lgcpgrid.list function</p></a></li>
<li><a href='#lgcpgrid.matrix'><p>lgcpgrid.matrix function</p></a></li>
<li><a href='#lgcpInits'><p>lgcpInits function</p></a></li>
<li><a href='#lgcppars'><p>lgcppars function</p></a></li>
<li><a href='#lgcpPredict'><p>lgcpPredict function</p></a></li>
<li><a href='#lgcpPredictAggregated'><p>lgcpPredictAggregated function</p></a></li>
<li><a href='#lgcpPredictAggregateSpatialPlusPars'><p>lgcpPredictAggregateSpatialPlusPars function</p></a></li>
<li><a href='#lgcpPredictMultitypeSpatialPlusPars'><p>lgcpPredictMultitypeSpatialPlusPars function</p></a></li>
<li><a href='#lgcpPredictSpatial'><p>lgcpPredictSpatial function</p></a></li>
<li><a href='#lgcpPredictSpatialINLA'><p>lgcpPredictSpatialINLA function</p></a></li>
<li><a href='#lgcpPredictSpatialPlusPars'><p>lgcpPredictSpatialPlusPars function</p></a></li>
<li><a href='#lgcpPredictSpatioTemporalPlusPars'><p>lgcpPredictSpatioTemporalPlusPars function</p></a></li>
<li><a href='#lgcpPrior'><p>lgcpPrior function</p></a></li>
<li><a href='#lgcpSim'><p>lgcpSim function</p></a></li>
<li><a href='#lgcpSimMultitypeSpatialCovariates'><p>lgcpSimMultitypeSpatialCovariates function</p></a></li>
<li><a href='#lgcpSimSpatial'><p>lgcpSimSpatial function</p></a></li>
<li><a href='#lgcpSimSpatialCovariates'><p>lgcpSimSpatialCovariates function</p></a></li>
<li><a href='#lgcpvignette'><p>lgcpvignette function</p></a></li>
<li><a href='#loc2poly'><p>loc2poly function</p></a></li>
<li><a href='#LogGaussianPrior'><p>LogGaussianPrior function</p></a></li>
<li><a href='#loop.mcmc'><p>loop over an iterator</p></a></li>
<li><a href='#ltar'><p>ltar function</p></a></li>
<li><a href='#MALAlgcp'><p>MALAlgcp function</p></a></li>
<li><a href='#MALAlgcpAggregateSpatial.PlusPars'><p>MALAlgcpAggregateSpatial.PlusPars function</p></a></li>
<li><a href='#MALAlgcpMultitypeSpatial.PlusPars'><p>MALAlgcpMultitypeSpatial.PlusPars function</p></a></li>
<li><a href='#MALAlgcpSpatial'><p>MALAlgcpSpatial function</p></a></li>
<li><a href='#MALAlgcpSpatial.PlusPars'><p>MALAlgcpSpatial.PlusPars function</p></a></li>
<li><a href='#MALAlgcpSpatioTemporal.PlusPars'><p>MALAlgcpSpatioTemporal.PlusPars function</p></a></li>
<li><a href='#matchcovariance'><p>matchcovariance function</p></a></li>
<li><a href='#maternCovFct15'><p>maternCovFct15 function</p></a></li>
<li><a href='#maternCovFct25'><p>maternCovFct25 function</p></a></li>
<li><a href='#mcmcLoop'><p>iterator for MCMC loops</p></a></li>
<li><a href='#mcmcpars'><p>mcmcpars function</p></a></li>
<li><a href='#mcmcProgressNone'><p>null progress monitor</p></a></li>
<li><a href='#mcmcProgressPrint'><p>printing progress monitor</p></a></li>
<li><a href='#mcmcProgressTextBar'><p>text bar progress monitor</p></a></li>
<li><a href='#mcmcProgressTk'><p>graphical progress monitor</p></a></li>
<li><a href='#mcmctrace'><p>mcmctrace function</p></a></li>
<li><a href='#mcmctrace.lgcpPredict'><p>mcmctrace.lgcpPredict function</p></a></li>
<li><a href='#meanfield'><p>meanfield function</p></a></li>
<li><a href='#meanfield.lgcpPredict'><p>meanfield.lgcpPredict function</p></a></li>
<li><a href='#meanfield.lgcpPredictINLA'><p>meanfield.lgcpPredictINLA function</p></a></li>
<li><a href='#MonteCarloAverage'><p>MonteCarloAverage function</p></a></li>
<li><a href='#mstppp'><p>mstppp function</p></a></li>
<li><a href='#mstppp.list'><p>mstppp.list function</p></a></li>
<li><a href='#mstppp.ppp'><p>mstppp.ppp function</p></a></li>
<li><a href='#mstppp.stppp'><p>mstppp.stppp function</p></a></li>
<li><a href='#muEst'><p>muEst function</p></a></li>
<li><a href='#multiply.list'><p>multiply.list function</p></a></li>
<li><a href='#neattable'><p>neattable function</p></a></li>
<li><a href='#neigh2D'><p>neigh2D function</p></a></li>
<li><a href='#nextStep'><p>next step of an MCMC chain</p></a></li>
<li><a href='#nullAverage'><p>nullAverage function</p></a></li>
<li><a href='#nullFunction'><p>nullFunction function</p></a></li>
<li><a href='#numCases'><p>numCases function</p></a></li>
<li><a href='#osppp2latlon'><p>osppp2latlon function</p></a></li>
<li><a href='#osppp2merc'><p>osppp2merc function</p></a></li>
<li><a href='#paramprec'><p>paramprec function</p></a></li>
<li><a href='#paramprecbase'><p>paramprecbase function</p></a></li>
<li><a href='#parautocorr'><p>parautocorr function</p></a></li>
<li><a href='#parsummary'><p>parsummary function</p></a></li>
<li><a href='#plot.fromSPDF'><p>plot.fromSPDF function</p></a></li>
<li><a href='#plot.fromXYZ'><p>plot.fromXYZ function</p></a></li>
<li><a href='#plot.lgcpAutocorr'><p>plot.lgcpAutocorr function</p></a></li>
<li><a href='#plot.lgcpgrid'><p>plot.lgcpgrid function</p></a></li>
<li><a href='#plot.lgcpPredict'><p>plot.lgcpPredict function</p></a></li>
<li><a href='#plot.lgcpQuantiles'><p>plot.lgcpQuantiles function</p></a></li>
<li><a href='#plot.lgcpZmat'><p>plot.lgcpZmat function</p></a></li>
<li><a href='#plot.mcmcdiag'><p>plot.mcmcdiag function</p></a></li>
<li><a href='#plot.mstppp'><p>plot.mstppp function</p></a></li>
<li><a href='#plot.stppp'><p>plot.stppp function</p></a></li>
<li><a href='#plot.temporalAtRisk'><p>plot.temporalAtRisk function</p></a></li>
<li><a href='#plotExceed'><p>plotExceed function</p></a></li>
<li><a href='#plotExceed.array'><p>plotExceed.array function</p></a></li>
<li><a href='#plotExceed.lgcpPredict'><p>plotExceed.lgcpPredict function</p></a></li>
<li><a href='#plotit'><p>plotit function</p></a></li>
<li><a href='#postcov'><p>postcov function</p></a></li>
<li><a href='#postcov.lgcpPredictAggregateSpatialPlusParameters'><p>postcov.lgcpPredictAggregateSpatialPlusParameters function</p></a></li>
<li><a href='#postcov.lgcpPredictMultitypeSpatialPlusParameters'><p>postcov.lgcpPredictMultitypeSpatialPlusParameters function</p></a></li>
<li><a href='#postcov.lgcpPredictSpatialOnlyPlusParameters'><p>postcov.lgcpPredictSpatialOnlyPlusParameters function</p></a></li>
<li><a href='#postcov.lgcpPredictSpatioTemporalPlusParameters'><p>postcov.lgcpPredictSpatioTemporalPlusParameters function</p></a></li>
<li><a href='#print.dump2dir'><p>print.dump2dir function</p></a></li>
<li><a href='#print.fromFunction'><p>print.fromFunction function</p></a></li>
<li><a href='#print.fromSPDF'><p>print.fromSPDF function</p></a></li>
<li><a href='#print.fromXYZ'><p>print.fromXYZ function</p></a></li>
<li><a href='#print.gridaverage'><p>print.gridaverage function</p></a></li>
<li><a href='#print.lgcpgrid'><p>print.lgcpgrid function</p></a></li>
<li><a href='#print.lgcpPredict'><p>print.lgcpPredict function</p></a></li>
<li><a href='#print.mcmc'><p>print.mcmc function</p></a></li>
<li><a href='#print.mstppp'><p>print.mstppp function</p></a></li>
<li><a href='#print.stapp'><p>print.stapp function</p></a></li>
<li><a href='#print.stppp'><p>print.stppp function</p></a></li>
<li><a href='#print.temporalAtRisk'><p>print.temporalAtRisk function</p></a></li>
<li><a href='#priorpost'><p>priorpost function</p></a></li>
<li><a href='#PriorSpec'><p>PriorSpec function</p></a></li>
<li><a href='#PriorSpec.list'><p>PriorSpec.list function</p></a></li>
<li><a href='#quantile.lgcpgrid'><p>quantile.lgcpgrid function</p></a></li>
<li><a href='#quantile.lgcpPredict'><p>quantile.lgcpPredict function</p></a></li>
<li><a href='#RandomFieldsCovFct'><p>RandomFieldsCovFct function</p></a></li>
<li><a href='#raster.lgcpgrid'><p>raster.lgcpgrid function</p></a></li>
<li><a href='#rescale.mstppp'><p>rescale.mstppp function</p></a></li>
<li><a href='#rescale.stppp'><p>rescale.stppp function</p></a></li>
<li><a href='#resetLoop'><p>reset iterator</p></a></li>
<li><a href='#rgauss'><p>rgauss function</p></a></li>
<li><a href='#roteffgain'><p>roteffgain function</p></a></li>
<li><a href='#rotmat'><p>rotmat function</p></a></li>
<li><a href='#rr'><p>rr function</p></a></li>
<li><a href='#rr.lgcpPredict'><p>rr.lgcpPredict function</p></a></li>
<li><a href='#samplePosterior'><p>samplePosterior function</p></a></li>
<li><a href='#segProbs'><p>segProbs function</p></a></li>
<li><a href='#seintens'><p>seintens function</p></a></li>
<li><a href='#seintens.lgcpPredict'><p>seintens.lgcpPredict function</p></a></li>
<li><a href='#selectObsWindow'><p>selectObsWindow function</p></a></li>
<li><a href='#selectObsWindow.default'><p>selectObsWindow.default function</p></a></li>
<li><a href='#selectObsWindow.stppp'><p>selectObsWindow.stppp function</p></a></li>
<li><a href='#serr'><p>serr function</p></a></li>
<li><a href='#serr.lgcpPredict'><p>serr.lgcpPredict function</p></a></li>
<li><a href='#setoutput'><p>setoutput function</p></a></li>
<li><a href='#setTxtProgressBar2'><p>set the progress bar</p></a></li>
<li><a href='#showGrid'><p>showGrid function</p></a></li>
<li><a href='#showGrid.default'><p>showGrid.default function</p></a></li>
<li><a href='#showGrid.lgcpPredict'><p>showGrid.lgcpPredict function</p></a></li>
<li><a href='#showGrid.stppp'><p>showGrid.stppp function</p></a></li>
<li><a href='#smultiply.list'><p>smultiply.list function</p></a></li>
<li><a href='#sparsebase'><p>sparsebase function</p></a></li>
<li><a href='#spatialAtRisk'><p>spatialAtRisk function</p></a></li>
<li><a href='#spatialAtRisk.bivden'><p>spatialAtRisk.bivden function</p></a></li>
<li><a href='#spatialAtRisk.default'><p>spatialAtRisk.default function</p></a></li>
<li><a href='#spatialAtRisk.fromXYZ'><p>spatialAtRisk.fromXYZ function</p></a></li>
<li><a href='#spatialAtRisk.function'><p>spatialAtRisk.function function</p></a></li>
<li><a href='#spatialAtRisk.im'><p>spatialAtRisk.im function</p></a></li>
<li><a href='#spatialAtRisk.lgcpgrid'><p>spatialAtRisk.lgcpgrid function</p></a></li>
<li><a href='#spatialAtRisk.SpatialGridDataFrame'><p>spatialAtRisk.SpatialGridDataFrame function</p></a></li>
<li><a href='#spatialAtRisk.SpatialPolygonsDataFrame'><p>spatialAtRisk.SpatialPolygonsDataFrame function</p></a></li>
<li><a href='#spatialIntensities'><p>spatialIntensities function</p></a></li>
<li><a href='#spatialIntensities.fromSPDF'><p>spatialIntensities.fromSPDF function</p></a></li>
<li><a href='#spatialIntensities.fromXYZ'><p>spatialIntensities.fromXYZ function</p></a></li>
<li><a href='#spatialparsEst'><p>spatialparsEst function</p></a></li>
<li><a href='#SpatialPolygonsDataFrame.stapp'><p>SpatialPolygonsDataFrame.stapp function</p></a></li>
<li><a href='#SpikedExponentialCovFct'><p>SpikedExponentialCovFct function</p></a></li>
<li><a href='#stapp'><p>stapp function</p></a></li>
<li><a href='#stapp.list'><p>stapp.list function</p></a></li>
<li><a href='#stapp.SpatialPolygonsDataFrame'><p>stapp.SpatialPolygonsDataFrame function</p></a></li>
<li><a href='#stGPrealisation'><p>stGPrealisation function</p></a></li>
<li><a href='#stppp'><p>stppp function</p></a></li>
<li><a href='#stppp.list'><p>stppp.list function</p></a></li>
<li><a href='#stppp.ppp'><p>stppp.ppp function</p></a></li>
<li><a href='#summary.lgcpgrid'><p>summary.lgcpgrid function</p></a></li>
<li><a href='#summary.mcmc'><p>summary.mcmc function</p></a></li>
<li><a href='#target.and.grad.AggregateSpatialPlusPars'><p>target.and.grad.AggregateSpatialPlusPars function</p></a></li>
<li><a href='#target.and.grad.MultitypespatialPlusPars'><p>target.and.grad.MultitypespatialPlusPars function</p></a></li>
<li><a href='#target.and.grad.spatial'><p>target.and.grad.spatial function</p></a></li>
<li><a href='#target.and.grad.spatialPlusPars'><p>target.and.grad.spatialPlusPars function</p></a></li>
<li><a href='#target.and.grad.spatiotemporal'><p>target.and.grad.spatiotemporal function</p></a></li>
<li><a href='#target.and.grad.SpatioTemporalPlusPars'><p>target.and.grad.SpatioTemporalPlusPars function</p></a></li>
<li><a href='#temporalAtRisk'><p>temporalAtRisk function</p></a></li>
<li><a href='#temporalAtRisk.function'><p>temporalAtRisk.function function</p></a></li>
<li><a href='#temporalAtRisk.numeric'><p>temporalAtRisk.numeric function</p></a></li>
<li><a href='#tempRaster'><p>tempRaster function</p></a></li>
<li><a href='#textsummary'><p>textsummary function</p></a></li>
<li><a href='#thetaEst'><p>thetaEst function</p></a></li>
<li><a href='#toral.cov.mat'><p>toral.cov.mat function</p></a></li>
<li><a href='#touchingowin'><p>touchingowin function</p></a></li>
<li><a href='#traceplots'><p>traceplots function</p></a></li>
<li><a href='#transblack'><p>transblack function</p></a></li>
<li><a href='#transblue'><p>transblue function</p></a></li>
<li><a href='#transgreen'><p>transgreen function</p></a></li>
<li><a href='#transred'><p>transred function</p></a></li>
<li><a href='#txtProgressBar2'><p>A text progress bar with label</p></a></li>
<li><a href='#updateAMCMC'><p>updateAMCMC function</p></a></li>
<li><a href='#updateAMCMC.andrieuthomsh'><p>updateAMCMC.andrieuthomsh function</p></a></li>
<li><a href='#updateAMCMC.constanth'><p>updateAMCMC.constanth function</p></a></li>
<li><a href='#varfield'><p>varfield function</p></a></li>
<li><a href='#varfield.lgcpPredict'><p>varfield.lgcpPredict function</p></a></li>
<li><a href='#varfield.lgcpPredictINLA'><p>varfield.lgcpPredictINLA function</p></a></li>
<li><a href='#window.lgcpPredict'><p>window.lgcpPredict function</p></a></li>
<li><a href='#wpopdata'><p>Population of Welsh counties</p></a></li>
<li><a href='#wtowncoords'><p>Welsh town details: location</p></a></li>
<li><a href='#wtowns'><p>Welsh town details: population</p></a></li>
<li><a href='#xvals'><p>xvals function</p></a></li>
<li><a href='#xvals.default'><p>xvals.default function</p></a></li>
<li><a href='#xvals.fromXYZ'><p>xvals.fromXYZ function</p></a></li>
<li><a href='#xvals.lgcpPredict'><p>xvals.lgcpPredict function</p></a></li>
<li><a href='#xvals.SpatialGridDataFrame'><p>xvals.SpatialGridDataFrame function</p></a></li>
<li><a href='#YfromGamma'><p>YfromGamma function</p></a></li>
<li><a href='#yvals'><p>yvals function</p></a></li>
<li><a href='#yvals.default'><p>yvals.default function</p></a></li>
<li><a href='#yvals.fromXYZ'><p>yvals.fromXYZ function</p></a></li>
<li><a href='#yvals.lgcpPredict'><p>yvals.lgcpPredict function</p></a></li>
<li><a href='#yvals.SpatialGridDataFrame'><p>yvals.SpatialGridDataFrame function</p></a></li>
<li><a href='#zvals'><p>zvals function</p></a></li>
<li><a href='#zvals.default'><p>zvals.default function</p></a></li>
<li><a href='#zvals.fromXYZ'><p>zvals.fromXYZ function</p></a></li>
<li><a href='#zvals.SpatialGridDataFrame'><p>zvals.SpatialGridDataFrame function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Maintainer:</td>
<td>Benjamin M. Taylor &lt;benjamin.taylor.software@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Log-Gaussian Cox Process</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J.
    Diggle. Additional code contributions from Edzer Pebesma, Dominic Schumacher.</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatial and spatio-temporal modelling of point patterns using the
    log-Gaussian Cox process. Bayesian inference for spatial, spatiotemporal,
    multivariate and aggregated point processes using Markov chain Monte Carlo. See Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v063.i07">doi:10.18637/jss.v063.i07</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-02</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.geom, spatstat.explore, spatstat.utils, sp, sf,
raster, tcltk, iterators, ncdf4, methods, rpanel (&ge; 1.1-3),
fields, Matrix</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-03 10:22:36 UTC; ben</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-03 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onAttach'>.onAttach function</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>A function to print a welcome message on loading package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>libname argument</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>pkgname argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='add.list'>add.list function</h2><span id='topic+add.list'></span>

<h3>Description</h3>

<p>This function adds the elements of two list objects together and returns the result in another list object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.list(list1, list2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.list_+3A_list1">list1</code></td>
<td>
<p>a list of objects that could be summed using &quot;+&quot;</p>
</td></tr>
<tr><td><code id="add.list_+3A_list2">list2</code></td>
<td>
<p>a list of objects that could be summed using &quot;+&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with ith entry the sum of list1[[i]] and list2[[i]]
</p>

<hr>
<h2 id='addTemporalCovariates'>addTemporalCovariates function</h2><span id='topic+addTemporalCovariates'></span>

<h3>Description</h3>

<p>A function to 'bolt on' temporal data onto a spatial covariate design matrix. The function takes a spatial design matrix, Z(s) and
converts it to a spatiotemporal design matrix Z(s,t) when the effects can be separably decomposed i.e.,<br />
Z(s,t)beta = Z_1(s)beta_1 + Z_2(t)beta_2<br />
<br />
An example of this function in action is given in the vignette &quot;Bayesian_lgcp&quot;, in the section on spatiotemporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addTemporalCovariates(temporal.formula, T, laglength, tdata, Zmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addTemporalCovariates_+3A_temporal.formula">temporal.formula</code></td>
<td>
<p>a formula of the form t ~ tvar1 + tvar2 etc. Where the left hand side is a &quot;t&quot;. Note there should
not be an intercept term in both of the the spatial and temporal components.</p>
</td></tr>
<tr><td><code id="addTemporalCovariates_+3A_t">T</code></td>
<td>
<p>the time point of interest</p>
</td></tr>
<tr><td><code id="addTemporalCovariates_+3A_laglength">laglength</code></td>
<td>
<p>the number of previous time points to include in the analysis</p>
</td></tr>
<tr><td><code id="addTemporalCovariates_+3A_tdata">tdata</code></td>
<td>
<p>a data frame with variable t minimally including times (T-laglength):T and var1, var2 etc.</p>
</td></tr>
<tr><td><code id="addTemporalCovariates_+3A_zmat">Zmat</code></td>
<td>
<p>the spatial covariates Z(s), obtained by using the getZmat function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main idea of this function is: having created a spatial Z(s) using getZmat, to create a dummy dataset tdata and temporal
formula corresponding to the temporal component of the separable effects. The entries in the model matrix Z(s,t) corresponsing to
the time covariates are constant over the observation window in space, but in general vary from time-point to time-point.
</p>
<p>Note that if there is an intercept in the spatial part of the model e.g., X ~ var1 + var2, then in the temporal model,
the intercept should be removed i.e., t ~ tvar1 + tvar2 - 1
</p>


<h3>Value</h3>

<p>A list of design matrices, one for each time, Z(s,t) for t in (T-laglength):T
</p>


<h3>See Also</h3>

<p><a href="#topic+chooseCellwidth">chooseCellwidth</a>, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>
</p>

<hr>
<h2 id='affine.fromFunction'>affine.fromFunction function</h2><span id='topic+affine.fromFunction'></span>

<h3>Description</h3>

<p>An affine transformation of an object of class <code>fromFunction</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromFunction'
affine(X, mat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.fromFunction_+3A_x">X</code></td>
<td>
<p>an object of class fromFunction</p>
</td></tr>
<tr><td><code id="affine.fromFunction_+3A_mat">mat</code></td>
<td>
<p>matrix of affine transformation</p>
</td></tr>
<tr><td><code id="affine.fromFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object acted on by the transformation matrix
</p>

<hr>
<h2 id='affine.fromSPDF'>affine.fromSPDF function</h2><span id='topic+affine.fromSPDF'></span>

<h3>Description</h3>

<p>An affine transformation of an object of class <code>fromSPDF</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromSPDF'
affine(X, mat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.fromSPDF_+3A_x">X</code></td>
<td>
<p>an object of class fromSPDF</p>
</td></tr>
<tr><td><code id="affine.fromSPDF_+3A_mat">mat</code></td>
<td>
<p>matrix of affine transformation</p>
</td></tr>
<tr><td><code id="affine.fromSPDF_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object acted on by the transformation matrix
</p>

<hr>
<h2 id='affine.fromXYZ'>affine.fromXYZ function</h2><span id='topic+affine.fromXYZ'></span>

<h3>Description</h3>

<p>An affine transformation of an object of class <code>fromXYZ</code>. Nearest Neighbour interpolation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
affine(X, mat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.fromXYZ_+3A_x">X</code></td>
<td>
<p>an object of class fromFunction</p>
</td></tr>
<tr><td><code id="affine.fromXYZ_+3A_mat">mat</code></td>
<td>
<p>matrix of affine transformation</p>
</td></tr>
<tr><td><code id="affine.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object acted on by the transformation matrix
</p>

<hr>
<h2 id='affine.SpatialPolygonsDataFrame'>affine.SpatialPolygonsDataFrame function</h2><span id='topic+affine.SpatialPolygonsDataFrame'></span>

<h3>Description</h3>

<p>An affine transformation of an object of class <code>SpatialPolygonsDataFrame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPolygonsDataFrame'
affine(X, mat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.SpatialPolygonsDataFrame_+3A_x">X</code></td>
<td>
<p>an object of class fromFunction</p>
</td></tr>
<tr><td><code id="affine.SpatialPolygonsDataFrame_+3A_mat">mat</code></td>
<td>
<p>matrix of affine transformation</p>
</td></tr>
<tr><td><code id="affine.SpatialPolygonsDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object acted on by the transformation matrix
</p>

<hr>
<h2 id='affine.stppp'>affine.stppp function</h2><span id='topic+affine.stppp'></span>

<h3>Description</h3>

<p>An affine transformation of an object of class <code>stppp</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
affine(X, mat, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affine.stppp_+3A_x">X</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="affine.stppp_+3A_mat">mat</code></td>
<td>
<p>matrix of affine transformation</p>
</td></tr>
<tr><td><code id="affine.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object acted on by the transformation matrix
</p>

<hr>
<h2 id='aggCovInfo'>aggCovInfo function</h2><span id='topic+aggCovInfo'></span>

<h3>Description</h3>

<p>Generic function for aggregation of covariate information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggCovInfo(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggCovInfo_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="aggCovInfo_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method aggCovInfo
</p>

<hr>
<h2 id='aggCovInfo.ArealWeightedMean'>aggCovInfo.ArealWeightedMean function</h2><span id='topic+aggCovInfo.ArealWeightedMean'></span>

<h3>Description</h3>

<p>Aggregation via weighted mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ArealWeightedMean'
aggCovInfo(obj, regwts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggCovInfo.ArealWeightedMean_+3A_obj">obj</code></td>
<td>
<p>an ArealWeightedMean object</p>
</td></tr>
<tr><td><code id="aggCovInfo.ArealWeightedMean_+3A_regwts">regwts</code></td>
<td>
<p>regional (areal) weighting vector</p>
</td></tr>
<tr><td><code id="aggCovInfo.ArealWeightedMean_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Areal weighted mean.
</p>

<hr>
<h2 id='aggCovInfo.ArealWeightedSum'>aggCovInfo.ArealWeightedSum function</h2><span id='topic+aggCovInfo.ArealWeightedSum'></span>

<h3>Description</h3>

<p>Aggregation via weighted sum. Use to sum up population counts in regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ArealWeightedSum'
aggCovInfo(obj, regwts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggCovInfo.ArealWeightedSum_+3A_obj">obj</code></td>
<td>
<p>an ArealWeightedSum object</p>
</td></tr>
<tr><td><code id="aggCovInfo.ArealWeightedSum_+3A_regwts">regwts</code></td>
<td>
<p>regional (areal) weighting vector</p>
</td></tr>
<tr><td><code id="aggCovInfo.ArealWeightedSum_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Areal weighted Sum.
</p>

<hr>
<h2 id='aggCovInfo.Majority'>aggCovInfo.Majority function</h2><span id='topic+aggCovInfo.Majority'></span>

<h3>Description</h3>

<p>Aggregation via majority.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Majority'
aggCovInfo(obj, regwts, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggCovInfo.Majority_+3A_obj">obj</code></td>
<td>
<p>an Majority object</p>
</td></tr>
<tr><td><code id="aggCovInfo.Majority_+3A_regwts">regwts</code></td>
<td>
<p>regional (areal) weighting vector</p>
</td></tr>
<tr><td><code id="aggCovInfo.Majority_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The most popular cell type.
</p>

<hr>
<h2 id='aggregateCovariateInfo'>aggregateCovariateInfo function</h2><span id='topic+aggregateCovariateInfo'></span>

<h3>Description</h3>

<p>A function called by cov.interp.fft to allocate and perform interpolation of covariate infomation onto the FFT grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateCovariateInfo(cellidx, cidx, gidx, df, fftovl, classes, polyareas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateCovariateInfo_+3A_cellidx">cellidx</code></td>
<td>
<p>the index of the cell</p>
</td></tr>
<tr><td><code id="aggregateCovariateInfo_+3A_cidx">cidx</code></td>
<td>
<p>index of covariate, no longer used</p>
</td></tr>
<tr><td><code id="aggregateCovariateInfo_+3A_gidx">gidx</code></td>
<td>
<p>grid index</p>
</td></tr>
<tr><td><code id="aggregateCovariateInfo_+3A_df">df</code></td>
<td>
<p>the data frame containing the covariate information</p>
</td></tr>
<tr><td><code id="aggregateCovariateInfo_+3A_fftovl">fftovl</code></td>
<td>
<p>an overlay of the fft grid onto the SpatialPolygonsDataFrame or SpatialPixelsDataFrame objects</p>
</td></tr>
<tr><td><code id="aggregateCovariateInfo_+3A_classes">classes</code></td>
<td>
<p>vector of class attributes of the dataframe</p>
</td></tr>
<tr><td><code id="aggregateCovariateInfo_+3A_polyareas">polyareas</code></td>
<td>
<p>polygon areas of the SpatialPolygonsDataFrame or SpatialPixelsDataFrame objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the interpolated covariate information onto the FFT grid
</p>

<hr>
<h2 id='aggregateformulaList'>aggregateformulaList function</h2><span id='topic+aggregateformulaList'></span>

<h3>Description</h3>

<p>An internal function to collect terms from a formulalist. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateformulaList(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateformulaList_+3A_x">x</code></td>
<td>
<p>an object of class &quot;formulaList&quot;</p>
</td></tr>
<tr><td><code id="aggregateformulaList_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a formula of the form X ~ var1 + var2 tec.
</p>

<hr>
<h2 id='andrieuthomsh'>andrieuthomsh function</h2><span id='topic+andrieuthomsh'></span>

<h3>Description</h3>

<p>A Robbins-Munro stochastic approximation update is used to adapt the tuning parameter of the proposal kernel. 
The idea is to update the tuning parameter at each iteration of the sampler:
</p>
<p style="text-align: center;"><code class="reqn">h^{(i+1)} = h^{(i)} + \eta^{(i+1)}(\alpha^{(i)} - \alpha_{opt}),</code>
</p>

<p>where <code class="reqn">h^{(i)}</code> and <code class="reqn">\alpha^{(i)}</code> are the tuning parameter and acceptance probability at iteration 
<code class="reqn">i</code> and <code class="reqn">\alpha_{opt}</code> is a target acceptance probability. For Gaussian targets, and in the limit 
as the dimension of the problem tends to infinity, an appropriate target acceptance probability for 
MALA algorithms is 0.574. The sequence <code class="reqn">\{\eta^{(i)}\}</code> is chosen so that 
<code class="reqn">\sum_{i=0}^\infty\eta^{(i)}</code> is infinite whilst <code class="reqn">\sum_{i=0}^\infty\left(\eta^{(i)}\right)^{1+\epsilon}</code> is 
finite for <code class="reqn">\epsilon&gt;0</code>. These two conditions ensure that any value of <code class="reqn">h</code> can be reached, but in a way that 
maintains the ergodic behaviour of the chain. One class of sequences with this property is,
</p>
<p style="text-align: center;"><code class="reqn">\eta^{(i)} = \frac{C}{i^\alpha},</code>
</p>

<p>where <code class="reqn">\alpha\in(0,1]</code> and <code class="reqn">C&gt;0</code>.The scheme is set via
the <code>mcmcpars</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>andrieuthomsh(inith, alpha, C, targetacceptance = 0.574)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="andrieuthomsh_+3A_inith">inith</code></td>
<td>
<p>initial h</p>
</td></tr>
<tr><td><code id="andrieuthomsh_+3A_alpha">alpha</code></td>
<td>
<p>parameter <code class="reqn">\alpha</code></p>
</td></tr>
<tr><td><code id="andrieuthomsh_+3A_c">C</code></td>
<td>
<p>parameter <code class="reqn">C</code></p>
</td></tr>
<tr><td><code id="andrieuthomsh_+3A_targetacceptance">targetacceptance</code></td>
<td>
<p>target acceptance probability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class andrieuthomsh
</p>


<h3>References</h3>


<ol>
<li><p> Andrieu C, Thoms J (2008). A tutorial on adaptive MCMC. Statistics and Computing, 18(4), 343-373.
</p>
</li>
<li><p> Robbins H, Munro S (1951). A Stochastic Approximation Methods. The Annals of Mathematical Statistics, 22(3), 400-407.
</p>
</li>
<li><p> Roberts G, Rosenthal J (2001). Optimal Scaling for Various Metropolis-Hastings Algorithms. Statistical Science, 16(4), 351-367.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+mcmcpars">mcmcpars</a>, <a href="#topic+lgcpPredict">lgcpPredict</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>andrieuthomsh(inith=1,alpha=0.5,C=1,targetacceptance=0.574)
</code></pre>

<hr>
<h2 id='as.array.lgcpgrid'>as.array.lgcpgrid function</h2><span id='topic+as.array.lgcpgrid'></span>

<h3>Description</h3>

<p>Method to convert an lgcpgrid object into an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
as.array(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.array.lgcpgrid_+3A_x">x</code></td>
<td>
<p>an object of class lgcpgrid</p>
</td></tr>
<tr><td><code id="as.array.lgcpgrid_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>conversion from lgcpgrid to array
</p>

<hr>
<h2 id='as.fromXYZ'>as.fromXYZ function</h2><span id='topic+as.fromXYZ'></span>

<h3>Description</h3>

<p>Generic function for conversion to a fromXYZ object (eg as would have been produced by spatialAtRisk for example.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.fromXYZ(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.fromXYZ_+3A_x">X</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="as.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generic function returning method as.fromXYZ
</p>


<h3>See Also</h3>

<p><a href="#topic+as.im.fromXYZ">as.im.fromXYZ</a>, <a href="#topic+as.im.fromSPDF">as.im.fromSPDF</a>, <a href="#topic+as.im.fromFunction">as.im.fromFunction</a>, <a href="#topic+as.fromXYZ">as.fromXYZ</a>
</p>

<hr>
<h2 id='as.fromXYZ.fromFunction'>as.fromXYZ.fromFunction function</h2><span id='topic+as.fromXYZ.fromFunction'></span>

<h3>Description</h3>

<p>Method for converting from the fromFunction class of objects to the fromXYZ class of objects. Clearly this requires the
user to specify a grid onto which to compute the discretised verion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromFunction'
as.fromXYZ(X, xyt, M = 100, N = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.fromXYZ.fromFunction_+3A_x">X</code></td>
<td>
<p>an object of class fromFunction</p>
</td></tr>
<tr><td><code id="as.fromXYZ.fromFunction_+3A_xyt">xyt</code></td>
<td>
<p>and objects of class stppp</p>
</td></tr>
<tr><td><code id="as.fromXYZ.fromFunction_+3A_m">M</code></td>
<td>
<p>number of cells in x direction</p>
</td></tr>
<tr><td><code id="as.fromXYZ.fromFunction_+3A_n">N</code></td>
<td>
<p>number of cells in y direction</p>
</td></tr>
<tr><td><code id="as.fromXYZ.fromFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class im containing normalised intensities
</p>


<h3>See Also</h3>

<p><a href="#topic+as.im.fromXYZ">as.im.fromXYZ</a>, <a href="#topic+as.im.fromSPDF">as.im.fromSPDF</a>, <a href="#topic+as.im.fromFunction">as.im.fromFunction</a>, <a href="#topic+as.fromXYZ">as.fromXYZ</a>
</p>

<hr>
<h2 id='as.im.fromFunction'>as.im.fromFunction function</h2><span id='topic+as.im.fromFunction'></span>

<h3>Description</h3>

<p>Convert an object of class fromFunction(created by spatialAtRisk for example) into a spatstat im object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromFunction'
as.im(X, xyt, M = 100, N = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.im.fromFunction_+3A_x">X</code></td>
<td>
<p>an object of class fromSPDF</p>
</td></tr>
<tr><td><code id="as.im.fromFunction_+3A_xyt">xyt</code></td>
<td>
<p>and objects of class stppp</p>
</td></tr>
<tr><td><code id="as.im.fromFunction_+3A_m">M</code></td>
<td>
<p>number of cells in x direction</p>
</td></tr>
<tr><td><code id="as.im.fromFunction_+3A_n">N</code></td>
<td>
<p>number of cells in y direction</p>
</td></tr>
<tr><td><code id="as.im.fromFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class im containing normalised intensities
</p>


<h3>See Also</h3>

<p><a href="#topic+as.im.fromXYZ">as.im.fromXYZ</a>, <a href="#topic+as.im.fromSPDF">as.im.fromSPDF</a>, <a href="#topic+as.im.fromFunction">as.im.fromFunction</a>, <a href="#topic+as.fromXYZ">as.fromXYZ</a>
</p>

<hr>
<h2 id='as.im.fromSPDF'>as.im.fromSPDF function</h2><span id='topic+as.im.fromSPDF'></span>

<h3>Description</h3>

<p>Convert an object of class fromSPDF (created by spatialAtRisk for example) into a spatstat im object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromSPDF'
as.im(X, ncells = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.im.fromSPDF_+3A_x">X</code></td>
<td>
<p>an object of class fromSPDF</p>
</td></tr>
<tr><td><code id="as.im.fromSPDF_+3A_ncells">ncells</code></td>
<td>
<p>number of cells to divide range into; default 100</p>
</td></tr>
<tr><td><code id="as.im.fromSPDF_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class im containing normalised intensities
</p>


<h3>See Also</h3>

<p><a href="#topic+as.im.fromXYZ">as.im.fromXYZ</a>, <a href="#topic+as.im.fromSPDF">as.im.fromSPDF</a>, <a href="#topic+as.im.fromFunction">as.im.fromFunction</a>, <a href="#topic+as.fromXYZ">as.fromXYZ</a>
</p>

<hr>
<h2 id='as.im.fromXYZ'>as.im.fromXYZ function</h2><span id='topic+as.im.fromXYZ'></span>

<h3>Description</h3>

<p>Convert an object of class fromXYZ (created by spatialAtRisk for example) into a spatstat im object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
as.im(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.im.fromXYZ_+3A_x">X</code></td>
<td>
<p>object of class fromXYZ</p>
</td></tr>
<tr><td><code id="as.im.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class im containing normalised intensities
</p>


<h3>See Also</h3>

<p><a href="#topic+as.im.fromSPDF">as.im.fromSPDF</a>, <a href="#topic+as.im.fromFunction">as.im.fromFunction</a>, <a href="#topic+as.fromXYZ">as.fromXYZ</a>
</p>

<hr>
<h2 id='as.list.lgcpgrid'>as.list.lgcpgrid function</h2><span id='topic+as.list.lgcpgrid'></span>

<h3>Description</h3>

<p>Method to convert an lgcpgrid object into a list of matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list.lgcpgrid_+3A_x">x</code></td>
<td>
<p>an object of class lgcpgrid</p>
</td></tr>
<tr><td><code id="as.list.lgcpgrid_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>conversion from lgcpgrid to list
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.list">lgcpgrid.list</a>, <a href="#topic+lgcpgrid.array">lgcpgrid.array</a>, <a href="#topic+print.lgcpgrid">print.lgcpgrid</a>,
<a href="#topic+summary.lgcpgrid">summary.lgcpgrid</a>, <a href="#topic+quantile.lgcpgrid">quantile.lgcpgrid</a>, <a href="#topic+image.lgcpgrid">image.lgcpgrid</a>, <a href="#topic+plot.lgcpgrid">plot.lgcpgrid</a>
</p>

<hr>
<h2 id='as.owin.stapp'>as.owin.stapp function</h2><span id='topic+as.owin.stapp'></span>

<h3>Description</h3>

<p>A function to extract the SpatialPolygons part of W and return it as an owin object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stapp'
as.owin(W, ..., fatal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owin.stapp_+3A_w">W</code></td>
<td>
<p>see ?as.owin</p>
</td></tr>
<tr><td><code id="as.owin.stapp_+3A_...">...</code></td>
<td>
<p>see ?as.owin</p>
</td></tr>
<tr><td><code id="as.owin.stapp_+3A_fatal">fatal</code></td>
<td>
<p>see ?as.owin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an owin object
</p>

<hr>
<h2 id='as.owinlist'>as.owinlist function</h2><span id='topic+as.owinlist'></span>

<h3>Description</h3>

<p>Generic function for creating lists of owin objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.owinlist(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owinlist_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="as.owinlist_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method as.owinlist
</p>

<hr>
<h2 id='as.owinlist.SpatialPolygonsDataFrame'>as.owinlist.SpatialPolygonsDataFrame function</h2><span id='topic+as.owinlist.SpatialPolygonsDataFrame'></span>

<h3>Description</h3>

<p>A function to create a list of owin objects from a SpatialPolygonsDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPolygonsDataFrame'
as.owinlist(obj, dmin = 0, check = TRUE, subset = rep(TRUE, length(obj)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owinlist.SpatialPolygonsDataFrame_+3A_obj">obj</code></td>
<td>
<p>a SpatialPolygonsDataFrame object</p>
</td></tr>
<tr><td><code id="as.owinlist.SpatialPolygonsDataFrame_+3A_dmin">dmin</code></td>
<td>
<p>purpose is to simplify the SpatialPolygons. A numeric value giving the smallest permissible length of an edge. See ? simplify.owin</p>
</td></tr>
<tr><td><code id="as.owinlist.SpatialPolygonsDataFrame_+3A_check">check</code></td>
<td>
<p>whether or not to use spatstat functions to check the validity of SpatialPolygons objects</p>
</td></tr>
<tr><td><code id="as.owinlist.SpatialPolygonsDataFrame_+3A_subset">subset</code></td>
<td>
<p>logical vector. Subset of regions to extract and conver to owin objects. By default, all regions are extracted.</p>
</td></tr>
<tr><td><code id="as.owinlist.SpatialPolygonsDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of owin objects corresponding to the constituent Polygons objects
</p>

<hr>
<h2 id='as.owinlist.stapp'>as.owinlist.stapp function</h2><span id='topic+as.owinlist.stapp'></span>

<h3>Description</h3>

<p>A function to create a list of owin objects from a stapp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stapp'
as.owinlist(obj, dmin = 0, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.owinlist.stapp_+3A_obj">obj</code></td>
<td>
<p>an stapp object</p>
</td></tr>
<tr><td><code id="as.owinlist.stapp_+3A_dmin">dmin</code></td>
<td>
<p>purpose is to simplify the SpatialPolygons. A numeric value giving the smallest permissible length of an edge. See ? simplify.owin</p>
</td></tr>
<tr><td><code id="as.owinlist.stapp_+3A_check">check</code></td>
<td>
<p>whether or not to use spatstat functions to check the validity of SpatialPolygons objects</p>
</td></tr>
<tr><td><code id="as.owinlist.stapp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of owin objects corresponding to the constituent Polygons objects
</p>

<hr>
<h2 id='as.ppp.mstppp'>as.ppp.mstppp function</h2><span id='topic+as.ppp.mstppp'></span>

<h3>Description</h3>

<p>Convert from mstppp to ppp. Can be useful for data handling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mstppp'
as.ppp(X, ..., fatal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ppp.mstppp_+3A_x">X</code></td>
<td>
<p>an object of class mstppp</p>
</td></tr>
<tr><td><code id="as.ppp.mstppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="as.ppp.mstppp_+3A_fatal">fatal</code></td>
<td>
<p>logical value, see details in generic ?as.ppp</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ppp object without observation times
</p>

<hr>
<h2 id='as.ppp.stppp'>as.ppp.stppp function</h2><span id='topic+as.ppp.stppp'></span>

<h3>Description</h3>

<p>Convert from stppp to ppp. Can be useful for data handling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
as.ppp(X, ..., fatal = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ppp.stppp_+3A_x">X</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="as.ppp.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="as.ppp.stppp_+3A_fatal">fatal</code></td>
<td>
<p>logical value, see details in generic ?as.ppp</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ppp object without observation times
</p>

<hr>
<h2 id='as.SpatialGridDataFrame'>as.SpatialGridDataFrame function</h2><span id='topic+as.SpatialGridDataFrame'></span>

<h3>Description</h3>

<p>Generic method for convertign to an object of class SpatialGridDataFrame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SpatialGridDataFrame(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatialGridDataFrame_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="as.SpatialGridDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method as.SpatialGridDataFrame
</p>


<h3>See Also</h3>

<p><a href="#topic+as.SpatialGridDataFrame.fromXYZ">as.SpatialGridDataFrame.fromXYZ</a>
</p>

<hr>
<h2 id='as.SpatialGridDataFrame.fromXYZ'>as.SpatialGridDataFrame.fromXYZ function</h2><span id='topic+as.SpatialGridDataFrame.fromXYZ'></span>

<h3>Description</h3>

<p>Method for converting objects of class fromXYZ into those of class SpatialGridDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
as.SpatialGridDataFrame(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatialGridDataFrame.fromXYZ_+3A_obj">obj</code></td>
<td>
<p>an object of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="as.SpatialGridDataFrame.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class SpatialGridDataFrame
</p>


<h3>See Also</h3>

<p><a href="#topic+as.SpatialGridDataFrame">as.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='as.SpatialPixelsDataFrame'>as.SpatialPixelsDataFrame function</h2><span id='topic+as.SpatialPixelsDataFrame'></span>

<h3>Description</h3>

<p>Generic function for conversion to SpatialPixels objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.SpatialPixelsDataFrame(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatialPixelsDataFrame_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="as.SpatialPixelsDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method as.SpatialPixels
</p>


<h3>See Also</h3>

<p><a href="#topic+as.SpatialPixelsDataFrame.lgcpgrid">as.SpatialPixelsDataFrame.lgcpgrid</a>
</p>

<hr>
<h2 id='as.SpatialPixelsDataFrame.lgcpgrid'>as.SpatialPixelsDataFrame.lgcpgrid function</h2><span id='topic+as.SpatialPixelsDataFrame.lgcpgrid'></span>

<h3>Description</h3>

<p>Method to convert lgcpgrid objects to SpatialPixelsDataFrame objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
as.SpatialPixelsDataFrame(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.SpatialPixelsDataFrame.lgcpgrid_+3A_obj">obj</code></td>
<td>
<p>an lgcpgrid object</p>
</td></tr>
<tr><td><code id="as.SpatialPixelsDataFrame.lgcpgrid_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to SpatialPoints, eg a proj4string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a SpatialPixelsDataFrame, or a list consisting of SpatialPixelsDataFrame objects.
</p>

<hr>
<h2 id='as.stppp'>as.stppp function</h2><span id='topic+as.stppp'></span>

<h3>Description</h3>

<p>Generic function for converting to stppp objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.stppp(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.stppp_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="as.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method as.stppp
</p>

<hr>
<h2 id='as.stppp.stapp'>as.stppp.stapp function</h2><span id='topic+as.stppp.stapp'></span>

<h3>Description</h3>

<p>A function to convert stapp objects to stppp objects for use in lgcpPredict. The regional counts in the stapp object are
assigned a random location within each areal region proportional to a population density (if that is available) else
the counts are distributed uniformly across the observation windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stapp'
as.stppp(obj, popden = NULL, n = 100, dmin = 0, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.stppp.stapp_+3A_obj">obj</code></td>
<td>
<p>an object of class stapp</p>
</td></tr>
<tr><td><code id="as.stppp.stapp_+3A_popden">popden</code></td>
<td>
<p>a 'spatialAtRisk' of sub-class 'fromXYZ' object representing the population density, or for better results, lambda(s) can also
be used here. Cases are distributed across the spatial region according to popden. NULL by default, which has the effect of assigning counts uniformly.</p>
</td></tr>
<tr><td><code id="as.stppp.stapp_+3A_n">n</code></td>
<td>
<p>if popden is NULL, then this parameter controls the resolution of the uniform. Otherwise if popden is of class 'fromFunction', it controls the size of the imputation grid used for sampling. Default is 100.</p>
</td></tr>
<tr><td><code id="as.stppp.stapp_+3A_dmin">dmin</code></td>
<td>
<p>If any reginal counts are missing, then a set of polygonal 'holes' in the observation window will be computed for each. dmin is the parameter used to control the simplification of these holes (see ?simplify.owin). default is zero.</p>
</td></tr>
<tr><td><code id="as.stppp.stapp_+3A_check">check</code></td>
<td>
<p>logical. If any reginal counts are missing, then roughly speaking, check specifies whether to check the 'holes'.</p>
</td></tr>
<tr><td><code id="as.stppp.stapp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='assigninterp'>assigninterp function</h2><span id='topic+assigninterp'></span>

<h3>Description</h3>

<p>A function to assign an interpolation type to a variable in a data frame.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assigninterp(df, vars, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assigninterp_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="assigninterp_+3A_vars">vars</code></td>
<td>
<p>character vector giving name of variables</p>
</td></tr>
<tr><td><code id="assigninterp_+3A_value">value</code></td>
<td>
<p>an interpolation type, posssible options are given by typing interptypes(), see ?interptypes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three types of interpolation method employed in the package lgcp are:<br />
</p>

<ol>
<li><p> 'Majority' The interpolated value corresponds to the value of the covariate occupying
the largest area of the computational cell.
</p>
</li>
<li><p> 'ArealWeightedMean' The interpolated value corresponds to the mean of all covariate
values contributing to the computational cell weighted by their respective areas.
</p>
</li>
<li><p> 'ArealWeightedSum' The interpolated value is the sum of all contributing covariates
weighed by the proportion of area with respect to the covariate polygons. For example,
suppose region A has the same area as a computational grid cell and has 500 inhabitants.
If that region occupies half of a computational grid cell, then this interpolation type assigns
250 inhabitants from A to the computational grid cell.
</p>
</li></ol>



<h3>Value</h3>

<p>assigns an interpolation type to a variable
</p>


<h3>See Also</h3>

<p><a href="#topic+chooseCellwidth">chooseCellwidth</a>, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: spdf a SpatialPolygonsDataFrame
## Not run: spdf@data &lt;- assigninterp(df=spdf@data,vars="pop",value="ArealWeightedSum")
</code></pre>

<hr>
<h2 id='at'>at function</h2><span id='topic+at'></span>

<h3>Description</h3>

<p>at function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>at(t, mu, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="at_+3A_t">t</code></td>
<td>
<p>change in time parameter, see Brix and Diggle (2001)</p>
</td></tr>
<tr><td><code id="at_+3A_mu">mu</code></td>
<td>
<p>mean</p>
</td></tr>
<tr><td><code id="at_+3A_theta">theta</code></td>
<td>
<p>parameter beta in Brix and Diggle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='autocorr'>autocorr function</h2><span id='topic+autocorr'></span>

<h3>Description</h3>

<p><b>This function requires data to have been dumped to disk</b>: see <code>?dump2dir</code> and <code>?setoutput</code>. The routine <code>autocorr.lgcpPredict</code>
computes cellwise selected autocorrelations of Y.
Since computing the quantiles is an expensive operation, the option to output the quantiles on a subregion of interest is also provided (by
setting the argument <code>inWindow</code>, which has a sensible default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorr(
  x,
  lags,
  tidx = NULL,
  inWindow = x$xyt$window,
  crop2parentwindow = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorr_+3A_x">x</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="autocorr_+3A_lags">lags</code></td>
<td>
<p>a vector of the required lags</p>
</td></tr>
<tr><td><code id="autocorr_+3A_tidx">tidx</code></td>
<td>
<p>the index number of the the time interval of interest, default is the last time point.</p>
</td></tr>
<tr><td><code id="autocorr_+3A_inwindow">inWindow</code></td>
<td>
<p>an observation owin window on which to compute the autocorrelations, can speed up calculation. Default is x$xyt$window, set to NULL for full grid.</p>
</td></tr>
<tr><td><code id="autocorr_+3A_crop2parentwindow">crop2parentwindow</code></td>
<td>
<p>logical: whether to only compute autocorrelations for cells inside x$xyt$window (the 'parent window')</p>
</td></tr>
<tr><td><code id="autocorr_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array, the [,,i]th slice being the grid of cell-wise autocorrelations.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+dump2dir">dump2dir</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+plot.lgcpAutocorr">plot.lgcpAutocorr</a>, <a href="#topic+ltar">ltar</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='autocorrMultitype'>autocorrMultitype function</h2><span id='topic+autocorrMultitype'></span>

<h3>Description</h3>

<p>A function to compute cell-wise autocorrelation in the latent field at specifiec lags
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocorrMultitype(
  x,
  lags,
  fieldno,
  inWindow = x$xyt$window,
  crop2parentwindow = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorrMultitype_+3A_x">x</code></td>
<td>
<p>an object of class lgcpPredictMultitypeSpatialPlusParameters</p>
</td></tr>
<tr><td><code id="autocorrMultitype_+3A_lags">lags</code></td>
<td>
<p>the lags at which to compute the autocorrelation</p>
</td></tr>
<tr><td><code id="autocorrMultitype_+3A_fieldno">fieldno</code></td>
<td>
<p>the index of the lateyt field, the i in Y_i, see the help file for lgcpPredictMultitypeSpatialPlusParameters. IN diagnostic checking ,this command should be called for each field in the model.</p>
</td></tr>
<tr><td><code id="autocorrMultitype_+3A_inwindow">inWindow</code></td>
<td>
<p>an observation owin window on which to compute the autocorrelations, can speed up calculation. Default is x$xyt$window, set to NULL for full grid.</p>
</td></tr>
<tr><td><code id="autocorrMultitype_+3A_crop2parentwindow">crop2parentwindow</code></td>
<td>
<p>logical: whether to only compute autocorrelations for cells inside x$xyt$window (the 'parent window')</p>
</td></tr>
<tr><td><code id="autocorrMultitype_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array, the [,,i]th slice being the grid of cell-wise autocorrelations.
</p>

<hr>
<h2 id='BetaParameters'>BetaParameters function</h2><span id='topic+BetaParameters'></span>

<h3>Description</h3>

<p>An internal function to declare a vector a parameter vector for the main effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BetaParameters(beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BetaParameters_+3A_beta">beta</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='betavals'>betavals function</h2><span id='topic+betavals'></span>

<h3>Description</h3>

<p>A function to return the sampled beta from a call to the function lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betavals(lg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betavals_+3A_lg">lg</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars orlgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the posterior sampled beta
</p>


<h3>See Also</h3>

<p><a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='blockcircbase'>blockcircbase function</h2><span id='topic+blockcircbase'></span>

<h3>Description</h3>

<p>Compute the base matrix of a continuous Gaussian field. Computed as a block circulant matrix on a torus where x and y is the 
x and y centroids (must be equally spaced)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockcircbase(x, y, sigma, phi, model, additionalparameters, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockcircbase_+3A_x">x</code></td>
<td>
<p>x centroids, an equally spaced vector</p>
</td></tr>
<tr><td><code id="blockcircbase_+3A_y">y</code></td>
<td>
<p>y centroids, an equally spaced vector</p>
</td></tr>
<tr><td><code id="blockcircbase_+3A_sigma">sigma</code></td>
<td>
<p>spatial variance parameter</p>
</td></tr>
<tr><td><code id="blockcircbase_+3A_phi">phi</code></td>
<td>
<p>spatial decay parameter</p>
</td></tr>
<tr><td><code id="blockcircbase_+3A_model">model</code></td>
<td>
<p>covariance model, see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="blockcircbase_+3A_additionalparameters">additionalparameters</code></td>
<td>
<p>additional parameters for chosen covariance model. See ?CovarianceFct</p>
</td></tr>
<tr><td><code id="blockcircbase_+3A_inverse">inverse</code></td>
<td>
<p>logical. Whether to return the base matrix of the inverse covariance matrix (ie the base matrix for the precision matrix), default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the base matrix of a block circulant matrix representing a stationary covariance function on a toral grid.
</p>

<hr>
<h2 id='blockcircbaseFunction'>blockcircbaseFunction function</h2><span id='topic+blockcircbaseFunction'></span>

<h3>Description</h3>

<p>Compute the base matrix of a continuous Gaussian field. Computed as a block circulant matrix on a torus where x and y is the
x and y centroids (must be equally spaced). This is an extension of the function blockcircbase to extend the range of covariance functions
that can be fitted to the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockcircbaseFunction(x, y, CovFunction, CovParameters, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockcircbaseFunction_+3A_x">x</code></td>
<td>
<p>x centroids, an equally spaced vector</p>
</td></tr>
<tr><td><code id="blockcircbaseFunction_+3A_y">y</code></td>
<td>
<p>y centroids, an equally spaced vector</p>
</td></tr>
<tr><td><code id="blockcircbaseFunction_+3A_covfunction">CovFunction</code></td>
<td>
<p>a function of distance, returning the covariance between points that distance apart</p>
</td></tr>
<tr><td><code id="blockcircbaseFunction_+3A_covparameters">CovParameters</code></td>
<td>
<p>an object of class CovParamters, see ?CovParameters</p>
</td></tr>
<tr><td><code id="blockcircbaseFunction_+3A_inverse">inverse</code></td>
<td>
<p>logical. Whether to return the base matrix of the inverse covariance matrix (ie the base matrix for the precision matrix), default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the base matrix of a block circulant matrix representing a stationary covariance function on a toral grid.
</p>


<h3>See Also</h3>

<p><a href="#topic+chooseCellwidth">chooseCellwidth</a>, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>,
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>
</p>

<hr>
<h2 id='bt.scalar'>bt.scalar function</h2><span id='topic+bt.scalar'></span>

<h3>Description</h3>

<p>bt.scalar function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bt.scalar(t, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bt.scalar_+3A_t">t</code></td>
<td>
<p>change in time, see Brix and Diggle (2001)</p>
</td></tr>
<tr><td><code id="bt.scalar_+3A_theta">theta</code></td>
<td>
<p>parameter beta in Brix and Diggle</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='checkObsWin'>checkObsWin function</h2><span id='topic+checkObsWin'></span>

<h3>Description</h3>

<p>A function to run on an object generated by the &quot;selectObsWindow&quot; function. Plots the observation window with grid, use as a visual aid to check
the choice of cell width is correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkObsWin(ow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkObsWin_+3A_ow">ow</code></td>
<td>
<p>an object generated by selectObsWindow, see ?selectObsWindow</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the observation window and grid
</p>


<h3>See Also</h3>

<p><a href="#topic+chooseCellwidth">chooseCellwidth</a>
</p>

<hr>
<h2 id='chooseCellwidth'>chooseCellwidth function</h2><span id='topic+chooseCellwidth'></span>

<h3>Description</h3>

<p>A function to help choose the cell width (the parameter &quot;cellwidth&quot; in lgcpPredictSpatialPlusPars, for example) prior to setting up the FFT grid,
before an MCMC run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseCellwidth(obj, cwinit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chooseCellwidth_+3A_obj">obj</code></td>
<td>
<p>an object of class ppp, stppp, SpatialPolygonsDataFrame, or owin</p>
</td></tr>
<tr><td><code id="chooseCellwidth_+3A_cwinit">cwinit</code></td>
<td>
<p>the cell width</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ideally this function should be used after having made a preliminary guess at the parameters of the latent field.The idea is to run chooseCellwidth
several times, adjusting the parameter &quot;cwinit&quot; so as to balance available computational resources with output grid size.
</p>


<h3>Value</h3>

<p>produces a plot of the observation window and computational grid.
</p>


<h3>See Also</h3>

<p><a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>
</p>

<hr>
<h2 id='circulant'>circulant function</h2><span id='topic+circulant'></span>

<h3>Description</h3>

<p>generic function for constructing circulant matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circulant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulant_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="circulant_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method circulant
</p>

<hr>
<h2 id='circulant.matrix'>circulant.matrix function</h2><span id='topic+circulant.matrix'></span>

<h3>Description</h3>

<p>If x is a matrix whose columns are the bases of the sub-blocks of a block circulant matrix, then this function returns the 
block circulant matrix of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
circulant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulant.matrix_+3A_x">x</code></td>
<td>
<p>a matrix object</p>
</td></tr>
<tr><td><code id="circulant.matrix_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If x is a matrix whose columns are the bases of the sub-blocks of a block circulant matrix, then this function returns the block circulant matrix of interest.
</p>

<hr>
<h2 id='circulant.numeric'>circulant.numeric function</h2><span id='topic+circulant.numeric'></span>

<h3>Description</h3>

<p>returns a circulant matrix with base x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
circulant(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulant.numeric_+3A_x">x</code></td>
<td>
<p>an numeric object</p>
</td></tr>
<tr><td><code id="circulant.numeric_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a circulant matrix with base x
</p>

<hr>
<h2 id='clearinterp'>clearinterp function</h2><span id='topic+clearinterp'></span>

<h3>Description</h3>

<p>A function to remove the interpolation methods from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clearinterp(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clearinterp_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>removes the interpolation methods
</p>

<hr>
<h2 id='computeGradtruncSpatial'>computeGradtruncSpatial function</h2><span id='topic+computeGradtruncSpatial'></span>

<h3>Description</h3>

<p><b>Advanced use only.</b> A function to compute a gradient truncation parameter for 'spatial only' MALA via simulation. The function
requires an FFT 'grid' to be pre-computed, see <a href="#topic+fftgrid">fftgrid</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGradtruncSpatial(
  nsims = 100,
  scale = 1,
  nis,
  mu,
  rootQeigs,
  invrootQeigs,
  scaleconst,
  spatial,
  cellarea
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGradtruncSpatial_+3A_nsims">nsims</code></td>
<td>
<p>The number of simulations to use in computation of gradient truncation.</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatial_+3A_scale">scale</code></td>
<td>
<p>multiplicative scaling constant, returned value is scale (times) max(gradient over simulations). Default scale is 1.</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatial_+3A_nis">nis</code></td>
<td>
<p>cell counts on the extended grid</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatial_+3A_mu">mu</code></td>
<td>
<p>parameter of latent field, mu</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatial_+3A_rootqeigs">rootQeigs</code></td>
<td>
<p>root of eigenvalues of precision matrix of latent field</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatial_+3A_invrootqeigs">invrootQeigs</code></td>
<td>
<p>reciprocal root of eigenvalues of precision matrix of latent field</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatial_+3A_scaleconst">scaleconst</code></td>
<td>
<p>expected number of cases, or ML estimate of this quantity</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatial_+3A_spatial">spatial</code></td>
<td>
<p>spatial at risk interpolated onto grid of requisite size</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatial_+3A_cellarea">cellarea</code></td>
<td>
<p>cell area</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gradient truncation parameter
</p>


<h3>See Also</h3>

<p><a href="#topic+fftgrid">fftgrid</a>
</p>

<hr>
<h2 id='computeGradtruncSpatioTemporal'>computeGradtruncSpatioTemporal function</h2><span id='topic+computeGradtruncSpatioTemporal'></span>

<h3>Description</h3>

<p><b>Advanced use only.</b> A function to compute a gradient truncation parameter for 'spatial only' MALA via simulation. The function
requires an FFT 'grid' to be pre-computed, see <a href="#topic+fftgrid">fftgrid</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGradtruncSpatioTemporal(
  nsims = 100,
  scale = 1,
  nis,
  mu,
  rootQeigs,
  invrootQeigs,
  spatial,
  temporal,
  bt,
  cellarea
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_nsims">nsims</code></td>
<td>
<p>The number of simulations to use in computation of gradient truncation.</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_scale">scale</code></td>
<td>
<p>multiplicative scaling constant, returned value is scale (times) max(gradient over simulations). Default scale is 1.</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_nis">nis</code></td>
<td>
<p>cell counts on the extended grid</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_mu">mu</code></td>
<td>
<p>parameter of latent field, mu</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_rootqeigs">rootQeigs</code></td>
<td>
<p>root of eigenvalues of precision matrix of latent field</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_invrootqeigs">invrootQeigs</code></td>
<td>
<p>reciprocal root of eigenvalues of precision matrix of latent field</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_spatial">spatial</code></td>
<td>
<p>spatial at risk interpolated onto grid of requisite size</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_temporal">temporal</code></td>
<td>
<p>fitted temporal values</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_bt">bt</code></td>
<td>
<p>vectoer of variances b(delta t) in Brix and Diggle 2001</p>
</td></tr>
<tr><td><code id="computeGradtruncSpatioTemporal_+3A_cellarea">cellarea</code></td>
<td>
<p>cell area</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gradient truncation parameter
</p>


<h3>See Also</h3>

<p><a href="#topic+fftgrid">fftgrid</a>
</p>

<hr>
<h2 id='condProbs'>condProbs function</h2><span id='topic+condProbs'></span>

<h3>Description</h3>

<p>A function to compute the conditional type-probabilities from a multivariate LGCP. See the vignette &quot;Bayesian_lgcp&quot; for a full explanation of this.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condProbs(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condProbs_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredictMultitypeSpatialPlusParameters object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We suppose there are K point types of interest. The model for point-type k is as follows:<br />
<br />
X_k(s) ~ Poisson[R_k(s)]<br />
<br />
R_k(s) = C_A lambda_k(s) exp[Z_k(s)beta_k+Y_k(s)]<br />
<br />
</p>
<p>Here X_k(s) is the number of events of type k in the computational grid cell containing the
point s, R_k(s) is the Poisson rate, C_A is the cell area, lambda_k(s) is a known offset, Z_k(s) is a vector
of measured covariates and Y_i(s) where i = 1,...,K+1 are latent Gaussian processes on the
computational grid. The other parameters in the model are beta_k , the covariate effects for the
kth type; and eta_i = [log(sigma_i),log(phi_i)], the parameters of the process Y_i for i = 1,...,K+1 on
an appropriately transformed (again, in this case log) scale.
</p>
<p>The term 'conditional probability of type k' means the probability that at a particular location there
will be an event of type k, which denoted p_k.
</p>


<h3>Value</h3>

<p>an lgcpgrid object containing the consitional type-probabilities for each type
</p>


<h3>See Also</h3>

<p><a href="#topic+segProbs">segProbs</a>, <a href="#topic+postcov.lgcpPredictSpatialOnlyPlusParameters">postcov.lgcpPredictSpatialOnlyPlusParameters</a>, <a href="#topic+postcov.lgcpPredictAggregateSpatialPlusParameters">postcov.lgcpPredictAggregateSpatialPlusParameters</a>, <a href="#topic+postcov.lgcpPredictSpatioTemporalPlusParameters">postcov.lgcpPredictSpatioTemporalPlusParameters</a>, <a href="#topic+postcov.lgcpPredictMultitypeSpatialPlusParameters">postcov.lgcpPredictMultitypeSpatialPlusParameters</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='constanth'>constanth function</h2><span id='topic+constanth'></span>

<h3>Description</h3>

<p>This function is used to set up a constant acceptance scheme in the argument 
<code>mcmc.control</code> of the function <code>lgcpPredict</code>. The scheme is set via
the <code>mcmcpars</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constanth(h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constanth_+3A_h">h</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class constanth
</p>


<h3>See Also</h3>

<p><a href="#topic+mcmcpars">mcmcpars</a>, <a href="#topic+lgcpPredict">lgcpPredict</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>constanth(0.01)
</code></pre>

<hr>
<h2 id='constantInTime'>constantInTime function</h2><span id='topic+constantInTime'></span>

<h3>Description</h3>

<p>Generic function for creating constant-in-time temporalAtRisk objects, that is for models where mu(t) can be assumed to
be constant in time. The assumption being that the global at-risk population does not change in size over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constantInTime(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constantInTime_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="constantInTime_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details of temporalAtRisk objects, see ?temporalAtRisk&gt;
</p>


<h3>Value</h3>

<p>method constantInTime
</p>


<h3>See Also</h3>

<p><a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>, <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>, <a href="#topic+constantInTime.numeric">constantInTime.numeric</a>, <a href="#topic+constantInTime.stppp">constantInTime.stppp</a>, <a href="#topic+print.temporalAtRisk">print.temporalAtRisk</a>, <a href="#topic+plot.temporalAtRisk">plot.temporalAtRisk</a>
</p>

<hr>
<h2 id='constantInTime.numeric'>constantInTime.numeric function</h2><span id='topic+constantInTime.numeric'></span>

<h3>Description</h3>

<p>Create a constant-in-time temporalAtRisk object from a numeric object of length 1. The returned temporalAtRisk object is assumed to have
been scaled correctly by the user so that mu(t) = E(number of cases in a unit time interval).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
constantInTime(obj, tlim, warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constantInTime.numeric_+3A_obj">obj</code></td>
<td>
<p>numeric constant</p>
</td></tr>
<tr><td><code id="constantInTime.numeric_+3A_tlim">tlim</code></td>
<td>
<p>vector of length 2 giving time limits</p>
</td></tr>
<tr><td><code id="constantInTime.numeric_+3A_warn">warn</code></td>
<td>
<p>Issue a warning if the given temporal intensity treated is treated as 'known'?</p>
</td></tr>
<tr><td><code id="constantInTime.numeric_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details of temporalAtRisk objects, see ?temporalAtRisk&gt;
</p>


<h3>Value</h3>

<p>a function f(t) giving the (constant) temporal intensity at time t for integer t in the interval [tlim[1],tlim[2]] of class temporalAtRisk
</p>


<h3>See Also</h3>

<p><a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>, <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>, <a href="#topic+constantInTime">constantInTime</a>, <a href="#topic+constantInTime.stppp">constantInTime.stppp</a>, <a href="#topic+print.temporalAtRisk">print.temporalAtRisk</a>, <a href="#topic+plot.temporalAtRisk">plot.temporalAtRisk</a>,
</p>

<hr>
<h2 id='constantInTime.stppp'>constantInTime.stppp function</h2><span id='topic+constantInTime.stppp'></span>

<h3>Description</h3>

<p>Create a constant-in-time temporalAtRisk object from an stppp object. The returned temporalAtRisk object is scaled to return
mu(t) = E(number of cases in a unit time interval).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
constantInTime(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constantInTime.stppp_+3A_obj">obj</code></td>
<td>
<p>an object of class stppp.</p>
</td></tr>
<tr><td><code id="constantInTime.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details of temporalAtRisk objects, see ?temporalAtRisk&gt;
</p>


<h3>Value</h3>

<p>a function f(t) giving the (constant) temporal intensity at time t for integer t in the interval [tlim[1],tlim[2]] of class temporalAtRisk
</p>


<h3>See Also</h3>

<p><a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>, <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>, <a href="#topic+constantInTime">constantInTime</a>, <a href="#topic+constantInTime.numeric">constantInTime.numeric</a>, <a href="#topic+print.temporalAtRisk">print.temporalAtRisk</a>, <a href="#topic+plot.temporalAtRisk">plot.temporalAtRisk</a>,
</p>

<hr>
<h2 id='cov.interp.fft'>cov.interp.fft function</h2><span id='topic+cov.interp.fft'></span>

<h3>Description</h3>

<p>A function to interpolate covariate values onto the fft grid, ready for analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.interp.fft(
  formula,
  W,
  regionalcovariates = NULL,
  pixelcovariates = NULL,
  mcens,
  ncens,
  cellInside,
  overl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.interp.fft_+3A_formula">formula</code></td>
<td>
<p>an object of class formula (or one that can be coerced to that class) starting with X ~ (eg X~var1+var2 *NOT for example* Y~var1+var2): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="cov.interp.fft_+3A_w">W</code></td>
<td>
<p>an owin observation window</p>
</td></tr>
<tr><td><code id="cov.interp.fft_+3A_regionalcovariates">regionalcovariates</code></td>
<td>
<p>an optional SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="cov.interp.fft_+3A_pixelcovariates">pixelcovariates</code></td>
<td>
<p>an optional SpatialPixelsDataFrame</p>
</td></tr>
<tr><td><code id="cov.interp.fft_+3A_mcens">mcens</code></td>
<td>
<p>x-coordinates of output grid centroids (not fft grid centroids ie *not* the extended grid)</p>
</td></tr>
<tr><td><code id="cov.interp.fft_+3A_ncens">ncens</code></td>
<td>
<p>y-coordinates of output grid centroids (not fft grid centroids ie *not* the extended grid)</p>
</td></tr>
<tr><td><code id="cov.interp.fft_+3A_cellinside">cellInside</code></td>
<td>
<p>a 0-1 matrix indicating which computational cells are inside the observation window</p>
</td></tr>
<tr><td><code id="cov.interp.fft_+3A_overl">overl</code></td>
<td>
<p>an overlay of the computational grid onto the SpatialPolygonsDataFrame or SpatialPixelsDataFrame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The interpolated design matrix, ready for analysis
</p>

<hr>
<h2 id='CovarianceFct'>CovarianceFct function</h2><span id='topic+CovarianceFct'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovarianceFct(u, sigma, phi, model, additionalparameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovarianceFct_+3A_u">u</code></td>
<td>
<p>distance</p>
</td></tr>
<tr><td><code id="CovarianceFct_+3A_sigma">sigma</code></td>
<td>
<p>parameter sigma</p>
</td></tr>
<tr><td><code id="CovarianceFct_+3A_phi">phi</code></td>
<td>
<p>parameter phi</p>
</td></tr>
<tr><td><code id="CovarianceFct_+3A_model">model</code></td>
<td>
<p>character string, the model</p>
</td></tr>
<tr><td><code id="CovarianceFct_+3A_additionalparameters">additionalparameters</code></td>
<td>
<p>additional parameters for the covariance function that will be fixed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the covariance function evaluated at the specified distances
</p>

<hr>
<h2 id='covEffects'>covEffects function</h2><span id='topic+covEffects'></span>

<h3>Description</h3>

<p>A function used in conjunction with the function &quot;expectation&quot; to compute the main covariate effects,<br />
lambda(s) exp[Z(s)beta] <br />
in each computational grid cell. Currently
only implemented for spatial processes (lgcpPredictSpatialPlusPars and lgcpPredictAggregateSpatialPlusPars).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covEffects(Y, beta, eta, Z, otherargs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covEffects_+3A_y">Y</code></td>
<td>
<p>the latent field</p>
</td></tr>
<tr><td><code id="covEffects_+3A_beta">beta</code></td>
<td>
<p>the main effects</p>
</td></tr>
<tr><td><code id="covEffects_+3A_eta">eta</code></td>
<td>
<p>the parameters of the latent field</p>
</td></tr>
<tr><td><code id="covEffects_+3A_z">Z</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="covEffects_+3A_otherargs">otherargs</code></td>
<td>
<p>other arguments to the function (see vignette &quot;Bayesian_lgcp&quot; for an explanation)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the main effects
</p>


<h3>See Also</h3>

<p><a href="#topic+expectation">expectation</a>,  <a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ex &lt;- expectation(lg,covEffects)[[1]] # lg is output from spatial LGCP MCMC
</code></pre>

<hr>
<h2 id='CovFunction'>CovFunction function</h2><span id='topic+CovFunction'></span>

<h3>Description</h3>

<p>A Generic method used to specify the choice of covariance function for use in the MCMC algorithm. For further details and examples,
see the vignette &quot;Bayesian_lgcp&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovFunction(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovFunction_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="CovFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method CovFunction
</p>


<h3>See Also</h3>

<p><a href="#topic+CovFunction.function">CovFunction.function</a>, <a href="#topic+exponentialCovFct">exponentialCovFct</a>, <a href="#topic+RandomFieldsCovFct">RandomFieldsCovFct</a>, <a href="#topic+SpikedExponentialCovFct">SpikedExponentialCovFct</a>
</p>

<hr>
<h2 id='CovFunction.function'>CovFunction.function function</h2><span id='topic+CovFunction.function'></span>

<h3>Description</h3>

<p>A function used to define the covariance function for the latent field prior to running the MCMC algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
CovFunction(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovFunction.function_+3A_obj">obj</code></td>
<td>
<p>a function object</p>
</td></tr>
<tr><td><code id="CovFunction.function_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the covariance function ready to run the MCMC routine.
</p>


<h3>See Also</h3>

<p><a href="#topic+exponentialCovFct">exponentialCovFct</a>, <a href="#topic+RandomFieldsCovFct">RandomFieldsCovFct</a>, <a href="#topic+SpikedExponentialCovFct">SpikedExponentialCovFct</a>, <a href="#topic+CovarianceFct">CovarianceFct</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: cf1 &lt;- CovFunction(exponentialCovFct)
## Not run: cf2 &lt;- CovFunction(RandomFieldsCovFct(model="matern",additionalparameters=1))
</code></pre>

<hr>
<h2 id='CovParameters'>CovParameters function</h2><span id='topic+CovParameters'></span>

<h3>Description</h3>

<p>A function to provide a structure for the parameters of the latent field. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CovParameters(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CovParameters_+3A_list">list</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object used in the MCMC routine.
</p>

<hr>
<h2 id='Cvb'>Cvb function</h2><span id='topic+Cvb'></span>

<h3>Description</h3>

<p>This function is used in <code>thetaEst</code> to estimate the temporal correlation parameter, theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cvb(xyt, spatial.intensity, N = 100, spatial.covmodel, covpars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cvb_+3A_xyt">xyt</code></td>
<td>
<p>object of class stppp</p>
</td></tr>
<tr><td><code id="Cvb_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>bivariate density estimate of lambda, an object of class im (produced from density.ppp for example)</p>
</td></tr>
<tr><td><code id="Cvb_+3A_n">N</code></td>
<td>
<p>number of integration points</p>
</td></tr>
<tr><td><code id="Cvb_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>spatial covariance model</p>
</td></tr>
<tr><td><code id="Cvb_+3A_covpars">covpars</code></td>
<td>
<p>additional covariance parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function, see below.
Computes Monte carlo estimate of function C(v;beta) in Brix and Diggle 2001 pp 829 (... note later corrigendum to paper (2003) corrects the expression given in this paper)
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+thetaEst">thetaEst</a>
</p>

<hr>
<h2 id='d.func'>d.func function</h2><span id='topic+d.func'></span>

<h3>Description</h3>

<p>d.func function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d.func(mat1il, mat2jk, i, j, l, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d.func_+3A_mat1il">mat1il</code></td>
<td>
<p>matrix 1</p>
</td></tr>
<tr><td><code id="d.func_+3A_mat2jk">mat2jk</code></td>
<td>
<p>matrix 2</p>
</td></tr>
<tr><td><code id="d.func_+3A_i">i</code></td>
<td>
<p>index matrix 1 number 1</p>
</td></tr>
<tr><td><code id="d.func_+3A_j">j</code></td>
<td>
<p>index matrix 2 number 1</p>
</td></tr>
<tr><td><code id="d.func_+3A_l">l</code></td>
<td>
<p>index matrix 1 number 2</p>
</td></tr>
<tr><td><code id="d.func_+3A_k">k</code></td>
<td>
<p>index matrix 2 number 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='density.stppp'>density.stppp function</h2><span id='topic+density.stppp'></span>

<h3>Description</h3>

<p>A wrapper function for density.ppp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
density(x, bandwidth = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density.stppp_+3A_x">x</code></td>
<td>
<p>an stppp object</p>
</td></tr>
<tr><td><code id="density.stppp_+3A_bandwidth">bandwidth</code></td>
<td>
<p>'bandwidth' parameter, equivanent to parameter sigma in ?density.ppp ie standard deviation of isotropic Gaussian smoothing kernel.</p>
</td></tr>
<tr><td><code id="density.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to density.ppp</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bivariate density estimate of xyt; not this is a wrapper function for density.ppp
</p>


<h3>See Also</h3>

<p>density.ppp
</p>

<hr>
<h2 id='discreteWindow'>discreteWindow function</h2><span id='topic+discreteWindow'></span>

<h3>Description</h3>

<p>Generic function for extracting the FFT discrete window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discreteWindow(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discreteWindow_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="discreteWindow_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method discreteWindow
</p>


<h3>See Also</h3>

<p><a href="#topic+discreteWindow.lgcpPredict">discreteWindow.lgcpPredict</a>
</p>

<hr>
<h2 id='discreteWindow.lgcpPredict'>discreteWindow.lgcpPredict function</h2><span id='topic+discreteWindow.lgcpPredict'></span>

<h3>Description</h3>

<p>A function for extracting the FFT discrete window from an lgcpPredict object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
discreteWindow(obj, inclusion = "touching", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discreteWindow.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredict object</p>
</td></tr>
<tr><td><code id="discreteWindow.lgcpPredict_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
<tr><td><code id="discreteWindow.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='dump2dir'>dump2dir function</h2><span id='topic+dump2dir'></span>

<h3>Description</h3>

<p>This function, when set by the <code>gridfunction</code> argument of <a href="#topic+setoutput">setoutput</a>, in turn called by the argument 
<code>output.control</code> of <code>lgcpPredict</code> facilitates the dumping of data to disk. Data is dumped to a
netCDF file, <code>simout.nc</code>, stored in the directory specified by the user. If the directory does not exist, 
then it will be created. Since the requested data dumped to disk may be very large in a run of <code>lgcpPredict</code>, 
by default, the user is prompted as to whether to proceed with prediction, this can be turned off by setting 
the option <code>forceSave=TRUE</code> detailed here. To save space, or increase the number of simulations that can be
stored for a fixed disk space the option to only save the last time point is also available (<code>lastonly=TRUE</code>, 
which is the default setting).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dump2dir(dirname, lastonly = TRUE, forceSave = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dump2dir_+3A_dirname">dirname</code></td>
<td>
<p>character vector of length 1 containing the name of the directory to create</p>
</td></tr>
<tr><td><code id="dump2dir_+3A_lastonly">lastonly</code></td>
<td>
<p>only save output from time T? (see ?lgcpPredict for definition of T)</p>
</td></tr>
<tr><td><code id="dump2dir_+3A_forcesave">forceSave</code></td>
<td>
<p>option to override display of menu</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class dump2dir
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, \ <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='eigenfrombase'>eigenfrombase function</h2><span id='topic+eigenfrombase'></span>

<h3>Description</h3>

<p>A function to compute the eigenvalues of an SPD block circulant matrix given the base matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenfrombase(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenfrombase_+3A_x">x</code></td>
<td>
<p>the base matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the eigenvalues
</p>

<hr>
<h2 id='etavals'>etavals function</h2><span id='topic+etavals'></span>

<h3>Description</h3>

<p>A function to return the sampled eta from a call to the function lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etavals(lg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etavals_+3A_lg">lg</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars orlgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the posterior sampled eta
</p>


<h3>See Also</h3>

<p><a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>
</p>

<hr>
<h2 id='EvaluatePrior'>EvaluatePrior function</h2><span id='topic+EvaluatePrior'></span>

<h3>Description</h3>

<p>An internal function used in the MCMC routine to evaluate the prior for a given set of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EvaluatePrior(etaParameters, betaParameters, prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EvaluatePrior_+3A_etaparameters">etaParameters</code></td>
<td>
<p>the paramter eta</p>
</td></tr>
<tr><td><code id="EvaluatePrior_+3A_betaparameters">betaParameters</code></td>
<td>
<p>the parameter beta</p>
</td></tr>
<tr><td><code id="EvaluatePrior_+3A_prior">prior</code></td>
<td>
<p>the prior</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the prior evaluated at the given values.
</p>

<hr>
<h2 id='exceedProbs'>exceedProbs function</h2><span id='topic+exceedProbs'></span>

<h3>Description</h3>

<p>This function can be called using <code>MonteCarloAverage</code> (see <code>fun3</code> the examples in the help file for
<a href="#topic+MonteCarloAverage">MonteCarloAverage</a>). It computes exceedance probabilities,
</p>
<p style="text-align: center;"><code class="reqn">P[\exp(Y_{t_1:t_2})&gt;k],</code>
</p>

<p>that is the probability that the relative reisk exceeds threshold <code class="reqn">k</code>. Note that it is possible
to pass vectors of tresholds to the function, and the exceedance probabilities will be computed for each
of these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exceedProbs(threshold, direction = "upper")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exceedProbs_+3A_threshold">threshold</code></td>
<td>
<p>vector of threshold levels for the indicator function</p>
</td></tr>
<tr><td><code id="exceedProbs_+3A_direction">direction</code></td>
<td>
<p>default 'upper' giving exceedance probabilities, alternative is 'lower', which gives 'subordinate probabilities'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function of Y that computes the indicator function I(exp(Y)&gt;threshold) evaluated for each cell of a matrix Y
If several tresholds are specified an array is returned with the [,,i]th slice equal to I(exp(Y)&gt;threshold[i])
</p>


<h3>See Also</h3>

<p><a href="#topic+MonteCarloAverage">MonteCarloAverage</a>, <a href="#topic+setoutput">setoutput</a>
</p>

<hr>
<h2 id='exceedProbsAggregated'>exceedProbsAggregated function</h2><span id='topic+exceedProbsAggregated'></span>

<h3>Description</h3>

<p>NOTE THIS FUNCTION IS IN TESTING AT PRESENT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exceedProbsAggregated(threshold, lg = NULL, lastonly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exceedProbsAggregated_+3A_threshold">threshold</code></td>
<td>
<p>vector of threshold levels for the indicator function</p>
</td></tr>
<tr><td><code id="exceedProbsAggregated_+3A_lg">lg</code></td>
<td>
<p>an object of class aggregatedPredict</p>
</td></tr>
<tr><td><code id="exceedProbsAggregated_+3A_lastonly">lastonly</code></td>
<td>
<p>logical, whether to only compute the exceedances for the last time point. default is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes regional exceedance probabilities after MCMC has finished, it requires the information to have been dumped to disk, and
to have been computed using the function lgcpPredictAggregated
</p>
<p style="text-align: center;"><code class="reqn">P[\exp(Y_{t_1:t_2})&gt;k],</code>
</p>

<p>that is the probability that the relative risk exceeds threshold <code class="reqn">k</code>. Note that it is possible
to pass vectors of tresholds to the function, and the exceedance probabilities will be computed for each
of these.
</p>


<h3>Value</h3>

<p>a function of Y that computes the indicator function I(exp(Y)&gt;threshold) evaluated for each cell of a matrix Y, but with values aggregated to regions
If several tresholds are specified an array is returned with the [,,i]th slice equal to I(exp(Y)&gt;threshold[i])
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredictAggregated">lgcpPredictAggregated</a>
</p>

<hr>
<h2 id='expectation'>expectation function</h2><span id='topic+expectation'></span>

<h3>Description</h3>

<p>Generic function used in the computation of Monte Carlo expectations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectation(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectation_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="expectation_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method expectation
</p>

<hr>
<h2 id='expectation.lgcpPredict'>expectation.lgcpPredict function</h2><span id='topic+expectation.lgcpPredict'></span>

<h3>Description</h3>

<p><b>This function requires data to have been dumped to disk</b>: see <code>?dump2dir</code> and <code>?setoutput</code>. This function computes the
Monte Carlo Average of a function where data from a run of <code>lgcpPredict</code> has been dumped to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
expectation(obj, fun, maxit = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectation.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="expectation.lgcpPredict_+3A_fun">fun</code></td>
<td>
<p>a function accepting a single argument that returns a numeric vector, matrix or array object</p>
</td></tr>
<tr><td><code id="expectation.lgcpPredict_+3A_maxit">maxit</code></td>
<td>
<p>Not used in ordinary circumstances. Defines subset of samples over which to compute expectation. Expectation is computed using information from iterations 1:maxit, where 1 is the first non-burn in iteration dumped to disk.</p>
</td></tr>
<tr><td><code id="expectation.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Monte Carlo Average is computed as:
</p>
<p style="text-align: center;"><code class="reqn">E_{\pi(Y_{t_1:t_2}|X_{t_1:t_2})}[g(Y_{t_1:t_2})] \approx \frac1n\sum_{i=1}^n g(Y_{t_1:t_2}^{(i)})</code>
</p>

<p>where <code class="reqn">g</code> is a function of interest, <code class="reqn">Y_{t_1:t_2}^{(i)}</code> is the <code class="reqn">i</code>th retained sample from the target
and <code class="reqn">n</code> is the total number of retained iterations. For example, to compute the mean of <code class="reqn">Y_{t_1:t_2}</code> set,
</p>
<p style="text-align: center;"><code class="reqn">g(Y_{t_1:t_2}) = Y_{t_1:t_2},</code>
</p>

<p>the output from such a Monte Carlo average would be a set of <code class="reqn">t_2-t_1</code> grids, each cell of which
being equal to the mean over all retained iterations of the algorithm (NOTE: this is just an example computation, in
practice, there is no need to compute the mean on line explicitly, as this is already done by default in <code>lgcpPredict</code>).
</p>


<h3>Value</h3>

<p>the expectated value of that function
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+dump2dir">dump2dir</a>, <a href="#topic+setoutput">setoutput</a>
</p>

<hr>
<h2 id='expectation.lgcpPredictSpatialOnlyPlusParameters'>expectation.lgcpPredictSpatialOnlyPlusParameters function</h2><span id='topic+expectation.lgcpPredictSpatialOnlyPlusParameters'></span>

<h3>Description</h3>

<p><b>This function requires data to have been dumped to disk</b>: see <code>?dump2dir</code> and <code>?setoutput</code>. This function computes the
Monte Carlo Average of a function where data from a run of <code>lgcpPredict</code> has been dumped to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"expectation(obj,fun,maxit=NULL,...)"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectation.lgcpPredictSpatialOnlyPlusParameters_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredictSpatialOnlyPlusParameters</p>
</td></tr>
<tr><td><code id="expectation.lgcpPredictSpatialOnlyPlusParameters_+3A_fun">fun</code></td>
<td>
<p>a function with arguments 'Y', 'beta', 'eta', 'Z' and 'otherargs'. See vignette(&quot;Bayesian_lgcp&quot;) for an example</p>
</td></tr>
<tr><td><code id="expectation.lgcpPredictSpatialOnlyPlusParameters_+3A_maxit">maxit</code></td>
<td>
<p>Not used in ordinary circumstances. Defines subset of samples over which to compute expectation. Expectation is computed using information from iterations 1:maxit, where 1 is the first non-burn in iteration dumped to disk.</p>
</td></tr>
<tr><td><code id="expectation.lgcpPredictSpatialOnlyPlusParameters_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the expectated value of that function
</p>

<hr>
<h2 id='exponentialCovFct'>exponentialCovFct function</h2><span id='topic+exponentialCovFct'></span>

<h3>Description</h3>

<p>A function to declare and also evaluate an exponential covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponentialCovFct(d, CovParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exponentialCovFct_+3A_d">d</code></td>
<td>
<p>toral distance</p>
</td></tr>
<tr><td><code id="exponentialCovFct_+3A_covparameters">CovParameters</code></td>
<td>
<p>parameters of the latent field, an object of class &quot;CovParamaters&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the exponential covariance function
</p>


<h3>See Also</h3>

<p><a href="#topic+CovFunction.function">CovFunction.function</a>, <a href="#topic+RandomFieldsCovFct">RandomFieldsCovFct</a>, <a href="#topic+SpikedExponentialCovFct">SpikedExponentialCovFct</a>
</p>

<hr>
<h2 id='extendspatialAtRisk'>extendspatialAtRisk function</h2><span id='topic+extendspatialAtRisk'></span>

<h3>Description</h3>

<p>A function to extend a spatialAtRisk object, used in interpolating the fft grid NOTE THIS DOES NOT RETURN A PROPER spatialAtRisk OBJECT SINCE THE 
NORMALISING CONSTANT IS PUT BACK IN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extendspatialAtRisk(spatial)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extendspatialAtRisk_+3A_spatial">spatial</code></td>
<td>
<p>a spatialAtRisk object inheriting class 'fromXYZ'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the spatialAtRisk object on a slightly larger grid, with zeros appearing outside the original extent.
</p>

<hr>
<h2 id='extract'>extract function</h2><span id='topic+extract'></span>

<h3>Description</h3>

<p>Generic function for extracting information dumped to disk. See <a href="#topic+extract.lgcpPredict">extract.lgcpPredict</a> for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method extract
</p>


<h3>See Also</h3>

<p><a href="#topic+extract.lgcpPredict">extract.lgcpPredict</a>
</p>

<hr>
<h2 id='extract.lgcpPredict'>extract.lgcpPredict function</h2><span id='topic+extract.lgcpPredict'></span>

<h3>Description</h3>

<p><b>This function requires data to have been dumped to disk</b>: see <code>?dump2dir</code> and <code>?setoutput</code>. <code>extract.lgcpPredict</code>
extracts chunks of data that have been dumped to disk. The subset of data can either be specified using an (x,y,t,s) box or (window,t,s) region
where window is a polygonal subregion of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
extract(
  obj,
  x = NULL,
  y = NULL,
  t,
  s = -1,
  inWindow = NULL,
  crop2parentwindow = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="extract.lgcpPredict_+3A_x">x</code></td>
<td>
<p>range of x-indices: vector (eg c(2,4)) corresponding to desired subset of x coordinates. If equal to -1, then all cells in this dimension are extracted</p>
</td></tr>
<tr><td><code id="extract.lgcpPredict_+3A_y">y</code></td>
<td>
<p>range of y-indices as above</p>
</td></tr>
<tr><td><code id="extract.lgcpPredict_+3A_t">t</code></td>
<td>
<p>range of t-indices: time indices of interest</p>
</td></tr>
<tr><td><code id="extract.lgcpPredict_+3A_s">s</code></td>
<td>
<p>range of s-indices ie the simulation indices of interest</p>
</td></tr>
<tr><td><code id="extract.lgcpPredict_+3A_inwindow">inWindow</code></td>
<td>
<p>an observation owin window over which to extract the data (alternative to specifying x and y).</p>
</td></tr>
<tr><td><code id="extract.lgcpPredict_+3A_crop2parentwindow">crop2parentwindow</code></td>
<td>
<p>logical: whether to only extract cells inside obj$xyt$window (the 'parent window')</p>
</td></tr>
<tr><td><code id="extract.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extracted array
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+loc2poly">loc2poly</a>, <a href="#topic+dump2dir">dump2dir</a>, <a href="#topic+setoutput">setoutput</a>
</p>

<hr>
<h2 id='Extract.mstppp'>Extract.mstppp function</h2><span id='topic+Extract.mstppp'></span><span id='topic++5B.mstppp'></span><span id='topic++22+5B.mstppp+22'></span>

<h3>Description</h3>

<p>extracting subsets of an mstppp object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"x[subset]"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.mstppp_+3A_x">x</code></td>
<td>
<p>an object of class mstppp</p>
</td></tr>
<tr><td><code id="Extract.mstppp_+3A_subset">subset</code></td>
<td>
<p>subsetto extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extracts subset of an mstppp object
</p>

<hr>
<h2 id='Extract.stppp'>Extract.stppp function</h2><span id='topic+Extract.stppp'></span><span id='topic++5B.stppp'></span><span id='topic++22+5B.stppp+22'></span>

<h3>Description</h3>

<p>extracting subsets of an stppp object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"x[subset]"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract.stppp_+3A_x">x</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="Extract.stppp_+3A_subset">subset</code></td>
<td>
<p>the subset to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extracts subset of an stppp object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: xyt &lt;- lgcpSim()
## Not run: xyt
## Not run: xyt[xyt$t&gt;0.5]
</code></pre>

<hr>
<h2 id='fftgrid'>fftgrid function</h2><span id='topic+fftgrid'></span>

<h3>Description</h3>

<p>! As of lgcp version 0.9-5, this function is no longer used !
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftgrid(xyt, M, N, spatial, sigma, phi, model, covpars, inclusion = "touching")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftgrid_+3A_xyt">xyt</code></td>
<td>
<p>object of class stppp</p>
</td></tr>
<tr><td><code id="fftgrid_+3A_m">M</code></td>
<td>
<p>number of centroids in x-direction</p>
</td></tr>
<tr><td><code id="fftgrid_+3A_n">N</code></td>
<td>
<p>number of centroids in y-direction</p>
</td></tr>
<tr><td><code id="fftgrid_+3A_spatial">spatial</code></td>
<td>
<p>an object of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="fftgrid_+3A_sigma">sigma</code></td>
<td>
<p>scaling paramter for spatial covariance function, see Brix and Diggle (2001)</p>
</td></tr>
<tr><td><code id="fftgrid_+3A_phi">phi</code></td>
<td>
<p>scaling paramter for spatial covariance function, see Brix and Diggle (2001)</p>
</td></tr>
<tr><td><code id="fftgrid_+3A_model">model</code></td>
<td>
<p>correlation type see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="fftgrid_+3A_covpars">covpars</code></td>
<td>
<p>vector of additional parameters for certain classes of covariance function (eg Matern), these must be supplied in the order given in ?CovarianceFct</p>
</td></tr>
<tr><td><code id="fftgrid_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Advanced use only.</b> Computes various quantities for use in <code>lgcpPredict</code>,
<code>lgcpSim</code> .
</p>


<h3>Value</h3>

<p>fft objects for use in MALA
</p>

<hr>
<h2 id='fftinterpolate'>fftinterpolate function</h2><span id='topic+fftinterpolate'></span>

<h3>Description</h3>

<p>Generic function used for computing interpolations used in the function <a href="#topic+fftgrid">fftgrid</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftinterpolate(spatial, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftinterpolate_+3A_spatial">spatial</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="fftinterpolate_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method fftinterpolate
</p>


<h3>See Also</h3>

<p><a href="#topic+fftgrid">fftgrid</a>
</p>

<hr>
<h2 id='fftinterpolate.fromFunction'>fftinterpolate.fromFunction function</h2><span id='topic+fftinterpolate.fromFunction'></span>

<h3>Description</h3>

<p>This method performs interpolation within the function <code>fftgrid</code> for <code>fromFunction</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromFunction'
fftinterpolate(spatial, mcens, ncens, ext, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftinterpolate.fromFunction_+3A_spatial">spatial</code></td>
<td>
<p>objects of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromFunction_+3A_mcens">mcens</code></td>
<td>
<p>x-coordinates of interpolation grid in extended space</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromFunction_+3A_ncens">ncens</code></td>
<td>
<p>y-coordinates of interpolation grid in extended space</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromFunction_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of interpolated values
</p>


<h3>See Also</h3>

<p><a href="#topic+fftgrid">fftgrid</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>
</p>

<hr>
<h2 id='fftinterpolate.fromSPDF'>fftinterpolate.fromSPDF function</h2><span id='topic+fftinterpolate.fromSPDF'></span>

<h3>Description</h3>

<p>This method performs interpolation within the function <code>fftgrid</code> for <code>fromSPDF</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromSPDF'
fftinterpolate(spatial, mcens, ncens, ext, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftinterpolate.fromSPDF_+3A_spatial">spatial</code></td>
<td>
<p>objects of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromSPDF_+3A_mcens">mcens</code></td>
<td>
<p>x-coordinates of interpolation grid in extended space</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromSPDF_+3A_ncens">ncens</code></td>
<td>
<p>y-coordinates of interpolation grid in extended space</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromSPDF_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromSPDF_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of interpolated values
</p>


<h3>See Also</h3>

<p><a href="#topic+fftgrid">fftgrid</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a>
</p>

<hr>
<h2 id='fftinterpolate.fromXYZ'>interpolate.fromXYZ function</h2><span id='topic+fftinterpolate.fromXYZ'></span>

<h3>Description</h3>

<p>This method performs interpolation within the function <code>fftgrid</code> for <code>fromXYZ</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
fftinterpolate(spatial, mcens, ncens, ext, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftinterpolate.fromXYZ_+3A_spatial">spatial</code></td>
<td>
<p>objects of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromXYZ_+3A_mcens">mcens</code></td>
<td>
<p>x-coordinates of interpolation grid in extended space</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromXYZ_+3A_ncens">ncens</code></td>
<td>
<p>y-coordinates of interpolation grid in extended space</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromXYZ_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="fftinterpolate.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of interpolated values
</p>


<h3>See Also</h3>

<p><a href="#topic+fftgrid">fftgrid</a>, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>
</p>

<hr>
<h2 id='fftmultiply'>fftmultiply function</h2><span id='topic+fftmultiply'></span>

<h3>Description</h3>

<p>A function to pre-multiply a vector by a block cirulant matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftmultiply(efb, vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftmultiply_+3A_efb">efb</code></td>
<td>
<p>eigenvalues of the matrix</p>
</td></tr>
<tr><td><code id="fftmultiply_+3A_vector">vector</code></td>
<td>
<p>the vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector: the product of the matrix and the vector.
</p>

<hr>
<h2 id='formulaList'>formulaList function</h2><span id='topic+formulaList'></span>

<h3>Description</h3>

<p>A function to creat an object of class &quot;formulaList&quot; from a list of &quot;formula&quot; objects; use to define the model for the main effects
prior to running the multivariate MCMC algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formulaList(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formulaList_+3A_x">X</code></td>
<td>
<p>a list object, each element of which is a formula</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;formulaList&quot;
</p>

<hr>
<h2 id='GAfinalise'>GAfinalise function</h2><span id='topic+GAfinalise'></span>

<h3>Description</h3>

<p>Generic function defining the the finalisation step for the <code>gridAverage</code> class of functions.
The function is called invisibly within <code>MALAlgcp</code> and facilitates the computation of
Monte Carlo Averages online.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAfinalise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAfinalise_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GAfinalise_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method GAfinalise
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GAfinalise.MonteCarloAverage'>GAfinalise.MonteCarloAverage function</h2><span id='topic+GAfinalise.MonteCarloAverage'></span>

<h3>Description</h3>

<p>Finalise a Monte Carlo averaging scheme. Divide the sum by the number of iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MonteCarloAverage'
GAfinalise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAfinalise.MonteCarloAverage_+3A_f">F</code></td>
<td>
<p>an object of class MonteCarloAverage</p>
</td></tr>
<tr><td><code id="GAfinalise.MonteCarloAverage_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>computes Monte Carlo averages
</p>


<h3>See Also</h3>

<p><a href="#topic+MonteCarloAverage">MonteCarloAverage</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GAfinalise.nullAverage'>GAfinalise.nullAverage function</h2><span id='topic+GAfinalise.nullAverage'></span>

<h3>Description</h3>

<p>This is a null function and performs no action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nullAverage'
GAfinalise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAfinalise.nullAverage_+3A_f">F</code></td>
<td>
<p>an object of class nullAverage</p>
</td></tr>
<tr><td><code id="GAfinalise.nullAverage_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+nullAverage">nullAverage</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GAinitialise'>GAinitialise function</h2><span id='topic+GAinitialise'></span>

<h3>Description</h3>

<p>Generic function defining the the initialisation step for the <code>gridAverage</code> class of functions. 
The function is called invisibly within <code>MALAlgcp</code> and facilitates the computation of
Monte Carlo Averages online.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAinitialise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAinitialise_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GAinitialise_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method GAinitialise
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GAinitialise.MonteCarloAverage'>GAinitialise.MonteCarloAverage function</h2><span id='topic+GAinitialise.MonteCarloAverage'></span>

<h3>Description</h3>

<p>Initialise a Monte Carlo averaging scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MonteCarloAverage'
GAinitialise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAinitialise.MonteCarloAverage_+3A_f">F</code></td>
<td>
<p>an object of class MonteCarloAverage</p>
</td></tr>
<tr><td><code id="GAinitialise.MonteCarloAverage_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+MonteCarloAverage">MonteCarloAverage</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GAinitialise.nullAverage'>GAinitialise.nullAverage function</h2><span id='topic+GAinitialise.nullAverage'></span>

<h3>Description</h3>

<p>This is a null function and performs no action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nullAverage'
GAinitialise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAinitialise.nullAverage_+3A_f">F</code></td>
<td>
<p>an object of class nullAverage</p>
</td></tr>
<tr><td><code id="GAinitialise.nullAverage_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+nullAverage">nullAverage</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GammafromY'>GammafromY function</h2><span id='topic+GammafromY'></span>

<h3>Description</h3>

<p>A function to change Ys (spatially correlated noise) into Gammas (white noise). Used in the MALA algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GammafromY(Y, rootQeigs, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GammafromY_+3A_y">Y</code></td>
<td>
<p>Y matrix</p>
</td></tr>
<tr><td><code id="GammafromY_+3A_rootqeigs">rootQeigs</code></td>
<td>
<p>square root of the eigenvectors of the precision matrix</p>
</td></tr>
<tr><td><code id="GammafromY_+3A_mu">mu</code></td>
<td>
<p>parameter of the latent Gaussian field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gamma
</p>

<hr>
<h2 id='GAreturnvalue'>GAreturnvalue function</h2><span id='topic+GAreturnvalue'></span>

<h3>Description</h3>

<p>Generic function defining the the returned value for the <code>gridAverage</code> class of functions.
The function is called invisibly within <code>MALAlgcp</code> and facilitates the computation of
Monte Carlo Averages online.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAreturnvalue(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAreturnvalue_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GAreturnvalue_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method GAreturnvalue
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>
</p>

<hr>
<h2 id='GAreturnvalue.MonteCarloAverage'>GAreturnvalue.MonteCarloAverage function</h2><span id='topic+GAreturnvalue.MonteCarloAverage'></span>

<h3>Description</h3>

<p>Returns the required Monte Carlo average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MonteCarloAverage'
GAreturnvalue(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAreturnvalue.MonteCarloAverage_+3A_f">F</code></td>
<td>
<p>an object of class MonteCarloAverage</p>
</td></tr>
<tr><td><code id="GAreturnvalue.MonteCarloAverage_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results from MonteCarloAverage
</p>


<h3>See Also</h3>

<p><a href="#topic+MonteCarloAverage">MonteCarloAverage</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GAreturnvalue.nullAverage'>GAreturnvalue.nullAverage function##'</h2><span id='topic+GAreturnvalue.nullAverage'></span>

<h3>Description</h3>

<p>This is a null function and performs no action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nullAverage'
GAreturnvalue(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAreturnvalue.nullAverage_+3A_f">F</code></td>
<td>
<p>an object of class nullAverage</p>
</td></tr>
<tr><td><code id="GAreturnvalue.nullAverage_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+nullAverage">nullAverage</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GAupdate'>GAupdate function</h2><span id='topic+GAupdate'></span>

<h3>Description</h3>

<p>Generic function defining the the update step for the <code>gridAverage</code> class of functions.
The function is called invisibly within <code>MALAlgcp</code> and facilitates the computation of
Monte Carlo Averages online.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAupdate(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAupdate_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GAupdate_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method GAupdate
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GAupdate.MonteCarloAverage'>GAupdate.MonteCarloAverage function</h2><span id='topic+GAupdate.MonteCarloAverage'></span>

<h3>Description</h3>

<p>Update a Monte Carlo averaging scheme. This function performs the Monte Carlo sum online.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MonteCarloAverage'
GAupdate(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAupdate.MonteCarloAverage_+3A_f">F</code></td>
<td>
<p>an object of class MonteCarloAverage</p>
</td></tr>
<tr><td><code id="GAupdate.MonteCarloAverage_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updates Monte Carlo sums
</p>


<h3>See Also</h3>

<p><a href="#topic+MonteCarloAverage">MonteCarloAverage</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GAupdate.nullAverage'>GAupdate.nullAverage function</h2><span id='topic+GAupdate.nullAverage'></span>

<h3>Description</h3>

<p>This is a null function and performs no action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nullAverage'
GAupdate(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAupdate.nullAverage_+3A_f">F</code></td>
<td>
<p>an object of class nullAverage</p>
</td></tr>
<tr><td><code id="GAupdate.nullAverage_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+nullAverage">nullAverage</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='GaussianPrior'>GaussianPrior function</h2><span id='topic+GaussianPrior'></span>

<h3>Description</h3>

<p>A function to create a Gaussian prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussianPrior(mean, variance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussianPrior_+3A_mean">mean</code></td>
<td>
<p>a vector of length 2 representing the mean.</p>
</td></tr>
<tr><td><code id="GaussianPrior_+3A_variance">variance</code></td>
<td>
<p>a 2x2 matrix representing the variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class LogGaussianPrior that can be passed to the function PriorSpec.
</p>


<h3>See Also</h3>

<p><a href="#topic+LogGaussianPrior">LogGaussianPrior</a>, linkPriorSpec.list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: GaussianPrior(mean=rep(0,9),variance=diag(10^6,9))
</code></pre>

<hr>
<h2 id='gDisjoint_wg'>gDisjoint_wg function</h2><span id='topic+gDisjoint_wg'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gDisjoint_wg(w, gri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gDisjoint_wg_+3A_w">w</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="gDisjoint_wg_+3A_gri">gri</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='genFFTgrid'>genFFTgrid function</h2><span id='topic+genFFTgrid'></span>

<h3>Description</h3>

<p>A function to generate an FFT grid and associated quantities including cell dimensions,
size of extended grid, centroids, cell area, cellInside matrix (a 0/1 matrix: is the centroid of the cell inside the observation window?)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genFFTgrid(study.region, M, N, ext, inclusion = "touching")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genFFTgrid_+3A_study.region">study.region</code></td>
<td>
<p>an owin object</p>
</td></tr>
<tr><td><code id="genFFTgrid_+3A_m">M</code></td>
<td>
<p>number of cells in x direction</p>
</td></tr>
<tr><td><code id="genFFTgrid_+3A_n">N</code></td>
<td>
<p>number of cells in y direction</p>
</td></tr>
<tr><td><code id="genFFTgrid_+3A_ext">ext</code></td>
<td>
<p>multiplying constant: the size of the extended grid: ext*M by ext*N</p>
</td></tr>
<tr><td><code id="genFFTgrid_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list
</p>

<hr>
<h2 id='getCellCounts'>getCellCounts function</h2><span id='topic+getCellCounts'></span>

<h3>Description</h3>

<p>This function is used to count the number of observations falling inside grid cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCellCounts(x, y, xgrid, ygrid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCellCounts_+3A_x">x</code></td>
<td>
<p>x-coordinates of events</p>
</td></tr>
<tr><td><code id="getCellCounts_+3A_y">y</code></td>
<td>
<p>y-coordinates of events</p>
</td></tr>
<tr><td><code id="getCellCounts_+3A_xgrid">xgrid</code></td>
<td>
<p>x-coordinates of grid centroids</p>
</td></tr>
<tr><td><code id="getCellCounts_+3A_ygrid">ygrid</code></td>
<td>
<p>y-coordinates of grid centroids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of observations in each grid cell.
</p>

<hr>
<h2 id='getCounts'>getCounts function</h2><span id='topic+getCounts'></span>

<h3>Description</h3>

<p>This function is used to count the number of observations falling inside grid cells, the output
is used in the function <a href="#topic+lgcpPredict">lgcpPredict</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCounts(xyt, subset = rep(TRUE, xyt$n), M, N, ext)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCounts_+3A_xyt">xyt</code></td>
<td>
<p>stppp or ppp data object</p>
</td></tr>
<tr><td><code id="getCounts_+3A_subset">subset</code></td>
<td>
<p>Logical vector. Subset of data of interest, by default this is all data.</p>
</td></tr>
<tr><td><code id="getCounts_+3A_m">M</code></td>
<td>
<p>number of centroids in x-direction</p>
</td></tr>
<tr><td><code id="getCounts_+3A_n">N</code></td>
<td>
<p>number of cnetroids in y-direction</p>
</td></tr>
<tr><td><code id="getCounts_+3A_ext">ext</code></td>
<td>
<p>how far to extend the grid eg (M,N) to (ext*M,ext*N)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of observations in each grid cell returned on a grid suitable for use in the extended FFT space.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spatstat.explore)
xyt &lt;- stppp(ppp(runif(100),runif(100)),t=1:100,tlim=c(1,100))
cts &lt;- getCounts(xyt,M=64,N=64,ext=2) # gives an output grid of size 128 by 128
ctssub &lt;- cts[1:64,1:64] # returns the cell counts in the observation
                         # window of interest
</code></pre>

<hr>
<h2 id='getCovParameters'>getCovParameters function</h2><span id='topic+getCovParameters'></span>

<h3>Description</h3>

<p>Internal function for retrieving covariance parameters. not indended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCovParameters(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovParameters_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="getCovParameters_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method getCovParameters
</p>

<hr>
<h2 id='getCovParameters.GPrealisation'>getCovParameters.GPrealisation function</h2><span id='topic+getCovParameters.GPrealisation'></span>

<h3>Description</h3>

<p>Internal function for retrieving covariance parameters. not indended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GPrealisation'
getCovParameters(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovParameters.GPrealisation_+3A_obj">obj</code></td>
<td>
<p>an GPrealisation object</p>
</td></tr>
<tr><td><code id="getCovParameters.GPrealisation_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='getCovParameters.list'>getCovParameters.list function</h2><span id='topic+getCovParameters.list'></span>

<h3>Description</h3>

<p>Internal function for retrieving covariance parameters. not indended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
getCovParameters(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCovParameters.list_+3A_obj">obj</code></td>
<td>
<p>an list object</p>
</td></tr>
<tr><td><code id="getCovParameters.list_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='getinterp'>getinterp function</h2><span id='topic+getinterp'></span>

<h3>Description</h3>

<p>A function to get the interpolation methods from a data frame<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getinterp(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getinterp_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three types of interpolation method employed in the package lgcp are:<br />
</p>

<ol>
<li><p> 'Majority' The interpolated value corresponds to the value of the covariate occupying
the largest area of the computational cell.
</p>
</li>
<li><p> 'ArealWeightedMean' The interpolated value corresponds to the mean of all covariate
values contributing to the computational cell weighted by their respective areas.
</p>
</li>
<li><p> 'ArealWeightedSum' The interpolated value is the sum of all contributing covariates
weighed by the proportion of area with respect to the covariate polygons. For example,
suppose region A has the same area as a computational grid cell and has 500 inhabitants.
If that region occupies half of a computational grid cell, then this interpolation type assigns
250 inhabitants from A to the computational grid cell.
</p>
</li></ol>



<h3>Value</h3>

<p>the interpolation methods
</p>

<hr>
<h2 id='getlgcpPredictSpatialINLA'>getlgcpPredictSpatialINLA function</h2><span id='topic+getlgcpPredictSpatialINLA'></span>

<h3>Description</h3>

<p>A function to download and 'install' lgcpPredictSpatialINLA into the lgcp namespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getlgcpPredictSpatialINLA()
</code></pre>


<h3>Value</h3>

<p>Does not return anything
</p>

<hr>
<h2 id='getLHSformulaList'>getLHSformulaList function</h2><span id='topic+getLHSformulaList'></span>

<h3>Description</h3>

<p>A function to retrieve the dependent variables from a formulaList object. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLHSformulaList(fl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLHSformulaList_+3A_fl">fl</code></td>
<td>
<p>an object of class &quot;formulaList&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the indepentdent variables
</p>

<hr>
<h2 id='getpolyol'>getpolyol function</h2><span id='topic+getpolyol'></span>

<h3>Description</h3>

<p>A function to perform polygon/polygon overlay operations and form the computational grid, on which inference will eventually take place.
For details and examples of using this fucntion, please see the package vignette &quot;Bayesian_lgcp&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getpolyol(
  data,
  regionalcovariates = NULL,
  pixelcovariates = NULL,
  cellwidth,
  ext = 2,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getpolyol_+3A_data">data</code></td>
<td>
<p>an object of class ppp or SpatialPolygonsDataFrame, containing the event counts, i.e. the dataset that will eventually be analysed</p>
</td></tr>
<tr><td><code id="getpolyol_+3A_regionalcovariates">regionalcovariates</code></td>
<td>
<p>an object of class SpatialPolygonsDataFrame containng regionally measured covariate information</p>
</td></tr>
<tr><td><code id="getpolyol_+3A_pixelcovariates">pixelcovariates</code></td>
<td>
<p>X an object of class SpatialPixelsDataFrame containng regionally measured covariate information</p>
</td></tr>
<tr><td><code id="getpolyol_+3A_cellwidth">cellwidth</code></td>
<td>
<p>the chosen cell width</p>
</td></tr>
<tr><td><code id="getpolyol_+3A_ext">ext</code></td>
<td>
<p>the amount by which to extend the observation window in forming the FFT grid, default is 2. In the case that the point pattern has long range spatial correlation, this may need to be increased.</p>
</td></tr>
<tr><td><code id="getpolyol_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former, the default, includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class lgcppolyol, which can then be fed into the function getZmat.
</p>


<h3>See Also</h3>

<p><a href="#topic+chooseCellwidth">chooseCellwidth</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>
</p>

<hr>
<h2 id='getRotation'>getRotation function</h2><span id='topic+getRotation'></span>

<h3>Description</h3>

<p>Generic function for the computation of rotation matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRotation(xyt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRotation_+3A_xyt">xyt</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="getRotation_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method getRotation
</p>


<h3>See Also</h3>

<p><a href="#topic+getRotation.stppp">getRotation.stppp</a>
</p>

<hr>
<h2 id='getRotation.default'>getRotation.default function</h2><span id='topic+getRotation.default'></span>

<h3>Description</h3>

<p>Presently there is no default method, see ?getRotation.stppp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
getRotation(xyt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRotation.default_+3A_xyt">xyt</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="getRotation.default_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>currently no default implementation
</p>


<h3>See Also</h3>

<p><a href="#topic+getRotation.stppp">getRotation.stppp</a>
</p>

<hr>
<h2 id='getRotation.stppp'>getRotation.stppp function</h2><span id='topic+getRotation.stppp'></span>

<h3>Description</h3>

<p>Compute  rotation matrix if observation window is a polygonal boundary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
getRotation(xyt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRotation.stppp_+3A_xyt">xyt</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="getRotation.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the optimal rotation matrix and rotated data and observation window. Note it may or may not be advantageous to rotate the window, this information is displayed prior to the MALA routine when using lgcpPredict
</p>

<hr>
<h2 id='getup'>getup function</h2><span id='topic+getup'></span>

<h3>Description</h3>

<p>A function to get an object from a parent frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getup(n, lev = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getup_+3A_n">n</code></td>
<td>
<p>a character string, the name of the object</p>
</td></tr>
<tr><td><code id="getup_+3A_lev">lev</code></td>
<td>
<p>how many levels up the hierarchy to go (see the argument &quot;envir&quot; from the function &quot;get&quot;), default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='getZmat'>getZmat function</h2><span id='topic+getZmat'></span>

<h3>Description</h3>

<p>A function to construct a design matrix for use with the Bayesian MCMC routines in lgcp. See the vignette &quot;Bayesian_lgcp&quot; for further details on
how to use this function.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getZmat(
  formula,
  data,
  regionalcovariates = NULL,
  pixelcovariates = NULL,
  cellwidth,
  ext = 2,
  inclusion = "touching",
  overl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getZmat_+3A_formula">formula</code></td>
<td>
<p>a formula object of the form X ~ var1 + var2 etc. The name of the dependent variable must be &quot;X&quot;. Only accepts 'simple' formulae, such as the example given.</p>
</td></tr>
<tr><td><code id="getZmat_+3A_data">data</code></td>
<td>
<p>the data to be analysed (using, for example lgcpPredictSpatialPlusPars). Either an object of class ppp, or an object of class SpatialPolygonsDataFrame</p>
</td></tr>
<tr><td><code id="getZmat_+3A_regionalcovariates">regionalcovariates</code></td>
<td>
<p>an optional SpatialPolygonsDataFrame object containing covariate information, if applicable</p>
</td></tr>
<tr><td><code id="getZmat_+3A_pixelcovariates">pixelcovariates</code></td>
<td>
<p>an optional SpatialPixelsDataFrame object containing covariate information, if applicable</p>
</td></tr>
<tr><td><code id="getZmat_+3A_cellwidth">cellwidth</code></td>
<td>
<p>the width of computational cells</p>
</td></tr>
<tr><td><code id="getZmat_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="getZmat_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former, the default, includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
<tr><td><code id="getZmat_+3A_overl">overl</code></td>
<td>
<p>an object of class &quot;lgcppolyol&quot;, created by the function getpolyol. Such an object contains the FFT grid and a polygon/polygon overlay and speeds up computation massively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, a spatial LGCP model for the would have the form:<br />
<br />
X(s) ~ Poisson[R(s)]<br />
<br />
R(s) = C_A lambda(s) exp[Z(s)beta+Y(s)]<br />
<br />
</p>
<p>The function getZmat helps create the matrix Z. The returned object is passed onto an MCMC function, for example lgcpPredictSpatialPlusPars or
lgcpPredictAggregateSpatialPlusPars. This function can also be used to help construct Z for use with lgcpPredictSpatioTemporalPlusPars and
lgcpPredictMultitypeSpatialPlusPars, but these functions require a list of such objects: see the vignette &quot;Bayesian_lgcp&quot; for examples.
</p>


<h3>Value</h3>

<p>a design matrix for passing on to the Bayesian MCMC functions
</p>


<h3>See Also</h3>

<p><a href="#topic+chooseCellwidth">chooseCellwidth</a>, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>
</p>

<hr>
<h2 id='getZmats'>getZmats function</h2><span id='topic+getZmats'></span>

<h3>Description</h3>

<p>An internal function to create Z_k from an lgcpZmat object, for use in the multivariate MCMC algorithm. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getZmats(Zmat, formulaList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getZmats_+3A_zmat">Zmat</code></td>
<td>
<p>an objecty of class &quot;lgcpZmat&quot;</p>
</td></tr>
<tr><td><code id="getZmats_+3A_formulalist">formulaList</code></td>
<td>
<p>an object of class &quot;formulaList&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>design matrices for each of the point types
</p>

<hr>
<h2 id='GFfinalise'>GFfinalise function</h2><span id='topic+GFfinalise'></span>

<h3>Description</h3>

<p>Generic function defining the the finalisation step for the <code>gridFunction</code> class of objects. 
The function is called invisibly within <code>MALAlgcp</code> and facilitates the dumping of data to disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFfinalise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFfinalise_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GFfinalise_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method GFfinalise
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFfinalise.dump2dir'>GFfinalise.dump2dir function</h2><span id='topic+GFfinalise.dump2dir'></span>

<h3>Description</h3>

<p>This function finalises the dumping of data to a netCDF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dump2dir'
GFfinalise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFfinalise.dump2dir_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GFfinalise.dump2dir_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+dump2dir">dump2dir</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFfinalise.nullFunction'>GFfinalise.nullFunction function</h2><span id='topic+GFfinalise.nullFunction'></span>

<h3>Description</h3>

<p>This is a null function and performs no action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nullFunction'
GFfinalise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFfinalise.nullFunction_+3A_f">F</code></td>
<td>
<p>an object of class dump2dir</p>
</td></tr>
<tr><td><code id="GFfinalise.nullFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+nullFunction">nullFunction</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFinitialise'>GFinitialise function</h2><span id='topic+GFinitialise'></span>

<h3>Description</h3>

<p>Generic function defining the the initialisation step for the <code>gridFunction</code> class of objects. 
The function is called invisibly within <code>MALAlgcp</code> and facilitates the dumping of data to disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFinitialise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFinitialise_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GFinitialise_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method GFinitialise
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFinitialise.dump2dir'>GFinitialise.dump2dir function</h2><span id='topic+GFinitialise.dump2dir'></span>

<h3>Description</h3>

<p>Creates a directory (if necessary) and allocates space for a netCDF dump.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dump2dir'
GFinitialise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFinitialise.dump2dir_+3A_f">F</code></td>
<td>
<p>an object of class dump2dir</p>
</td></tr>
<tr><td><code id="GFinitialise.dump2dir_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>creates initialisation file and folder
</p>


<h3>See Also</h3>

<p><a href="#topic+dump2dir">dump2dir</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFinitialise.nullFunction'>GFinitialise.nullFunction function</h2><span id='topic+GFinitialise.nullFunction'></span>

<h3>Description</h3>

<p>This is a null function and performs no action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nullFunction'
GFinitialise(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFinitialise.nullFunction_+3A_f">F</code></td>
<td>
<p>an object of class dump2dir</p>
</td></tr>
<tr><td><code id="GFinitialise.nullFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+nullFunction">nullFunction</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFreturnvalue'>GFreturnvalue function</h2><span id='topic+GFreturnvalue'></span>

<h3>Description</h3>

<p>Generic function defining the the returned value for the <code>gridFunction</code> class of objects. 
The function is called invisibly within <code>MALAlgcp</code> and facilitates the dumping of data to disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFreturnvalue(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFreturnvalue_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GFreturnvalue_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method GFreturnvalue
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>
</p>

<hr>
<h2 id='GFreturnvalue.dump2dir'>GFreturnvalue.dump2dir function</h2><span id='topic+GFreturnvalue.dump2dir'></span>

<h3>Description</h3>

<p>This function returns the name of the directory the netCDF file was written to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dump2dir'
GFreturnvalue(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFreturnvalue.dump2dir_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GFreturnvalue.dump2dir_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>display where files have been written to
</p>


<h3>See Also</h3>

<p><a href="#topic+dump2dir">dump2dir</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFreturnvalue.nullFunction'>GFreturnvalue.nullFunction function</h2><span id='topic+GFreturnvalue.nullFunction'></span>

<h3>Description</h3>

<p>This is a null function and performs no action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nullFunction'
GFreturnvalue(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFreturnvalue.nullFunction_+3A_f">F</code></td>
<td>
<p>an object of class dump2dir</p>
</td></tr>
<tr><td><code id="GFreturnvalue.nullFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+nullFunction">nullFunction</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFupdate'>GFupdate function</h2><span id='topic+GFupdate'></span>

<h3>Description</h3>

<p>Generic function defining the the update step for the <code>gridFunction</code> class of objects. 
The function is called invisibly within <code>MALAlgcp</code> and facilitates the dumping of data to disk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFupdate(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFupdate_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GFupdate_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method GFupdate
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFupdate.dump2dir'>GFupdate.dump2dir function</h2><span id='topic+GFupdate.dump2dir'></span>

<h3>Description</h3>

<p>This function gets the required information from <code>MALAlgcp</code> and writes the data to the netCDF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dump2dir'
GFupdate(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFupdate.dump2dir_+3A_f">F</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="GFupdate.dump2dir_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>saves latent field
</p>


<h3>See Also</h3>

<p><a href="#topic+dump2dir">dump2dir</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='GFupdate.nullFunction'>GFupdate.nullFunction function</h2><span id='topic+GFupdate.nullFunction'></span>

<h3>Description</h3>

<p>This is a null function and performs no action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nullFunction'
GFupdate(F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFupdate.nullFunction_+3A_f">F</code></td>
<td>
<p>an object of class dump2dir</p>
</td></tr>
<tr><td><code id="GFupdate.nullFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+nullFunction">nullFunction</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='ginhomAverage'>ginhomAverage function</h2><span id='topic+ginhomAverage'></span>

<h3>Description</h3>

<p>A function to estimate the inhomogeneous pair correlation function for a spatiotemporal point process. See equation (8) of Diggle P, Rowlingson B, Su T (2005).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ginhomAverage(
  xyt,
  spatial.intensity,
  temporal.intensity,
  time.window = xyt$tlim,
  rvals = NULL,
  correction = "iso",
  suppresswarnings = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ginhomAverage_+3A_xyt">xyt</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="ginhomAverage_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>A spatialAtRisk object</p>
</td></tr>
<tr><td><code id="ginhomAverage_+3A_temporal.intensity">temporal.intensity</code></td>
<td>
<p>A temporalAtRisk object</p>
</td></tr>
<tr><td><code id="ginhomAverage_+3A_time.window">time.window</code></td>
<td>
<p>time interval contained in the interval xyt$tlim over which to compute average. Useful if there is a lot of data over a lot of time points.</p>
</td></tr>
<tr><td><code id="ginhomAverage_+3A_rvals">rvals</code></td>
<td>
<p>Vector of values for the argument r at which g(r) should be evaluated (see ?pcfinhom). There is a sensible default.</p>
</td></tr>
<tr><td><code id="ginhomAverage_+3A_correction">correction</code></td>
<td>
<p>choice of edge correction to use, see ?pcfinhom, default is Ripley isotropic correction</p>
</td></tr>
<tr><td><code id="ginhomAverage_+3A_suppresswarnings">suppresswarnings</code></td>
<td>
<p>Whether or not to suppress warnings generated by pcfinhom</p>
</td></tr>
<tr><td><code id="ginhomAverage_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to pcfinhom, see ?pcfinhom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time average of inhomogenous pcf, equation (13) of Brix and Diggle 2001.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Baddeley AJ, Moller J, Waagepetersen R (2000). Non-and semi-parametric estimation of interaction in inhomogeneous point patterns. Statistica Neerlandica, 54, 329-350.
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+thetaEst">thetaEst</a>, <a href="#topic+lambdaEst">lambdaEst</a>, <a href="#topic+muEst">muEst</a>
</p>

<hr>
<h2 id='gIntersects_pg'>gIntersects_pg function</h2><span id='topic+gIntersects_pg'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gIntersects_pg(spdf, grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gIntersects_pg_+3A_spdf">spdf</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="gIntersects_pg_+3A_grid">grid</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='gOverlay'>gOverlay function</h2><span id='topic+gOverlay'></span>

<h3>Description</h3>

<p>A function to overlay the FFT grid, a SpatialPolygons object, onto a SpatialPolygonsDataFrame object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gOverlay(grid, spdf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gOverlay_+3A_grid">grid</code></td>
<td>
<p>the FFT grid, a SpatialPolygons object</p>
</td></tr>
<tr><td><code id="gOverlay_+3A_spdf">spdf</code></td>
<td>
<p>a SpatialPolygonsDataFrame object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this code was adapted from Roger Bivand:<br />
https://stat.ethz.ch/pipermail/r-sig-geo/2011-June/012099.html
</p>


<h3>Value</h3>

<p>a matrix describing the features of the overlay: the originating indices of grid and spdf (all non-trivial intersections) and the area of each intersection.
</p>

<hr>
<h2 id='GPdrv'>GPdrv function</h2><span id='topic+GPdrv'></span>

<h3>Description</h3>

<p>A function to compute the first derivatives of the log target with respect to the paramters of the latent field. Not intended for general purpose use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPdrv(
  GP,
  prior,
  Z,
  Zt,
  eta,
  beta,
  nis,
  cellarea,
  spatial,
  gradtrunc,
  fftgrid,
  covfunction,
  d,
  eps = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPdrv_+3A_gp">GP</code></td>
<td>
<p>an object of class GPrealisation</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_prior">prior</code></td>
<td>
<p>priors for the model</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_z">Z</code></td>
<td>
<p>design matirix on the FFT grid</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_zt">Zt</code></td>
<td>
<p>transpose of the design matrix</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_eta">eta</code></td>
<td>
<p>vector of parameters, eta</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_beta">beta</code></td>
<td>
<p>vector of parameters, beta</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_nis">nis</code></td>
<td>
<p>cell counts on the extended grid</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_spatial">spatial</code></td>
<td>
<p>the poisson offset</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_fftgrid">fftgrid</code></td>
<td>
<p>an object of class FFTgrid</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_covfunction">covfunction</code></td>
<td>
<p>the choice of covariance function, see ?CovFunction</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_d">d</code></td>
<td>
<p>matrix of toral distances</p>
</td></tr>
<tr><td><code id="GPdrv_+3A_eps">eps</code></td>
<td>
<p>the finite difference step size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>first  derivatives of the log target at the specified paramters Y, eta and beta
</p>

<hr>
<h2 id='GPdrv2'>GPdrv2 function</h2><span id='topic+GPdrv2'></span>

<h3>Description</h3>

<p>A function to compute the second derivative of the log target with respect to the paramters of the latent field. Not intended for general purpose use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPdrv2(
  GP,
  prior,
  Z,
  Zt,
  eta,
  beta,
  nis,
  cellarea,
  spatial,
  gradtrunc,
  fftgrid,
  covfunction,
  d,
  eps = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPdrv2_+3A_gp">GP</code></td>
<td>
<p>an object of class GPrealisation</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_prior">prior</code></td>
<td>
<p>priors for the model</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_z">Z</code></td>
<td>
<p>design matirix on the FFT grid</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_zt">Zt</code></td>
<td>
<p>transpose of the design matrix</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_eta">eta</code></td>
<td>
<p>vector of parameters, eta</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_beta">beta</code></td>
<td>
<p>vector of parameters, beta</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_nis">nis</code></td>
<td>
<p>cell counts on the extended grid</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_spatial">spatial</code></td>
<td>
<p>the poisson offset</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_fftgrid">fftgrid</code></td>
<td>
<p>an object of class FFTgrid</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_covfunction">covfunction</code></td>
<td>
<p>the choice of covariance function, see ?CovFunction</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_d">d</code></td>
<td>
<p>matrix of toral distances</p>
</td></tr>
<tr><td><code id="GPdrv2_+3A_eps">eps</code></td>
<td>
<p>the finite difference step size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>first and second derivatives of the log target at the specified paramters Y, eta and beta
</p>

<hr>
<h2 id='GPdrv2_Multitype'>GPdrv2_Multitype function</h2><span id='topic+GPdrv2_Multitype'></span>

<h3>Description</h3>

<p>A function to compute the second derivatives of the log target for the multivariate model with respect to the paramters of the latent field. Not intended for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPdrv2_Multitype(
  GPlist,
  priorlist,
  Zlist,
  Ztlist,
  etalist,
  betalist,
  nis,
  cellarea,
  spatial,
  gradtrunc,
  fftgrid,
  covfunction,
  d,
  eps = 1e-06,
  k
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPdrv2_Multitype_+3A_gplist">GPlist</code></td>
<td>
<p>a list of objects of class GPrealisation</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_priorlist">priorlist</code></td>
<td>
<p>list of priors for the model</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_zlist">Zlist</code></td>
<td>
<p>list of design matirices on the FFT grid</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_ztlist">Ztlist</code></td>
<td>
<p>list of transpose design matrices</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_etalist">etalist</code></td>
<td>
<p>list of parameters, eta, for each realisation</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_betalist">betalist</code></td>
<td>
<p>clist of parameters, beta, for each realisation</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_nis">nis</code></td>
<td>
<p>cell counts of each type the extended grid</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_spatial">spatial</code></td>
<td>
<p>list of poisson offsets for each type</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_fftgrid">fftgrid</code></td>
<td>
<p>an object of class FFTgrid</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_covfunction">covfunction</code></td>
<td>
<p>list giving the choice of covariance function for each type, see ?CovFunction</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_d">d</code></td>
<td>
<p>matrix of toral distances</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_eps">eps</code></td>
<td>
<p>the finite difference step size</p>
</td></tr>
<tr><td><code id="GPdrv2_Multitype_+3A_k">k</code></td>
<td>
<p>index of type for which to compute the gradient and hessian</p>
</td></tr>
</table>


<h3>Value</h3>

<p>first and second derivatives of the log target  for tyupe k at the specified paramters Y, eta and beta
</p>

<hr>
<h2 id='GPlist2array'>GPlist2array function</h2><span id='topic+GPlist2array'></span>

<h3>Description</h3>

<p>An internal function for turning a list of GPrealisation objects into an an array by a particular common element of the GPrealisation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPlist2array(GPlist, element)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPlist2array_+3A_gplist">GPlist</code></td>
<td>
<p>an object of class GPrealisation</p>
</td></tr>
<tr><td><code id="GPlist2array_+3A_element">element</code></td>
<td>
<p>the name of the element of GPlist[[1]] (for example) to extract, e.g. &quot;Y&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array
</p>

<hr>
<h2 id='GPrealisation'>GPrealisation function</h2><span id='topic+GPrealisation'></span>

<h3>Description</h3>

<p>A function to store a realisation of a spatial gaussian process for use in MCMC algorithms that include Bayesian parameter estimation.
Stores not only the realisation, but also computational quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPrealisation(gamma, fftgrid, covFunction, covParameters, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPrealisation_+3A_gamma">gamma</code></td>
<td>
<p>the transformed (white noise) realisation of the process</p>
</td></tr>
<tr><td><code id="GPrealisation_+3A_fftgrid">fftgrid</code></td>
<td>
<p>an object of class FFTgrid, see ?genFFTgrid</p>
</td></tr>
<tr><td><code id="GPrealisation_+3A_covfunction">covFunction</code></td>
<td>
<p>an object of class function returning the spatial covariance</p>
</td></tr>
<tr><td><code id="GPrealisation_+3A_covparameters">covParameters</code></td>
<td>
<p>an object of class CovParamaters, see ?CovParamaters</p>
</td></tr>
<tr><td><code id="GPrealisation_+3A_d">d</code></td>
<td>
<p>matrix of grid distances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a realisation of a spatial Gaussian process on a regular grid
</p>

<hr>
<h2 id='grid2spdf'>grid2spdf function</h2><span id='topic+grid2spdf'></span>

<h3>Description</h3>

<p>A function to convert a regular (x,y) grid of centroids into a SpatialPoints object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2spdf(xgrid, ygrid, proj4string = CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid2spdf_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spdf_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spdf_+3A_proj4string">proj4string</code></td>
<td>
<p>an optional proj4string, projection string for the grid, set using the function CRS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPolygonsDataFrame
</p>

<hr>
<h2 id='grid2spix'>grid2spix function</h2><span id='topic+grid2spix'></span>

<h3>Description</h3>

<p>A function to convert a regular (x,y) grid of centroids into a SpatialPixels object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2spix(xgrid, ygrid, proj4string = CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid2spix_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spix_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spix_+3A_proj4string">proj4string</code></td>
<td>
<p>an optional proj4string, projection string for the grid, set using the function CRS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPixels object
</p>

<hr>
<h2 id='grid2spoly'>grid2spoly function</h2><span id='topic+grid2spoly'></span>

<h3>Description</h3>

<p>A function to convert a regular (x,y) grid of centroids into a SpatialPolygons object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2spoly(xgrid, ygrid, proj4string = CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid2spoly_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spoly_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spoly_+3A_proj4string">proj4string</code></td>
<td>
<p>proj 4 string: specify in the usual way</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPolygons object
</p>

<hr>
<h2 id='grid2spts'>grid2spts function</h2><span id='topic+grid2spts'></span>

<h3>Description</h3>

<p>A function to convert a regular (x,y) grid of centroids into a SpatialPoints object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2spts(xgrid, ygrid, proj4string = CRS(as.character(NA)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid2spts_+3A_xgrid">xgrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spts_+3A_ygrid">ygrid</code></td>
<td>
<p>vector of x centroids (equally spaced)</p>
</td></tr>
<tr><td><code id="grid2spts_+3A_proj4string">proj4string</code></td>
<td>
<p>an optional proj4string, projection string for the grid, set using the function CRS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SpatialPoints object
</p>

<hr>
<h2 id='gridav'>gridav function</h2><span id='topic+gridav'></span>

<h3>Description</h3>

<p>A generic function for returning <code>gridmeans</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridav(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridav_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="gridav_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method gridav
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+lgcpgrid">lgcpgrid</a>
</p>

<hr>
<h2 id='gridav.lgcpPredict'>gridav.lgcpPredict function</h2><span id='topic+gridav.lgcpPredict'></span>

<h3>Description</h3>

<p>Accessor function for <code>lgcpPredict objects</code>: returns the <code>gridmeans</code> argument
set in the <code>output.control</code> argument of the function <code>lgcpPredict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
gridav(obj, fun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridav.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="gridav.lgcpPredict_+3A_fun">fun</code></td>
<td>
<p>an optional character vector of length 1 giving the name of a function to return Monte Carlo average of</p>
</td></tr>
<tr><td><code id="gridav.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the output from the gridmeans option of the setoutput argument of lgcpPredict
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+lgcpgrid">lgcpgrid</a>
</p>

<hr>
<h2 id='gridfun'>gridfun function</h2><span id='topic+gridfun'></span>

<h3>Description</h3>

<p>A generic function for returning <code>gridfunction</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridfun(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridfun_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="gridfun_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method gridfun
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+lgcpgrid">lgcpgrid</a>
</p>

<hr>
<h2 id='gridfun.lgcpPredict'>gridfun.lgcpPredict function</h2><span id='topic+gridfun.lgcpPredict'></span>

<h3>Description</h3>

<p>Accessor function for <code>lgcpPredict objects</code>: returns the <code>gridfunction</code> argument
set in the <code>output.control</code> argument of the function <code>lgcpPredict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
gridfun(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridfun.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="gridfun.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the output from the gridfunction option of the setoutput argument of lgcpPredict
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+lgcpgrid">lgcpgrid</a>
</p>

<hr>
<h2 id='gridInWindow'>gridInWindow function</h2><span id='topic+gridInWindow'></span>

<h3>Description</h3>

<p>For the grid defined by x-coordinates, xvals, and y-coordinates, yvals, and an owin object W, this function just returns
a logical matrix M, whose [i,j] entry is TRUE if the point(xvals[i], yvals[j]) is inside the observation window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridInWindow(xvals, yvals, win, inclusion = "touching")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridInWindow_+3A_xvals">xvals</code></td>
<td>
<p>x coordinates</p>
</td></tr>
<tr><td><code id="gridInWindow_+3A_yvals">yvals</code></td>
<td>
<p>y coordinates</p>
</td></tr>
<tr><td><code id="gridInWindow_+3A_win">win</code></td>
<td>
<p>owin object</p>
</td></tr>
<tr><td><code id="gridInWindow_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of TRUE/FALSE, which elements of the grid are inside the observation window win
</p>

<hr>
<h2 id='gTouches_wg'>gTouches_wg function</h2><span id='topic+gTouches_wg'></span>

<h3>Description</h3>

<p>A function to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gTouches_wg(w, gri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gTouches_wg_+3A_w">w</code></td>
<td>
<p>X</p>
</td></tr>
<tr><td><code id="gTouches_wg_+3A_gri">gri</code></td>
<td>
<p>X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='gu'>gu function</h2><span id='topic+gu'></span>

<h3>Description</h3>

<p>gu function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gu(u, sigma, phi, model, additionalparameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gu_+3A_u">u</code></td>
<td>
<p>distance</p>
</td></tr>
<tr><td><code id="gu_+3A_sigma">sigma</code></td>
<td>
<p>variance parameter, see Brix and Diggle (2001)</p>
</td></tr>
<tr><td><code id="gu_+3A_phi">phi</code></td>
<td>
<p>scale parameter, see Brix and Diggle (2001)</p>
</td></tr>
<tr><td><code id="gu_+3A_model">model</code></td>
<td>
<p>correlation type, see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="gu_+3A_additionalparameters">additionalparameters</code></td>
<td>
<p>vector of additional parameters for certain classes of covariance function (eg Matern), these must be supplied in the order given in ?CovarianceFct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>this is just a wrapper for CovarianceFct
</p>

<hr>
<h2 id='guessinterp'>guessinterp function</h2><span id='topic+guessinterp'></span>

<h3>Description</h3>

<p>A function to guess provisional interpolational methods to variables in a data frame. Numeric variables are assigned
interpolation by areal weighted mean (see below); factor, character and other types of variable are assigned
interpolation by majority vote (see below). Not that the interpolation type ArealWeightedSum is not assigned automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guessinterp(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guessinterp_+3A_df">df</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three types of interpolation method employed in the package lgcp are:<br />
</p>

<ol>
<li><p> 'Majority' The interpolated value corresponds to the value of the covariate occupying
the largest area of the computational cell.
</p>
</li>
<li><p> 'ArealWeightedMean' The interpolated value corresponds to the mean of all covariate
values contributing to the computational cell weighted by their respective areas.
</p>
</li>
<li><p> 'ArealWeightedSum' The interpolated value is the sum of all contributing covariates
weighed by the proportion of area with respect to the covariate polygons. For example,
suppose region A has the same area as a computational grid cell and has 500 inhabitants.
If that region occupies half of a computational grid cell, then this interpolation type assigns
250 inhabitants from A to the computational grid cell.
</p>
</li></ol>



<h3>Value</h3>

<p>the data frame, but with attributes describing the interpolation method for each variable
</p>


<h3>See Also</h3>

<p><a href="#topic+chooseCellwidth">chooseCellwidth</a>, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: spdf a SpatialPolygonsDataFrame
## Not run: spdf@data &lt;- guessinterp(spdf@data)
</code></pre>

<hr>
<h2 id='hasNext'>generic hasNext method</h2><span id='topic+hasNext'></span>

<h3>Description</h3>

<p>test if an iterator has any more values to go
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasNext(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasNext_+3A_obj">obj</code></td>
<td>
<p>an iterator</p>
</td></tr>
</table>

<hr>
<h2 id='hasNext.iter'>hasNext.iter function</h2><span id='topic+hasNext.iter'></span>

<h3>Description</h3>

<p>method for iter objects
test if an iterator has any more values to go
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iter'
hasNext(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasNext.iter_+3A_obj">obj</code></td>
<td>
<p>an iterator</p>
</td></tr>
</table>

<hr>
<h2 id='hvals'>hvals function</h2><span id='topic+hvals'></span>

<h3>Description</h3>

<p>Generic function to return the values of the proposal scaling <code class="reqn">h</code> in the MCMC algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hvals_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="hvals_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method hvals
</p>

<hr>
<h2 id='hvals.lgcpPredict'>hvals.lgcpPredict function</h2><span id='topic+hvals.lgcpPredict'></span>

<h3>Description</h3>

<p>Accessor function returning the value of <code class="reqn">h</code>, the MALA proposal scaling constant over the iterations of the algorithm for
objects of class <code>lgcpPredict</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
hvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hvals.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="hvals.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the values of h taken during the progress of the algorithm
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='identify.lgcpPredict'>identify.lgcpPredict function</h2><span id='topic+identify.lgcpPredict'></span>

<h3>Description</h3>

<p>Identifies the indices of grid cells on plots of <code>lgcpPredict</code> objects. Can be used to identify
a small number of cells for further information eg trace or autocorrelation plots (provided data has been dumped to disk). On calling
<code>identify(lg)</code> for example (see code below), the user can click multiply with the left mouse button on the graphics device; once
the user has selected all points of interest, the right button is pressed, which returns them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
identify(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify.lgcpPredict_+3A_x">x</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="identify.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2 x n matrix containing the grid indices of the points of interest, where n is the number of points selected via the mouse.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+loc2poly">loc2poly</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: plot(lg) # lg an lgcpPredict object
## Not run: pt_indices &lt;- identify(lg)
</code></pre>

<hr>
<h2 id='identifygrid'>identifygrid function</h2><span id='topic+identifygrid'></span>

<h3>Description</h3>

<p>Identifies the indices of grid cells on plots of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifygrid(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identifygrid_+3A_x">x</code></td>
<td>
<p>the x grid centroids</p>
</td></tr>
<tr><td><code id="identifygrid_+3A_y">y</code></td>
<td>
<p>the y grid centroids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2 x n matrix containing the grid indices of the points of interest, where n is the number of points selected via the mouse.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+loc2poly">loc2poly</a>, <a href="#topic+identify.lgcpPredict">identify.lgcpPredict</a>
</p>

<hr>
<h2 id='image.lgcpgrid'>image.lgcpgrid function</h2><span id='topic+image.lgcpgrid'></span>

<h3>Description</h3>

<p>Produce an image plot of an lgcpgrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
image(x, sel = 1:x$len, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.lgcpgrid_+3A_x">x</code></td>
<td>
<p>an object of class lgcpgrid</p>
</td></tr>
<tr><td><code id="image.lgcpgrid_+3A_sel">sel</code></td>
<td>
<p>vector of integers between 1 and grid$len: which grids to plot. Default NULL, in which case all grids are plotted.</p>
</td></tr>
<tr><td><code id="image.lgcpgrid_+3A_ask">ask</code></td>
<td>
<p>logical; if TRUE the user is asked before each plot</p>
</td></tr>
<tr><td><code id="image.lgcpgrid_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grid plotting
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.list">lgcpgrid.list</a>, <a href="#topic+lgcpgrid.array">lgcpgrid.array</a>, <a href="#topic+as.list.lgcpgrid">as.list.lgcpgrid</a>, <a href="#topic+print.lgcpgrid">print.lgcpgrid</a>,
<a href="#topic+summary.lgcpgrid">summary.lgcpgrid</a>, <a href="#topic+quantile.lgcpgrid">quantile.lgcpgrid</a>, <a href="#topic+plot.lgcpgrid">plot.lgcpgrid</a>
</p>

<hr>
<h2 id='initialiseAMCMC'>initialiseAMCMC function</h2><span id='topic+initialiseAMCMC'></span>

<h3>Description</h3>

<p>A generic to be used for the purpose of user-defined adaptive MCMC schemes,
initialiseAMCMC tells the MALA algorithm which value of h to use first. See
lgcp vignette, codevignette(&quot;lgcp&quot;), for further details on writing adaptive MCMC schemes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialiseAMCMC(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialiseAMCMC_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="initialiseAMCMC_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method intialiseAMCMC
</p>


<h3>See Also</h3>

<p><a href="#topic+initialiseAMCMC.constanth">initialiseAMCMC.constanth</a>, <a href="#topic+initialiseAMCMC.andrieuthomsh">initialiseAMCMC.andrieuthomsh</a>
</p>

<hr>
<h2 id='initialiseAMCMC.andrieuthomsh'>initaliseAMCMC.andrieuthomsh function</h2><span id='topic+initialiseAMCMC.andrieuthomsh'></span>

<h3>Description</h3>

<p>Initialises the <a href="#topic+andrieuthomsh">andrieuthomsh</a> adaptive scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'andrieuthomsh'
initialiseAMCMC(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialiseAMCMC.andrieuthomsh_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="initialiseAMCMC.andrieuthomsh_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>initial h for scheme
</p>


<h3>References</h3>


<ol>
<li><p> Andrieu C, Thoms J (2008). A tutorial on adaptive MCMC. Statistics and Computing, 18(4), 343-373.
</p>
</li>
<li><p> Robbins H, Munro S (1951). A Stochastic Approximation Methods. The Annals of Mathematical Statistics, 22(3), 400-407.
</p>
</li>
<li><p> Roberts G, Rosenthal J (2001). Optimal Scaling for Various Metropolis-Hastings Algorithms. Statistical Science, 16(4), 351-367.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+andrieuthomsh">andrieuthomsh</a>
</p>

<hr>
<h2 id='initialiseAMCMC.constanth'>initaliseAMCMC.constanth function</h2><span id='topic+initialiseAMCMC.constanth'></span>

<h3>Description</h3>

<p>Initialises the <a href="#topic+constanth">constanth</a> adaptive scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'constanth'
initialiseAMCMC(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialiseAMCMC.constanth_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="initialiseAMCMC.constanth_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>initial h for scheme
</p>


<h3>See Also</h3>

<p><a href="#topic+constanth">constanth</a>
</p>

<hr>
<h2 id='integerise'>integerise function</h2><span id='topic+integerise'></span>

<h3>Description</h3>

<p>Generic function for converting the time variable of an stppp object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integerise(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integerise_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="integerise_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method integerise
</p>


<h3>See Also</h3>

<p><a href="#topic+integerise.stppp">integerise.stppp</a>
</p>

<hr>
<h2 id='integerise.mstppp'>integerise.mstppp function</h2><span id='topic+integerise.mstppp'></span>

<h3>Description</h3>

<p>Function for converting the times and time limits of an mstppp object into integer values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mstppp'
integerise(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integerise.mstppp_+3A_obj">obj</code></td>
<td>
<p>an mstppp object</p>
</td></tr>
<tr><td><code id="integerise.mstppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mstppp object, but with integerised times.
</p>

<hr>
<h2 id='integerise.stppp'>integerise.stppp function</h2><span id='topic+integerise.stppp'></span>

<h3>Description</h3>

<p>Function for converting the times and time limits of an stppp object into integer values. Do this before estimating mu(t), and hence
before creating the temporalAtRisk object. Not taking this step is possible in lgcp, but can cause minor complications connected with the scaling of mu(t).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
integerise(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integerise.stppp_+3A_obj">obj</code></td>
<td>
<p>an stppp object</p>
</td></tr>
<tr><td><code id="integerise.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The stppp object, but with integerised times.
</p>

<hr>
<h2 id='intens'>intens function</h2><span id='topic+intens'></span>

<h3>Description</h3>

<p>Generic function to return the Poisson Intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intens(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intens_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="intens_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method intens
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+intens.lgcpPredict">intens.lgcpPredict</a>
</p>

<hr>
<h2 id='intens.lgcpPredict'>intens.lgcpPredict function</h2><span id='topic+intens.lgcpPredict'></span>

<h3>Description</h3>

<p>Accessor function returning the Poisson intensity as an lgcpgrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
intens(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intens.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredict object</p>
</td></tr>
<tr><td><code id="intens.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the cell-wise mean Poisson intensity, as computed by MCMC.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='intens.lgcpSimMultitypeSpatialPlusParameters'>intens.lgcpSimMultitypeSpatialPlusParameters function</h2><span id='topic+intens.lgcpSimMultitypeSpatialPlusParameters'></span>

<h3>Description</h3>

<p>A function to return the cellwise Poisson intensity used during in constructing the simulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"intens(obj, ...)"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intens.lgcpSimMultitypeSpatialPlusParameters_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpSimMultitypeSpatialPlusParameters</p>
</td></tr>
<tr><td><code id="intens.lgcpSimMultitypeSpatialPlusParameters_+3A_...">...</code></td>
<td>
<p>other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Poisson intensity
</p>

<hr>
<h2 id='intens.lgcpSimSpatialPlusParameters'>intens.lgcpSimSpatialPlusParameters function</h2><span id='topic+intens.lgcpSimSpatialPlusParameters'></span>

<h3>Description</h3>

<p>A function to return the cellwise Poisson intensity used during in constructing the simulated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpSimSpatialPlusParameters'
intens(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intens.lgcpSimSpatialPlusParameters_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpSimSpatialPlusParameters</p>
</td></tr>
<tr><td><code id="intens.lgcpSimSpatialPlusParameters_+3A_...">...</code></td>
<td>
<p>other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Poisson intensity
</p>

<hr>
<h2 id='interptypes'>interptypes function</h2><span id='topic+interptypes'></span>

<h3>Description</h3>

<p>A function to return the types of covariate interpolation available<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interptypes()
</code></pre>


<h3>Details</h3>

<p>The three types of interpolation method employed in the package lgcp are:<br />
</p>

<ol>
<li><p> 'Majority' The interpolated value corresponds to the value of the covariate occupying
the largest area of the computational cell.
</p>
</li>
<li><p> 'ArealWeightedMean' The interpolated value corresponds to the mean of all covariate
values contributing to the computational cell weighted by their respective areas.
</p>
</li>
<li><p> 'ArealWeightedSum' The interpolated value is the sum of all contributing covariates
weighed by the proportion of area with respect to the covariate polygons. For example,
suppose region A has the same area as a computational grid cell and has 500 inhabitants.
If that region occupies half of a computational grid cell, then this interpolation type assigns
250 inhabitants from A to the computational grid cell.
</p>
</li></ol>



<h3>Value</h3>

<p>character string of available interpolation types
</p>

<hr>
<h2 id='inversebase'>inversebase function</h2><span id='topic+inversebase'></span>

<h3>Description</h3>

<p>A function to compute the base of the inverse os a block circulant matrix, given the base of the matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inversebase(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inversebase_+3A_x">x</code></td>
<td>
<p>the base matrix of a block circulant matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the base matrix of the inverse of the circulant matrix
</p>

<hr>
<h2 id='is.burnin'>is this a burn-in iteration?</h2><span id='topic+is.burnin'></span>

<h3>Description</h3>

<p>if this mcmc iteration is in the burn-in period, return TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.burnin(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.burnin_+3A_obj">obj</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>

<hr>
<h2 id='is.pow2'>is.pow2 function</h2><span id='topic+is.pow2'></span>

<h3>Description</h3>

<p>Tests whether a number id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pow2(num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.pow2_+3A_num">num</code></td>
<td>
<p>a numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical: is num a power of 2?
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.pow2(128)  # TRUE
is.pow2(64.9) # FALSE
</code></pre>

<hr>
<h2 id='is.retain'>do we retain this iteration?</h2><span id='topic+is.retain'></span>

<h3>Description</h3>

<p>if this mcmc iteration is one not thinned out, this is true
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.retain(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.retain_+3A_obj">obj</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>

<hr>
<h2 id='is.SPD'>is.SPD function</h2><span id='topic+is.SPD'></span>

<h3>Description</h3>

<p>A function to compute whether a block circulant matrix is symmetric positive definite (SPD), given its base matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.SPD(base)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.SPD_+3A_base">base</code></td>
<td>
<p>base matrix of a block circulant matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, whether the circulant matrix the base represents is SPD
</p>

<hr>
<h2 id='iteration'>iteration number</h2><span id='topic+iteration'></span>

<h3>Description</h3>

<p>within a loop, this is the iteration number we are currently doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iteration(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iteration_+3A_obj">obj</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>get the iteration number
</p>


<h3>Value</h3>

<p>integer iteration number, starting from 1.
</p>

<hr>
<h2 id='KinhomAverage'>KinhomAverage function</h2><span id='topic+KinhomAverage'></span>

<h3>Description</h3>

<p>A function to estimate the inhomogeneous K function for a spatiotemporal point process. The method of computation is similar to
<a href="#topic+ginhomAverage">ginhomAverage</a>, see eq (8) Diggle P, Rowlingson B, Su T (2005) to see how this is computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KinhomAverage(
  xyt,
  spatial.intensity,
  temporal.intensity,
  time.window = xyt$tlim,
  rvals = NULL,
  correction = "iso",
  suppresswarnings = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KinhomAverage_+3A_xyt">xyt</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="KinhomAverage_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>A spatialAtRisk object</p>
</td></tr>
<tr><td><code id="KinhomAverage_+3A_temporal.intensity">temporal.intensity</code></td>
<td>
<p>A temporalAtRisk object</p>
</td></tr>
<tr><td><code id="KinhomAverage_+3A_time.window">time.window</code></td>
<td>
<p>time interval contained in the interval xyt$tlim over which to compute average. Useful if there is a lot of data over a lot of time points.</p>
</td></tr>
<tr><td><code id="KinhomAverage_+3A_rvals">rvals</code></td>
<td>
<p>Vector of values for the argument r at which the inhmogeneous K function should be evaluated (see ?Kinhom). There is a sensible default.</p>
</td></tr>
<tr><td><code id="KinhomAverage_+3A_correction">correction</code></td>
<td>
<p>choice of edge correction to use, see ?Kinhom, default is Ripley isotropic correction</p>
</td></tr>
<tr><td><code id="KinhomAverage_+3A_suppresswarnings">suppresswarnings</code></td>
<td>
<p>Whether or not to suppress warnings generated by Kinhom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time average of inhomogenous K function.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Baddeley AJ, Moller J, Waagepetersen R (2000). Non-and semi-parametric estimation of interaction in inhomogeneous point patterns. Statistica Neerlandica, 54, 329-350.
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+thetaEst">thetaEst</a>, <a href="#topic+lambdaEst">lambdaEst</a>, <a href="#topic+muEst">muEst</a>
</p>

<hr>
<h2 id='lambdaEst'>lambdaEst function</h2><span id='topic+lambdaEst'></span>

<h3>Description</h3>

<p>Generic function for estimating bivariate densities by eye. Specific methods exist for stppp objects and ppp objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdaEst(xyt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaEst_+3A_xyt">xyt</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="lambdaEst_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method lambdaEst
</p>


<h3>See Also</h3>

<p><a href="#topic+lambdaEst.stppp">lambdaEst.stppp</a>, <a href="#topic+lambdaEst.ppp">lambdaEst.ppp</a>
</p>

<hr>
<h2 id='lambdaEst.ppp'>lambdaEst.ppp function</h2><span id='topic+lambdaEst.ppp'></span>

<h3>Description</h3>

<p>A tool for the visual estimation of lambda(s) via a 2 dimensional smoothing of the case locations. For parameter estimation, the alternative is
to estimate lambda(s) by some other means, convert it into a spatialAtRisk object and then into a pixel image object using the build in coercion 
methods, this <code>im</code> object can then be fed to <a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+KinhomAverage">KinhomAverage</a> or <a href="#topic+thetaEst">thetaEst</a> for instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
lambdaEst(xyt, weights = c(), edge = TRUE, bw = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaEst.ppp_+3A_xyt">xyt</code></td>
<td>
<p>object of class stppp</p>
</td></tr>
<tr><td><code id="lambdaEst.ppp_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights to be attached to the points.  May include negative values. See ?density.ppp.</p>
</td></tr>
<tr><td><code id="lambdaEst.ppp_+3A_edge">edge</code></td>
<td>
<p>Logical flag: if TRUE, apply edge correction. See ?density.ppp.</p>
</td></tr>
<tr><td><code id="lambdaEst.ppp_+3A_bw">bw</code></td>
<td>
<p>optional bandwidth. Set to NULL by default, which calls teh resolve.2D.kernel function for computing an initial value of this</p>
</td></tr>
<tr><td><code id="lambdaEst.ppp_+3A_...">...</code></td>
<td>
<p>arguments to be passed to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function lambdaEst is built directly on the density.ppp function and as such, implements a bivariate 
Gaussian smoothing kernel. The bandwidth is initially that which is automatically chosen by the default method 
of density.ppp. Since image plots of these kernel density estimates may not have appropriate 
colour scales, the ability to adjust this is given with the slider 'colour adjustment'. With colour adjustment set 
to 1, the default image.plot for the equivalent pixel image object is shown and for values less than 1, the colour 
scheme is more spread out, allowing the user to get a better feel for the density that is being fitted. NOTE: colour 
adjustment does not affect the returned density and the user should be aware that the returned density will 'look like' 
that displayed when colour adjustment is set equal to 1.
</p>


<h3>Value</h3>

<p>This is an rpanel function for visual choice of lambda(s), the output is a variable, varname, with the density *per unit time* 
the variable varname can be fed to the function ginhomAverage or KinhomAverage as the argument density (see for example ?ginhomAverage), or into the 
function thetaEst as the argument spatial.intensity.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+thetaEst">thetaEst</a>, <a href="#topic+muEst">muEst</a>
</p>

<hr>
<h2 id='lambdaEst.stppp'>lambdaEst.stppp function</h2><span id='topic+lambdaEst.stppp'></span>

<h3>Description</h3>

<p>A tool for the visual estimation of lambda(s) via a 2 dimensional smoothing of the case locations. For parameter estimation, the alternative is
to estimate lambda(s) by some other means, convert it into a spatialAtRisk object and then into a pixel image object using the build in coercion 
methods, this <code>im</code> object can then be fed to <a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+KinhomAverage">KinhomAverage</a> or <a href="#topic+thetaEst">thetaEst</a> for instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
lambdaEst(xyt, weights = c(), edge = TRUE, bw = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaEst.stppp_+3A_xyt">xyt</code></td>
<td>
<p>object of class stppp</p>
</td></tr>
<tr><td><code id="lambdaEst.stppp_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights to be attached to the points.  May include negative values. See ?density.ppp.</p>
</td></tr>
<tr><td><code id="lambdaEst.stppp_+3A_edge">edge</code></td>
<td>
<p>Logical flag: if TRUE, apply edge correction. See ?density.ppp.</p>
</td></tr>
<tr><td><code id="lambdaEst.stppp_+3A_bw">bw</code></td>
<td>
<p>optional bandwidth. Set to NULL by default, which calls teh resolve.2D.kernel function for computing an initial value of this</p>
</td></tr>
<tr><td><code id="lambdaEst.stppp_+3A_...">...</code></td>
<td>
<p>arguments to be passed to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function lambdaEst is built directly on the density.ppp function and as such, implements a bivariate 
Gaussian smoothing kernel. The bandwidth is initially that which is automatically chosen by the default method 
of density.ppp. Since image plots of these kernel density estimates may not have appropriate 
colour scales, the ability to adjust this is given with the slider 'colour adjustment'. With colour adjustment set 
to 1, the default image.plot for the equivalent pixel image object is shown and for values less than 1, the colour 
scheme is more spread out, allowing the user to get a better feel for the density that is being fitted. NOTE: colour 
adjustment does not affect the returned density and the user should be aware that the returned density will 'look like' 
that displayed when colour adjustment is set equal to 1.
</p>


<h3>Value</h3>

<p>This is an rpanel function for visual choice of lambda(s), the output is a variable, varname, with the density *per unit time* 
the variable varname can be fed to the function ginhomAverage or KinhomAverage as the argument density (see for example ?ginhomAverage), or into the 
function thetaEst as the argument spatial.intensity.
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+thetaEst">thetaEst</a>, <a href="#topic+muEst">muEst</a>
</p>

<hr>
<h2 id='lgcp-package'>lgcp</h2><span id='topic+lgcp-package'></span><span id='topic+lgcp'></span>

<h3>Description</h3>

<p>An R package for spatiotemporal prediction and forecasting for log-Gaussian Cox processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcp
</code></pre>


<h3>Format</h3>

<p>An object of class <code>logical</code> of length 1.
</p>


<h3>Details</h3>

<p>This package was not yet installed at build time.<br />

Index:  This package was not yet installed at build time.<br />
</p>
<p>For examples and further details of the package, type vignette(&quot;lgcp&quot;), or refer to the paper associated with this package.
</p>
<p>The content of <code>lgcp</code> can be broken up as follows:<br />
</p>
<p><em>Datasets</em> wpopdata.rda, wtowncoords.rda, wtowns.rda. Giving regional and town poopulations as well as town coordinates,are provided by Wikipedia
and The Office for National Statistics under respectively
the Creative Commons Attribution-ShareAlike 3.0 Unported License and the Open Government Licence.<br />
</p>
<p><em>Data manipulation</em><br />
</p>
<p><em>Model fitting and parameter estimation</em><br />
</p>
<p><em>Unconditional and conditional simulation</em><br />
</p>
<p><em>Summary statistics, diagnostics and visualisation</em><br />
</p>


<h3>Dependencies</h3>

<p>The <code>lgcp</code> package depends upon some other important contributions to CRAN in order to operate; their uses here are indicated:<br /><br />
spatstat, sp, RandomFields, iterators, ncdf, methods, tcltk, rgl, rpanel, fields, rgdal, maptools, rgeos, raster
</p>


<h3>Citation</h3>

<p>To see how to cite <code>lgcp</code>, type <code>citation("lgcp")</code> at the console.
</p>


<h3>Author(s)</h3>

<p>Benjamin Taylor, Health and Medicine, Lancaster University,
Tilman Davies, Institute of Fundamental Sciences - Statistics, Massey University, New Zealand.,
Barry Rowlingson, Health and Medicine, Lancaster University
Peter Diggle, Health and Medicine, Lancaster University
</p>


<h3>References</h3>


<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>


<hr>
<h2 id='lgcpbayes'>lgcpbayes function</h2><span id='topic+lgcpbayes'></span>

<h3>Description</h3>

<p>Display the introductory vignette for the lgcp package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpbayes()
</code></pre>


<h3>Value</h3>

<p>displays the vignette by calling browseURL
</p>

<hr>
<h2 id='lgcpForecast'>lgcpForecast function</h2><span id='topic+lgcpForecast'></span>

<h3>Description</h3>

<p>Function to produce forecasts for the mean field <code class="reqn">Y</code> at times beyond the last time point in the 
analysis (given by the argument <code>T</code> in the function <code>lgcpPredict</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpForecast(
  lg,
  ptimes,
  spatial.intensity,
  temporal.intensity,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpForecast_+3A_lg">lg</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="lgcpForecast_+3A_ptimes">ptimes</code></td>
<td>
<p>vector of time points for prediction. Must start strictly after last inferred time point.</p>
</td></tr>
<tr><td><code id="lgcpForecast_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>the fixed spatial component: an object of that can be coerced to one of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="lgcpForecast_+3A_temporal.intensity">temporal.intensity</code></td>
<td>
<p>the fixed temporal component: either a numeric vector, or a function that can be coerced into an object of class temporalAtRisk</p>
</td></tr>
<tr><td><code id="lgcpForecast_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>forcasted relative risk, Poisson intensities and Y values over grid, together with approximate variance.
</p>


<h3>References</h3>

<p>Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='lgcpgrid'>lgcpgrid function</h2><span id='topic+lgcpgrid'></span>

<h3>Description</h3>

<p>Generic function for the hadling of list objects where each element of the list is
a matrix. Each matrix is assumed to have the same dimension. Such objects arise from the
various routines in the package lgcp.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpgrid(grid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpgrid_+3A_grid">grid</code></td>
<td>
<p>a list object with each member of the list being a numeric matrix, each matrix having the same dimension</p>
</td></tr>
<tr><td><code id="lgcpgrid_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>lgcpgrid objects are list objects with names len, nrow, ncol, grid, xvals, yvals, zvals. The first three elements of the list
store the dimension of the object, the fourth element, grid, is itself a list object consisting of matrices in which the
data is stored. The last three arguments can be used to give what is effectively a 3 dimensional array a physical reference.
</p>
<p>For example, the mean of Y from a call to lgcpPredict, obj$y.mean for example, is stored in an lgcpgrid object. If several time points have been
stored in the call to lgcpPredict, then the grid element of the lgcpgrid object contains the output for each of the time points in succession. So
the first element, obj$y.mean$grid[[1]],contains the output from the first time point and so on.
</p>


<h3>Value</h3>

<p>method lgcpgrid
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.list">lgcpgrid.list</a>, <a href="#topic+lgcpgrid.array">lgcpgrid.array</a>, <a href="#topic+lgcpgrid.matrix">lgcpgrid.matrix</a>
</p>

<hr>
<h2 id='lgcpgrid.array'>lgcpgrid.array function</h2><span id='topic+lgcpgrid.array'></span>

<h3>Description</h3>

<p>Creates an lgcp grid object from an 3-dimensional array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
lgcpgrid(
  grid,
  xvals = 1:dim(grid)[1],
  yvals = 1:dim(grid)[2],
  zvals = 1:dim(grid)[3],
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpgrid.array_+3A_grid">grid</code></td>
<td>
<p>a three dimensional array object</p>
</td></tr>
<tr><td><code id="lgcpgrid.array_+3A_xvals">xvals</code></td>
<td>
<p>optional vector of x-coordinates associated to grid. By default, this is the cell index in the x direction.</p>
</td></tr>
<tr><td><code id="lgcpgrid.array_+3A_yvals">yvals</code></td>
<td>
<p>optional vector of y-coordinates associated to grid. By default, this is the cell index in the y direction.</p>
</td></tr>
<tr><td><code id="lgcpgrid.array_+3A_zvals">zvals</code></td>
<td>
<p>optional vector of z-coordinates (time) associated to grid. By default, this is the cell index in the z direction.</p>
</td></tr>
<tr><td><code id="lgcpgrid.array_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class lgcpgrid
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.list">lgcpgrid.list</a>, <a href="#topic+as.list.lgcpgrid">as.list.lgcpgrid</a>, <a href="#topic+print.lgcpgrid">print.lgcpgrid</a>,
<a href="#topic+summary.lgcpgrid">summary.lgcpgrid</a>, <a href="#topic+quantile.lgcpgrid">quantile.lgcpgrid</a>, <a href="#topic+image.lgcpgrid">image.lgcpgrid</a>, <a href="#topic+plot.lgcpgrid">plot.lgcpgrid</a>
</p>

<hr>
<h2 id='lgcpgrid.list'>lgcpgrid.list function</h2><span id='topic+lgcpgrid.list'></span>

<h3>Description</h3>

<p>Creates an lgcpgrid object from a list object plus some optional coordinates. Note that each element of the list should be a matrix,
and that each matrix should have the same dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
lgcpgrid(
  grid,
  xvals = 1:dim(grid[[1]])[1],
  yvals = 1:dim(grid[[1]])[2],
  zvals = 1:length(grid),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpgrid.list_+3A_grid">grid</code></td>
<td>
<p>a list object with each member of the list being a numeric matrix, each matrix having the same dimension</p>
</td></tr>
<tr><td><code id="lgcpgrid.list_+3A_xvals">xvals</code></td>
<td>
<p>optional vector of x-coordinates associated to grid. By default, this is the cell index in the x direction.</p>
</td></tr>
<tr><td><code id="lgcpgrid.list_+3A_yvals">yvals</code></td>
<td>
<p>optional vector of y-coordinates associated to grid. By default, this is the cell index in the y direction.</p>
</td></tr>
<tr><td><code id="lgcpgrid.list_+3A_zvals">zvals</code></td>
<td>
<p>optional vector of z-coordinates (time) associated to grid. By default, this is the cell index in the z direction.</p>
</td></tr>
<tr><td><code id="lgcpgrid.list_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class lgcpgrid
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.array">lgcpgrid.array</a>, <a href="#topic+as.list.lgcpgrid">as.list.lgcpgrid</a>, <a href="#topic+print.lgcpgrid">print.lgcpgrid</a>,
<a href="#topic+summary.lgcpgrid">summary.lgcpgrid</a>, <a href="#topic+quantile.lgcpgrid">quantile.lgcpgrid</a>, <a href="#topic+image.lgcpgrid">image.lgcpgrid</a>, <a href="#topic+plot.lgcpgrid">plot.lgcpgrid</a>
</p>

<hr>
<h2 id='lgcpgrid.matrix'>lgcpgrid.matrix function</h2><span id='topic+lgcpgrid.matrix'></span>

<h3>Description</h3>

<p>Creates an lgcp grid object from an 2-dimensional matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
lgcpgrid(grid, xvals = 1:nrow(grid), yvals = 1:ncol(grid), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpgrid.matrix_+3A_grid">grid</code></td>
<td>
<p>a three dimensional array object</p>
</td></tr>
<tr><td><code id="lgcpgrid.matrix_+3A_xvals">xvals</code></td>
<td>
<p>optional vector of x-coordinates associated to grid. By default, this is the cell index in the x direction.</p>
</td></tr>
<tr><td><code id="lgcpgrid.matrix_+3A_yvals">yvals</code></td>
<td>
<p>optional vector of y-coordinates associated to grid. By default, this is the cell index in the y direction.</p>
</td></tr>
<tr><td><code id="lgcpgrid.matrix_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class lgcpgrid
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.list">lgcpgrid.list</a>, <a href="#topic+as.list.lgcpgrid">as.list.lgcpgrid</a>, <a href="#topic+print.lgcpgrid">print.lgcpgrid</a>,
<a href="#topic+summary.lgcpgrid">summary.lgcpgrid</a>, <a href="#topic+quantile.lgcpgrid">quantile.lgcpgrid</a>, <a href="#topic+image.lgcpgrid">image.lgcpgrid</a>, <a href="#topic+plot.lgcpgrid">plot.lgcpgrid</a>
</p>

<hr>
<h2 id='lgcpInits'>lgcpInits function</h2><span id='topic+lgcpInits'></span>

<h3>Description</h3>

<p>A function to declare initial values for a run of the MCMC routine. If specified, the MCMC algorithm will calibrate the proposal
density using these as provisional estimates of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpInits(etainit = NULL, betainit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpInits_+3A_etainit">etainit</code></td>
<td>
<p>a vector, the initial value of eta to use</p>
</td></tr>
<tr><td><code id="lgcpInits_+3A_betainit">betainit</code></td>
<td>
<p>a vector, the initial value of beta to use, this vector must have names the same as the variable names in the formula in use, and in the same order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is not necessary to supply intial values to the MCMC routine, by default the functions lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars,
lgcpPredictSpatioTemporalPlusPars and lgcpPredictMultitypeSpatialPlusPars will initialise the MCMC as follows. For eta, if no initial value is
specified then the initial value of eta in the MCMC run will be the prior mean. For beta, if no initial value is specified then
the initial value of beta in the MCMC run will be estimated from an overdispersed Poisson fit to the cell counts, ignoring spatial correlation. The user cannot
specify an initial value of Y (or equivalently Gamma), as a sensible value is chosen by the MCMC function.
</p>
<p>A secondary function of specifying initial values is to help design the MCMC proposal matrix, which is based on these initial estimates.
</p>


<h3>Value</h3>

<p>an object of class lgcpInits used in the MCMC routine.
</p>


<h3>See Also</h3>

<p><a href="#topic+chooseCellwidth">chooseCellwidth</a>, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+CovFunction">CovFunction</a>,
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: INITS &lt;- lgcpInits(etainit=log(c(sqrt(1.5),275)), betainit=NULL)
</code></pre>

<hr>
<h2 id='lgcppars'>lgcppars function</h2><span id='topic+lgcppars'></span>

<h3>Description</h3>

<p>A function for setting the parameters sigma, phi and theta for <code>lgcpPredict</code>. Note that the returned
set of parameters also features mu=-0.5*sigma^2, gives mean(exp(Y)) = 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcppars(sigma = NULL, phi = NULL, theta = NULL, mu = NULL, beta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcppars_+3A_sigma">sigma</code></td>
<td>
<p>sigma parameter</p>
</td></tr>
<tr><td><code id="lgcppars_+3A_phi">phi</code></td>
<td>
<p>phi parameter</p>
</td></tr>
<tr><td><code id="lgcppars_+3A_theta">theta</code></td>
<td>
<p>this is 'beta' parameter in Brix and Diggle (2001)</p>
</td></tr>
<tr><td><code id="lgcppars_+3A_mu">mu</code></td>
<td>
<p>the mean of the latent field, if equal to NULL, this is set to -sigma^2/2</p>
</td></tr>
<tr><td><code id="lgcppars_+3A_beta">beta</code></td>
<td>
<p>ONLY USED IN case where there is covariate information.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='lgcpPredict'>lgcpPredict function</h2><span id='topic+lgcpPredict'></span>

<h3>Description</h3>

<p>The function <code>lgcpPredict</code> performs spatiotemporal prediction for log-Gaussian Cox Processes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpPredict(
  xyt,
  T,
  laglength,
  model.parameters = lgcppars(),
  spatial.covmodel = "exponential",
  covpars = c(),
  cellwidth = NULL,
  gridsize = NULL,
  spatial.intensity,
  temporal.intensity,
  mcmc.control,
  output.control = setoutput(),
  missing.data.areas = NULL,
  autorotate = FALSE,
  gradtrunc = Inf,
  ext = 2,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpPredict_+3A_xyt">xyt</code></td>
<td>
<p>a spatio-temporal point pattern object, see ?stppp</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_t">T</code></td>
<td>
<p>time point of interest</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_laglength">laglength</code></td>
<td>
<p>specifies lag window, so that data from and including  time (T-laglength) to time T is used in the MALA algorithm</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_model.parameters">model.parameters</code></td>
<td>
<p>values for parameters, see ?lgcppars</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>correlation type see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_covpars">covpars</code></td>
<td>
<p>vector of additional parameters for certain classes of covariance function (eg Matern), these must be supplied in the order given in ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_cellwidth">cellwidth</code></td>
<td>
<p>width of grid cells on which to do MALA (grid cells are square) in same units as observation window. Note EITHER gridsize OR cellwidth must be specified.</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_gridsize">gridsize</code></td>
<td>
<p>size of output grid required. Note EITHER gridsize OR cellwidthe must be specified.</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>the fixed spatial component: an object of that can be coerced to one of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_temporal.intensity">temporal.intensity</code></td>
<td>
<p>the fixed temporal component: either a numeric vector, or a function that can be coerced into an object of class temporalAtRisk</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_mcmc.control">mcmc.control</code></td>
<td>
<p>MCMC paramters, see ?mcmcpars</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_output.control">output.control</code></td>
<td>
<p>output choice, see ?setoutput</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_missing.data.areas">missing.data.areas</code></td>
<td>
<p>a list of owin objects (of length laglength+1) which has xyt$window as a base window, but with polygonal holes specifying spatial areas where there is missing data.</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_autorotate">autorotate</code></td>
<td>
<p>logical: whether or not to automatically do MCMC on optimised, rotated grid.</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>truncation for gradient vector equal to H parameter Moller et al 1998 pp 473. Default is Inf, which means no gradient truncation. Set to NULL to estimate this automatically (though note that this may not necessarily be a good choice). The default seems to work in most settings.</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays very slowly (compared withe the size of hte observation window), increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="lgcpPredict_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.
further notes on autorotate argument: If set to TRUE, and the argument spatial is not NULL, then the argument spatial must be computed in the original frame of reference (ie NOT in the rotated frame). 
Autorotate performs bilinear interpolation (via interp.im) on an inverse transformed grid; if there is no computational advantage in doing this, a warning message will be issued. Note that best accuracy 
is achieved by manually rotating xyt and then computing spatial on the transformed xyt and finally feeding these in as arguments to the function lgcpPredict. By default autorotate is set to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following is a mathematical description of a log-Gaussian Cox Process, it is best viewed in the pdf version of the manual.
</p>
<p>Let <code class="reqn">\mathcal Y(s,t)</code> be a spatiotemporal Gaussian process, <code class="reqn">W\subset R^2</code> be an 
observation window in space and <code class="reqn">T\subset R_{\geq 0}</code> be an interval of time of interest. 
Cases occur at spatio-temporal positions <code class="reqn">(x,t) \in W \times T</code> 
according to an inhomogeneous spatio-temporal Cox process,
i.e. a Poisson process with a stochastic intensity <code class="reqn">R(x,t)</code>,
The number of cases, <code class="reqn">X_{S,[t_1,t_2]}</code>, arising in 
any <code class="reqn">S \subseteq W</code> during the interval <code class="reqn">[t_1,t_2]\subseteq T</code> is 
then Poisson distributed conditional on <code class="reqn">R(\cdot)</code>,
</p>
<p style="text-align: center;"><code class="reqn">X_{S,[t_1,t_2]} \sim \mbox{Poisson}\left\{\int_S\int_{t_1}^{t_2} R(s,t)d sd t\right\}</code>
</p>

<p>Following Brix and Diggle (2001) and Diggle et al (2005), the intensity is decomposed multiplicatively as
</p>
<p style="text-align: center;"><code class="reqn">R(s,t) = \lambda(s)\mu(t)\exp\{\mathcal Y(s,t)\}.</code>
</p>

<p>In the above, the fixed spatial component, <code class="reqn">\lambda:R^2\mapsto R_{\geq 0}</code>, 
is a known function, proportional to the population at risk at each point in space and scaled so that
</p>
<p style="text-align: center;"><code class="reqn">\int_W\lambda(s)d s=1,</code>
</p>

<p>whilst the fixed temporal component, 
<code class="reqn">\mu:R_{\geq 0}\mapsto R_{\geq 0}</code>, is also a known function with
</p>
<p style="text-align: center;"><code class="reqn">\mu(t) \delta t = E[X_{W,\delta t}],</code>
</p>

<p>for <code class="reqn">t</code> in a small interval of time, <code class="reqn">\delta t</code>, over which the rate of the process over <code class="reqn">W</code> can be considered constant.
</p>
<p><b>
NOTE: the xyt stppp object can be recorded in continuous time, but for the purposes of prediciton,    
discretisation must take place. For the time dimension, this is achieved invisibly by <code>as.integer(xyt$t)</code> and
<code>as.integer(xyt$tlim)</code>. Therefore, before running an analysis please make sure that this is commensurate
with the physical inerpretation and requirements of your output. The spatial discretisation is
chosen with the argument cellwidth (or gridsize). If the chosen discretisation in time and space is too coarse for a
given set of parameters (sigma, phi and theta) then the proper correlation structures implied by the model will not
be captured in the output.
</b>
</p>
<p>Before calling this function, the user must decide on the time point of interest, the
number of intervals of data to use, the parameters, spatial covariance model, spatial discretisation,
fixed spatial (<code class="reqn">\lambda(s)</code>) and temporal (<code class="reqn">\mu(t)</code>) components, mcmc parameters, and whether or not any output is
required.
</p>


<h3>Value</h3>

<p>the results of fitting the model in an object of class <code>lgcpPredict</code>
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/        
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+lambdaEst">lambdaEst</a>, <a href="#topic+muEst">muEst</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+thetaEst">thetaEst</a>,  
<a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+lgcppars">lgcppars</a>, <a href="#topic+CovarianceFct">CovarianceFct</a>, <a href="#topic+mcmcpars">mcmcpars</a>, <a href="#topic+setoutput">setoutput</a> 
<a href="#topic+print.lgcpPredict">print.lgcpPredict</a>, <a href="#topic+xvals.lgcpPredict">xvals.lgcpPredict</a>, <a href="#topic+yvals.lgcpPredict">yvals.lgcpPredict</a>, <a href="#topic+plot.lgcpPredict">plot.lgcpPredict</a>, <a href="#topic+meanfield.lgcpPredict">meanfield.lgcpPredict</a>,
<a href="#topic+rr.lgcpPredict">rr.lgcpPredict</a>, <a href="#topic+serr.lgcpPredict">serr.lgcpPredict</a>, <a href="#topic+intens.lgcpPredict">intens.lgcpPredict</a>,   
<a href="#topic+varfield.lgcpPredict">varfield.lgcpPredict</a>, <a href="#topic+gridfun.lgcpPredict">gridfun.lgcpPredict</a>, <a href="#topic+gridav.lgcpPredict">gridav.lgcpPredict</a>, <a href="#topic+hvals.lgcpPredict">hvals.lgcpPredict</a>, <a href="#topic+window.lgcpPredict">window.lgcpPredict</a>,
<a href="#topic+mcmctrace.lgcpPredict">mcmctrace.lgcpPredict</a>, <a href="#topic+plotExceed.lgcpPredict">plotExceed.lgcpPredict</a>, <a href="#topic+quantile.lgcpPredict">quantile.lgcpPredict</a>, <a href="#topic+identify.lgcpPredict">identify.lgcpPredict</a>, <a href="#topic+expectation.lgcpPredict">expectation.lgcpPredict</a>,
<a href="#topic+extract.lgcpPredict">extract.lgcpPredict</a>, <a href="#topic+showGrid.lgcpPredict">showGrid.lgcpPredict</a>
</p>

<hr>
<h2 id='lgcpPredictAggregated'>lgcpPredictAggregated function</h2><span id='topic+lgcpPredictAggregated'></span>

<h3>Description</h3>

<p>The function <code>lgcpPredict</code> performs spatiotemporal prediction for log-Gaussian Cox Processes for point process data where counts
have been aggregated to the regional level. This is achieved by imputation of the regional counts onto a spatial continuum; if something
is known about the underlying spatial density of cases, then this information can be added to improve the quality of the imputation, 
without this, the counts are distributed uniformly within regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpPredictAggregated(
  app,
  popden = NULL,
  T,
  laglength,
  model.parameters = lgcppars(),
  spatial.covmodel = "exponential",
  covpars = c(),
  cellwidth = NULL,
  gridsize = NULL,
  spatial.intensity,
  temporal.intensity,
  mcmc.control,
  output.control = setoutput(),
  autorotate = FALSE,
  gradtrunc = NULL,
  n = 100,
  dmin = 0,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpPredictAggregated_+3A_app">app</code></td>
<td>
<p>a spatio-temporal aggregated point pattern object, see ?stapp</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_popden">popden</code></td>
<td>
<p>a spatialAtRisk object of class 'fromFunction' describing the population density, if known. Default is NULL, which gives a uniform density on each region.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_t">T</code></td>
<td>
<p>time point of interest</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_laglength">laglength</code></td>
<td>
<p>specifies lag window, so that data from and including  time (T-laglength) to time T is used in the MALA algorithm</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_model.parameters">model.parameters</code></td>
<td>
<p>values for parameters, see ?lgcppars</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>correlation type see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_covpars">covpars</code></td>
<td>
<p>vector of additional parameters for certain classes of covariance function (eg Matern), these must be supplied in the order given in ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_cellwidth">cellwidth</code></td>
<td>
<p>width of grid cells on which to do MALA (grid cells are square). Note EITHER gridsize OR cellwidthe must be specified.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_gridsize">gridsize</code></td>
<td>
<p>size of output grid required. Note EITHER gridsize OR cellwidthe must be specified.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>the fixed spatial component: an object of that can be coerced to one of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_temporal.intensity">temporal.intensity</code></td>
<td>
<p>the fixed temporal component: either a numeric vector, or a function that can be coerced into an object of class temporalAtRisk</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_mcmc.control">mcmc.control</code></td>
<td>
<p>MCMC paramters, see ?mcmcpars</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_output.control">output.control</code></td>
<td>
<p>output choice, see ?setoutput</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_autorotate">autorotate</code></td>
<td>
<p>logical: whether or not to automatically do MCMC on optimised, rotated grid.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>truncation for gradient vector equal to H parameter Moller et al 1998 pp 473. Set to NULL to estimate this automatically (default). Set to zero for no gradient truncation.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_n">n</code></td>
<td>
<p>parameter for as.stppp. If popden is NULL, then this parameter controls the resolution of the uniform. Otherwise if popden is of class 'fromFunction', it controls the size of the imputation grid used for sampling. Default is 100.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_dmin">dmin</code></td>
<td>
<p>parameter for as.stppp. If any reginal counts are missing, then a set of polygonal 'holes' in the observation window will be computed for each. dmin is the parameter used to control the simplification of these holes (see ?simplify.owin). default is zero.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregated_+3A_check">check</code></td>
<td>
<p>logical parameter for as.stppp. If any reginal counts are missing, then roughly speaking, check specifies whether to check the 'holes'. 
further notes on autorotate argument: If set to TRUE, and the argument spatial is not NULL, then the argument spatial must be computed in the original frame of reference (ie NOT in the rotated frame). 
Autorotate performs bilinear interpolation (via interp.im) on an inverse transformed grid; if there is no computational advantage in doing this, a warning message will be issued. Note that best accuracy 
is achieved by manually rotating xyt and then computing spatial on the transformed xyt and finally feeding these in as arguments to the function lgcpPredict. By default autorotate is set to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following is a mathematical description of a log-Gaussian Cox Process, it is best viewed in the pdf version of the manual.
</p>
<p>Let <code class="reqn">\mathcal Y(s,t)</code> be a spatiotemporal Gaussian process, <code class="reqn">W\subset R^2</code> be an 
observation window in space and <code class="reqn">T\subset R_{\geq 0}</code> be an interval of time of interest. 
Cases occur at spatio-temporal positions <code class="reqn">(x,t) \in W \times T</code> 
according to an inhomogeneous spatio-temporal Cox process,
i.e. a Poisson process with a stochastic intensity <code class="reqn">R(x,t)</code>,
The number of cases, <code class="reqn">X_{S,[t_1,t_2]}</code>, arising in 
any <code class="reqn">S \subseteq W</code> during the interval <code class="reqn">[t_1,t_2]\subseteq T</code> is 
then Poisson distributed conditional on <code class="reqn">R(\cdot)</code>,
</p>
<p style="text-align: center;"><code class="reqn">X_{S,[t_1,t_2]} \sim \mbox{Poisson}\left\{\int_S\int_{t_1}^{t_2} R(s,t)d sd t\right\}</code>
</p>

<p>Following Brix and Diggle (2001) and Diggle et al (2005), the intensity is decomposed multiplicatively as
</p>
<p style="text-align: center;"><code class="reqn">R(s,t) = \lambda(s)\mu(t)\exp\{\mathcal Y(s,t)\}.</code>
</p>

<p>In the above, the fixed spatial component, <code class="reqn">\lambda:R^2\mapsto R_{\geq 0}</code>, 
is a known function, proportional to the population at risk at each point in space and scaled so that
</p>
<p style="text-align: center;"><code class="reqn">\int_W\lambda(s)d s=1,</code>
</p>

<p>whilst the fixed temporal component, 
<code class="reqn">\mu:R_{\geq 0}\mapsto R_{\geq 0}</code>, is also a known function with
</p>
<p style="text-align: center;"><code class="reqn">\mu(t) \delta t = E[X_{W,\delta t}],</code>
</p>

<p>for <code class="reqn">t</code> in a small interval of time, <code class="reqn">\delta t</code>, over which the rate of the process over <code class="reqn">W</code> can be considered constant.
</p>
<p><b>
NOTE: the xyt stppp object can be recorded in continuous time, but for the purposes of prediciton,    
discretisation must take place. For the time dimension, this is achieved invisibly by <code>as.integer(xyt$t)</code> and
<code>as.integer(xyt$tlim)</code>. Therefore, before running an analysis please make sure that this is commensurate
with the physical inerpretation and requirements of your output. The spatial discretisation is
chosen with the argument cellwidth (or gridsize). If the chosen discretisation in time and space is too coarse for a
given set of parameters (sigma, phi and theta) then the proper correlation structures implied by the model will not
be captured in the output.
</b>
</p>
<p>Before calling this function, the user must decide on the time point of interest, the
number of intervals of data to use, the parameters, spatial covariance model, spatial discretisation,
fixed spatial (<code class="reqn">\lambda(s)</code>) and temporal (<code class="reqn">\mu(t)</code>) components, mcmc parameters, and whether or not any output is
required.
</p>


<h3>Value</h3>

<p>the results of fitting the model in an object of class <code>lgcpPredict</code>
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+lambdaEst">lambdaEst</a>, <a href="#topic+muEst">muEst</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+thetaEst">thetaEst</a>,  
<a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+lgcppars">lgcppars</a>, <a href="#topic+CovarianceFct">CovarianceFct</a>, <a href="#topic+mcmcpars">mcmcpars</a>, <a href="#topic+setoutput">setoutput</a> 
<a href="#topic+print.lgcpPredict">print.lgcpPredict</a>, <a href="#topic+xvals.lgcpPredict">xvals.lgcpPredict</a>, <a href="#topic+yvals.lgcpPredict">yvals.lgcpPredict</a>, <a href="#topic+plot.lgcpPredict">plot.lgcpPredict</a>, <a href="#topic+meanfield.lgcpPredict">meanfield.lgcpPredict</a>,
<a href="#topic+rr.lgcpPredict">rr.lgcpPredict</a>, <a href="#topic+serr.lgcpPredict">serr.lgcpPredict</a>, <a href="#topic+intens.lgcpPredict">intens.lgcpPredict</a>,   
<a href="#topic+varfield.lgcpPredict">varfield.lgcpPredict</a>, <a href="#topic+gridfun.lgcpPredict">gridfun.lgcpPredict</a>, <a href="#topic+gridav.lgcpPredict">gridav.lgcpPredict</a>, <a href="#topic+hvals.lgcpPredict">hvals.lgcpPredict</a>, <a href="#topic+window.lgcpPredict">window.lgcpPredict</a>,
<a href="#topic+mcmctrace.lgcpPredict">mcmctrace.lgcpPredict</a>, <a href="#topic+plotExceed.lgcpPredict">plotExceed.lgcpPredict</a>, <a href="#topic+quantile.lgcpPredict">quantile.lgcpPredict</a>, <a href="#topic+identify.lgcpPredict">identify.lgcpPredict</a>, <a href="#topic+expectation.lgcpPredict">expectation.lgcpPredict</a>,
<a href="#topic+extract.lgcpPredict">extract.lgcpPredict</a>, <a href="#topic+showGrid.lgcpPredict">showGrid.lgcpPredict</a>
</p>

<hr>
<h2 id='lgcpPredictAggregateSpatialPlusPars'>lgcpPredictAggregateSpatialPlusPars function</h2><span id='topic+lgcpPredictAggregateSpatialPlusPars'></span>

<h3>Description</h3>

<p>A function to deliver fully Bayesian inference for the aggregated spatial log-Gaussian Cox process.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpPredictAggregateSpatialPlusPars(
  formula,
  spdf,
  Zmat = NULL,
  overlayInZmat = FALSE,
  model.priors,
  model.inits = lgcpInits(),
  spatial.covmodel,
  cellwidth = NULL,
  poisson.offset = NULL,
  mcmc.control,
  output.control = setoutput(),
  gradtrunc = Inf,
  ext = 2,
  Nfreq = 101,
  inclusion = "touching",
  overlapping = FALSE,
  pixwts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_formula">formula</code></td>
<td>
<p>a formula object of the form X ~ var1 + var2 etc. The name of the dependent variable must be &quot;X&quot;. Only accepts 'simple' formulae, such as the example given.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_spdf">spdf</code></td>
<td>
<p>a SpatialPolygonsDataFrame object with variable &quot;X&quot;, the event counts per region.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_zmat">Zmat</code></td>
<td>
<p>design matrix Z (see below) constructed with getZmat</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_overlayinzmat">overlayInZmat</code></td>
<td>
<p>if the covariate information in Zmat also comes from spdf, set to TRUE to avoid replicating the overlay operations. Default is FALSE.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_model.priors">model.priors</code></td>
<td>
<p>model priors, set using lgcpPrior</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_model.inits">model.inits</code></td>
<td>
<p>model initial values. The default is NULL, in which case lgcp will use the prior mean to initialise eta and beta will be initialised from an oversispersed glm fit to the data. Otherwise use lgcpInits to specify.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>choice of spatial covariance function. See ?CovFunction</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_cellwidth">cellwidth</code></td>
<td>
<p>the width of computational cells</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_poisson.offset">poisson.offset</code></td>
<td>
<p>A SpatialAtRisk object defining lambda (see below)</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_mcmc.control">mcmc.control</code></td>
<td>
<p>MCMC paramters, see ?mcmcpars</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_output.control">output.control</code></td>
<td>
<p>output choice, see ?setoutput</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>truncation for gradient vector equal to H parameter Moller et al 1998 pp 473. Default is Inf, which means no gradient truncation, which seems to work in most settings.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_nfreq">Nfreq</code></td>
<td>
<p>the sampling frequency for the cell counts. Default is every 101 iterations.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former, the default, includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_overlapping">overlapping</code></td>
<td>
<p>logical does spdf contain overlapping polygons? Default is FALSE. If set to TRUE, spdf can contain a variable named 'sintens' that gives the sampling intensity for each polygon; the default is to assume that cases are evenly split between overlapping regions.</p>
</td></tr>
<tr><td><code id="lgcpPredictAggregateSpatialPlusPars_+3A_pixwts">pixwts</code></td>
<td>
<p>optional matrix of dimension (NM) x (number of regions in spdf) where M, N are the number of cells in the x and y directions (not the number of cells on the Fourier grid, rather the number of cell on the output grid). The ith row of this matrix are the probabilities that for the ith grid cell (in the same order as expand.grid(mcens,ncens)) a case belongs to each of the regions in spdf. Including this object overrides 'sintens' in the overlapping option above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette &quot;Bayesian_lgcp&quot; for examples of this code in use.<br />
</p>
<p>In this case, we OBSERVE case counts in the regions of a SpatialPolygonsDataFrame; the counts are stored as a variable, X.
The model for the UNOBSERVED data, X(s), is as follows:<br />
<br />
X(s) ~ Poisson[R(s)]<br />
<br />
R(s) = C_A lambda(s) exp[Z(s)beta+Y(s)]<br />
<br />
</p>
<p>Here X(s) is the number of events in the cell of the computational grid containing s, R(s) is the Poisson rate,
C_A is the cell area, lambda(s) is a known offset, Z(s) is a vector of measured covariates and Y(s) is the
latent Gaussian process on the computational grid. The other parameters in the model are beta, the covariate effects;
and eta=[log(sigma),log(phi)], the parameters of the process Y on an appropriately transformed (in this case log) scale.
</p>
<p>We recommend the user takes the following steps before running this method:
</p>

<ol>
<li><p> Compute approximate values of the parameters, eta, of the process Y using the function minimum.contrast.
These approximate values are used for two main reasons: (1) to help inform the size of the computational grid, since we
will need to use a cell width that enables us to capture the dependence properties of Y and (2) to help inform the
proposal kernel for the MCMC algorithm.
</p>
</li>
<li><p> Choose an appropriate grid on which to perform inference using the function chooseCellwidth; this will partly be determined
by the results of the first stage and partly by the available computational resource available to perform inference.
</p>
</li>
<li><p> Using the function getpolyol, construct the computational grid and polygon overlays, as required. As this can be an expensive step,
we recommend that the user saves this object after it has been
constructed and in future reference to the data, reloads this object, rather than having to re-compute it (provided the
computational grid has not changed).
</p>
</li>
<li><p> Decide on which covariates are to play a part in the analysis and use the lgcp function getZmat to interpolate these
onto the computational grid. Note that having saved the results from the previous step, this is a relatively quick operation,
and allows the user to quickly construct different design matrices, Z, from different candidate models for the data
</p>
</li>
<li><p> If required, set up the population offset using SpatialAtRisk functions (see the vignette &quot;Bayesian_lgcp&quot;); specify the priors
using lgcpPrior; and if desired, the initial values for the MCMC, using the function lgcpInits.
</p>
</li>
<li><p> Run the MCMC algorithm and save the output to disk. We recommend dumping information to disk using the dump2dir function
in the output.control argument because it offers much greater flexibility in terms of MCMC diagnosis and post-processing.
</p>
</li>
<li><p> Perform post-processing analyses including MCMC diagnostic checks and produce summaries of the posterior expectations
we require for presentation. (see the vignette &quot;Bayesian_lgcp&quot; for further details). Functions of use in this step include
traceplots, autocorr, parautocorr, ltar, parsummary, priorpost, postcov, textsummary, expectation, exceedProbs and lgcp:::expectation.lgcpPredict
</p>
</li></ol>



<h3>Value</h3>

<p>an object of class lgcpPredictAggregateSpatialPlusParameters
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle. Bayesian Inference and Data Augmentation Schemes for Spatial, Spatiotemporal and Multivariate Log-Gaussian Cox Processes in R. Submitted.
</p>
</li>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>



<h3>See Also</h3>

<p>linkchooseCellWidth, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>,  <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='lgcpPredictMultitypeSpatialPlusPars'>lgcpPredictMultitypeSpatialPlusPars function</h2><span id='topic+lgcpPredictMultitypeSpatialPlusPars'></span>

<h3>Description</h3>

<p>A function to deliver fully Bayesian inference for a multitype spatial log-Gaussian Cox process.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpPredictMultitypeSpatialPlusPars(
  formulaList,
  sd,
  typemark = NULL,
  Zmat = NULL,
  model.priorsList,
  model.initsList = NULL,
  spatial.covmodelList,
  cellwidth = NULL,
  poisson.offset = NULL,
  mcmc.control,
  output.control = setoutput(),
  gradtrunc = Inf,
  ext = 2,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_formulalist">formulaList</code></td>
<td>
<p>an object of class formulaList, see ?formulaList. A list of formulae of the form t1 ~ var1 + var2 etc. The name of the dependent variable must correspond to the name of the point type. Only accepts 'simple' formulae, such as the example given.</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_sd">sd</code></td>
<td>
<p>a marked ppp object, the mark of interest must be able to be coerced to a factor variable</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_typemark">typemark</code></td>
<td>
<p>if there are multiple marks, thrun the MCMC algorithm for spatial point process data. Not for general purpose use.is sets the name of the mark by which</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_zmat">Zmat</code></td>
<td>
<p>design matrix including all covariate effects from each point type, constructed with getZmat</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_model.priorslist">model.priorsList</code></td>
<td>
<p>model priors, a list object of length the number of types, each element set using lgcpPrior</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_model.initslist">model.initsList</code></td>
<td>
<p>list of model initial values (of length the number of types). The default is NULL, in which case lgcp will use the prior mean to initialise eta and beta will be initialised from an oversispersed glm fit to the data. Otherwise use lgcpInits to specify.</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_spatial.covmodellist">spatial.covmodelList</code></td>
<td>
<p>list of spatial covariance functions (of length the number of types). See ?CovFunction</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_cellwidth">cellwidth</code></td>
<td>
<p>the width of computational cells</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_poisson.offset">poisson.offset</code></td>
<td>
<p>A list of SpatialAtRisk objects (of length the number of types) defining lambda_k (see below)</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_mcmc.control">mcmc.control</code></td>
<td>
<p>MCMC paramters, see ?mcmcpars</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_output.control">output.control</code></td>
<td>
<p>output choice, see ?setoutput</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>truncation for gradient vector equal to H parameter Moller et al 1998 pp 473. Default is Inf, which means no gradient truncation, which seems to work in most settings.</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="lgcpPredictMultitypeSpatialPlusPars_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former, the default, includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette &quot;Bayesian_lgcp&quot; for examples of this code in use.<br />
</p>
<p>We suppose there are K point types of interest. The model for point-type k is as follows:<br />
<br />
X_k(s) ~ Poisson[R_k(s)]<br />
<br />
R_k(s) = C_A lambda_k(s) exp[Z_k(s)beta_k+Y_k(s)]<br />
<br />
</p>
<p>Here X_k(s) is the number of events of type k in the computational grid cell containing the
point s, R_k(s) is the Poisson rate, C_A is the cell area, lambda_k(s) is a known offset, Z_k(s) is a vector
of measured covariates and Y_i(s) where i = 1,...,K+1 are latent Gaussian processes on the
computational grid. The other parameters in the model are beta_k , the covariate effects for the
kth type; and eta_i = [log(sigma_i),log(phi_i)], the parameters of the process Y_i for i = 1,...,K+1 on
an appropriately transformed (again, in this case log) scale.
</p>
<p>We recommend the user takes the following steps before running this method:
</p>

<ol>
<li><p> Compute approximate values of the parameters, eta, of the process Y using the function minimum.contrast.
These approximate values are used for two main reasons: (1) to help inform the size of the computational grid, since we
will need to use a cell width that enables us to capture the dependence properties of Y and (2) to help inform the
proposal kernel for the MCMC algorithm.
</p>
</li>
<li><p> Choose an appropriate grid on which to perform inference using the function chooseCellwidth; this will partly be determined
by the results of the first stage and partly by the available computational resource available to perform inference.
</p>
</li>
<li><p> Using the function getpolyol, construct the computational grid and polygon overlays, as required. As this can be an expensive step,
we recommend that the user saves this object after it has been
constructed and in future reference to the data, reloads this object, rather than having to re-compute it (provided the
computational grid has not changed).
</p>
</li>
<li><p> Decide on which covariates are to play a part in the analysis and use the lgcp function getZmat to interpolate these
onto the computational grid. Note that having saved the results from the previous step, this is a relatively quick operation,
and allows the user to quickly construct different design matrices, Z, from different candidate models for the data
</p>
</li>
<li><p> If required, set up the population offset using SpatialAtRisk functions (see the vignette &quot;Bayesian_lgcp&quot;); specify the priors
using lgcpPrior; and if desired, the initial values for the MCMC, using the function lgcpInits.
</p>
</li>
<li><p> Run the MCMC algorithm and save the output to disk. We recommend dumping information to disk using the dump2dir function
in the output.control argument because it offers much greater flexibility in terms of MCMC diagnosis and post-processing.
</p>
</li>
<li><p> Perform post-processing analyses including MCMC diagnostic checks and produce summaries of the posterior expectations
we require for presentation. (see the vignette &quot;Bayesian_lgcp&quot; for further details). Functions of use in this step include
traceplots, autocorr, parautocorr, ltar, parsummary, priorpost, postcov, textsummary, expectation, exceedProbs and lgcp:::expectation.lgcpPredict
</p>
</li></ol>



<h3>Value</h3>

<p>an object of class lgcpPredictMultitypeSpatialPlusParameters
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle. Bayesian Inference and Data Augmentation Schemes for Spatial, Spatiotemporal and Multivariate Log-Gaussian Cox Processes in R. Submitted.
</p>
</li>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>



<h3>See Also</h3>

<p>linkchooseCellWidth, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='lgcpPredictSpatial'>lgcpPredictSpatial function</h2><span id='topic+lgcpPredictSpatial'></span>

<h3>Description</h3>

<p>The function <code>lgcpPredictSpatial</code> performs spatial prediction for log-Gaussian Cox Processes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpPredictSpatial(
  sd,
  model.parameters = lgcppars(),
  spatial.covmodel = "exponential",
  covpars = c(),
  cellwidth = NULL,
  gridsize = NULL,
  spatial.intensity,
  spatial.offset = NULL,
  mcmc.control,
  output.control = setoutput(),
  gradtrunc = Inf,
  ext = 2,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpPredictSpatial_+3A_sd">sd</code></td>
<td>
<p>a spatial point pattern object, see ?ppp</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_model.parameters">model.parameters</code></td>
<td>
<p>values for parameters, see ?lgcppars</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>correlation type see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_covpars">covpars</code></td>
<td>
<p>vector of additional parameters for certain classes of covariance function (eg Matern), these must be supplied in the order given in ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_cellwidth">cellwidth</code></td>
<td>
<p>width of grid cells on which to do MALA (grid cells are square) in same units as observation window. Note EITHER gridsize OR cellwidthe must be specified.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_gridsize">gridsize</code></td>
<td>
<p>size of output grid required. Note EITHER gridsize OR cellwidthe must be specified.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>the fixed spatial component: an object of that can be coerced to one of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_spatial.offset">spatial.offset</code></td>
<td>
<p>Numeric of length 1. Optional offset parameter, corresponding to the expected number of cases. NULL by default, in which case, this is estimateed from teh data.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_mcmc.control">mcmc.control</code></td>
<td>
<p>MCMC paramters, see ?mcmcpars</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_output.control">output.control</code></td>
<td>
<p>output choice, see ?setoutput</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>truncation for gradient vector equal to H parameter Moller et al 1998 pp 473. Default is Inf, which means no gradient truncation. Set to NULL to estimate this automatically (though note that this may not necessarily be a good choice). The default seems to work in most settings.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatial_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former, the default, includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following is a mathematical description of a log-Gaussian Cox Process, it is best viewed in the pdf version of the manual.
</p>
<p>Let <code class="reqn">\mathcal Y(s)</code> be a spatial Gaussian process and <code class="reqn">W\subset R^2</code> be an 
observation window in space. 
Cases occur at spatial positions <code class="reqn">x \in W</code> 
according to an inhomogeneous spatial Cox process,
i.e. a Poisson process with a stochastic intensity <code class="reqn">R(x)</code>,
The number of cases, <code class="reqn">X_{S}</code>, arising in 
any <code class="reqn">S \subseteq W</code> is 
then Poisson distributed conditional on <code class="reqn">R(\cdot)</code>,
</p>
<p style="text-align: center;"><code class="reqn">X_{S} \sim \mbox{Poisson}\left\{\int_S R(s)ds\right\}</code>
</p>

<p>Following Brix and Diggle (2001) and Diggle et al (2005) (but ignoring temporal variation), the intensity is decomposed multiplicatively as
</p>
<p style="text-align: center;"><code class="reqn">R(s,t) = \lambda(s)\exp\{\mathcal Y(s,t)\}.</code>
</p>

<p>In the above, the fixed spatial component, <code class="reqn">\lambda:R^2\mapsto R_{\geq 0}</code>, 
is a known function, proportional to the population at risk at each point in space and scaled so that
</p>
<p style="text-align: center;"><code class="reqn">\int_W\lambda(s)d s=1.</code>
</p>

<p>Before calling this function, the user must decide on the parameters, spatial covariance model, spatial discretisation,
fixed spatial (<code class="reqn">\lambda(s)</code>) component, mcmc parameters, and whether or not any output is
required. Note there is no autorotate option for this function.
</p>


<h3>Value</h3>

<p>the results of fitting the model in an object of class <code>lgcpPredict</code>
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a> <a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+lambdaEst">lambdaEst</a>, <a href="#topic+muEst">muEst</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+thetaEst">thetaEst</a>,  
<a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+lgcppars">lgcppars</a>, <a href="#topic+CovarianceFct">CovarianceFct</a>, <a href="#topic+mcmcpars">mcmcpars</a>, <a href="#topic+setoutput">setoutput</a> 
<a href="#topic+print.lgcpPredict">print.lgcpPredict</a>, <a href="#topic+xvals.lgcpPredict">xvals.lgcpPredict</a>, <a href="#topic+yvals.lgcpPredict">yvals.lgcpPredict</a>, <a href="#topic+plot.lgcpPredict">plot.lgcpPredict</a>, <a href="#topic+meanfield.lgcpPredict">meanfield.lgcpPredict</a>,
<a href="#topic+rr.lgcpPredict">rr.lgcpPredict</a>, <a href="#topic+serr.lgcpPredict">serr.lgcpPredict</a>, <a href="#topic+intens.lgcpPredict">intens.lgcpPredict</a>,   
<a href="#topic+varfield.lgcpPredict">varfield.lgcpPredict</a>, <a href="#topic+gridfun.lgcpPredict">gridfun.lgcpPredict</a>, <a href="#topic+gridav.lgcpPredict">gridav.lgcpPredict</a>, <a href="#topic+hvals.lgcpPredict">hvals.lgcpPredict</a>, <a href="#topic+window.lgcpPredict">window.lgcpPredict</a>,
<a href="#topic+mcmctrace.lgcpPredict">mcmctrace.lgcpPredict</a>, <a href="#topic+plotExceed.lgcpPredict">plotExceed.lgcpPredict</a>, <a href="#topic+quantile.lgcpPredict">quantile.lgcpPredict</a>, <a href="#topic+identify.lgcpPredict">identify.lgcpPredict</a>, <a href="#topic+expectation.lgcpPredict">expectation.lgcpPredict</a>,
<a href="#topic+extract.lgcpPredict">extract.lgcpPredict</a>, <a href="#topic+showGrid.lgcpPredict">showGrid.lgcpPredict</a>
</p>

<hr>
<h2 id='lgcpPredictSpatialINLA'>lgcpPredictSpatialINLA function</h2><span id='topic+lgcpPredictSpatialINLA'></span>

<h3>Description</h3>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
!IMPORTANT! after library(lgcp) this will be a dummy function.
In order to use, type getlgcpPredictSpatialINLA() at the console. This will download and install the true function.
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpPredictSpatialINLA(
  sd,
  ns,
  model.parameters = lgcppars(),
  spatial.covmodel = "exponential",
  covpars = c(),
  cellwidth = NULL,
  gridsize = NULL,
  spatial.intensity,
  ext = 2,
  optimverbose = FALSE,
  inlaverbose = TRUE,
  generic0hyper = list(theta = list(initial = 0, fixed = TRUE)),
  strategy = "simplified.laplace",
  method = "Nelder-Mead"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_sd">sd</code></td>
<td>
<p>a spatial point pattern object, see ?ppp</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_ns">ns</code></td>
<td>
<p>size of neighbourhood to use for GMRF approximation ns=1 corresponds to 3^2-1=8 eight neighbours around each point, ns=2 corresponds to 5^2-1=24 neighbours etc ...</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_model.parameters">model.parameters</code></td>
<td>
<p>values for parameters, see ?lgcppars</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>correlation type see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_covpars">covpars</code></td>
<td>
<p>vector of additional parameters for certain classes of covariance function (eg Matern), these must be supplied in the order given in ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_cellwidth">cellwidth</code></td>
<td>
<p>width of grid cells on which to do MALA (grid cells are square). Note EITHER gridsize OR cellwidthe must be specified.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_gridsize">gridsize</code></td>
<td>
<p>size of output grid required. Note EITHER gridsize OR cellwidthe must be specified.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>the fixed spatial component: an object of that can be coerced to one of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_optimverbose">optimverbose</code></td>
<td>
<p>logical whether to print optimisation details of covariance matching step</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_inlaverbose">inlaverbose</code></td>
<td>
<p>loogical whether to print the inla fitting procedure to the console</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_generic0hyper">generic0hyper</code></td>
<td>
<p>optional hyperparameter list specification for &quot;generic0&quot; INLA model. default is list(theta=list(initial=0,fixed=TRUE)), which effectively treats the precision matrix as known.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_strategy">strategy</code></td>
<td>
<p>inla strategy</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialINLA_+3A_method">method</code></td>
<td>
<p>optimisation method to be used in function matchcovariance, default is &quot;Nelder-Mead&quot;. See ?matchcovariance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>lgcpPredictSpatialINLA</code> performs spatial prediction for log-Gaussian Cox Processes using the integrated nested Laplace approximation.
</p>
<p>The following is a mathematical description of a log-Gaussian Cox Process, it is best viewed in the pdf version of the manual.
</p>
<p>Let <code class="reqn">\mathcal Y(s)</code> be a spatial Gaussian process and <code class="reqn">W\subset R^2</code> be an
observation window in space.
Cases occur at spatial positions <code class="reqn">x \in W</code>
according to an inhomogeneous spatial Cox process,
i.e. a Poisson process with a stochastic intensity <code class="reqn">R(x)</code>,
The number of cases, <code class="reqn">X_{S}</code>, arising in
any <code class="reqn">S \subseteq W</code> is
then Poisson distributed conditional on <code class="reqn">R(\cdot)</code>,
</p>
<p style="text-align: center;"><code class="reqn">X_{S} \sim \mbox{Poisson}\left\{\int_S R(s)ds\right\}</code>
</p>

<p>Following Brix and Diggle (2001) and Diggle et al (2005) (but ignoring temporal variation), the intensity is decomposed multiplicatively as
</p>
<p style="text-align: center;"><code class="reqn">R(s,t) = \lambda(s)\exp\{\mathcal Y(s,t)\}.</code>
</p>

<p>In the above, the fixed spatial component, <code class="reqn">\lambda:R^2\mapsto R_{\geq 0}</code>,
is a known function, proportional to the population at risk at each point in space and scaled so that
</p>
<p style="text-align: center;"><code class="reqn">\int_W\lambda(s)d s=1.</code>
</p>

<p>Before calling this function, the user must decide on the parameters, spatial covariance model, spatial discretisation,
fixed spatial (<code class="reqn">\lambda(s)</code>) component and whether or not any output is
required. Note there is no autorotate option for this function.
</p>


<h3>Value</h3>

<p>the results of fitting the model in an object of class <code>lgcpPredict</code>
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a> <a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+lambdaEst">lambdaEst</a>, <a href="#topic+muEst">muEst</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+thetaEst">thetaEst</a>,
<a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+lgcppars">lgcppars</a>, <a href="#topic+CovarianceFct">CovarianceFct</a>, <a href="#topic+mcmcpars">mcmcpars</a>, <a href="#topic+setoutput">setoutput</a>
<a href="#topic+print.lgcpPredict">print.lgcpPredict</a>, <a href="#topic+xvals.lgcpPredict">xvals.lgcpPredict</a>, <a href="#topic+yvals.lgcpPredict">yvals.lgcpPredict</a>, <a href="#topic+plot.lgcpPredict">plot.lgcpPredict</a>, <a href="#topic+meanfield.lgcpPredict">meanfield.lgcpPredict</a>,
<a href="#topic+rr.lgcpPredict">rr.lgcpPredict</a>, <a href="#topic+serr.lgcpPredict">serr.lgcpPredict</a>, <a href="#topic+intens.lgcpPredict">intens.lgcpPredict</a>,
<a href="#topic+varfield.lgcpPredict">varfield.lgcpPredict</a>, <a href="#topic+gridfun.lgcpPredict">gridfun.lgcpPredict</a>, <a href="#topic+gridav.lgcpPredict">gridav.lgcpPredict</a>, <a href="#topic+hvals.lgcpPredict">hvals.lgcpPredict</a>, <a href="#topic+window.lgcpPredict">window.lgcpPredict</a>,
<a href="#topic+mcmctrace.lgcpPredict">mcmctrace.lgcpPredict</a>, <a href="#topic+plotExceed.lgcpPredict">plotExceed.lgcpPredict</a>, <a href="#topic+quantile.lgcpPredict">quantile.lgcpPredict</a>, <a href="#topic+identify.lgcpPredict">identify.lgcpPredict</a>, <a href="#topic+expectation.lgcpPredict">expectation.lgcpPredict</a>,
<a href="#topic+extract.lgcpPredict">extract.lgcpPredict</a>, <a href="#topic+showGrid.lgcpPredict">showGrid.lgcpPredict</a>,
</p>

<hr>
<h2 id='lgcpPredictSpatialPlusPars'>lgcpPredictSpatialPlusPars function</h2><span id='topic+lgcpPredictSpatialPlusPars'></span>

<h3>Description</h3>

<p>A function to deliver fully Bayesian inference for the spatial log-Gaussian Cox process.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpPredictSpatialPlusPars(
  formula,
  sd,
  Zmat = NULL,
  model.priors,
  model.inits = lgcpInits(),
  spatial.covmodel,
  cellwidth = NULL,
  poisson.offset = NULL,
  mcmc.control,
  output.control = setoutput(),
  gradtrunc = Inf,
  ext = 2,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_formula">formula</code></td>
<td>
<p>a formula object of the form X ~ var1 + var2 etc. The name of the dependent variable must be &quot;X&quot;. Only accepts 'simple' formulae, such as the example given.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_sd">sd</code></td>
<td>
<p>a spatstat ppp object</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_zmat">Zmat</code></td>
<td>
<p>design matrix Z (see below) constructed with getZmat</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_model.priors">model.priors</code></td>
<td>
<p>model priors, set using lgcpPrior</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_model.inits">model.inits</code></td>
<td>
<p>model initial values. The default is NULL, in which case lgcp will use the prior mean to initialise eta and beta will be initialised from an oversispersed glm fit to the data. Otherwise use lgcpInits to specify.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>choice of spatial covariance function. See ?CovFunction</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_cellwidth">cellwidth</code></td>
<td>
<p>the width of computational cells</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_poisson.offset">poisson.offset</code></td>
<td>
<p>A SpatialAtRisk object defining lambda (see below)</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_mcmc.control">mcmc.control</code></td>
<td>
<p>MCMC paramters, see ?mcmcpars</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_output.control">output.control</code></td>
<td>
<p>output choice, see ?setoutput</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>truncation for gradient vector equal to H parameter Moller et al 1998 pp 473. Default is Inf, which means no gradient truncation, which seems to work in most settings.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatialPlusPars_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former, the default, includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette &quot;Bayesian_lgcp&quot; for examples of this code in use.<br />
</p>
<p>The model for the data is as follows:<br />
<br />
X(s) ~ Poisson[R(s)]<br />
<br />
R(s) = C_A lambda(s) exp[Z(s)beta+Y(s)]<br />
<br />
</p>
<p>Here X(s) is the number of events in the cell of the computational grid containing s, R(s) is the Poisson rate,
C_A is the cell area, lambda(s) is a known offset, Z(s) is a vector of measured covariates and Y(s) is the
latent Gaussian process on the computational grid. The other parameters in the model are beta, the covariate effects;
and eta=[log(sigma),log(phi)], the parameters of the process Y on an appropriately transformed (in this case log) scale.
</p>
<p>We recommend the user takes the following steps before running this method:
</p>

<ol>
<li><p> Compute approximate values of the parameters, eta, of the process Y using the function minimum.contrast.
These approximate values are used for two main reasons: (1) to help inform the size of the computational grid, since we
will need to use a cell width that enables us to capture the dependence properties of Y and (2) to help inform the
proposal kernel for the MCMC algorithm.
</p>
</li>
<li><p> Choose an appropriate grid on which to perform inference using the function chooseCellwidth; this will partly be determined
by the results of the first stage and partly by the available computational resource available to perform inference.
</p>
</li>
<li><p> Using the function getpolyol, construct the computational grid and polygon overlays, as required. As this can be an expensive step,
we recommend that the user saves this object after it has been
constructed and in future reference to the data, reloads this object, rather than having to re-compute it (provided the
computational grid has not changed).
</p>
</li>
<li><p> Decide on which covariates are to play a part in the analysis and use the lgcp function getZmat to interpolate these
onto the computational grid. Note that having saved the results from the previous step, this is a relatively quick operation,
and allows the user to quickly construct different design matrices, Z, from different candidate models for the data
</p>
</li>
<li><p> If required, set up the population offset using SpatialAtRisk functions (see the vignette &quot;Bayesian_lgcp&quot;); specify the priors
using lgcpPrior; and if desired, the initial values for the MCMC, using the function lgcpInits.
</p>
</li>
<li><p> Run the MCMC algorithm and save the output to disk. We recommend dumping information to disk using the dump2dir function
in the output.control argument because it offers much greater flexibility in terms of MCMC diagnosis and post-processing.
</p>
</li>
<li><p> Perform post-processing analyses including MCMC diagnostic checks and produce summaries of the posterior expectations
we require for presentation. (see the vignette &quot;Bayesian_lgcp&quot; for further details). Functions of use in this step include
traceplots, autocorr, parautocorr, ltar, parsummary, priorpost, postcov, textsummary, expectation, exceedProbs and lgcp:::expectation.lgcpPredict
</p>
</li></ol>



<h3>Value</h3>

<p>an object of class lgcpPredictSpatialOnlyPlusParameters
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle. Bayesian Inference and Data Augmentation Schemes for Spatial, Spatiotemporal and Multivariate Log-Gaussian Cox Processes in R. Submitted.
</p>
</li>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>



<h3>See Also</h3>

<p>linkchooseCellWidth, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='lgcpPredictSpatioTemporalPlusPars'>lgcpPredictSpatioTemporalPlusPars function</h2><span id='topic+lgcpPredictSpatioTemporalPlusPars'></span>

<h3>Description</h3>

<p>A function to deliver fully Bayesian inference for the spatiotemporal log-Gaussian Cox process.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpPredictSpatioTemporalPlusPars(
  formula,
  xyt,
  T,
  laglength,
  ZmatList = NULL,
  model.priors,
  model.inits = lgcpInits(),
  spatial.covmodel,
  cellwidth = NULL,
  poisson.offset = NULL,
  mcmc.control,
  output.control = setoutput(),
  gradtrunc = Inf,
  ext = 2,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_formula">formula</code></td>
<td>
<p>a formula object of the form X ~ var1 + var2 etc. The name of the dependent variable must be &quot;X&quot;. Only accepts 'simple' formulae, such as the example given.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_xyt">xyt</code></td>
<td>
<p>An object of class stppp</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_t">T</code></td>
<td>
<p>the time point of interest</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_laglength">laglength</code></td>
<td>
<p>the number of previous time points to include in the analysis</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_zmatlist">ZmatList</code></td>
<td>
<p>A list of design matrices Z constructed with getZmat and possibly addTemporalCovariates see the details below and Bayesian_lgcp vignette for details on how to construct this.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_model.priors">model.priors</code></td>
<td>
<p>model priors, set using lgcpPrior</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_model.inits">model.inits</code></td>
<td>
<p>model initial values. The default is NULL, in which case lgcp will use the prior mean to initialise eta and beta will be initialised from an oversispersed glm fit to the data. Otherwise use lgcpInits to specify.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>choice of spatial covariance function. See ?CovFunction</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_cellwidth">cellwidth</code></td>
<td>
<p>the width of computational cells</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_poisson.offset">poisson.offset</code></td>
<td>
<p>A list of SpatialAtRisk objects (of length the number of types) defining lambda_k (see below)</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_mcmc.control">mcmc.control</code></td>
<td>
<p>MCMC paramters, see ?mcmcpars</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_output.control">output.control</code></td>
<td>
<p>output choice, see ?setoutput</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>truncation for gradient vector equal to H parameter Moller et al 1998 pp 473. Default is Inf, which means no gradient truncation, which seems to work in most settings.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_ext">ext</code></td>
<td>
<p>integer multiple by which grid should be extended, default is 2. Generally this will not need to be altered, but if the spatial correlation decays slowly, increasing 'ext' may be necessary.</p>
</td></tr>
<tr><td><code id="lgcpPredictSpatioTemporalPlusPars_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former, the default, includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette &quot;Bayesian_lgcp&quot; for examples of this code in use.<br />
</p>
<p>The model for the data is as follows:<br />
<br />
X(s) ~ Poisson[R(s,t)]<br />
<br />
R(s) = C_A lambda(s,t) exp[Z(s,t)beta+Y(s,t)]<br />
<br />
</p>
<p>Here X(s,t) is the number of events in the cell of the computational grid containing s, R(s,t) is the Poisson rate,
C_A is the cell area, lambda(s,t) is a known offset, Z(s,t) is a vector of measured covariates and Y(s,t) is the
latent Gaussian process on the computational grid. The other parameters in the model are beta, the covariate effects;
and eta=[log(sigma),log(phi),log(theta)], the parameters of the process Y on an appropriately transformed (in this case log) scale.<br />
</p>
<p>We recommend the user takes the following steps before running this method:
</p>

<ol>
<li><p> Compute approximate values of the parameters, eta, of the process Y using the function minimum.contrast.
These approximate values are used for two main reasons: (1) to help inform the size of the computational grid, since we
will need to use a cell width that enables us to capture the dependence properties of Y and (2) to help inform the
proposal kernel for the MCMC algorithm.
</p>
</li>
<li><p> Choose an appropriate grid on which to perform inference using the function chooseCellwidth; this will partly be determined
by the results of the first stage and partly by the available computational resource available to perform inference.
</p>
</li>
<li><p> Using the function getpolyol, construct the computational grid and polygon overlays, as required. As this can be an expensive step,
we recommend that the user saves this object after it has been
constructed and in future reference to the data, reloads this object, rather than having to re-compute it (provided the
computational grid has not changed).
</p>
</li>
<li><p> Decide on which covariates are to play a part in the analysis and use the lgcp function getZmat to interpolate these
onto the computational grid. Note that having saved the results from the previous step, this is a relatively quick operation,
and allows the user to quickly construct different design matrices, Z, from different candidate models for the data
</p>
</li>
<li><p> If required, set up the population offset using SpatialAtRisk functions (see the vignette &quot;Bayesian_lgcp&quot;); specify the priors
using lgcpPrior; and if desired, the initial values for the MCMC, using the function lgcpInits.
</p>
</li>
<li><p> Run the MCMC algorithm and save the output to disk. We recommend dumping information to disk using the dump2dir function
in the output.control argument because it offers much greater flexibility in terms of MCMC diagnosis and post-processing.
</p>
</li>
<li><p> Perform post-processing analyses including MCMC diagnostic checks and produce summaries of the posterior expectations
we require for presentation. (see the vignette &quot;Bayesian_lgcp&quot; for further details). Functions of use in this step include
traceplots, autocorr, parautocorr, ltar, parsummary, priorpost, postcov, textsummary, expectation, exceedProbs and lgcp:::expectation.lgcpPredict
</p>
</li></ol>

<p>The user must provide a list of design matrices to use this function. In the interpolation step above, there are three cases to consider
</p>

<ol>
<li><p> where Z(s,t) cannot be decomposed, i.e., Z are true spatiotemporal covariates. In this case, each element of the list must
be constructed separately using the function getZmat on the covariates for each time point.
</p>
</li>
<li><p> Z(s,t)beta = Z_1(s)beta_1 + Z_2(t)beta_2: the spatial and temporal effects are separable;
in this case use the function addTemporalCovariates, to aid in the construction of the list.
</p>
</li>
<li><p> Z(s,t)beta = Z(s)beta, in which case the user only needs to perform the interpolation using getZmat
once, each of the elements of the  list will then be identical.
</p>
</li>
<li><p> Z(s,t)beta =  Z(t)beta in this case we follow the procedure for the separable case above.
For example, if dotw is a temporal covariate we would use formula &lt;- X ~ dotw for the main algorithm, formula.spatial &lt;- X ~ 1 to
interpolate the spatial covariates using getZmat, followed by temporal.formula &lt;- t ~ dotw - 1 using addTemporalCovariates
to construct the list of design matrices, Zmat.
</p>
</li></ol>



<h3>Value</h3>

<p>an object of class lgcpPredictSpatioTemporalPlusParameters
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle. Bayesian Inference and Data Augmentation Schemes for Spatial, Spatiotemporal and Multivariate Log-Gaussian Cox Processes in R. Submitted.
</p>
</li>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>



<h3>See Also</h3>

<p>linkchooseCellWidth, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='lgcpPrior'>lgcpPrior function</h2><span id='topic+lgcpPrior'></span>

<h3>Description</h3>

<p>A function to create the prior for beta and eta ready for a run of the MCMC algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpPrior(etaprior = NULL, betaprior = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpPrior_+3A_etaprior">etaprior</code></td>
<td>
<p>an object of class PriorSpec defining the prior for the parameters of the latent field, eta. See ?PriorSpec.list.</p>
</td></tr>
<tr><td><code id="lgcpPrior_+3A_betaprior">betaprior</code></td>
<td>
<p>etaprior an object of class PriorSpec defining the prior for the parameters of main effects, beta. See ?PriorSpec.list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R structure representing the prior density ready for a run of the MCMC algorithm.
</p>


<h3>See Also</h3>

<p><a href="#topic+GaussianPrior">GaussianPrior</a>, <a href="#topic+LogGaussianPrior">LogGaussianPrior</a>, <a href="#topic+PriorSpec.list">PriorSpec.list</a>, <a href="#topic+chooseCellwidth">chooseCellwidth</a>, <a href="#topic+getpolyol">getpolyol</a>, <a href="#topic+guessinterp">guessinterp</a>, <a href="#topic+getZmat">getZmat</a>,
<a href="#topic+addTemporalCovariates">addTemporalCovariates</a>, <a href="#topic+lgcpPrior">lgcpPrior</a>, <a href="#topic+lgcpInits">lgcpInits</a>, <a href="#topic+CovFunction">CovFunction</a>
<a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>, <a href="#topic+lgcpPredictSpatioTemporalPlusPars">lgcpPredictSpatioTemporalPlusPars</a>,
<a href="#topic+lgcpPredictMultitypeSpatialPlusPars">lgcpPredictMultitypeSpatialPlusPars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lgcpPrior(etaprior=PriorSpec(LogGaussianPrior(mean=log(c(1,500)),
    variance=diag(0.15,2))),betaprior=PriorSpec(GaussianPrior(mean=rep(0,9),
    variance=diag(10^6,9))))
</code></pre>

<hr>
<h2 id='lgcpSim'>lgcpSim function</h2><span id='topic+lgcpSim'></span>

<h3>Description</h3>

<p>Approximate simulation from a spatiotemoporal log-Gaussian Cox Process. Returns an stppp object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpSim(
  owin = NULL,
  tlim = as.integer(c(0, 10)),
  spatial.intensity = NULL,
  temporal.intensity = NULL,
  cellwidth = 0.05,
  model.parameters = lgcppars(sigma = 2, phi = 0.2, theta = 1),
  spatial.covmodel = "exponential",
  covpars = c(),
  returnintensities = FALSE,
  progressbar = TRUE,
  ext = 2,
  plot = FALSE,
  ratepow = 0.25,
  sleeptime = 0,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpSim_+3A_owin">owin</code></td>
<td>
<p>polygonal observation window</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_tlim">tlim</code></td>
<td>
<p>time interval on which to simulate data</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>object that can be coerced into a spatialAtRisk object. if NULL then uniform spatial is chosen</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_temporal.intensity">temporal.intensity</code></td>
<td>
<p>the fixed temporal component: either a numeric vector, or a function that can be coerced into an object of class temporalAtRisk</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_cellwidth">cellwidth</code></td>
<td>
<p>width of cells  in same units as observation window</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_model.parameters">model.parameters</code></td>
<td>
<p>parameters of model, see ?lgcppars.</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>spatial covariance function, default is exponential, see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_covpars">covpars</code></td>
<td>
<p>vector of additional parameters for spatial covariance function, in order they appear in chosen model in ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_returnintensities">returnintensities</code></td>
<td>
<p>logigal, whether to return the spatial intensities and true field Y at each time. Default FALSE.</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_progressbar">progressbar</code></td>
<td>
<p>logical, whether to print a progress bar. Default TRUE.</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_ext">ext</code></td>
<td>
<p>how much to extend the parameter space by. Default is 2.</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_plot">plot</code></td>
<td>
<p>logical, whether to plot intensities.</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_ratepow">ratepow</code></td>
<td>
<p>power that intensity is raised to for plotting purposes (makes the plot more pleasign to the eye), defaul 0.25</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_sleeptime">sleeptime</code></td>
<td>
<p>time in seconds to sleep between plots</p>
</td></tr>
<tr><td><code id="lgcpSim_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following is a mathematical description of a log-Gaussian Cox Process, it is best viewed in the pdf version of the manual.
</p>
<p>Let <code class="reqn">\mathcal Y(s,t)</code> be a spatiotemporal Gaussian process, <code class="reqn">W\subset R^2</code> be an
observation window in space and <code class="reqn">T\subset R_{\geq 0}</code> be an interval of time of interest.
Cases occur at spatio-temporal positions <code class="reqn">(x,t) \in W \times T</code>
according to an inhomogeneous spatio-temporal Cox process,
i.e. a Poisson process with a stochastic intensity <code class="reqn">R(x,t)</code>,
The number of cases, <code class="reqn">X_{S,[t_1,t_2]}</code>, arising in
any <code class="reqn">S \subseteq W</code> during the interval <code class="reqn">[t_1,t_2]\subseteq T</code> is
then Poisson distributed conditional on <code class="reqn">R(\cdot)</code>,
</p>
<p style="text-align: center;"><code class="reqn">X_{S,[t_1,t_2]} \sim \mbox{Poisson}\left\{\int_S\int_{t_1}^{t_2} R(s,t)d sd t\right\}</code>
</p>

<p>Following Brix and Diggle (2001) and Diggle et al (2005), the intensity is decomposed multiplicatively as
</p>
<p style="text-align: center;"><code class="reqn">R(s,t) = \lambda(s)\mu(t)\exp\{\mathcal Y(s,t)\}.</code>
</p>

<p>In the above, the fixed spatial component, <code class="reqn">\lambda:R^2\mapsto R_{\geq 0}</code>,
is a known function, proportional to the population at risk at each point in space and scaled so that
</p>
<p style="text-align: center;"><code class="reqn">\int_W\lambda(s)d s=1,</code>
</p>

<p>whilst the fixed temporal component,
<code class="reqn">\mu:R_{\geq 0}\mapsto R_{\geq 0}</code>, is also a known function with
</p>
<p style="text-align: center;"><code class="reqn">\mu(t) \delta t = E[X_{W,\delta t}],</code>
</p>

<p>for <code class="reqn">t</code> in a small interval of time, <code class="reqn">\delta t</code>, over which the rate of the process over <code class="reqn">W</code> can be considered constant.
</p>


<h3>Value</h3>

<p>an stppp object containing the data
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li>
<li><p> Wood ATA, Chan G (1994). Simulation of Stationary Gaussian Processes in [0,1]d. Journal of Computational and Graphical Statistics, 3(4), 409-432.
</p>
</li>
<li><p> Moller J, Syversveen AR, Waagepetersen RP (1998). Log Gaussian Cox Processes. Scandinavian Journal of Statistics, 25(3), 451-482.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+showGrid.stppp">showGrid.stppp</a>, <a href="#topic+stppp">stppp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: library(spatstat.explore); library(spatstat.utils); xyt &lt;- lgcpSim()
</code></pre>

<hr>
<h2 id='lgcpSimMultitypeSpatialCovariates'>lgcpSimMultitypeSpatialCovariates function</h2><span id='topic+lgcpSimMultitypeSpatialCovariates'></span>

<h3>Description</h3>

<p>A function to Simulate multivariate point process models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpSimMultitypeSpatialCovariates(
  formulaList,
  owin,
  regionalcovariates,
  pixelcovariates,
  betaList,
  spatial.offsetList = NULL,
  cellwidth,
  model.parameters,
  spatial.covmodel = "exponential",
  covpars = c(),
  ext = 2,
  plot = FALSE,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_formulalist">formulaList</code></td>
<td>
<p>a list of formulae objetcs</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_owin">owin</code></td>
<td>
<p>a spatstat owin object on which to simulate the data</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_regionalcovariates">regionalcovariates</code></td>
<td>
<p>a SpatialPolygonsDataFrame object</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_pixelcovariates">pixelcovariates</code></td>
<td>
<p>a SpatialPixelsDataFrame object</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_betalist">betaList</code></td>
<td>
<p>list of beta parameters</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_spatial.offsetlist">spatial.offsetList</code></td>
<td>
<p>list of poisson offsets</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_cellwidth">cellwidth</code></td>
<td>
<p>cellwidth</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_model.parameters">model.parameters</code></td>
<td>
<p>model parameters, a list eg list(sigma=1,phi=0.2)</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>the choice of spatial covariance model, can be anything from the RandomFields covariance function, CovariacenFct.</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_covpars">covpars</code></td>
<td>
<p>additional covariance parameters, for the chosen model, optional.</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_ext">ext</code></td>
<td>
<p>number of times to extend the simulation window</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_plot">plot</code></td>
<td>
<p>whether to plot the results automatically</p>
</td></tr>
<tr><td><code id="lgcpSimMultitypeSpatialCovariates_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former, the default, includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a marked ppp object, the simulated data
</p>

<hr>
<h2 id='lgcpSimSpatial'>lgcpSimSpatial function</h2><span id='topic+lgcpSimSpatial'></span>

<h3>Description</h3>

<p>A function to simulate from a log gaussian process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpSimSpatial(
  owin = NULL,
  spatial.intensity = NULL,
  expectednumcases = 100,
  cellwidth = 0.05,
  model.parameters = lgcppars(sigma = 2, phi = 0.2),
  spatial.covmodel = "exponential",
  covpars = c(),
  ext = 2,
  plot = FALSE,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpSimSpatial_+3A_owin">owin</code></td>
<td>
<p>observation window</p>
</td></tr>
<tr><td><code id="lgcpSimSpatial_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>an object that can be coerced to one of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="lgcpSimSpatial_+3A_expectednumcases">expectednumcases</code></td>
<td>
<p>the expected number of cases</p>
</td></tr>
<tr><td><code id="lgcpSimSpatial_+3A_cellwidth">cellwidth</code></td>
<td>
<p>width of cells in same units as observation window</p>
</td></tr>
<tr><td><code id="lgcpSimSpatial_+3A_model.parameters">model.parameters</code></td>
<td>
<p>parameters of model, see ?lgcppars. Only set sigma and phi for spatial model.</p>
</td></tr>
<tr><td><code id="lgcpSimSpatial_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>spatial covariance function, default is exponential, see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpSimSpatial_+3A_covpars">covpars</code></td>
<td>
<p>vector of additional parameters for spatial covariance function, in order they appear in chosen model in ?CovarianceFct</p>
</td></tr>
<tr><td><code id="lgcpSimSpatial_+3A_ext">ext</code></td>
<td>
<p>how much to extend the parameter space by. Default is 2.</p>
</td></tr>
<tr><td><code id="lgcpSimSpatial_+3A_plot">plot</code></td>
<td>
<p>logical, whether to plot the latent field.</p>
</td></tr>
<tr><td><code id="lgcpSimSpatial_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ppp object containing the data
</p>

<hr>
<h2 id='lgcpSimSpatialCovariates'>lgcpSimSpatialCovariates function</h2><span id='topic+lgcpSimSpatialCovariates'></span>

<h3>Description</h3>

<p>A function to  simulate a spatial LGCP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpSimSpatialCovariates(
  formula,
  owin,
  regionalcovariates = NULL,
  pixelcovariates = NULL,
  Zmat = NULL,
  beta,
  poisson.offset = NULL,
  cellwidth,
  model.parameters,
  spatial.covmodel = "exponential",
  covpars = c(),
  ext = 2,
  plot = FALSE,
  inclusion = "touching"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_formula">formula</code></td>
<td>
<p>a formula of the form X ~ var1 + var2 etc.</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_owin">owin</code></td>
<td>
<p>the observation window on which to do the simulation</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_regionalcovariates">regionalcovariates</code></td>
<td>
<p>an optional object of class SpatialPolygonsDataFrame containing covariates</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_pixelcovariates">pixelcovariates</code></td>
<td>
<p>an optional object of class SpatialPixelsDataFrame containing covariates</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_zmat">Zmat</code></td>
<td>
<p>optional design matrix, if the polygon/polygon overlays have already been computed</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_beta">beta</code></td>
<td>
<p>the parameters, beta for the model</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_poisson.offset">poisson.offset</code></td>
<td>
<p>the poisson offet, created using a SpatialAtRisk.fromXYZ class of objects</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_cellwidth">cellwidth</code></td>
<td>
<p>the with of cells on which to do the simulation</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_model.parameters">model.parameters</code></td>
<td>
<p>the paramters of the model eg list(sigma=1,phi=0.2)</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>the choice of spatial covariance model, can be anything from the RandomFields covariance function, CovariacenFct.</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_covpars">covpars</code></td>
<td>
<p>additional covariance parameters, for the chosen model, optional.</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_ext">ext</code></td>
<td>
<p>the amount by which to extend the observation grid in each direction, default is 2</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_plot">plot</code></td>
<td>
<p>whether to plot the resulting data</p>
</td></tr>
<tr><td><code id="lgcpSimSpatialCovariates_+3A_inclusion">inclusion</code></td>
<td>
<p>criterion for cells being included into observation window. Either 'touching' or 'centroid'. The former, the default, includes all cells that touch the observation window, the latter includes all cells whose centroids are inside the observation window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ppp onject containing the simulated data
</p>

<hr>
<h2 id='lgcpvignette'>lgcpvignette function</h2><span id='topic+lgcpvignette'></span>

<h3>Description</h3>

<p>Display the introductory vignette for the lgcp package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcpvignette()
</code></pre>


<h3>Value</h3>

<p>displays the vignette by calling browseURL
</p>

<hr>
<h2 id='loc2poly'>loc2poly function</h2><span id='topic+loc2poly'></span>

<h3>Description</h3>

<p>Converts a polygon selected via the mouse in a graphics window into an polygonal owin object. (Make sure the x and y scales are correct!)
Points must be selected traversing the required window in one direction (ie either clockwise, or anticlockwise), points must not be overlapping.
Select the sequence of edges via left mouse button clicks and store the polygon with a right click.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loc2poly(n = 512, type = "l", col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loc2poly_+3A_n">n</code></td>
<td>
<p>the maximum number of points to locate</p>
</td></tr>
<tr><td><code id="loc2poly_+3A_type">type</code></td>
<td>
<p>same as argument type in function locator. see ?locator. Default draws lines</p>
</td></tr>
<tr><td><code id="loc2poly_+3A_col">col</code></td>
<td>
<p>colour of lines/points</p>
</td></tr>
<tr><td><code id="loc2poly_+3A_...">...</code></td>
<td>
<p>other arguments to pass to locate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a polygonal owin object
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+identify.lgcpPredict">identify.lgcpPredict</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: plot(lg) # lg an lgcpPredict object
## Not run: subwin &lt;- loc2poly())
</code></pre>

<hr>
<h2 id='LogGaussianPrior'>LogGaussianPrior function</h2><span id='topic+LogGaussianPrior'></span>

<h3>Description</h3>

<p>A function to create a Gaussian prior on the log scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LogGaussianPrior(mean, variance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogGaussianPrior_+3A_mean">mean</code></td>
<td>
<p>a vector of length 2 representing the mean (on the log scale)</p>
</td></tr>
<tr><td><code id="LogGaussianPrior_+3A_variance">variance</code></td>
<td>
<p>a 2x2 matrix representing the variance (on the log scale)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class LogGaussianPrior that can be passed to the function PriorSpec.
</p>


<h3>See Also</h3>

<p><a href="#topic+GaussianPrior">GaussianPrior</a>, linkPriorSpec.list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: LogGaussianPrior(mean=log(c(1,500)),variance=diag(0.15,2))
</code></pre>

<hr>
<h2 id='loop.mcmc'>loop over an iterator</h2><span id='topic+loop.mcmc'></span>

<h3>Description</h3>

<p>useful for testing progress bars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loop.mcmc(object, sleep = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loop.mcmc_+3A_object">object</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
<tr><td><code id="loop.mcmc_+3A_sleep">sleep</code></td>
<td>
<p>pause between iterations in seconds</p>
</td></tr>
</table>

<hr>
<h2 id='ltar'>ltar function</h2><span id='topic+ltar'></span>

<h3>Description</h3>

<p>A function to return the sampled log-target from a call to the function lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars,
lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars. This is used as a convergence diagnostic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ltar(lg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltar_+3A_lg">lg</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars orlgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the log-target from each saved iteration of the MCMC chain.
</p>


<h3>See Also</h3>

<p><a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='MALAlgcp'>MALAlgcp function</h2><span id='topic+MALAlgcp'></span>

<h3>Description</h3>

<p>ADVANCED USE ONLY A function to perform MALA for the spatial only case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MALAlgcp(
  mcmcloop,
  inits,
  adaptivescheme,
  M,
  N,
  Mext,
  Next,
  sigma,
  phi,
  theta,
  mu,
  nis,
  cellarea,
  spatialvals,
  temporal.fitted,
  tdiff,
  scaleconst,
  rootQeigs,
  invrootQeigs,
  cellInside,
  MCMCdiag,
  gradtrunc,
  gridfun,
  gridav,
  mcens,
  ncens,
  aggtimes
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MALAlgcp_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>an mcmcLoop object</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_inits">inits</code></td>
<td>
<p>initial values from mcmc.control</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_adaptivescheme">adaptivescheme</code></td>
<td>
<p>adaptive scheme from mcmc.control</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_m">M</code></td>
<td>
<p>number of cells in x direction on output grid</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_n">N</code></td>
<td>
<p>number of cells in y direction on output grid</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_mext">Mext</code></td>
<td>
<p>number of cells in x direction on extended output grid</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_next">Next</code></td>
<td>
<p>number of cells in y direction on extended output grid</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_sigma">sigma</code></td>
<td>
<p>spatial covariance parameter sigma</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_phi">phi</code></td>
<td>
<p>spatial covariance parameter phi</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_theta">theta</code></td>
<td>
<p>temporal correlation parameter theta</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_mu">mu</code></td>
<td>
<p>spatial covariance parameter mu</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_nis">nis</code></td>
<td>
<p>cell counts matrix</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_cellarea">cellarea</code></td>
<td>
<p>area of cells</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_spatialvals">spatialvals</code></td>
<td>
<p>spatial at risk, function lambda, interpolated onto the requisite grid</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_temporal.fitted">temporal.fitted</code></td>
<td>
<p>temporal fitted values representing mu(t)</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_tdiff">tdiff</code></td>
<td>
<p>vecto of time differences with convention that the first element is Inf</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_scaleconst">scaleconst</code></td>
<td>
<p>expected number of observations</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_rootqeigs">rootQeigs</code></td>
<td>
<p>square root of eigenvalues of precision matrix</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_invrootqeigs">invrootQeigs</code></td>
<td>
<p>inverse square root of eigenvalues of precision matrix</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_cellinside">cellInside</code></td>
<td>
<p>logical matrix dictating whether cells are inside the observation window</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_mcmcdiag">MCMCdiag</code></td>
<td>
<p>defunct</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_gridfun">gridfun</code></td>
<td>
<p>grid functions</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_gridav">gridav</code></td>
<td>
<p>grid average functions</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_mcens">mcens</code></td>
<td>
<p>x-coordinates of cell centroids</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_ncens">ncens</code></td>
<td>
<p>y-coordinates of cell centroids</p>
</td></tr>
<tr><td><code id="MALAlgcp_+3A_aggtimes">aggtimes</code></td>
<td>
<p>z-coordinates of cell centroids (ie time)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object passed back to lgcpPredictSpatial
</p>

<hr>
<h2 id='MALAlgcpAggregateSpatial.PlusPars'>MALAlgcpAggregateSpatial.PlusPars function</h2><span id='topic+MALAlgcpAggregateSpatial.PlusPars'></span>

<h3>Description</h3>

<p>A function to run the MCMC algorithm for aggregated spatial point process data. Not for general purpose use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MALAlgcpAggregateSpatial.PlusPars(
  mcmcloop,
  inits,
  adaptivescheme,
  M,
  N,
  Mext,
  Next,
  mcens,
  ncens,
  formula,
  Zmat,
  model.priors,
  model.inits,
  fftgrid,
  spatial.covmodel,
  nis,
  cellarea,
  spatialvals,
  cellInside,
  MCMCdiag,
  gradtrunc,
  gridfun,
  gridav,
  d,
  spdf,
  ol,
  Nfreq
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>details of the mcmc loop</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_inits">inits</code></td>
<td>
<p>initial values</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_adaptivescheme">adaptivescheme</code></td>
<td>
<p>the adaptive MCMC scheme</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_m">M</code></td>
<td>
<p>number of grid cells in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_n">N</code></td>
<td>
<p>number of grid cells in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_mext">Mext</code></td>
<td>
<p>number of extended grid cells in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_next">Next</code></td>
<td>
<p>number of extended grid cells in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_mcens">mcens</code></td>
<td>
<p>centroids in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_ncens">ncens</code></td>
<td>
<p>centroids in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_formula">formula</code></td>
<td>
<p>a formula object of the form X ~ var1 + var2 etc.</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_zmat">Zmat</code></td>
<td>
<p>design matrix constructed using getZmat</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_model.priors">model.priors</code></td>
<td>
<p>model priors, constructed using lgcpPrior</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_model.inits">model.inits</code></td>
<td>
<p>initial values for the MCMC</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_fftgrid">fftgrid</code></td>
<td>
<p>an objects of class FFTgrid, see genFFTgrid</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>spatial covariance model, consructed with CovFunction</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_nis">nis</code></td>
<td>
<p>cell counts on the etended grid</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_spatialvals">spatialvals</code></td>
<td>
<p>inerpolated poisson offset on fft grid</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_cellinside">cellInside</code></td>
<td>
<p>0-1 matrix indicating inclusion in the observation window</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_mcmcdiag">MCMCdiag</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_gridfun">gridfun</code></td>
<td>
<p>used to specify other actions to be taken, e.g. dumping MCMC output to disk.</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_gridav">gridav</code></td>
<td>
<p>used for computing Monte Carlo expectations online</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_d">d</code></td>
<td>
<p>matrix of toral distances</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_spdf">spdf</code></td>
<td>
<p>the SpatialPolygonsDataFrame containing the aggregate counts as a variable X</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_ol">ol</code></td>
<td>
<p>overlay of fft grid onto spdf</p>
</td></tr>
<tr><td><code id="MALAlgcpAggregateSpatial.PlusPars_+3A_nfreq">Nfreq</code></td>
<td>
<p>frequency at which to resample nis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output from the MCMC run
</p>

<hr>
<h2 id='MALAlgcpMultitypeSpatial.PlusPars'>MALAlgcpMultitypeSpatial.PlusPars function</h2><span id='topic+MALAlgcpMultitypeSpatial.PlusPars'></span>

<h3>Description</h3>

<p>A function to run the MCMC algorithm for multivariate spatial point process data. Not for general purpose use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MALAlgcpMultitypeSpatial.PlusPars(
  mcmcloop,
  inits,
  adaptivescheme,
  M,
  N,
  Mext,
  Next,
  mcens,
  ncens,
  formulaList,
  zml,
  Zmat,
  model.priorsList,
  model.initsList,
  fftgrid,
  spatial.covmodelList,
  nis,
  cellarea,
  spatialvals,
  cellInside,
  MCMCdiag,
  gradtrunc,
  gridfun,
  gridav,
  marks,
  ntypes,
  d
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>details of the mcmc loop</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_inits">inits</code></td>
<td>
<p>initial values</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_adaptivescheme">adaptivescheme</code></td>
<td>
<p>the adaptive MCMC scheme</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_m">M</code></td>
<td>
<p>number of grid cells in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_n">N</code></td>
<td>
<p>number of grid cells in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_mext">Mext</code></td>
<td>
<p>number of extended grid cells in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_next">Next</code></td>
<td>
<p>number of extended grid cells in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_mcens">mcens</code></td>
<td>
<p>centroids in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_ncens">ncens</code></td>
<td>
<p>centroids in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_formulalist">formulaList</code></td>
<td>
<p>a list of formula objects of the form X ~ var1 + var2 etc.</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_zml">zml</code></td>
<td>
<p>list of design matrices</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_zmat">Zmat</code></td>
<td>
<p>a design matrix constructed using getZmat</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_model.priorslist">model.priorsList</code></td>
<td>
<p>list of model priors, see lgcpPriors</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_model.initslist">model.initsList</code></td>
<td>
<p>list of model initial values, see lgcpInits</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_fftgrid">fftgrid</code></td>
<td>
<p>an objects of class FFTgrid, see genFFTgrid</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_spatial.covmodellist">spatial.covmodelList</code></td>
<td>
<p>list of spatial covariance models constructed using CovFunction</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_nis">nis</code></td>
<td>
<p>cell counts on the etended grid</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_spatialvals">spatialvals</code></td>
<td>
<p>inerpolated poisson offset on fft grid</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_cellinside">cellInside</code></td>
<td>
<p>0-1 matrix indicating inclusion in the observation window</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_mcmcdiag">MCMCdiag</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_gridfun">gridfun</code></td>
<td>
<p>used to specify other actions to be taken, e.g. dumping MCMC output to disk.</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_gridav">gridav</code></td>
<td>
<p>used for computing Monte Carlo expectations online</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_marks">marks</code></td>
<td>
<p>the marks from the marked ppp object</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_ntypes">ntypes</code></td>
<td>
<p>the number of types being analysed</p>
</td></tr>
<tr><td><code id="MALAlgcpMultitypeSpatial.PlusPars_+3A_d">d</code></td>
<td>
<p>matrix of toral distances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output from the MCMC run
</p>

<hr>
<h2 id='MALAlgcpSpatial'>MALAlgcpSpatial function</h2><span id='topic+MALAlgcpSpatial'></span>

<h3>Description</h3>

<p>ADVANCED USE ONLY A function to perform MALA for the spatial only case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MALAlgcpSpatial(
  mcmcloop,
  inits,
  adaptivescheme,
  M,
  N,
  Mext,
  Next,
  sigma,
  phi,
  mu,
  nis,
  cellarea,
  spatialvals,
  scaleconst,
  rootQeigs,
  invrootQeigs,
  cellInside,
  MCMCdiag,
  gradtrunc,
  gridfun,
  gridav,
  mcens,
  ncens
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MALAlgcpSpatial_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>an mcmcLoop object</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_inits">inits</code></td>
<td>
<p>initial values from mcmc.control</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_adaptivescheme">adaptivescheme</code></td>
<td>
<p>adaptive scheme from mcmc.control</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_m">M</code></td>
<td>
<p>number of cells in x direction on output grid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_n">N</code></td>
<td>
<p>number of cells in y direction on output grid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_mext">Mext</code></td>
<td>
<p>number of cells in x direction on extended output grid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_next">Next</code></td>
<td>
<p>number of cells in y direction on extended output grid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_sigma">sigma</code></td>
<td>
<p>spatial covariance parameter sigma</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_phi">phi</code></td>
<td>
<p>spatial covariance parameter phi</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_mu">mu</code></td>
<td>
<p>spatial covariance parameter mu</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_nis">nis</code></td>
<td>
<p>cell counts matrix</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_cellarea">cellarea</code></td>
<td>
<p>area of cells</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_spatialvals">spatialvals</code></td>
<td>
<p>spatial at risk, function lambda, interpolated onto the requisite grid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_scaleconst">scaleconst</code></td>
<td>
<p>expected number of observations</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_rootqeigs">rootQeigs</code></td>
<td>
<p>square root of eigenvalues of precision matrix</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_invrootqeigs">invrootQeigs</code></td>
<td>
<p>inverse square root of eigenvalues of precision matrix</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_cellinside">cellInside</code></td>
<td>
<p>logical matrix dictating whether cells are inside the observation window</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_mcmcdiag">MCMCdiag</code></td>
<td>
<p>defunct</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_gridfun">gridfun</code></td>
<td>
<p>grid functions</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_gridav">gridav</code></td>
<td>
<p>grid average functions</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_mcens">mcens</code></td>
<td>
<p>x-coordinates of cell centroids</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial_+3A_ncens">ncens</code></td>
<td>
<p>y-coordinates of cell centroids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object passed back to lgcpPredictSpatial
</p>

<hr>
<h2 id='MALAlgcpSpatial.PlusPars'>MALAlgcpSpatial.PlusPars function</h2><span id='topic+MALAlgcpSpatial.PlusPars'></span>

<h3>Description</h3>

<p>A function to run the MCMC algorithm for spatial point process data. Not for general purpose use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MALAlgcpSpatial.PlusPars(
  mcmcloop,
  inits,
  adaptivescheme,
  M,
  N,
  Mext,
  Next,
  mcens,
  ncens,
  formula,
  Zmat,
  model.priors,
  model.inits,
  fftgrid,
  spatial.covmodel,
  nis,
  cellarea,
  spatialvals,
  cellInside,
  MCMCdiag,
  gradtrunc,
  gridfun,
  gridav,
  d
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>details of the mcmc loop</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_inits">inits</code></td>
<td>
<p>initial values</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_adaptivescheme">adaptivescheme</code></td>
<td>
<p>the adaptive MCMC scheme</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_m">M</code></td>
<td>
<p>number of grid cells in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_n">N</code></td>
<td>
<p>number of grid cells in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_mext">Mext</code></td>
<td>
<p>number of extended grid cells in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_next">Next</code></td>
<td>
<p>number of extended grid cells in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_mcens">mcens</code></td>
<td>
<p>centroids in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_ncens">ncens</code></td>
<td>
<p>centroids in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_formula">formula</code></td>
<td>
<p>a formula object of the form X ~ var1 + var2 etc.</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_zmat">Zmat</code></td>
<td>
<p>design matrix constructed using getZmat</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_model.priors">model.priors</code></td>
<td>
<p>model priors, constructed using lgcpPrior</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_model.inits">model.inits</code></td>
<td>
<p>initial values for the MCMC</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_fftgrid">fftgrid</code></td>
<td>
<p>an objects of class FFTgrid, see genFFTgrid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>spatial covariance model, consructed with CovFunction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_nis">nis</code></td>
<td>
<p>cell counts on the etended grid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_spatialvals">spatialvals</code></td>
<td>
<p>inerpolated poisson offset on fft grid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_cellinside">cellInside</code></td>
<td>
<p>0-1 matrix indicating inclusion in the observation window</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_mcmcdiag">MCMCdiag</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_gridfun">gridfun</code></td>
<td>
<p>used to specify other actions to be taken, e.g. dumping MCMC output to disk.</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_gridav">gridav</code></td>
<td>
<p>used for computing Monte Carlo expectations online</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatial.PlusPars_+3A_d">d</code></td>
<td>
<p>matrix of toral distances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output from the MCMC run
</p>

<hr>
<h2 id='MALAlgcpSpatioTemporal.PlusPars'>MALAlgcpSpatioTemporal.PlusPars function</h2><span id='topic+MALAlgcpSpatioTemporal.PlusPars'></span>

<h3>Description</h3>

<p>A function to run the MCMC algorithm for spatiotemporal point process data. Not for general purpose use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MALAlgcpSpatioTemporal.PlusPars(
  mcmcloop,
  inits,
  adaptivescheme,
  M,
  N,
  Mext,
  Next,
  mcens,
  ncens,
  formula,
  ZmatList,
  model.priors,
  model.inits,
  fftgrid,
  spatial.covmodel,
  nis,
  tdiff,
  cellarea,
  spatialvals,
  cellInside,
  MCMCdiag,
  gradtrunc,
  gridfun,
  gridav,
  d,
  aggtimes,
  spatialOnlyCovariates
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>details of the mcmc loop</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_inits">inits</code></td>
<td>
<p>initial values</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_adaptivescheme">adaptivescheme</code></td>
<td>
<p>the adaptive MCMC scheme</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_m">M</code></td>
<td>
<p>number of grid cells in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_n">N</code></td>
<td>
<p>number of grid cells in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_mext">Mext</code></td>
<td>
<p>number of extended grid cells in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_next">Next</code></td>
<td>
<p>number of extended grid cells in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_mcens">mcens</code></td>
<td>
<p>centroids in x direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_ncens">ncens</code></td>
<td>
<p>centroids in y direction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_formula">formula</code></td>
<td>
<p>a formula object of the form X ~ var1 + var2 etc.</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_zmatlist">ZmatList</code></td>
<td>
<p>list of design matrices constructed using getZmat</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_model.priors">model.priors</code></td>
<td>
<p>model priors, constructed using lgcpPrior</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_model.inits">model.inits</code></td>
<td>
<p>initial values for the MCMC</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_fftgrid">fftgrid</code></td>
<td>
<p>an objects of class FFTgrid, see genFFTgrid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>spatial covariance model, consructed with CovFunction</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_nis">nis</code></td>
<td>
<p>cell counts on the etended grid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_tdiff">tdiff</code></td>
<td>
<p>vector of time differences</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_spatialvals">spatialvals</code></td>
<td>
<p>inerpolated poisson offset on fft grid</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_cellinside">cellInside</code></td>
<td>
<p>0-1 matrix indicating inclusion in the observation window</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_mcmcdiag">MCMCdiag</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_gridfun">gridfun</code></td>
<td>
<p>used to specify other actions to be taken, e.g. dumping MCMC output to disk.</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_gridav">gridav</code></td>
<td>
<p>used for computing Monte Carlo expectations online</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_d">d</code></td>
<td>
<p>matrix of toral distances</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_aggtimes">aggtimes</code></td>
<td>
<p>the aggregate times</p>
</td></tr>
<tr><td><code id="MALAlgcpSpatioTemporal.PlusPars_+3A_spatialonlycovariates">spatialOnlyCovariates</code></td>
<td>
<p>whether this is a 'spatial' only problem</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output from the MCMC run
</p>

<hr>
<h2 id='matchcovariance'>matchcovariance function</h2><span id='topic+matchcovariance'></span>

<h3>Description</h3>

<p>A function to match the covariance matrix of a Gaussian Field with an approximate GMRF with neighbourhood size ns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchcovariance(
  xg,
  yg,
  ns,
  sigma,
  phi,
  model,
  additionalparameters,
  verbose = TRUE,
  r = 1,
  method = "Nelder-Mead"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchcovariance_+3A_xg">xg</code></td>
<td>
<p>x grid must be equally spaced</p>
</td></tr>
<tr><td><code id="matchcovariance_+3A_yg">yg</code></td>
<td>
<p>y grid must be equally spaced</p>
</td></tr>
<tr><td><code id="matchcovariance_+3A_ns">ns</code></td>
<td>
<p>neighbourhood size</p>
</td></tr>
<tr><td><code id="matchcovariance_+3A_sigma">sigma</code></td>
<td>
<p>spatial variability parameter</p>
</td></tr>
<tr><td><code id="matchcovariance_+3A_phi">phi</code></td>
<td>
<p>spatial dependence parameter</p>
</td></tr>
<tr><td><code id="matchcovariance_+3A_model">model</code></td>
<td>
<p>covariance model, see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="matchcovariance_+3A_additionalparameters">additionalparameters</code></td>
<td>
<p>additional parameters for chosen covariance model</p>
</td></tr>
<tr><td><code id="matchcovariance_+3A_verbose">verbose</code></td>
<td>
<p>whether or not to print stuff generated by the optimiser</p>
</td></tr>
<tr><td><code id="matchcovariance_+3A_r">r</code></td>
<td>
<p>parameter used in optimisation, see Rue and Held (2005) pp 188. default value 1.</p>
</td></tr>
<tr><td><code id="matchcovariance_+3A_method">method</code></td>
<td>
<p>The choice of optimising routine must either be 'Nelder-Mead' or 'BFGS'. see ?optim</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='maternCovFct15'>maternCovFct15 function</h2><span id='topic+maternCovFct15'></span>

<h3>Description</h3>

<p>A function to declare and also evaluate an Matern 1.5 covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maternCovFct15(d, CovParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maternCovFct15_+3A_d">d</code></td>
<td>
<p>toral distance</p>
</td></tr>
<tr><td><code id="maternCovFct15_+3A_covparameters">CovParameters</code></td>
<td>
<p>parameters of the latent field, an object of class &quot;CovParamaters&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the exponential covariance function
</p>


<h3>Author(s)</h3>

<p>Dominic Schumacher
</p>


<h3>See Also</h3>

<p><a href="#topic+CovFunction.function">CovFunction.function</a>, <a href="#topic+RandomFieldsCovFct">RandomFieldsCovFct</a>, <a href="#topic+SpikedExponentialCovFct">SpikedExponentialCovFct</a>
</p>

<hr>
<h2 id='maternCovFct25'>maternCovFct25 function</h2><span id='topic+maternCovFct25'></span>

<h3>Description</h3>

<p>A function to declare and also evaluate an Matern 2.5 covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maternCovFct25(d, CovParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maternCovFct25_+3A_d">d</code></td>
<td>
<p>toral distance</p>
</td></tr>
<tr><td><code id="maternCovFct25_+3A_covparameters">CovParameters</code></td>
<td>
<p>parameters of the latent field, an object of class &quot;CovParamaters&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the exponential covariance function
</p>


<h3>Author(s)</h3>

<p>Dominic Schumacher
</p>


<h3>See Also</h3>

<p><a href="#topic+CovFunction.function">CovFunction.function</a>, <a href="#topic+RandomFieldsCovFct">RandomFieldsCovFct</a>, <a href="#topic+SpikedExponentialCovFct">SpikedExponentialCovFct</a>
</p>

<hr>
<h2 id='mcmcLoop'>iterator for MCMC loops</h2><span id='topic+mcmcLoop'></span>

<h3>Description</h3>

<p>control an MCMC loop with this iterator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcLoop(N, burnin, thin, trim = TRUE, progressor = mcmcProgressPrint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcLoop_+3A_n">N</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="mcmcLoop_+3A_burnin">burnin</code></td>
<td>
<p>length of burn-in</p>
</td></tr>
<tr><td><code id="mcmcLoop_+3A_thin">thin</code></td>
<td>
<p>frequency of thinning</p>
</td></tr>
<tr><td><code id="mcmcLoop_+3A_trim">trim</code></td>
<td>
<p>whether to cut off iterations after the last retained iteration</p>
</td></tr>
<tr><td><code id="mcmcLoop_+3A_progressor">progressor</code></td>
<td>
<p>a function that returns a progress object</p>
</td></tr>
</table>

<hr>
<h2 id='mcmcpars'>mcmcpars function</h2><span id='topic+mcmcpars'></span>

<h3>Description</h3>

<p>A function for setting MCMC options in a run of <code>lgcpPredict</code> for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcpars(mala.length, burnin, retain, inits = NULL, adaptivescheme)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcpars_+3A_mala.length">mala.length</code></td>
<td>
<p>default = 100,</p>
</td></tr>
<tr><td><code id="mcmcpars_+3A_burnin">burnin</code></td>
<td>
<p>default = floor(mala.length/2),</p>
</td></tr>
<tr><td><code id="mcmcpars_+3A_retain">retain</code></td>
<td>
<p>thinning parameter eg operated on chain every 'retain' iteration (eg store output or compute some posterior functional)</p>
</td></tr>
<tr><td><code id="mcmcpars_+3A_inits">inits</code></td>
<td>
<p>optional initial values for MCMC</p>
</td></tr>
<tr><td><code id="mcmcpars_+3A_adaptivescheme">adaptivescheme</code></td>
<td>
<p>the type of adaptive mcmc to use, see ?constanth (constant h) or ?andrieuthomsh (adaptive MCMC of Andrieu and Thoms (2008))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mcmc parameters
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='mcmcProgressNone'>null progress monitor</h2><span id='topic+mcmcProgressNone'></span>

<h3>Description</h3>

<p>a progress monitor that does nothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcProgressNone(mcmcloop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcProgressNone_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>an mcmc loop iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a progress monitor
</p>

<hr>
<h2 id='mcmcProgressPrint'>printing progress monitor</h2><span id='topic+mcmcProgressPrint'></span>

<h3>Description</h3>

<p>a progress monitor that prints each iteration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcProgressPrint(mcmcloop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcProgressPrint_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>an mcmc loop iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a progress monitor
</p>

<hr>
<h2 id='mcmcProgressTextBar'>text bar progress monitor</h2><span id='topic+mcmcProgressTextBar'></span>

<h3>Description</h3>

<p>a progress monitor that uses a text progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcProgressTextBar(mcmcloop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcProgressTextBar_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>an mcmc loop iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a progress monitor
</p>

<hr>
<h2 id='mcmcProgressTk'>graphical progress monitor</h2><span id='topic+mcmcProgressTk'></span>

<h3>Description</h3>

<p>a progress monitor that uses tcltk dialogs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcProgressTk(mcmcloop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcProgressTk_+3A_mcmcloop">mcmcloop</code></td>
<td>
<p>an mcmc loop iterator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a progress monitor
</p>

<hr>
<h2 id='mcmctrace'>mcmctrace function</h2><span id='topic+mcmctrace'></span>

<h3>Description</h3>

<p>Generic function to extract the information required to produce MCMC trace plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmctrace(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmctrace_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="mcmctrace_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method mcmctrace
</p>

<hr>
<h2 id='mcmctrace.lgcpPredict'>mcmctrace.lgcpPredict function</h2><span id='topic+mcmctrace.lgcpPredict'></span>

<h3>Description</h3>

<p>If <code>MCMCdiag</code> was positive when <code>lgcpPredict</code> was called, then this retrieves information from the chains stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
mcmctrace(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmctrace.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="mcmctrace.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the saved MCMC chains in an object of class <code>mcmcdiag</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+plot.mcmcdiag">plot.mcmcdiag</a>
</p>

<hr>
<h2 id='meanfield'>meanfield function</h2><span id='topic+meanfield'></span>

<h3>Description</h3>

<p>Generic function to extract the mean of the latent field Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanfield(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanfield_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="meanfield_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method meanfield
</p>

<hr>
<h2 id='meanfield.lgcpPredict'>meanfield.lgcpPredict function</h2><span id='topic+meanfield.lgcpPredict'></span>

<h3>Description</h3>

<p>This is an accessor function for objects of class <code>lgcpPredict</code> and returns the mean of the
field Y as an lgcpgrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
meanfield(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanfield.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="meanfield.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the cell-wise mean of Y computed via Monte Carlo.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+lgcpgrid">lgcpgrid</a>
</p>

<hr>
<h2 id='meanfield.lgcpPredictINLA'>meanfield.lgcpPredictINLA function</h2><span id='topic+meanfield.lgcpPredictINLA'></span>

<h3>Description</h3>

<p>A function to return the mean of the latent field from a call to lgcpPredictINLA output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredictINLA'
meanfield(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanfield.lgcpPredictINLA_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredictINLA</p>
</td></tr>
<tr><td><code id="meanfield.lgcpPredictINLA_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean of the latent field
</p>

<hr>
<h2 id='MonteCarloAverage'>MonteCarloAverage function</h2><span id='topic+MonteCarloAverage'></span>

<h3>Description</h3>

<p>This function creates an object of class <code>MonteCarloAverage</code>. The purpose of the function is to compute 
Monte Carlo expectations online in the function <code>lgcpPredict</code>, it is set in the argument <code>gridmeans</code>
of the argument <code>output.control</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MonteCarloAverage(funlist, lastonly = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MonteCarloAverage_+3A_funlist">funlist</code></td>
<td>
<p>a character vector of names of functions, each accepting single argument Y</p>
</td></tr>
<tr><td><code id="MonteCarloAverage_+3A_lastonly">lastonly</code></td>
<td>
<p>compute average using only time T? (see ?lgcpPredict for definition of T)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Monte Carlo Average is computed as:
</p>
<p style="text-align: center;"><code class="reqn">E_{\pi(Y_{t_1:t_2}|X_{t_1:t_2})}[g(Y_{t_1:t_2})] \approx \frac1n\sum_{i=1}^n g(Y_{t_1:t_2}^{(i)})</code>
</p>

<p>where <code class="reqn">g</code> is a function of interest, <code class="reqn">Y_{t_1:t_2}^{(i)}</code> is the <code class="reqn">i</code>th retained sample from the target  
and <code class="reqn">n</code> is the total number of retained iterations. For example, to compute the mean of <code class="reqn">Y_{t_1:t_2}</code> set,
</p>
<p style="text-align: center;"><code class="reqn">g(Y_{t_1:t_2}) = Y_{t_1:t_2},</code>
</p>

<p>the output from such a Monte Carlo average would be a set of <code class="reqn">t_2-t_1</code> grids, each cell of which 
being equal to the mean over all retained iterations of the algorithm (NOTE: this is just an example computation, in
practice, there is no need to compute the mean on line explicitly, as this is already done by defaul in <code>lgcpPredict</code>).
For further examples, see below. The option <code>last=TRUE</code> computes,
</p>
<p style="text-align: center;"><code class="reqn">E_{\pi(Y_{t_1:t_2}|X_{t_1:t_2})}[g(Y_{t_2})],</code>
</p>

<p>so in this case the expectation over the last time point only is computed. This can save computation time.
</p>


<h3>Value</h3>

<p>object of class MonteCarloAverage
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>, <a href="#topic+exceedProbs">exceedProbs</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun1 &lt;- function(x){return(x)}   # gives the mean
fun2 &lt;- function(x){return(x^2)} # computes E(X^2). Can be used with the 
                                 # mean to compute variances, since 
                                 # Var(X) = E(X^2) - E(X)^2
fun3 &lt;- exceedProbs(c(1.5,2,3))  # exceedance probabilities, 
                                 #see ?exceedProbs
mca &lt;- MonteCarloAverage(c("fun1","fun2","fun3"))
mca2 &lt;- MonteCarloAverage(c("fun1","fun2","fun3"),lastonly=TRUE)
</code></pre>

<hr>
<h2 id='mstppp'>mstppp function</h2><span id='topic+mstppp'></span>

<h3>Description</h3>

<p>Generic function used in the construction of marked space-time planar point patterns. An mstppp object is like an stppp object,
but with an extra component containing a data frame (the mark information).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstppp(P, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstppp_+3A_p">P</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="mstppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observations are assumed to occur in the plane and the observation window is assumed not to change over time.
</p>


<h3>Value</h3>

<p>method mstppp
</p>


<h3>See Also</h3>

<p><a href="#topic+mstppp">mstppp</a>, <a href="#topic+mstppp.ppp">mstppp.ppp</a>, <a href="#topic+mstppp.list">mstppp.list</a>
</p>

<hr>
<h2 id='mstppp.list'>mstppp.list function</h2><span id='topic+mstppp.list'></span>

<h3>Description</h3>

<p>Construct a marked space-time planar point pattern from a list object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
mstppp(P, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstppp.list_+3A_p">P</code></td>
<td>
<p>list object containing $xyt, an (n x 3) matrix corresponding to (x,y,t) values; $tlim, a vector of length 2 givign the observation time window, 
$window giving an owin spatial observation winow, see ?owin for more details, and $data, a data frame containing the collection of marks</p>
</td></tr>
<tr><td><code id="mstppp.list_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class mstppp
</p>


<h3>See Also</h3>

<p><a href="#topic+mstppp">mstppp</a>, <a href="#topic+mstppp.ppp">mstppp.ppp</a>,
</p>

<hr>
<h2 id='mstppp.ppp'>mstppp.ppp function</h2><span id='topic+mstppp.ppp'></span>

<h3>Description</h3>

<p>Construct a marked space-time planar point pattern from a ppp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
mstppp(P, t, tlim, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstppp.ppp_+3A_p">P</code></td>
<td>
<p>a spatstat ppp object</p>
</td></tr>
<tr><td><code id="mstppp.ppp_+3A_t">t</code></td>
<td>
<p>a vector of length P$n</p>
</td></tr>
<tr><td><code id="mstppp.ppp_+3A_tlim">tlim</code></td>
<td>
<p>a vector of length 2 specifying the observation time window</p>
</td></tr>
<tr><td><code id="mstppp.ppp_+3A_data">data</code></td>
<td>
<p>a data frame containing the collection of marks</p>
</td></tr>
<tr><td><code id="mstppp.ppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class mstppp
</p>


<h3>See Also</h3>

<p><a href="#topic+mstppp">mstppp</a>, <a href="#topic+mstppp.list">mstppp.list</a>
</p>

<hr>
<h2 id='mstppp.stppp'>mstppp.stppp function</h2><span id='topic+mstppp.stppp'></span>

<h3>Description</h3>

<p>Construct a marked space-time planar point pattern from an stppp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
mstppp(P, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstppp.stppp_+3A_p">P</code></td>
<td>
<p>an lgcp stppp object</p>
</td></tr>
<tr><td><code id="mstppp.stppp_+3A_data">data</code></td>
<td>
<p>a data frame containing the collection of marks</p>
</td></tr>
<tr><td><code id="mstppp.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class mstppp
</p>


<h3>See Also</h3>

<p><a href="#topic+mstppp">mstppp</a>, <a href="#topic+mstppp.list">mstppp.list</a>
</p>

<hr>
<h2 id='muEst'>muEst function</h2><span id='topic+muEst'></span>

<h3>Description</h3>

<p>Computes a non-parametric estimate of mu(t). For the purposes of performing prediction, the alternatives are: (1) use a parameteric model as in Diggle P, Rowlingson B, Su T (2005),
or (2) a <a href="#topic+constantInTime">constantInTime</a> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muEst(xyt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muEst_+3A_xyt">xyt</code></td>
<td>
<p>an stppp object</p>
</td></tr>
<tr><td><code id="muEst_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to lowess</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class temporalAtRisk giving the smoothed mut using the lowess function
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+constantInTime">constantInTime</a>, <a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+thetaEst">thetaEst</a>, <a href="#topic+lambdaEst">lambdaEst</a>
</p>

<hr>
<h2 id='multiply.list'>multiply.list function</h2><span id='topic+multiply.list'></span>

<h3>Description</h3>

<p>This function multiplies the elements of two list objects together and returns the result in another list object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiply.list(list1, list2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiply.list_+3A_list1">list1</code></td>
<td>
<p>a list of objects that could be summed using &quot;+&quot;</p>
</td></tr>
<tr><td><code id="multiply.list_+3A_list2">list2</code></td>
<td>
<p>a list of objects that could be summed using &quot;+&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with ith entry the sum of list1[[i]] and list2[[i]]
</p>

<hr>
<h2 id='neattable'>neattable function</h2><span id='topic+neattable'></span>

<h3>Description</h3>

<p>Function to print right-aligned tables to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neattable(mat, indent = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neattable_+3A_mat">mat</code></td>
<td>
<p>a numeric or character matrix object</p>
</td></tr>
<tr><td><code id="neattable_+3A_indent">indent</code></td>
<td>
<p>indent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints to screen with specified indent
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- rbind(c("one","two","three"),matrix(round(runif(9),3),3,3))
neattable(mat)
</code></pre>

<hr>
<h2 id='neigh2D'>neigh2D function</h2><span id='topic+neigh2D'></span>

<h3>Description</h3>

<p>A function to compute the neighbours of a cell on a toral grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neigh2D(i, j, ns, M, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neigh2D_+3A_i">i</code></td>
<td>
<p>cell index i</p>
</td></tr>
<tr><td><code id="neigh2D_+3A_j">j</code></td>
<td>
<p>cell index j</p>
</td></tr>
<tr><td><code id="neigh2D_+3A_ns">ns</code></td>
<td>
<p>number of neighbours either side</p>
</td></tr>
<tr><td><code id="neigh2D_+3A_m">M</code></td>
<td>
<p>size of grid in x direction</p>
</td></tr>
<tr><td><code id="neigh2D_+3A_n">N</code></td>
<td>
<p>size of grid in y direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the cell indices of the neighbours
</p>

<hr>
<h2 id='nextStep'>next step of an MCMC chain</h2><span id='topic+nextStep'></span>

<h3>Description</h3>

<p>just a wrapper for nextElem really.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nextStep(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextStep_+3A_object">object</code></td>
<td>
<p>an mcmc loop object</p>
</td></tr>
</table>

<hr>
<h2 id='nullAverage'>nullAverage function</h2><span id='topic+nullAverage'></span>

<h3>Description</h3>

<p>A null scheme, that does not perform any computation in the running of <code>lgcpPredict</code>, it is the default
value of <code>gridmeans</code> in the argument <code>output.control</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullAverage()
</code></pre>


<h3>Value</h3>

<p>object of class nullAverage
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+GAinitialise">GAinitialise</a>, <a href="#topic+GAupdate">GAupdate</a>, <a href="#topic+GAfinalise">GAfinalise</a>, <a href="#topic+GAreturnvalue">GAreturnvalue</a>
</p>

<hr>
<h2 id='nullFunction'>nullFunction function</h2><span id='topic+nullFunction'></span>

<h3>Description</h3>

<p>This is a null function and performs no action.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullFunction()
</code></pre>


<h3>Value</h3>

<p>object of class nullFunction
</p>


<h3>See Also</h3>

<p><a href="#topic+setoutput">setoutput</a>, <a href="#topic+GFinitialise">GFinitialise</a>, <a href="#topic+GFupdate">GFupdate</a>, <a href="#topic+GFfinalise">GFfinalise</a>, <a href="#topic+GFreturnvalue">GFreturnvalue</a>
</p>

<hr>
<h2 id='numCases'>numCases function</h2><span id='topic+numCases'></span>

<h3>Description</h3>

<p>A function used in conjunction with the function &quot;expectation&quot; to compute the expected number of cases in each computational grid cell. Currently
only implemented for spatial processes (lgcpPredictSpatialPlusPars and lgcpPredictAggregateSpatialPlusPars).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numCases(Y, beta, eta, Z, otherargs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numCases_+3A_y">Y</code></td>
<td>
<p>the latent field</p>
</td></tr>
<tr><td><code id="numCases_+3A_beta">beta</code></td>
<td>
<p>the main effects</p>
</td></tr>
<tr><td><code id="numCases_+3A_eta">eta</code></td>
<td>
<p>the parameters of the latent field</p>
</td></tr>
<tr><td><code id="numCases_+3A_z">Z</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="numCases_+3A_otherargs">otherargs</code></td>
<td>
<p>other arguments to the function (see vignette &quot;Bayesian_lgcp&quot; for an explanation)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of cases in each cell
</p>


<h3>See Also</h3>

<p><a href="#topic+expectation">expectation</a>,  <a href="#topic+lgcpPredictSpatialPlusPars">lgcpPredictSpatialPlusPars</a>, <a href="#topic+lgcpPredictAggregateSpatialPlusPars">lgcpPredictAggregateSpatialPlusPars</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ex &lt;- expectation(lg,numCases)[[1]] # lg is output from spatial LGCP MCMC
</code></pre>

<hr>
<h2 id='osppp2latlon'>osppp2latlon function</h2><span id='topic+osppp2latlon'></span>

<h3>Description</h3>

<p>A function to transform a ppp object in the OSGB projection (epsg:27700) to a ppp object in the latitude/longitude (epsg:4326) projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osppp2latlon(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osppp2latlon_+3A_obj">obj</code></td>
<td>
<p>a ppp object in OSGB</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pppobject in Lat/Lon
</p>

<hr>
<h2 id='osppp2merc'>osppp2merc function</h2><span id='topic+osppp2merc'></span>

<h3>Description</h3>

<p>A function to transform a ppp object in the OS GB projection (epsg:27700) to a ppp object in the Mercator (epsg:3857) projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osppp2merc(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osppp2merc_+3A_obj">obj</code></td>
<td>
<p>a ppp object in OSGB</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ppp object in Mercator
</p>

<hr>
<h2 id='paramprec'>paramprec function</h2><span id='topic+paramprec'></span>

<h3>Description</h3>

<p>A function to compute the precision matrix of a GMRF on an M x N toral grid with neighbourhood size ns. Note that 
the precision matrix is block circulant. The returned function operates on a parameter vector as in Rue and Held (2005) pp 187.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramprec(ns, M, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramprec_+3A_ns">ns</code></td>
<td>
<p>neighbourhood size</p>
</td></tr>
<tr><td><code id="paramprec_+3A_m">M</code></td>
<td>
<p>number of cells in x direction</p>
</td></tr>
<tr><td><code id="paramprec_+3A_n">N</code></td>
<td>
<p>number of cells in y direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that returns the precision matrix given a parameter vector.
</p>

<hr>
<h2 id='paramprecbase'>paramprecbase function</h2><span id='topic+paramprecbase'></span>

<h3>Description</h3>

<p>A function to compute the parametrised base matrix of a precision matrix of a GMRF on an M x N toral grid with neighbourhood size ns. Note that 
the precision matrix is block circulant. The returned function operates on a parameter vector as in Rue and Held (2005) pp 187.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramprecbase(ns, M, N, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramprecbase_+3A_ns">ns</code></td>
<td>
<p>neighbourhood size</p>
</td></tr>
<tr><td><code id="paramprecbase_+3A_m">M</code></td>
<td>
<p>number of x cells</p>
</td></tr>
<tr><td><code id="paramprecbase_+3A_n">N</code></td>
<td>
<p>number of y cells</p>
</td></tr>
<tr><td><code id="paramprecbase_+3A_inverse">inverse</code></td>
<td>
<p>whether or not to compute the base matrix of the inverse precision matrix (ie the covariance matrix). default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a functioin that returns the base matrix of the precision matrix
</p>

<hr>
<h2 id='parautocorr'>parautocorr function</h2><span id='topic+parautocorr'></span>

<h3>Description</h3>

<p>A function to produce autocorrelation plots for the paramerers beta and eta from a call to the function lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parautocorr(obj, xlab = "Lag", ylab = NULL, main = "", ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parautocorr_+3A_obj">obj</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars orlgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
<tr><td><code id="parautocorr_+3A_xlab">xlab</code></td>
<td>
<p>optional label for x-axis, there is a sensible default.</p>
</td></tr>
<tr><td><code id="parautocorr_+3A_ylab">ylab</code></td>
<td>
<p>optional label for y-axis, there is a sensible default.</p>
</td></tr>
<tr><td><code id="parautocorr_+3A_main">main</code></td>
<td>
<p>optional title of the plot, there is a sensible default.</p>
</td></tr>
<tr><td><code id="parautocorr_+3A_ask">ask</code></td>
<td>
<p>the paramter &quot;ask&quot;, see ?par</p>
</td></tr>
<tr><td><code id="parautocorr_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function &quot;hist&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>produces autocorrelation plots of the parameters beta and eta
</p>


<h3>See Also</h3>

<p><a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='parsummary'>parsummary function</h2><span id='topic+parsummary'></span>

<h3>Description</h3>

<p>A function to produce a summary table for the parameters beta and eta from a call to the function lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parsummary(obj, expon = TRUE, LaTeX = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parsummary_+3A_obj">obj</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars orlgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
<tr><td><code id="parsummary_+3A_expon">expon</code></td>
<td>
<p>whether to exponentiate the results, so that the parameters beta haev the interpretation of &quot;relative risk per unit increase in the covariate&quot; default is TRUE</p>
</td></tr>
<tr><td><code id="parsummary_+3A_latex">LaTeX</code></td>
<td>
<p>whether to print paramter names using LaTeX symbols (if the table is later to be exported to a LaTeX document)</p>
</td></tr>
<tr><td><code id="parsummary_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the median, 0.025 and 0.975 quantiles.
</p>


<h3>See Also</h3>

<p><a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='plot.fromSPDF'>plot.fromSPDF function</h2><span id='topic+plot.fromSPDF'></span>

<h3>Description</h3>

<p>Plot method for objects of class fromSPDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromSPDF'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fromSPDF_+3A_x">x</code></td>
<td>
<p>an object of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="plot.fromSPDF_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints the object
</p>

<hr>
<h2 id='plot.fromXYZ'>plot.fromXYZ function</h2><span id='topic+plot.fromXYZ'></span>

<h3>Description</h3>

<p>Plot method for objects of class fromXYZ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fromXYZ_+3A_x">x</code></td>
<td>
<p>object of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="plot.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image plot
</p>

<hr>
<h2 id='plot.lgcpAutocorr'>plot.lgcpAutocorr function</h2><span id='topic+plot.lgcpAutocorr'></span>

<h3>Description</h3>

<p>Plots <code>lgcpAutocorr</code> objects: output from <code>autocorr</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpAutocorr'
plot(x, sel = 1:dim(x)[3], ask = TRUE, crop = TRUE, plotwin = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lgcpAutocorr_+3A_x">x</code></td>
<td>
<p>an object of class lgcpAutocorr</p>
</td></tr>
<tr><td><code id="plot.lgcpAutocorr_+3A_sel">sel</code></td>
<td>
<p>vector of integers between 1 and grid$len: which grids to plot. Default NULL, in which case all grids are plotted.</p>
</td></tr>
<tr><td><code id="plot.lgcpAutocorr_+3A_ask">ask</code></td>
<td>
<p>logical; if TRUE the user is asked before each plot</p>
</td></tr>
<tr><td><code id="plot.lgcpAutocorr_+3A_crop">crop</code></td>
<td>
<p>whether or not to crop to bounding box of observation window</p>
</td></tr>
<tr><td><code id="plot.lgcpAutocorr_+3A_plotwin">plotwin</code></td>
<td>
<p>logical whether to plot the window attr(x,&quot;window&quot;), default is FALSE</p>
</td></tr>
<tr><td><code id="plot.lgcpAutocorr_+3A_...">...</code></td>
<td>
<p>other arguments  passed to image.plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>See Also</h3>

<p><a href="#topic+autocorr">autocorr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ac &lt;- autocorr(lg,qt=c(1,2,3))
                          # assumes that lg has class lgcpPredict
## Not run: plot(ac)
</code></pre>

<hr>
<h2 id='plot.lgcpgrid'>plot.lgcpgrid function</h2><span id='topic+plot.lgcpgrid'></span>

<h3>Description</h3>

<p>This is a wrapper function for image.lgcpgrid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
plot(x, sel = 1:x$len, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lgcpgrid_+3A_x">x</code></td>
<td>
<p>an object of class lgcpgrid</p>
</td></tr>
<tr><td><code id="plot.lgcpgrid_+3A_sel">sel</code></td>
<td>
<p>vector of integers between 1 and grid$len: which grids to plot. Default NULL, in which case all grids are plotted.</p>
</td></tr>
<tr><td><code id="plot.lgcpgrid_+3A_ask">ask</code></td>
<td>
<p>logical; if TRUE the user is asked before each plot</p>
</td></tr>
<tr><td><code id="plot.lgcpgrid_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image-type plot
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.list">lgcpgrid.list</a>, <a href="#topic+lgcpgrid.array">lgcpgrid.array</a>, <a href="#topic+as.list.lgcpgrid">as.list.lgcpgrid</a>, <a href="#topic+print.lgcpgrid">print.lgcpgrid</a>,
<a href="#topic+summary.lgcpgrid">summary.lgcpgrid</a>,<a href="#topic+quantile.lgcpgrid">quantile.lgcpgrid</a>, <a href="#topic+image.lgcpgrid">image.lgcpgrid</a>
</p>

<hr>
<h2 id='plot.lgcpPredict'>plot.lgcpPredict function</h2><span id='topic+plot.lgcpPredict'></span>

<h3>Description</h3>

<p>Simple plotting function for objects of class <code>lgcpPredict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
plot(
  x,
  type = "relrisk",
  sel = 1:x$EY.mean$len,
  plotdata = TRUE,
  ask = TRUE,
  clipWindow = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lgcpPredict_+3A_x">x</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="plot.lgcpPredict_+3A_type">type</code></td>
<td>
<p>Character string: what type of plot to produce. Choices are &quot;relrisk&quot; (=exp(Y)); &quot;serr&quot; (standard error of relative risk); or &quot;intensity&quot; (=lambda*mu*exp(Y)).</p>
</td></tr>
<tr><td><code id="plot.lgcpPredict_+3A_sel">sel</code></td>
<td>
<p>vector of integers between 1 and grid$len: which grids to plot. Default NULL, in which case all grids are plotted.</p>
</td></tr>
<tr><td><code id="plot.lgcpPredict_+3A_plotdata">plotdata</code></td>
<td>
<p>whether or not to overlay the data</p>
</td></tr>
<tr><td><code id="plot.lgcpPredict_+3A_ask">ask</code></td>
<td>
<p>logical; if TRUE the user is asked before each plot</p>
</td></tr>
<tr><td><code id="plot.lgcpPredict_+3A_clipwindow">clipWindow</code></td>
<td>
<p>whether to plot grid cells outside the observation window</p>
</td></tr>
<tr><td><code id="plot.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments passed to image.plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the Monte Carlo mean of quantities obtained via simulation. By default the mean relative risk is plotted.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='plot.lgcpQuantiles'>plot.lgcpQuantiles function</h2><span id='topic+plot.lgcpQuantiles'></span>

<h3>Description</h3>

<p>Plots <code>lgcpQuantiles</code> objects: output from <code>quantiles.lgcpPredict</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpQuantiles'
plot(x, sel = 1:dim(x)[3], ask = TRUE, crop = TRUE, plotwin = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lgcpQuantiles_+3A_x">x</code></td>
<td>
<p>an object of class lgcpQuantiles</p>
</td></tr>
<tr><td><code id="plot.lgcpQuantiles_+3A_sel">sel</code></td>
<td>
<p>vector of integers between 1 and grid$len: which grids to plot. Default NULL, in which case all grids are plotted.</p>
</td></tr>
<tr><td><code id="plot.lgcpQuantiles_+3A_ask">ask</code></td>
<td>
<p>logical; if TRUE the user is asked before each plot</p>
</td></tr>
<tr><td><code id="plot.lgcpQuantiles_+3A_crop">crop</code></td>
<td>
<p>whether or not to crop to bounding box of observation window</p>
</td></tr>
<tr><td><code id="plot.lgcpQuantiles_+3A_plotwin">plotwin</code></td>
<td>
<p>logical whether to plot the window attr(x,&quot;window&quot;), default is FALSE</p>
</td></tr>
<tr><td><code id="plot.lgcpQuantiles_+3A_...">...</code></td>
<td>
<p>other arguments  passed to image.plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grid plotting
This is a wrapper function for image.lgcpgrid
</p>


<h3>See Also</h3>

<p><a href="#topic+quantile.lgcpPredict">quantile.lgcpPredict</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: qtiles &lt;- quantile(lg,qt=c(0.5,0.75,0.9),fun=exp)
                          # assumed that lg has class lgcpPredict
## Not run: plot(qtiles)
</code></pre>

<hr>
<h2 id='plot.lgcpZmat'>plot.lgcpZmat function</h2><span id='topic+plot.lgcpZmat'></span>

<h3>Description</h3>

<p>A function to plot lgcpZmat objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpZmat'
plot(
  x,
  ask = TRUE,
  pow = 1,
  main = NULL,
  misscol = "black",
  obswin = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lgcpZmat_+3A_x">x</code></td>
<td>
<p>an lgcpZmat object, see ?getZmat</p>
</td></tr>
<tr><td><code id="plot.lgcpZmat_+3A_ask">ask</code></td>
<td>
<p>graphical parameter ask, see ?par</p>
</td></tr>
<tr><td><code id="plot.lgcpZmat_+3A_pow">pow</code></td>
<td>
<p>power parameter, raises the image values to this power (helps with visualisation, default is 1.)</p>
</td></tr>
<tr><td><code id="plot.lgcpZmat_+3A_main">main</code></td>
<td>
<p>title for plot, default is null which gives an automatic title to the plot (the name of the covariate)</p>
</td></tr>
<tr><td><code id="plot.lgcpZmat_+3A_misscol">misscol</code></td>
<td>
<p>colour to identify imputed grid cells, default is yellow</p>
</td></tr>
<tr><td><code id="plot.lgcpZmat_+3A_obswin">obswin</code></td>
<td>
<p>optional observation window to add to plot using plot(obswin).</p>
</td></tr>
<tr><td><code id="plot.lgcpZmat_+3A_...">...</code></td>
<td>
<p>other paramters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sequence of plots of the interpolated covariate values
</p>

<hr>
<h2 id='plot.mcmcdiag'>plot.mcmcdiag function</h2><span id='topic+plot.mcmcdiag'></span>

<h3>Description</h3>

<p>The command <code>plot(trace(lg))</code>, where <code>lg</code> is an object of class <code>lgcpPredict</code> will plot the
mcmc traces of a subset of the cells, provided they have been stored, see <code>mcmpars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmcdiag'
plot(x, idx = 1:dim(x$trace)[2], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mcmcdiag_+3A_x">x</code></td>
<td>
<p>an object of class mcmcdiag</p>
</td></tr>
<tr><td><code id="plot.mcmcdiag_+3A_idx">idx</code></td>
<td>
<p>vector of chain indices to plot, default plots all chains</p>
</td></tr>
<tr><td><code id="plot.mcmcdiag_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the saved MCMC chains
</p>


<h3>See Also</h3>

<p><a href="#topic+mcmctrace.lgcpPredict">mcmctrace.lgcpPredict</a>, <a href="#topic+mcmcpars">mcmcpars</a>,
</p>

<hr>
<h2 id='plot.mstppp'>plot.mstppp function</h2><span id='topic+plot.mstppp'></span>

<h3>Description</h3>

<p>Plot method for mstppp objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mstppp'
plot(x, cols = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mstppp_+3A_x">x</code></td>
<td>
<p>an object of class mstppp</p>
</td></tr>
<tr><td><code id="plot.mstppp_+3A_cols">cols</code></td>
<td>
<p>optional vector of colours to plot points with</p>
</td></tr>
<tr><td><code id="plot.mstppp_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the mstppp object x
</p>

<hr>
<h2 id='plot.stppp'>plot.stppp function</h2><span id='topic+plot.stppp'></span>

<h3>Description</h3>

<p>Plot method for stppp objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stppp_+3A_x">x</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="plot.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the stppp object x
</p>

<hr>
<h2 id='plot.temporalAtRisk'>plot.temporalAtRisk function</h2><span id='topic+plot.temporalAtRisk'></span>

<h3>Description</h3>

<p>Pot a temporalAtRisk object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'temporalAtRisk'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.temporalAtRisk_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="plot.temporalAtRisk_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>print the object
</p>


<h3>See Also</h3>

<p><a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>, <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>, <a href="#topic+constantInTime">constantInTime</a>, <a href="#topic+constantInTime.numeric">constantInTime.numeric</a>, <a href="#topic+constantInTime.stppp">constantInTime.stppp</a>, <a href="#topic+print.temporalAtRisk">print.temporalAtRisk</a>,
</p>

<hr>
<h2 id='plotExceed'>plotExceed function</h2><span id='topic+plotExceed'></span>

<h3>Description</h3>

<p>A generic function for plotting exceedance probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotExceed(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotExceed_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="plotExceed_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generic function returning method plotExceed
</p>


<h3>See Also</h3>

<p><a href="#topic+plotExceed.lgcpPredict">plotExceed.lgcpPredict</a>, <a href="#topic+plotExceed.array">plotExceed.array</a>
</p>

<hr>
<h2 id='plotExceed.array'>plotExceed.array function</h2><span id='topic+plotExceed.array'></span>

<h3>Description</h3>

<p>Function for plotting exceedance probabilities stored in array objects. Used in <code>plotExceed.lgcpPredict</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
plotExceed(
  obj,
  fun,
  lgcppredict = NULL,
  xvals = NULL,
  yvals = NULL,
  window = NULL,
  cases = NULL,
  nlevel = 64,
  ask = TRUE,
  mapunderlay = NULL,
  alpha = 1,
  sub = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotExceed.array_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_fun">fun</code></td>
<td>
<p>the name of the function used to compute exceedances (character vector of length 1). Note that the named function must be in memory.</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_lgcppredict">lgcppredict</code></td>
<td>
<p>an object of class lgcpPredict that can be used to supply an observation window and x and y coordinates</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_xvals">xvals</code></td>
<td>
<p>optional vector giving x coords of centroids of cells</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_yvals">yvals</code></td>
<td>
<p>optional vector giving y coords of centroids of cells</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_window">window</code></td>
<td>
<p>optional obervation window</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_cases">cases</code></td>
<td>
<p>optional xy (n x 2) matrix of locations of cases to plot</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_nlevel">nlevel</code></td>
<td>
<p>number of colour levels to use in plot, default is 64</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_ask">ask</code></td>
<td>
<p>whether or not to ask for a new plot between plotting exceedances at different thresholds.</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_mapunderlay">mapunderlay</code></td>
<td>
<p>optional underlay to plot underneath maps of exceedance probabilities. Use in conjunction with rainbow parameter 'alpha' (eg alpha=0.3) to set transparency of exceedance layer.</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_alpha">alpha</code></td>
<td>
<p>graphical parameter takign values in [0,1] controlling transparency of exceedance layer. Default is 1.</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_sub">sub</code></td>
<td>
<p>optional subtitle for plot</p>
</td></tr>
<tr><td><code id="plotExceed.array_+3A_...">...</code></td>
<td>
<p>additional arguments passed to image.plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generic function returning method plotExceed
</p>


<h3>See Also</h3>

<p><a href="#topic+plotExceed.lgcpPredict">plotExceed.lgcpPredict</a>
</p>

<hr>
<h2 id='plotExceed.lgcpPredict'>plotExceed.lgcpPredict function</h2><span id='topic+plotExceed.lgcpPredict'></span>

<h3>Description</h3>

<p>Function for plotting exceedance probabilities stored in <code>lgcpPredict</code> ojects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
plotExceed(
  obj,
  fun,
  nlevel = 64,
  ask = TRUE,
  plotcases = FALSE,
  mapunderlay = NULL,
  alpha = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotExceed.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="plotExceed.lgcpPredict_+3A_fun">fun</code></td>
<td>
<p>the name of the function used to compute exceedances (character vector of length 1). Note that the named function must be in memory.</p>
</td></tr>
<tr><td><code id="plotExceed.lgcpPredict_+3A_nlevel">nlevel</code></td>
<td>
<p>number of colour levels to use in plot, default is 64</p>
</td></tr>
<tr><td><code id="plotExceed.lgcpPredict_+3A_ask">ask</code></td>
<td>
<p>whether or not to ask for a new plot between plotting exceedances at different thresholds.</p>
</td></tr>
<tr><td><code id="plotExceed.lgcpPredict_+3A_plotcases">plotcases</code></td>
<td>
<p>whether or not to plot the cases on the map</p>
</td></tr>
<tr><td><code id="plotExceed.lgcpPredict_+3A_mapunderlay">mapunderlay</code></td>
<td>
<p>optional underlay to plot underneath maps of exceedance probabilities. Use in conjunction with rainbow parameter 'alpha' (eg alpha=0.3) to set transparency of exceedance layer.</p>
</td></tr>
<tr><td><code id="plotExceed.lgcpPredict_+3A_alpha">alpha</code></td>
<td>
<p>graphical parameter takign values in [0,1] controlling transparency of exceedance layer. Default is 1.</p>
</td></tr>
<tr><td><code id="plotExceed.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments passed to image.plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot of exceedances
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+MonteCarloAverage">MonteCarloAverage</a>, <a href="#topic+setoutput">setoutput</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: exceedfun &lt;- exceedProbs(c(1.5,2,4))
## Not run: 
    plot(lg,"exceedfun") # lg is an object of class lgcpPredict
                         # in which the Monte Carlo mean of
                         # "exceedfun" was computed
                         # see ?MonteCarloAverage and ?setoutput

## End(Not run)
</code></pre>

<hr>
<h2 id='plotit'>plotit function</h2><span id='topic+plotit'></span>

<h3>Description</h3>

<p>A function to plot various objects. A developmental tool: not intended for general use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotit_+3A_x">x</code></td>
<td>
<p>an a list, matrix, or GPrealisation object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the objects.
</p>

<hr>
<h2 id='postcov'>postcov function</h2><span id='topic+postcov'></span>

<h3>Description</h3>

<p>Generic function for producing plots of the posterior covariance function from a call to the function lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars,
lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postcov(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postcov_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="postcov_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method postcov
</p>


<h3>See Also</h3>

<p><a href="#topic+postcov.lgcpPredictSpatialOnlyPlusParameters">postcov.lgcpPredictSpatialOnlyPlusParameters</a>,<a href="#topic+postcov.lgcpPredictAggregateSpatialPlusParameters">postcov.lgcpPredictAggregateSpatialPlusParameters</a>, <a href="#topic+postcov.lgcpPredictSpatioTemporalPlusParameters">postcov.lgcpPredictSpatioTemporalPlusParameters</a>, <a href="#topic+postcov.lgcpPredictMultitypeSpatialPlusParameters">postcov.lgcpPredictMultitypeSpatialPlusParameters</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='postcov.lgcpPredictAggregateSpatialPlusParameters'>postcov.lgcpPredictAggregateSpatialPlusParameters function</h2><span id='topic+postcov.lgcpPredictAggregateSpatialPlusParameters'></span>

<h3>Description</h3>

<p>A function for producing plots of the posterior covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"postcov(obj,qts=c(0.025,0.5,0.975),covmodel=NULL,ask=TRUE,...)"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postcov.lgcpPredictAggregateSpatialPlusParameters_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredictAggregateSpatialPlusParameters object</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictAggregateSpatialPlusParameters_+3A_qts">qts</code></td>
<td>
<p>vector of quantiles of length 3, default is 0.025, 0.5, 0.975</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictAggregateSpatialPlusParameters_+3A_covmodel">covmodel</code></td>
<td>
<p>the assumed covariance model. NULL by default, this information is read in from the object obj, so generally does not need to be set.</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictAggregateSpatialPlusParameters_+3A_ask">ask</code></td>
<td>
<p>parameter &quot;ask&quot;, see ?par</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictAggregateSpatialPlusParameters_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>


<h3>See Also</h3>

<p><a href="#topic+postcov.lgcpPredictSpatialOnlyPlusParameters">postcov.lgcpPredictSpatialOnlyPlusParameters</a>, <a href="#topic+postcov.lgcpPredictAggregateSpatialPlusParameters">postcov.lgcpPredictAggregateSpatialPlusParameters</a>, <a href="#topic+postcov.lgcpPredictSpatioTemporalPlusParameters">postcov.lgcpPredictSpatioTemporalPlusParameters</a>, <a href="#topic+postcov.lgcpPredictMultitypeSpatialPlusParameters">postcov.lgcpPredictMultitypeSpatialPlusParameters</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='postcov.lgcpPredictMultitypeSpatialPlusParameters'>postcov.lgcpPredictMultitypeSpatialPlusParameters function</h2><span id='topic+postcov.lgcpPredictMultitypeSpatialPlusParameters'></span>

<h3>Description</h3>

<p>A function for producing plots of the posterior covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"postcov(obj,qts=c(0.025,0.5,0.975),covmodel=NULL,ask=TRUE,...)"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postcov.lgcpPredictMultitypeSpatialPlusParameters_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredictMultitypeSpatialPlusParameters object</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictMultitypeSpatialPlusParameters_+3A_qts">qts</code></td>
<td>
<p>vector of quantiles of length 3, default is 0.025, 0.5, 0.975</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictMultitypeSpatialPlusParameters_+3A_covmodel">covmodel</code></td>
<td>
<p>the assumed covariance model. NULL by default, this information is read in from the object obj, so generally does not need to be set.</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictMultitypeSpatialPlusParameters_+3A_ask">ask</code></td>
<td>
<p>parameter &quot;ask&quot;, see ?par</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictMultitypeSpatialPlusParameters_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots of the posterior covariance function for each type.
</p>


<h3>See Also</h3>

<p><a href="#topic+postcov.lgcpPredictSpatialOnlyPlusParameters">postcov.lgcpPredictSpatialOnlyPlusParameters</a>, <a href="#topic+postcov.lgcpPredictAggregateSpatialPlusParameters">postcov.lgcpPredictAggregateSpatialPlusParameters</a>, <a href="#topic+postcov.lgcpPredictSpatioTemporalPlusParameters">postcov.lgcpPredictSpatioTemporalPlusParameters</a>, <a href="#topic+postcov.lgcpPredictMultitypeSpatialPlusParameters">postcov.lgcpPredictMultitypeSpatialPlusParameters</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='postcov.lgcpPredictSpatialOnlyPlusParameters'>postcov.lgcpPredictSpatialOnlyPlusParameters function</h2><span id='topic+postcov.lgcpPredictSpatialOnlyPlusParameters'></span>

<h3>Description</h3>

<p>A function for producing plots of the posterior spatial covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"postcov(obj,qts=c(0.025,0.5,0.975),covmodel=NULL,ask=TRUE,...)"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postcov.lgcpPredictSpatialOnlyPlusParameters_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredictSpatialOnlyPlusParameters object</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictSpatialOnlyPlusParameters_+3A_qts">qts</code></td>
<td>
<p>vector of quantiles of length 3, default is 0.025, 0.5, 0.975</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictSpatialOnlyPlusParameters_+3A_covmodel">covmodel</code></td>
<td>
<p>the assumed covariance model. NULL by default, this information is read in from the object obj, so generally does not need to be set.</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictSpatialOnlyPlusParameters_+3A_ask">ask</code></td>
<td>
<p>parameter &quot;ask&quot;, see ?par</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictSpatialOnlyPlusParameters_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the posterior covariance function.
</p>


<h3>See Also</h3>

<p><a href="#topic+postcov.lgcpPredictSpatialOnlyPlusParameters">postcov.lgcpPredictSpatialOnlyPlusParameters</a>, <a href="#topic+postcov.lgcpPredictAggregateSpatialPlusParameters">postcov.lgcpPredictAggregateSpatialPlusParameters</a>, <a href="#topic+postcov.lgcpPredictSpatioTemporalPlusParameters">postcov.lgcpPredictSpatioTemporalPlusParameters</a>, <a href="#topic+postcov.lgcpPredictMultitypeSpatialPlusParameters">postcov.lgcpPredictMultitypeSpatialPlusParameters</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='postcov.lgcpPredictSpatioTemporalPlusParameters'>postcov.lgcpPredictSpatioTemporalPlusParameters function</h2><span id='topic+postcov.lgcpPredictSpatioTemporalPlusParameters'></span>

<h3>Description</h3>

<p>A function for producing plots of the posterior spatiotemporal covariance function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>"postcov(obj,qts=c(0.025,0.5,0.975),covmodel=NULL,ask=TRUE,...)"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postcov.lgcpPredictSpatioTemporalPlusParameters_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredictSpatioTemporalPlusParameters object</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictSpatioTemporalPlusParameters_+3A_qts">qts</code></td>
<td>
<p>vector of quantiles of length 3, default is 0.025, 0.5, 0.975</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictSpatioTemporalPlusParameters_+3A_covmodel">covmodel</code></td>
<td>
<p>the assumed covariance model. NULL by default, this information is read in from the object obj, so generally does not need to be set.</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictSpatioTemporalPlusParameters_+3A_ask">ask</code></td>
<td>
<p>parameter &quot;ask&quot;, see ?par</p>
</td></tr>
<tr><td><code id="postcov.lgcpPredictSpatioTemporalPlusParameters_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of the posterior spatial covariance function and temporal correlation function.
</p>


<h3>See Also</h3>

<p><a href="#topic+postcov.lgcpPredictSpatialOnlyPlusParameters">postcov.lgcpPredictSpatialOnlyPlusParameters</a>, <a href="#topic+postcov.lgcpPredictAggregateSpatialPlusParameters">postcov.lgcpPredictAggregateSpatialPlusParameters</a>, <a href="#topic+postcov.lgcpPredictSpatioTemporalPlusParameters">postcov.lgcpPredictSpatioTemporalPlusParameters</a>, <a href="#topic+postcov.lgcpPredictMultitypeSpatialPlusParameters">postcov.lgcpPredictMultitypeSpatialPlusParameters</a>,
<a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='print.dump2dir'>print.dump2dir function</h2><span id='topic+print.dump2dir'></span>

<h3>Description</h3>

<p>Display function for dump2dir objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dump2dir'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dump2dir_+3A_x">x</code></td>
<td>
<p>an object of class dump2dir</p>
</td></tr>
<tr><td><code id="print.dump2dir_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><a href="#topic+dump2dir">dump2dir</a>,
</p>

<hr>
<h2 id='print.fromFunction'>print.fromFunction function</h2><span id='topic+print.fromFunction'></span>

<h3>Description</h3>

<p>Print method for objects of class fromFunction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromFunction'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fromFunction_+3A_x">x</code></td>
<td>
<p>an object of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="print.fromFunction_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints the object
</p>

<hr>
<h2 id='print.fromSPDF'>print.fromSPDF function</h2><span id='topic+print.fromSPDF'></span>

<h3>Description</h3>

<p>Print method for objects of class fromSPDF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromSPDF'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fromSPDF_+3A_x">x</code></td>
<td>
<p>an object of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="print.fromSPDF_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints the object
</p>

<hr>
<h2 id='print.fromXYZ'>print.fromXYZ function</h2><span id='topic+print.fromXYZ'></span>

<h3>Description</h3>

<p>Print method for objects of class fromXYZ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fromXYZ_+3A_x">x</code></td>
<td>
<p>an object of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="print.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints the object
</p>

<hr>
<h2 id='print.gridaverage'>print.gridaverage function</h2><span id='topic+print.gridaverage'></span>

<h3>Description</h3>

<p>Print method for <code>gridaverage</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gridaverage'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gridaverage_+3A_x">x</code></td>
<td>
<p>an object of class gridaverage</p>
</td></tr>
<tr><td><code id="print.gridaverage_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>just prints out details
</p>

<hr>
<h2 id='print.lgcpgrid'>print.lgcpgrid function</h2><span id='topic+print.lgcpgrid'></span>

<h3>Description</h3>

<p>Print method for lgcp grid objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lgcpgrid_+3A_x">x</code></td>
<td>
<p>an object of class lgcpgrid</p>
</td></tr>
<tr><td><code id="print.lgcpgrid_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>just prints out details to the console
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.list">lgcpgrid.list</a>, <a href="#topic+lgcpgrid.array">lgcpgrid.array</a>, <a href="#topic+as.list.lgcpgrid">as.list.lgcpgrid</a>,
<a href="#topic+summary.lgcpgrid">summary.lgcpgrid</a> <a href="#topic+quantile.lgcpgrid">quantile.lgcpgrid</a> <a href="#topic+image.lgcpgrid">image.lgcpgrid</a> <a href="#topic+plot.lgcpgrid">plot.lgcpgrid</a>
</p>

<hr>
<h2 id='print.lgcpPredict'>print.lgcpPredict function</h2><span id='topic+print.lgcpPredict'></span>

<h3>Description</h3>

<p>Print method for lgcpPredict objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lgcpPredict_+3A_x">x</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="print.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>just prints information to the screen
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='print.mcmc'>print.mcmc function</h2><span id='topic+print.mcmc'></span>

<h3>Description</h3>

<p>print method
print an mcmc iterator's details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcmc_+3A_x">x</code></td>
<td>
<p>a mcmc iterator</p>
</td></tr>
<tr><td><code id="print.mcmc_+3A_...">...</code></td>
<td>
<p>other args</p>
</td></tr>
</table>

<hr>
<h2 id='print.mstppp'>print.mstppp function</h2><span id='topic+print.mstppp'></span>

<h3>Description</h3>

<p>Print method for mstppp objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mstppp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mstppp_+3A_x">x</code></td>
<td>
<p>an object of class mstppp</p>
</td></tr>
<tr><td><code id="print.mstppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints the mstppp object x
</p>

<hr>
<h2 id='print.stapp'>print.stapp function</h2><span id='topic+print.stapp'></span>

<h3>Description</h3>

<p>Print method for stapp objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stapp'
print(x, printhead = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stapp_+3A_x">x</code></td>
<td>
<p>an object of class stapp</p>
</td></tr>
<tr><td><code id="print.stapp_+3A_printhead">printhead</code></td>
<td>
<p>whether or not to print the head of the counts matrix</p>
</td></tr>
<tr><td><code id="print.stapp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints the stapp object x
</p>

<hr>
<h2 id='print.stppp'>print.stppp function</h2><span id='topic+print.stppp'></span>

<h3>Description</h3>

<p>Print method for stppp objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.stppp_+3A_x">x</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="print.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints the stppp object x
</p>

<hr>
<h2 id='print.temporalAtRisk'>print.temporalAtRisk function</h2><span id='topic+print.temporalAtRisk'></span>

<h3>Description</h3>

<p>Printing method for temporalAtRisk objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'temporalAtRisk'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.temporalAtRisk_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="print.temporalAtRisk_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>print the object
</p>


<h3>See Also</h3>

<p><a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>, <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>, <a href="#topic+constantInTime">constantInTime</a>, <a href="#topic+constantInTime.numeric">constantInTime.numeric</a>, <a href="#topic+constantInTime.stppp">constantInTime.stppp</a>, <a href="#topic+plot.temporalAtRisk">plot.temporalAtRisk</a>
</p>

<hr>
<h2 id='priorpost'>priorpost function</h2><span id='topic+priorpost'></span>

<h3>Description</h3>

<p>A function to plot the prior and posterior densities of the model parameters eta and beta. The prior appears as a red line
and the posterior appears as a histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorpost(
  obj,
  breaks = 30,
  xlab = NULL,
  ylab = "Density",
  main = "",
  ask = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priorpost_+3A_obj">obj</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
<tr><td><code id="priorpost_+3A_breaks">breaks</code></td>
<td>
<p>&quot;breaks&quot; paramter from the function &quot;hist&quot;</p>
</td></tr>
<tr><td><code id="priorpost_+3A_xlab">xlab</code></td>
<td>
<p>optional label for x-axis, there is a sensible default.</p>
</td></tr>
<tr><td><code id="priorpost_+3A_ylab">ylab</code></td>
<td>
<p>optional label for y-axis, there is a sensible default.</p>
</td></tr>
<tr><td><code id="priorpost_+3A_main">main</code></td>
<td>
<p>optional title of the plot, there is a sensible default.</p>
</td></tr>
<tr><td><code id="priorpost_+3A_ask">ask</code></td>
<td>
<p>the paramter &quot;ask&quot;, see ?par</p>
</td></tr>
<tr><td><code id="priorpost_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function &quot;hist&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots of the prior and posterior of the model parameters eta and beta.
</p>


<h3>See Also</h3>

<p><a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='PriorSpec'>PriorSpec function</h2><span id='topic+PriorSpec'></span>

<h3>Description</h3>

<p>Generic for declaring that an object is of valid type for use as as prior in lgcp. For further details and examples, see the vignette &quot;Bayesian_lgcp&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PriorSpec(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PriorSpec_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="PriorSpec_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method PriorSpec
</p>


<h3>See Also</h3>

<p><a href="#topic+PriorSpec.list">PriorSpec.list</a>
</p>

<hr>
<h2 id='PriorSpec.list'>PriorSpec.list function</h2><span id='topic+PriorSpec.list'></span>

<h3>Description</h3>

<p>Method for declaring a Bayesian prior density in lgcp. Checks to confirm that the object obj has the requisite components for functioning as a prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
PriorSpec(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PriorSpec.list_+3A_obj">obj</code></td>
<td>
<p>a list object defining a prior , see ?GaussianPrior and ?LogGaussianPrior</p>
</td></tr>
<tr><td><code id="PriorSpec.list_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object suitable for use in a call to the MCMC routines
</p>


<h3>See Also</h3>

<p><a href="#topic+GaussianPrior">GaussianPrior</a>, <a href="#topic+LogGaussianPrior">LogGaussianPrior</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: PriorSpec(LogGaussianPrior(mean=log(c(1,500)),variance=diag(0.15,2)))
## Not run: PriorSpec(GaussianPrior(mean=rep(0,9),variance=diag(10^6,9)))
</code></pre>

<hr>
<h2 id='quantile.lgcpgrid'>quantile.lgcpgrid function</h2><span id='topic+quantile.lgcpgrid'></span>

<h3>Description</h3>

<p>Quantile method for lgcp objects. This just applies the quantile function to each of
the elements of x$grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
quantile(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.lgcpgrid_+3A_x">x</code></td>
<td>
<p>an object of class lgcpgrid</p>
</td></tr>
<tr><td><code id="quantile.lgcpgrid_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quantiles per grid, see ?quantile for further options
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.list">lgcpgrid.list</a>, <a href="#topic+lgcpgrid.array">lgcpgrid.array</a>, <a href="#topic+as.list.lgcpgrid">as.list.lgcpgrid</a>, <a href="#topic+print.lgcpgrid">print.lgcpgrid</a>,
<a href="#topic+summary.lgcpgrid">summary.lgcpgrid</a>, <a href="#topic+image.lgcpgrid">image.lgcpgrid</a>, <a href="#topic+plot.lgcpgrid">plot.lgcpgrid</a>
</p>

<hr>
<h2 id='quantile.lgcpPredict'>quantile.lgcpPredict function</h2><span id='topic+quantile.lgcpPredict'></span>

<h3>Description</h3>

<p><b>This function requires data to have been dumped to disk</b>: see <code>?dump2dir</code> and <code>?setoutput</code>. The routine <code>quantile.lgcpPredict</code>
computes quantiles of functions of Y. For example, to get cell-wise quantiles of exceedance probabilities, set <code>fun=exp</code>.
Since computign the quantiles is an expensive operation, the option to output the quantiles on a subregion of interest is also provided (by
setting the argument <code>inWindow</code>, which has a sensible default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
quantile(
  x,
  qt,
  tidx = NULL,
  fun = NULL,
  inWindow = x$xyt$window,
  crop2parentwindow = TRUE,
  startidx = 1,
  sampcount = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.lgcpPredict_+3A_x">x</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="quantile.lgcpPredict_+3A_qt">qt</code></td>
<td>
<p>a vector of the required quantiles</p>
</td></tr>
<tr><td><code id="quantile.lgcpPredict_+3A_tidx">tidx</code></td>
<td>
<p>the index number of the the time interval of interest, default is the last time point.</p>
</td></tr>
<tr><td><code id="quantile.lgcpPredict_+3A_fun">fun</code></td>
<td>
<p>a 1-1 function (default the identity function) to be applied cell-wise to the grid. Must be able to evaluate sapply(vec,fun) for vectors vec.</p>
</td></tr>
<tr><td><code id="quantile.lgcpPredict_+3A_inwindow">inWindow</code></td>
<td>
<p>an observation owin window on which to compute the quantiles, can speed up calculation. Default is x$xyt$window.</p>
</td></tr>
<tr><td><code id="quantile.lgcpPredict_+3A_crop2parentwindow">crop2parentwindow</code></td>
<td>
<p>logical: whether to only compute the quantiles for cells inside x$xyt$window (the 'parent window')</p>
</td></tr>
<tr><td><code id="quantile.lgcpPredict_+3A_startidx">startidx</code></td>
<td>
<p>optional starting sample index for computing quantiles. Default is 1.</p>
</td></tr>
<tr><td><code id="quantile.lgcpPredict_+3A_sampcount">sampcount</code></td>
<td>
<p>number of samples to include in computation of quantiles after startidx. Default is all</p>
</td></tr>
<tr><td><code id="quantile.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array, the [,,i]th slice being the grid of cell-wise quantiles, qt[i], of fun(Y), where Y is the MCMC output dumped to disk.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+dump2dir">dump2dir</a>, <a href="#topic+setoutput">setoutput</a>, <a href="#topic+plot.lgcpQuantiles">plot.lgcpQuantiles</a>
</p>

<hr>
<h2 id='RandomFieldsCovFct'>RandomFieldsCovFct function</h2><span id='topic+RandomFieldsCovFct'></span>

<h3>Description</h3>

<p>A function to declare and also evaluate an covariance function from the RandomFields Package. See ?CovarianceFct. Note that the present version of
lgcp only offers estimation for sigma and phi, any additional paramters are treated as fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RandomFieldsCovFct(model, additionalparameters = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RandomFieldsCovFct_+3A_model">model</code></td>
<td>
<p>the choice of model e.g.  &quot;matern&quot;</p>
</td></tr>
<tr><td><code id="RandomFieldsCovFct_+3A_additionalparameters">additionalparameters</code></td>
<td>
<p>additional parameters for chosen covariance model. See ?CovarianceFct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a covariance function from the RandomFields package
</p>


<h3>See Also</h3>

<p><a href="#topic+CovFunction.function">CovFunction.function</a>, <a href="#topic+exponentialCovFct">exponentialCovFct</a>, <a href="#topic+SpikedExponentialCovFct">SpikedExponentialCovFct</a>, <a href="#topic+CovarianceFct">CovarianceFct</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: RandomFieldsCovFct(model="matern",additionalparameters=1)
</code></pre>

<hr>
<h2 id='raster.lgcpgrid'>raster.lgcpgrid function</h2><span id='topic+raster.lgcpgrid'></span>

<h3>Description</h3>

<p>A function to convert lgcpgrid objects into either a raster object, or a RasterBrick object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
raster(x, crs = NA, transpose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster.lgcpgrid_+3A_x">x</code></td>
<td>
<p>an lgcpgrid object</p>
</td></tr>
<tr><td><code id="raster.lgcpgrid_+3A_crs">crs</code></td>
<td>
<p>PROJ4 type description of a map projection (optional). See ?raster</p>
</td></tr>
<tr><td><code id="raster.lgcpgrid_+3A_transpose">transpose</code></td>
<td>
<p>Logical. Transpose the data? See ?brick method for array</p>
</td></tr>
<tr><td><code id="raster.lgcpgrid_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='rescale.mstppp'>rescale.mstppp function</h2><span id='topic+rescale.mstppp'></span>

<h3>Description</h3>

<p>Rescale an mstppp object. Similar to rescale.ppp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mstppp'
rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale.mstppp_+3A_x">X</code></td>
<td>
<p>an object of class mstppp</p>
</td></tr>
<tr><td><code id="rescale.mstppp_+3A_s">s</code></td>
<td>
<p>scale as in rescale.ppp: x and y coordinaes are scaled by 1/s</p>
</td></tr>
<tr><td><code id="rescale.mstppp_+3A_unitname">unitname</code></td>
<td>
<p>parameter as defined in ?rescale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ppp object without observation times
</p>

<hr>
<h2 id='rescale.stppp'>rescale.stppp function</h2><span id='topic+rescale.stppp'></span>

<h3>Description</h3>

<p>Rescale an stppp object. Similar to rescale.ppp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
rescale(X, s, unitname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale.stppp_+3A_x">X</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="rescale.stppp_+3A_s">s</code></td>
<td>
<p>scale as in rescale.ppp: x and y coordinaes are scaled by 1/s</p>
</td></tr>
<tr><td><code id="rescale.stppp_+3A_unitname">unitname</code></td>
<td>
<p>parameter as defined in ?rescale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ppp object without observation times
</p>

<hr>
<h2 id='resetLoop'>reset iterator</h2><span id='topic+resetLoop'></span>

<h3>Description</h3>

<p>call this to reset an iterator's state to the initial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetLoop(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resetLoop_+3A_obj">obj</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
</table>

<hr>
<h2 id='rgauss'>rgauss function</h2><span id='topic+rgauss'></span>

<h3>Description</h3>

<p>A function to simulate a Gaussian field on a regular square lattice, the returned object is of class lgcpgrid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgauss(
  n = 1,
  range = c(0, 1),
  ncells = 128,
  spatial.covmodel = "exponential",
  model.parameters = lgcppars(sigma = 2, phi = 0.1),
  covpars = c(),
  ext = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgauss_+3A_n">n</code></td>
<td>
<p>the number of realisations to generate. Default is 1.</p>
</td></tr>
<tr><td><code id="rgauss_+3A_range">range</code></td>
<td>
<p>a vector of length 2, defining the left-most and right most cell centroids in the x-direction. Note that the centroids in the y-direction are the same as those in the x-direction.</p>
</td></tr>
<tr><td><code id="rgauss_+3A_ncells">ncells</code></td>
<td>
<p>the number of cells, typially a power of 2</p>
</td></tr>
<tr><td><code id="rgauss_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>spatial covariance function, default is exponential, see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="rgauss_+3A_model.parameters">model.parameters</code></td>
<td>
<p>parameters of model, see ?lgcppars. Only set sigma and phi for spatial model.</p>
</td></tr>
<tr><td><code id="rgauss_+3A_covpars">covpars</code></td>
<td>
<p>vector of additional parameters for spatial covariance function, in order they appear in chosen model in ?CovarianceFct</p>
</td></tr>
<tr><td><code id="rgauss_+3A_ext">ext</code></td>
<td>
<p>how much to extend the parameter space by. Default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an lgcp grid object containing the simulated field(s).
</p>

<hr>
<h2 id='roteffgain'>roteffgain function</h2><span id='topic+roteffgain'></span>

<h3>Description</h3>

<p>Compute whether there might be any advantage in rotating the observation window in the object xyt for a proposed cell width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roteffgain(xyt, cellwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roteffgain_+3A_xyt">xyt</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="roteffgain_+3A_cellwidth">cellwidth</code></td>
<td>
<p>size of grid on which to do MALA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>whether or not there woud be any efficiency gain in the MALA by rotating window
</p>


<h3>See Also</h3>

<p><a href="#topic+getRotation.stppp">getRotation.stppp</a>
</p>

<hr>
<h2 id='rotmat'>rotmat function</h2><span id='topic+rotmat'></span>

<h3>Description</h3>

<p>This function returns a rotation matrix corresponding to an anticlockwise rotation of theta radians about the origin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotmat(theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotmat_+3A_theta">theta</code></td>
<td>
<p>an angle in radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformation matrix corresponding to an anticlockwise rotation of theta radians about the origin
</p>

<hr>
<h2 id='rr'>rr function</h2><span id='topic+rr'></span>

<h3>Description</h3>

<p>Generic function to return relative risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rr(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rr_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="rr_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method rr
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+rr.lgcpPredict">rr.lgcpPredict</a>
</p>

<hr>
<h2 id='rr.lgcpPredict'>rr.lgcpPredict function</h2><span id='topic+rr.lgcpPredict'></span>

<h3>Description</h3>

<p>Accessor function returning the relative risk = exp(Y) as an lgcpgrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
rr(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rr.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredict object</p>
</td></tr>
<tr><td><code id="rr.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the relative risk as computed my MCMC
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='samplePosterior'>samplePosterior function</h2><span id='topic+samplePosterior'></span>

<h3>Description</h3>

<p>A function to draw a sample from the posterior of a spatial LGCP. Randomly selects an index i, and returns the ith value of eta,
the ith value of beta and the ith value of Y as a named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplePosterior(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samplePosterior_+3A_x">x</code></td>
<td>
<p>an object of class lgcpPredictSpatialOnlyPlusParameters or lgcpPredictAggregateSpatialPlusParameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sample from the posterior named list object with names elements &quot;eta&quot;, &quot;beta&quot; and &quot;Y&quot;.
</p>

<hr>
<h2 id='segProbs'>segProbs function</h2><span id='topic+segProbs'></span>

<h3>Description</h3>

<p>A function to compute segregation probabilities from a multivariate LGCP. See the vignette &quot;Bayesian_lgcp&quot; for a full explanation of this.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segProbs(obj, domprob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segProbs_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredictMultitypeSpatialPlusParameters object</p>
</td></tr>
<tr><td><code id="segProbs_+3A_domprob">domprob</code></td>
<td>
<p>the threshold beyond which we declare a type as dominant e.g. a value of 0.8 would mean we would consider each type to be dominant if the
conditional probability of an event of a given type at that location exceeded 0.8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We suppose there are K point types of interest. The model for point-type k is as follows:<br />
<br />
X_k(s) ~ Poisson[R_k(s)]<br />
<br />
R_k(s) = C_A lambda_k(s) exp[Z_k(s)beta_k+Y_k(s)]<br />
<br />
</p>
<p>Here X_k(s) is the number of events of type k in the computational grid cell containing the
point s, R_k(s) is the Poisson rate, C_A is the cell area, lambda_k(s) is a known offset, Z_k(s) is a vector
of measured covariates and Y_i(s) where i = 1,...,K+1 are latent Gaussian processes on the
computational grid. The other parameters in the model are beta_k , the covariate effects for the
kth type; and eta_i = [log(sigma_i),log(phi_i)], the parameters of the process Y_i for i = 1,...,K+1 on
an appropriately transformed (again, in this case log) scale.
</p>
<p>The term 'conditional probability of type k' means the probability that at a particular location, x, there
will be an event of type k, we denote this p_k(x).
</p>
<p>It is also of interest to scientists to be able to illustrate spatial regions where a genotype
dominates a posteriori. We say that type k dominates at position x if p_k(x)&gt;c, where c (the parameter domprob) is a
threshold is a threshold set by the user. Let A_k(c,q) denote the set of locations x for which P[p_k(x)&gt;c|X] &gt; q.
</p>
<p>As the quantities c and q tend to 1 each area A_k(c,p) shrinks towards the empty set; this
happens more slowly in a highly segregated pattern compared with a weakly segregated one.
</p>
<p>The function segProbs computes P[p_k(x)&gt;c|X] for each type, from which plots of P[p_k(x)&gt;c|X] &gt; q can be produced.
</p>


<h3>Value</h3>

<p>an lgcpgrid object contatining the segregation probabilities.
</p>

<hr>
<h2 id='seintens'>seintens function</h2><span id='topic+seintens'></span>

<h3>Description</h3>

<p>Generic function to return the standard error of the Poisson Intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seintens(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seintens_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="seintens_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method seintens
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+seintens.lgcpPredict">seintens.lgcpPredict</a>
</p>

<hr>
<h2 id='seintens.lgcpPredict'>seintens.lgcpPredict function</h2><span id='topic+seintens.lgcpPredict'></span>

<h3>Description</h3>

<p>Accessor function returning the  standard error of the Poisson intensity as an lgcpgrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
seintens(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seintens.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredict object</p>
</td></tr>
<tr><td><code id="seintens.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the cell-wise standard error of the Poisson intensity, as computed by MCMC.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='selectObsWindow'>selectObsWindow function</h2><span id='topic+selectObsWindow'></span>

<h3>Description</h3>

<p>See ?selectObsWindow.stppp for further details on usage. This is a generic function for the purpose of selecting an observation window 
(or more precisely a bounding box) to contain the extended FFT grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectObsWindow(xyt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectObsWindow_+3A_xyt">xyt</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="selectObsWindow_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method selectObsWindow
</p>


<h3>See Also</h3>

<p><a href="#topic+selectObsWindow.default">selectObsWindow.default</a>, <a href="#topic+selectObsWindow.stppp">selectObsWindow.stppp</a>
</p>

<hr>
<h2 id='selectObsWindow.default'>selectObsWindow.default function</h2><span id='topic+selectObsWindow.default'></span>

<h3>Description</h3>

<p>Default method, note at present, there is only an implementation for stppp objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
selectObsWindow(xyt, cellwidth, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectObsWindow.default_+3A_xyt">xyt</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="selectObsWindow.default_+3A_cellwidth">cellwidth</code></td>
<td>
<p>size of the grid spacing in chosen units (equivalent to the cell width argument in <a href="#topic+lgcpPredict">lgcpPredict</a>)</p>
</td></tr>
<tr><td><code id="selectObsWindow.default_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>!!NOTE!! that this function also returns the grid ($xvals and $yvals) on which the FFT (and hence MALA) will be performed. It is useful to
define spatialAtRiskobjects on this grid to prevent loss of information from the bilinear interpolation that takes place as part of the fitting 
algorithm.
</p>


<h3>Value</h3>

<p>this is the same as selectObsWindow.stppp
</p>


<h3>See Also</h3>

<p><a href="#topic+spatialAtRisk">spatialAtRisk</a> <a href="#topic+selectObsWindow.stppp">selectObsWindow.stppp</a>
</p>

<hr>
<h2 id='selectObsWindow.stppp'>selectObsWindow.stppp function</h2><span id='topic+selectObsWindow.stppp'></span>

<h3>Description</h3>

<p>This function computes an appropriate observation window on which to perform prediction. Since the FFT grid
must have dimension 2^M by 2^N for some M and N, the window <code>xyt$window</code>, is extended to allow this to be fit in for a given cell width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
selectObsWindow(xyt, cellwidth, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectObsWindow.stppp_+3A_xyt">xyt</code></td>
<td>
<p>an object of class stppp</p>
</td></tr>
<tr><td><code id="selectObsWindow.stppp_+3A_cellwidth">cellwidth</code></td>
<td>
<p>size of the grid spacing in chosen units (equivalent to the cell width argument in <a href="#topic+lgcpPredict">lgcpPredict</a>)</p>
</td></tr>
<tr><td><code id="selectObsWindow.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>!!NOTE!! that this function also returns the grid ($xvals and $yvals) on which the FFT (and hence MALA) will be performed. It is useful to
define spatialAtRiskobjects on this grid to prevent loss of information from the bilinear interpolation that takes place as part of the fitting 
algorithm.
</p>


<h3>Value</h3>

<p>a resized stppp object together with grid sizes M and N ready for FFT, together with the FFT grid locations, can be useful for estimating lambda(s)
</p>


<h3>See Also</h3>

<p><a href="#topic+spatialAtRisk">spatialAtRisk</a>
</p>

<hr>
<h2 id='serr'>serr function</h2><span id='topic+serr'></span>

<h3>Description</h3>

<p>Generic function to return standard error of relative risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serr(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serr_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="serr_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method serr
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+serr.lgcpPredict">serr.lgcpPredict</a>
</p>

<hr>
<h2 id='serr.lgcpPredict'>serr.lgcpPredict function</h2><span id='topic+serr.lgcpPredict'></span>

<h3>Description</h3>

<p>Accessor function returning the standard error of relative risk as an lgcpgrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
serr(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serr.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an lgcpPredict object</p>
</td></tr>
<tr><td><code id="serr.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard error of the relative risk as computed by MCMC.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='setoutput'>setoutput function</h2><span id='topic+setoutput'></span>

<h3>Description</h3>

<p>Sets output functionality for <a href="#topic+lgcpPredict">lgcpPredict</a> via the main functions <a href="#topic+dump2dir">dump2dir</a> and <a href="#topic+MonteCarloAverage">MonteCarloAverage</a>. Note that it is possible for
the user to create their own <code>gridfunction</code> and <code>gridmeans</code> schemes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setoutput(gridfunction = NULL, gridmeans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setoutput_+3A_gridfunction">gridfunction</code></td>
<td>
<p>what to do with the latent field, but default this set to nothing, but could save output to a directory, see ?dump2dir</p>
</td></tr>
<tr><td><code id="setoutput_+3A_gridmeans">gridmeans</code></td>
<td>
<p>list of Monte Carlo averages to compute, see ?MonteCarloAverage</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output parameters
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+dump2dir">dump2dir</a>, <a href="#topic+MonteCarloAverage">MonteCarloAverage</a>
</p>

<hr>
<h2 id='setTxtProgressBar2'>set the progress bar</h2><span id='topic+setTxtProgressBar2'></span>

<h3>Description</h3>

<p>update a text progress bar. See help(txtProgressBar) for more info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setTxtProgressBar2(pb, value, title = NULL, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setTxtProgressBar2_+3A_pb">pb</code></td>
<td>
<p>text progress bar object</p>
</td></tr>
<tr><td><code id="setTxtProgressBar2_+3A_value">value</code></td>
<td>
<p>new value</p>
</td></tr>
<tr><td><code id="setTxtProgressBar2_+3A_title">title</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="setTxtProgressBar2_+3A_label">label</code></td>
<td>
<p>text for end of progress bar</p>
</td></tr>
</table>

<hr>
<h2 id='showGrid'>showGrid function</h2><span id='topic+showGrid'></span>

<h3>Description</h3>

<p>Generic method for displaying the FFT grid used in computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showGrid(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showGrid_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="showGrid_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generic function returning method showGrid
</p>


<h3>See Also</h3>

<p><a href="#topic+showGrid.default">showGrid.default</a>, <a href="#topic+showGrid.lgcpPredict">showGrid.lgcpPredict</a>, <a href="#topic+showGrid.stppp">showGrid.stppp</a>
</p>

<hr>
<h2 id='showGrid.default'>showGrid.default function</h2><span id='topic+showGrid.default'></span>

<h3>Description</h3>

<p>Default method for printing a grid to a screen. Arguments are vectors giving the x any y coordinates of the
centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
showGrid(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showGrid.default_+3A_x">x</code></td>
<td>
<p>an vector of grid values for the x coordinates</p>
</td></tr>
<tr><td><code id="showGrid.default_+3A_y">y</code></td>
<td>
<p>an vector of grid values for the y coordinates</p>
</td></tr>
<tr><td><code id="showGrid.default_+3A_...">...</code></td>
<td>
<p>additional arguments passed to points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots grid centroids on the current graphics device
</p>


<h3>See Also</h3>

<p><a href="#topic+showGrid.lgcpPredict">showGrid.lgcpPredict</a>, <a href="#topic+showGrid.stppp">showGrid.stppp</a>
</p>

<hr>
<h2 id='showGrid.lgcpPredict'>showGrid.lgcpPredict function</h2><span id='topic+showGrid.lgcpPredict'></span>

<h3>Description</h3>

<p>This function displays the FFT grid used on a plot of an <code>lgcpPredict</code> object.
First plot the object using for example <code>plot(lg)</code>, where <code>lg</code> is an object
of class <code>lgcpPredict</code>, then for any of the plots produced, a call to
<code>showGrid(lg,pch=="+",cex=0.5)</code> will display the centroids of the FFT grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
showGrid(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showGrid.lgcpPredict_+3A_x">x</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="showGrid.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments  passed to points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots grid centroids on the current graphics device
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+showGrid.default">showGrid.default</a>, <a href="#topic+showGrid.stppp">showGrid.stppp</a>
</p>

<hr>
<h2 id='showGrid.stppp'>showGrid.stppp function</h2><span id='topic+showGrid.stppp'></span>

<h3>Description</h3>

<p>If an stppp object has been created via simulation, ie using the function <code>lgcpSim</code>, then
this function will display the grid centroids that were used in the simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stppp'
showGrid(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showGrid.stppp_+3A_x">x</code></td>
<td>
<p>an object of class stppp. Note this function oly applies to SIMULATED data.</p>
</td></tr>
<tr><td><code id="showGrid.stppp_+3A_...">...</code></td>
<td>
<p>additional arguments  passed to points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots grid centroids on the current graphics device. FOR SIMULATED DATA ONLY.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpSim">lgcpSim</a>, <a href="#topic+showGrid.default">showGrid.default</a>, <a href="#topic+showGrid.lgcpPredict">showGrid.lgcpPredict</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: xyt &lt;- lgcpSim()
## Not run: plot(xyt)
## Not run: showGrid(xyt,pch="+",cex=0.5)
</code></pre>

<hr>
<h2 id='smultiply.list'>smultiply.list function</h2><span id='topic+smultiply.list'></span>

<h3>Description</h3>

<p>This function multiplies each element of a list by a scalar constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smultiply.list(list, const)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smultiply.list_+3A_list">list</code></td>
<td>
<p>a list of objects that could be summed using &quot;+&quot;</p>
</td></tr>
<tr><td><code id="smultiply.list_+3A_const">const</code></td>
<td>
<p>a numeric constant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with ith entry the scalar multiple of const * list[[i]]
</p>

<hr>
<h2 id='sparsebase'>sparsebase function</h2><span id='topic+sparsebase'></span>

<h3>Description</h3>

<p>A function that returns the full precision matrix in sparse format from the base of a block circulant matrix, see ?Matrix::sparseMatrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsebase(base)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparsebase_+3A_base">base</code></td>
<td>
<p>base matrix of a block circulant matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>...
</p>

<hr>
<h2 id='spatialAtRisk'>spatialAtRisk function</h2><span id='topic+spatialAtRisk'></span>

<h3>Description</h3>

<p>The methods for this generic function:<a href="#topic+spatialAtRisk.default">spatialAtRisk.default</a>, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>, <a href="#topic+spatialAtRisk.im">spatialAtRisk.im</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>, 
<a href="#topic+spatialAtRisk.SpatialGridDataFrame">spatialAtRisk.SpatialGridDataFrame</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a> and <a href="#topic+spatialAtRisk.bivden">spatialAtRisk.bivden</a> are used to represent the fixed 
spatial component, lambda(s) in the log-Gaussian Cox process model. Typically lambda(s) would be represented as a spatstat object of class im, that encodes 
population density information. However, regardless of the physical interpretation of lambda(s), 
in lgcp we assume that it integrates to 1 over the observation window. The above methods make sure this condition is satisfied (with the 
exception of the method for objects of class function), as well as providing a framework for manipulating these structures. lgcp uses bilinear interpolation 
to project a user supplied lambda(s) onto a discrete grid ready for inference via MCMC, this grid can be obtained via the <a href="#topic+selectObsWindow">selectObsWindow</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialAtRisk(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAtRisk_+3A_x">X</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="spatialAtRisk_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic function used in the construction of spatialAtRisk objects. The class of spatialAtRisk objects provide a framework for describing
the spatial inhomogeneity of the at-risk population, lambda(s). This is in contrast to the class of 
<a href="#topic+temporalAtRisk">temporalAtRisk</a> objects, which describe the global levels of the population at risk, mu(t).
</p>
<p>Unless the user has specified lambda(s) directly by an R function (a mapping the from the real plane onto the non-negative real numbers, 
see ?spatialAtRisk.function), then it is only necessary to describe the population at risk up to a constant of proportionality, as the routines 
automatically normalise the lambda provided to integrate to 1.
</p>
<p>For reference purposes, the following is a mathematical description of a log-Gaussian Cox Process, it is best viewed in the pdf version of the manual.
</p>
<p>Let <code class="reqn">\mathcal Y(s,t)</code> be a spatiotemporal Gaussian process, <code class="reqn">W\subset R^2</code> be an 
observation window in space and <code class="reqn">T\subset R_{\geq 0}</code> be an interval of time of interest. 
Cases occur at spatio-temporal positions <code class="reqn">(x,t) \in W \times T</code> 
according to an inhomogeneous spatio-temporal Cox process,
i.e. a Poisson process with a stochastic intensity <code class="reqn">R(x,t)</code>,
The number of cases, <code class="reqn">X_{S,[t_1,t_2]}</code>, arising in 
any <code class="reqn">S \subseteq W</code> during the interval <code class="reqn">[t_1,t_2]\subseteq T</code> is 
then Poisson distributed conditional on <code class="reqn">R(\cdot)</code>,
</p>
<p style="text-align: center;"><code class="reqn">X_{S,[t_1,t_2]} \sim \mbox{Poisson}\left\{\int_S\int_{t_1}^{t_2} R(s,t)d sd t\right\}</code>
</p>

<p>Following Brix and Diggle (2001) and Diggle et al (2005), the intensity is decomposed multiplicatively as
</p>
<p style="text-align: center;"><code class="reqn">R(s,t) = \lambda(s)\mu(t)\exp\{\mathcal Y(s,t)\}.</code>
</p>

<p>In the above, the fixed spatial component, <code class="reqn">\lambda:R^2\mapsto R_{\geq 0}</code>, 
is a known function, proportional to the population at risk at each point in space and scaled so that
</p>
<p style="text-align: center;"><code class="reqn">\int_W\lambda(s)d s=1,</code>
</p>

<p>whilst the fixed temporal component, 
<code class="reqn">\mu:R_{\geq 0}\mapsto R_{\geq 0}</code>, is also a known function with
</p>
<p style="text-align: center;"><code class="reqn">\mu(t) \delta t = E[X_{W,\delta t}],</code>
</p>

<p>for <code class="reqn">t</code> in a small interval of time, <code class="reqn">\delta t</code>, over which the rate of the process over <code class="reqn">W</code> can be considered constant.
</p>


<h3>Value</h3>

<p>method spatialAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+selectObsWindow">selectObsWindow</a> <a href="#topic+lgcpPredict">lgcpPredict</a>, linklgcpSim, <a href="#topic+spatialAtRisk.default">spatialAtRisk.default</a>, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>, <a href="#topic+spatialAtRisk.im">spatialAtRisk.im</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>, <a href="#topic+spatialAtRisk.SpatialGridDataFrame">spatialAtRisk.SpatialGridDataFrame</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a>, <a href="#topic+spatialAtRisk.bivden">spatialAtRisk.bivden</a>
</p>

<hr>
<h2 id='spatialAtRisk.bivden'>spatialAtRisk.bivden function</h2><span id='topic+spatialAtRisk.bivden'></span>

<h3>Description</h3>

<p>Creates a spatialAtRisk object from a sparr bivden object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bivden'
spatialAtRisk(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAtRisk.bivden_+3A_x">X</code></td>
<td>
<p>a bivden object</p>
</td></tr>
<tr><td><code id="spatialAtRisk.bivden_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class spatialAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, linklgcpSim, <a href="#topic+spatialAtRisk.default">spatialAtRisk.default</a>, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>, <a href="#topic+spatialAtRisk.im">spatialAtRisk.im</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>, <a href="#topic+spatialAtRisk.SpatialGridDataFrame">spatialAtRisk.SpatialGridDataFrame</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a>
</p>

<hr>
<h2 id='spatialAtRisk.default'>spatialAtRisk.default function</h2><span id='topic+spatialAtRisk.default'></span>

<h3>Description</h3>

<p>The default method for creating a spatialAtRisk object, which attempts to extract x, y and Zm values from the object using <code>xvals</code>,
<code>yvals</code> and <code>zvals</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
spatialAtRisk(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAtRisk.default_+3A_x">X</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="spatialAtRisk.default_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class spatialAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, linklgcpSim, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>, <a href="#topic+spatialAtRisk.im">spatialAtRisk.im</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>, <a href="#topic+spatialAtRisk.SpatialGridDataFrame">spatialAtRisk.SpatialGridDataFrame</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a>, <a href="#topic+spatialAtRisk.bivden">spatialAtRisk.bivden</a>, <code>xvals</code>, <code>yvals</code>, <code>zvals</code>
</p>

<hr>
<h2 id='spatialAtRisk.fromXYZ'>spatialAtRisk.fromXYZ function</h2><span id='topic+spatialAtRisk.fromXYZ'></span>

<h3>Description</h3>

<p>Creates a spatialAtRisk object from a list of X, Y, Zm giving respectively the x and y coordinates of the grid and the 'z' values ie
so that Zm[i,j] is proportional to the at-risk population at X[i], Y[j].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
spatialAtRisk(X, Y, Zm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAtRisk.fromXYZ_+3A_x">X</code></td>
<td>
<p>vector of x-coordinates</p>
</td></tr>
<tr><td><code id="spatialAtRisk.fromXYZ_+3A_y">Y</code></td>
<td>
<p>vector of y-coordinates</p>
</td></tr>
<tr><td><code id="spatialAtRisk.fromXYZ_+3A_zm">Zm</code></td>
<td>
<p>matrix such that Zm[i,j] = f(x[i],y[j]) for some function f</p>
</td></tr>
<tr><td><code id="spatialAtRisk.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class spatialAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, linklgcpSim, <a href="#topic+spatialAtRisk.default">spatialAtRisk.default</a>, <a href="#topic+spatialAtRisk.im">spatialAtRisk.im</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>, <a href="#topic+spatialAtRisk.SpatialGridDataFrame">spatialAtRisk.SpatialGridDataFrame</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a>, <a href="#topic+spatialAtRisk.bivden">spatialAtRisk.bivden</a>
</p>

<hr>
<h2 id='spatialAtRisk.function'>spatialAtRisk.function function</h2><span id='topic+spatialAtRisk.function'></span>

<h3>Description</h3>

<p>Creates a spatialAtRisk object from a function mapping R^2 onto the non negative reals. Note that for spatialAtRisk
objects defined in this manner, the user is responsible for ensurng that the integral of the function is 1 over the observation
window of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
spatialAtRisk(X, warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAtRisk.function_+3A_x">X</code></td>
<td>
<p>a function with accepts arguments x and y that returns the at risk population at coordinate (x,y), which should be a numeric of length 1</p>
</td></tr>
<tr><td><code id="spatialAtRisk.function_+3A_warn">warn</code></td>
<td>
<p>whether to issue a warning or not</p>
</td></tr>
<tr><td><code id="spatialAtRisk.function_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class spatialAtRisk
NOTE The function provided is assumed to integrate to 1 over the observation window, the user is responsible for ensuring this is the case.
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, linklgcpSim, <a href="#topic+spatialAtRisk.default">spatialAtRisk.default</a>, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>, <a href="#topic+spatialAtRisk.im">spatialAtRisk.im</a>, <a href="#topic+spatialAtRisk.SpatialGridDataFrame">spatialAtRisk.SpatialGridDataFrame</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a>, <a href="#topic+spatialAtRisk.bivden">spatialAtRisk.bivden</a>
</p>

<hr>
<h2 id='spatialAtRisk.im'>spatialAtRisk.im function</h2><span id='topic+spatialAtRisk.im'></span>

<h3>Description</h3>

<p>Creates a spatialAtRisk object from a spatstat pixel image (im) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'im'
spatialAtRisk(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAtRisk.im_+3A_x">X</code></td>
<td>
<p>object of class im</p>
</td></tr>
<tr><td><code id="spatialAtRisk.im_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class spatialAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, linklgcpSim, <a href="#topic+spatialAtRisk.default">spatialAtRisk.default</a>, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>, <a href="#topic+spatialAtRisk.SpatialGridDataFrame">spatialAtRisk.SpatialGridDataFrame</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a>, <a href="#topic+spatialAtRisk.bivden">spatialAtRisk.bivden</a>
</p>

<hr>
<h2 id='spatialAtRisk.lgcpgrid'>spatialAtRisk.lgcpgrid function</h2><span id='topic+spatialAtRisk.lgcpgrid'></span>

<h3>Description</h3>

<p>Creates a spatialAtRisk object from an lgcpgrid object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
spatialAtRisk(X, idx = length(X$grid), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAtRisk.lgcpgrid_+3A_x">X</code></td>
<td>
<p>an lgcpgrid object</p>
</td></tr>
<tr><td><code id="spatialAtRisk.lgcpgrid_+3A_idx">idx</code></td>
<td>
<p>in the case that X$grid is a list of length &gt; 1, this argument specifies which element of the list to convert. By default, it is the last.</p>
</td></tr>
<tr><td><code id="spatialAtRisk.lgcpgrid_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class spatialAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, linklgcpSim, <a href="#topic+spatialAtRisk.default">spatialAtRisk.default</a>, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>, <a href="#topic+spatialAtRisk.im">spatialAtRisk.im</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>, <a href="#topic+spatialAtRisk.SpatialGridDataFrame">spatialAtRisk.SpatialGridDataFrame</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a>
</p>

<hr>
<h2 id='spatialAtRisk.SpatialGridDataFrame'>spatialAtRisk.SpatialGridDataFrame function</h2><span id='topic+spatialAtRisk.SpatialGridDataFrame'></span>

<h3>Description</h3>

<p>Creates a spatialAtRisk object from an sp SpatialGridDataFrame object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialGridDataFrame'
spatialAtRisk(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAtRisk.SpatialGridDataFrame_+3A_x">X</code></td>
<td>
<p>a SpatialGridDataFrame object</p>
</td></tr>
<tr><td><code id="spatialAtRisk.SpatialGridDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class spatialAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, linklgcpSim, <a href="#topic+spatialAtRisk.default">spatialAtRisk.default</a>, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>, <a href="#topic+spatialAtRisk.im">spatialAtRisk.im</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>, <a href="#topic+spatialAtRisk.SpatialPolygonsDataFrame">spatialAtRisk.SpatialPolygonsDataFrame</a>, <a href="#topic+spatialAtRisk.bivden">spatialAtRisk.bivden</a>
</p>

<hr>
<h2 id='spatialAtRisk.SpatialPolygonsDataFrame'>spatialAtRisk.SpatialPolygonsDataFrame function</h2><span id='topic+spatialAtRisk.SpatialPolygonsDataFrame'></span>

<h3>Description</h3>

<p>Creates a spatialAtRisk object from a SpatialPolygonsDataFrame object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPolygonsDataFrame'
spatialAtRisk(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialAtRisk.SpatialPolygonsDataFrame_+3A_x">X</code></td>
<td>
<p>a SpatialPolygonsDataFrame object; one column of the data frame should have name &quot;atrisk&quot;, containing the aggregate population at risk for that region</p>
</td></tr>
<tr><td><code id="spatialAtRisk.SpatialPolygonsDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class spatialAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>, linklgcpSim, <a href="#topic+spatialAtRisk.default">spatialAtRisk.default</a>, <a href="#topic+spatialAtRisk.fromXYZ">spatialAtRisk.fromXYZ</a>, <a href="#topic+spatialAtRisk.im">spatialAtRisk.im</a>, <a href="#topic+spatialAtRisk.function">spatialAtRisk.function</a>, <a href="#topic+spatialAtRisk.SpatialGridDataFrame">spatialAtRisk.SpatialGridDataFrame</a>, <a href="#topic+spatialAtRisk.bivden">spatialAtRisk.bivden</a>
</p>

<hr>
<h2 id='spatialIntensities'>spatialIntensities function</h2><span id='topic+spatialIntensities'></span>

<h3>Description</h3>

<p>Generic method for extracting spatial intensities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialIntensities(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialIntensities_+3A_x">X</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="spatialIntensities_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method spatialintensities
</p>


<h3>See Also</h3>

<p><a href="#topic+spatialIntensities.fromXYZ">spatialIntensities.fromXYZ</a>, <a href="#topic+spatialIntensities.fromSPDF">spatialIntensities.fromSPDF</a>
</p>

<hr>
<h2 id='spatialIntensities.fromSPDF'>spatialIntensities.fromSPDF function</h2><span id='topic+spatialIntensities.fromSPDF'></span>

<h3>Description</h3>

<p>Extract the spatial intensities from an object of class fromSPDF (as would have been created by spatialAtRisk.SpatialPolygonsDataFrame for example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromSPDF'
spatialIntensities(X, xyt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialIntensities.fromSPDF_+3A_x">X</code></td>
<td>
<p>an object of class fromSPDF</p>
</td></tr>
<tr><td><code id="spatialIntensities.fromSPDF_+3A_xyt">xyt</code></td>
<td>
<p>object of class stppp or a list object of numeric vectors with names $x, $y</p>
</td></tr>
<tr><td><code id="spatialIntensities.fromSPDF_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalised spatial intensities
</p>


<h3>See Also</h3>

<p><a href="#topic+spatialIntensities">spatialIntensities</a>, <a href="#topic+spatialIntensities.fromXYZ">spatialIntensities.fromXYZ</a>
</p>

<hr>
<h2 id='spatialIntensities.fromXYZ'>spatialIntensities.fromXYZ function</h2><span id='topic+spatialIntensities.fromXYZ'></span>

<h3>Description</h3>

<p>Extract the spatial intensities from an object of class fromXYZ (as would have been created by spatialAtRisk for example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
spatialIntensities(X, xyt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialIntensities.fromXYZ_+3A_x">X</code></td>
<td>
<p>object of class fromXYZ</p>
</td></tr>
<tr><td><code id="spatialIntensities.fromXYZ_+3A_xyt">xyt</code></td>
<td>
<p>object of class stppp or a list object of numeric vectors with names $x, $y</p>
</td></tr>
<tr><td><code id="spatialIntensities.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalised spatial intensities
</p>


<h3>See Also</h3>

<p><a href="#topic+spatialIntensities">spatialIntensities</a>, <a href="#topic+spatialIntensities.fromSPDF">spatialIntensities.fromSPDF</a>
</p>

<hr>
<h2 id='spatialparsEst'>spatialparsEst function</h2><span id='topic+spatialparsEst'></span>

<h3>Description</h3>

<p>Having estimated either the pair correlation or K functions using respectively <a href="#topic+ginhomAverage">ginhomAverage</a> or <a href="#topic+KinhomAverage">KinhomAverage</a>, the spatial 
parameters sigma and phi can be estimated. This function provides a visual tool for this estimation procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialparsEst(
  gk,
  sigma.range,
  phi.range,
  spatial.covmodel,
  covpars = c(),
  guess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialparsEst_+3A_gk">gk</code></td>
<td>
<p>an R object; output from the function KinhomAverage or ginhomAverage</p>
</td></tr>
<tr><td><code id="spatialparsEst_+3A_sigma.range">sigma.range</code></td>
<td>
<p>range of sigma values to consider</p>
</td></tr>
<tr><td><code id="spatialparsEst_+3A_phi.range">phi.range</code></td>
<td>
<p>range of phi values to consider</p>
</td></tr>
<tr><td><code id="spatialparsEst_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>correlation type see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="spatialparsEst_+3A_covpars">covpars</code></td>
<td>
<p>vector of additional parameters for certain classes of covariance function (eg Matern), these must be supplied in the order given in ?CovarianceFct</p>
</td></tr>
<tr><td><code id="spatialparsEst_+3A_guess">guess</code></td>
<td>
<p>logical. Perform an initial guess at paramters? Alternative (the default) sets initial values in the middle of sigma.range and phi.range. NOTE: automatic parameter estimation can be can be unreliable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To get a good choice of parameters, it is likely that the routine will have to be called several times in order to refine 
the choice of sigma.range and phi.range.
</p>


<h3>Value</h3>

<p>rpanel function to help choose sigma nad phi by eye
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Baddeley AJ, Moller J, Waagepetersen R (2000). Non-and semi-parametric estimation of interaction in inhomogeneous point patterns. Statistica Neerlandica, 54, 329-350.
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+thetaEst">thetaEst</a>, <a href="#topic+lambdaEst">lambdaEst</a>, <a href="#topic+muEst">muEst</a>
</p>

<hr>
<h2 id='SpatialPolygonsDataFrame.stapp'>SpatialPolygonsDataFrame.stapp function</h2><span id='topic+SpatialPolygonsDataFrame.stapp'></span>

<h3>Description</h3>

<p>A function to return the SpatialPolygonsDataFrame part of an stapp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatialPolygonsDataFrame.stapp(from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialPolygonsDataFrame.stapp_+3A_from">from</code></td>
<td>
<p>stapp object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class SpatialPolygonsDataFrame
</p>

<hr>
<h2 id='SpikedExponentialCovFct'>SpikedExponentialCovFct function</h2><span id='topic+SpikedExponentialCovFct'></span>

<h3>Description</h3>

<p>A function to declare and also evaluate a spiked exponential covariance function. Note that the present version of
lgcp only offers estimation for sigma and phi, the additional parameter 'spikevar' is treated as fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpikedExponentialCovFct(d, CovParameters, spikevar = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpikedExponentialCovFct_+3A_d">d</code></td>
<td>
<p>toral distance</p>
</td></tr>
<tr><td><code id="SpikedExponentialCovFct_+3A_covparameters">CovParameters</code></td>
<td>
<p>parameters of the latent field, an object of class &quot;CovParamaters&quot;.</p>
</td></tr>
<tr><td><code id="SpikedExponentialCovFct_+3A_spikevar">spikevar</code></td>
<td>
<p>the additional variance at distance 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the spiked exponential covariance function; note that the spikevariance is currently not estimated as part of the MCMC routine, and is thus treated as a fixed parameter.
</p>


<h3>See Also</h3>

<p><a href="#topic+CovFunction.function">CovFunction.function</a>, <a href="#topic+exponentialCovFct">exponentialCovFct</a>, <a href="#topic+RandomFieldsCovFct">RandomFieldsCovFct</a>
</p>

<hr>
<h2 id='stapp'>stapp function</h2><span id='topic+stapp'></span>

<h3>Description</h3>

<p>Generic function for space-time aggregated point-process data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stapp(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stapp_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="stapp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method stapp
</p>

<hr>
<h2 id='stapp.list'>stapp.list function</h2><span id='topic+stapp.list'></span>

<h3>Description</h3>

<p>A wrapper function for stapp.SpatialPolygonsDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
stapp(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stapp.list_+3A_obj">obj</code></td>
<td>
<p>an list object as described above, see ?stapp.SpatialPolygonsDataFrame for further details on the requirements of the list</p>
</td></tr>
<tr><td><code id="stapp.list_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Construct a space-time aggregated point-process (stapp) object from a list object. The first element of the list 
should be a SpatialPolygonsDataFrame, the second element of the list a counts matrix, the third element of the list a
vector of times, the fourth element a vector giving the bounds of the temporal observation window and the fifth element
a spatstat owin object giving the spatial observation window.
</p>


<h3>Value</h3>

<p>an object of class stapp
</p>

<hr>
<h2 id='stapp.SpatialPolygonsDataFrame'>stapp.SpatialPolygonsDataFrame function</h2><span id='topic+stapp.SpatialPolygonsDataFrame'></span>

<h3>Description</h3>

<p>Construct a space-time aggregated point-process (stapp) object from a SpatialPolygonsDataFrame (along with some other info)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPolygonsDataFrame'
stapp(obj, counts, t, tlim, window, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stapp.SpatialPolygonsDataFrame_+3A_obj">obj</code></td>
<td>
<p>an SpatialPolygonsDataFrame object</p>
</td></tr>
<tr><td><code id="stapp.SpatialPolygonsDataFrame_+3A_counts">counts</code></td>
<td>
<p>a (length(t) by N) matrix containing aggregated case counts for each of the geographical regions defined by the SpatialPolygonsDataFrame, where N is the number of regions</p>
</td></tr>
<tr><td><code id="stapp.SpatialPolygonsDataFrame_+3A_t">t</code></td>
<td>
<p>vector of times, for each element of t there should correspond a column in the matrix 'counts'</p>
</td></tr>
<tr><td><code id="stapp.SpatialPolygonsDataFrame_+3A_tlim">tlim</code></td>
<td>
<p>vector giving the upper and lower bounds of the temporal observation window</p>
</td></tr>
<tr><td><code id="stapp.SpatialPolygonsDataFrame_+3A_window">window</code></td>
<td>
<p>the observation window, of class owin, see ?owin</p>
</td></tr>
<tr><td><code id="stapp.SpatialPolygonsDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class stapp
</p>

<hr>
<h2 id='stGPrealisation'>stGPrealisation function</h2><span id='topic+stGPrealisation'></span>

<h3>Description</h3>

<p>A function to store a realisation of a spatiotemporal gaussian process for use in MCMC algorithms that include Bayesian parameter estimation.
Stores not only the realisation, but also computational quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stGPrealisation(gamma, fftgrid, covFunction, covParameters, d, tdiff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stGPrealisation_+3A_gamma">gamma</code></td>
<td>
<p>the transformed (white noise) realisation of the process</p>
</td></tr>
<tr><td><code id="stGPrealisation_+3A_fftgrid">fftgrid</code></td>
<td>
<p>an object of class FFTgrid, see ?genFFTgrid</p>
</td></tr>
<tr><td><code id="stGPrealisation_+3A_covfunction">covFunction</code></td>
<td>
<p>an object of class function returning the spatial covariance</p>
</td></tr>
<tr><td><code id="stGPrealisation_+3A_covparameters">covParameters</code></td>
<td>
<p>an object of class CovParamaters, see ?CovParamaters</p>
</td></tr>
<tr><td><code id="stGPrealisation_+3A_d">d</code></td>
<td>
<p>matrix of grid distances</p>
</td></tr>
<tr><td><code id="stGPrealisation_+3A_tdiff">tdiff</code></td>
<td>
<p>vector of time differences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a realisation of a spatiotemporal Gaussian process on a regular grid
</p>

<hr>
<h2 id='stppp'>stppp function</h2><span id='topic+stppp'></span>

<h3>Description</h3>

<p>Generic function used in the construction of space-time planar point patterns. An stppp object is like a ppp object,
but with extra components for (1) a vector giving the time at whcih the event occurred and (2) a time-window over which observations occurred.
Observations are assumed to occur in the plane and the observation window is assumed not to change over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stppp(P, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stppp_+3A_p">P</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="stppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method stppp
</p>


<h3>See Also</h3>

<p><a href="#topic+stppp">stppp</a>, <a href="#topic+stppp.ppp">stppp.ppp</a>, <a href="#topic+stppp.list">stppp.list</a>
</p>

<hr>
<h2 id='stppp.list'>stppp.list function</h2><span id='topic+stppp.list'></span>

<h3>Description</h3>

<p>Construct a space-time planar point pattern from a list object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
stppp(P, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stppp.list_+3A_p">P</code></td>
<td>
<p>list object containing $data, an (n x 3) matrix corresponding to (x,y,t) values; $tlim, a vector of length 2 givign the observation time window; and $window giving an owin spatial observation winow, see ?owin for more details</p>
</td></tr>
<tr><td><code id="stppp.list_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class stppp
</p>


<h3>See Also</h3>

<p><a href="#topic+stppp">stppp</a>, <a href="#topic+stppp.ppp">stppp.ppp</a>,
</p>

<hr>
<h2 id='stppp.ppp'>stppp.ppp function</h2><span id='topic+stppp.ppp'></span>

<h3>Description</h3>

<p>Construct a space-time planar point pattern from a ppp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppp'
stppp(P, t, tlim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stppp.ppp_+3A_p">P</code></td>
<td>
<p>a spatstat ppp object</p>
</td></tr>
<tr><td><code id="stppp.ppp_+3A_t">t</code></td>
<td>
<p>a vector of length P$n</p>
</td></tr>
<tr><td><code id="stppp.ppp_+3A_tlim">tlim</code></td>
<td>
<p>a vector of length 2 specifying the observation time window</p>
</td></tr>
<tr><td><code id="stppp.ppp_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class stppp
</p>


<h3>See Also</h3>

<p><a href="#topic+stppp">stppp</a>, <a href="#topic+stppp.list">stppp.list</a>
</p>

<hr>
<h2 id='summary.lgcpgrid'>summary.lgcpgrid function</h2><span id='topic+summary.lgcpgrid'></span>

<h3>Description</h3>

<p>Summary method for lgcp objects. This just applies the summary function to each
of the elements of object$grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpgrid'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lgcpgrid_+3A_object">object</code></td>
<td>
<p>an object of class lgcpgrid</p>
</td></tr>
<tr><td><code id="summary.lgcpgrid_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary per grid, see ?summary for further options
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpgrid.list">lgcpgrid.list</a>, <a href="#topic+lgcpgrid.array">lgcpgrid.array</a>, <a href="#topic+as.list.lgcpgrid">as.list.lgcpgrid</a>, <a href="#topic+print.lgcpgrid">print.lgcpgrid</a>,
<a href="#topic+quantile.lgcpgrid">quantile.lgcpgrid</a>, <a href="#topic+image.lgcpgrid">image.lgcpgrid</a>, <a href="#topic+plot.lgcpgrid">plot.lgcpgrid</a>
</p>

<hr>
<h2 id='summary.mcmc'>summary.mcmc function</h2><span id='topic+summary.mcmc'></span>

<h3>Description</h3>

<p>summary of an mcmc iterator
print out values of an iterator and reset it. DONT call this
in a loop that uses this iterator - it will reset it. And break.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcmc_+3A_object">object</code></td>
<td>
<p>an mcmc iterator</p>
</td></tr>
<tr><td><code id="summary.mcmc_+3A_...">...</code></td>
<td>
<p>other args</p>
</td></tr>
</table>

<hr>
<h2 id='target.and.grad.AggregateSpatialPlusPars'>target.and.grad.AggregateSpatialPlusPars function</h2><span id='topic+target.and.grad.AggregateSpatialPlusPars'></span>

<h3>Description</h3>

<p>A function to compute the target and gradient for the Bayesian aggregated point process model. Not for general use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.and.grad.AggregateSpatialPlusPars(
  GP,
  prior,
  Z,
  Zt,
  eta,
  beta,
  nis,
  cellarea,
  spatial,
  gradtrunc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_gp">GP</code></td>
<td>
<p>an object constructed using GPrealisation</p>
</td></tr>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_prior">prior</code></td>
<td>
<p>the prior, created using lgcpPrior</p>
</td></tr>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_z">Z</code></td>
<td>
<p>the design matrix on the full FFT grid</p>
</td></tr>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_zt">Zt</code></td>
<td>
<p>the transpose of the design matrix</p>
</td></tr>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_eta">eta</code></td>
<td>
<p>the model parameter, eta</p>
</td></tr>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_beta">beta</code></td>
<td>
<p>the model parameters, beta</p>
</td></tr>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_nis">nis</code></td>
<td>
<p>cell counts on the FFT grid</p>
</td></tr>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_spatial">spatial</code></td>
<td>
<p>the poisson offset</p>
</td></tr>
<tr><td><code id="target.and.grad.AggregateSpatialPlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>the gradient truncation parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the target and gradient
</p>

<hr>
<h2 id='target.and.grad.MultitypespatialPlusPars'>target.and.grad.MultitypespatialPlusPars function</h2><span id='topic+target.and.grad.MultitypespatialPlusPars'></span>

<h3>Description</h3>

<p>A function to compute the taget an gradient for the Bayesian multivariate lgcp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.and.grad.MultitypespatialPlusPars(
  GPlist,
  priorlist,
  Zlist,
  Ztlist,
  eta,
  beta,
  nis,
  cellarea,
  spatial,
  gradtrunc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_gplist">GPlist</code></td>
<td>
<p>list of Gaussian processes</p>
</td></tr>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_priorlist">priorlist</code></td>
<td>
<p>list of priors</p>
</td></tr>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_zlist">Zlist</code></td>
<td>
<p>list of design matrices on the FFT gridd</p>
</td></tr>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_ztlist">Ztlist</code></td>
<td>
<p>list of transposed design matrices</p>
</td></tr>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_eta">eta</code></td>
<td>
<p>LGCP model parameter eta</p>
</td></tr>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_beta">beta</code></td>
<td>
<p>LGCP model parameter beta</p>
</td></tr>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_nis">nis</code></td>
<td>
<p>matrix of cell counts on the extended grid</p>
</td></tr>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_spatial">spatial</code></td>
<td>
<p>the poisson offset interpolated onto the correcy grid</p>
</td></tr>
<tr><td><code id="target.and.grad.MultitypespatialPlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation paramter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the target and gradient
</p>

<hr>
<h2 id='target.and.grad.spatial'>target.and.grad.spatial function</h2><span id='topic+target.and.grad.spatial'></span>

<h3>Description</h3>

<p>A function to compute the target and gradient for 'spatial only' MALA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.and.grad.spatial(
  Gamma,
  nis,
  cellarea,
  rootQeigs,
  invrootQeigs,
  mu,
  spatial,
  logspat,
  scaleconst,
  gradtrunc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.and.grad.spatial_+3A_gamma">Gamma</code></td>
<td>
<p>current state of the chain, Gamma</p>
</td></tr>
<tr><td><code id="target.and.grad.spatial_+3A_nis">nis</code></td>
<td>
<p>matrix of cell counts</p>
</td></tr>
<tr><td><code id="target.and.grad.spatial_+3A_cellarea">cellarea</code></td>
<td>
<p>area of cells, a positive number</p>
</td></tr>
<tr><td><code id="target.and.grad.spatial_+3A_rootqeigs">rootQeigs</code></td>
<td>
<p>square root of the eigenvectors of the precision matrix</p>
</td></tr>
<tr><td><code id="target.and.grad.spatial_+3A_invrootqeigs">invrootQeigs</code></td>
<td>
<p>inverse square root of the eigenvectors of the precision matrix</p>
</td></tr>
<tr><td><code id="target.and.grad.spatial_+3A_mu">mu</code></td>
<td>
<p>parameter of the latent Gaussian field</p>
</td></tr>
<tr><td><code id="target.and.grad.spatial_+3A_spatial">spatial</code></td>
<td>
<p>spatial at risk function, lambda, interpolated onto correct grid</p>
</td></tr>
<tr><td><code id="target.and.grad.spatial_+3A_logspat">logspat</code></td>
<td>
<p>log of spatial at risk function, lambda*scaleconst, interpolated onto correct grid</p>
</td></tr>
<tr><td><code id="target.and.grad.spatial_+3A_scaleconst">scaleconst</code></td>
<td>
<p>the expected number of cases</p>
</td></tr>
<tr><td><code id="target.and.grad.spatial_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the back-transformed Y, its exponential, the log-target and gradient for use in MALAlgcpSpatial
</p>

<hr>
<h2 id='target.and.grad.spatialPlusPars'>target.and.grad.spatialPlusPars function</h2><span id='topic+target.and.grad.spatialPlusPars'></span>

<h3>Description</h3>

<p>A function to compute the target and gradient for the Bayesian spatial LGCP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.and.grad.spatialPlusPars(
  GP,
  prior,
  Z,
  Zt,
  eta,
  beta,
  nis,
  cellarea,
  spatial,
  gradtrunc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_gp">GP</code></td>
<td>
<p>an object created using GPrealisation</p>
</td></tr>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_prior">prior</code></td>
<td>
<p>the model priors, created using lgcpPrior</p>
</td></tr>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_z">Z</code></td>
<td>
<p>the design matrix on the FFT grid</p>
</td></tr>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_zt">Zt</code></td>
<td>
<p>transpose of the design matrix</p>
</td></tr>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_eta">eta</code></td>
<td>
<p>the paramters, eta</p>
</td></tr>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_beta">beta</code></td>
<td>
<p>the parameters, beta</p>
</td></tr>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_nis">nis</code></td>
<td>
<p>cell counts on the FFT grid</p>
</td></tr>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_spatial">spatial</code></td>
<td>
<p>poisson offset</p>
</td></tr>
<tr><td><code id="target.and.grad.spatialPlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>the gradient truncation parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the target and graient for this model
</p>

<hr>
<h2 id='target.and.grad.spatiotemporal'>target.and.grad.spatiotemporal function</h2><span id='topic+target.and.grad.spatiotemporal'></span>

<h3>Description</h3>

<p>A function to compute the target and gradient for 'spatial only' MALA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.and.grad.spatiotemporal(
  Gamma,
  nis,
  cellarea,
  rootQeigs,
  invrootQeigs,
  mu,
  spatial,
  logspat,
  temporal,
  bt,
  gt,
  gradtrunc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_gamma">Gamma</code></td>
<td>
<p>current state of the chain, Gamma</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_nis">nis</code></td>
<td>
<p>matrix of cell counts</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_cellarea">cellarea</code></td>
<td>
<p>area of cells, a positive number</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_rootqeigs">rootQeigs</code></td>
<td>
<p>square root of the eigenvectors of the precision matrix</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_invrootqeigs">invrootQeigs</code></td>
<td>
<p>inverse square root of the eigenvectors of the precision matrix</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_mu">mu</code></td>
<td>
<p>parameter of the latent Gaussian field</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_spatial">spatial</code></td>
<td>
<p>spatial at risk function, lambda, interpolated onto correct grid</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_logspat">logspat</code></td>
<td>
<p>log of spatial at risk function, lambda*scaleconst, interpolated onto correct grid</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_temporal">temporal</code></td>
<td>
<p>fitted temoporal values</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_bt">bt</code></td>
<td>
<p>in Brix and Diggle vector b(delta t)</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_gt">gt</code></td>
<td>
<p>in Brix and Diggle vector g(delta t) (ie the coefficient of R in G(t)), with convention that (deltat[1])=Inf</p>
</td></tr>
<tr><td><code id="target.and.grad.spatiotemporal_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>gradient truncation parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the back-transformed Y, its exponential, the log-target and gradient for use in MALAlgcp
</p>

<hr>
<h2 id='target.and.grad.SpatioTemporalPlusPars'>target.and.grad.SpatioTemporalPlusPars function</h2><span id='topic+target.and.grad.SpatioTemporalPlusPars'></span>

<h3>Description</h3>

<p>A function to compute the target and gradient for the Bayesian spatiotemporal LGCP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target.and.grad.SpatioTemporalPlusPars(
  GP,
  prior,
  Z,
  Zt,
  eta,
  beta,
  nis,
  cellarea,
  spatial,
  gradtrunc,
  ETA0,
  tdiff
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_gp">GP</code></td>
<td>
<p>an object created using the stGPrealisation function</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_prior">prior</code></td>
<td>
<p>the priors for hte model, created using lgcpPrior</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_z">Z</code></td>
<td>
<p>the design matrix on the FFT grid</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_zt">Zt</code></td>
<td>
<p>the transpose of the design matrix</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_eta">eta</code></td>
<td>
<p>the paramers eta</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_beta">beta</code></td>
<td>
<p>the parameters beta</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_nis">nis</code></td>
<td>
<p>the cell counts on the FFT grid</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_cellarea">cellarea</code></td>
<td>
<p>the cell area</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_spatial">spatial</code></td>
<td>
<p>the poisson offset</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_gradtrunc">gradtrunc</code></td>
<td>
<p>the gradient truncation parameter</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_eta0">ETA0</code></td>
<td>
<p>the initial value of eta</p>
</td></tr>
<tr><td><code id="target.and.grad.SpatioTemporalPlusPars_+3A_tdiff">tdiff</code></td>
<td>
<p>vector of time differences between time points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the target and gradient for the spatiotemporal model.
</p>

<hr>
<h2 id='temporalAtRisk'>temporalAtRisk function</h2><span id='topic+temporalAtRisk'></span>

<h3>Description</h3>

<p>Generic function used in the construction of temporalAtRisk objects. A temporalAtRisk object describes the at risk
population globally in an observation time window [t_1,t_2]. Therefore, for any t in [t_1,t_2], a temporalAtRisk object should be able
to return the global at risk population, mu(t) = E(number of cases in the unit time interval containing t). This is in contrast to the class of 
<a href="#topic+spatialAtRisk">spatialAtRisk</a> objects, which describe the spatial inhomogeneity in the population at risk, lambda(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temporalAtRisk(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temporalAtRisk_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="temporalAtRisk_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in the prediction routine, <a href="#topic+lgcpPredict">lgcpPredict</a>, and the simulation routine, <a href="#topic+lgcpSim">lgcpSim</a>, time discretisation is achieved
using <code>as.integer</code> on both observation times and time limits t_1 and t_2 (which may be stored as non-integer values). The
functions that create temporalAtRisk objects therefore return piecewise cconstant step-functions. that can be evaluated for any real
t in [t_1,t_2], but with the restriction that mu(t_i) = mu(t_j) whenever <code>as.integer(t_i)==as.integer(t_j)</code>.
</p>
<p>A temporalAtRisk object may be (1) 'assumed known', or (2) scaled to a particular dataset. In the latter case, in the routines available (<a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>
and <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>), the stppp dataset of interest should be referenced, in which case the scaling of mu(t) will be done 
automatically. Otherwise, for example for simulation purposes, no scaling of mu(t) occurs, and it is assumed that the mu(t) corresponds to the
expected number of cases during the unit time interval containnig t.
For reference purposes, the following is a mathematical description of a log-Gaussian Cox Process, it is best viewed in the pdf version of the manual.
</p>
<p>Let <code class="reqn">\mathcal Y(s,t)</code> be a spatiotemporal Gaussian process, <code class="reqn">W\subset R^2</code> be an 
observation window in space and <code class="reqn">T\subset R_{\geq 0}</code> be an interval of time of interest. 
Cases occur at spatio-temporal positions <code class="reqn">(x,t) \in W \times T</code> 
according to an inhomogeneous spatio-temporal Cox process,
i.e. a Poisson process with a stochastic intensity <code class="reqn">R(x,t)</code>,
The number of cases, <code class="reqn">X_{S,[t_1,t_2]}</code>, arising in 
any <code class="reqn">S \subseteq W</code> during the interval <code class="reqn">[t_1,t_2]\subseteq T</code> is 
then Poisson distributed conditional on <code class="reqn">R(\cdot)</code>,
</p>
<p style="text-align: center;"><code class="reqn">X_{S,[t_1,t_2]} \sim \mbox{Poisson}\left\{\int_S\int_{t_1}^{t_2} R(s,t)d sd t\right\}</code>
</p>

<p>Following Brix and Diggle (2001) and Diggle et al (2005), the intensity is decomposed multiplicatively as
</p>
<p style="text-align: center;"><code class="reqn">R(s,t) = \lambda(s)\mu(t)\exp\{\mathcal Y(s,t)\}.</code>
</p>

<p>In the above, the fixed spatial component, <code class="reqn">\lambda:R^2\mapsto R_{\geq 0}</code>, 
is a known function, proportional to the population at risk at each point in space and scaled so that
</p>
<p style="text-align: center;"><code class="reqn">\int_W\lambda(s)d s=1,</code>
</p>

<p>whilst the fixed temporal component, 
<code class="reqn">\mu:R_{\geq 0}\mapsto R_{\geq 0}</code>, is also a known function with
</p>
<p style="text-align: center;"><code class="reqn">\mu(t) \delta t = E[X_{W,\delta t}],</code>
</p>

<p>for <code class="reqn">t</code> in a small interval of time, <code class="reqn">\delta t</code>, over which the rate of the process over <code class="reqn">W</code> can be considered constant.
</p>


<h3>Value</h3>

<p>method temporalAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+lgcpPredict">lgcpPredict</a>, <a href="#topic+lgcpSim">lgcpSim</a>, <a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>, <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>, <a href="#topic+constantInTime">constantInTime</a>, <a href="#topic+constantInTime.numeric">constantInTime.numeric</a>, <a href="#topic+constantInTime.stppp">constantInTime.stppp</a>, <a href="#topic+print.temporalAtRisk">print.temporalAtRisk</a>, <a href="#topic+plot.temporalAtRisk">plot.temporalAtRisk</a>
</p>

<hr>
<h2 id='temporalAtRisk.function'>temporalAtRisk.function function</h2><span id='topic+temporalAtRisk.function'></span>

<h3>Description</h3>

<p>Create a temporalAtRisk object from a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
temporalAtRisk(obj, tlim, xyt = NULL, warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temporalAtRisk.function_+3A_obj">obj</code></td>
<td>
<p>a function accepting single, scalar, numeric argument, t, that returns the temporal intensity for time t</p>
</td></tr>
<tr><td><code id="temporalAtRisk.function_+3A_tlim">tlim</code></td>
<td>
<p>an integer vector of length 2 giving the time limits of the observation window</p>
</td></tr>
<tr><td><code id="temporalAtRisk.function_+3A_xyt">xyt</code></td>
<td>
<p>an object of class stppp. If NULL (default) then the function returned is not scaled. Otherwise, the function is scaled so that f(t) = expected number of counts at time t.</p>
</td></tr>
<tr><td><code id="temporalAtRisk.function_+3A_warn">warn</code></td>
<td>
<p>Issue a warning if the given temporal intensity treated is treated as 'known'?</p>
</td></tr>
<tr><td><code id="temporalAtRisk.function_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in the prediction routine, <a href="#topic+lgcpPredict">lgcpPredict</a>, and the simulation routine, <a href="#topic+lgcpSim">lgcpSim</a>, time discretisation is achieved
using <code>as.integer</code> on both observation times and time limits t_1 and t_2 (which may be stored as non-integer values). The
functions that create temporalAtRisk objects therefore return piecewise cconstant step-functions. that can be evaluated for any real
t in [t_1,t_2], but with the restriction that mu(t_i) = mu(t_j) whenever <code>as.integer(t_i)==as.integer(t_j)</code>.
</p>
<p>A temporalAtRisk object may be (1) 'assumed known', corresponding to the default argument <code>xyt=NULL</code>; or (2) scaled to a particular dataset
(argument xyt=[stppp object of interest]). In the latter case, in the routines available (<a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>
and <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>), the dataset of interest should be referenced, in which case the scaling of mu(t) will be done 
automatically. Otherwise, for example for simulation purposes, no scaling of mu(t) occurs, and it is assumed that the mu(t) corresponds to the
expected number of cases during the unit time interval containnig t.
</p>


<h3>Value</h3>

<p>a function f(t) giving the temporal intensity at time t for integer t in the interval [tlim[1],tlim[2]] of class temporalAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+spatialAtRisk">spatialAtRisk</a>, <a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>,  <a href="#topic+constantInTime">constantInTime</a>, <a href="#topic+constantInTime.numeric">constantInTime.numeric</a>, <a href="#topic+constantInTime.stppp">constantInTime.stppp</a>, <a href="#topic+print.temporalAtRisk">print.temporalAtRisk</a>, <a href="#topic+plot.temporalAtRisk">plot.temporalAtRisk</a>
</p>

<hr>
<h2 id='temporalAtRisk.numeric'>temporalAtRisk.numeric function</h2><span id='topic+temporalAtRisk.numeric'></span>

<h3>Description</h3>

<p>Create a temporalAtRisk object from a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
temporalAtRisk(obj, tlim, xyt = NULL, warn = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temporalAtRisk.numeric_+3A_obj">obj</code></td>
<td>
<p>a numeric vector of length (tlim[2]-tlim[1] + 1) giving the temporal intensity up to a constant of proportionality at each integer time within the interval defined by tlim</p>
</td></tr>
<tr><td><code id="temporalAtRisk.numeric_+3A_tlim">tlim</code></td>
<td>
<p>an integer vector of length 2 giving the time limits of the observation window</p>
</td></tr>
<tr><td><code id="temporalAtRisk.numeric_+3A_xyt">xyt</code></td>
<td>
<p>an object of class stppp. If NULL (default) then the function returned is not scaled. Otherwise, the function is scaled so that f(t) = expected number of counts at time t.</p>
</td></tr>
<tr><td><code id="temporalAtRisk.numeric_+3A_warn">warn</code></td>
<td>
<p>Issue a warning if the given temporal intensity treated is treated as 'known'?</p>
</td></tr>
<tr><td><code id="temporalAtRisk.numeric_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in the prediction routine, <a href="#topic+lgcpPredict">lgcpPredict</a>, and the simulation routine, <a href="#topic+lgcpSim">lgcpSim</a>, time discretisation is achieved
using <code>as.integer</code> on both observation times and time limits t_1 and t_2 (which may be stored as non-integer values). The
functions that create temporalAtRisk objects therefore return piecewise constant step-functions that can be evaluated for any real
t in [t_1,t_2], but with the restriction that mu(t_i) = mu(t_j) whenever <code>as.integer(t_i)==as.integer(t_j)</code>.
</p>
<p>A temporalAtRisk object may be (1) 'assumed known', corresponding to the default argument <code>xyt=NULL</code>; or (2) scaled to a particular dataset
(argument xyt=[stppp object of interest]). In the latter case, in the routines available (<a href="#topic+temporalAtRisk.numeric">temporalAtRisk.numeric</a>
and <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>), the dataset of interest should be referenced, in which case the scaling of mu(t) will be done 
automatically. Otherwise, for example for simulation purposes, no scaling of mu(t) occurs, and it is assumed that the mu(t) corresponds to the
expected number of cases during the unit time interval containing t.
</p>


<h3>Value</h3>

<p>a function f(t) giving the temporal intensity at time t for integer t in the interval as.integer([tlim[1],tlim[2]]) of class temporalAtRisk
</p>

<ol>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+temporalAtRisk">temporalAtRisk</a>, <a href="#topic+spatialAtRisk">spatialAtRisk</a>,  <a href="#topic+temporalAtRisk.function">temporalAtRisk.function</a>, <a href="#topic+constantInTime">constantInTime</a>, <a href="#topic+constantInTime.numeric">constantInTime.numeric</a>, <a href="#topic+constantInTime.stppp">constantInTime.stppp</a>, <a href="#topic+print.temporalAtRisk">print.temporalAtRisk</a>, <a href="#topic+plot.temporalAtRisk">plot.temporalAtRisk</a>
</p>

<hr>
<h2 id='tempRaster'>tempRaster function</h2><span id='topic+tempRaster'></span>

<h3>Description</h3>

<p>A function to create a temporary raster object from an x-y regular grid of cell centroids. Useful for projection from one raster to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempRaster(mcens, ncens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tempRaster_+3A_mcens">mcens</code></td>
<td>
<p>vector of equally-spaced coordinates of cell centroids in x-direction</p>
</td></tr>
<tr><td><code id="tempRaster_+3A_ncens">ncens</code></td>
<td>
<p>vector of equally-spaced coordinates of cell centroids in y-direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an empty raster object
</p>

<hr>
<h2 id='textsummary'>textsummary function</h2><span id='topic+textsummary'></span>

<h3>Description</h3>

<p>A function to print a text description of the inferred paramerers beta and eta from a call to the function lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textsummary(obj, digits = 3, scientific = -3, inclIntercept = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="textsummary_+3A_obj">obj</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars orlgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
<tr><td><code id="textsummary_+3A_digits">digits</code></td>
<td>
<p>see the option &quot;digits&quot; in ?format</p>
</td></tr>
<tr><td><code id="textsummary_+3A_scientific">scientific</code></td>
<td>
<p>see the option &quot;scientific&quot; in ?format</p>
</td></tr>
<tr><td><code id="textsummary_+3A_inclintercept">inclIntercept</code></td>
<td>
<p>logical: whether to summarise the intercept term, default is FALSE.</p>
</td></tr>
<tr><td><code id="textsummary_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function &quot;format&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A text summary, that can be pasted into a LaTeX document and later edited.
</p>


<h3>See Also</h3>

<p><a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+traceplots">traceplots</a>, <a href="#topic+parsummary">parsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='thetaEst'>thetaEst function</h2><span id='topic+thetaEst'></span>

<h3>Description</h3>

<p>A tool to visually estimate the temporal correlation parameter theta; note that sigma and phi must have first been estiamted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thetaEst(
  xyt,
  spatial.intensity = NULL,
  temporal.intensity = NULL,
  sigma,
  phi,
  theta.range = c(0, 10),
  N = 100,
  spatial.covmodel = "exponential",
  covpars = c()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thetaEst_+3A_xyt">xyt</code></td>
<td>
<p>object of class stppp</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_spatial.intensity">spatial.intensity</code></td>
<td>
<p>A spatial at risk object OR a bivariate density estimate of lambda, an object of class im (produced from density.ppp for example),</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_temporal.intensity">temporal.intensity</code></td>
<td>
<p>either an object of class temporalAtRisk, or one that can be coerced into that form. If NULL (default), this is estimated from the data, seee ?muEst</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_sigma">sigma</code></td>
<td>
<p>estimate of parameter sigma</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_phi">phi</code></td>
<td>
<p>estimate of parameter phi</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_theta.range">theta.range</code></td>
<td>
<p>range of theta values to consider</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_n">N</code></td>
<td>
<p>number of integration points in computation of C(v,beta) (see Brix and Diggle 2003, corrigendum to Brix and Diggle 2001)</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_spatial.covmodel">spatial.covmodel</code></td>
<td>
<p>spatial covariance model</p>
</td></tr>
<tr><td><code id="thetaEst_+3A_covpars">covpars</code></td>
<td>
<p>additional covariance parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An r panel tool for visual estimation of temporal parameter theta
NOTE if lambdaEst has been invoked to estimate lambda, then the returned density should be passed to thetaEst as the argument spatial.intensity
</p>


<h3>References</h3>


<ol>
<li><p> Benjamin M. Taylor, Tilman M. Davies, Barry S. Rowlingson, Peter J. Diggle (2013). Journal of Statistical Software, 52(4), 1-40. URL http://www.jstatsoft.org/v52/i04/
</p>
</li>
<li><p> Brix A, Diggle PJ (2001). Spatiotemporal Prediction for log-Gaussian Cox processes. Journal of the Royal Statistical Society, Series B, 63(4), 823-841.
</p>
</li>
<li><p> Diggle P, Rowlingson B, Su T (2005). Point Process Methodology for On-line Spatio-temporal Disease Surveillance. Environmetrics, 16(5), 423-434.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+ginhomAverage">ginhomAverage</a>, <a href="#topic+KinhomAverage">KinhomAverage</a>, <a href="#topic+spatialparsEst">spatialparsEst</a>, <a href="#topic+lambdaEst">lambdaEst</a>, <a href="#topic+muEst">muEst</a>
</p>

<hr>
<h2 id='toral.cov.mat'>toral.cov.mat function</h2><span id='topic+toral.cov.mat'></span>

<h3>Description</h3>

<p>A function to compute the covariance matrix of a stationary process on a torus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toral.cov.mat(xg, yg, sigma, phi, model, additionalparameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toral.cov.mat_+3A_xg">xg</code></td>
<td>
<p>x grid</p>
</td></tr>
<tr><td><code id="toral.cov.mat_+3A_yg">yg</code></td>
<td>
<p>y grid</p>
</td></tr>
<tr><td><code id="toral.cov.mat_+3A_sigma">sigma</code></td>
<td>
<p>spatial variability parameter</p>
</td></tr>
<tr><td><code id="toral.cov.mat_+3A_phi">phi</code></td>
<td>
<p>spatial decay parameter</p>
</td></tr>
<tr><td><code id="toral.cov.mat_+3A_model">model</code></td>
<td>
<p>model for covariance, see ?CovarianceFct</p>
</td></tr>
<tr><td><code id="toral.cov.mat_+3A_additionalparameters">additionalparameters</code></td>
<td>
<p>additional parameters for covariance structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>circulant covariacne matrix
</p>

<hr>
<h2 id='touchingowin'>touchingowin function</h2><span id='topic+touchingowin'></span>

<h3>Description</h3>

<p>A function to compute which cells are touching an owin or spatial polygons object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>touchingowin(x, y, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="touchingowin_+3A_x">x</code></td>
<td>
<p>grid centroids in x-direction note this will be expanded into a GRID of (x,y) values in the function</p>
</td></tr>
<tr><td><code id="touchingowin_+3A_y">y</code></td>
<td>
<p>grid centroids in y-direction note this will be expanded into a GRID of (x,y) values in the function</p>
</td></tr>
<tr><td><code id="touchingowin_+3A_w">w</code></td>
<td>
<p>an owin or SpatialPolygons object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of TRUE or FALSE according to whether the cell
</p>

<hr>
<h2 id='traceplots'>traceplots function</h2><span id='topic+traceplots'></span>

<h3>Description</h3>

<p>A function to produce trace plots for the paramerers beta and eta from a call to the function lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars or lgcpPredictMultitypeSpatialPlusPars
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplots(obj, xlab = "Sample No.", ylab = NULL, main = "", ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplots_+3A_obj">obj</code></td>
<td>
<p>an object produced by a call to lgcpPredictSpatialPlusPars, lgcpPredictAggregateSpatialPlusPars, lgcpPredictSpatioTemporalPlusPars orlgcpPredictMultitypeSpatialPlusPars</p>
</td></tr>
<tr><td><code id="traceplots_+3A_xlab">xlab</code></td>
<td>
<p>optional label for x-axis, there is a sensible default.</p>
</td></tr>
<tr><td><code id="traceplots_+3A_ylab">ylab</code></td>
<td>
<p>optional label for y-axis, there is a sensible default.</p>
</td></tr>
<tr><td><code id="traceplots_+3A_main">main</code></td>
<td>
<p>optional title of the plot, there is a sensible default.</p>
</td></tr>
<tr><td><code id="traceplots_+3A_ask">ask</code></td>
<td>
<p>the paramter &quot;ask&quot;, see ?par</p>
</td></tr>
<tr><td><code id="traceplots_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function &quot;hist&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>produces MCMC trace plots of the parameters beta and eta
</p>


<h3>See Also</h3>

<p><a href="#topic+ltar">ltar</a>, <a href="#topic+autocorr">autocorr</a>, <a href="#topic+parautocorr">parautocorr</a>, <a href="#topic+parsummary">parsummary</a>, <a href="#topic+textsummary">textsummary</a>,
<a href="#topic+priorpost">priorpost</a>, <a href="#topic+postcov">postcov</a>, <a href="#topic+exceedProbs">exceedProbs</a>, <a href="#topic+betavals">betavals</a>, <a href="#topic+etavals">etavals</a>
</p>

<hr>
<h2 id='transblack'>transblack function</h2><span id='topic+transblack'></span>

<h3>Description</h3>

<p>A function to return a transparent black colour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transblack(alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transblack_+3A_alpha">alpha</code></td>
<td>
<p>transparency parameter, see ?rgb</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string of colour
</p>

<hr>
<h2 id='transblue'>transblue function</h2><span id='topic+transblue'></span>

<h3>Description</h3>

<p>A function to return a transparent blue colour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transblue(alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transblue_+3A_alpha">alpha</code></td>
<td>
<p>transparency parameter, see ?rgb</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string of colour
</p>

<hr>
<h2 id='transgreen'>transgreen function</h2><span id='topic+transgreen'></span>

<h3>Description</h3>

<p>A function to return a transparent green colour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transgreen(alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transgreen_+3A_alpha">alpha</code></td>
<td>
<p>transparency parameter, see ?rgb</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string of colour
</p>

<hr>
<h2 id='transred'>transred function</h2><span id='topic+transred'></span>

<h3>Description</h3>

<p>A function to return a transparent red colour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transred(alpha = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transred_+3A_alpha">alpha</code></td>
<td>
<p>transparency parameter, see ?rgb</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string of colour
</p>

<hr>
<h2 id='txtProgressBar2'>A text progress bar with label</h2><span id='topic+txtProgressBar2'></span>

<h3>Description</h3>

<p>This is the base txtProgressBar but with a little modification to
implement the label parameter for style=3. For full info see txtProgressBar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>txtProgressBar2(
  min = 0,
  max = 1,
  initial = 0,
  char = "=",
  width = NA,
  title = "",
  label = "",
  style = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="txtProgressBar2_+3A_min">min</code></td>
<td>
<p>min value for bar</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_max">max</code></td>
<td>
<p>max value for bar</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_initial">initial</code></td>
<td>
<p>initial value for bar</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_char">char</code></td>
<td>
<p>the character (or character string) to form the progress bar.</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_width">width</code></td>
<td>
<p>progress bar width</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_title">title</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_label">label</code></td>
<td>
<p>text to put at the end of the bar</p>
</td></tr>
<tr><td><code id="txtProgressBar2_+3A_style">style</code></td>
<td>
<p>bar style</p>
</td></tr>
</table>

<hr>
<h2 id='updateAMCMC'>updateAMCMC function</h2><span id='topic+updateAMCMC'></span>

<h3>Description</h3>

<p>A generic to be used for the purpose of user-defined adaptive MCMC schemes,
updateAMCMC tells the MALA algorithm how to update the value of h. See
lgcp vignette, codevignette(&quot;lgcp&quot;), for further details on writing adaptive MCMC schemes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateAMCMC(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateAMCMC_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="updateAMCMC_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method updateAMCMC
</p>


<h3>See Also</h3>

<p><a href="#topic+updateAMCMC.constanth">updateAMCMC.constanth</a>, <a href="#topic+updateAMCMC.andrieuthomsh">updateAMCMC.andrieuthomsh</a>
</p>

<hr>
<h2 id='updateAMCMC.andrieuthomsh'>updateAMCMC.andrieuthomsh function</h2><span id='topic+updateAMCMC.andrieuthomsh'></span>

<h3>Description</h3>

<p>Updates the <a href="#topic+andrieuthomsh">andrieuthomsh</a> adaptive scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'andrieuthomsh'
updateAMCMC(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateAMCMC.andrieuthomsh_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="updateAMCMC.andrieuthomsh_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>update and return current h for scheme
</p>


<h3>References</h3>


<ol>
<li><p> Andrieu C, Thoms J (2008). A tutorial on adaptive MCMC. Statistics and Computing, 18(4), 343-373.
</p>
</li>
<li><p> Robbins H, Munro S (1951). A Stochastic Approximation Methods. The Annals of Mathematical Statistics, 22(3), 400-407.
</p>
</li>
<li><p> Roberts G, Rosenthal J (2001). Optimal Scaling for Various Metropolis-Hastings Algorithms. Statistical Science, 16(4), 351-367.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+andrieuthomsh">andrieuthomsh</a>
</p>

<hr>
<h2 id='updateAMCMC.constanth'>updateAMCMC.constanth function</h2><span id='topic+updateAMCMC.constanth'></span>

<h3>Description</h3>

<p>Updates the <a href="#topic+constanth">constanth</a> adaptive scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'constanth'
updateAMCMC(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateAMCMC.constanth_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="updateAMCMC.constanth_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>update and return current h for scheme
</p>


<h3>See Also</h3>

<p><a href="#topic+constanth">constanth</a>
</p>

<hr>
<h2 id='varfield'>varfield function</h2><span id='topic+varfield'></span>

<h3>Description</h3>

<p>Generic function to extract the variance of the latent field Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varfield(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varfield_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="varfield_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>method meanfield
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='varfield.lgcpPredict'>varfield.lgcpPredict function</h2><span id='topic+varfield.lgcpPredict'></span>

<h3>Description</h3>

<p>This is an accessor function for objects of class <code>lgcpPredict</code> and returns the variance of the
field Y as an lgcpgrid object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
varfield(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varfield.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="varfield.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the cell-wise variance of Y computed via Monte Carlo.
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='varfield.lgcpPredictINLA'>varfield.lgcpPredictINLA function</h2><span id='topic+varfield.lgcpPredictINLA'></span>

<h3>Description</h3>

<p>A function to return the variance of the latent field from a call to lgcpPredictINLA output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredictINLA'
varfield(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varfield.lgcpPredictINLA_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredictINLA</p>
</td></tr>
<tr><td><code id="varfield.lgcpPredictINLA_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the variance of the latent field
</p>

<hr>
<h2 id='window.lgcpPredict'>window.lgcpPredict function</h2><span id='topic+window.lgcpPredict'></span>

<h3>Description</h3>

<p>Accessor function returning the observation window from objects of class <code>lgcpPredict</code>. Note that for
computational purposes, the window of an <code>stppp</code> object will be extended to accommodate the requirement that
the dimensions must be powers of 2. The function <code>window.lgcpPredict</code> returns the extended window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
window(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window.lgcpPredict_+3A_x">x</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="window.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the observation window used durign computation
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='wpopdata'>Population of Welsh counties</h2><span id='topic+wpopdata'></span>

<h3>Description</h3>

<p>Population of Welsh counties</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wpopdata)</code></pre>


<h3>Format</h3>

<p>matrix</p>


<h3>Source</h3>

<p>ONS</p>


<h3>References</h3>

<p>http://www.statistics.gov.uk/default.asp</p>

<hr>
<h2 id='wtowncoords'>Welsh town details: location</h2><span id='topic+wtowncoords'></span>

<h3>Description</h3>

<p>Welsh town details: location</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wtowncoords)</code></pre>


<h3>Format</h3>

<p>matrix</p>


<h3>Source</h3>

<p>Wikipedia</p>


<h3>References</h3>

<p><a href="https://www.wikipedia.org/">https://www.wikipedia.org/</a></p>

<hr>
<h2 id='wtowns'>Welsh town details: population</h2><span id='topic+wtowns'></span>

<h3>Description</h3>

<p>Welsh town details: population</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wtowns)</code></pre>


<h3>Format</h3>

<p>matrix</p>


<h3>Source</h3>

<p>ONS</p>


<h3>References</h3>

<p>http://www.statistics.gov.uk/default.asp</p>

<hr>
<h2 id='xvals'>xvals function</h2><span id='topic+xvals'></span>

<h3>Description</h3>

<p>Generic for extractign the 'x values' from an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvals_+3A_obj">obj</code></td>
<td>
<p>an object of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="xvals_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the xvals method
</p>


<h3>See Also</h3>

<p><a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='xvals.default'>xvals.default function</h2><span id='topic+xvals.default'></span>

<h3>Description</h3>

<p>Default method for extracting 'x values' looks for $X, $x in that order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
xvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvals.default_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="xvals.default_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x values
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='xvals.fromXYZ'>xvals.fromXYZ function</h2><span id='topic+xvals.fromXYZ'></span>

<h3>Description</h3>

<p>Method for extracting 'x values' from an object of class fromXYZ
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
xvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvals.fromXYZ_+3A_obj">obj</code></td>
<td>
<p>a spatialAtRisk object</p>
</td></tr>
<tr><td><code id="xvals.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x values
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='xvals.lgcpPredict'>xvals.lgcpPredict function</h2><span id='topic+xvals.lgcpPredict'></span>

<h3>Description</h3>

<p>Gets the x-coordinates of the centroids of the prediction grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
xvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvals.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="xvals.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x coordinates of the centroids of the grid
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='xvals.SpatialGridDataFrame'>xvals.SpatialGridDataFrame function</h2><span id='topic+xvals.SpatialGridDataFrame'></span>

<h3>Description</h3>

<p>Method for extracting 'x values' from an object of class spatialGridDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialGridDataFrame'
xvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xvals.SpatialGridDataFrame_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="xvals.SpatialGridDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x values
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='YfromGamma'>YfromGamma function</h2><span id='topic+YfromGamma'></span>

<h3>Description</h3>

<p>A function to change Gammas (white noise) into Ys (spatially correlated noise). Used in the MALA algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>YfromGamma(Gamma, invrootQeigs, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="YfromGamma_+3A_gamma">Gamma</code></td>
<td>
<p>Gamma matrix</p>
</td></tr>
<tr><td><code id="YfromGamma_+3A_invrootqeigs">invrootQeigs</code></td>
<td>
<p>inverse square root of the eigenvectors of the precision matrix</p>
</td></tr>
<tr><td><code id="YfromGamma_+3A_mu">mu</code></td>
<td>
<p>parameter of the latent Gaussian field</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Y
</p>

<hr>
<h2 id='yvals'>yvals function</h2><span id='topic+yvals'></span>

<h3>Description</h3>

<p>Generic for extractign the 'y values' from an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yvals_+3A_obj">obj</code></td>
<td>
<p>an object of class spatialAtRisk</p>
</td></tr>
<tr><td><code id="yvals_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the yvals method
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='yvals.default'>yvals.default function</h2><span id='topic+yvals.default'></span>

<h3>Description</h3>

<p>Default method for extracting 'y values' looks for $Y, $y in that order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
yvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yvals.default_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="yvals.default_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the y values
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='yvals.fromXYZ'>yvals.fromXYZ function</h2><span id='topic+yvals.fromXYZ'></span>

<h3>Description</h3>

<p>Method for extracting 'y values' from an object of class fromXYZ
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
yvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yvals.fromXYZ_+3A_obj">obj</code></td>
<td>
<p>a spatialAtRisk object</p>
</td></tr>
<tr><td><code id="yvals.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the y values
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='yvals.lgcpPredict'>yvals.lgcpPredict function</h2><span id='topic+yvals.lgcpPredict'></span>

<h3>Description</h3>

<p>Gets the y-coordinates of the centroids of the prediction grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lgcpPredict'
yvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yvals.lgcpPredict_+3A_obj">obj</code></td>
<td>
<p>an object of class lgcpPredict</p>
</td></tr>
<tr><td><code id="yvals.lgcpPredict_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the y coordinates of the centroids of the grid
</p>


<h3>See Also</h3>

<p><a href="#topic+lgcpPredict">lgcpPredict</a>
</p>

<hr>
<h2 id='yvals.SpatialGridDataFrame'>yvals.SpatialGridDataFrame function</h2><span id='topic+yvals.SpatialGridDataFrame'></span>

<h3>Description</h3>

<p>Method for extracting 'y values' from an object of class SpatialGridDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialGridDataFrame'
yvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yvals.SpatialGridDataFrame_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="yvals.SpatialGridDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the y values
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='zvals'>zvals function</h2><span id='topic+zvals'></span>

<h3>Description</h3>

<p>Generic for extractign the 'z values' from an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zvals_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="zvals_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the zvals method
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='zvals.default'>zvals.default function</h2><span id='topic+zvals.default'></span>

<h3>Description</h3>

<p>Default method for extracting 'z values' looks for $Zm, $Z, $z in that order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
zvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zvals.default_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="zvals.default_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x values
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='zvals.fromXYZ'>zvals.fromXYZ function</h2><span id='topic+zvals.fromXYZ'></span>

<h3>Description</h3>

<p>Method for extracting 'z values' from an object of class fromXYZ
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fromXYZ'
zvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zvals.fromXYZ_+3A_obj">obj</code></td>
<td>
<p>a spatialAtRisk object</p>
</td></tr>
<tr><td><code id="zvals.fromXYZ_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the z values
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>, <a href="#topic+zvals.SpatialGridDataFrame">zvals.SpatialGridDataFrame</a>
</p>

<hr>
<h2 id='zvals.SpatialGridDataFrame'>zvals.SpatialGridDataFrame function</h2><span id='topic+zvals.SpatialGridDataFrame'></span>

<h3>Description</h3>

<p>Method for extracting 'z values' from an object of class SpatialGridDataFrame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialGridDataFrame'
zvals(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zvals.SpatialGridDataFrame_+3A_obj">obj</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="zvals.SpatialGridDataFrame_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the z values
</p>


<h3>See Also</h3>

<p><a href="#topic+xvals">xvals</a>,  <a href="#topic+yvals">yvals</a>, <a href="#topic+zvals">zvals</a>, <a href="#topic+xvals.default">xvals.default</a>, <a href="#topic+yvals.default">yvals.default</a>, <a href="#topic+zvals.default">zvals.default</a>, <a href="#topic+xvals.fromXYZ">xvals.fromXYZ</a>, <a href="#topic+yvals.fromXYZ">yvals.fromXYZ</a>, <a href="#topic+zvals.fromXYZ">zvals.fromXYZ</a>, <a href="#topic+xvals.SpatialGridDataFrame">xvals.SpatialGridDataFrame</a>, <a href="#topic+yvals.SpatialGridDataFrame">yvals.SpatialGridDataFrame</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
