<!DOCTYPE html><html lang="en"><head><title>Help for package jrSiCKLSNMF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jrSiCKLSNMF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddSickleJrMetadata'><p>Add metadata to an object of class SickleJr</p></a></li>
<li><a href='#BuildKNNGraphLaplacians'><p>Build KNN graphs and generate their graph Laplacians</p></a></li>
<li><a href='#BuildSNNGraphLaplacians'><p>Build SNN graphs and generate their graph Laplacians</p></a></li>
<li><a href='#CalculateUMAPSickleJr'><p>Calculate the UMAP for an object of class SickleJr</p></a></li>
<li><a href='#ClusterSickleJr'><p>Cluster the <code class="reqn">\mathbf{H}</code> matrix</p></a></li>
<li><a href='#CreateSickleJr'><p>Create an object of class SickleJr</p></a></li>
<li><a href='#DetermineClusters'><p>Perform clustering diagnostics</p></a></li>
<li><a href='#DetermineDFromIRLBA'><p>Create elbow plots of the singular values derived from IRLBA</p>
to determine D for large datasets</a></li>
<li><a href='#GenerateWmatricesandHmatrix'><p>Initialize the <code class="reqn">\mathbf{W}</code> matrices in each modality and the shared <code class="reqn">\mathbf{H}</code> matrix</p></a></li>
<li><a href='#jrSiCKLSNMF'><p>Run jrSiCKLSNMF outside of a SickleJr object</p></a></li>
<li><a href='#MinibatchDiagnosticPlot'><p>Plot a diagnostic plot for the mini-batch algorithm</p></a></li>
<li><a href='#NormalizeCountMatrices'><p>Normalize the count matrices and set whether to use the Poisson KL divergence</p>
or the Frobenius norm</a></li>
<li><a href='#PlotLossvsLatentFactors'><p>Create plots to help determine the number of latent factors</p></a></li>
<li><a href='#PlotSickleJrUMAP'><p>Generate UMAP plots for an object of class SickleJr</p></a></li>
<li><a href='#RunjrSiCKLSNMF'><p>Run jrSiCKLSNMF on an object of class SickleJr</p></a></li>
<li><a href='#SetLambdasandRowReg'><p>Set lambda values and type of row regularization for an object of class SickleJr</p></a></li>
<li><a href='#SetWandHfromWHinitials'><p>Set <code class="reqn">\mathbf{W}</code> matrices and <code class="reqn">\mathbf{H}</code> matrix from pre-calculated values</p></a></li>
<li><a href='#SickleJr-class'><p>The SickleJr class</p></a></li>
<li><a href='#SimData'><p>A simulated dataset for use with jrSiCKLSNMF</p></a></li>
<li><a href='#SimSickleJrSmall'><p>A small SickleJr object containing a subset of data from the</p>
<code style="white-space: pre;">&#8288;SimData&#8288;</code> data object. Contains the completed analysis from the
'Getting Started' vignette for a small subset of 10 cells with 150 genes and
700 peaks. The clusters derived from this dataset are not accurate; this dataset
is intended for use with code examples.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multimodal Single-Cell Omics Dimensionality Reduction</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to perform Joint graph Regularized Single-Cell Kullback-Leibler Sparse Non-negative Matrix Factorization ('jrSiCKLSNMF', pronounced "junior sickles NMF") on quality controlled single-cell multimodal omics count data. 'jrSiCKLSNMF' specifically deals with dual-assay scRNA-seq and scATAC-seq data. This package contains functions to extract meaningful latent factors that are shared across omics modalities. These factors enable accurate cell-type clustering and facilitate visualizations. Methods for pre-processing, clustering, and mini-batch updates and other adaptations for larger datasets are also included. For further details on the methods used in this package please see Ellis, Roy, and Datta (2023) &lt;<a href="https://doi.org/10.3389%2Ffgene.2023.1179439">doi:10.3389/fgene.2023.1179439</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), igraph, umap, kknn, ggplot2, methods, stats,
rlang, Matrix,
data.table,parallel,pbapply,cluster,MASS,clValid,factoextra,
foreach,irlba,scran,Rdpack,ggrepel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-12 04:48:21 UTC; dorothyellis</td>
</tr>
<tr>
<td>Author:</td>
<td>Dorothy Ellis <a href="https://orcid.org/0000-0002-8624-0042"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Susmita Datta [ths],
  Kenneth Perkins [ctb] (Util.h function author,
    http://programmingnotes.org/),
  Renaud Gaujoux [ctb] (Author of .nndsvd R adaptation)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dorothy Ellis &lt;ddemoreellis@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-12 11:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddSickleJrMetadata'>Add metadata to an object of class SickleJr</h2><span id='topic+AddSickleJrMetadata'></span>

<h3>Description</h3>

<p>Add any type of metadata to an object of class SickleJr. Metadata
are stored in list format under the name specified in <code>metadataname</code> of each node in slot <code>metadata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddSickleJrMetadata(SickleJr, metadata, metadataname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddSickleJrMetadata_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr holding at least one count matrix of omics data</p>
</td></tr>
<tr><td><code id="AddSickleJrMetadata_+3A_metadata">metadata</code></td>
<td>
<p>Metadata to add to the SickleJr object; there are no restrictions on type</p>
</td></tr>
<tr><td><code id="AddSickleJrMetadata_+3A_metadataname">metadataname</code></td>
<td>
<p>A string input that indicates the desired name for the added
metadata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with added metadata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-AddSickleJrMetadata(SimSickleJrSmall,
SimData$cell_type,"cell_types_full_data")
</code></pre>

<hr>
<h2 id='BuildKNNGraphLaplacians'>Build KNN graphs and generate their graph Laplacians</h2><span id='topic+BuildKNNGraphLaplacians'></span>

<h3>Description</h3>

<p>Generate graph Laplacians for graph regularization of
jrSiCKLSNMF from the list of raw count matrices using a KNN graph. Note that this
is only appropriate when the number of features is considerably greater
than the number of cells in all modalities. If this is not the case, please use
<code><a href="#topic+BuildSNNGraphLaplacians">BuildSNNGraphLaplacians</a></code> or any other method of graph
construction that does not rely on the Euclidean distance and store the graph Laplacians for
each modality as a list in the <code>graph.laplacian.list</code> slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildKNNGraphLaplacians(SickleJr, k = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BuildKNNGraphLaplacians_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="BuildKNNGraphLaplacians_+3A_k">k</code></td>
<td>
<p>Number of KNN neighbors to calculate; by default, is set to 20</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with a list of graph Laplacians in sparse matrix format
added to the <code>graph.laplacian.list</code> slot
</p>


<h3>References</h3>

<p>Lun AT, McCarthy DJ, Marioni JC (2016).
&ldquo;A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor.&rdquo;
<em>F1000Research</em>, <b>5</b>.
ISSN 1759796X, <a href="https://doi.org/10.12688/F1000RESEARCH.9501.2">doi:10.12688/F1000RESEARCH.9501.2</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/27909575/">https://pubmed.ncbi.nlm.nih.gov/27909575/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-BuildKNNGraphLaplacians(SimSickleJrSmall)
</code></pre>

<hr>
<h2 id='BuildSNNGraphLaplacians'>Build SNN graphs and generate their graph Laplacians</h2><span id='topic+BuildSNNGraphLaplacians'></span>

<h3>Description</h3>

<p>Generate graph Laplacians for graph regularization of
jrSiCKLSNMF from the list of raw count matrices using an SNN graph. SNN is more robust to
situations where the number of cells outnumbers the number of features. Uses
the <code>scran</code> package's <code>BuildSNNGraph</code> function (Lun et al. 2016)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildSNNGraphLaplacians(SickleJr, k = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BuildSNNGraphLaplacians_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="BuildSNNGraphLaplacians_+3A_k">k</code></td>
<td>
<p>Number of KNN neighbors to calculate SNN graph; defaults to 20</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with list of graph Laplacians in sparse
matrix format added to its <code>graph.laplacian.list</code> slot
</p>


<h3>References</h3>

<p>Lun AT, McCarthy DJ, Marioni JC (2016).
&ldquo;A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor.&rdquo;
<em>F1000Research</em>, <b>5</b>.
ISSN 1759796X, <a href="https://doi.org/10.12688/F1000RESEARCH.9501.2">doi:10.12688/F1000RESEARCH.9501.2</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/27909575/">https://pubmed.ncbi.nlm.nih.gov/27909575/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-BuildSNNGraphLaplacians(SimSickleJrSmall)
</code></pre>

<hr>
<h2 id='CalculateUMAPSickleJr'>Calculate the UMAP for an object of class SickleJr</h2><span id='topic+CalculateUMAPSickleJr'></span>

<h3>Description</h3>

<p>Perform UMAP on the <code class="reqn">\mathbf{H}</code> matrix alone (default) or within a modality by
using UMAP on the <code class="reqn">W^vH</code> corresponding to modality <code class="reqn">v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalculateUMAPSickleJr(
  SickleJr,
  umap.settings = umap::umap.defaults,
  modality = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CalculateUMAPSickleJr_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="CalculateUMAPSickleJr_+3A_umap.settings">umap.settings</code></td>
<td>
<p>Optional settings for the <code><a href="umap.html#topic+umap">umap</a></code>; defaults to <code><a href="umap.html#topic+umap.defaults">umap.defaults</a></code></p>
</td></tr>
<tr><td><code id="CalculateUMAPSickleJr_+3A_modality">modality</code></td>
<td>
<p>A number corresponding to the desired modality; if set, will perform UMAP on
<code class="reqn">\mathbf{W}^{\mathtt{modality}}</code>
on <code class="reqn">\mathbf{H}</code> alone; not recommended for datasets of more than 1000 cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with UMAP output based on the <code class="reqn">\mathbf{H}</code> matrix alone or within a modality added to its <code>umap</code> slot
</p>


<h3>References</h3>

<p>McInnes L, Healy J, Saul N, Großberger L (2018).
&ldquo;UMAP: Uniform Manifold Approximation and Projection.&rdquo;
<em>Journal of Open Source Software</em>, <b>3</b>(29), 861.
ISSN 2475-9066, <a href="https://doi.org/10.21105/JOSS.00861">doi:10.21105/JOSS.00861</a>, <a href="https://joss.theoj.org/papers/10.21105/joss.00861">https://joss.theoj.org/papers/10.21105/joss.00861</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Since this example has only 10 observations,
#we need to modify the number of neighbors from the default of 15
umap.settings=umap::umap.defaults
umap.settings$n_neighbors=2
SimSickleJrSmall&lt;-CalculateUMAPSickleJr(SimSickleJrSmall,
umap.settings=umap.settings)
SimSickleJrSmall&lt;-CalculateUMAPSickleJr(SimSickleJrSmall,
umap.settings=umap.settings,modality=1)
SimSickleJrSmall&lt;-CalculateUMAPSickleJr(SimSickleJrSmall,
umap.settings=umap.settings,modality=2)
</code></pre>

<hr>
<h2 id='ClusterSickleJr'>Cluster the <code class="reqn">\mathbf{H}</code> matrix</h2><span id='topic+ClusterSickleJr'></span>

<h3>Description</h3>

<p>Perform k-means, spectral clustering, clustering based off of the
index of the maximum latent factor, or Louvain community detection on the <code class="reqn">\mathbf{H}</code> matrix.
Defaults to k-means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusterSickleJr(
  SickleJr,
  numclusts,
  method = "kmeans",
  neighbors = 20,
  louvainres = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ClusterSickleJr_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="ClusterSickleJr_+3A_numclusts">numclusts</code></td>
<td>
<p>Number of clusters; can be NULL when method is &quot;max&quot; or &quot;louvain&quot;</p>
</td></tr>
<tr><td><code id="ClusterSickleJr_+3A_method">method</code></td>
<td>
<p>String holding the clustering method: can choose &quot;kmeans&quot; for
k-means clustering, &quot;spectral&quot; for spectral clustering, &quot;louvain&quot; for Louvain
community detection or &quot;max&quot; for clustering based on the maximum row value; note that
&quot;max&quot; is only appropriate for jrSiCKLSNMF with L2 norm row regularization</p>
</td></tr>
<tr><td><code id="ClusterSickleJr_+3A_neighbors">neighbors</code></td>
<td>
<p>Number indicating the number of neighbors to use to generate the
graphs for spectral clustering and Louvain community detection: both of these
methods require the construction of a graph first (here we use KNN);
defaults to 20 and unused when the clustering method equal to &quot;kmeans&quot; or &quot;max&quot;</p>
</td></tr>
<tr><td><code id="ClusterSickleJr_+3A_louvainres">louvainres</code></td>
<td>
<p>Numeric containing the resolution parameter for Louvain
community detection; unused for all other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SickleJr- an object of class SickleJr with added clustering information
</p>


<h3>References</h3>

<p>Blondel VD, Guillaume JL, Lambiotte R, Lefebvre E (2008).
&ldquo;Fast unfolding of communities in large networks.&rdquo;
<em>Journal of Statistical Mechanics: Theory and Experiment</em>, <b>2008</b>(10), P10008.
ISSN 1742-5468, <a href="https://doi.org/10.1088/1742-5468/2008/10/P10008">doi:10.1088/1742-5468/2008/10/P10008</a>, 0803.0476, <a href="https://iopscience.iop.org/article/10.1088/1742-5468/2008/10/P10008">https://iopscience.iop.org/article/10.1088/1742-5468/2008/10/P10008</a>.
</p>
<p>Lun AT, McCarthy DJ, Marioni JC (2016).
&ldquo;A step-by-step workflow for low-level analysis of single-cell RNA-seq data with Bioconductor.&rdquo;
<em>F1000Research</em>, <b>5</b>.
ISSN 1759796X, <a href="https://doi.org/10.12688/F1000RESEARCH.9501.2">doi:10.12688/F1000RESEARCH.9501.2</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/27909575/">https://pubmed.ncbi.nlm.nih.gov/27909575/</a>.
</p>
<p>Ng AY, Jordan MI, Weiss Y (2001).
&ldquo;On spectral clustering: analysis and an algorithm.&rdquo;
In <em>Proceedings of the 14th International Conference on Neural Information Processing Systems: Natural and Synthetic</em>,  NIPS'01, 849&ndash;856.
</p>
<p>Schliep K, Hechenbichler K (2016).
&ldquo;kknn: Weighted k-Nearest Neighbors.&rdquo;
<a href="https://cran.r-project.org/package=kknn">https://cran.r-project.org/package=kknn</a>.
</p>
<p>Xu W, Liu X, Gong Y (2003).
&ldquo;Document clustering based on non-negative matrix factorization.&rdquo;
<em>SIGIR '03: Proceedings of the 26th annual international ACM SIGIR conference on research and development in information retrieval</em>, 267&ndash;273.
<a href="https://doi.org/10.1145/860435.860485">doi:10.1145/860435.860485</a>, <a href="https://dl.acm.org/doi/10.1145/860435.860485">https://dl.acm.org/doi/10.1145/860435.860485</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-ClusterSickleJr(SimSickleJrSmall,3)
SimSickleJrSmall&lt;-ClusterSickleJr(SimSickleJrSmall,method="louvain",neighbors=5)
SimSickleJrSmall&lt;-ClusterSickleJr(SimSickleJrSmall,method="spectral",neighbors=5,numclusts=3)
#DO NOT DO THIS FOR REAL DATA; this is just to illustrate max clustering
SimSickleJrSmall&lt;-SetLambdasandRowReg(SimSickleJrSmall,rowReg="L2Norm")
SimSickleJrSmall&lt;-ClusterSickleJr(SimSickleJrSmall,method="max")
</code></pre>

<hr>
<h2 id='CreateSickleJr'>Create an object of class SickleJr</h2><span id='topic+CreateSickleJr'></span>

<h3>Description</h3>

<p>Using a list of sparse count matrices, create an object of class SickleJr
and specify the names of these count matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateSickleJr(count.matrices, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateSickleJr_+3A_count.matrices">count.matrices</code></td>
<td>
<p>A list of quality-controlled count matrices with pre-filtered features where each modality corresponds to each matrix in the
list</p>
</td></tr>
<tr><td><code id="CreateSickleJr_+3A_names">names</code></td>
<td>
<p>Optional parameter with names for the count matrices in vector format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with sparse count matrices added to the <code>count.matrices</code> slot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ExampleSickleJr&lt;-CreateSickleJr(SimData$Xmatrices)
</code></pre>

<hr>
<h2 id='DetermineClusters'>Perform clustering diagnostics</h2><span id='topic+DetermineClusters'></span>

<h3>Description</h3>

<p>A wrapper for the <code><a href="clValid.html#topic+clValid">clValid</a></code> and <code><a href="factoextra.html#topic+fviz_nbclust">fviz_nbclust</a></code> functions to perform clustering diagnostics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DetermineClusters(
  SickleJr,
  numclusts = 2:20,
  clusteringmethod = "kmeans",
  diagnosticmethods = c("wss", "silhouette", "gap_stat"),
  clValidvalidation = "internal",
  createDiagnosticplots = TRUE,
  runclValidDiagnostics = TRUE,
  printPlots = TRUE,
  printclValid = TRUE,
  subset = FALSE,
  subsetsize = 1000,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DetermineClusters_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_numclusts">numclusts</code></td>
<td>
<p>A vector of integers indicating the number of clusters to test</p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_clusteringmethod">clusteringmethod</code></td>
<td>
<p>String holding the clustering method: defaults to k-means; since the other methods
are not implemented in jrSiCKLSNMF, it is recommended to use k-means.</p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_diagnosticmethods">diagnosticmethods</code></td>
<td>
<p>Vector of strings indicating which methods to plot. Defaults to all three of the available: wss, silhouette, and gap_stat</p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_clvalidvalidation">clValidvalidation</code></td>
<td>
<p>String containing validation method to use for <code>clValid</code>. Defaults to internal.</p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_creatediagnosticplots">createDiagnosticplots</code></td>
<td>
<p>Boolean indicating whether to create diagnostic plots for cluster size</p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_runclvaliddiagnostics">runclValidDiagnostics</code></td>
<td>
<p>Boolean indicating whether to calculate the diagnostics from <code>clValid</code></p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_printplots">printPlots</code></td>
<td>
<p>Boolean indicating whether to print the diagnostic plots</p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_printclvalid">printclValid</code></td>
<td>
<p>Boolean indicating whether to print the diagnostic results from <code>clValid</code></p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_subset">subset</code></td>
<td>
<p>Boolean indicating whether to calculate the diagnostics on a subset of the data rather
than on the whole dataset.</p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_subsetsize">subsetsize</code></td>
<td>
<p>Numeric value indicating size of the subset</p>
</td></tr>
<tr><td><code id="DetermineClusters_+3A_seed">seed</code></td>
<td>
<p>Numeric value holding the random seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with cluster diagnostics added to its <code>clusterdiagnostics</code> slot
</p>


<h3>References</h3>

<p>Brock G, Pihur V, Datta S, Datta S (2008).
&ldquo;clValid: An R Package for Cluster Validation.&rdquo;
<em>Journal of Statistical Software</em>, <b>25</b>(4), 1&ndash;22.
<a href="https://www.jstatsoft.org/v25/i04/">https://www.jstatsoft.org/v25/i04/</a>.
</p>
<p>Kassambara A, Mundt F (2020).
<em>factoextra: Extract and Visualize the Results of Multivariate Data Analyses</em>.
R package version 1.0.7, <a href="https://CRAN.R-project.org/package=factoextra">https://CRAN.R-project.org/package=factoextra</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Since these data are too small, the clValid diagnostics do not run
#properly. See the vignette for an example with the clValid diagnostics
SimSickleJrSmall&lt;-DetermineClusters(SimSickleJrSmall,numclusts=2:5,runclValidDiagnostics=FALSE)
</code></pre>

<hr>
<h2 id='DetermineDFromIRLBA'>Create elbow plots of the singular values derived from IRLBA
to determine D for large datasets</h2><span id='topic+DetermineDFromIRLBA'></span>

<h3>Description</h3>

<p>This generates v+1 plots, where v is the number of data modalities, of the approximate
singular values generated by IRLBA.There is one plot for each modality and then a
final plot that concatenates all of the modalities together. Choose the largest elbow
value among the three plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DetermineDFromIRLBA(SickleJr, d = 50)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DetermineDFromIRLBA_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="DetermineDFromIRLBA_+3A_d">d</code></td>
<td>
<p>Number of desired factors; it is important to select a number that
allows you to see a clear elbow: defaults to 50.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with plots for IRLBA diagnostics added to its <code>plots</code> slot
</p>


<h3>References</h3>

<p>Baglama J, Reichel L (2005).
&ldquo;Augmented Implicitly Restarted Lanczos Bidiagonalization Methods.&rdquo;
<em>SIAM Journal on Scientific Computing</em>, <b>27</b>(1), 19&ndash;42.
ISSN 10648275, <a href="https://doi.org/10.1137/04060593X">doi:10.1137/04060593X</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-DetermineDFromIRLBA(SimSickleJrSmall,d=5)
</code></pre>

<hr>
<h2 id='GenerateWmatricesandHmatrix'>Initialize the <code class="reqn">\mathbf{W}</code> matrices in each modality and the shared <code class="reqn">\mathbf{H}</code> matrix</h2><span id='topic+GenerateWmatricesandHmatrix'></span>

<h3>Description</h3>

<p>Create the <code class="reqn">\mathbf{W}^v</code> matrices and <code class="reqn">\mathbf{H}</code> matrix via non-negative double singular
value decomposition (NNDSVD) (Boutsidis and Gallopoulus 2008; Gaujoux and Seoighe 2010)
or randomization. For randomization, the algorithm runs for 10 rounds
for the desired number of random initializations and picks the <code class="reqn">\mathbf{W}^v</code> matrices and <code class="reqn">\mathbf{H}</code> matrix with
the lowest achieved loss.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateWmatricesandHmatrix(
  SickleJr,
  d = 10,
  random = FALSE,
  numberReps = 100,
  seed = 5,
  minibatch = FALSE,
  batchsize = -1,
  random_W_updates = FALSE,
  subsample = 1:dim(SickleJr@count.matrices[[1]])[2],
  usesvd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_d">d</code></td>
<td>
<p>Number of latent factors to use: defaults to 10</p>
</td></tr>
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_random">random</code></td>
<td>
<p>Boolean indicating whether to use random initialization (<code>TRUE</code>) or NNDSVD (<code>FALSE</code>): default is NNDSVD</p>
</td></tr>
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_numberreps">numberReps</code></td>
<td>
<p>Number of random initializations to use: default is 5</p>
</td></tr>
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility of random initializations</p>
</td></tr>
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_minibatch">minibatch</code></td>
<td>
<p>Indicates whether or not to use the mini-batch algorithm</p>
</td></tr>
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_batchsize">batchsize</code></td>
<td>
<p>Size of batches for mini-batch NMF</p>
</td></tr>
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_random_w_updates">random_W_updates</code></td>
<td>
<p>Indicates whether to only update each <code class="reqn">\mathbf{W}^v</code> once per round of
<code class="reqn">\mathbf{H}</code> updates; only appropriate for mini-batch algorithms</p>
</td></tr>
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_subsample">subsample</code></td>
<td>
<p>A vector of values to use for subsampling; only appropriate
when determining proper values for d.</p>
</td></tr>
<tr><td><code id="GenerateWmatricesandHmatrix_+3A_usesvd">usesvd</code></td>
<td>
<p>Indicates whether to use <code>R</code>'s singular value decomposition function
svd (TRUE) or irlba (FALSE), default is <code>FALSE</code>; use irlba for larger datasets
to increase performance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SickleJr An object of class SickleJr with the <code class="reqn">\mathbf{W}^v</code> matrices and <code class="reqn">\mathbf{H}</code> matrix added.
</p>


<h3>References</h3>

<p>Boutsidis C, Gallopoulos E (2008).
&ldquo;SVD based initialization: A head start for nonnegative matrix factorization.&rdquo;
<em>Pattern Recognition</em>, <b>41</b>(4), 1350&ndash;1362.
ISSN 00313203, <a href="https://doi.org/10.1016/J.PATCOG.2007.09.010">doi:10.1016/J.PATCOG.2007.09.010</a>.
</p>
<p>Gaujoux R, Seoighe C (2010).
&ldquo;A flexible R package for nonnegative matrix factorization.&rdquo;
<em>BMC Bioinformatics</em>, <b>11</b>(1), 1&ndash;9.
ISSN 14712105, <a href="https://doi.org/10.1186/1471-2105-11-367">doi:10.1186/1471-2105-11-367</a>, <a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-11-367">https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-11-367</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-SetLambdasandRowReg(SimSickleJrSmall,
lambdaWlist=list(10,50),lambdaH=500,rowReg="None")
SimSickleJrSmall&lt;-GenerateWmatricesandHmatrix(SimSickleJrSmall,d=5,usesvd=TRUE)

</code></pre>

<hr>
<h2 id='jrSiCKLSNMF'>Run jrSiCKLSNMF outside of a SickleJr object</h2><span id='topic+jrSiCKLSNMF'></span>

<h3>Description</h3>

<p>Perform joint non-negative matrix factorization (NMF) across multiple modalities of single-cell data.
To measure the discrepancy between two distributions, one can use the Poisson Kullback-Leibler divergence (<code class="reqn">\mathtt{diffFunc}=</code><code class="reqn">\mathtt{"klp"}</code>)  or the Frobenius norm (<code class="reqn">\mathtt{diffFunc}=</code><code class="reqn">\mathtt{"fr"}</code>).
It is also possible to set graph regularization constraints on <code class="reqn">\mathbf{W}^v</code> and either a sparsity constraint on <code class="reqn">\mathbf{H}</code> or an
L2 norm constraint on the rows of <code class="reqn">\mathbf{H}</code>.
This function passes by reference and updates the variables <code class="reqn">\mathtt{WL}</code> and <code class="reqn">\mathtt{H}</code> and does not require data to be in an
object of type SickleJr. <code class="reqn">\mathtt{RunjrSiCKLSNMF}</code> calls this function. If your data are in an object of class SickleJr,
please use the <code class="reqn">\mathtt{RunjrSiCKLSNMF}</code> function instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jrSiCKLSNMF(
  datamatL,
  WL,
  H,
  AdjL,
  DL,
  lambdaWL,
  lambdaH,
  initsamp,
  suppress_warnings,
  diffFunc = "klp",
  Hconstraint = "None",
  differr = 1e-06,
  rounds = 1000L,
  display_progress = TRUE,
  minibatch = TRUE,
  batchsize = 100L,
  random_W_updates = TRUE,
  minrounds = 100L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jrSiCKLSNMF_+3A_datamatl">datamatL</code></td>
<td>
<p>An R list where each entry contains a normalized, sparse <code class="reqn">\mathbf{X}^v</code> matrix corresponding to single-cell modality <code class="reqn">v</code></p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_wl">WL</code></td>
<td>
<p>An R list containing initialized values of the <code class="reqn">\mathbf{W}^v</code> within each modality <code class="reqn">v</code></p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_h">H</code></td>
<td>
<p>A matrix containing initialized values for the shared <code class="reqn">\mathbf{H}</code></p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_adjl">AdjL</code></td>
<td>
<p>An R list containing all of the adjacency matrices for the
feature-feature similarity graphs in sparse format; note that <code class="reqn">\mathtt{D-Adj}</code> is the
graph Laplacian</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_dl">DL</code></td>
<td>
<p>An R list containing all of the degree matrices of the
feature-feature similarity graphs; note that <code class="reqn">\mathtt{D-Adj}</code> is the graph Laplacian</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_lambdawl">lambdaWL</code></td>
<td>
<p>A list of the <code class="reqn">\lambda_{\mathbf{W}^v}</code> corresponding to modality <code class="reqn">v</code></p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_lambdah">lambdaH</code></td>
<td>
<p>A double containing the desired value for <code class="reqn">\lambda_{\mathbf{H}}</code></p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_initsamp">initsamp</code></td>
<td>
<p>A vector of randomly selected rows of <code class="reqn">\mathtt{H}</code> on which to run the objective function</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_suppress_warnings">suppress_warnings</code></td>
<td>
<p>A Boolean that indicates whether warnings should be suppressed</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_difffunc">diffFunc</code></td>
<td>
<p>A string indicating what type of divergence to use; set to the Poisson Kullback-Leibler divergence
(<code class="reqn">\mathtt{``klp"}</code>) by default, but the Frobenius norm (<code class="reqn">\mathtt{``fr"}</code>) is also available</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_hconstraint">Hconstraint</code></td>
<td>
<p>A string that indicates whether you want to set an L2 norm constraint on the rows of <code class="reqn">\mathbf{H}</code>. Enter 'None' for
no constraints or 'L2Norm' to set the L2 norm of each row of <code class="reqn">\mathbf{H}</code> to 1</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_differr">differr</code></td>
<td>
<p>A double containing the tolerance</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_rounds">rounds</code></td>
<td>
<p>A double containing the number of rounds</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_display_progress">display_progress</code></td>
<td>
<p>A Boolean indicating whether to display the progress bar</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_minibatch">minibatch</code></td>
<td>
<p>A Boolean indicating whether to use the mini-batch version of the algorithm</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of batches for mini-batch updates</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_random_w_updates">random_W_updates</code></td>
<td>
<p>A Boolean indicating whether to update <code class="reqn">\mathbf{W}^v</code> once per epoch (TRUE) or after every update of
the subset of <code class="reqn">\mathbf{H}</code> (FALSE) for the mini-batch algorithm.</p>
</td></tr>
<tr><td><code id="jrSiCKLSNMF_+3A_minrounds">minrounds</code></td>
<td>
<p>A minimum number of rounds for the algorithm to run: most useful for the mini-batch algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R list containing values for the objective function.
</p>


<h3>References</h3>

<p>Cai D, He X, Wu X, Han J (2008).
&ldquo;Non-negative matrix factorization on manifold.&rdquo;
<em>Proceedings - IEEE International Conference on Data Mining, ICDM</em>, 63&ndash;72.
ISSN 15504786, <a href="https://doi.org/10.1109/ICDM.2008.57">doi:10.1109/ICDM.2008.57</a>.
</p>
<p>Greene D, Cunningham P (2009).
&ldquo;A matrix factorization approach for integrating multiple data views.&rdquo;
<em>Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)</em>, <b>5781 LNAI</b>(PART 1), 423&ndash;438.
ISSN 03029743, <a href="https://doi.org/10.1007/978-3-642-04180-8_45">doi:10.1007/978-3-642-04180-8_45</a>, <a href="https://link.springer.com/chapter/10.1007/978-3-642-04180-8_45">https://link.springer.com/chapter/10.1007/978-3-642-04180-8_45</a>.
</p>
<p>Eddelbuettel D, François R (2011).
&ldquo;Rcpp: Seamless R and C++ Integration.&rdquo;
<em>Journal of Statistical Software</em>, <b>40</b>(8), 1&ndash;18.
<a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>.
</p>
<p>Eddelbuettel D, Sanderson C (2014).
&ldquo;RcppArmadillo: Accelerating R with high-performance C++ linear algebra.&rdquo;
<em>Computational	Statistics and Data Analysis</em>, <b>71</b>, 1054&ndash;1063.
<a href="http://dx.doi.org/10.1016/j.csda.2013.02.005">http://dx.doi.org/10.1016/j.csda.2013.02.005</a>.
</p>
<p>Elyanow R, Dumitrascu B, Engelhardt BE, Raphael BJ (2020).
&ldquo;NetNMF-SC: Leveraging gene-gene interactions for imputation and dimensionality reduction in single-cell expression analysis.&rdquo;
<em>Genome Research</em>, <b>30</b>(2), 195&ndash;204.
ISSN 15495469, <a href="https://doi.org/10.1101/gr.251603.119">doi:10.1101/gr.251603.119</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/31992614/">https://pubmed.ncbi.nlm.nih.gov/31992614/</a>.
</p>
<p>Le Roux J, Weniger F, Hershey JR (2015).
&ldquo;Sparse NMF: half-baked or well done?&rdquo;
Mitsubishi Electric Research Laboratories (MERL), Cambridge.
</p>
<p>Lee DD, Seung HS (2000).
&ldquo;Algorithms for Non-negative Matrix Factorization.&rdquo;
In Leen T, Dietterich T, Tresp V (eds.), <em>Advances in Neural Information Processing Systems</em>, volume 13.
<a href="https://proceedings.neurips.cc/paper/2000/file/f9d1152547c0bde01830b7e8bd60024c-Paper.pdf">https://proceedings.neurips.cc/paper/2000/file/f9d1152547c0bde01830b7e8bd60024c-Paper.pdf</a>.
</p>
<p>Liu J, Wang C, Gao J, Han J (2013).
&ldquo;Multi-view clustering via joint nonnegative matrix factorization.&rdquo;
<em>Proceedings of the 2013 SIAM International Conference on Data Mining</em>, 252&ndash;260.
<a href="https://doi.org/10.1137/1.9781611972832.28">doi:10.1137/1.9781611972832.28</a>.
</p>

<hr>
<h2 id='MinibatchDiagnosticPlot'>Plot a diagnostic plot for the mini-batch algorithm</h2><span id='topic+MinibatchDiagnosticPlot'></span>

<h3>Description</h3>

<p>To ensure sufficient convergence of the loss for jrSiCKLSNMF with mini-batch updates, we
plot the loss vs the number of iterations for the mini-batch algorithm.
After a certain number of iterations, the loss should appear to oscillate
around a value. Before continuing with downstream analyses, please ensure that
the loss exhibits this sort of behavior. For the mini-batch algorithm, it is not
possible to use the convergence criteria used for the batch version of the
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MinibatchDiagnosticPlot(SickleJr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MinibatchDiagnosticPlot_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with mini-batch diagnostic plots added to the <code>plots</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-MinibatchDiagnosticPlot(SimSickleJrSmall)
</code></pre>

<hr>
<h2 id='NormalizeCountMatrices'>Normalize the count matrices and set whether to use the Poisson KL divergence
or the Frobenius norm</h2><span id='topic+NormalizeCountMatrices'></span>

<h3>Description</h3>

<p>Normalize the count data within each modality. The default
normalization, which should be used when using the KL divergence, is median
library size normalization (Zheng et al. 2017; Elyanow et al. 2020). To perform median library size normalization,
each count within a cell is divided by its library size (i.e. the counts within a column are divided by the
column sum). Then, all values are multiplied by the median library size
(i.e. the median column sum). To use the Frobenius norm, set <code>frob=TRUE</code> to log<code class="reqn">(x+1)</code>
normalize your count data and use a desired <code>scaleFactor</code>.
You may also use a different form of normalization and store these results
in the <code>normalized.count.matrices</code> slot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalizeCountMatrices(SickleJr, diffFunc = "klp", scaleFactor = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormalizeCountMatrices_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="NormalizeCountMatrices_+3A_difffunc">diffFunc</code></td>
<td>
<p>A string set to &quot;klp&quot; when using the Poisson KL divergence
or to &quot;fr&quot; when using the Frobenius norm: default is KL divergence; this also determines
the type of normalization</p>
</td></tr>
<tr><td><code id="NormalizeCountMatrices_+3A_scalefactor">scaleFactor</code></td>
<td>
<p>A single numeric value (if using the same scale factor for each modality)
or a list of numeric values to use (if using different scale factors in different modalities)
as scale factors for the log<code class="reqn">(x+1)</code> normalization when <code>diffFunc="fr"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with a list of sparse, normalized data matrices added to its <code>normalized.count.matrices</code> slot
</p>


<h3>References</h3>

<p>Elyanow R, Dumitrascu B, Engelhardt BE, Raphael BJ (2020).
&ldquo;NetNMF-SC: Leveraging gene-gene interactions for imputation and dimensionality reduction in single-cell expression analysis.&rdquo;
<em>Genome Research</em>, <b>30</b>(2), 195&ndash;204.
ISSN 15495469, <a href="https://doi.org/10.1101/gr.251603.119">doi:10.1101/gr.251603.119</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/31992614/">https://pubmed.ncbi.nlm.nih.gov/31992614/</a>.
</p>
<p>Zheng GX, Terry JM, Belgrader P, Ryvkin P, Bent ZW, Wilson R, Ziraldo SB, Wheeler TD, McDermott GP, Zhu J, Gregory MT, Shuga J, Montesclaros L, Underwood JG, Masquelier DA, Nishimura SY, Schnall-Levin M, Wyatt PW, Hindson CM, Bharadwaj R, Wong A, Ness KD, Beppu LW, Deeg HJ, McFarland C, Loeb KR, Valente WJ, Ericson NG, Stevens EA, Radich JP, Mikkelsen TS, Hindson BJ, Bielas JH (2017).
&ldquo;Massively parallel digital transcriptional profiling of single cells.&rdquo;
<em>Nature Communications</em>, <b>8</b>.
ISSN 20411723, <a href="https://doi.org/10.1038/NCOMMS14049">doi:10.1038/NCOMMS14049</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/28091601/">https://pubmed.ncbi.nlm.nih.gov/28091601/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-NormalizeCountMatrices(SimSickleJrSmall)
SimSickleJrSmall&lt;-NormalizeCountMatrices(SimSickleJrSmall, diffFunc="fr",scaleFactor=1e6)
</code></pre>

<hr>
<h2 id='PlotLossvsLatentFactors'>Create plots to help determine the number of latent factors</h2><span id='topic+PlotLossvsLatentFactors'></span>

<h3>Description</h3>

<p>Generate plots of the lowest achieved loss after a
pre-specified number of iterations (default 100) for each latent factor
(defaults to 2:20). This operates similarly to a scree plot, so please select
a number of latent factors that corresponds to the elbow of the plot.
This method is not appropriate for larger sets of data (more than 1000 cells)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotLossvsLatentFactors(
  SickleJr,
  rounds = 100,
  differr = 1e-04,
  d_vector = c(2:20),
  parallel = FALSE,
  nCores = detectCores() - 1,
  subsampsize = NULL,
  minibatch = FALSE,
  random = FALSE,
  random_W_updates = FALSE,
  seed = NULL,
  batchsize = -1,
  lossonsubset = FALSE,
  losssubsetsize = dim(SickleJr@count.matrices[[1]])[2]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotLossvsLatentFactors_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_rounds">rounds</code></td>
<td>
<p>Number of rounds to use: defaults to 100; this process is time consuming,
so a high number of rounds is not recommended</p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_differr">differr</code></td>
<td>
<p>Tolerance for the percentage update in the likelihood: for these plots,
this defaults to <code class="reqn">1e-4</code></p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_d_vector">d_vector</code></td>
<td>
<p>Vector of <code class="reqn">d</code> values to test: default is 2 to 20</p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_parallel">parallel</code></td>
<td>
<p>Boolean indicating whether to use parallel computation</p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_ncores">nCores</code></td>
<td>
<p>Number of desired cores; defaults to the number of cores of the current machine minus 1 for convenience</p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_subsampsize">subsampsize</code></td>
<td>
<p>Size of the random subsample (defaults to <code>NULL</code>, which means all cells will be used); using a random subsample decreases computation time but sacrifices accuracy</p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_minibatch">minibatch</code></td>
<td>
<p>Boolean indicating whether to use the mini-batch algorithm: default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_random">random</code></td>
<td>
<p>Boolean indicating whether to use random initialization to generate the <code class="reqn">\mathbf{W}^v</code> matrices and <code class="reqn">\mathbf{H}</code> matrix:
defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_random_w_updates">random_W_updates</code></td>
<td>
<p>Boolean parameter for mini-batch algorithm; if <code>TRUE</code>, only updates <code class="reqn">\mathbf{W}^v</code> once per epoch on the
penultimate subset of <code class="reqn">\mathbf{H}</code>; otherwise updates <code class="reqn">\mathbf{W}^v</code> after every update of the subset of <code class="reqn">\mathbf{H}</code></p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_seed">seed</code></td>
<td>
<p>Number representing the random seed</p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_batchsize">batchsize</code></td>
<td>
<p>Desired batch size; do not use if using a subsample</p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_lossonsubset">lossonsubset</code></td>
<td>
<p>Boolean indicating whether to calculate the loss on a subset rather than the full dataset; speeds up computation for larger datasets</p>
</td></tr>
<tr><td><code id="PlotLossvsLatentFactors_+3A_losssubsetsize">losssubsetsize</code></td>
<td>
<p>Number of cells to use for the loss subset; default is total number of cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with a list of initialized <code class="reqn">\mathbf{W}^v</code> matrices and an <code class="reqn">\mathbf{H}</code> matrix
for each latent factor <code class="reqn">d\in\{1,...,D\}</code> added to the <code>WHinitials</code> slot, a data frame holding relevant
values for plotting the elbow plot added to the <code>latent.factor.elbow.values</code> slot, diagnostic plots of the loss vs. the number of latent factors added to the <code>plots</code>
slot, and the cell indices used to calculate the loss on the subsample added to the <code>lossCalcSubSample</code> slot
</p>


<h3>References</h3>

<p>Wickham H (2016).
<em>ggplot2: Elegant Graphics for Data Analysis</em>, 2 edition.
Springer International Publishing, Cham, Switzerland.
ISBN 978-3-319-24277-4, <a href="https://doi.org/10.1007/978-3-319-24277-4">doi:10.1007/978-3-319-24277-4</a>, <a href="https://ggplot2.tidyverse.org/">https://ggplot2.tidyverse.org/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall@latent.factor.elbow.values&lt;-data.frame(NULL,NULL)
SimSickleJrSmall&lt;-PlotLossvsLatentFactors(SimSickleJrSmall,d_vector=c(2:5),
rounds=5,parallel=FALSE)
#Next, we commute 2 of these in parallel.
## Not run: 
SimSickleJrSmall&lt;-PlotLossvsLatentFactors(SimSickleJrSmall,
d_vector=c(6:7),rounds=5,parallel=TRUE,nCores=2)
## End(Not run)
</code></pre>

<hr>
<h2 id='PlotSickleJrUMAP'>Generate UMAP plots for an object of class SickleJr</h2><span id='topic+PlotSickleJrUMAP'></span>

<h3>Description</h3>

<p>Plot the first and second dimensions of a UMAP dimension reduction
and color either by clustering results or metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSickleJrUMAP(
  SickleJr,
  umap.modality = "H",
  cluster = "kmeans",
  title = "",
  colorbymetadata = NULL,
  legendname = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotSickleJrUMAP_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="PlotSickleJrUMAP_+3A_umap.modality">umap.modality</code></td>
<td>
<p>String corresponding to the name of the UMAP of interest: defaults to <code>"H"</code></p>
</td></tr>
<tr><td><code id="PlotSickleJrUMAP_+3A_cluster">cluster</code></td>
<td>
<p>String input that indicates which cluster to color by: defaults to <code>"kmeans"</code></p>
</td></tr>
<tr><td><code id="PlotSickleJrUMAP_+3A_title">title</code></td>
<td>
<p>String input for optional <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> plot title</p>
</td></tr>
<tr><td><code id="PlotSickleJrUMAP_+3A_colorbymetadata">colorbymetadata</code></td>
<td>
<p>Name of metadata column if coloring by metadata</p>
</td></tr>
<tr><td><code id="PlotSickleJrUMAP_+3A_legendname">legendname</code></td>
<td>
<p>String input that to allow specification of a different legend name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with plots added to the <code>plots</code> slot
</p>


<h3>References</h3>

<p>Wickham H (2016).
<em>ggplot2: Elegant Graphics for Data Analysis</em>, 2 edition.
Springer International Publishing, Cham, Switzerland.
ISBN 978-3-319-24277-4, <a href="https://doi.org/10.1007/978-3-319-24277-4">doi:10.1007/978-3-319-24277-4</a>, <a href="https://ggplot2.tidyverse.org/">https://ggplot2.tidyverse.org/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-PlotSickleJrUMAP(SimSickleJrSmall,
title="K-Means Example")
SimSickleJrSmall&lt;-PlotSickleJrUMAP(SimSickleJrSmall,umap.modality=1)
</code></pre>

<hr>
<h2 id='RunjrSiCKLSNMF'>Run jrSiCKLSNMF on an object of class SickleJr</h2><span id='topic+RunjrSiCKLSNMF'></span>

<h3>Description</h3>

<p>Wrapper function to run jrSiCKLSNMF on an object of class SickleJr. Performs jrSiCKLSNMF on
the given SickleJr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunjrSiCKLSNMF(
  SickleJr,
  rounds = 30000,
  differr = 1e-06,
  display_progress = TRUE,
  lossonsubset = FALSE,
  losssubsetsize = dim(SickleJr@H)[1],
  minibatch = FALSE,
  batchsize = 1000,
  random_W_updates = FALSE,
  seed = NULL,
  minrounds = 200,
  suppress_warnings = FALSE,
  subsample = 1:dim(SickleJr@normalized.count.matrices[[1]])[2]
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RunjrSiCKLSNMF_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_rounds">rounds</code></td>
<td>
<p>Number of rounds: defaults to 2000</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_differr">differr</code></td>
<td>
<p>Tolerance for percentage change in loss between updates: defaults to 1e-6</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_display_progress">display_progress</code></td>
<td>
<p>Boolean indicating whether to display the progress bar for jrSiCKLSNMF</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_lossonsubset">lossonsubset</code></td>
<td>
<p>Boolean indicating whether to use a subset to calculate the loss function
rather than the whole dataset</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_losssubsetsize">losssubsetsize</code></td>
<td>
<p>Size of the subset of data on which to calculate the loss</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_minibatch">minibatch</code></td>
<td>
<p>Boolean indicating whether to use mini-batch updates</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_batchsize">batchsize</code></td>
<td>
<p>Size of batch for mini-batch updates</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_random_w_updates">random_W_updates</code></td>
<td>
<p>Boolean indicating whether or not to use random_W_updates updates
(i.e. only update <code class="reqn">\mathbf{W}^v</code> once per mini-batch epoch)</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_seed">seed</code></td>
<td>
<p>Number specifying desired random seed</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_minrounds">minrounds</code></td>
<td>
<p>Minimum number of rounds: most helpful for the mini-batch algorithm</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_suppress_warnings">suppress_warnings</code></td>
<td>
<p>Boolean indicating whether to suppress warnings</p>
</td></tr>
<tr><td><code id="RunjrSiCKLSNMF_+3A_subsample">subsample</code></td>
<td>
<p>A numeric used primarily when finding an appropriate number of
latent factors: defaults to total number of cells</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with updated <code class="reqn">\mathbf{W}^v</code> matrices, updated <code class="reqn">\mathbf{H}</code> matrix, and a vector of values for
the loss function added to the <code>Wlist</code>, <code>H</code>, and <code>loss</code> slots, respectively
</p>


<h3>References</h3>

<p>Cai D, He X, Wu X, Han J (2008).
&ldquo;Non-negative matrix factorization on manifold.&rdquo;
<em>Proceedings - IEEE International Conference on Data Mining, ICDM</em>, 63&ndash;72.
ISSN 15504786, <a href="https://doi.org/10.1109/ICDM.2008.57">doi:10.1109/ICDM.2008.57</a>.
</p>
<p>Greene D, Cunningham P (2009).
&ldquo;A matrix factorization approach for integrating multiple data views.&rdquo;
<em>Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)</em>, <b>5781 LNAI</b>(PART 1), 423&ndash;438.
ISSN 03029743, <a href="https://doi.org/10.1007/978-3-642-04180-8_45">doi:10.1007/978-3-642-04180-8_45</a>, <a href="https://link.springer.com/chapter/10.1007/978-3-642-04180-8_45">https://link.springer.com/chapter/10.1007/978-3-642-04180-8_45</a>.
</p>
<p>Eddelbuettel D, François R (2011).
&ldquo;Rcpp: Seamless R and C++ Integration.&rdquo;
<em>Journal of Statistical Software</em>, <b>40</b>(8), 1&ndash;18.
<a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>.
</p>
<p>Eddelbuettel D, Sanderson C (2014).
&ldquo;RcppArmadillo: Accelerating R with high-performance C++ linear algebra.&rdquo;
<em>Computational	Statistics and Data Analysis</em>, <b>71</b>, 1054&ndash;1063.
<a href="http://dx.doi.org/10.1016/j.csda.2013.02.005">http://dx.doi.org/10.1016/j.csda.2013.02.005</a>.
</p>
<p>Elyanow R, Dumitrascu B, Engelhardt BE, Raphael BJ (2020).
&ldquo;NetNMF-SC: Leveraging gene-gene interactions for imputation and dimensionality reduction in single-cell expression analysis.&rdquo;
<em>Genome Research</em>, <b>30</b>(2), 195&ndash;204.
ISSN 15495469, <a href="https://doi.org/10.1101/gr.251603.119">doi:10.1101/gr.251603.119</a>, <a href="https://pubmed.ncbi.nlm.nih.gov/31992614/">https://pubmed.ncbi.nlm.nih.gov/31992614/</a>.
</p>
<p>Le Roux J, Weniger F, Hershey JR (2015).
&ldquo;Sparse NMF: half-baked or well done?&rdquo;
Mitsubishi Electric Research Laboratories (MERL), Cambridge.
</p>
<p>Lee DD, Seung HS (2000).
&ldquo;Algorithms for Non-negative Matrix Factorization.&rdquo;
In Leen T, Dietterich T, Tresp V (eds.), <em>Advances in Neural Information Processing Systems</em>, volume 13.
<a href="https://proceedings.neurips.cc/paper/2000/file/f9d1152547c0bde01830b7e8bd60024c-Paper.pdf">https://proceedings.neurips.cc/paper/2000/file/f9d1152547c0bde01830b7e8bd60024c-Paper.pdf</a>.
</p>
<p>Liu J, Wang C, Gao J, Han J (2013).
&ldquo;Multi-view clustering via joint nonnegative matrix factorization.&rdquo;
<em>Proceedings of the 2013 SIAM International Conference on Data Mining</em>, 252&ndash;260.
<a href="https://doi.org/10.1137/1.9781611972832.28">doi:10.1137/1.9781611972832.28</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-RunjrSiCKLSNMF(SimSickleJrSmall,rounds=5)
</code></pre>

<hr>
<h2 id='SetLambdasandRowReg'>Set lambda values and type of row regularization for an object of class SickleJr</h2><span id='topic+SetLambdasandRowReg'></span>

<h3>Description</h3>

<p>Provide the values for the graph regularization <code class="reqn">\lambda_{\textbf{W}^v}</code>
for each modality as a list, provide the value for the sparsity constraint <code class="reqn">\lambda_{\mathbf{H}}</code>,
and select whether to use L2 norm regularization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SetLambdasandRowReg(
  SickleJr,
  lambdaWlist = list(10, 50),
  lambdaH = 500,
  rowReg = "None"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SetLambdasandRowReg_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="SetLambdasandRowReg_+3A_lambdawlist">lambdaWlist</code></td>
<td>
<p>A list of graph regularization constraints for the <code class="reqn">\mathbf{W}^v</code> matrices:
defaults to 2 modalities with the RNA modality constraint equal to 10 and the ATAC modality constraint equal to 50</p>
</td></tr>
<tr><td><code id="SetLambdasandRowReg_+3A_lambdah">lambdaH</code></td>
<td>
<p>A numeric holding the sparsity constraint on <code class="reqn">\mathbf{H}</code>: defaults to 500.</p>
</td></tr>
<tr><td><code id="SetLambdasandRowReg_+3A_rowreg">rowReg</code></td>
<td>
<p>A string that is equal to <code>"None"</code> for no constraints on the rows of <code class="reqn">\mathbf{H}</code> and <code>"L2Norm"</code>
to set the L2 norms of the rows of <code class="reqn">\mathbf{H}</code> to be equal to 1: defaults to &quot;None&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with the lambda hyperparameter values added to its <code>lambdaWlist</code> and <code>lambdaH</code> slots and with the
row regularization value added to its <code>rowRegularization</code> slot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-SetLambdasandRowReg(SimSickleJrSmall,
lambdaWlist=list(10,50),lambdaH=500,rowReg="None")
SimSickleJrSmall&lt;-SetLambdasandRowReg(SimSickleJrSmall,
lambdaWlist=list(3,15),lambdaH=0,rowReg="L2Norm")
</code></pre>

<hr>
<h2 id='SetWandHfromWHinitials'>Set <code class="reqn">\mathbf{W}</code> matrices and <code class="reqn">\mathbf{H}</code> matrix from pre-calculated values</h2><span id='topic+SetWandHfromWHinitials'></span>

<h3>Description</h3>

<p>Use values calculated in the step to determine number of latent factors in the initial
steps for the jrSiCKLSNMF algorithm. If only a subset was calculated, this produces an error.
In this case, please use <code><a href="#topic+GenerateWmatricesandHmatrix">GenerateWmatricesandHmatrix</a></code> to generate new
<code class="reqn">\mathbf{W}^v</code> matrices and a new <code class="reqn">\mathbf{H}</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SetWandHfromWHinitials(SickleJr, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SetWandHfromWHinitials_+3A_sicklejr">SickleJr</code></td>
<td>
<p>An object of class SickleJr</p>
</td></tr>
<tr><td><code id="SetWandHfromWHinitials_+3A_d">d</code></td>
<td>
<p>The number of desired latent factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class SickleJr with the <code>Wlist</code> slot and the <code>H</code> slot filled from pre-calculated values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SimSickleJrSmall&lt;-SetWandHfromWHinitials(SimSickleJrSmall,d=5)
</code></pre>

<hr>
<h2 id='SickleJr-class'>The SickleJr class</h2><span id='topic+SickleJr-class'></span><span id='topic+SickleJr'></span>

<h3>Description</h3>

<p>Defines the SickleJr class for use with jrSiCKLSNMF. This object
contains all of the information required for analysis using jrSiCKLSNMF. This includes
count matrices, normalized matrices, graph Laplacians, hyperparameters, diagnostic plots,
and plots of cell clusters.
</p>


<h3>Value</h3>

<p>An object of class SickleJr
</p>


<h3>Slots</h3>


<dl>
<dt><code>count.matrices</code></dt><dd><p>A list containing all of the quality controlled count matrices.
Note that these count matrices should not use all features and should
only include features that appear in at a minimum 10 cells.</p>
</dd>
<dt><code>normalized.count.matrices</code></dt><dd><p>A list that holds the normalized count matrices</p>
</dd>
<dt><code>graph.laplacian.list</code></dt><dd><p>A list of the graph Laplacians to be used for graph regularization</p>
</dd>
<dt><code>rowRegularization</code></dt><dd><p>A string that indicates the type of row regularization to
use. Types include &quot;None&quot; and &quot;L2Norm&quot;</p>
</dd>
<dt><code>diffFunc</code></dt><dd><p>A string that holds the name of the function used to measure the discrepancy between
data matrix X and WH for each modality; can be <code>"klp"</code> for the Poisson Kullback-Leibler divergence
or <code>"fr"</code> for the Frobenius norm</p>
</dd>
<dt><code>lambdaWlist</code></dt><dd><p>A list of lambda values to use as the hyperparameters for the
corresponding <code class="reqn">\mathbf{W}^v</code> in the <code class="reqn">v^{\text{th}}</code> modality</p>
</dd>
<dt><code>lambdaH</code></dt><dd><p>A numeric value corresponding to the hyperparameter of the sparsity constraint on <code class="reqn">\mathbf{H}</code></p>
</dd>
<dt><code>Wlist</code></dt><dd><p>A list of the generated <code class="reqn">\mathbf{W}^v</code> matrices, one for each modality</p>
</dd>
<dt><code>H</code></dt><dd><p>The shared <code class="reqn">\mathbf{H}</code> matrix</p>
</dd>
<dt><code>WHinitials</code></dt><dd><p>A list that if, when using <code><a href="#topic+PlotLossvsLatentFactors">PlotLossvsLatentFactors</a></code>, all of the cells are used to calculate
the initial values, stores these initial generated matrices; can be used
as initializations when running <code><a href="#topic+RunjrSiCKLSNMF">RunjrSiCKLSNMF</a></code> to save time</p>
</dd>
<dt><code>lossCalcSubsample</code></dt><dd><p>A vector that holds the cell indices on which <code><a href="#topic+PlotLossvsLatentFactors">PlotLossvsLatentFactors</a></code> was calculated</p>
</dd>
<dt><code>latent.factor.elbow.values</code></dt><dd><p>A data frame that holds the relevant information to plot the latent factor elbow plot</p>
</dd>
<dt><code>minibatch</code></dt><dd><p>Indicator variable that states whether the algorithm should use mini-batch updates.</p>
</dd>
<dt><code>clusterdiagnostics</code></dt><dd><p>List of the cluster diagnostic results for the SickleJr object. Includes diagnostic plots from <code><a href="factoextra.html#topic+fviz_nbclust">fviz_nbclust</a></code> and
and diagnostics from <code><a href="clValid.html#topic+clValid">clValid</a></code></p>
</dd>
<dt><code>clusters</code></dt><dd><p>List of results of different clustering methods performed on the SickleJr object</p>
</dd>
<dt><code>metadata</code></dt><dd><p>List of metadata</p>
</dd>
<dt><code>loss</code></dt><dd><p>Vector of the value for the loss function</p>
</dd>
<dt><code>umap</code></dt><dd><p>List of different UMAP-based dimension reductions using <code><a href="umap.html#topic+umap">umap</a></code></p>
</dd>
<dt><code>plots</code></dt><dd><p>Holds various <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> results for easy access of diagnostics and cluster visualizations</p>
</dd>
</dl>

<hr>
<h2 id='SimData'>A simulated dataset for use with jrSiCKLSNMF</h2><span id='topic+SimData'></span>

<h3>Description</h3>

<p>A simulated dataset with <code class="reqn">\mathcal{U}(1,1.25)</code> multiplicative noise for the
scRNA-seq variability parameter in SPARSim for the simulated scRNA-seq data and
with <code class="reqn">\mathcal{N}(-0.25,0.25)</code> additive noise to the expression levels of the scATAC-seq data
for data simulated via SimATAC. The simulated matrices are located in SimData$Xmatrices
and the identities for the cell types are contained in SimData$cell_type. This corresponds
to the Xmatrix data found in both
</p>
<p>XandLmatrices25/XandindividLKNNLmatrices1Sparsity5.RData and
</p>
<p>XandBulkLmatrix25/XandBulkLKNNmatrices1Sparsity5.RData on our Github
</p>
<p><a href="https://github.com/ellisdoro/jrSiCKLSNMF_Simulations">ellisdoro/jrSiCKLSNMF_Simulations</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SimData)
</code></pre>


<h3>Format</h3>

<p>A list made up of a two items. The first is list of 2 simulated sparse matrices
and the second is a vector containing cell identities.
</p>

<dl>
<dt>Xmatrices</dt><dd><p>A list of 2 sparse matrices, each containing a different
simulated omics modality measured on the same set of single cells: the first entry in the list
corresponds to simulated scRNA-seq data and has 1000 genes and 300 cells; the second entry in
the list corresponds to simulated scATAC-seq data and has 5910 peaks and 300
cells.</p>
</dd>
<dt>cell_type</dt><dd><p>A vector containing the cell-type identities of the simulated data</p>
</dd></dl>



<h3>Source</h3>

<p><a href="https://github.com/ellisdoro/jrSiCKLSNMF_Simulations">jrSicKLSNMF Simulations</a>
</p>

<hr>
<h2 id='SimSickleJrSmall'>A small SickleJr object containing a subset of data from the
<code style="white-space: pre;">&#8288;SimData&#8288;</code> data object. Contains the completed analysis from the
'Getting Started' vignette for a small subset of 10 cells with 150 genes and
700 peaks. The clusters derived from this dataset are not accurate; this dataset
is intended for use with code examples.</h2><span id='topic+SimSickleJrSmall'></span>

<h3>Description</h3>

<p>A small SickleJr object containing a subset of data from the
<code style="white-space: pre;">&#8288;SimData&#8288;</code> data object. Contains the completed analysis from the
'Getting Started' vignette for a small subset of 10 cells with 150 genes and
700 peaks. The clusters derived from this dataset are not accurate; this dataset
is intended for use with code examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SimSickleJrSmall)
</code></pre>


<h3>Format</h3>

<p>A SickleJr object containing a completed analysis using jrSiCKLSNMF
</p>

<dl>
<dt>count.matrices</dt><dd><p>Contains a list of 2 sparse matrices, each containing a different
simulated omics modality measured on the same set of single cells</p>
</dd>
<dt>normalized.count.matrices</dt><dd><p>The normalized versions of the count matrices
contained in slot <code>count.matrices</code></p>
</dd>
<dt>graph.laplacian.list</dt><dd><p>A list of sparse matrices containing the graph
Laplacians corresponding to the KNN feature-feature similarity graphs constructed
for each omics modality</p>
</dd>
<dt>rowRegularization</dt><dd><p>A string indicating the row regularization: here it
is set to <code>"None"</code></p>
</dd>
<dt>diffFunc</dt><dd><p>A string specifying the function to measure the discrepancy
between the normalized data and the fitted matrices: here, it is set to &quot;klp&quot;
for the Poisson Kullback-Leibler divergence</p>
</dd>
<dt>lambdaWlist</dt><dd><p>A list holding the graph regularization parameters: here,
they are 10 and 50</p>
</dd>
<dt>lambdaH</dt><dd><p>A numeric indicating the value for the sparsity parameter.
Here it is equals 500</p>
</dd>
<dt>Wlist</dt><dd><p>A list holding the fitted <code class="reqn">\mathbf{W}^v</code> matrices</p>
</dd>
<dt>H</dt><dd><p>A matrix holding <code class="reqn">\mathbf{H}</code></p>
</dd>
<dt>WHinitials</dt><dd><p>A list of initial values for <code class="reqn">\mathbf{W}^v</code> and <code class="reqn">\mathbf{H}</code></p>
</dd>
<dt>lossCalcSubsample</dt><dd><p>A vector containing a subset on which to calculate the loss</p>
</dd>
<dt>latent.factor.elbow.values</dt><dd><p>A data frame holding the loss and the number of latent factor that is used for diagnostic plots</p>
</dd>
<dt>minibatch</dt><dd><p>A Boolean indicating whether or not to use the mini-batch algorithm: <code>FALSE</code> here</p>
</dd>
<dt>clusterdiagnostics</dt><dd><p>Diagnostic plots and results</p>
</dd>
<dt>clusters</dt><dd><p>A list holding the <code>"kmeans"</code> clustering results</p>
</dd>
<dt>metadata</dt><dd><p>A list holding metadata; here this is just cell type information</p>
</dd>
<dt>loss</dt><dd><p>A list holding a vector called &quot;Loss&quot;</p>
</dd>
<dt>umap</dt><dd><p>A list holding various UMAP approximations</p>
</dd>
<dt>plots</dt><dd><p>A list holding ggplots corresponding to different diagnostics and visualizations</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/ellisdoro/jrSiCKLSNMF_Simulations">jrSicKLSNMF Simulations</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
