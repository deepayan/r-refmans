<!DOCTYPE html><html><head><title>Help for package microeco</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {microeco}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clone'><p>Copy an R6 class object</p></a></li>
<li><a href='#dataset'><p>The dataset structured with microtable class for the demonstration of examples</p></a></li>
<li><a href='#dropallfactors'><p>Remove all factors in a data frame</p></a></li>
<li><a href='#env_data_16S'><p>The environmental factors for the 16S example data</p></a></li>
<li><a href='#fungi_func_FungalTraits'><p>The FungalTraits database for fungi trait prediction</p></a></li>
<li><a href='#fungi_func_FUNGuild'><p>The FUNGuild database for fungi trait prediction</p></a></li>
<li><a href='#microeco'><p>Introduction to microeco package (<a href="https://github.com/ChiLiubio/microeco">https://github.com/ChiLiubio/microeco</a>)</p></a></li>
<li><a href='#microtable'><p>Create <code>microtable</code> object to store and manage all the basic files.</p></a></li>
<li><a href='#otu_table_16S'><p>The OTU table of the 16S example data</p></a></li>
<li><a href='#otu_table_ITS'><p>The OTU table of the ITS example data</p></a></li>
<li><a href='#phylo_tree_16S'><p>The phylogenetic tree of 16S example data</p></a></li>
<li><a href='#prok_func_FAPROTAX'><p>The modified FAPROTAX trait database</p></a></li>
<li><a href='#prok_func_NJC19_list'><p>The modified NJC19 database</p></a></li>
<li><a href='#sample_info_16S'><p>The sample information of 16S example data</p></a></li>
<li><a href='#sample_info_ITS'><p>The sample information of ITS example data</p></a></li>
<li><a href='#Tax4Fun2_KEGG'><p>The KEGG data files used in the trans_func class</p></a></li>
<li><a href='#taxonomy_table_16S'><p>The taxonomic information of 16S example data</p></a></li>
<li><a href='#taxonomy_table_ITS'><p>The taxonomic information of ITS example data</p></a></li>
<li><a href='#tidy_taxonomy'><p>Clean up the taxonomic table to make taxonomic assignments consistent.</p></a></li>
<li><a href='#trans_abund'><p>Create <code>trans_abund</code> object for plotting taxonomic abundance.</p></a></li>
<li><a href='#trans_alpha'><p>Create <code>trans_alpha</code> object for alpha diversity statistics and plot.</p></a></li>
<li><a href='#trans_beta'><p>Create <code>trans_beta</code> object for beta-diversity analysis based on the distance matrix</p></a></li>
<li><a href='#trans_classifier'><p>Create trans_classifier object for machine-learning-based model prediction.</p></a></li>
<li><a href='#trans_diff'><p>Create <code>trans_diff</code> object for the differential analysis on the taxonomic abundance</p></a></li>
<li><a href='#trans_env'><p>Create <code>trans_env</code> object to analyze the association between environmental factor and microbial community.</p></a></li>
<li><a href='#trans_func'><p>Create <code>trans_func</code> object for functional prediction.</p></a></li>
<li><a href='#trans_network'><p>Create <code>trans_network</code> object for network analysis.</p></a></li>
<li><a href='#trans_norm'><p>Feature abundance normalization/transformation.</p></a></li>
<li><a href='#trans_nullmodel'><p>Create <code>trans_nullmodel</code> object for phylogeny- and taxonomy-based null model analysis.</p></a></li>
<li><a href='#trans_venn'><p>Create <code>trans_venn</code> object for the Venn diagram, petal plot and UpSet plot.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Microbial Community Ecology Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Chi Liu [aut, cre],
  Felipe R. P. Mansoldo [ctb],
  Umer Zeeshan Ijaz [ctb],
  Chenhao Li [ctb],
  Yang Cao [ctb],
  Minjie Yao [ctb],
  Xiangzhen Li [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chi Liu &lt;liuchi0426@126.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A series of statistical and plotting approaches in microbial community ecology based on the R6 class. The classes are designed for data preprocessing, taxa abundance plotting, alpha diversity analysis, beta diversity analysis, differential abundance test, null model analysis, network analysis, machine learning, environmental data analysis and functional analysis.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ChiLiubio/microeco">https://github.com/ChiLiubio/microeco</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, stats, ape, vegan, rlang, data.table, magrittr, dplyr,
tibble, scales, grid, ggplot2 (&ge; 3.5.0), RColorBrewer,
reshape2, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>GUniFrac, MASS, ggpubr, randomForest, ggdendro, ggrepel,
agricolae, gridExtra, picante, pheatmap, rgexf, mice, GGally</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-30 06:17:09 UTC; Chi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-31 00:00:05 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
</table>
<hr>
<h2 id='clone'>Copy an R6 class object</h2><span id='topic+clone'></span>

<h3>Description</h3>

<p>Copy an R6 class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clone(x, deep = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clone_+3A_x">x</code></td>
<td>
<p>R6 class object</p>
</td></tr>
<tr><td><code id="clone_+3A_deep">deep</code></td>
<td>
<p>default TRUE; TRUE means deep copy, i.e. copied object is unlinked with the original one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>identical but unlinked R6 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dataset")
clone(dataset)
</code></pre>

<hr>
<h2 id='dataset'>The dataset structured with microtable class for the demonstration of examples</h2><span id='topic+dataset'></span>

<h3>Description</h3>

<p>The dataset arose from 16S rRNA gene amplicon sequencing of wetland soils in China &lt;doi:10.1016/j.geoderma.2018.09.035&gt;. 
In <code>dataset$sample_table</code>, the 'Group' column means Chinese inland wetlands (IW), coastal wetland (CW) and Tibet plateau wetlands (TW).
The column 'Type' denotes the sampling region: northeastern region (NE), northwest region (NW), North China area (NC), 
middle-lower reaches of the Yangtze River (YML), southern coastal area (SC), upper reaches of the Yangtze River (YU) and Qinghai-Tibet Plateau (QTP). 
The column 'Saline' represents the saline soils and non-saline soils.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataset)
</code></pre>


<h3>Format</h3>

<p>An R6 class object
</p>


<h3>Details</h3>


<ul>
<li><p> sample_table: sample information table
</p>
</li>
<li><p> otu_table: species-community abundance table
</p>
</li>
<li><p> tax_table: taxonomic table
</p>
</li>
<li><p> phylo_tree: phylogenetic tree
</p>
</li>
<li><p> taxa_abund: taxa abundance list with several tables for Phylum...Genus
</p>
</li>
<li><p> alpha_diversity: alpha diversity table
</p>
</li>
<li><p> beta_diversity: list with several beta diversity distance matrix
</p>
</li></ul>


<hr>
<h2 id='dropallfactors'>Remove all factors in a data frame</h2><span id='topic+dropallfactors'></span>

<h3>Description</h3>

<p>Remove all factors in a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropallfactors(x, unfac2num = FALSE, char2num = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dropallfactors_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="dropallfactors_+3A_unfac2num">unfac2num</code></td>
<td>
<p>default FALSE; whether try to convert all character columns to numeric; if FALSE, only try to convert column with factor attribute.
Note that this can only transform the columns that may be transformed to numeric without using factor.</p>
</td></tr>
<tr><td><code id="dropallfactors_+3A_char2num">char2num</code></td>
<td>
<p>default FALSE; whether force all the character to be numeric class by using factor as an intermediate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame without factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("taxonomy_table_16S")
taxonomy_table_16S[, 1] &lt;- as.factor(taxonomy_table_16S[, 1])
str(dropallfactors(taxonomy_table_16S))
</code></pre>

<hr>
<h2 id='env_data_16S'>The environmental factors for the 16S example data</h2><span id='topic+env_data_16S'></span>

<h3>Description</h3>

<p>The environmental factors for the 16S example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(env_data_16S)
</code></pre>

<hr>
<h2 id='fungi_func_FungalTraits'>The FungalTraits database for fungi trait prediction</h2><span id='topic+fungi_func_FungalTraits'></span>

<h3>Description</h3>

<p>The FungalTraits database for fungi trait prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fungi_func_FungalTraits)
</code></pre>

<hr>
<h2 id='fungi_func_FUNGuild'>The FUNGuild database for fungi trait prediction</h2><span id='topic+fungi_func_FUNGuild'></span>

<h3>Description</h3>

<p>The FUNGuild database for fungi trait prediction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fungi_func_FUNGuild)
</code></pre>

<hr>
<h2 id='microeco'>Introduction to microeco package (<a href="https://github.com/ChiLiubio/microeco">https://github.com/ChiLiubio/microeco</a>)</h2><span id='topic+microeco'></span>

<h3>Description</h3>

<p>For the detailed tutorial on microeco package, please follow the links:<br />
Online tutorial website: <a href="https://chiliubio.github.io/microeco_tutorial/">https://chiliubio.github.io/microeco_tutorial/</a> <br />
Download tutorial: <a href="https://github.com/ChiLiubio/microeco_tutorial/releases">https://github.com/ChiLiubio/microeco_tutorial/releases</a>
</p>
<p>For each R6 class, please open the help document by searching the class name.
For example, to search microtable class, please run the command <code>help(microtable)</code> or <code>?microtable</code>.<br />
Another way to open the help document of R6 class is to click the following links collected:<br />
<code><a href="#topic+microtable">microtable</a></code><br />
<code><a href="#topic+trans_abund">trans_abund</a></code><br />
<code><a href="#topic+trans_venn">trans_venn</a></code><br />
<code><a href="#topic+trans_alpha">trans_alpha</a></code><br />
<code><a href="#topic+trans_beta">trans_beta</a></code><br />
<code><a href="#topic+trans_diff">trans_diff</a></code><br />
<code><a href="#topic+trans_network">trans_network</a></code><br />
<code><a href="#topic+trans_nullmodel">trans_nullmodel</a></code><br />
<code><a href="#topic+trans_classifier">trans_classifier</a></code><br />
<code><a href="#topic+trans_env">trans_env</a></code><br />
<code><a href="#topic+trans_func">trans_func</a></code><br />
<code><a href="#topic+trans_norm">trans_norm</a></code><br />
</p>
<p>To report bugs or discuss questions, please use Github Issues (<a href="https://github.com/ChiLiubio/microeco/issues">https://github.com/ChiLiubio/microeco/issues</a>).
Before creating a new issue, 
please read the guideline (<a href="https://chiliubio.github.io/microeco_tutorial/notes.html#github-issues">https://chiliubio.github.io/microeco_tutorial/notes.html#github-issues</a>).
</p>
<p>To cite microeco package in publications, please run the following command to get the reference: <code>citation("microeco")</code><br />
To read the paper, please turn to the publication website 
(<a href="https://academic.oup.com/femsec/article/97/2/fiaa255/6041020">https://academic.oup.com/femsec/article/97/2/fiaa255/6041020</a>).
</p>
<p>Reference:<br />
Chi Liu, Yaoming Cui, Xiangzhen Li and Minjie Yao. 2021. microeco: an R package for data mining in microbial community ecology. 
FEMS Microbiology Ecology, 97(2): fiaa255. DOI:10.1093/femsec/fiaa255
</p>

<hr>
<h2 id='microtable'>Create <code>microtable</code> object to store and manage all the basic files.</h2><span id='topic+microtable'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of operations on the input files and basic manipulations,
including microtable object creation, data trimming, data filtering, rarefaction based on Paul et al. (2013) &lt;doi:10.1371/journal.pone.0061217&gt;, taxonomic abundance calculation, 
alpha and beta diversity calculation based on the An et al. (2019) &lt;doi:10.1016/j.geoderma.2018.09.035&gt; and 
Lozupone et al. (2005) &lt;doi:10.1128/AEM.71.12.8228-8235.2005&gt; and other basic operations.<br />
<br />
Online tutorial: <a href="https://chiliubio.github.io/microeco_tutorial/">https://chiliubio.github.io/microeco_tutorial/</a> <br />
Download tutorial: <a href="https://github.com/ChiLiubio/microeco_tutorial/releases">https://github.com/ChiLiubio/microeco_tutorial/releases</a>
</p>


<h3>Format</h3>

<p>microtable.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-microtable-new"><code>microtable$new()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-filter_pollution"><code>microtable$filter_pollution()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-filter_taxa"><code>microtable$filter_taxa()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-rarefy_samples"><code>microtable$rarefy_samples()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-tidy_dataset"><code>microtable$tidy_dataset()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-add_rownames2taxonomy"><code>microtable$add_rownames2taxonomy()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-sample_sums"><code>microtable$sample_sums()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-taxa_sums"><code>microtable$taxa_sums()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-sample_names"><code>microtable$sample_names()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-taxa_names"><code>microtable$taxa_names()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-rename_taxa"><code>microtable$rename_taxa()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-merge_samples"><code>microtable$merge_samples()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-merge_taxa"><code>microtable$merge_taxa()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-save_table"><code>microtable$save_table()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-cal_abund"><code>microtable$cal_abund()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-save_abund"><code>microtable$save_abund()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-cal_alphadiv"><code>microtable$cal_alphadiv()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-save_alphadiv"><code>microtable$save_alphadiv()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-cal_betadiv"><code>microtable$cal_betadiv()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-save_betadiv"><code>microtable$save_betadiv()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-print"><code>microtable$print()</code></a>
</p>
</li>
<li> <p><a href="#method-microtable-clone"><code>microtable$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-microtable-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>microtable$new(
  otu_table,
  sample_table = NULL,
  tax_table = NULL,
  phylo_tree = NULL,
  rep_fasta = NULL,
  auto_tidy = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>otu_table</code></dt><dd><p>data.frame; The feature abundance table; rownames are features (e.g. OTUs/ASVs/species/genes); column names are samples.</p>
</dd>
<dt><code>sample_table</code></dt><dd><p>data.frame; default NULL; The sample information table; rownames are samples; columns are sample metadata; 
If not provided, the function can generate a table automatically according to the sample names in otu_table.</p>
</dd>
<dt><code>tax_table</code></dt><dd><p>data.frame; default NULL; The taxonomic information table; rownames are features; column names are taxonomic classes.</p>
</dd>
<dt><code>phylo_tree</code></dt><dd><p>phylo; default NULL; The phylogenetic tree; use <code>read.tree</code> function in ape package for input.</p>
</dd>
<dt><code>rep_fasta</code></dt><dd><p><code>DNAStringSet</code> or <code>list</code> format; default NULL; The representative sequences; 
use <code>read.fasta</code> function in <code>seqinr</code> package or <code>readDNAStringSet</code> function in <code>Biostrings</code> package for input.</p>
</dd>
<dt><code>auto_tidy</code></dt><dd><p>default FALSE; Whether trim the files in the <code>microtable</code> object automatically;
If TRUE, running the functions in <code>microtable</code> class can invoke the <code>tidy_dataset</code> function automatically.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>an object of class <code>microtable</code> with the following components:
</p>

<dl>
<dt><code>sample_table</code></dt><dd><p>The sample information table.</p>
</dd>
<dt><code>otu_table</code></dt><dd><p>The feature table.</p>
</dd>
<dt><code>tax_table</code></dt><dd><p>The taxonomic table.</p>
</dd>
<dt><code>phylo_tree</code></dt><dd><p>The phylogenetic tree.</p>
</dd>
<dt><code>rep_fasta</code></dt><dd><p>The representative sequence.</p>
</dd>
<dt><code>taxa_abund</code></dt><dd><p>default NULL; use <code>cal_abund</code> function to calculate.</p>
</dd>
<dt><code>alpha_diversity</code></dt><dd><p>default NULL; use <code>cal_alphadiv</code> function to calculate.</p>
</dd>
<dt><code>beta_diversity</code></dt><dd><p>default NULL; use <code>cal_betadiv</code> function to calculate.</p>
</dd>
</dl>




<h5>Examples</h5>

<div class="r example copy">
<pre>data(otu_table_16S)
data(taxonomy_table_16S)
data(sample_info_16S)
data(phylo_tree_16S)
m1 &lt;- microtable$new(otu_table = otu_table_16S)
m1 &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, 
  tax_table = taxonomy_table_16S, phylo_tree = phylo_tree_16S)
# trim the files in the dataset
m1$tidy_dataset()
</pre>
</div>


<hr>
<a id="method-microtable-filter_pollution"></a>



<h4>Method <code>filter_pollution()</code></h4>

<p>Filter the features considered pollution in <code>microtable$tax_table</code>.
This operation will remove any line of the <code>microtable$tax_table</code> containing any the word in taxa parameter regardless of word case.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$filter_pollution(taxa = c("mitochondria", "chloroplast"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>taxa</code></dt><dd><p>default <code>c("mitochondria", "chloroplast")</code>; filter mitochondria and chloroplast, or others as needed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>m1$filter_pollution(taxa = c("mitochondria", "chloroplast"))
</pre>
</div>


<hr>
<a id="method-microtable-filter_taxa"></a>



<h4>Method <code>filter_taxa()</code></h4>

<p>Filter the feature with low abundance and/or low occurrence frequency.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$filter_taxa(rel_abund = 0, freq = 1, include_lowest = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>rel_abund</code></dt><dd><p>default 0; the relative abundance threshold, such as 0.0001.</p>
</dd>
<dt><code>freq</code></dt><dd><p>default 1; the occurrence frequency threshold. 
For example, the number 2 represents filtering the feature that occurs less than 2 times.
A number smaller than 1 is also allowable. 
For instance, the number 0.1 represents filtering the feature that occurs in less than 10% samples.</p>
</dd>
<dt><code>include_lowest</code></dt><dd><p>default TRUE; whether include the feature with the threshold.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
d1 &lt;- clone(m1)
d1$filter_taxa(rel_abund = 0.0001, freq = 0.2)
}
</pre>
</div>


<hr>
<a id="method-microtable-rarefy_samples"></a>



<h4>Method <code>rarefy_samples()</code></h4>

<p>Rarefy communities to make all samples have same feature number.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$rarefy_samples(
  method = c("rarefying", "SRS")[1],
  sample.size = NULL,
  rngseed = 123,
  replace = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default c(&quot;rarefying&quot;, &quot;SRS&quot;)[1]; &quot;rarefying&quot; represents the classical resampling like <code><a href="vegan.html#topic+rrarefy">rrarefy</a></code> function of <code>vegan</code> package.
&quot;SRS&quot; is scaling with ranked subsampling method based on the SRS package provided by Lukas Beule and Petr Karlovsky (2020) &lt;DOI:10.7717/peerj.9593&gt;.</p>
</dd>
<dt><code>sample.size</code></dt><dd><p>default NULL; feature number, If not provided, use minimum number of all samples.</p>
</dd>
<dt><code>rngseed</code></dt><dd><p>default 123; random seed.</p>
</dd>
<dt><code>replace</code></dt><dd><p>default TRUE; see <code><a href="base.html#topic+sample">sample</a></code> for the random sampling; Available when <code>method = "rarefying"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None; rarefied dataset.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$rarefy_samples(sample.size = min(m1$sample_sums()), replace = TRUE)
}
</pre>
</div>


<hr>
<a id="method-microtable-tidy_dataset"></a>



<h4>Method <code>tidy_dataset()</code></h4>

<p>Trim all the data in the <code>microtable</code> object to make taxa and samples consistent. So the results are intersections.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$tidy_dataset(main_data = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>main_data</code></dt><dd><p>default FALSE; if TRUE, only basic data in <code>microtable</code> object is trimmed. Otherwise, all data, 
including <code>taxa_abund</code>, <code>alpha_diversity</code> and <code>beta_diversity</code>, are all trimed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None, object of <code>microtable</code> itself cleaned up.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>m1$tidy_dataset(main_data = TRUE)
</pre>
</div>


<hr>
<a id="method-microtable-add_rownames2taxonomy"></a>



<h4>Method <code>add_rownames2taxonomy()</code></h4>

<p>Add the rownames of <code>microtable$tax_table</code> as its last column. 
This is especially useful when the rownames of <code>microtable$tax_table</code> are required as a taxonomic level 
for the taxonomic abundance calculation and biomarker idenfification.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$add_rownames2taxonomy(use_name = "OTU")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_name</code></dt><dd><p>default &quot;OTU&quot;; The column name used in the <code>tax_table</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL, a new tax_table stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$add_rownames2taxonomy()
}
</pre>
</div>


<hr>
<a id="method-microtable-sample_sums"></a>



<h4>Method <code>sample_sums()</code></h4>

<p>Sum the species number for each sample.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$sample_sums()</pre></div>



<h5>Returns</h5>

<p>species number of samples.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$sample_sums()
}
</pre>
</div>


<hr>
<a id="method-microtable-taxa_sums"></a>



<h4>Method <code>taxa_sums()</code></h4>

<p>Sum the species number for each taxa.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$taxa_sums()</pre></div>



<h5>Returns</h5>

<p>species number of taxa.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$taxa_sums()
}
</pre>
</div>


<hr>
<a id="method-microtable-sample_names"></a>



<h4>Method <code>sample_names()</code></h4>

<p>Show sample names.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$sample_names()</pre></div>



<h5>Returns</h5>

<p>sample names.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$sample_names()
}
</pre>
</div>


<hr>
<a id="method-microtable-taxa_names"></a>



<h4>Method <code>taxa_names()</code></h4>

<p>Show taxa names of tax_table.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$taxa_names()</pre></div>



<h5>Returns</h5>

<p>taxa names.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$taxa_names()
}
</pre>
</div>


<hr>
<a id="method-microtable-rename_taxa"></a>



<h4>Method <code>rename_taxa()</code></h4>

<p>Rename the features, including the rownames of <code>otu_table</code>, rownames of <code>tax_table</code>, tip labels of <code>phylo_tree</code> and <code>rep_fasta</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$rename_taxa(newname_prefix = "ASV_")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>newname_prefix</code></dt><dd><p>default &quot;ASV_&quot;; the prefix of new names; new names will be newname_prefix + numbers according to the rownames order of <code>otu_table</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None; renamed dataset.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$rename_taxa()
}
</pre>
</div>


<hr>
<a id="method-microtable-merge_samples"></a>



<h4>Method <code>merge_samples()</code></h4>

<p>Merge samples according to specific group to generate a new <code>microtable</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$merge_samples(use_group)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_group</code></dt><dd><p>the group column in <code>sample_table</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new merged microtable object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$merge_samples(use_group = "Group")
}
</pre>
</div>


<hr>
<a id="method-microtable-merge_taxa"></a>



<h4>Method <code>merge_taxa()</code></h4>

<p>Merge taxa according to specific taxonomic rank to generate a new <code>microtable</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$merge_taxa(taxa = "Genus")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>taxa</code></dt><dd><p>default &quot;Genus&quot;; the specific rank in <code>tax_table</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new merged <code>microtable</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$merge_taxa(taxa = "Genus")
}
</pre>
</div>


<hr>
<a id="method-microtable-save_table"></a>



<h4>Method <code>save_table()</code></h4>

<p>Save each basic data in microtable object as local file.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$save_table(dirpath = "basic_files", sep = ",", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dirpath</code></dt><dd><p>default &quot;basic_files&quot;; directory to save the tables, phylogenetic tree and sequences in microtable object. It will be created if not found.</p>
</dd>
<dt><code>sep</code></dt><dd><p>default &quot;,&quot;; the field separator string, used to save tables. Same with <code>sep</code> parameter in <code><a href="utils.html#topic+write.table">write.table</a></code> function.
default <code>','</code> correspond to the file name suffix 'csv'. The option <code>'\t'</code> correspond to the file name suffix 'tsv'. For other options, suffix are all 'txt'.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code><a href="utils.html#topic+write.table">write.table</a></code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
m1$save_table()
}
</pre>
</div>


<hr>
<a id="method-microtable-cal_abund"></a>



<h4>Method <code>cal_abund()</code></h4>

<p>Calculate the taxonomic abundance at each taxonomic level or selected levels.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$cal_abund(
  select_cols = NULL,
  rel = TRUE,
  merge_by = "|",
  split_group = FALSE,
  split_by = "&amp;&amp;",
  split_column = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>select_cols</code></dt><dd><p>default NULL; numeric vector or character vector of colnames of <code>microtable$tax_table</code>; 
applied to select columns to merge and calculate abundances according to ordered hierarchical levels.
This is very useful if there are commented columns or some columns with multiple structure that cannot be used directly.</p>
</dd>
<dt><code>rel</code></dt><dd><p>default TRUE; if TRUE, relative abundance is used; if FALSE, absolute abundance (i.e. raw values) will be summed.</p>
</dd>
<dt><code>merge_by</code></dt><dd><p>default &quot;|&quot;; the symbol to merge and concatenate taxonomic names of different levels.</p>
</dd>
<dt><code>split_group</code></dt><dd><p>default FALSE; if TRUE, split the rows to multiple rows according to one or more columns in <code>tax_table</code>. 
Very useful when multiple mapping information exist.</p>
</dd>
<dt><code>split_by</code></dt><dd><p>default &quot;&amp;&amp;&quot;; Separator delimiting collapsed values; only useful when <code>split_group = TRUE</code>; 
see <code>sep</code> parameter in <code>separate_rows</code> function of tidyr package.</p>
</dd>
<dt><code>split_column</code></dt><dd><p>default NULL; character vector or list; only useful when <code>split_group = TRUE</code>; character vector: 
fixed column or columns used for the splitting in tax_table for each abundance calculation; 
list: containing more character vectors to assign the column names to each calculation, such as list(c(&quot;Phylum&quot;), c(&quot;Phylum&quot;, &quot;Class&quot;)).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>taxa_abund list in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$cal_abund()
}
</pre>
</div>


<hr>
<a id="method-microtable-save_abund"></a>



<h4>Method <code>save_abund()</code></h4>

<p>Save taxonomic abundance as local file.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$save_abund(
  dirpath = "taxa_abund",
  merge_all = FALSE,
  rm_un = FALSE,
  rm_pattern = "__$",
  sep = ",",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dirpath</code></dt><dd><p>default &quot;taxa_abund&quot;; directory to save the taxonomic abundance files. It will be created if not found.</p>
</dd>
<dt><code>merge_all</code></dt><dd><p>default FALSE; Whether merge all tables into one. The merged file format is generally called 'mpa' style.</p>
</dd>
<dt><code>rm_un</code></dt><dd><p>default FALSE; Whether remove unclassified taxa in which the name ends with '__' generally.</p>
</dd>
<dt><code>rm_pattern</code></dt><dd><p>default &quot;__$&quot;; The pattern searched through the merged taxonomic names. See also <code>pattern</code> parameter in <code><a href="base.html#topic+grepl">grepl</a></code> function. 
Only available when <code>rm_un = TRUE</code>. The default &quot;__$&quot; means removing the names end with '__'.</p>
</dd>
<dt><code>sep</code></dt><dd><p>default &quot;,&quot;; the field separator string. Same with <code>sep</code> parameter in <code><a href="utils.html#topic+write.table">write.table</a></code> function.
default <code>','</code> correspond to the file name suffix 'csv'. The option <code>'\t'</code> correspond to the file name suffix 'tsv'. For other options, suffix are all 'txt'.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code><a href="utils.html#topic+write.table">write.table</a></code>.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
m1$save_abund(dirpath = "taxa_abund")
m1$save_abund(merge_all = TRUE, rm_un = TRUE, sep = "\t")
}
</pre>
</div>


<hr>
<a id="method-microtable-cal_alphadiv"></a>



<h4>Method <code>cal_alphadiv()</code></h4>

<p>Calculate alpha diversity.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$cal_alphadiv(measures = NULL, PD = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>measures</code></dt><dd><p>default NULL; one or more indexes in <code>c("Observed", "Coverage", "Chao1", "ACE", "Shannon", "Simpson", "InvSimpson", "Fisher", "Pielou")</code>; 
The default NULL represents that all the measures are calculated. 'Shannon', 'Simpson' and 'InvSimpson' are calculated based on <code>vegan::diversity</code> function;
'Chao1' and 'ACE' depend on the function <code>vegan::estimateR</code>.
'Fisher' index relies on the function <code>vegan::fisher.alpha</code>.
&quot;Observed&quot; means the observed species number in a community, i.e. richness.
&quot;Coverage&quot; represents good's coverage. It is defined:
</p>
<p style="text-align: center;"><code class="reqn">Coverage = 1 - \frac{f1}{n}</code>
</p>
 
<p>where <em>n</em> is the total abundance of a sample, and <em>f1</em> is the number of singleton (species with abundance 1) in the sample.
&quot;Pielou&quot; denotes the Pielou evenness index. It is defined:
</p>
<p style="text-align: center;"><code class="reqn">J = \frac{H'}{\ln(S)}</code>
</p>

<p>where <em>H'</em> is Shannon index, and <em>S</em> is the species number.</p>
</dd>
<dt><code>PD</code></dt><dd><p>default FALSE; whether Faith's phylogenetic diversity is calculated. The calculation depends on the function <code>picante::pd</code>.
Note that the phylogenetic tree (<code>phylo_tree</code> object in the data) is required for PD.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>alpha_diversity stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$cal_alphadiv(measures = NULL, PD = FALSE)
class(m1$alpha_diversity)
}
</pre>
</div>


<hr>
<a id="method-microtable-save_alphadiv"></a>



<h4>Method <code>save_alphadiv()</code></h4>

<p>Save alpha diversity table to the computer.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$save_alphadiv(dirpath = "alpha_diversity")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dirpath</code></dt><dd><p>default &quot;alpha_diversity&quot;; directory name to save the alpha_diversity.csv file.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-microtable-cal_betadiv"></a>



<h4>Method <code>cal_betadiv()</code></h4>

<p>Calculate beta diversity dissimilarity matrix, such as Bray-Curtis, Jaccard, and UniFrac.
See An et al. (2019) &lt;doi:10.1016/j.geoderma.2018.09.035&gt; and Lozupone et al. (2005) &lt;doi:10.1128/AEM.71.12.8228â€“8235.2005&gt;.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$cal_betadiv(method = NULL, unifrac = FALSE, binary = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default NULL; a character vector with one or more elements; <code>c("bray", "jaccard")</code> is used when <code>method = NULL</code>; 
See the <code>method</code> parameter in <code><a href="vegan.html#topic+vegdist">vegdist</a></code> function for more available options, such as 'aitchison' and 'robust.aitchison'.</p>
</dd>
<dt><code>unifrac</code></dt><dd><p>default FALSE; whether UniFrac indexes (weighted and unweighted) are calculated. Phylogenetic tree is necessary when <code>unifrac = TRUE</code>.</p>
</dd>
<dt><code>binary</code></dt><dd><p>default FALSE; Whether convert abundance to binary data (presence/absence) when <code>method</code> is not &quot;jaccard&quot;. 
TRUE is used for &quot;jaccard&quot; automatically.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code><a href="vegan.html#topic+vegdist">vegdist</a></code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>beta_diversity list stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
m1$cal_betadiv(unifrac = FALSE)
class(m1$beta_diversity)
}
</pre>
</div>


<hr>
<a id="method-microtable-save_betadiv"></a>



<h4>Method <code>save_betadiv()</code></h4>

<p>Save beta diversity matrix to the computer.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$save_betadiv(dirpath = "beta_diversity")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dirpath</code></dt><dd><p>default &quot;beta_diversity&quot;; directory name to save the beta diversity matrix files.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-microtable-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the microtable object.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$print()</pre></div>


<hr>
<a id="method-microtable-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>microtable$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `microtable$new`
## ------------------------------------------------

data(otu_table_16S)
data(taxonomy_table_16S)
data(sample_info_16S)
data(phylo_tree_16S)
m1 &lt;- microtable$new(otu_table = otu_table_16S)
m1 &lt;- microtable$new(sample_table = sample_info_16S, otu_table = otu_table_16S, 
  tax_table = taxonomy_table_16S, phylo_tree = phylo_tree_16S)
# trim the files in the dataset
m1$tidy_dataset()

## ------------------------------------------------
## Method `microtable$filter_pollution`
## ------------------------------------------------

m1$filter_pollution(taxa = c("mitochondria", "chloroplast"))

## ------------------------------------------------
## Method `microtable$filter_taxa`
## ------------------------------------------------


d1 &lt;- clone(m1)
d1$filter_taxa(rel_abund = 0.0001, freq = 0.2)


## ------------------------------------------------
## Method `microtable$rarefy_samples`
## ------------------------------------------------


m1$rarefy_samples(sample.size = min(m1$sample_sums()), replace = TRUE)


## ------------------------------------------------
## Method `microtable$tidy_dataset`
## ------------------------------------------------

m1$tidy_dataset(main_data = TRUE)

## ------------------------------------------------
## Method `microtable$add_rownames2taxonomy`
## ------------------------------------------------


m1$add_rownames2taxonomy()


## ------------------------------------------------
## Method `microtable$sample_sums`
## ------------------------------------------------


m1$sample_sums()


## ------------------------------------------------
## Method `microtable$taxa_sums`
## ------------------------------------------------


m1$taxa_sums()


## ------------------------------------------------
## Method `microtable$sample_names`
## ------------------------------------------------


m1$sample_names()


## ------------------------------------------------
## Method `microtable$taxa_names`
## ------------------------------------------------


m1$taxa_names()


## ------------------------------------------------
## Method `microtable$rename_taxa`
## ------------------------------------------------


m1$rename_taxa()


## ------------------------------------------------
## Method `microtable$merge_samples`
## ------------------------------------------------


m1$merge_samples(use_group = "Group")


## ------------------------------------------------
## Method `microtable$merge_taxa`
## ------------------------------------------------


m1$merge_taxa(taxa = "Genus")


## ------------------------------------------------
## Method `microtable$save_table`
## ------------------------------------------------

## Not run: 
m1$save_table()

## End(Not run)

## ------------------------------------------------
## Method `microtable$cal_abund`
## ------------------------------------------------


m1$cal_abund()


## ------------------------------------------------
## Method `microtable$save_abund`
## ------------------------------------------------

## Not run: 
m1$save_abund(dirpath = "taxa_abund")
m1$save_abund(merge_all = TRUE, rm_un = TRUE, sep = "\t")

## End(Not run)

## ------------------------------------------------
## Method `microtable$cal_alphadiv`
## ------------------------------------------------


m1$cal_alphadiv(measures = NULL, PD = FALSE)
class(m1$alpha_diversity)


## ------------------------------------------------
## Method `microtable$cal_betadiv`
## ------------------------------------------------


m1$cal_betadiv(unifrac = FALSE)
class(m1$beta_diversity)

</code></pre>

<hr>
<h2 id='otu_table_16S'>The OTU table of the 16S example data</h2><span id='topic+otu_table_16S'></span>

<h3>Description</h3>

<p>The OTU table of the 16S example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(otu_table_16S)
</code></pre>

<hr>
<h2 id='otu_table_ITS'>The OTU table of the ITS example data</h2><span id='topic+otu_table_ITS'></span>

<h3>Description</h3>

<p>The OTU table of the ITS example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(otu_table_ITS)
</code></pre>

<hr>
<h2 id='phylo_tree_16S'>The phylogenetic tree of 16S example data</h2><span id='topic+phylo_tree_16S'></span>

<h3>Description</h3>

<p>The phylogenetic tree of 16S example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(phylo_tree_16S)
</code></pre>

<hr>
<h2 id='prok_func_FAPROTAX'>The modified FAPROTAX trait database</h2><span id='topic+prok_func_FAPROTAX'></span>

<h3>Description</h3>

<p>The modified FAPROTAX trait database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(prok_func_FAPROTAX)
</code></pre>

<hr>
<h2 id='prok_func_NJC19_list'>The modified NJC19 database</h2><span id='topic+prok_func_NJC19_list'></span>

<h3>Description</h3>

<p>The modified NJC19 database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(prok_func_NJC19_list)
</code></pre>

<hr>
<h2 id='sample_info_16S'>The sample information of 16S example data</h2><span id='topic+sample_info_16S'></span>

<h3>Description</h3>

<p>The sample information of 16S example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sample_info_16S)
</code></pre>

<hr>
<h2 id='sample_info_ITS'>The sample information of ITS example data</h2><span id='topic+sample_info_ITS'></span>

<h3>Description</h3>

<p>The sample information of ITS example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sample_info_ITS)
</code></pre>

<hr>
<h2 id='Tax4Fun2_KEGG'>The KEGG data files used in the trans_func class</h2><span id='topic+Tax4Fun2_KEGG'></span>

<h3>Description</h3>

<p>The KEGG data files used in the trans_func class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Tax4Fun2_KEGG)
</code></pre>

<hr>
<h2 id='taxonomy_table_16S'>The taxonomic information of 16S example data</h2><span id='topic+taxonomy_table_16S'></span>

<h3>Description</h3>

<p>The taxonomic information of 16S example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(taxonomy_table_16S)
</code></pre>

<hr>
<h2 id='taxonomy_table_ITS'>The taxonomic information of ITS example data</h2><span id='topic+taxonomy_table_ITS'></span>

<h3>Description</h3>

<p>The taxonomic information of ITS example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(taxonomy_table_ITS)
</code></pre>

<hr>
<h2 id='tidy_taxonomy'>Clean up the taxonomic table to make taxonomic assignments consistent.</h2><span id='topic+tidy_taxonomy'></span>

<h3>Description</h3>

<p>Clean up the taxonomic table to make taxonomic assignments consistent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_taxonomy(
  taxonomy_table,
  column = "all",
  pattern = c(".*unassigned.*", ".*uncultur.*", ".*unknown.*", ".*unidentif.*",
    ".*unclassified.*", ".*No blast hit.*", ".*Incertae.sedis.*"),
  replacement = "",
  ignore.case = TRUE,
  na_fill = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_taxonomy_+3A_taxonomy_table">taxonomy_table</code></td>
<td>
<p>a data.frame with taxonomic information.</p>
</td></tr>
<tr><td><code id="tidy_taxonomy_+3A_column">column</code></td>
<td>
<p>default &quot;all&quot;; &quot;all&quot; or a number; 'all' represents cleaning up all the columns; a number represents cleaning up this column.</p>
</td></tr>
<tr><td><code id="tidy_taxonomy_+3A_pattern">pattern</code></td>
<td>
<p>default c(&quot;.*unassigned.*&quot;, &quot;.*uncultur.*&quot;, &quot;.*unknown.*&quot;, &quot;.*unidentif.*&quot;, &quot;.*unclassified.*&quot;, &quot;.*No blast hit.*&quot;, &quot;.*Incertae.sedis.*&quot;); 
the characters (regular expressions) to be removed or replaced; removed when parameter <code>replacement = ""</code>, 
replaced when parameter replacement has something; Note that the capital and small letters are not distinguished when <code>ignore.case = TRUE</code>.</p>
</td></tr>
<tr><td><code id="tidy_taxonomy_+3A_replacement">replacement</code></td>
<td>
<p>default &quot;&quot;; the characters used to replace the character in <code>pattern</code> parameter.</p>
</td></tr>
<tr><td><code id="tidy_taxonomy_+3A_ignore.case">ignore.case</code></td>
<td>
<p>default TRUE; if FALSE, the pattern matching is case sensitive and if TRUE, case is ignored during matching.</p>
</td></tr>
<tr><td><code id="tidy_taxonomy_+3A_na_fill">na_fill</code></td>
<td>
<p>default &quot;&quot;; used to replace <code>NA</code>.</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code> object.
</p>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("taxonomy_table_16S")
tidy_taxonomy(taxonomy_table_16S)
</code></pre>

<hr>
<h2 id='trans_abund'>Create <code>trans_abund</code> object for plotting taxonomic abundance.</h2><span id='topic+trans_abund'></span>

<h3>Description</h3>

<p>This class is a wrapper for the taxonomic abundance transformations and visualization.
The converted data style is the long-format for <code>ggplot2</code> plot.
The plotting methods include bar plot, boxplot, heatmap, pie chart and line chart.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_abund-new"><code>trans_abund$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-plot_bar"><code>trans_abund$plot_bar()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-plot_heatmap"><code>trans_abund$plot_heatmap()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-plot_box"><code>trans_abund$plot_box()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-plot_line"><code>trans_abund$plot_line()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-plot_pie"><code>trans_abund$plot_pie()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-plot_donut"><code>trans_abund$plot_donut()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-plot_radar"><code>trans_abund$plot_radar()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-plot_tern"><code>trans_abund$plot_tern()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-print"><code>trans_abund$print()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_abund-clone"><code>trans_abund$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_abund-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>trans_abund$new(
  dataset = NULL,
  taxrank = "Phylum",
  show = 0,
  ntaxa = 10,
  groupmean = NULL,
  group_morestats = FALSE,
  delete_taxonomy_lineage = TRUE,
  delete_taxonomy_prefix = TRUE,
  prefix = NULL,
  use_percentage = TRUE,
  input_taxaname = NULL,
  high_level = NULL,
  high_level_fix_nsub = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>default NULL; the object of <code><a href="#topic+microtable">microtable</a></code> class.</p>
</dd>
<dt><code>taxrank</code></dt><dd><p>default &quot;Phylum&quot;; taxonomic rank.</p>
</dd>
<dt><code>show</code></dt><dd><p>default 0; the relative abundance threshold for filtering the taxa with low abundance.</p>
</dd>
<dt><code>ntaxa</code></dt><dd><p>default 10; how many taxa are selected to show. Taxa are ordered by abundance from high to low. 
This parameter does not conflict with the parameter <code>show</code>. Both can be used. <code>ntaxa = NULL</code> means it is unavailable.</p>
</dd>
<dt><code>groupmean</code></dt><dd><p>default NULL; calculate mean abundance for each group. Select a column name in <code>microtable$sample_table</code>.</p>
</dd>
<dt><code>group_morestats</code></dt><dd><p>default FALSE; only available when <code>groupmean</code> parameter is provided; 
Whether output more statistics for each group, including min, max, median and quantile;
Thereinto, quantile25 and quantile75 denote 25% and 75% quantiles, respectively.</p>
</dd>
<dt><code>delete_taxonomy_lineage</code></dt><dd><p>default TRUE; whether delete the taxonomy lineage in front of the target level.</p>
</dd>
<dt><code>delete_taxonomy_prefix</code></dt><dd><p>default TRUE; whether delete the prefix of taxonomy, such as &quot;g__&quot;.</p>
</dd>
<dt><code>prefix</code></dt><dd><p>default NULL; character string; available when <code>delete_taxonomy_prefix = T</code>; 
default NULL reprensents using the &quot;letter+__&quot;, e.g. &quot;k__&quot; for Phylum level;
Please provide the customized prefix when it is not standard, otherwise the program can not correctly recognize it.</p>
</dd>
<dt><code>use_percentage</code></dt><dd><p>default TRUE; show the abundance percentage.</p>
</dd>
<dt><code>input_taxaname</code></dt><dd><p>default NULL; character vector; input taxa names for selecting some taxa.</p>
</dd>
<dt><code>high_level</code></dt><dd><p>default NULL; a taxonomic rank, such as &quot;Phylum&quot;, used to add the taxonomic information of higher level.
It is necessary for the legend with nested taxonomic levels in the bar plot.</p>
</dd>
<dt><code>high_level_fix_nsub</code></dt><dd><p>default NULL; an integer, used to fix the number of selected abundant taxa in each taxon from higher taxonomic level.
If the total number under one taxon of higher level is less than the high_level_fix_nsub, the total number will be used.
When <code>high_level_fix_nsub</code> is provided, the taxa number of higher level is calculated as: <code>ceiling(ntaxa/high_level_fix_nsub)</code>.
Note that <code>ntaxa</code> means either the parameter <code>ntaxa</code> or the taxonomic number obtained by filtering according to the <code>show</code> parameter.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data_abund</code> stored in the object. The column 'all_mean_abund' reprensents mean relative abundance across all the samples.
So the values in one taxon are all same across all the samples.
If the sum of column 'Abundance' in one sample is larger than 1, the 'Abundance', 'SD' and 'SE' has been multiplied by 100.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
data(dataset)
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 10)
}
</pre>
</div>


<hr>
<a id="method-trans_abund-plot_bar"></a>



<h4>Method <code>plot_bar()</code></h4>

<p>Bar plot.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$plot_bar(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  bar_type = "full",
  others_color = "grey90",
  facet = NULL,
  order_x = NULL,
  x_axis_name = NULL,
  barwidth = NULL,
  use_alluvium = FALSE,
  clustering = FALSE,
  clustering_plot = FALSE,
  cluster_plot_width = 0.2,
  facet_color = "grey95",
  strip_text = 11,
  legend_text_italic = FALSE,
  xtext_angle = 0,
  xtext_size = 10,
  xtext_keep = TRUE,
  xtitle_keep = TRUE,
  ytitle_size = 17,
  coord_flip = FALSE,
  ggnested = FALSE,
  high_level_add_other = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette for the bars.</p>
</dd>
<dt><code>bar_type</code></dt><dd><p>default &quot;full&quot;; &quot;full&quot; or &quot;notfull&quot;; if <code>"full"</code>, total abundance are summed to 1 or 100 percentage.</p>
</dd>
<dt><code>others_color</code></dt><dd><p>default &quot;grey90&quot;; the color for &quot;others&quot; taxa.</p>
</dd>
<dt><code>facet</code></dt><dd><p>default NULL; a character vector for the facet; group column name of <code>sample_table</code>, such as, <code>"Group"</code>;
If multiple facets are needed, please provide ordered names, such as <code>c("Group", "Type")</code>.
The latter should have a finer scale than the former one;
Please adjust the facet orders in the plot by assigning factors in <code>sample_table</code> before creating <code>trans_abund</code> object or 
assigning factors in the <code>data_abund</code> table of <code>trans_abund</code> object.
When multiple facets are used, please first install package <code>ggh4x</code> using the command <code>install.packages("ggh4x")</code>.</p>
</dd>
<dt><code>order_x</code></dt><dd><p>default NULL; vector; used to order the sample names in x axis; must be the samples vector, such as <code>c("S1", "S3", "S2")</code>.</p>
</dd>
<dt><code>x_axis_name</code></dt><dd><p>NULL; a character string; a column name of sample_table in dataset; used to show the sample names in x axis.</p>
</dd>
<dt><code>barwidth</code></dt><dd><p>default NULL; bar width, see <code>width</code> in <code><a href="ggplot2.html#topic+geom_bar">geom_bar</a></code>.</p>
</dd>
<dt><code>use_alluvium</code></dt><dd><p>default FALSE; whether add alluvium plot. If <code>TRUE</code>, please first install <code>ggalluvial</code> package.</p>
</dd>
<dt><code>clustering</code></dt><dd><p>default FALSE; whether order samples by the clustering.</p>
</dd>
<dt><code>clustering_plot</code></dt><dd><p>default FALSE; whether add clustering plot.
If <code>clustering_plot = TRUE</code>, <code>clustering</code> will be also TRUE in any case for the clustering.</p>
</dd>
<dt><code>cluster_plot_width</code></dt><dd><p>default 0.2, the dendrogram plot width; available when <code>clustering_plot = TRUE</code>.</p>
</dd>
<dt><code>facet_color</code></dt><dd><p>default &quot;grey95&quot;; facet background color.</p>
</dd>
<dt><code>strip_text</code></dt><dd><p>default 11; facet text size.</p>
</dd>
<dt><code>legend_text_italic</code></dt><dd><p>default FALSE; whether use italic in legend.</p>
</dd>
<dt><code>xtext_angle</code></dt><dd><p>default 0; number ranging from 0 to 90; used to adjust x axis text angle to reduce text overlap;</p>
</dd>
<dt><code>xtext_size</code></dt><dd><p>default 10; x axis text size.</p>
</dd>
<dt><code>xtext_keep</code></dt><dd><p>default TRUE; whether retain x text.</p>
</dd>
<dt><code>xtitle_keep</code></dt><dd><p>default TRUE; whether retain x title.</p>
</dd>
<dt><code>ytitle_size</code></dt><dd><p>default 17; y axis title size.</p>
</dd>
<dt><code>coord_flip</code></dt><dd><p>default FALSE; whether flip cartesian coordinates so that horizontal becomes vertical, and vertical becomes horizontal.</p>
</dd>
<dt><code>ggnested</code></dt><dd><p>default FALSE; whether use nested legend. Need <code>ggnested</code> package to be installed (https://github.com/gmteunisse/ggnested).
To make it available, please assign <code>high_level</code> parameter when creating the object.</p>
</dd>
<dt><code>high_level_add_other</code></dt><dd><p>default FALSE; whether add 'Others' (all the unknown taxa) in each taxon of higher taxonomic level.
Only available when <code>ggnested = TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_bar(facet = "Group", xtext_keep = FALSE)
}
</pre>
</div>


<hr>
<a id="method-trans_abund-plot_heatmap"></a>



<h4>Method <code>plot_heatmap()</code></h4>

<p>Plot the heatmap.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$plot_heatmap(
  color_values = rev(RColorBrewer::brewer.pal(n = 11, name = "RdYlBu")),
  facet = NULL,
  x_axis_name = NULL,
  order_x = NULL,
  withmargin = TRUE,
  plot_numbers = FALSE,
  plot_text_size = 4,
  plot_breaks = NULL,
  margincolor = "white",
  plot_colorscale = "log10",
  min_abundance = 0.01,
  max_abundance = NULL,
  strip_text = 11,
  xtext_size = 10,
  ytext_size = 11,
  xtext_keep = TRUE,
  xtitle_keep = TRUE,
  grid_clean = TRUE,
  xtext_angle = 0,
  legend_title = "% Relative\nAbundance",
  pheatmap = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default rev(RColorBrewer::brewer.pal(n = 11, name = &quot;RdYlBu&quot;)); 
colors palette for the plotting.</p>
</dd>
<dt><code>facet</code></dt><dd><p>default NULL; a character vector for the facet; a group column name of <code>sample_table</code>, such as, <code>"Group"</code>;
If multiple facets are needed, please provide ordered names, such as <code>c("Group", "Type")</code>.
The latter should have a finer scale than the former one;
Please adjust the facet orders in the plot by assigning factors in <code>sample_table</code> before creating <code>trans_abund</code> object or 
assigning factors in the <code>data_abund</code> table of <code>trans_abund</code> object.
When multiple facets are used, please first install package <code>ggh4x</code> using the command <code>install.packages("ggh4x")</code>.</p>
</dd>
<dt><code>x_axis_name</code></dt><dd><p>NULL; a character string; a column name of sample_table used to show the sample names in x axis.</p>
</dd>
<dt><code>order_x</code></dt><dd><p>default NULL; vector; used to order the sample names in x axis; must be the samples vector, such as, c(&quot;S1&quot;, &quot;S3&quot;, &quot;S2&quot;).</p>
</dd>
<dt><code>withmargin</code></dt><dd><p>default TRUE; whether retain the tile margin.</p>
</dd>
<dt><code>plot_numbers</code></dt><dd><p>default FALSE; whether plot the number in heatmap.</p>
</dd>
<dt><code>plot_text_size</code></dt><dd><p>default 4; If plot_numbers TRUE, text size in plot.</p>
</dd>
<dt><code>plot_breaks</code></dt><dd><p>default NULL; The legend breaks.</p>
</dd>
<dt><code>margincolor</code></dt><dd><p>default &quot;white&quot;; If withmargin TRUE, use this as the margin color.</p>
</dd>
<dt><code>plot_colorscale</code></dt><dd><p>default &quot;log10&quot;; color scale.</p>
</dd>
<dt><code>min_abundance</code></dt><dd><p>default .01; the minimum abundance percentage in plot.</p>
</dd>
<dt><code>max_abundance</code></dt><dd><p>default NULL; the maximum abundance percentage in plot, NULL reprensent the max percentage.</p>
</dd>
<dt><code>strip_text</code></dt><dd><p>default 11; facet text size.</p>
</dd>
<dt><code>xtext_size</code></dt><dd><p>default 10; x axis text size.</p>
</dd>
<dt><code>ytext_size</code></dt><dd><p>default 11; y axis text size.</p>
</dd>
<dt><code>xtext_keep</code></dt><dd><p>default TRUE; whether retain x text.</p>
</dd>
<dt><code>xtitle_keep</code></dt><dd><p>default TRUE; whether retain x title.</p>
</dd>
<dt><code>grid_clean</code></dt><dd><p>default TRUE; whether remove grid lines.</p>
</dd>
<dt><code>xtext_angle</code></dt><dd><p>default 0; number ranging from 0 to 90; used to adjust x axis text angle to reduce text overlap;</p>
</dd>
<dt><code>legend_title</code></dt><dd><p>default &quot;% Relative\nAbundance&quot;; legend title text.</p>
</dd>
<dt><code>pheatmap</code></dt><dd><p>default FALSE; whether use pheatmap package to plot the heatmap.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters pass to pheatmap when pheatmap = TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 object or grid object based on pheatmap.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Genus", ntaxa = 40)
t1$plot_heatmap(facet = "Group", xtext_keep = FALSE, withmargin = FALSE)
}
</pre>
</div>


<hr>
<a id="method-trans_abund-plot_box"></a>



<h4>Method <code>plot_box()</code></h4>

<p>Box plot.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$plot_box(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  group = NULL,
  show_point = FALSE,
  point_color = "black",
  point_size = 3,
  point_alpha = 0.3,
  plot_flip = FALSE,
  boxfill = TRUE,
  middlecolor = "grey95",
  middlesize = 1,
  xtext_angle = 0,
  xtext_size = 10,
  ytitle_size = 17,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette for the box.</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; a column name of sample table to show abundance across groups.</p>
</dd>
<dt><code>show_point</code></dt><dd><p>default FALSE; whether show points in plot.</p>
</dd>
<dt><code>point_color</code></dt><dd><p>default &quot;black&quot;; If show_point TRUE; use the color</p>
</dd>
<dt><code>point_size</code></dt><dd><p>default 3; If show_point TRUE; use the size</p>
</dd>
<dt><code>point_alpha</code></dt><dd><p>default .3; If show_point TRUE; use the transparency.</p>
</dd>
<dt><code>plot_flip</code></dt><dd><p>default FALSE; Whether rotate plot.</p>
</dd>
<dt><code>boxfill</code></dt><dd><p>default TRUE; Whether fill the box with colors.</p>
</dd>
<dt><code>middlecolor</code></dt><dd><p>default &quot;grey95&quot;; The middle line color.</p>
</dd>
<dt><code>middlesize</code></dt><dd><p>default 1; The middle line size.</p>
</dd>
<dt><code>xtext_angle</code></dt><dd><p>default 0; number ranging from 0 to 90; used to adjust x axis text angle to reduce text overlap;</p>
</dd>
<dt><code>xtext_size</code></dt><dd><p>default 10; x axis text size.</p>
</dd>
<dt><code>ytitle_size</code></dt><dd><p>default 17; y axis title size.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to <code><a href="ggplot2.html#topic+geom_boxplot">geom_boxplot</a></code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_box(group = "Group")
}
</pre>
</div>


<hr>
<a id="method-trans_abund-plot_line"></a>



<h4>Method <code>plot_line()</code></h4>

<p>Plot the line chart.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$plot_line(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  plot_SE = TRUE,
  position = position_dodge(0.1),
  errorbar_size = 1,
  errorbar_width = 0.1,
  point_size = 3,
  point_alpha = 0.8,
  line_size = 0.8,
  line_alpha = 0.8,
  line_type = 1,
  xtext_angle = 0,
  xtext_size = 10,
  ytitle_size = 17
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette for the points and lines.</p>
</dd>
<dt><code>plot_SE</code></dt><dd><p>default TRUE; TRUE: the errorbar is <code class="reqn">meanÂ±se</code>; FALSE: the errorbar is <code class="reqn">meanÂ±sd</code>.</p>
</dd>
<dt><code>position</code></dt><dd><p>default position_dodge(0.1); Position adjustment, either as a string (such as &quot;identity&quot;), or the result of a call to a position adjustment function.</p>
</dd>
<dt><code>errorbar_size</code></dt><dd><p>default 1; errorbar line size.</p>
</dd>
<dt><code>errorbar_width</code></dt><dd><p>default 0.1; errorbar width.</p>
</dd>
<dt><code>point_size</code></dt><dd><p>default 3; point size for taxa.</p>
</dd>
<dt><code>point_alpha</code></dt><dd><p>default 0.8; point transparency.</p>
</dd>
<dt><code>line_size</code></dt><dd><p>default 0.8; line size.</p>
</dd>
<dt><code>line_alpha</code></dt><dd><p>default 0.8; line transparency.</p>
</dd>
<dt><code>line_type</code></dt><dd><p>default 1; an integer; line type.</p>
</dd>
<dt><code>xtext_angle</code></dt><dd><p>default 0; number ranging from 0 to 90; used to adjust x axis text angle to reduce text overlap;</p>
</dd>
<dt><code>xtext_size</code></dt><dd><p>default 10; x axis text size.</p>
</dd>
<dt><code>ytitle_size</code></dt><dd><p>default 17; y axis title size.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Genus", ntaxa = 5)
t1$plot_line(point_size = 3)
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Genus", ntaxa = 5, groupmean = "Group")
t1$plot_line(point_size = 5, errorbar_size = 1, xtext_angle = 30)
}
</pre>
</div>


<hr>
<a id="method-trans_abund-plot_pie"></a>



<h4>Method <code>plot_pie()</code></h4>

<p>Pie chart.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$plot_pie(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  facet_nrow = 1,
  strip_text = 11,
  add_label = FALSE,
  legend_text_italic = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette for each section.</p>
</dd>
<dt><code>facet_nrow</code></dt><dd><p>default 1; how many rows in the plot.</p>
</dd>
<dt><code>strip_text</code></dt><dd><p>default 11; sample title size.</p>
</dd>
<dt><code>add_label</code></dt><dd><p>default FALSE; Whether add the percentage label in each section of pie chart.</p>
</dd>
<dt><code>legend_text_italic</code></dt><dd><p>default FALSE; whether use italic in legend.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 6, groupmean = "Group")
t1$plot_pie(facet_nrow = 1)
}
</pre>
</div>


<hr>
<a id="method-trans_abund-plot_donut"></a>



<h4>Method <code>plot_donut()</code></h4>

<p>Donut chart based on the <code>ggpubr::ggdonutchart</code> function.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$plot_donut(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  label = TRUE,
  facet_nrow = 1,
  legend_text_italic = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette for the donut.</p>
</dd>
<dt><code>label</code></dt><dd><p>default TRUE; whether show the percentage label.</p>
</dd>
<dt><code>facet_nrow</code></dt><dd><p>default 1; how many rows in the plot.</p>
</dd>
<dt><code>legend_text_italic</code></dt><dd><p>default FALSE; whether use italic in legend.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>ggpubr::ggdonutchart</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>combined ggplot2 objects list, generated by <code>ggpubr::ggarrange</code> function.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 6, groupmean = "Group")
t1$plot_donut(label = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_abund-plot_radar"></a>



<h4>Method <code>plot_radar()</code></h4>

<p>Radar chart based on the <code>ggradar</code> package (https://github.com/ricardo-bion/ggradar).
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$plot_radar(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette for samples.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>ggradar::ggradar</code> function except group.colours parameter.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 6, groupmean = "Group")
t1$plot_radar()
}
</pre>
</div>


<hr>
<a id="method-trans_abund-plot_tern"></a>



<h4>Method <code>plot_tern()</code></h4>

<p>Ternary diagrams based on the <code>ggtern</code> package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$plot_tern(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  color_legend_guide_size = 4
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette for the samples.</p>
</dd>
<dt><code>color_legend_guide_size</code></dt><dd><p>default 4; The size of legend guide for color.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 6, groupmean = "Group")
t1$plot_tern()
}
</pre>
</div>


<hr>
<a id="method-trans_abund-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the trans_abund object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$print()</pre></div>


<hr>
<a id="method-trans_abund-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_abund$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_abund$new`
## ------------------------------------------------


data(dataset)
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 10)


## ------------------------------------------------
## Method `trans_abund$plot_bar`
## ------------------------------------------------


t1$plot_bar(facet = "Group", xtext_keep = FALSE)


## ------------------------------------------------
## Method `trans_abund$plot_heatmap`
## ------------------------------------------------


t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Genus", ntaxa = 40)
t1$plot_heatmap(facet = "Group", xtext_keep = FALSE, withmargin = FALSE)


## ------------------------------------------------
## Method `trans_abund$plot_box`
## ------------------------------------------------


t1$plot_box(group = "Group")


## ------------------------------------------------
## Method `trans_abund$plot_line`
## ------------------------------------------------


t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Genus", ntaxa = 5)
t1$plot_line(point_size = 3)
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Genus", ntaxa = 5, groupmean = "Group")
t1$plot_line(point_size = 5, errorbar_size = 1, xtext_angle = 30)


## ------------------------------------------------
## Method `trans_abund$plot_pie`
## ------------------------------------------------


t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 6, groupmean = "Group")
t1$plot_pie(facet_nrow = 1)


## ------------------------------------------------
## Method `trans_abund$plot_donut`
## ------------------------------------------------

## Not run: 
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 6, groupmean = "Group")
t1$plot_donut(label = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `trans_abund$plot_radar`
## ------------------------------------------------

## Not run: 
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 6, groupmean = "Group")
t1$plot_radar()

## End(Not run)

## ------------------------------------------------
## Method `trans_abund$plot_tern`
## ------------------------------------------------

## Not run: 
t1 &lt;- trans_abund$new(dataset = dataset, taxrank = "Phylum", ntaxa = 6, groupmean = "Group")
t1$plot_tern()

## End(Not run)
</code></pre>

<hr>
<h2 id='trans_alpha'>Create <code>trans_alpha</code> object for alpha diversity statistics and plot.</h2><span id='topic+trans_alpha'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of alpha diversity analysis, including the statistics and visualization.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_alpha-new"><code>trans_alpha$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_alpha-cal_diff"><code>trans_alpha$cal_diff()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_alpha-plot_alpha"><code>trans_alpha$plot_alpha()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_alpha-print"><code>trans_alpha$print()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_alpha-clone"><code>trans_alpha$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_alpha-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>trans_alpha$new(
  dataset = NULL,
  group = NULL,
  by_group = NULL,
  by_ID = NULL,
  order_x = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>the object of <code><a href="#topic+microtable">microtable</a></code> class.</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; a column of <code>sample_table</code> used for the statistics; If provided, can return <code>data_stat</code>.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>default NULL; a column of <code>sample_table</code> used to perform the differential test 
among groups (<code>group</code> parameter) for each group (<code>by_group</code> parameter). So <code>by_group</code> has a higher level than <code>group</code> parameter.</p>
</dd>
<dt><code>by_ID</code></dt><dd><p>default NULL; a column of <code>sample_table</code> used to perform paired t test or paired wilcox test for the paired data,
such as the data of plant compartments for different plant species (ID). 
So <code>by_ID</code> in sample_table should be the smallest unit of sample collection without any repetition in it.</p>
</dd>
<dt><code>order_x</code></dt><dd><p>default NULL; a <code>sample_table</code> column name or a vector with sample names; if provided, order samples by using <code>factor</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data_alpha</code> and <code>data_stat</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
data(dataset)
t1 &lt;- trans_alpha$new(dataset = dataset, group = "Group")
}
</pre>
</div>


<hr>
<a id="method-trans_alpha-cal_diff"></a>



<h4>Method <code>cal_diff()</code></h4>

<p>Differential test on alpha diversity.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_alpha$cal_diff(
  method = c("KW", "KW_dunn", "wilcox", "t.test", "anova", "scheirerRayHare", "lm",
    "lme", "betareg", "glmm", "glmm_beta")[1],
  measure = NULL,
  p_adjust_method = "fdr",
  formula = NULL,
  KW_dunn_letter = TRUE,
  alpha = 0.05,
  anova_post_test = "duncan.test",
  return_model = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default &quot;KW&quot;; see the following available options:
</p>

<dl>
<dt><strong>'KW'</strong></dt><dd><p>Kruskal-Wallis Rank Sum Test for all groups (&gt;= 2)</p>
</dd>
<dt><strong>'KW_dunn'</strong></dt><dd><p>Dunn's Kruskal-Wallis Multiple Comparisons &lt;10.1080/00401706.1964.10490181&gt; based on <code>dunnTest</code> function in <code>FSA</code> package</p>
</dd>
<dt><strong>'wilcox'</strong></dt><dd><p>Wilcoxon Rank Sum Test for all paired groups</p>
</dd>
<dt><strong>'t.test'</strong></dt><dd><p>Student's t-Test for all paired groups</p>
</dd>
<dt><strong>'anova'</strong></dt><dd><p>Variance analysis. For one-way anova, the post hoc test is Duncan's new multiple range test 
based on <code>duncan.test</code> function of <code>agricolae</code> package. Please use <code>anova_post_test</code> parameter to select other post hoc method.
For multi-way anova, Please use <code>formula</code> parameter to specify the model and see <code><a href="stats.html#topic+aov">aov</a></code> for more details</p>
</dd>
<dt><strong>'scheirerRayHare'</strong></dt><dd><p>Scheirer Ray Hare test (nonparametric test) for a two-way factorial experiment; 
see <code>scheirerRayHare</code> function of <code>rcompanion</code> package</p>
</dd>
<dt><strong>'lm'</strong></dt><dd><p>Linear Model based on the <code>lm</code> function</p>
</dd>
<dt><strong>'lme'</strong></dt><dd><p>Linear Mixed Effect Model based on the <code>lmerTest</code> package</p>
</dd>
<dt><strong>'betareg'</strong></dt><dd><p>Beta Regression for Rates and Proportions based on the <code>betareg</code> package</p>
</dd>
<dt><strong>'glmm'</strong></dt><dd><p>Generalized linear mixed model (GLMM) based on the <code>glmmTMB</code> package</p>
</dd>
<dt><strong>'glmm_beta'</strong></dt><dd><p>Generalized linear mixed model (GLMM) with a family function of beta distribution. 
This is an extension of the GLMM model in <code>'glmm'</code> option. 
The only difference is in <code>glmm_beta</code> the family function is fixed with the beta distribution function, 
facilitating the fitting for proportional data (ranging from 0 to 1). The link function is fixed with <code>"logit"</code>.</p>
</dd>
</dl>
</dd>
<dt><code>measure</code></dt><dd><p>default NULL; character vector; If NULL, all indexes will be calculated; see names of <code>microtable$alpha_diversity</code>, 
e.g. c(&quot;Observed&quot;, &quot;Chao1&quot;, &quot;Shannon&quot;).</p>
</dd>
<dt><code>p_adjust_method</code></dt><dd><p>default &quot;fdr&quot; (for &quot;KW&quot;, &quot;wilcox&quot;, &quot;t.test&quot;) or &quot;holm&quot; (for &quot;KW_dunn&quot;); P value adjustment method; 
For <code>method = 'KW', 'wilcox' or 't.test'</code>, please see method parameter of <code>p.adjust</code> function for available options;
For <code>method = 'KW_dunn'</code>, please see <code>dunn.test::p.adjustment.methods</code> for available options.</p>
</dd>
<dt><code>formula</code></dt><dd><p>default NULL; applied to two-way or multi-factor anova when 
method = <code>"anova"</code> or <code>"scheirerRayHare"</code> or <code>"lme"</code> or <code>"betareg"</code> or <code>"glmm"</code>; 
specified set for independent variables, i.e. the latter part of a general formula, 
such as <code>'block + N*P*K'</code>.</p>
</dd>
<dt><code>KW_dunn_letter</code></dt><dd><p>default TRUE; For <code>method = 'KW_dunn'</code>, <code>TRUE</code> denotes paired significances are presented by letters;
<code>FALSE</code> means significances are shown by asterisk for paired comparison.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>default 0.05; Significant level; used for generating significance letters when method is 'anova' or 'KW_dunn'.</p>
</dd>
<dt><code>anova_post_test</code></dt><dd><p>default &quot;duncan.test&quot;. The post hoc test method for one-way anova. Other available options include &quot;LSD.test&quot; and &quot;HSD.test&quot;. 
All those are the function names in <code>agricolae</code> package.</p>
</dd>
<dt><code>return_model</code></dt><dd><p>default FALSE; whether return the original lmer or glmm model list in the object.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>kruskal.test</code> (when <code>method = "KW"</code>) or <code>wilcox.test</code> function (when <code>method = "wilcox"</code>) or 
<code>dunnTest</code> function of <code>FSA</code> package (when <code>method = "KW_dunn"</code>) or 
<code>agricolae::duncan.test</code>/<code>agricolae::LSD.test</code>/<code>agricolae::HSD.test</code> (when <code>method = "anova"</code>, one-way anova) or 
<code>rcompanion::scheirerRayHare</code> (when <code>method = "scheirerRayHare"</code>) or 
<code>lmerTest::lmer</code> (when <code>method = "lme"</code>) or 
<code>betareg::betareg</code> (when <code>method = "betareg"</code>) or 
<code>glmmTMB::glmmTMB</code> (when <code>method = "glmm"</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_diff</code>, stored in object with the format <code>data.frame</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_diff(method = "KW")
t1$cal_diff(method = "anova")
t1 &lt;- trans_alpha$new(dataset = dataset, group = "Type", by_group = "Group")
t1$cal_diff(method = "anova")
}
</pre>
</div>


<hr>
<a id="method-trans_alpha-plot_alpha"></a>



<h4>Method <code>plot_alpha()</code></h4>

<p>Plot the alpha diversity. Box plot is used for the visualization of alpha diversity when the <code>group</code> is found in the object.
Heatmap is employed automatically to show the significances of differential test 
when the formula is found in the <code>res_diff</code> table of the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_alpha$plot_alpha(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  measure = "Shannon",
  group = NULL,
  add_sig = TRUE,
  add_sig_label = "Significance",
  add_sig_text_size = 3.88,
  add_sig_label_num_dec = 4,
  boxplot_add = "jitter",
  order_x_mean = FALSE,
  y_start = 0.1,
  y_increase = 0.05,
  xtext_angle = NULL,
  xtext_size = 15,
  ytitle_size = 17,
  barwidth = 0.9,
  use_boxplot = TRUE,
  plot_SE = TRUE,
  errorbar_size = 1,
  errorbar_width = 0.2,
  point_size = 3,
  point_alpha = 0.8,
  add_line = FALSE,
  line_size = 0.8,
  line_type = 1,
  line_color = "grey50",
  line_alpha = 0.5,
  heatmap_cell = "P.unadj",
  heatmap_sig = "Significance",
  heatmap_x = "Factors",
  heatmap_y = "Measure",
  heatmap_lab_fill = "P value",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); color pallete for groups.</p>
</dd>
<dt><code>measure</code></dt><dd><p>default &quot;Shannon&quot;; one alpha diversity index in the object.</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; group name used for the plot.</p>
</dd>
<dt><code>add_sig</code></dt><dd><p>default TRUE; wheter add significance label using the result of <code>cal_diff</code> function, i.e. <code>object$res_diff</code>;
This is manily designed to add post hoc test of anova or other significances to make the label mapping easy.</p>
</dd>
<dt><code>add_sig_label</code></dt><dd><p>default &quot;Significance&quot;; select a colname of <code>object$res_diff</code> for the label text when 'Letter' is not in the table, 
such as 'P.adj' or 'Significance'.</p>
</dd>
<dt><code>add_sig_text_size</code></dt><dd><p>default 3.88; the size of text in added label.</p>
</dd>
<dt><code>add_sig_label_num_dec</code></dt><dd><p>default 4; reserved decimal places when the parameter <code>add_sig_label</code> use numeric column, like 'P.adj'.</p>
</dd>
<dt><code>boxplot_add</code></dt><dd><p>default &quot;jitter&quot;; points type, see the add parameter in <code>ggpubr::ggboxplot</code>.</p>
</dd>
<dt><code>order_x_mean</code></dt><dd><p>default FALSE; whether order x axis by the means of groups from large to small.</p>
</dd>
<dt><code>y_start</code></dt><dd><p>default 0.1; the y axis value from which to add the significance asterisk label; 
the default 0.1 means <code>max(values) + 0.1 * (max(values) - min(values))</code>.</p>
</dd>
<dt><code>y_increase</code></dt><dd><p>default 0.05; the increasing y axia space to add the label (asterisk or letter); the default 0.05 means <code>0.05 * (max(values) - min(values))</code>; 
this parameter is also used to label the letters of anova result with the fixed space.</p>
</dd>
<dt><code>xtext_angle</code></dt><dd><p>default NULL; number (e.g. 30) used to make x axis text generate angle.</p>
</dd>
<dt><code>xtext_size</code></dt><dd><p>default 15; x axis text size.</p>
</dd>
<dt><code>ytitle_size</code></dt><dd><p>default 17; y axis title size.</p>
</dd>
<dt><code>barwidth</code></dt><dd><p>default 0.9; the bar width in plot; applied when by_group is not NULL.</p>
</dd>
<dt><code>use_boxplot</code></dt><dd><p>default TRUE; TRUE denotes boxplot by using the data_alpha table in the object. 
FALSE represents mean-sd or mean-se plot by invoking the data_stat table in the object.</p>
</dd>
<dt><code>plot_SE</code></dt><dd><p>default TRUE; TRUE: the errorbar is <code class="reqn">meanÂ±se</code>; FALSE: the errorbar is <code class="reqn">meanÂ±sd</code>.</p>
</dd>
<dt><code>errorbar_size</code></dt><dd><p>default 1; errorbar size. Available when <code>use_boxplot = FALSE</code>.</p>
</dd>
<dt><code>errorbar_width</code></dt><dd><p>default 0.2; errorbar width. Available when <code>use_boxplot = FALSE</code> and <code>by_group</code> is NULL.</p>
</dd>
<dt><code>point_size</code></dt><dd><p>default 3; point size for taxa. Available when <code>use_boxplot = FALSE</code>.</p>
</dd>
<dt><code>point_alpha</code></dt><dd><p>default 0.8; point transparency. Available when <code>use_boxplot = FALSE</code>.</p>
</dd>
<dt><code>add_line</code></dt><dd><p>default FALSE; whether add line. Available when <code>use_boxplot = FALSE</code>.</p>
</dd>
<dt><code>line_size</code></dt><dd><p>default 0.8; line size when <code>add_line = TRUE</code>. Available when <code>use_boxplot = FALSE</code>.</p>
</dd>
<dt><code>line_type</code></dt><dd><p>default 1; an integer; line type when <code>add_line = TRUE</code>. Available when <code>use_boxplot = FALSE</code>.</p>
</dd>
<dt><code>line_color</code></dt><dd><p>default &quot;grey50&quot;; line color when <code>add_line = TRUE</code>. Available when <code>use_boxplot = FALSE</code> and <code>by_group</code> is NULL.</p>
</dd>
<dt><code>line_alpha</code></dt><dd><p>default 0.5; line transparency when <code>add_line = TRUE</code>. Available when <code>use_boxplot = FALSE</code>.</p>
</dd>
<dt><code>heatmap_cell</code></dt><dd><p>default &quot;P.unadj&quot;; the column of <code>res_diff</code> table for the cell of heatmap when formula with multiple factors is found in the method.</p>
</dd>
<dt><code>heatmap_sig</code></dt><dd><p>default &quot;Significance&quot;; the column of <code>res_diff</code> for the significance label of heatmap.</p>
</dd>
<dt><code>heatmap_x</code></dt><dd><p>default &quot;Factors&quot;; the column of <code>res_diff</code> for the x axis of heatmap.</p>
</dd>
<dt><code>heatmap_y</code></dt><dd><p>default &quot;Taxa&quot;; the column of <code>res_diff</code> for the y axis of heatmap.</p>
</dd>
<dt><code>heatmap_lab_fill</code></dt><dd><p>default &quot;P value&quot;; legend title of heatmap.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passing to <code>ggpubr::ggboxplot</code> function when box plot is used or 
<code>plot_cor</code> function in <code><a href="#topic+trans_env">trans_env</a></code> class for the heatmap of multiple factors when formula is found in the res_diff of the object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1 &lt;- trans_alpha$new(dataset = dataset, group = "Group")
t1$cal_diff(method = "wilcox")
t1$plot_alpha(measure = "Shannon", add_sig = TRUE)
t1 &lt;- trans_alpha$new(dataset = dataset, group = "Type", by_group = "Group")
t1$cal_diff(method = "wilcox")
t1$plot_alpha(measure = "Shannon", add_sig = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_alpha-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the trans_alpha object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_alpha$print()</pre></div>


<hr>
<a id="method-trans_alpha-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_alpha$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_alpha$new`
## ------------------------------------------------


data(dataset)
t1 &lt;- trans_alpha$new(dataset = dataset, group = "Group")


## ------------------------------------------------
## Method `trans_alpha$cal_diff`
## ------------------------------------------------


t1$cal_diff(method = "KW")
t1$cal_diff(method = "anova")
t1 &lt;- trans_alpha$new(dataset = dataset, group = "Type", by_group = "Group")
t1$cal_diff(method = "anova")


## ------------------------------------------------
## Method `trans_alpha$plot_alpha`
## ------------------------------------------------


t1 &lt;- trans_alpha$new(dataset = dataset, group = "Group")
t1$cal_diff(method = "wilcox")
t1$plot_alpha(measure = "Shannon", add_sig = TRUE)
t1 &lt;- trans_alpha$new(dataset = dataset, group = "Type", by_group = "Group")
t1$cal_diff(method = "wilcox")
t1$plot_alpha(measure = "Shannon", add_sig = TRUE)

</code></pre>

<hr>
<h2 id='trans_beta'>Create <code>trans_beta</code> object for beta-diversity analysis based on the distance matrix</h2><span id='topic+trans_beta'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of beta-diversity related analysis, 
including ordination analysis based on An et al. (2019) &lt;doi:10.1016/j.geoderma.2018.09.035&gt;, group distance comparision, 
clustering, perMANOVA based on Anderson al. (2008) &lt;doi:10.1111/j.1442-9993.2001.01070.pp.x&gt;, ANOSIM and PERMDISP.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_beta-new"><code>trans_beta$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_ordination"><code>trans_beta$cal_ordination()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-plot_ordination"><code>trans_beta$plot_ordination()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_manova"><code>trans_beta$cal_manova()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_anosim"><code>trans_beta$cal_anosim()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_betadisper"><code>trans_beta$cal_betadisper()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_group_distance"><code>trans_beta$cal_group_distance()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-cal_group_distance_diff"><code>trans_beta$cal_group_distance_diff()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-plot_group_distance"><code>trans_beta$plot_group_distance()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-plot_clustering"><code>trans_beta$plot_clustering()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_beta-clone"><code>trans_beta$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_beta-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>trans_beta$new(dataset = NULL, measure = NULL, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>the object of <code><a href="#topic+microtable">microtable</a></code> class.</p>
</dd>
<dt><code>measure</code></dt><dd><p>default NULL; bray, jaccard, wei_unifrac or unwei_unifrac, or other name of matrix stored in <code>microtable$beta_diversity</code>; 
used for ordination, manova, group distance comparision, etc. The measure must be one of names in <code>microtable$beta_diversity</code> list. 
Please see <code>cal_betadiv</code> function of <code><a href="#topic+microtable">microtable</a></code> class for more details.</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; sample group used for manova, betadisper or group distance comparision.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>parameters stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(dataset)
t1 &lt;- trans_beta$new(dataset = dataset, measure = "bray", group = "Group")
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_ordination"></a>



<h4>Method <code>cal_ordination()</code></h4>

<p>Unconstrained ordination.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_ordination(
  ordination = "PCoA",
  ncomp = 3,
  trans = FALSE,
  scale_species = FALSE,
  scale_species_ratio = 0.8,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ordination</code></dt><dd><p>default &quot;PCoA&quot;; &quot;PCA&quot;, &quot;DCA&quot;, &quot;PCoA&quot; or &quot;NMDS&quot;. PCA: principal component analysis; DCA: detrended correspondence analysis; 
PCoA: principal coordinates analysis; NMDS: non-metric multidimensional scaling.</p>
</dd>
<dt><code>ncomp</code></dt><dd><p>default 3; dimensions shown in the results.</p>
</dd>
<dt><code>trans</code></dt><dd><p>default FALSE; whether species abundance will be square transformed; only available when <code>ordination</code> is &quot;PCA&quot; or &quot;DCA&quot;.</p>
</dd>
<dt><code>scale_species</code></dt><dd><p>default FALSE; whether species loading in PCA or DCA is scaled.</p>
</dd>
<dt><code>scale_species_ratio</code></dt><dd><p>default 0.8; the ratio to scale up the loading; multiply by the maximum distance between samples and origin. 
Only available when <code>scale_species = TURE</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>vegan::rda</code> function when <code>ordination = "PCA"</code>, 
or <code>vegan::decorana</code> function when <code>ordination = "DCA"</code>, 
or <code>ape::pcoa</code> function when <code>ordination = "PCoA"</code>, 
or <code>vegan::metaMDS</code> function when when <code>ordination = "NMDS"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_ordination</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$cal_ordination(ordination = "PCoA")
</pre>
</div>


<hr>
<a id="method-trans_beta-plot_ordination"></a>



<h4>Method <code>plot_ordination()</code></h4>

<p>Plot the ordination result.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$plot_ordination(
  plot_type = "point",
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  shape_values = c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14),
  plot_color = NULL,
  plot_shape = NULL,
  plot_group_order = NULL,
  add_sample_label = NULL,
  point_size = 3,
  point_alpha = 0.8,
  centroid_segment_alpha = 0.6,
  centroid_segment_size = 1,
  centroid_segment_linetype = 3,
  ellipse_chull_fill = TRUE,
  ellipse_chull_alpha = 0.1,
  ellipse_level = 0.9,
  ellipse_type = "t",
  NMDS_stress_pos = c(1, 1),
  NMDS_stress_text_prefix = "",
  loading_arrow = FALSE,
  loading_taxa_num = 10,
  loading_text_color = "black",
  loading_arrow_color = "grey30",
  loading_text_size = 3,
  loading_text_italic = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_type</code></dt><dd><p>default &quot;point&quot;; one or more elements of &quot;point&quot;, &quot;ellipse&quot;, &quot;chull&quot; and &quot;centroid&quot;.
</p>

<dl>
<dt><strong>'point'</strong></dt><dd><p>add point</p>
</dd>
<dt><strong>'ellipse'</strong></dt><dd><p>add confidence ellipse for points of each group</p>
</dd>
<dt><strong>'chull'</strong></dt><dd><p>add convex hull for points of each group</p>
</dd>
<dt><strong>'centroid'</strong></dt><dd><p>add centroid line of each group</p>
</dd>
</dl>
</dd>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette for different groups.</p>
</dd>
<dt><code>shape_values</code></dt><dd><p>default c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14); a vector for point shape types of groups, see <code>ggplot2</code> tutorial.</p>
</dd>
<dt><code>plot_color</code></dt><dd><p>default NULL; a colname of <code>sample_table</code> to assign colors to different groups in plot.</p>
</dd>
<dt><code>plot_shape</code></dt><dd><p>default NULL; a colname of <code>sample_table</code> to assign shapes to different groups in plot.</p>
</dd>
<dt><code>plot_group_order</code></dt><dd><p>default NULL; a vector used to order the groups in the legend of plot.</p>
</dd>
<dt><code>add_sample_label</code></dt><dd><p>default NULL; a column name in <code>sample_table</code>; If provided, show the point name in plot.</p>
</dd>
<dt><code>point_size</code></dt><dd><p>default 3; point size when &quot;point&quot; is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>point_alpha</code></dt><dd><p>default .8; point transparency in plot when &quot;point&quot; is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>centroid_segment_alpha</code></dt><dd><p>default 0.6; segment transparency in plot when &quot;centroid&quot; is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>centroid_segment_size</code></dt><dd><p>default 1; segment size in plot when &quot;centroid&quot; is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>centroid_segment_linetype</code></dt><dd><p>default 3; the line type related with centroid in plot when &quot;centroid&quot; is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>ellipse_chull_fill</code></dt><dd><p>default TRUE; whether fill colors to the area of ellipse or chull.</p>
</dd>
<dt><code>ellipse_chull_alpha</code></dt><dd><p>default 0.1; color transparency in the ellipse or convex hull depending on whether &quot;ellipse&quot; or &quot;centroid&quot; is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>ellipse_level</code></dt><dd><p>default .9; confidence level of ellipse when &quot;ellipse&quot; is in <code>plot_type</code> parameter.</p>
</dd>
<dt><code>ellipse_type</code></dt><dd><p>default &quot;t&quot;; ellipse type when &quot;ellipse&quot; is in <code>plot_type</code> parameter; see type in <code><a href="ggplot2.html#topic+stat_ellipse">stat_ellipse</a></code>.</p>
</dd>
<dt><code>NMDS_stress_pos</code></dt><dd><p>default c(1, 1); a numerical vector with two values used to represent the insertion position of the stress text. 
The first one denotes the x-axis, while the second one corresponds to the y-axis. 
The assigned position is determined by multiplying the respective value with the maximum point on the corresponding coordinate axis. 
Thus, the x-axis position is equal to <code>max(points of x axis) * NMDS_stress_pos[1]</code>, 
and the y-axis position is equal to <code>max(points of y axis) * NMDS_stress_pos[2]</code>. Negative values can also be utilized for the negative part of the axis.
<code>NMDS_stress_pos = NULL</code> denotes no stress text to show.</p>
</dd>
<dt><code>NMDS_stress_text_prefix</code></dt><dd><p>default &quot;&quot;; If NMDS_stress_pos is not NULL, this parameter can be used to add text in front of the stress value.</p>
</dd>
<dt><code>loading_arrow</code></dt><dd><p>default FALSE; whether show the loading using arrow.</p>
</dd>
<dt><code>loading_taxa_num</code></dt><dd><p>default 10; the number of taxa used for the loading. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
<dt><code>loading_text_color</code></dt><dd><p>default &quot;black&quot;; the color of taxa text. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
<dt><code>loading_arrow_color</code></dt><dd><p>default &quot;grey30&quot;; the color of taxa arrow. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
<dt><code>loading_text_size</code></dt><dd><p>default 3; the size of taxa text. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
<dt><code>loading_text_italic</code></dt><dd><p>default FALSE; whether using italic for the taxa text. Only available when <code>loading_arrow = TRUE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$plot_ordination(plot_type = "point")
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = "point")
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "ellipse"))
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), 
	  centroid_segment_linetype = 1)
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_manova"></a>



<h4>Method <code>cal_manova()</code></h4>

<p>Calculate perMANOVA (Permutational Multivariate Analysis of Variance) based on &lt;doi:10.1111/j.1442-9993.2001.01070.pp.x&gt; and R vegan <code>adonis2</code> function.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_manova(
  manova_all = TRUE,
  manova_set = NULL,
  group = NULL,
  by_group = NULL,
  p_adjust_method = "fdr",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>manova_all</code></dt><dd><p>default TRUE; TRUE represents test for all the groups, i.e. the overall test;
FALSE represents test for all the paired groups.</p>
</dd>
<dt><code>manova_set</code></dt><dd><p>default NULL; other specified group set for manova, such as <code>"Group + Type"</code> and <code>"Group*Type"</code>; see also <code><a href="vegan.html#topic+adonis2">adonis2</a></code>.
manova_set has higher priority than manova_all parameter. If manova_set is provided; manova_all is disabled.</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; a column name of <code>sample_table</code> used for manova. If NULL, search <code>group</code> variable stored in the object.
Available when <code>manova_set</code> is not provided.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>default NULL; one column name in <code>sample_table</code>; used to perform paired comparisions within each group. 
Only available when <code>manova_all = FALSE</code> and <code>manova_set</code> is not provided.</p>
</dd>
<dt><code>p_adjust_method</code></dt><dd><p>default &quot;fdr&quot;; p.adjust method; available when <code>manova_all = FALSE</code>; see method parameter of <code>p.adjust</code> function for available options.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code><a href="vegan.html#topic+adonis2">adonis2</a></code> function of <code>vegan</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_manova</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$cal_manova(manova_all = TRUE)
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_anosim"></a>



<h4>Method <code>cal_anosim()</code></h4>

<p>Analysis of similarities (ANOSIM) based on R vegan <code>anosim</code> function.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_anosim(
  paired = FALSE,
  group = NULL,
  by_group = NULL,
  p_adjust_method = "fdr",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>paired</code></dt><dd><p>default FALSE; whether perform paired test between any two combined groups from all the input groups.</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; a column name of <code>sample_table</code>. If NULL, search <code>group</code> variable stored in the object.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>default NULL; one column name in <code>sample_table</code>; used to perform paired comparisions within each group. 
Only available when <code>paired = TRUE</code>.</p>
</dd>
<dt><code>p_adjust_method</code></dt><dd><p>default &quot;fdr&quot;; p.adjust method; available when <code>paired = TRUE</code>; see method parameter of <code>p.adjust</code> function for available options.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code><a href="vegan.html#topic+anosim">anosim</a></code> function of <code>vegan</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_anosim</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$cal_anosim()
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_betadisper"></a>



<h4>Method <code>cal_betadisper()</code></h4>

<p>A wrapper for <code>betadisper</code> function in vegan package for multivariate homogeneity test of groups dispersions (PERMDISP).
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_betadisper(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>parameters passed to <code><a href="vegan.html#topic+betadisper">betadisper</a></code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_betadisper</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$cal_betadisper()
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_group_distance"></a>



<h4>Method <code>cal_group_distance()</code></h4>

<p>Convert sample distances within groups or between groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_group_distance(
  within_group = TRUE,
  by_group = NULL,
  ordered_group = NULL,
  sep = " vs "
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>within_group</code></dt><dd><p>default TRUE; whether transform sample distance within groups, if FALSE, transform sample distance between any two groups.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>default NULL; one colname name of sample_table in <code>microtable</code> object.
If provided, transform distances by the provided by_group parameter. This is especially useful for ordering and filtering values further.
When <code>within_group = TRUE</code>, the result of by_group parameter is the format of paired groups.
When <code>within_group = FALSE</code>, the result of by_group parameter is the format same with the group information in <code>sample_table</code>.</p>
</dd>
<dt><code>ordered_group</code></dt><dd><p>default NULL; a vector representing the ordered elements of <code>group</code> parameter; only useful when within_group = FALSE.</p>
</dd>
<dt><code>sep</code></dt><dd><p>default TRUE; a character string to separate the group names after merging them into a new name.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_group_distance</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_group_distance(within_group = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_beta-cal_group_distance_diff"></a>



<h4>Method <code>cal_group_distance_diff()</code></h4>

<p>Differential test of distances among groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$cal_group_distance_diff(
  group = NULL,
  by_group = NULL,
  by_ID = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>default NULL; a column name of <code>object$res_group_distance</code> used for the statistics; If NULL, use the <code>group</code> inside the object.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>default NULL; a column of <code>object$res_group_distance</code> used to perform the differential test 
among elements in <code>group</code> parameter for each element in <code>by_group</code> parameter. So <code>by_group</code> has a larger scale than <code>group</code> parameter.
This <code>by_group</code> is very different from the <code>by_group</code> parameter in the <code>cal_group_distance</code> function.</p>
</dd>
<dt><code>by_ID</code></dt><dd><p>default NULL; a column of <code>object$res_group_distance</code> used to perform paired t test or paired wilcox test for the paired data,
such as the data of plant compartments for different plant species (ID). 
So <code>by_ID</code> should be the smallest unit of sample collection without any repetition in it.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>cal_diff</code> function of <code><a href="#topic+trans_alpha">trans_alpha</a></code> class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_group_distance_diff</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_group_distance_diff()
}
</pre>
</div>


<hr>
<a id="method-trans_beta-plot_group_distance"></a>



<h4>Method <code>plot_group_distance()</code></h4>

<p>Plotting the distance between samples within or between groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$plot_group_distance(plot_group_order = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_group_order</code></dt><dd><p>default NULL; a vector used to order the groups in the plot.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters (except measure) passed to <code>plot_alpha</code> function of <code><a href="#topic+trans_alpha">trans_alpha</a></code> class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_group_distance()
}
</pre>
</div>


<hr>
<a id="method-trans_beta-plot_clustering"></a>



<h4>Method <code>plot_clustering()</code></h4>

<p>Plotting clustering result based on the <code>ggdendro</code> package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$plot_clustering(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  measure = NULL,
  group = NULL,
  replace_name = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default RColorBrewer::brewer.pal(8, &quot;Dark2&quot;); color palette for the text.</p>
</dd>
<dt><code>measure</code></dt><dd><p>default NULL; beta diversity index; If NULL, using the measure when creating object</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; if provided, use this group to assign color.</p>
</dd>
<dt><code>replace_name</code></dt><dd><p>default NULL; if provided, use this as label.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>ggplot</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>t1$plot_clustering(group = "Group", replace_name = c("Saline", "Type"))
</pre>
</div>


<hr>
<a id="method-trans_beta-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_beta$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_beta$new`
## ------------------------------------------------

data(dataset)
t1 &lt;- trans_beta$new(dataset = dataset, measure = "bray", group = "Group")

## ------------------------------------------------
## Method `trans_beta$cal_ordination`
## ------------------------------------------------

t1$cal_ordination(ordination = "PCoA")

## ------------------------------------------------
## Method `trans_beta$plot_ordination`
## ------------------------------------------------

t1$plot_ordination(plot_type = "point")
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = "point")
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "ellipse"))
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), 
	  centroid_segment_linetype = 1)

## ------------------------------------------------
## Method `trans_beta$cal_manova`
## ------------------------------------------------

t1$cal_manova(manova_all = TRUE)

## ------------------------------------------------
## Method `trans_beta$cal_anosim`
## ------------------------------------------------

t1$cal_anosim()

## ------------------------------------------------
## Method `trans_beta$cal_betadisper`
## ------------------------------------------------

t1$cal_betadisper()

## ------------------------------------------------
## Method `trans_beta$cal_group_distance`
## ------------------------------------------------


t1$cal_group_distance(within_group = TRUE)


## ------------------------------------------------
## Method `trans_beta$cal_group_distance_diff`
## ------------------------------------------------


t1$cal_group_distance_diff()


## ------------------------------------------------
## Method `trans_beta$plot_group_distance`
## ------------------------------------------------


t1$plot_group_distance()


## ------------------------------------------------
## Method `trans_beta$plot_clustering`
## ------------------------------------------------

t1$plot_clustering(group = "Group", replace_name = c("Saline", "Type"))
</code></pre>

<hr>
<h2 id='trans_classifier'>Create trans_classifier object for machine-learning-based model prediction.</h2><span id='topic+trans_classifier'></span>

<h3>Description</h3>

<p>This class is a wrapper for methods of machine-learning-based classification or regression models, including data pre-processing, feature selection, 
data split, model training, prediction, confusionMatrix and ROC (Receiver Operator Characteristic) or PR (Precision-Recall) curve.
</p>
<p>Author(s): Felipe Mansoldo and Chi Liu
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_classifier-new"><code>trans_classifier$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_preProcess"><code>trans_classifier$cal_preProcess()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_feature_sel"><code>trans_classifier$cal_feature_sel()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_split"><code>trans_classifier$cal_split()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-set_trainControl"><code>trans_classifier$set_trainControl()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_train"><code>trans_classifier$cal_train()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_feature_imp"><code>trans_classifier$cal_feature_imp()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-plot_feature_imp"><code>trans_classifier$plot_feature_imp()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_predict"><code>trans_classifier$cal_predict()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-plot_confusionMatrix"><code>trans_classifier$plot_confusionMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-cal_ROC"><code>trans_classifier$cal_ROC()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-plot_ROC"><code>trans_classifier$plot_ROC()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_classifier-clone"><code>trans_classifier$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_classifier-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create the trans_classifier object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$new(
  dataset = NULL,
  x.predictors = "all",
  y.response = NULL,
  n.cores = 1
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>the object of <code><a href="#topic+microtable">microtable</a></code> Class.</p>
</dd>
<dt><code>x.predictors</code></dt><dd><p>default &quot;all&quot;; character string or data.frame; a character string represents selecting the corresponding data from microtable$taxa_abund; 
data.frame represents other customized input. See the following available options:
</p>

<dl>
<dt><strong>'all'</strong></dt><dd><p>use all the taxa stored in microtable$taxa_abund</p>
</dd>
<dt><strong>'Genus'</strong></dt><dd><p>use Genus level table in microtable$taxa_abund, or other specific taxonomic rank, e.g. 'Phylum'</p>
</dd>
<dt><strong>other input</strong></dt><dd><p>must be a data.frame; It should have the same format with the data.frame in microtable$taxa_abund, i.e. rows are features; 
cols are samples with same names in sample_table</p>
</dd>
</dl>
</dd>
<dt><code>y.response</code></dt><dd><p>default NULL; the response variable in sample_table.</p>
</dd>
<dt><code>n.cores</code></dt><dd><p>default 1; the CPU thread used.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>data_feature and data_response in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
data(dataset)
t1 &lt;- trans_classifier$new(
		dataset = dataset, 
		x.predictors = "Genus",
		y.response = "Group")
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_preProcess"></a>



<h4>Method <code>cal_preProcess()</code></h4>

<p>Pre-process (centering, scaling etc.) of the feature data based on the caret::preProcess function. 
See <a href="https://topepo.github.io/caret/pre-processing.html">https://topepo.github.io/caret/pre-processing.html</a> for more details.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_preProcess(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>parameters pass to preProcess function of caret package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>converted data_feature in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_preProcess(method = c("center", "scale", "nzv"))
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_feature_sel"></a>



<h4>Method <code>cal_feature_sel()</code></h4>

<p>Perform feature selection.
See <a href="https://topepo.github.io/caret/feature-selection-overview.html">https://topepo.github.io/caret/feature-selection-overview.html</a> for more details.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_feature_sel(
  boruta.maxRuns = 300,
  boruta.pValue = 0.01,
  boruta.repetitions = 4,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>boruta.maxRuns</code></dt><dd><p>default 300; maximal number of importance source runs; passed to the maxRuns parameter in Boruta function of Boruta package.</p>
</dd>
<dt><code>boruta.pValue</code></dt><dd><p>default 0.01; p value passed to the pValue parameter in Boruta function of Boruta package.</p>
</dd>
<dt><code>boruta.repetitions</code></dt><dd><p>default 4; repetition runs for the feature selection.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to Boruta function of Boruta package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>optimized data_feature in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_feature_sel(boruta.maxRuns = 300, boruta.pValue = 0.01)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_split"></a>



<h4>Method <code>cal_split()</code></h4>

<p>Split data for training and testing.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_split(prop.train = 3/4)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prop.train</code></dt><dd><p>default 3/4; the ratio of the dataset used for the training.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>data_train and data_test in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_split(prop.train = 3/4)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-set_trainControl"></a>



<h4>Method <code>set_trainControl()</code></h4>

<p>Control parameters for the following training. See trainControl function of caret package for details.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$set_trainControl(
  method = "repeatedcv",
  classProbs = TRUE,
  savePredictions = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default 'repeatedcv'; 'repeatedcv': Repeated k-Fold cross validation; 
see method parameter in <code>trainControl</code> function of <code>caret</code> package for available options.</p>
</dd>
<dt><code>classProbs</code></dt><dd><p>default TRUE; should class probabilities be computed for classification models?;
see classProbs parameter in <code>caret::trainControl</code> function.</p>
</dd>
<dt><code>savePredictions</code></dt><dd><p>default TRUE; see <code>savePredictions</code> parameter in <code>caret::trainControl</code> function.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to trainControl function of caret package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>trainControl in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$set_trainControl(method = 'repeatedcv')
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_train"></a>



<h4>Method <code>cal_train()</code></h4>

<p>Run the model training.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_train(method = "rf", max.mtry = 2, max.ntree = 200, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default &quot;rf&quot;; &quot;rf&quot;: random forest; see method in caret::train function for other options.</p>
</dd>
<dt><code>max.mtry</code></dt><dd><p>default 2; for method = &quot;rf&quot;; maximum mtry used for the tunegrid to do hyperparameter tuning to optimize the model.</p>
</dd>
<dt><code>max.ntree</code></dt><dd><p>default 200; for method = &quot;rf&quot;; maximum number of trees used to optimize the model.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to <code>caret::train</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_train in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# random forest
t1$cal_train(method = "rf")
# Support Vector Machines with Radial Basis Function Kernel
t1$cal_train(method = "svmRadial", tuneLength = 15)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_feature_imp"></a>



<h4>Method <code>cal_feature_imp()</code></h4>

<p>Get feature importance from the training model.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_feature_imp(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>parameters pass to varImp function of caret package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_feature_imp in the object. One row for each predictor variable. The column(s) are different importance measures.
For the method 'rf', it is MeanDecreaseGini (classification) or IncNodePurity (regression).
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_feature_imp()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-plot_feature_imp"></a>



<h4>Method <code>plot_feature_imp()</code></h4>

<p>Bar plot for feature importance.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$plot_feature_imp(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>parameters pass to <code>plot_diff_bar</code> function of <code>trans_diff</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$plot_feature_imp(use_number = 1:20, coord_flip = FALSE)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_predict"></a>



<h4>Method <code>cal_predict()</code></h4>

<p>Run the prediction.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_predict(positive_class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>positive_class</code></dt><dd><p>default NULL; see positive parameter in confusionMatrix function of caret package;
If positive_class is NULL, use the first group in data as the positive class automatically.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_predict, res_confusion_fit and res_confusion_stats stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_predict()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-plot_confusionMatrix"></a>



<h4>Method <code>plot_confusionMatrix()</code></h4>

<p>Plot the cross-tabulation of observed and predicted classes with associated statistics.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$plot_confusionMatrix(
  plot_confusion = TRUE,
  plot_statistics = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_confusion</code></dt><dd><p>default TRUE; whether plot the confusion matrix.</p>
</dd>
<dt><code>plot_statistics</code></dt><dd><p>default TRUE; whether plot the statistics.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$plot_confusionMatrix()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-cal_ROC"></a>



<h4>Method <code>cal_ROC()</code></h4>

<p>Get ROC (Receiver Operator Characteristic) curve data and the performance data.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$cal_ROC(input = "pred")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>input</code></dt><dd><p>default &quot;pred&quot;; 'pred' or 'train'; 'pred' represents using prediction results;
'train' represents using training results.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a list res_ROC stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_ROC()
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-plot_ROC"></a>



<h4>Method <code>plot_ROC()</code></h4>

<p>Plot ROC curve.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$plot_ROC(
  plot_type = c("ROC", "PR")[1],
  plot_group = "all",
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  add_AUC = TRUE,
  plot_method = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_type</code></dt><dd><p>default c(&quot;ROC&quot;, &quot;PR&quot;)[1]; 'ROC' represents ROC (Receiver Operator Characteristic) curve; 
'PR' represents PR (Precision-Recall) curve.</p>
</dd>
<dt><code>plot_group</code></dt><dd><p>default &quot;all&quot;; 'all' represents all the classes in the model;
'add' represents all adding micro-average and macro-average results, see 
<a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html">https://scikit-learn.org/stable/auto_examples/model_selection/plot_roc.html</a>;
other options should be one or more class names, same with the names in Group column of res_ROC$res_roc from cal_ROC function.</p>
</dd>
<dt><code>color_values</code></dt><dd><p>default RColorBrewer::brewer.pal(8, &quot;Dark2&quot;); colors used in the plot.</p>
</dd>
<dt><code>add_AUC</code></dt><dd><p>default TRUE; whether add AUC in the legend.</p>
</dd>
<dt><code>plot_method</code></dt><dd><p>default FALSE; If TRUE, show the method in the legend though only one method is found.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to geom_path function of ggplot2 package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2 object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$plot_ROC(size = 1, alpha = 0.7)
}
</pre>
</div>


<hr>
<a id="method-trans_classifier-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_classifier$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_classifier$new`
## ------------------------------------------------


data(dataset)
t1 &lt;- trans_classifier$new(
		dataset = dataset, 
		x.predictors = "Genus",
		y.response = "Group")


## ------------------------------------------------
## Method `trans_classifier$cal_preProcess`
## ------------------------------------------------

## Not run: 
t1$cal_preProcess(method = c("center", "scale", "nzv"))

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_feature_sel`
## ------------------------------------------------

## Not run: 
t1$cal_feature_sel(boruta.maxRuns = 300, boruta.pValue = 0.01)

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_split`
## ------------------------------------------------

## Not run: 
t1$cal_split(prop.train = 3/4)

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$set_trainControl`
## ------------------------------------------------

## Not run: 
t1$set_trainControl(method = 'repeatedcv')

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_train`
## ------------------------------------------------

## Not run: 
# random forest
t1$cal_train(method = "rf")
# Support Vector Machines with Radial Basis Function Kernel
t1$cal_train(method = "svmRadial", tuneLength = 15)

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_feature_imp`
## ------------------------------------------------

## Not run: 
t1$cal_feature_imp()

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$plot_feature_imp`
## ------------------------------------------------

## Not run: 
t1$plot_feature_imp(use_number = 1:20, coord_flip = FALSE)

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_predict`
## ------------------------------------------------

## Not run: 
t1$cal_predict()

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$plot_confusionMatrix`
## ------------------------------------------------

## Not run: 
t1$plot_confusionMatrix()

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$cal_ROC`
## ------------------------------------------------

## Not run: 
t1$cal_ROC()

## End(Not run)

## ------------------------------------------------
## Method `trans_classifier$plot_ROC`
## ------------------------------------------------

## Not run: 
t1$plot_ROC(size = 1, alpha = 0.7)

## End(Not run)
</code></pre>

<hr>
<h2 id='trans_diff'>Create <code>trans_diff</code> object for the differential analysis on the taxonomic abundance</h2><span id='topic+trans_diff'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of differential abundance test and indicator analysis methods, including 
LEfSe based on the Segata et al. (2011) &lt;doi:10.1186/gb-2011-12-6-r60&gt;,
random forest &lt;doi:10.1016/j.geoderma.2018.09.035&gt;, metastat based on White et al. (2009) &lt;doi:10.1371/journal.pcbi.1000352&gt;,
non-parametric Kruskal-Wallis Rank Sum Test,
Dunn's Kruskal-Wallis Multiple Comparisons based on the <code>FSA</code> package, Wilcoxon Rank Sum and Signed Rank Tests, t-test, anova, 
Scheirer Ray Hare test, 
R package <code>metagenomeSeq</code> Paulson et al. (2013) &lt;doi:10.1038/nmeth.2658&gt;, 
R package <code>ANCOMBC</code> &lt;doi:10.1038/s41467-020-17041-7&gt;, R package <code>ALDEx2</code> &lt;doi:10.1371/journal.pone.0067019; 10.1186/2049-2618-2-15&gt;, 
R package <code>MicrobiomeStat</code> &lt;doi:10.1186/s13059-022-02655-5&gt;, beta regression &lt;doi:10.18637/jss.v034.i02&gt;, R package <code>maaslin2</code>,
linear mixed-effects model and generalized linear mixed model.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_diff-new"><code>trans_diff$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_diff-plot_diff_abund"><code>trans_diff$plot_diff_abund()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_diff-plot_diff_bar"><code>trans_diff$plot_diff_bar()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_diff-plot_diff_cladogram"><code>trans_diff$plot_diff_cladogram()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_diff-print"><code>trans_diff$print()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_diff-clone"><code>trans_diff$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_diff-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>trans_diff$new(
  dataset = NULL,
  method = c("lefse", "rf", "metastat", "metagenomeSeq", "KW", "KW_dunn", "wilcox",
    "t.test", "anova", "scheirerRayHare", "lm", "ancombc2", "ALDEx2_t", "ALDEx2_kw",
    "DESeq2", "linda", "maaslin2", "betareg", "lme", "glmm", "glmm_beta")[1],
  group = NULL,
  taxa_level = "all",
  filter_thres = 0,
  alpha = 0.05,
  p_adjust_method = "fdr",
  transformation = NULL,
  remove_unknown = TRUE,
  lefse_subgroup = NULL,
  lefse_min_subsam = 10,
  lefse_norm = 1e+06,
  nresam = 0.6667,
  boots = 30,
  rf_ntree = 1000,
  group_choose_paired = NULL,
  metagenomeSeq_count = 1,
  ALDEx2_sig = c("wi.eBH", "kw.eBH"),
  by_group = NULL,
  by_ID = NULL,
  beta_pseudo = .Machine$double.eps,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>default NULL; <code><a href="#topic+microtable">microtable</a></code> object.</p>
</dd>
<dt><code>method</code></dt><dd><p>default &quot;lefse&quot;; see the following available options:
</p>

<dl>
<dt><strong>'lefse'</strong></dt><dd><p>LEfSe method based on Segata et al. (2011) &lt;doi:10.1186/gb-2011-12-6-r60&gt;</p>
</dd>
<dt><strong>'rf'</strong></dt><dd><p>random forest and non-parametric test method based on An et al. (2019) &lt;doi:10.1016/j.geoderma.2018.09.035&gt;</p>
</dd>
<dt><strong>'metastat'</strong></dt><dd><p>Metastat method for all paired groups based on White et al. (2009) &lt;doi:10.1371/journal.pcbi.1000352&gt;</p>
</dd>
<dt><strong>'metagenomeSeq'</strong></dt><dd><p>zero-inflated log-normal model-based differential test method from <code>metagenomeSeq</code> package.</p>
</dd>
<dt><strong>'KW'</strong></dt><dd><p>KW: Kruskal-Wallis Rank Sum Test for all groups (&gt;= 2)</p>
</dd>
<dt><strong>'KW_dunn'</strong></dt><dd><p>Dunn's Kruskal-Wallis Multiple Comparisons when group number &gt; 2; see dunnTest function in <code>FSA</code> package</p>
</dd>
<dt><strong>'wilcox'</strong></dt><dd><p>Wilcoxon Rank Sum and Signed Rank Tests for all paired groups </p>
</dd>
<dt><strong>'t.test'</strong></dt><dd><p>Student's t-Test for all paired groups</p>
</dd>
<dt><strong>'anova'</strong></dt><dd><p>ANOVA for one-way or multi-factor analysis; see <code>cal_diff</code> function of <code>trans_alpha</code> class</p>
</dd>
<dt><strong>'scheirerRayHare'</strong></dt><dd><p>Scheirer Ray Hare test for nonparametric test used for a two-way factorial experiment; 
see <code>scheirerRayHare</code> function of <code>rcompanion</code> package</p>
</dd>
<dt><strong>'lm'</strong></dt><dd><p>Linear Model based on the <code>lm</code> function</p>
</dd>
<dt><strong>'ALDEx2_t'</strong></dt><dd><p>runs Welch's t and Wilcoxon tests with <code>ALDEx2</code> package; see also the test parameter in <code>ALDEx2::aldex</code> function;
ALDEx2 uses the centred log-ratio (clr) transformation and estimates per-feature technical variation within each sample using Monte-Carlo instances 
drawn from the Dirichlet distribution; Reference: &lt;doi:10.1371/journal.pone.0067019&gt; and &lt;doi:10.1186/2049-2618-2-15&gt;; 
require <code>ALDEx2</code> package to be installed 
(<a href="https://bioconductor.org/packages/release/bioc/html/ALDEx2.html">https://bioconductor.org/packages/release/bioc/html/ALDEx2.html</a>)</p>
</dd>
<dt><strong>'ALDEx2_kw'</strong></dt><dd><p>runs Kruskal-Wallace and generalized linear model (glm) test with <code>ALDEx2</code> package; 
see also the <code>test</code> parameter in <code>ALDEx2::aldex</code> function.</p>
</dd>
<dt><strong>'DESeq2'</strong></dt><dd><p>Differential expression analysis based on the Negative Binomial (a.k.a. Gamma-Poisson) distribution based on the <code>DESeq2</code> package.</p>
</dd>
<dt><strong>'ancombc2'</strong></dt><dd><p>Analysis of Compositions of Microbiomes with Bias Correction (ANCOM-BC) 
based on the <code>ancombc2</code> function from <code>ANCOMBC</code> package.
If the <code>fix_formula</code> parameter is not provided, the function can automatically assign it by using group parameter.
For this method, the <code>group</code> parameter is directly passed to the group parameter of <code>ancombc2</code> function.
Reference: &lt;doi:10.1038/s41467-020-17041-7&gt;&lt;10.1038/s41592-023-02092-7&gt;; Require <code>ANCOMBC</code> package to be installed 
(<a href="https://bioconductor.org/packages/release/bioc/html/ANCOMBC.html">https://bioconductor.org/packages/release/bioc/html/ANCOMBC.html</a>)</p>
</dd>
<dt><strong>'linda'</strong></dt><dd><p>Linear Model for Differential Abundance Analysis of High-dimensional Compositional Data 
based on the <code>linda</code> function of <code>MicrobiomeStat</code> package. 
For linda method, please provide either the group parameter or the formula parameter.
When the formula parameter is provided, it should start with '~' as it is directly used by the linda function.
If the group parameter is used, the prefix '~' is not necessary as the function can automatically add it.
The parameter <code>feature.dat.type = 'count'</code> has been fixed. Other parameters can be passed to the <code>linda</code> function.
Reference: &lt;doi:10.1186/s13059-022-02655-5&gt;</p>
</dd>
<dt><strong>'maaslin2'</strong></dt><dd><p>finding associations between metadata and potentially high-dimensional microbial multi-omics data based on the Maaslin2 package.
Using this option can invoke the <code>trans_env$cal_cor</code> function with <code>cor_method = "maaslin2"</code>.</p>
</dd>
<dt><strong>'betareg'</strong></dt><dd><p>Beta Regression based on the <code>betareg</code> package. 
Please see the <code>beta_pseudo</code> parameter for the use of pseudo value when there is 0 or 1 in the data</p>
</dd>
<dt><strong>'lme'</strong></dt><dd><p>Linear Mixed Effect Model based on the <code>lmerTest</code> package.
In the return table, the significance of fixed factors are tested by function <code>anova</code>.
The significance of 'Estimate' in each term of fixed factors comes from the model.</p>
</dd>
<dt><strong>'glmm'</strong></dt><dd><p>Generalized linear mixed model (GLMM) based on the <code>glmmTMB</code> package.
For more available parameters, please see <code>glmmTMB::glmmTMB</code> function and use parameter passing.
In the return table, Conditional_R2 and Marginal_R2 represent total variance (explained by both fixed and random effects) and the variance explained by 
fixed effects, respectively. The significance of fixed factors are tested by Chi-square test from function <code>car::Anova</code>.
The significance of 'Estimate' in each term of fixed factors comes from the model.</p>
</dd>
<dt><strong>'glmm_beta'</strong></dt><dd><p>Generalized linear mixed model with a family function of beta distribution, 
developed for the relative abundance (ranging from 0 to 1) of taxa specifically. 
This is an extension of the GLMM model in <code>'glmm'</code> option.
The only difference is in <code>glmm_beta</code> the family function is fixed with the beta distribution function, 
i.e. <code>family = glmmTMB::beta_family(link = "logit")</code>.
Please see the <code>beta_pseudo</code> parameter for the use of pseudo value when there is 0 or 1 in the data</p>
</dd>
</dl>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; sample group used for the comparision; a colname of input <code>microtable$sample_table</code>;
It is necessary when method is not &quot;anova&quot; or method is &quot;anova&quot; but formula is not provided.
Once group is provided, the return res_abund will have mean and sd values for group.</p>
</dd>
<dt><code>taxa_level</code></dt><dd><p>default &quot;all&quot;; 'all' represents using abundance data at all taxonomic ranks; 
For testing at a specific rank, provide taxonomic rank name, such as &quot;Genus&quot;.
If the provided taxonomic name is neither 'all' nor a colname in tax_table of input dataset, 
the function will use the features in input <code>microtable$otu_table</code> automatically.</p>
</dd>
<dt><code>filter_thres</code></dt><dd><p>default 0; the abundance threshold, such as 0.0005 when the input is relative abundance; only available when method != &quot;metastat&quot;.
The features with abundances lower than filter_thres will be filtered.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>default 0.05; significance threshold to select taxa when method is &quot;lefse&quot; or &quot;rf&quot;; 
or used to generate significance letters when method is 'anova' or 'KW_dunn' like the alpha parameter in <code>cal_diff</code> of <code>trans_alpha</code> class.</p>
</dd>
<dt><code>p_adjust_method</code></dt><dd><p>default &quot;fdr&quot;; p.adjust method; see method parameter of <code>p.adjust</code> function for other available options; 
&quot;none&quot; means disable p value adjustment; So when <code>p_adjust_method = "none"</code>, P.adj is same with P.unadj.</p>
</dd>
<dt><code>transformation</code></dt><dd><p>default NULL; feature abundance transformation method in the class <code><a href="#topic+trans_norm">trans_norm</a></code>,
such as 'AST' for the arc sine square root transformation.
Only available when <code>method</code> is one of &quot;KW&quot;, &quot;KW_dunn&quot;, &quot;wilcox&quot;, &quot;t.test&quot;, &quot;anova&quot;, &quot;scheirerRayHare&quot;, &quot;betareg&quot; and &quot;lme&quot;.</p>
</dd>
<dt><code>remove_unknown</code></dt><dd><p>default TRUE; whether remove unknown features that donot have clear classification information.</p>
</dd>
<dt><code>lefse_subgroup</code></dt><dd><p>default NULL; sample sub group used for sub-comparision in lefse; Segata et al. (2011) &lt;doi:10.1186/gb-2011-12-6-r60&gt;.</p>
</dd>
<dt><code>lefse_min_subsam</code></dt><dd><p>default 10; sample numbers required in the subgroup test.</p>
</dd>
<dt><code>lefse_norm</code></dt><dd><p>default 1000000; scale value in lefse.</p>
</dd>
<dt><code>nresam</code></dt><dd><p>default 0.6667; sample number ratio used in each bootstrap for method = &quot;lefse&quot; or &quot;rf&quot;.</p>
</dd>
<dt><code>boots</code></dt><dd><p>default 30; bootstrap test number for method = &quot;lefse&quot; or &quot;rf&quot;.</p>
</dd>
<dt><code>rf_ntree</code></dt><dd><p>default 1000; see ntree in randomForest function of randomForest package when method = &quot;rf&quot;.</p>
</dd>
<dt><code>group_choose_paired</code></dt><dd><p>default NULL; a vector used for selecting the required groups for paired testing, only used for method = &quot;metastat&quot; or &quot;metagenomeSeq&quot;.</p>
</dd>
<dt><code>metagenomeSeq_count</code></dt><dd><p>default 1; Filter features to have at least 'counts' counts.; see the count parameter in MRcoefs function of <code>metagenomeSeq</code> package.</p>
</dd>
<dt><code>ALDEx2_sig</code></dt><dd><p>default c(&quot;wi.eBH&quot;, &quot;kw.eBH&quot;); which column of the final result is used as the significance asterisk assignment;
applied to method = &quot;ALDEx2_t&quot; or &quot;ALDEx2_kw&quot;; the first element is provided to &quot;ALDEx2_t&quot;; the second is provided to &quot;ALDEx2_kw&quot;;
for &quot;ALDEx2_t&quot;, the available choice is &quot;wi.eBH&quot; (Expected Benjamini-Hochberg corrected P value of Wilcoxon test)
and &quot;we.eBH&quot; (Expected BH corrected P value of Welch's t test); for &quot;ALDEx2_kw&quot;; for &quot;ALDEx2_t&quot;,
the available choice is &quot;kw.eBH&quot; (Expected BH corrected P value of Kruskal-Wallace test) and &quot;glm.eBH&quot; (Expected BH corrected P value of glm test).</p>
</dd>
<dt><code>by_group</code></dt><dd><p>default NULL; a column of sample_table used to perform the differential test 
among groups (<code>group</code> parameter) for each group (<code>by_group</code> parameter). So <code>by_group</code> has a higher level than <code>group</code> parameter.
Same with the <code>by_group</code> parameter in <code>trans_alpha</code> class. 
Only available when method is one of <code>c("KW", "KW_dunn", "wilcox", "t.test", "anova", "scheirerRayHare")</code>.</p>
</dd>
<dt><code>by_ID</code></dt><dd><p>default NULL; a column of sample_table used to perform paired t test or paired wilcox test for the paired data,
such as the data of plant compartments for different plant species (ID). 
So <code>by_ID</code> in sample_table should be the smallest unit of sample collection without any repetition in it.
Same with the <code>by_ID</code> parameter in trans_alpha class.</p>
</dd>
<dt><code>beta_pseudo</code></dt><dd><p>default .Machine$double.eps; the pseudo value used when the parameter <code>method</code> is <code>'betareg'</code> or <code>'glmm_beta'</code>.
As the beta distribution function limits 0 &lt; response value &lt; 1, a pseudo value will be added for the data that equal to 0.
The data that equal to 1 will be replaced by <code>1/(1 + beta_pseudo)</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>cal_diff</code> function of <code>trans_alpha</code> class when method is one of 
&quot;KW&quot;, &quot;KW_dunn&quot;, &quot;wilcox&quot;, &quot;t.test&quot;, &quot;anova&quot;, &quot;betareg&quot;, &quot;lme&quot;, &quot;glmm&quot; or &quot;glmm_beta&quot;;
passed to <code>ANCOMBC::ancombc2</code> function when method is &quot;ancombc2&quot; (except tax_level, global and fix_formula parameters);
passed to <code>ALDEx2::aldex</code> function when method = &quot;ALDEx2_t&quot; or &quot;ALDEx2_kw&quot;;
passed to <code>DESeq2::DESeq</code> function when method = &quot;DESeq2&quot;;
passed to <code>MicrobiomeStat::linda</code> function when method = &quot;linda&quot;;
passed to <code>trans_env$cal_cor</code> function when method = &quot;maaslin2&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_diff and res_abund.<br />
<strong>res_abund</strong> includes mean abundance of each taxa (Mean), standard deviation (SD), standard error (SE) and sample number (N) in the group (Group).<br />
<strong>res_diff</strong> is the detailed differential test result, may containing:<br />
<strong>&quot;Comparison&quot;</strong>: The groups for the comparision, maybe all groups or paired groups. If this column is not found, all groups are used;<br />
<strong>&quot;Group&quot;</strong>: Which group has the maximum median or mean value across the test groups; 
For non-parametric methods, median value; For t.test, mean value;<br />
<strong>&quot;Taxa&quot;</strong>: which taxa is used in this comparision;<br />
<strong>&quot;Method&quot;</strong>: Test method used in the analysis depending on the method input;<br />
<strong>&quot;LDA&quot; or &quot;MeanDecreaseGini&quot;</strong>: LDA: linear discriminant score in LEfSe; MeanDecreaseGini: mean decreasing gini index in random forest;<br />
<strong>&quot;P.unadj&quot;</strong>: original p value;<br />
<strong>&quot;P.adj&quot;</strong>: adjusted p value;<br />
<strong>Others</strong>: qvalue: qvalue in metastat analysis.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
data(dataset)
t1 &lt;- trans_diff$new(dataset = dataset, method = "lefse", group = "Group")
t1 &lt;- trans_diff$new(dataset = dataset, method = "rf", group = "Group")
t1 &lt;- trans_diff$new(dataset = dataset, method = "metastat", group = "Group", taxa_level = "Genus")
t1 &lt;- trans_diff$new(dataset = dataset, method = "wilcox", group = "Group")
}
</pre>
</div>


<hr>
<a id="method-trans_diff-plot_diff_abund"></a>



<h4>Method <code>plot_diff_abund()</code></h4>

<p>Plot the abundance of differential taxa
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_diff$plot_diff_abund(
  use_number = 1:20,
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  select_group = NULL,
  select_taxa = NULL,
  simplify_names = TRUE,
  keep_prefix = TRUE,
  group_order = NULL,
  barwidth = 0.9,
  use_se = TRUE,
  add_sig = FALSE,
  add_sig_label = "Significance",
  add_sig_label_color = "black",
  add_sig_tip_length = 0.01,
  y_start = 1.01,
  y_increase = 0.05,
  text_y_size = 10,
  coord_flip = TRUE,
  xtext_angle = 45,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_number</code></dt><dd><p>default 1:20; numeric vector; the taxa numbers (1:n) selected in the plot; 
If the n is larger than the number of total significant taxa, automatically use all the taxa.</p>
</dd>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette.</p>
</dd>
<dt><code>select_group</code></dt><dd><p>default NULL; this is used to select the paired groups. 
This parameter is especially useful when the comparision methods is applied to paired groups;
The input select_group must be one of <code>object$res_diff$Comparison</code>.</p>
</dd>
<dt><code>select_taxa</code></dt><dd><p>default NULL; character vector to provide taxa names. 
The taxa names should be same with the names shown in the plot, not the 'Taxa' column names in <code>object$res_diff$Taxa</code>.</p>
</dd>
<dt><code>simplify_names</code></dt><dd><p>default TRUE; whether use the simplified taxonomic name.</p>
</dd>
<dt><code>keep_prefix</code></dt><dd><p>default TRUE; whether retain the taxonomic prefix.</p>
</dd>
<dt><code>group_order</code></dt><dd><p>default NULL; a vector to order groups, i.e. reorder the legend and colors in plot; 
If NULL, the function can first check whether the group column of sample_table is factor. If yes, use the levels in it.
If provided, overlook the levels in the group of sample_table.</p>
</dd>
<dt><code>barwidth</code></dt><dd><p>default 0.9; the bar width in plot.</p>
</dd>
<dt><code>use_se</code></dt><dd><p>default TRUE; whether use SE in plot, if FALSE, use SD.</p>
</dd>
<dt><code>add_sig</code></dt><dd><p>default FALSE; whether add the significance label to the plot.</p>
</dd>
<dt><code>add_sig_label</code></dt><dd><p>default &quot;Significance&quot;; select a colname of object$res_diff for the label text, such as 'P.adj' or 'Significance'.</p>
</dd>
<dt><code>add_sig_label_color</code></dt><dd><p>default &quot;black&quot;; the color for the label text when add_sig = TRUE.</p>
</dd>
<dt><code>add_sig_tip_length</code></dt><dd><p>default 0.01; the tip length for the added line when add_sig = TRUE.</p>
</dd>
<dt><code>y_start</code></dt><dd><p>default 1.01; the y axis position from which to add the label; the default 1.01 means 1.01 * Value;
For method != &quot;anova&quot;, all the start positions are same, i.e. Value = max(Mean+SD or Mean+SE); 
For method = &quot;anova&quot;; the stat position is calculated for each point, i.e. Value = Mean+SD or Mean+SE.</p>
</dd>
<dt><code>y_increase</code></dt><dd><p>default 0.05; the increasing y axia space to add label for paired groups; the default 0.05 means 0.05 * y_start * Value; 
In addition, this parameter is also used to label the letters of anova result with the fixed (1 + y_increase) * y_start * Value.</p>
</dd>
<dt><code>text_y_size</code></dt><dd><p>default 10; the size for the y axis text, i.e. feature text.</p>
</dd>
<dt><code>coord_flip</code></dt><dd><p>default TRUE; whether flip cartesian coordinates so that horizontal becomes vertical, and vertical becomes horizontal.</p>
</dd>
<dt><code>xtext_angle</code></dt><dd><p>default 45; number ranging from 0 to 90; used to make x axis text generate angle to reduce text overlap; 
only available when coord_flip = FALSE.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>ggsignif::stat_signif</code> when add_sig = TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1 &lt;- trans_diff$new(dataset = dataset, method = "anova", group = "Group", taxa_level = "Genus")
t1$plot_diff_abund(use_number = 1:10)
t1$plot_diff_abund(use_number = 1:10, add_sig = TRUE)
t1 &lt;- trans_diff$new(dataset = dataset, method = "wilcox", group = "Group")
t1$plot_diff_abund(use_number = 1:20)
t1$plot_diff_abund(use_number = 1:20, add_sig = TRUE)
t1 &lt;- trans_diff$new(dataset = dataset, method = "lefse", group = "Group")
t1$plot_diff_abund(use_number = 1:20)
t1$plot_diff_abund(use_number = 1:20, add_sig = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_diff-plot_diff_bar"></a>



<h4>Method <code>plot_diff_bar()</code></h4>

<p>Bar plot for indicator index, such as LDA score and P value.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_diff$plot_diff_bar(
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  color_group_map = FALSE,
  use_number = 1:10,
  threshold = NULL,
  select_group = NULL,
  keep_full_name = FALSE,
  keep_prefix = TRUE,
  group_order = NULL,
  axis_text_y = 12,
  coord_flip = TRUE,
  xtext_angle = 45,
  xtext_size = 10,
  heatmap_cell = "P.unadj",
  heatmap_sig = "Significance",
  heatmap_x = "Factors",
  heatmap_y = "Taxa",
  heatmap_lab_fill = "P value",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette for different groups.</p>
</dd>
<dt><code>color_group_map</code></dt><dd><p>default FALSE; whether match the colors to groups in order to fix the color in each group when part of groups are not shown in the plot.
When <code>color_group_map = TRUE</code>, the group_order inside the object will be used as full groups set to guide the color extraction.</p>
</dd>
<dt><code>use_number</code></dt><dd><p>default 1:10; numeric vector; the taxa numbers used in the plot, i.e. 1:n.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>default NULL; threshold value of indicators for selecting taxa, such as 3 for LDA score of LEfSe.</p>
</dd>
<dt><code>select_group</code></dt><dd><p>default NULL; this is used to select the paired group when multiple comparisions are generated;
The input select_group must be one of <code>object$res_diff$Comparison</code>.</p>
</dd>
<dt><code>keep_full_name</code></dt><dd><p>default FALSE; whether keep the taxonomic full lineage names.</p>
</dd>
<dt><code>keep_prefix</code></dt><dd><p>default TRUE; whether retain the taxonomic prefix, such as &quot;g__&quot;.</p>
</dd>
<dt><code>group_order</code></dt><dd><p>default NULL; a vector to order the legend and colors in plot; 
If NULL, the function can first determine whether the group column of <code>microtable$sample_table</code> is factor. If yes, use the levels in it.
If provided, this parameter can overwrite the levels in the group of <code>microtable$sample_table</code>.</p>
</dd>
<dt><code>axis_text_y</code></dt><dd><p>default 12; the size for the y axis text.</p>
</dd>
<dt><code>coord_flip</code></dt><dd><p>default TRUE; whether flip cartesian coordinates so that horizontal becomes vertical, and vertical becomes horizontal.</p>
</dd>
<dt><code>xtext_angle</code></dt><dd><p>default 45; number ranging from 0 to 90; used to make x axis text generate angle to reduce text overlap; 
only available when coord_flip = FALSE.</p>
</dd>
<dt><code>xtext_size</code></dt><dd><p>default 10; the text size of x axis.</p>
</dd>
<dt><code>heatmap_cell</code></dt><dd><p>default &quot;P.unadj&quot;; the column of data for the cell of heatmap when formula with multiple factors is found in the method.</p>
</dd>
<dt><code>heatmap_sig</code></dt><dd><p>default &quot;Significance&quot;; the column of data for the significance label of heatmap.</p>
</dd>
<dt><code>heatmap_x</code></dt><dd><p>default &quot;Factors&quot;; the column of data for the x axis of heatmap.</p>
</dd>
<dt><code>heatmap_y</code></dt><dd><p>default &quot;Taxa&quot;; the column of data for the y axis of heatmap.</p>
</dd>
<dt><code>heatmap_lab_fill</code></dt><dd><p>default &quot;P value&quot;; legend title of heatmap.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passing to <code><a href="ggplot2.html#topic+geom_bar">geom_bar</a></code> for the bar plot or 
<code>plot_cor</code> function in <code><a href="#topic+trans_env">trans_env</a></code> class for the heatmap of multiple factors when formula is found in the method.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_diff_bar(use_number = 1:20)
}
</pre>
</div>


<hr>
<a id="method-trans_diff-plot_diff_cladogram"></a>



<h4>Method <code>plot_diff_cladogram()</code></h4>

<p>Plot the cladogram using taxa with significant difference.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_diff$plot_diff_cladogram(
  color = RColorBrewer::brewer.pal(8, "Dark2"),
  group_order = NULL,
  use_taxa_num = 200,
  filter_taxa = NULL,
  use_feature_num = NULL,
  clade_label_level = 4,
  select_show_labels = NULL,
  only_select_show = FALSE,
  sep = "|",
  branch_size = 0.2,
  alpha = 0.2,
  clade_label_size = 2,
  clade_label_size_add = 5,
  clade_label_size_log = exp(1),
  node_size_scale = 1,
  node_size_offset = 1,
  annotation_shape = 22,
  annotation_shape_size = 5
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); color palette used in the plot.</p>
</dd>
<dt><code>group_order</code></dt><dd><p>default NULL; a vector to order the legend in plot; 
If NULL, the function can first check whether the group column of sample_table is factor. If yes, use the levels in it.
If provided, this parameter can overwrite the levels in the group of sample_table. 
If the number of provided group_order is less than the number of groups in <code>res_diff$Group</code>, the function will select the groups of group_order automatically.</p>
</dd>
<dt><code>use_taxa_num</code></dt><dd><p>default 200; integer; The taxa number used in the background tree plot; select the taxa according to the mean abundance .</p>
</dd>
<dt><code>filter_taxa</code></dt><dd><p>default NULL; The mean relative abundance used to filter the taxa with low abundance.</p>
</dd>
<dt><code>use_feature_num</code></dt><dd><p>default NULL; integer; The feature number used in the plot; 
select the features according to the LDA score (method = &quot;lefse&quot;) or MeanDecreaseGini (method = &quot;rf&quot;) from high to low.</p>
</dd>
<dt><code>clade_label_level</code></dt><dd><p>default 4; the taxonomic level for marking the label with letters, root is the largest.</p>
</dd>
<dt><code>select_show_labels</code></dt><dd><p>default NULL; character vector; The features to show in the plot with full label names, not the letters.</p>
</dd>
<dt><code>only_select_show</code></dt><dd><p>default FALSE; whether only use the the select features in the parameter <code>select_show_labels</code>.</p>
</dd>
<dt><code>sep</code></dt><dd><p>default &quot;|&quot;; the seperate character in the taxonomic information.</p>
</dd>
<dt><code>branch_size</code></dt><dd><p>default 0.2; numberic, size of branch.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>default 0.2; shading of the color.</p>
</dd>
<dt><code>clade_label_size</code></dt><dd><p>default 2; basic size for the clade label; please also see <code>clade_label_size_add</code> and <code>clade_label_size_log</code>.</p>
</dd>
<dt><code>clade_label_size_add</code></dt><dd><p>default 5; added basic size for the clade label; see the formula in <code>clade_label_size_log</code> parameter.</p>
</dd>
<dt><code>clade_label_size_log</code></dt><dd><p>default <code>exp(1)</code>; the base of <code>log</code> function for added size of the clade label; the size formula: 
<code>clade_label_size + log(clade_label_level + clade_label_size_add, base = clade_label_size_log)</code>; 
so use <code>clade_label_size_log</code>, <code>clade_label_size_add</code> and <code>clade_label_size</code>
can totally control the label size for different taxonomic levels.</p>
</dd>
<dt><code>node_size_scale</code></dt><dd><p>default 1; scale for the node size.</p>
</dd>
<dt><code>node_size_offset</code></dt><dd><p>default 1; offset for the node size.</p>
</dd>
<dt><code>annotation_shape</code></dt><dd><p>default 22; shape used in the annotation legend.</p>
</dd>
<dt><code>annotation_shape_size</code></dt><dd><p>default 5; size used in the annotation legend.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_diff_cladogram(use_taxa_num = 100, use_feature_num = 30, select_show_labels = NULL)
}
</pre>
</div>


<hr>
<a id="method-trans_diff-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the trans_alpha object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_diff$print()</pre></div>


<hr>
<a id="method-trans_diff-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_diff$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_diff$new`
## ------------------------------------------------


data(dataset)
t1 &lt;- trans_diff$new(dataset = dataset, method = "lefse", group = "Group")
t1 &lt;- trans_diff$new(dataset = dataset, method = "rf", group = "Group")
t1 &lt;- trans_diff$new(dataset = dataset, method = "metastat", group = "Group", taxa_level = "Genus")
t1 &lt;- trans_diff$new(dataset = dataset, method = "wilcox", group = "Group")


## ------------------------------------------------
## Method `trans_diff$plot_diff_abund`
## ------------------------------------------------


t1 &lt;- trans_diff$new(dataset = dataset, method = "anova", group = "Group", taxa_level = "Genus")
t1$plot_diff_abund(use_number = 1:10)
t1$plot_diff_abund(use_number = 1:10, add_sig = TRUE)
t1 &lt;- trans_diff$new(dataset = dataset, method = "wilcox", group = "Group")
t1$plot_diff_abund(use_number = 1:20)
t1$plot_diff_abund(use_number = 1:20, add_sig = TRUE)
t1 &lt;- trans_diff$new(dataset = dataset, method = "lefse", group = "Group")
t1$plot_diff_abund(use_number = 1:20)
t1$plot_diff_abund(use_number = 1:20, add_sig = TRUE)


## ------------------------------------------------
## Method `trans_diff$plot_diff_bar`
## ------------------------------------------------


t1$plot_diff_bar(use_number = 1:20)


## ------------------------------------------------
## Method `trans_diff$plot_diff_cladogram`
## ------------------------------------------------


t1$plot_diff_cladogram(use_taxa_num = 100, use_feature_num = 30, select_show_labels = NULL)

</code></pre>

<hr>
<h2 id='trans_env'>Create <code>trans_env</code> object to analyze the association between environmental factor and microbial community.</h2><span id='topic+trans_env'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of operations associated with environmental measurements, including redundancy analysis, 
mantel test, correlation analysis and linear fitting.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_env-new"><code>trans_env$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-cal_diff"><code>trans_env$cal_diff()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-plot_diff"><code>trans_env$plot_diff()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-cal_autocor"><code>trans_env$cal_autocor()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-cal_ordination"><code>trans_env$cal_ordination()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-cal_ordination_anova"><code>trans_env$cal_ordination_anova()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-cal_ordination_envfit"><code>trans_env$cal_ordination_envfit()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-trans_ordination"><code>trans_env$trans_ordination()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-plot_ordination"><code>trans_env$plot_ordination()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-cal_mantel"><code>trans_env$cal_mantel()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-cal_cor"><code>trans_env$cal_cor()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-plot_cor"><code>trans_env$plot_cor()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-plot_scatterfit"><code>trans_env$plot_scatterfit()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-print"><code>trans_env$print()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_env-clone"><code>trans_env$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_env-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>trans_env$new(
  dataset = NULL,
  env_cols = NULL,
  add_data = NULL,
  character2numeric = FALSE,
  standardize = FALSE,
  complete_na = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>the object of <code><a href="#topic+microtable">microtable</a></code> Class.</p>
</dd>
<dt><code>env_cols</code></dt><dd><p>default NULL; either numeric vector or character vector to select columns in <code>microtable$sample_table</code>, i.e. dataset$sample_table. 
This parameter should be used in the case that all the required environmental data is in <code>sample_table</code> of your <code>microtable</code> object.
Otherwise, please use <code>add_data</code> parameter.</p>
</dd>
<dt><code>add_data</code></dt><dd><p>default NULL; <code>data.frame</code> format; provide the environmental data in the format <code>data.frame</code>; rownames should be sample names.
This parameter should be used when the <code>microtable$sample_table</code> object does not have environmental data. 
Under this circumstance, the <code>env_cols</code> parameter can not be used because no data can be selected.</p>
</dd>
<dt><code>character2numeric</code></dt><dd><p>default FALSE; whether convert the characters or factors to numeric values.</p>
</dd>
<dt><code>standardize</code></dt><dd><p>default FALSE; whether scale environmental variables to zero mean and unit variance.</p>
</dd>
<dt><code>complete_na</code></dt><dd><p>default FALSE; Whether fill the NA (missing value) in the environmental data;
If TRUE, the function can run the interpolation with the <code>mice</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data_env</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(dataset)
data(env_data_16S)
t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11])
</pre>
</div>


<hr>
<a id="method-trans_env-cal_diff"></a>



<h4>Method <code>cal_diff()</code></h4>

<p>Differential test of environmental variables across groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$cal_diff(
  group = NULL,
  by_group = NULL,
  method = c("KW", "KW_dunn", "wilcox", "t.test", "anova", "scheirerRayHare", "lme")[1],
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>default NULL; a colname of <code>sample_table</code> used to compare values across groups.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>default NULL; perform differential test among groups (<code>group</code> parameter) within each group (<code>by_group</code> parameter).</p>
</dd>
<dt><code>method</code></dt><dd><p>default &quot;KW&quot;; see the following available options:
</p>

<dl>
<dt><strong>'KW'</strong></dt><dd><p>KW: Kruskal-Wallis Rank Sum Test for all groups (&gt;= 2)</p>
</dd>
<dt><strong>'KW_dunn'</strong></dt><dd><p>Dunn's Kruskal-Wallis Multiple Comparisons, see <code>dunnTest</code> function in <code>FSA</code> package</p>
</dd>
<dt><strong>'wilcox'</strong></dt><dd><p>Wilcoxon Rank Sum and Signed Rank Tests for all paired groups</p>
</dd>
<dt><strong>'t.test'</strong></dt><dd><p>Student's t-Test for all paired groups</p>
</dd>
<dt><strong>'anova'</strong></dt><dd><p>Duncan's new multiple range test for one-way anova; see <code>duncan.test</code> function of <code>agricolae</code> package.
For multi-factor anova, see <code>aov</code></p>
</dd>
<dt><strong>'scheirerRayHare'</strong></dt><dd><p>Scheirer Ray Hare test for nonparametric test used for a two-way factorial experiment; 
see <code>scheirerRayHare</code> function of <code>rcompanion</code> package</p>
</dd>
<dt><strong>'lme'</strong></dt><dd><p>lme: Linear Mixed Effect Model based on the <code>lmerTest</code> package</p>
</dd>
</dl>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>cal_diff</code> function of <code><a href="#topic+trans_alpha">trans_alpha</a></code> class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_diff</code> stored in the object.
In the data frame, 'Group' column means that the group has the maximum median or mean value across the test groups;
For non-parametric methods, median value; For t.test, mean value.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_diff(group = "Group", method = "KW")
t1$cal_diff(group = "Group", method = "anova")
}
</pre>
</div>


<hr>
<a id="method-trans_env-plot_diff"></a>



<h4>Method <code>plot_diff()</code></h4>

<p>Plot environmental variables across groups and add the significance label.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$plot_diff(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>parameters passed to <code>plot_alpha</code> in <code><a href="#topic+trans_alpha">trans_alpha</a></code> class. 
Please see <code>plot_alpha</code> function of <code><a href="#topic+trans_alpha">trans_alpha</a></code> for all the available parameters.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-trans_env-cal_autocor"></a>



<h4>Method <code>cal_autocor()</code></h4>

<p>Calculate the autocorrelations among environmental variables.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$cal_autocor(
  group = NULL,
  ggpairs = TRUE,
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  alpha = 0.8,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>group</code></dt><dd><p>default NULL; a colname of sample_table; used to perform calculations for different groups.</p>
</dd>
<dt><code>ggpairs</code></dt><dd><p>default TRUE; whether use <code>GGally::ggpairs</code> function to plot the correlation results.</p>
</dd>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); colors palette.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>default 0.8; the alpha value to add transparency in colors; useful when group is not NULL.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>GGally::ggpairs</code> when <code>ggpairs = TRUE</code> or 
passed to <code>cal_cor</code> of <code>trans_env</code> class when <code>ggpairs = FALSE</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>ggmatrix</code> when <code>ggpairs = TRUE</code> or data.frame object when <code>ggpairs = FALSE</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# Spearman correlation
t1$cal_autocor(upper = list(continuous = GGally::wrap("cor", method= "spearman")))
}
</pre>
</div>


<hr>
<a id="method-trans_env-cal_ordination"></a>



<h4>Method <code>cal_ordination()</code></h4>

<p>Redundancy analysis (RDA) and Correspondence Analysis (CCA) based on the <code>vegan</code> package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$cal_ordination(
  method = c("RDA", "dbRDA", "CCA")[1],
  feature_sel = FALSE,
  taxa_level = NULL,
  taxa_filter_thres = NULL,
  use_measure = NULL,
  add_matrix = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default c(&quot;RDA&quot;, &quot;dbRDA&quot;, &quot;CCA&quot;)[1]; the ordination method.</p>
</dd>
<dt><code>feature_sel</code></dt><dd><p>default FALSE; whether perform the feature selection based on forward selection method.</p>
</dd>
<dt><code>taxa_level</code></dt><dd><p>default NULL; If use RDA or CCA, provide the taxonomic rank, such as &quot;Phylum&quot; or &quot;Genus&quot;;
If use otu_table; please set <code>taxa_level = "OTU"</code>.</p>
</dd>
<dt><code>taxa_filter_thres</code></dt><dd><p>default NULL; relative abundance threshold used to filter taxa when method is &quot;RDA&quot; or &quot;CCA&quot;.</p>
</dd>
<dt><code>use_measure</code></dt><dd><p>default NULL; a name of beta diversity matrix; only available when parameter <code>method = "dbRDA"</code>;
If not provided, use the first beta diversity matrix in the <code>microtable$beta_diversity</code> automatically.</p>
</dd>
<dt><code>add_matrix</code></dt><dd><p>default NULL; additional distance matrix provided, when the user does not want to use the beta diversity matrix within the dataset;
only available when method = &quot;dbRDA&quot;.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters passed to <code>dbrda</code>, <code>rda</code> or <code>cca</code> function according to the <code>method</code> parameter.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_ordination</code> and <code>res_ordination_R2</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_ordination(method = "dbRDA", use_measure = "bray")
t1$cal_ordination(method = "RDA", taxa_level = "Genus")
t1$cal_ordination(method = "CCA", taxa_level = "Genus")
}
</pre>
</div>


<hr>
<a id="method-trans_env-cal_ordination_anova"></a>



<h4>Method <code>cal_ordination_anova()</code></h4>

<p>Use anova to test the significance of the terms and axis in ordination.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$cal_ordination_anova(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>parameters passed to <code>anova</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_ordination_terms and res_ordination_axis</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_ordination_anova()
}
</pre>
</div>


<hr>
<a id="method-trans_env-cal_ordination_envfit"></a>



<h4>Method <code>cal_ordination_envfit()</code></h4>

<p>Fit each environmental vector onto the ordination to obtain the contribution of each variable.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$cal_ordination_envfit(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>the parameters passed to <code>vegan::envfit</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_ordination_envfit</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_ordination_envfit()
}
</pre>
</div>


<hr>
<a id="method-trans_env-trans_ordination"></a>



<h4>Method <code>trans_ordination()</code></h4>

<p>Transform ordination results for the following plot.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$trans_ordination(
  show_taxa = 10,
  adjust_arrow_length = FALSE,
  min_perc_env = 0.1,
  max_perc_env = 0.8,
  min_perc_tax = 0.1,
  max_perc_tax = 0.8
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>show_taxa</code></dt><dd><p>default 10; taxa number shown in the plot.</p>
</dd>
<dt><code>adjust_arrow_length</code></dt><dd><p>default FALSE; whether adjust the arrow length to be clearer.</p>
</dd>
<dt><code>min_perc_env</code></dt><dd><p>default 0.1; used for scaling up the minimum of env arrow; multiply by the maximum distance between samples and origin.</p>
</dd>
<dt><code>max_perc_env</code></dt><dd><p>default 0.8; used for scaling up the maximum of env arrow; multiply by the maximum distance between samples and origin.</p>
</dd>
<dt><code>min_perc_tax</code></dt><dd><p>default 0.1; used for scaling up the minimum of tax arrow; multiply by the maximum distance between samples and origin.</p>
</dd>
<dt><code>max_perc_tax</code></dt><dd><p>default 0.8; used for scaling up the maximum of tax arrow; multiply by the maximum distance between samples and origin.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_ordination_trans</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$trans_ordination(adjust_arrow_length = TRUE, min_perc_env = 0.1, max_perc_env = 1)
}
</pre>
</div>


<hr>
<a id="method-trans_env-plot_ordination"></a>



<h4>Method <code>plot_ordination()</code></h4>

<p>plot ordination result.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$plot_ordination(
  plot_color = NULL,
  plot_shape = NULL,
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  shape_values = c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14),
  env_text_color = "black",
  env_arrow_color = "grey30",
  taxa_text_color = "firebrick1",
  taxa_arrow_color = "firebrick1",
  env_text_size = 3.7,
  taxa_text_size = 3,
  taxa_text_italic = TRUE,
  plot_type = "point",
  point_size = 3,
  point_alpha = 0.8,
  centroid_segment_alpha = 0.6,
  centroid_segment_size = 1,
  centroid_segment_linetype = 3,
  ellipse_chull_fill = TRUE,
  ellipse_chull_alpha = 0.1,
  ellipse_level = 0.9,
  ellipse_type = "t",
  add_sample_label = NULL,
  env_nudge_x = NULL,
  env_nudge_y = NULL,
  taxa_nudge_x = NULL,
  taxa_nudge_y = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_color</code></dt><dd><p>default NULL; a colname of <code>sample_table</code> to assign colors to different groups.</p>
</dd>
<dt><code>plot_shape</code></dt><dd><p>default NULL; a colname of <code>sample_table</code> to assign shapes to different groups.</p>
</dd>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); color pallete for different groups.</p>
</dd>
<dt><code>shape_values</code></dt><dd><p>default c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14); a vector for point shape types of groups, see ggplot2 tutorial.</p>
</dd>
<dt><code>env_text_color</code></dt><dd><p>default &quot;black&quot;; environmental variable text color.</p>
</dd>
<dt><code>env_arrow_color</code></dt><dd><p>default &quot;grey30&quot;; environmental variable arrow color.</p>
</dd>
<dt><code>taxa_text_color</code></dt><dd><p>default &quot;firebrick1&quot;; taxa text color.</p>
</dd>
<dt><code>taxa_arrow_color</code></dt><dd><p>default &quot;firebrick1&quot;; taxa arrow color.</p>
</dd>
<dt><code>env_text_size</code></dt><dd><p>default 3.7; environmental variable text size.</p>
</dd>
<dt><code>taxa_text_size</code></dt><dd><p>default 3; taxa text size.</p>
</dd>
<dt><code>taxa_text_italic</code></dt><dd><p>default TRUE; &quot;italic&quot;; whether use &quot;italic&quot; style for the taxa text.</p>
</dd>
<dt><code>plot_type</code></dt><dd><p>default &quot;point&quot;; plotting type of samples;
one or more elements of &quot;point&quot;, &quot;ellipse&quot;, &quot;chull&quot;, &quot;centroid&quot; and &quot;none&quot;; &quot;none&quot; denotes nothing.
</p>

<dl>
<dt><strong>'point'</strong></dt><dd><p>add point</p>
</dd>
<dt><strong>'ellipse'</strong></dt><dd><p>add confidence ellipse for points of each group</p>
</dd>
<dt><strong>'chull'</strong></dt><dd><p>add convex hull for points of each group</p>
</dd>
<dt><strong>'centroid'</strong></dt><dd><p>add centroid line of each group</p>
</dd>
</dl>
</dd>
<dt><code>point_size</code></dt><dd><p>default 3; point size in plot when &quot;point&quot; is in <code>plot_type</code>.</p>
</dd>
<dt><code>point_alpha</code></dt><dd><p>default .8; point transparency in plot when &quot;point&quot; is in <code>plot_type</code>.</p>
</dd>
<dt><code>centroid_segment_alpha</code></dt><dd><p>default 0.6; segment transparency in plot when &quot;centroid&quot; is in <code>plot_type</code>.</p>
</dd>
<dt><code>centroid_segment_size</code></dt><dd><p>default 1; segment size in plot when &quot;centroid&quot; is in <code>plot_type</code>.</p>
</dd>
<dt><code>centroid_segment_linetype</code></dt><dd><p>default 3; an integer; the line type related with centroid in plot when &quot;centroid&quot; is in <code>plot_type</code>.</p>
</dd>
<dt><code>ellipse_chull_fill</code></dt><dd><p>default TRUE; whether fill colors to the area of ellipse or chull.</p>
</dd>
<dt><code>ellipse_chull_alpha</code></dt><dd><p>default 0.1; color transparency in the ellipse or convex hull depending on whether &quot;ellipse&quot; or &quot;centroid&quot; is in <code>plot_type</code>.</p>
</dd>
<dt><code>ellipse_level</code></dt><dd><p>default .9; confidence level of ellipse when &quot;ellipse&quot; is in <code>plot_type</code>.</p>
</dd>
<dt><code>ellipse_type</code></dt><dd><p>default &quot;t&quot;; ellipse type when &quot;ellipse&quot; is in <code>plot_type</code>; see type in <code><a href="ggplot2.html#topic+stat_ellipse">stat_ellipse</a></code>.</p>
</dd>
<dt><code>add_sample_label</code></dt><dd><p>default NULL; the column name in sample table, if provided, show the point name in plot.</p>
</dd>
<dt><code>env_nudge_x</code></dt><dd><p>default NULL; numeric vector to adjust the env text x axis position; passed to nudge_x parameter of <code>ggrepel::geom_text_repel</code> function;
default NULL represents automatic adjustment; the length must be same with the row number of <code>object$res_ordination_trans$df_arrows</code>. For example, 
if there are 5 env variables, env_nudge_x should be something like <code>c(0.1, 0, -0.2, 0, 0)</code>. 
Note that this parameter and env_nudge_y is generally used when the automatic text adjustment is not very well.</p>
</dd>
<dt><code>env_nudge_y</code></dt><dd><p>default NULL; numeric vector to adjust the env text y axis position; passed to nudge_y parameter of ggrepel::geom_text_repel function;
default NULL represents automatic adjustment; the length must be same with the row number of <code>object$res_ordination_trans$df_arrows</code>. For example, 
if there are 5 env variables, env_nudge_y should be something like <code>c(0.1, 0, -0.2, 0, 0)</code>.</p>
</dd>
<dt><code>taxa_nudge_x</code></dt><dd><p>default NULL; numeric vector to adjust the taxa text x axis position; passed to nudge_x parameter of ggrepel::geom_text_repel function;
default NULL represents automatic adjustment; the length must be same with the row number of <code>object$res_ordination_trans$df_arrows_spe</code>. For example, 
if 3 taxa are shown, taxa_nudge_x should be something like <code>c(0.3, -0.2, 0)</code>.</p>
</dd>
<dt><code>taxa_nudge_y</code></dt><dd><p>default NULL; numeric vector to adjust the taxa text y axis position; passed to nudge_y parameter of ggrepel::geom_text_repel function;
default NULL represents automatic adjustment; the length must be same with the row number of <code>object$res_ordination_trans$df_arrows_spe</code>. For example, 
if 3 taxa are shown, taxa_nudge_y should be something like <code>c(-0.2, 0, 0.4)</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters passed to <code>geom_point</code> for controlling sample points.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_ordination(method = "RDA")
t1$trans_ordination(adjust_arrow_length = TRUE, max_perc_env = 1.5)
t1$plot_ordination(plot_color = "Group")
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "chull"))
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), 
	  centroid_segment_linetype = 1)
t1$plot_ordination(plot_color = "Group", env_nudge_x = c(0.4, 0, 0, 0, 0, -0.2, 0, 0), 
	  env_nudge_y = c(0.6, 0, 0.2, 0.5, 0, 0.1, 0, 0.2))
}
</pre>
</div>


<hr>
<a id="method-trans_env-cal_mantel"></a>



<h4>Method <code>cal_mantel()</code></h4>

<p>Mantel test between beta diversity matrix and environmental data.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$cal_mantel(
  partial_mantel = FALSE,
  add_matrix = NULL,
  use_measure = NULL,
  method = "pearson",
  p_adjust_method = "fdr",
  by_group = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>partial_mantel</code></dt><dd><p>default FALSE; whether use partial mantel test; If TRUE, use other all measurements as the zdis in each calculation.</p>
</dd>
<dt><code>add_matrix</code></dt><dd><p>default NULL; additional distance matrix provided when the beta diversity matrix in the dataset is not used.</p>
</dd>
<dt><code>use_measure</code></dt><dd><p>default NULL; a name of beta diversity matrix. If necessary and not provided, use the first beta diversity matrix.</p>
</dd>
<dt><code>method</code></dt><dd><p>default &quot;pearson&quot;; one of &quot;pearson&quot;, &quot;spearman&quot; and &quot;kendall&quot;; correlation method; see method parameter in <code>vegan::mantel</code> function.</p>
</dd>
<dt><code>p_adjust_method</code></dt><dd><p>default &quot;fdr&quot;; p.adjust method; see method parameter of <code>p.adjust</code> function for available options.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>default NULL; one column name or number in sample_table; used to perform mantel test for different groups separately.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters passed to <code><a href="vegan.html#topic+mantel">mantel</a></code> of vegan package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_mantel</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_mantel(use_measure = "bray")
t1$cal_mantel(partial_mantel = TRUE, use_measure = "bray")
}
</pre>
</div>


<hr>
<a id="method-trans_env-cal_cor"></a>



<h4>Method <code>cal_cor()</code></h4>

<p>Calculate the correlations between taxonomic abundance and environmental variables.
Actually, it can also be applied to other correlation between any two variables from two tables.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$cal_cor(
  use_data = c("Genus", "all", "other")[1],
  cor_method = c("pearson", "spearman", "kendall", "maaslin2")[1],
  add_abund_table = NULL,
  filter_thres = 0,
  use_taxa_num = NULL,
  other_taxa = NULL,
  p_adjust_method = "fdr",
  p_adjust_type = c("All", "Type", "Taxa", "Env")[1],
  by_group = NULL,
  group_use = NULL,
  group_select = NULL,
  taxa_name_full = TRUE,
  tmp_input_maaslin2 = "tmp_input",
  tmp_output_maaslin2 = "tmp_output",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_data</code></dt><dd><p>default &quot;Genus&quot;; &quot;Genus&quot;, &quot;all&quot; or &quot;other&quot;; &quot;Genus&quot; or other taxonomic name: use genus or other taxonomic abundance table in <code>taxa_abund</code>; 
&quot;all&quot;: use all merged taxonomic abundance table; &quot;other&quot;: provide additional taxa name with <code>other_taxa</code> parameter which is necessary.</p>
</dd>
<dt><code>cor_method</code></dt><dd><p>default &quot;pearson&quot;; &quot;pearson&quot;, &quot;spearman&quot;, &quot;kendall&quot; or &quot;maaslin2&quot;; correlation method.
&quot;pearson&quot;, &quot;spearman&quot; or &quot;kendall&quot; all refer to the correlation analysis based on the <code>cor.test</code> function in R.
&quot;maaslin2&quot; is the method in <code>Maaslin2</code> package for finding associations between metadata and potentially high-dimensional microbial multi-omics data.</p>
</dd>
<dt><code>add_abund_table</code></dt><dd><p>default NULL; additional data table to be used. Samples must be rows.</p>
</dd>
<dt><code>filter_thres</code></dt><dd><p>default 0; the abundance threshold, such as 0.0005 when the input is relative abundance.
The features with abundances lower than filter_thres will be filtered. This parameter cannot be applied when add_abund_table parameter is provided.</p>
</dd>
<dt><code>use_taxa_num</code></dt><dd><p>default NULL; integer; a number used to select high abundant taxa; only useful when <code>use_data</code> parameter is a taxonomic level, e.g., &quot;Genus&quot;.</p>
</dd>
<dt><code>other_taxa</code></dt><dd><p>default NULL; character vector containing a series of feature names; used when use_data = &quot;other&quot;; 
provided names should be standard full names used to select taxa from all the tables in taxa_abund list of the microtable object;
please see the example.</p>
</dd>
<dt><code>p_adjust_method</code></dt><dd><p>default &quot;fdr&quot;; p.adjust method; see method parameter of <code>p.adjust</code> function for available options.
<code>p_adjust_method = "none"</code> can disable the p value adjustment.</p>
</dd>
<dt><code>p_adjust_type</code></dt><dd><p>default &quot;All&quot;; &quot;All&quot;, &quot;Type&quot;, &quot;Taxa&quot; or &quot;Env&quot;; P value adjustment type.
&quot;Env&quot;: adjustment for each environmental variable separately; 
&quot;Taxa&quot;: adjustment for each taxon separately; 
&quot;Type&quot;: adjustment according to the groups provided. If <code>by_group</code> is NULL, adjustment is performed for all the data together.
If <code>by_group</code> is provided, for each group in it separately.
These three options are the first three colnames of return table <code>res_cor</code>.
&quot;All&quot;: adjustment for all the data together no matter whether <code>by_group</code> is provided. If <code>by_group</code> is NULL, it is same with the &quot;Type&quot; option.</p>
</dd>
<dt><code>by_group</code></dt><dd><p>default NULL; one column name or number in sample_table; calculate correlations for different groups separately.</p>
</dd>
<dt><code>group_use</code></dt><dd><p>default NULL; numeric or character vector to select one column in sample_table for selecting samples; together with group_select.</p>
</dd>
<dt><code>group_select</code></dt><dd><p>default NULL; the group name used; remain samples within the group.</p>
</dd>
<dt><code>taxa_name_full</code></dt><dd><p>default TRUE; Whether use the complete taxonomic name of taxa.</p>
</dd>
<dt><code>tmp_input_maaslin2</code></dt><dd><p>default &quot;tmp_input&quot;; the temporary folder used to save the input files for Maaslin2.</p>
</dd>
<dt><code>tmp_output_maaslin2</code></dt><dd><p>default &quot;tmp_output&quot;; the temporary folder used to save the output files of Maaslin2.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>Maaslin2</code> function of <code>Maaslin2</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_cor</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t2 &lt;- trans_diff$new(dataset = dataset, method = "rf", group = "Group", rf_taxa_level = "Genus")
t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11])
t1$cal_cor(use_data = "other", p_adjust_method = "fdr", other_taxa = t2$res_diff$Taxa[1:40])
t1$cal_cor(use_data = "other", p_adjust_type = "Env", other_taxa = t2$res_diff$Taxa[1:40])
}
</pre>
</div>


<hr>
<a id="method-trans_env-plot_cor"></a>



<h4>Method <code>plot_cor()</code></h4>

<p>Plot correlation heatmap.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$plot_cor(
  color_vector = c("#053061", "white", "#A50026"),
  color_palette = NULL,
  pheatmap = FALSE,
  filter_feature = NULL,
  filter_env = NULL,
  ylab_type_italic = FALSE,
  keep_full_name = FALSE,
  keep_prefix = TRUE,
  text_y_order = NULL,
  text_x_order = NULL,
  xtext_angle = 30,
  xtext_size = 10,
  font_family = NULL,
  cluster_ggplot = "none",
  cluster_height_rows = 0.2,
  cluster_height_cols = 0.2,
  text_y_position = "right",
  mylabels_x = NULL,
  na.value = "grey50",
  trans = "identity",
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_vector</code></dt><dd><p>default <code>c("#053061", "white", "#A50026")</code>; colors with only three values representing low, middle and high values.</p>
</dd>
<dt><code>color_palette</code></dt><dd><p>default NULL; a customized palette with more color values to be used instead of the parameter <code>color_vector</code>.</p>
</dd>
<dt><code>pheatmap</code></dt><dd><p>default FALSE; whether use pheatmap package to plot the heatmap.</p>
</dd>
<dt><code>filter_feature</code></dt><dd><p>default NULL; character vector; used to filter features that only have labels in the <code>filter_feature</code> vector. 
For example, <code>filter_feature = ""</code> can be used to remove features that only have &quot;&quot;, no any &quot;*&quot;.</p>
</dd>
<dt><code>filter_env</code></dt><dd><p>default NULL; character vector; used to filter environmental variables that only have labels in the <code>filter_env</code> vector. 
For example, <code>filter_env = ""</code> can be used to remove features that only have &quot;&quot;, no any &quot;*&quot;.</p>
</dd>
<dt><code>ylab_type_italic</code></dt><dd><p>default FALSE; whether use italic type for y lab text.</p>
</dd>
<dt><code>keep_full_name</code></dt><dd><p>default FALSE; whether use the complete taxonomic name.</p>
</dd>
<dt><code>keep_prefix</code></dt><dd><p>default TRUE; whether retain the taxonomic prefix.</p>
</dd>
<dt><code>text_y_order</code></dt><dd><p>default NULL; character vector; provide customized text order for y axis; shown in the plot from the top down.</p>
</dd>
<dt><code>text_x_order</code></dt><dd><p>default NULL; character vector; provide customized text order for x axis.</p>
</dd>
<dt><code>xtext_angle</code></dt><dd><p>default 30; number ranging from 0 to 90; used to adjust x axis text angle.</p>
</dd>
<dt><code>xtext_size</code></dt><dd><p>default 10; x axis text size.</p>
</dd>
<dt><code>font_family</code></dt><dd><p>default NULL; font family used in <code>ggplot2</code>; only available when <code>pheatmap = FALSE</code>.</p>
</dd>
<dt><code>cluster_ggplot</code></dt><dd><p>default &quot;none&quot;; add clustering dendrogram for <code>ggplot2</code> based heatmap. Available options: &quot;none&quot;, &quot;row&quot;, &quot;col&quot; or &quot;both&quot;. 
&quot;none&quot;: no any clustering used; &quot;row&quot;: add clustering for rows; &quot;col&quot;: add clustering for columns; &quot;both&quot;: add clustering for both rows and columns.
Only available when <code>pheatmap = FALSE</code>.</p>
</dd>
<dt><code>cluster_height_rows</code></dt><dd><p>default 0.2, the dendrogram plot height for rows; available when <code>cluster_ggplot</code> is not &quot;none&quot;.</p>
</dd>
<dt><code>cluster_height_cols</code></dt><dd><p>default 0.2, the dendrogram plot height for columns; available when <code>cluster_ggplot</code> is not &quot;none&quot;.</p>
</dd>
<dt><code>text_y_position</code></dt><dd><p>default &quot;right&quot;; &quot;left&quot; or &quot;right&quot;; the y axis text position for ggplot2 based heatmap.</p>
</dd>
<dt><code>mylabels_x</code></dt><dd><p>default NULL; provide x axis text labels additionally; only available when <code>pheatmap = TRUE</code>.</p>
</dd>
<dt><code>na.value</code></dt><dd><p>default &quot;grey50&quot;; the color for the missing values when <code>pheatmap = FALSE</code>.</p>
</dd>
<dt><code>trans</code></dt><dd><p>default &quot;identity&quot;; the transformation for continuous scales in the legend when <code>pheatmap = FALSE</code>; 
see the <code>trans</code> item in <code>ggplot2::scale_colour_gradientn</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters passed to <code>ggplot2::geom_tile</code> or <code>pheatmap::pheatmap</code>, depending on the parameter <code>pheatmap</code> is FALSE or TRUE.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>plot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_cor(pheatmap = FALSE)
}
</pre>
</div>


<hr>
<a id="method-trans_env-plot_scatterfit"></a>



<h4>Method <code>plot_scatterfit()</code></h4>

<p>Scatter plot with fitted line based on the correlation or regression.<br />
The most important thing is to make sure that the input x and y
have correponding sample orders. If one of x and y is a matrix, the other will be also transformed to matrix with Euclidean distance.
Then, both of them are transformed to be vectors. If x or y is a vector with a single value, x or y will be
assigned according to the column selection of the <code>data_env</code> in the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$plot_scatterfit(
  x = NULL,
  y = NULL,
  group = NULL,
  group_order = NULL,
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  shape_values = NULL,
  type = c("cor", "lm")[1],
  cor_method = "pearson",
  label_sep = ";",
  label.x.npc = "left",
  label.y.npc = "top",
  label.x = NULL,
  label.y = NULL,
  x_axis_title = "",
  y_axis_title = "",
  point_size = 5,
  point_alpha = 0.6,
  line_size = 0.8,
  line_alpha = 1,
  line_color = "black",
  line_se = TRUE,
  line_se_color = "grey70",
  pvalue_trim = 4,
  cor_coef_trim = 3,
  lm_equation = TRUE,
  lm_fir_trim = 2,
  lm_sec_trim = 2,
  lm_squ_trim = 2,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>default NULL; a single numeric or character value, a vector, or a distance matrix used for the x axis.
If x is a single value, it will be used to select the column of <code>data_env</code> in the object.
If x is a distance matrix, it will be transformed to be a vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>default NULL; a single numeric or character value, a vector, or a distance matrix used for the y axis.
If y is a single value, it will be used to select the column of <code>data_env</code> in the object.
If y is a distance matrix, it will be transformed to be a vector.</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; a character vector; if length is 1, must be a colname of <code>sample_table</code> in the input dataset;
Otherwise, group should be a vector having same length with x/y (for vector) or column number of x/y (for matrix).</p>
</dd>
<dt><code>group_order</code></dt><dd><p>default NULL; a vector used to order groups, i.e. reorder the legend and colors in plot when group is not NULL; 
If group_order is NULL and group is provided, the function can first check whether the group column of <code>sample_table</code> is factor. 
If group_order is provided, disable the group orders or factor levels in the <code>group</code> column of <code>sample_table</code>.</p>
</dd>
<dt><code>color_values</code></dt><dd><p>default <code>RColorBrewer::brewer.pal</code>(8, &quot;Dark2&quot;); color pallete for different groups.</p>
</dd>
<dt><code>shape_values</code></dt><dd><p>default NULL; a numeric vector for point shape types of groups when group is not NULL, see ggplot2 tutorial.</p>
</dd>
<dt><code>type</code></dt><dd><p>default c(&quot;cor&quot;, &quot;lm&quot;)[1]; &quot;cor&quot;: correlation; &quot;lm&quot; for regression.</p>
</dd>
<dt><code>cor_method</code></dt><dd><p>default &quot;pearson&quot;; one of &quot;pearson&quot;, &quot;kendall&quot; and &quot;spearman&quot;; correlation method.</p>
</dd>
<dt><code>label_sep</code></dt><dd><p>default &quot;;&quot;; the separator string between different label parts.</p>
</dd>
<dt><code>label.x.npc</code></dt><dd><p>default &quot;left&quot;; can be numeric or character vector of the same length as the number of groups and/or panels. If too short, they will be recycled.
</p>

<dl>
<dt>numeric</dt><dd><p>value should be between 0 and 1. Coordinates to be used for positioning the label, expressed in &quot;normalized parent coordinates&quot;</p>
</dd>
<dt>character</dt><dd><p>allowed values include: i) one of c('right', 'left', 'center', 'centre', 'middle') for x-axis; ii) and one of 
c( 'bottom', 'top', 'center', 'centre', 'middle') for y-axis.</p>
</dd>
</dl>
</dd>
<dt><code>label.y.npc</code></dt><dd><p>default &quot;top&quot;; same usage with label.x.npc; also see <code>label.y.npc</code> parameter of <code>ggpubr::stat_cor</code> function.</p>
</dd>
<dt><code>label.x</code></dt><dd><p>default NULL; x axis absolute position for adding the statistic label.</p>
</dd>
<dt><code>label.y</code></dt><dd><p>default NULL; x axis absolute position for adding the statistic label.</p>
</dd>
<dt><code>x_axis_title</code></dt><dd><p>default &quot;&quot;; the title of x axis.</p>
</dd>
<dt><code>y_axis_title</code></dt><dd><p>default &quot;&quot;; the title of y axis.</p>
</dd>
<dt><code>point_size</code></dt><dd><p>default 5; point size value.</p>
</dd>
<dt><code>point_alpha</code></dt><dd><p>default 0.6; alpha value for the point color transparency.</p>
</dd>
<dt><code>line_size</code></dt><dd><p>default 0.8; line size value.</p>
</dd>
<dt><code>line_alpha</code></dt><dd><p>default 1; alpha value for the line color transparency.</p>
</dd>
<dt><code>line_color</code></dt><dd><p>default &quot;black&quot;; fitted line color; only available when <code>group = NULL</code>.</p>
</dd>
<dt><code>line_se</code></dt><dd><p>default TRUE; Whether show the confidence interval for the fitting.</p>
</dd>
<dt><code>line_se_color</code></dt><dd><p>default &quot;grey70&quot;; the color to fill the confidence interval when <code>line_se = TRUE</code>.</p>
</dd>
<dt><code>pvalue_trim</code></dt><dd><p>default 4; trim the decimal places of p value.</p>
</dd>
<dt><code>cor_coef_trim</code></dt><dd><p>default 3; trim the decimal places of correlation coefficient.</p>
</dd>
<dt><code>lm_equation</code></dt><dd><p>default TRUE; whether include the equation in the label when <code>type = "lm"</code>.</p>
</dd>
<dt><code>lm_fir_trim</code></dt><dd><p>default 2; trim the decimal places of first coefficient in regression.</p>
</dd>
<dt><code>lm_sec_trim</code></dt><dd><p>default 2; trim the decimal places of second coefficient in regression.</p>
</dd>
<dt><code>lm_squ_trim</code></dt><dd><p>default 2; trim the decimal places of R square in regression.</p>
</dd>
<dt><code>...</code></dt><dd><p>other arguments passed to <code>geom_text</code> or <code>geom_label</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_scatterfit(x = 1, y = 2, type = "cor")
t1$plot_scatterfit(x = 1, y = 2, type = "lm", point_alpha = .3)
t1$plot_scatterfit(x = "pH", y = "TOC", type = "lm", group = "Group", line_se = FALSE)
t1$plot_scatterfit(x = 
	 dataset$beta_diversity$bray[rownames(t1$data_env), rownames(t1$data_env)], y = "pH")
}
</pre>
</div>


<hr>
<a id="method-trans_env-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the trans_env object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$print()</pre></div>


<hr>
<a id="method-trans_env-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_env$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_env$new`
## ------------------------------------------------

data(dataset)
data(env_data_16S)
t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11])

## ------------------------------------------------
## Method `trans_env$cal_diff`
## ------------------------------------------------


t1$cal_diff(group = "Group", method = "KW")
t1$cal_diff(group = "Group", method = "anova")


## ------------------------------------------------
## Method `trans_env$cal_autocor`
## ------------------------------------------------

## Not run: 
# Spearman correlation
t1$cal_autocor(upper = list(continuous = GGally::wrap("cor", method= "spearman")))

## End(Not run)

## ------------------------------------------------
## Method `trans_env$cal_ordination`
## ------------------------------------------------


t1$cal_ordination(method = "dbRDA", use_measure = "bray")
t1$cal_ordination(method = "RDA", taxa_level = "Genus")
t1$cal_ordination(method = "CCA", taxa_level = "Genus")


## ------------------------------------------------
## Method `trans_env$cal_ordination_anova`
## ------------------------------------------------


t1$cal_ordination_anova()


## ------------------------------------------------
## Method `trans_env$cal_ordination_envfit`
## ------------------------------------------------


t1$cal_ordination_envfit()


## ------------------------------------------------
## Method `trans_env$trans_ordination`
## ------------------------------------------------


t1$trans_ordination(adjust_arrow_length = TRUE, min_perc_env = 0.1, max_perc_env = 1)


## ------------------------------------------------
## Method `trans_env$plot_ordination`
## ------------------------------------------------


t1$cal_ordination(method = "RDA")
t1$trans_ordination(adjust_arrow_length = TRUE, max_perc_env = 1.5)
t1$plot_ordination(plot_color = "Group")
t1$plot_ordination(plot_color = "Group", plot_shape = "Group", plot_type = c("point", "ellipse"))
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "chull"))
t1$plot_ordination(plot_color = "Group", plot_type = c("point", "centroid"), 
	  centroid_segment_linetype = 1)
t1$plot_ordination(plot_color = "Group", env_nudge_x = c(0.4, 0, 0, 0, 0, -0.2, 0, 0), 
	  env_nudge_y = c(0.6, 0, 0.2, 0.5, 0, 0.1, 0, 0.2))


## ------------------------------------------------
## Method `trans_env$cal_mantel`
## ------------------------------------------------


t1$cal_mantel(use_measure = "bray")
t1$cal_mantel(partial_mantel = TRUE, use_measure = "bray")


## ------------------------------------------------
## Method `trans_env$cal_cor`
## ------------------------------------------------


t2 &lt;- trans_diff$new(dataset = dataset, method = "rf", group = "Group", rf_taxa_level = "Genus")
t1 &lt;- trans_env$new(dataset = dataset, add_data = env_data_16S[, 4:11])
t1$cal_cor(use_data = "other", p_adjust_method = "fdr", other_taxa = t2$res_diff$Taxa[1:40])
t1$cal_cor(use_data = "other", p_adjust_type = "Env", other_taxa = t2$res_diff$Taxa[1:40])


## ------------------------------------------------
## Method `trans_env$plot_cor`
## ------------------------------------------------


t1$plot_cor(pheatmap = FALSE)


## ------------------------------------------------
## Method `trans_env$plot_scatterfit`
## ------------------------------------------------


t1$plot_scatterfit(x = 1, y = 2, type = "cor")
t1$plot_scatterfit(x = 1, y = 2, type = "lm", point_alpha = .3)
t1$plot_scatterfit(x = "pH", y = "TOC", type = "lm", group = "Group", line_se = FALSE)
t1$plot_scatterfit(x = 
	 dataset$beta_diversity$bray[rownames(t1$data_env), rownames(t1$data_env)], y = "pH")

</code></pre>

<hr>
<h2 id='trans_func'>Create <code>trans_func</code> object for functional prediction.</h2><span id='topic+trans_func'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of functional prediction analysis on species and communities, including the prokaryotic trait prediction based on 
Louca et al. (2016) &lt;doi:10.1126/science.aaf4507&gt; and Lim et al. (2020) &lt;10.1038/s41597-020-0516-5&gt;, 
or fungal trait prediction based on Nguyen et al. (2016) &lt;10.1016/j.funeco.2015.06.006&gt; and Polme et al. (2020) &lt;doi:10.1007/s13225-020-00466-2&gt;; 
functional redundancy calculation and metabolic pathway abundance prediction Abhauer et al. (2015) &lt;10.1093/bioinformatics/btv287&gt;.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>func_group_list</code></dt><dd><p>store and show the function group list</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_func-new"><code>trans_func$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-cal_spe_func"><code>trans_func$cal_spe_func()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-cal_spe_func_perc"><code>trans_func$cal_spe_func_perc()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-show_prok_func"><code>trans_func$show_prok_func()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-trans_spe_func_perc"><code>trans_func$trans_spe_func_perc()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-plot_spe_func_perc"><code>trans_func$plot_spe_func_perc()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-cal_tax4fun"><code>trans_func$cal_tax4fun()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-cal_tax4fun2"><code>trans_func$cal_tax4fun2()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-cal_tax4fun2_FRI"><code>trans_func$cal_tax4fun2_FRI()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-print"><code>trans_func$print()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_func-clone"><code>trans_func$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_func-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create the <code>trans_func</code> object. This function can identify the data type for Prokaryotes or Fungi automatically.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$new(dataset = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>the object of <code><a href="#topic+microtable">microtable</a></code> Class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>for_what</code>: &quot;prok&quot; or &quot;fungi&quot; or NA, &quot;prok&quot; represent prokaryotes. &quot;fungi&quot; represent fungi. NA stand for unknown according to the Kingdom information. 
In this case, if the user still want to use the function to identify species traits, please provide &quot;prok&quot; or &quot;fungi&quot; manually, 
e.g. <code>t1$for_what &lt;- "prok"</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(dataset)
t1 &lt;- trans_func$new(dataset = dataset)
</pre>
</div>


<hr>
<a id="method-trans_func-cal_spe_func"></a>



<h4>Method <code>cal_spe_func()</code></h4>

<p>Identify traits of each feature by matching taxonomic assignments to functional database.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$cal_spe_func(
  prok_database = c("FAPROTAX", "NJC19")[1],
  fungi_database = c("FUNGuild", "FungalTraits")[1]
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prok_database</code></dt><dd><p>default &quot;FAPROTAX&quot;; <code>"FAPROTAX"</code> or <code>"NJC19"</code>; select a prokaryotic trait database:
</p>

<dl>
<dt><strong>'FAPROTAX'</strong></dt><dd><p>FAPROTAX v1.2.4; Reference: Louca et al. (2016). Decoupling function and taxonomy in the global ocean microbiome. 
Science, 353(6305), 1272. &lt;doi:10.1126/science.aaf4507&gt;</p>
</dd>
<dt><strong>'NJC19'</strong></dt><dd><p>NJC19: Lim et al. (2020). Large-scale metabolic interaction networkÂ of the mouse and human gut microbiota. 
Scientific Data, 7(1). &lt;10.1038/s41597-020-0516-5&gt;. 
Note that the matching in this database is performed at the species level, 
hence utilizing it demands a higher level of precision in regards to the assignments of species in the taxonomic information table.</p>
</dd>
</dl>
</dd>
<dt><code>fungi_database</code></dt><dd><p>default &quot;FUNGuild&quot;; <code>"FUNGuild"</code> or <code>"FungalTraits"</code>; select a fungal trait database:
</p>

<dl>
<dt><strong>'FUNGuild'</strong></dt><dd><p>Nguyen et al. (2016) FUNGuild: An open annotation tool for parsing fungal community datasets by ecological guild.
Fungal Ecology, 20(1), 241-248, &lt;doi:10.1016/j.funeco.2015.06.006&gt;</p>
</dd>
<dt><strong>'FungalTraits'</strong></dt><dd><p>version: FungalTraits_1.2_ver_16Dec_2020V.1.2; Polme et al. 
FungalTraits: a user-friendly traits database of fungi and fungus-like stramenopiles.  
Fungal Diversity 105, 1-16 (2020). &lt;doi:10.1007/s13225-020-00466-2&gt;</p>
</dd>
</dl>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_spe_func</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_spe_func(prok_database = "FAPROTAX")
t1$cal_spe_func(fungi_database = "FungalTraits")
}
</pre>
</div>


<hr>
<a id="method-trans_func-cal_spe_func_perc"></a>



<h4>Method <code>cal_spe_func_perc()</code></h4>

<p>Calculating the percentages of species with specific trait in communities.
The percentages of the taxa with specific trait can reflect corresponding functional potential in the community.
So this method is one representation of functional redundancy (FR) without the consideration of phylogenetic distance among taxa.
The FR is defined:
</p>
<p style="text-align: center;"><code class="reqn">FR_{kj}^{unweighted} = \frac{N_{j}}{N_{k}}</code>
</p>

<p style="text-align: center;"><code class="reqn">FR_{kj}^{weighted} = \frac{\sum_{i=1}^{N_{j}} A_{i}}{\sum_{i=1}^{N_{k}} A_{i}}</code>
</p>

<p>where <code class="reqn">FR_{kj}</code> denotes the FR for sample k and function j. <code class="reqn">N_{k}</code> is the species number in sample k.
<code class="reqn">N_{j}</code> is the number of species with function j in sample k.
<code class="reqn">A_{i}</code> is the abundance (counts) of species i in sample k.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$cal_spe_func_perc(abundance_weighted = FALSE, perc = TRUE, dec = 2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>abundance_weighted</code></dt><dd><p>default FALSE; whether use abundance of taxa. If FALSE, calculate the functional population percentage. 
If TRUE, calculate the functional individual percentage.</p>
</dd>
<dt><code>perc</code></dt><dd><p>default TRUE; whether to use percentages in the result. If TRUE, value is bounded between 0 and 100.
If FALSE, the result is relative proportion ('abundance_weighted = FALSE') or relative abundance ('abundance_weighted = TRUE') bounded between 0 and 1.</p>
</dd>
<dt><code>dec</code></dt><dd><p>default 2; remained decimal places.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_spe_func_perc</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_spe_func_perc(abundance_weighted = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_func-show_prok_func"></a>



<h4>Method <code>show_prok_func()</code></h4>

<p>Show the annotation information for a function of prokaryotes from FAPROTAX database.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$show_prok_func(use_func = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_func</code></dt><dd><p>default NULL; the function name.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$show_prok_func(use_func = "methanotrophy")
}
</pre>
</div>


<hr>
<a id="method-trans_func-trans_spe_func_perc"></a>



<h4>Method <code>trans_spe_func_perc()</code></h4>

<p>Transform the <code>res_spe_func_perc</code> table to the long table format for the following visualization.
Also add the group information if the database has hierarchical groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$trans_spe_func_perc()</pre></div>



<h5>Returns</h5>

<p><code>res_spe_func_perc_trans</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$trans_spe_func_perc()
}
</pre>
</div>


<hr>
<a id="method-trans_func-plot_spe_func_perc"></a>



<h4>Method <code>plot_spe_func_perc()</code></h4>

<p>Plot the percentages of species with specific trait in communities.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$plot_spe_func_perc(
  add_facet = TRUE,
  order_x = NULL,
  color_gradient_low = "#00008B",
  color_gradient_high = "#9E0142"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_facet</code></dt><dd><p>default TRUE; whether use group names as the facets in the plot, see <code>trans_func$func_group_list</code> object.</p>
</dd>
<dt><code>order_x</code></dt><dd><p>default NULL; character vector; to sort the x axis text; can be also used to select partial samples to show.</p>
</dd>
<dt><code>color_gradient_low</code></dt><dd><p>default &quot;#00008B&quot;; the color used as the low end in the color gradient.</p>
</dd>
<dt><code>color_gradient_high</code></dt><dd><p>default &quot;#9E0142&quot;; the color used as the high end in the color gradient.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot2.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_spe_func_perc()
}
</pre>
</div>


<hr>
<a id="method-trans_func-cal_tax4fun"></a>



<h4>Method <code>cal_tax4fun()</code></h4>

<p>Predict functional potential of communities using <code>tax4fun</code> package.
please cite: Tax4Fun: Predicting functional profiles from metagenomic 16S rRNA data. Bioinformatics, 31(17), 2882-2884, &lt;doi:10.1093/bioinformatics/btv287&gt;.
Note that this function requires a standard prefix in taxonomic table with double underlines (e.g. 'g__') .
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$cal_tax4fun(keep_tem = FALSE, folderReferenceData = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>keep_tem</code></dt><dd><p>default FALSE; whether keep the intermediate file, that is, the feature table in local place.</p>
</dd>
<dt><code>folderReferenceData</code></dt><dd><p>default NULL; the folder, see <a href="http://tax4fun.gobics.de/">http://tax4fun.gobics.de/</a>  and Tax4Fun function in Tax4Fun package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>tax4fun_KO</code> and <code>tax4fun_path</code> in object.
</p>


<hr>
<a id="method-trans_func-cal_tax4fun2"></a>



<h4>Method <code>cal_tax4fun2()</code></h4>

<p>Predict functional potential of communities with Tax4Fun2 method. 
The function was adapted from the raw Tax4Fun2 package to make it compatible with the microtable object.
Pleas cite: 
Tax4Fun2: prediction of habitat-specific functional profiles and functional redundancy based on 16S rRNA gene sequences. Environmental Microbiome 15, 11 (2020).
&lt;doi:10.1186/s40793-020-00358-7&gt;
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$cal_tax4fun2(
  blast_tool_path = NULL,
  path_to_reference_data = "Tax4Fun2_ReferenceData_v2",
  path_to_temp_folder = NULL,
  database_mode = "Ref99NR",
  normalize_by_copy_number = T,
  min_identity_to_reference = 97,
  use_uproc = T,
  num_threads = 1,
  normalize_pathways = F
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>blast_tool_path</code></dt><dd><p>default NULL; the folder path, e.g., ncbi-blast-2.5.0+/bin ; blast tools folder downloaded from 
&quot;ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+&quot;  ; e.g., ncbi-blast-2.5.0+-x64-win64.tar.gz  for windows system; 
if blast_tool_path is NULL, search the tools in the environmental path variable.</p>
</dd>
<dt><code>path_to_reference_data</code></dt><dd><p>default &quot;Tax4Fun2_ReferenceData_v2&quot;; the path that points to files used in the prediction; 
The directory must contain the Ref99NR or Ref100NR folder; 
download Ref99NR.zip from &quot;https://cloudstor.aarnet.edu.au/plus/s/DkoZIyZpMNbrzSw/download&quot; or 
Ref100NR.zip from &quot;https://cloudstor.aarnet.edu.au/plus/s/jIByczak9ZAFUB4/download&quot;.</p>
</dd>
<dt><code>path_to_temp_folder</code></dt><dd><p>default NULL; The temporary folder to store the logfile, intermediate file and result files; if NULL, 
use the default temporary in the computer system.</p>
</dd>
<dt><code>database_mode</code></dt><dd><p>default 'Ref99NR'; &quot;Ref99NR&quot; or &quot;Ref100NR&quot;; Ref99NR: 99% clustering reference database; Ref100NR: no clustering.</p>
</dd>
<dt><code>normalize_by_copy_number</code></dt><dd><p>default TRUE; whether normalize the result by the 16S rRNA copy number in the genomes.</p>
</dd>
<dt><code>min_identity_to_reference</code></dt><dd><p>default 97; the sequences identity threshold used for finding the nearest species.</p>
</dd>
<dt><code>use_uproc</code></dt><dd><p>default TRUE; whether use UProC to functionally anotate the genomes in the reference data.</p>
</dd>
<dt><code>num_threads</code></dt><dd><p>default 1; the threads used in the blastn.</p>
</dd>
<dt><code>normalize_pathways</code></dt><dd><p>default FALSE; Different to Tax4Fun, when converting from KEGG functions to KEGG pathways, 
Tax4Fun2 does not equally split KO gene abundances between pathways a functions is affiliated to. The full predicted abundance is affiliated to each pathway. 
Use TRUE to split the abundances (default is FALSE).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_tax4fun2_KO</code> and <code>res_tax4fun2_pathway</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_tax4fun2(blast_tool_path = "ncbi-blast-2.5.0+/bin", 
    path_to_reference_data = "Tax4Fun2_ReferenceData_v2")
}
</pre>
</div>


<hr>
<a id="method-trans_func-cal_tax4fun2_FRI"></a>



<h4>Method <code>cal_tax4fun2_FRI()</code></h4>

<p>Calculate (multi-) functional redundancy index (FRI) of prokaryotic community with Tax4Fun2 method.
This function is used to calculating aFRI and rFRI use the intermediate files generated by the function cal_tax4fun2().
please also cite: 
Tax4Fun2: prediction of habitat-specific functional profiles and functional redundancy based on 16S rRNA gene sequences. 
Environmental Microbiome 15, 11 (2020). &lt;doi:10.1186/s40793-020-00358-7&gt;
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$cal_tax4fun2_FRI()</pre></div>



<h5>Returns</h5>

<p>res_tax4fun2_aFRI and res_tax4fun2_rFRI in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_tax4fun2_FRI()
}
</pre>
</div>


<hr>
<a id="method-trans_func-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the trans_func object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$print()</pre></div>


<hr>
<a id="method-trans_func-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_func$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_func$new`
## ------------------------------------------------

data(dataset)
t1 &lt;- trans_func$new(dataset = dataset)

## ------------------------------------------------
## Method `trans_func$cal_spe_func`
## ------------------------------------------------


t1$cal_spe_func(prok_database = "FAPROTAX")
t1$cal_spe_func(fungi_database = "FungalTraits")


## ------------------------------------------------
## Method `trans_func$cal_spe_func_perc`
## ------------------------------------------------


t1$cal_spe_func_perc(abundance_weighted = TRUE)


## ------------------------------------------------
## Method `trans_func$show_prok_func`
## ------------------------------------------------


t1$show_prok_func(use_func = "methanotrophy")


## ------------------------------------------------
## Method `trans_func$trans_spe_func_perc`
## ------------------------------------------------


t1$trans_spe_func_perc()


## ------------------------------------------------
## Method `trans_func$plot_spe_func_perc`
## ------------------------------------------------


t1$plot_spe_func_perc()


## ------------------------------------------------
## Method `trans_func$cal_tax4fun2`
## ------------------------------------------------

## Not run: 
t1$cal_tax4fun2(blast_tool_path = "ncbi-blast-2.5.0+/bin", 
    path_to_reference_data = "Tax4Fun2_ReferenceData_v2")

## End(Not run)

## ------------------------------------------------
## Method `trans_func$cal_tax4fun2_FRI`
## ------------------------------------------------

## Not run: 
t1$cal_tax4fun2_FRI()

## End(Not run)
</code></pre>

<hr>
<h2 id='trans_network'>Create <code>trans_network</code> object for network analysis.</h2><span id='topic+trans_network'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of network analysis methods, 
including the network construction, network attributes analysis,
eigengene analysis, network subsetting, node and edge properties, network visualization and other operations.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_network-new"><code>trans_network$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_network"><code>trans_network$cal_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_module"><code>trans_network$cal_module()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-save_network"><code>trans_network$save_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_network_attr"><code>trans_network$cal_network_attr()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-get_node_table"><code>trans_network$get_node_table()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-get_edge_table"><code>trans_network$get_edge_table()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-get_adjacency_matrix"><code>trans_network$get_adjacency_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-plot_network"><code>trans_network$plot_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_eigen"><code>trans_network$cal_eigen()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-plot_taxa_roles"><code>trans_network$plot_taxa_roles()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-subset_network"><code>trans_network$subset_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_powerlaw"><code>trans_network$cal_powerlaw()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-cal_sum_links"><code>trans_network$cal_sum_links()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-plot_sum_links"><code>trans_network$plot_sum_links()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-random_network"><code>trans_network$random_network()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-trans_comm"><code>trans_network$trans_comm()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-print"><code>trans_network$print()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_network-clone"><code>trans_network$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_network-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create the <code>trans_network</code> object, store the important intermediate data 
and calculate correlations if <code>cor_method</code> parameter is not NULL.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$new(
  dataset = NULL,
  cor_method = NULL,
  use_WGCNA_pearson_spearman = FALSE,
  use_NetCoMi_pearson_spearman = FALSE,
  use_sparcc_method = c("NetCoMi", "SpiecEasi")[1],
  taxa_level = "OTU",
  filter_thres = 0,
  nThreads = 1,
  SparCC_simu_num = 100,
  env_cols = NULL,
  add_data = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>default NULL; the object of <code><a href="#topic+microtable">microtable</a></code> class. Default NULL means customized analysis.</p>
</dd>
<dt><code>cor_method</code></dt><dd><p>default NULL; NULL or one of &quot;bray&quot;, &quot;pearson&quot;, &quot;spearman&quot;, &quot;sparcc&quot;, &quot;bicor&quot;, &quot;cclasso&quot; and &quot;ccrepe&quot;;
All the methods refered to <code>NetCoMi</code> package are performed based on <code>netConstruct</code> function of <code>NetCoMi</code> package and require
<code>NetCoMi</code> to be installed from Github (<a href="https://github.com/stefpeschel/NetCoMi">https://github.com/stefpeschel/NetCoMi</a>);
For the algorithm details, please see Peschel et al. 2020 Brief. Bioinform &lt;doi: 10.1093/bib/bbaa290&gt;;
</p>

<dl>
<dt><strong>NULL</strong></dt><dd><p>NULL denotes non-correlation network, i.e. do not use correlation-based network. 
If so, the return res_cor_p list will be NULL.</p>
</dd>
<dt><strong>'bray'</strong></dt><dd><p>1-B, where B is Bray-Curtis dissimilarity; based on <code>vegan::vegdist</code> function</p>
</dd>
<dt><strong>'pearson'</strong></dt><dd><p>Pearson correlation; If <code>use_WGCNA_pearson_spearman</code> and <code>use_NetCoMi_pearson_spearman</code> are both FALSE, 
use the function <code>cor.test</code> in R; <code>use_WGCNA_pearson_spearman = TRUE</code> invoke <code>corAndPvalue</code> function of <code>WGCNA</code> package; 
<code>use_NetCoMi_pearson_spearman = TRUE</code> invoke <code>netConstruct</code> function of <code>NetCoMi</code> package</p>
</dd>
<dt><strong>'spearman'</strong></dt><dd><p>Spearman correlation; other details are same with the 'pearson' option</p>
</dd>
<dt><strong>'sparcc'</strong></dt><dd><p>SparCC algorithm (Friedman &amp; Alm, PLoS Comp Biol, 2012, &lt;doi:10.1371/journal.pcbi.1002687&gt;);
use NetCoMi package when <code>use_sparcc_method = "NetCoMi"</code>; use <code>SpiecEasi</code> package when <code>use_sparcc_method = "SpiecEasi"</code> 
and require <code>SpiecEasi</code> to be installed from Github
(<a href="https://github.com/zdk123/SpiecEasi">https://github.com/zdk123/SpiecEasi</a>)</p>
</dd>
<dt><strong>'bicor'</strong></dt><dd><p>Calculate biweight midcorrelation efficiently for matrices based on <code>WGCNA::bicor</code> function; 
This option can invoke <code>netConstruct</code> function of <code>NetCoMi</code> package;
Make sure <code>WGCNA</code> and <code>NetCoMi</code> packages are both installed</p>
</dd>
<dt><strong>'cclasso'</strong></dt><dd><p>Correlation inference of Composition data through Lasso method based on <code>netConstruct</code> function of <code>NetCoMi</code> package; 
for details, see <code>NetCoMi::cclasso</code> function</p>
</dd>
<dt><strong>'ccrepe'</strong></dt><dd><p>Calculates compositionality-corrected p-values and q-values for compositional data 
using an arbitrary distance metric based on <code>NetCoMi::netConstruct</code> function; also see <code>NetCoMi::ccrepe</code> function</p>
</dd>
</dl>
</dd>
<dt><code>use_WGCNA_pearson_spearman</code></dt><dd><p>default FALSE; whether use WGCNA package to calculate correlation when <code>cor_method</code> = &quot;pearson&quot; or &quot;spearman&quot;.</p>
</dd>
<dt><code>use_NetCoMi_pearson_spearman</code></dt><dd><p>default FALSE; whether use NetCoMi package to calculate correlation when <code>cor_method</code> = &quot;pearson&quot; or &quot;spearman&quot;.
The important difference between NetCoMi and others is the features of zero handling and data normalization; See &lt;doi: 10.1093/bib/bbaa290&gt;.</p>
</dd>
<dt><code>use_sparcc_method</code></dt><dd><p>default <code>c("NetCoMi", "SpiecEasi")[1]</code>; 
use <code>NetCoMi</code> package or <code>SpiecEasi</code> package to perform SparCC when <code>cor_method = "sparcc"</code>.</p>
</dd>
<dt><code>taxa_level</code></dt><dd><p>default &quot;OTU&quot;; taxonomic rank; 'OTU' denotes using feature abundance table; 
other available options should be one of the colnames of <code>tax_table</code> of input dataset.</p>
</dd>
<dt><code>filter_thres</code></dt><dd><p>default 0; the relative abundance threshold.</p>
</dd>
<dt><code>nThreads</code></dt><dd><p>default 1; the CPU thread number; available when <code>use_WGCNA_pearson_spearman = TRUE</code> or <code>use_sparcc_method = "SpiecEasi"</code>.</p>
</dd>
<dt><code>SparCC_simu_num</code></dt><dd><p>default 100; SparCC simulation number for bootstrap when <code>use_sparcc_method = "SpiecEasi"</code>.</p>
</dd>
<dt><code>env_cols</code></dt><dd><p>default NULL; numeric or character vector to select the column names of environmental data in dataset$sample_table;
the environmental data can be used in the correlation network (as the nodes) or <code>FlashWeave</code> network.</p>
</dd>
<dt><code>add_data</code></dt><dd><p>default NULL; provide environmental variable table additionally instead of <code>env_cols</code> parameter; rownames must be sample names.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to <code>NetCoMi::netConstruct</code> for other operations, such as zero handling and/or data normalization 
when cor_method and other parameters refer to <code>NetCoMi</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_cor_p</code> list with the correlation (association) matrix and p value matrix. Note that when <code>cor_method</code> and other parameters
refer to <code>NetCoMi</code> package, the p value table are all zero as the significant associations have been selected.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
data(dataset)
# for correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.0002)
# for non-correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL)
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_network"></a>



<h4>Method <code>cal_network()</code></h4>

<p>Construct network based on the <code>igraph</code> package or <code>SpiecEasi</code> package or <code>julia FlashWeave</code> package or <code>beemStatic</code> package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_network(
  network_method = c("COR", "SpiecEasi", "gcoda", "FlashWeave", "beemStatic")[1],
  COR_p_thres = 0.01,
  COR_p_adjust = "fdr",
  COR_weight = TRUE,
  COR_cut = 0.6,
  COR_optimization = FALSE,
  COR_optimization_low_high = c(0.01, 0.8),
  COR_optimization_seq = 0.01,
  SpiecEasi_method = "mb",
  FlashWeave_tempdir = NULL,
  FlashWeave_meta_data = FALSE,
  FlashWeave_other_para = "alpha=0.01,sensitive=true,heterogeneous=true",
  beemStatic_t_strength = 0.001,
  beemStatic_t_stab = 0.8,
  add_taxa_name = "Phylum",
  delete_unlinked_nodes = TRUE,
  usename_rawtaxa_when_taxalevel_notOTU = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>network_method</code></dt><dd><p>default &quot;COR&quot;; &quot;COR&quot;, &quot;SpiecEasi&quot;, &quot;gcoda&quot;, &quot;FlashWeave&quot; or &quot;beemStatic&quot;; 
<code>network_method = NULL</code> means skipping the network construction for the customized use.
The option details: 
</p>

<dl>
<dt><strong>'COR'</strong></dt><dd><p>correlation-based network; use the correlation and p value matrices in <code>res_cor_p</code> list stored in the object; 
See Deng et al. (2012) &lt;doi:10.1186/1471-2105-13-113&gt; for other details</p>
</dd>
<dt><strong>'SpiecEasi'</strong></dt><dd><p><code>SpiecEasi</code> network; relies on algorithms of sparse neighborhood and inverse covariance selection;
belong to the category of conditional dependence and graphical models;
see <a href="https://github.com/zdk123/SpiecEasi">https://github.com/zdk123/SpiecEasi</a> for installing the R package; 
see Kurtz et al. (2015) &lt;doi:10.1371/journal.pcbi.1004226&gt; for the algorithm details</p>
</dd>
<dt><strong>'gcoda'</strong></dt><dd><p>hypothesize the logistic normal distribution of microbiome data; use penalized maximum likelihood method to estimate
the sparse structure of inverse covariance for latent normal variables to address the high dimensionality of the microbiome data;
belong to the category of conditional dependence and graphical models;
depend on the R <code>NetCoMi</code> package <a href="https://github.com/stefpeschel/NetCoMi">https://github.com/stefpeschel/NetCoMi</a>; 
see FANG et al. (2017) &lt;doi:10.1089/cmb.2017.0054&gt; for the algorithm details</p>
</dd>
<dt><strong>'FlashWeave'</strong></dt><dd><p><code>FlashWeave</code> network; Local-to-global learning framework; belong to the category of conditional dependence and graphical models;
good performance on heterogenous datasets to find direct associations among taxa;
see <a href="https://github.com/meringlab/FlashWeave.jl">https://github.com/meringlab/FlashWeave.jl</a> for installing <code>julia</code> language and 
<code>FlashWeave</code> package; julia must be in the computer system env path, otherwise the program can not find it;
see Tackmann et al. (2019) &lt;doi:10.1016/j.cels.2019.08.002&gt; for the algorithm details</p>
</dd>
<dt><strong>'beemStatic'</strong></dt><dd><p><code>beemStatic</code> network;
extend generalized Lotka-Volterra model to cases of cross-sectional datasets to infer interaction among taxa based on expectation-maximization algorithm;
see <a href="https://github.com/CSB5/BEEM-static">https://github.com/CSB5/BEEM-static</a> for installing the R package;
see Li et al. (2021) &lt;doi:10.1371/journal.pcbi.1009343&gt; for the algorithm details</p>
</dd>
</dl>
</dd>
<dt><code>COR_p_thres</code></dt><dd><p>default 0.01; the p value threshold for the correlation-based network.</p>
</dd>
<dt><code>COR_p_adjust</code></dt><dd><p>default &quot;fdr&quot;; p value adjustment method, see <code>method</code> parameter of <code>p.adjust</code> function for available options,
in which <code>COR_p_adjust = "none"</code> means giving up the p value adjustment.</p>
</dd>
<dt><code>COR_weight</code></dt><dd><p>default TRUE; whether use correlation coefficient as the weight of edges; FALSE represents weight = 1 for all edges.</p>
</dd>
<dt><code>COR_cut</code></dt><dd><p>default 0.6; correlation coefficient threshold for the correlation network.</p>
</dd>
<dt><code>COR_optimization</code></dt><dd><p>default FALSE; whether use random matrix theory (RMT) based method to determine the correlation coefficient; 
see https://doi.org/10.1186/1471-2105-13-113</p>
</dd>
<dt><code>COR_optimization_low_high</code></dt><dd><p>default <code>c(0.01, 0.8)</code>; the low and high value threshold used for the RMT optimization; only useful when COR_optimization = TRUE.</p>
</dd>
<dt><code>COR_optimization_seq</code></dt><dd><p>default 0.01; the interval of correlation coefficient used for RMT optimization; only useful when COR_optimization = TRUE.</p>
</dd>
<dt><code>SpiecEasi_method</code></dt><dd><p>default &quot;mb&quot;; either 'glasso' or 'mb';see spiec.easi function in package SpiecEasi and https://github.com/zdk123/SpiecEasi.</p>
</dd>
<dt><code>FlashWeave_tempdir</code></dt><dd><p>default NULL; The temporary directory used to save the temporary files for running FlashWeave; If not assigned, use the system user temp.</p>
</dd>
<dt><code>FlashWeave_meta_data</code></dt><dd><p>default FALSE; whether use env data for the optimization, If TRUE, the function automatically find the <code>env_data</code> in the object and
generate a file for meta_data_path parameter of FlashWeave package.</p>
</dd>
<dt><code>FlashWeave_other_para</code></dt><dd><p>default <code>"alpha=0.01,sensitive=true,heterogeneous=true"</code>; the parameters passed to julia FlashWeave package;
user can change the parameters or add more according to FlashWeave help document;
An exception is meta_data_path parameter as it is generated based on the data inside the object, see FlashWeave_meta_data parameter for the description.</p>
</dd>
<dt><code>beemStatic_t_strength</code></dt><dd><p>default 0.001; for network_method = &quot;beemStatic&quot;; the threshold used to limit the number of interactions (strength);
same with the t.strength parameter in showInteraction function of beemStatic package.</p>
</dd>
<dt><code>beemStatic_t_stab</code></dt><dd><p>default 0.8; for network_method = &quot;beemStatic&quot;; 
the threshold used to limit the number of interactions (stability); same with the t.stab parameter in showInteraction function of beemStatic package.</p>
</dd>
<dt><code>add_taxa_name</code></dt><dd><p>default &quot;Phylum&quot;; one or more taxonomic rank name; used to add taxonomic rank name to network node properties.</p>
</dd>
<dt><code>delete_unlinked_nodes</code></dt><dd><p>default TRUE; whether delete the nodes without any link.</p>
</dd>
<dt><code>usename_rawtaxa_when_taxalevel_notOTU</code></dt><dd><p>default FALSE; whether use OTU name as representatives of taxa when <code>taxa_level != "OTU"</code>.
Default <code>FALSE</code> means using taxonomic information of <code>taxa_level</code> instead of OTU name.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to <code>SpiecEasi::spiec.easi</code> when <code>network_method = "SpiecEasi"</code>;
pass to <code>NetCoMi::netConstruct</code> when <code>network_method = "gcoda"</code>; 
pass to <code>beemStatic::func.EM</code> when <code>network_method = "beemStatic"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_network</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# for correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.001)
t1$cal_network(COR_p_thres = 0.05, COR_cut = 0.6)
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.003)
t1$cal_network(network_method = "SpiecEasi", SpiecEasi_method = "mb")
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.005)
t1$cal_network(network_method = "beemStatic")
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.001)
t1$cal_network(network_method = "FlashWeave")
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_module"></a>



<h4>Method <code>cal_module()</code></h4>

<p>Calculate network modules and add module names to the network node properties.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_module(
  method = "cluster_fast_greedy",
  module_name_prefix = "M"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default &quot;cluster_fast_greedy&quot;; the method used to find the optimal community structure of a graph;
the following are available functions (options) from igraph package: <br />
<code>"cluster_fast_greedy"</code>, <code>"cluster_walktrap"</code>, <code>"cluster_edge_betweenness"</code>, <br />
<code>"cluster_infomap"</code>, <code>"cluster_label_prop"</code>, <code>"cluster_leading_eigen"</code>, <br />
<code>"cluster_louvain"</code>, <code>"cluster_spinglass"</code>, <code>"cluster_optimal"</code>. <br />
For the details of these functions, please see the help document, such as <code>help(cluster_fast_greedy)</code>;
Note that the default <code>"cluster_fast_greedy"</code> method can not be applied to directed network. 
If directed network is provided, the function can automatically switch the default method from <code>"cluster_fast_greedy"</code> to <code>"cluster_walktrap"</code>.</p>
</dd>
<dt><code>module_name_prefix</code></dt><dd><p>default &quot;M&quot;; the prefix of module names; module names are made of the module_name_prefix and numbers;
numbers are assigned according to the sorting result of node numbers in modules with decreasing trend.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_network</code> with modules, stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.0002)
t1$cal_network(COR_p_thres = 0.01, COR_cut = 0.6)
t1$cal_module(method = "cluster_fast_greedy")
}
</pre>
</div>


<hr>
<a id="method-trans_network-save_network"></a>



<h4>Method <code>save_network()</code></h4>

<p>Save network as gexf style, which can be opened by Gephi (<a href="https://gephi.org/">https://gephi.org/</a>).
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$save_network(filepath = "network.gexf")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filepath</code></dt><dd><p>default &quot;network.gexf&quot;; file path to save the network.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>None
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$save_network(filepath = "network.gexf")
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_network_attr"></a>



<h4>Method <code>cal_network_attr()</code></h4>

<p>Calculate network properties.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_network_attr()</pre></div>



<h5>Returns</h5>

<p><code>res_network_attr</code> stored in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_network_attr()
}
</pre>
</div>


<hr>
<a id="method-trans_network-get_node_table"></a>



<h4>Method <code>get_node_table()</code></h4>

<p>Get the node property table. The properties may include the node names, modules allocation, degree, betweenness, abundance, 
taxonomy, within-module connectivity and among-module connectivity &lt;doi:10.1016/j.geoderma.2022.115866&gt;.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$get_node_table(node_roles = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>node_roles</code></dt><dd><p>default TRUE; whether calculate node roles, i.e. Module hubs, Network hubs, Connectors and Peripherals &lt;doi:10.1016/j.geoderma.2022.115866&gt;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_node_table</code> in object; Abundance expressed as a percentage; 
betweenness_centrality: betweenness centrality; betweenness_centrality: closeness centrality; eigenvector_centrality: eigenvector centrality; 
z: within-module connectivity; p: among-module connectivity.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$get_node_table(node_roles = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_network-get_edge_table"></a>



<h4>Method <code>get_edge_table()</code></h4>

<p>Get the edge property table, including connected nodes, label and weight.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$get_edge_table()</pre></div>



<h5>Returns</h5>

<p><code>res_edge_table</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$get_edge_table()
}
</pre>
</div>


<hr>
<a id="method-trans_network-get_adjacency_matrix"></a>



<h4>Method <code>get_adjacency_matrix()</code></h4>

<p>Get the adjacency matrix from the network graph.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$get_adjacency_matrix(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>parameters passed to as_adjacency_matrix function of <code>igraph</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_adjacency_matrix</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$get_adjacency_matrix(attr = "weight")
}
</pre>
</div>


<hr>
<a id="method-trans_network-plot_network"></a>



<h4>Method <code>plot_network()</code></h4>

<p>Plot the network based on a series of methods from other packages, such as <code>igraph</code>, <code>ggraph</code> and <code>networkD3</code>. 
The networkD3 package provides dynamic network. It is especially useful for a glimpse of the whole network structure and finding 
the interested nodes and edges in a large network. In contrast, the igraph and ggraph methods are suitable for relatively small network.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$plot_network(
  method = c("igraph", "ggraph", "networkD3")[1],
  node_label = "name",
  node_color = NULL,
  ggraph_layout = "fr",
  ggraph_node_size = 2,
  ggraph_node_text = TRUE,
  ggraph_text_color = NULL,
  ggraph_text_size = 3,
  networkD3_node_legend = TRUE,
  networkD3_zoom = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default &quot;igraph&quot;; The available options:
</p>

<dl>
<dt><strong>'igraph'</strong></dt><dd><p>call <code>plot.igraph</code> function in <code>igraph</code> package for a static network; see plot.igraph for the parameters</p>
</dd>
<dt><strong>'ggraph'</strong></dt><dd><p>call <code>ggraph</code> function in <code>ggraph</code> package for a static network</p>
</dd>
<dt><strong>'networkD3'</strong></dt><dd><p>use forceNetwork function in <code>networkD3</code> package for a dynamic network; see forceNetwork function for the parameters</p>
</dd>
</dl>
</dd>
<dt><code>node_label</code></dt><dd><p>default &quot;name&quot;; node label shown in the plot for <code>method = "ggraph"</code> or <code>method = "networkD3"</code>; 
Please see the column names of object$res_node_table, which is the returned table of function object$get_node_table;
User can select other column names in res_node_table.</p>
</dd>
<dt><code>node_color</code></dt><dd><p>default NULL; node color assignment for <code>method = "ggraph"</code> or <code>method = "networkD3"</code>; 
Select a column name of <code>object$res_node_table</code>, such as &quot;module&quot;.</p>
</dd>
<dt><code>ggraph_layout</code></dt><dd><p>default &quot;fr&quot;; for <code>method = "ggraph"</code>; see <code>layout</code> parameter of <code>create_layout</code> function in <code>ggraph</code> package.</p>
</dd>
<dt><code>ggraph_node_size</code></dt><dd><p>default 2; for <code>method = "ggraph"</code>; the node size.</p>
</dd>
<dt><code>ggraph_node_text</code></dt><dd><p>default TRUE; for <code>method = "ggraph"</code>; whether show the label text of nodes.</p>
</dd>
<dt><code>ggraph_text_color</code></dt><dd><p>default NULL; for <code>method = "ggraph"</code>; a column name of object$res_node_table used to assign label text colors.</p>
</dd>
<dt><code>ggraph_text_size</code></dt><dd><p>default 3; for <code>method = "ggraph"</code>; the node label text size.</p>
</dd>
<dt><code>networkD3_node_legend</code></dt><dd><p>default TRUE; used for <code>method = "networkD3"</code>; logical value to enable node colour legends;
Please see the legend parameter in networkD3::forceNetwork function.</p>
</dd>
<dt><code>networkD3_zoom</code></dt><dd><p>default TRUE; used for <code>method = "networkD3"</code>; logical value to enable (TRUE) or disable (FALSE) zooming;
Please see the zoom parameter in networkD3::forceNetwork function.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters passed to <code>plot.igraph</code> function when <code>method = "igraph"</code> or forceNetwork function when <code>method = "networkD3"</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>network plot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_network(method = "igraph", layout = layout_with_kk)
t1$plot_network(method = "ggraph", node_color = "module")
t1$plot_network(method = "networkD3", node_color = "module")
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_eigen"></a>



<h4>Method <code>cal_eigen()</code></h4>

<p>Calculate eigengenes of modules, i.e. the first principal component based on PCA analysis, and the percentage of variance &lt;doi:10.1186/1471-2105-13-113&gt;.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_eigen()</pre></div>



<h5>Returns</h5>

<p><code>res_eigen</code> and <code>res_eigen_expla</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_eigen()
}
</pre>
</div>


<hr>
<a id="method-trans_network-plot_taxa_roles"></a>



<h4>Method <code>plot_taxa_roles()</code></h4>

<p>Plot the classification and importance of nodes, see object$res_node_table for the variable names used in the parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$plot_taxa_roles(
  use_type = c(1, 2)[1],
  roles_color_background = FALSE,
  roles_color_values = NULL,
  add_label = FALSE,
  add_label_group = "Network hubs",
  add_label_text = "name",
  label_text_size = 4,
  label_text_color = "grey50",
  label_text_italic = FALSE,
  label_text_parse = FALSE,
  plot_module = FALSE,
  x_lim = c(0, 1),
  use_level = "Phylum",
  show_value = c("z", "p"),
  show_number = 1:10,
  plot_color = "Phylum",
  plot_shape = "taxa_roles",
  plot_size = "Abundance",
  color_values = RColorBrewer::brewer.pal(12, "Paired"),
  shape_values = c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_type</code></dt><dd><p>default 1; 1 or 2; 1 represents taxa roles area plot; 2 represents the layered plot with taxa as x axis.</p>
</dd>
<dt><code>roles_color_background</code></dt><dd><p>default FALSE; for use_type=1; TRUE: use background colors for each area; FALSE: use classic point colors.</p>
</dd>
<dt><code>roles_color_values</code></dt><dd><p>default NULL; for use_type=1; color palette for background or points.</p>
</dd>
<dt><code>add_label</code></dt><dd><p>default FALSE; for use_type = 1; whether add labels for the points.</p>
</dd>
<dt><code>add_label_group</code></dt><dd><p>default &quot;Network hubs&quot;; If add_label = TRUE; which part of tax_roles is used to show labels; character vectors.</p>
</dd>
<dt><code>add_label_text</code></dt><dd><p>default &quot;name&quot;; If add_label = TRUE; which column of object$res_node_table is used to label the text.</p>
</dd>
<dt><code>label_text_size</code></dt><dd><p>default 4; The text size of the label.</p>
</dd>
<dt><code>label_text_color</code></dt><dd><p>default &quot;grey50&quot;; The text color of the label.</p>
</dd>
<dt><code>label_text_italic</code></dt><dd><p>default FALSE; whether use italic style for the label text.</p>
</dd>
<dt><code>label_text_parse</code></dt><dd><p>default FALSE; whether parse the label text. See the parse parameter in <code>ggrepel::geom_text_repel</code> function.</p>
</dd>
<dt><code>plot_module</code></dt><dd><p>default FALSE; for use_type=1; whether plot the modules information.</p>
</dd>
<dt><code>x_lim</code></dt><dd><p>default c(0, 1); for use_type=1; x axis range when roles_color_background = FALSE.</p>
</dd>
<dt><code>use_level</code></dt><dd><p>default &quot;Phylum&quot;; for use_type=2; used taxonomic level in x axis.</p>
</dd>
<dt><code>show_value</code></dt><dd><p>default c(&quot;z&quot;, &quot;p&quot;); for use_type=2; used variable in y axis.</p>
</dd>
<dt><code>show_number</code></dt><dd><p>default 1:10; for use_type=2; showed number in x axis, sorting according to the nodes number.</p>
</dd>
<dt><code>plot_color</code></dt><dd><p>default &quot;Phylum&quot;; for use_type=2; used variable for color.</p>
</dd>
<dt><code>plot_shape</code></dt><dd><p>default &quot;taxa_roles&quot;; for use_type=2; used variable for shape.</p>
</dd>
<dt><code>plot_size</code></dt><dd><p>default &quot;Abundance&quot;; for use_type=2; used for point size; a fixed number (e.g. 5) is also available.</p>
</dd>
<dt><code>color_values</code></dt><dd><p>default RColorBrewer::brewer.pal(12, &quot;Paired&quot;); for use_type=2; color vector</p>
</dd>
<dt><code>shape_values</code></dt><dd><p>default c(16, 17, 7, 8, 15, 18, 11, 10, 12, 13, 9, 3, 4, 0, 1, 2, 14); for use_type=2; shape vector, see ggplot2 tutorial for the shape meaning.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to geom_point.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_taxa_roles(roles_color_background = FALSE)
}
</pre>
</div>


<hr>
<a id="method-trans_network-subset_network"></a>



<h4>Method <code>subset_network()</code></h4>

<p>Subset of the network.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$subset_network(node = NULL, edge = NULL, rm_single = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>node</code></dt><dd><p>default NULL; provide the node names that you want to use in the sub-network.</p>
</dd>
<dt><code>edge</code></dt><dd><p>default NULL; provide the edge name needed; must be one of &quot;+&quot; or &quot;-&quot;.</p>
</dd>
<dt><code>rm_single</code></dt><dd><p>default TRUE; whether remove the nodes without any edge in the sub-network.
So this function can also be used to remove the nodes withou any edge when node and edge are both NULL.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new network
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$subset_network(node = t1$res_node_table %&gt;% base::subset(module == "M1") %&gt;% 
  rownames, rm_single = TRUE)
# return a sub network that contains all nodes of module M1
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_powerlaw"></a>



<h4>Method <code>cal_powerlaw()</code></h4>

<p>Fit degrees to a power law distribution. First, perform a bootstrapping hypothesis test to determine whether degrees follow a power law distribution.
If the distribution follows power law, then fit degrees to power law distribution and return the parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_powerlaw(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>parameters pass to bootstrap_p function in poweRlaw package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_powerlaw_p</code> and <code>res_powerlaw_fit</code>; see <code>poweRlaw::bootstrap_p</code> function for the bootstrapping p value details;
see <code>igraph::fit_power_law</code> function for the power law fit return details.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_powerlaw()
}
</pre>
</div>


<hr>
<a id="method-trans_network-cal_sum_links"></a>



<h4>Method <code>cal_sum_links()</code></h4>

<p>This function is used to sum the links number from one taxa to another or in the same taxa, for example, at Phylum level.
This is very useful to fast see how many nodes are connected between different taxa or within the taxa.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$cal_sum_links(taxa_level = "Phylum")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>taxa_level</code></dt><dd><p>default &quot;Phylum&quot;; taxonomic rank.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>res_sum_links_pos</code> and <code>res_sum_links_neg</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_sum_links(taxa_level = "Phylum")
}
</pre>
</div>


<hr>
<a id="method-trans_network-plot_sum_links"></a>



<h4>Method <code>plot_sum_links()</code></h4>

<p>Plot the summed linkages among taxa.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$plot_sum_links(
  plot_pos = TRUE,
  plot_num = NULL,
  color_values = RColorBrewer::brewer.pal(8, "Dark2"),
  method = c("chorddiag", "circlize")[1],
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot_pos</code></dt><dd><p>default TRUE; If TRUE, plot the summed positive linkages; If FALSE, plot the summed negative linkages.</p>
</dd>
<dt><code>plot_num</code></dt><dd><p>default NULL; number of taxa presented in the plot.</p>
</dd>
<dt><code>color_values</code></dt><dd><p>default RColorBrewer::brewer.pal(8, &quot;Dark2&quot;); colors palette for taxa.</p>
</dd>
<dt><code>method</code></dt><dd><p>default c(&quot;chorddiag&quot;, &quot;circlize&quot;)[1]; chorddiag package &lt;https://github.com/mattflor/chorddiag&gt; or circlize package.</p>
</dd>
<dt><code>...</code></dt><dd><p>pass to <code>chorddiag::chorddiag</code> function when <code>method = "chorddiag"</code> or 
<code>circlize::chordDiagram</code> function when <code>method = "circlize"</code>.
Note that for <code>circlize::chordDiagram</code> function, <code>keep.diagonal</code>, <code>symmetric</code> and <code>self.link</code> parameters have been fixed to fit the input data.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>please see the invoked function.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
test1$plot_sum_links(method = "chorddiag", plot_pos = TRUE, plot_num = 10)
test1$plot_sum_links(method = "circlize", transparency = 0.2, 
	  annotationTrackHeight = circlize::mm_h(c(5, 5)))
}
</pre>
</div>


<hr>
<a id="method-trans_network-random_network"></a>



<h4>Method <code>random_network()</code></h4>

<p>Generate random networks, compare them with the empirical network and get the p value of topological properties.
The generation of random graph is based on the <code>erdos.renyi.game</code> function of igraph package.
The numbers of vertices and edges in the random graph are same with the empirical network stored in the object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$random_network(runs = 100, output_sim = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>runs</code></dt><dd><p>default 100; simulation number of random network.</p>
</dd>
<dt><code>output_sim</code></dt><dd><p>default FALSE; whether output each simulated network result.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a data.frame with the following components:
</p>

<dl>
<dt><code>Observed</code></dt><dd><p>Topological properties of empirical network</p>
</dd>
<dt><code>Mean_sim</code></dt><dd><p>Mean of properties of simulated networks</p>
</dd>
<dt><code>SD_sim</code></dt><dd><p>SD of properties of simulated networks</p>
</dd>
<dt><code>p_value</code></dt><dd><p>Significance, i.e. p values</p>
</dd>
</dl>

<p>When <code>output_sim = TRUE</code>, the columns from the five to the last are each simulated result.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$random_network(runs = 100)
}
</pre>
</div>


<hr>
<a id="method-trans_network-trans_comm"></a>



<h4>Method <code>trans_comm()</code></h4>

<p>Transform classifed features to community-like microtable object for further analysis, such as module-taxa table.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$trans_comm(use_col = "module", abundance = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_col</code></dt><dd><p>default &quot;module&quot;; which column to use as the 'community'; must be one of the name of res_node_table from function <code>get_node_table</code>.</p>
</dd>
<dt><code>abundance</code></dt><dd><p>default TRUE; whether sum abundance of taxa. TRUE: sum the abundance for a taxon across all samples; 
FALSE: sum the frequency for a taxon across all samples.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code><a href="#topic+microtable">microtable</a></code> class.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t2 &lt;- t1$trans_comm(use_col = "module")
}
</pre>
</div>


<hr>
<a id="method-trans_network-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the trans_network object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$print()</pre></div>


<hr>
<a id="method-trans_network-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_network$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_network$new`
## ------------------------------------------------


data(dataset)
# for correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.0002)
# for non-correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL)


## ------------------------------------------------
## Method `trans_network$cal_network`
## ------------------------------------------------

## Not run: 
# for correlation network
t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.001)
t1$cal_network(COR_p_thres = 0.05, COR_cut = 0.6)
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.003)
t1$cal_network(network_method = "SpiecEasi", SpiecEasi_method = "mb")
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.005)
t1$cal_network(network_method = "beemStatic")
t1 &lt;- trans_network$new(dataset = dataset, cor_method = NULL, filter_thres = 0.001)
t1$cal_network(network_method = "FlashWeave")

## End(Not run)

## ------------------------------------------------
## Method `trans_network$cal_module`
## ------------------------------------------------


t1 &lt;- trans_network$new(dataset = dataset, cor_method = "pearson", 
		taxa_level = "OTU", filter_thres = 0.0002)
t1$cal_network(COR_p_thres = 0.01, COR_cut = 0.6)
t1$cal_module(method = "cluster_fast_greedy")


## ------------------------------------------------
## Method `trans_network$save_network`
## ------------------------------------------------

## Not run: 
t1$save_network(filepath = "network.gexf")

## End(Not run)

## ------------------------------------------------
## Method `trans_network$cal_network_attr`
## ------------------------------------------------


t1$cal_network_attr()


## ------------------------------------------------
## Method `trans_network$get_node_table`
## ------------------------------------------------


t1$get_node_table(node_roles = TRUE)


## ------------------------------------------------
## Method `trans_network$get_edge_table`
## ------------------------------------------------


t1$get_edge_table()


## ------------------------------------------------
## Method `trans_network$get_adjacency_matrix`
## ------------------------------------------------


t1$get_adjacency_matrix(attr = "weight")


## ------------------------------------------------
## Method `trans_network$plot_network`
## ------------------------------------------------


t1$plot_network(method = "igraph", layout = layout_with_kk)
t1$plot_network(method = "ggraph", node_color = "module")
t1$plot_network(method = "networkD3", node_color = "module")


## ------------------------------------------------
## Method `trans_network$cal_eigen`
## ------------------------------------------------


t1$cal_eigen()


## ------------------------------------------------
## Method `trans_network$plot_taxa_roles`
## ------------------------------------------------


t1$plot_taxa_roles(roles_color_background = FALSE)


## ------------------------------------------------
## Method `trans_network$subset_network`
## ------------------------------------------------


t1$subset_network(node = t1$res_node_table %&gt;% base::subset(module == "M1") %&gt;% 
  rownames, rm_single = TRUE)
# return a sub network that contains all nodes of module M1


## ------------------------------------------------
## Method `trans_network$cal_powerlaw`
## ------------------------------------------------


t1$cal_powerlaw()


## ------------------------------------------------
## Method `trans_network$cal_sum_links`
## ------------------------------------------------


t1$cal_sum_links(taxa_level = "Phylum")


## ------------------------------------------------
## Method `trans_network$plot_sum_links`
## ------------------------------------------------

## Not run: 
test1$plot_sum_links(method = "chorddiag", plot_pos = TRUE, plot_num = 10)
test1$plot_sum_links(method = "circlize", transparency = 0.2, 
	  annotationTrackHeight = circlize::mm_h(c(5, 5)))

## End(Not run)

## ------------------------------------------------
## Method `trans_network$random_network`
## ------------------------------------------------

## Not run: 
t1$random_network(runs = 100)

## End(Not run)

## ------------------------------------------------
## Method `trans_network$trans_comm`
## ------------------------------------------------


t2 &lt;- t1$trans_comm(use_col = "module")

</code></pre>

<hr>
<h2 id='trans_norm'>Feature abundance normalization/transformation.</h2><span id='topic+trans_norm'></span>

<h3>Description</h3>

<p>Feature abundance normalization/transformation for a microtable object or data.frame object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_norm-new"><code>trans_norm$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_norm-norm"><code>trans_norm$norm()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_norm-clone"><code>trans_norm$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_norm-new"></a>



<h4>Method <code>new()</code></h4>

<p>Get a transposed abundance table if the input is microtable object. In the table, rows are samples, and columns are features. 
This can make the further operations same with the traditional ecological methods.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_norm$new(dataset = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>the <code><a href="#topic+microtable">microtable</a></code> object or <code>data.frame</code> object. 
If it is <code>data.frame</code> object, please make sure that rows are samples, and columns are features.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>data_table, stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>library(microeco)
data(dataset)
t1 &lt;- trans_norm$new(dataset = dataset)
</pre>
</div>


<hr>
<a id="method-trans_norm-norm"></a>



<h4>Method <code>norm()</code></h4>

<p>Normalization/transformation methods.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_norm$norm(
  method = NULL,
  MARGIN = NULL,
  logbase = 2,
  Cmin = NULL,
  pseudocount = 1,
  intersect.no = 10,
  ct.min = 1,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default NULL; See the following details and available options. <br /> 
<br /> 
Methods for normalization:
</p>

<ul>
<li> <p><code>GMPR</code>: Geometric mean of pairwise ratios &lt;doi: 10.7717/peerj.4600&gt;. 
For a given sample <code class="reqn">i</code>, the size factor <code class="reqn">s_i</code> is defined:
</p>
<p style="text-align: center;"><code class="reqn">s_i = \lgroup {\displaystyle\prod_{j=1}^{n} r_{ij}} \rgroup ^{1/n}</code>
</p>

<p>where <code class="reqn">r_{ij} = Median_{k|c_{ki}c_{kj} \ne 0} \lbrace \dfrac{c_{ki}}{c_{kj}} \rbrace</code>. 
<code class="reqn">r_{ij}</code> is the median count ratio of nonzero counts between sample <code class="reqn">i</code> and <code class="reqn">j</code>.
<code class="reqn">k</code> denotes all the features. For sample <code class="reqn">i</code>, <code class="reqn">GMPR = \frac{x_{i}}{s_i}</code>, where <code class="reqn">x_i</code> is the feature abundances of sample <code class="reqn">i</code>.
</p>
</li>
<li> <p><code>clr</code>: Centered log-ratio normalization &lt;ISBN:978-0-412-28060-3&gt; &lt;doi: 10.3389/fmicb.2017.02224&gt;. 
It is defined:  </p>
<p style="text-align: center;"><code class="reqn">clr_{ki} = \log\frac{x_{ki}}{g(x_i)}</code>
</p>

<p>where <code class="reqn">x_{ki}</code> is the abundance of <code class="reqn">k</code>th feature in sample <code class="reqn">i</code>, <code class="reqn">g(x_i)</code> is the geometric mean of abundances for sample <code class="reqn">i</code>.
A pseudocount need to be added to deal with the zero. For more information, please see the 'clr' method in <code>decostand</code> function of vegan package.
</p>
</li>
<li> <p><code>rclr</code>: Robust centered log-ratio normalization &lt;doi: doi:10.1128/msystems.00016-19&gt;.
It is defined:  </p>
<p style="text-align: center;"><code class="reqn">rclr_{ki} = \log\frac{x_{ki}}{g(x_i &gt; 0)}</code>
</p>

<p>where <code class="reqn">x_{ki}</code> is the abundance of <code class="reqn">k</code>th feature in sample <code class="reqn">i</code>, <code class="reqn">g(x_i &gt; 0)</code> is the geometric mean of abundances (&gt; 0) for sample <code class="reqn">i</code>.
In rclr, zero values are kept as zeroes, and not taken into account.
</p>
</li>
<li> <p><code>CCS</code>: Cumulative sum scaling normalization based on the <code>metagenomeSeq</code> package &lt;doi:10.1038/nmeth.2658&gt;.
For a given sample <code class="reqn">j</code>, the scaling factor <code class="reqn">s_{j}^{l}</code> is defined:
</p>
<p style="text-align: center;"><code class="reqn">s_{j}^{l} = {\displaystyle\sum_{i|c_{ij} \leqslant q_{j}^{l}} c_{ij}}</code>
</p>

<p>where <code class="reqn">q_{j}^{l}</code> is the <code class="reqn">l</code>th quantile of sample <code class="reqn">j</code>, that is, in sample <code class="reqn">j</code> there are <code class="reqn">l</code> features with counts smaller than <code class="reqn">q_{j}^{l}</code>.
<code class="reqn">c_{ij}</code> denotes the count (abundance) of feature i in sample <code class="reqn">j</code>.
For <code class="reqn">l</code> = 0.95<code class="reqn">m</code> (feature number), <code class="reqn">q_{j}^{l}</code> corresponds to the 95th percentile of the count distribution for sample <code class="reqn">j</code>.
Normalized counts <code class="reqn">\tilde{c_{ij}} = (\frac{c_{ij}}{s_{j}^{l}})(N)</code>, where <code class="reqn">N</code> is an appropriately chosen normalization constant.
</p>
</li>
<li> <p><code>TSS</code>: Total sum scaling, divided by the sequencing depth.
</p>
</li>
<li> <p><code>TMM</code>: Trimmed mean of M-values method based on the <code>normLibSizes</code> function of <code>edgeR</code> package &lt;doi: 10.1186/gb-2010-11-3-r25&gt;.
</p>
</li>
<li> <p><code>RLE</code>: Relative log expression. 
</p>
</li>
<li> <p><code>SRS</code>: scaling with ranked subsampling method based on the SRS package provided by Lukas Beule and Petr Karlovsky (2020) &lt;DOI:10.7717/peerj.9593&gt;.
</p>
</li></ul>

<p>Methods based on <code><a href="vegan.html#topic+decostand">decostand</a></code> function:
</p>

<ul>
<li> <p><code>total</code>: divide by margin total (default MARGIN = 1, i.e. rows - samples).
</p>
</li>
<li> <p><code>max</code>: divide by margin maximum (default MARGIN = 2, i.e. columns - features).
</p>
</li>
<li> <p><code>normalize</code>:  make margin sum of squares equal to one (default MARGIN = 1).
</p>
</li>
<li> <p><code>range</code>: standardize values into range 0...1 (default MARGIN = 2). If all values are constant, they will be transformed to 0.
</p>
</li>
<li> <p><code>standardize</code>: scale x to zero mean and unit variance (default MARGIN = 2).
</p>
</li>
<li> <p><code>pa</code>: scale x to presence/absence scale (0/1).
</p>
</li>
<li> <p><code>log</code>: logarithmic transformation as suggested by Anderson et al. (2006): log_b (x) + 1 for x &gt; 0, where b is the base of the logarithm; zeros are left as zeros. Higher bases give less weight to quantities and more to presences, and logbase = Inf gives the presence/absence scaling. Please note this is not log(x+1). Anderson et al. (2006) suggested this for their (strongly) modified Gower distance (implemented as method = &quot;altGower&quot; in vegdist), but the standardization can be used independently of distance indices.
</p>
</li></ul>

<p>Other methods for transformation:
</p>

<ul>
<li> <p><code>AST</code>: Arc sine square root transformation.
</p>
</li></ul>
</dd>
<dt><code>MARGIN</code></dt><dd><p>default NULL; 1 = samples, and 2 = features of abundance table; only available when method comes from <code><a href="vegan.html#topic+decostand">decostand</a></code> function.
If MARGIN is NULL, use the default value in decostand function.</p>
</dd>
<dt><code>logbase</code></dt><dd><p>default exp(1); The logarithm base.</p>
</dd>
<dt><code>Cmin</code></dt><dd><p>default NULL; see Cmin parameter in <code>SRS::SRS</code> function; Only available when <code>method = "SRS"</code>.
If not provided, use the minimum number across all the samples.</p>
</dd>
<dt><code>pseudocount</code></dt><dd><p>default 1; add pseudocount for those features with 0 abundance when <code>method = "clr"</code>.</p>
</dd>
<dt><code>intersect.no</code></dt><dd><p>default 10; the intersecting taxa number between paired sample for <code>method = "GMPR"</code>.</p>
</dd>
<dt><code>ct.min</code></dt><dd><p>default 1; the minimum number of counts required to calculate ratios for <code>method = "GMPR"</code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to <code><a href="vegan.html#topic+decostand">decostand</a></code>, or <code>metagenomeSeq::cumNorm</code> when method = &quot;CCS&quot;, or 
<code>edgeR::normLibSizes</code> when method = &quot;TMM&quot; or &quot;RLE&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>new microtable object or data.frame object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>newdataset &lt;- t1$norm(method = "log")
newdataset &lt;- t1$norm(method = "clr")
</pre>
</div>


<hr>
<a id="method-trans_norm-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_norm$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_norm$new`
## ------------------------------------------------

library(microeco)
data(dataset)
t1 &lt;- trans_norm$new(dataset = dataset)

## ------------------------------------------------
## Method `trans_norm$norm`
## ------------------------------------------------

newdataset &lt;- t1$norm(method = "log")
newdataset &lt;- t1$norm(method = "clr")
</code></pre>

<hr>
<h2 id='trans_nullmodel'>Create <code>trans_nullmodel</code> object for phylogeny- and taxonomy-based null model analysis.</h2><span id='topic+trans_nullmodel'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of null model related approaches, 
including the mantel correlogram analysis of phylogenetic signal, beta nearest taxon index (betaNTI), 
beta net relatedness index (betaNRI), NTI, NRI and RCbray calculations;
See Stegen et al. (2013) &lt;10.1038/ismej.2013.93&gt; and Liu et al. (2017) &lt;doi:10.1038/s41598-017-17736-w&gt; for the algorithms and applications.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_nullmodel-new"><code>trans_nullmodel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_mantel_corr"><code>trans_nullmodel$cal_mantel_corr()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-plot_mantel_corr"><code>trans_nullmodel$plot_mantel_corr()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_betampd"><code>trans_nullmodel$cal_betampd()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_betamntd"><code>trans_nullmodel$cal_betamntd()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_ses_betampd"><code>trans_nullmodel$cal_ses_betampd()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_ses_betamntd"><code>trans_nullmodel$cal_ses_betamntd()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_rcbray"><code>trans_nullmodel$cal_rcbray()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_process"><code>trans_nullmodel$cal_process()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_NRI"><code>trans_nullmodel$cal_NRI()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_NTI"><code>trans_nullmodel$cal_NTI()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_Cscore"><code>trans_nullmodel$cal_Cscore()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_NST"><code>trans_nullmodel$cal_NST()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_NST_test"><code>trans_nullmodel$cal_NST_test()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-cal_NST_convert"><code>trans_nullmodel$cal_NST_convert()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_nullmodel-clone"><code>trans_nullmodel$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_nullmodel-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$new(
  dataset = NULL,
  filter_thres = 0,
  taxa_number = NULL,
  group = NULL,
  select_group = NULL,
  env_cols = NULL,
  add_data = NULL,
  complete_na = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>the object of <code><a href="#topic+microtable">microtable</a></code> Class.</p>
</dd>
<dt><code>filter_thres</code></dt><dd><p>default 0; the relative abundance threshold.</p>
</dd>
<dt><code>taxa_number</code></dt><dd><p>default NULL; how many taxa the user want to keep, if provided, filter_thres parameter will be forcible invalid.</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; which column name in sample_table is selected as the group for the following selection.</p>
</dd>
<dt><code>select_group</code></dt><dd><p>default NULL; one or more elements in <code>group</code>, used to select samples.</p>
</dd>
<dt><code>env_cols</code></dt><dd><p>default NULL; number or name vector to select the environmental data in dataset$sample_table.</p>
</dd>
<dt><code>add_data</code></dt><dd><p>default NULL; provide environmental data table additionally.</p>
</dd>
<dt><code>complete_na</code></dt><dd><p>default FALSE; whether fill the NA in environmental data based on the method in mice package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data_comm</code> and <code>data_tree</code> in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>data(dataset)
data(env_data_16S)
t1 &lt;- trans_nullmodel$new(dataset, filter_thres = 0.0005, add_data = env_data_16S)
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_mantel_corr"></a>



<h4>Method <code>cal_mantel_corr()</code></h4>

<p>Calculate mantel correlogram.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_mantel_corr(
  use_env = NULL,
  break.pts = seq(0, 1, 0.02),
  cutoff = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_env</code></dt><dd><p>default NULL; numeric or character vector to select env_data; if provide multiple variables or NULL, 
use PCA (principal component analysis) to reduce dimensionality.</p>
</dd>
<dt><code>break.pts</code></dt><dd><p>default seq(0, 1, 0.02); see break.pts parameter in <code><a href="vegan.html#topic+mantel.correlog">mantel.correlog</a></code> of <code>vegan</code> package.</p>
</dd>
<dt><code>cutoff</code></dt><dd><p>default FALSE; see cutoff parameter in <code><a href="vegan.html#topic+mantel.correlog">mantel.correlog</a></code>.</p>
</dd>
<dt><code>...</code></dt><dd><p>parameters pass to <code><a href="vegan.html#topic+mantel.correlog">mantel.correlog</a></code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_mantel_corr in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_mantel_corr(use_env = "pH")
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-plot_mantel_corr"></a>



<h4>Method <code>plot_mantel_corr()</code></h4>

<p>Plot mantel correlogram.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$plot_mantel_corr(point_shape = 22, point_size = 3)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>point_shape</code></dt><dd><p>default 22; the number for selecting point shape type; see <code>ggplot2</code> manual for the number meaning.</p>
</dd>
<dt><code>point_size</code></dt><dd><p>default 3; the point size.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$plot_mantel_corr()
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_betampd"></a>



<h4>Method <code>cal_betampd()</code></h4>

<p>Calculate betaMPD (mean pairwise distance). Same with <code>picante::comdist</code> function, but faster.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_betampd(abundance.weighted = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>abundance.weighted</code></dt><dd><p>default TRUE; whether use abundance-weighted method.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_betampd in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_betampd(abundance.weighted = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_betamntd"></a>



<h4>Method <code>cal_betamntd()</code></h4>

<p>Calculate betaMNTD (mean nearest taxon distance). Same with <code>picante::comdistnt</code> package, but faster.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_betamntd(
  abundance.weighted = TRUE,
  exclude.conspecifics = FALSE,
  use_iCAMP = FALSE,
  use_iCAMP_force = TRUE,
  iCAMP_tempdir = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>abundance.weighted</code></dt><dd><p>default TRUE; whether use abundance-weighted method.</p>
</dd>
<dt><code>exclude.conspecifics</code></dt><dd><p>default FALSE; see <code>exclude.conspecifics</code> parameter in <code>comdistnt</code> function of <code>picante</code> package.</p>
</dd>
<dt><code>use_iCAMP</code></dt><dd><p>default FALSE; whether use <code>bmntd.big</code> function of <code>iCAMP</code> package to calculate betaMNTD. 
This method can store the phylogenetic distance matrix on the disk to lower the memory spending and perform the calculation parallelly.</p>
</dd>
<dt><code>use_iCAMP_force</code></dt><dd><p>default FALSE; whether use <code>bmntd.big</code> function of <code>iCAMP</code> package automatically when the feature number is large.</p>
</dd>
<dt><code>iCAMP_tempdir</code></dt><dd><p>default NULL; the temporary directory used to place the large tree file; If NULL; use the system user tempdir.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters pass to <code>iCAMP::pdist.big</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_betamntd in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$cal_betamntd(abundance.weighted = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_ses_betampd"></a>



<h4>Method <code>cal_ses_betampd()</code></h4>

<p>Calculate standardized effect size of betaMPD, i.e. beta net relatedness index (betaNRI).
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_ses_betampd(
  runs = 1000,
  null.model = c("taxa.labels", "richness", "frequency", "sample.pool", "phylogeny.pool",
    "independentswap", "trialswap")[1],
  abundance.weighted = TRUE,
  iterations = 1000
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>runs</code></dt><dd><p>default 1000; simulation runs.</p>
</dd>
<dt><code>null.model</code></dt><dd><p>default &quot;taxa.labels&quot;; The available options include &quot;taxa.labels&quot;, &quot;richness&quot;, &quot;frequency&quot;, &quot;sample.pool&quot;, &quot;phylogeny.pool&quot;, 
&quot;independentswap&quot;and &quot;trialswap&quot;; see <code>null.model</code> parameter of <code>ses.mntd</code> function in <code>picante</code> package for the algorithm details.</p>
</dd>
<dt><code>abundance.weighted</code></dt><dd><p>default TRUE; whether use weighted abundance.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>default 1000; iteration number for part null models to perform; see iterations parameter of <code>picante::randomizeMatrix</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_ses_betampd in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# only run 50 times for the example; default 1000
t1$cal_ses_betampd(runs = 50, abundance.weighted = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_ses_betamntd"></a>



<h4>Method <code>cal_ses_betamntd()</code></h4>

<p>Calculate standardized effect size of betaMNTD, i.e. beta nearest taxon index (betaNTI).
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_ses_betamntd(
  runs = 1000,
  null.model = c("taxa.labels", "richness", "frequency", "sample.pool", "phylogeny.pool",
    "independentswap", "trialswap")[1],
  abundance.weighted = TRUE,
  exclude.conspecifics = FALSE,
  use_iCAMP = FALSE,
  use_iCAMP_force = TRUE,
  iCAMP_tempdir = NULL,
  nworker = 2,
  iterations = 1000
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>runs</code></dt><dd><p>default 1000; simulation number of null model.</p>
</dd>
<dt><code>null.model</code></dt><dd><p>default &quot;taxa.labels&quot;; The available options include &quot;taxa.labels&quot;, &quot;richness&quot;, &quot;frequency&quot;, &quot;sample.pool&quot;, &quot;phylogeny.pool&quot;, 
&quot;independentswap&quot;and &quot;trialswap&quot;; see <code>null.model</code> parameter of <code>ses.mntd</code> function in <code>picante</code> package for the algorithm details.</p>
</dd>
<dt><code>abundance.weighted</code></dt><dd><p>default TRUE; whether use abundance-weighted method.</p>
</dd>
<dt><code>exclude.conspecifics</code></dt><dd><p>default FALSE; see <code>comdistnt</code> in picante package.</p>
</dd>
<dt><code>use_iCAMP</code></dt><dd><p>default FALSE; whether use bmntd.big function of iCAMP package to calculate betaMNTD. 
This method can store the phylogenetic distance matrix on the disk to lower the memory spending and perform the calculation parallelly.</p>
</dd>
<dt><code>use_iCAMP_force</code></dt><dd><p>default FALSE; whether to make use_iCAMP to be TRUE when the feature number is large.</p>
</dd>
<dt><code>iCAMP_tempdir</code></dt><dd><p>default NULL; the temporary directory used to place the large tree file; If NULL; use the system user tempdir.</p>
</dd>
<dt><code>nworker</code></dt><dd><p>default 2; the CPU thread number.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>default 1000; iteration number for part null models to perform; see iterations parameter of <code>picante::randomizeMatrix</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_ses_betamntd in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# only run 50 times for the example; default 1000
t1$cal_ses_betamntd(runs = 50, abundance.weighted = TRUE, exclude.conspecifics = FALSE)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_rcbray"></a>



<h4>Method <code>cal_rcbray()</code></h4>

<p>Calculate Brayâ€“Curtis-based Raupâ€“Crick (RCbray) &lt;doi: 10.1890/ES10-00117.1&gt;.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_rcbray(
  runs = 1000,
  verbose = TRUE,
  null.model = "independentswap"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>runs</code></dt><dd><p>default 1000; simulation runs.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>default TRUE; whether show the calculation process message.</p>
</dd>
<dt><code>null.model</code></dt><dd><p>default &quot;independentswap&quot;; see more available options in <code>randomizeMatrix</code> function of <code>picante</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_rcbray in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
# only run 50 times for the example; default 1000
t1$cal_rcbray(runs = 50)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_process"></a>



<h4>Method <code>cal_process()</code></h4>

<p>Infer the ecological processes according to ses.betaMNTD/ses.betaMPD and rcbray.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_process(use_betamntd = TRUE, group = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_betamntd</code></dt><dd><p>default TRUE; whether use ses.betaMNTD; if false, use ses.betaMPD.</p>
</dd>
<dt><code>group</code></dt><dd><p>default NULL; a column name in sample_table of microtable object. 
If provided, the analysis will be performed for each group instead of the whole.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_process in object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_process(use_betamntd = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_NRI"></a>



<h4>Method <code>cal_NRI()</code></h4>

<p>Calculates Nearest Relative Index (NRI), equivalent to -1 times the standardized effect size of MPD.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_NRI(
  null.model = "taxa.labels",
  abundance.weighted = FALSE,
  runs = 999,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>null.model</code></dt><dd><p>default &quot;taxa.labels&quot;; Null model to use; see <code>null.model</code> parameter in <code>ses.mpd</code> function of <code>picante</code> package for available options.</p>
</dd>
<dt><code>abundance.weighted</code></dt><dd><p>default FALSE; Should mean nearest relative distances for each species be weighted by species abundance?</p>
</dd>
<dt><code>runs</code></dt><dd><p>default 999; Number of randomizations.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters pass to ses.mpd function in picante package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_NRI in object, equivalent to -1 times ses.mpd.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
# only run 50 times for the example; default 999
t1$cal_NRI(null.model = "taxa.labels", abundance.weighted = FALSE, runs = 50)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_NTI"></a>



<h4>Method <code>cal_NTI()</code></h4>

<p>Calculates Nearest Taxon Index (NTI), equivalent to -1 times the standardized effect size of MNTD.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_NTI(
  null.model = "taxa.labels",
  abundance.weighted = FALSE,
  runs = 999,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>null.model</code></dt><dd><p>default &quot;taxa.labels&quot;; Null model to use; see <code>null.model</code> parameter in <code>ses.mntd</code> function of <code>picante</code> package for available options.</p>
</dd>
<dt><code>abundance.weighted</code></dt><dd><p>default FALSE; Should mean nearest taxon distances for each species be weighted by species abundance?</p>
</dd>
<dt><code>runs</code></dt><dd><p>default 999; Number of randomizations.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters pass to <code>ses.mntd</code> function in <code>picante</code> package.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_NTI in object, equivalent to -1 times ses.mntd.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
# only run 50 times for the example; default 999
t1$cal_NTI(null.model = "taxa.labels", abundance.weighted = TRUE, runs = 50)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_Cscore"></a>



<h4>Method <code>cal_Cscore()</code></h4>

<p>Calculates the (normalised) mean number of checkerboard combinations (C-score) using <code>C.score</code> function in <code>bipartite</code> package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_Cscore(by_group = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>by_group</code></dt><dd><p>default NULL; one column name or number in sample_table; calculate C-score for different groups separately.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters pass to <code>bipartite::C.score</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>vector.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_Cscore(normalise = FALSE)
t1$cal_Cscore(by_group = "Group", normalise = FALSE)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_NST"></a>



<h4>Method <code>cal_NST()</code></h4>

<p>Calculate normalized stochasticity ratio (NST) based on the <code>NST</code> package.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_NST(method = "tNST", group, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default &quot;tNST&quot;; <code>'tNST'</code> or <code>'pNST'</code>. See the help document of <code>tNST</code> or <code>pNST</code> function in <code>NST</code> package for more details.</p>
</dd>
<dt><code>group</code></dt><dd><p>a colname of <code>sample_table</code> in microtable object; 
the function can select the data from sample_table to generate a one-column (n x 1) matrix and 
provide it to the group parameter of <code>tNST</code> or <code>pNST</code> function.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters pass to <code>NST::tNST</code> or <code>NST::pNST</code> function; see the document of corresponding function for more details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>res_NST stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_NST(group = "Group", dist.method = "bray", output.rand = TRUE, SES = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_NST_test"></a>



<h4>Method <code>cal_NST_test()</code></h4>

<p>Test the significance of NST difference between each pair of groups.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_NST_test(method = "nst.boot", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>default &quot;nst.boot&quot;; &quot;nst.boot&quot; or &quot;nst.panova&quot;; see <code>NST::nst.boot</code> function or <code>NST::nst.panova</code> function for the details.</p>
</dd>
<dt><code>...</code></dt><dd><p>paremeters pass to NST::nst.boot when method = &quot;nst.boot&quot; or NST::nst.panova when method = &quot;nst.panova&quot;.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>list. See the Return part of <code>NST::nst.boot</code> function or <code>NST::nst.panova</code> function in NST package.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_NST_test()
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-cal_NST_convert"></a>



<h4>Method <code>cal_NST_convert()</code></h4>

<p>Convert NST paired long format table to symmetric matrix form.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$cal_NST_convert(column = 10)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>column</code></dt><dd><p>default 10; which column is selected for the conversion. See the columns of <code>res_NST$index.pair</code> stored in the object.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>symmetric matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\dontrun{
t1$cal_NST_convert(column = 10)
}
</pre>
</div>


<hr>
<a id="method-trans_nullmodel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_nullmodel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_nullmodel$new`
## ------------------------------------------------

data(dataset)
data(env_data_16S)
t1 &lt;- trans_nullmodel$new(dataset, filter_thres = 0.0005, add_data = env_data_16S)

## ------------------------------------------------
## Method `trans_nullmodel$cal_mantel_corr`
## ------------------------------------------------

## Not run: 
t1$cal_mantel_corr(use_env = "pH")

## End(Not run)

## ------------------------------------------------
## Method `trans_nullmodel$plot_mantel_corr`
## ------------------------------------------------

## Not run: 
t1$plot_mantel_corr()

## End(Not run)

## ------------------------------------------------
## Method `trans_nullmodel$cal_betampd`
## ------------------------------------------------


t1$cal_betampd(abundance.weighted = TRUE)


## ------------------------------------------------
## Method `trans_nullmodel$cal_betamntd`
## ------------------------------------------------


t1$cal_betamntd(abundance.weighted = TRUE)


## ------------------------------------------------
## Method `trans_nullmodel$cal_ses_betampd`
## ------------------------------------------------

## Not run: 
# only run 50 times for the example; default 1000
t1$cal_ses_betampd(runs = 50, abundance.weighted = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `trans_nullmodel$cal_ses_betamntd`
## ------------------------------------------------

## Not run: 
# only run 50 times for the example; default 1000
t1$cal_ses_betamntd(runs = 50, abundance.weighted = TRUE, exclude.conspecifics = FALSE)

## End(Not run)

## ------------------------------------------------
## Method `trans_nullmodel$cal_rcbray`
## ------------------------------------------------

## Not run: 
# only run 50 times for the example; default 1000
t1$cal_rcbray(runs = 50)

## End(Not run)

## ------------------------------------------------
## Method `trans_nullmodel$cal_process`
## ------------------------------------------------

## Not run: 
t1$cal_process(use_betamntd = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `trans_nullmodel$cal_NRI`
## ------------------------------------------------


# only run 50 times for the example; default 999
t1$cal_NRI(null.model = "taxa.labels", abundance.weighted = FALSE, runs = 50)


## ------------------------------------------------
## Method `trans_nullmodel$cal_NTI`
## ------------------------------------------------


# only run 50 times for the example; default 999
t1$cal_NTI(null.model = "taxa.labels", abundance.weighted = TRUE, runs = 50)


## ------------------------------------------------
## Method `trans_nullmodel$cal_Cscore`
## ------------------------------------------------

## Not run: 
t1$cal_Cscore(normalise = FALSE)
t1$cal_Cscore(by_group = "Group", normalise = FALSE)

## End(Not run)

## ------------------------------------------------
## Method `trans_nullmodel$cal_NST`
## ------------------------------------------------

## Not run: 
t1$cal_NST(group = "Group", dist.method = "bray", output.rand = TRUE, SES = TRUE)

## End(Not run)

## ------------------------------------------------
## Method `trans_nullmodel$cal_NST_test`
## ------------------------------------------------

## Not run: 
t1$cal_NST_test()

## End(Not run)

## ------------------------------------------------
## Method `trans_nullmodel$cal_NST_convert`
## ------------------------------------------------

## Not run: 
t1$cal_NST_convert(column = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='trans_venn'>Create <code>trans_venn</code> object for the Venn diagram, petal plot and UpSet plot.</h2><span id='topic+trans_venn'></span>

<h3>Description</h3>

<p>This class is a wrapper for a series of intersection analysis related methods, including 2- to 5-way venn diagram, 
more than 5-way petal or UpSet plot and intersection transformations based on David et al. (2012) &lt;doi:10.1128/AEM.01459-12&gt;.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-trans_venn-new"><code>trans_venn$new()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_venn-plot_venn"><code>trans_venn$plot_venn()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_venn-plot_bar"><code>trans_venn$plot_bar()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_venn-trans_comm"><code>trans_venn$trans_comm()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_venn-print"><code>trans_venn$print()</code></a>
</p>
</li>
<li> <p><a href="#method-trans_venn-clone"><code>trans_venn$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-trans_venn-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>trans_venn$new(dataset, ratio = NULL, name_joint = "&amp;")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>the object of <code><a href="#topic+microtable">microtable</a></code> class or a matrix-like table (data.frame or matrix object).
If dataset is a matrix-like table, features must be rows.</p>
</dd>
<dt><code>ratio</code></dt><dd><p>default NULL; NULL, &quot;numratio&quot; or &quot;seqratio&quot;; &quot;numratio&quot;: calculate the percentage of feature number; 
&quot;seqratio&quot;: calculate the percentage of feature abundance; NULL: no additional percentage.</p>
</dd>
<dt><code>name_joint</code></dt><dd><p>default &quot;&amp;&quot;; the joint mark for generating multi-sample names.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>data_details</code> and <code>data_summary</code> stored in the object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
data(dataset)
t1 &lt;- dataset$merge_samples(use_group = "Group")
t1 &lt;- trans_venn$new(dataset = t1, ratio = "numratio")
}
</pre>
</div>


<hr>
<a id="method-trans_venn-plot_venn"></a>



<h4>Method <code>plot_venn()</code></h4>

<p>Plot venn diagram.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_venn$plot_venn(
  color_circle = RColorBrewer::brewer.pal(8, "Dark2"),
  fill_color = TRUE,
  text_size = 4.5,
  text_name_size = 6,
  text_name_position = NULL,
  alpha = 0.3,
  linesize = 1.1,
  petal_plot = FALSE,
  petal_color = "#BEAED4",
  petal_color_center = "#BEBADA",
  petal_a = 4,
  petal_r = 1,
  petal_use_lim = c(-12, 12),
  petal_center_size = 40,
  petal_move_xy = 4,
  petal_move_k = 2.3,
  petal_move_k_count = 1.3,
  petal_text_move = 40,
  other_text_show = NULL,
  other_text_position = c(2, 2),
  other_text_size = 5
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>color_circle</code></dt><dd><p>default <code>RColorBrewer::brewer.pal(8, "Dark2")</code>; color pallete.</p>
</dd>
<dt><code>fill_color</code></dt><dd><p>default TRUE; whether fill the area color.</p>
</dd>
<dt><code>text_size</code></dt><dd><p>default 4.5; text size in plot.</p>
</dd>
<dt><code>text_name_size</code></dt><dd><p>default 6; name size in plot.</p>
</dd>
<dt><code>text_name_position</code></dt><dd><p>default NULL; name position in plot.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>default .3; alpha for transparency.</p>
</dd>
<dt><code>linesize</code></dt><dd><p>default 1.1; cycle line size.</p>
</dd>
<dt><code>petal_plot</code></dt><dd><p>default FALSE; whether use petal plot.</p>
</dd>
<dt><code>petal_color</code></dt><dd><p>default &quot;#BEAED4&quot;; color of the petals; If petal_color only has one color value, all the petals will be assigned with this color value.
If petal_color has multiple colors, and the number of color values is smaller than the petal number, 
the function can append more colors automatically with the color interpolation.</p>
</dd>
<dt><code>petal_color_center</code></dt><dd><p>default &quot;#BEBADA&quot;; color of the center in the petal plot.</p>
</dd>
<dt><code>petal_a</code></dt><dd><p>default 4; the length of the ellipse.</p>
</dd>
<dt><code>petal_r</code></dt><dd><p>default 1; scaling up the size of the ellipse.</p>
</dd>
<dt><code>petal_use_lim</code></dt><dd><p>default c(-12, 12); the width of the plot.</p>
</dd>
<dt><code>petal_center_size</code></dt><dd><p>default 40; petal center circle size.</p>
</dd>
<dt><code>petal_move_xy</code></dt><dd><p>default 4; the distance of text to circle.</p>
</dd>
<dt><code>petal_move_k</code></dt><dd><p>default 2.3; the distance of title to circle.</p>
</dd>
<dt><code>petal_move_k_count</code></dt><dd><p>default 1.3; the distance of data text to circle.</p>
</dd>
<dt><code>petal_text_move</code></dt><dd><p>default 40; the distance between two data text.</p>
</dd>
<dt><code>other_text_show</code></dt><dd><p>default NULL; other characters used to show in the plot.</p>
</dd>
<dt><code>other_text_position</code></dt><dd><p>default c(1, 1); the text position for text in <code>other_text_show</code>.</p>
</dd>
<dt><code>other_text_size</code></dt><dd><p>default 5; the text size for text in <code>other_text_show</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>ggplot.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t1$plot_venn()
}
</pre>
</div>


<hr>
<a id="method-trans_venn-plot_bar"></a>



<h4>Method <code>plot_bar()</code></h4>

<p>Plot the intersections using histogram, i.e. UpSet plot. Especially useful when samples &gt; 5.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_venn$plot_bar(
  left_plot = TRUE,
  sort_samples = FALSE,
  up_y_title = "Intersection size",
  up_y_title_size = 15,
  up_y_text_size = 8,
  up_bar_fill = "grey70",
  bottom_y_text_size = 12,
  bottom_height = 1,
  bottom_point_size = 3,
  bottom_point_color = "black",
  bottom_background_fill = "grey95",
  left_width = 0.3,
  left_bar_fill = "grey70",
  left_x_text_size = 10,
  left_background_fill = "grey95"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>left_plot</code></dt><dd><p>default TRUE; whether add the left bar plot to show the feature number of each sample.</p>
</dd>
<dt><code>sort_samples</code></dt><dd><p>default FALSE; <code>TRUE</code> is used to sort samples according to the number of features in each sample.
<code>FALSE</code> means the sample order is same with that in sample_table of the raw dataset.</p>
</dd>
<dt><code>up_y_title</code></dt><dd><p>default &quot;Intersection set&quot;; y axis title of upper plot.</p>
</dd>
<dt><code>up_y_title_size</code></dt><dd><p>default 15; y axis title size of upper plot.</p>
</dd>
<dt><code>up_y_text_size</code></dt><dd><p>default 4; y axis text size of upper plot.</p>
</dd>
<dt><code>up_bar_fill</code></dt><dd><p>default &quot;grey70&quot;; bar fill color of upper plot.</p>
</dd>
<dt><code>bottom_y_text_size</code></dt><dd><p>default 12; y axis text size, i.e. sample name size, of bottom sample plot.</p>
</dd>
<dt><code>bottom_height</code></dt><dd><p>default 1; bottom plot height relative to the upper bar plot. 1 represents the height of bottom plot is same with the upper bar plot.</p>
</dd>
<dt><code>bottom_point_size</code></dt><dd><p>default 3; point size of bottom plot.</p>
</dd>
<dt><code>bottom_point_color</code></dt><dd><p>default &quot;black&quot;; point color of bottom plot.</p>
</dd>
<dt><code>bottom_background_fill</code></dt><dd><p>default &quot;grey95&quot;; fill color for the striped background in the bottom sample plot.</p>
</dd>
<dt><code>left_width</code></dt><dd><p>default 0.3; left bar plot width relative to the right bottom plot.</p>
</dd>
<dt><code>left_bar_fill</code></dt><dd><p>default &quot;grey70&quot;; fill color for the left bar plot presenting feature number.</p>
</dd>
<dt><code>left_x_text_size</code></dt><dd><p>default 10; x axis text size of the left bar plot.</p>
</dd>
<dt><code>left_background_fill</code></dt><dd><p>default &quot;grey95&quot;; fill color for the striped background in the left plot.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a ggplot2 object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t2 &lt;- t1$plot_bar()
}
</pre>
</div>


<hr>
<a id="method-trans_venn-trans_comm"></a>



<h4>Method <code>trans_comm()</code></h4>

<p>Transform intersection result to community-like microtable object for further composition analysis.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_venn$trans_comm(use_frequency = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>use_frequency</code></dt><dd><p>default TRUE; whether only use OTUs occurrence frequency, i.e. presence/absence data; if FALSE, use abundance data.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a new <code><a href="#topic+microtable">microtable</a></code> class.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
t2 &lt;- t1$trans_comm(use_frequency = TRUE)
}
</pre>
</div>


<hr>
<a id="method-trans_venn-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the trans_venn object.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_venn$print()</pre></div>


<hr>
<a id="method-trans_venn-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trans_venn$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `trans_venn$new`
## ------------------------------------------------


data(dataset)
t1 &lt;- dataset$merge_samples(use_group = "Group")
t1 &lt;- trans_venn$new(dataset = t1, ratio = "numratio")


## ------------------------------------------------
## Method `trans_venn$plot_venn`
## ------------------------------------------------


t1$plot_venn()


## ------------------------------------------------
## Method `trans_venn$plot_bar`
## ------------------------------------------------


t2 &lt;- t1$plot_bar()


## ------------------------------------------------
## Method `trans_venn$trans_comm`
## ------------------------------------------------


t2 &lt;- t1$trans_comm(use_frequency = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
