<!DOCTYPE html><html><head><title>Help for package car</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {car}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Anova'><p>Anova Tables for Various Statistical Models</p></a></li>
<li><a href='#avPlots'><p>Added-Variable Plots</p></a></li>
<li><a href='#bcPower'><p>Box-Cox, Box-Cox with Negatives Allowed, Yeo-Johnson and Basic Power Transformations</p></a></li>
<li><a href='#Boot'><p>Bootstrapping for regression models</p></a></li>
<li><a href='#boxCox'>
<p>Graph the profile log-likelihood for Box-Cox transformations in 1D, or in 2D with the bcnPower family.</p></a></li>
<li><a href='#boxCoxVariable'><p>Constructed Variable for Box-Cox Transformation</p></a></li>
<li><a href='#Boxplot'>
<p>Boxplots With Point Identification</p></a></li>
<li><a href='#boxTidwell'><p>Box-Tidwell Transformations</p></a></li>
<li><a href='#brief'>
<p>Print Abbreviated Ouput</p></a></li>
<li><a href='#car-defunct'><p>Defunct Functions in the car Package</p></a></li>
<li><a href='#car-deprecated'><p>Deprecated Functions in the car Package</p></a></li>
<li><a href='#car-internal.Rd'>
<p>Internal Objects for the <span class="pkg">car</span> package</p></a></li>
<li><a href='#carHexsticker'>
<p>View the Official Hex Sticker for the car Package</p></a></li>
<li><a href='#carPalette'>
<p>Set or Retrieve <span class="pkg">car</span> Package Color Palette</p></a></li>
<li><a href='#carWeb'><p> Access to the R Companion to Applied Regression Website</p></a></li>
<li><a href='#ceresPlots'><p>Ceres Plots</p></a></li>
<li><a href='#compareCoefs'>
<p>Print estimated coefficients and their standard errors in a table</p>
for several regression models.</a></li>
<li><a href='#Contrasts'><p>Functions to Construct Contrasts</p></a></li>
<li><a href='#crPlots'><p>Component+Residual (Partial Residual) Plots</p></a></li>
<li><a href='#deltaMethod'><p>Estimate and Standard Error of a Nonlinear Function of Estimated Regression</p>
Coefficients</a></li>
<li><a href='#densityPlot'>
<p>Nonparametric Density Estimates</p></a></li>
<li><a href='#dfbetaPlots'><p>dfbeta and dfbetas Index Plots</p></a></li>
<li><a href='#durbinWatsonTest'><p>Durbin-Watson Test for Autocorrelated Errors</p></a></li>
<li><a href='#Ellipses'><p>Ellipses, Data Ellipses, and Confidence Ellipses</p></a></li>
<li><a href='#Export'>
<p>Export a data frame to disk in one of many formats</p></a></li>
<li><a href='#hccm'><p>Heteroscedasticity-Corrected Covariance Matrices</p></a></li>
<li><a href='#hist.boot'>
<p>Methods Functions to Support <code>boot</code> Objects</p></a></li>
<li><a href='#Import'>
<p>Import data from many file formats</p></a></li>
<li><a href='#infIndexPlot'><p>Influence Index Plot</p></a></li>
<li><a href='#influence.mixed.models'>
<p>Influence Diagnostics for Mixed-Effects Models</p></a></li>
<li><a href='#influencePlot'><p>Regression Influence Plot</p></a></li>
<li><a href='#invResPlot'><p>Inverse Response Plots to Transform the Response</p></a></li>
<li><a href='#invTranPlot'><p> Choose a Predictor Transformation Visually or Numerically</p></a></li>
<li><a href='#leveneTest'><p>Levene's Test</p></a></li>
<li><a href='#leveragePlots'><p>Regression Leverage Plots</p></a></li>
<li><a href='#linearHypothesis'><p>Test Linear Hypothesis</p></a></li>
<li><a href='#logit'><p>Logit Transformation</p></a></li>
<li><a href='#mcPlots'><p>Draw Linear Model Marginal and Conditional Plots in Parallel or Overlaid</p></a></li>
<li><a href='#mmps'><p>Marginal Model Plotting</p></a></li>
<li><a href='#ncvTest'><p>Score Test for Non-Constant Error Variance</p></a></li>
<li><a href='#outlierTest'><p>Bonferroni Outlier Test</p></a></li>
<li><a href='#panel.car'><p>Panel Function for Coplots</p></a></li>
<li><a href='#pointLabel'><p> Label placement for points to avoid overlaps</p></a></li>
<li><a href='#poTest'><p>Test for Proportional Odds in the Proportional-Odds Logistic-Regression Model</p></a></li>
<li><a href='#powerTransform'><p>Finding Univariate or Multivariate Power Transformations</p></a></li>
<li><a href='#Predict'>
<p>Model Predictions</p></a></li>
<li><a href='#qqPlot'><p>Quantile-Comparison Plot</p></a></li>
<li><a href='#recode'><p>Recode a Variable</p></a></li>
<li><a href='#regLine'><p>Plot Regression Line</p></a></li>
<li><a href='#residualPlots'><p>Residual Plots for Linear and Generalized Linear Models</p></a></li>
<li><a href='#S'>
<p>Modified Functions for Summarizing Linear, Generalized Linear, and Some Other Models</p></a></li>
<li><a href='#scatter3d'><p>Three-Dimensional Scatterplots and Point Identification</p></a></li>
<li><a href='#scatterplot'><p>Enhanced Scatterplots with Marginal Boxplots, Point Marking, Smoothers, and More</p></a></li>
<li><a href='#scatterplotMatrix'><p>Scatterplot Matrices</p></a></li>
<li><a href='#ScatterplotSmoothers'>
<p>Smoothers to Draw Lines on Scatterplots</p></a></li>
<li><a href='#showLabels'>
<p>Functions to Identify and Mark Extreme Points in a 2D Plot.</p></a></li>
<li><a href='#sigmaHat'><p> Return the scale estimate for a regression model</p></a></li>
<li><a href='#some'><p>Sample a Few Elements of an Object</p></a></li>
<li><a href='#spreadLevelPlot'><p>Spread-Level Plots</p></a></li>
<li><a href='#strings2factors'>
<p>Convert Character-String Variables in a Data Frame to Factors</p></a></li>
<li><a href='#subsets'><p>Plot Output from regsubsets Function in leaps package</p></a></li>
<li><a href='#symbox'><p>Boxplots for transformations to symmetry</p></a></li>
<li><a href='#Tapply'><p>Apply a Function to a Variable Within Factor Levels</p></a></li>
<li><a href='#testTransform'><p>Likelihood-Ratio Tests for Univariate or Multivariate Power Transformations</p>
to Normality</a></li>
<li><a href='#TransformationAxes'><p>Axes for Transformed Variables</p></a></li>
<li><a href='#vif'><p>Variance Inflation Factors</p></a></li>
<li><a href='#wcrossprod'>
<p>Weighted Matrix Crossproduct</p></a></li>
<li><a href='#whichNames'><p>Position of Row Names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Companion to Applied Regression</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), carData (&ge; 3.0-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, MASS, mgcv, nnet, pbkrtest (&ge; 0.4-4), quantreg,
grDevices, utils, stats, graphics, lme4 (&ge; 1.1-27.1), nlme,
scales</td>
</tr>
<tr>
<td>Suggests:</td>
<td>alr4, boot, coxme, effects, knitr, leaps, lmtest, Matrix,
MatrixModels, mvtnorm, rgl (&ge; 0.111.3), rio, sandwich,
SparseM, survival, survey</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Functions to Accompany J. Fox and S. Weisberg, 
  An R Companion to Applied Regression, Third Edition, Sage, 2019.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-forge.r-project.org/projects/car/">https://r-forge.r-project.org/projects/car/</a>,
<a href="https://CRAN.R-project.org/package=car">https://CRAN.R-project.org/package=car</a>,
<a href="https://socialsciences.mcmaster.ca/jfox/Books/Companion/index.html">https://socialsciences.mcmaster.ca/jfox/Books/Companion/index.html</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>John Fox [aut, cre],
  Sanford Weisberg [aut],
  Brad Price [aut],
  Daniel Adler [ctb],
  Douglas Bates [ctb],
  Gabriel Baud-Bovy [ctb],
  Ben Bolker [ctb],
  Steve Ellison [ctb],
  David Firth [ctb],
  Michael Friendly [ctb],
  Gregor Gorjanc [ctb],
  Spencer Graves [ctb],
  Richard Heiberger [ctb],
  Pavel Krivitsky [ctb],
  Rafael Laboissiere [ctb],
  Martin Maechler [ctb],
  Georges Monette [ctb],
  Duncan Murdoch [ctb],
  Henric Nilsson [ctb],
  Derek Ogle [ctb],
  Brian Ripley [ctb],
  Tom Short [ctb],
  William Venables [ctb],
  Steve Walker [ctb],
  David Winsemius [ctb],
  Achim Zeileis [ctb],
  R-Core [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Fox &lt;jfox@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>car</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>742</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2023-03-25 21:15:09</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-30 10:40:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-25 21:36:48 UTC; rforge</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; ; 2024-01-02 08:02:22 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='Anova'>Anova Tables for Various Statistical Models</h2><span id='topic+Anova'></span><span id='topic+Anova.lm'></span><span id='topic+Anova.lme'></span><span id='topic+Anova.aov'></span><span id='topic+Anova.glm'></span><span id='topic+Anova.multinom'></span><span id='topic+Anova.polr'></span><span id='topic+Anova.mer'></span><span id='topic+Anova.merMod'></span><span id='topic+Anova.mlm'></span><span id='topic+Anova.manova'></span><span id='topic+Manova'></span><span id='topic+Manova.mlm'></span><span id='topic+print.Anova.mlm'></span><span id='topic+summary.Anova.mlm'></span><span id='topic+print.summary.Anova.mlm'></span><span id='topic+print.univaov'></span><span id='topic+as.data.frame.univaov'></span><span id='topic+Anova.coxph'></span><span id='topic+Anova.svyglm'></span><span id='topic+Anova.svycoxph'></span><span id='topic+Anova.rlm'></span><span id='topic+Anova.coxme'></span><span id='topic+Anova.default'></span>

<h3>Description</h3>

<p>Calculates type-II or type-III analysis-of-variance tables for
model objects produced by <code>lm</code>, <code>glm</code>, <code>multinom</code>
(in the <span class="pkg">nnet</span> package), <code>polr</code> (in the <span class="pkg">MASS</span>
package), <code>coxph</code> (in the <span class="pkg">survival</span> package),
<code>coxme</code> (in the <span class="pkg">coxme</span> pckage),
<code>svyglm</code> and <code>svycoxph</code> (in the <span class="pkg">survey</span> package), <code>rlm</code> (in the <span class="pkg">MASS</span> package),
<code>lmer</code> in the <span class="pkg">lme4</span> package,
<code>lme</code> in the <span class="pkg">nlme</span> package, and (by the default method) for most
models with a linear predictor and asymptotically normal coefficients (see details below). For linear
models, F-tests are calculated; for generalized linear models,
likelihood-ratio chisquare, Wald chisquare, or F-tests are calculated;
for multinomial logit and proportional-odds logit models, likelihood-ratio
tests are calculated.  Various test statistics are provided for multivariate
linear models produced by <code>lm</code> or <code>manova</code>. Partial-likelihood-ratio tests
or Wald tests are provided for Cox models. Wald chi-square tests are provided for fixed effects in
linear and generalized linear mixed-effects models. Wald chi-square or F tests are provided
in the default case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Anova(mod, ...)

Manova(mod, ...)

## S3 method for class 'lm'
Anova(mod, error, type=c("II","III", 2, 3),
	white.adjust=c(FALSE, TRUE, "hc3", "hc0", "hc1", "hc2", "hc4"),
	vcov.=NULL, singular.ok, ...)

## S3 method for class 'aov'
Anova(mod, ...)

## S3 method for class 'glm'
Anova(mod, type=c("II","III", 2, 3),
    test.statistic=c("LR", "Wald", "F"),
    error, error.estimate=c("pearson", "dispersion", "deviance"),
   vcov.=vcov(mod, complete=TRUE),  singular.ok, ...)

## S3 method for class 'multinom'
Anova(mod, type = c("II","III", 2, 3), ...)

## S3 method for class 'polr'
Anova(mod, type = c("II","III", 2, 3), ...)

## S3 method for class 'mlm'
Anova(mod, type=c("II","III", 2, 3), SSPE, error.df,
    idata, idesign, icontrasts=c("contr.sum", "contr.poly"), imatrix,
    test.statistic=c("Pillai", "Wilks", "Hotelling-Lawley", "Roy"),...)

## S3 method for class 'manova'
Anova(mod, ...)

## S3 method for class 'mlm'
Manova(mod, ...)

## S3 method for class 'Anova.mlm'
print(x, ...)

## S3 method for class 'Anova.mlm'
summary(object, test.statistic, univariate=object$repeated,
    multivariate=TRUE, p.adjust.method, ...)

## S3 method for class 'summary.Anova.mlm'
print(x, digits = getOption("digits"),
    SSP=TRUE, SSPE=SSP, ... )

## S3 method for class 'univaov'
print(x, digits = max(getOption("digits") - 2L, 3L),
                          style=c("wide", "long"),
                          by=c("response", "term"),
                          ...)

## S3 method for class 'univaov'
as.data.frame(x, row.names, optional, by=c("response", "term"), ...)

## S3 method for class 'coxph'
Anova(mod, type=c("II", "III", 2, 3),
	test.statistic=c("LR", "Wald"), ...)

## S3 method for class 'coxme'
Anova(mod, type=c("II", "III", 2, 3),
    test.statistic=c("Wald", "LR"), ...)

## S3 method for class 'lme'
Anova(mod, type=c("II","III", 2, 3),
		vcov.=vcov(mod, complete=FALSE), singular.ok, ...)

## S3 method for class 'mer'
Anova(mod, type=c("II", "III", 2, 3),
	test.statistic=c("Chisq", "F"), vcov.=vcov(mod, complete=FALSE), singular.ok, ...)

## S3 method for class 'merMod'
Anova(mod, type=c("II", "III", 2, 3),
    test.statistic=c("Chisq", "F"), vcov.=vcov(mod, complete=FALSE), singular.ok, ...)

## S3 method for class 'svyglm'
Anova(mod, ...)

## S3 method for class 'svycoxph'
Anova(mod, type=c("II", "III", 2, 3),
  test.statistic="Wald", ...)

## S3 method for class 'rlm'
Anova(mod, ...)

## Default S3 method:
Anova(mod, type=c("II", "III", 2, 3),
	test.statistic=c("Chisq", "F"), vcov.=vcov(mod, complete=FALSE),
	singular.ok, error.df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Anova_+3A_mod">mod</code></td>
<td>
<p><code>lm</code>, <code>aov</code>, <code>glm</code>, <code>multinom</code>, <code>polr</code>
<code>mlm</code>, <code>coxph</code>, <code>coxme</code>, <code>lme</code>, <code>mer</code>, <code>merMod</code>, <code>svyglm</code>, <code>svycoxph</code>,
<code>rlm</code>, or other suitable model object.</p>
</td></tr>
<tr><td><code id="Anova_+3A_error">error</code></td>
<td>
<p>for a linear model, an <code>lm</code> model object from which the
error sum of squares and degrees of freedom are to be calculated. For
F-tests for a generalized linear model, a <code>glm</code> object from which the
dispersion is to be estimated. If not specified, <code>mod</code> is used.</p>
</td></tr>
<tr><td><code id="Anova_+3A_type">type</code></td>
<td>
<p>type of test, <code>"II"</code>, <code>"III"</code>, <code>2</code>, or <code>3</code>.  Roman numerals are equivalent to
the corresponding Arabic numerals.</p>
</td></tr>
<tr><td><code id="Anova_+3A_singular.ok">singular.ok</code></td>
<td>
<p>defaults to <code>TRUE</code> for type-II tests, and <code>FALSE</code>
for type-III tests where the tests for models with aliased coefficients
will not be straightforwardly interpretable;
if <code>FALSE</code>, a model with aliased coefficients produces an error. This argument is available only for some <code>Anova</code> methods.</p>
</td></tr>
<tr><td><code id="Anova_+3A_test.statistic">test.statistic</code></td>
<td>
<p>for a generalized linear model, whether to calculate
<code>"LR"</code> (likelihood-ratio), <code>"Wald"</code>, or <code>"F"</code> tests; for a Cox
or Cox mixed-effects model, whether to calculate <code>"LR"</code> (partial-likelihood ratio) or
<code>"Wald"</code> tests; in the default case or for linear mixed models fit by
<code>lmer</code>, whether to calculate Wald <code>"Chisq"</code> or Kenward-Roger
<code>"F"</code> tests with Satterthwaite degrees of freedom (<em>warning:</em> the KR F-tests
can be very time-consuming).
For a multivariate linear model, the multivariate test statistic to compute &mdash; one of
<code>"Pillai"</code>, <code>"Wilks"</code>, <code>"Hotelling-Lawley"</code>, or <code>"Roy"</code>,
with <code>"Pillai"</code> as the default. The <code>summary</code> method for <code>Anova.mlm</code>
objects permits the specification of more than one multivariate
test statistic, and the default is to report all four.</p>
</td></tr>
<tr><td><code id="Anova_+3A_error.estimate">error.estimate</code></td>
<td>
<p>for F-tests for a generalized linear model, base the
dispersion estimate on the Pearson residuals (<code>"pearson"</code>, the default); use the
dispersion estimate in the model object (<code>"dispersion"</code>); or base the dispersion estimate on
the residual deviance (<code>"deviance"</code>). For binomial or Poisson GLMs, where the dispersion
is fixed to 1, setting <code>error.estimate="dispersion"</code> is changed to <code>"pearson"</code>,
with a warning.</p>
</td></tr>
<tr><td><code id="Anova_+3A_white.adjust">white.adjust</code></td>
<td>
<p>if not <code>FALSE</code>, the default,
tests use a heteroscedasticity-corrected coefficient
covariance matrix; the various values of the argument specify different corrections.
See the documentation for <code><a href="car.html#topic+hccm">hccm</a></code> for details. If <code>white.adjust=TRUE</code>
then the <code>"hc3"</code> correction is selected.</p>
</td></tr>
<tr><td><code id="Anova_+3A_sspe">SSPE</code></td>
<td>
<p>For <code>Anova</code> for a multivariate linear model, the
error sum-of-squares-and-products matrix; if missing, will be computed
from the residuals of the model; for the <code>print</code> method for the <code>summary</code> of
an <code>Anova</code> of a multivariate linear model,
whether or not to print the error SSP matrix (defaults to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="Anova_+3A_ssp">SSP</code></td>
<td>
<p>if <code>TRUE</code> (the default), print the sum-of-squares and
cross-products matrix for the hypothesis and the response-transformation matrix.</p>
</td></tr>
<tr><td><code id="Anova_+3A_error.df">error.df</code></td>
<td>
<p>The degrees of freedom for error; if <code>error.df</code> missing for a multivariate linear model (object of class <code>"mlm"</code>), the error degrees of freedom will be taken from the model.
</p>
<p>For the <code>default</code> <code>Anova</code> method, if an F-test is requested and if <code>error.df</code> is missing, the error degrees of freedom will be computed by applying the <code>df.residual</code> function to the model; if <code>df.residual</code> returns <code>NULL</code> or <code>NA</code>, then a chi-square test will be substituted for the F-test (with a message to that effect.</p>
</td></tr>
<tr><td><code id="Anova_+3A_idata">idata</code></td>
<td>
<p>an optional data frame giving a factor or factors defining the
intra-subject model for multivariate repeated-measures data. See
<em>Details</em> for an explanation of the intra-subject design and for
further explanation of the other arguments relating to intra-subject factors.</p>
</td></tr>
<tr><td><code id="Anova_+3A_idesign">idesign</code></td>
<td>
<p>a one-sided model formula using the &ldquo;data&rdquo; in <code>idata</code> and
specifying the intra-subject design.</p>
</td></tr>
<tr><td><code id="Anova_+3A_icontrasts">icontrasts</code></td>
<td>
<p>names of contrast-generating functions to be applied by default
to factors and ordered factors, respectively, in the within-subject
&ldquo;data&rdquo;; the contrasts must produce an intra-subject model
matrix in which different terms are orthogonal. The default is
<code>c("contr.sum", "contr.poly")</code>.</p>
</td></tr>
<tr><td><code id="Anova_+3A_imatrix">imatrix</code></td>
<td>
<p>as an alternative to specifying <code>idata</code>, <code>idesign</code>, and
(optionally) <code>icontrasts</code>, the model matrix for the within-subject design
can be given directly in the form of list of named elements. Each element gives
the columns of the within-subject model matrix for a term to be tested, and must
have as many rows as there are responses; the columns of the within-subject model
matrix for different terms must be mutually orthogonal.</p>
</td></tr>
<tr><td><code id="Anova_+3A_x">x</code>, <code id="Anova_+3A_object">object</code></td>
<td>
<p>object of class <code>"Anova.mlm"</code> to print or summarize.</p>
</td></tr>
<tr><td><code id="Anova_+3A_multivariate">multivariate</code>, <code id="Anova_+3A_univariate">univariate</code></td>
<td>
<p>compute and print multivariate and univariate tests for a repeated-measures
ANOVA or multivariate linear model; the default is <code>TRUE</code> for both for repeated measures and <code>TRUE</code>
for <code>multivariate</code> for a multivariate linear model.</p>
</td></tr>
<tr><td><code id="Anova_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>if given for a multivariate linear model when univariate tests are requested, the
univariate tests are corrected for simultaneous inference by term; if specified, should be one of the methods
recognized by <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> or <code>TRUE</code>, in which case the default (Holm) adjustment is used.</p>
</td></tr>
<tr><td><code id="Anova_+3A_digits">digits</code></td>
<td>
<p>minimum number of significant digits to print.</p>
</td></tr>
<tr><td><code id="Anova_+3A_style">style</code></td>
<td>
<p>for printing univariate tests if requested for a multivariate linear model; one of <code>"wide"</code>,
the default, or <code>"long"</code>.</p>
</td></tr>
<tr><td><code id="Anova_+3A_by">by</code></td>
<td>
<p>if univariate tests are printed in <code>"long"</code> <code>style</code>, they can be ordered <code>by</code>
<code>"response"</code>, the default, or by <code>"term"</code>.</p>
</td></tr>
<tr><td><code id="Anova_+3A_row.names">row.names</code>, <code id="Anova_+3A_optional">optional</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="Anova_+3A_vcov.">vcov.</code></td>
<td>
<p>in the <code>default</code> method, an optional coefficient-covariance matrix or function
to compute a covariance matrix, computed by default by applying the generic <code>vcov</code> function to the model object.
A similar argument may be supplied to the <code>lm</code> method, and the default (<code>NULL</code>) is to ignore the argument;
if both <code>vcov.</code> and <code>white.adjust</code> are supplied to the <code>lm</code> method, the latter is used.</p>
</td></tr>
</table>
<p>In the <code>glm</code> method, <code>vcov.</code> is ignored unless <code>test="Wald"</code>; in the <code>mer</code> and <code>merMod</code> methods, <code>vcov.</code> is ignored if <code>test="F"</code>.
</p>
<table>
<tr><td><code id="Anova_+3A_...">...</code></td>
<td>
<p>do not use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The designations &quot;type-II&quot; and &quot;type-III&quot; are borrowed from SAS, but the
definitions used here do not correspond precisely to those employed by SAS.
Type-II tests are calculated according to the principle of marginality,
testing each term after all others, except ignoring the term's higher-order relatives;
so-called type-III tests violate marginality, testing
each term in the model after all of the others. This definition of Type-II tests
corresponds to the tests produced by SAS for analysis-of-variance models, where all of the predictors
are factors, but not more generally (i.e., when there are quantitative predictors).
Be very careful in formulating the model for type-III tests, or the hypotheses tested
will not make sense.
</p>
<p>As implemented here, type-II Wald tests are a generalization of the linear hypotheses used to generate
these tests in linear models.
</p>
<p>For tests for linear models, multivariate linear models, and Wald tests for generalized linear models,
Cox models, mixed-effects models, generalized linear models fit to survey data, and in the default case,
<code>Anova</code> finds the test statistics without refitting the model. The <code>svyglm</code> method simply
calls the <code>default</code> method and therefore can take the same arguments.
</p>
<p>The standard R <code>anova</code> function calculates sequential (&quot;type-I&quot;) tests.
These rarely test interesting hypotheses in unbalanced designs.
</p>
<p>A MANOVA for a multivariate linear model (i.e., an object of
class <code>"mlm"</code> or <code>"manova"</code>) can optionally include an
intra-subject repeated-measures design.
If the intra-subject design is absent (the default), the multivariate
tests concern all of  the response variables.
To specify a repeated-measures design, a data frame is provided defining the repeated-measures factor or
factors
via <code>idata</code>, with default contrasts given by the <code>icontrasts</code>
argument. An intra-subject model-matrix is generated from the formula
specified by the <code>idesign</code> argument; columns of the model matrix
corresponding to different terms in the intra-subject model must be orthogonal
(as is insured by the default contrasts). Note that the contrasts given in
<code>icontrasts</code> can be overridden by assigning specific contrasts to the
factors in <code>idata</code>. As an alternative, the within-subjects model matrix
can be specified directly via the <code>imatrix</code> argument.
<code>Manova</code> is essentially a synonym for <code>Anova</code>
for multivariate linear models.
</p>
<p>If univariate tests are requested for the <code>summary</code> of a multivariate linear model, the object returned
contains a <code>univaov</code> component of <code>"univaov"</code>; <code>print</code> and <code>as.data.frame</code> methods are
provided for the <code>"univaov"</code> class.
</p>
<p>For the default method to work, the model object must contain a standard
<code>terms</code> element, and must respond to the <code>vcov</code>, <code>coef</code>, and <code>model.matrix</code> functions.
If any of these requirements is missing, then it may be possible to supply it reasonably simply (e.g., by
writing a missing <code>vcov</code> method for the class of the model object).
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code>, or <code>"Anova.mlm"</code>, which usually is printed.
For objects of class <code>"Anova.mlm"</code>, there is also a <code>summary</code> method,
which provides much more detail than the <code>print</code> method about the MANOVA, including
traditional mixed-model univariate F-tests with Greenhouse-Geisser and Huynh-Feldt
corrections.
</p>


<h3>Warning</h3>

<p>Be careful of type-III tests: For a traditional multifactor ANOVA model with interactions, for example, these tests will normally only be sensible when using contrasts that, for different terms, are
orthogonal in the row-basis of the model, such as those produced by <code><a href="stats.html#topic+contr.sum">contr.sum</a></code>, <code><a href="stats.html#topic+contr.poly">contr.poly</a></code>, or <code><a href="stats.html#topic+contr.helmert">contr.helmert</a></code>, but <em>not</em> by the default
<code><a href="stats.html#topic+contr.treatment">contr.treatment</a></code>. In a model that contains factors, numeric covariates, and interactions, main-effect tests for factors will be for differences over the origin. In contrast (pun intended),
type-II tests are invariant with respect to (full-rank) contrast coding. If you don't understand this issue, then you probably shouldn't use <code>Anova</code> for type-III tests.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>; the code for the Mauchly test and Greenhouse-Geisser and Huynh-Feldt
corrections for non-spericity in repeated-measures ANOVA are adapted from the functions
<code>stats:::stats:::mauchly.test.SSD</code> and <code>stats:::sphericity</code> by R Core; <code>summary.Anova.mlm</code>
and <code>print.summary.Anova.mlm</code> incorporates code contributed by Gabriel Baud-Bovy.</p>


<h3>References</h3>

<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.
</p>
<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Hand, D. J., and Taylor, C. C. (1987)
<em>Multivariate Analysis of Variance and Repeated Measures: A Practical
Approach for Behavioural Scientists.</em> Chapman and Hall.
</p>
<p>O'Brien, R. G., and Kaiser, M. K. (1985)
MANOVA method for analyzing repeated measures designs: An extensive primer.
<em>Psychological Bulletin</em> <b>97</b>, 316&ndash;333.
</p>


<h3>See Also</h3>

 <p><code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code>, <code><a href="stats.html#topic+anova">anova</a></code>
<code><a href="stats.html#topic+anova.lm">anova.lm</a></code>, <code><a href="stats.html#topic+anova.glm">anova.glm</a></code>,
<code><a href="stats.html#topic+anova.mlm">anova.mlm</a></code>, <code><a href="survival.html#topic+anova.coxph">anova.coxph</a></code>, <code><a href="survey.html#topic+svyglm">svyglm</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Two-Way Anova

mod &lt;- lm(conformity ~ fcategory*partner.status, data=Moore,
  contrasts=list(fcategory=contr.sum, partner.status=contr.sum))
Anova(mod)
Anova(mod, type=3)  # note use of contr.sum in call to lm()

## One-Way MANOVA
## See ?Pottery for a description of the data set used in this example.

summary(Anova(lm(cbind(Al, Fe, Mg, Ca, Na) ~ Site, data=Pottery)))

## MANOVA for a randomized block design (example courtesy of Michael Friendly:
##  See ?Soils for description of the data set)

soils.mod &lt;- lm(cbind(pH,N,Dens,P,Ca,Mg,K,Na,Conduc) ~ Block + Contour*Depth,
    data=Soils)
Manova(soils.mod)
summary(Anova(soils.mod), univariate=TRUE, multivariate=FALSE,
    p.adjust.method=TRUE)

## a multivariate linear model for repeated-measures data
## See ?OBrienKaiser for a description of the data set used in this example.

phase &lt;- factor(rep(c("pretest", "posttest", "followup"), c(5, 5, 5)),
    levels=c("pretest", "posttest", "followup"))
hour &lt;- ordered(rep(1:5, 3))
idata &lt;- data.frame(phase, hour)
idata

mod.ok &lt;- lm(cbind(pre.1, pre.2, pre.3, pre.4, pre.5,
                     post.1, post.2, post.3, post.4, post.5,
                     fup.1, fup.2, fup.3, fup.4, fup.5) ~  treatment*gender,
                data=OBrienKaiser)
(av.ok &lt;- Anova(mod.ok, idata=idata, idesign=~phase*hour))

summary(av.ok, multivariate=FALSE)

## A "doubly multivariate" design with two  distinct repeated-measures variables
## (example courtesy of Michael Friendly)
## See ?WeightLoss for a description of the dataset.

imatrix &lt;- matrix(c(
	1,0,-1, 1, 0, 0,
	1,0, 0,-2, 0, 0,
	1,0, 1, 1, 0, 0,
	0,1, 0, 0,-1, 1,
	0,1, 0, 0, 0,-2,
	0,1, 0, 0, 1, 1), 6, 6, byrow=TRUE)
colnames(imatrix) &lt;- c("WL", "SE", "WL.L", "WL.Q", "SE.L", "SE.Q")
rownames(imatrix) &lt;- colnames(WeightLoss)[-1]
(imatrix &lt;- list(measure=imatrix[,1:2], month=imatrix[,3:6]))
contrasts(WeightLoss$group) &lt;- matrix(c(-2,1,1, 0,-1,1), ncol=2)
(wl.mod&lt;-lm(cbind(wl1, wl2, wl3, se1, se2, se3)~group, data=WeightLoss))
Anova(wl.mod, imatrix=imatrix, test="Roy")

## mixed-effects models examples:

## Not run:  # loads nlme package
	library(nlme)
	example(lme)
	Anova(fm2)

## End(Not run)

## Not run:  # loads lme4 package
	library(lme4)
	example(glmer)
	Anova(gm1)

## End(Not run)

</code></pre>

<hr>
<h2 id='avPlots'>Added-Variable Plots</h2><span id='topic+avPlots'></span><span id='topic+avPlots.default'></span><span id='topic+avp'></span><span id='topic+avPlot'></span><span id='topic+avPlot.lm'></span><span id='topic+avPlot.glm'></span><span id='topic+avPlot3d'></span><span id='topic+avPlot3d.lm'></span><span id='topic+avPlot3d.glm'></span>

<h3>Description</h3>

<p>These functions construct added-variable, also called 
partial-regression, plots for  linear and generalized linear
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avPlots(model, ...)

## Default S3 method:
avPlots(model, terms=~., intercept=FALSE, 
  layout=NULL, ask, main, ...)

avp(...)

avPlot(model, ...)

## S3 method for class 'lm'
avPlot(model, variable,
	id=TRUE, col = carPalette()[1], col.lines = carPalette()[2],
	xlab, ylab, pch = 1, lwd = 2, cex = par("cex"), pt.wts = FALSE,
	main=paste("Added-Variable Plot:", variable),
	grid=TRUE,
	ellipse=FALSE,
  marginal.scale=FALSE, ...)

## S3 method for class 'glm'
avPlot(model, variable, 
	id=TRUE,
	col = carPalette()[1], col.lines = carPalette()[2],
	xlab, ylab, pch = 1, lwd = 2, cex = par("cex"), pt.wts = FALSE,
	type=c("Wang", "Weisberg"), 
	main=paste("Added-Variable Plot:", variable), grid=TRUE,
	ellipse=FALSE, ...)
	
avPlot3d(model, coef1, coef2, id=TRUE, ...)

## S3 method for class 'lm'
avPlot3d(model, coef1, coef2, id=TRUE, fit="linear", ...)

## S3 method for class 'glm'
avPlot3d(model, coef1, coef2, id=TRUE, type=c("Wang", "Weisberg"), 
  fit="linear", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="avPlots_+3A_model">model</code></td>
<td>
<p>model object produced by <code>lm</code> or <code>glm</code>.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_terms">terms</code></td>
<td>
<p> A one-sided formula that specifies a subset of the predictors. 
One added-variable plot is drawn for each term.   For example, the
specification <code>terms = ~.-X3</code> would plot against all terms
except for <code>X3</code>. If this argument is a quoted name of one of the terms, the 
added-variable plot is drawn for that term only.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_coef1">coef1</code>, <code id="avPlots_+3A_coef2">coef2</code></td>
<td>
<p>the quoted names of the two coefficients for a 3D added variable plot.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_intercept">intercept</code></td>
<td>
<p>Include the intercept in the plots; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_variable">variable</code></td>
<td>
<p>A quoted string giving the name of a regressor in the model matrix for the horizontal
axis.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_layout">layout</code></td>
<td>
<p>If set to a value like <code>c(1, 1)</code> or <code>c(4, 3)</code>, the layout
of the graph will have this many rows and columns.  If not set, the program
will select an appropriate layout.  If the number of graphs exceed nine, you 
must select the layout yourself, or you will get a maximum of nine per page.
If <code>layout=NA</code>, the function does not set the layout and the user can
use the <code>par</code> function to control the layout, for example to have 
plots from two models in the same graphics window.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_main">main</code></td>
<td>
<p>The title of the plot; if missing, one will be supplied.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, ask the user before drawing the next plot; if <code>FALSE</code> don't ask.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code>, no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code>, the default, is equivalent to 
<code>list(method=list(abs(residuals(model, type="pearson")), "x"), n=2, cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the largest residuals and the 2 points with 
the most extreme horizontal values (i.e., largest partial leverage).
For <code>avPlot3d</code>, point identication is through <code><a href="car.html#topic+Identify3d">Identify3d</a></code>.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_col">col</code></td>
<td>
<p>color for points; the default is the <em>second</em> entry
in the current <span class="pkg">car</span> palette (see <code><a href="car.html#topic+carPalette">carPalette</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="avPlots_+3A_col.lines">col.lines</code></td>
<td>
<p>color for the fitted line.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_pch">pch</code></td>
<td>
<p>plotting character for points; default is <code>1</code> 
(a circle, see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="avPlots_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>2</code> (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="avPlots_+3A_cex">cex</code></td>
<td>
<p>size of plotted points; default is taken from <code>par("cex")</code>.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_pt.wts">pt.wts</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), for a weighted
least squares fit or a generalized linear model, the areas of plotted points
are made proportional to the weights, with the average size taken from the
<code>cex</code> argument.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label.  If omitted a label will be constructed.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label.  If omitted a label will be constructed.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_type">type</code></td>
<td>
<p>if <code>"Wang"</code> use the method of Wang (1985);
if <code>"Weisberg"</code> use the method in the Arc software associated with
Cook and Weisberg (1999).</p>
</td></tr>
<tr><td><code id="avPlots_+3A_grid">grid</code></td>
<td>
<p>If <code>TRUE</code>, the default, a light-gray background grid is put on the graph.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_ellipse">ellipse</code></td>
<td>
<p>controls plotting data-concentration ellipses. If <code>FALSE</code> (the default), no ellipses are plotted.
Can be a list of named values giving <code>levels</code>, a vector of one or more bivariate-normal probability-contour levels at which to
plot the ellipses; and <code>robust</code>, a logical value determing whether to use the <code><a href="MASS.html#topic+cov.trob">cov.trob</a></code> function in the <span class="pkg">MASS</span> package
to calculate the center and covariance matrix for the data ellipses. <code>TRUE</code> is equivalent to <code>list(levels=c(.5, .95), robust=TRUE)</code>.</p>
</td></tr>  
<tr><td><code id="avPlots_+3A_marginal.scale">marginal.scale</code></td>
<td>
<p>Consider an added-variable plot of Y versus X given Z.  If this argument is <code>FALSE</code> then the limits on the horizontal axis are determined by the range of the residuals from the regression of X on Z and the limits on the vertical axis are determined by the range of the residuals from the regressnio of Y on Z.  If the argument is <code>TRUE</code>, then the limits on the horizontal axis are determined by the range of X minus it mean, and on the vertical axis by the range of Y minus its means; adjustment is made if necessary to include outliers.  This scaling allows visualization of the correlations between Y and Z and between X and Z.  For example, if the X and Z are highly correlated, then the points will be concentrated on the middle of the plot.</p>
</td></tr> 
<tr><td><code id="avPlots_+3A_fit">fit</code></td>
<td>
<p>one or both of <code>"linear"</code> (linear least-squares, the default) and <code>"robust"</code> (robust regression) surfaces to be fit to the 3D added-variable plot; see <code><a href="car.html#topic+scatter3d">scatter3d</a></code> for details.</p>
</td></tr>
<tr><td><code id="avPlots_+3A_...">...</code></td>
<td>
<p><code>avPlots</code> passes these arguments to <code>avPlot</code> and <code>avPlot</code> passes them to <code>plot</code>; for <code>avPlot3d</code>, 
additional optional arguments to be passed to <code><a href="car.html#topic+scatter3d">scatter3d</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions intended for direct use are <code>avPlots</code> (for which <code>avp</code>
is an abbreviation) and <code>avPlot3d</code>. 
</p>


<h3>Value</h3>

<p>These functions are used for their side effect id producing
plots, but also invisibly return the coordinates of the plotted points.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, Sanford Weisberg <a href="mailto:sandy@umn.edu">sandy@umn.edu</a></p>


<h3>References</h3>

<p>Cook, R. D. and Weisberg, S. (1999)
<em>Applied Regression, Including Computing and Graphics.</em> Wiley.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Wang, P C. (1985)
Adding a variable in generalized linear models.
<em>Technometrics</em> <b>27</b>, 273&ndash;276.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+residualPlots">residualPlots</a></code>, <code><a href="car.html#topic+crPlots">crPlots</a></code>, <code><a href="car.html#topic+ceresPlots">ceresPlots</a></code>, <code>link{dataEllipse}</code>, <code><a href="car.html#topic+showLabels">showLabels</a></code>, <code><a href="car.html#topic+dataEllipse">dataEllipse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>avPlots(lm(prestige ~ income + education + type, data=Duncan))

avPlots(glm(partic != "not.work" ~ hincome + children, 
  data=Womenlf, family=binomial), id=FALSE, pt.wts=TRUE)
  
m1 &lt;- lm(partic ~ tfr + menwage + womwage + debt + parttime, Bfox)
par(mfrow=c(1,3))
# marginal plot, ignoring other predictors:
with(Bfox, dataEllipse(womwage, partic, levels=0.5)) 
abline(lm(partic ~ womwage, Bfox), col="red", lwd=2)
# AV plot, adjusting for others:
avPlots(m1, ~ womwage, ellipse=list(levels=0.5)) 
# AV plot, adjusting and scaling as in marginal plot
avPlots(m1, ~ womwage, marginal.scale=TRUE, ellipse=list(levels=0.5)) 

# 3D AV plot, requires the rgl package
if (interactive() &amp;&amp; require("rgl")){
avPlot3d(lm(prestige ~ income + education + type, data=Duncan), 
  "income", "education")
}
</code></pre>

<hr>
<h2 id='bcPower'>Box-Cox, Box-Cox with Negatives Allowed, Yeo-Johnson and Basic Power Transformations</h2><span id='topic+bcPower'></span><span id='topic+bcnPower'></span><span id='topic+bcnPowerInverse'></span><span id='topic+yjPower'></span><span id='topic+basicPower'></span>

<h3>Description</h3>

<p>Transform the elements of a vector or columns of a matrix using, the Box-Cox, Box-Cox with negatives allowed,
Yeo-Johnson, or simple power transformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcPower(U, lambda, jacobian.adjusted=FALSE, gamma=NULL)

bcnPower(U, lambda, jacobian.adjusted = FALSE, gamma)

bcnPowerInverse(z, lambda, gamma)

yjPower(U, lambda, jacobian.adjusted = FALSE)

basicPower(U,lambda, gamma=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcPower_+3A_u">U</code></td>
<td>
<p>A vector, matrix or data.frame of values to be transformed</p>
</td></tr>
<tr><td><code id="bcPower_+3A_lambda">lambda</code></td>
<td>
<p>Power transformation parameter with one element for each 
column of U, usuallly in the range from <code class="reqn">-2</code> to <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="bcPower_+3A_jacobian.adjusted">jacobian.adjusted</code></td>
<td>
<p>If <code>TRUE</code>, the transformation is normalized to have
Jacobian equal to one.  The default <code>FALSE</code> is almost always appropriate.</p>
</td></tr>
<tr><td><code id="bcPower_+3A_gamma">gamma</code></td>
<td>
<p>For bcPower or basicPower, the transformation is of U + gamma, where gamma is a positive number called a start that must be large enough so that U + gamma is strictly positive.  For the bcnPower, Box-cox power with negatives allowed, see the details below.</p>
</td></tr>
<tr><td><code id="bcPower_+3A_z">z</code></td>
<td>
<p>a numeric vector the result of a call to <code>bcnPower</code> with <code>jacobian.adjusted=FALSE</code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>The Box-Cox 
family of <em>scaled power transformations</em>
equals <code class="reqn">(x^{\lambda}-1)/\lambda</code>
for <code class="reqn">\lambda \neq 0</code>, and
<code class="reqn">\log(x)</code> if <code class="reqn">\lambda =0</code>.  The <code>bcPower</code> 
function computes the scaled power transformation of 
<code class="reqn">x = U + \gamma</code>, where <code class="reqn">\gamma</code> 
is set by the user so <code class="reqn">U+\gamma</code> is strictly positive for these
transformations to make sense.
</p>
<p>The Box-Cox family with negatives allowed was proposed by Hawkins and Weisberg (2017).  It is the Box-Cox power transformation of </p>
<p style="text-align: center;"><code class="reqn">z = .5  (U + \sqrt{U^2 + \gamma^2)})</code>
</p>
<p> where for this family <code class="reqn">\gamma</code> is either user selected or is estimated. <code>gamma</code> must be positive if <code class="reqn">U</code> includes negative values and non-negative otherwise, ensuring that <code class="reqn">z</code> is always positive.  The bcnPower transformations behave similarly to the bcPower transformations, and introduce less bias than is introduced by setting the parameter <code class="reqn">\gamma</code> to be non-zero in the Box-Cox family.
</p>
<p>The function <code>bcnPowerInverse</code> computes the inverse of the <code>bcnPower</code> function, so <code>U = bcnPowerInverse(bcnPower(U, lambda=lam, jacobian.adjusted=FALSE, gamma=gam), lambda=lam, gamma=gam)</code> is true for any permitted value of <code>gam</code> and <code>lam</code>.
</p>
<p>If <code>family="yeo.johnson"</code> then the Yeo-Johnson transformations are used.
This is the Box-Cox transformation of <code class="reqn">U+1</code> for nonnegative values,
and of <code class="reqn">|U|+1</code> with parameter <code class="reqn">2-\lambda</code> for <code class="reqn">U</code> negative.
</p>
<p>The basic power transformation returns <code class="reqn">U^{\lambda}</code> if 
<code class="reqn">\lambda</code> is not 0, and <code class="reqn">\log(\lambda)</code> 
otherwise for <code class="reqn">U</code> strictly positive.
</p>
<p>If <code>jacobian.adjusted</code> is <code>TRUE</code>, then the scaled transformations 
are divided by the
Jacobian, which is a function of the geometric mean of <code class="reqn">U</code> for <code>skewPower</code> and <code>yjPower</code> and of <code class="reqn">U + gamma</code> for <code>bcPower</code>.  With this adjustment, the Jacobian of the transformation is always equal to 1.  Jacobian adjustment facilitates computing the Box-Cox estimates of the transformation parameters.
</p>
<p>Missing values are permitted, and return <code>NA</code> where ever <code>U</code> is equal to <code>NA</code>.
</p>


<h3>Value</h3>

<p>Returns a vector or matrix of transformed values.
</p>


<h3>Author(s)</h3>

<p> Sanford Weisberg, &lt;sandy@umn.edu&gt; </p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Hawkins, D. and Weisberg, S. (2017)
Combining the Box-Cox Power and Generalized Log Transformations to Accomodate Nonpositive  Responses In Linear and Mixed-Effects Linear Models <em>South African Statistics Journal</em>, 51, 317-328.
</p>
<p>Weisberg, S. (2014)  <em>Applied Linear Regression</em>, Fourth Edition, Wiley
Wiley, Chapter 7.
</p>
<p>Yeo, In-Kwon and Johnson, Richard (2000) A new family of power
transformations to improve normality or symmetry.  <em>Biometrika</em>, 87,
954-959.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+powerTransform">powerTransform</a></code>, <code><a href="car.html#topic+testTransform">testTransform</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>U &lt;- c(NA, (-3:3))
## Not run: bcPower(U, 0)  # produces an error as U has negative values
bcPower(U, 0, gamma=4)
bcPower(U, .5, jacobian.adjusted=TRUE, gamma=4)
bcnPower(U, 0, gamma=2)
basicPower(U, lambda = 0, gamma=4)
yjPower(U, 0)
V &lt;- matrix(1:10, ncol=2)
bcPower(V, c(0, 2))
basicPower(V, c(0,1))
</code></pre>

<hr>
<h2 id='Boot'>Bootstrapping for regression models </h2><span id='topic+Boot'></span><span id='topic+Boot.default'></span><span id='topic+Boot.lm'></span><span id='topic+Boot.glm'></span><span id='topic+Boot.nls'></span>

<h3>Description</h3>

<p>This function provides a simple front-end to the <code>boot</code> function in the
<span class="pkg">boot</span> package that is tailored to bootstrapping based on regression models.  Whereas <code>boot</code> is very general and therefore
has many arguments, the <code>Boot</code> function has very few arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Boot(object, f=coef, labels=names(f(object)), R=999,
  method=c("case", "residual"), ncores=1, ...)

## Default S3 method:
Boot(object, f=coef, labels=names(f(object)),
  R=999, method=c("case", "residual"), ncores=1,
  start = FALSE, ...)

## S3 method for class 'lm'
Boot(object, f=coef, labels=names(f(object)),
  R=999, method=c("case", "residual"), ncores=1, ...)

## S3 method for class 'glm'
Boot(object, f=coef, labels=names(f(object)),
  R=999, method=c("case", "residual"), ncores=1, ...)

## S3 method for class 'nls'
Boot(object, f=coef, labels=names(f(object)),
  R=999, method=c("case", "residual"), ncores=1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Boot_+3A_object">object</code></td>
<td>
<p>A regression object of class <code>"lm"</code>, <code>"glm"</code> or 
<code>"nls"</code>.  The function may work with other regression objects that support
the <code>update</code> method and have a <code>subset</code> argument.  See discussion of
the default method in the details below.</p>
</td></tr>
<tr><td><code id="Boot_+3A_f">f</code></td>
<td>
<p>A function whose one argument is the name of a regression object that will
be applied to the updated regression object to compute the statistics of 
interest.  The default is <code>coef</code>, to return regression coefficient 
estimates.  For example, <code>f = function(obj) coef(obj)[1]/coef(obj)[2]</code> will
bootstrap the ratio of the first and second coefficient estimates.</p>
</td></tr>
<tr><td><code id="Boot_+3A_labels">labels</code></td>
<td>
<p>Provides labels for the statistics computed by <code>f</code>.  Default
labels are obtained from a call to <code>f</code>, or generic labels if <code>f</code> 
does not return names.</p>
</td></tr>
<tr><td><code id="Boot_+3A_r">R</code></td>
<td>
<p>Number of bootstrap samples.  The number of bootstrap samples actually
computed may be smaller than this value if either the fitting method is 
iterative and fails to converge for some boothstrap samples, or if the rank of a
fitted model is different in a bootstrap replication than in the original data.</p>
</td></tr>
<tr><td><code id="Boot_+3A_method">method</code></td>
<td>
<p>The bootstrap method, either &ldquo;case&rdquo; for resampling
cases or &ldquo;residuals&rdquo; for a residual bootstrap.  See the details
below. The residual bootstrap is available only for <code>lm</code> and <code>nls</code>
objects and will return an error for <code>glm</code> objects.</p>
</td></tr>
<tr><td><code id="Boot_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code>boot</code> function, see 
<code><a href="boot.html#topic+boot">boot</a></code>.</p>
</td></tr>
<tr><td><code id="Boot_+3A_start">start</code></td>
<td>
<p>Should the estimates returned by <code>f</code> be passed as starting
values for each bootstrap iteration? Alternatively, <code>start</code> can be a
numeric vector of starting values.  The default is to use
the estimates from the last bootstrap iteration as starting values
for the next iteration.</p>
</td></tr>
<tr><td><code id="Boot_+3A_ncores">ncores</code></td>
<td>
<p>A numeric argument that specifies the number of cores for parallel
processing for unix systems.  If less than or equal to 1, no parallel processing wiill be used. Note in a Windows platform will produce a warning and set this argument to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Boot</code> uses a
regression object and the choice of <code>method</code>, and creates a function that is
passed as the <code>statistic</code> argument to the <code>boot</code> function in the <span class="pkg">boot</span> package.  The argument <code>R</code> is also passed to <code>boot</code>.  If <code>ncores</code> is greater than 1, then the <code>parallel</code> and <code>ncpus</code> arguments to <code>boot</code> are set appropriately to use multiple codes, if available, on your computer. All other arguments to <code>boot</code> are kept at their default values unless you pass values for them.
</p>
<p>The methods available for <code>lm</code> and <code>nls</code> objects are &ldquo;case&rdquo; and
&ldquo;residual&rdquo;.  The case bootstrap resamples from the joint distribution
of the terms in the model and the response.  The residual bootstrap fixes the
fitted values from the original data, and creates bootstraps by adding a
bootstrap sample of the residuals to the fitted values to get a bootstrap
response.  It is an implementation of Algorithm 6.3, page 271, of
Davison and Hinkley (1997).  For <code>nls</code> objects ordinary residuals are used
in the resampling rather than the standardized residuals used in the <code>lm</code>
method.  The residual bootstrap for
generalized linear models has several competing approaches, but none are
without problems.  If you want to do a residual bootstrap for a glm, you
will need to write your own call to <code>boot</code>.
</p>
<p>For the default object to work with other types of regression models, the model must have methods for the the following generic functions:  <code>residuals(object, type="pearson")</code> must return Pearson residuals; <code>fitted(object)</code> must return fitted values; <code>hatvalues(object)</code> should return the leverages, or perhaps the value 1 which will effectively ignore setting the hatvalues.  In addition, the <code>data</code> argument should contain no missing values among the columns actually used in fitting the model, as the resampling may incorrectly attempt to include cases with missing values.  For <code>lm</code>, <code>glm</code> and <code>nls</code>, missing values cause the return of an error message.
</p>
<p>An attempt to fit using a bootstrap sample may fail.  In a <code>lm</code> or
<code>glm</code> fit, the bootstrap sample could have a different rank from the original
fit.  In an <code>nls</code> fit, convergence may not be obtained for some bootstraps.
In either case, <code>NA</code> are returned for the value of the function <code>f</code>.
The summary methods handle the <code>NA</code>s appropriately.
</p>
<p>Fox and Weisberg (2017) cited below discusses this function and provides more examples.
</p>


<h3>Value</h3>

<p>See <code><a href="boot.html#topic+boot">boot</a></code> for the returned value of the structure returned by this function. 
</p>


<h3>Warning</h3>

<p>C=A call like <code>car::Boot(object, method="residual")</code> will fail for the residual method if not preceded by <code>library(car)</code>.  If <code>method="case"</code> the <code>library(car)</code> command is not required.
</p>


<h3>Author(s)</h3>

<p> Sanford Weisberg, <a href="mailto:sandy@umn.edu">sandy@umn.edu</a>.  Achim Zeileis added multicore support, and also fixed the default method to work for many more regression models.</p>


<h3>References</h3>

<p>Davison, A, and Hinkley, D.  (1997)  <em>Bootstrap Methods and their
Applications</em>.  Oxford:  Oxford University Press.
</p>
<p>Fox, J. and Weisberg, S. (2019) <em>Companion to Applied Regression</em>, Third Edition. Thousand Oaks:  Sage.
</p>
<p>Fox, J. and Weisberg, S. (2019) <em>Bootstrapping Regression Models in R</em>,
<a href="https://socialsciences.mcmaster.ca/jfox/Books/Companion/appendices/Appendix-Bootstrapping.pdf">https://socialsciences.mcmaster.ca/jfox/Books/Companion/appendices/Appendix-Bootstrapping.pdf</a>.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley
Wiley, Chapters 4 and 11.</p>


<h3>See Also</h3>

<p>Functions that work with
<code>boot</code> objects from the <span class="pkg">boot</span> package are
<code><a href="boot.html#topic+boot.array">boot.array</a></code>,
<code><a href="boot.html#topic+boot.ci">boot.ci</a></code>,
<code><a href="boot.html#topic+plot.boot">plot.boot</a></code> and
<code><a href="boot.html#topic+empinf">empinf</a></code>.  Additional
functions in the <span class="pkg">car</span> package are
<code><a href="car.html#topic+summary.boot">summary.boot</a></code>,
<code><a href="car.html#topic+confint.boot">confint.boot</a></code>, and
<code><a href="car.html#topic+hist.boot">hist.boot</a></code>.   
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lm(Fertility ~ ., swiss)
betahat.boot &lt;- Boot(m1, R=199) # 199 bootstrap samples--too small to be useful
summary(betahat.boot)  # default summary
confint(betahat.boot)
hist(betahat.boot)
# Bootstrap for the estimated residual standard deviation:
sigmahat.boot &lt;- Boot(m1, R=199, f=sigmaHat, labels="sigmaHat")
summary(sigmahat.boot)
confint(sigmahat.boot)
</code></pre>

<hr>
<h2 id='boxCox'>
Graph the profile log-likelihood for Box-Cox transformations in 1D, or in 2D with the bcnPower family.
</h2><span id='topic+boxCox'></span><span id='topic+boxCox2d'></span><span id='topic+boxCox.lm'></span><span id='topic+boxCox.default'></span><span id='topic+boxCox.formula'></span><span id='topic+boxCox.bcnPowerTransform'></span>

<h3>Description</h3>

<p>Computes and optionally plots profile log-likelihoods for the parameter of the
Box-Cox power family, the Yeo-Johnson power family, or for either of the parameters in a bcnPower family.   This is a slight generalization of the
<code>boxcox</code> function in the <span class="pkg">MASS</span> package that allows for families of 
transformations other than the Box-Cox power family.  the <code>boxCox2d</code> function
produces a  contour
plot of the two-dimensional likelihood profile for the bcnPower family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxCox(object, ...)

## Default S3 method:
boxCox(object,
        lambda = seq(-2, 2, 1/10), plotit = TRUE,
        interp = plotit, eps = 1/50,
        xlab=NULL, ylab=NULL, main= "Profile Log-likelihood",
        family="bcPower",
        param=c("lambda", "gamma"), gamma=NULL,
        grid=TRUE, ...)

## S3 method for class 'formula'
boxCox(object, lambda = seq(-2, 2, 1/10), plotit = TRUE, family = "bcPower",
    param = c("lambda", "gamma"), gamma = NULL, grid = TRUE,
    ...)

## S3 method for class 'lm'
boxCox(object, lambda = seq(-2, 2, 1/10), plotit = TRUE, ...)

boxCox2d(x, ksds = 4, levels = c(0.5, 0.95, 0.99, 0.999),
                 main = "bcnPower Log-likelihood", grid=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxCox_+3A_object">object</code></td>
<td>

<p>a formula or fitted model object of class <code>lm</code> or <code>aov</code>.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_lambda">lambda</code></td>
<td>

<p>vector of values of <code class="reqn">\lambda</code>, with default (-2, 2) in steps of 0.1, where the profile
log-likelihood will be evaluated.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_plotit">plotit</code></td>
<td>

<p>logical which controls whether the result should be plotted; default <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_interp">interp</code></td>
<td>

<p>logical which controls whether spline interpolation is used. Default to
<code>TRUE</code> if plotting with lambda of length less than 100.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_eps">eps</code></td>
<td>

<p>Tolerance for lambda = 0; defaults to 0.02.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_xlab">xlab</code></td>
<td>

<p>defaults to <code>"lambda"</code> or <code>"gamma"</code>.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_ylab">ylab</code></td>
<td>

<p>defaults to <code>"log-Likelihood"</code> or for bcnPower family to the appropriate label.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_family">family</code></td>
<td>

<p>Defaults to <code>"bcPower"</code> for the Box-Cox power family of
transformations.  If set to <code>"yjPower"</code> the Yeo-Johnson family, which
permits negative responses, is used.  If set to <code>bcnPower</code> the function gives the profile
log-likelihood for the parameter selected via <code>param</code>.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_param">param</code></td>
<td>
<p>Relevant only to <code>family="bcnPower"</code>, produces a profile log-likelihood for the parameter selected, maximizing over the remaining parameter.</p>
</td></tr>
<tr><td><code id="boxCox_+3A_gamma">gamma</code></td>
<td>

<p>For use when the <code>family="bcnPower", param="gamma"</code>.  If this is a vector of positive values, then the profile log-likelihood for the location (or start) parameter in the  <code>bcnPower</code> family is evaluated at these values of gamma.  If gamma is <code>NULL</code>, then evaulation is done at 100 equally spaced points between <code>min(.01, gmax - 3*sd)</code> and <code>gmax + 3*sd</code>, where <code>gmax</code> is the maximimum likelihood estimate of gamma, and <code>sd</code> is the sd of the response.  See <code><a href="car.html#topic+bcnPower">bcnPower</a></code> for the definition of <code>gamma</code>.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_...">...</code></td>
<td>

<p>additional arguments passed to <code>plot</code>, or to <code>contour</code> with <code>boxCox2d</code>.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_x">x</code></td>
<td>

<p>An object created by a call to <code><a href="car.html#topic+powerTransform">powerTransform</a></code> using <code>family="bcnPower"</code>.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_ksds">ksds</code></td>
<td>

<p>Contour plotting of the log-likelihood surface will cover plus of minus <code>ksds</code> standard deviations on each axis.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_levels">levels</code></td>
<td>

<p>Contours will be drawn at the values of levels.  For example, <code>levels=c(.5, .99)</code> would display two contours, at the 50% level and at the 99% level.
</p>
</td></tr>
<tr><td><code id="boxCox_+3A_main">main</code></td>
<td>

<p>Title for the contour plot or the profile log-likelihood plot
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>boxCox</code> function is an elaboration of the <code><a href="MASS.html#topic+boxcox">boxcox</a></code> function in the
<span class="pkg">MASS</span> package.  The first 7 arguments are the same as in <code>boxcox</code>, and if the argument <code>family="bcPower"</code> is used, the result is essentially identical to the function in <span class="pkg">MASS</span>.  Two additional families are the <code>yjPower</code> and <code>bcnPower</code> families that allow a few values of the response to be non-positive.
The bcnPower family has two parameters: a power <code class="reqn">\lambda</code> and a start or location parameter <code class="reqn">\gamma</code>, and the <code>boxCox</code> function can be used to obtain a profile log-likelihood for either parameter with <code class="reqn">\lambda</code> as the default. Alternatively, the <code>boxCox2d</code> function can be used to get a contour plot of the profile log-likelihood.
</p>


<h3>Value</h3>

<p>Both functions ae designed for their side effects of drawing a graph.  The <code>boxCox</code> function returns a list of the lambda (or possibly, gamma) vector and the computed profile log-likelihood vector,
invisibly if the result is plotted.  If <code>plotit=TRUE</code> plots log-likelihood vs
lambda and indicates a 95% confidence interval about the maximum observed value of
lambda. If <code>interp=TRUE</code>, spline interpolation is used to give a smoother plot.
</p>


<h3>Author(s)</h3>

<p> Sanford Weisberg, &lt;sandy@umn.edu&gt; </p>


<h3>References</h3>

<p>Box, G. E. P. and Cox, D. R. (1964) An analysis of transformations.
<em>Journal
of the Royal Statisistical Society, Series B</em>. 26 211-46.
</p>
<p>Cook, R. D. and Weisberg, S. (1999)  <em>Applied Regression Including
Computing
and Graphics</em>.  Wiley.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.
</p>
<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Hawkins, D. and Weisberg, S. (2017)
Combining the Box-Cox Power and Generalized Log Transformations to Accomodate Nonpositive  Responses In Linear and Mixed-Effects Linear Models <em>South African Statistics Journal</em>, 51, 317-328.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley.
</p>
<p>Yeo, I. and Johnson, R. (2000)  A new family of
power transformations to improve normality or symmetry.
<em>Biometrika</em>, 87, 954-959.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+boxcox">boxcox</a></code>, <code><a href="car.html#topic+yjPower">yjPower</a></code>, <code><a href="car.html#topic+bcPower">bcPower</a></code>, <code><a href="car.html#topic+bcnPower">bcnPower</a></code>,
<code><a href="car.html#topic+powerTransform">powerTransform</a></code>, <code><a href="graphics.html#topic+contour">contour</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  with(trees, boxCox(Volume ~ log(Height) + log(Girth), data = trees,
         lambda = seq(-0.25, 0.25, length = 10)))

  data("quine", package = "MASS")
  with(quine, boxCox(Days ~ Eth*Sex*Age*Lrn, 
         lambda = seq(-0.05, 0.45, len = 20), family="yjPower"))
</code></pre>

<hr>
<h2 id='boxCoxVariable'>Constructed Variable for Box-Cox Transformation</h2><span id='topic+boxCoxVariable'></span>

<h3>Description</h3>

<p>Computes a constructed variable for the Box-Cox transformation of the
response variable in a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxCoxVariable(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxCoxVariable_+3A_y">y</code></td>
<td>
<p>response variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructed variable is defined as <code class="reqn">y[\log(y/\widetilde{y}) - 1]</code>, where 
<code class="reqn">\widetilde{y}</code> is the geometric mean of <code>y</code>. 
</p>
<p>The constructed variable is meant to be
added to the right-hand-side of the linear model. The t-test for the
coefficient of the constructed variable is an approximate score test for whether a
transformation is required. 
</p>
<p>If <code class="reqn">b</code> is the coefficient of the constructed variable,
then an estimate of the normalizing power transformation based on the score statistic
is <code class="reqn">1 - b</code>. An added-variable plot for the constructed
variable shows leverage and influence on the decision to transform <code>y</code>. 
</p>


<h3>Value</h3>

<p>a numeric vector of the same length as <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Atkinson, A. C. (1985)
<em>Plots, Transformations, and Regression</em>. Oxford.
</p>
<p>Box, G. E. P. and Cox, D. R. (1964)
An analysis of transformations.
<em>JRSS B</em> <b>26</b> 211&ndash;246.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+boxcox">boxcox</a></code>, <code><a href="car.html#topic+powerTransform">powerTransform</a></code>, <code><a href="car.html#topic+bcPower">bcPower</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(interlocks + 1 ~ assets, data=Ornstein)
mod.aux &lt;- update(mod, . ~ . + boxCoxVariable(interlocks + 1))
summary(mod.aux)
# avPlots(mod.aux, "boxCoxVariable(interlocks + 1)")
</code></pre>

<hr>
<h2 id='Boxplot'>
Boxplots With Point Identification
</h2><span id='topic+Boxplot'></span><span id='topic+Boxplot.default'></span><span id='topic+Boxplot.formula'></span><span id='topic+Boxplot.list'></span><span id='topic+Boxplot.data.frame'></span><span id='topic+Boxplot.matrix'></span>

<h3>Description</h3>

<p><code>Boxplot</code> is a wrapper for the standard <span class="rlang"><b>R</b></span> <code><a href="graphics.html#topic+boxplot">boxplot</a></code> function, providing point identification, 
axis labels, and a formula interface for boxplots without a grouping variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Boxplot(y, ...)

## Default S3 method:
Boxplot(y, g, id=TRUE, xlab, ylab, ...)

## S3 method for class 'formula'
Boxplot(formula, data=NULL, subset, na.action=NULL, 
    id=TRUE, xlab, ylab, ...)

## S3 method for class 'list'
Boxplot(y, xlab="", ylab="", ...)

## S3 method for class 'data.frame'
Boxplot(y, id=TRUE, ...)

## S3 method for class 'matrix'
Boxplot(y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Boxplot_+3A_y">y</code></td>
<td>
<p>a numeric variable for which the boxplot is to be constructed; a list of numeric
variables, each element of which will be treated as a group; a numeric data frame or a
numeric matrix, each of whose columns will be treated as a group.</p>
</td></tr>
<tr><td><code id="Boxplot_+3A_g">g</code></td>
<td>
<p>a grouping variable, usually a factor, for constructing parallel boxplots.</p>
</td></tr>
<tr><td><code id="Boxplot_+3A_id">id</code></td>
<td>
<p>a list of named elements giving one or more specifications for labels of individual points (&quot;outliers&quot;):
<code>n</code>, the maximum number of points to label (default 10); <code>location</code>, <code>"lr"</code> (left or right) of points or 
<code>"avoid"</code> to try to avoid overplotting; <code>method</code>, one of <code>"y"</code> (automatic, the default), <code>"identify"</code> (interactive), or <code>"none"</code>; <code>col</code> for labels (default is the first color in <code>carPalette()</code> ); and <code>cex</code> size of labels (default is <code>1</code>).
Can be <code>FALSE</code> to suppress point identification or <code>TRUE</code> (the default) to use all defaults. This is similar to how <code><a href="car.html#topic+showLabels">showLabels</a></code> handles point labels
for other functions in the <span class="pkg">car</span> package, except that the usual default is <code>id=FALSE</code>.</p>
</td></tr>
<tr><td><code id="Boxplot_+3A_xlab">xlab</code>, <code id="Boxplot_+3A_ylab">ylab</code></td>
<td>
<p>text labels for the horizontal and vertical axes; if missing, <code>Boxplot</code> will use the
variable names, or, in the case of a list, data frame, or matrix, empty labels.</p>
</td></tr>
<tr><td><code id="Boxplot_+3A_formula">formula</code></td>
<td>
<p>a &lsquo;model&rsquo; formula, of the form <code>~ y</code> to produce a boxplot for the variable <code>y</code>, or
of the form <code>y ~ g</code>, <code>y ~ g1*g2*...</code>, or <code>y ~ g1 + g2 + ...</code> to 
produce parallel boxplots for <code>y</code> within levels of the grouping variable(s)
<code>g</code>, etc., usually factors.</p>
</td></tr>
<tr><td><code id="Boxplot_+3A_data">data</code>, <code id="Boxplot_+3A_subset">subset</code>, <code id="Boxplot_+3A_na.action">na.action</code></td>
<td>
<p>as for statistical modeling functions (see, e.g., <code><a href="stats.html#topic+lm">lm</a></code>).</p>
</td></tr>
<tr><td><code id="Boxplot_+3A_...">...</code></td>
<td>
<p>further arguments, such as <code>at</code>, to be passed to <code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, with a contribution from Steve Ellison 
to handle <code>at</code> argument (see <code><a href="graphics.html#topic+boxplot">boxplot</a></code>).</p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Boxplot(~income, data=Prestige, id=list(n=Inf)) # identify all outliers
Boxplot(income ~ type, data=Prestige)
Boxplot(income ~ type, data=Prestige, at=c(1, 3, 2))
Boxplot(k5 + k618 ~ lfp*wc, data=Mroz)
with(Prestige, Boxplot(income, id=list(labels=rownames(Prestige))))
with(Prestige, Boxplot(income, type, id=list(labels=rownames(Prestige))))
Boxplot(scale(Prestige[, 1:4]))
</code></pre>

<hr>
<h2 id='boxTidwell'>Box-Tidwell Transformations</h2><span id='topic+boxTidwell'></span><span id='topic+boxTidwell.formula'></span><span id='topic+boxTidwell.default'></span><span id='topic+print.boxTidwell'></span>

<h3>Description</h3>

<p>Computes the Box-Tidwell power transformations of the predictors in a
linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxTidwell(y, ...)

## S3 method for class 'formula'
boxTidwell(formula, other.x=NULL, data=NULL, subset, 
  na.action=getOption("na.action"), verbose=FALSE, tol=0.001, 
  max.iter=25, ...)

## Default S3 method:
boxTidwell(y, x1, x2=NULL, max.iter=25, tol=0.001, 
  verbose=FALSE, ...)
  
## S3 method for class 'boxTidwell'
print(x, digits=getOption("digits") - 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxTidwell_+3A_formula">formula</code></td>
<td>
<p>two-sided formula, the right-hand-side of which gives the
predictors to be transformed.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_other.x">other.x</code></td>
<td>
<p>one-sided formula giving the predictors that are <em>not</em>
candidates for transformation, including (e.g.) factors.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables in the model. 
By default the variables are taken from the environment from which 
<code>boxTidwell</code> is called.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the data contain <code>NA</code>s. 
The default is set by the <code>na.action</code> setting of <code>options</code>.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> a record of iterations is printed; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_tol">tol</code></td>
<td>
<p>if the maximum relative change in coefficients is less than <code>tol</code> then
convergence is declared.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_y">y</code></td>
<td>
<p>response variable.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_x1">x1</code></td>
<td>
<p>matrix of predictors to transform.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_x2">x2</code></td>
<td>
<p>matrix of predictors that are <em>not</em> candidates for transformation.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_...">...</code></td>
<td>
<p>not for the user.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_x">x</code></td>
<td>
<p><code>boxTidwell</code> object.</p>
</td></tr>
<tr><td><code id="boxTidwell_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum-likelihood estimates of the transformation parameters are computed
by Box and Tidwell's (1962) method, which is usually more efficient than using
a general nonlinear least-squares routine for this problem. Score tests for the
transformations are also reported.
</p>


<h3>Value</h3>

<p>an object of class <code>boxTidwell</code>, which is normally just printed.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

 
<p>Box, G. E. P. and Tidwell, P. W. (1962)
Transformation of the independent variables.
<em>Technometrics</em> <b>4</b>, 531-550.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boxTidwell(prestige ~ income + education, ~ type + poly(women, 2), data=Prestige)
</code></pre>

<hr>
<h2 id='brief'>
Print Abbreviated Ouput
</h2><span id='topic+brief'></span><span id='topic+brief.data.frame'></span><span id='topic+brief.tbl'></span><span id='topic+brief.matrix'></span><span id='topic+brief.numeric'></span><span id='topic+brief.integer'></span><span id='topic+brief.character'></span><span id='topic+brief.factor'></span><span id='topic+brief.function'></span><span id='topic+brief.list'></span><span id='topic+brief.lm'></span><span id='topic+brief.glm'></span><span id='topic+brief.multinom'></span><span id='topic+brief.polr'></span><span id='topic+brief.default'></span>

<h3>Description</h3>

<p>Print data objects and statistical model summaries in abbreviated form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brief(object, ...)

## S3 method for class 'data.frame'
brief(object, rows = if (nr &lt;= 10) c(nr, 0) else c(3, 2),
    cols, head=FALSE, tail=FALSE, elided = TRUE,
    classes = inherits(object, "data.frame"), ...)
## S3 method for class 'tbl'
brief(object, ...)
## S3 method for class 'matrix'
brief(object, rows = if (nr &lt;= 10) c(nr, 0) else c(3, 2), ...)

## S3 method for class 'numeric'
brief(object, rows = c(2, 1), elided = TRUE, ...)
## S3 method for class 'integer'
brief(object, rows = c(2, 1), elided = TRUE, ...)
## S3 method for class 'character'
brief(object, rows = c(2, 1), elided = TRUE, ...)
## S3 method for class 'factor'
brief(object, rows=c(2, 1), elided=TRUE, ...)

## S3 method for class 'list'
brief(object, rows = c(2, 1), elided = TRUE, ...)

## S3 method for class 'function'
brief(object, rows = c(5, 3), elided = TRUE, ...)

## S3 method for class 'lm'
brief(object,  terms = ~ .,
    intercept=missing(terms), pvalues=FALSE,
    digits=3, horizontal=TRUE, vcov., ...)

## S3 method for class 'glm'
brief(object, terms = ~ .,
    intercept=missing(terms), pvalues=FALSE,
    digits=3, horizontal=TRUE, vcov., dispersion, exponentiate, ...)

## S3 method for class 'multinom'
brief(object, terms = ~ .,
    intercept=missing(terms), pvalues=FALSE,
    digits=3, horizontal=TRUE, exponentiate=TRUE, ...)

## S3 method for class 'polr'
brief(object, terms = ~ .,
    intercept, pvalues=FALSE,
    digits=3, horizontal=TRUE, exponentiate=TRUE, ...)

## Default S3 method:
brief(object, terms = ~ .,
    intercept=missing(terms), pvalues=FALSE,
    digits=3, horizontal=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brief_+3A_object">object</code></td>
<td>
<p>a data or model object to abbreviate.</p>
</td></tr>
<tr><td><code id="brief_+3A_rows">rows</code></td>
<td>
<p>for a matrix or data frame, a 2-element integer vector with the number of rows to print at
the beginning and end of the display; for a vector or factor,
the number of lines of output to show at the beginning
and end; for a list, the number of elements to show at the beginning and end; for a function, the number
of lines to show at the beginning and end.</p>
</td></tr>
<tr><td><code id="brief_+3A_cols">cols</code></td>
<td>
<p>for a matrix or data frame, a 2-element integer vector with the number of columns to print at
the beginning (i.e., left) and end (right) of the display.</p>
</td></tr>
<tr><td><code id="brief_+3A_head">head</code>, <code id="brief_+3A_tail">tail</code></td>
<td>
<p>alternatives to the <code>rows</code> argument; if <code>TRUE</code>, print the first or last 6
rows; can also be the number of the first or last few rows to print; only one of <code>heads</code> and
<code>tails</code> should be specified; ignored if <code>FALSE</code> (the default).</p>
</td></tr>
<tr><td><code id="brief_+3A_elided">elided</code></td>
<td>
<p>controls whether to report the number of elided elements, rows, or columns; default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="brief_+3A_classes">classes</code></td>
<td>
<p>show the class of each column of a data frame at the top of the column; the classes are
shown in single-character abbreviated form&mdash;e.g., <code>[f]</code> for a factor, <code>[i]</code> for an integer
variable, <code>[n]</code> for a numeric variable, <code>[c]</code> for a character variable.</p>
</td></tr>
<tr><td><code id="brief_+3A_terms">terms</code></td>
<td>
<p>a one-sided formula giving the terms to summarize; the default is <code>~ .</code>&mdash;i.e., to summarize all terms in the model.</p>
</td></tr>
<tr><td><code id="brief_+3A_intercept">intercept</code></td>
<td>
<p>whether or not to include the intercept; the default is <code>TRUE</code> unless the <code>terms</code> argument is given, in which
case the default is <code>FALSE</code>; ignored for <code>polr</code> models.</p>
</td></tr>
<tr><td><code id="brief_+3A_pvalues">pvalues</code></td>
<td>
<p>include the p-value for each coefficient in the table; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="brief_+3A_exponentiate">exponentiate</code></td>
<td>
<p>for a <code>"glm"</code> or <code>"glmerMod"</code> model using the <code>log</code> or <code>logit</code> link, or a
<code>"polr"</code> or <code>"multinom"</code> model, show exponentiated coefficient estimates and confidence bounds.</p>
</td></tr>
<tr><td><code id="brief_+3A_digits">digits</code></td>
<td>
<p>significant digits for printing.</p>
</td></tr>
<tr><td><code id="brief_+3A_horizontal">horizontal</code></td>
<td>
<p>if <code>TRUE</code> (the default), orient the summary produced by <code>brief</code> horizontally, which typically saves space.</p>
</td></tr>
<tr><td><code id="brief_+3A_dispersion">dispersion</code></td>
<td>
<p>use an estimated covariance matrix computed as the dispersion times the unscaled covariance matrix; see <code><a href="stats.html#topic+summary.glm">summary.glm</a></code></p>
</td></tr>
<tr><td><code id="brief_+3A_vcov.">vcov.</code></td>
<td>
<p>either a matrix giving the estimated covariance matrix of the estimates, 
or a function that
when called with <code>object</code> as an argument returns an estimated covariance matrix of the estimates.  If not set, <code>vcov(object, complete=FALSE)</code> is called to use the
usual estimated covariance matrix with aliased regressors removed. 
Other choices include the functions documented at <code><a href="car.html#topic+hccm">hccm</a></code>, and a bootstrap
estimate <code>vcov.=vcov(Boot(object))</code>; see the documentation for <code><a href="car.html#topic+Boot">Boot</a></code>.  
NOTES:  (1) The <code>dispersion</code> and <code>vcov.</code> arguments may not <em>both</em> be 
specified. (2) Setting <code>vcov.=vcov</code> returns an error if the model includes aliased 
terms; use <code>vcov.=vcov(object, complete=FALSE)</code>. (3) The <code>hccm</code> method will 
generally return a matrix of full rank even if the model has aliased terms.  Similarly
<code>vcov.=vcov(Boot(object))</code> may return a full rank matrix.
</p>
</td></tr>
<tr><td><code id="brief_+3A_...">...</code></td>
<td>
<p>arguments to pass down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>object</code> for a data object, or summary for a model object.
</p>


<h3>Note</h3>

<p>The method <code>brief.matrix</code> calls <code>brief.data.frame</code>, and <code>brief.tbl</code> (for tibbles) calls <code>print</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+S">S</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>brief(rnorm(100))
brief(Duncan)
brief(OBrienKaiser, elided=TRUE)
brief(matrix(1:500, 10, 50))
brief(lm)

mod.prestige &lt;- lm(prestige ~ education + income + type, Prestige)
brief(mod.prestige, pvalues=TRUE)
brief(mod.prestige, ~ type)
mod.mroz &lt;- glm(lfp ~ ., data=Mroz, family=binomial)
brief(mod.mroz)
</code></pre>

<hr>
<h2 id='car-defunct'>Defunct Functions in the car Package</h2><span id='topic+car-defunct'></span><span id='topic+av.plot'></span><span id='topic+av.plots'></span><span id='topic+box.cox'></span><span id='topic+bc'></span><span id='topic+box.cox.powers'></span><span id='topic+box.cox.var'></span><span id='topic+box.tidwell'></span><span id='topic+cookd'></span><span id='topic+confidence.ellipse'></span><span id='topic+ceres.plot'></span><span id='topic+ceres.plots'></span><span id='topic+cr.plot'></span><span id='topic+cr.plots'></span><span id='topic+data.ellipse'></span><span id='topic+durbin.watson'></span><span id='topic+levene.test'></span><span id='topic+leverage.plot'></span><span id='topic+leverage.plots'></span><span id='topic+linear.hypothesis'></span><span id='topic+outlier.test'></span><span id='topic+ncv.test'></span><span id='topic+qq.plot'></span><span id='topic+spread.level.plot'></span><span id='topic+skewPower'></span>

<h3>Description</h3>

<p>These functions are were deprecated in 2009 and are now defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av.plot(...)
av.plots(...)
box.cox(...)
bc(...)
box.cox.powers(...)
box.cox.var(...)
box.tidwell(...)
cookd(...)
confidence.ellipse(...)
ceres.plot(...)
ceres.plots(...)
cr.plot(...)
cr.plots(...)
data.ellipse(...)
durbin.watson(...)
levene.test(...)
leverage.plot(...)
leverage.plots(...)
linear.hypothesis(...)
ncv.test(...)
outlier.test(...)
qq.plot(...)
skewPower(...)
spread.level.plot(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="car-defunct_+3A_...">...</code></td>
<td>
<p>pass arguments down.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>av.plot</code> and <code>av.plots</code> are replaced by <code><a href="car.html#topic+avPlot">avPlot</a></code> and <code><a href="car.html#topic+avPlots">avPlots</a></code> functions.
</p>
<p><code>box.cox</code> and <code>bc</code> are now replaced by <code><a href="car.html#topic+bcPower">bcPower</a></code>.
</p>
<p><code>box.cox.powers</code> is replaced by <code><a href="car.html#topic+powerTransform">powerTransform</a></code>.
</p>
<p><code>box.cox.var</code> is replaced by <code><a href="car.html#topic+boxCoxVariable">boxCoxVariable</a></code>.
</p>
<p><code>box.tidwell</code> is replaced by <code><a href="car.html#topic+boxTidwell">boxTidwell</a></code>.
</p>
<p><code>cookd</code> is replaced by <code><a href="stats.html#topic+influence.measures">cooks.distance</a></code> in the <span class="pkg">stats</span> package.
</p>
<p><code>confidence.ellipse</code> is replaced by <code><a href="car.html#topic+confidenceEllipse">confidenceEllipse</a></code>.
</p>
<p><code>ceres.plot</code> and <code>ceres.plots</code> are now replaced by the <code><a href="car.html#topic+ceresPlot">ceresPlot</a></code> and <code><a href="car.html#topic+ceresPlots">ceresPlots</a></code> 
functions.
</p>
<p><code>cr.plot</code> and <code>cr.plots</code> are now replaced by the <code><a href="car.html#topic+crPlot">crPlot</a></code> and <code><a href="car.html#topic+crPlots">crPlots</a></code> functions.
</p>
<p><code>data.ellipse</code> is replaced by <code><a href="car.html#topic+dataEllipse">dataEllipse</a></code>.
</p>
<p><code>durbin.watson</code> is replaced by <code><a href="car.html#topic+durbinWatsonTest">durbinWatsonTest</a></code>.
</p>
<p><code>levene.test</code> is replaced by <code><a href="car.html#topic+leveneTest">leveneTest</a></code> function.
</p>
<p><code>leverage.plot</code> and <code>leverage.plots</code> are now replaced by the <code><a href="car.html#topic+leveragePlot">leveragePlot</a></code> and <code><a href="car.html#topic+leveragePlots">leveragePlots</a></code> 
functions.
</p>
<p><code>linear.hypothesis</code> is replaced by the <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> function.
</p>
<p><code>ncv.test</code> is replaced by <code><a href="car.html#topic+ncvTest">ncvTest</a></code>.
</p>
<p><code>outlier.test</code> is replaced by <code><a href="car.html#topic+outlierTest">outlierTest</a></code>.
</p>
<p><code>qq.plot</code> is replaced by <code><a href="car.html#topic+qqPlot">qqPlot</a></code>.
</p>
<p><code>skewPower</code> is replaced by <code><a href="car.html#topic+bcnPower">bcnPower</a></code>.
</p>
<p><code>spread.level.plot</code> is replaced by <code><a href="car.html#topic+spreadLevelPlot">spreadLevelPlot</a></code>.
</p>

<hr>
<h2 id='car-deprecated'>Deprecated Functions in the car Package</h2><span id='topic+car-deprecated'></span><span id='topic+bootCase'></span><span id='topic+bootCase.lm'></span><span id='topic+bootCase.glm'></span><span id='topic+bootCase.nls'></span><span id='topic+nextBoot'></span><span id='topic+nextBoot.lm'></span><span id='topic+nextBoot.nls'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions of the <span class="pkg">car</span> package only, and may be removed eventually. Commands that worked in versions of the <span class="pkg">car</span> package prior to version 3.0-0 will not necessarily work in version 3.0-0 and beyond, or may not work in the same manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
bootCase(...)

nextBoot(...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="car-deprecated_+3A_...">...</code></td>
<td>
<p>arguments to pass to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are replaced by <code><a href="car.html#topic+Boot">Boot</a></code>.
</p>


<h3>See Also</h3>

<p>See Also  <code><a href="car.html#topic+Boot">Boot</a></code></p>

<hr>
<h2 id='car-internal.Rd'>
Internal Objects for the <span class="pkg">car</span> package
</h2><span id='topic+car-internal.Rd'></span><span id='topic+.carEnv'></span>

<h3>Description</h3>

<p>These objects (currently only the <code>.carEnv</code> environment) are exported for
technical reasons and are not for direct use.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>

<hr>
<h2 id='carHexsticker'>
View the Official Hex Sticker for the car Package</h2><span id='topic+carHexsticker'></span>

<h3>Description</h3>

<p>Open the official hex sticker for the car package in your browser</p>


<h3>Usage</h3>

<pre><code class='language-R'>carHexsticker()
</code></pre>


<h3>Value</h3>

<p>Used for its side effect of openning the hex sticker for the car package in your browser.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  # intended for interactive use
carHexsticker()

## End(Not run)
</code></pre>

<hr>
<h2 id='carPalette'>
Set or Retrieve <span class="pkg">car</span> Package Color Palette
</h2><span id='topic+carPalette'></span>

<h3>Description</h3>

<p>This function is used to set or retrieve colors to be used in <span class="pkg">car</span> package graphics functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carPalette(palette)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carPalette_+3A_palette">palette</code></td>
<td>

<p>if missing, returns the colors that will be used in <span class="pkg">car</span> graphics; if present, the colors to be used in graphics will be set. The <code>palette</code> argument may also be one of <code>"car"</code> or <code>"default"</code> to use the default <span class="pkg">car</span> palette (defined below), <code>"R"</code> to use the default R palette, or <code>"colorblind"</code> to use a colorblind-friendly palette (from <a href="https://jfly.uni-koeln.de/color/">https://jfly.uni-koeln.de/color/</a>). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function sets or returns the value of <code>options(carPalette=pallete)</code> that will be use in <span class="pkg">car</span> graphics functions to determine colors.  The default is <code>c("black", "blue", "magenta", "cyan", "orange", "gray", "green3", "red"))</code>, which is nearly a permutation of the colors returned by the standard <code>palette</code> function that minimizes the use of red and green in the same graph, and that substitutes orange for the often hard to see yellow.
</p>


<h3>Value</h3>

<p>Invisibly returns the previous value of the <span class="pkg">car</span> palette.
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg and John Fox</p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+palette">palette</a></code>, <code><a href="grDevices.html#topic+colors">colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Standard color palette
palette()
# car standard color palette
carPalette()
# set colors to all black
carPalette(rep("black", 8))
# Use a custom color palette with 12 distinct colors
carPalette(sample(colors(distinct=TRUE), 12))
# restore default
carPalette("default")
</code></pre>

<hr>
<h2 id='carWeb'> Access to the R Companion to Applied Regression Website </h2><span id='topic+carWeb'></span>

<h3>Description</h3>

<p>This function will access the website for <em>An R Companion to Applied Regression</em>, or setup files or data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>carWeb(page = c("webpage", "errata", "taskviews"), script, data, setup)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carWeb_+3A_page">page</code></td>
<td>
<p> A character string indicating what page to open. The default
<code>"webpage"</code> will open the main web page, <code>"errata"</code> displays the
errata sheet for the book, <code>"taskviews"</code> fetches and displays
a list of available task views from CRAN.
</p>
</td></tr>
<tr><td><code id="carWeb_+3A_script">script</code></td>
<td>
<p>The quoted name of a chapter in <em>An R Companion to Applied
Regression</em>, like <code>"chap-1"</code>, <code>"chap-2"</code>, up to <code>"chap-10"</code>.  All the R
commands used in that chapter will be displayed in your browser, where
you can save them as a text file.
</p>
</td></tr>
<tr><td><code id="carWeb_+3A_data">data</code></td>
<td>
<p>The quoted name of a data file in <em>An R Companion to Applied
Regression</em>, like <code>"Duncan.txt"</code> or <code>"Prestige.txt"</code>.  The file will be
opened in your web browser.  You do not need to specify the extension <code>.txt</code>
</p>
</td></tr>
<tr><td><code id="carWeb_+3A_setup">setup</code></td>
<td>
<p>If <code>TRUE</code> this command will download a number of files to your computer that are discussed in Fox and Weisberg (2019), beginning in Chapter 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either displays a web page or a PDF document or downloads files to your working directory.
</p>


<h3>Author(s)</h3>

<p> Sanford Weisberg, based on the function <code>UsingR</code> in the <span class="pkg">UsingR</span>
package by John Verzani </p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  # meant for interactive use
carWeb()
carWeb(setup=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='ceresPlots'>Ceres Plots</h2><span id='topic+ceresPlots'></span><span id='topic+ceresPlots.default'></span><span id='topic+ceresPlot'></span><span id='topic+ceresPlot.lm'></span><span id='topic+ceresPlot.glm'></span>

<h3>Description</h3>

<p>These functions draw Ceres plots for linear and generalized
linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ceresPlots(model, ...)

## Default S3 method:
ceresPlots(model, terms = ~., layout = NULL, ask, main,
    ...)

ceresPlot(model, ...)

## S3 method for class 'lm'
ceresPlot(model, variable, id=FALSE,
  line=TRUE,  smooth=TRUE, col=carPalette()[1], col.lines=carPalette()[-1],
  xlab, ylab, pch=1, lwd=2,  grid=TRUE, ...)

## S3 method for class 'glm'
ceresPlot(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ceresPlots_+3A_model">model</code></td>
<td>
<p>model object produced by <code>lm</code> or <code>glm</code>.</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_terms">terms</code></td>
<td>
<p> A one-sided formula that specifies a subset of the regressors.
One component-plus-residual plot is drawn for each term.  The default
<code>~.</code> is to plot against all numeric predictors.  For example, the
specification <code>terms = ~ . - X3</code> would plot against all predictors
except for <code>X3</code>.  Factors and nonstandard predictors such as B-splines are
skipped.  If this argument is a quoted name of one of the regressors, the
component-plus-residual plot is drawn for that predictor only.
</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_layout">layout</code></td>
<td>

<p>If set to a value like <code>c(1, 1)</code> or <code>c(4, 3)</code>, the layout
of the graph will have this many rows and columns.  If not set, the program
will select an appropriate layout.  If the number of graphs exceed nine, you
must select the layout yourself, or you will get a maximum of nine per page.
If <code>layout=NA</code>, the function does not set the layout and the user can
use the <code>par</code> function to control the layout, for example to have
plots from two models in the same graphics window.
</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, ask the user before drawing the next plot; if <code>FALSE</code>, the default, don't ask.
This is relevant only if not all the graphs can be drawn in one window.</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_main">main</code></td>
<td>
<p>Overall title for any array of cerers plots; if missing a default
is provided.</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_...">...</code></td>
<td>
<p><code>ceresPlots</code> passes these arguments to <code>ceresPlot</code>.
<code>ceresPlot</code> passes them to <code>plot</code>.
</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_variable">variable</code></td>
<td>
<p>A quoted string giving the name of a variable for the horizontal
axis</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method=list(abs(residuals(model, type="pearson")), "x"), n=2,
    cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the largest residuals and the 2 points with the most extreme
horizontal (X) values.</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_line">line</code></td>
<td>
<p><code>TRUE</code> to plot least-squares line.
</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_smooth">smooth</code></td>
<td>
<p>specifies the smoother to be used along with its arguments; if <code>FALSE</code>, no smoother is shown;
can be a list giving the smoother function and its named arguments; <code>TRUE</code>, the default, is equivalent to
<code>list(smoother=loessLine)</code>. See <code><a href="car.html#topic+ScatterplotSmoothers">ScatterplotSmoothers</a></code> for the smoothers supplied by the
<span class="pkg">car</span> package and their arguments.  Ceres plots do not support variance smooths.</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_col">col</code></td>
<td>
<p>color for points; the default is the first entry
in the current <span class="pkg">car</span> palette (see <code><a href="car.html#topic+carPalette">carPalette</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_col.lines">col.lines</code></td>
<td>
<p>a list of at least two colors.  The first color is used for the
ls line and the second color is used for the fitted lowess line.  To use
the same color for both, use, for example, <code>col.lines=c("red", "red")</code>
</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_xlab">xlab</code>, <code id="ceresPlots_+3A_ylab">ylab</code></td>
<td>
<p>labels for the x and y axes, respectively.  If not set
appropriate labels are created by the function.</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_pch">pch</code></td>
<td>
<p>plotting character for points; default is <code>1</code>
(a circle, see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>2</code> (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="ceresPlots_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ceres plots are a generalization of component+residual (partial
residual) plots that are less prone to leakage of nonlinearity
among the predictors.
</p>
<p>The function intended for direct use is <code>ceresPlots</code>.
</p>
<p>The model cannot contain interactions, but can contain factors.
Factors may be present in the model, but Ceres plots cannot be drawn
for them.
</p>


<h3>Value</h3>

<p><code>NULL</code>. These functions are used for their side effect: producing
plots.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Cook, R. D. and Weisberg, S. (1999)
<em>Applied Regression, Including Computing and Graphics.</em> Wiley.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.
</p>
<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+crPlots">crPlots</a></code>, <code><a href="car.html#topic+avPlots">avPlots</a></code>, <code><a href="car.html#topic+showLabels">showLabels</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ceresPlots(lm(prestige~income+education+type, data=Prestige), terms= ~ . - type)
</code></pre>

<hr>
<h2 id='compareCoefs'>
Print estimated coefficients and their standard errors in a table
for several regression models.
</h2><span id='topic+compareCoefs'></span>

<h3>Description</h3>

<p>This function extracts estimates of regression parameters and
their standard errors from one or more models and prints them in a
table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareCoefs(..., se = TRUE, zvals = FALSE, pvals = FALSE, vcov.,
    print = TRUE, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareCoefs_+3A_...">...</code></td>
<td>

<p>One or more regression-model objects.  These may be of class <code>lm</code>, <code>glm</code>,
<code>nlm</code>, or any other regression method for which the functions <code>coef</code> and
<code>vcov</code> return appropriate values, or if the object inherits from the <code>mer</code>
class created by the <code>lme4</code> package or <code>lme</code> in the <code>nlme</code>
package.
</p>
</td></tr>
<tr><td><code id="compareCoefs_+3A_se">se</code></td>
<td>

<p>If <code>TRUE</code>, the default, show standard errors as well as estimates.
</p>
</td></tr>
<tr><td><code id="compareCoefs_+3A_zvals">zvals</code></td>
<td>
<p>If <code>TRUE</code> (the default is <code>FALSE</code>), print Wald statistics, the
ratio of each coefficient to its standard error.</p>
</td></tr>
<tr><td><code id="compareCoefs_+3A_pvals">pvals</code></td>
<td>
<p>If codeTRUE (the default is <code>FALSE</code>), print two-sided p-values
from the standard normal distribution corresponding to the Wald statistics.</p>
</td></tr>
<tr><td><code id="compareCoefs_+3A_vcov.">vcov.</code></td>
<td>
<p>an optional argument, specifying a function to be applied to all of the models, returning a coefficient covariance matrix
for each, or a list with one element for each model, with each element either containing a function to
be applied to the corresponding model or a coefficient covariance matrix for that model. If omitted, <code>vcov</code> is applied to
each model.  This argument can also be a list of estimated covariance matrices of the coefficient estimates.</p>
</td></tr>
<tr><td><code id="compareCoefs_+3A_print">print</code></td>
<td>

<p>If <code>TRUE</code>, the default, the results are printed in a nice format
using <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.  If
<code>FALSE</code>, the results are returned as a matrix
</p>
</td></tr>
<tr><td><code id="compareCoefs_+3A_digits">digits</code></td>
<td>

<p>Passed to the <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code> function for printing the result.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is mainly used for its side-effect of printing the result.  It
also  invisibly returns a matrix of estimates, standard errors, Wald statistics, and p-values.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) <em>An R Companion to Applied Regression</em>,
Third Edition, Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod1 &lt;- lm(prestige ~ income + education, data=Duncan)
mod2 &lt;- update(mod1, subset=-c(6,16))
mod3 &lt;- update(mod1, . ~ . + type)
mod4 &lt;- update(mod1, . ~ . + I(income + education)) # aliased coef.
compareCoefs(mod1)
compareCoefs(mod1, mod2, mod4)
compareCoefs(mod1, mod2, mod3, zvals=TRUE, pvals=TRUE)
compareCoefs(mod1, mod2, se=FALSE)
compareCoefs(mod1, mod1, vcov.=list(vcov, hccm))
</code></pre>

<hr>
<h2 id='Contrasts'>Functions to Construct Contrasts</h2><span id='topic+Contrasts'></span><span id='topic+contr.Treatment'></span><span id='topic+contr.Sum'></span><span id='topic+contr.Helmert'></span>

<h3>Description</h3>

<p>These are substitutes for similarly named functions in the <span class="pkg">stats</span> package 
(note the uppercase letter starting the second word in each function name).
The only difference is that the contrast functions from the <span class="pkg">car</span> package
produce easier-to-read names for the contrasts when they are used in statistical models. 
</p>
<p>The functions and this documentation are adapted from the <span class="pkg">stats</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.Treatment(n, base = 1, contrasts = TRUE)

contr.Sum(n, contrasts = TRUE)

contr.Helmert(n, contrasts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Contrasts_+3A_n">n</code></td>
<td>
<p>a vector of levels for a factor, or the number of levels.</p>
</td></tr>
<tr><td><code id="Contrasts_+3A_base">base</code></td>
<td>
<p>an integer specifying which level is considered the baseline level. 
Ignored if <code>contrasts</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Contrasts_+3A_contrasts">contrasts</code></td>
<td>
<p>a logical indicating whether contrasts should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used for creating contrast matrices for use in fitting analysis of variance and regression models. 
The columns of the resulting matrices contain contrasts which can be used for coding a factor with <code>n</code> levels. 
The returned value contains the computed contrasts. If the argument <code>contrasts</code> is <code>FALSE</code> then a square matrix is returned.
</p>
<p>Several aspects of these contrast functions are controlled by options set via the <code>options</code> command:
</p>

<dl>
<dt><code>decorate.contrasts</code></dt><dd><p>This option should be set to a 2-element character vector containing the prefix and suffix
characters to surround contrast names. If the option is not set, then <code>c("[", "]")</code> is used. For example, setting
<code>options(decorate.contrasts=c(".", ""))</code> produces contrast names that are separated from factor names by a period.
Setting <code>options( decorate.contrasts=c("", ""))</code> reproduces the behaviour of the R base contrast functions.</p>
</dd> 
<dt><code>decorate.contr.Treatment</code></dt><dd><p>A character string to be appended to contrast names to signify treatment contrasts;
if the option is unset, then <code>"T."</code> is used.</p>
</dd>
<dt><code>decorate.contr.Sum</code></dt><dd><p>Similar to the above, with default <code>"S."</code>.</p>
</dd>
<dt><code>decorate.contr.Helmert</code></dt><dd><p>Similar to the above, with default <code>"H."</code>.</p>
</dd> 
<dt><code>contr.Sum.show.levels</code></dt><dd><p>Logical value: if <code>TRUE</code> (the default if unset), 
then level names are used for contrasts; if <code>FALSE</code>, then numbers are used, as in <code>contr.sum</code>
in the <code>base</code> package.</p>
</dd> 
</dl>

<p>Note that there is no replacement for <code>contr.poly</code> in the <code>base</code> package (which produces 
orthogonal-polynomial contrasts) since this function already constructs easy-to-read contrast names.
</p>


<h3>Value</h3>

<p>A matrix with <code>n</code> rows and <code>k</code> columns, with <code>k = n - 1</code> if <code>contrasts</code> is <code>TRUE</code> 
and <code>k = n</code> if <code>contrasts</code> is <code>FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+contr.treatment">contr.treatment</a></code>, <code><a href="stats.html#topic+contr.sum">contr.sum</a></code>, 
<code><a href="stats.html#topic+contr.helmert">contr.helmert</a></code>, <code><a href="stats.html#topic+contr.poly">contr.poly</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># contr.Treatment vs. contr.treatment in the base package:

lm(prestige ~ (income + education)*type, data=Prestige, 
    contrasts=list(type="contr.Treatment"))

##  Call:
##  lm(formula = prestige ~ (income + education) * type, data = Prestige,
##      contrasts = list(type = "contr.Treatment"))
##  
##  Coefficients:
##          (Intercept)                  income               education  
##              2.275753                0.003522                1.713275  
##          type[T.prof]              type[T.wc]     income:type[T.prof]  
##              15.351896              -33.536652               -0.002903  
##      income:type[T.wc]  education:type[T.prof]    education:type[T.wc]  
##              -0.002072                1.387809                4.290875  

lm(prestige ~ (income + education)*type, data=Prestige, 
    contrasts=list(type="contr.treatment"))    

##  Call:
##  lm(formula = prestige ~ (income + education) * type, data = Prestige,
##      contrasts = list(type = "contr.treatment"))
##  
##  Coefficients:
##      (Intercept)              income           education  
##          2.275753            0.003522            1.713275  
##          typeprof              typewc     income:typeprof  
##          15.351896          -33.536652           -0.002903  
##      income:typewc  education:typeprof    education:typewc  
##          -0.002072            1.387809            4.290875      
</code></pre>

<hr>
<h2 id='crPlots'>Component+Residual (Partial Residual) Plots</h2><span id='topic+crPlots.default'></span><span id='topic+crPlots'></span><span id='topic+crp'></span><span id='topic+crPlot'></span><span id='topic+crPlot.lm'></span><span id='topic+crPlot3d'></span><span id='topic+crPlot3d.lm'></span>

<h3>Description</h3>

<p>These functions construct component+residual plots, also called
partial-residual plots, for linear and generalized linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crPlots(model, ...)

## Default S3 method:
crPlots(model, terms = ~., layout = NULL, ask, main, 
    ...)

crp(...)

crPlot(model, ...)

## S3 method for class 'lm'
crPlot(model, variable, id=FALSE,
    order=1, line=TRUE, smooth=TRUE, 
    col=carPalette()[1], col.lines=carPalette()[-1],
    xlab, ylab, pch=1, lwd=2, grid=TRUE, ...)
    
crPlot3d(model, var1, var2, ...)

## S3 method for class 'lm'
crPlot3d(model, var1, var2,
    xlab = var1,
    ylab = paste0("C+R(", eff$response, ")"), zlab = var2,
    axis.scales = TRUE, axis.ticks = FALSE, revolutions = 0,
    bg.col = c("white", "black"),
    axis.col = if (bg.col == "white") c("darkmagenta", "black", "darkcyan") 
        else c("darkmagenta", "white", "darkcyan"),
    surface.col = carPalette()[2:3], surface.alpha = 0.5,
    point.col = "yellow", text.col = axis.col,
    grid.col = if (bg.col ==  "white") "black" else "gray",
    fogtype = c("exp2", "linear", "exp", "none"),
    fill = TRUE, grid = TRUE, grid.lines = 26,
    smoother = c("loess", "mgcv", "none"), df.mgcv = NULL, loess.args = NULL,
    sphere.size = 1, radius = 1, threshold = 0.01, speed = 1, fov = 60,
    ellipsoid = FALSE, level = 0.5, ellipsoid.alpha = 0.1,
    id = FALSE, 
    mouseMode=c(none="none", left="polar", right="zoom", middle="fov", 
	               wheel="pull"),
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crPlots_+3A_model">model</code></td>
<td>
<p>model object produced by <code>lm</code> or <code>glm</code>.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_terms">terms</code></td>
<td>
<p> A one-sided formula that specifies a subset of the regressors. 
One component-plus-residual plot is drawn for each regressor.  The default
<code>~.</code> is to plot against all numeric regressors.  For example, the
specification <code>terms = ~ . - X3</code> would plot against all regressors
except for <code>X3</code>, while <code>terms = ~ log(X4)</code> would give the plot for the 
predictor X4 that is represented in the model by log(X4).  If this argument is a 
quoted name of one of the predictors, the 
component-plus-residual plot is drawn for that predictor only.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_var1">var1</code>, <code id="crPlots_+3A_var2">var2</code></td>
<td>
<p>The quoted names of the two predictors in the model to use for a 3D C+R plot.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_layout">layout</code></td>
<td>
 
<p>If set to a value like <code>c(1, 1)</code> or <code>c(4, 3)</code>, the layout
of the graph will have this many rows and columns.  If not set, the program
will select an appropriate layout.  If the number of graphs exceed nine, you 
must select the layout yourself, or you will get a maximum of nine per page.
If <code>layout=NA</code>, the function does not set the layout and the user can
use the <code>par</code> function to control the layout, for example to have 
plots from two models in the same graphics window.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, ask the user before drawing the next plot; if <code>FALSE</code>, the default,  don't ask.
This is relevant only if not all the graphs can be drawn in one window.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_main">main</code></td>
<td>
<p>The title of the plot; if missing, one will be supplied.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_...">...</code></td>
<td>
<p><code>crPlots</code> passes these arguments to <code>crPlot</code>.  
<code>crPlot</code> passes them to <code>plot</code>. </p>
</td></tr>
<tr><td><code id="crPlots_+3A_variable">variable</code></td>
<td>
<p>A quoted string giving the name of a variable for the horizontal
axis.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method=list(abs(residuals(model, type="pearson")), "x"), n=2, 
    cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the largest residuals and the 2 points with the most extreme
horizontal (X) values. For 3D C+R plots, see <code><a href="car.html#topic+Identify3d">Identify3d</a></code>.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_order">order</code></td>
<td>
<p>order of polynomial regression performed for predictor to be plotted; default <code>1</code>.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_line">line</code></td>
<td>
<p><code>TRUE</code> to plot least-squares line.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_smooth">smooth</code></td>
<td>
<p>specifies the smoother to be used along with its arguments; if <code>FALSE</code>, no smoother is shown;
can be a list giving the smoother function and its named arguments; <code>TRUE</code>, the default, is equivalent to
<code>list(smoother=loessLine)</code>. See <code><a href="car.html#topic+ScatterplotSmoothers">ScatterplotSmoothers</a></code> for the smoothers supplied by the
<span class="pkg">car</span> package and their arguments.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_smoother">smoother</code>, <code id="crPlots_+3A_df.mgcv">df.mgcv</code>, <code id="crPlots_+3A_loess.args">loess.args</code></td>
<td>
<p><code>smoother</code> specifies quoted name of the surface smoother to use for
the partial residuals, either <code><a href="stats.html#topic+loess">loess</a></code>, the default, or <code><a href="mgcv.html#topic+mgcv">mgcv</a></code>.
<code>df.mgcv</code> gives the degrees of freedom for the <code>mgcv</code> smoother; <code>NULL</code>, the default, causes the df to be computed by <code>mgcv</code>. <code>loess.args</code> is an optional list with named elements <code>span</code>, <code>family</code> and <code>degree</code>, with default <code>span = 2/3</code>;
<code>family = "gaussian"</code> for a binomial or Poisson GLM and <code>family = "symmetric"</code>
otherwise; and <code>degree = 1</code> (see <code><a href="stats.html#topic+loess">loess</a></code>).</p>
</td></tr>
<tr><td><code id="crPlots_+3A_col">col</code></td>
<td>
<p>color for points; the default is the first entry
in the current <span class="pkg">car</span> palette (see <code><a href="car.html#topic+carPalette">carPalette</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="crPlots_+3A_col.lines">col.lines</code></td>
<td>
<p>a list of at least two colors.  The first color is used for the
ls line and the second color is used for the fitted lowess line.  To use
the same color for both, use, for example, <code>col.lines=c("red", "red")</code></p>
</td></tr>
<tr><td><code id="crPlots_+3A_xlab">xlab</code>, <code id="crPlots_+3A_ylab">ylab</code>, <code id="crPlots_+3A_zlab">zlab</code></td>
<td>
<p>labels for the x and y axes, and for the z axis of a 3D plot.  If not set 
appropriate labels are created by the function. for the 3D C+R plot, the predictors are on
the x and z axes and the response on the y (vertical) axis.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_pch">pch</code></td>
<td>
<p>plotting character for points; default is <code>1</code> 
(a circle, see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="crPlots_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>2</code> (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="crPlots_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph. For a 3D C+R plot, see the <code>grid</code> argument for <code><a href="car.html#topic+scatter3d">scatter3d</a></code>.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_grid.lines">grid.lines</code></td>
<td>
<p>number of horizontal and vertical lines to be drawn on
regression surfaces for 2D C+R plots (26 by default); the square of <code>grid.lines</code> corresponds
to the number of points at which the fitted partial regression surface is evaluated
and so this argument should not be set too small.</p>
</td></tr>
<tr><td><code id="crPlots_+3A_axis.scales">axis.scales</code>, <code id="crPlots_+3A_axis.ticks">axis.ticks</code>, <code id="crPlots_+3A_revolutions">revolutions</code>, <code id="crPlots_+3A_bg.col">bg.col</code>, <code id="crPlots_+3A_axis.col">axis.col</code>, <code id="crPlots_+3A_surface.col">surface.col</code>, <code id="crPlots_+3A_surface.alpha">surface.alpha</code>, <code id="crPlots_+3A_point.col">point.col</code>, <code id="crPlots_+3A_text.col">text.col</code>, <code id="crPlots_+3A_grid.col">grid.col</code>, <code id="crPlots_+3A_fogtype">fogtype</code>, <code id="crPlots_+3A_fill">fill</code>, <code id="crPlots_+3A_sphere.size">sphere.size</code>, <code id="crPlots_+3A_radius">radius</code>, <code id="crPlots_+3A_threshold">threshold</code>, <code id="crPlots_+3A_speed">speed</code>, <code id="crPlots_+3A_fov">fov</code>, <code id="crPlots_+3A_ellipsoid">ellipsoid</code>, <code id="crPlots_+3A_level">level</code>, <code id="crPlots_+3A_ellipsoid.alpha">ellipsoid.alpha</code>, <code id="crPlots_+3A_mousemode">mouseMode</code></td>
<td>
<p>see <code><a href="car.html#topic+scatter3d">scatter3d</a>.</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions intended for direct use are <code>crPlots</code>, for which <code>crp</code>
is an abbreviation, and, for 3D C+R plots, <code>crPlot3d</code>. 
</p>
<p>For 2D plots, the model cannot contain interactions, but can contain factors. 
Parallel boxplots of the partial residuals are drawn for the levels
of a factor. <code>crPlot3d</code> can handle models with two-way interactions.
</p>
<p>For 2D C+R plots, the fit is represented by a broken blue line and a smooth of the partial
residuals by a solid magenta line. For 3D C+R plots, the fit is represented by a blue surface
and a smooth of the partial residuals by a magenta surface.
</p>


<h3>Value</h3>

<p><code>NULL</code>. These functions are used for their side effect of producing
plots.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

 
<p>Cook, R. D. and Weisberg, S. (1999)
<em>Applied Regression, Including Computing and Graphics.</em> Wiley.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+ceresPlots">ceresPlots</a></code>, <code><a href="car.html#topic+avPlots">avPlots</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>crPlots(m&lt;-lm(prestige ~ income + education, data=Prestige)) 

crPlots(m, terms=~ . - education) # get only one plot

crPlots(lm(prestige ~ log2(income) + education + poly(women,2), data=Prestige))

crPlots(glm(partic != "not.work" ~ hincome + children, 
  data=Womenlf, family=binomial), smooth=list(span=0.75))

# 3D C+R plot, requires the rgl, effects, and mgcv packages
if (interactive() &amp;&amp; require(rgl) &amp;&amp; require(effects) &amp;&amp; require(mgcv)){
crPlot3d(lm(prestige ~ income*education + women, data=Prestige), 
    "income", "education") 
}
</code></pre>

<hr>
<h2 id='deltaMethod'>Estimate and Standard Error of a Nonlinear Function of Estimated Regression 
Coefficients</h2><span id='topic+deltaMethod'></span><span id='topic+deltaMethod.default'></span><span id='topic+deltaMethod.lm'></span><span id='topic+deltaMethod.nls'></span><span id='topic+deltaMethod.multinom'></span><span id='topic+deltaMethod.polr'></span><span id='topic+deltaMethod.survreg'></span><span id='topic+deltaMethod.coxph'></span><span id='topic+deltaMethod.mer'></span><span id='topic+deltaMethod.merMod'></span><span id='topic+deltaMethod.lme'></span><span id='topic+deltaMethod.lmList'></span>

<h3>Description</h3>

<p><code>deltaMethod</code> is a generic function that uses the delta method to get a 
first-order approximate 
standard error for a nonlinear function of a vector of random variables
with known or estimated covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaMethod(object, ...)

## Default S3 method:
deltaMethod(object, g., vcov., func=g., constants, level=0.95, 
  rhs, ..., envir=parent.frame())
## S3 method for class 'lm'
 deltaMethod(object, g., vcov.=vcov(object, complete=FALSE), 
           parameterNames=names(coef(object)), ..., envir=parent.frame())
## S3 method for class 'nls'
deltaMethod(object, g., vcov.=vcov(object, complete=FALSE), ..., envir=parent.frame())
## S3 method for class 'multinom'
 deltaMethod(object, g., vcov. = vcov(object, complete=FALSE), 
           parameterNames = if (is.matrix(coef(object))) 
           colnames(coef(object)) else names(coef(object)), ..., envir=parent.frame()) 
## S3 method for class 'polr'
 deltaMethod(object, g., vcov.=vcov(object, complete=FALSE), ..., envir=parent.frame())
## S3 method for class 'survreg'
 deltaMethod(object, g., vcov. = vcov(object, complete=FALSE), 
           parameterNames = names(coef(object)), ..., envir=parent.frame())
## S3 method for class 'coxph'
 deltaMethod(object, g., vcov. = vcov(object, complete=FALSE), 
           parameterNames = names(coef(object)), ..., envir=parent.frame())
## S3 method for class 'mer'
 deltaMethod(object, g., vcov. = vcov(object, complete=FALSE),
           parameterNames = names(fixef(object)), ..., envir=parent.frame())
## S3 method for class 'merMod'
 deltaMethod(object, g., vcov. = vcov(object, complete=FALSE),
           parameterNames = names(fixef(object)), ..., envir=parent.frame())
## S3 method for class 'lme'
 deltaMethod(object, g., vcov. = vcov(object, complete=FALSE),
           parameterNames = names(fixef(object)), ..., envir=parent.frame())
## S3 method for class 'lmList'
 deltaMethod(object, g.,  ..., envir=parent.frame())

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deltaMethod_+3A_object">object</code></td>
<td>
<p>For the default method, <code>object</code> is either (1) a vector of <code>p</code> 
named elements, so <code>names(object)</code> returns a list
of <code>p</code> character strings that are the names of the elements of
<code>object</code>; or (2) a model object for which there are <code><a href="stats.html#topic+coef">coef</a></code> and <code><a href="stats.html#topic+vcov">vcov</a></code> methods,
and for which the named coefficient vector returned by <code>coef</code> is asymptotically normally distributed with asymptotic
covariance matrix returned by <code>vcov</code>.
For the other methods, <code>object</code> is a 
regression object for which <code>coef(object)</code> or <code>fixef(object)</code> returns a vector of parameter
estimates.</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_g.">g.</code></td>
<td>
<p>A quoted string that is the function of the parameter estimates to be
evaluated; see the details below. </p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_vcov.">vcov.</code></td>
<td>
<p>The (estimated) covariance matrix of the coefficient
estimates.  For the default method, this argument is required.  For all
other methods, this argument must either provide the estimated covariance
matrix or a function that when applied
to <code>object</code> returns a covariance matrix.  The default is 
to use the function <code>vcov</code>.</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_func">func</code></td>
<td>
<p>A quoted string used to annotate output.  The default of
<code>func = g.</code> is usually appropriate.</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_parameternames">parameterNames</code></td>
<td>
<p>A character vector of length <code>p</code> that gives the 
names of the parameters in the same order as they appear in the vector of
estimates.  This argument will be useful if some of the names in the
vector of estimates include special characters, like <code>I(x2^2)</code>, or 
<code>x1:x2</code> that will confuse the numerical differentiation function.  See
details below.</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_constants">constants</code></td>
<td>
<p>This argument is a named vector whose elements are constants that
are used in the <code>f</code> argument. It isn't generally necessary to specify this argument but it may be convenient to do so.</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_level">level</code></td>
<td>
<p>level for confidence interval, default <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_rhs">rhs</code></td>
<td>
<p>hypothesized value for the specified function of parameters; if absent
no hypothesis test is performed.</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_...">...</code></td>
<td>
<p>Used to pass arguments to the generic method.</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_envir">envir</code></td>
<td>
<p>Environment in which <code>g.</code> is evaluated; not normally specified by the user.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">x</code> is a random vector of length <code class="reqn">p</code> that is at least approximately 
normally distributed with mean <code class="reqn">\beta</code> and estimated covariance matrix 
<code class="reqn">C</code>.   Then any function <code class="reqn">g(\beta)</code> of <code class="reqn">\beta</code>, is estimated by
<code class="reqn">g(x)</code>, which is in large samples normally distributed with mean <code class="reqn">g(\beta)</code>
and estimated variance <code class="reqn">h'Ch</code>, where <code class="reqn">h</code> is the first derivative of
<code class="reqn">g(\beta)</code> with respect to <code class="reqn">\beta</code> evaluated at <code class="reqn">x</code>.  This function
returns both <code class="reqn">g(x)</code> and its standard error, the square root of the estimated
variance.
</p>
<p>The default method requires that you provide <code class="reqn">x</code> in the argument
<code>object</code>, <code class="reqn">C</code> in the argument <code>vcov.</code>, and a text expression
in argument <code>g.</code> that when evaluated gives the function <code class="reqn">g</code>.  The
call <code>names(object)</code> must return the names of the elements of <code>x</code>
that are used in the expression <code>g.</code>.  
</p>
<p>Since
the delta method is often applied to functions of regression parameter 
estimates, the argument <code>object</code> may be the name of a regression
object from which the estimates and their estimated variance matrix can
be extracted.  In most regression models, estimates are returned by the
<code>coef(object)</code> and the variance matrix from <code>vcov(object)</code>.
You can provide an alternative function for computing the sample variance
matrix, for example to use a sandwich estimator.
</p>
<p>For mixed models using <code>lme4</code> or <code>nlme</code>, the coefficient estimates
are returned by the <code>fixef</code> function, while for <code>multinom</code>,
<code>lmList</code> and <code>nlsList</code> coefficient estimates are returned by 
<code>coef</code> as a matrix.  Methods for these models are provided to get the
correct estimates and variance matrix.
</p>
<p>The argument <code>g.</code> must be a quoted character string
that gives the function of interest.  For example, if you set 
<code>m2 &lt;- lm(Y ~ X1 + X2 + X1:X2)</code>, then <code>deltaMethod(m2,"X1/X2")</code> applies the
delta method to the ratio of the coefficient estimates for <code>X1</code> and
<code>X2</code>.  The argument <code>g.</code> can consist of constants and names 
associated with the elements of the vector of coefficient estimates.
</p>
<p>In some cases the names may include characters such as the colon 
<code>:</code> used in interactions, or mathematical symbols like <code>+</code> or 
<code>-</code> signs that would confuse the 
function that computes numerical derivatives, and for this case you can replace
the names of the estimates with the <code>parameterNames</code> argument.  For
example, the ratio of the
<code>X2</code> main effect to the interaction term could be computed using
<code>deltaMethod(m2, "b1/b3", parameterNames=c("b0", "b1", "b2", "b3"))</code>.
The name &ldquo;<code>(Intercept)</code>&rdquo; used for the intercept in linear and generalized
linear models is an exception, and it will be correctly interpreted by
<code>deltaMethod</code>. Another option is to use back-ticks to quote nonstandard R names, as in <code>deltaMethod(m2,"X1/`X1:X2`")</code>.
</p>
<p>For <code>multinom</code> objects, the <code>coef</code> function returns a matrix of
coefficients, with each row giving the estimates for comparisons of one category
to the baseline.  The <code>deltaMethod</code> function applies the delta method to
each row of this matrix.  Similarly, for <code>lmList</code> and <code>nlsList</code>
objects, the delta method is computed for each element of the list of
models fit. 
</p>
<p>For nonlinear regression objects produced by the <code>nls</code> function, the call <code>coef(object)</code> 
returns the estimated
coefficient vectors with names corresponding to parameter names.  
For example,           
<code>m2 &lt;- nls(y ~ theta/(1 + gamma * x), start = list(theta=2, gamma=3))</code> will
have parameters named  <code>c("theta", "gamma")</code>.   
In many other familiar regression models, such as those produced by <code>lm</code> and <code>glm</code>, the names of
the coefficient estimates are the corresponding regressor names, not
parameter names. 
</p>
<p>For mixed-effects models fit with <code>lmer</code> and <code>glmer</code> from the 
<span class="pkg">lme4</span> package or <code>lme</code> and <code>nlme</code> from the <span class="pkg">nlme</span> package, 
only fixed-effect coefficients are considered.
</p>
<p>For regression models for which methods are not provided, you can extract
the named vector of coefficient estimates and and estimate of its covariance
matrix and then apply the default <code>deltaMethod</code> function. 
</p>
<p><em>Note:</em> Earlier versions of <code>deltaMethod</code> included an argument 
<code>parameterPrefix</code> that implemented the same functionality as the
<code>parameterNames</code> argument, but which caused several problems that
were not easily fixed without the change in syntax.  
</p>


<h3>Value</h3>

<p>An object of class <code>"deltaMethod"</code>, inheriting from <code>"data.frame"</code>, for which a <code>print</code> method is provided. The object contains columns
named <code>Estimate</code> for the estimate, <code>SE</code> for its standard error, and columns for confidence limits and possibly a hypothesis test.
The value of <code>g.</code> is given as a row label.  
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg, <a href="mailto:sandy@umn.edu">sandy@umn.edu</a>, John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, and Pavel Krivitsky.</p>


<h3>References</h3>

<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Weisberg, S. (2014) <em>Applied
Linear Regression</em>, Fourth Edition, Wiley, Section 6.1.2.
</p>


<h3>See Also</h3>

<p>First derivatives of <code>g.</code> are computed using symbolic differentiation
by the function <code><a href="stats.html#topic+D">D</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lm(time ~ t1 + t2, data = Transact) 
deltaMethod(m1, "b1/b2", parameterNames= paste("b", 0:2, sep="")) 
deltaMethod(m1, "t1/t2", rhs=1) # use names of preds. rather than coefs.
deltaMethod(m1, "t1/t2", vcov=hccm) # use hccm function to est. vars.
deltaMethod(m1, "1/(Intercept)")
# The next example invokes the default method by extracting the
# vector of estimates and covariance matrix explicitly
deltaMethod(coef(m1), "t1/t2", vcov.=vcov(m1))
</code></pre>

<hr>
<h2 id='densityPlot'>
Nonparametric Density Estimates
</h2><span id='topic+densityPlot'></span><span id='topic+densityPlot.default'></span><span id='topic+densityPlot.formula'></span><span id='topic+adaptiveKernel'></span><span id='topic+depan'></span><span id='topic+dbiwt'></span>

<h3>Description</h3>

<p><code>densityPlot</code> contructs and graphs nonparametric density estimates, possibly conditioned on a factor, using the standard <span class="rlang"><b>R</b></span> <code><a href="stats.html#topic+density">density</a></code> function or by default <code>adaptiveKernel</code>, which computes an adaptive kernel density estimate.
<code>depan</code> provides the Epanechnikov kernel and <code>dbiwt</code> provides the biweight kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityPlot(x, ...)

## Default S3 method:
densityPlot(x, g, method=c("adaptive", "kernel"),
    bw=if (method == "adaptive") bw.nrd0 else "SJ", adjust=1,
    kernel, xlim, ylim,
    normalize=FALSE, xlab=deparse(substitute(x)), ylab="Density", main="",
    col=carPalette(), lty=seq_along(col), lwd=2, grid=TRUE,
    legend=TRUE, show.bw=FALSE, rug=TRUE, ...)

## S3 method for class 'formula'
densityPlot(formula, data=NULL, subset,
    na.action=NULL, xlab, ylab, main="", legend=TRUE, ...)

adaptiveKernel(x, kernel=dnorm, bw=bw.nrd0, adjust=1.0, n=500,
    from, to, cut=3, na.rm=TRUE)
    
depan(x)
dbiwt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityPlot_+3A_x">x</code></td>
<td>
<p>a numeric variable, the density of which is estimated; for 
<code>depan</code> and <code>dbiwt</code>, the argument of the kernel function.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_g">g</code></td>
<td>
<p>an optional factor to divide the data.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_formula">formula</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> model formula, of the form <code>~ variable</code> to estimate the unconditional
density of <code>variable</code>, or <code>variable ~ factor</code> to estimate the density of <code>variable</code>
within each level of <code>factor</code>.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the data.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_subset">subset</code></td>
<td>
<p>an optional vector defining a subset of the data.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_na.action">na.action</code></td>
<td>
<p>a function to handle missing values; defaults to the value of the <span class="rlang"><b>R</b></span> <code>na.action</code> option,
initially set to <code><a href="stats.html#topic+na.omit">na.omit</a></code>.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_method">method</code></td>
<td>
<p>either <code>"adaptive"</code> (the default) for an adaptive-kernel estimate or <code>"kernel"</code> for a fixed-bandwidth kernel estimate.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_bw">bw</code></td>
<td>
<p>the geometric mean bandwidth for the adaptive-kernel or bandwidth of the kernel density estimate(s). Must be a numerical value
or a function to compute the bandwidth (default <code><a href="stats.html#topic+bw.nrd0">bw.nrd0</a></code>) for the adaptive
kernel estimate; for the kernel estimate, may either the quoted name of a rule to
compute the bandwidth, or a numeric value. If plotting by groups, <code>bw</code>
may be a vector of values, one for each group. See <code><a href="stats.html#topic+density">density</a></code> and <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code> for details of the kernel estimator.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_adjust">adjust</code></td>
<td>
<p>a multiplicative adjustment factor for the bandwidth; the default, <code>1</code>, indicates no adjustment;
if plotting by groups, <code>adjust</code> may be a vector of adjustment factors, one for each group. The default bandwidth-selection rule tends to give a value that's too large if
the distribution is asymmetric or has multiple modes; try setting <code>adjust</code> &lt;  1, particularly for the adaptive-kernel estimator.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_kernel">kernel</code></td>
<td>
<p>for <code>densityPlot</code> this is the name of the kernel function for the kernel estimator (the default is <code>"gaussian"</code>, see <code><a href="stats.html#topic+density">density</a></code>);
or a kernel function for the adaptive-kernel estimator (the default is <code>dnorm</code>, producing the Gaussian kernel).
For <code>adaptivekernel</code> this is a kernel function, defaulting to <code>dnorm</code>, which is the Gaussian kernel (standard-normal density).</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_xlim">xlim</code>, <code id="densityPlot_+3A_ylim">ylim</code></td>
<td>
<p>axis limits; if missing, determined from the range of x-values at which the densities are estimated and the estimated densities.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_normalize">normalize</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), the estimated densities are rescaled to integrate approximately to 1; particularly useful if the
density is estimated over a restricted domain, as when <code>from</code> or <code>to</code> are specified.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_xlab">xlab</code></td>
<td>
<p>label for the horizontal-axis; defaults to the name of the variable <code>x</code>.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_ylab">ylab</code></td>
<td>
<p>label for the vertical axis; defaults to <code>"Density"</code>.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_main">main</code></td>
<td>
<p>plot title; default is empty.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_col">col</code></td>
<td>
<p>vector of colors for the density estimate(s); defaults to the color <code><a href="car.html#topic+carPalette">carPalette</a></code>.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_lty">lty</code></td>
<td>
<p>vector of line types for the density estimate(s); defaults to the successive integers, starting at 1.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_lwd">lwd</code></td>
<td>
<p>line width for the density estimate(s); defaults to 2.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_grid">grid</code></td>
<td>
<p>if <code>TRUE</code> (the default), grid lines are drawn on the plot.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_legend">legend</code></td>
<td>
<p>a list of up to two named elements: <code>location</code>, for the legend when densities are plotted for several groups, defaults to
<code>"upperright"</code> (see <code><a href="graphics.html#topic+legend">legend</a></code>); and <code>title</code> of the legend, which defaults to the name of the grouping factor. If <code>TRUE</code>,
the default, the default values are used; if <code>FALSE</code>, the legend is suppressed.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_n">n</code></td>
<td>
<p>number of equally spaced points at which the adaptive-kernel estimator is evaluated; the default is <code>500</code>.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_from">from</code>, <code id="densityPlot_+3A_to">to</code>, <code id="densityPlot_+3A_cut">cut</code></td>
<td>
<p>the range over which the density estimate is computed; the default, if missing, is <code>min(x) - cut*bw, max(x) + cut*bw</code>.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_na.rm">na.rm</code></td>
<td>
<p>remove missing values from <code>x</code> in computing the adaptive-kernel estimate? The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_show.bw">show.bw</code></td>
<td>
<p>if <code>TRUE</code>, show the bandwidth(s) in the horizontal-axis label or (for multiple groups)
the legend; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_rug">rug</code></td>
<td>
<p>if <code>TRUE</code> (the default), draw a rug plot (one-dimentional scatterplot) at the bottom of the density estimate.</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_...">...</code></td>
<td>
<p>arguments to be passed down to graphics functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you use a different kernel function than the default <code>dnorm</code> that has a
standard deviation different from 1 along with an automatic rule
like the default function <code>bw.nrd0</code>, you can attach an attribute to the kernel
function named <code>"scale"</code> that gives its standard deviation. This is true for
the two supplied kernels, <code>depan</code> and <code>dbiwt</code>
</p>


<h3>Value</h3>

<p><code>densityPlot</code> invisibly returns the <code>"density"</code> object computed (or list of <code>"density"</code> objects) and draws a graph.
<code>adaptiveKernel</code> returns an object of class <code>"density"</code>
(see <code><a href="stats.html#topic+density">density</a>)</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>W. N. Venables and B. D. Ripley (2002) <em>Modern Applied Statistics with S</em>. New York: Springer.
</p>
<p>B.W. Silverman (1986) <em>Density Estimation for Statistics and Data Analysis</em>. London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>, <code><a href="stats.html#topic+bw.SJ">bw.SJ</a></code>, <code><a href="stats.html#topic+plot.density">plot.density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>densityPlot(~ income, show.bw=TRUE, method="kernel", data=Prestige)
densityPlot(~ income, show.bw=TRUE, data=Prestige)
densityPlot(~ income, from=0, normalize=TRUE, show.bw=TRUE, data=Prestige)

densityPlot(income ~ type, data=Prestige)
densityPlot(~ income, show.bw=TRUE, method="kernel", data=Prestige)
densityPlot(~ income, show.bw=TRUE, data=Prestige)
densityPlot(~ income, from=0, normalize=TRUE, show.bw=TRUE, data=Prestige)

densityPlot(income ~ type, kernel=depan, data=Prestige)
densityPlot(income ~ type, kernel=depan, legend=list(location="top"), data=Prestige)

plot(adaptiveKernel(UN$infantMortality, from=0, adjust=0.75), col="magenta")
lines(density(na.omit(UN$infantMortality), from=0, adjust=0.75), col="blue")
rug(UN$infantMortality, col="cyan")
legend("topright", col=c("magenta", "blue"), lty=1,
       legend=c("adaptive kernel", "kernel"), inset=0.02)


plot(adaptiveKernel(UN$infantMortality, from=0, adjust=0.75), col="magenta")
lines(density(na.omit(UN$infantMortality), from=0, adjust=0.75), col="blue")
rug(UN$infantMortality, col="cyan")
legend("topright", col=c("magenta", "blue"), lty=1,
       legend=c("adaptive kernel", "kernel"), inset=0.02)

</code></pre>

<hr>
<h2 id='dfbetaPlots'>dfbeta and dfbetas Index Plots</h2><span id='topic+dfbetaPlots'></span><span id='topic+dfbetasPlots'></span><span id='topic+dfbetaPlots.lm'></span><span id='topic+dfbetasPlots.lm'></span>

<h3>Description</h3>

<p>These functions display index plots of dfbeta (effect on coefficients of deleting
each observation in turn) and dfbetas (effect on coefficients of deleting each observation
in turn, standardized by a deleted estimate of the coefficient standard error). In the
plot of dfbeta, horizontal lines are drawn at 0 and +/- one standard error; in the plot
of dfbetas, horizontal lines are drawn and 0 and +/- 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfbetaPlots(model, ...)

dfbetasPlots(model, ...)

## S3 method for class 'lm'
dfbetaPlots(model, terms= ~ ., intercept=FALSE, layout=NULL, ask, 
	    main, xlab, ylab, labels=rownames(dfbeta), 
        id.method="y",  
        id.n=if(id.method[1]=="identify") Inf else 0, id.cex=1,
        id.col=carPalette()[1], id.location="lr", col=carPalette()[1], grid=TRUE, ...)

## S3 method for class 'lm'
dfbetasPlots(model, terms=~., intercept=FALSE, layout=NULL, ask, 
	    main, xlab, ylab,
        labels=rownames(dfbetas), id.method="y",
        id.n=if(id.method[1]=="identify") Inf else 0, id.cex=1, 
        id.col=carPalette()[1], id.location="lr", col=carPalette()[1], grid=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfbetaPlots_+3A_model">model</code></td>
<td>
<p>model object produced by <code>lm</code> or <code>glm</code>.
</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_terms">terms</code></td>
<td>
<p> A one-sided formula that specifies a subset of the terms in the model. 
One dfbeta or dfbetas plot is drawn for each regressor.  The default
<code>~.</code> is to plot against all terms in the model with the exception of an intercept.  For example, the
specification <code>terms = ~.-X3</code> would plot against all terms
except for <code>X3</code>.  If this argument is a quoted name of one of the terms, the 
index plot is drawn for that term only.
</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_intercept">intercept</code></td>
<td>
<p>Include the intercept in the plots; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_layout">layout</code></td>
<td>
 
<p>If set to a value like <code>c(1, 1)</code> or <code>c(4, 3)</code>, the layout
of the graph will have this many rows and columns.  If not set, the program
will select an appropriate layout.  If the number of graphs exceed nine, you 
must select the layout yourself, or you will get a maximum of nine per page.
If <code>layout=NA</code>, the function does not set the layout and the user can
use the <code>par</code> function to control the layout, for example to have 
plots from two models in the same graphics window.
</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_main">main</code></td>
<td>
<p>The title of the graph; if missing, one will be supplied.
</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_xlab">xlab</code></td>
<td>
<p>Horizontal axis label; defaults to <code>"Index"</code>.</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_ylab">ylab</code></td>
<td>
<p>Vertical axis label; defaults to coefficient name.</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, ask the user before drawing the next plot; if <code>FALSE</code>, the default, don't ask.
</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_...">...</code></td>
<td>
<p>optional additional arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+points">points</a></code>, and <code><a href="car.html#topic+showLabels">showLabels</a></code></p>
</td></tr></table>
<p>. 
</p>
<table>
<tr><td><code id="dfbetaPlots_+3A_id.method">id.method</code>, <code id="dfbetaPlots_+3A_labels">labels</code>, <code id="dfbetaPlots_+3A_id.n">id.n</code>, <code id="dfbetaPlots_+3A_id.cex">id.cex</code>, <code id="dfbetaPlots_+3A_id.col">id.col</code>, <code id="dfbetaPlots_+3A_id.location">id.location</code></td>
<td>
<p>Arguments for the labelling of
points.  The default is <code>id.n=0</code> for labeling no points.  See
<code><a href="car.html#topic+showLabels">showLabels</a></code> for details of these arguments.
</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_col">col</code></td>
<td>
<p>color for points; defaults to the first entry in the color <code><a href="car.html#topic+carPalette">carPalette</a></code>.</p>
</td></tr>
<tr><td><code id="dfbetaPlots_+3A_grid">grid</code></td>
<td>
<p>If <code>TRUE</code>, the default, a light-gray background grid is put on the
graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. These functions are used for their side effect: producing
plots.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dfbeta">dfbeta</a></code> ,<code><a href="stats.html#topic+dfbetas">dfbetas</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dfbetaPlots(lm(prestige ~ income + education + type, data=Duncan))

dfbetasPlots(glm(partic != "not.work" ~ hincome + children, 
  data=Womenlf, family=binomial))
</code></pre>

<hr>
<h2 id='durbinWatsonTest'>Durbin-Watson Test for Autocorrelated Errors</h2><span id='topic+durbinWatsonTest'></span><span id='topic+dwt'></span><span id='topic+durbinWatsonTest.lm'></span><span id='topic+durbinWatsonTest.default'></span><span id='topic+print.durbinWatsonTest'></span>

<h3>Description</h3>

<p>Computes residual autocorrelations and generalized Durbin-Watson
statistics and their bootstrapped p-values. <code>dwt</code> is an
abbreviation for <code>durbinWatsonTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>durbinWatsonTest(model, ...)

dwt(...)

## S3 method for class 'lm'
durbinWatsonTest(model, max.lag=1, simulate=TRUE, reps=1000,
    method=c("resample","normal"),
    alternative=c("two.sided", "positive", "negative"), ...)

## Default S3 method:
durbinWatsonTest(model, max.lag=1, ...)

## S3 method for class 'durbinWatsonTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="durbinWatsonTest_+3A_model">model</code></td>
<td>
<p>a linear-model object, or a vector of residuals from a linear model.</p>
</td></tr>
<tr><td><code id="durbinWatsonTest_+3A_max.lag">max.lag</code></td>
<td>
<p>maximum lag to which to compute residual autocorrelations
and Durbin-Watson statistics.</p>
</td></tr>
<tr><td><code id="durbinWatsonTest_+3A_simulate">simulate</code></td>
<td>
<p>if <code>TRUE</code> p-values will be estimated by bootstrapping.</p>
</td></tr>
<tr><td><code id="durbinWatsonTest_+3A_reps">reps</code></td>
<td>
<p>number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="durbinWatsonTest_+3A_method">method</code></td>
<td>
<p>bootstrap method: <code>"resample"</code> to resample from the observed
residuals; <code>"normal"</code> to sample normally distributed errors with 0 mean
and standard deviation equal to the standard error of the regression.</p>
</td></tr>
<tr><td><code id="durbinWatsonTest_+3A_alternative">alternative</code></td>
<td>
<p>sign of autocorrelation in alternative hypothesis; specify
only if <code>max.lag = 1</code>; if <code>max.lag &gt; 1</code>, then <code>alternative</code> is
taken to be <code>"two.sided"</code>.</p>
</td></tr>
<tr><td><code id="durbinWatsonTest_+3A_...">...</code></td>
<td>
<p>arguments to be passed down.</p>
</td></tr>
<tr><td><code id="durbinWatsonTest_+3A_x">x</code></td>
<td>
<p><code>durbinWatsonTest</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of type <code>"durbinWatsonTest"</code>.
</p>


<h3>Note</h3>

<p>p-values are available only from the <code>lm</code> method.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

 
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>, Third Edition. Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>durbinWatsonTest(lm(fconvict ~ tfr + partic + degrees + mconvict, data=Hartnagel))
</code></pre>

<hr>
<h2 id='Ellipses'>Ellipses, Data Ellipses, and Confidence Ellipses</h2><span id='topic+ellipse'></span><span id='topic+dataEllipse'></span><span id='topic+confidenceEllipse'></span><span id='topic+confidenceEllipse.default'></span><span id='topic+confidenceEllipse.lm'></span><span id='topic+confidenceEllipse.glm'></span><span id='topic+confidenceEllipse.mlm'></span><span id='topic+confidenceEllipses'></span><span id='topic+confidenceEllipses.default'></span><span id='topic+confidenceEllipses.mlm'></span>

<h3>Description</h3>

<p>These functions draw ellipses, including data ellipses, and
confidence ellipses for linear, generalized linear, and possibly other models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse(center, shape, radius, log="", center.pch=19, center.cex=1.5, 
  segments=51, draw=TRUE, add=draw, xlab="", ylab="", 
  col=carPalette()[2], lwd=2, fill=FALSE, fill.alpha=0.3, grid=TRUE, ...)

dataEllipse(x, y, groups, group.labels=group.levels, ellipse.label,
  weights, log="", levels=c(0.5, 0.95), center.pch=19, 
  center.cex=1.5, draw=TRUE, plot.points=draw, add=!plot.points, segments=51, 
  robust=FALSE, xlab=deparse(substitute(x)), ylab=deparse(substitute(y)), 
  col=if (missing(groups)) carPalette()[1:2] else carPalette()[1:length(group.levels)],
  pch=if (missing(groups)) 1 else seq(group.levels),
  lwd=2, fill=FALSE, fill.alpha=0.3, grid=TRUE, id=FALSE, ...) 

confidenceEllipse(model, ...)

## S3 method for class 'lm'
confidenceEllipse(model, which.coef, vcov.=vcov, 
  L, levels=0.95, Scheffe=FALSE, dfn,
  center.pch=19, center.cex=1.5, segments=51, xlab, ylab, 
  col=carPalette()[2], lwd=2, fill=FALSE, fill.alpha=0.3, draw=TRUE, add=!draw,
  grid=TRUE, ...)
  
## S3 method for class 'glm'
confidenceEllipse(model, chisq, ...)

## S3 method for class 'mlm'
confidenceEllipse(model, xlab, ylab, which.coef=1:2, ...)

## Default S3 method:
confidenceEllipse(model, which.coef, vcov.=vcov,
  L, levels=0.95, Scheffe=FALSE,  dfn,
  center.pch=19, center.cex=1.5, segments=51, xlab, ylab, 
  col=carPalette()[2], lwd=2, fill=FALSE, fill.alpha=0.3, draw=TRUE, add=!draw, 
  grid=TRUE, ...)
  
confidenceEllipses(model, ...)

## Default S3 method:
confidenceEllipses(model, coefnames,  main, grid=TRUE, ...)

## S3 method for class 'mlm'
confidenceEllipses(model, coefnames, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ellipses_+3A_center">center</code></td>
<td>
<p>2-element vector with coordinates of center of ellipse.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_shape">shape</code></td>
<td>
<p><code class="reqn">2\times 2</code> shape (or covariance) matrix.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_radius">radius</code></td>
<td>
<p>radius of circle generating the ellipse.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_log">log</code></td>
<td>
<p>when an ellipse is to be added to an existing plot, indicates
whether computations were on logged values and to be plotted on logged
axes; <code>"x"</code> if the x-axis is logged, <code>"y"</code> if the y-axis is
logged, and <code>"xy"</code> or <code>"yx"</code> if both axes are logged. The
default is <code>""</code>, indicating that neither axis is logged.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_center.pch">center.pch</code></td>
<td>
<p>character for plotting ellipse center; if <code>FALSE</code> or <code>NULL</code> the center point isn't plotted.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_center.cex">center.cex</code></td>
<td>
<p>relative size of character for plotting ellipse center.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_segments">segments</code></td>
<td>
<p>number of line-segments used to draw ellipse.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_draw">draw</code></td>
<td>
<p>if <code>TRUE</code> produce graphical output; if <code>FALSE</code>, only invisibly return coordinates of ellipse(s).</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code> add ellipse(s) to current plot.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_xlab">xlab</code></td>
<td>
<p>label for horizontal axis.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_ylab">ylab</code></td>
<td>
<p>label for vertical axis.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_x">x</code></td>
<td>
<p>a numeric vector, or (if <code>y</code> is missing) a 2-column numeric matrix.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_y">y</code></td>
<td>
<p>a numeric vector, of the same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_groups">groups</code></td>
<td>
<p>optional: a factor to divide the data into groups; a separate ellipse will be plotted for each group (level of the factor).</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_group.labels">group.labels</code></td>
<td>
<p>labels to be plotted for the groups; by default, the levels of the <code>groups</code> factor.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_ellipse.label">ellipse.label</code></td>
<td>
<p>a label for the ellipse(s) or a vector of labels; if several ellipses are drawn and just one label is given,
then that label will be repeated. The default is not to label the ellipses.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights, of the same length as <code>x</code> and <code>y</code> to be used  by <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>
or <code><a href="MASS.html#topic+cov.trob">cov.trob</a></code> in computing a weighted covariance matrix; if absent, weights of <code>1</code> are used.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_plot.points">plot.points</code></td>
<td>
<p>if <code>FALSE</code> data ellipses are drawn,
but points are not plotted.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_levels">levels</code></td>
<td>
<p>draw elliptical contours at these (normal) probability or confidence levels.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_robust">robust</code></td>
<td>
<p>if <code>TRUE</code> use the <code>cov.trob</code> function in the <span class="pkg">MASS</span> package
to calculate the center and covariance matrix for the data ellipse.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_model">model</code></td>
<td>
<p>a model object produced by <code>lm</code> or <code>glm</code>.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_which.coef">which.coef</code></td>
<td>
<p>2-element vector giving indices of coefficients to plot; 
if missing, the first two coefficients (disregarding the regression constant)
will be selected.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_vcov.">vcov.</code></td>
<td>
<p>a coefficient-covariance matrix or a function (such as <code><a href="car.html#topic+hccm">hccm</a></code>) to 
compute the coefficent-covariance
matrix from <code>model</code>; the default is the <code>vcov</code> function.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_l">L</code></td>
<td>
<p>As an alternative to selecting coefficients to plot, a transformation matrix can be specified to compute two
linear combinations of the coefficients; if the <code>L</code> matrix is given, it takes precedence over the <code>which.coef</code>
argument. <code>L</code> should have two rows and as many columns as there are coefficients. It can be given directly as a
numeric matrix, or specified by a pair of character-valued expressions, in the same manner as for the 
<code>link{linearHypothesis}</code> function, but with no right-hand side.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_scheffe">Scheffe</code></td>
<td>
<p>if <code>TRUE</code> scale the ellipse so that its projections onto the
axes give Scheffe confidence intervals for the coefficients.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_dfn">dfn</code></td>
<td>
<p>&ldquo;numerator&rdquo; degrees of freedom (or just degrees of freedom for a GLM) for
drawing the confidence ellipse. Defaults to the number of coefficients in the model (disregarding the constant) if 
<code>Scheffe</code> is <code>TRUE</code>, or to <code>2</code> otherwise; selecting <code>dfn = 1</code> will 
draw the &ldquo;confidence-interval generating&rdquo; ellipse, with projections on the axes
corresponding to individual confidence intervals with the stated level of coverage.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_chisq">chisq</code></td>
<td>
<p>if <code>TRUE</code>, the confidence ellipse for the coefficients in a generalized linear model are
based on the chisquare statistic, if <code>FALSE</code> on the $F$-statistic. This corresponds to using the default
and linear-model methods respectively.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_col">col</code></td>
<td>
<p>color for lines and ellipse center; the default is the <em>second</em> entry
in the current <span class="pkg">car</span> palette (see <code><a href="car.html#topic+carPalette">carPalette</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>). For <code>dataEllipse</code>, two colors can be given, in
which case the first is for plotted points and the second for lines and the ellipse center;
if ellipses are plotted for <code>groups</code>, then this is a vector of colors for the groups.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_pch">pch</code></td>
<td>
<p>for <code>dataEllipse</code> this is the plotting character (default, symbol <code>1</code>, a hollow circle)
to use for the points; if ellipses are plotted by <code>groups</code>, then this a vector of plotting characters,
with consecutive symbols starting with <code>1</code> as the default.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>2</code> (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_fill">fill</code></td>
<td>
<p>fill the ellipse with translucent color <code>col</code> (default, <code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>transparency of fill (default = <code>0.3</code>).</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_...">...</code></td>
<td>
<p>other plotting parameters to be passed to <code>plot</code> and
<code>line</code>.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method="mahal", n=2, cex=1, col=carPalette()[1], location="lr")</code>
(with the default <code>col</code> actually dependent on the number of groups),
which identifies the 2 points with the largest Mahalanobis distances from the center of the data.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_coefnames">coefnames</code></td>
<td>
<p>character vector of coefficient names to use to label the diagonal of the pairwise confidence ellipse matrix plotted by <code>confidenceEllipses</code>; defaults to the names of the coefficients in the model.</p>
</td></tr>
<tr><td><code id="Ellipses_+3A_main">main</code></td>
<td>
<p>title for matrix of pairwise confidence ellipses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ellipse is computed by suitably transforming a unit circle.
</p>
<p><code>dataEllipse</code> superimposes the normal-probability contours over a scatterplot
of the data.
</p>
<p><code>confidenceEllipses</code> plots a matrix of all pairwise confidence ellipses; each panel of the matrix is created by <code>confidenceEllipse</code>.
</p>


<h3>Value</h3>

<p>These functions are mainly used for their side effect of producing plots.  For
greater flexibility (e.g., adding plot annotations), however, <code>ellipse</code> returns invisibly the (x, y) coordinates of the calculated ellipse.
<code>dataEllipse</code> and <code>confidenceEllipse</code> return invisibly the  coordinates of one or more ellipses, in the latter instance a list named by
<code>levels</code>; <code>confidenceEllipses</code> invisibly returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Georges Monette, John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, and Michael Friendly.</p>


<h3>References</h3>

 
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Monette, G. (1990)
Geometry of multiple regression and 3D graphics.
In Fox, J. and Long, J. S. (Eds.) 
<em>Modern Methods of Data Analysis.</em> Sage.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+cov.trob">cov.trob</a></code>, <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>, <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataEllipse(Duncan$income, Duncan$education, levels=0.1*1:9, 
    ellipse.label=0.1*1:9, lty=2, fill=TRUE, fill.alpha=0.1)
    
confidenceEllipse(lm(prestige ~ income + education, data=Duncan), Scheffe=TRUE)

confidenceEllipse(lm(prestige ~ income + education, data=Duncan), vcov.=hccm)

confidenceEllipse(lm(prestige ~ income + education, data=Duncan), 
	L=c("income + education", "income - education"))
	
confidenceEllipses(lm(prestige ~ income + education + type, data=Duncan),
  fill=TRUE)
cov2cor(vcov(lm(prestige ~ income + education + type, 
  data=Duncan))) # correlations among coefficients

wts &lt;- rep(1, nrow(Duncan))
wts[c(6, 16)] &lt;- 0 # delete Minister, Conductor
with(Duncan, {
	dataEllipse(income, prestige, levels=0.68)
	dataEllipse(income, prestige, levels=0.68, robust=TRUE, 
	    plot.points=FALSE, col="green3")
	dataEllipse(income, prestige, weights=wts, levels=0.68, 
	    plot.points=FALSE, col="brown")
	dataEllipse(income, prestige, weights=wts, robust=TRUE, levels=0.68, 
		plot.points=FALSE, col="blue")
	})
    
with(Prestige, dataEllipse(income, education, type, 
    id=list(n=2, labels=rownames(Prestige)), pch=15:17,
    xlim=c(0, 25000), center.pch="+",
    group.labels=c("Blue Collar", "Professional", "White Collar"),
    ylim=c(5, 20), level=.95, fill=TRUE, fill.alpha=0.1))
</code></pre>

<hr>
<h2 id='Export'>
Export a data frame to disk in one of many formats
</h2><span id='topic+Export'></span>

<h3>Description</h3>

<p>Uses the <code>export</code> function in the <span class="pkg">rio</span> package to export a file to disk.  This function adds an argument for converting row.names to a column in the resulting file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Export(x, file, format, ..., keep.row.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Export_+3A_x">x</code></td>
<td>

<p>A data frame or matrix to be written to a file.
</p>
</td></tr>
<tr><td><code id="Export_+3A_file">file</code></td>
<td>

<p>A character string naming a file. If the file name has an extension, such as <code>.xlsx</code>, the extention is used to infer the type of file to be exported.  See <code><a href="rio.html#topic+export">export</a></code> for the file types supported.
</p>
</td></tr>
<tr><td><code id="Export_+3A_format">format</code></td>
<td>
<p>see <code><a href="rio.html#topic+export">export</a></code>.
</p>
</td></tr>
<tr><td><code id="Export_+3A_...">...</code></td>
<td>

<p>Additional arguments; see <code><a href="rio.html#topic+export">export</a></code>.
</p>
</td></tr>
<tr><td><code id="Export_+3A_keep.row.names">keep.row.names</code></td>
<td>

<p>If set to <code>TRUE</code>, then the data frame's row.names are appended to the left of the data frame with the name &quot;id&quot;.  If set to quoted character string, the row.names are added using the character string as its name.  If set to <code>FALSE</code> row.names are lost.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function in the <span class="pkg">car</span> package for exporting (writing) a data frame to a file in a wide variety of formats including csv, Microsoft Excel.  It optionally allows converting the row.names for the data frame to a column before writing.  It then calls <code><a href="rio.html#topic+export">export</a></code> in the <code>rio</code> package.  That function in turn uses many other packages and functions for writing the function to a file.
</p>


<h3>Value</h3>

<p>The name of the output file as a character string (invisibly).
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg <a href="mailto:sandy@umn.edu">sandy@umn.edu</a></p>


<h3>References</h3>

<p>Chung-hong Chan, Geoffrey CH Chan, Thomas J. Leeper, and Jason Becker (2017). rio: A
Swiss-army knife for data file I/O. R package version 0.5.0.
</p>


<h3>See Also</h3>

<p><code><a href="rio.html#topic+export">export</a></code>, <code><a href="car.html#topic+Import">Import</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("rio")) {

Export(Duncan, "Duncan.csv", keep.row.names="occupation")
Duncan2 &lt;- Import("Duncan.csv") # Automatically restores row.names
identical(Duncan, Duncan2)
# cleanup
unlink("Duncan.csv")

}
</code></pre>

<hr>
<h2 id='hccm'>Heteroscedasticity-Corrected Covariance Matrices</h2><span id='topic+hccm'></span><span id='topic+hccm.lm'></span><span id='topic+hccm.default'></span>

<h3>Description</h3>

<p>Calculates heteroscedasticity-corrected covariance matrices 
linear models fit by least squares or weighted least squares. 
These are also called &ldquo;White-corrected&rdquo; or &ldquo;White-Huber&rdquo;
covariance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hccm(model, ...)

## S3 method for class 'lm'
hccm(model, type=c("hc3", "hc0", "hc1", "hc2", "hc4"), 
	singular.ok=TRUE, ...)

## Default S3 method:
hccm(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hccm_+3A_model">model</code></td>
<td>
<p>a unweighted or weighted linear model, produced by <code>lm</code>.</p>
</td></tr>
<tr><td><code id="hccm_+3A_type">type</code></td>
<td>
<p>one of <code>"hc0"</code>, <code>"hc1"</code>, <code>"hc2"</code>, <code>"hc3"</code>, or <code>"hc4"</code>; the
first of these gives the classic White correction. The <code>"hc1"</code>, <code>"hc2"</code>, and <code>"hc3"</code>
corrections are described in Long and Ervin (2000); <code>"hc4"</code> is described in Cribari-Neto (2004).</p>
</td></tr>
<tr><td><code id="hccm_+3A_singular.ok">singular.ok</code></td>
<td>
<p>if <code>FALSE</code> (the default is <code>TRUE</code>), a model with aliased coefficients
produces an error; otherwise, the aliased coefficients are ignored in the coefficient covariance
matrix that's returned.</p>
</td></tr>
<tr><td><code id="hccm_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code>hccm.lm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original White-corrected coefficient covariance matrix (<code>"hc0"</code>) for an unweighted model is
</p>
<p style="text-align: center;"><code class="reqn">V(b)=(X^{\prime }X)^{-1}X^{\prime }diag(e_{i}^{2})X(X^{\prime }X)^{-1}</code>
</p>

<p>where <code class="reqn">e_{i}^{2}</code> are the squared residuals, and <code class="reqn">X</code> is the model
matrix. The other methods represent adjustments to this formula. If there are weights, these are incorporated in the
corrected covariance matrix.
</p>
<p>The function <code>hccm.default</code> simply catches non-<code>lm</code> objects.
</p>
<p>See Freedman (2006) and Fox and Weisberg (2019, Sec. 5.1.2) for discussion of the use of these methods in generalized linear models or models with nonconstant variance.
</p>


<h3>Value</h3>

<p>The heteroscedasticity-corrected covariance matrix for the model.
</p>
<p>The function will return an error, rather than a matrix, under two circumstances.  First, if any of the cases have hatvalue (leverage) equal to one, then the corresponding fitted value will always equal the observed value.  For types hc2, hc3 and hc4 the hccm matrix is undefined.  For hc0 and hc1 it is defined but it can be shown to be singular, and therefore not a consistent estimate of the covariance matrix of the coefficient estimates.  A singular estimate of the covariance matrix may also be obstained if the matrix <code class="reqn">X</code> is ill-conditioned.  In this latter case rescaling the model matrix may give a full-rank estimate. 
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Cribari-Neto, F. (2004)
Asymptotic inference under heteroskedasticity of unknown form.
<em>Computational Statistics and Data Analysis</em> <b>45</b>, 215&ndash;233.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Freedman, D. (2006)
On the so-called &quot;Huber sandwich estimator&quot; and &quot;robust standard errors&quot;,
<em>American Statistician</em>, <b>60</b>, 299&ndash;302.
</p>
<p>Long, J. S. and Ervin, L. H. (2000)
Using heteroscedasity consistent standard errors in the linear regression model. 
<em>The American Statistician</em> <b>54</b>, 217&ndash;224.
</p>
<p>White, H. (1980)
A heteroskedastic consistent covariance matrix estimator and a direct test of heteroskedasticity.
<em>Econometrica</em> <b>48</b>, 817&ndash;838.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(interlocks ~ assets + nation, data=Ornstein)
print(vcov(mod), digits=4)
##             (Intercept)     assets  nationOTH   nationUK   nationUS
## (Intercept)   1.079e+00 -1.588e-05 -1.037e+00 -1.057e+00 -1.032e+00
## assets       -1.588e-05  1.642e-09  1.155e-05  1.362e-05  1.109e-05
## nationOTH    -1.037e+00  1.155e-05  7.019e+00  1.021e+00  1.003e+00
## nationUK     -1.057e+00  1.362e-05  1.021e+00  7.405e+00  1.017e+00
## nationUS     -1.032e+00  1.109e-05  1.003e+00  1.017e+00  2.128e+00

print(hccm(mod), digits=4)             
##             (Intercept)     assets  nationOTH   nationUK   nationUS
## (Intercept)   1.664e+00 -3.957e-05 -1.569e+00 -1.611e+00 -1.572e+00
## assets       -3.957e-05  6.752e-09  2.275e-05  3.051e-05  2.231e-05
## nationOTH    -1.569e+00  2.275e-05  8.209e+00  1.539e+00  1.520e+00
## nationUK     -1.611e+00  3.051e-05  1.539e+00  4.476e+00  1.543e+00
## nationUS     -1.572e+00  2.231e-05  1.520e+00  1.543e+00  1.946e+00
</code></pre>

<hr>
<h2 id='hist.boot'>
Methods Functions to Support <code>boot</code> Objects
</h2><span id='topic+hist.boot'></span><span id='topic+summary.boot'></span><span id='topic+confint.boot'></span><span id='topic+vcov.boot'></span><span id='topic+Confint.boot'></span>

<h3>Description</h3>

<p>The <code>Boot</code> function in the <span class="pkg">car</span> package uses the <code><a href="boot.html#topic+boot">boot</a></code> function from the
<span class="pkg">boot</span> package to do a straightforward case
or residual bootstrap for many regression objects.  These are method functions for standard generics to summarize the results of the bootstrap.  Other tools for this purpose are available in the <code>boot</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot'
hist(x, parm, layout = NULL, ask, main = "", freq = FALSE,
    estPoint = TRUE, point.col = carPalette()[1], point.lty = 2, point.lwd = 2,
    estDensity = !freq, den.col = carPalette()[2], den.lty = 1, den.lwd = 2,
    estNormal = !freq, nor.col = carPalette()[3], nor.lty = 2, nor.lwd = 2,
    ci = c("bca", "none", "perc", "norm"), level = 0.95, 
    legend = c("top", "none", "separate"), box = TRUE, ...)

## S3 method for class 'boot'
summary(object, parm, high.moments = FALSE, extremes = FALSE, ...)

## S3 method for class 'boot'
confint(object, parm, level = 0.95, type = c("bca", "norm",
    "basic", "perc"), ...)

## S3 method for class 'boot'
Confint(object, parm, level = 0.95, type = c("bca", "norm",
    "basic", "perc"), ...)

## S3 method for class 'boot'
vcov(object, use="complete.obs", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.boot_+3A_x">x</code>, <code id="hist.boot_+3A_object">object</code></td>
<td>

<p>An object created by a call to <code>boot</code> in the <code>boot</code> package, or to <code>Boot</code> in the <span class="pkg">car</span> package of class <code>"boot"</code>.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_parm">parm</code></td>
<td>

<p>A vector of numbers or coefficient names giving the coefficients for which a
histogram or confidence interval is desired.  If numbers are used, 1 corresponds to the intercept,
if any.  The default is all coefficients.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_layout">layout</code></td>
<td>

<p>If set to a value like <code>c(1, 1)</code> or <code>c(4, 3)</code>, the layout
of the graph will have this many rows and columns.  If not set, the program
will select an appropriate layout.  If the number of graphs exceed nine, you
must select the layout yourself, or you will get a maximum of nine per page.
If <code>layout=NA</code>, the function does not set the layout and the user can
use the <code>par</code> function to control the layout, for example to have
plots from two models in the same graphics window.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_ask">ask</code></td>
<td>

<p>If <code>TRUE</code>, ask the user before drawing the next plot; if <code>FALSE</code>, don't
ask.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_main">main</code></td>
<td>

<p>Main title for the graphs.  The default is <code>main=""</code> for no title.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_freq">freq</code></td>
<td>

<p>The default for the generic <code>hist</code> function is <code>freq=TRUE</code> to give a frequency histogram.  The default for <code>hist.boot</code> is <code>freq=FALSE</code> to give a density histogram.  A density estimate and/or a fitted normal density can be added to the graph if <code>freq=FALSE</code> but not if <code>freq=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_estpoint">estPoint</code>, <code id="hist.boot_+3A_point.col">point.col</code>, <code id="hist.boot_+3A_point.lty">point.lty</code>, <code id="hist.boot_+3A_point.lwd">point.lwd</code></td>
<td>

<p>If <code>estPoint=TRUE</code>, the default, a vertical line is drawn on the histgram
at the value of the point estimate computed from the complete data. The
remaining three optional arguments set the color, line type and line width
of the line that is drawn.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_estdensity">estDensity</code>, <code id="hist.boot_+3A_den.col">den.col</code>, <code id="hist.boot_+3A_den.lty">den.lty</code>, <code id="hist.boot_+3A_den.lwd">den.lwd</code></td>
<td>

<p>If <code>estDensity=TRUE</code> and<code>freq=FALSE</code>, the default, a kernel density estimate is drawn
on the plot with a call to the <code>density</code> function with no additional
arguments. The
remaining three optional arguments set the color, line type and line width
of the lines that are drawn.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_estnormal">estNormal</code>, <code id="hist.boot_+3A_nor.col">nor.col</code>, <code id="hist.boot_+3A_nor.lty">nor.lty</code>, <code id="hist.boot_+3A_nor.lwd">nor.lwd</code></td>
<td>

<p>If <code>estNormal=TRUE</code> and<code>freq=FALSE</code>, the default, a normal density
with mean and sd computed from the data is drawn on the plot. The
remaining three optional arguments set the color, line type and line width
of the lines that are drawn.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_ci">ci</code></td>
<td>

<p>A confidence interval based on the bootstrap will be added to the histogram
using the BCa method if <code>ci="bca"</code> the percentile method if
<code>ci="perc"</code>, or the normal method if <code>ci="norm"</code>.  No interval is drawn if
<code>ci="none"</code>.  The default is <code>"bca"</code>.  The interval is indicated
by a thick horizontal line at <code>y=0</code>.  For some bootstraps the BCa method is unavailable, in which case a warning is issued and <code>ci="perc"</code> is substituted.  If you wish to see all the options at once, see <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>.  The normal method is computed as the (estimate from the original data) minus the bootstrap bias plus or minus the standard deviation of the bootstrap replicates times the appropriate quantile of the standard normal distribution.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_legend">legend</code></td>
<td>

<p>A legend can be added to the (array of) histograms.  The value &ldquo;top&rdquo;
puts at the top-left of the plots.  The value &ldquo;separate&rdquo; puts the legend in its own graph following all the histograms.  The value &ldquo;none&rdquo;
suppresses the legend.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_box">box</code></td>
<td>

<p>Add a box around each histogram.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>hist</code>; for other methods this is included for compatibility with the generic method.  For example, the argument
<code>border=par()$bg</code> in <code>hist</code> will draw the histogram transparently, leaving only
the density estimates.  With the <code>vcov</code> function, the additional arguments are passed to <code><a href="stats.html#topic+cov">cov</a></code>.  See the Value section, below.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_high.moments">high.moments</code></td>
<td>

<p>Should the skewness and kurtosis be included in the summary?  Default is FALSE.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_extremes">extremes</code></td>
<td>

<p>Should the minimum, maximum and range be included in the summary?  Default is FALSE.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_level">level</code></td>
<td>

<p>Confidence level, a number between 0 and 1.  In <code>confint</code>, <code>level</code> can be
a vector; for example <code>level=c(.50, .90, .95)</code> will return the following estimated quantiles:  <code>c(.025, .05, .25, .75, .95, .975)</code>.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_type">type</code></td>
<td>

<p>Selects the  confidence interval type.  The types
implemented are the <code>"percentile"</code> method, which uses the function
<code>quantile</code> to return the appropriate quantiles for the confidence
limit specified, the default <code>bca</code> which uses the bias-corrected and accelerated
method presented by Efron and Tibshirani (1993, Chapter 14).  For the
other types, see the documentation for <code><a href="boot.html#topic+boot">boot</a></code>.
</p>
</td></tr>
<tr><td><code id="hist.boot_+3A_use">use</code></td>
<td>
<p>The default <code>use="complete.obs"</code> for <code>vcov</code> computes a bootstrap covariance matrix by deleting bootstraps that returned NAs.  Setting <code>use</code> to anything else will result in a matrix of NAs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hist</code> is used for the side-effect of drawing an array of historgams of
each column of the first argument.   <code>summary</code> returns a matrix of
summary statistics for each of the columns in the bootstrap object.  The
<code>confint</code> method returns confidence intervals.  <code>Confint</code> appends the estimates based on the original fitted model to the left of the confidence intervals.
</p>
<p>The function <code>vcov</code> returns the sample covariance of the bootstrap sample estimates, by default skipping any bootstrap samples that returned NA.
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg, <a href="mailto:sandy@umn.edu">sandy@umn.edu</a></p>


<h3>References</h3>

<p>Efron, B. and Tibsharini, R. (1993)
<em>An Introduction to the Bootstrap</em>. New
York: Chapman and Hall.
</p>
<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition.  Thousand Oaks:  Sage.
</p>
<p>Fox, J. and Weisberg, S. (2018) <em>Bootstrapping Regression Models in R</em>,
<a href="https://socialsciences.mcmaster.ca/jfox/Books/Companion/appendices/Appendix-Bootstrapping.pdf">https://socialsciences.mcmaster.ca/jfox/Books/Companion/appendices/Appendix-Bootstrapping.pdf</a>.
</p>
<p>Weisberg, S. (2013) <em>Applied
Linear Regression</em>, Fourth Edition, Wiley
</p>


<h3>See Also</h3>

<p>See Also <code><a href="car.html#topic+Boot">Boot</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>,
<code><a href="stats.html#topic+density">density</a></code>, Fox and Weisberg (2017), cited above </p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lm(Fertility ~ ., swiss)
betahat.boot &lt;- Boot(m1, R=99) # 99 bootstrap samples--too small to be useful
summary(betahat.boot)  # default summary
confint(betahat.boot)
hist(betahat.boot)
</code></pre>

<hr>
<h2 id='Import'>
Import data from many file formats
</h2><span id='topic+Import'></span>

<h3>Description</h3>

<p>Uses the <code>import</code> function from the <span class="pkg">rio</span> package to read a data.frame from a variety of file types.  The <code>Import</code> function includes 2 additional arguments adding row names and for converting character and logical variables to factors for some file types.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Import(file, format, ..., row.names=TRUE,
       stringsAsFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Import_+3A_file">file</code></td>
<td>

<p>A character string naming a file, URL, or .zip or .tar archive.  See the details below.  If the file name has an extension like <code>.xlsx</code> or <code>.csv</code> then the type of file is inferred from the extension.
</p>
</td></tr>
<tr><td><code id="Import_+3A_format">format</code></td>
<td>

<p>If an extension is not present in the file name or it is wrong, the file format can be set with this argument; see <code><a href="rio.html#topic+import">import</a></code>.
</p>
</td></tr>
<tr><td><code id="Import_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code><a href="rio.html#topic+import">import</a></code>.  
</p>
</td></tr>
<tr><td><code id="Import_+3A_row.names">row.names</code></td>
<td>

<p>If <code>TRUE</code>, the default, the left-most character variable that has all unique elements is removed from the data frame and set to be <code>row.names</code>.  To match <code>import</code>, set <code>row.names=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="Import_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>

<p>If <code>TRUE</code>, then character variables that do not have all unique elements are converted to factors. The default is <code>FALSE</code>. Prior to May 2020 the default was determined by <code>getOption("stringsAsFactors")</code>, which then defaulted to <code>TRUE</code>.  This option is <code>FALSE</code> in R 4.0.0 and has been deprecated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls the <code><a href="rio.html#topic+import">import</a></code> function to read a data frame from a file.  Many file types are supported.  For files of type <code>"txt", "csv", "xlsx", "xls"</code> or <code> "ods"</code> the arguments <code>row.names</code> and <code>stringsAsFactors</code> can be used to add row names and convert character variables to factors, respectively.   Many more details are given on the man page for <code>import</code>.
</p>


<h3>Value</h3>

<p>A data frame.  See <code><a href="rio.html#topic+import">import</a></code> for more details
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg <a href="mailto:sandy@umn.edu">sandy@umn.edu</a></p>


<h3>See Also</h3>

<p><code><a href="rio.html#topic+import">import</a></code>, <code><a href="car.html#topic+Export">Export</a></code>, <code><a href="car.html#topic+strings2factors">strings2factors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("rio")) {

head(Duncan, 3) # first three rows
Export(Duncan, "Duncan.csv", keep.row.names="occupation")
Duncan2 &lt;- Import("Duncan.csv") # Automatically restores row.names and factors
brief(Duncan2) 
identical(Duncan, Duncan2) # FALSE because type is of a different class
Duncan3 &lt;- Import("Duncan.csv", stringsAsFactors=TRUE) 
brief(Duncan3) 
identical(Duncan, Duncan3) # TRUE type is of same class
# cleanup
unlink("Duncan.csv")

}
</code></pre>

<hr>
<h2 id='infIndexPlot'>Influence Index Plot</h2><span id='topic+infIndexPlot'></span><span id='topic+influenceIndexPlot'></span><span id='topic+infIndexPlot.lm'></span><span id='topic+infIndexPlot.lmerMod'></span><span id='topic+infIndexPlot.influence.merMod'></span><span id='topic+infIndexPlot.influence.lme'></span>

<h3>Description</h3>

<p>Provides index plots of influence and related diagnostics for a regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infIndexPlot(model, ...)

influenceIndexPlot(model, ...)

## S3 method for class 'lm'
infIndexPlot(model, vars=c("Cook", "Studentized", "Bonf", "hat"),
    id=TRUE, grid=TRUE, main="Diagnostic Plots", ...)

## S3 method for class 'influence.merMod'
infIndexPlot(model,
    vars = c("dfbeta", "dfbetas", "var.cov.comps",
    "cookd"), id = TRUE, grid = TRUE, main = "Diagnostic Plots", ...)
## S3 method for class 'influence.lme'
infIndexPlot(model,
    vars = c("dfbeta", "dfbetas", "var.cov.comps",
    "cookd"), id = TRUE, grid = TRUE, main = "Diagnostic Plots", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infIndexPlot_+3A_model">model</code></td>
<td>
<p>A regression object of class <code>lm</code>, <code>glm</code>, or <code>lmerMod</code>, or an influence
object for a <code>lmer</code>, <code>glmer</code>, or <code>lme</code> object (see
<code><a href="car.html#topic+influence.mixed.models">influence.mixed.models</a></code>). The <code>"lmerMod"</code> method calls the <code>"lm"</code> method and can take the same arguments.</p>
</td></tr>
<tr><td><code id="infIndexPlot_+3A_vars">vars</code></td>
<td>

<p>All the quantities listed in this argument are plotted.  Use <code>"Cook"</code>
for Cook's distances, <code>"Studentized"</code> for Studentized
residuals, <code>"Bonf"</code> for Bonferroni p-values for an outlier test, and
and <code>"hat"</code> for hat-values (or leverages) for a linear or generalized
linear model, or <code>"dfbeta"</code>, <code>"dfbetas"</code>, <code>"var.cov.comps"</code>, and
<code>"cookd"</code> for an influence object derived from a mixed model.   Capitalization is optional.
All but <code>"dfbeta"</code> and <code>"dfbetas"</code> may be abbreviated by the first one or more letters.
</p>
</td></tr>
<tr><td><code id="infIndexPlot_+3A_main">main</code></td>
<td>
<p>main title for graph</p>
</td></tr>
<tr><td><code id="infIndexPlot_+3A_id">id</code></td>
<td>
<p>a list of named values controlling point labelling. The default, <code>TRUE</code>, is
equivalent to <code>id=list(method="y", n=2, cex=1, col=carPalette()[1], location="lr")</code>;
<code>FALSE</code> suppresses point labelling. See <code><a href="car.html#topic+showLabels">showLabels</a></code> for details.</p>
</td></tr>
<tr><td><code id="infIndexPlot_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the graph.</p>
</td></tr>
<tr><td><code id="infIndexPlot_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Used for its side effect of producing a graph.  Produces index plots
of diagnostic quantities.
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg <a href="mailto:sandy@umn.edu">sandy@umn.edu</a> and John Fox</p>


<h3>References</h3>

<p>Cook, R. D. and Weisberg, S. (1999)
<em>Applied Regression, Including Computing and Graphics.</em> Wiley.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.
Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Weisberg, S. (2014)
<em>Applied Linear Regression</em>, Fourth Edition, Wiley.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+cooks.distance">cooks.distance</a></code>, <code><a href="stats.html#topic+rstudent">rstudent</a></code>,
<code><a href="car.html#topic+outlierTest">outlierTest</a></code>, <code><a href="stats.html#topic+hatvalues">hatvalues</a></code>, <code><a href="car.html#topic+influence.mixed.models">influence.mixed.models</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>influenceIndexPlot(lm(prestige ~ income + education + type, Duncan))

## Not run:  # a little slow
  if (require(lme4)){
      print(fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject),
          sleepstudy)) # from ?lmer
      infIndexPlot(influence(fm1, "Subject"))
      infIndexPlot(influence(fm1))
      }
      
  if (require(lme4)){
      gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
          data = cbpp, family = binomial) # from ?glmer
      infIndexPlot(influence(gm1, "herd", maxfun=100))
      infIndexPlot(influence(gm1, maxfun=100))
      gm1.11 &lt;- update(gm1, subset = herd != 11) # check deleting herd 11
      compareCoefs(gm1, gm1.11)
      }
    
## End(Not run)
</code></pre>

<hr>
<h2 id='influence.mixed.models'>
Influence Diagnostics for Mixed-Effects Models
</h2><span id='topic+influence.mixed.models'></span><span id='topic+influence.lme'></span><span id='topic+cooks.distance.influence.lme'></span><span id='topic+dfbeta.influence.lme'></span><span id='topic+dfbetas.influence.lme'></span>

<h3>Description</h3>

<p>These functions compute deletion influence diagnostics for linear mixed-effects models fit by <code><a href="nlme.html#topic+lme">lme</a></code> in the <span class="pkg">nlme</span> package.
The main function is a method for the <code><a href="stats.html#topic+influence">influence</a></code> generic function. Other functions are provided for
computing <code><a href="stats.html#topic+dfbeta">dfbeta</a></code>, <code><a href="stats.html#topic+dfbetas">dfbetas</a></code>, <code><a href="stats.html#topic+cooks.distance">cooks.distance</a></code>, and influence on variance-covariance components based
on the object computed by <code>influence.lme</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lme'
influence(model, groups, data, ncores=1, ...)

## S3 method for class 'influence.lme'
cooks.distance(model, ...)
## S3 method for class 'influence.lme'
dfbeta(model, which = c("fixed", "var.cov"), ...)
## S3 method for class 'influence.lme'
dfbetas(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influence.mixed.models_+3A_model">model</code></td>
<td>
<p>in the case <code>influence</code>, a model of class  <code>"lme"</code>;
in the case of <code>cooks.distance</code>, <code>dfbeta</code>, or <code>dfbetas</code>, an object returned by <code>influence.lme</code>.</p>
</td></tr>
<tr><td><code id="influence.mixed.models_+3A_groups">groups</code></td>
<td>
<p>a character vector containing the name of a grouping factor or names of grouping factors; if more than one name
is supplied, then groups are defined by all combinations of levels of the grouping factors that appear in
the data. If omitted, then each individual row of the data matrix is treated as a &quot;group&quot; to be deleted in turn.</p>
</td></tr>
<tr><td><code id="influence.mixed.models_+3A_data">data</code></td>
<td>
<p>an optional data frame with the data to which <code>model</code> was fit; 
<code>influence.lme</code> can access the data unless <code>keep.data=FALSE</code> was specified in the call to <code>lme</code>,
so it's usually unnecessary to supply the <code>data</code> argument.</p>
</td></tr>
<tr><td><code id="influence.mixed.models_+3A_ncores">ncores</code></td>
<td>
<p>number of cores for parallel computation of diagnostics; if <code>1</code>
(the default), the computation isn't parallelized; if <code>Inf</code>, all of the available <em>physical</em> cores 
(not necessarily <em>logical</em> cores &mdash; see <code><a href="parallel.html#topic+detectCores">detectCores</a></code>) on the computer will be used.</p>
</td></tr>
<tr><td><code id="influence.mixed.models_+3A_which">which</code></td>
<td>
<p>if <code>"fixed.effects"</code> (the default), return influence on the fixed effects; if <code>"var.cov"</code>, return influence on the variance-covariance components.</p>
</td></tr>
<tr><td><code id="influence.mixed.models_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>influence.lme</code> starts with the estimated variance-covariance components from <code>model</code> and then refits
the model omitting each group in turn.
</p>
<p>The other functions are methods for the <code><a href="stats.html#topic+dfbeta">dfbeta</a></code>, <code><a href="stats.html#topic+dfbetas">dfbetas</a></code>, and <code><a href="stats.html#topic+cooks.distance">cooks.distance</a></code> generics, to be applied to the
<code>"influence.lme"</code> object produced by the <code>influence</code> function; the <code>dfbeta</code> methods can also return
influence on the variance-covariance components.
</p>


<h3>Value</h3>

<p><code>influence.lme</code> returns an object of class 
<code>"influence.lme"</code>,
which contains the following elements:
</p>

<dl>
<dt><code>"fixed.effects"</code></dt><dd><p>the estimated fixed effects for the model.</p>
</dd>
<dt><code>"fixed.effects[-groups]"</code></dt><dd><p>a matrix with columns corresponding to the fixed-effects coefficients and rows corresponding to groups, giving the
estimated fixed effects with each group deleted in turn; <em>groups</em> is formed from the name(s) of the grouping factor(s).</p>
</dd>
<dt><code>"var.cov.comps"</code></dt><dd><p>the estimated variance-covariance parameters for the model.</p>
</dd>
<dt><code>"var.cov.comps[-groups]"</code></dt><dd><p>a matrix with the estimated covariance parameters (in columns) with each group deleted in turn.</p>
</dd>
<dt><code>"vcov"</code></dt><dd><p>The estimated covariance matrix of the fixed-effects coefficients.</p>
</dd>
<dt><code>"vcov[-groups]"</code></dt><dd><p>a list each of whose elements is the estimated covariance matrix of the fixed-effects coefficients with one group deleted.</p>
</dd>
<dt><code>"groups"</code></dt><dd><p>a character vector giving the names of the grouping factors.</p>
</dd>
<dt><code>"deleted"</code></dt><dd><p>the possibly composite grouping factor, each of whose elements is deleted in turn.</p>
</dd>
</dl>

<p>For plotting <code>"influence.lme"</code> objects, see <code><a href="car.html#topic+infIndexPlot">infIndexPlot</a></code>.
</p>


<h3>Author(s)</h3>

<p>J. Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+lme">lme</a></code>, <code><a href="car.html#topic+infIndexPlot">infIndexPlot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(nlme)){
    print(fm1 &lt;- lme(distance ~ age, data = Orthodont))
    infIndexPlot(influence(fm1, "Subject"))
    infIndexPlot(influence(fm1))
    }
</code></pre>

<hr>
<h2 id='influencePlot'>Regression Influence Plot</h2><span id='topic+influencePlot'></span><span id='topic+influencePlot.lm'></span><span id='topic+influencePlot.lmerMod'></span><span id='topic+influence.plot'></span>

<h3>Description</h3>

<p>This function creates a &ldquo;bubble&rdquo; plot of Studentized residuals versus hat values, with the areas of the
circles representing the observations proportional to the value Cook's distance. Vertical reference lines are drawn
at twice and three times the average hat value, horizontal reference lines at -2, 0, and 2 on the
Studentized-residual scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>influencePlot(model, ...)

## S3 method for class 'lm'
influencePlot(model, scale=10,  
 xlab="Hat-Values", ylab="Studentized Residuals", id=TRUE, 
 fill=TRUE, fill.col=carPalette()[2], fill.alpha=0.5, ...)

## S3 method for class 'lmerMod'
influencePlot(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="influencePlot_+3A_model">model</code></td>
<td>
<p>a linear, generalized-linear, or linear mixed model; the <code>"lmerMod"</code> method calls the <code>"lm"</code> method and can take the same arguments.</p>
</td></tr>
<tr><td><code id="influencePlot_+3A_scale">scale</code></td>
<td>
<p>a factor to adjust the size of the circles.
</p>
</td></tr>
<tr><td><code id="influencePlot_+3A_xlab">xlab</code>, <code id="influencePlot_+3A_ylab">ylab</code></td>
<td>
<p>axis labels.
</p>
</td></tr>
<tr><td><code id="influencePlot_+3A_id">id</code></td>
<td>
<p>settings for labelling points; see <code>link{showLabels}</code> for details. To omit point labelling, set
<code>id=FALSE</code>; the default, <code>id=TRUE</code> is equivalent to <code>id=list(method="noteworthy", n=2, cex=1, col=carPalette()[1], location="lr")</code>.  
The default <code>method="noteworthy"</code> is used only in this function and indicates setting labels for points with large Studentized residuals, hat-values or Cook's distances.  Set 
<code>id=list(method="identify")</code> for interactive point identification.</p>
</td></tr>
<tr><td><code id="influencePlot_+3A_fill">fill</code></td>
<td>
<p>if <code>TRUE</code> (the default) fill the circles, with the opacity of the filled color proportional to Cook's D, using the <code><a href="scales.html#topic+alpha">alpha</a></code> function in the <span class="pkg">scales</span> package to compute the opacity of the fill.</p>
</td></tr>
<tr><td><code id="influencePlot_+3A_fill.col">fill.col</code></td>
<td>
<p>color to use for the filled points, taken by default from the second element of the <code><a href="car.html#topic+carPalette">carPalette</a></code> color palette.</p>
</td></tr>
<tr><td><code id="influencePlot_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>the maximum alpha (opacity) of the points.</p>
</td></tr>
<tr><td><code id="influencePlot_+3A_...">...</code></td>
<td>
<p>arguments to pass to the <code>plot</code> and <code>points</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If points are identified, returns a data frame with the hat values, 
Studentized residuals and Cook's distance of the identified points.  If
no points are identified, nothing is returned.  This function is primarily
used for its side-effect of drawing a plot.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, minor changes by S. Weisberg
<a href="mailto:sandy@umn.edu">sandy@umn.edu</a> and a contribution from Michael Friendly</p>


<h3>References</h3>

<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cooks.distance">cooks.distance</a></code>, <code><a href="stats.html#topic+rstudent">rstudent</a></code>, <code><a href="scales.html#topic+alpha">alpha</a></code>, <code><a href="car.html#topic+carPalette">carPalette</a></code>,
<code><a href="stats.html#topic+hatvalues">hatvalues</a></code>, <code><a href="car.html#topic+showLabels">showLabels</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>influencePlot(lm(prestige ~ income + education, data=Duncan))
## Not run:  # requires user interaction to identify points
influencePlot(lm(prestige ~ income + education, data=Duncan), 
    id=list(method="identify"))

## End(Not run)
</code></pre>

<hr>
<h2 id='invResPlot'>Inverse Response Plots to Transform the Response</h2><span id='topic+invResPlot'></span><span id='topic+inverseResponsePlot'></span><span id='topic+inverseResponsePlot.lm'></span>

<h3>Description</h3>

<p>For a <code>lm</code> model, draws an inverse.response plot with the response <code class="reqn">Y</code> on the
vertical axis and the fitted values <code class="reqn">\hat{Y}</code>
on the horizontal axis.  Uses <code>nls</code> to
estimate  <code class="reqn">\lambda</code> in the function 
<code class="reqn">\hat{Y}=b_0+b_1Y^{\lambda}</code>.
Adds the fitted curve to the plot. 
<code>invResPlot</code> is an alias for <code>inverseResponsePlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverseResponsePlot(model, lambda=c(-1,0,1), robust=FALSE, xlab=NULL, ...)

## S3 method for class 'lm'
inverseResponsePlot(model, lambda=c(-1, 0, 1), 
    robust=FALSE, xlab=NULL, id=FALSE, ...)

invResPlot(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invResPlot_+3A_model">model</code></td>
<td>
<p>A <code>"lm"</code> regression object.</p>
</td></tr>
<tr><td><code id="invResPlot_+3A_lambda">lambda</code></td>
<td>
<p>A vector of values for lambda.  A plot will be produced 
with curves corresponding to these lambdas and to the nonlinear least squares 
estimate of lambda.</p>
</td></tr>
<tr><td><code id="invResPlot_+3A_robust">robust</code></td>
<td>
<p>If <code>TRUE</code>, then estimation uses Huber M-estimates with the median
absolute deviation to estimate scale and k= 1.345.  The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="invResPlot_+3A_xlab">xlab</code></td>
<td>
<p>The horizontal axis label.  If <code>NULL</code>, it is constructed by the function.</p>
</td></tr>
<tr><td><code id="invResPlot_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method=list(method="x", n=2, cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the most extreme horizontal (X) values.</p>
</td></tr>
<tr><td><code id="invResPlot_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>invTranPlot</code> and then to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As a side effect, a plot is produced with the response on the horizontal
axis and fitted values on the vertical axis.  
Several lines are added to be plot as
the ols estimates of the regression of <code class="reqn">\hat{Y}</code> on
<code class="reqn">Y^{\lambda}</code>,
interpreting <code class="reqn">\lambda</code> = 0 to be natural logarithms.
</p>
<p>Numeric output is a list with elements
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>Estimate of transformation parameter for the response</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>The residual sum of squares at the minimum if robust=FALSE.
If robust = TRUE, the value of Huber objective function is returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sanford Weisberg, <code>sandy@umn.edu</code></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2011) 
<em>An R Companion to Applied Regression</em>, Second Edition, Sage.
</p>
<p>Prendergast, L. A., &amp; Sheather, S. J. (2013)
On sensitivity of inverse response plot estimation and the benefits of a robust estimation approach. <em>Scandinavian Journal of Statistics</em>, 40(2), 219-237.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley, Chapter 7.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+invTranPlot">invTranPlot</a></code>, <code><a href="car.html#topic+powerTransform">powerTransform</a></code>, 
<code><a href="car.html#topic+showLabels">showLabels</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>m2 &lt;- lm(rate ~ log(len) + log(adt) + slim + shld + log(sigs1), Highway1)
invResPlot(m2)
</code></pre>

<hr>
<h2 id='invTranPlot'> Choose a Predictor Transformation Visually or Numerically </h2><span id='topic+invTranPlot'></span><span id='topic+invTranPlot.default'></span><span id='topic+invTranPlot.formula'></span><span id='topic+invTranEstimate'></span>

<h3>Description</h3>

<p><code>invTranPlot</code>
draws a two-dimensional scatterplot of <code class="reqn">Y</code> versus 
<code class="reqn">X</code>, along with the OLS
fit from the regression of <code class="reqn">Y</code> on 
<code class="reqn">(X^{\lambda}-1)/\lambda</code>.  <code>invTranEstimate</code>
finds the nonlinear least squares estimate of <code class="reqn">\lambda</code> and its
standard error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>            
invTranPlot(x, ...)

## S3 method for class 'formula'
invTranPlot(x, data, subset, na.action, id=FALSE, ...)

## Default S3 method:
invTranPlot(x, y, lambda=c(-1, 0, 1), robust=FALSE, 
        lty.lines=rep(c("solid", "dashed", "dotdash", "longdash", "twodash"), 
        length=1 + length(lambda)), lwd.lines=2, 
        col=carPalette()[1], col.lines=carPalette(), 
        xlab=deparse(substitute(x)), ylab=deparse(substitute(y)),
        family="bcPower", optimal=TRUE, key="auto", id=FALSE,
        grid=TRUE, ...)

invTranEstimate(x, y, family="bcPower", confidence=0.95, robust=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invTranPlot_+3A_x">x</code></td>
<td>
<p>The predictor variable, or a formula with a single response and
a single predictor </p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_y">y</code></td>
<td>
<p>The response variable </p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_data">data</code></td>
<td>
<p>An optional data frame to get the data for the formula</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_subset">subset</code></td>
<td>
<p>Optional, as in <code><a href="stats.html#topic+lm">lm</a></code>, select a subset of the cases</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_na.action">na.action</code></td>
<td>
<p>Optional, as in <code><a href="stats.html#topic+lm">lm</a></code>, the action for missing data</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_lambda">lambda</code></td>
<td>
<p>The powers used in the plot.  The optimal power than minimizes
the residual sum of squares is always added unless optimal is <code>FALSE</code>. </p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_robust">robust</code></td>
<td>
<p>If <code>TRUE</code>, then the estimated transformation is computed using
Huber M-estimation with the MAD used to estimate scale and k=1.345.  The
default is <code>FALSE</code>.</p>
</td></tr> 
<tr><td><code id="invTranPlot_+3A_family">family</code></td>
<td>
<p>The transformation family to use, <code>"bcPower"</code>, 
<code>"yjPower"</code>, or a user-defined family.</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_confidence">confidence</code></td>
<td>
<p>returns a profile likelihood confidence interval for the optimal 
transformation with this confidence level.  If <code>FALSE</code>, or if <code>robust=TRUE</code>,
no interval is returned.</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_optimal">optimal</code></td>
<td>
<p>Include the optimal value of lambda?</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_lty.lines">lty.lines</code></td>
<td>
<p>line types corresponding to the powers</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_lwd.lines">lwd.lines</code></td>
<td>
<p>the width of the plotted lines, defaults to 2 times the standard</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_col">col</code></td>
<td>
<p>color(s) of the points in the plot.  If you wish to distinguish points
according to the levels of a factor, we recommend using symbols, specified with
the <code>pch</code> argument, rather than colors.</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_col.lines">col.lines</code></td>
<td>
<p>color of the fitted lines corresponding to the powers.  The
default is to use the colors returned by  <code><a href="car.html#topic+carPalette">carPalette</a></code></p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_key">key</code></td>
<td>
<p>The default is <code>"auto"</code>, in which case a legend is added to
the plot, either above the top marign or in the bottom right or top right corner.
Set to NULL to suppress the legend.</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_xlab">xlab</code></td>
<td>
<p>Label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_ylab">ylab</code></td>
<td>
<p>Label for the vertical axis.</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method=list(method="x", n=2, cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the most extreme horizontal values &mdash; i.e., the response variable in the model.</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plot method, such as <code>pch</code>.</p>
</td></tr>
<tr><td><code id="invTranPlot_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invTranPlot</code>
plots a graph and returns a data frame with <code class="reqn">\lambda</code> in the 
first column, and the residual sum of squares from the regression
for that <code class="reqn">\lambda</code> in the second column.
</p>
<p><code>invTranEstimate</code> returns a list with elements <code>lambda</code> for the
estimate, <code>se</code> for its standard error, and <code>RSS</code>, the minimum
value of the residual sum of squares.  
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg, <a href="mailto:sandy@umn.edu">sandy@umn.edu</a> </p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2011) 
<em>An R Companion to Applied Regression</em>, Second Edition, Sage.
</p>
<p>Prendergast, L. A., &amp; Sheather, S. J. (2013)
On sensitivity of inverse response plot estimation and the benefits of a robust estimation approach. <em>Scandinavian Journal of Statistics</em>, 40(2), 219-237.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley, Chapter 7. 
</p>


<h3>See Also</h3>

 <p><code><a href="car.html#topic+inverseResponsePlot">inverseResponsePlot</a></code>,<code><a href="stats.html#topic+optimize">optimize</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>with(UN, invTranPlot(ppgdp, infantMortality))
with(UN, invTranEstimate(ppgdp, infantMortality))
</code></pre>

<hr>
<h2 id='leveneTest'>Levene's Test</h2><span id='topic+leveneTest'></span><span id='topic+leveneTest.formula'></span><span id='topic+leveneTest.lm'></span><span id='topic+leveneTest.default'></span>

<h3>Description</h3>

<p>Computes Levene's test for homogeneity of variance across groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leveneTest(y, ...)
## S3 method for class 'formula'
leveneTest(y, data, ...)
## S3 method for class 'lm'
leveneTest(y, ...)
## Default S3 method:
leveneTest(y, group, center=median, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leveneTest_+3A_y">y</code></td>
<td>
<p>response variable for the default method, or a <code>lm</code> or 
<code>formula</code> object. If <code>y</code> is a linear-model object or a formula,
the variables on the right-hand-side of the model must all be factors and
must be completely crossed.</p>
</td></tr>
<tr><td><code id="leveneTest_+3A_group">group</code></td>
<td>
<p>factor defining groups.</p>
</td></tr>
<tr><td><code id="leveneTest_+3A_center">center</code></td>
<td>
<p>The name of a function to compute the center of each group;
<code>mean</code> gives the original Levene's test; the default, <code>median</code>,
provides a more robust test.</p>
</td></tr>
<tr><td><code id="leveneTest_+3A_data">data</code></td>
<td>
<p>a data frame for evaluating the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="leveneTest_+3A_...">...</code></td>
<td>
<p>arguments to be passed down, e.g., <code>data</code> for the
<code>formula</code> and <code>lm</code> methods; can also be used to pass arguments to
the function given by <code>center</code> (e.g., <code>center=mean</code> and
<code>trim=0.1</code> specify the 10% trimmed mean).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object meant to be printed showing the results of the test.
</p>


<h3>Note</h3>

<p>adapted from a response posted by Brian Ripley to the r-help email list.</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>; original generic version 
contributed by Derek Ogle</p>


<h3>References</h3>

<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(Moore, leveneTest(conformity, fcategory))
with(Moore, leveneTest(conformity, interaction(fcategory, partner.status)))
leveneTest(conformity ~ fcategory*partner.status, data=Moore)
leveneTest(lm(conformity ~ fcategory*partner.status, data=Moore))
leveneTest(conformity ~ fcategory*partner.status, data=Moore, center=mean)
leveneTest(conformity ~ fcategory*partner.status, data=Moore, center=mean, trim=0.1)
</code></pre>

<hr>
<h2 id='leveragePlots'>Regression Leverage Plots</h2><span id='topic+leveragePlots'></span><span id='topic+leveragePlot'></span><span id='topic+leveragePlot.lm'></span><span id='topic+leveragePlot.glm'></span>

<h3>Description</h3>

<p>These functions display a generalization, due to Sall (1990) and
Cook and Weisberg (1991), 
of added-variable plots to multiple-df terms in a linear model. 
When a term has just 1 df, the leverage plot is a rescaled version
of the usual added-variable (partial-regression) plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leveragePlots(model, terms = ~., layout = NULL, ask, 
    main, ...)

leveragePlot(model, ...)

## S3 method for class 'lm'
leveragePlot(model, term.name,
		id=TRUE, col=carPalette()[1], col.lines=carPalette()[2], lwd=2, 
		xlab, ylab, main="Leverage Plot", grid=TRUE, ...)

## S3 method for class 'glm'
leveragePlot(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leveragePlots_+3A_model">model</code></td>
<td>
<p>model object produced by <code>lm</code>
</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_terms">terms</code></td>
<td>
<p> A one-sided formula that specifies a subset of the numeric regressors, factors and interactions.
One added-variable plot is drawn for each term, either a main effect or an interactions.  The default
<code>~.</code> is to plot against all terms in the model.  For example, the
specification <code>terms = ~ . - X3</code> would plot against all predictors
except for <code>X3</code>.  If this argument is a quoted name of one of the predictors, the 
added-variable plot is drawn for that predictor only.  The plots for main effects with interactions present violate the marginality principle and may not be easily interpreted.
</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_layout">layout</code></td>
<td>
 
<p>If set to a value like <code>c(1, 1)</code> or <code>c(4, 3)</code>, the layout
of the graph will have this many rows and columns.  If not set, the program
will select an appropriate layout.  If the number of graphs exceed nine, you 
must select the layout yourself, or you will get a maximum of nine per page.
If <code>layout=NA</code>, the function does not set the layout and the user can
use the <code>par</code> function to control the layout, for example to have 
plots from two models in the same graphics window.
</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_ask">ask</code></td>
<td>
<p>if <code>TRUE</code>, a menu is provided in the R Console for the
user to select the term(s) to plot.
</p>
</td></tr>   
<tr><td><code id="leveragePlots_+3A_xlab">xlab</code>, <code id="leveragePlots_+3A_ylab">ylab</code></td>
<td>
<p>axis labels; if missing, labels will be supplied.
</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_main">main</code></td>
<td>
<p>title for plot; if missing, a title will be supplied.
</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_...">...</code></td>
<td>
<p>arguments passed down to method functions.</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_term.name">term.name</code></td>
<td>
<p>Quoted name of term in the model to be plotted; this argument 
is omitted for <code>leveragePlots</code>.</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code>, no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code>, the default, is equivalent to <code>list(method=list(abs(residuals(model, type="pearson")), "x"), n=2, 
    cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the largest residuals and the 2 points with the greatest partial leverage.</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_col">col</code></td>
<td>
<p>color(s) of points</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_col.lines">col.lines</code></td>
<td>
<p>color of the fitted line
</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>2</code> (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="leveragePlots_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function intended for direct use is <code>leveragePlots</code>. 
</p>
<p>The model can contain factors and interactions. A leverage plot can be
drawn for each term in the model, including the constant.
</p>
<p><code>leveragePlot.glm</code> is a dummy function, which generates an error message.
</p>


<h3>Value</h3>

<p><code>NULL</code>. These functions are used for their side effect: producing
plots.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Cook, R. D. and Weisberg, S. (1991).
Added Variable Plots in Linear
Regression. In Stahel, W. and Weisberg, S. (eds.),
<em>Directions in Robust Statistics and Diagnostics</em>.
Springer, 47-60.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Sall, J. (1990)
Leverage plots for general linear hypotheses.
<em>American Statistician</em> <b>44</b>, 308&ndash;315.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+avPlots">avPlots</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>leveragePlots(lm(prestige~(income+education)*type, data=Duncan))
</code></pre>

<hr>
<h2 id='linearHypothesis'>Test Linear Hypothesis</h2><span id='topic+linearHypothesis'></span><span id='topic+lht'></span><span id='topic+linearHypothesis.lm'></span><span id='topic+linearHypothesis.glm'></span><span id='topic+linearHypothesis.mlm'></span><span id='topic+linearHypothesis.polr'></span><span id='topic+linearHypothesis.default'></span><span id='topic+linearHypothesis.mer'></span><span id='topic+linearHypothesis.merMod'></span><span id='topic+linearHypothesis.lme'></span><span id='topic+linearHypothesis.svyglm'></span><span id='topic+linearHypothesis.rlm'></span><span id='topic+linearHypothesis.survreg'></span><span id='topic+linearHypothesis.lmList'></span><span id='topic+linearHypothesis.nlsList'></span><span id='topic+matchCoefs'></span><span id='topic+matchCoefs.default'></span><span id='topic+matchCoefs.mer'></span><span id='topic+matchCoefs.merMod'></span><span id='topic+matchCoefs.lme'></span><span id='topic+matchCoefs.mlm'></span><span id='topic+matchCoefs.lmList'></span><span id='topic+makeHypothesis'></span><span id='topic+printHypothesis'></span><span id='topic+print.linearHypothesis.mlm'></span>

<h3>Description</h3>

<p>Generic function for testing a linear hypothesis, and methods
for linear models, generalized linear models, multivariate linear
models, linear and generalized linear mixed-effects models, 
generalized linear models fit with <code>svyglm</code> in the <span class="pkg">survey</span> package,
robust linear models fit with <code>rlm</code> in the <span class="pkg">MASS</span> package,
and other models that have methods for <code>coef</code> and <code>vcov</code>. 
For mixed-effects models, the tests are Wald chi-square tests for the fixed effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearHypothesis(model, ...)

lht(model, ...)

## Default S3 method:
linearHypothesis(model, hypothesis.matrix, rhs=NULL,
		test=c("Chisq", "F"), vcov.=NULL, singular.ok=FALSE, verbose=FALSE, 
    coef. = coef(model), suppress.vcov.msg=FALSE, error.df, ...)  

## S3 method for class 'lm'
linearHypothesis(model, hypothesis.matrix, rhs=NULL,
    test=c("F", "Chisq"), vcov.=NULL, 
	white.adjust=c(FALSE, TRUE, "hc3", "hc0", "hc1", "hc2", "hc4"), 
	singular.ok=FALSE, ...)

## S3 method for class 'glm'
linearHypothesis(model,  ...)

## S3 method for class 'lmList'
linearHypothesis(model,  ..., vcov.=vcov, coef.=coef)

## S3 method for class 'nlsList'
linearHypothesis(model,  ..., vcov.=vcov, coef.=coef)

## S3 method for class 'mlm'
linearHypothesis(model, hypothesis.matrix, rhs=NULL, SSPE, V,
    test, idata, icontrasts=c("contr.sum", "contr.poly"), idesign, iterms, 
    check.imatrix=TRUE, P=NULL, title="", singular.ok=FALSE, verbose=FALSE, ...)
    
## S3 method for class 'polr'
linearHypothesis(model, hypothesis.matrix, rhs=NULL, vcov., 
	verbose=FALSE, ...)
       
## S3 method for class 'linearHypothesis.mlm'
print(x, SSP=TRUE, SSPE=SSP, 
    digits=getOption("digits"), ...) 
    
## S3 method for class 'lme'
linearHypothesis(model, hypothesis.matrix, rhs=NULL,
		vcov.=NULL, singular.ok=FALSE, verbose=FALSE, ...)
    
## S3 method for class 'mer'
linearHypothesis(model, hypothesis.matrix, rhs=NULL,
		vcov.=NULL, test=c("Chisq", "F"), singular.ok=FALSE, verbose=FALSE, ...)
        
## S3 method for class 'merMod'
linearHypothesis(model, hypothesis.matrix, rhs=NULL,
    	vcov.=NULL, test=c("Chisq", "F"), singular.ok=FALSE, verbose=FALSE, ...)
		
## S3 method for class 'svyglm'
linearHypothesis(model, ...)

## S3 method for class 'rlm'
linearHypothesis(model, ...)

## S3 method for class 'survreg'
linearHypothesis(model, hypothesis.matrix, rhs=NULL,
		test=c("Chisq", "F"), vcov., verbose=FALSE, ...)
    
matchCoefs(model, pattern, ...)

## Default S3 method:
matchCoefs(model, pattern, coef.=coef, ...)

## S3 method for class 'lme'
matchCoefs(model, pattern, ...)

## S3 method for class 'mer'
matchCoefs(model, pattern, ...)

## S3 method for class 'merMod'
matchCoefs(model, pattern, ...)

## S3 method for class 'mlm'
matchCoefs(model, pattern, ...)

## S3 method for class 'lmList'
matchCoefs(model, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearHypothesis_+3A_model">model</code></td>
<td>
<p>fitted model object. The default method of <code>linearHypothesis</code> works for models
for which the estimated parameters can be retrieved by <code>coef</code> and
the corresponding estimated covariance matrix by <code>vcov</code>. See the
<em>Details</em> for more information.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_hypothesis.matrix">hypothesis.matrix</code></td>
<td>
<p>matrix (or vector) giving linear combinations
of coefficients by rows, or a character vector giving the hypothesis
in symbolic form (see <em>Details</em>).</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_rhs">rhs</code></td>
<td>
<p>right-hand-side vector for hypothesis, with as many entries as
rows in the hypothesis matrix; can be omitted, in which case it defaults
to a vector of zeroes. For a multivariate linear model, <code>rhs</code> is a
matrix, defaulting to 0. This argument isn't available for F-tests for linear mixed models.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_singular.ok">singular.ok</code></td>
<td>
<p>if <code>FALSE</code> (the default), a model with aliased
coefficients produces an error; if <code>TRUE</code>, the aliased coefficients
are ignored, and the hypothesis matrix should not have columns for them.
For a multivariate linear model: will return the hypothesis and error SSP
matrices even if the latter is singular; useful for computing univariate
repeated-measures ANOVAs where there are fewer subjects than df for within-subject
effects.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_error.df">error.df</code></td>
<td>
<p>For the <code>default</code> <code>linearHypothesis</code> method, if an F-test is requested and if <code>error.df</code> is missing, the error degrees of freedom will be computed by applying the <code>df.residual</code> function to the model; if <code>df.residual</code> returns <code>NULL</code> or <code>NA</code>, then a chi-square test will be substituted for the F-test (with a message to that effect.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_idata">idata</code></td>
<td>
<p>an optional data frame giving a factor or factors defining the
intra-subject model for multivariate repeated-measures data. See 
<em>Details</em> for an explanation of the intra-subject design and for
further explanation of the other arguments relating to intra-subject factors.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_icontrasts">icontrasts</code></td>
<td>
<p>names of contrast-generating functions to be applied by default
to factors and ordered factors, respectively, in the within-subject
&ldquo;data&rdquo;; the contrasts must produce an intra-subject model 
matrix in which different terms are orthogonal.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_idesign">idesign</code></td>
<td>
<p>a one-sided model formula using the &ldquo;data&rdquo; in <code>idata</code> and
specifying the intra-subject design.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_iterms">iterms</code></td>
<td>
<p>the quoted name of a term, or a vector of quoted names of terms,
in the intra-subject design to be tested.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_check.imatrix">check.imatrix</code></td>
<td>
<p>check that columns of the intra-subject model matrix for
different terms are mutually orthogonal (default, <code>TRUE</code>). Set to <code>FALSE</code>
only if you have <em>already</em> checked that the intra-subject model matrix is
block-orthogonal.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_p">P</code></td>
<td>
<p>transformation matrix to be applied to the repeated measures in
multivariate repeated-measures data; if <code>NULL</code> <em>and</em> no 
intra-subject model is specified, no response-transformation is applied; if
an intra-subject model is specified via the <code>idata</code>, <code>idesign</code>,
and (optionally) <code>icontrasts</code> arguments, then <code>P</code> is generated 
automatically from the <code>iterms</code> argument.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_sspe">SSPE</code></td>
<td>
<p>in <code>linearHypothesis</code> method for <code>mlm</code> objects: 
optional error sum-of-squares-and-products matrix; if missing,
it is computed from the model. In <code>print</code> method for 
<code>linearHypothesis.mlm</code> objects: if <code>TRUE</code>, 
print the sum-of-squares and cross-products matrix for error.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_test">test</code></td>
<td>
<p>character string, <code>"F"</code> or <code>"Chisq"</code>,
specifying whether to compute the finite-sample
F statistic (with approximate F distribution) or the large-sample
Chi-squared statistic (with asymptotic Chi-squared distribution). For a
multivariate linear model, the multivariate test statistic to report &mdash; one or more of
<code>"Pillai"</code>, <code>"Wilks"</code>, <code>"Hotelling-Lawley"</code>, or <code>"Roy"</code>, 
with <code>"Pillai"</code> as the default.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_title">title</code></td>
<td>
<p>an optional character string to label the output.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_v">V</code></td>
<td>
<p>inverse of sum of squares and products of the model matrix; if missing
it is computed from the model.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_vcov.">vcov.</code></td>
<td>
<p>a function for estimating the covariance matrix of the regression
coefficients, e.g., <code><a href="car.html#topic+hccm">hccm</a></code>, or an estimated covariance matrix
for <code>model</code>. See also <code>white.adjust</code>. 
For the <code>"lmList"</code> and <code>"nlsList"</code> methods, <code>vcov.</code>
must be a function (defaulting to <code>vcov</code>) to be applied to each model in the list.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_coef.">coef.</code></td>
<td>
<p>a vector of coefficient estimates.  The default is to get the
coefficient estimates from the <code>model</code> argument, but the user can input
any vector of the correct length. 
For the <code>"lmList"</code> and <code>"nlsList"</code> methods, <code>coef.</code>
must be a function (defaulting to <code>coef</code>) to be applied to each model in the list.</p>
</td></tr>       
<tr><td><code id="linearHypothesis_+3A_white.adjust">white.adjust</code></td>
<td>
<p>logical or character. Convenience interface to <code>hccm</code>
(instead of using the argument <code>vcov.</code>). Can be set either to a character value
specifying the <code>type</code> argument of <code><a href="car.html#topic+hccm">hccm</a></code> or <code>TRUE</code>,
in which case <code>"hc3"</code> is used implicitly. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, the hypothesis matrix, right-hand-side
vector (or matrix), and estimated value of the hypothesis 
are printed to standard output; if <code>FALSE</code> (the default),
the hypothesis is only printed in symbolic form and the value of the hypothesis
is not printed.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_x">x</code></td>
<td>
<p>an object produced by <code>linearHypothesis.mlm</code>.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_ssp">SSP</code></td>
<td>
<p>if <code>TRUE</code> (the default), print the sum-of-squares and 
cross-products matrix for the hypothesis and the response-transformation matrix.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_digits">digits</code></td>
<td>
<p>minimum number of signficiant digits to print.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_pattern">pattern</code></td>
<td>
<p>a <a href="base.html#topic+regex">regular expression</a> to be matched against coefficient names.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_suppress.vcov.msg">suppress.vcov.msg</code></td>
<td>
<p>for internal use by methods that call the default method.</p>
</td></tr>
<tr><td><code id="linearHypothesis_+3A_...">...</code></td>
<td>
<p>arguments to pass down.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>linearHypothesis</code> computes either a finite-sample F statistic or asymptotic Chi-squared
statistic for carrying out a Wald-test-based comparison between a model
and a linearly restricted model. The default method will work with any
model object for which the coefficient vector can be retrieved by 
<code>coef</code> and the coefficient-covariance matrix by <code>vcov</code> (otherwise
the argument <code>vcov.</code> has to be set explicitly). For computing the
F statistic (but not the Chi-squared statistic) a <code>df.residual</code> 
method needs to be available. If a <code>formula</code> method exists, it is
used for pretty printing.
</p>
<p>The method for <code>"lm"</code> objects calls the default method, but it
changes the default test to <code>"F"</code>, supports the convenience argument
<code>white.adjust</code> (for backwards compatibility), and enhances the output
by the residual sums of squares. For <code>"glm"</code> objects just the default
method is called (bypassing the <code>"lm"</code> method). The <code>"svyglm"</code> method
also calls the default method.
</p>
<p>Multinomial logit models fit by the <code><a href="nnet.html#topic+multinom">multinom</a></code> function in the <span class="pkg">nnet</span> package invoke the default method, and the coefficient names are composed from the response-level names and conventional coefficient names, separated by a period (<code>"."</code>): see one of the examples below.
</p>
<p>The function <code>lht</code> also dispatches to <code>linearHypothesis</code>.
</p>
<p>The hypothesis matrix can be supplied as a numeric matrix (or vector), 
the rows of which specify linear combinations of the model coefficients, 
which are tested equal to the corresponding entries in the right-hand-side 
vector, which defaults to a vector of zeroes. 
</p>
<p>Alternatively, the
hypothesis can be specified symbolically as a character vector with one
or more elements, each of which gives either a linear combination of
coefficients, or a linear equation in the coefficients (i.e., with both
a left and right side separated by an equals sign). Components of a
linear expression or linear equation can consist of numeric constants, or
numeric constants multiplying coefficient names (in which case the number
precedes the coefficient, and may be separated from it by spaces or an
asterisk); constants of 1 or -1 may be omitted.  Spaces are always optional.
Components are separated by plus or minus signs. Newlines or tabs in
hypotheses will be treated as spaces. See the examples below.
</p>
<p>If the user sets the arguments <code>coef.</code> and <code>vcov.</code>, then the computations
are done without reference to the <code>model</code> argument.  This is like assuming
that <code>coef.</code> is normally distibuted with estimated variance <code>vcov.</code>
and the <code>linearHypothesis</code> will compute tests on the mean vector for 
<code>coef.</code>, without actually using the <code>model</code> argument.
</p>
<p>A linear hypothesis for a multivariate linear model (i.e., an object of
class <code>"mlm"</code>) can optionally include an intra-subject transformation matrix
for a repeated-measures design.
If the intra-subject transformation is absent (the default), the multivariate 
test concerns all of the corresponding coefficients for the response variables. 
There are two ways to specify the transformation matrix for the
repeated measures: 
</p>

<ol>
<li><p> The transformation matrix can be specified directly via the <code>P</code> 
argument.
</p>
</li>
<li><p> A data frame can be provided defining the repeated-measures factor or
factors 
via <code>idata</code>, with default contrasts given by the <code>icontrasts</code>
argument. An intra-subject model-matrix is generated from the one-sided formula 
specified by the <code>idesign</code> argument; columns of the model matrix 
corresponding to different terms in the intra-subject model must be orthogonal 
(as is insured by the default contrasts). Note that the contrasts given in
<code>icontrasts</code> can be overridden by assigning specific contrasts to the
factors in <code>idata</code>. 
The repeated-measures transformation matrix consists of the
columns of the intra-subject model matrix corresponding to the term or terms
in <code>iterms</code>. In most instances, this will be the simpler approach, and
indeed, most tests of interests can be generated automatically via the
<code><a href="car.html#topic+Anova">Anova</a></code> function.
</p>
</li></ol>

<p><code>matchCoefs</code> is a convenience function that can sometimes help in formulating hypotheses; for example
<code>matchCoefs(mod, ":")</code> will return the names of all interaction coefficients in the model <code>mod</code>.
</p>


<h3>Value</h3>

<p>For a univariate model, an object of class <code>"anova"</code> 
which contains the residual degrees of freedom
in the model, the difference in degrees of freedom, Wald statistic
(either <code>"F"</code> or <code>"Chisq"</code>), and corresponding p value.
The value of the linear hypothesis and its covariance matrix are returned
respectively as <code>"value"</code> and <code>"vcov"</code> attributes of the object
(but not printed).
</p>
<p>For a multivariate linear model, an object of class 
<code>"linearHypothesis.mlm"</code>, which contains sums-of-squares-and-product
matrices for the hypothesis and for error, degrees of freedom for the 
hypothesis and error, and some other information.
</p>
<p>The returned object normally would be printed.
</p>


<h3>Author(s)</h3>

<p>Achim Zeileis and John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Hand, D. J., and Taylor, C. C. (1987)
<em>Multivariate Analysis of Variance and Repeated Measures: A Practical
Approach for Behavioural Scientists.</em> Chapman and Hall.
</p>
<p>O'Brien, R. G., and Kaiser, M. K. (1985)
MANOVA method for analyzing repeated measures designs: An extensive primer.
<em>Psychological Bulletin</em> <b>97</b>, 316&ndash;333.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova">anova</a></code>, <code><a href="car.html#topic+Anova">Anova</a></code>, <code><a href="lmtest.html#topic+waldtest">waldtest</a></code>,
<code><a href="car.html#topic+hccm">hccm</a></code>, <code><a href="sandwich.html#topic+vcovHC">vcovHC</a></code>, <code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code>, 
<code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod.davis &lt;- lm(weight ~ repwt, data=Davis)

## the following are equivalent:
linearHypothesis(mod.davis, diag(2), c(0,1))
linearHypothesis(mod.davis, c("(Intercept) = 0", "repwt = 1"))
linearHypothesis(mod.davis, c("(Intercept)", "repwt"), c(0,1))
linearHypothesis(mod.davis, c("(Intercept)", "repwt = 1"))

## use asymptotic Chi-squared statistic
linearHypothesis(mod.davis, c("(Intercept) = 0", "repwt = 1"), test = "Chisq")


## the following are equivalent:
  ## use HC3 standard errors via white.adjust option
linearHypothesis(mod.davis, c("(Intercept) = 0", "repwt = 1"), 
    white.adjust = TRUE)
  ## covariance matrix *function*
linearHypothesis(mod.davis, c("(Intercept) = 0", "repwt = 1"), vcov = hccm)
  ## covariance matrix *estimate*
linearHypothesis(mod.davis, c("(Intercept) = 0", "repwt = 1"), 
    vcov = hccm(mod.davis, type = "hc3"))

mod.duncan &lt;- lm(prestige ~ income + education, data=Duncan)

## the following are all equivalent:
linearHypothesis(mod.duncan, "1*income - 1*education = 0")
linearHypothesis(mod.duncan, "income = education")
linearHypothesis(mod.duncan, "income - education")
linearHypothesis(mod.duncan, "1income - 1education = 0")
linearHypothesis(mod.duncan, "0 = 1*income - 1*education")
linearHypothesis(mod.duncan, "income-education=0")
linearHypothesis(mod.duncan, "1*income - 1*education + 1 = 1")
linearHypothesis(mod.duncan, "2income = 2*education")

mod.duncan.2 &lt;- lm(prestige ~ type*(income + education), data=Duncan)
coefs &lt;- names(coef(mod.duncan.2))

## test against the null model (i.e., only the intercept is not set to 0)
linearHypothesis(mod.duncan.2, coefs[-1]) 

## test all interaction coefficients equal to 0
linearHypothesis(mod.duncan.2, coefs[grep(":", coefs)], verbose=TRUE)
linearHypothesis(mod.duncan.2, matchCoefs(mod.duncan.2, ":"), verbose=TRUE) # equivalent
lh &lt;- linearHypothesis(mod.duncan.2, coefs[grep(":", coefs)])
attr(lh, "value") # value of linear function
attr(lh, "vcov")  # covariance matrix of linear function

## a multivariate linear model for repeated-measures data
## see ?OBrienKaiser for a description of the data set used in this example.

mod.ok &lt;- lm(cbind(pre.1, pre.2, pre.3, pre.4, pre.5, 
                     post.1, post.2, post.3, post.4, post.5, 
                     fup.1, fup.2, fup.3, fup.4, fup.5) ~  treatment*gender, 
                data=OBrienKaiser)
coef(mod.ok)

## specify the model for the repeated measures:
phase &lt;- factor(rep(c("pretest", "posttest", "followup"), c(5, 5, 5)),
    levels=c("pretest", "posttest", "followup"))
hour &lt;- ordered(rep(1:5, 3))
idata &lt;- data.frame(phase, hour)
idata
 
## test the four-way interaction among the between-subject factors 
## treatment and gender, and the intra-subject factors 
## phase and hour              
    
linearHypothesis(mod.ok, c("treatment1:gender1", "treatment2:gender1"),
    title="treatment:gender:phase:hour", idata=idata, idesign=~phase*hour, 
    iterms="phase:hour")

## mixed-effects models examples:

## Not run:  # loads nlme package
	library(nlme)
	example(lme)
	linearHypothesis(fm2, "age = 0")

## End(Not run)

## Not run:  # loads lme4 package
	library(lme4)
	example(glmer)
	linearHypothesis(gm1, matchCoefs(gm1, "period"))

## End(Not run)

if (require(nnet)){
  print(m &lt;- multinom(partic ~ hincome + children, data=Womenlf))
  print(coefs &lt;- as.vector(outer(c("not.work.", "parttime."), 
                            c("hincome", "childrenpresent"),
                            paste0)))
  linearHypothesis(m, coefs) # ominbus Wald test
}

</code></pre>

<hr>
<h2 id='logit'>Logit Transformation</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Compute the logit transformation of proportions or percentages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p, percents, adjust)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_p">p</code></td>
<td>
<p>numeric vector or array of proportions or percentages.</p>
</td></tr>
<tr><td><code id="logit_+3A_percents">percents</code></td>
<td>
<p><code>TRUE</code> for percentages, <code>FALSE</code> for proportions. If the argument is missing and the largest value of <code>p</code> &gt; 1, <code>percents</code> is set to <code>TRUE</code>, otherwise to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="logit_+3A_adjust">adjust</code></td>
<td>
<p>adjustment factor to avoid proportions of 0 or 1;
defaults to <code>0</code> if there are no such proportions in the data,
and to <code>.025</code> if there are.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the logit transformation logit <code class="reqn">=\log [p/(1-p)]</code>
for the proportion <code class="reqn">p</code>. 
</p>
<p>If <code class="reqn">p=0</code> or <code class="reqn">1</code>, then the logit
is undefined. <code>logit</code> can remap the proportions to the interval 
<code>(adjust, 1 - adjust)</code> prior to the transformation. If it adjusts the data
automatically, <code>logit</code> will print a warning message.
</p>


<h3>Value</h3>

<p>a numeric vector or array of the same shape and size as <code>p</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+probabilityAxis">probabilityAxis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>save.opt &lt;- options(digits=4)
logit(.1*0:10)
logit(.1*0:10, adjust=0)
options(save.opt)
</code></pre>

<hr>
<h2 id='mcPlots'>Draw Linear Model Marginal and Conditional Plots in Parallel or Overlaid</h2><span id='topic+mcPlots'></span><span id='topic+mcPlots.default'></span><span id='topic+mcPlot'></span><span id='topic+mcPlot.lm'></span><span id='topic+mcPlot.glm'></span>

<h3>Description</h3>

<p>the <code>mcPlot</code> function draws two graphs or overlays the two graphs.  For a response Y and a regressor X, the first plot is the <em>m</em>arginal plot of Y versus X with both variables centered, visualizing the conditional distribution of Y given X ignoring all other regressors.  The second plot is an added-variable for X after all other regressors, visualizing the <em>c</em>onditional distribution of Y given X after adjusting for all other predictors.  The added variable plot by default is drawn using the same xlim and ylim as the centered marginal plot to emphasize that conditioning removes variation in both the regressor and the response.The plot is primarily intended as a pedagogical tool for understanding coefficients in first-order models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcPlots(model, ...)

## Default S3 method:
mcPlots(model, terms=~., layout=NULL, ask, overlaid=TRUE, ...)

mcPlot(model, ...)

## S3 method for class 'lm'
mcPlot(model, variable, id=FALSE,
    col.marginal=carPalette()[2], col.conditional=carPalette()[3],
    col.arrows="gray", pch = c(16,1), cex=par("cex"), pt.wts=FALSE,
    lwd = 2, grid=TRUE, ellipse=FALSE, overlaid=TRUE, new=TRUE, 
    title=TRUE, ...)
    
## S3 method for class 'glm'
mcPlot(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcPlots_+3A_model">model</code></td>
<td>
<p>model object produced by <code>lm</code>; the <code>"glm"</code> method just
reports an error.</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_terms">terms</code></td>
<td>
<p> A one-sided formula that specifies a subset of the predictors.
One added-variable plot is drawn for each regressor and for each basis vector used to define a factor. For example, the
specification <code>terms = ~ . - X3</code> would plot against all terms
except for <code>X3</code>. If this argument is a quoted name of one of the regressors or factors, the
added-variable plot is drawn for that regressor or factor only.  Unlike other car functions, the formula should include the names of regressors, not predictors.  That is, if <code>log(X4)</code> is used to represent a predictor <code>X4</code>, the formula should specify <code>terms = ~ log(X4)</code>.
</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_variable">variable</code></td>
<td>
<p>A quoted string giving the name of a numeric predictor in the model matrix for the horizontal
axis.  To plot against a factor, you need to specify the full name of one of the indicator variables that define the factor.  For example, for a factor called <code>type</code> with levels <code>A</code>, <code>B</code> and C, using the usual drop-first level parameterization of the factor, the regressors for <code>type</code> would be <code>typeB</code> or <code>typeC</code>.  Similarly, to plot against the regressor <code>log(X4)</code>, you must specify <code>"log((X4)"</code>, not <code>"X4"</code>.
</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_layout">layout</code></td>
<td>

<p>If set to a value like <code>c(1, 2)</code> or <code>c(6, 2)</code>, the layout
of the graph will have this many rows and columns.  If not set, behavior depends on the value of the <code>overlaid</code> argument; see the details
</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, ask the user before drawing the next plot; if <code>FALSE</code> don't ask.
</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_...">...</code></td>
<td>
<p><code>mcPlots</code> passes these arguments to <code>mcPlot</code>.
<code>mcPlot</code> passes arguments to <code>plot</code>.
</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method=list(abs(residuals(model, type="pearson")), "x"), n=2, cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the largest residuals and the 2 points with the most extreme
horizontal (X) values.</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_overlaid">overlaid</code></td>
<td>
<p>If TRUE, the default, overlay the marginal and conditional plots on the same graph; otherwise
plot them side-by-side.  See the details below</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_col.marginal">col.marginal</code>, <code id="mcPlots_+3A_col.conditional">col.conditional</code></td>
<td>
<p>colors for points, lines,
ellipses in the marginal and conditional plots, respectively.  The defaults are determined by the <code><a href="car.html#topic+carPalette">carPalette</a></code> function.</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_col.arrows">col.arrows</code></td>
<td>
<p>color for the arrows with <code>overlaid=TRUE</code></p>
</td></tr>
<tr><td><code id="mcPlots_+3A_pch">pch</code></td>
<td>
<p>Plotting character for marginal and conditional plots, respectively.</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_cex">cex</code></td>
<td>
<p>size of plotted points; default is taken from <code>par("cex")</code>.</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_pt.wts">pt.wts</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), the areas of 
plotted points for a weighted least squares fit 
are made proportional to the weights, with the average size taken from the
<code>cex</code> argument.</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>2</code> (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_grid">grid</code></td>
<td>
<p>If <code>TRUE</code>, the default, a light-gray background grid is put on the graph.</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_ellipse">ellipse</code></td>
<td>
<p>Arguments to pass to the <code><a href="car.html#topic+dataEllipse">dataEllipse</a></code> function, in the form of a list
with named elements; e.g., <code>ellipse.args=list(robust=TRUE))</code> will cause the ellipse to be plotted using
a robust covariance-matrix. if <code>FALSE</code>, the default, no ellipse is plotted. <code>TRUE</code> is equivalent to
<code>ellipse=list(levels=0.5)</code>, which plots a bivariate-normal 50 percent concentration ellipse.</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_new">new</code></td>
<td>
<p>if <code>TRUE</code>, the default, the plot window is reset when <code>overlaid=FALSE</code> using <code>par{mfrow=c(1, 2)}</code>.  If <code>FALSE</code>, the layout of the plot window is not reset.
Users will ordinarily ignore this argument.</p>
</td></tr>
<tr><td><code id="mcPlots_+3A_title">title</code></td>
<td>
<p>If TRUE, the default, the standard main argument in plot is used to add a standard title to each plot.  If FALSE no title is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With an <code>lm</code> object, suppose the response is Y, X is a numeric regressor of interest, and Z is all the remaining predictors, possibly including interactions and factors.  This function produces two graphs.  The first graph is the marginal plot of Y versus X, with each variable centered around its mean.  The second conditional plot is the added-variable plot of e(Y|Z) versus e(X|Z) where e(a|b) means the Pearson residuals from the regression of a on b.  If <code>overlaid=TRUE</code>, these two plots are overlaid in one graph, with the points in different colors.  In addition, each point in the marginal plot is joined to its value in the conditional plot by an arrow.  Least squares regression lines fit to the marginal and conditional graphs are also shown; data ellipsoids can also be added.  If <code>overlaid=FALSE</code>, then the two graphs are shown in side-by-side plots as long as the second argument to <code>layout</code> is equal to <code>2</code>, or <code>layout</code> is set by the function. The arrows are omitted if the graphs are not overlaid.
</p>
<p>These graphs are primarily for teaching, as the marginal plot shows the relationship between Y and X ignoring Z, while the conditional is the relationship between Y and X given X.  By keeping the scales the same in both graphs the effect of conditioning on both X and Y can be visualized.
</p>
<p>This function is intended for first-order models with numeric predictors only.  For a factor,  one (pair) of mcPlots will be produced for each of the dummy variables in the basis for the factor, and the resulting plots are not generally meaningful because they depend on parameterization.  If the mean function includes interactions, then mcPlots for main effects may violate the hierarchy principle, and may also be of little interest.  mcPlots for interactions of numerical predictors, however, can be useful.
</p>
<p>These graphs are closely related to the ARES plots proposed by Cook and Weisberg (1989).
This plot would benefit from animation.
</p>


<h3>Value</h3>

<p>These functions are used for their side effect of producing
plots.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, Sanford Weisberg <a href="mailto:sandy@umn.edu">sandy@umn.edu</a></p>


<h3>References</h3>

<p>Cook, R. D. and Weisberg, S. (1989)
<em>Regression diagnostics with dynamic graphics,</em> Technometrics, 31, 277.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.
</p>
<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+avPlots">avPlots</a></code>, <code><a href="car.html#topic+residualPlots">residualPlots</a></code>, <code><a href="car.html#topic+crPlots">crPlots</a></code>, <code><a href="car.html#topic+ceresPlots">ceresPlots</a></code>,
<code><a href="car.html#topic+dataEllipse">dataEllipse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lm(partic ~ tfr + menwage + womwage + debt + parttime, data = Bfox)
mcPlot(m1, "womwage")
mcPlot(m1, "womwage", overlaid=FALSE, ellipse=TRUE)
</code></pre>

<hr>
<h2 id='mmps'>Marginal Model Plotting</h2><span id='topic+mmps'></span><span id='topic+mmp'></span><span id='topic+mmp.lm'></span><span id='topic+mmp.glm'></span><span id='topic+mmp.default'></span><span id='topic+marginalModelPlot'></span><span id='topic+marginalModelPlots'></span>

<h3>Description</h3>

<p>For a regression object, draw a plot of the response on the vertical axis versus
a linear combination <code class="reqn">u</code> of regressors in the mean function on the horizontal
axis.  Added to the plot are a smooth for the graph, along with
a smooth from the plot of the fitted values on <code class="reqn">u</code>.  <code>mmps</code> is an alias
for <code>marginalModelPlots</code>, and <code>mmp</code> is an alias for <code>marginalModelPlot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalModelPlots(...)

mmps(model, terms= ~ ., fitted=TRUE, layout=NULL, ask,
        main, groups, key=TRUE, ...)

marginalModelPlot(...)

mmp(model, ...)

## S3 method for class 'lm'
mmp(model, variable, sd = FALSE,
    xlab = deparse(substitute(variable)), 
    smooth=TRUE, key=TRUE, pch, groups=NULL, ...)

## Default S3 method:
mmp(model, variable, sd = FALSE,
    xlab = deparse(substitute(variable)), ylab, smooth=TRUE,
    key=TRUE, pch, groups=NULL,
    col.line = carPalette()[c(2, 8)], col=carPalette()[1],
    id=FALSE, grid=TRUE, ...)

## S3 method for class 'glm'
mmp(model, variable, sd = FALSE,
    xlab = deparse(substitute(variable)), ylab,
    smooth=TRUE, key=TRUE, pch, groups=NULL,
    col.line = carPalette()[c(2, 8)], col=carPalette()[1],
    id=FALSE, grid=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmps_+3A_model">model</code></td>
<td>
<p>A regression object, usually of class either <code>lm</code> or <code>glm</code>,
for which there is a <code>predict</code> method defined. </p>
</td></tr>
<tr><td><code id="mmps_+3A_terms">terms</code></td>
<td>
<p>A one-sided formula.  A marginal model plot will be drawn for
each term on the right-side of this formula that is not a factor.  The
default is <code>~ .</code>, which specifies that all the terms in
<code>formula(object)</code> will be used.  If a conditioning argument is given,
eg <code>terms = ~. | a</code>, then separate colors and smoothers are used for
each unique non-missing value of <code>a</code>.  See examples below.</p>
</td></tr>
<tr><td><code id="mmps_+3A_fitted">fitted</code></td>
<td>
<p>If <code>TRUE</code>, the default, then a marginal model plot in the direction
of the fitted values for a linear model or the linear predictor of a 
generalized linear model will be drawn.</p>
</td></tr>
<tr><td><code id="mmps_+3A_layout">layout</code></td>
<td>

<p>If set to a value like <code>c(1, 1)</code> or <code>c(4, 3)</code>, the layout
of the graph will have this many rows and columns.  If not set, the program
will select an appropriate layout.  If the number of graphs exceed nine, you
must select the layout yourself, or you will get a maximum of nine per page.
If <code>layout=NA</code>, the function does not set the layout and the user can
use the <code>par</code> function to control the layout, for example to have
plots from two models in the same graphics window.
</p>
</td></tr>
<tr><td><code id="mmps_+3A_ask">ask</code></td>
<td>
<p>If <code>TRUE</code>, ask before clearing the graph window to draw more plots.</p>
</td></tr>
<tr><td><code id="mmps_+3A_main">main</code></td>
<td>

<p>Main title for the array of plots.  Use <code>main=""</code> to suppress the title;
if missing, a title will be supplied.
</p>
</td></tr>
<tr><td><code id="mmps_+3A_...">...</code></td>
<td>

<p>Additional arguments passed from <code>mmps</code> to <code>mmp</code> and
then to <code>plot</code>.  Users should generally use <code>mmps</code>, or equivalently
<code>marginalModelPlots</code>.
</p>
</td></tr>
<tr><td><code id="mmps_+3A_variable">variable</code></td>
<td>
<p> The quantity to be plotted on the horizontal axis.  If this argument
is missing, the horizontal variable is the linear predictor, returned by 
<code>predict(object)</code> for models of class
<code>lm</code>, with default label <code>"Fitted values"</code>,  or returned by 
<code>predict(object, type="link")</code> for models of class <code>glm</code>, with default 
label <code>"Linear predictor"</code>. It can be any other
vector of length equal to the number of observations in the object. Thus the
<code>mmp</code> function can be used to get a marginal model plot versus any
regressor or predictor while the <code>mmps</code> function can be used only to get
marginal model plots for the first-order regressors in the formula.  In
particular, terms defined by a spline basis are skipped by <code>mmps</code>, but
you can use <code>mmp</code> to get the plot for the variable used to define
the splines.</p>
</td></tr>
<tr><td><code id="mmps_+3A_sd">sd</code></td>
<td>
<p> If <code>TRUE</code>, display sd smooths.  For a binomial regression with all
sample sizes equal to one, this argument is ignored as the SD bounds don't
make any sense. </p>
</td></tr>
<tr><td><code id="mmps_+3A_xlab">xlab</code></td>
<td>
<p> label for horizontal axis.</p>
</td></tr>
<tr><td><code id="mmps_+3A_ylab">ylab</code></td>
<td>
<p> label for vertical axis, defaults to name of response.</p>
</td></tr>
<tr><td><code id="mmps_+3A_smooth">smooth</code></td>
<td>
<p>specifies the smoother to be used along with its arguments; if <code>FALSE</code>, no smoother is shown;
can be a list giving the smoother function and its named arguments; <code>TRUE</code>, the default, is equivalent to
<code>list(smoother=loessLine, span=2/3)</code> for linear models and <code>list(smoother=gamLine, k=3)</code> for generalized linear models.
See <code><a href="car.html#topic+ScatterplotSmoothers">ScatterplotSmoothers</a></code> for the smoothers supplied by the
<span class="pkg">car</span> package and their arguments; the <code>spread</code> argument is not supported for marginal model plots.</p>
</td></tr>
<tr><td><code id="mmps_+3A_groups">groups</code></td>
<td>
<p>The name of a vector that specifies a grouping variable for
separate colors/smoothers.  This can also be specified as a conditioning
argument on the <code>terms</code> argument.</p>
</td></tr>
<tr><td><code id="mmps_+3A_key">key</code></td>
<td>
<p>If <code>TRUE</code>, include a key at the top of the plot, if <code>FALSE</code> omit the
key.  If grouping is present, the key is only printed for the upper-left plot.</p>
</td></tr>
<tr><td><code id="mmps_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method="y", n=2, cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the most unusual response (Y) values.</p>
</td></tr>
<tr><td><code id="mmps_+3A_pch">pch</code></td>
<td>
<p>plotting character to use if no grouping is present.</p>
</td></tr>
<tr><td><code id="mmps_+3A_col.line">col.line</code></td>
<td>
<p> colors for data and model smooth, respectively.  The default is to use <code><a href="car.html#topic+carPalette">carPalette</a></code>, <code>carPalette()[c(2, 8)]</code>,  blue and red. </p>
</td></tr>
<tr><td><code id="mmps_+3A_col">col</code></td>
<td>
<p>color(s) for the plotted points.</p>
</td></tr>
<tr><td><code id="mmps_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mmp</code> and <code>marginalModelPlot</code> draw one marginal model plot against
whatever is specified as the horizontal axis.
<code>mmps</code> and <code>marginalModelPlots</code> draws marginal model plots
versus each of the terms in the <code>terms</code> argument and versus fitted values.
<code>mmps</code> skips factors and  interactions if they are specified in the
<code>terms</code> argument.  Terms based on polynomials or on splines (or
potentially any term that is represented by a matrix of regressors) will
be used to form a marginal model plot by returning a linear combination of the
terms.  For example, if you specify <code>terms = ~ X1 + poly(X2, 3)</code> and
<code>poly(X2, 3)</code> was part of the original model formula, the horizontal
axis of the marginal model plot for <code>X2</code> will be the value of
<code>predict(model, type="terms")[, "poly(X2, 3)"])</code>.  If the <code>predict</code>
method for the model you are using doesn't support <code>type="terms"</code>,
then the polynomial/spline term is skipped.  Adding a conditioning variable,
e.g., <code>terms = ~ a + b | c</code>, will produce marginal model plots for <code>a</code>
and <code>b</code> with different colors and smoothers for each unique non-missing
value of <code>c</code>.
</p>
<p>For linear models, the default smoother is loess.
For generalized linear models, the default smoother uses <code>gamLine</code>, fitting
a generalized additive model with the same family, link and weights as the fit of the
model. SD smooths are not computed for for generalized linear models.
</p>
<p>For generalized linear models the default number of elements in the spline basis is
<code>k=3</code>; this is done to allow fitting for predictors with just a few support
points.  If you have many support points you may wish to set <code>k</code> to a higher
number, or <code>k=-1</code> for the default used by <code><a href="mgcv.html#topic+gam">gam</a></code>.
</p>


<h3>Value</h3>

<p>Used for its side effect of producing plots.
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg, <a href="mailto:sandy@umn.edu">sandy@umn.edu</a></p>


<h3>References</h3>

<p>Cook, R. D., &amp; Weisberg, S. (1997). Graphics for assessing the adequacy of regression models.
<em>Journal of the American Statistical Association</em>, 92(438), 490-499.
</p>
<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition.  Sage.
</p>
<p>Weisberg, S. (2005) <em>Applied
Linear Regression</em>, Third Edition, Wiley, Section 8.4.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+ScatterplotSmoothers">ScatterplotSmoothers</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>c1 &lt;- lm(infantMortality ~ ppgdp, UN)
mmps(c1)
c2 &lt;- update(c1, ~ log(ppgdp))
mmps(c2)
# include SD lines
p1 &lt;- lm(prestige ~ income + education, Prestige)
mmps(p1, sd=TRUE)
# condition on type:
mmps(p1, ~. | type)
# logisitic regression example
# smoothers return warning messages.
# fit a separate smoother and color for each type of occupation.
m1 &lt;- glm(lfp ~ ., family=binomial, data=Mroz)
mmps(m1)
</code></pre>

<hr>
<h2 id='ncvTest'>Score Test for Non-Constant Error Variance</h2><span id='topic+ncvTest'></span><span id='topic+ncvTest.lm'></span><span id='topic+ncvTest.glm'></span>

<h3>Description</h3>

<p>Computes a score test of the hypothesis of constant error variance
against the alternative that the error variance changes with the
level of the response (fitted values), or with a linear combination
of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncvTest(model, ...)

## S3 method for class 'lm'
ncvTest(model, var.formula, ...)

## S3 method for class 'glm'
ncvTest(model, ...) # to report an error
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncvTest_+3A_model">model</code></td>
<td>
<p>a weighted or unweighted linear model, produced by <code>lm</code>.</p>
</td></tr>
<tr><td><code id="ncvTest_+3A_var.formula">var.formula</code></td>
<td>
<p>a one-sided formula for the error variance; if omitted,
the error variance depends on the fitted values.</p>
</td></tr>
<tr><td><code id="ncvTest_+3A_...">...</code></td>
<td>
<p>arguments passed down to methods functions; not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test is often called the Breusch-Pagan test; it was independently
suggested with some extension by Cook and Weisberg (1983).
</p>
<p><code>ncvTest.glm</code> is a dummy function to generate an error when a <code>glm</code>
model is used.
</p>


<h3>Value</h3>

<p>The function returns a <code>chisqTest</code> object, which is usually just printed.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, Sandy Weisberg <a href="mailto:sandy@umn.edu">sandy@umn.edu</a></p>


<h3>References</h3>

<p>Breusch, T. S. and Pagan, A. R. (1979)
A simple test for heteroscedasticity and random coefficient variation.
<em>Econometrica</em> <b>47</b>, 1287&ndash;1294.
</p>
<p>Cook, R. D. and Weisberg, S. (1983)
Diagnostics for heteroscedasticity in regression.
<em>Biometrika</em> <b>70</b>, 1&ndash;10.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+hccm">hccm</a></code>, <code><a href="car.html#topic+spreadLevelPlot">spreadLevelPlot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>ncvTest(lm(interlocks ~ assets + sector + nation, data=Ornstein))

ncvTest(lm(interlocks ~ assets + sector + nation, data=Ornstein), 
    ~ assets + sector + nation, data=Ornstein)
</code></pre>

<hr>
<h2 id='outlierTest'>Bonferroni Outlier Test</h2><span id='topic+outlierTest'></span><span id='topic+outlierTest.lm'></span><span id='topic+outlierTest.glm'></span><span id='topic+outlierTest.lmerMod'></span><span id='topic+print.outlierTest'></span>

<h3>Description</h3>

<p>Reports the Bonferroni p-values for testing each observation in turn to be a mean-shift outlier, based Studentized residuals in
linear (t-tests), generalized linear models (normal tests), and linear mixed models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlierTest(model, ...)

## S3 method for class 'lm'
outlierTest(model, cutoff=0.05, n.max=10, order=TRUE, 
	labels=names(rstudent), ...)
	
## S3 method for class 'lmerMod'
outlierTest(model, ...)

## S3 method for class 'outlierTest'
print(x, digits=5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlierTest_+3A_model">model</code></td>
<td>
<p>an <code>lm</code>, <code>glm</code>, or <code>lmerMod</code> model object; the <code>"lmerMod"</code> method calls the <code>"lm"</code> method and can take the same arguments.</p>
</td></tr>
<tr><td><code id="outlierTest_+3A_cutoff">cutoff</code></td>
<td>
<p>observations with Bonferroni p-values exceeding
<code>cutoff</code> are not reported, unless no observations are
nominated, in which case the one with the largest Studentized
residual is reported.</p>
</td></tr>
<tr><td><code id="outlierTest_+3A_n.max">n.max</code></td>
<td>
<p>maximum number of observations to report (default, <code>10</code>).</p>
</td></tr>
<tr><td><code id="outlierTest_+3A_order">order</code></td>
<td>
<p>report Studenized residuals in descending order of magnitude? 
(default, <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="outlierTest_+3A_labels">labels</code></td>
<td>
<p>an optional vector of observation names.</p>
</td></tr>
<tr><td><code id="outlierTest_+3A_...">...</code></td>
<td>
<p>arguments passed down to methods functions.</p>
</td></tr>
<tr><td><code id="outlierTest_+3A_x">x</code></td>
<td>
<p><code>outlierTest</code> object.</p>
</td></tr>
<tr><td><code id="outlierTest_+3A_digits">digits</code></td>
<td>
<p>number of digits for reported p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a linear model, p-values reported use the t distribution with degrees of
freedom one less than the residual df for the model. For a generalized
linear model, p-values are based on the standard-normal distribution. The Bonferroni
adjustment multiplies the usual two-sided p-value by the number of 
observations. The <code>lm</code> method works for <code>glm</code> objects. To show all
of the observations set <code>cutoff=Inf</code> and <code>n.max=Inf</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>outlierTest</code>, which is normally just
printed.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a> and Sanford Weisberg</p>


<h3>References</h3>

<p>Cook, R. D. and Weisberg, S. (1982)
<em>Residuals and Influence in Regression.</em> Chapman and Hall.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley.
</p>
<p>Williams, D. A. (1987)
Generalized linear model diagnostics using the deviance and single
case deletions. <em>Applied Statistics</em> <b>36</b>, 181&ndash;191.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>outlierTest(lm(prestige ~ income + education, data=Duncan))
</code></pre>

<hr>
<h2 id='panel.car'>Panel Function for Coplots</h2><span id='topic+panel.car'></span>

<h3>Description</h3>

<p>a panel function for use with <code>coplot</code> that plots points, a lowess line,
and a regression line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.car(x, y, col, pch, cex=1, span=0.5, lwd=2, 
  reg.line=lm, lowess.line=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.car_+3A_x">x</code></td>
<td>
<p>vector giving horizontal coordinates.</p>
</td></tr>
<tr><td><code id="panel.car_+3A_y">y</code></td>
<td>
<p>vector giving vertical coordinates.</p>
</td></tr>
<tr><td><code id="panel.car_+3A_col">col</code></td>
<td>
<p>point color.</p>
</td></tr>
<tr><td><code id="panel.car_+3A_pch">pch</code></td>
<td>
<p>plotting character for points.</p>
</td></tr>
<tr><td><code id="panel.car_+3A_cex">cex</code></td>
<td>
<p>character expansion factor for points.</p>
</td></tr>
<tr><td><code id="panel.car_+3A_span">span</code></td>
<td>
<p>span for lowess smoother.</p>
</td></tr>
<tr><td><code id="panel.car_+3A_lwd">lwd</code></td>
<td>
<p>line width, default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="panel.car_+3A_reg.line">reg.line</code></td>
<td>
<p>function to compute coefficients of regression line,
or <code>FALSE</code> for no line.</p>
</td></tr>
<tr><td><code id="panel.car_+3A_lowess.line">lowess.line</code></td>
<td>
<p>if <code>TRUE</code> plot lowess smooth.</p>
</td></tr>
<tr><td><code id="panel.car_+3A_...">...</code></td>
<td>
<p>other arguments to pass to functions <code>lines</code>
and <code>regLine</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. This function is used for its side effect: producing
a panel in a coplot.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+coplot">coplot</a></code>, <code><a href="car.html#topic+regLine">regLine</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>coplot(prestige ~ income|education, panel=panel.car, 
  col="red", data=Prestige)
</code></pre>

<hr>
<h2 id='pointLabel'> Label placement for points to avoid overlaps  </h2><span id='topic+pointLabel'></span>

<h3>Description</h3>

<p>Use optimization routines to find good locations for point labels
without overlaps. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointLabel(x, y = NULL, labels = seq(along = x), cex = 1,
           method = c("SANN", "GA"),
           allowSmallOverlap = FALSE,
           trace = FALSE,
           doPlot = TRUE,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointLabel_+3A_x">x</code>, <code id="pointLabel_+3A_y">y</code></td>
<td>
<p> as with <code>plot.default</code>, these provide the x and y coordinates for
the point labels.  Any reasonable way of defining the coordinates is
acceptable.  See the function <code>xy.coords</code> for details. </p>
</td></tr>
<tr><td><code id="pointLabel_+3A_labels">labels</code></td>
<td>
<p> as with <code>text</code>, a character vector or expression specifying the text to be
written.  An attempt is made to coerce other language objects
(names and calls) to expressions, and vectors and other
classed objects to character vectors by <code>as.character</code>. </p>
</td></tr>
<tr><td><code id="pointLabel_+3A_cex">cex</code></td>
<td>
<p> numeric character expansion factor as with <code>text</code>. </p>
</td></tr>
<tr><td><code id="pointLabel_+3A_method">method</code></td>
<td>
<p> the optimization method, either &ldquo;SANN&rdquo; for simulated
annealing (the default) or &ldquo;GA&rdquo; for a genetic algorithm. </p>
</td></tr>
<tr><td><code id="pointLabel_+3A_allowsmalloverlap">allowSmallOverlap</code></td>
<td>
<p> logical; if <code>TRUE</code>, labels are allowed
a small overlap. The overlap allowed is 2% of the diagonal
distance of the plot area.</p>
</td></tr>
<tr><td><code id="pointLabel_+3A_trace">trace</code></td>
<td>
<p> logical; if <code>TRUE</code>, status updates are given as the optimization algorithms
progress.</p>
</td></tr>
<tr><td><code id="pointLabel_+3A_doplot">doPlot</code></td>
<td>
<p> logical; if <code>TRUE</code>, the labels are plotted on the
existing graph with <code>text</code>.</p>
</td></tr>
<tr><td><code id="pointLabel_+3A_...">...</code></td>
<td>
<p> arguments passed along to <code>text</code> to specify
labeling parameters such as <code>col</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eight positions are candidates for label placement, either
horizontally, vertically, or diagonally offset from the points. The
default position for labels is the top right diagonal relative to the
point (considered the preferred label position). 
</p>
<p>With the default settings, simulating annealing solves faster than the
genetic algorithm. It is an open question as to which settles into a
global optimum the best (both algorithms have parameters that may be
tweaked).
</p>
<p>The label positioning problem is NP-hard (nondeterministic
polynomial-time hard). Placement becomes difficult and slows
considerably with large numbers of points. This function places all
labels, whether overlaps occur or not. Some placement algorithms
remove labels that overlap.
</p>
<p>Note that only <code>cex</code> is used to calculate string width and
height (using <code>strwidth</code> and <code>strheight</code>), so passing a
different font may corrupt the label dimensions. You could get around
this by adjusting the font parameters with <code>par</code> prior to running
this function.
</p>


<h3>Value</h3>

<p>An <code>xy</code> list giving the <code>x</code> and <code>y</code> positions of the
label as would be placed by <code>text(xy, labels)</code>.
</p>


<h3>Note</h3>

<p>This function was moved from the <span class="pkg">maptools</span> package in anticipation of the retirement of that package, and with the permission of the function author.</p>


<h3>Author(s)</h3>

<p> Tom Short, EPRI, <a href="mailto:tshort@epri.com">tshort@epri.com</a> </p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Automatic_label_placement">https://en.wikipedia.org/wiki/Automatic_label_placement</a>
</p>
<p><a href="https://i11www.iti.uni-karlsruhe.de/map-labeling/bibliography/">https://i11www.iti.uni-karlsruhe.de/map-labeling/bibliography/</a>
</p>
<p><a href="http://www.eecs.harvard.edu/~shieber/Projects/Carto/carto.html">http://www.eecs.harvard.edu/~shieber/Projects/Carto/carto.html</a>
</p>
<p><a href="http://www.szoraster.com/Cartography/PracticalExperience.htm">http://www.szoraster.com/Cartography/PracticalExperience.htm</a>
</p>
<p>The genetic algorithm code was adapted from the python code at 
</p>
<p><a href="https://meta.wikimedia.org/wiki/Map_generator">https://meta.wikimedia.org/wiki/Map_generator</a>.
</p>
<p>The simulated annealing code follows the algorithm and guidelines in:
</p>
<p>Jon Christensen, Joe Marks, and Stuart Shieber. Placing text labels on
maps and diagrams. In Paul Heckbert, editor, Graphics Gems IV, pages
497-504. Academic Press, Boston, MA, 1994.
<a href="http://www.eecs.harvard.edu/~shieber/Biblio/Papers/jc.label.pdf">http://www.eecs.harvard.edu/~shieber/Biblio/Papers/jc.label.pdf</a>
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+text">text</a></code>, <code><a href="plotrix.html#topic+thigmophobe.labels">thigmophobe.labels</a></code>
in package <span class="pkg">plotrix</span> </p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
x &lt;- rnorm(n)*10
y &lt;- rnorm(n)*10
plot(x, y, col = "red", pch = 20)
pointLabel(x, y, as.character(round(x,5)), offset = 0, cex = .7)

plot(x, y, col = "red", pch = 20)
pointLabel(x, y, expression(over(alpha, beta[123])), offset = 0, cex = .8)

</code></pre>

<hr>
<h2 id='poTest'>Test for Proportional Odds in the Proportional-Odds Logistic-Regression Model</h2><span id='topic+poTest'></span><span id='topic+poTest.polr'></span><span id='topic+print.poTest'></span>

<h3>Description</h3>

<p>The <code>poTest</code> function implements tests proposed by Brant (1990) for proportional odds for
logistic models fit by the <code><a href="MASS.html#topic+polr">polr</a></code> function in the MASS package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poTest(model, ...)
## S3 method for class 'polr'
poTest(model, ...)
## S3 method for class 'poTest'
print(x, digits=3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poTest_+3A_model">model</code></td>
<td>
<p>a proptional-odds logit model fit by <code><a href="MASS.html#topic+polr">polr</a></code>.</p>
</td></tr>
<tr><td><code id="poTest_+3A_x">x</code></td>
<td>
<p>an object produced by <code>poTest</code>.</p>
</td></tr>
<tr><td><code id="poTest_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to print.</p>
</td></tr>
<tr><td><code id="poTest_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>poTest</code> returns an object meant to be printed showing the results of the tests.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>References</h3>

<p>R. Brant, &quot;Assessing proportionality in the proportional odds model for ordinal logistic regression.&quot;
Biometrics 46: 1171&ndash;1178, 1990.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("MASS")){
    .W &lt;- Womenlf
    .W$partic &lt;- factor(.W$partic, levels=c("not.work", "parttime", "fulltime"))
    poTest(polr(partic ~ hincome + children + region, data=.W))
}
</code></pre>

<hr>
<h2 id='powerTransform'>Finding Univariate or Multivariate Power Transformations</h2><span id='topic+powerTransform'></span><span id='topic+powerTransform.default'></span><span id='topic+powerTransform.lm'></span><span id='topic+powerTransform.formula'></span><span id='topic+powerTransform.lmerMod'></span>

<h3>Description</h3>

<p><code>powerTransform</code> uses the maximum likelihood-like approach of Box and Cox (1964) to select a transformatiion of a univariate or multivariate response for normality, linearity and/or constant variance.  Available families of transformations are the default Box-Cox power family and two additioal families that are modifications of the Box-Cox family that allow for (a few) negative responses. The summary method automatically computes two or three likelihood ratio type tests concerning the transformation powers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerTransform(object, ...)

## Default S3 method:
powerTransform(object, family="bcPower", ...)

## S3 method for class 'lm'
powerTransform(object, family="bcPower", ...)

## S3 method for class 'formula'
powerTransform(object, data, subset, weights, na.action,
    family="bcPower", ...)

## S3 method for class 'lmerMod'
powerTransform(object, family="bcPower", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerTransform_+3A_object">object</code></td>
<td>
<p>This can either be an object of class <code>lm</code> or <code>lmerMod</code>, a formula, or a
matrix or vector; see below.
</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_family">family</code></td>
<td>
<p>The quoted name of a family of transformations.  The available options are <code>"bcPower"</code>
for the default for the Box-Cox power family; <code>"bcnPower"</code> for a two-parameter modification of
the Box-Cox family that allows negative responses (Hawkins and Weisberg (2017)), and the
<code>"yjPower"</code> family (Yeo and Johnson(2000)), another
modifiation of the Box-Cox family that allows a few negative values.  All three families are documented
at <code><a href="car.html#topic+bcPower">bcPower</a></code>.
</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_data">data</code></td>
<td>
<p>A data frame or environment, as in &lsquo;<a href="stats.html#topic+lm">lm</a>&rsquo;.</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_subset">subset</code></td>
<td>
<p>Case indices to be used, as in &lsquo;<a href="stats.html#topic+lm">lm</a>&rsquo;.</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_weights">weights</code></td>
<td>
<p>Weights as in &lsquo;<a href="stats.html#topic+lm">lm</a>&rsquo;.</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_na.action">na.action</code></td>
<td>
<p>Missing value action, as in &lsquo;lm&rsquo;.</p>
</td></tr>
<tr><td><code id="powerTransform_+3A_...">...</code></td>
<td>
<p>Additional arguments that used in the interative algorithm; defaults are generally adequate.  For use with the <code>bcnPower</code> family, a convergence criterion can be set with <code>conv=.0001</code> the default, and a minimum positive value of the location parameter can be set, with default <code>gamma.min=.1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the Box and Cox (1964) method of selecting a power transformation of a variable toward normality, and its generalization by Velilla (1993) to a multivariate response.  Cook and Weisberg (1999) and Weisberg (2014) suggest the usefulness of transforming a set of predictors <code>z1, z2, z3</code> for multivariate normality.  It also includes two additional families that allow for negative values.
</p>
<p>If the <code>object</code> argument is of class &lsquo;lm&rsquo; or &lsquo;lmerMod&rsquo;, the Box-Cox procedure is applied to the conditional distribution of the response given the predictors.  For &lsquo;lm&rsquo; objects, the respose may be multivariate, and each column will have its own transformation.  With &lsquo;lmerMod&rsquo; the response must be univariate.
</p>
<p>The <code>object</code> argument may also be a formula.  For example, <code>z ~ x1 + x2 + x3</code> will estimate a transformation for the response <code>z</code> from a family after fitting a linear model with the given formula.  <code>cbind(y1, y2, y3) ~ 1</code> specifies transformations
to multivariate normality with no predictors.  A vector value for <code>object</code>, for example
<code>powerTransform(ais$LBM)</code>, is equivalent to<code>powerTransform(LBM ~ 1, ais)</code>.  Similarly, <code>powerTransform(cbind(ais$LBM, ais$SSF))</code>, where the first argument is a matrix rather than a formula is equivalent to specification of a mulitvariate linear model <code>powerTransform(cbind(LBM, SSF) ~ 1, ais)</code>.
</p>
<p>Three families of power transformations are available. The default Box-Cox power family (<code>family="bcPower"</code>) of power transformations effectively replaces a vector by that vector raised to a power, generally in the range from -3 to 3.  For powers close to zero, the log-transformtion is suggested.  In practical situations, after estimating a power using the <code>powerTransform</code> function, a variable would be replaced by a simple power transformation of it, for example, if <code class="reqn">\lambda\approx 0.5</code>, then the correspoding variable would be replaced by its square root; if <code class="reqn">\lambda</code> is close enough to zero, the the variable would be replaced by its natural logarithm.  The Box-Cox family requires the responses to be strictly positive.
</p>
<p>The <code>family="bcnPower"</code>, or Box-Cox with negatives, family proposed by Hawkins and Weisberg (2017)  allows for (a few) non-positive values, while allowing for the transformed data to be interpreted similarly to the interpretation of Box-Cox transformed values.  This family is the Box-Cox transformation of <code class="reqn">z = .5 * (y + (y^2 + \gamma^2)^{1/2})</code> that depends on a location parameter <code class="reqn">\gamma</code>.  The quantity <code class="reqn">z</code> is positive for all values of <code class="reqn">y</code>.  If <code class="reqn">\gamma = 0</code> and <code class="reqn">y</code> is strictly positive, then the Box-Cox and the bcnPower transformations are identical.  When fitting the Box-Cox with negatives family, <code>lambda</code> is restricted to the range [-3, 3], and <code>gamma</code> is restricted to the range from <code>gamma.min=.1</code> to the largest positive value of the variable, since values outside these ranges are unreasonable in practice.  The value of <code>gamma.min</code> can be changed with an argument to <code>powerTransform</code>.
</p>
<p>The final family <code>family="yjPower"</code> uses the Yeo-Johnson transformation, which is the Box-Cox transformation of <code class="reqn">U+1</code> for nonnegative values, and of <code class="reqn">|U|+1</code> with parameter <code class="reqn">2-\lambda</code> for <code class="reqn">U</code> negative and thus it provides a family for fitting when (a few) observations are negative.  Because of the unusual constraints on the powers for positive and negative data, this transformation is not used very often, as results are difficult to interpret.  In practical problems, a variable would be replaced by its Yeo-Johnson transformation computed using the <code><a href="car.html#topic+yjPower">yjPower</a></code> function.
</p>
<p>The function <code><a href="car.html#topic+testTransform">testTransform</a></code> is used to obtain likelihood ratio tests for any specified value for the transformation parameter(s).
</p>
<p>Computations maximize the likelihood-like functions described by Box and Cox (1964) and by Velilla (1993).  For univariate responses, the computations are very stable and problems are unlikely, although for &lsquo;lmer&rsquo; models computations may be very slow because the model is refit many times. For multivariate responses with the <code>bcnPower</code> family, the computing algorithm may fail.  In this case we recommend adding the argument <code>itmax = 1</code> to the call to <code>powerTransform</code>.  This will return the starting value estimates of the transformation parameters, fitting a d-dimensional response as if all the d responses were independent.
</p>


<h3>Value</h3>

<p>An object of class <code>powerTransform</code> or class <code>bcnPowerTransform</code> if <code>family="bcnPower"</code> that
inherits from <code>powerTransform</code> is returned, including the components listed below.
</p>
<p>A <code>summary</code> method presents estimated values for the transformation power <code>lambda</code> and for the &lsquo;bcnPower&rsquo; family the location parameter <code>gamma</code> as well.  Standard errors and Wald 95% confidence intervals based on the standard errors are computed from the inverse of the sample Hessian matrix evaluted at the estimates.  The interval estimates for the <code>gamma</code> parameters will generally be very wide, reflecting little information available about the location parameter.  Likelihood ratio type tests are also provided.  For the &lsquo;bcnPower&rsquo; family these are based on the profile loglikelihood for <code>lambda</code> alone; that is, we treat <code>gamma</code> as a nusiance parameter and average over it.
</p>
<p>The components of the returned object includes
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>Estimated transformation parameter</p>
</td></tr>
<tr><td><code>roundlam</code></td>
<td>
<p>Convenient rounded values for the estimates.  These rounded
values will  usually be the desired transformations.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>Estimated location parameters for <code>bcnPower</code>, <code>NULL</code> otherwise</p>
</td></tr>
<tr><td><code>invHess</code></td>
<td>
<p>Estimated covariance matrix of the estimated parameters</p>
</td></tr>
<tr><td><code>llik</code></td>
<td>
<p>Value of the log-likelihood at the estimates</p>
</td></tr>
</table>
<p>The <code>summary</code> method for <code>powerTransform</code> returns an array with columns labeled &quot;Est Power&quot; for the value of <code>lambda</code> that maximizes the likelihood; &quot;Rounded Pwr&quot; for <code>roundlam</code>,  and columns &quot;Wald Lwr Bnd&quot; and &quot;Wald Ur Bnd&quot; for a 95 percent Wald normal theory confidence interval for <code>lambda</code> computed as the estimate plus or minus 1.96 times the standard error.
</p>


<h3>Author(s)</h3>

<p> Sanford Weisberg, &lt;sandy@umn.edu&gt; </p>


<h3>References</h3>

<p>Box, G. E. P. and Cox, D. R. (1964) An analysis of transformations.
<em>Journal
of the Royal Statisistical Society, Series B</em>. 26 211-46.
</p>
<p>Cook, R. D. and Weisberg, S. (1999)  <em>Applied Regression Including
Computing
and Graphics</em>.  Wiley.
</p>
<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Hawkins, D. and Weisberg, S. (2017)
Combining the Box-Cox Power and Generalized Log Transformations to Accomodate Nonpositive  Responses In Linear and Mixed-Effects Linear Models <em>South African Statistics Journal</em>, 51, 317-328.
</p>
<p>Velilla, S. (1993)  A note on the multivariate Box-Cox transformation to
normality.  <em>Statistics and Probability Letters</em>, 17, 259-263.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley.
</p>
<p>Yeo, I. and Johnson, R. (2000) A new family of
power transformations to improve normality or symmetry.
<em>Biometrika</em>, 87, 954-959.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+testTransform">testTransform</a></code>, <code><a href="car.html#topic+bcPower">bcPower</a></code>, <code><a href="car.html#topic+bcnPower">bcnPower</a></code>, <code><a href="base.html#topic+transform">transform</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>, <code><a href="car.html#topic+boxCox">boxCox</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'># Box Cox Method, univariate
summary(p1 &lt;- powerTransform(cycles ~ len + amp + load, Wool))
# fit linear model with transformed response:
coef(p1, round=TRUE)
summary(m1 &lt;- lm(bcPower(cycles, p1$roundlam) ~ len + amp + load, Wool))

# Multivariate Box Cox uses Highway1 data
summary(powerTransform(cbind(len, adt, trks, sigs1) ~ 1, Highway1))

# Multivariate transformation to normality within levels of 'htype'
summary(a3 &lt;- powerTransform(cbind(len, adt, trks, sigs1) ~ htype, Highway1))

# test lambda = (0 0 0 -1)
testTransform(a3, c(0, 0, 0, -1))

# save the rounded transformed values, plot them with a separate
# color for each highway type
transformedY &lt;- bcPower(with(Highway1, cbind(len, adt, trks, sigs1)),
                        coef(a3, round=TRUE))
## Not run:  # generates a smoother warning
scatterplotMatrix( ~ transformedY|htype, Highway1) 

## End(Not run)

# With negative responses, use the bcnPower family
m2 &lt;- lm(I1L1 ~ pool, LoBD)
summary(p2 &lt;- powerTransform(m2, family="bcnPower"))
testTransform(p2, .5)
summary(powerTransform(update(m2, cbind(LoBD$I1L2, LoBD$I1L1) ~ .), family="bcnPower"))

## Not run:  # takes a few seconds:
  # multivariate bcnPower, with 8 responses
  summary(powerTransform(update(m2, as.matrix(LoBD[, -1]) ~ .), family="bcnPower"))
  # multivariate bcnPower, fit with one iteration using starting values as estimates
  summary(powerTransform(update(m2, as.matrix(LoBD[, -1]) ~ .), family="bcnPower", itmax=1))

## End(Not run)

# mixed effects model
## Not run:  # uses the lme4 package
  data &lt;- reshape(LoBD[1:20, ], varying=names(LoBD)[-1], direction="long", v.names="y")
  names(data) &lt;- c("pool", "assay", "y", "id")
  data$assay &lt;- factor(data$assay)
  require(lme4)
  m2 &lt;- lmer(y ~ pool + (1|assay), data)
  summary(l2 &lt;- powerTransform(m2, family="bcnPower", verbose=TRUE))

## End(Not run)
</code></pre>

<hr>
<h2 id='Predict'>
Model Predictions
</h2><span id='topic+Predict'></span><span id='topic+Predict.lm'></span>

<h3>Description</h3>

<p><code>Predict</code> is a generic function with, at present, a single method for <code>"lm"</code> objects,
<code>Predict.lm</code>, which is a modification of the standard <code><a href="stats.html#topic+predict.lm">predict.lm</a></code> method in
the <span class="pkg">stats</span> package, but with an additional <code>vcov.</code> argument for a user-specified covariance matrix for intreval estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Predict(object, ...)

## S3 method for class 'lm'
Predict(object, newdata, se.fit = FALSE, 
  scale = NULL, df = Inf, 
  interval = c("none", "confidence", "prediction"), 
  level = 0.95, type = c("response", "terms"), 
  terms = NULL, na.action = na.pass,
  pred.var = res.var/weights, weights = 1, vcov., ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Predict_+3A_object">object</code></td>
<td>
<p>a model object for which predictions are desired.</p>
</td></tr>
<tr><td><code id="Predict_+3A_newdata">newdata</code>, <code id="Predict_+3A_se.fit">se.fit</code>, <code id="Predict_+3A_scale">scale</code>, <code id="Predict_+3A_df">df</code>, <code id="Predict_+3A_interval">interval</code>, <code id="Predict_+3A_level">level</code>, <code id="Predict_+3A_type">type</code>, <code id="Predict_+3A_terms">terms</code>, <code id="Predict_+3A_na.action">na.action</code>, <code id="Predict_+3A_pred.var">pred.var</code>, <code id="Predict_+3A_weights">weights</code></td>
<td>
<p>see <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>.</p>
</td></tr>
<tr><td><code id="Predict_+3A_vcov.">vcov.</code></td>
<td>
<p>optional, either a function to compute the coefficient covariance matrix of 
<code>object</code> (e.g., <code><a href="car.html#topic+hccm">hccm</a></code>) or a coefficient covariance matrix (as returned,
e.g., by <code><a href="car.html#topic+hccm">hccm</a></code>).  To use a bootstrap to estimate the covariance matrix, set <code>vcov. = vcov(Boot(object))</code>.</p>
</td></tr>
<tr><td><code id="Predict_+3A_...">...</code></td>
<td>
<p>arguments to pass down to <code>Predict</code> or <code>predict</code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there is no appropriate method for <code>Predict</code>, then a <code><a href="stats.html#topic+predict">predict</a></code> method
is invoked. If there is a <em>specific</em> <code>predict</code> method for the primary class of <code>object</code> but
only an <em>inherited</em> <code>Predict</code> method, then the <code>predict</code> method is invoked.
Thus an object of class <code>c("glm", "lm")</code> will invoke method <code>predict.glm</code> rather than
<code>Predict.lm</code>, but an object of class <code>c("aov", "lm")</code> will invoke <code>Predict.lm</code>
rather than <code>predict.lm</code>.
</p>


<h3>Value</h3>

<p>See <code><a href="stats.html#topic+predict">predict</a></code> and <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+predict.lm">predict.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(interlocks ~ log(assets), data=Ornstein)
newd &lt;- data.frame(assets=exp(4:12))
(p1 &lt;- predict(mod, newd, interval="prediction"))
p2 &lt;- Predict(mod, newd, interval="prediction", vcov.=vcov)
all.equal(p1, p2) # the same

(predict(mod, newd, se=TRUE))
(p3 &lt;- Predict(mod, newd, se=TRUE, vcov.=hccm)) # larger SEs
p4 &lt;- Predict(mod, newd, se=TRUE, vcov.=hccm(mod, type="hc3"))
all.equal(p3, p4) # the same
</code></pre>

<hr>
<h2 id='qqPlot'>Quantile-Comparison Plot</h2><span id='topic+qqPlot'></span><span id='topic+qqp'></span><span id='topic+qqPlot.default'></span><span id='topic+qqPlot.formula'></span><span id='topic+qqPlot.lm'></span><span id='topic+qqPlot.glm'></span>

<h3>Description</h3>

<p>Plots empirical quantiles of a variable, or of studentized residuals from
a linear model, against theoretical quantiles of a comparison distribution.  Includes
options not available in the <code><a href="stats.html#topic+qqnorm">qqnorm</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqPlot(x, ...)

qqp(...)

## Default S3 method:
qqPlot(x, distribution="norm", groups, layout,
    ylim=range(x, na.rm=TRUE), ylab=deparse(substitute(x)),
    xlab=paste(distribution, "quantiles"), glab=deparse(substitute(groups)),
    main=NULL, las=par("las"),
    envelope=TRUE, col=carPalette()[1], col.lines=carPalette()[2],
    lwd=2, pch=1, cex=par("cex"),
    line=c("quartiles", "robust", "none"), id=TRUE, grid=TRUE, ...)

## S3 method for class 'formula'
qqPlot(formula, data, subset, id=TRUE, ylab, glab, ...)

## S3 method for class 'lm'
qqPlot(x, xlab=paste(distribution, "Quantiles"),
    ylab=paste("Studentized Residuals(",
                deparse(substitute(x)), ")", sep=""),
    main=NULL, distribution=c("t", "norm"),
    line=c("robust", "quartiles", "none"), las=par("las"),
    simulate=TRUE, envelope=TRUE,  reps=100,
    col=carPalette()[1], col.lines=carPalette()[2], lwd=2, pch=1, cex=par("cex"),
    id=TRUE, grid=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqPlot_+3A_x">x</code></td>
<td>
<p>vector of numeric values or <code>lm</code> object.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_distribution">distribution</code></td>
<td>
<p>root name of comparison distribution &ndash; e.g., <code>"norm"</code> for the
normal distribution; <code>t</code> for the t-distribution.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_groups">groups</code></td>
<td>
<p>an optional factor; if specified, a QQ plot will be drawn for <code>x</code>
within each level of <code>groups</code>.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_layout">layout</code></td>
<td>
<p>a 2-vector with the number of rows and columns for plotting by
groups &ndash; for example <code>c(1, 3)</code> for 1 row and 3 columns; if omitted, the
number of rows and columns will be selected automatically; the specified number
of rows and columns must be sufficient to accomodate the number of groups; ignored
if there is no grouping factor.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_formula">formula</code></td>
<td>
<p>one-sided formula specifying a single variable to be plotted or a two-sided formula of
the form <code>variable ~ factor</code>, where a QQ plot will be drawn for <code>variable</code> within each
level of <code>factor</code>.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_data">data</code></td>
<td>
<p>optional data frame within which to evaluage the formula.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_subset">subset</code></td>
<td>
<p>optional subset expression to select cases to plot.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_ylim">ylim</code></td>
<td>
<p>limits for vertical axis; defaults to the range of <code>x</code>. If plotting by groups, a common
y-axis is used for all groups.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_ylab">ylab</code></td>
<td>
<p>label for vertical (empirical quantiles) axis.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_xlab">xlab</code></td>
<td>
<p>label for horizontal (comparison quantiles) axis.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_glab">glab</code></td>
<td>
<p>label for the grouping variable.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_main">main</code></td>
<td>
<p>label for plot.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_envelope">envelope</code></td>
<td>
<p><code>TRUE</code> (the default), <code>FALSE</code>, a confidence level such as <code>0.95</code>, or a list specifying how to plot a point-wise confidence envelope (see Details).</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_las">las</code></td>
<td>
<p>if <code>0</code>, ticks labels are drawn parallel to the
axis; set to <code>1</code> for horizontal labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_col">col</code></td>
<td>
<p>color for points; the default is the <em>first</em> entry
in the current <span class="pkg">car</span> palette (see <code><a href="car.html#topic+carPalette">carPalette</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_col.lines">col.lines</code></td>
<td>
<p>color for lines; the default is the <em>second</em> entry
in the current <span class="pkg">car</span> palette.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_pch">pch</code></td>
<td>
<p>plotting character for points; default is <code>1</code>
(a circle, see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_cex">cex</code></td>
<td>
<p>factor for expanding the size of plotted symbols; the default is
<code>1</code>.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code>, no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method="y", n=2, cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the 2 points with the most extreme
verical values &mdash; studentized residuals for the <code>"lm"</code> method. Points labels are by default
taken from the names of the variable being plotted is any, else case indices are used.  Unlike most graphical functions in <span class="pkg">car</span>, the default is <code>id=TRUE</code> to include point identification.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>2</code> (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_line">line</code></td>
<td>
<p><code>"quartiles"</code> to pass a line through the quartile-pairs, or
<code>"robust"</code> for a robust-regression line; the latter uses the <code>rlm</code>
function in the <code>MASS</code> package. Specifying <code>line = "none"</code> suppresses the line.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_simulate">simulate</code></td>
<td>
<p>if <code>TRUE</code> calculate confidence envelope by parametric bootstrap;
for <code>lm</code> object only. The method is due to Atkinson (1985).</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_reps">reps</code></td>
<td>
<p>integer; number of bootstrap replications for confidence envelope.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_...">...</code></td>
<td>
<p>arguments such as <code>df</code> to be passed to the appropriate quantile function.</p>
</td></tr>
<tr><td><code id="qqPlot_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws theoretical quantile-comparison plots for variables and for studentized residuals
from a linear model. A comparison line is drawn on the plot either through the quartiles
of the two distributions, or by robust regression.
</p>
<p>Any distribution for which quantile and
density functions exist in R (with prefixes <code>q</code> and <code>d</code>, respectively) may be used.
When plotting a vector, the confidence envelope is based on the SEs of the order statistics
of an independent random sample from the comparison distribution (see Fox, 2016).
Studentized residuals from linear models are plotted against the appropriate t-distribution with a point-wise
confidence envelope computed by default by a parametric bootstrap,
as described by Atkinson (1985).
The function <code>qqp</code> is an abbreviation for <code>qqPlot</code>.
</p>
<p>The <code>envelope</code> argument can take a list with the following named elements; if an element is missing, then the default value is used:
</p>

<dl>
<dt><code>level</code></dt><dd><p>confidence level (default <code>0.95</code>).</p>
</dd>
<dt><code>style</code></dt><dd><p>one of <code>"filled"</code> (the default), <code>"lines"</code>, or <code>"none"</code>.</p>
</dd>
<dt><code>col</code></dt><dd><p>color (default is the value of <code>col.lines</code>).</p>
</dd>
<dt><code>alpha</code></dt><dd><p>transparency/opacity of a filled confidence envelope, a number between 0 and 1 (default <code>0.15</code>).</p>
</dd>
<dt><code>border</code></dt><dd><p>controls whether a border is drawn around a filled confidence envelope (default <code>TRUE</code>).</p>
</dd>
</dl>



<h3>Value</h3>

<p>These functions return the labels of identified points, unless a grouping factor is employed,
in which case <code>NULL</code> is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.
</p>
<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Atkinson, A. C. (1985)
<em>Plots, Transformations, and Regression.</em> Oxford.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqplot">qqplot</a></code>, <code><a href="stats.html#topic+qqnorm">qqnorm</a></code>,
<code><a href="stats.html#topic+qqline">qqline</a></code>, <code><a href="car.html#topic+showLabels">showLabels</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rchisq(100, df=2)
qqPlot(x)
qqPlot(x, dist="chisq", df=2, envelope=list(style="lines"))

qqPlot(~ income, data=Prestige, subset = type == "prof")
qqPlot(income ~ type, data=Prestige, layout=c(1, 3))

qqPlot(lm(prestige ~ income + education + type, data=Duncan),
	envelope=.99)
</code></pre>

<hr>
<h2 id='recode'>Recode a Variable</h2><span id='topic+recode'></span><span id='topic+Recode'></span>

<h3>Description</h3>

<p>Recodes a numeric vector, character vector, or factor 
according to simple recode specifications. <code>Recode</code>
is an alias for <code>recode</code> that avoids name clashes
with packages, such as <span class="pkg">Hmisc</span>, that have a <code>recode</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode(var, recodes, as.factor, as.numeric=TRUE, levels, 
       to.value="=", interval=":", separator=";")

Recode(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_+3A_var">var</code></td>
<td>
<p>numeric vector, character vector, or factor.</p>
</td></tr>
<tr><td><code id="recode_+3A_recodes">recodes</code></td>
<td>
<p>character string of recode specifications:
see below.</p>
</td></tr>
<tr><td><code id="recode_+3A_as.factor">as.factor</code></td>
<td>
<p>return a factor; default is <code>TRUE</code> if 
<code>var</code> is a factor, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="recode_+3A_as.numeric">as.numeric</code></td>
<td>
<p>if <code>TRUE</code> (the default), and <code>as.factor</code> is <code>FALSE</code>, 
then the result will be coerced to numeric
if all values in the result can represent numbers (contain only numerals,
minus signs, etc.).</p>
</td></tr>
<tr><td><code id="recode_+3A_levels">levels</code></td>
<td>
<p>an optional argument specifying the order of the
levels in the returned factor; the default is to use the sort order
of the level names.</p>
</td></tr>
<tr><td><code id="recode_+3A_to.value">to.value</code></td>
<td>
<p>The operator to separate old from new values, <code>"="</code>
by default; some other possibilities: <code>"-&gt;"</code>, <code>"~"</code>, <code>"~&gt;"</code>.
Cannot include the interval operator (by default <code>:</code>) or the separator string (by default, <code>;</code>), 
so, e.g., by default <code>":=&gt;"</code> is not allowed. The discussion
in Details assumes the default <code>"="</code>. Use a non-default <code>to.value</code> if
factor levels contain <code>=</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_interval">interval</code></td>
<td>
<p>the operator used to denote numeric intervals, by default <code>":"</code>. The discussion in Details assumes the default <code>":"</code>. Use a non-default <code>interval</code> if factor levels contain <code>:</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_separator">separator</code></td>
<td>
<p>the character string used to separate recode specifications, by default <code>";"</code>. The discussion in Details assumes the default <code>";"</code>. Use a non-default <code>separator</code> if factor levels contain <code>;</code>.</p>
</td></tr>
<tr><td><code id="recode_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>recode</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recode specifications appear in a character string, separated by default by
semicolons (see the examples below), each of the form <code>input=output</code>
(where <code>=</code> may be replaced by a non-default value of the
<code>to.value</code> argument, e.g., <code>input -&gt; output</code>). Spaces may be
used for clarity.
If an input value satisfies more than one specification, 
then the first (from left to right) applies.
If no specification is satisfied, then the input value is carried
over to the result. <code>NA</code> is allowed on input and output.
Several recode specifications are supported:
</p>

<dl>
<dt>single value</dt><dd><p>For example, <code>0=NA</code>.</p>
</dd>
<dt>vector of values</dt><dd><p>For example, <code>c(7, 8, 9) = 'high'</code>.</p>
</dd>
<dt>range of values</dt><dd><p>For example, <code>7:9 = 'C'</code>. The special values <code>lo</code>
and <code>hi</code> may appear in a range. For example, <code>lo:10=1</code>. <em>Note:</em> <code>:</code> is
<em>not</em> the R sequence operator.  In addition, you may not use <code>:</code> with the <code>c</code> function within a recode specification, so for example <code>c(1, 3, 5:7)</code> will cause an error. The <code>:</code> is the default value of the <code>recode</code> <code>interval</code> operator; a non-default value may be specified.</p>
</dd>
<dt><code>else</code></dt><dd><p>everything that does not fit a previous specification.
For example, <code>else = NA</code>. Note that <code>else</code> matches <em>all</em> otherwise
unspecified values on input, including <code>NA</code>, and if present should appear last among the recode specifications.</p>
</dd>
</dl>

<p>Character data and factor levels on the left-hand side of a recode specification must be quoted. Thus,
e.g., <code>c(a, b, c) = 'low'</code> is not allowed, and should be <code>c('a', 'b', 'c') = 'low'</code>. 
Similarly, the colon is reserved for numeric data, and, e.g., <code>c('a':'c') = 'low'</code> is not allowed. 
If the <code>var</code> argument is a character variable with (some) values that are character representations of numbers, or a factor
with (some) levels that are numbers (e.g., <code>'12'</code> or <code>'-2'</code>), then these too must be quoted 
and cannot be used with colons (e.g., <code>'15':'19' = '15 to 19'</code> is not allowed, and could be
specified as <code>c('15', '16', '17', '18', '19') = '15 to 19'</code>, assuming that all values are 
the character representation of whole numbers).
</p>
<p>If all of the output values are numeric, and if <code>as.factor</code> is 
<code>FALSE</code>, then a numeric result is returned; if <code>var</code> is a factor,
then by default so is the result.
</p>


<h3>Value</h3>

<p>a recoded vector of the same length as <code>var</code>.
</p>


<h3>Warning</h3>

<p>The factor levels may not contain the character strings in <code>to.value</code> (by default <code>"="</code>), interval (by default <code>":"</code>), or <code>separator</code> (by default <code>";"</code>).
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>, <code><a href="base.html#topic+factor">factor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rep(1:3, 3)
x
recode(x, "c(1, 2) = 'A'; 
           else = 'B'")
Recode(x, "1~2 -&gt; ':=1' // 3 -&gt; ';=2'", to.value="-&gt;", 
       interval="~", separator="//")
</code></pre>

<hr>
<h2 id='regLine'>Plot Regression Line</h2><span id='topic+regLine'></span>

<h3>Description</h3>

<p>Plots a regression line on a scatterplot; the line is plotted 
between the minimum and maximum x-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regLine(mod, col=carPalette()[2], lwd=2, lty=1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regLine_+3A_mod">mod</code></td>
<td>
<p>a model, such as produced by <code>lm</code>,
that responds to the <code>coef</code> function
by returning a 2-element vector, whose elements are
interpreted respectively as the
intercept and slope of a regresison line.</p>
</td></tr>
<tr><td><code id="regLine_+3A_col">col</code></td>
<td>
<p>color for points and lines; the default is the <em>second</em> entry
in the current <span class="pkg">car</span> palette (see <code><a href="car.html#topic+carPalette">carPalette</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="regLine_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>2</code> (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="regLine_+3A_lty">lty</code></td>
<td>
<p>line type; default is <code>1</code>, a solid line (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="regLine_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to the
<code>lines</code> plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast to <code>abline</code>, this function plots only over
the range of the observed x-values. The x-values are extracted from
<code>mod</code> as the second column of the model matrix. 
</p>


<h3>Value</h3>

<p><code>NULL</code>. This function is used for its side effect: adding
a line to the plot.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+abline">abline</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(repwt ~ weight, pch=c(1,2)[sex], data=Davis)
regLine(lm(repwt~weight, subset=sex=="M", data=Davis))
regLine(lm(repwt~weight, subset=sex=="F", data=Davis), lty=2)
</code></pre>

<hr>
<h2 id='residualPlots'>Residual Plots for Linear and Generalized Linear Models</h2><span id='topic+residualPlots'></span><span id='topic+residualPlots.default'></span><span id='topic+residualPlots.lm'></span><span id='topic+residualPlots.glm'></span><span id='topic+residualPlot'></span><span id='topic+residualPlot.default'></span><span id='topic+residualPlot.lm'></span><span id='topic+residualPlot.glm'></span><span id='topic+residCurvTest'></span><span id='topic+residCurvTest.lm'></span><span id='topic+residCurvTest.glm'></span><span id='topic+tukeyNonaddTest'></span>

<h3>Description</h3>

<p>Draws a plot or plots of residuals versus one or more term in a mean function and/or versus
fitted values.  For linear models curvature tests are computed for each of the plots
by adding a quadratic term to the regression function and testing the quadratic to be zero.  This is Tukey's test for nonadditivity when plotting against fitted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>### This is a generic function with only one required argument:

residualPlots (model, ...)

## Default S3 method:
residualPlots(model, terms= ~ . , 
            layout=NULL, ask, main="", 
            fitted=TRUE, AsIs=TRUE, plot=TRUE, tests=TRUE, groups, ...)

## S3 method for class 'lm'
residualPlots(model, ...)

## S3 method for class 'glm'
residualPlots(model, ...)

### residualPlots calls residualPlot, so these arguments can be
### used with either function

residualPlot(model, ...)

## Default S3 method:
residualPlot(model, variable = "fitted", type = "pearson",
     groups, plot = TRUE, linear = TRUE,     
     quadratic = if(missing(groups)) TRUE else FALSE, 
     smooth=FALSE, id=FALSE,
     col = carPalette()[1], col.quad = carPalette()[2], pch=1,
     xlab, ylab, lwd=1, grid=TRUE, key=!missing(groups), ...)

## S3 method for class 'lm'
residualPlot(model, ...)

## S3 method for class 'glm'
residualPlot(model, variable = "fitted", type = "pearson",
    plot = TRUE, quadratic = FALSE, smooth=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residualPlots_+3A_model">model</code></td>
<td>

<p>A regression object.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_terms">terms</code></td>
<td>

<p>A one-sided formula that specifies a subset of the terms that appear in the formula that defined the model. The default
<code>~ .</code> is to plot against all first-order terms.  Interactions are skipped.  For example, the
specification <code>terms = ~ . - X3</code> would plot against all terms
except for <code>X3</code>.  To get a plot against fitted values only, use the
arguments <code>terms = ~ 1</code>.  If a term like <code>log(X1)</code> is in the formula, then the corresponding
plot is obtained using <code>terms = ~ log(X1)</code>.
For polynomial terms generated using the <code>poly</code> function, the
plot is against the first-order variable, which may be centered and scaled
depending on how the arguments to the <code>poly</code> function. Plots against factors
are boxplots.  Plots against splines use the
result of <code>predict(model), type="terms")[, variable])</code> as the
horizontal axis.
</p>
<p>A grouping variable can also be specified, so, for example
<code>terms= ~ .|type</code> would use the factor <code>type</code> to set a different
color and symbol for each level of <code>type</code>.  Any fits in the plots will
also be done separately for each level of group.  This can be useful of finding interactions
between the grouping variable and the term on the horizontal axis.  The grouping variable can
also be set using the argument <code>goups="type"</code>.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_layout">layout</code></td>
<td>

<p>If set to a value like <code>c(1, 1)</code> or <code>c(4, 3)</code>, the layout
of the graph will have this many rows and columns per &quot;page&quot; with a prompt given the in console to change to the next page.  If not set, the program
will select an appropriate layout.  If the number of graphs exceed nine, you
must select the layout yourself, or you will get a maximum of nine per page.
If <code>layout=NA</code>, the function does not set the layout and the user can
use the <code>par</code> function to control the layout, for example to have
plots from two models in the same graphics window.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_ask">ask</code></td>
<td>

<p>If <code>TRUE</code>, ask the user before drawing the next plot; if <code>FALSE</code>, don't
ask.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_main">main</code></td>
<td>

<p>Main title for the graphs.  The default is <code>main=""</code> for no title.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_fitted">fitted</code></td>
<td>

<p>If <code>TRUE</code>, the default, include the plot against fitted values.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_asis">AsIs</code></td>
<td>

<p>Some terms in a model formula use the as-is or identity function, for example a term like <code>I(X^2)</code> to include a quadratic.  These terms will be skipped in plotting if <code>AsIs</code> is <code>FALSE</code>.  The default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code>, draw the plot(s).
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_tests">tests</code></td>
<td>

<p>If <code>TRUE</code>, display the curvature tests.  
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_...">...</code></td>
<td>

<p>Additional arguments passed to <code>residualPlot</code> and then to
<code>plot</code>.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_variable">variable</code></td>
<td>

<p>Quoted variable name for the factor or regressor to be put on the horizontal axis, or
the default <code>"fitted"</code> to plot versus fitted values.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_type">type</code></td>
<td>

<p>Specifies the type of residual to be plotted.  Any of <code>c("working", "response", "deviance", "pearson", "partial", "rstudent", "rstandard")</code> may be specified.  The default <code>type = "pearson"</code> is usually appropriate, since it is equal to ordinary residuals observed minus fit with ols, and correctly weighted residuals with wls or for a glm.  The last two options use the <code><a href="stats.html#topic+rstudent">rstudent</a></code> and <code><a href="stats.html#topic+rstandard">rstandard</a></code> functions and use studentized or standardized residuals.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_groups">groups</code></td>
<td>
<p>A grouping indicator, provided as the quoted name of a grouping variable in the model, such as &quot;type&quot;, or &quot;ageGroup&quot;.  Points in different
groups will be plotted with different colors and symbols. If missing, no grouping is used.  In <code>residualPlots</code>, the grouping variable can also be set in the <code>terms</code>
argument, as described above.  The default is no grouping. 
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_linear">linear</code></td>
<td>
<p>If <code>TRUE</code>, adds a horizontal line at zero if no groups.
With groups, within level of groups display the ols regression of the residuals
as response and the horizontal axis as the regressor.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_quadratic">quadratic</code></td>
<td>

<p>if <code>TRUE</code>, fits the quadratic regression of the
vertical axis on the horizontal axis and displays a lack of fit test.  Default
is <code>TRUE</code> for <code>lm</code> and <code>FALSE</code> for <code>glm</code> or if <code>groups</code>
not missing.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_smooth">smooth</code></td>
<td>
<p>specifies the smoother to be used along with its arguments; if <code>FALSE</code>, which is the default except for
generalized linear models, no smoother is shown;
can be a list giving the smoother function and its named arguments; <code>TRUE</code> is equivalent to
<code>list(smoother=loessLine, span=2/3, col=carPalette()[3])</code>, which is the default for a GLM.
See <code><a href="car.html#topic+ScatterplotSmoothers">ScatterplotSmoothers</a></code> for the smoothers supplied by the
<span class="pkg">car</span> package and their arguments.</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method="r", n=2, cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points with the largest absolute residuals.</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_col">col</code></td>
<td>

<p>default color for points.  If groups is set, col can be a list at least
as long as the number of levels for groups giving the colors for each groups.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_col.quad">col.quad</code></td>
<td>

<p>default color for quadratic fit if groups is missing.  Ignored if groups are used.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_pch">pch</code></td>
<td>
<p>plotting character.  The default is pch=1.  If groups are used,
pch can be set to a vector at least as long as the number of groups.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_xlab">xlab</code></td>
<td>

<p>X-axis label.  If not specified, a useful label is constructed by
the function.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_ylab">ylab</code></td>
<td>

<p>Y-axis label.  If not specified, a useful label is constructed by
the function.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_lwd">lwd</code></td>
<td>

<p>line width for the quadratic fit, if any.
</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph</p>
</td></tr>
<tr><td><code id="residualPlots_+3A_key">key</code></td>
<td>
<p>Should a key be added to the plot?  Default is <code>!is.null(groups)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>residualPlots</code> draws one or more residuals plots depending on the
value of the <code>terms</code> and <code>fitted</code> arguments.  If <code>terms = ~ .</code>,
the default, then a plot is produced of residuals versus each first-order
term in the formula used to create the model.  A plot of
residuals versus fitted values is also included unless <code>fitted=FALSE</code>.  Setting <code>terms = ~1</code>
will provide only the plot against fitted values.
</p>
<p>A table of curvature tests is displayed for linear models. For plots
against a term in the model formula, say <code>X1</code>, the test displayed is
the t-test for for <code>I(X1^2)</code> in the fit of <code>update, model, ~. + I(X1^2))</code>.
Econometricians call this a specification test.  For factors, the displayed
plot is a boxplot, no curvature test is computed, and grouping is ignored.
For fitted values in a linear model, the test is Tukey's one-degree-of-freedom test for
nonadditivity.  You can suppress the tests with the argument <code>tests=FALSE</code>.
If grouping is used curvature tests are not displayed.
</p>
<p><code>residualPlot</code>, which is called by <code>residualPlots</code>,
should be viewed as an internal function, and is included here to display its
arguments, which can be used with <code>residualPlots</code> as well.  The
<code>residualPlot</code> function returns the curvature test as an invisible result.
</p>
<p><code>residCurvTest</code> computes the curvature test only.  For any factors a
boxplot will be drawn.  For any polynomials, plots are against the linear term.
Other non-standard predictors like B-splines are skipped.
</p>


<h3>Value</h3>

<p>For <code>lm</code> objects,
returns a data.frame with one row for each plot drawn, one column for
the curvature test statistic, and a second column for the corresponding
p-value.  This function is used primarily for its side effect of drawing
residual plots.
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg, <a href="mailto:sandy@umn.edu">sandy@umn.edu</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition.  Sage.
</p>
<p>Weisberg, S. (2014) <em>Applied
Linear Regression</em>, Fourth Edition, Wiley, Chapter 8</p>


<h3>See Also</h3>

<p>See Also <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="graphics.html#topic+identify">identify</a></code>,
<code><a href="car.html#topic+showLabels">showLabels</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lm(prestige ~ income + type, data=Prestige)
residualPlots(m1)
residualPlots(m1, terms= ~ 1 | type) # plot vs. yhat grouping by type
</code></pre>

<hr>
<h2 id='S'>
Modified Functions for Summarizing Linear, Generalized Linear, and Some Other Models
</h2><span id='topic+S'></span><span id='topic+Confint'></span><span id='topic+S.lm'></span><span id='topic+S.glm'></span><span id='topic+S.default'></span><span id='topic+S.multinom'></span><span id='topic+S.polr'></span><span id='topic+S.lme'></span><span id='topic+S.lmerMod'></span><span id='topic+S.glmerMod'></span><span id='topic+S.data.frame'></span><span id='topic+print.S.lm'></span><span id='topic+print.S.glm'></span><span id='topic+print.S.multinom'></span><span id='topic+print.S.polr'></span><span id='topic+print.S.lme'></span><span id='topic+print.S.lmerMod'></span><span id='topic+print.S.glmerMod'></span><span id='topic+Confint.lm'></span><span id='topic+Confint.glm'></span><span id='topic+Confint.multinom'></span><span id='topic+Confint.polr'></span><span id='topic+Confint.lme'></span><span id='topic+Confint.lmerMod'></span><span id='topic+Confint.glmerMod'></span><span id='topic+Confint.default'></span>

<h3>Description</h3>

<p><span class="pkg">car</span> package replacements for the <code><a href="base.html#topic+summary">summary</a></code> (<code>S</code>) and <code><a href="stats.html#topic+confint">confint</a></code> (<code>Confint</code>) functions for <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="mgcv.html#topic+multinom">multinom</a></code>, and <code><a href="MASS.html#topic+polr">polr</a></code> objects, with additional arguments but the same defaults as the original functions. The <code>Confint</code> method for <code>"polr"</code> objects profiles the likelihood to get confidence intervals for the regression parameters but uses Wald intervals for the thresholds.
Default methods that call the standard R <code><a href="base.html#topic+summary">summary</a></code> and <code><a href="stats.html#topic+confint">confint</a></code> functions are provided for the <code>S</code> and <code>Confint</code> generics, so the <span class="pkg">car</span> functions should be safe to use in general. The default method for <code>Confint</code> also assumes that there is an appropriate <code><a href="stats.html#topic+coef">coef</a></code> method. For briefer model summaries, see <code><a href="car.html#topic+brief">brief</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
S(object, brief, ...)

## S3 method for class 'lm'
S(object, brief=FALSE,
    correlation = FALSE, symbolic.cor = FALSE,
    vcov. = vcov(object, complete=FALSE), header = TRUE,
    resid.summary = FALSE, adj.r2 = FALSE,
    ...)

## S3 method for class 'glm'
S(object, brief=FALSE,
    exponentiate, dispersion, correlation = FALSE, symbolic.cor = FALSE,
    vcov. = vcov(object, complete=FALSE), header = TRUE,
    resid.summary = FALSE, ...)

## S3 method for class 'multinom'
S(object, brief=FALSE, exponentiate=FALSE, ...)

## S3 method for class 'polr'
S(object, brief=FALSE, exponentiate=FALSE, ...)

## S3 method for class 'lme'
S(object, brief=FALSE, correlation=FALSE, ...)

## S3 method for class 'lmerMod'
S(object, brief=FALSE, KR=FALSE, correlation=FALSE, ...)

## S3 method for class 'glmerMod'
S(object, brief=FALSE, correlation=FALSE, exponentiate, ...)

## S3 method for class 'data.frame'
S(object, brief=FALSE, ...)

## Default S3 method:
S(object, brief, ...)

## S3 method for class 'S.lm'
print(x, digits = max(3, getOption("digits") - 3),
    symbolic.cor = x$symbolic.cor, signif.stars = getOption("show.signif.stars"), ...)

## S3 method for class 'S.glm'
print(x, digits = max(3L, getOption("digits") - 3L),
    symbolic.cor = x$symbolic.cor, signif.stars = getOption("show.signif.stars"), ...)

## S3 method for class 'S.multinom'
print(x, digits = max(3, getOption("digits") - 3),
    signif.stars = getOption("show.signif.stars"), ...)

## S3 method for class 'S.polr'
print(x, digits = max(3, getOption("digits") - 3),
    signif.stars = getOption("show.signif.stars"), ...)

## S3 method for class 'S.lme'
print(x, digits=max(3, getOption("digits") - 3),
    signif.stars = getOption("show.signif.stars"), ...)

## S3 method for class 'S.lmerMod'
print(x, digits=max(3, getOption("digits") - 3),
    signif.stars = getOption("show.signif.stars"), ...)

## S3 method for class 'S.glmerMod'
print(x, digits=max(3, getOption("digits") - 3),
    signif.stars = getOption("show.signif.stars"), ...)

Confint(object, ...)

## S3 method for class 'lm'
Confint(object, estimate=TRUE,
    parm, level=0.95, vcov.=vcov(object, complete=FALSE), ...)

## S3 method for class 'glm'
Confint(object, estimate=TRUE, exponentiate=FALSE,
    vcov., dispersion, type=c("LR", "Wald"), ...)

## S3 method for class 'polr'
Confint(object, estimate=TRUE, exponentiate=FALSE,
    thresholds=!exponentiate, ...)

## S3 method for class 'multinom'
Confint(object, estimate=TRUE, exponentiate=FALSE, ...)

## S3 method for class 'lme'
Confint(object, estimate=TRUE, level=0.95, ...)

## S3 method for class 'lmerMod'
Confint(object, estimate=TRUE, level=0.95, ...)

## S3 method for class 'glmerMod'
Confint(object, estimate=TRUE, level=0.95,
    exponentiate=FALSE, ...)

## Default S3 method:
Confint(object, estimate=TRUE, level=0.95, vcov., ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S_+3A_object">object</code></td>
<td>

<p>a model or other object, e.g., of class <code>"lm"</code> as produced by a call to <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
</td></tr>
<tr><td><code id="S_+3A_exponentiate">exponentiate</code></td>
<td>
<p>for a <code>"glm"</code> or <code>"glmerMod"</code> model using the <code>log</code> or <code>logit</code> link, or a
<code>"polr"</code> or <code>"multinom"</code> model, show exponentiated coefficient estimates and confidence bounds.</p>
</td></tr>
<tr><td><code id="S_+3A_correlation">correlation</code>, <code id="S_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>see <code><a href="stats.html#topic+summary.lm">summary.lm</a></code></p>
</td></tr>
<tr><td><code id="S_+3A_x">x</code>, <code id="S_+3A_digits">digits</code>, <code id="S_+3A_signif.stars">signif.stars</code></td>
<td>
<p>see <code><a href="stats.html#topic+summary.lm">summary.lm</a></code></p>
</td></tr>
<tr><td><code id="S_+3A_dispersion">dispersion</code></td>
<td>
<p>see <code><a href="stats.html#topic+summary.glm">summary.glm</a></code></p>
</td></tr>
<tr><td><code id="S_+3A_vcov.">vcov.</code></td>
<td>
<p>either a matrix giving the estimated covariance matrix of the estimates, or a function that
when called with <code>object</code> as an argument returns an estimated covariance matrix of the estimates.
The default of <code>vcov. = vcov</code> uses the usual estimated covariance matrix.  Other choices include
the functions documented at <code><a href="car.html#topic+hccm">hccm</a></code>.  See example below for using a bootstrap to estimate  the
covariance matrix.  For the <code>glm</code> methods of <code>Confint</code> and <code>S</code>, if the <code>vcov.</code> or
<code>dispersion</code> argument is specified, then Wald-based confidence limits are computed;
otherwise the reported confidence limits are computed by profiling the likelihood.
NOTE:  The <code>dispersion</code> and <code>vcov.</code> arguments may not <em>both</em> be specified.
</p>
</td></tr>
<tr><td><code id="S_+3A_header">header</code></td>
<td>

<p>if <code>TRUE</code>, print the header for the summary output, default is <code>TRUE</code>
</p>
</td></tr>
<tr><td><code id="S_+3A_resid.summary">resid.summary</code></td>
<td>

<p>if <code>TRUE</code>, print the five-number summary of the residuals in the summary, defaults to <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="S_+3A_adj.r2">adj.r2</code></td>
<td>

<p>if <code>TRUE</code>, print the adjusted r-squared in the summary, default is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="S_+3A_brief">brief</code></td>
<td>

<p>if <code>TRUE</code>, set <code>header</code>, <code>resid.summary</code> and <code>adj.r.squared</code> to <code>FALSE</code>, and suppress exponeniated coefficients for GLMs with log or logit link. For a data frame, equivalent to use of <code><a href="car.html#topic+brief">brief</a></code>.
</p>
</td></tr>
<tr><td><code id="S_+3A_kr">KR</code></td>
<td>
<p>if <code>TRUE</code> (default is <code>FALSE</code>), compute Kenward-Roger standard errors and
Satterthwaite degrees of freedom for t-tests. <em>Warning:</em> This computation can be very time-consuming.</p>
</td></tr>
<tr><td><code id="S_+3A_parm">parm</code>, <code id="S_+3A_level">level</code></td>
<td>
<p>see <code><a href="stats.html#topic+confint">confint</a></code></p>
</td></tr>
<tr><td><code id="S_+3A_estimate">estimate</code></td>
<td>
<p>show the estimated coefficients in the confidence-interval table; default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="S_+3A_thresholds">thresholds</code></td>
<td>
<p>show confidence intervals for the estimated thresholds in the <code>"polr" model.</code></p>
</td></tr>
<tr><td><code id="S_+3A_type">type</code></td>
<td>
<p>if <code>"LR"</code> (the default) compute confidence intervals based on the LR statistics by profiling the likelihood; if <code>"Wald"</code> base confidence intervals on the Wald statistic using the coefficient standard error and the normal distribution.</p>
</td></tr>
<tr><td><code id="S_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed down, for consistency with <code>summary</code> and <code>confint</code> methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these functions mimic functions in the <span class="pkg">stats</span> and other standard R packages for summarizing aspects of linear, generalized linear, and some other statistical models. The 
<code>S</code> function also provides an alterntive to <code>summary</code> for data frames, treating character variables as if they were factors.
</p>
<p>The <code>S</code> and <code>Confint</code> functions add support for the <code>vcov.</code> argument for linear models, which allows specifying a covariance matrix for the regression coefficients other than the usual covariance matrix returned by the function <code><a href="stats.html#topic+vcov">vcov</a></code>.  This argument may be either the name of a function, so that the call to <code>vcov.(object)</code> returns a covariance matrix, or else <code>vcov.</code> is set equal to a covariance matrix.  For example, setting <code>vcov.=hccm</code> uses 'proposal 3' described by Long and Ervin (2000) for a sandwich coefficient-variance estimator that may be robust against nonconstant variance (see <code><a href="car.html#topic+hccm">hccm</a></code>).  Setting <code>vcov. = hccm(object, type = "hc2")</code> would use the matrix returned by the <code>hccm</code> function using proposal 2.  For use with a bootstrap, see the examples below. The overall F-test in the <code>S.lm</code> output uses the supplied covariance matrix in a call to the <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code> function.
</p>
<p>The supplied <code>print</code> method for <code>S.lm</code> (and for other <code>S</code> methods) has additional arguments to customize the standard <code>summary.lm</code> output.  Standard output is obtained by setting <code>resid.summary=TRUE, adj.r2=TRUE</code>.
</p>
<p>Using a heterscedasticy-corrected covariance matrix computed using <code><a href="car.html#topic+hccm">hccm</a></code> with GLMs other than Gaussian is not justified; see the article by Freedman (2006).
</p>
<p>The <code>Summary.glm</code> method for models fit with the log or logit link by default prints a table of exponentiated coefficients and their confidence limits; <code>Summary.multinom</code> and <code>Summary.polr</code> optionally print tables of exponentiated coefficients.
</p>


<h3>Value</h3>

<p>The <code>S.lm</code> and <code>S.glm</code> functions return a list with all the elements shown at <code><a href="stats.html#topic+summary.lm">summary.lm</a></code> and <code><a href="stats.html#topic+summary.glm">summary.glm</a></code>. The <code>S.multinom</code> and <code>S.polr</code> functions return a list with all the elements shown at <code><a href="nnet.html#topic+summary.multinom">summary.multinom</a></code> and <code>summary.polr</code> plus potentially a table of exponentiated coefficients and confidence bounds.
</p>
<p>The <code>Confint.lm</code> function returns either the output from <code><a href="stats.html#topic+confint.lm">confint.lm</a></code> if
<code>vcov. = vcov</code> or Wald-type confidence intervals using the supplied covariance matrix for any other choice of <code>vcov.</code>.
</p>
<p>Finally, <code>Confint</code> applied to any object that does not inherit from <code>"lm"</code>, <code>"multinom"</code>, or <code>"polr"</code> simply calls <code>confint</code>, along with, by default, using <code><a href="stats.html#topic+coef">coef</a></code> to add a column of estimates to the confidence limits.
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg <a href="mailto:sandy@umn.edu">sandy@umn.edu</a>
</p>


<h3>References</h3>

<p>Freedman, David A. (2006). On the so-called Huber sandwich estimator and robust standard errors.
<em>The American Statistician</em>, <b>60</b>, 299-302.
</p>
<p>Long, J. S. and Ervin, L. H. (2000)
Using heteroscedasity consistent standard errors in the linear regression model.
<em>The American Statistician</em> <b>54</b>, 217&ndash;224.
</p>
<p>White, H. (1980)
A heteroskedastic consistent covariance matrix estimator and a direct test of heteroskedasticity.
<em>Econometrica</em> <b>48</b>, 817&ndash;838.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+brief">brief</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>,
<code><a href="stats.html#topic+summary.lm">summary.lm</a></code>, <code><a href="stats.html#topic+confint">confint</a></code>, <code><a href="stats.html#topic+vcov.lm">vcov.lm</a></code>, <code><a href="car.html#topic+hccm">hccm</a></code>,
<code><a href="car.html#topic+Boot">Boot</a></code>, <code><a href="car.html#topic+linearHypothesis">linearHypothesis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mod.prestige &lt;- lm(prestige ~ education + income + type, Prestige)
S(mod.prestige, vcov.=hccm)
S(mod.prestige, brief=TRUE)
Confint(mod.prestige, vcov.=hccm)

# A logit model
mod.mroz &lt;- glm(lfp ~ ., data=Mroz, family=binomial)
S(mod.mroz)

# use for data frames vs. summary()
Duncan.1 &lt;-Duncan
Duncan.1$type &lt;- as.character(Duncan$type)
summary(Duncan.1)
S(Duncan.1)

## Not run:  # generates an error, which can then be corrected to run example
# Using the bootstrap for standard errors
b1 &lt;- Boot(mod.prestige)
S(mod.prestige, vcov.= vcov(b1))
Confint(b1) # run with the boot object to get corrected confidence intervals

## End(Not run)
</code></pre>

<hr>
<h2 id='scatter3d'>Three-Dimensional Scatterplots and Point Identification</h2><span id='topic+scatter3d'></span><span id='topic+scatter3d.formula'></span><span id='topic+scatter3d.default'></span><span id='topic+Identify3d'></span>

<h3>Description</h3>

<p>The <code>scatter3d</code> function uses the <code>rgl</code> package to draw 3D scatterplots
with various regression surfaces. The function <code>Identify3d</code>
allows you to label points interactively with the mouse:
Press the right mouse button (on a two-button mouse) or the centre button (on a
three-button mouse), drag a
rectangle around the points to be identified, and release the button.
Repeat this procedure for each point or
set of &ldquo;nearby&rdquo; points to be identified. To exit from point-identification mode,
click the right (or centre) button in an empty region of the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter3d(x, ...)

## S3 method for class 'formula'
scatter3d(formula, data, subset, radius, xlab, ylab, zlab, id=FALSE, ...)

## Default S3 method:
scatter3d(x, y, z,
	  xlab=deparse(substitute(x)), ylab=deparse(substitute(y)),
	  zlab=deparse(substitute(z)), axis.scales=TRUE, axis.ticks=FALSE,
	  revolutions=0,
	  bg.col=c("white", "black"),
	  axis.col=if (bg.col == "white") c("darkmagenta", "black", "darkcyan")
		            else c("darkmagenta", "white", "darkcyan"),
	  surface.col=carPalette()[-1], surface.alpha=0.5,
	  neg.res.col="magenta", pos.res.col="cyan",
	  square.col=if (bg.col == "white") "black" else "gray",
	  point.col="yellow", text.col=axis.col,
	  grid.col=if (bg.col == "white") "black" else "gray",
	  fogtype=c("exp2", "linear", "exp", "none"),
	  residuals=(length(fit) == 1),
	  surface=TRUE, fill=TRUE,
	  grid=TRUE, grid.lines=26, df.smooth=NULL, df.additive=NULL,
	  sphere.size=1, radius=1, threshold=0.01, speed=1, fov=60,
	  fit="linear", groups=NULL, parallel=TRUE,
	  ellipsoid=FALSE, level=0.5, ellipsoid.alpha=0.1, id=FALSE,
	  model.summary=FALSE, 
	  reg.function, reg.function.col=surface.col[length(surface.col)], 
	  mouseMode=c(none="none", left="polar", right="zoom", middle="fov", 
	               wheel="pull"),
	  ...)

Identify3d(x, y, z, axis.scales=TRUE, groups = NULL, labels = 1:length(x),
	col = c("blue", "green", "orange", "magenta", "cyan", "red", "yellow", "gray"),
	offset = ((100/length(x))^(1/3)) * 0.02)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter3d_+3A_formula">formula</code></td>
<td>
<p>&ldquo;model&rdquo; formula, of the form <code>y ~ x + z</code> or
to plot by groups <code>y ~ x + z | g</code>, where <code>g</code> evaluates to a factor
or other variable dividing the data into groups.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_data">data</code></td>
<td>
<p>data frame within which to evaluate the formula.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_subset">subset</code></td>
<td>
<p>expression defining a subset of observations.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_x">x</code></td>
<td>
<p>variable for horizontal axis.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_y">y</code></td>
<td>
<p>variable for vertical axis (response).</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_z">z</code></td>
<td>
<p>variable for out-of-screen axis.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_xlab">xlab</code>, <code id="scatter3d_+3A_ylab">ylab</code>, <code id="scatter3d_+3A_zlab">zlab</code></td>
<td>
<p>axis labels.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_axis.scales">axis.scales</code></td>
<td>
<p>if <code>TRUE</code>, label the values of the ends of the axes.
<em>Note:</em> For <code>Identify3d</code> to work properly, the value of this argument must
be the same as in <code>scatter3d</code>.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_axis.ticks">axis.ticks</code></td>
<td>
<p>if <code>TRUE</code>, print interior axis-&ldquo;tick&rdquo; labels; the default is <code>FALSE</code>.
(The code for this option was provided by David Winsemius.)</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_revolutions">revolutions</code></td>
<td>
<p>number of full revolutions of the display.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_bg.col">bg.col</code></td>
<td>
<p>background colour; one of <code>"white"</code>, <code>"black"</code>.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_axis.col">axis.col</code></td>
<td>
<p>colours for axes; if <code>axis.scales</code> is <code>FALSE</code>, then
the second colour is used for all three axes.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_surface.col">surface.col</code></td>
<td>
<p>vector of colours for regression planes,
used in the order specified by <code>fit</code>; for multi-group plots, the colours are used for the regression
surfaces and points in the several groups.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_surface.alpha">surface.alpha</code></td>
<td>
<p>transparency of regression surfaces, from <code>0.0</code> (fully transparent) to <code>1.0</code> (opaque); default is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_neg.res.col">neg.res.col</code>, <code id="scatter3d_+3A_pos.res.col">pos.res.col</code></td>
<td>
<p>colours for lines representing negative
and positive residuals.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_square.col">square.col</code></td>
<td>
<p>colour to use to plot squared residuals.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_point.col">point.col</code></td>
<td>
<p>colour of points.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_text.col">text.col</code></td>
<td>
<p>colour of axis labels.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_grid.col">grid.col</code></td>
<td>
<p>colour of grid lines on the regression surface(s).</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_fogtype">fogtype</code></td>
<td>
<p>type of fog effect; one of <code>"exp2"</code>, <code>"linear"</code>,
<code>"exp"</code>, <code>"none".</code></p>
</td></tr>
<tr><td><code id="scatter3d_+3A_residuals">residuals</code></td>
<td>
<p>plot residuals if <code>TRUE</code>; if  <code>residuals="squares"</code>,
then the squared residuals are shown as squares (using code adapted from Richard
Heiberger). Residuals are available only when there is one surface plotted.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_surface">surface</code></td>
<td>
<p>plot surface(s) (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_fill">fill</code></td>
<td>
<p>fill the plotted surface(s) with colour (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_grid">grid</code></td>
<td>
<p>plot grid lines on the regression surface(s) (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_grid.lines">grid.lines</code></td>
<td>
<p>number of lines (default, 26) forming the grid, in each of the x and z directions.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_df.smooth">df.smooth</code></td>
<td>
<p>degrees of freedom for the two-dimensional smooth regression surface;
if <code>NULL</code> (the default), the <code><a href="mgcv.html#topic+gam">gam</a></code> function will select the degrees of freedom
for a smoothing spline by generalized cross-validation; if a positive number, a fixed
regression spline will be fit with the specified degrees of freedom.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_df.additive">df.additive</code></td>
<td>
<p>degrees of freedom for each explanatory variable in an additive regression;
if <code>NULL</code> (the default), the <code>gam</code> function will select degrees of freedom
for the smoothing splines by generalized cross-validation; if a positive number
or a vector of two positive numbers, fixed
regression splines will be fit with the specified degrees of freedom for each term.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_sphere.size">sphere.size</code></td>
<td>
<p>general size of spheres representing points;
the actual size is dependent on the number of observations.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_radius">radius</code></td>
<td>
<p>relative radii of the spheres representing the points. This is normally a vector of the
same length as the variables giving the coordinates of the points, and for the <code>formula</code> method,
that must be the case or the argument may be omitted, in which case spheres are the same size;
for the <code>default</code> method, the default for the argument, <code>1</code>, produces spheres
all of the same size. The radii are scaled so that their median is 1.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_threshold">threshold</code></td>
<td>
<p>if the actual size of the spheres is less than the threshold,
points are plotted instead.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_speed">speed</code></td>
<td>
<p>relative speed of revolution of the plot.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_fov">fov</code></td>
<td>
<p>field of view (in degrees); controls degree of perspective.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_fit">fit</code></td>
<td>
<p>one or more of <code>"linear"</code> (linear least squares regression), <code>"quadratic"</code> (quadratic least squares regression), <code>"smooth"</code> (nonparametric regression),
<code>"additive"</code> (nonparametric additive regression), <code>"robust"</code> (robust linear regression); to display fitted surface(s); partial matching is supported &ndash;
e.g., <code>c("lin", "quad")</code>.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_groups">groups</code></td>
<td>
<p>if <code>NULL</code> (the default), no groups are defined; if a factor, a different surface
or set of surfaces is plotted for each level of the factor; in this event, the colours in
<code>surface.col</code> are used successively for the points, surfaces, and residuals corresponding to
each level of the factor.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_parallel">parallel</code></td>
<td>
<p>when plotting surfaces by <code>groups</code>, should the surfaces be constrained to be
parallel? A logical value, with default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_ellipsoid">ellipsoid</code></td>
<td>
<p>plot concentration ellipsoid(s) (<code>TRUE</code> or <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_level">level</code></td>
<td>
<p>expected proportion of bivariate-normal observations included in the
concentration ellipsoid(s); default is 0.5.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_ellipsoid.alpha">ellipsoid.alpha</code></td>
<td>
<p>transparency of ellipsoids, from <code>0.0</code> (fully transparent) to <code>1.0</code> (opaque); default is <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_id">id</code></td>
<td>
<p><code>FALSE</code>, <code>TRUE</code>, or a list controlling point identification, 
similar to <code><a href="car.html#topic+showLabels">showLabels</a></code> for 2D plots (see Details).</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_model.summary">model.summary</code></td>
<td>
<p>print summary or summaries of the model(s) fit
(<code>TRUE</code> or <code>FALSE</code>). <code>scatter3d</code> rescales the three variables
internally to fit in the unit cube; this rescaling will affect regression
coefficients.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_labels">labels</code></td>
<td>
<p>text labels for the points, one for each point;  defaults to
the observation indices.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_col">col</code></td>
<td>
<p>colours for the point labels, given by group. There must be at
least as many colours as groups; if there are no groups, the first colour is used. Normally, the colours
would correspond to the <code>surface.col</code> argument to <code>scatter3d</code>.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_offset">offset</code></td>
<td>
<p>vertical displacement for point labels (to avoid overplotting the points).</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_reg.function">reg.function</code></td>
<td>
<p>an arithmetic expression that is a function of <code>x</code> and <code>z</code> (respectively, the horizontal and out-of-screen explanatory variables), representing an arbitrary regression function to plot.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_reg.function.col">reg.function.col</code></td>
<td>
<p>color to use for the surface produced by <code>reg.function</code>; defaults to the <em>last</em> color in <code>surface.col</code>.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_mousemode">mouseMode</code></td>
<td>
<p>defines what the mouse buttons, etc., do; passed to <code><a href="rgl.html#topic+par3d">par3d</a></code> in the <span class="pkg">rgl</span> package; the default in <code>scatter3d</code> is the same as in the <span class="pkg">rgl</span> package, except for the left mouse button.</p>
</td></tr>
<tr><td><code id="scatter3d_+3A_...">...</code></td>
<td>
<p>arguments to be passed down.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>id</code> argument to <code>scatter3d</code> can be <code>FALSE</code>, <code>TRUE</code> (in which case 2
points will be identified according to their Mahalanobis distances from the center of the data),
or a list containing any or all of the following elements:
</p>

<dl>
<dt>method</dt><dd><p>if <code>"mahal"</code> (the default), relatively extreme points are identified automatically
according to their Mahalanobis distances from the centroid (point of means);
if <code>"identify"</code>, points are identified interactively by right-clicking and dragging a box around them; right-click
in an empty area to exit from interactive-point-identification mode; if <code>"xz"</code>, identify extreme points in the
predictor plane; if <code>"y"</code>, identify unusual values of the response; if <code>"xyz"</code> identify
unusual values of an variable; if <code>"none"</code>, no point identification.
See <code><a href="car.html#topic+showLabels">showLabels</a></code> for more information.</p>
</dd>
<dt>n</dt><dd><p>Number of relatively extreme points to identify automatically (default, <code>2</code>,
unless <code>method="identify"</code>, in which case identification continues until the user
exits).</p>
</dd>
<dt>labels</dt><dd><p>text labels for the points, one for each point; in the <code>default</code> method defaults to
the observation indices, in the <code>formula</code> method to the row names of the data.</p>
</dd>
<dt>offset</dt><dd><p>vertical displacement for point labels (to avoid overplotting the points).</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>scatter3d</code> does not return a useful value; it is used for its side-effect of
creating a 3D scatterplot. <code>Identify3d</code> returns the labels of the
identified points.
</p>


<h3>Note</h3>

<p>You have to install the <code>rgl</code> package to produce 3D plots.  On a Macintosh (but not on Windows or Linux), you may also need to install the X11 windowing system.  Go to <a href="https://www.xquartz.org/">https://www.xquartz.org/</a> and click on the link for XQuartz. Double-click on the downloaded disk-image file, and then double-click on <code>XQuartz.pkg</code> to start the installer. You may take all of the defaults in the installation. After XQuartz is installed, you should restart your Macintosh.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+rgl-package">rgl-package</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    if(interactive() &amp;&amp; require(rgl) &amp;&amp; require(mgcv)){
scatter3d(prestige ~ income + education, data=Duncan, id=list(n=3))
Sys.sleep(5) # wait 5 seconds
scatter3d(prestige ~ income + education | type, data=Duncan)
Sys.sleep(5)
scatter3d(prestige ~ income + education | type, surface=FALSE,
	ellipsoid=TRUE, revolutions=3, data=Duncan)
scatter3d(prestige ~ income + education, fit=c("linear", "additive"),
	data=Prestige)
Sys.sleep(5)
scatter3d(prestige ~ income + education | type,
    radius=(1 + women)^(1/3), data=Prestige)
Sys.sleep(5)
if (require(mvtnorm)){
  local({
    set.seed(123)
    Sigma &lt;- matrix(c(
      1, 0.5,
      0.5, 1),
      2, 2
    )
    X &lt;- rmvnorm(200, sigma=Sigma)
    D &lt;- data.frame(
      x1 = X[, 1],
      x2 = X[, 2]
    )
    D$y &lt;- with(D, 10 + 1*x1 + 2*x2 + 3*x1*x2 + rnorm(200, sd=3))
    # plot true regression function
    scatter3d(y ~ x1 + x2, D, 
              reg.function=10 + 1*x + 2*z + 3*x*z,
              fit="quadratic", revolutions=2)
  })
}
	}
	## Not run:  # requires user interaction to identify points
# drag right mouse button to identify points, click right button in open area to exit
scatter3d(prestige ~ income + education, data=Duncan, id=list(method="identify"))
scatter3d(prestige ~ income + education | type, data=Duncan, id=list(method="identify"))
    
## End(Not run)
</code></pre>

<hr>
<h2 id='scatterplot'>Enhanced Scatterplots with Marginal Boxplots, Point Marking, Smoothers, and More</h2><span id='topic+scatterplot'></span><span id='topic+scatterplot.formula'></span><span id='topic+scatterplot.default'></span><span id='topic+sp'></span>

<h3>Description</h3>

<p>This function uses basic R graphics to draw a two-dimensional scatterplot, with options to allow for plot enhancements that are often helpful with regression problems.  Enhancements include adding marginal boxplots, estimated mean and variance functions using either parametric or nonparametric methods, point identification, jittering, setting characteristics of points and lines like color, size and symbol, marking points and fitting lines conditional on a grouping variable, and other enhancements.
<code>sp</code> is an abbreviation for <code>scatterplot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatterplot(x, ...)

## S3 method for class 'formula'
scatterplot(formula, data, subset, xlab, ylab, id=FALSE,
    legend=TRUE, ...)

## Default S3 method:
scatterplot(x, y, boxplots=if (by.groups) "" else "xy",
        regLine=TRUE, legend=TRUE, id=FALSE, ellipse=FALSE, grid=TRUE,
        smooth=TRUE,
        groups, by.groups=!missing(groups),
        xlab=deparse(substitute(x)), ylab=deparse(substitute(y)),
        log="", jitter=list(), cex=par("cex"),
        col=carPalette()[-1], pch=1:n.groups,
        reset.par=TRUE, ...)

sp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatterplot_+3A_x">x</code></td>
<td>
<p>vector of horizontal coordinates (or first argument of generic function).</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_y">y</code></td>
<td>
<p>vector of vertical coordinates.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_formula">formula</code></td>
<td>
<p>a model formula, of the form <code>y ~ x</code> or, if plotting by
groups, <code>y ~ x | z</code>, where <code>z</code> evaluates to a factor
or other variable dividing the data into groups. If <code>x</code> is a factor, then parallel boxplots
are produced using the <code><a href="car.html#topic+Boxplot">Boxplot</a></code> function.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_data">data</code></td>
<td>
<p>data frame within which to evaluate the formula.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_subset">subset</code></td>
<td>
<p>expression defining a subset of observations.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_boxplots">boxplots</code></td>
<td>
<p>if <code>"x"</code> a marginal boxplot for the horizontal <code>x</code>-axis is drawn below the plot;
if <code>"y"</code> a marginal boxplot for vertical <code>y</code>-axis is drawn to the left of the plot;
if <code>"xy"</code> both marginal boxplots are drawn; set to <code>""</code> or <code>FALSE</code> to
suppress both boxplots.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_regline">regLine</code></td>
<td>
<p>controls adding a fitted regression line to the plot.  if
<code>regLine=FALSE</code>, no line is drawn.  If <code>TRUE</code>, the default, an OLS
line is fit.  This argument can also be a list.  The default of <code>TRUE</code> is
equivalent to <code>regLine=list(method=lm, lty=1, lwd=2, col=col)</code>, which specifies
using the <code>lm</code> function to estimate the fitted line, to draw a solid line
(<code>lty=1</code>) of width 2 times the nominal width (<code>lwd=2</code>) in the color given by
the first element of the <code>col</code> argument described below.
</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_legend">legend</code></td>
<td>
<p>when the plot is drawn by groups and <code>legend=TRUE</code>, controls placement
and properties of a
legend; if <code>FALSE</code>, the legend is suppressed. Can be a list of
named arguments, as follows: <code>title</code> for the legend; <code>inset</code>, giving space
as a proportion of the axes to offset the legend from the axes; <code>coords</code>
specifying the position of the legend in any form acceptable to the
<code><a href="graphics.html#topic+legend">legend</a></code> function or, if not given, the legend is placed <em>above</em>
the plot in the upper margin; <code>columns</code> for the legend, determined automatically
to prefer a horizontal layout if not given explicitly; <code>cex</code> giving the
relative size of the legend symbols and text. <code>TRUE</code> (the default) is equivalent to
<code>list(title=deparse(substitute(groups)), inset=0.02, cex=1)</code>.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are
identified; can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to
<code>list(method="mahal", n=2, cex=1, col=carPalette()[-1], location="lr")</code>,
which identifies the 2 points (in each group) with the largest Mahalanobis distances
from the center of the data.  See <code><a href="car.html#topic+showLabels">showLabels</a></code> for a description of the
other arguments.  The default behavior of <code>id</code> is not the same in all graphics
functions in <span class="pkg">car</span>, as the <code>method</code> used depends on the type of plot.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_ellipse">ellipse</code></td>
<td>
<p>controls plotting data-concentration ellipses. If <code>FALSE</code>
(the default), no ellipses are plotted.  Can be a list of named values giving
<code>levels</code>, a vector of one or more bivariate-normal probability-contour levels at
which to plot the ellipses; <code>robust</code>, a logical value determing whether to use
the <code><a href="MASS.html#topic+cov.trob">cov.trob</a></code> function in the <span class="pkg">MASS</span> package to calculate the center
and covariance matrix for the data ellipses; and <code>fill</code> and <code>fill.alpha</code>,
which control whether the ellipse is filled and the transparency of the fill.
<code>TRUE</code> is equivalent to
<code>list(levels=c(.5, .95), robust=TRUE, fill=TRUE, fill.alpha=0.2)</code>.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the graph</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_smooth">smooth</code></td>
<td>
<p>specifies a nonparametric estimate of the mean or median
function of the vertical axis variable given the
horizontal axis variable and optionally a nonparametric estimate of the conditional variance.  If
<code>smooth=FALSE</code> neither function is drawn.  If <code>smooth=TRUE</code>, then both the mean function
and variance funtions are drawn for ungrouped data, and the mean function only is drawn
for grouped
data.  The default smoother is <code><a href="car.html#topic+loessLine">loessLine</a></code>, which uses the
<code><a href="stats.html#topic+loess">loess</a></code> function from
the <span class="pkg">stats</span> package.  This smoother is fast and reliable.  See the details below
for changing
the smoother, line type, width and color, of the added lines, and adding arguments
for the smoother.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_groups">groups</code></td>
<td>
<p>a factor or other variable dividing the data into groups; groups are
plotted with different colors, plotting characters, fits, and smooths.  Using this
argument is equivalent to specifying the grouping variable in the formula.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_by.groups">by.groups</code></td>
<td>
<p>if <code>TRUE</code> (the default when there are groups), regression lines are fit by groups.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_xlab">xlab</code></td>
<td>
<p>label for horizontal axis.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_ylab">ylab</code></td>
<td>
<p>label for vertical axis.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_log">log</code></td>
<td>
<p>same as the <code>log</code> argument to <code><a href="graphics.html#topic+plot">plot</a></code>, to produce log axes.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_jitter">jitter</code></td>
<td>
<p>a list with elements <code>x</code> or <code>y</code> or both, specifying jitter factors
for the horizontal and vertical coordinates of the points in the scatterplot. The
<code><a href="base.html#topic+jitter">jitter</a></code> function is used to randomly perturb the points; specifying a
factor of <code>1</code> produces the default jitter.
Fitted lines are unaffected by the jitter.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_col">col</code></td>
<td>
<p>with no grouping, this specifies a color for plotted points;
with grouping, this argument  should be a vector
of colors of length at least equal to the number of groups. The default is
value returned by <code><a href="car.html#topic+carPalette">carPalette</a>[-1]</code>.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_pch">pch</code></td>
<td>
<p>plotting characters for points; default is the plotting characters in
order (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_cex">cex</code></td>
<td>
<p>sets the size of plotting characters, with <code>cex=1</code> the standard size.  You can also
set the sizes of other elements with the arguments <code>cex.axis</code>, <code>cex.lab</code>, <code>cex.main</code>,
and <code>cex.sub</code>.  See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_reset.par">reset.par</code></td>
<td>
<p>if <code>TRUE</code> (the default) then plotting parameters are reset to their previous values
when <code>scatterplot</code> exits; if <code>FALSE</code> then the <code>mar</code> and <code>mfcol</code> parameters are
altered for the current plotting device. Set to <code>FALSE</code> if you want to add graphical elements
(such as lines) to the plot.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_...">...</code></td>
<td>
<p>other arguments passed down and to <code>plot</code>.  For example, the argument <code>las</code> sets
the style of the axis labels, and <code>xlim</code> and <code>ylim</code> set the limits on the horizontal and
vertical axes, respectively; see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many arguments to <code>scatterplot</code> were changed in version 3 of <span class="pkg">car</span> to simplify use of this function.
</p>
<p>The <code>smooth</code> argument is used to control adding smooth curves to the plot to estimate the conditional center of the vertical axis variable given the horizontal axis variable, and also the conditional variability.  Setting <code>smooth=FALSE</code> omits all smoothers, while <code>smooth=TRUE</code>, the default, includes default smoothers.   Alternatively <code>smooth</code> can be set to a list of subarguments that provide finer control over the smoothing.  
</p>
<p>The default behavior of <code>smooth=TRUE</code> is equivalent to <code>smooth=list(smoother=loessLine, var=!by.groups, lty.var=2, lty.var=4, style="filled", alpha=0.15, border=TRUE, vertical=TRUE)</code>, specifying the default <code><a href="car.html#topic+loessLine">loessLine</a></code> smoother for the conditional mean smooth and variance smooth.  The color of the smooths is the same of the color of the points, but this can be changed with the arguments <code>col.smooth</code> and <code>col.var</code>.
</p>
<p>Additional available smoothers are <code><a href="car.html#topic+gamLine">gamLine</a></code> which uses the <code><a href="mgcv.html#topic+gam">gam</a></code> function and <code><a href="car.html#topic+quantregLine">quantregLine</a></code> which uses quantile regression to estimate the median and quartile functions using <code><a href="quantreg.html#topic+rqss">rqss</a></code>.  All of these smoothers have one or more arguments described on their help pages, and these arguments can be added to the <code>smooth</code> argument; for example, <code>smooth = list(span=1/2)</code> would use the default <code>loessLine</code> smoother, include the variance smooth, and change the value of the smoothing parameter to 1/2.  
</p>
<p>For <code>loessLine</code> and <code>gamLine</code> the variance smooth is estimated by separately smoothing the squared positive and negative residuals from the mean smooth, using the same type of smoother.  The displayed curves are equal to the mean smooth plus the square root of the fit to the positive squared residuals, and the mean fit minus the square root of the smooth of the negative squared residuals.  The lines therefore represent the comnditional variabiliity at each value on the horizontal axis.  Because smoothing is done separately for positive and negative residuals, the variation shown will generally not be symmetric about the fitted mean function.  For the <code>quantregLine</code> method, the center estimates the conditional median, and the variability estimates the lower and upper quartiles of the estimated conditional distribution.
</p>
<p>The default depection of the variance functions is via a shaded envelope between the upper and lower estimate of variability.  setting the subarguement <code>style="lines"</code> will display only the boundaries of this region, and <code>style="none"</code> suppresses variance smoothing.
</p>
<p>For  <code>style="filled"</code> several subarguments modify the appearance of the region:  codealpha is a number between 0 and 1 that specifies opacity with defualt 0.15, <code>border</code>, <code>TRUE</code> or <code>FALSE</code> specifies a border for the envelope, and <code>vertical</code> either <code>TRUE</code> or <code>FALSE</code>, modifies the behavior of the envelope at the edges of the graph.
</p>
<p>The sub-arguments <code>spread</code>, <code>lty.spread</code> and <code>col.spread</code> of the <code>smooth</code> argument are equivalent to the newer <code>var</code>, <code>col.var</code> and <code>lty.var</code>, respectively, recognizing that the spread is a measuure of conditional variability.
</p>


<h3>Value</h3>

<p>If points are identified, their labels are returned; otherwise <code>NULL</code> is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>,
<code><a href="base.html#topic+jitter">jitter</a></code>, <code><a href="graphics.html#topic+legend">legend</a></code>,
<code><a href="car.html#topic+scatterplotMatrix">scatterplotMatrix</a></code>, <code><a href="car.html#topic+dataEllipse">dataEllipse</a></code>, <code><a href="car.html#topic+Boxplot">Boxplot</a></code>,
<code><a href="MASS.html#topic+cov.trob">cov.trob</a></code>,
<code><a href="car.html#topic+showLabels">showLabels</a></code>, <code><a href="car.html#topic+ScatterplotSmoothers">ScatterplotSmoothers</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>scatterplot(prestige ~ income, data=Prestige, ellipse=TRUE, 
  smooth=list(style="lines"))

scatterplot(prestige ~ income, data=Prestige, 
  smooth=list(smoother=quantregLine))
  
scatterplot(prestige ~ income, data=Prestige, 
  smooth=list(smoother=quantregLine, border="FALSE"))

# use quantile regression for median and quartile fits
scatterplot(prestige ~ income | type, data=Prestige,
  smooth=list(smoother=quantregLine, var=TRUE, span=1, lwd=4, lwd.var=2))

scatterplot(prestige ~ income | type, data=Prestige, 
  legend=list(coords="topleft"))

scatterplot(vocabulary ~ education, jitter=list(x=1, y=1),
            data=Vocab, smooth=FALSE, lwd=3)

scatterplot(infantMortality ~ ppgdp, log="xy", data=UN, id=list(n=5))

scatterplot(income ~ type, data=Prestige)

## Not run:  # interactive point identification
    # remember to exit from point-identification mode
    scatterplot(infantMortality ~ ppgdp, id=list(method="identify"), data=UN)

## End(Not run)
</code></pre>

<hr>
<h2 id='scatterplotMatrix'>Scatterplot Matrices</h2><span id='topic+scatterplotMatrix'></span><span id='topic+scatterplotMatrix.formula'></span><span id='topic+scatterplotMatrix.default'></span><span id='topic+spm'></span>

<h3>Description</h3>

<p>This function provides a convenient interface to the <code>pairs</code> function to produce
enhanced scatterplot matrices, including univariate displays on the diagonal and a variety of fitted lines, smoothers, variance functions, and concentration ellipsoids.
<code>spm</code> is an abbreviation for <code>scatterplotMatrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
scatterplotMatrix(x, ...)

## S3 method for class 'formula'
scatterplotMatrix(formula, data=NULL, subset, ...)

## Default S3 method:
scatterplotMatrix(x, smooth = TRUE,
    id = FALSE, legend = TRUE, regLine = TRUE,
    ellipse = FALSE, var.labels = colnames(x), diagonal = TRUE,
    plot.points = TRUE, groups = NULL, by.groups = TRUE,
    use = c("complete.obs", "pairwise.complete.obs"), col =
    carPalette()[-1], pch = 1:n.groups, cex = par("cex"),
    cex.axis = par("cex.axis"), cex.labels = NULL,
    cex.main = par("cex.main"), row1attop = TRUE, ...)

spm(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatterplotMatrix_+3A_x">x</code></td>
<td>
<p>a data matrix or a numeric data frame.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_formula">formula</code></td>
<td>
<p>a one-sided &ldquo;model&rdquo; formula, of the form
<code> ~ x1 + x2 + ... + xk</code> or <code> ~ x1 + x2 + ... + xk | z</code> where <code>z</code>
evaluates to a factor or other variable to divide the data into groups.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_data">data</code></td>
<td>
<p>for <code>scatterplotMatrix.formula</code>,
a data frame within which to evaluate the formula.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_subset">subset</code></td>
<td>
<p>expression defining a subset of observations.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_smooth">smooth</code></td>
<td>
<p>specifies a nonparametric estimate of the mean or median
function of the vertical axis variable given the
horizontal axis variable and optionally a nonparametric estimate of the spread or variance function.  If
<code>smooth=FALSE</code> neither function is drawn.  If <code>smooth=TRUE</code>, then both the mean function
and variance funtions are drawn for ungrouped data, and the mean function only is drawn for grouped
data.  The default smoother is <code><a href="car.html#topic+loessLine">loessLine</a></code>, which uses the <code><a href="stats.html#topic+loess">loess</a></code> function from
the <code>stats</code> package.  This smoother is fast and reliable.  See the details below for changing
the smoother, line type, width and color, of the added lines, and adding arguments for the smoother.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method="mahal", n=2, cex=1, location="lr")</code>,
which identifies the 2 points (in each group, if <code>by.groups=TRUE</code>) with the largest Mahalanobis distances from the center
of the data; <code>list(method="identify")</code> for interactive point identification is not allowed.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_legend">legend</code></td>
<td>
<p>controls placement, point size, and text size of a legend if the plot is drawn by groups; if <code>FALSE</code>, the legend
is suppressed. Can be a list with the named element <code>coords</code> specifying the position of the legend
in any form acceptable to the <code><a href="graphics.html#topic+legend">legend</a></code> function, and elements <code>pt.cex</code> and <code>cex</code> corresponding respectively to the <code>pt.cex</code> and <code>cex</code> arguments of the <code><a href="graphics.html#topic+legend">legend</a></code> function;
<code>TRUE</code> (the default) is equivalent to <code>list(coords=NULL, pt.cex=cex, cex=cex)</code>, for which placement will vary
by the the value of the <code>diagonal</code> argument&mdash;e.g., <code>"topright"</code> for <code>diagonal=TRUE</code>.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_regline">regLine</code></td>
<td>
<p>controls adding a fitted regression line to each plot, or to each group of points
if <code>by.groups=TRUE</code>.  If <code>regLine=FALSE</code>, no line
is drawn.  This argument can also be a list with named list, with default <code>regLine=TRUE</code> equivalent
to <code>regLine = list(method=lm, lty=1, lwd=2, col=col[1])</code> specifying the name of the function that
computes the line, with line type 1 (solid) of relative line width 2 and the color equal to the first
value in the argument <code>col</code>. Setting <code>method=MASS::rlm</code> would fit using a robust regression.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_ellipse">ellipse</code></td>
<td>
<p>controls plotting data-concentration ellipses. If <code>FALSE</code> (the default), no
ellipses are plotted.  Can be a list of named values giving <code>levels</code>, a vector of one or more
bivariate-normal probability-contour levels at which to
plot the ellipses;  <code>robust</code>, a logical value determing whether to use
the <code><a href="MASS.html#topic+cov.trob">cov.trob</a></code> function in the <span class="pkg">MASS</span> package
to calculate the center and covariance matrix for the data ellipses; and <code>fill</code> and <code>fill.alpha</code>,
which control whether the ellipse is filled and the transparency of the fill. <code>TRUE</code> is equivalent
to <code>list(levels=c(.5, .95), robust=TRUE, fill=TRUE, fill.alpha=0.2)</code>.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_var.labels">var.labels</code></td>
<td>
<p>variable labels (for the diagonal of the plot).</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_diagonal">diagonal</code></td>
<td>
<p>contents of the diagonal panels of the plot. If <code>diagonal=TRUE</code> adaptive kernel density
estimates are plotted, separately for each group if grouping is present.  <code>diagonal=FALSE</code> suppresses
the diagonal entries.  See details below for other choices for the diagonal.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_plot.points">plot.points</code></td>
<td>
<p>if <code>TRUE</code> the points are plotted in each
off-diagonal panel.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_groups">groups</code></td>
<td>
<p>a factor or other variable dividing the data into groups; groups are
plotted with different colors and plotting characters.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_by.groups">by.groups</code></td>
<td>
<p>if <code>TRUE</code>, the default, regression lines and smooths are fit by groups.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_use">use</code></td>
<td>
<p>if <code>"complete.obs"</code> (the default), cases with missing data are omitted; if <code>"pairwise.complete.obs"), all valid cases are used
    in each panel of the plot.</code></p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_pch">pch</code></td>
<td>
<p>plotting characters for points; default is the plotting characters in
order (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_col">col</code></td>
<td>
<p>colors for points; the default is <code><a href="car.html#topic+carPalette">carPalette</a></code> starting at the second color. The color of
the <code>regLine</code> and <code>smooth</code> are the same as for points but can be changed using the the
<code>regLine</code> and <code>smooth</code> arguments.</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_cex">cex</code></td>
<td>
<p>relative size of plotted points</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_cex.axis">cex.axis</code></td>
<td>
<p>relative size of axis labels</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_cex.labels">cex.labels</code></td>
<td>
<p>relative size of labels on the diagonal</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_cex.main">cex.main</code></td>
<td>
<p>relative size of the main title, if any</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_row1attop">row1attop</code></td>
<td>
<p>If <code>TRUE</code> (the default) the first row is at the top, as in a matrix, as
opposed to at the bottom, as in graph (argument suggested by Richard Heiberger).</p>
</td></tr>
<tr><td><code id="scatterplotMatrix_+3A_...">...</code></td>
<td>
<p>arguments to pass down.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many arguments to <code>scatterplotMatrix</code> were changed in version 3 of <span class="pkg">car</span>, to simplify use of
this function.
</p>
<p>The <code>smooth</code> argument is usually either set to <code>TRUE</code> or <code>FALSE</code> to draw, or omit,
the smoother.  Alternatively <code>smooth</code> can be set to a list of arguments.  The default behavior of
<code>smooth=TRUE</code> is equivalent to <code>smooth=list(smoother=loessLine, spread=TRUE, lty.smooth=1, lwd.smooth=1.5, lty.spread=3, lwd.spread=1)</code>, specifying the smoother to be used, including the spread or variance smooth,
and the line widths and types for the curves.  You can also specify the colors you want to use for the mean and variance smooths with the arguments <code>col.smooth</code> and <code>col.spread</code>. Alternative smoothers are <code>gamline</code> which uses the
<code><a href="mgcv.html#topic+gam">gam</a></code> function from the <span class="pkg">mgcv</span> package, and <code>quantregLine</code> which uses quantile regression to
estimate the median and quartile functions using <code><a href="quantreg.html#topic+rqss">rqss</a></code> from the <span class="pkg">quantreg</span> package.  All of these
smoothers have one or more arguments described on their help pages, and these arguments can be added to the
<code>smooth</code> argument; for example, <code>smooth = list(span=1/2)</code> would use the default
<code>loessLine</code> smoother,
include the variance smooth, and change the value of the smoothing parameter to 1/2.  For <code>loessLine</code>
and <code>gamLine</code> the variance smooth is estimated by separately
smoothing the squared positive and negative
residuals from the mean smooth, using the same type of smoother.  The displayed curves are equal to
the mean smooth plus the square root of the fit to the positive squared residuals, and the mean fit minus
the square root of the smooth of the negative squared residuals.  The lines therefore represent the
comnditional variabiliity at each value on the horizontal axis.  Because smoothing is done separately for
positive and negative residuals, the variation shown will generally not be symmetric about the fitted mean
function.  For the <code>quantregLine</code> method, the center estimates the median for each value on the
horizontal axis, and the spread estimates the lower and upper quartiles of the estimated conditional
distribution for each value of the horizontal axis.
</p>
<p>The sub-arguments <code>spread</code>, <code>lty.spread</code> and <code>col.spread</code> of the <code>smooth</code> argument are equivalent to the newer <code>var</code>, <code>col.var</code> and <code>lty.var</code>, respectively, recognizing that the spread is a measuure of conditional variability.
</p>
<p>By default the diagonal argument is used to draw kernel density estimates of the
variables by setting <code>diagonal=TRUE</code>, which is equivalent to setting <code>diagonal =
   list(method="adaptiveDensity", bw=bw.nrd0, adjust=1, kernel=dnorm, na.rm=TRUE)</code>.  The additional arguments
shown are descibed at <code><a href="car.html#topic+adaptiveKernel">adaptiveKernel</a></code>.  The other methods avaliable, with their default
arguments, are <code>diagonal=list(method="density", bw="nrd0", adjust=1, kernel="gaussian", na.rm=TRUE)</code>
which uses <code><a href="stats.html#topic+density">density</a></code> for nonadaptive kernel density estimation; <code>diagonal=list(method
   ="histogram", breaks="FD")</code>
which uses <code><a href="graphics.html#topic+hist">hist</a></code> for drawing a histogram that ignores grouping, if present;
<code>diagonal=list(method="boxplot")</code> with no additional arguments which draws (parallel) boxplots;
<code>diagonal=list(method="qqplot")</code> with no additional arguments which draws a normal QQ plot; and
<code>diagonal=list(method="oned")</code> with no additional arguments which draws a rug plot tilted to the
diagonal, as suggested by Richard Heiberger.
</p>
<p>Earlier versions of <code>scatterplotMatrix</code> included arguments <code>transform</code> and <code>family</code> to estimate power transformations using the <code><a href="car.html#topic+powerTransform">powerTransform</a></code> function before drawing the plot.  The same functionality can be achieved by calling <code>powerTransform</code> directly to estimate a transformation, saving the transformed variables, and then plotting.
</p>


<h3>Value</h3>

<p><code>NULL</code>, returned invisibly. This function is used for its side effect: producing
a plot.  If point identification is used, a vector of identified points is returned.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pairs">pairs</a></code>, <code><a href="car.html#topic+scatterplot">scatterplot</a></code>,
<code><a href="car.html#topic+dataEllipse">dataEllipse</a></code>, <code><a href="car.html#topic+powerTransform">powerTransform</a></code>,
<code><a href="car.html#topic+bcPower">bcPower</a></code>, <code><a href="car.html#topic+yjPower">yjPower</a></code>, <code><a href="MASS.html#topic+cov.trob">cov.trob</a></code>,
<code><a href="car.html#topic+showLabels">showLabels</a></code>, <code><a href="car.html#topic+ScatterplotSmoothers">ScatterplotSmoothers</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>scatterplotMatrix(~ income + education + prestige | type, data=Duncan)
scatterplotMatrix(~ income + education + prestige | type, data=Duncan,
    regLine=FALSE, smooth=list(span=1))
scatterplotMatrix(~ income + education + prestige,
    data=Duncan, id=TRUE, smooth=list(method=gamLine))
</code></pre>

<hr>
<h2 id='ScatterplotSmoothers'>
Smoothers to Draw Lines on Scatterplots
</h2><span id='topic+ScatterplotSmoothers'></span><span id='topic+gamLine'></span><span id='topic+quantregLine'></span><span id='topic+loessLine'></span>

<h3>Description</h3>

<p>These smoothers are used to draw nonparametric-regression lines on scatterplots produced by
the <code><a href="car.html#topic+scatterplot">scatterplot</a></code>, <code><a href="car.html#topic+scatterplotMatrix">scatterplotMatrix</a></code>, and several other <span class="pkg">car</span> functions.
The functions are not meant to
be called directly by the user, although the user can supply options via the <code>smoother.args</code> argument,
the contents of which vary by the smoother (see <em>Details</em> below). The <code>gamLine</code> smoother uses the
<code><a href="mgcv.html#topic+gam">gam</a></code> function in the <span class="pkg">mgcv</span> package, the <code>loessLine</code> smoother uses the
<code><a href="stats.html#topic+loess">loess</a></code> function in the <span class="pkg">stats</span> package, and the <code>quantregLine</code> smoother uses the
<code><a href="quantreg.html#topic+rqss">rqss</a></code> function in the <span class="pkg">quantreg</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamLine(x, y, col=carPalette()[1], log.x=FALSE, log.y=FALSE, var=FALSE, spread=var,
    smoother.args=NULL, draw=TRUE, offset=0)

loessLine(x, y, col=carPalette()[1], log.x=FALSE, log.y=FALSE, var=FALSE, spread=var,
    smoother.args=NULL, draw=TRUE, offset=0)

quantregLine(x, y, col=carPalette()[1], log.x=FALSE, log.y=FALSE, var=FALSE, spread=var,
    smoother.args=NULL, draw=TRUE, offset=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScatterplotSmoothers_+3A_x">x</code></td>
<td>
<p>horizontal coordinates of points.</p>
</td></tr>
<tr><td><code id="ScatterplotSmoothers_+3A_y">y</code></td>
<td>
<p>vertical coordinates of points.</p>
</td></tr>
<tr><td><code id="ScatterplotSmoothers_+3A_col">col</code></td>
<td>
<p>line color.</p>
</td></tr>
<tr><td><code id="ScatterplotSmoothers_+3A_log.x">log.x</code></td>
<td>
<p>should be set to <code>TRUE</code> (default is <code>FALSE</code>) if the horizontal axis is logged.</p>
</td></tr>
<tr><td><code id="ScatterplotSmoothers_+3A_log.y">log.y</code></td>
<td>
<p>should be set to <code>TRUE</code> (default is <code>FALSE</code>) if the vertical axis is logged.</p>
</td></tr>
<tr><td><code id="ScatterplotSmoothers_+3A_spread">spread</code>, <code id="ScatterplotSmoothers_+3A_var">var</code></td>
<td>
<p>the default is to plot only an estimated mean or median function.  If either of
these arguments is TRUE, then a measure of variability is also plotted.</p>
</td></tr>
<tr><td><code id="ScatterplotSmoothers_+3A_smoother.args">smoother.args</code></td>
<td>
<p>additional options accepted by the smoother, in the form of a list of
named values (see <em>Details</em> below).</p>
</td></tr>
<tr><td><code id="ScatterplotSmoothers_+3A_draw">draw</code></td>
<td>
<p>if TRUE, the default, draw the smoother on the currently active graph.
If FALSE, return a list with coordinates <code>x</code> and <code>y</code> for the points
that make up the smooth and if requested <code>x.pos, y.pos, x.neg, y.neg</code> for the
spread smooths.</p>
</td></tr>
<tr><td><code id="ScatterplotSmoothers_+3A_offset">offset</code></td>
<td>
<p>For use when <code>spread=TRUE</code>, the vertical axis is <code>sqrt(offset^2 + variance smooth)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>loessLine</code> function is a re-implementation of the <code>loess</code> smoother
that was used in <span class="pkg">car</span> prior to September 2012.  The main enhancement is the ability to
set more options through the <code>smoother.args</code> argument.
</p>
<p>The <code>gamLine</code> function is more general than  <code>loessLine</code> 
because it supports fitting a generalized spline regression model, with user-specified error
distribution and link function.
</p>
<p>The <code>quantregLine</code> function fits a model using splines with estimation
based on L1 regression for the median and quantile regression the (optional) spread.  It is
likely to be more robust than the other smoothers.
</p>
<p>The <code>smoother.args</code> argument is a list of named elements (or sub-arguments) used to pass
additional arguments to the smoother.  As of November, 2016, the smoother is evaluated by default at an equally spaced grid of 50 points in the range of the horizontal variable.  With any of the smoothers, you can change to, say, 100 evaluation points via the argument <code>smoother.args=list(evaluation=100)</code>.  As of version 3.0-1, the <code>smoother.args</code> elements  <code>col.var</code>, <code>lty.var</code>, and <code>lwd.var</code> are equivalent to <code>col.spread</code>, <code>lty.spread</code>, and <code>lwd.spread</code>, respectively. The <code>style</code> sub-argument controls how spread/variance envelopes are displayed, with choices <code>"filled"</code> (the default), <code>"lines"</code>, and <code>"none"</code> (which is equivalent to <code>var=FALSE</code>). The <code>alpha</code> subargument controls the transparency/opacity of filled spread envelopes with allowable values between <code>0</code> and <code>1</code> (default <code>0.15</code>). The <code>border</code> subargument controls whether a border line is drawn around the filled region (the default is <code>TRUE</code>). The <code>vertical</code> subargument controls whether the left and right ends of the filled region are forced to be vertical (the default is <code>TRUE</code>).
</p>
<p>For <code>loessLine</code>, the default is
<code>smoother.args=list(lty.smooth=1, lwd.smooth=2, lty.spread=4, lwd.spread=2, style="filled", alpha=0.15, span=2/3,
degree=1, family="symmetric", iterations=4)</code>. (Prior to November 2016, the default span was 1/2.)
The elements <code>lty.smooth</code>, <code>lwd.smooth</code>, and <code>col.spread</code> are the line type, line width, and line color, 
respectively of the mean or median smooth; <code>lty.spread</code>,
<code>lwd.spread</code>, and <code>col.spread</code> are the line type, width, and color of the spread smooths, if requested.
The elements <code>span</code>, <code>degree</code>, and <code>family</code> are
passed as arguments to the <code><a href="stats.html#topic+loess">loess</a></code> function, along with <code>iterations</code> robustness iterations.
</p>
<p>For <code>gamLine</code>, the default is
<code>smoother.args=list(lty.smooth=1, lwd.smooth=2, lty.spread=4, lwd.spread=2, style="filled", alpha=0.15,
k=-1, bs="tp", family="gaussian", link=NULL, weights=NULL)</code>.
The first six elements are as for <code>loessLine</code>.  The next two
elements are passed to the <code><a href="mgcv.html#topic+gam">gam</a></code> function to control smoothing:
<code>k=-1</code> allows <code>gam</code> to choose the number of splines in the basis
function; <code>bs="tp"</code> provides the type of spline basis to be used, with <code>"tp"</code>
for the default thin-plate splines.  The last three arguments specify
a distributional family, link function, and weights as in generalized linear models.  See the examples
below.  The <code>spread</code> element is ignored unless <code>family="gaussian"</code> and <code>link=NULL</code>.
</p>
<p>For <code>quantregLine</code>, the default is
<code>smoother.args=list(lty.smooth=1, lwd.smooth=2, lty.spread=4, lwd.spread=2, style="filled", alpha=0.15,
lambda=IQR(x))</code>.  The first six
elements are as for <code>loessLine</code>.  The last element is passed to the
<code><a href="quantreg.html#topic+qss">qss</a></code> function in <span class="pkg">quantreg</span>.  It is a smoothing
parameter, by default a robust estimate of the scale of the horizontal axis variable.
This is an arbitrary choice, and may not work well in all circumstances.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a> and Sanford Weisberg <a href="mailto:sandy@umn.edu">sandy@umn.edu</a>.</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+scatterplot">scatterplot</a></code>, <code><a href="car.html#topic+scatterplotMatrix">scatterplotMatrix</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code>,
<code><a href="stats.html#topic+loess">loess</a></code>, and <code><a href="quantreg.html#topic+rqss">rqss</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>scatterplot(prestige ~ income, data=Prestige)
scatterplot(prestige ~ income, data=Prestige, smooth=list(smoother=gamLine))
scatterplot(prestige ~ income, data=Prestige,
    smooth=list(smoother=quantregLine))

scatterplot(prestige ~ income | type, data=Prestige)
scatterplot(prestige ~ income | type, data=Prestige,
    smooth=list(smoother=gamLine))
scatterplot(prestige ~ income | type, data=Prestige,
    smooth=list(smoother=quantregLine))
scatterplot(prestige ~ income | type, data=Prestige, smooth=FALSE)

scatterplot(prestige ~ income | type, data=Prestige, 
    smooth=list(spread=TRUE))
scatterplot(prestige ~ income | type, data=Prestige,
    smooth=list(smoother=gamLine, spread=TRUE))
scatterplot(prestige ~ income | type, data=Prestige,
    smooth=list(smoother=quantregLine, spread=TRUE))

scatterplot(weight ~ repwt | sex, data=Davis,
    smooth=list(smoother=loessLine, spread=TRUE, style="lines"))
scatterplot(weight ~ repwt | sex, data=Davis,
    smooth=list(smoother=gamLine, spread=TRUE, style="lines")) # messes up
scatterplot(weight ~ repwt | sex, data=Davis,
    smooth=list(smoother=quantregLine, spread=TRUE, style="lines")) #  robust

set.seed(12345)
w &lt;- 1 + rpois(100, 5)
x &lt;- rnorm(100)
p &lt;- 1/(1 + exp(-(x + 0.5*x^2)))
y &lt;- rbinom(100, w, p)
scatterplot(y/w ~ x, smooth=list(smoother=gamLine, family="binomial",
    weights=w))
scatterplot(y/w ~ x, smooth=list(smoother=gamLine, family=binomial,
    link="probit", weights=w))
scatterplot(y/w ~ x, smooth=list(smoother=loessLine), reg=FALSE)

y &lt;- rbinom(100, 1, p)
scatterplot(y ~ x, smooth=list(smoother=gamLine, family=binomial))
</code></pre>

<hr>
<h2 id='showLabels'>
Functions to Identify and Mark Extreme Points in a 2D Plot.
</h2><span id='topic+showLabels'></span>

<h3>Description</h3>

<p>This function is called by several graphical functions in the <span class="pkg">car</span>
package to mark extreme points in a 2D plot.  Although the user is unlikely
to call this function directly, the documentation below applies to all
these other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showLabels(x, y, labels=NULL, method="identify",
  n = length(x), cex=1, col=carPalette()[1], location=c("lr", "ab", "avoid"), ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showLabels_+3A_x">x</code></td>
<td>

<p>Plotted horizontal coordinates.
</p>
</td></tr>
<tr><td><code id="showLabels_+3A_y">y</code></td>
<td>

<p>Plotted vertical coordinates.
</p>
</td></tr>
<tr><td><code id="showLabels_+3A_labels">labels</code></td>
<td>

<p>Plotting labels.  When called from within a <span class="pkg">car</span> plotting function, the labels are automatically obtained from the row names in the data frame used to create the modeling object. If <code>labels=NULL</code>, case numbers will be used.  If labels are long, the
<code><a href="base.html#topic+substr">substr</a></code> or <code><a href="base.html#topic+abbreviate">abbreviate</a></code> functions can be used to shorten them. Users may supply their own labels as a character vector of length equal to the number of plotted points.  For use with <span class="pkg">car</span> plotting functions, the number of plotted points is equal to the number of rows of data that have neither missing values nor are excluded using the &lsquo;subset&rsquo; argument.  When called directly, the length of labels shoud equal the length of x.
</p>
</td></tr>
<tr><td><code id="showLabels_+3A_method">method</code></td>
<td>

<p>How points are to be identified.  See Details below.
</p>
</td></tr>
<tr><td><code id="showLabels_+3A_n">n</code></td>
<td>

<p>Number of points to be identified.  If set to 0, no points are identified.
</p>
</td></tr>
<tr><td><code id="showLabels_+3A_cex">cex</code></td>
<td>

<p>Controls the size of the plotted labels.  The default is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="showLabels_+3A_col">col</code></td>
<td>

<p>Controls the color of the plotted labels. The default is the first element returned by <code>carPalette()</code>.
</p>
</td></tr>
<tr><td><code id="showLabels_+3A_location">location</code></td>
<td>
<p>Where should the label be drawn?  The default is <code>"lr"</code> to draw the label to the left of the point for points in the right-half of the graph and to the right for points in the left-half.  The other option is <code>"ab"</code> for above the point for points below the middle of the graph and above the point below the middle. Finally, <code>"avoid"</code> tries to avoid over-plotting labels.
</p>
</td></tr>
<tr><td><code id="showLabels_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>method</code> determine how the points
to be identified are selected.  For the default value of <code>method="identify"</code>,
the <code><a href="graphics.html#topic+identify">identify</a></code> function is used to identify points
interactively using the mouse.  Up to <code>n</code> points can be identified,
so if  <code>n=0</code>, which is the default in many functions in the <span class="pkg">car</span>
package, then no point identification is done.
</p>
<p>Automatic point identification can be done depending on the value of the
argument <code>method</code>.
</p>

<ul>
<li> <p><code>method = "x"</code> select points according to their value of <code>abs(x - mean(x))</code>
</p>
</li>
<li> <p><code>method = "y"</code> select points according to their value of <code>abs(y - mean(y))</code>
</p>
</li>
<li> <p><code>method = "r"</code> select points according to their value of <code>abs(y)</code>, as may be
appropriate in residual plots, or others with a meaningful origin at 0
</p>
</li>
<li> <p><code>method = "mahal"</code> Treat <code>(x, y)</code> as if it were a bivariate sample, and
select cases according to their Mahalanobis distance from  <code>(mean(x), mean(y))</code>
</p>
</li>
<li> <p><code>method</code> can be a vector of the same length as <code>x</code> consisting of
values to determine the points to be labeled.  For example, for a linear model
<code>m</code>, setting <code>method=cooks.distance(m)</code> will label the
points corresponding to the largest values of Cook's distance, or
<code>method = which(abs(residuals(m, type="pearson")) &gt; 2</code> would label
all observations with Pearson residuals greater than 2 in absolute value.
Warning:  If missing data are present, points may be incorrectly labelled.
</p>
</li>
<li> <p><code>method</code> can be a vector of case numbers or case-labels, in which case
those cases will be labeled.  Warning:  If missing data are present, a list of
case numbers may identify the wrong points.  A list of case labels, however,
will work correctly with missing values.
</p>
</li>
<li> <p><code>method = "none"</code> causes no point labels to be shown.
</p>
</li></ul>

<p>With <code>showLabels</code>, the <code>method</code> argument can be a list, so, for
example <code>method=list("x", "y")</code> would label according to the horizontal
and vertical axes variables.
</p>
<p>Finally, if the axes in the graph are logged, the function uses logged-variables
where appropriate.
</p>


<h3>Value</h3>

<p>A function primarily used for its side-effect of drawing
point labels on a plot.
Returns invisibly the labels of the selected points, or NULL if no
points are selected. Although intended for use with other functions in
the <span class="pkg">car</span> package, this function can be used directly.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>, Sanford Weisberg <a href="mailto:sandy@umn.edu">sandy@umn.edu</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) <em>An R Companion to Applied Regression</em>,
Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+avPlots">avPlots</a></code>, <code><a href="car.html#topic+residualPlots">residualPlots</a></code>,
<code><a href="car.html#topic+crPlots">crPlots</a></code>, <code><a href="car.html#topic+leveragePlots">leveragePlots</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(income ~ education, Prestige)
with(Prestige, showLabels(education, income,
     labels = rownames(Prestige), method=list("x", "y"), n=3))
m &lt;- lm(income ~ education, Prestige)
plot(income ~ education, Prestige)
abline(m)
with(Prestige, showLabels(education, income,
     labels=rownames(Prestige), method=abs(residuals(m)), n=4))
</code></pre>

<hr>
<h2 id='sigmaHat'> Return the scale estimate for a regression model </h2><span id='topic+sigmaHat'></span><span id='topic+sigmaHat.default'></span><span id='topic+sigmaHat.glm'></span><span id='topic+sigmaHat.lm'></span>

<h3>Description</h3>

<p>This function provides a consistent method to return the estimated scale
from a linear, generalized linear, nonlinear, or other model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigmaHat(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigmaHat_+3A_object">object</code></td>
<td>
<p>A regression object of type lm, glm or nls</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an lm or nls object, the returned quantity is the square root of the
estimate of <code class="reqn">\sigma^2</code>.  For a glm object, the returned quantity is
the square root of the estimated dispersion parameter.
</p>


<h3>Value</h3>

<p>A nonnegative number
</p>


<h3>Author(s)</h3>

<p>Sanford Weisberg, <a href="mailto:sandy@umn.edu">sandy@umn.edu</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- lm(prestige ~ income + education, data=Duncan)
sigmaHat(m1)
</code></pre>

<hr>
<h2 id='some'>Sample a Few Elements of an Object</h2><span id='topic+some'></span><span id='topic+some.data.frame'></span><span id='topic+some.matrix'></span><span id='topic+some.default'></span>

<h3>Description</h3>

<p>Randomly select a few elements of an object, typically a data frame,
matrix, vector, or list. If the object is a data frame or a matrix,
then rows are sampled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>some(x, ...)

## S3 method for class 'data.frame'
some(x, n=10, cols=NULL, ...)

## S3 method for class 'matrix'
some(x, n=10, cols=NULL, ...)

## Default S3 method:
some(x, n=10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="some_+3A_x">x</code></td>
<td>
<p>the object to be sampled.</p>
</td></tr>
<tr><td><code id="some_+3A_n">n</code></td>
<td>
<p>number of elements to sample.</p>
</td></tr>
<tr><td><code id="some_+3A_cols">cols</code></td>
<td>
<p>if <code>NULL</code>, use all columns, if a vector of column names or numbers, use only the columns indicated</p>
</td></tr>
<tr><td><code id="some_+3A_...">...</code></td>
<td>
<p>arguments passed down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sampled elements or rows.
</p>


<h3>Note</h3>

<p>These functions are adapted from <code>head</code> and <code>tail</code>
in the <code>utils</code> package.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+head">head</a></code>, <code><a href="utils.html#topic+tail">tail</a></code>, <code><a href="car.html#topic+brief">brief</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>some(Duncan)
some(Duncan, cols=names(Duncan)[1:3])
</code></pre>

<hr>
<h2 id='spreadLevelPlot'>Spread-Level Plots</h2><span id='topic+spreadLevelPlot'></span><span id='topic+slp'></span><span id='topic+spreadLevelPlot.formula'></span><span id='topic+spreadLevelPlot.default'></span><span id='topic+spreadLevelPlot.lm'></span><span id='topic+print.spreadLevelPlot'></span>

<h3>Description</h3>

<p>Creates plots for examining the possible dependence of
spread on level, or an extension of these plots to the studentized residuals
from linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spreadLevelPlot(x, ...)

slp(...)

## S3 method for class 'formula'
spreadLevelPlot(x, data=NULL, subset, na.action, 
    main=paste("Spread-Level Plot for", varnames[response], 
    "by", varnames[-response]), ...)

## Default S3 method:
spreadLevelPlot(x, by, robust.line=TRUE, 
	start=0, xlab="Median", ylab="Hinge-Spread", 
	point.labels=TRUE, las=par("las"),
	main=paste("Spread-Level Plot for", deparse(substitute(x)), 
		"by", deparse(substitute(by))), 
	col=carPalette()[1], col.lines=carPalette()[2],
    pch=1, lwd=2, grid=TRUE, ...)

## S3 method for class 'lm'
spreadLevelPlot(x, robust.line=TRUE, 
	xlab="Fitted Values", ylab="Absolute Studentized Residuals", las=par("las"),
	main=paste("Spread-Level Plot for\n", deparse(substitute(x))),
	pch=1, col=carPalette()[1], col.lines=carPalette()[2:3], lwd=2, grid=TRUE, 
    id=FALSE, smooth=TRUE, ...)
	  
## S3 method for class 'spreadLevelPlot'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spreadLevelPlot_+3A_x">x</code></td>
<td>
<p>a formula of the form <code>y ~ x</code>, where <code>y</code> is a numeric vector
and <code>x</code> is a factor, or an <code>lm</code> object to be plotted; alternatively a numeric vector.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables to be plotted. 
By default the variables are taken from the environment from which 
<code>spreadLevelPlot</code> is called.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_na.action">na.action</code></td>
<td>
<p>a function that indicates what should happen when the data contain <code>NA</code>s. 
The default is set by the <code>na.action</code> setting of <code>options</code>.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_by">by</code></td>
<td>
<p>a factor, numeric vector, or character vector defining groups.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_robust.line">robust.line</code></td>
<td>
<p>if <code>TRUE</code> a robust line is fit using the <code>rlm</code> function in
the <code>MASS</code> package; if <code>FALSE</code> a line is fit using <code>lm</code>.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_start">start</code></td>
<td>
<p>add the constant <code>start</code> to each data value.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_main">main</code></td>
<td>
<p>title for the plot.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_xlab">xlab</code></td>
<td>
<p>label for horizontal axis.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_ylab">ylab</code></td>
<td>
<p>label for vertical axis.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_point.labels">point.labels</code></td>
<td>
<p>if <code>TRUE</code> label the points in the plot with group names.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_las">las</code></td>
<td>
<p>if <code>0</code>, ticks labels are drawn parallel to the
axis; set to <code>1</code> for horizontal labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_col">col</code></td>
<td>
<p>color for points; the default is the first entry
in the current <span class="pkg">car</span> palette (see <code><a href="car.html#topic+carPalette">carPalette</a></code>
and <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_col.lines">col.lines</code></td>
<td>
<p>for the default method, the line color, defaulting to the second entry in the <span class="pkg">car</span> color palette; 
for the <code>"lm"</code> method, a vector of two colors for, respectively, the fitted straight line and a nonparametric regression smooth line,
default to the second and third entries in the <span class="pkg">car</span> color palette.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_pch">pch</code></td>
<td>
<p>plotting character for points; default is <code>1</code> 
(a circle, see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>2</code> (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_grid">grid</code></td>
<td>
<p>If TRUE, the default, a light-gray background grid is put on the
graph</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_id">id</code></td>
<td>
<p>controls point identification; if <code>FALSE</code> (the default), no points are identified;
can be a list of named arguments to the <code><a href="car.html#topic+showLabels">showLabels</a></code> function;
<code>TRUE</code> is equivalent to <code>list(method=list("x", "y"), n=2, 
        cex=1, col=carPalette()[1], location="lr")</code>,
which identifies the 2 points the most extreme horizontal (&quot;X&quot;, absolute studentized residual) values and the 2 points
with the most extreme horizontal (&quot;Y&quot;, fitted values) values.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_smooth">smooth</code></td>
<td>
<p>specifies the smoother to be used along with its arguments; if <code>FALSE</code>, no smoother is shown;
can be a list giving the smoother function and its named arguments; <code>TRUE</code>, the default, is equivalent to
<code>list(smoother=loessLine)</code>. See <code><a href="car.html#topic+ScatterplotSmoothers">ScatterplotSmoothers</a></code> for the smoothers supplied by the
<span class="pkg">car</span> package and their arguments.</p>
</td></tr>
<tr><td><code id="spreadLevelPlot_+3A_...">...</code></td>
<td>
<p>arguments passed to plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Except for linear models, computes the statistics for, and plots, a Tukey spread-level plot
of log(hinge-spread) vs. log(median) for the groups; fits a line to the plot; and calculates a
spread-stabilizing transformation from the slope of the line. 
</p>
<p>For linear models, plots log(abs(studentized residuals) vs. log(fitted values).  Point labeling was added in November, 2016.
</p>
<p>The function <code>slp</code> is an abbreviation for <code>spreadLevelPlot</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>spreadLevelPlot</code> containing:
</p>
<table>
<tr><td><code>Statistics</code></td>
<td>
<p>a matrix with the lower-hinge, median, upper-hinge, and hinge-spread
for each group. (Not for an <code>lm</code> object.)</p>
</td></tr>
<tr><td><code>PowerTransformation</code></td>
<td>
<p>spread-stabilizing power transformation, calculated as <code class="reqn">1 - slope</code>
of the line fit to the plot.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

 
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Hoaglin, D. C., Mosteller, F. and Tukey, J. W. (Eds.) (1983)
<em>Understanding Robust and Exploratory Data Analysis.</em> Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+hccm">hccm</a></code>, <code><a href="car.html#topic+ncvTest">ncvTest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>spreadLevelPlot(interlocks + 1 ~ nation, data=Ornstein)
slp(lm(interlocks + 1 ~ assets + sector + nation, data=Ornstein))
</code></pre>

<hr>
<h2 id='strings2factors'>
Convert Character-String Variables in a Data Frame to Factors
</h2><span id='topic+strings2factors'></span><span id='topic+strings2factors.data.frame'></span>

<h3>Description</h3>

<p>Converts the character variables (or a subset of these variables) in a data frame to factors, with optional control of the order of the resulting factor levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strings2factors(object, which, not, exclude.unique, levels, verbose, ...)
## S3 method for class 'data.frame'
strings2factors(object, which, not, 
    exclude.unique=TRUE, levels=list(), verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strings2factors_+3A_object">object</code></td>
<td>
<p>a data frame or an object inheriting from the <code>"data.frame"</code> class.</p>
</td></tr>
<tr><td><code id="strings2factors_+3A_which">which</code></td>
<td>
<p>an optional character vector of names or column numbers of the character variables to be converted to factors; if absent, <em>all</em> character variables will be converted, except as excluded by the <code>not</code> and <code>exclude.unique</code> arguments (see below).</p>
</td></tr>
<tr><td><code id="strings2factors_+3A_not">not</code></td>
<td>
<p>an optional character vector of names or column numbers of character variables <em>not</em> to be converted to factors.</p>
</td></tr>
<tr><td><code id="strings2factors_+3A_exclude.unique">exclude.unique</code></td>
<td>
<p>if <code>TRUE</code> (the default), character variables all of whose values are unique (i.e., all different from each other) are not converted to factors. Such variables, which would have as many levels as there are cases, are typically case identifiers and not categorical variables. If <code>FALSE</code>, character variables all of whose values are unique are converted to factors with a warning.</p>
</td></tr>
<tr><td><code id="strings2factors_+3A_levels">levels</code></td>
<td>
<p>an optional named list, each element of which is a character vector of levels of the corresponding factor. This argument allows you to control the order of levels of the factor; if omitted, or if a particular factor is omitted from the list, the levels will be in the default alphabetic order.</p>
</td></tr>
<tr><td><code id="strings2factors_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (the default), the names of the character variables that were converted to factors are printed on the console.</p>
</td></tr>
<tr><td><code id="strings2factors_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with (some) character variables replaced by corresponding factors.</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+factor">factor</a></code>, <code><a href="base.html#topic+data.frame">data.frame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- Moore # from the carData package
M$partner &lt;- as.character(Moore$partner.status)
M$fcat &lt;- as.character(Moore$fcategory)
M$names &lt;- rownames(M) # values are unique
str(M)
str(strings2factors(M))
str(strings2factors(M,
  levels=list(partner=c("low", "high"), fcat=c("low", "medium", "high"))))
str(strings2factors(M, which="partner", levels=list(partner=c("low", "high"))))
str(strings2factors(M, not="partner", exclude.unique=FALSE))
</code></pre>

<hr>
<h2 id='subsets'>Plot Output from regsubsets Function in leaps package</h2><span id='topic+subsets'></span><span id='topic+subsets.regsubsets'></span>

<h3>Description</h3>

<p>The <code><a href="leaps.html#topic+regsubsets">regsubsets</a></code> function in the <span class="pkg">leaps</span> package finds
optimal subsets of predictors based on some criterion statistic. This function plots a measure of fit against subset size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsets(object, ...)

## S3 method for class 'regsubsets'
subsets(object, 
    names=abbreviate(object$xnames, minlength = abbrev), 
    abbrev=1, min.size=1, max.size=length(names), 
    legend="interactive", 
    statistic=c("bic", "cp", "adjr2", "rsq", "rss"), 
    las=par('las'), cex.subsets=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsets_+3A_object">object</code></td>
<td>
<p>a <code>regsubsets</code> object produced by the <code>regsubsets</code> function
in the <span class="pkg">leaps</span> package.</p>
</td></tr>
<tr><td><code id="subsets_+3A_names">names</code></td>
<td>
<p>a vector of (short) names for the predictors, excluding the
regression intercept, if one is present; if missing, these are
derived from the predictor names in <code>object</code>.</p>
</td></tr>
<tr><td><code id="subsets_+3A_abbrev">abbrev</code></td>
<td>
<p>minimum number of characters to use in abbreviating predictor names.</p>
</td></tr>
<tr><td><code id="subsets_+3A_min.size">min.size</code></td>
<td>
<p>minimum size subset to plot; default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="subsets_+3A_max.size">max.size</code></td>
<td>
<p>maximum size subset to plot; default is number of predictors.</p>
</td></tr>
<tr><td><code id="subsets_+3A_legend">legend</code></td>
<td>
<p>If not <code>FALSE</code>, in which case the legend is suppressed,
the coordinates at which to place a legend of the abbreviated predictor names on the plot, 
in a form recognized by
the <code><a href="graphics.html#topic+legend">legend</a></code> function. If <code>"interactive"</code>, the legend is placed on the
plot interactively with the mouse. By expanding the left or right plot margin, you can place
the legend in the margin, if you wish (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="subsets_+3A_statistic">statistic</code></td>
<td>
<p>statistic to plot for each predictor subset; one of: 
<code>"bic"</code>, Bayes Information Criterion; 
<code>"cp"</code>, Mallows's <code class="reqn">C_{p}</code>;
<code>"adjr2"</code>, <code class="reqn">R^{2}</code> adjusted for degrees of freedom;
<code>"rsq"</code>, unadjusted <code class="reqn">R^{2}</code>;
<code>"rss"</code>, residual sum of squares.</p>
</td></tr>
<tr><td><code id="subsets_+3A_las">las</code></td>
<td>
<p>if <code>0</code>, ticks labels are drawn parallel to the
axis; set to <code>1</code> for horizontal labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="subsets_+3A_cex.subsets">cex.subsets</code></td>
<td>
<p>can be used to change the relative size of the characters used to
plot the regression subsets; default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="subsets_+3A_...">...</code></td>
<td>
<p>arguments to be passed down to 
<code>subsets.regsubsets</code> and <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if the <code>legend</code> is <code>TRUE</code>; otherwise a data frame with the legend.
</p>


<h3>Author(s)</h3>

<p>John Fox</p>


<h3>References</h3>

<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="leaps.html#topic+regsubsets">regsubsets</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(leaps)){
    subsets(regsubsets(undercount ~ ., data=Ericksen),
            legend=c(3.5, -37))
}
</code></pre>

<hr>
<h2 id='symbox'>Boxplots for transformations to symmetry</h2><span id='topic+symbox'></span><span id='topic+symbox.formula'></span><span id='topic+symbox.default'></span><span id='topic+symbox.lm'></span>

<h3>Description</h3>

<p><code>symbox</code> first transforms <code>x</code> to each of a series
of selected powers, with each transformation standardized to mean 0 and
standard deviation 1. The results are then displayed side-by-side in boxplots, permiting
a visual assessment of which power makes the distribution reasonably symmetric.
For the <code>"lm"</code> method, the response variable in the model is successively 
transformed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>symbox(x, ...)
## S3 method for class 'formula'
symbox(formula, data=NULL, subset, na.action=NULL, ylab,  ...)
## Default S3 method:
symbox(x, powers = c(-1, -0.5, 0, 0.5, 1), start, 
	trans=bcPower, xlab="Powers", ylab, ...)
## S3 method for class 'lm'
symbox(x, powers = c(-1, -0.5, 0, 0.5, 1), start, trans=bcPower, 
                      xlab, ylab="Studentized residuals", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symbox_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="symbox_+3A_formula">formula</code></td>
<td>
<p>a one-sided formula specifying a single numeric variable.</p>
</td></tr>
<tr><td><code id="symbox_+3A_data">data</code>, <code id="symbox_+3A_subset">subset</code>, <code id="symbox_+3A_na.action">na.action</code></td>
<td>
<p>as for statistical modeling functions (see, e.g., <code><a href="stats.html#topic+lm">lm</a></code>).</p>
</td></tr>
<tr><td><code id="symbox_+3A_xlab">xlab</code>, <code id="symbox_+3A_ylab">ylab</code></td>
<td>
<p>axis labels; if <code>ylab</code> is missing, a label will be supplied. For the <code>"lm"</code> method, if <code>xlab</code> is missing, a label will also be supplied.</p>
</td></tr>
<tr><td><code id="symbox_+3A_powers">powers</code></td>
<td>
<p>a vector of selected powers to which <code>x</code> is to be raised. 
For meaningful comparison of powers,  <code>1</code> should be included
in the vector of powers.</p>
</td></tr>
<tr><td><code id="symbox_+3A_start">start</code></td>
<td>
<p>a constant to be added to <code>x</code>. If <code>start</code> is missing and
<code>trans</code> is <code><a href="car.html#topic+bcPower">bcPower</a></code> (the default) or <code><a href="car.html#topic+bcnPower">bcnPower</a></code>, then
a start will be automatically generated if there are zero or negative values in 
<code>x</code>, and a warning will be printed; the auto-generated <code>start</code> is the
absolute value of the minimum <code>x</code> plus 1 percent of the range of <code>x</code>.</p>
</td></tr>
<tr><td><code id="symbox_+3A_trans">trans</code></td>
<td>
<p>a transformation function whose first argument is a numeric vector and whose second
argument is a transformation parameter, given by the <code>powers</code> argument; the default
is <code><a href="car.html#topic+bcPower">bcPower</a></code>, and another possibility is <code><a href="car.html#topic+yjPower">yjPower</a></code>.
<code><a href="car.html#topic+bcnPower">bcnPower</a></code> may also be used, in which case the <code>gamma</code> parameter
is set to the value of <code>start</code>.</p>
</td></tr>
<tr><td><code id="symbox_+3A_...">...</code></td>
<td>
<p>arguments to be passed down.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>as returned by <code>boxplot</code>.</p>


<h3>Author(s)</h3>

<p>Gregor Gorjanc, John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>.</p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition. Sage.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+boxplot">boxplot</a></code>, <code><a href="MASS.html#topic+boxcox">boxcox</a></code>, <code><a href="car.html#topic+bcPower">bcPower</a></code>, <code><a href="car.html#topic+yjPower">yjPower</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>symbox(~ income, data=Prestige)
symbox(lm(wages ~ education + poly(age, 2) + sex, data=SLID))
</code></pre>

<hr>
<h2 id='Tapply'>Apply a Function to a Variable Within Factor Levels</h2><span id='topic+Tapply'></span>

<h3>Description</h3>

<p>Applies a function, typically to compute a single statistic, like a mean, median, or standard deviation,
within levels of a factor or within combinations of levels of two or more factors to produce a table of statistics. This function provides
a formula interface to the standard R <code><a href="base.html#topic+tapply">tapply</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tapply(formula, fun, data, na.action = na.pass, ..., targs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Tapply_+3A_formula">formula</code></td>
<td>
<p> a two-sided formula of the form <code>variable ~ factor.1 + factor.2 + ... + factor.n</code> or,
equivalently, <code>variable ~ factor.1*factor.2* ... *factor.n</code>.
The variables on the right-hand side
of the formula are normally factors or are otherwise coerced to factors.</p>
</td></tr>
<tr><td><code id="Tapply_+3A_fun">fun</code></td>
<td>
<p>a function, like <code>mean</code>, <code>median</code>, or <code>sd</code>, that takes a vector first argument and typically
returns a single number as its value.</p>
</td></tr>
<tr><td><code id="Tapply_+3A_data">data</code></td>
<td>
<p>an optional data frame within which to find the variable and factor(s).</p>
</td></tr>
<tr><td><code id="Tapply_+3A_na.action">na.action</code></td>
<td>
<p>a function to handle missing values, as in statistical modeling functions like <code><a href="stats.html#topic+lm">lm</a></code>;
the default is <code><a href="stats.html#topic+na.pass">na.pass</a></code>.</p>
</td></tr>
<tr><td><code id="Tapply_+3A_...">...</code></td>
<td>
<p>arguments to pass to the function given in the <code>fun</code> argument, such as (commonly) 
<code>na.rm=TRUE</code>.</p>
</td></tr>
<tr><td><code id="Tapply_+3A_targs">targs</code></td>
<td>
<p>a list of optional arguments to pass to <code><a href="base.html#topic+tapply">tapply</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function given by <code>fun</code> is applied to the values of the left-hand-side variable in <code>formula</code> within
(combination of) levels of the factor(s) given in the right-hand side of <code>formula</code>, producing a table of statistics.
</p>


<h3>Value</h3>

<p>The object returned by <code><a href="base.html#topic+tapply">tapply</a></code>, typically simply printed.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition. Sage.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+tapply">tapply</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>Tapply(conformity ~ partner.status + fcategory, mean, data=Moore)
Tapply(conformity ~ partner.status + fcategory, mean, data=Moore, 
    trim=0.2)

Moore[1, 2] &lt;- NA
Tapply(conformity ~ partner.status + fcategory, mean, data=Moore)
Tapply(conformity ~ partner.status + fcategory, mean, data=Moore, 
  na.rm=TRUE)
Tapply(conformity ~ partner.status + fcategory, mean, data=Moore, 
  na.action=na.omit)  # equivalent
remove("Moore")
</code></pre>

<hr>
<h2 id='testTransform'>Likelihood-Ratio Tests for Univariate or Multivariate Power Transformations
to Normality</h2><span id='topic+testTransform'></span><span id='topic+testTransform.powerTransform'></span><span id='topic+testTransform.lmerModpowerTransform'></span><span id='topic+testTransform.bcnPowerTransformlmer'></span>

<h3>Description</h3>

<p><code>testTransform</code> computes likelihood ratio tests for particular values of the power parameter
based on <code>powerTransform</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testTransform(object, lambda)

## S3 method for class 'powerTransform'
testTransform(object, lambda=rep(1, dim(object$y)[2]))

## S3 method for class 'lmerModpowerTransform'
testTransform(object, lambda=1)

## S3 method for class 'bcnPowerTransformlmer'
testTransform(object, lambda=1)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testTransform_+3A_object">object</code></td>
<td>
<p>An object created by a call to <code>powerTransform</code>.</p>
</td></tr>
<tr><td><code id="testTransform_+3A_lambda">lambda</code></td>
<td>
<p>A vector of powers of length equal to the number of
variables transformed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="car.html#topic+powerTransform">powerTransform</a></code> is used to estimate a power
transformation for a univariate or multivariate sample or multiple linear
regression problem, using the method of Box and Cox (1964).  It is usual to
round the estimates to nearby convenient values, and this function is use to
compulte a likelihood ratio test for values of the transformation parameter
other than the ml-type estimate.
</p>
<p>For one-parameter families of transformations, namely the Box-Cox power family <code><a href="car.html#topic+bcPower">bcPower</a></code> and the Yeo-Johnson power family <code><a href="car.html#topic+yjPower">yjPower</a></code>, this function computes a test based on twice the difference in the log-likelihood between the maximum likelihood-like estimate and the log-likelihood evaluated at the value of <code>lambda</code> specified.
</p>
<p>For the <code><a href="car.html#topic+bcnPower">bcnPower</a></code> Box-Cox power with negatives allowed, the test is based on the profile loglikelihood maximizing over the location (or <code>gamma</code>) parameter(s).  Thus, <code>gamma</code> is treated as a nusiance parameter.</p>


<h3>Value</h3>

<p>A data frame with one row giving the value of the test statistic, its
degrees of freedom, and a p-value.  The test is the likelihood ratio test,
comparing the value of the log-likelihood at the hypothesized value to
the value of the log-likelihood at the maximum likelihood estimate.
</p>


<h3>Author(s)</h3>

<p> Sanford Weisberg, &lt;sandy@umn.edu&gt; </p>


<h3>References</h3>

<p>Box, G. E. P. and Cox, D. R. (1964) An analysis of transformations. <em>Journal
of the Royal Statisistical Society, Series B</em>. 26 211-46.
</p>
<p>Cook, R. D. and Weisberg, S. (1999)  <em>Applied Regression Including Computing
and Graphics</em>.  Wiley.
</p>
<p>Fox, J. and Weisberg, S. (2019)
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>
<p>Weisberg, S. (2014) <em>Applied Linear Regression</em>, Fourth Edition, Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+powerTransform">powerTransform</a></code> and <code><a href="car.html#topic+bcnPower">bcnPower</a></code> for examples of the use of this function and other tests that might be of interest in some circumstances. </p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(a3 &lt;- powerTransform(cbind(len, adt, trks, sigs1) ~ htype, Highway1))
# test lambda = (0 0 0 -1)
testTransform(a3, c(0, 0, 0, -1))
summary(q1 &lt;- powerTransform(lm(cbind(LoBD$I1L2, LoBD$I1L1) ~ pool, LoBD), family="bcnPower"))
testTransform(q1, c(.3, .8))

</code></pre>

<hr>
<h2 id='TransformationAxes'>Axes for Transformed Variables</h2><span id='topic+basicPowerAxis'></span><span id='topic+bcPowerAxis'></span><span id='topic+bcnPowerAxis'></span><span id='topic+yjPowerAxis'></span><span id='topic+probabilityAxis'></span>

<h3>Description</h3>

<p>These functions produce axes for the original scale of 
transformed variables. Typically these would appear as additional
axes to the right or
at the top of the plot, but if the plot is produced with 
<code>axes=FALSE</code>, then these functions could be used for axes below or to
the left of the plot as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basicPowerAxis(power, base=exp(1), 
    side=c("right", "above", "left", "below"), 
    at, start=0, lead.digits=1, n.ticks, grid=FALSE, grid.col=gray(0.50), 
    grid.lty=2,
    axis.title="Untransformed Data", cex=1, las=par("las"))

bcPowerAxis(power, side=c("right", "above", "left", "below"), 
    at, start=0, lead.digits=1, n.ticks, grid=FALSE, grid.col=gray(0.50), 
    grid.lty=2,
    axis.title="Untransformed Data", cex=1, las=par("las"))
    
bcnPowerAxis(power, shift, side=c("right", "above", "left", "below"), 
    at, start=0, lead.digits=1, n.ticks, grid=FALSE, grid.col=gray(0.50), 
    grid.lty=2,
    axis.title="Untransformed Data", cex=1, las=par("las"))
    
yjPowerAxis(power, side=c("right", "above", "left", "below"), 
	at, lead.digits=1, n.ticks, grid=FALSE, grid.col=gray(0.50), 
  grid.lty=2,
	axis.title="Untransformed Data", cex=1, las=par("las"))

probabilityAxis(scale=c("logit", "probit"), 
	side=c("right", "above", "left", "below"),
	at, lead.digits=1, grid=FALSE, grid.lty=2, grid.col=gray(0.50),
    axis.title = "Probability", interval = 0.1, cex = 1, las=par("las"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransformationAxes_+3A_power">power</code></td>
<td>
<p>power for Box-Cox, Box-Cox with negatives, Yeo-Johnson, or simple power transformation.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_shift">shift</code></td>
<td>
<p>the shift (gamma) parameter for the Box-Cox with negatives family.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_scale">scale</code></td>
<td>
<p>transformation used for probabilities, <code>"logit"</code>
(the default) or <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_side">side</code></td>
<td>
<p>side at which the axis is to be drawn; numeric
codes are also permitted: <code>side = 1</code> for the bottom of the plot,
<code>side=2</code> for the left side, 
<code>side = 3</code> for the top, <code>side = 4</code> for the right side.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_at">at</code></td>
<td>
<p>numeric vector giving location of tick marks on
original scale; if missing, the function will try to pick
nice locations for the ticks.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_start">start</code></td>
<td>
<p>if a <em>start</em> was added to a variable (e.g., to make all
data values positive), it can now be subtracted from the tick labels.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_lead.digits">lead.digits</code></td>
<td>
<p>number of leading digits for determining &lsquo;nice&rsquo; numbers 
for tick labels (default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_n.ticks">n.ticks</code></td>
<td>
<p>number of tick marks; if missing, same as corresponding
transformed axis.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_grid">grid</code></td>
<td>
<p>if <code>TRUE</code> grid lines for the axis will be drawn.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_grid.col">grid.col</code></td>
<td>
<p>color of grid lines.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_grid.lty">grid.lty</code></td>
<td>
<p>line type for grid lines.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_axis.title">axis.title</code></td>
<td>
<p>title for axis.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_cex">cex</code></td>
<td>
<p>relative character expansion for axis label.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_las">las</code></td>
<td>
<p>if <code>0</code>, ticks labels are drawn parallel to the
axis; set to <code>1</code> for horizontal labels (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_base">base</code></td>
<td>
<p>base of log transformation for <code>power.axis</code>
when <code>power = 0</code>.</p>
</td></tr>
<tr><td><code id="TransformationAxes_+3A_interval">interval</code></td>
<td>
<p>desired interval between tick marks on the probability
scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transformations corresponding to the three functions are as follows:
</p>

<dl>
<dt><code>basicPowerAxis</code>:</dt><dd><p>Simple power transformation, 
<code class="reqn">x^{\prime }=x^{p}</code> for <code class="reqn">p\neq 0</code>
and <code class="reqn">x^{\prime }=\log x</code> for <code class="reqn">p=0</code>.</p>
</dd>
<dt><code>bcPowerAxis</code>:</dt><dd><p>Box-Cox power transformation,
<code class="reqn">x^{\prime }=(x^{\lambda }-1)/\lambda</code> 
for <code class="reqn">\lambda \neq 0</code> and <code class="reqn">x^{\prime }=\log x</code> 
for <code class="reqn">\lambda =0</code>.</p>
</dd>
<dt><code>bcnPowerAxis</code>:</dt><dd><p>Box-Cox with negatives power transformation, the Box-Cox power transformation of <code class="reqn">z = .5 * (y + (y^2 + \gamma^2)^{1/2})</code>, where <code class="reqn">\gamma</code> is strictly positive if <code class="reqn">y</code> includes negative values and non-negative otherwise.  The value of <code class="reqn">z</code> is always positive.</p>
</dd>
<dt><code>yjPowerAxis</code>:</dt><dd><p>Yeo-Johnson power transformation, 
for non-negative <code class="reqn">x</code>, the Box-Cox transformation of
<code class="reqn">x + 1</code>; for negative <code class="reqn">x</code>, the Box-Cox transformation of
<code class="reqn">|x| + 1</code> with power <code class="reqn">2 - p</code>.</p>
</dd>
<dt><code>probabilityAxis</code>:</dt><dd><p>logit or probit transformation,
logit <code class="reqn">=\log [p/(1-p)]</code>, or 
probit <code class="reqn">=\Phi^{-1}(p)</code>, where <code class="reqn">\Phi^{-1}</code> is the
standard-normal quantile function.</p>
</dd>
</dl>

<p>These functions will try to place tick marks at reasonable locations, but
producing a good-looking graph sometimes requires some fiddling with the 
<code>at</code> argument.
</p>


<h3>Value</h3>

<p>These functions are used for their side effects: to draw axes.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+basicPower">basicPower</a></code>, <code><a href="car.html#topic+bcPower">bcPower</a></code>, <code><a href="car.html#topic+yjPower">yjPower</a></code>, 
<code><a href="boot.html#topic+logit">logit</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>UN &lt;- na.omit(UN)
par(mar=c(5, 4, 4, 4) + 0.1) # leave space on right

with(UN, plot(log(ppgdp, 10), log(infantMortality, 10)))
basicPowerAxis(0, base=10, side="above", 
  at=c(50, 200, 500, 2000, 5000, 20000), grid=TRUE, 
  axis.title="GDP per capita")
basicPowerAxis(0, base=10, side="right",
  at=c(5, 10, 20, 50, 100), grid=TRUE, 
  axis.title="infant mortality rate per 1000")

with(UN, plot(bcPower(ppgdp, 0), bcPower(infantMortality, 0)))
bcPowerAxis(0, side="above", 
  grid=TRUE, axis.title="GDP per capita")
bcPowerAxis(0, side="right",
  grid=TRUE, axis.title="infant mortality rate per 1000")

with(UN, qqPlot(logit(infantMortality/1000)))
probabilityAxis()

with(UN, qqPlot(qnorm(infantMortality/1000)))
probabilityAxis(at=c(.005, .01, .02, .04, .08, .16), scale="probit")

qqPlot(bcnPower(Ornstein$interlocks, lambda=1/3, gamma=0.1))
bcnPowerAxis(1/3, 0.1, at=c(o=0, 5, 10, 20, 40, 80))
</code></pre>

<hr>
<h2 id='vif'>Variance Inflation Factors</h2><span id='topic+vif'></span><span id='topic+vif.default'></span><span id='topic+vif.lm'></span><span id='topic+vif.merMod'></span><span id='topic+vif.polr'></span><span id='topic+vif.svyolr'></span>

<h3>Description</h3>

<p>Calculates variance-inflation and generalized variance-inflation factors
(VIFs and GVIFs) for linear, generalized linear, and other regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif(mod, ...)

## Default S3 method:
vif(mod, ...)

## S3 method for class 'lm'
vif(mod, type=c("terms", "predictor"), ...)

## S3 method for class 'merMod'
vif(mod, ...)

## S3 method for class 'polr'
vif(mod, ...)

## S3 method for class 'svyolr'
vif(mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vif_+3A_mod">mod</code></td>
<td>
<p>for the default method, an object that responds to 
<code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>, and
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, such as a <code>glm</code> object.</p>
</td></tr>
<tr><td><code id="vif_+3A_type">type</code></td>
<td>
<p>for unweighted <code>lm</code> objects only, how to handle models that contain interactions: see Details below.</p>
</td></tr>
<tr><td><code id="vif_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If all terms in an unweighted linear model have 1 df, then the usual variance-inflation
factors are calculated.
</p>
<p>If any terms in an unweighted linear model have more than 1 df, then generalized variance-inflation factors
(Fox and Monette, 1992) are calculated. These are interpretable as the inflation
in size of the confidence ellipse or ellipsoid for the coefficients of the term in
comparison with what would be obtained for orthogonal data. 
</p>
<p>The generalized VIFs
are invariant with respect to the coding of the terms in the model (as long as
the subspace of the columns of the model matrix pertaining to each term is
invariant). To adjust for the dimension of the confidence ellipsoid, the function
also prints <code class="reqn">GVIF^{1/(2\times df)}</code> where <code class="reqn">df</code> is the degrees of freedom
associated with the term.
</p>
<p>Through a further generalization, the implementation here is applicable as well to other sorts of models,
in particular weighted linear models,  generalized linear models, and mixed-effects models.
</p>
<p>Two methods of computing GVIFs are provided for unweighted linear models: 
</p>

<ul>
<li><p> Setting <code>type="terms"</code> (the default) behaves like the default method, and computes the GVIF for each term in the model, ignoring relations of marginality among the terms in models with interactions. GVIFs computed in this manner aren't generally sensible.
</p>
</li>
<li><p> Setting <code>type="predictor"</code> focuses in turn on each predictor in the model, combining the main effect for that predictor with the main effects of the predictors with which the focal predictor interacts and the interactions; e.g., in the model with formula <code>y ~ a*b + b*c</code>, the GVIF for the predictor <code>a</code> also includes the <code>b</code> main effect and the <code>a:b</code> interaction regressors; the GVIF for the predictor <code>c</code> includes the <code>b</code> main effect and the  <code>b:c</code> interaction; and the GVIF for the predictor <code>b</code> includes the <code>a</code> and <code>c</code> main effects and the <code>a:b</code> and <code>a:c</code> interactions (i.e., the whole model), and is thus necessarily 1. These predictor GVIFs should be regarded as experimental.
</p>
</li></ul>

<p>Specific methods are provided for ordinal regression model objects produced by <code><a href="MASS.html#topic+polr">polr</a></code> in the <span class="pkg">MASS</span> package and <code><a href="survey.html#topic+svyolr">svyolr</a></code> in the <span class="pkg">survey</span> package, which are &quot;intercept-less&quot;; VIFs or GVIFs for linear and similar regression models without intercepts are generally not sensible.
</p>


<h3>Value</h3>

<p>A vector of VIFs, or a matrix containing one row for each term, and
columns for the GVIF, df, and <code class="reqn">GVIF^{1/(2\times df)}</code>, the last 
of which is intended to be comparable across terms of different dimension.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a> and Henric Nilsson</p>


<h3>References</h3>

 
<p>Fox, J. and Monette, G. (1992)
Generalized collinearity diagnostics.
<em>JASA</em>, <b>87</b>, 178&ndash;183.
</p>
<p>Fox, J. (2016)
<em>Applied Regression Analysis and Generalized Linear Models</em>,
Third Edition. Sage.  
</p>
<p>Fox, J. and Weisberg, S. (2018) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vif(lm(prestige ~ income + education, data=Duncan))
vif(lm(prestige ~ income + education + type, data=Duncan))
vif(lm(prestige ~ (income + education)*type, data=Duncan),
    type="terms") # not recommended
vif(lm(prestige ~ (income + education)*type, data=Duncan),
    type="predictor")
</code></pre>

<hr>
<h2 id='wcrossprod'>
Weighted Matrix Crossproduct
</h2><span id='topic+wcrossprod'></span>

<h3>Description</h3>

<p>Given matrices <code>x</code> and <code>y</code> as arguments and an optional matrix or vector of weights, <code>w</code>, 
return a weighted matrix cross-product, <code>t(x) w y</code>.
If no weights are supplied, or the weights are constant, the function uses
<code><a href="Matrix.html#topic+crossprod">crossprod</a></code> for speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wcrossprod(x, y, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wcrossprod_+3A_x">x</code>, <code id="wcrossprod_+3A_y">y</code></td>
<td>

<p>x, y numeric matrices; <code>missing(y)</code> is taken to be the same matrix as x. 
Vectors are promoted to single-column or single-row matrices, depending on the context. 
</p>
</td></tr>
<tr><td><code id="wcrossprod_+3A_w">w</code></td>
<td>

<p>A numeric vector or matrix of weights, conformable with <code>x</code> and <code>y</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix, with appropriate dimnames taken from <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly,
John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+crossprod">crossprod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
n &lt;- 24
drop &lt;- 4
sex &lt;- sample(c("M", "F"), n, replace=TRUE)
x1 &lt;- 1:n
x2 &lt;- sample(1:n)
extra &lt;- c( rep(0, n - drop), floor(15 + 10 * rnorm(drop)) )
y1 &lt;- x1 + 3*x2 + 6*(sex=="M") + floor(10 * rnorm(n)) + extra
y2 &lt;- x1 - 2*x2 - 8*(sex=="M") + floor(10 * rnorm(n)) + extra
# assign non-zero weights to 'dropped' obs
wt &lt;- c(rep(1, n-drop), rep(.2,drop))

X &lt;- cbind(x1, x2)
Y &lt;- cbind(y1, y2)
wcrossprod(X)
wcrossprod(X, w=wt)

wcrossprod(X, Y)
wcrossprod(X, Y, w=wt)

wcrossprod(x1, y1)
wcrossprod(x1, y1, w=wt)

</code></pre>

<hr>
<h2 id='whichNames'>Position of Row Names</h2><span id='topic+which.names'></span><span id='topic+whichNames'></span><span id='topic+whichNames.data.frame'></span><span id='topic+whichNames.default'></span>

<h3>Description</h3>

<p>These functions return the indices of the supplied row names of a data frame
or names of another object, such as a vector or list. <code>whichNames</code> is just an alias for <code>which.names</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichNames(names, object, ...)

which.names(names, object, ...)

## S3 method for class 'data.frame'
whichNames(names, object, ...)

## Default S3 method:
whichNames(names, object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whichNames_+3A_names">names</code></td>
<td>
<p>a name or character vector of names.</p>
</td></tr>
<tr><td><code id="whichNames_+3A_object">object</code></td>
<td>
<p>a data frame or an object with a names attribute.</p>
</td></tr>
<tr><td><code id="whichNames_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the index or indices of <code>names</code> in row names of the data frame or names of an object of another class. 
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>Fox, J. and Weisberg, S. (2019) 
<em>An R Companion to Applied Regression</em>, Third Edition, Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>whichNames(c('minister', 'conductor'), Duncan)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
