<!DOCTYPE html><html lang="en"><head><title>Help for package ConfMatrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ConfMatrix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ConfMatrix'><p>Confusion matrix</p></a></li>
<li><a href='#QCCS'><p>Quality Control Columns Set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Confusion Matrix</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Silverio Vilchez-Lopez &lt;svilchez@ujaen.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Thematic quality indices are provided to facilitate the evaluation
    and quality control of geospatial data products (e.g. thematic maps, remote
    sensing classifications, etc.). The indices offered are based on the
    so-called confusion matrix. This matrix is constructed by comparing the
    assigned classes or attributes of a set of pairs of positions or objects
    in the product and the ground truth. In this package it is considered that
    the classes of the ground truth correspond to the columns and that the
    classes of the product to be valued correspond to the rows. The package
    offers two object classes with their methods: 'ConfMatrix' (Confusion
    matrix) and 'QCCS' (Quality Control Columns Set). The 'ConfMatrix' class of
    objects offers more than 20 methods based on the confusion matrix. The
    'QCCS' class of objects offers a different perspective in which the ground
    truth is considered to allow the values of the column marginals to be fixed,
    see Ariza López et al. (2019) &lt;<a href="https://doi.org/10.3390%2Fapp9204240">doi:10.3390/app9204240</a>&gt; and Canran Liu et al.
    (2007) &lt;<a href="https://doi.org/10.1016%2Fj.rse.2006.10.010">doi:10.1016/j.rse.2006.10.010</a>&gt; for more details. The package was
    created with 'R6'.</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, Rdpack, ggplot2, gridExtra</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, roxygen2, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-30 11:53:33 UTC; UJA</td>
</tr>
<tr>
<td>Author:</td>
<td>Francisco Javier Ariza-Lopez [aut],
  Paola Barba-Ceballos [aut],
  Silverio Vilchez-Lopez [aut, cre],
  Jose Rodriguez-Avi [aut],
  Maria Virtudes Alba-Fernandez [aut],
  Jose Luis Garcia-Balboa [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-03 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ConfMatrix'>Confusion matrix</h2><span id='topic+ConfMatrix'></span>

<h3>Description</h3>

<p>The ConfMatrix class works with confusion matrices, thus providing
the possibility of calculating several indices with their
corresponding variances and confidence intervals. A confusion matrix
is constructed by comparing a sample of a set of common positions in
the product and the ground truth. Appropriate sampling methods must
be applied to generate the confusion matrix. It is considered that
the classes of the ground truth correspond to the columns
and that the classes of the product to be valued correspond
to the rows. First, an object of this class of object must be created
(instantiated) and then the methods that offer the index calculations
will be invoked. Mnemonic method names are proposed and are therefore
long, for example methods that provide averages start with &quot;AV&quot; and
those that provide combinations start with &quot;Comb&quot;. Methods related
to a specific thematics class end with the ending &quot;_i&quot;.
</p>


<h3>Mathematical elements</h3>


<ul>
<li> <p><code class="reqn">x_{ii}</code>: diagonal element of the matrix.
</p>
</li>
<li> <p><code class="reqn">x_{ij}</code>: element <code class="reqn">i,j</code> of the matrix.
</p>
</li>
<li> <p><code class="reqn">x_{i+}</code>: sum of all elements in rows <code class="reqn">i</code>.
</p>
</li>
<li> <p><code class="reqn">x_{+j}</code>: sum of all elements in column <code class="reqn">j</code>.
</p>
</li>
<li> <p><code class="reqn">M</code>: number of classes.
</p>
</li>
<li> <p><code class="reqn">\overline{x}_{i+}</code>: sum of all elements of row <code class="reqn">i</code> except element <code class="reqn">i</code> of the diagonal.
</p>
</li>
<li> <p><code class="reqn">\overline{x}_{+i}</code>: sum of all elements of column <code class="reqn">i</code> except element <code class="reqn">i</code> of the diagonal.
</p>
</li>
<li> <p><code class="reqn">N_{Total}</code>:Total count of elements in the instance's Confusion Matrix.
</p>
<p style="text-align: center;"><code class="reqn">N_{Total}=\sum_{i,j}^M x_{ij}</code>
</p>

</li>
<li> <p><code class="reqn">N_i / N_j</code>: Total count of elements in row <code class="reqn">i</code> or column <code class="reqn">j</code>.
</p>
<p style="text-align: center;"><code class="reqn">N_{i}=x_{i+}</code>
</p>

<p style="text-align: center;"><code class="reqn">N_{j}=x_{+j}</code>
</p>

</li>
<li> <p><code class="reqn">N_{ij}</code>: Total count of elements in row <code class="reqn">i</code> and column <code class="reqn">j</code>.
</p>
<p style="text-align: center;"><code class="reqn">N_{ij}=x_{i+}+x_{+j}-x_{ii}</code>
</p>

</li></ul>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Values</code></dt><dd><p><code style="white-space: pre;">&#8288;
Matrix of integer values. An matrix must be added.
&#8288;</code></p>
</dd>
<dt><code>ID</code></dt><dd><p><code style="white-space: pre;">&#8288;
Identifier. It is a character string with a maximum length of 50 characters.
By default,&#8288;</code> <code class="reqn">CM_i</code> <code style="white-space: pre;">&#8288;will be taken as identification. Where&#8288;</code> <code class="reqn">i \in [1,999]</code> <code style="white-space: pre;">&#8288;will be the
number of ConfMatrix instances already defined in the session.
&#8288;</code></p>
</dd>
<dt><code>Date</code></dt><dd><p><code style="white-space: pre;">&#8288;
Date provided by the user in format DDMMYYYY, "DD-MM-YYYY", "DD/MM/YYYY".
By default the date provided by the system will be taken.

&#8288;</code></p>
</dd>
<dt><code>ClassNames</code></dt><dd><p><code style="white-space: pre;">&#8288;
Name of the classes. It is given by a character strings vector whose elements
are the name of the classes. Each element of the vector is a string of maximum
20 characters. By default for the column elements they will be&#8288;</code> <code class="reqn">PC_i</code>
(Producer class) <code style="white-space: pre;">&#8288;and for the elements of row&#8288;</code> <code class="reqn">UC_i</code><code style="white-space: pre;">&#8288; (User class), with&#8288;</code> <code class="reqn">i</code> <code style="white-space: pre;">&#8288;being the correspond-
ing row or column number.
&#8288;</code></p>
</dd>
<dt><code>Source</code></dt><dd><p><code style="white-space: pre;">&#8288;
Indicates where the matrix comes from (article, project, etc.). It is suggest-
ed to enter a reference or a DOI. A character string with a maximum length of
80 characters can be entered. By default, is NULL.
&#8288;</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ConfMatrix-new"><code>ConfMatrix$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-plot.index"><code>ConfMatrix$plot.index()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-plot.UserProdAcc"><code>ConfMatrix$plot.UserProdAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-print"><code>ConfMatrix$print()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AllParameters"><code>ConfMatrix$AllParameters()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-UserAcc"><code>ConfMatrix$UserAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-UserAcc_i"><code>ConfMatrix$UserAcc_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AvUserAcc"><code>ConfMatrix$AvUserAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-CombUserAcc"><code>ConfMatrix$CombUserAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-ProdAcc"><code>ConfMatrix$ProdAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-ProdAcc_i"><code>ConfMatrix$ProdAcc_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AvProdAcc"><code>ConfMatrix$AvProdAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-CombProdAcc"><code>ConfMatrix$CombProdAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-UserProdAcc"><code>ConfMatrix$UserProdAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-CombUserProdAcc"><code>ConfMatrix$CombUserProdAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AvUserProdAcc"><code>ConfMatrix$AvUserProdAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AvUserProdAcc_i"><code>ConfMatrix$AvUserProdAcc_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-UserProdAcc_W"><code>ConfMatrix$UserProdAcc_W()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-OverallAcc"><code>ConfMatrix$OverallAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-Kappa"><code>ConfMatrix$Kappa()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-ModKappa"><code>ConfMatrix$ModKappa()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-UserKappa_i"><code>ConfMatrix$UserKappa_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-ModKappaUser_i"><code>ConfMatrix$ModKappaUser_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-ProdKappa_i"><code>ConfMatrix$ProdKappa_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-ModKappaProd_i"><code>ConfMatrix$ModKappaProd_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-DetailKappa"><code>ConfMatrix$DetailKappa()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-DetailCondKappa"><code>ConfMatrix$DetailCondKappa()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-DetailWKappa"><code>ConfMatrix$DetailWKappa()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-Tau"><code>ConfMatrix$Tau()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-DetailWTau"><code>ConfMatrix$DetailWTau()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-Ent"><code>ConfMatrix$Ent()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AvNormEnt"><code>ConfMatrix$AvNormEnt()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-GeomAvNormEnt"><code>ConfMatrix$GeomAvNormEnt()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AvMaxNormEnt"><code>ConfMatrix$AvMaxNormEnt()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-EntUser_i"><code>ConfMatrix$EntUser_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-NormEntUser"><code>ConfMatrix$NormEntUser()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-EntProd_i"><code>ConfMatrix$EntProd_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-NormEntProd"><code>ConfMatrix$NormEntProd()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-Sucess"><code>ConfMatrix$Sucess()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-Sucess_i"><code>ConfMatrix$Sucess_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AvHellAcc"><code>ConfMatrix$AvHellAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AvHellAcc_i"><code>ConfMatrix$AvHellAcc_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-AvShortAcc"><code>ConfMatrix$AvShortAcc()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-ShortAcc_i"><code>ConfMatrix$ShortAcc_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-GroundTruth"><code>ConfMatrix$GroundTruth()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-GroundTruth_i"><code>ConfMatrix$GroundTruth_i()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-HellingerDist"><code>ConfMatrix$HellingerDist()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-QES"><code>ConfMatrix$QES()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-MTypify"><code>ConfMatrix$MTypify()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-MBootStrap"><code>ConfMatrix$MBootStrap()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-MNormalize"><code>ConfMatrix$MNormalize()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-MPseudoZeroes"><code>ConfMatrix$MPseudoZeroes()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-OverallAcc.test"><code>ConfMatrix$OverallAcc.test()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-Kappa.test"><code>ConfMatrix$Kappa.test()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-Tau.test"><code>ConfMatrix$Tau.test()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-TSCM.test"><code>ConfMatrix$TSCM.test()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-QIndep.test"><code>ConfMatrix$QIndep.test()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ConfMatrix-new"></a>



<h4>Method <code>new()</code></h4>

<p>Public method to create an instance of the ConfMatrix class.
When creating it, values must be given to the matrix. The values
of the matrix must be organized in such a way that the columns
represent the classes in the reference and the rows represent
the classes in the product being evaluated. The creation of a
ConfMatrix instance includes a series of checks on the data. If
checks are not met, the system generates coded error messages.
The optional possibility of adding metadata to the matrix is offered.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$new(
  Values,
  ID = NULL,
  Date = NULL,
  ClassNames = NULL,
  Source = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Values</code></dt><dd><p><code style="white-space: pre;">&#8288;
Matrix of integer values. A matrix must be added.
&#8288;</code></p>
</dd>
<dt><code>ID</code></dt><dd><p><code style="white-space: pre;">&#8288;
Identifier. It is a character string with a maximum length of 50 characters.
By default,&#8288;</code> <code class="reqn">CM_i</code> <code style="white-space: pre;">&#8288;will be taken as identification. Where&#8288;</code> <code class="reqn">i \in [1,999]</code> <code style="white-space: pre;">&#8288;will be the
number of ConfMatrix instances already defined in the session.
&#8288;</code></p>
</dd>
<dt><code>Date</code></dt><dd><p><code style="white-space: pre;">&#8288;
Date provided by the user in format DDMMYYYY, "DD-MM-YYYY", "DD/MM/YYYY".
By default the date provided by the system will be taken.

&#8288;</code></p>
</dd>
<dt><code>ClassNames</code></dt><dd><p><code style="white-space: pre;">&#8288;
Name of the classes. It is given by a character strings vector whose elements
are the name of the classes. Each element of the vector is a string of maximum
20 characters. By default for the column elements they will be&#8288;</code> <code class="reqn">PC_i</code>
(Producer class) <code style="white-space: pre;">&#8288;and for the elements of row&#8288;</code> <code class="reqn">UC_i</code><code style="white-space: pre;">&#8288; (User class), with&#8288;</code> <code class="reqn">i</code> <code style="white-space: pre;">&#8288;being the correspond-
ing row or column number.
&#8288;</code></p>
</dd>
<dt><code>Source</code></dt><dd><p><code style="white-space: pre;">&#8288;
Indicates where the matrix comes from (article, project, etc.). It is suggest-
ed to enter a reference or a DOI. A character string with a maximum length of
80 characters can be entered. By default, is NULL.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Object of the ConfMatrix class, or an error message.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
cm&lt;-ConfMatrix$new (A,ID="5",Date="27-10-2023",Source="Congalton and Green,
2008")

</pre>
</div>


<hr>
<a id="method-ConfMatrix-plot.index"></a>



<h4>Method <code>plot.index()</code></h4>

<p>Public method that provides a graph of the indices of
the functions ConfMatrix$OverallAcc, ConfMatrix$Kappa,
ConfMatrix$Tau, ConfMatrix$AvHellAcc and ConfMatrix$AvShortAcc
with their corresponding standard deviations.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$plot.index()</pre></div>



<h5>Returns</h5>

<p>A graph of the indices of the functions OverallAcc, Kappa,
Tau, AvHellAcc, AvShortAcc with their corresponding
standard deviations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.index()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-plot.UserProdAcc"></a>



<h4>Method <code>plot.UserProdAcc()</code></h4>

<p>Public method that provides a graph for the user’s
and producer’s accuracies and standard deviations.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$plot.UserProdAcc()</pre></div>



<h5>Returns</h5>

<p>The graph of the accuracy index of users and producers
with their corresponding standard desviation.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.UserProdAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-print"></a>



<h4>Method <code>print()</code></h4>

<p>Public method that shows all the data entered
by the user for a instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$print()</pre></div>



<h5>Returns</h5>

<p>ConfMatrix object identifier, date, class name, data
source and confusion matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,ClassNames=c("Deciduous","conifer","agriculture",
"shrub"),Source="Congalton and Green 2008")
p$print()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AllParameters"></a>



<h4>Method <code>AllParameters()</code></h4>

<p>Public method in which multiple parameters are
calculated for the given confusion matrix. This method is
equivalent to ConfMatrix$OverallAcc,ConfMatrix$UserAcc,
ConfMatrix$ProdAcc,ConfMatrix$Kappa and ConfMatrix$MPseudoZeroes.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AllParameters()</pre></div>



<h5>Returns</h5>

<p>The following list of elements: the confusion matrix,
dimension, total sum of cell values, overall accuracy, overall
accuracy variance, global kappa index, global kappa simplified
variance, producer accuracy by class, user accuracy by class,
and pseudoceros matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AllParameters()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-UserAcc"></a>



<h4>Method <code>UserAcc()</code></h4>

<p>Public method for deriving the index called user’s
accuracy for all the classes in a ConfMatrix object instance.
The user's accuracy for the class <code class="reqn">i</code> of a thematic product is
calculated by dividing the value in the diagonal of class <code class="reqn">i</code> by
the sum of all values in the row of the class <code class="reqn">i</code> (row marginal).
The method also offers the variance and confidence interval.
The reference Congalton and Green (2008) is followed
for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
UserAcc=\dfrac{x_{ii}}{x_{i+}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{UserAcc}=\dfrac{UserAcc \cdot (1-UserAcc)}{N_{i}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$UserAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of vectors, containing the user’s accuracy real values for
all classes, their variances and confidence intervals for each class,
respectively.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-UserAcc_i"></a>



<h4>Method <code>UserAcc_i()</code></h4>

<p>Public method for deriving the index called
user’s accuracy for a specific class <code class="reqn">i</code> in a ConfMatrix object
instance. The user’s accuracy for the class <code class="reqn">i</code> of a thematic
product is calculated by dividing the value in the diagonal of
class <code class="reqn">i</code> by the sum of all values in the row of the class i
(row marginal). The method also offers the variance and confidence
interval. The reference Congalton and Green (2008)
is followed for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
UserAcc_{i}=\dfrac{x_{ii}}{x_{i+}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{UserAcc_i}=\dfrac{UserAcc_i \cdot (1-UserAcc_i)}{N_{i}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$UserAcc_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the user’s accuracy
for class i, its variance, and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc_i(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AvUserAcc"></a>



<h4>Method <code>AvUserAcc()</code></h4>

<p>Public method that provides the arithmetic average,
without weighing, of all user’s accuracies of a ConfMatrix object
instance. The method also offers the variance and confidence
interval. The reference Tung and LeDrew (1988) is
followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
AvUserAcc=\dfrac{1}{M} \sum^M_{i=1} \dfrac{x_{ii}}
{ x_{i+}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{AvUserAcc}=\dfrac{AvUserAcc \cdot (1-AvUserAcc)}{N_{Total}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AvUserAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the average
user’s accuracy, its variance, and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(352,43,89,203),nrow=2,ncol=2)
p&lt;-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvUserAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-CombUserAcc"></a>



<h4>Method <code>CombUserAcc()</code></h4>

<p>Public method that provides the combined user's accuracy.
Which is the average of the overall accuracy and the average user's
accuracy. The method also offers the
variance and confidence interval. The reference
Tung and LeDrew (1988) is followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
CombUserAcc=\dfrac{OverallAcc+AvUserAcc}{2}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{CombUserAcc}=\dfrac{CombUserAcc \cdot (1-CombUserAcc)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">OverallAcc</code>: overall accuracy.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$CombUserAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the combined
accuracy from the user's perspective,
its variation and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(352,43,89,203),nrow=2,ncol=2)
p&lt;-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombUserAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-ProdAcc"></a>



<h4>Method <code>ProdAcc()</code></h4>

<p>Public method for deriving the index called
producer’s accuracy for all the classes in a ConfMatrix
object instance. The producer’s accuracy for the class i
of a thematic product is calculated by dividing the value
in the diagonal of class <code class="reqn">i</code> by the sum of all values in the
row of the class <code class="reqn">i</code> (column marginal). The method also
offers the variance and confidence interval. The reference
Congalton and Green (2008) if followed for the
computations.
</p>
<p style="text-align: center;"><code class="reqn">
ProdAcc=\dfrac{x_{ii}}{x_{+j}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{ProdAcc}=\dfrac{ProdAcc \cdot (1-ProdAcc)}{N_{j}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$ProdAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of vectors each one containing the producer’s
accuracy real values for all classes, their variances and
confidence intervals for each class, respectively.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-ProdAcc_i"></a>



<h4>Method <code>ProdAcc_i()</code></h4>

<p>Public method for deriving the index called
producer’s accuracy for a specific class <code class="reqn">i</code> in a ConfMatrix
object instance. The user’s accuracy for the class <code class="reqn">i</code> of a
thematic product is calculated by dividing the value in the
diagonal of class <code class="reqn">i</code> by the sum of all values in the column
of the class <code class="reqn">i</code> (column marginal). The method also offers
the variance and confidence interval. The reference
Congalton and Green (2008) is followed for the
calculations.
</p>
<p style="text-align: center;"><code class="reqn">
ProdAcc_{i}=\dfrac{x_{ii}}{x_{+j}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{ProdAcc_i}=\dfrac{ProdAcc_i \cdot (1-ProdAcc_i)}{N_{j}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$ProdAcc_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Producer class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}.
</code></p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the producer’s
accuracy for class i, its variance, and its confidence
interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc_i(1)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AvProdAcc"></a>



<h4>Method <code>AvProdAcc()</code></h4>

<p>Public method that provides the arithmetic
average of all producer’s accuracies of a ConfMatrix object
instance. The method also offers the variance and confidence
interval. The reference Tung and LeDrew (1988)
is followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
AvProdAcc=\dfrac{1}{M} \sum^M_{i=1} \dfrac{x_{ii}}
{ x_{+j}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{AvProdAcc}=\dfrac{AvProdAcc \cdot (1-AvProdAcc)}{N_{Total}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AvProdAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the average producer’s
accuracy, its variance, and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(352,43,89,203),nrow=2,ncol=2)
p&lt;-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvProdAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-CombProdAcc"></a>



<h4>Method <code>CombProdAcc()</code></h4>

<p>Public method that provides the combined producer's
accuracy. Which is the average of the overall accuracy and the average
producer accuracy. The method also offers the
variance and confidence interval. The reference
Tung and LeDrew (1988) is followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
CombProdAcc=\dfrac{OverallAcc+AvProdAcc}{2}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{CombProdAcc}=\dfrac{CombProdAcc \cdot (1-CombProdAcc)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">OverallAcc</code>: overall accuracy.
</p>
</li>
<li> <p><code class="reqn">AvProdAcc</code>: average accuracy from producer's perspective.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$CombProdAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the combined accuracy
from producer's perspective, its variance and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(352,43,89,203),nrow=2,ncol=2)
p&lt;-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombProdAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-UserProdAcc"></a>



<h4>Method <code>UserProdAcc()</code></h4>

<p>Public method that calculates the user’s and the
producer’s indexes jointly. This method is equivalent to the methods
ConfMatrix$UserAcc and ConfMatrix$ProdAcc.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$UserProdAcc()</pre></div>



<h5>Returns</h5>

<p>A list containing the producer's and user's accuracies and
their standard deviations, respectively.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserProdAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-CombUserProdAcc"></a>



<h4>Method <code>CombUserProdAcc()</code></h4>

<p>Public method that provides the combined accuracy,
defined by the average of the overall accuracy and the Hellden's
average accuracy, which refers to the average user's and producer's
accuracies. The method also offers the
variance and confidence interval. The reference
Liu et al. (2007) is followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
CombUserProdAcc=\dfrac{OverallAcc+AvHellAcc}{2}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{CombUserProdAcc}=\dfrac{CombUserProdAcc \cdot
(1-CombUserProdAcc)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">OverallAcc</code>: overall accuracy.
</p>
</li>
<li> <p><code class="reqn">AvHellAcc</code>: average of Hellden's mean accuracy index.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$CombUserProdAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the combined accuracy from both user's
and producer's perspectives, its variance and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$CombUserProdAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AvUserProdAcc"></a>



<h4>Method <code>AvUserProdAcc()</code></h4>

<p>Public method that provides the arithmetic
average of all user’s and producer’s accuracy indexes of
a ConfMatrix object instance. The method also offers the
variance and confidence interval. The reference
Liu et al. (2007) is followed for the
calculations.
</p>
<p style="text-align: center;"><code class="reqn">
AvUserProdAcc=\dfrac{AvUserAcc+AvProdAcc}{2}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{AvUserProdAcc}=\dfrac{AvUserProdAcc \cdot (1-AvUserProdAcc)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">AvUserAcc</code>: average accuracy from user's perspective.
</p>
</li>
<li> <p><code class="reqn">AvProdAcc</code>: average accuracy from producer's perspective.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AvUserProdAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the average mean
precision values from the user's and producer's perspective,
their variance and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AvUserProdAcc_i"></a>



<h4>Method <code>AvUserProdAcc_i()</code></h4>

<p>Public method that provides the average of
user’s and producer’s accuracies for a specific class i.
The method also offers the variance and confidence
interval. The reference Liu et al. (2007)
is followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
AvUserProdAcc_i=\dfrac{UserAcc_i+ProdAcc_i}{2}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{AvUserProdAcc_i}=\dfrac{AvUserProdAcc_i
\cdot (1-AvUserProdAcc_i)}{N_{ij}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">UserAcc_i</code>: user accuracy index for class i.
</p>
</li>
<li> <p><code class="reqn">ProdAcc_i</code>: producer accuracy index for class i.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AvUserProdAcc_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the average of
user’s and producer’s accuracies, its variance and
confidence interval for class i.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc_i(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-UserProdAcc_W"></a>



<h4>Method <code>UserProdAcc_W()</code></h4>

<p>Public method that calculates the weighted user's,
producer’s and overall accuracies and their standard deviations.
The reference Congalton and Green (2008) is followed
for the computations.
</p>
<p>Be
</p>
<p style="text-align: center;"><code class="reqn">
Overall_W=\dfrac{\sum^M_{i=1} p_{ii} }{\sum^M_{i,j=1} p_{ij}}
</code>
</p>

<p>where <code class="reqn">p_{ij}=\dfrac{x_{ij}}{\sum^M_{i,j=1} x_{ij}}</code>
</p>
<p style="text-align: center;"><code class="reqn">
UserAcc_W=\dfrac{p_{o_{i+}}}{p_{i+}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
ProdAcc_W=\dfrac{p_{o_{+j}}}{p_{+j}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{UserAcc_W}=\dfrac{UserAcc_W \cdot (1-UserAcc_W)}{N_i}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{ProdAcc_W}=\dfrac{ProdAcc_W \cdot (1-ProdAcc_W)}{N_j}
</code>
</p>

<p>where <code class="reqn">p_o=\sum^M_{i,j=1} w_{ij}p_{ij}</code> and <code class="reqn">0 \leq w_{ij} \leq 1</code>
for <code class="reqn">i \neq j</code> and <code class="reqn">w_{ii}=1</code> for <code class="reqn">i = j</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$UserProdAcc_W(WM)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>WM</code></dt><dd><p>Weight matrix (as matrix)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the weight matrix, the product of the
confusion matrix and the weight matrix, overall, user and
producer weighted accuracies and their standard deviations.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
WM&lt;- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1),nrow=4,ncol=4))
p$UserProdAcc_W(WM)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-OverallAcc"></a>



<h4>Method <code>OverallAcc()</code></h4>

<p>Public method to calculate the global index called
Overall Accuracy. The Overall Accuracy is calculated by dividing
the sum of the entries that form the major diagonal (i.e., the
number of correct classifications) by the total number of cases.
The method also offers the variance and confidence interval.
The reference Congalton and Green (2008)
is followed for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
OverallAcc = \dfrac{\sum_{i=1}^{M} x_{ii}}{\sum_{i, j=1}^{M} x_{ij}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{OverallAcc}=\dfrac{OverallAcc \cdot (1-OverallAcc)}{N_{Total}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$OverallAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the overall accuracy,
its variance, and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A)
p$OverallAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-Kappa"></a>



<h4>Method <code>Kappa()</code></h4>

<p>Public method that provides Kappa coefficient,
which measures the relationship between the observed proportion
of agreement and the proportion expected to occur by chance.
The method also offers the variance and confidence interval.
The reference Cohen (1960) is followed
for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
Kappa=\dfrac{OverallAcc-ExpAcc}{1-ExpAcc}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
ExpAcc= \dfrac{x_{+ i}x_{i +}}{ ( \sum_{i,j=1}^M x_{ij} )^{2} }
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{Kappa}=\dfrac{OverallAcc-ExpAcc}{(1-ExpAcc)^2 \cdot N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">OverallAcc</code>: overall accuracy.
</p>
</li>
<li> <p><code class="reqn">ExpAcc</code>: expected accuracy of agreement if agreement
were purely random.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$Kappa(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing with kappa
coefficient, its variance and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$Kappa()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-ModKappa"></a>



<h4>Method <code>ModKappa()</code></h4>

<p>Public method that provides the overall modified
kappa coefficient. The method also offers the
variance and confidence interval. The references
Stehman (1997) and Foody (1992)
are followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
ModKappa=\dfrac{OverallAcc-\dfrac{1}{M}}{1-\dfrac{1}{M}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{ModKappa}=\dfrac{OverallAcc \cdot (1- OverallAcc)}
{ \left(1-\dfrac{1}{M} \right)^2 \cdot N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">OverallAcc</code>: overall accuracy.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$ModKappa(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing modified coefficient
kappa, its variance and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A &lt;- matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),nrow=4,ncol=4)
p &lt;- ConfMatrix$new(A,Source="Foody 1992")
p$ModKappa()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-UserKappa_i"></a>



<h4>Method <code>UserKappa_i()</code></h4>

<p>Public method derived by the kappa coefficient evaluated
from the user's perspective, for a specific class i. The method
also offers the variance and confidence interval. The reference
Rosenfield and Fitzpatrick-Lins (1986) is followed
for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
UserKappa_i=\dfrac{UserAcc_i-\dfrac{ x_{i + }}
{\sum^M_{i,j=1} x_{ij}}}{1-\dfrac{ x_{i + }}
{\sum^M_{i,j=1} x_{ij}}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{UserKappa_i}=\dfrac{UserAcc_i \cdot (1-UserAcc_i)}
{ \left(1-\dfrac{ x_{i + }}
{\sum^M_{i,j=1} x_{ij}}\right)^2 \cdot N_{i}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">UserAcc_i</code>: user accuracy index for class i.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$UserKappa_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the kappa coefficient
(user’s perspective), its variance and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35, 29,13,3,5,7,28,48,1,0,2,3,17),
nrow=5,ncol=5)
p&lt;-ConfMatrix$new(A,Source="Næsset 1996")
p$UserKappa_i(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-ModKappaUser_i"></a>



<h4>Method <code>ModKappaUser_i()</code></h4>

<p>Public method, derived from the general modified
kappa coefficient, which provides the modified kappa coefficient
from the user's perspective and for a specific class i. Equitable probabilities
of belonging to each class are assumed. The method also offers
the variance and confidence interval. The references
Stehman (1997) and Foody (1992)
are followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
ModKappaUser_i=\dfrac{UserAcc_i-\dfrac{1}{M}}
{1-\dfrac{1}{M}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{ModKappaUser_i}=\dfrac{UserAcc_i
\cdot (1- UserAcc_i)}{ \left(1- \dfrac{1}{M} \right)^2 \cdot N_{i}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">UserAcc_i</code>: user accuracy index for class i.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$ModKappaUser_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the modified kappa
coefficient from the user's perspective, its variance and
confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Liu et al. 2007")
p$ModKappaUser_i(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-ProdKappa_i"></a>



<h4>Method <code>ProdKappa_i()</code></h4>

<p>Public method derived by the kappa coefficient evaluated
from the producer's perspective, for a specific class i. The method
also offers the variance and confidence interval. The reference
Rosenfield and Fitzpatrick-Lins (1986) is followed
for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
ProdKappa_i=\dfrac{ProdAcc_i-\dfrac{ x_{ + i }}
{\sum^M_{i,j=1} x_{ij}}}{1-\dfrac{ x_{+ i }}
{\sum^M_{i,j=1} x_{ij}}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{ProdKappa_i}=\dfrac{ProdAcc_i \cdot (1- ProdAcc_i)}
{\left(1-\dfrac{ x_{+ i }}
{\sum^M_{i,j=1} x_{ij}} \right)^2 \cdot N_{j}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">ProdAcc_i</code>: producer accuracy index for class i.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$ProdKappa_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the coefficient kappa
(producer’s), its variance and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A &lt;- matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,29,13,3,5,7,28,48,1,0,2,3,17),
nrow=5,ncol=5)
p&lt;-ConfMatrix$new(A,Source="Næsset 1996")
p$ProdKappa_i(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-ModKappaProd_i"></a>



<h4>Method <code>ModKappaProd_i()</code></h4>

<p>Public method, derived from the general modified
kappa coefficient, which provides the modified kappa coefficient
from the producer's perspective and for a specific class i. Equitable
probabilities of belonging to each class are assumed. The method also
offers the variance and confidence interval. The references
Stehman (1997) and Foody (1992)
are followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
ModKappaProd_i=\dfrac{ProdAcc_i-\dfrac{1}{M}}
{1-\dfrac{1}{M}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{ModKappaProd_i}=\dfrac{ProdAcc_i
\cdot (1- ProdAcc_i)}{ \left( 1-\dfrac{1}{M} \right)^2 \cdot N_{j}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">ProdAcc_i</code>: producer accuracy index for class i.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$ModKappaProd_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the modified kappa coefficient
from the producer's perspective, its variance and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Foody 1992")
p$ModKappaProd_i(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-DetailKappa"></a>



<h4>Method <code>DetailKappa()</code></h4>

<p>Public method that calculates the general Kappa
agreement index, its standard deviation and the test statistic
to test its significance. The delta method has been used to calculate
the sample variance. The reference
Congalton and Green (2008) is followed for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
Kappa=\dfrac{OverallAcc-ExpAcc}{1-ExpAcc}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
ExpAcc= \dfrac{x_{+ j} \cdot x_{i +}}{\sum_{(i,j=1}^M x_{ij})^{2}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{Kappa} = \dfrac{1}{N_{Total}} \left( \dfrac{\theta_1 (1-\theta_1) }{(1-\theta_2)^2}
+ \dfrac{2(1-\theta_1)(2\theta_1\theta_2-\theta_3)}{(1-\theta_2)^3}
+ \dfrac{(1-\theta_1)^2(\theta_4-4\theta_2^2)}{(1-\theta_2)^4} \right)
</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
\theta_1=OverallAcc= \sum_{i, j=1}^{M} \dfrac{ x_{ii}}{ x_{ij}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\theta_2=ExpAcc=\sum^M_{i=1}
\left( \dfrac{x_{+ i}}{\sum_{j=1}^M x_{ij}}
\cdot \dfrac{x_{i +}}{\sum_{j=1}^M x_{ij}} \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\theta_3=\sum^M_{i=1} \left( \dfrac{x_{ii} x_{+ i}}{\sum_{j=1}^M x_{ij}}
\cdot \dfrac{x_{ii} x_{i +}}{\sum_{j=1}^M x_{ij}} \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\theta_4=\dfrac{1}{ ( \sum_{i,j=1}^M x_{ij})^3} \sum_{i,j=1}^M x_{ij}
(x_{j+}+x_{+i})^2
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Z=\dfrac{Kappa}{\sqrt{\sigma^2_{Kappa}}}
</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">ExpAcc</code>: expected accuracy of agreement if agreement
were purely random.
</p>
</li>
<li> <p><code class="reqn">OverallAcc</code>: overall accuracy.
</p>
</li>
<li> <p><code class="reqn">\theta_1, \theta_2, \theta_3, \theta_4</code>: real values.
</p>
</li>
<li> <p><code class="reqn">Z</code>: the test statistic.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$DetailKappa()</pre></div>



<h5>Returns</h5>

<p>A list of real values containing the kappa coefficient,
its standard deviation, and the value of its test statistic.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailKappa()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-DetailCondKappa"></a>



<h4>Method <code>DetailCondKappa()</code></h4>

<p>Public method that calculates the Kappa class agreement
index (conditional Kappa) from the perspective of user (i) and
producer (j) and its standard deviations. The reference
Congalton and Green (2008) is followed for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
CondKappa_{user}=\dfrac{\dfrac{x_{ii}}{x_{i+}}-x_{+j}}{1-x_{+j}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
CondKappa_{producer}=\dfrac{\dfrac{x_{ii}}{x_{+j}}-x_{i+}}{1-x_{i+}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{CondKappa_{producer}}=\dfrac{1}{N_{Total}} \cdot
\dfrac{x_{+j}-x_{ii}}{x_{+j}^3 (1-x_{i+})^3} \cdot ((x_{+j}-x_{ii})\cdot
(x_{+j}x_{i+}-x_{ii}) + x_{ii} (1-x_{+j}-x_{i+}+x_{ii})  )
</code>
</p>

<p><code class="reqn">\sigma^2_{CondKappa_{user}}</code> is done in an analogous way by exchanging
<code class="reqn">x_{i+}</code> to <code class="reqn">x_{+j}</code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$DetailCondKappa()</pre></div>



<h5>Returns</h5>

<p>A list of real values containing conditional Kappa index of the user's and the
producer's, and its corresponding standard deviation.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(0.2361,0.0694,0.1389,0.0556,0.1667,0.0417,0.1111,0,0.1806),
ncol=3,nrow=3)
p&lt;-ConfMatrix$new(A,Source="Czaplewski 1994")
p$DetailCondKappa ()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-DetailWKappa"></a>



<h4>Method <code>DetailWKappa()</code></h4>

<p>Public method that calculates the general Kappa agreement
index (weighted) and its standard deviation. The reference
Fleiss et al. (1969); Næsset (1996) and Congalton and Green (2008)
are followed for the computations.
</p>
<p>Be <code class="reqn">p_{ij}=\dfrac{x_{ij}}{\sum^M_{i,j} x_{ij}}</code> for each element <code class="reqn">i,j</code> for the matrix
and <code class="reqn">0 \leq w_{ij} \leq 1</code> for <code class="reqn">i \neq j</code> and <code class="reqn">w_{ii}=1</code> for <code class="reqn">i = j</code>.
If the elements of the weight are greater than 1, their value must be given as a percentage.
</p>
<p>Therefore, let:
</p>
<p style="text-align: center;"><code class="reqn">
p_o=\sum^M_{i,j=1} w_{ij}p_{ij}
</code>
</p>

<p>be the weighted agreement, and
</p>
<p style="text-align: center;"><code class="reqn">
p_c=\sum^M_{i,j=1} w_{ij}p_{i+}p_{+j}
</code>
</p>

<p>with <code class="reqn">p_{i+}, p_{+j}</code> analogous to <code class="reqn">x_{i+}, x_{+j}</code>.
</p>
<p>Then, the weighted Kappa is defined by
</p>
<p style="text-align: center;"><code class="reqn">
Kappa_w=\dfrac{p_o-p_c}{1-p_c}
</code>
</p>

<p>The variance may be estimated by
</p>
<p style="text-align: center;"><code class="reqn">
\sigma^2_{Kappa_w}=\dfrac{1}{N_{Total} (1-p_c)^4} \left(
 \sum^M_{i,j=1} p_{ij} [ w_{ij} (1-p_c)-(\overline{w}_{i+}+\overline{w}_{+j}) (1-p_o)]^2
 -(p_op_c-2p_c+p_o)^2 \right)
</code>
</p>

<p>where <code class="reqn">\overline{w}_{i+}=\sum^M_{j=1} w_{ij}p_{+j}</code> and
<code class="reqn">\overline{w}_{+j}=\sum^M_{i=1} w_{ij}p_{i+}</code>
</p>
<p>Its statistic is given by:
</p>
<p style="text-align: center;"><code class="reqn">
Z=\dfrac{Kappa_W}{\sqrt{\sigma^2_{Kappa_W}}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$DetailWKappa(WM)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>WM</code></dt><dd><p>Weight matrix (as matrix).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the weight matrix, kappa index obtained from
the original matrix and the weight matrix, its standard deviations
and the value of its test statistic.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A &lt;- matrix(c(1,1,0,0,0,5,55,27,23,0,3,30,68,74,4,0,8,8,39,26,0,0,2,4,26),
nrow=5)
WM &lt;- matrix(c(1,0.75,0.5,0.25,0,0.75,1,0.75,0.5,0.25,0.5,0.75,1,0.75,0.5,
0.25,0.5,0.75,1,0.75,0,0.25,0.5,0.75,1),nrow=5)
p&lt;-ConfMatrix$new(A, Source="Næsset 1996")
p$DetailWKappa(WM)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-Tau"></a>



<h4>Method <code>Tau()</code></h4>

<p>Public method that calculates the Tau index and
its variance. Its value indicates how much the classification has
improved compared to a random classification of the N elements into
M groups. The method also offers the
variance and confidence interval.
The reference Ma and Redmond (1995) is followed
for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
Tau = \dfrac{OverallAcc-PrAgCoef}{1-PrAgCoef}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
PrAgCoef=\dfrac{1}{M}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{Tau}=\dfrac{OverallAcc \cdot (1-OverallAcc)}
{N_{Total} \cdot (1-PrAgCoef)^2}
</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">OverallAcc</code>: overall accuracy.
</p>
</li>
<li> <p><code class="reqn">PrAgCoef</code>: a priori random agreement coefficient.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$Tau(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the Tau index,
its variance and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p&lt;-ConfMatrix$new(A,Source="Muñoz 2016")
p$Tau()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-DetailWTau"></a>



<h4>Method <code>DetailWTau()</code></h4>

<p>Public method that calculates the general Tau
concordance index (weighted) and its standard deviation.
</p>
<p>Be <code class="reqn">p_{ij}=\dfrac{x_{ij}}{\sum^M_{i,j} x_{ij}}</code> for each element <code class="reqn">i,j</code> for the matrix
and <code class="reqn">0 \leq w_{ij} \leq 1</code> for <code class="reqn">i \neq j</code> and <code class="reqn">w_{ii}=1</code> for <code class="reqn">i = j</code>.
If the elements of the weight are greater than 1, their value must be given as a percentage.
The following real values are defined:
</p>
<p style="text-align: center;"><code class="reqn">
\theta_1=\sum_{i}^{M} p_{ii}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\theta_2=\sum^M_{i=1} w_{ij}p_{i+}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\theta_3=\sum^M_{i=1} \left( p_{ii} (w_{ij}+p_{+j}) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\theta_4=\sum^M_{i,j=1} p_{ij} m_{ij}
</code>
</p>

<p>where <code class="reqn">m_{ij}</code> are the elements of a matrix, which are given by <code class="reqn">(w_{ij}+p_{+j})^2</code>
</p>
<p>Therefore,
</p>
<p style="text-align: center;"><code class="reqn">
Tau_W=\dfrac{\theta_1-\theta_2}{1-\theta_2}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{Tau_W}=\dfrac{1}{N_{Total}} \left( \dfrac{\theta_1 (1-\theta_1)}{(1-\theta_2)^2}
 + 2 \dfrac{1-\theta_1}{(1-\theta_2)^3} (2 \theta_1 \theta_2-\theta_3) +
 \dfrac{(1-\theta_1)^2}{(1-\theta_2)^4} (\theta_4 - 4 \theta_2^2) \right)
</code>
</p>

<p>The statistic is given by
</p>
<p style="text-align: center;"><code class="reqn">
Z=\dfrac{Tau_W}{\sqrt{\sigma^2_{Tau_W}}}
</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">\theta_1, \theta_2, \theta_3, \theta_4</code>: real values.
</p>
</li>
<li> <p><code class="reqn">Z</code>: the test statistic.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$DetailWTau(WV)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>WV</code></dt><dd><p><code style="white-space: pre;">&#8288;
Weights vector (as matrix)
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with the weighted Tau index, the weight matrix,
its standard deviation and its statistics.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WV &lt;-matrix(c(0.4, 0.1, 0.4, 0.1),ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailWTau(WV)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-Ent"></a>



<h4>Method <code>Ent()</code></h4>

<p>Public method for calculating product entropy,which
refers to the lack of orden and predictability that the product
presents. The method also offers the variance and confidence
interval. The reference Finn (1993) is
followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
Ent=\sum^M_{i,j=1} \left(\dfrac{x_{ij}}{\sum^M_{i,j=1} x_{ij}}
 \cdot \log \left(\dfrac{x_{ij}}{\dfrac{ x_{i+}
 \cdot  x_{+j}}{\sum^M_{i,j=1} x_{ij}}} \right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{Ent}=\dfrac{Ent \cdot (1-Ent)}{N_{Total}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$Ent(a = NULL, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
<dt><code>v</code></dt><dd><p><code style="white-space: pre;">&#8288;
Base of the logarithm, where&#8288;</code> <code class="reqn">v \in \mathbb{R}^{+}-\{1\}</code>. <code style="white-space: pre;">&#8288;By default v=10(units Hartleys),
v=2(units bits), v=e(units nats).&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the entropy, its variance
and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$Ent(v=2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AvNormEnt"></a>



<h4>Method <code>AvNormEnt()</code></h4>

<p>Public method that calculates normalized entropy using
the arithmetic mean of the entropies on the product and the
reference. The method also offers the variance and confidence interval. The reference
Strehl and Ghosh (2002) is followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
AvNormEnt=\dfrac{2Ent}{Ent_i(A)+Ent_i(B)}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(A)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(B)=-\sum^M_{i=1}\left( \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{AvNormEnt}=\dfrac{AvNormEnt \cdot (1-AvNormEnt)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">Ent</code>: product entropy.
</p>
</li>
<li> <p><code class="reqn">Ent_i(A)</code>: entropy with respect to the classes <em>i</em>
of the product. A is a matrix.
</p>
</li>
<li> <p><code class="reqn">Ent_i(B)</code>: entropy with respect to the class <em>i</em> on the reference. B is a matrix.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AvNormEnt(a = NULL, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
<dt><code>v</code></dt><dd><p><code style="white-space: pre;">&#8288;
Base of the logarithm, where&#8288;</code> <code class="reqn">v \in \mathbb{R}^{+}-\{1\}</code>. <code style="white-space: pre;">&#8288;By default v=10(units Hartleys),
v=2(units bits), v=e(units nats).&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the normalized
entropy (arithmetic mean of the entropies on the product
and reference), its variance and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Liu et al. 2007")
p$AvNormEnt(v=2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-GeomAvNormEnt"></a>



<h4>Method <code>GeomAvNormEnt()</code></h4>

<p>Public method that calculates the normalized entropy
using the geometric mean of the product and reference entropies.
The method also offers the variance and confidence interval.
The reference Ghosh et al. (2002) is followed
for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
GeomAvNormEnt=\dfrac{Ent}{\sqrt{Ent_i(A) \cdot Ent_i(B)}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(A)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(B)=-\sum^M_{i=1}\left( \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{GeomAvNormEnt}=
\dfrac{GeomAvNormEnt \cdot (1-GeomAvNormEnt)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">Ent</code>: product entropy.
</p>
</li>
<li> <p><code class="reqn">Ent_i(A)</code>: entropy with respect to the classes <em>i</em>
of the product. A is a matrix.
</p>
</li>
<li> <p><code class="reqn">Ent_i(B)</code>: entropy with respect to the class <em>i</em> of the reference. B is a matrix.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$GeomAvNormEnt(a = NULL, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
<dt><code>v</code></dt><dd><p><code style="white-space: pre;">&#8288;
Base of the logarithm, where&#8288;</code> <code class="reqn">v \in \mathbb{R}^{+}-\{1\}</code>. <code style="white-space: pre;">&#8288;By default v=10(units Hartleys),
v=2(units bits), v=e(units nats).&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the normalized
entropy (geometric mean of the entropies on the product
and reference), its variance and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Liu et al. 2007")
p$GeomAvNormEnt(v=2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AvMaxNormEnt"></a>



<h4>Method <code>AvMaxNormEnt()</code></h4>

<p>Public method that provides normalized entropy using
the arithmetic mean of the maximum entropies of the product and
reference. The method also offers the variance and confidence interval.
The reference Strehl (2002) is
followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
AvMaxNormEnt=\dfrac{2 Ent}{max(Ent_i(A))+max(Ent_i(B))}=
\dfrac{Ent}{\log M}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(A)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(B)=-\sum^M_{i=1}\left( \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{AvMaxNormEnt}=
\dfrac{AvMaxNormEnt \cdot (1-AvMaxNormEnt)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">Ent</code>: product entropy.
</p>
</li>
<li> <p><code class="reqn">Ent_i(A)</code>: entropy with respect to the classes <em>i</em>
of the product. A is a matrix.
</p>
</li>
<li> <p><code class="reqn">Ent_i(B)</code>: entropy with respect to the class <em>i</em> on the reference. B is a matrix.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AvMaxNormEnt(a = NULL, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
<dt><code>v</code></dt><dd><p><code style="white-space: pre;">&#8288;
Base of the logarithm, where&#8288;</code> <code class="reqn">v \in \mathbb{R}^{+}-\{1\}</code>. <code style="white-space: pre;">&#8288;By default v=10(units Hartleys),
v=2(units bits), v=e(units nats).&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the normalized entropy
(arithmetic mean of the maximum entropies of the product and of
reference), its variance, and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(8,0,0,0,0,16,0,0,0,0,8,0,0,0,0,16),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Liu et al. 2007")
p$AvMaxNormEnt(v=2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-EntUser_i"></a>



<h4>Method <code>EntUser_i()</code></h4>

<p>Public method that calculates relative change of
entropy for a given class <code class="reqn">i</code> of the product. The method also
offers the variance and confidence interval.
The reference Finn (1993) is followed for
the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
EntUser_i= \dfrac{Ent_i(A)-Ent_i(A|b_i)}{Ent_i(A)}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(A)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(A|b_i)=-\sum^M_{j=1} \left( \left(\dfrac{ x_{ij}}
{ x_{i+} }\right) \cdot \log \left(\dfrac{x_{ij}}
{ x_{i+}}\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{EntUser_i}= \dfrac{EntUser_i \cdot (1-EntUser_i)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">Ent_i(A)</code>: entropy with respect to the classes <em>i</em>
of the product. A is a matrix.
</p>
</li>
<li> <p><code class="reqn">Ent_i(A|b_i)</code>: Producer entropy knowing that the
location corresponding to reference B is in class <code class="reqn">b_i</code>.
B is a matrix.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$EntUser_i(i, a = NULL, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
<dt><code>v</code></dt><dd><p><code style="white-space: pre;">&#8288;
Base of the logarithm, where&#8288;</code> <code class="reqn">v \in \mathbb{R}^{+}-\{1\}</code>. <code style="white-space: pre;">&#8288;By default v=10(units Hartleys),
v=2(units bits), v=e(units nats).&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the relative change of entropy
for given class i, its variance, its confidence interval, producer's
entropy, and producer's entropy knowing that the
location corresponding to reference B is in class <code class="reqn">b_i</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$EntUser_i(1,v=2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-NormEntUser"></a>



<h4>Method <code>NormEntUser()</code></h4>

<p>Public method that calculates normalized entropy
of the product. The method also offers the variance and
confidence interval. The reference
Finn (1993) is followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
NormEntUser=\dfrac{Ent}{Ent_i(B)}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(B)=-\sum^M_{i=1} \left( \left(  \dfrac {x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left( \dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{NormEntUser}=\dfrac{NormEntUser \cdot (1-NormEntUser)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">Ent</code>: product entropy.
</p>
</li>
<li> <p><code class="reqn">Ent_i(B)</code>: entropy with respect to the class <em>i</em> on the reference. B is a matrix.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$NormEntUser(a = NULL, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
<dt><code>v</code></dt><dd><p><code style="white-space: pre;">&#8288;
Base of the logarithm, where&#8288;</code> <code class="reqn">v \in \mathbb{R}^{+}-\{1\}</code>. <code style="white-space: pre;">&#8288;By default v=10(units Hartleys),
v=2(units bits), v=e(units nats).&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing with normalized entropy
of the product class i, conditioned to reference data, its variance
and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$NormEntUser(v=2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-EntProd_i"></a>



<h4>Method <code>EntProd_i()</code></h4>

<p>Public method that calculates relative change of
entropy for a given a class <code class="reqn">i</code> of the reference from the producer's
perspective. The method also offers the variance and confidence interval.
The reference Stehman (1997) is followed for
the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
EntProd_i= \dfrac{Ent_i(B)-Ent_i(B|a_j)}{Ent_i(B)}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(B)=-\sum^M_{i=1} \left( \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left(\dfrac{ x_{i+}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(B|a_j)=-\sum^M_{i=1}\left( \left(\dfrac{ x_{ij}}
{ x_{+j} }\right) \cdot \log \left(\dfrac{x_{ij}}
{ x_{+j}}\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{EntProd_i}= \dfrac{EntProd_i \cdot (1-EntProd_i)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">Ent_i(B)</code>: entropy with respect to the class <em>i</em> on the reference. B is a matrix.
</p>
</li>
<li> <p><code class="reqn">Ent_i(B|a_j)</code>: Entropy of reference B knowing that the
location of product A is in the class <code class="reqn">a_j</code>.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$EntProd_i(i, a = NULL, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
<dt><code>v</code></dt><dd><p><code style="white-space: pre;">&#8288;
Base of the logarithm, where&#8288;</code> <code class="reqn">v \in \mathbb{R}^{+}-\{1\}</code>. <code style="white-space: pre;">&#8288; By default v=10(units Hartleys),
v=2(units bits), v=e(units nats).
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the relative change of entropy
for given class i, its variance, its confidence interval, entropy with
respect to reference classes, and entropy with respect to reference
classes knowing that the location corresponding to A is in class <code class="reqn">a_j</code>.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$EntProd_i(3,v=2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-NormEntProd"></a>



<h4>Method <code>NormEntProd()</code></h4>

<p>Public method that calculates normalized entropy of
the reference from the producer's perspective. The method also offers the variance and confidence
interval. The reference Finn (1993) is
followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
NormEntProd=\dfrac{Ent}{Ent_i(A)}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
Ent_i(A)=-\sum^M_{j=1}\left( \left(\dfrac{ x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \cdot \log \left( \dfrac{x_{+j}}
{\sum^M_{i,j=1} x_{ij} }\right) \right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{NormEntProd}=\dfrac{NormEntProd \cdot (1-NormEntProd)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">Ent</code>: product entropy.
</p>
</li>
<li> <p><code class="reqn">Ent_i(A)</code>: entropy with respect to the classes <em>i</em>
of the product. A is a matrix.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$NormEntProd(a = NULL, v = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
<dt><code>v</code></dt><dd><p><code style="white-space: pre;">&#8288;
Base of the logarithm, where&#8288;</code> <code class="reqn">v \in \mathbb{R}^{+}-\{1\}</code>.<code style="white-space: pre;">&#8288; By default v=10(units Hartleys),
v=2(units bits), v=e(units nats).&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the normalized entropy
of the reference class <code class="reqn">i</code> from the producer's perspective, its variance
and confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$NormEntProd(v=2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-Sucess"></a>



<h4>Method <code>Sucess()</code></h4>

<p>Public method that provides the Classification
Success Index (CSI) which considers all classes and gives an
overall estimation of classification effectiveness.
The method also offers the variance and confidence interval.
The references Koukoulas and Blackburn (2001) and
Türk (2002) are followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
Sucess=1-(1-AvUserAcc+1-AvProdAcc)=AvUserAcc+AvProdAcc-1
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{Sucess}=\dfrac{Sucess \cdot (1-Sucess)}{N_{Total}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">AvUserAcc</code>: average accuracy from user's perspective.
</p>
</li>
<li> <p><code class="reqn">AvProdAcc</code>: average accuracy from producer's perspective.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$Sucess(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the ICSI, its variance
and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),nrow=3,ncol=3)
p&lt;-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-Sucess_i"></a>



<h4>Method <code>Sucess_i()</code></h4>

<p>Public method that provides the Individual
Classification Success Index (ICSI) which considers  the classification
effectiveness for one particular class of interest.
The method also offers the variance and confidence interval.
The references Koukoulas and Blackburn (2001) and Türk (2002)
are followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
Sucess_i=1-(1-UserAcc_i+1-ProdAcc_i)=UserAcc_i+ProdAcc_i-1
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{Sucess_i}=\dfrac{Sucess_i \cdot (1-Sucess_i)}{N_{ij}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">UserAcc_i</code>: user accuracy index for class i.
</p>
</li>
<li> <p><code class="reqn">ProdAcc_i</code>: producer accuracy index for class i.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$Sucess_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the ICSI,
its variance and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),nrow=3,ncol=3)
p&lt;-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess_i(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AvHellAcc"></a>



<h4>Method <code>AvHellAcc()</code></h4>

<p>Public method that provides the average value of the
Hellden mean precision index. Denoted by the probability that a
randomly chosen position or element assigned to a specific class on
the product has a correspondence of the same class in the homologous
position or element in the reference, and that a randomly chosen point
or element assigned to a specific class on the reference has a
correspondence of the same class in the homologous position or
element in the product. The method also offers the
variance and confidence interval.
The reference Liu et al. (2007) is followed for
the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
AvHellAcc=\dfrac{1}{M} 2 \sum^M_{i=1} \dfrac{ x_{ii}}
{ x_{+i} + x_{i+}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{AvHellAcc}=\dfrac{AvHellAcc \cdot (1-AvHellAcc)}{N_{Total}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AvHellAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the average of
Hellden's mean accuracy index, its variance and
confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvHellAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AvHellAcc_i"></a>



<h4>Method <code>AvHellAcc_i()</code></h4>

<p>Public method that provides the Hellden’ average
accuracy for the specified class. The method also offers the variance and
confidence interval. The references
Hellden (1980) and Rosenfield and Fitzpatrick-Lins (1986) are
followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
AvHellAcc_i=\dfrac{2}{\dfrac{1}{UserAcc_i}+\dfrac{1}{ProdAcc_i}}=
\dfrac{2 UserAcc_i \cdot ProdAcc_i}{UserAcc_i + ProdAcc_i}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{AvHellAcc_i}=\dfrac{AvHellAcc_i \cdot (1-AvHellAcc_i)}{N_{ij}}
</code>
</p>

<p>where:
</p>

<ol>
<li> <p><code class="reqn">UserAcc_i</code>: user accuracy index for class i.
</p>
</li>
<li> <p><code class="reqn">ProdAcc_i</code>: producer accuracy index for class i.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AvHellAcc_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the Hellden’s mean
accuracy, its variance and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A &lt;- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick 1986")
p$AvHellAcc_i(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-AvShortAcc"></a>



<h4>Method <code>AvShortAcc()</code></h4>

<p>Public method that provides the average of the Short's
mapping accuracy index. It is determined as the quotient between the
well-classified elements (value on the diagonal) and the subtraction
of that same value on the errors of omission and commission (rest of
values in the column and row) corresponding to each class. The method
also offers the variance and confidence interval. The
reference Liu et al. (2007) is followed for
the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
AvShortAcc=\dfrac{1}{M} \sum^M_{i=1} \dfrac{x_{ii}}
{ \overline{x}_{+ i}+ \overline{x}_{i +}-x_{ii}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{AvShortAcc}=\dfrac{AvShortAcc \cdot (1-AvShortAcc)}{N_{Total}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$AvShortAcc(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the average of
Short's mapping accuracy index, its variance and
confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvShortAcc()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-ShortAcc_i"></a>



<h4>Method <code>ShortAcc_i()</code></h4>

<p>Public method that provides the Short's mapping
accuracy for each class. The method also offers the
variance and confidence interval. The references
Rosenfield and Fitzpatrick-Lins (1986) and Short (1982)
are followed for the calculations.
</p>
<p style="text-align: center;"><code class="reqn">
ShortAcc_i=\dfrac{x_{ii}}{ \overline{x}_{+ i}+
 \overline{x}_{i +}-x_{ii}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{ShortAcc_i}=\dfrac{ShortAcc_i \cdot (1-ShortAcc_i)}{N_{ij}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$ShortAcc_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of real values containing the Short's
mapping accuracy, its variance and its confidence interval.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A &lt;- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick-Lins 1986")
p$ShortAcc_i(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-GroundTruth"></a>



<h4>Method <code>GroundTruth()</code></h4>

<p>Public method that calculates the Ground Truth index,
its variance and confidence interval.The reference Türk (1979)
is followed for the computations.
</p>
<p>To calculate <code class="reqn">R</code> we begin the following iterative process:
</p>
<p>Be <code class="reqn">U_j^{(0)}=f_j^0</code> with <code class="reqn">f_j^0=\dfrac{\overline{x}_{i+}}{\sum_{i=1}^M \overline{x}_{i+}}</code>
and <code class="reqn">f_i^0=\dfrac{\overline{x}_{+i}}{\sum_{i=1}^M \overline{x}_{+i}}</code>
</p>
<p>Where <code class="reqn">2m</code> with <code class="reqn">m=1,2,\cdots</code>
</p>
<p style="text-align: center;"><code class="reqn">
 V_{i,2m-1}=\dfrac{f_i^0}{U_{+,2m-2}-U_{i,2m-2}}
 </code>
</p>

<p>where <code class="reqn">U_{+,2m}=\sum_{i=1}^M U_{j,2m} </code>
and when <code class="reqn">2m+1</code> with <code class="reqn">m=1,2,\cdots</code>
</p>
<p style="text-align: center;"><code class="reqn">
 U_{j,2m}=\dfrac{f_j^0}{V_{+,2m-1}-V_{i,2m-1}}
 </code>
</p>

<p>where <code class="reqn">V_{+,2m-1}=\sum_{i=1}^M V_{i,2m-1} </code>
</p>
<p>The iterative steps continue for <code class="reqn">m=1, 2,\cdots</code> until
the accuracy stabilizes thus taking the V term.
Where
</p>
<p style="text-align: center;"><code class="reqn">
R=\dfrac{V}{\sum_{i=1}^{M} V_i}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
ProdAcc=\dfrac{x_{ii}}{\sum_{j=1}^M x_{+j}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
GroundTruth = \dfrac{ProdAcc-R}{1-R}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{GroundTruth}=\dfrac{GroundTruth \cdot (1-GroundTruth)}
{N_{Total}}
</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">R</code>: casual lucky guess.
</p>
</li>
<li> <p><code class="reqn">ProdAcc</code>: producer accuracy.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$GroundTruth(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with Ground Truth indexes, their variance, confidence
intervals and the matrix with the expected frequencies.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-GroundTruth_i"></a>



<h4>Method <code>GroundTruth_i()</code></h4>

<p>Public method that calculates the Ground Truth index
for class i, its variance and confidence interval.The reference
Türk (1979) is followed for the computations.
</p>
<p>To calculate R_i we begin the following iterative process:
Be <code class="reqn">U_j^{(0)}=f_j^0</code> with <code class="reqn">f_j^0=\dfrac{\overline{x}_{i+}}{\sum_{i=1}^M \overline{x}_{i+}}</code>
and <code class="reqn">f_i^0=\dfrac{\overline{x}_{+i}}{\sum_{i=1}^M \overline{x}_{+i}}</code>
</p>
<p>Where <code class="reqn">2m</code> with <code class="reqn">m=1,2,\cdots</code>
</p>
<p style="text-align: center;"><code class="reqn">
 V_{i,2m-1}=\dfrac{f_i^0}{U_{+,2m-2}-U_{i,2m-2}}
 </code>
</p>

<p>where <code class="reqn">U_{+,2m}=\sum_{i=1}^M U_{j,2m} </code>
and when <code class="reqn">2m+1</code> with <code class="reqn">m=1,2,\cdots</code>
</p>
<p style="text-align: center;"><code class="reqn">
 U_{j,2m}=\dfrac{f_j^0}{V_{+,2m-1}-V_{i,2m-1}}
 </code>
</p>

<p>where <code class="reqn">V_{+,2m-1}=\sum_{i=1}^M V_{i,2m-1} </code>
</p>
<p>The iterative steps continue for <code class="reqn">m=1, 2,\cdots</code> until
the accuracy stabilizes thus taking the V term.
Where
</p>
<p style="text-align: center;"><code class="reqn">
R_i=\dfrac{V_i}{\sum_{i=1}^{k} V_i}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
ProdAcc_i=\dfrac{x_{ii}}{\sum_{j=1}^M x_{+j}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
GroundTruth_i = \dfrac{ProdAcc_i-R_i}{1-R_i}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma^2_{GroundTruth_i}=\dfrac{GroundTruth_i \cdot (1-GroundTruth_i)}
{N_{Total}}
</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">R_i</code>: casual lucky guess for class <code class="reqn">i</code>. Is a real value.
</p>
</li>
<li> <p><code class="reqn">ProdAcc_i</code>: producer accuracy for class <code class="reqn">i</code>.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$GroundTruth_i(i, a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p><code style="white-space: pre;">&#8288;
Class to evaluate, where&#8288;</code> <code class="reqn">i \in \mathbb{Z}-\{0\}</code>.</p>
</dd>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
Significance level. By default 0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with Ground Truth index for class <code class="reqn">i</code>, its variance, confidence
interval and the matrix with the expected frequencies for all classes.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth_i(3)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-HellingerDist"></a>



<h4>Method <code>HellingerDist()</code></h4>

<p>Public method that provides that Hellinger distance
between two confusion matrices.
The reference García-Balboa et al. (2018) is followed
for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
HellingerDist = \dfrac{4n_{A}m_{B}}{n_{A}+m_{B}} \sum^{M}_{i=1} (\sqrt{p_i}-\sqrt{q_i})^2
</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">n_{A}</code>: sum of elements of the matrix A.
</p>
</li>
<li> <p><code class="reqn">m_{B}</code>: sum of elements of the matrix B.
</p>
</li>
<li> <p><code class="reqn">p_i</code>: probability that element <code class="reqn">i \in [1, \cdots, MxM]</code> is well classified in matrix A.
</p>
</li>
<li> <p><code class="reqn">q_i</code>: probability that element <code class="reqn">i \in [1, \cdots, MxM]</code> is well classified in matrix B.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$HellingerDist(f, p = NULL, q = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>f</code></dt><dd><p><code style="white-space: pre;">&#8288;
Element of the ConfMatrix.
&#8288;</code></p>
</dd>
<dt><code>p</code></dt><dd><p><code style="white-space: pre;">&#8288;
probability vector of matrix A. By default, relative frequencies observed
for each cell is taken.
&#8288;</code></p>
</dd>
<dt><code>q</code></dt><dd><p><code style="white-space: pre;">&#8288;
probability vector of matrix B. By default, relative frequencies observed
for each cell is taken.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A real value for the Hellinger distance.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
r&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
B&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(B,Source="Congalton and Green 2008")
r$HellingerDist(f)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-QES"></a>



<h4>Method <code>QES()</code></h4>

<p>Public method that calculates the values of quantity
difference, exchange and shift. Quantity difference is the amount of
difference between the product and the reference and is due to the
less than maximum match in the proportions of the categories. Exchange
represents transitions from class <code class="reqn">i</code> to <code class="reqn">j</code> and a transition from class <code class="reqn">j</code>
to class <code class="reqn">i</code> in an identical number of cases. Shift refers to the
difference remaining after subtracting quantity difference and exchange
from the overall difference. The reference
Pontius Jr and Santacruz (2014) is followed for the computations.
</p>
<p>Where
</p>
<p style="text-align: center;"><code class="reqn">
Q=\dfrac{\sum^M_{j=1} q_{j}}{2}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
E=\dfrac{\sum^M_{j=1} e_{j}}{2}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
S=\dfrac{\sum^M_{j=1} s_{j}}{2}
</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">
d_{j}=\dfrac{ \left( \sum^M_{i=1} (x_{ij} + x_{ji})  \right) -2 x_{jj} }{\sum^M_{i=1} \sum^M_{j=1} x_{ij}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
q_{j}=\dfrac{\left|  \sum^M_{i=1} (x_{ij} + x_{ji})  \right| }{\sum^J_{i=1} \sum^J_{j=1} x_{ij}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
e_{j}=\dfrac{2 \left( \left( \sum^M_{i=1} min(x_{ij}, x_{ji})  \right) - x_{jj} \right)}{\sum^M_{i=1} \sum^M_{j=1} x_{ij}}
</code>
</p>

<p style="text-align: center;"><code class="reqn">
s_{j}=d_{j}-q_{j}-e_{j}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$QES()</pre></div>



<h5>Returns</h5>

<p>A list of integer values with quantity, exchange, and shift.
In addition to the differences for classes of the components of
quantity, exchange and turn.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(3,2,1,1,3,3,2,0,1),nrow=3,ncol=3)
p&lt;-ConfMatrix$new(A,Source="Pontius Jr. and Santacruz 2023")
p$QES()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-MTypify"></a>



<h4>Method <code>MTypify()</code></h4>

<p>Public method that typifies the confusion matrix.
The total sum of the original matrix is used for typing. In a
typed matrix the sum of all values is unity. The resulting
values can be presented as real values (parameter RaR=1), or as
a percentage (parameter RaR !=1).
</p>
<p style="text-align: center;"><code class="reqn">
MTypify=\dfrac{x_{ij}}{\sum^M_{i,j=1} x_{ij}}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$MTypify(RaR = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>RaR</code></dt><dd><p>&quot;1&quot; indicates result as real, other values mean percentage
as integer. By default RaR=1.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list with two arrays, the first is the original array,
the second the typed one.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MTypify(RaR=5)
</pre>
</div>


<hr>
<a id="method-ConfMatrix-MBootStrap"></a>



<h4>Method <code>MBootStrap()</code></h4>

<p>Public method that provides B resamples, using a
multinomial distribution, of the confusion matrix of a ConfMatrix
object. As a result, a set of bootstrapped cases is offered. The
reference Fienberg (1970) is
followed for the computations.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$MBootStrap(B, pr = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>B</code></dt><dd><p>Number of resamples.</p>
</dd>
<dt><code>pr</code></dt><dd><p>Vector with resampling probabilities. By default, the
success probability of each cell will be taken.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of B + 1 arrays formed by the original confusion matrix
and all the simulated cases.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MBootStrap(2)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-MNormalize"></a>



<h4>Method <code>MNormalize()</code></h4>

<p>Public method that carries out an iterative process in
order to equals one the sum of values by rows and columns.
The references Fienberg (1970) and
Muñoz (2016) are followed for the computations.
</p>
<p>The following iterative process is used:
</p>
<p>Let <code class="reqn">x_{ij}</code> be the elements of the instance. It defines:
</p>
<p style="text-align: center;"><code class="reqn">x'_{ij}=\dfrac{x_{ij}}{x_{i+}}</code>
</p>

<p style="text-align: center;"><code class="reqn">x''_{ij}=\dfrac{x'_{ij}}{x'_{+j}}</code>
</p>

<p>Taking <code class="reqn">x_{ij}=x''_{ij}</code> for the next iteration.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$MNormalize(iter = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iter</code></dt><dd><p><code style="white-space: pre;">&#8288;
Number of iteration. By default iter=1000.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list formed by the original confusion matrix and the
normalized matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p&lt;-ConfMatrix$new(A,Source="Muñoz 2016")
p$MNormalize()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-MPseudoZeroes"></a>



<h4>Method <code>MPseudoZeroes()</code></h4>

<p>Public method that small values are calculated for empty
cells of the matrix. All non-empty cells of the matrix change their
values. This function will not be applied if all the elements of the
matrix are different from 0.
The reference Muñoz (2016) is followed
for the computations.
</p>
<p>Let <code class="reqn">x_{ij}</code> be the elements of the instance.
</p>
<p>The following values are defined:
</p>
<p style="text-align: center;"><code class="reqn">e_{ij}=\dfrac{x_{i+}x_{+j}}{\sum^M_{i,j=1} x_{ij}}</code>
</p>

<p style="text-align: center;"><code class="reqn">v=\dfrac{\left( \sum^M_{i,j=1} x_{ij} \right)^2 - \sum^M_{i,j=1} x_{ij}^2}{\sum^M_{i,j=1} (e_{ij}-x_{ij})^2}</code>
</p>

<p style="text-align: center;"><code class="reqn">p_{ij}=\dfrac{e_{ij} \cdot v }{\sum^M_{i,j=1} x_{ij}}</code>
</p>

<p>Finally, the elements of the pseudozero matrix <code class="reqn">Z</code> will be given by:
</p>
<p style="text-align: center;"><code class="reqn">z_{ij}=\left(\dfrac{\sum^M_{i,j=1} x_{ij}}{(\sum^M_{i,j=1} x_{ij})+v} \right)
(p_{ij}+x_{ij})</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$MPseudoZeroes()</pre></div>



<h5>Returns</h5>

<p>A list formed by the original confusion matrix and the
Pseudozeroes matrix.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p&lt;-ConfMatrix$new(A,Source="Muñoz 2016")
p$MPseudoZeroes()

</pre>
</div>


<hr>
<a id="method-ConfMatrix-OverallAcc.test"></a>



<h4>Method <code>OverallAcc.test()</code></h4>

<p>Public method that tests whether two independent
confusion matrices (instances of the ConfMatrix class), are
significantly different using their overall accuracy indexes.
The reference Congalton and Green (2008) and Ma and Redmond (1995) are followed
for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
Z = \dfrac{|O_A-O_B|}{\sqrt{(\sigma^2_{O_A}+\sigma^2_{O_B})}}
</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">O_A</code>: overall index of matrix A.
</p>
</li>
<li> <p><code class="reqn">O_B</code>: overall index of matrix B.
</p>
</li>
<li> <p><code class="reqn">\sigma^2_{O_A}</code>: variance of <code class="reqn">O_A</code>.
</p>
</li>
<li> <p><code class="reqn">\sigma^2_{O_B}</code>: variance of <code class="reqn">O_B</code>.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$OverallAcc.test(f)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>f</code></dt><dd><p><code style="white-space: pre;">&#8288;
Instance of ConfMatrix class.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of class &quot;htest&quot; containing the results of the hypothesis test.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
B&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$OverallAcc.test(f)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-Kappa.test"></a>



<h4>Method <code>Kappa.test()</code></h4>

<p>Public method that tests whether two independent
confusion matrices (instances of the ConfMatrix class), are
significantly different when using the kappa indexes.
The reference Congalton and Green (2008) is followed
for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
Z = \dfrac{|k_A-k_B|}{\sqrt{(\sigma^2_{k_A}+\sigma^2_{k_B})}}
</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">k_A</code>: kappa index of matrix A.
</p>
</li>
<li> <p><code class="reqn">k_B</code>: kappa index of matrix B.
</p>
</li>
<li> <p><code class="reqn">\sigma^2_{k_A}</code>: variance of <code class="reqn">k_A</code>.
</p>
</li>
<li> <p><code class="reqn">\sigma^2_{k_B}</code>: variance of <code class="reqn">k_B</code>.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$Kappa.test(f)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>f</code></dt><dd><p><code style="white-space: pre;">&#8288;
Element of the ConfMatrix class.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of class &quot;htest&quot; containing the results of the hypothesis test.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
B&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Kappa.test(f)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-Tau.test"></a>



<h4>Method <code>Tau.test()</code></h4>

<p>Public method that tests whether two independent
confusion matrices (instances of the ConfMatrix class), are
significantly different using their Tau indexes.
The reference Congalton and Green (2008) and
Ma and Redmond (1995) are followed for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
Z = \dfrac{|\tau_A-\tau_B|}{\sqrt{(\sigma^2_{\tau_A}+\sigma^2_{\tau_B})}}
</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">\tau_A</code>: Tau index of matrix A.
</p>
</li>
<li> <p><code class="reqn">\tau_B</code>: Tau index of matrix B.
</p>
</li>
<li> <p><code class="reqn">\sigma^2_{\tau_A}</code>: variance of <code class="reqn">\tau_A</code>.
</p>
</li>
<li> <p><code class="reqn">\sigma^2_{\tau_B}</code>: variance of <code class="reqn">\tau_B</code>.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$Tau.test(f)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>f</code></dt><dd><p><code style="white-space: pre;">&#8288;
Element of the ConfMatrix class.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of class &quot;htest&quot; containing the results of the hypothesis test.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
B&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Tau.test(f)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-TSCM.test"></a>



<h4>Method <code>TSCM.test()</code></h4>

<p>Public method that performs a homogeneity test
based on the Hellinger distance between two confusion matrices
(instances of the ConfMatrix class).
The test considers the individual cell values in the matrices.
Bootstrap is applied to the matrices to obtain a consistent estimator.
The reference García-Balboa et al. (2018) are followed for
the computations.
The calculation consists of obtaining a statistic, which we will call
<code class="reqn">T_{n,m}</code>, between both matrices from ConfMatrix$HellingerDist.
Bootstrap is then applied to the confusion matrices to obtain
simulations of both matrices. ConfMatrix$HellingerDist is applied
again to these simulations and we will obtain the statistics
<code class="reqn">T^*_{n,m}</code>. The p value is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
\hat{p}=\dfrac{Card(T^*_{n,m} \geq T^*_{n,m})}{B}
</code>
</p>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$TSCM.test(f, B = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>f</code></dt><dd><p><code style="white-space: pre;">&#8288;
Element of the ConfMatrix class.
&#8288;</code></p>
</dd>
<dt><code>B</code></dt><dd><p><code style="white-space: pre;">&#8288;
Number of bootstraps that you want to generate. By default B=1000.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of class &quot;htest&quot; containing the results of the hypothesis test.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
C&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(C,Source="Congalton and Green 2008")
p$TSCM.test(f)

</pre>
</div>


<hr>
<a id="method-ConfMatrix-QIndep.test"></a>



<h4>Method <code>QIndep.test()</code></h4>

<p>Public method that performs the
quasi-independence test for the elements of a confusion matrix.
The reference
Türk (1979) and Goodman (1968)
are followed for the computations.
</p>
<p style="text-align: center;"><code class="reqn">
G^2 = 2 \cdot \sum \log \dfrac{x_{ij}}{E_{ij}}
</code>
</p>

<p>Following the procedure for calculating the elements
of the function ConfMatrix$GroundTruth, we will have to <code class="reqn">E_{ij}</code>
is obtained from:
</p>
<p style="text-align: center;"><code class="reqn">f_{ij}=U_j \cdot V_i</code>
</p>

<p style="text-align: center;"><code class="reqn">f_{ij}^0=f_{ij}-f_{ii}</code>
</p>

<p style="text-align: center;"><code class="reqn">M^0=x_{ij}-x_{ii}</code>
</p>

<p>where the elements of <code class="reqn">M^0</code> are <code class="reqn">m_{ij}^0</code>
</p>
<p style="text-align: center;"><code class="reqn">E_{ij}=f_{ij}^0 \sum^M_{i,j=1} m_{ij}^{0}</code>
</p>

<p>Where:
</p>

<ol>
<li> <p><code class="reqn">x_{ij}</code>: matrix element. Observed frequency.
</p>
</li>
<li> <p><code class="reqn">E_{ij}</code>: expected frequency.
</p>
</li></ol>



<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$QIndep.test()</pre></div>



<h5>Returns</h5>

<p>A list of class &quot;htest&quot; containing the results of the hypothesis test.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>A&lt;-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source= "Türk 1979")
p$QIndep.test()

</pre>
</div>




<h3>Note</h3>

<p>Error Messages: List of possible errors:
</p>

<ul>
<li> <p><code>Error type 1</code>: Non-square matrix.
</p>
</li>
<li> <p><code>Error type 2</code>: Single element matrix.
</p>
</li>
<li> <p><code>Error type 3</code>: Negative values.
</p>
</li>
<li> <p><code>Error type 4</code>: Sum of elements 0.
</p>
</li>
<li> <p><code>Error type 5</code>: Sum of rows 0.
</p>
</li>
<li> <p><code>Error type 6</code>: Sum of columns 0.
</p>
</li>
<li> <p><code>Error type 7</code>: It is not a matrix.
</p>
</li></ul>



<h3>References</h3>

<p>Alba-Fernández MV, Ariza-López FJ, Rodríguez-Avi J, García-Balboa JL (2020).
&ldquo;Statistical methods for thematic-accuracy quality control based on an accurate reference sample.&rdquo;
<em>Remote Sensing</em>, <b>12</b>(5), 816.
</p>
<p>Ariza FJ, Pinilla C, Garcia JL (2011).
&ldquo;Comparación de matrices de confusión celda a celda mediante bootstraping.&rdquo;
</p>
<p>Ariza-Lopez F, Rodríguez-Avi J, García-Balboa J, Mesas-Carrascosa F (2013).
<em>FUNDAMENTOS DE EVALUACIÓN DE LA CALIDAD DE LA INFORMACIÓN GEOGRÁFICA</em>.
Universidad de Ja\'en. Servicio de publicaciones.
ISBN 978-84-8439-813-4.
</p>
<p>Cohen J (1960).
&ldquo;A coefficient of agreement for nominal scales.&rdquo;
<em>Educational and psychological measurement</em>, <b>20</b>(1), 37&ndash;46.
</p>
<p>Congalton RG, Green K (2008).
<em>Assessing the accuracy of remotely sensed data: principles and practices</em>.
CRC press.
</p>
<p>Czaplewski RL (1994).
<em>Variance approximations for assessments of classification accuracy</em>, volume 316.
US Department of Agriculture, Forest Service, Rocky Mountain Forest and      Range Experiment Station.
</p>
<p>Fienberg SE (1970).
&ldquo;An iterative procedure for estimation in contingency tables.&rdquo;
<em>The Annals of Mathematical Statistics</em>, <b>41</b>(3), 907&ndash;917.
</p>
<p>Finn JT (1993).
&ldquo;Use of the average mutual information index in evaluating classification error and consistency.&rdquo;
<em>International Journal of Geographical Information Science</em>, <b>7</b>(4), 349&ndash;366.
</p>
<p>Fleiss JL, Cohen J, Everitt BS (1969).
&ldquo;Large sample standard errors of kappa and weighted kappa.&rdquo;
<em>Psychological bulletin</em>, <b>72</b>(5), 323.
</p>
<p>Foody GM (1992).
&ldquo;On the compensation for chance agreement in image classification accuracy assessment.&rdquo;
<em>Photogrammetric engineering and remote sensing</em>, <b>58</b>(10), 1459&ndash;1460.
</p>
<p>García-Balboa JL, Alba-Fernández MV, Ariza-López FJ, Rodríguez-Avi J (2018).
&ldquo;Analysis of thematic similarity using confusion matrices.&rdquo;
<em>ISPRS international journal of geo-information</em>, <b>7</b>(6), 233.
</p>
<p>Ghosh J, Strehl A, Merugu S (2002).
&ldquo;A consensus framework for integrating distributed clusterings under limited knowledge sharing.&rdquo;
In <em>Proc. NSF Workshop on Next Generation Data Mining</em>, 99&ndash;108.
</p>
<p>Goodman LA (1968).
&ldquo;The analysis of cross-classified data: Independence, quasi-independence, and interactions in contingency tables with or without missing entries: Ra Fisher memorial lecture.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>63</b>(324), 1091&ndash;1131.
</p>
<p>Hellden U (1980).
&ldquo;A test of landsat-2 imagery and digital data for thematic mapping illustrated by an environmental study in northern Kenya, Lund University.&rdquo;
<em>Natural Geography Institute Report No. 47</em>.
</p>
<p>Koukoulas S, Blackburn GA (2001).
&ldquo;Introducing new indices for accuracy evaluation of classified images representing semi-natural woodland environments.&rdquo;
<em>Photogrammetric Engineering and Remote Sensing</em>, <b>67</b>(4), 499&ndash;510.
</p>
<p>Labatut V, Cherifi H (2011).
&ldquo;Evaluation of performance measures for classifiers comparison.&rdquo;
<em>arXiv preprint arXiv:1112.4133</em>.
</p>
<p>Liu C, Frazier P, Kumar L (2007).
&ldquo;Comparative assessment of the measures of thematic classification accuracy.&rdquo;
<em>Remote sensing of environment</em>, <b>107</b>(4), 606&ndash;616.
</p>
<p>Ma Z, Redmond RL (1995).
&ldquo;Tau coefficients for accuracy assessment of classification of remote sensing data.&rdquo;
<em>Photogrammetric Engineering and Remote Sensing</em>, <b>61</b>, 435-439.
</p>
<p>Muñoz JMS (2016).
&ldquo;Análisis de Calidad Cartográfica mediante el estudio de la Matriz de Confusión.&rdquo;
<em>Pensamiento matemático</em>, <b>6</b>(2), 9&ndash;26.
</p>
<p>Næsset E (1996).
&ldquo;Use of the weighted Kappa coefficient in classification error assessment of thematic maps.&rdquo;
<em>International Journal of Geographical Information Systems</em>, <b>10</b>(5), 591&ndash;603.
</p>
<p>Pontius Jr RG, Santacruz A (2014).
&ldquo;Quantity, exchange, and shift components of difference in a square contingency table.&rdquo;
<em>International Journal of Remote Sensing</em>, <b>35</b>(21), 7543&ndash;7554.
</p>
<p>Pontius Jr. RG, Santacruz A (2023).
<em>diffeR: Metrics of Difference for Comparing Pairs of Maps or Pairs of Variables</em>.
R package version 0.0-8, <a href="https://CRAN.R-project.org/package=diffeR">https://CRAN.R-project.org/package=diffeR</a>.
</p>
<p>Rosenfield GH, Fitzpatrick-Lins K (1986).
&ldquo;A coefficient of agreement as a measure of thematic classification accuracy.&rdquo;
<em>Photogrammetric engineering and remote sensing</em>, <b>52</b>(2), 223&ndash;227.
</p>
<p>Short NM (1982).
<em>The Landsat tutorial workbook: Basics of satellite remote sensing</em>, volume 1078.
National Aeronautics and Space Administration, Scientific and Technical Information Branch.
</p>
<p>Strehl A (2002).
<em>Relationship-based clustering and cluster ensembles for high-dimensional data mining</em>.
The University of Texas at Austin.
</p>
<p>Strehl A, Ghosh J (2002).
&ldquo;Cluster ensembles&mdash;a knowledge reuse framework for combining multiple partitions.&rdquo;
<em>Journal of machine learning research</em>, <b>3</b>(Dec), 583&ndash;617.
</p>
<p>Tung F, LeDrew E (1988).
&ldquo;The determination of optimal threshold levels for change detection using various accuracy indexes.&rdquo;
<em>Photogrammetric Engineering and Remote Sensing</em>, <b>54</b>(10), 1449&ndash;1454.
</p>
<p>Türk G (1979).
&ldquo;Gt index: A measure of the success of prediction.&rdquo;
<em>Remote Sensing of Environment</em>, <b>8</b>(1), 65&ndash;75.
</p>
<p>Türk G (2002).
&ldquo;Map evaluation and chance correction.&rdquo;
<em>Photogrammetric Engineering and Remote Sensing</em>, <b>68</b>, 123&ndash;125;133.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `ConfMatrix$new`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
cm&lt;-ConfMatrix$new (A,ID="5",Date="27-10-2023",Source="Congalton and Green,
2008")


## ------------------------------------------------
## Method `ConfMatrix$plot.index`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.index()


## ------------------------------------------------
## Method `ConfMatrix$plot.UserProdAcc`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$plot.UserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$print`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,ClassNames=c("Deciduous","conifer","agriculture",
"shrub"),Source="Congalton and Green 2008")
p$print()


## ------------------------------------------------
## Method `ConfMatrix$AllParameters`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AllParameters()


## ------------------------------------------------
## Method `ConfMatrix$UserAcc`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc()


## ------------------------------------------------
## Method `ConfMatrix$UserAcc_i`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90), nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$AvUserAcc`
## ------------------------------------------------

A&lt;-matrix(c(352,43,89,203),nrow=2,ncol=2)
p&lt;-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvUserAcc()


## ------------------------------------------------
## Method `ConfMatrix$CombUserAcc`
## ------------------------------------------------

A&lt;-matrix(c(352,43,89,203),nrow=2,ncol=2)
p&lt;-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombUserAcc()


## ------------------------------------------------
## Method `ConfMatrix$ProdAcc`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$ProdAcc_i`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$ProdAcc_i(1)


## ------------------------------------------------
## Method `ConfMatrix$AvProdAcc`
## ------------------------------------------------

A&lt;-matrix(c(352,43,89,203),nrow=2,ncol=2)
p&lt;-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$AvProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$CombProdAcc`
## ------------------------------------------------

A&lt;-matrix(c(352,43,89,203),nrow=2,ncol=2)
p&lt;-ConfMatrix$new(A,Source="Tung and LeDrew 1988")
p$CombProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$UserProdAcc`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$UserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$CombUserProdAcc`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$CombUserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvUserProdAcc`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvUserProdAcc_i`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvUserProdAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$UserProdAcc_W`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
WM&lt;- t(matrix(c(1,0,0.67,1,0,1,0,0,1,0,1,1,0.91,0,0.61,1),nrow=4,ncol=4))
p$UserProdAcc_W(WM)


## ------------------------------------------------
## Method `ConfMatrix$OverallAcc`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A)
p$OverallAcc()


## ------------------------------------------------
## Method `ConfMatrix$Kappa`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$Kappa()


## ------------------------------------------------
## Method `ConfMatrix$ModKappa`
## ------------------------------------------------

A &lt;- matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),nrow=4,ncol=4)
p &lt;- ConfMatrix$new(A,Source="Foody 1992")
p$ModKappa()


## ------------------------------------------------
## Method `ConfMatrix$UserKappa_i`
## ------------------------------------------------

A&lt;-matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35, 29,13,3,5,7,28,48,1,0,2,3,17),
nrow=5,ncol=5)
p&lt;-ConfMatrix$new(A,Source="Næsset 1996")
p$UserKappa_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ModKappaUser_i`
## ------------------------------------------------

A&lt;-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Liu et al. 2007")
p$ModKappaUser_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ProdKappa_i`
## ------------------------------------------------

A &lt;- matrix(c(73,13,5,1,0,21,32,13,3,0,16,39,35,29,13,3,5,7,28,48,1,0,2,3,17),
nrow=5,ncol=5)
p&lt;-ConfMatrix$new(A,Source="Næsset 1996")
p$ProdKappa_i(2)


## ------------------------------------------------
## Method `ConfMatrix$ModKappaProd_i`
## ------------------------------------------------

A&lt;-matrix(c(317,61,2,35,23,120,4,29,0,0,60,0,0,0,0,8),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Foody 1992")
p$ModKappaProd_i(2)


## ------------------------------------------------
## Method `ConfMatrix$DetailKappa`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailKappa()


## ------------------------------------------------
## Method `ConfMatrix$DetailCondKappa`
## ------------------------------------------------

A&lt;-matrix(c(0.2361,0.0694,0.1389,0.0556,0.1667,0.0417,0.1111,0,0.1806),
ncol=3,nrow=3)
p&lt;-ConfMatrix$new(A,Source="Czaplewski 1994")
p$DetailCondKappa ()


## ------------------------------------------------
## Method `ConfMatrix$DetailWKappa`
## ------------------------------------------------

A &lt;- matrix(c(1,1,0,0,0,5,55,27,23,0,3,30,68,74,4,0,8,8,39,26,0,0,2,4,26),
nrow=5)
WM &lt;- matrix(c(1,0.75,0.5,0.25,0,0.75,1,0.75,0.5,0.25,0.5,0.75,1,0.75,0.5,
0.25,0.5,0.75,1,0.75,0,0.25,0.5,0.75,1),nrow=5)
p&lt;-ConfMatrix$new(A, Source="Næsset 1996")
p$DetailWKappa(WM)


## ------------------------------------------------
## Method `ConfMatrix$Tau`
## ------------------------------------------------

A&lt;-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p&lt;-ConfMatrix$new(A,Source="Muñoz 2016")
p$Tau()


## ------------------------------------------------
## Method `ConfMatrix$DetailWTau`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
WV &lt;-matrix(c(0.4, 0.1, 0.4, 0.1),ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$DetailWTau(WV)


## ------------------------------------------------
## Method `ConfMatrix$Ent`
## ------------------------------------------------

A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$Ent(v=2)


## ------------------------------------------------
## Method `ConfMatrix$AvNormEnt`
## ------------------------------------------------

A&lt;-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Liu et al. 2007")
p$AvNormEnt(v=2)


## ------------------------------------------------
## Method `ConfMatrix$GeomAvNormEnt`
## ------------------------------------------------

A&lt;-matrix(c(0,12,0,0,12,0,0,0,0,0,0,12,0,0,12,0),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Liu et al. 2007")
p$GeomAvNormEnt(v=2)


## ------------------------------------------------
## Method `ConfMatrix$AvMaxNormEnt`
## ------------------------------------------------

A&lt;-matrix(c(8,0,0,0,0,16,0,0,0,0,8,0,0,0,0,16),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Liu et al. 2007")
p$AvMaxNormEnt(v=2)


## ------------------------------------------------
## Method `ConfMatrix$EntUser_i`
## ------------------------------------------------

A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$EntUser_i(1,v=2)


## ------------------------------------------------
## Method `ConfMatrix$NormEntUser`
## ------------------------------------------------

A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$NormEntUser(v=2)


## ------------------------------------------------
## Method `ConfMatrix$EntProd_i`
## ------------------------------------------------

A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$EntProd_i(3,v=2)


## ------------------------------------------------
## Method `ConfMatrix$NormEntProd`
## ------------------------------------------------

A&lt;-matrix(c(35,4,12,2,14,11,9,5,11,3,38,12,1,0,4,2),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Finn 1993")
p$NormEntProd(v=2)


## ------------------------------------------------
## Method `ConfMatrix$Sucess`
## ------------------------------------------------

A&lt;-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),nrow=3,ncol=3)
p&lt;-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess()


## ------------------------------------------------
## Method `ConfMatrix$Sucess_i`
## ------------------------------------------------

A&lt;-matrix(c(0.3,0.02,0.01,0.12,0.19,0.03,0.02,0.01,0.3),nrow=3,ncol=3)
p&lt;-ConfMatrix$new(A,Source="Labatut and Cherifi 2011")
p$Sucess_i(2)


## ------------------------------------------------
## Method `ConfMatrix$AvHellAcc`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvHellAcc()


## ------------------------------------------------
## Method `ConfMatrix$AvHellAcc_i`
## ------------------------------------------------

A &lt;- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick 1986")
p$AvHellAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$AvShortAcc`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
p$AvShortAcc()


## ------------------------------------------------
## Method `ConfMatrix$ShortAcc_i`
## ------------------------------------------------

A &lt;- matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source="Rosenfield and Fitzpatrick-Lins 1986")
p$ShortAcc_i(2)


## ------------------------------------------------
## Method `ConfMatrix$GroundTruth`
## ------------------------------------------------

A&lt;-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth()


## ------------------------------------------------
## Method `ConfMatrix$GroundTruth_i`
## ------------------------------------------------

A&lt;-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source="Türk 1979")
p$GroundTruth_i(3)


## ------------------------------------------------
## Method `ConfMatrix$HellingerDist`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
r&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
B&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(B,Source="Congalton and Green 2008")
r$HellingerDist(f)


## ------------------------------------------------
## Method `ConfMatrix$QES`
## ------------------------------------------------

A&lt;-matrix(c(3,2,1,1,3,3,2,0,1),nrow=3,ncol=3)
p&lt;-ConfMatrix$new(A,Source="Pontius Jr. and Santacruz 2023")
p$QES()


## ------------------------------------------------
## Method `ConfMatrix$MTypify`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MTypify(RaR=5)

## ------------------------------------------------
## Method `ConfMatrix$MBootStrap`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A, Source="Congalton and Green 2008")
p$MBootStrap(2)


## ------------------------------------------------
## Method `ConfMatrix$MNormalize`
## ------------------------------------------------

A&lt;-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p&lt;-ConfMatrix$new(A,Source="Muñoz 2016")
p$MNormalize()


## ------------------------------------------------
## Method `ConfMatrix$MPseudoZeroes`
## ------------------------------------------------

A&lt;-matrix(c(238051,7,132,0,0,24,9,2,189,1,4086,188,0,4,16,45,1,0,939,5082,
51817,0,34,500,1867,325,17,0,0,5,11148,1618,78,0,0,0,0,48,4,834,2853,340,
32,0,197,5,151,119,135,726,6774,75,1,553,0,105,601,110,174,155,8257,8,0,
29,36,280,0,0,6,5,2993,0,115,2,0,4,124,595,0,0,4374),nrow=9,ncol=9)
p&lt;-ConfMatrix$new(A,Source="Muñoz 2016")
p$MPseudoZeroes()


## ------------------------------------------------
## Method `ConfMatrix$OverallAcc.test`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
B&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$OverallAcc.test(f)


## ------------------------------------------------
## Method `ConfMatrix$Kappa.test`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
B&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Kappa.test(f)


## ------------------------------------------------
## Method `ConfMatrix$Tau.test`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
B&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(B,Source="Congalton and Green 2008")
p$Tau.test(f)


## ------------------------------------------------
## Method `ConfMatrix$TSCM.test`
## ------------------------------------------------

A&lt;-matrix(c(65,6,0,4,4,81,11,7,22,5,85,3,24,8,19,90),nrow=4,ncol=4)
p&lt;-ConfMatrix$new(A,Source="Congalton and Green 2008")
C&lt;-matrix(c(45,6,0,4,4,91,8,7,12,5,55,3,24,8,9,55),nrow=4,ncol=4)
f&lt;-ConfMatrix$new(C,Source="Congalton and Green 2008")
p$TSCM.test(f)


## ------------------------------------------------
## Method `ConfMatrix$QIndep.test`
## ------------------------------------------------

A&lt;-matrix(c(148,1,8,2,0,0,50,15,3,0,1,6,39,7,1,1,0,6,25,1,1,0,0,1,6),nrow=5,
ncol=5)
p&lt;-ConfMatrix$new(A,Source= "Türk 1979")
p$QIndep.test()

</code></pre>

<hr>
<h2 id='QCCS'>Quality Control Columns Set</h2><span id='topic+QCCS'></span>

<h3>Description</h3>

<p>The difference between a QCCS and a confusion matrix is
that while forming a confusion matrix requires that the reference and
the product be more or less equivalent, for the QCCS it is required
that the reference be actually of higher quality than the product.
This forces us to leave the marginals corresponding to the reference
fixed. That is why we work by columns. In this way, the QCCS class
works with a confusion matrix expressed as a set of column vectors
and it will be analyzed by columns. A QCCS is constructed by comparing
a sample of a set of common positions in the product and the ground
truth. Appropriate sampling methods must be applied to generate the
QCCS. It is considered that the classes of the ground truth
correspond to the columns and that the classes of the
product to be valued correspond to the rows. On the other hand, the
concept of QCCS is directly linked to quality control, so the
specifications of this control must be indicated (Ariza-López et al. 2019).
Specifications are stated as percentages. E.g. for class &quot;A&quot; under
consideration, a minimum quality value is established (e.g. better than 90%), and
maximum values of confusion with other categories (e.g. confusion
between A and B less than 5%). The specifications are proportions of
a multinomial. First, an object of this class of object must be
created (instantiated) and then the methods that offer the index
calculations will be invoked.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Vectors</code></dt><dd><p><code style="white-space: pre;">&#8288;
List of integer values data for the vectors.
&#8288;</code></p>
</dd>
<dt><code>Prob</code></dt><dd><p><code style="white-space: pre;">&#8288;
List of probability values corresponding to each of the vectors.
&#8288;</code></p>
</dd>
<dt><code>ID</code></dt><dd><p><code style="white-space: pre;">&#8288;
Identifier. It is a character string with a maximum length of 50 characters.
By default,&#8288;</code> <code class="reqn">QCCS_i</code> <code style="white-space: pre;">&#8288;will be taken as identification. Where&#8288;</code> <code class="reqn">i \in [1,999]</code> <code style="white-space: pre;">&#8288;will be the
number of QCCS instances already defined in the session.
&#8288;</code></p>
</dd>
<dt><code>Date</code></dt><dd><p><code style="white-space: pre;">&#8288;
Date provided by the user in format DDMMYYYY, "DD-MM-YYYY", "DD/MM/YYYY".
By default the date provided by the system will be taken.
&#8288;</code></p>
</dd>
<dt><code>ClassNames</code></dt><dd><p><code style="white-space: pre;">&#8288;
Name of the classes. It is given by a character strings vector whose elements
are the name of the classes. Each element of the vector is a string of maximum
20 characters. By default for the column elements they will be&#8288;</code> <code class="reqn">PC_i'</code> <code style="white-space: pre;">&#8288; (Producer
class).&#8288;</code></p>
</dd>
<dt><code>Source</code></dt><dd><p><code style="white-space: pre;">&#8288;
Indicates where the "vectors" and "prob" parameters come from (article, project,
etc.). It is suggested to enter a reference or a DOI. A character string with
a maximum length of 80 characters can be entered. By default, is NULL.
&#8288;</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-QCCS-new"><code>QCCS$new()</code></a>
</p>
</li>
<li> <p><a href="#method-QCCS-print"><code>QCCS$print()</code></a>
</p>
</li>
<li> <p><a href="#method-QCCS-Exact.test"><code>QCCS$Exact.test()</code></a>
</p>
</li>
<li> <p><a href="#method-QCCS-Ji.test"><code>QCCS$Ji.test()</code></a>
</p>
</li>
<li> <p><a href="#method-QCCS-JiGlobal.test"><code>QCCS$JiGlobal.test()</code></a>
</p>
</li></ul>


<hr>
<a id="method-QCCS-new"></a>



<h4>Method <code>new()</code></h4>

<p>Public method to create an instance of the QCCS class.
At the time of creation, column set data and specification values
must be provided. The same number of data and as specification values
must be entered, and the pairs of data-specifications vectors must
have the same size, otherwise an error will be provided.
The optional possibility of adding metadata to the matrix is offered.
The values of the data vectors represent the classes of ground truth.
</p>


<h5>Usage</h5>

<div class="r"><pre>QCCS$new(
  Vectors,
  Prob,
  ID = NULL,
  Date = NULL,
  ClassNames = NULL,
  Source = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Vectors</code></dt><dd><p><code style="white-space: pre;">&#8288;
List of integer values data for the vectors.
&#8288;</code></p>
</dd>
<dt><code>Prob</code></dt><dd><p><code style="white-space: pre;">&#8288;
List of probability values corresponding to each of the vectors.
&#8288;</code></p>
</dd>
<dt><code>ID</code></dt><dd><p><code style="white-space: pre;">&#8288;
Identifier. It is a character string with a maximum length of 50 characters.
By default,&#8288;</code> <code class="reqn">QCCS_i</code> <code style="white-space: pre;">&#8288;will be taken as identification. Where&#8288;</code> <code class="reqn">i \in [1,999]</code> <code style="white-space: pre;">&#8288;will be
the number of QCCS instances already defined in the session.
&#8288;</code></p>
</dd>
<dt><code>Date</code></dt><dd><p><code style="white-space: pre;">&#8288;
Date provided by the user in format DDMMYYYY, "DD-MM-YYYY", "DD/MM/YYYY".
By default the date provided by the system will be taken.
&#8288;</code></p>
</dd>
<dt><code>ClassNames</code></dt><dd><p><code style="white-space: pre;">&#8288;
Name of the classes. It is given by a character strings vector whose elements
are the name of the classes. Each element of the vector is a string of maximum
20 characters. By default for the column elements they will be&#8288;</code> <code class="reqn">PC_i'</code> <code style="white-space: pre;">&#8288; (Producer
class).&#8288;</code></p>
</dd>
<dt><code>Source</code></dt><dd><p><code style="white-space: pre;">&#8288;
Indicates where the "vectors" and "prob" parameters come from (article, proj-
ect, etc.). It is suggested to enter a reference or a DOI. A character string
with a maximum length of 80 characters can be entered. By default, is NULL.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>Vectors&lt;-list(c(47,4,0),c(44,5,3))
Prob&lt;-list(c(0.95,0.04,0.01),c(0.88,0.1,0.02))
A&lt;-QCCS$new(Vectors,Prob,
Source="Ariza-Lopez et al. 2019")

</pre>
</div>


<hr>
<a id="method-QCCS-print"></a>



<h4>Method <code>print()</code></h4>

<p>Public method that shows all the data entered
by the user.
</p>


<h5>Usage</h5>

<div class="r"><pre>QCCS$print()</pre></div>



<h5>Returns</h5>

<p>QCCS object identifier, Date, name of classes, source
of data and data vectors and probability.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Vectors&lt;-list(c(18,0,3,0),c(27,19))
Prob&lt;-list(c(0.85,0.1,0.03,0.02),c(0.8,0.2))
A&lt;-QCCS$new(Vectors,Prob,
Source="Alba-Fernández et al. 2020")
A$print()

</pre>
</div>


<hr>
<a id="method-QCCS-Exact.test"></a>



<h4>Method <code>Exact.test()</code></h4>

<p>Public method that using a QCCS object
instance calculates whether the data meets specifications.
An exact test is applied to each of the multinomials
that are defined for each column.
The Bonferroni method is used.
The references (Ariza-López et al. 2019) and (Alba-Fernández et al. 2020)
are followed for the computations.
</p>


<h5>Usage</h5>

<div class="r"><pre>QCCS$Exact.test(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
significance level. By default a=0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of the &quot;htest&quot; class containing the results of the hypothesis test.
The p-value returned is the lowest of those obtained for the data analyzed.
In addition, the Bonferroni criterion value, the p-values obtained for each column,
the original data vectors and the probability vectors are also returned as
parameters of the htest class.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>\donttest{
Vectors&lt;-list(c(47,4,0),c(40,5,3))
Prob&lt;-list(c(0.95,0.04,0.01),c(0.88,0.1,0.02))
A&lt;-QCCS$new(Vectors,Prob,
Source="Ariza-Lopez et al. 2019")
A$Exact.test()
}

</pre>
</div>


<hr>
<a id="method-QCCS-Ji.test"></a>



<h4>Method <code>Ji.test()</code></h4>

<p>Public method that using a QCCS object instance
calculates whether the data meets specifications in each of the classes.
The Chi square test is used. The Bonferroni method is used.
The references (Ariza-López et al. 2019) and (Alba-Fernández et al. 2020)
are followed for the computations.
</p>


<h5>Usage</h5>

<div class="r"><pre>QCCS$Ji.test(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
significance level. By default a=0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of the &quot;htest&quot; class containing the results of the hypothesis test.
The p-value returned is the lowest of those obtained for the data analyzed.
In addition, the Bonferroni criterion value, the obtained p-values, the degrees of
freedom and the statistics obtained for each column, the original data vectors
and the probability vectors are also returned as parameters of the htest class.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Vectors&lt;-list(c(18,0,3,0),c(27,19))
Prob&lt;-list(c(0.85,0.1,0.03,0.02),c(0.8,0.2))
A &lt;- QCCS$new(Vectors,Prob,
Source="Alba-Fernández et al. 2020")
A$Ji.test()

</pre>
</div>


<hr>
<a id="method-QCCS-JiGlobal.test"></a>



<h4>Method <code>JiGlobal.test()</code></h4>

<p>Public method that using a QCCS
object instance calculates whether the data meets
specifications. The Chi square test is used.
The references
(Ariza-López et al. 2019) and (Alba-Fernández et al. 2020)
are followed for the computations.
</p>


<h5>Usage</h5>

<div class="r"><pre>QCCS$JiGlobal.test(a = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>a</code></dt><dd><p><code style="white-space: pre;">&#8288;
significance level. By default a=0.05.
&#8288;</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A list of class &quot;htest&quot; containing the results of the hypothesis test.
In addition, the original data vectors and the probability vectors are also
returned.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Vectors&lt;-list(c(18,0,3,0),c(27,19))
Prob&lt;-list(c(0.85,0.1,0.03,0.02),c(0.8,0.2))
A &lt;- QCCS$new(Vectors,Prob,
Source="Alba-Fernández et al. 2020")
A$JiGlobal.test()

</pre>
</div>




<h3>Note</h3>

<p>Error Messages: List of possible errors:
</p>

<ul>
<li> <p><code>Error type 1</code>: Different number of data vectors and probability.
</p>
</li>
<li> <p><code>Error type 2</code>: Different number of elements in the pair of data
vectors and probabilities.
</p>
</li>
<li> <p><code>Error type 3</code>: The sum of the elements of the data vectors is 0.
</p>
</li>
<li> <p><code>Error type 4</code>: The sum of each probability vectors must be 1.
</p>
</li>
<li> <p><code>Error type 5</code>: Some element of the data vector is negative.
</p>
</li>
<li> <p><code>Error type 6</code>: Some element of the probability vector is negative.
</p>
</li></ul>



<h3>References</h3>

<p>Alba-Fernández MV, Ariza-López FJ, Rodríguez-Avi J, García-Balboa JL (2020).
&ldquo;Statistical methods for thematic-accuracy quality control based on an accurate reference sample.&rdquo;
<em>Remote Sensing</em>, <b>12</b>(5), 816.
</p>
<p>Ariza-López FJ, Rodríguez-Avi J, Alba-Fernández MV, García-Balboa JL (2019).
&ldquo;Thematic accuracy quality control by means of a set of multinomials.&rdquo;
<em>Applied Sciences</em>, <b>9</b>(20), 4240.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `QCCS$new`
## ------------------------------------------------

Vectors&lt;-list(c(47,4,0),c(44,5,3))
Prob&lt;-list(c(0.95,0.04,0.01),c(0.88,0.1,0.02))
A&lt;-QCCS$new(Vectors,Prob,
Source="Ariza-Lopez et al. 2019")


## ------------------------------------------------
## Method `QCCS$print`
## ------------------------------------------------

Vectors&lt;-list(c(18,0,3,0),c(27,19))
Prob&lt;-list(c(0.85,0.1,0.03,0.02),c(0.8,0.2))
A&lt;-QCCS$new(Vectors,Prob,
Source="Alba-Fernández et al. 2020")
A$print()


## ------------------------------------------------
## Method `QCCS$Exact.test`
## ------------------------------------------------


Vectors&lt;-list(c(47,4,0),c(40,5,3))
Prob&lt;-list(c(0.95,0.04,0.01),c(0.88,0.1,0.02))
A&lt;-QCCS$new(Vectors,Prob,
Source="Ariza-Lopez et al. 2019")
A$Exact.test()



## ------------------------------------------------
## Method `QCCS$Ji.test`
## ------------------------------------------------

Vectors&lt;-list(c(18,0,3,0),c(27,19))
Prob&lt;-list(c(0.85,0.1,0.03,0.02),c(0.8,0.2))
A &lt;- QCCS$new(Vectors,Prob,
Source="Alba-Fernández et al. 2020")
A$Ji.test()


## ------------------------------------------------
## Method `QCCS$JiGlobal.test`
## ------------------------------------------------

Vectors&lt;-list(c(18,0,3,0),c(27,19))
Prob&lt;-list(c(0.85,0.1,0.03,0.02),c(0.8,0.2))
A &lt;- QCCS$new(Vectors,Prob,
Source="Alba-Fernández et al. 2020")
A$JiGlobal.test()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
