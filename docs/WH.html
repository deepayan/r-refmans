<!DOCTYPE html><html><head><title>Help for package WH</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WH}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blockdiag'><p>Diagonal Stacking of Matrices</p></a></li>
<li><a href='#build_D_mat'><p>Build Difference Matrix of Given Order</p></a></li>
<li><a href='#compute_res_deviance'><p>Deviance Residuals for Poisson GLM</p></a></li>
<li><a href='#eigen_dec'><p>Eigen Decomposition of Penalization Matrix</p></a></li>
<li><a href='#get_diagnosis'><p>Diagnosis for Model Fit</p></a></li>
<li><a href='#map'><p>Lapply with Custom Return Type</p></a></li>
<li><a href='#map2'><p>Bivariate Lapply with Custom Return Type</p></a></li>
<li><a href='#output_to_df'><p>Provide WH model Fit Results as a Data.frame</p></a></li>
<li><a href='#plot.WH_1d'><p>Plot Method for a Whittaker-Henderson Fit</p></a></li>
<li><a href='#plot.WH_2d'><p>Plot Method for a Whittaker-Henderson Fit</p></a></li>
<li><a href='#portfolio_LTC'><p>Agregated Long-Term Care Dataset</p></a></li>
<li><a href='#portfolio_mort'><p>Agregated Mortality Dataset</p></a></li>
<li><a href='#predict.WH_1d'><p>Prediction for a Whittaker-Henderson Fit</p></a></li>
<li><a href='#predict.WH_2d'><p>Prediction for a Whittaker-Henderson Fit</p></a></li>
<li><a href='#print.WH_1d'><p>Print Method for a Whittaker-Henderson Fit</p></a></li>
<li><a href='#print.WH_2d'><p>Print Method for a Whittaker-Henderson Fit</p></a></li>
<li><a href='#WH_1d'><p>1D Whittaker-Henderson Smoothing</p></a></li>
<li><a href='#WH_1d_fixed_lambda'><p>Whittaker-Henderson Smoothing (Maximum Likelihood, fixed lambda)</p></a></li>
<li><a href='#WH_1d_outer'><p>Whittaker-Henderson Smoothing (Maximum Likelihood, optimize function)</p></a></li>
<li><a href='#WH_1d_perf'><p>Whittaker-Henderson Smoothing (Maximum Likelihood, Generalized Fellner-Schall update)</p></a></li>
<li><a href='#WH_2d'><p>2D Whittaker-Henderson Smoothing</p></a></li>
<li><a href='#WH_2d_fixed_lambda'><p>2D Whittaker-Henderson Smoothing (Maximum Likelihood, fixed lambda)</p></a></li>
<li><a href='#WH_2d_outer'><p>2D Whittaker-Henderson Smoothing (Maximum Likelihood, optim function)</p></a></li>
<li><a href='#WH_2d_perf'><p>2D Whittaker-Henderson Smoothing (Maximum Likelihood, Generalized Fellner-Schall update)</p></a></li>
<li><a href='#WH-package'><p>WH : Enhanced Implementation of Whittaker-Henderson Smoothing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Enhanced Implementation of Whittaker-Henderson Smoothing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An enhanced implementation of Whittaker-Henderson smoothing for the gradation 
    of one-dimensional and two-dimensional actuarial tables used to quantify Life Insurance risks.
    'WH' is based on the methods described in Biessy (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2306.06932">doi:10.48550/arXiv.2306.06932</a>&gt;.
    Among other features, it generalizes the original smoothing algorithm to maximum likelihood estimation, 
    automatically selects the smoothing parameter(s) and extrapolates beyond the range of data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/GuillaumeBiessy/WH">https://github.com/GuillaumeBiessy/WH</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GuillaumeBiessy/WH/issues">https://github.com/GuillaumeBiessy/WH/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-16 11:47:09 UTC; Guillaume BIESSY</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillaume Biessy <a href="https://orcid.org/0000-0003-3756-7345"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillaume Biessy &lt;guillaume.biessy78@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-18 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='blockdiag'>Diagonal Stacking of Matrices</h2><span id='topic+blockdiag'></span>

<h3>Description</h3>

<p>Diagonal Stacking of Matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockdiag(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockdiag_+3A_...">...</code></td>
<td>
<p>One or several object of type <code>matrix</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix obtained by stacking the input matrices diagonally
</p>

<hr>
<h2 id='build_D_mat'>Build Difference Matrix of Given Order</h2><span id='topic+build_D_mat'></span>

<h3>Description</h3>

<p>Build Difference Matrix of Given Order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_D_mat(n, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_D_mat_+3A_n">n</code></td>
<td>
<p>Number of observations in the problem</p>
</td></tr>
<tr><td><code id="build_D_mat_+3A_q">q</code></td>
<td>
<p>Order of the penalization matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The difference matrix of order <code>q</code> for a vector containing
<code>n</code> observations.
</p>

<hr>
<h2 id='compute_res_deviance'>Deviance Residuals for Poisson GLM</h2><span id='topic+compute_res_deviance'></span>

<h3>Description</h3>

<p>Deviance Residuals for Poisson GLM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_res_deviance(D, D_hat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_res_deviance_+3A_d">D</code></td>
<td>
<p>Vector or matrix containing the number of observed events</p>
</td></tr>
<tr><td><code id="compute_res_deviance_+3A_d_hat">D_hat</code></td>
<td>
<p>Vector or matrix containing the number of predicted events</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or matrix (depending on the input type, will be a matrix
if at least one of the input is) containing the deviance residuals
</p>

<hr>
<h2 id='eigen_dec'>Eigen Decomposition of Penalization Matrix</h2><span id='topic+eigen_dec'></span>

<h3>Description</h3>

<p>Eigen Decomposition of Penalization Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_dec(n, q, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen_dec_+3A_n">n</code></td>
<td>
<p>Number of observations in the problem</p>
</td></tr>
<tr><td><code id="eigen_dec_+3A_q">q</code></td>
<td>
<p>Order of the penalization matrix</p>
</td></tr>
<tr><td><code id="eigen_dec_+3A_p">p</code></td>
<td>
<p>Number of eigenvectors to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components : - <code>U</code> a matrix whose columns are the
eigenvectors of the penalization matrix - <code>s</code> a vector containing the
eigenvalues sorted in ascending order
</p>

<hr>
<h2 id='get_diagnosis'>Diagnosis for Model Fit</h2><span id='topic+get_diagnosis'></span>

<h3>Description</h3>

<p>Diagnosis for Model Fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_diagnosis(dev, pen, sum_edf, n_pos, tr_log_P, tr_log_Psi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_diagnosis_+3A_dev">dev</code></td>
<td>
<p>Deviance of the model</p>
</td></tr>
<tr><td><code id="get_diagnosis_+3A_pen">pen</code></td>
<td>
<p>Penalization force</p>
</td></tr>
<tr><td><code id="get_diagnosis_+3A_sum_edf">sum_edf</code></td>
<td>
<p>Effective dimension</p>
</td></tr>
<tr><td><code id="get_diagnosis_+3A_n_pos">n_pos</code></td>
<td>
<p>Number of strictly positive weights</p>
</td></tr>
<tr><td><code id="get_diagnosis_+3A_tr_log_p">tr_log_P</code></td>
<td>
<p>Trace of logarithm of penalization matrix</p>
</td></tr>
<tr><td><code id="get_diagnosis_+3A_tr_log_psi">tr_log_Psi</code></td>
<td>
<p>Trace of logarithm of variance-covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing various diagnoses about the fit
</p>

<hr>
<h2 id='map'>Lapply with Custom Return Type</h2><span id='topic+map'></span>

<h3>Description</h3>

<p>Lapply with Custom Return Type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(x, f, output_type = "list")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_x">x</code></td>
<td>
<p>A vector or list</p>
</td></tr>
<tr><td><code id="map_+3A_f">f</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="map_+3A_output_type">output_type</code></td>
<td>
<p>The desired return type. Should be one of &quot;list&quot; (the
default), &quot;integer&quot;, &quot;numeric&quot; or &quot;character&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (if output_type = &quot;list&quot;) or a vector, sharing names with x,
built by applying f to each element of x. This is a rough implementation
of the <code>map</code> function from the <code>purrr</code> package and aims at removing the
dependency from that package.
</p>

<hr>
<h2 id='map2'>Bivariate Lapply with Custom Return Type</h2><span id='topic+map2'></span>

<h3>Description</h3>

<p>Bivariate Lapply with Custom Return Type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map2(x, y, f, output_type = "list")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map2_+3A_x">x</code>, <code id="map2_+3A_y">y</code></td>
<td>
<p>A couple of vectors or lists with the same size</p>
</td></tr>
<tr><td><code id="map2_+3A_f">f</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="map2_+3A_output_type">output_type</code></td>
<td>
<p>The desired return type. Should be one of &quot;list&quot; (the
default), &quot;integer&quot;, &quot;numeric&quot; or &quot;character&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (if output_type = &quot;list&quot;) or a vector, sharing names with x,
built by applying f to each element of x and y simultaneously. This is a
rough implementation of the <code>map2</code> function from the <code>purrr</code> package
purrr aims at removing the dependency from that package.
</p>

<hr>
<h2 id='output_to_df'>Provide WH model Fit Results as a Data.frame</h2><span id='topic+output_to_df'></span>

<h3>Description</h3>

<p>Provide WH model Fit Results as a Data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_to_df(object, dim1 = "x", dim2 = "t")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_to_df_+3A_object">object</code></td>
<td>
<p>An object of class  <code>"WH_1d"</code> or <code>"WH_2d"</code> returned
by one of the eponymous functions <code><a href="#topic+WH_1d">WH_1d()</a></code> or <code><a href="#topic+WH_2d">WH_2d()</a></code></p>
</td></tr>
<tr><td><code id="output_to_df_+3A_dim1">dim1</code></td>
<td>
<p>The optional name to be given to the first dimension</p>
</td></tr>
<tr><td><code id="output_to_df_+3A_dim2">dim2</code></td>
<td>
<p>The optional name to be given to the second dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame regrouping information about the fitted and predicted
values, the model variance, residuals and effective degrees of freedom...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- portfolio_mort$d
ec &lt;- portfolio_mort$ec

y &lt;- log(d / ec)
y[d == 0] &lt;- - 20
wt &lt;- d

fit_1d &lt;- WH_1d(d, ec)
output_to_df(fit_1d)

keep_age &lt;- which(rowSums(portfolio_LTC$ec) &gt; 5e2)
keep_duration &lt;- which(colSums(portfolio_LTC$ec) &gt; 1e3)

d  &lt;- portfolio_LTC$d[keep_age, keep_duration]
ec &lt;- portfolio_LTC$ec[keep_age, keep_duration]

y &lt;- log(d / ec) # observation vector
y[d == 0] &lt;- - 20
wt &lt;- d

# Maximum likelihood
fit_2d &lt;- WH_2d(d, ec)
output_to_df(fit_2d)

</code></pre>

<hr>
<h2 id='plot.WH_1d'>Plot Method for a Whittaker-Henderson Fit</h2><span id='topic+plot.WH_1d'></span>

<h3>Description</h3>

<p>Plot Method for a Whittaker-Henderson Fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WH_1d'
plot(x, what = "fit", trans, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.WH_1d_+3A_x">x</code></td>
<td>
<p>An object of class <code>"WH_1d"</code> returned by the <code><a href="#topic+WH_1d">WH_1d()</a></code> function</p>
</td></tr>
<tr><td><code id="plot.WH_1d_+3A_what">what</code></td>
<td>
<p>What should be plotted. Should be one of <code>fit</code> (the model fit and
standard deviation, the default), <code>res</code> for residuals and <code>edf</code> for the
effective degrees of freedom.</p>
</td></tr>
<tr><td><code id="plot.WH_1d_+3A_trans">trans</code></td>
<td>
<p>An (optional) transformation to be applied to the data. By
default the identity function</p>
</td></tr>
<tr><td><code id="plot.WH_1d_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot representing the desired element from the fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- portfolio_mort$d
ec &lt;- portfolio_mort$ec

fit &lt;- WH_1d(d, ec)
plot(fit)
plot(fit, "res")
plot(fit, "edf")

</code></pre>

<hr>
<h2 id='plot.WH_2d'>Plot Method for a Whittaker-Henderson Fit</h2><span id='topic+plot.WH_2d'></span>

<h3>Description</h3>

<p>Plot Method for a Whittaker-Henderson Fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WH_2d'
plot(x, what = "y_hat", trans, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.WH_2d_+3A_x">x</code></td>
<td>
<p>An object of class <code>"WH_2d"</code> returned by the <code><a href="#topic+WH_2d">WH_2d()</a></code> function</p>
</td></tr>
<tr><td><code id="plot.WH_2d_+3A_what">what</code></td>
<td>
<p>Should be one of <code>y_hat</code> (the default) for model fit, <code>std_y_hat</code>
for the associated standard deviation, <code>res</code> for residuals and <code>edf</code> for
the effective degrees of freedom.</p>
</td></tr>
<tr><td><code id="plot.WH_2d_+3A_trans">trans</code></td>
<td>
<p>An (optional) transformation to be applied to the data. By
default the identity function</p>
</td></tr>
<tr><td><code id="plot.WH_2d_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot representing the desired element from the fit...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>keep_age &lt;- which(rowSums(portfolio_LTC$ec) &gt; 5e2)
keep_duration &lt;- which(colSums(portfolio_LTC$ec) &gt; 1e3)

d  &lt;- portfolio_LTC$d[keep_age, keep_duration]
ec &lt;- portfolio_LTC$ec[keep_age, keep_duration]

fit &lt;- WH_2d(d, ec)
plot(fit)
plot(fit, "std_y_hat")

</code></pre>

<hr>
<h2 id='portfolio_LTC'>Agregated Long-Term Care Dataset</h2><span id='topic+portfolio_LTC'></span>

<h3>Description</h3>

<p>Agregated dataset built from a synthetic long-term care portfolio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portfolio_LTC
</code></pre>


<h3>Format</h3>

<p>A dataset obtaining by agregating the information from a fictive
long-term care annuitant database with 5,000 annuitants over a 10-year
observation period. The dataset is supplied as a list with two components :
</p>
<dl>
<dt>exit</dt><dd><p>A matrix containing the number of observed deaths for
each combination of age and duration in LTC where at least one death
has been observed</p>
</dd> <dt>expo</dt><dd><p>A matrix containing the associated central
exposure in person-years for each combination of age and duration in LTC in d</p>
</dd></dl>


<hr>
<h2 id='portfolio_mort'>Agregated Mortality Dataset</h2><span id='topic+portfolio_mort'></span>

<h3>Description</h3>

<p>Agregated dataset built from a synthetic mortality portfolio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portfolio_mort
</code></pre>


<h3>Format</h3>

<p>A dataset containing the information from a simulated annuity
portfolio with 100,000 contributors over a 10-year observation period. The
dataset is supplied as a list with two components : </p>
<dl>
<dt>d</dt><dd><p>A
vector containing the number of observed deaths for ages where at
least one death has been observed</p>
</dd> <dt>ec</dt><dd><p>A vector containing the associated
central exposure in person-years for each age in d</p>
</dd></dl>


<hr>
<h2 id='predict.WH_1d'>Prediction for a Whittaker-Henderson Fit</h2><span id='topic+predict.WH_1d'></span>

<h3>Description</h3>

<p>Extrapolate the Whittaker-Henderson fit for new observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WH_1d'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.WH_1d_+3A_object">object</code></td>
<td>
<p>An object of class <code>"WH_1d"</code> returned by the <code><a href="#topic+WH_1d">WH_1d()</a></code> function</p>
</td></tr>
<tr><td><code id="predict.WH_1d_+3A_newdata">newdata</code></td>
<td>
<p>A vector containing the position of new observations.
Observations from the fit will automatically be added to this, in the
adequate order</p>
</td></tr>
<tr><td><code id="predict.WH_1d_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"WH_1d"</code> with additional components <code>y_pred</code> and
<code>std_y_pred</code> corresponding to the model predictions and associated standard
deviations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- portfolio_mort$d
ec &lt;- portfolio_mort$ec

fit &lt;- WH_1d(d, ec)
newdata = 18:99
pred &lt;- predict(fit, newdata)
plot(pred)

</code></pre>

<hr>
<h2 id='predict.WH_2d'>Prediction for a Whittaker-Henderson Fit</h2><span id='topic+predict.WH_2d'></span>

<h3>Description</h3>

<p>Extrapolate the Whittaker-Henderson fit for new observations in a way that is
consistent with the initial model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WH_2d'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.WH_2d_+3A_object">object</code></td>
<td>
<p>An object of class <code>"WH_2d"</code> returned by the <code><a href="#topic+WH_2d">WH_2d()</a></code> function</p>
</td></tr>
<tr><td><code id="predict.WH_2d_+3A_newdata">newdata</code></td>
<td>
<p>A list containing two vectors indicating the new observation
positions</p>
</td></tr>
<tr><td><code id="predict.WH_2d_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"WH_2d"</code> with additional components <code>y_pred</code> and
<code>std_y_pred</code> corresponding to the model predictions and associated standard
deviations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>keep_age &lt;- which(rowSums(portfolio_LTC$ec) &gt; 5e2)
keep_duration &lt;- which(colSums(portfolio_LTC$ec) &gt; 1e3)

d  &lt;- portfolio_LTC$d[keep_age, keep_duration]
ec &lt;- portfolio_LTC$ec[keep_age, keep_duration]

fit &lt;- WH_2d(d, ec)
newdata &lt;- list(age = 50:99, duration = 0:19)
pred &lt;- predict(fit, newdata)
plot(pred)

</code></pre>

<hr>
<h2 id='print.WH_1d'>Print Method for a Whittaker-Henderson Fit</h2><span id='topic+print.WH_1d'></span>

<h3>Description</h3>

<p>Print Method for a Whittaker-Henderson Fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WH_1d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.WH_1d_+3A_x">x</code></td>
<td>
<p>An object of class <code>"WH_1d"</code> returned by the <code><a href="#topic+WH_1d">WH_1d()</a></code> function</p>
</td></tr>
<tr><td><code id="print.WH_1d_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- portfolio_mort$d
ec &lt;- portfolio_mort$ec

y &lt;- log(d / ec)
y[d == 0] &lt;- - 20
wt &lt;- d

WH_1d(d, ec)

</code></pre>

<hr>
<h2 id='print.WH_2d'>Print Method for a Whittaker-Henderson Fit</h2><span id='topic+print.WH_2d'></span>

<h3>Description</h3>

<p>Print Method for a Whittaker-Henderson Fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'WH_2d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.WH_2d_+3A_x">x</code></td>
<td>
<p>An object of class <code>"WH_2d"</code> returned by the <code><a href="#topic+WH_2d">WH_2d()</a></code> function</p>
</td></tr>
<tr><td><code id="print.WH_2d_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>keep_age &lt;- which(rowSums(portfolio_LTC$ec) &gt; 5e2)
keep_duration &lt;- which(colSums(portfolio_LTC$ec) &gt; 1e3)

d  &lt;- portfolio_LTC$d[keep_age, keep_duration]
ec &lt;- portfolio_LTC$ec[keep_age, keep_duration]

WH_2d(d, ec)

</code></pre>

<hr>
<h2 id='WH_1d'>1D Whittaker-Henderson Smoothing</h2><span id='topic+WH_1d'></span>

<h3>Description</h3>

<p>Main package function to apply Whittaker-Henderson smoothing in a
one-dimensional survival analysis framework. It takes as input a vector of
observed events and a vector of associated central exposure, both depending
on a single covariate, and build a smooth version of the log-hazard rate.
Smoothing parameters may be supplied or automatically chosen according to an
adequate criterion such as <code>"REML"</code> (the default), <code>"AIC"</code>, <code>"BIC"</code> or
<code>"GCV"</code>. Whittaker-Henderson may be applied in a full maximum likelihood
framework (the default) or an approximate gaussian framework (the original).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_1d(
  d,
  ec,
  lambda,
  criterion,
  method,
  q = 2,
  framework,
  y,
  wt,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_1d_+3A_d">d</code></td>
<td>
<p>Vector of observed events, should have named elements.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_ec">ec</code></td>
<td>
<p>Vector of central exposure. The central exposure corresponds to the
sum of the exposure duration over the insured population. An individual
experiencing an event of interest during the year will no longer be exposed
afterward and the exposure should be computed accordingly.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter. If missing, an optimization procedure will
be used to find the optimal smoothing parameter. If supplied, no optimal
smoothing parameter search will take place unless the <code>method</code> argument is
also supplied, in which case <code>lambda</code> will be used as the starting
parameter for the optimization procedure.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_criterion">criterion</code></td>
<td>
<p>Criterion to be used for the selection of the optimal
smoothing parameter. Default is <code>"REML"</code> which stands for restricted
maximum likelihood. Other options include <code>"AIC"</code>, <code>"BIC"</code> and <code>"GCV"</code>.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_method">method</code></td>
<td>
<p>Method to be used to find the optimal smoothing parameter.
Default to <code>"fixed_lambda"</code> if <code>lambda</code> is supplied, meaning no
optimization is performed. Otherwise, default to the most reliable
<code>"outer"</code> methodbased on the <code>optimize</code> function from package <code>stats</code>.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_q">q</code></td>
<td>
<p>Order of penalization. Polynoms of degrees <code>q - 1</code> are considered
completely smooth and are therefore unpenalized. Should be left to the
default of <code>2</code> for most practical applications.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_framework">framework</code></td>
<td>
<p>Default framework is <code>"ml"</code> which stands for maximum
likelihood unless the <code>y</code> argument is also provided, in which case an
<code>"reg"</code> or (approximate) regression framework is used.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_y">y</code></td>
<td>
<p>Optional vector of observations whose elements should be named. Used
only in the regression framework and if the <code>d</code> and <code>ec</code> arguments are
missing (otherwise <code>y</code> is automatically computed from <code>d</code> and <code>ec</code>). May be
useful when using Whittaker-Henderson smoothing outside of the survival
analysis framework.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_wt">wt</code></td>
<td>
<p>Optional vector of weights. As for the observation vector <code>y</code>, used
only in the regression framework and if the <code>d</code> and <code>ec</code> arguments are
missing (otherwise <code>wt</code> is automatically set to <code>d</code>). May be useful when
using Whittaker-Henderson smoothing outside of the survival analysis
framework.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_quiet">quiet</code></td>
<td>
<p>Should messages and warnings be silenced ? Default to <code>FALSE</code>,
may be set to <code>TRUE</code> is the function is called repeatedly.</p>
</td></tr>
<tr><td><code id="WH_1d_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the smoothing function called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>WH_1d</code> i.e. a list containing :
</p>

<ul>
<li> <p><code>d</code> The inputed vector of observed events (if supplied as input)
</p>
</li>
<li> <p><code>ec</code> The inputed vector of central exposure (if supplied as input)
</p>
</li>
<li> <p><code>y</code> The observation vector, either supplied or computed as y = log(d) - log(ec)
</p>
</li>
<li> <p><code>wt</code> The inputed vector of weights, either supplied or computed as <code>d</code>
</p>
</li>
<li> <p><code>y_hat</code> The vector of values fitted using Whittaker-Henderson smoothing
</p>
</li>
<li> <p><code>std_y_hat</code> The vector of standard deviation associated with the fit
</p>
</li>
<li> <p><code>res</code> The vector of deviance residuals associated with the fit
</p>
</li>
<li> <p><code>edf_obs</code> The vector of effective degrees of freedom associated with each observation
</p>
</li>
<li> <p><code>edf_par</code> The vector of effective degrees of freedom associated with each eigenvector
</p>
</li>
<li> <p><code>diagnosis</code> A data.frame with one line containing the sum of effective degrees of freedom
for the model, the deviance of the fit as well as the AIC, BIC, GCV and
REML criteria
</p>
</li>
<li> <p><code>Psi</code> The variance-covariance matrix associated with the fit, which is required
for the extrapolation step.
</p>
</li>
<li> <p><code>lambda</code> The smoothing parameter used.
</p>
</li>
<li> <p><code>p</code> The number of eigenvectors kept on each dimension if the rank reduction method
is used (it should not in the one-dimensional case).
</p>
</li>
<li> <p><code>q</code> The supplied order for the penalization matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- portfolio_mort$d
ec &lt;- portfolio_mort$ec

y &lt;- log(d / ec)
y[d == 0] &lt;- - 20
wt &lt;- d

# Maximum likelihood
WH_1d(d, ec, lambda = 1e2)
WH_1d(d, ec) # default outer iteration method based on the optimize function
WH_1d(d, ec, criterion = "GCV")
# alternative optimization criterion for smoothing parameter selection

# Regression
WH_1d(y = y, wt = wt, lambda = 1e2) # regression framework is default when y is supplied
WH_1d(d, ec, framework = "reg", lambda = 1e2)
# setting framework = "reg" forces computation of y from d and ec

</code></pre>

<hr>
<h2 id='WH_1d_fixed_lambda'>Whittaker-Henderson Smoothing (Maximum Likelihood, fixed lambda)</h2><span id='topic+WH_1d_fixed_lambda'></span>

<h3>Description</h3>

<p>Whittaker-Henderson Smoothing (Maximum Likelihood, fixed lambda)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_1d_fixed_lambda(
  d,
  ec,
  y,
  wt,
  lambda = 1000,
  q = 2,
  p,
  reg = FALSE,
  verbose = FALSE,
  accu_dev = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_1d_fixed_lambda_+3A_d">d</code></td>
<td>
<p>Vector of observed events</p>
</td></tr>
<tr><td><code id="WH_1d_fixed_lambda_+3A_ec">ec</code></td>
<td>
<p>Vector of central exposure</p>
</td></tr>
<tr><td><code id="WH_1d_fixed_lambda_+3A_y">y</code></td>
<td>
<p>Vector of observations</p>
</td></tr>
<tr><td><code id="WH_1d_fixed_lambda_+3A_wt">wt</code></td>
<td>
<p>Optional vector of weights</p>
</td></tr>
<tr><td><code id="WH_1d_fixed_lambda_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter</p>
</td></tr>
<tr><td><code id="WH_1d_fixed_lambda_+3A_q">q</code></td>
<td>
<p>Order of penalization. Polynoms of degrees q - 1 are considered
smooth and are therefore unpenalized</p>
</td></tr>
<tr><td><code id="WH_1d_fixed_lambda_+3A_p">p</code></td>
<td>
<p>The number of eigenvectors to keep</p>
</td></tr>
<tr><td><code id="WH_1d_fixed_lambda_+3A_reg">reg</code></td>
<td>
<p>Should the regression framework be used ? Boolean. If <code>TRUE</code>, will
stop after the first iteration.</p>
</td></tr>
<tr><td><code id="WH_1d_fixed_lambda_+3A_accu_dev">accu_dev</code></td>
<td>
<p>Tolerance for the convergence of the optimization procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"WH_1d"</code> i.e. a list containing model fit,
variance, residuals and degrees of freedom as well as diagnosis to asses
the quality of the fit.
</p>

<hr>
<h2 id='WH_1d_outer'>Whittaker-Henderson Smoothing (Maximum Likelihood, optimize function)</h2><span id='topic+WH_1d_outer'></span>

<h3>Description</h3>

<p>Whittaker-Henderson Smoothing (Maximum Likelihood, optimize function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_1d_outer(
  d,
  ec,
  y,
  wt,
  q = 2,
  p,
  criterion = "REML",
  lambda = 1000,
  reg = FALSE,
  verbose = FALSE,
  accu_crit = 1e-12,
  accu_dev = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_1d_outer_+3A_d">d</code></td>
<td>
<p>Vector of observed events</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_ec">ec</code></td>
<td>
<p>Vector of central exposure</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_y">y</code></td>
<td>
<p>Vector of observations</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_wt">wt</code></td>
<td>
<p>Optional vector of weights</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_q">q</code></td>
<td>
<p>Order of penalization. Polynoms of degrees q - 1 are considered
smooth and are therefore unpenalized</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_p">p</code></td>
<td>
<p>The number of eigenvectors to keep</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_criterion">criterion</code></td>
<td>
<p>Criterion used to choose the smoothing parameter. One of
&quot;GCV&quot; (default), &quot;AIC&quot; or &quot;BIC&quot;.</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_lambda">lambda</code></td>
<td>
<p>Initial smoothing parameter</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_reg">reg</code></td>
<td>
<p>Should the regression framework be used ? Boolean. If <code>TRUE</code>, will
stop after the first iteration.</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_verbose">verbose</code></td>
<td>
<p>Should information about the optimization progress be
displayed</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_accu_crit">accu_crit</code></td>
<td>
<p>Tolerance for the convergence of the outer optimization
procedure</p>
</td></tr>
<tr><td><code id="WH_1d_outer_+3A_accu_dev">accu_dev</code></td>
<td>
<p>Tolerance for the convergence of the optimization procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"WH_1d"</code> i.e. a list containing model fit,
variance, residuals and degrees of freedom as well as diagnosis to asses
the quality of the fit.
</p>

<hr>
<h2 id='WH_1d_perf'>Whittaker-Henderson Smoothing (Maximum Likelihood, Generalized Fellner-Schall update)</h2><span id='topic+WH_1d_perf'></span>

<h3>Description</h3>

<p>Whittaker-Henderson Smoothing (Maximum Likelihood, Generalized Fellner-Schall update)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_1d_perf(
  d,
  ec,
  y,
  wt,
  q = 2,
  p,
  criterion = "REML",
  lambda = 1000,
  reg = FALSE,
  verbose = FALSE,
  accu_crit = 1e-12,
  accu_dev = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_1d_perf_+3A_d">d</code></td>
<td>
<p>Vector of observed events</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_ec">ec</code></td>
<td>
<p>Vector of central exposure</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_y">y</code></td>
<td>
<p>Vector of observations</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_wt">wt</code></td>
<td>
<p>Optional vector of weights</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_q">q</code></td>
<td>
<p>Order of penalization. Polynoms of degrees q - 1 are considered
smooth and are therefore unpenalized</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_p">p</code></td>
<td>
<p>The number of eigenvectors to keep</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_criterion">criterion</code></td>
<td>
<p>Criterion used to choose the smoothing parameter. One of
&quot;GCV&quot; (default), &quot;AIC&quot; or &quot;BIC&quot;.</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_lambda">lambda</code></td>
<td>
<p>Initial smoothing parameter</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_reg">reg</code></td>
<td>
<p>Should the regression framework be used ? Boolean. If <code>TRUE</code>, will
stop after the first iteration.</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_verbose">verbose</code></td>
<td>
<p>Should information about the optimization progress be
displayed</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_accu_crit">accu_crit</code></td>
<td>
<p>Tolerance for the convergence of the outer optimization
procedure</p>
</td></tr>
<tr><td><code id="WH_1d_perf_+3A_accu_dev">accu_dev</code></td>
<td>
<p>Tolerance for the convergence of the optimization procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"WH_1d"</code> i.e. a list containing model fit,
variance, residuals and degrees of freedom as well as diagnosis to asses
the quality of the fit.
</p>

<hr>
<h2 id='WH_2d'>2D Whittaker-Henderson Smoothing</h2><span id='topic+WH_2d'></span>

<h3>Description</h3>

<p>Main package function to apply Whittaker-Henderson smoothing in a
bidimensional survival analysis framework. It takes as input a matrix of
observed events and a matrix of associated central exposure, both depending
on two covariates, and build a smooth version of the log-hazard rate.
Smoothing parameters may be supplied or automatically chosen according to a
specific criterion such as <code>"REML"</code> (the default), <code>"AIC"</code>, <code>"BIC"</code> or
<code>"GCV"</code>. Whittaker-Henderson may be applied in a full maximum likelihood
framework or an approximate gaussian framework. As Whittaker-Henderson
smoothing relies on full-rank smoothers, computation time and memory usage in
the bidimensional case may prove overwhelming and the function integrates a
rank-reduction procedure to avoid such issues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_2d(
  d,
  ec,
  lambda,
  criterion,
  method,
  max_dim = 200,
  p,
  q = c(2, 2),
  framework,
  y,
  wt,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_2d_+3A_d">d</code></td>
<td>
<p>Matrix of observed events, whose rows and columns must be named.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_ec">ec</code></td>
<td>
<p>Matrix of central exposure. The central exposure corresponds to the
sum of the exposure duration over the insured population. An individual
experiencing an event of interest during the year will no longer be exposed
afterward and the exposure should be computed accordingly.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_lambda">lambda</code></td>
<td>
<p>Smoothing parameter vector of size <code>2</code>. If missing, an
optimization procedure will be used to find the optimal smoothing
parameter. If supplied, no optimal smoothing parameter search will take
place unless the <code>method</code> argument is also supplied, in which case <code>lambda</code>
will be used as the starting parameter for the optimization procedure.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_criterion">criterion</code></td>
<td>
<p>Criterion to be used for the selection of the optimal
smoothing parameter. Default is <code>"REML"</code> which stands for restricted
maximum likelihood. Other options include <code>"AIC"</code>, <code>"BIC"</code> and <code>"GCV"</code>.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_method">method</code></td>
<td>
<p>Method to be used to find the optimal smoothing parameter.
Default to <code>"fixed_lambda"</code> if <code>lambda</code> is supplied, meaning no
optimization is performed. Otherwise, default to <code>"perf"</code> which means the
faster performance iteration method is used. The alternative <code>"outer"</code>
method is safer but slower. Both those methods rely on the <code>optim</code> function
from package <code>stats</code>.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_max_dim">max_dim</code></td>
<td>
<p>Number of parameters to be kept in the optimization problem.
Default is <code>200</code>. Values higher than <code>1000</code> may result in very high
computation times and memory usage.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_p">p</code></td>
<td>
<p>Optional vector of size <code>2</code>. Maximum number of eigenvectors to keep
on each dimension after performing the eigen decomposition of the
penalization matrix. If missing, will be automatically computed so that the
number of elements of the (square) matrices involved in the optimization
problem remains lower that the <code>max_dim</code> argument</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_q">q</code></td>
<td>
<p>Order of penalization vector of size <code>2</code>. Polynoms of degrees
<code style="white-space: pre;">&#8288;(q[[1]] - 1,q[[2]] - 1)&#8288;</code> are considered smooth and are therefore
unpenalized. Should be left to the default of <code>c(2,2)</code> for most practical
applications.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_framework">framework</code></td>
<td>
<p>Default framework is <code>"ml"</code> which stands for maximum
likelihood unless the <code>y</code> argument is also provided, in which case an
<code>"reg"</code> or (approximate) regression framework is used.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_y">y</code></td>
<td>
<p>Optional matrix of observations whose rows and columns should be
named. Used only in the regression framework and if the <code>d</code> and <code>ec</code>
arguments are missing (otherwise <code>y</code> is automatically computed from <code>d</code> and
<code>ec</code>). May be useful when using Whittaker-Henderson smoothing outside of
the survival analysis framework.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_wt">wt</code></td>
<td>
<p>Optional matrix of weights. As for the observation vector <code>y</code>, Used
only in the regression framework and if the <code>d</code> and <code>ec</code> arguments are
missing (otherwise <code>wt</code> is set equal to <code>d</code>). May be useful when using
Whittaker-Henderson smoothing outside of the survival analysis framework.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_quiet">quiet</code></td>
<td>
<p>Should messages and warnings be silenced ? Default to <code>FALSE</code>,
may be set to <code>TRUE</code> is the function is called repeatedly.</p>
</td></tr>
<tr><td><code id="WH_2d_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the smoothing function called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>WH_2d</code> i.e. a list containing :
</p>

<ul>
<li> <p><code>d</code> The inputed matrix of observed events (if supplied as input)
</p>
</li>
<li> <p><code>ec</code> The inputed matrix of central exposure (if supplied as input)
</p>
</li>
<li> <p><code>y</code> The observation matrix, either supplied or computed as y = log(d) - log(ec)
</p>
</li>
<li> <p><code>wt</code> The inputed matrix of weights, either supplied or set to <code>d</code>
</p>
</li>
<li> <p><code>y_hat</code> The matrix of values fitted using Whittaker-Henderson smoothing
</p>
</li>
<li> <p><code>std_y_hat</code> The matrix of standard deviations associated with the fit
</p>
</li>
<li> <p><code>res</code> The matrix of deviance residuals associated with the fit
</p>
</li>
<li> <p><code>edf_obs</code> The matrix of effective degrees of freedom associated with each observation
</p>
</li>
<li> <p><code>edf_par</code> The matrix of effective degrees of freedom associated with each eigenvector
</p>
</li>
<li> <p><code>diagnosis</code> A data.frame with one line containing the sum of effective degrees of freedom
for the model, the deviance of the fit as well as the AIC, BIC, GCV and
REML criteria
</p>
</li>
<li> <p><code>Psi</code> The variance-covariance matrix associated with the fit, which is required
for the extrapolation step.
</p>
</li>
<li> <p><code>lambda</code> The vector of smoothing parameters used.
</p>
</li>
<li> <p><code>p</code> The number of eigenvectors kept on each dimension if the rank reduction method
is used.
</p>
</li>
<li> <p><code>q</code> The supplied vector of orders for the penalization matrices.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>keep_age &lt;- which(rowSums(portfolio_LTC$ec) &gt; 5e2)
keep_duration &lt;- which(colSums(portfolio_LTC$ec) &gt; 1e3)

d  &lt;- portfolio_LTC$d[keep_age, keep_duration]
ec &lt;- portfolio_LTC$ec[keep_age, keep_duration]

y &lt;- log(d / ec) # observation vector
y[d == 0] &lt;- - 20
wt &lt;- d

# Maximum likelihood
WH_2d(d, ec, lambda = c(1e2, 1e2))
WH_2d(d, ec) # performance iteration default method
WH_2d(d, ec, method = "outer") # slower but safer outer iteration method
WH_2d(d, ec, criterion = "GCV")
# alternative optimization criteria for smoothing parameter selection

# Regression
WH_2d(y = y, wt = wt, lambda = c(1e2, 1e2)) # regression framework is triggered when y is supplied
WH_2d(d, ec, framework = "reg", lambda = c(1e2, 1e2))
# setting framework = "reg" forces computation of y from d and ec

# Rank reduction
keep_age &lt;- which(rowSums(portfolio_LTC$ec) &gt; 1e2)
keep_duration &lt;- which(colSums(portfolio_LTC$ec) &gt; 1e2)

d  &lt;- portfolio_LTC$d[keep_age, keep_duration]
ec &lt;- portfolio_LTC$ec[keep_age, keep_duration]

prod(dim(d)) # problem dimension is 627 !
WH_2d(d, ec)
# rank-reduction is used to find an approximate solution using 200 parameters

</code></pre>

<hr>
<h2 id='WH_2d_fixed_lambda'>2D Whittaker-Henderson Smoothing (Maximum Likelihood, fixed lambda)</h2><span id='topic+WH_2d_fixed_lambda'></span>

<h3>Description</h3>

<p>2D Whittaker-Henderson Smoothing (Maximum Likelihood, fixed lambda)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_2d_fixed_lambda(
  d,
  ec,
  y,
  wt,
  lambda = c(1000, 1000),
  q = c(2, 2),
  p,
  reg = FALSE,
  verbose = FALSE,
  accu_dev = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_2d_fixed_lambda_+3A_y">y</code></td>
<td>
<p>Matrix of observations</p>
</td></tr>
<tr><td><code id="WH_2d_fixed_lambda_+3A_wt">wt</code></td>
<td>
<p>Optional matrix of weights</p>
</td></tr>
<tr><td><code id="WH_2d_fixed_lambda_+3A_lambda">lambda</code></td>
<td>
<p>Vector of smoothing parameter</p>
</td></tr>
<tr><td><code id="WH_2d_fixed_lambda_+3A_q">q</code></td>
<td>
<p>Matrix of orders of penalization. Polynoms of degrees q - 1 are considered
smooth and are therefore unpenalized</p>
</td></tr>
<tr><td><code id="WH_2d_fixed_lambda_+3A_p">p</code></td>
<td>
<p>The number of eigenvectors to keep on each dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"WH_2d"</code> i.e. a list containing model fit,
variance, residuals and degrees of freedom as well as diagnosis to asses
the quality of the fit.
</p>

<hr>
<h2 id='WH_2d_outer'>2D Whittaker-Henderson Smoothing (Maximum Likelihood, optim function)</h2><span id='topic+WH_2d_outer'></span>

<h3>Description</h3>

<p>2D Whittaker-Henderson Smoothing (Maximum Likelihood, optim function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_2d_outer(
  d,
  ec,
  y,
  wt,
  q = c(2, 2),
  p,
  criterion = "REML",
  lambda = c(1000, 1000),
  reg = FALSE,
  verbose = FALSE,
  accu_crit = 1e-12,
  accu_dev = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_2d_outer_+3A_d">d</code></td>
<td>
<p>Vector of observed events</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_ec">ec</code></td>
<td>
<p>Vector of central exposure</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_y">y</code></td>
<td>
<p>Vector of observations</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_wt">wt</code></td>
<td>
<p>Optional vector of weights</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_q">q</code></td>
<td>
<p>Order of penalization. Polynoms of degrees q - 1 are considered
smooth and are therefore unpenalized</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_p">p</code></td>
<td>
<p>The number of eigenvectors to keep</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_criterion">criterion</code></td>
<td>
<p>Criterion used to choose the smoothing parameter. One of
&quot;GCV&quot; (default), &quot;AIC&quot; or &quot;BIC&quot;.</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_lambda">lambda</code></td>
<td>
<p>Initial smoothing parameters</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_reg">reg</code></td>
<td>
<p>Should the regression framework be used ? Boolean. If <code>TRUE</code>, will
stop after the first iteration.</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_verbose">verbose</code></td>
<td>
<p>Should information about the optimization progress be
displayed</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_accu_crit">accu_crit</code></td>
<td>
<p>Tolerance for the convergence of the outer optimization
procedure</p>
</td></tr>
<tr><td><code id="WH_2d_outer_+3A_accu_dev">accu_dev</code></td>
<td>
<p>Tolerance for the convergence of the optimization procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"WH_2d"</code> i.e. a list containing model fit,
variance, residuals and degrees of freedom as well as diagnosis to asses
the quality of the fit.
</p>

<hr>
<h2 id='WH_2d_perf'>2D Whittaker-Henderson Smoothing (Maximum Likelihood, Generalized Fellner-Schall update)</h2><span id='topic+WH_2d_perf'></span>

<h3>Description</h3>

<p>2D Whittaker-Henderson Smoothing (Maximum Likelihood, Generalized Fellner-Schall update)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WH_2d_perf(
  d,
  ec,
  y,
  wt,
  q = c(2, 2),
  p,
  criterion = "REML",
  lambda = c(1000, 1000),
  reg = FALSE,
  verbose = FALSE,
  accu_crit = 1e-12,
  accu_dev = 1e-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH_2d_perf_+3A_d">d</code></td>
<td>
<p>Vector of observed events</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_ec">ec</code></td>
<td>
<p>Vector of central exposure</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_y">y</code></td>
<td>
<p>Vector of observations</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_wt">wt</code></td>
<td>
<p>Optional vector of weights</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_q">q</code></td>
<td>
<p>Order of penalization. Polynoms of degrees q - 1 are considered
smooth and are therefore unpenalized</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_p">p</code></td>
<td>
<p>The number of eigenvectors to keep</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_criterion">criterion</code></td>
<td>
<p>Criterion used to choose the smoothing parameter. One of
&quot;GCV&quot; (default), &quot;AIC&quot; or &quot;BIC&quot;.</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_lambda">lambda</code></td>
<td>
<p>Initial smoothing parameters</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_reg">reg</code></td>
<td>
<p>Should the regression framework be used ? Boolean. If <code>TRUE</code>, will
stop after the first iteration.</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_verbose">verbose</code></td>
<td>
<p>Should information about the optimization progress be
displayed</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_accu_crit">accu_crit</code></td>
<td>
<p>Tolerance for the convergence of the outer optimization
procedure</p>
</td></tr>
<tr><td><code id="WH_2d_perf_+3A_accu_dev">accu_dev</code></td>
<td>
<p>Tolerance for the convergence of the optimization procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"WH_2d"</code> i.e. a list containing model fit,
variance, residuals and degrees of freedom as well as diagnosis to asses
the quality of the fit.
</p>

<hr>
<h2 id='WH-package'>WH : Enhanced Implementation of Whittaker-Henderson Smoothing</h2><span id='topic+WH-package'></span>

<h3>Description</h3>

<p>An enhanced implementation of Whittaker-Henderson smoothing for the gradation
of one-dimensional and two-dimensional actuarial tables used to quantify Life
Insurance risks. <code>WH</code> is based on the methods described in Biessy (2023)
<a href="doi:10.48550/arXiv.2306.06932">doi:10.48550/arXiv.2306.06932</a>. Among other features, it generalizes the
original smoothing algorithm to maximum likelihood estimation, automatically
selects the smoothing parameter(s) and extrapolates beyond the range of data.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
