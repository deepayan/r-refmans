<!DOCTYPE html><html><head><title>Help for package minerva</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {minerva}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#minerva-package'><p>The minerva package</p></a></li>
<li><a href='#cstats'><p>Compute statistics (MIC and normalized TIC) between each pair of the two</p>
collections of variables (convenience function).
If n and m are the number of variables in X and Y respectively, then the
statistic between the (row) i (for X) and j (for Y) is stored in <code>mic[i, j]</code>
and <code>tic[i, j]</code>.</a></li>
<li><a href='#mic_strength'><p>Compute the association strengh</p></a></li>
<li><a href='#mictools'><p>Function that implements the <code>mictools</code> pipeline.</p>
In particular it computes the null and observed distribution of the <code>tic_e</code> measure</a></li>
<li><a href='#mictools_null'><p>This set of functions are helper function to compute null distribution of the <code>tic_e</code> and</p>
<code>tic_e</code> observed distribution from a matrix</a></li>
<li><a href='#mine'><p>MINE family statistics</p>
Maximal Information-Based Nonparametric Exploration (MINE)
statistics. <code>mine</code> computes the MINE family measures between two variables.</a></li>
<li><a href='#mine_stat'><p>This is an helper function to compute one <code>mine</code> statistic.</p>
It take two vectors of the same dimension as an input.</a></li>
<li><a href='#pstats'><p>Compute pairwise statistics (MIC and normalized TIC) between variables</p>
(convenience function).</a></li>
<li><a href='#Spellman'><p>CDC15 Yeast Gene Expression Dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-06-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Maximal Information-Based Nonparametric Exploration for Variable
Analysis</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, Rcpp, stats, graphics</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Wrapper for 'minepy' implementation of Maximal
        Information-based Nonparametric Exploration statistics (MIC and
        MINE family). Detailed information of the ANSI C implementation of
	'minepy' can be found at <a href="http://minepy.readthedocs.io/en/latest">http://minepy.readthedocs.io/en/latest</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>, <a href="http://minepy.readthedocs.io/en/latest">http://minepy.readthedocs.io/en/latest</a>,
<a href="http://www.exploredata.net">http://www.exploredata.net</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-16 15:41:57 UTC; michele</td>
</tr>
<tr>
<td>Author:</td>
<td>Michele Filosi [aut, cre],
  Roberto Visintainer [aut],
  Davide Albanese [aut],
  Samantha Riccadonna [ctb],
  Giuseppe Jurman [ctb],
  Cesare Furlanello [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michele Filosi &lt;michele.filosi@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-17 07:10:05 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
</table>
<hr>
<h2 id='minerva-package'>The minerva package</h2><span id='topic+minerva-package'></span><span id='topic+minerva'></span>

<h3>Description</h3>

<p>Maximal Information-Based Nonparametric Exploration R Package for 
Variable Analysis. The package provides the <code><a href="#topic+mine">mine</a></code> function
allowing the computation of Maximal Information-based Nonparametric
Exploration statistics, firstly introduced in D. Reshef et al. (2011)
<em>Detecting novel associations in large datasets</em>. Science 334,
6062 (<a href="http://www.exploredata.net">http://www.exploredata.net</a>). In particular, the package
is an R wrapper for the C engine <em>cmine</em>
(<a href="http://minepy.readthedocs.io/en/latest/">http://minepy.readthedocs.io/en/latest/</a>).  </p>


<h3>Details</h3>

<p>Summary:
</p>

<table>
<tr>
 <td style="text-align: left;">
  Package: </td><td style="text-align: left;"> minerva</td>
</tr>
<tr>
 <td style="text-align: left;">
  Version: </td><td style="text-align: left;"> 1.4.3</td>
</tr>
<tr>
 <td style="text-align: left;">
  Date: </td><td style="text-align: left;"> 2014-10-08</td>
</tr>
<tr>
 <td style="text-align: left;">
  Depends: </td><td style="text-align: left;"> R &gt;= (2.14.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
  Enshances: </td><td style="text-align: left;"> parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
  URL: </td><td style="text-align: left;"> http://www.r-project.org, </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> http://minepy.readthedocs.io/en/latest/, </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td><td style="text-align: left;"> http://www.exploredata.net</td>
</tr>
<tr>
 <td style="text-align: left;">
  License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Index:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+Spellman">Spellman</a></code> </td><td style="text-align: left;"> Yeast Gene Expression Dataset</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+mine">mine</a></code> </td><td style="text-align: left;"> MINE-family statistics</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+minerva-package">minerva-package</a></code> </td><td style="text-align: left;"> The minerva package</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Michele Filosi [aut, cre],
Roberto Visintainer [aut],
Davide Albanese [aut],
Samantha Riccadonna [ctb],
Giuseppe Jurman [ctb],
Cesare Furlanello [ctb]
</p>
<p>Maintainer: Michele Filosi &lt;filosi@fbk.eu&gt;
</p>


<h3>References</h3>

<p>D. Reshef, Y. Reshef, H. Finucane, S. Grossman, G. McVean, P. Turnbaugh, 
E. Lander, M. Mitzenmacher, P. Sabeti. (2011)
<em>Detecting novel associations in large datasets</em>. 
Science 334, 6062  
(<a href="http://www.exploredata.net">http://www.exploredata.net</a>).
</p>
<p>D. Albanese, M. Filosi, R. Visintainer, S. Riccadonna, G. Jurman,
C. Furlanello. <em>cmine, minerva &amp; minepy: a C engine for the
MINE suite an its R and Python wrappers.</em>
<a href="http://minepy.readthedocs.io/en/latest/">http://minepy.readthedocs.io/en/latest/</a>  
</p>
<p><em>minepy. Maximal Information-based Nonparametric Exploration
in C and Python.</em><br /> 
(<a href="http://minepy.sourceforge.net">http://minepy.sourceforge.net</a>)
</p>

<hr>
<h2 id='cstats'>Compute statistics (MIC and normalized TIC) between each pair of the two
collections of variables (convenience function).
If n and m are the number of variables in X and Y respectively, then the
statistic between the (row) i (for X) and j (for Y) is stored in <code>mic[i, j]</code>
and <code>tic[i, j]</code>.</h2><span id='topic+cstats'></span>

<h3>Description</h3>

<p>Compute statistics (MIC and normalized TIC) between each pair of the two
collections of variables (convenience function).
If n and m are the number of variables in X and Y respectively, then the
statistic between the (row) i (for X) and j (for Y) is stored in <code>mic[i, j]</code>
and <code>tic[i, j]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cstats(x, y, alpha = 0.6, C = 15, est = "mic_approx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cstats_+3A_x">x</code></td>
<td>
<p>Numeric Matrix of m-by-n with n variables and m samples.</p>
</td></tr>
<tr><td><code id="cstats_+3A_y">y</code></td>
<td>
<p>Numeric Matrix of m-by-p with p variables and m samples.</p>
</td></tr>
<tr><td><code id="cstats_+3A_alpha">alpha</code></td>
<td>
<p>number (0, 1.0] or &gt;=4 if alpha is in (0,1] then B will be max(n^alpha, 4) where n is the
number of samples. If alpha is &gt;=4 then alpha defines directly the B
parameter. If alpha is higher than the number of samples (n) it will be
limited to be n, so B = min(alpha, n).</p>
</td></tr>
<tr><td><code id="cstats_+3A_c">C</code></td>
<td>
<p>number (&gt; 0) determines how many more clumps there will be than columns in
every partition. Default value is 15, meaning that when trying to
draw x grid lines on the x-axis, the algorithm will start with at
most 15*x clumps.</p>
</td></tr>
<tr><td><code id="cstats_+3A_est">est</code></td>
<td>
<p>string (&quot;mic_approx&quot;, &quot;mic_e&quot;) estimator. 
With est=&quot;mic_approx&quot; the original MINE statistics will
be computed, with est=&quot;mic_e&quot; the equicharacteristic matrix is
is evaluated and MIC_e and TIC_e are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two elements:
MIC: the MIC statistic matrix (n x p).
TIC: the normalized TIC statistic matrix (n x p).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rnorm(2560), ncol=8, nrow=320)
y &lt;- matrix(rnorm(1280), ncol=4, nrow=320)

mictic &lt;- cstats(x, y, alpha=9, C=5, est="mic_e")
head(mictic)

</code></pre>

<hr>
<h2 id='mic_strength'>Compute the association strengh</h2><span id='topic+mic_strength'></span>

<h3>Description</h3>

<p>This function uses the null distribution of the <code>tic_e</code> computed with the function <code><a href="#topic+mictools">mictools</a></code>. 
Based on the available pvalue and the permutation null distribution it identifies reliable association between variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mic_strength(x, pval, alpha = NULL, C = 5, pthr = 0.05, pval.col = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mic_strength_+3A_x">x</code></td>
<td>
<p>a numeric matrix with N samples on the rows and M variables on the columns (NxM).</p>
</td></tr>
<tr><td><code id="mic_strength_+3A_pval">pval</code></td>
<td>
<p>a data.frame with pvalues for each pair of association of the <code>x</code> input matrix. It should contain two colums with 
the indices of the computed association according to the x input matrix</p>
</td></tr>
<tr><td><code id="mic_strength_+3A_alpha">alpha</code></td>
<td>
<p>float (0, 1.0] or &gt;=4 if alpha is in (0,1] then B will be max(n^alpha, 4) where n is the
number of samples. If alpha is &gt;=4 then alpha defines directly the B
parameter. If alpha is higher than the number of samples (n) it will be
limited to be n, so B = min(alpha, n) Default value is 0.6 (see Details).</p>
</td></tr>
<tr><td><code id="mic_strength_+3A_c">C</code></td>
<td>
<p>a positive integer number, the <code>C</code> parameter of the <code>mine</code> statistic. 
See <code><a href="#topic+mine">mine</a></code> function for further details.</p>
</td></tr>
<tr><td><code id="mic_strength_+3A_pthr">pthr</code></td>
<td>
<p>threshold on pvalue for measure to consider for computing mic_e</p>
</td></tr>
<tr><td><code id="mic_strength_+3A_pval.col">pval.col</code></td>
<td>
<p>an integer or character or vector relative to the columns of <code>pval</code> dataframe respectively for <code>pvalue</code>, 
association between variable 1, variable 2 in the <code>x</code> input matrix. See Details for further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method implemented here is a wrapper for the original method published by Albanese et al. (2018). The python version
is available at <a href="https://github.com/minepy/mictools">https://github.com/minepy/mictools</a>.
</p>
<p>This function should be called after the estimation of the null distribution of <code>tic_e</code> scores based on permutations of the input data.
</p>
<p>The <code>mic</code> association is computed only for the variables for which the pvalue in the <code>pval</code> <code>data.frame</code> is less then 
the threshold set with the <code>pthr</code> input parameter. 
We assume the first column of the <code>pval</code> <code>data.frame</code> contains the pvalue, this value can be changed using 
the <code>pval.col</code>[1] parameter. 
</p>
<p>The <code>pval.col</code> parameter, by default takes the first three columns in the <code>pval</code> <code>data.frame</code>, in particular the first column containing the <code>pvalues</code> 
of the association between variable in column <code>pval.col[2]</code> and <code>pval.col[3]</code>.
If a character vector is provided names in <code>pval.col</code> are matched with the names in <code>pval</code> <code>data.frame</code>.
If <code>NULL</code> is passed it is assumed the first column contains pvalue, while the 2 and 3 the index or name of the variable in <code>x</code>.
If one value is passed it refers to the <code>pvalue</code> column and the consecutive two columns are assume to contain variable indexes.
</p>


<h3>Value</h3>

<p>A dataframe with the <code>tic_e</code> Pvalue, the <code>mic</code> value and the column identifier regarding the input matrix
<code>x</code> of the variables of which the association is computed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mine">mine</a></code>, <code><a href="#topic+mictools">mictools</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Spellman)
mydata &lt;- as.matrix(Spellman[, 10:20])
ticenull &lt;- mictools(mydata, nperm=1000)

## Use the nominal pvalue:
ms &lt;- mic_strength(mydata, pval=ticenull$pval, alpha=NULL, pval.col = c(1, 4,5))

## Use the adjusted pvalue:
ms &lt;- mic_strength(mydata, pval=ticenull$pval, alpha=NULL, pval.col = c(6, 4,5))

ms 

## Not run: 
## Use qvalue
require(qvalue)
qobj &lt;- qvalue(ticenull$pval$pval)
ticenull$pval$qvalue &lt;- qobj$qvalue
ms &lt;- mic_strength(mydata, pval=ticenull$pval, alpha=NULL, pval.col = c("qvalue", "Var1", "Var2"))

## Get the data from mictools repository

lnf &lt;- "https://raw.githubusercontent.com/minepy/mictools/master/examples/datasaurus.txt"
datasaurus &lt;- read.table(lnf, header=TRUE, row.names = 1, stringsAsFactors = FALSE)
datasaurus &lt;- t(datasaurus)
ticenull &lt;- mictools(datasaurus, nperm=200000)
micres &lt;- mic_strength(mydata, ticenull$pval, pval.col=c(6, 4, 5))

## Plot distribution of pvalues
hist(ticenull$pval, breaks=50, freq=FALSE)

## Plot distribution of tic_e values
hist(ticenull$tic)

## Correct pvalues using qvalue package
require(qvalue)
require(ggplot2)
qobj &lt;- qvalue(ticenull$pval$pval)
ticenull$pval$qvalue &lt;- qobj$qvalue
micres &lt;- mic_strength(datasaurus, ticenull$pval, pval.col=c("qvalue", "Var1", "Var2"))

hist(qobj$qvalue)

df &lt;- data.frame(pi0.labmda=qobj$pi0.lambda, lambda=qobj$lambda, pi0.smooth=qobj$pi0.smooth)
gp0 &lt;- ggplot(df, aes(lambda, pi0.labmda)) + geom_point() 
gp0 &lt;- gp0 + geom_line(aes(lambda, pi0.smooth))
gp0 &lt;- gp0 + geom_hline(yintercept = qobj$pi0, linetype="dashed", col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='mictools'>Function that implements the <code>mictools</code> pipeline.
In particular it computes the null and observed distribution of the <code>tic_e</code> measure</h2><span id='topic+mictools'></span>

<h3>Description</h3>

<p>Function that implements the <code>mictools</code> pipeline.
In particular it computes the null and observed distribution of the <code>tic_e</code> measure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mictools(x, alpha = 9, C = 5, seed = 0, nperm = 2e+05, p.adjust.method = "BH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mictools_+3A_x">x</code></td>
<td>
<p>a numeric matrix with N samples on the rows and M variables on the columns (NxM).</p>
</td></tr>
<tr><td><code id="mictools_+3A_alpha">alpha</code></td>
<td>
<p>float (0, 1.0] or &gt;=4 if alpha is in (0,1] then B will be max(n^alpha, 4) where n is the
number of samples. If alpha is &gt;=4 then alpha defines directly the B
parameter. If alpha is higher than the number of samples (n) it will be
limited to be n, so B = min(alpha, n) Default value is 0.6 (see Details).</p>
</td></tr>
<tr><td><code id="mictools_+3A_c">C</code></td>
<td>
<p>a positive integer number, the <code>C</code> parameter of the <code>mine</code> statistic. 
See <code><a href="#topic+mine">mine</a></code> function for further details.</p>
</td></tr>
<tr><td><code id="mictools_+3A_seed">seed</code></td>
<td>
<p>seed for random number generation reproducibility</p>
</td></tr>
<tr><td><code id="mictools_+3A_nperm">nperm</code></td>
<td>
<p>integer, number of permutation to perform</p>
</td></tr>
<tr><td><code id="mictools_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method for pvalue adjustment, see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> for available methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function to implement the 'mictools' pipeline.
Differently from the python pipeline available on github we consider a data matrix of NxM with N samples by rows 
and M variables by columns as standard for R.
</p>


<h3>Value</h3>

<p>A list of 5 named elements containing the following information of the computed statistic:
</p>

<dl>
<dt>tic</dt><dd><p>This is a vector with the null distribution of tic_e values based on the permutation.</p>
</dd>
<dt>nulldist</dt><dd><p>Null distribution of the <code>tic_e</code> measure. It is a <code>data.frame</code> of 4 columns
containing the histogram of the distribution of <code>tic_e</code> for each bin delimited by <code>BinStart</code> 
and <code>BinEnd</code>, the count for each bin <code>NullCount</code> and the cumulative distribution 
of the right tail area <code>NullCumSum</code></p>
</dd>
<dt>obstic</dt><dd><p><code>data.frame</code> with the observed <code>tic_e</code> values, the indexes of the variables between the tic is computed. 
If the input matrix has column names then the names are reported in the dataframe, otherwise &quot;Var&lt;i&gt;&quot; is added for each variable.</p>
</dd>
<dt>obsdists</dt><dd><p><code>data.frame</code> similar to <code>nulldist</code> but with observed values of <code>tic_e</code></p>
</dd>
<dt>pval</dt><dd><p>data.frame with the pvalue computed for each comparison. The adjusted pvalue is also reported based 
on the method chosen with the parameter <code>p.adjust.method</code></p>
</dd>
</dl>



<h3>References</h3>

<p>D. Albanese, S. Riccadonna, C. Donati, P. Franceschi (2018)
_A practical tool for Maximal Information Coefficient Analysis_
GigaScience, 7, 4, doi: <a href="https://doi.org/10.1093/gigascience/giy032">10.1093/gigascience/giy032</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+p.adjust">p.adjust</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="#topic+mine">mine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Spellman)
Spellman &lt;- as.matrix(Spellman)
spellress &lt;- mictools(Spellman[, 10:20], nperm=1000)

## Use a different pvalue correction method
spellressb &lt;- mictools(Spellman[,10:20], nperm=1000, seed=1234, p.adjust.method="bonferroni")

## Distribution of tic_e null
hist(spellress$tic, breaks=100, main="Tic_e null distribution")
barplot(spellress$nulldist$NullCount)

## Distribution of the observed tic
hist(spellress$obstic$TIC)
barplot(spellress$obsdist$Count)

## Distribution of empirical pvalues
hist(spellress$pval$pval, breaks=50)

</code></pre>

<hr>
<h2 id='mictools_null'>This set of functions are helper function to compute null distribution of the <code>tic_e</code> and 
<code>tic_e</code> observed distribution from a matrix</h2><span id='topic+mictools_null'></span>

<h3>Description</h3>

<p>This set of functions are helper function to compute null distribution of the <code>tic_e</code> and 
<code>tic_e</code> observed distribution from a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mictools_null(x, alpha = 9, C = 5, nperm = 200000L, seed = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mictools_null_+3A_x">x</code></td>
<td>
<p>matrix N x M with M variables and N samples</p>
</td></tr>
<tr><td><code id="mictools_null_+3A_alpha">alpha</code></td>
<td>
<p>numeric value representing parameter for the mine statistic see <code><a href="#topic+mine">mine</a></code></p>
</td></tr>
<tr><td><code id="mictools_null_+3A_c">C</code></td>
<td>
<p>c parameter for the mine statistic see <code><a href="#topic+mine">mine</a></code></p>
</td></tr>
<tr><td><code id="mictools_null_+3A_nperm">nperm</code></td>
<td>
<p>numper of permutation</p>
</td></tr>
<tr><td><code id="mictools_null_+3A_seed">seed</code></td>
<td>
<p>integer to set the starting seed for random number generation (for reproducibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It returns a vector of <code>nperm</code> <code>tic_e</code> values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mictools_null</code>: compute the <code>tic_e</code> null distribution
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+mictools">mictools</a></code>
</p>

<hr>
<h2 id='mine'>MINE family statistics
Maximal Information-Based Nonparametric Exploration (MINE) 
statistics. <code>mine</code> computes the MINE family measures between two variables.</h2><span id='topic+mine'></span><span id='topic+MINE'></span><span id='topic+MIC-R2'></span><span id='topic+mic-r2'></span>

<h3>Description</h3>

<p>MINE family statistics
Maximal Information-Based Nonparametric Exploration (MINE) 
statistics. <code>mine</code> computes the MINE family measures between two variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mine(
  x,
  y = NULL,
  master = NULL,
  alpha = 0.6,
  C = 15,
  n.cores = 1,
  var.thr = 1e-05,
  eps = NULL,
  est = "mic_approx",
  na.rm = FALSE,
  use = "all.obs",
  normalization = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mine_+3A_x">x</code></td>
<td>
<p>a numeric vector (of size <em>n</em>), matrix or data frame (which is coerced to matrix).</p>
</td></tr>
<tr><td><code id="mine_+3A_y">y</code></td>
<td>
<p>NULL (default) or a numeric vector of size <em>n</em> (<em>i.e.</em>, with compatible dimensions to x).</p>
</td></tr>
<tr><td><code id="mine_+3A_master">master</code></td>
<td>
<p>an optional vector of indices (numeric or character) to
be given when <code>y</code> is not set, otherwise master is ignored. It can be 
either one column index to be used as reference for the comparison 
(versus all other columns) or a vector of column indices to be used for 
computing all mutual statistics.</p>
</td></tr>
<tr><td><code id="mine_+3A_alpha">alpha</code></td>
<td>
<p>float (0, 1.0] or &gt;=4 if alpha is in (0,1] then B will be max(n^alpha, 4) where n is the
number of samples. If alpha is &gt;=4 then alpha defines directly the B
parameter. If alpha is higher than the number of samples (n) it will be
limited to be n, so B = min(alpha, n) Default value is 0.6 (see Details).</p>
</td></tr>
<tr><td><code id="mine_+3A_c">C</code></td>
<td>
<p>an optional number determining the starting point of the 
<em>X-by-Y</em> search-grid. When trying to partition the <em>x</em>-axis into 
<em>X</em> columns, the algorithm will start with at most <code>C</code><em>X</em> 
<em>clumps</em>. Default value is 15 (see Details).</p>
</td></tr>
<tr><td><code id="mine_+3A_n.cores">n.cores</code></td>
<td>
<p>ooptional number of cores to be used in the
computations, when master is specified. It requires the
<span class="pkg">parallel</span> package, which provides support for parallel 
computing, released with <span class="rlang"><b>R</b></span> &gt;= 2.14.0. Defaults is 1 (<em>i.e.</em>, not performing parallel computing).</p>
</td></tr>
<tr><td><code id="mine_+3A_var.thr">var.thr</code></td>
<td>
<p>minimum value allowed for the variance of the input
variables, since <code>mine</code> can not be computed in case of variance
close to 0. Default value is 1e-5. Information about failed check
are reported in <em>var_thr.log</em> file.</p>
</td></tr>
<tr><td><code id="mine_+3A_eps">eps</code></td>
<td>
<p>integer in [0,1].  If 'NULL' (default) it is set to
1-MIC. It can be set to zero for noiseless functions,
but the default choice is the most appropriate parametrization
for general cases (as stated in Reshef et al. SOM).
It provides robustness.</p>
</td></tr>
<tr><td><code id="mine_+3A_est">est</code></td>
<td>
<p>Default value is &quot;mic_approx&quot;. With est=&quot;mic_approx&quot; the original MINE statistics will
be computed, with est=&quot;mic_e&quot; the equicharacteristic matrix is
is evaluated and the mic() and tic() methods will return MIC_e and
TIC_e values respectively.</p>
</td></tr>
<tr><td><code id="mine_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean. This variable is passed directly to the
<code>cor</code>-based functions. See <code>cor</code> for further details.</p>
</td></tr>
<tr><td><code id="mine_+3A_use">use</code></td>
<td>
<p>Default value is &quot;all.obs&quot;. This variable is passed directly to the 
<code>cor</code>-based functions. See <code>cor</code> for further details.</p>
</td></tr>
<tr><td><code id="mine_+3A_normalization">normalization</code></td>
<td>
<p>logical whether to use normalization when computing <code>tic</code> measure. Ignored for other measures.
Default to FALSE.</p>
</td></tr>
<tr><td><code id="mine_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mine</code> is an R wrapper for the C engine <em>cmine</em> 
(<a href="http://minepy.readthedocs.io/en/latest/">http://minepy.readthedocs.io/en/latest/</a>), 
an implementation of Maximal Information-Based Nonparametric Exploration (MINE) 
statistics. The MINE statistics were firstly detailed in 
D. Reshef et al. (2011) <em>Detecting novel associations in large datasets</em>. 
Science 334, 6062 (<a href="http://www.exploredata.net">http://www.exploredata.net</a>).
</p>
<p>Here we recall the main concepts of the MINE family statistics.
Let <code class="reqn">D={(x,y)}</code> be the set of <em>n</em> ordered pairs of elements of <code>x</code>
and <code>y</code>. The data space is partitioned in 
an <em>X-by-Y</em> grid, grouping the <em>x</em> and <em>y</em> values 
in <em>X</em> and <em>Y</em> bins respectively.<br />
</p>
<p>The <strong>Maximal Information Coefficient (MIC)</strong> is defined as 
</p>
<p style="text-align: center;"><code class="reqn">\textrm{MIC}(D)=\max_{XY&lt;B(n)} M(D)_{X,Y} = \max_{XY&lt;B(n)} \frac{I^*(D,X,Y)}{log(\min{X,Y})},</code>
</p>
<p> where
<code class="reqn">B(n)=n^{\alpha}</code> is the search-grid size,
<code class="reqn">I^*(D,X,Y)</code>
is the maximum mutual information over all grids <em>X-by-Y</em>, of the distribution induced by D on 
a grid having <em>X</em> and <em>Y</em> bins (where the probability mass on a cell 
of the grid is the fraction of points of D falling in that cell).
The other statistics of the MINE family are derived from the mutual information 
matrix achieved by an <em>X-by-Y</em> grid on D.<br />
</p>
<p>The <strong>Maximum Asymmetry Score (MAS)</strong> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\textrm{MAS}(D) = \max_{XY&lt;B(n)} |M(D)_{X,Y} - M(D)_{Y,X}|.</code>
</p>

<p>The <strong>Maximum Edge Value (MEV)</strong> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\textrm{MEV}(D) = \max_{XY&lt;B(n)} \{M(D)_{X,Y}: X=2~or~Y=2\}.</code>
</p>

<p>The <strong>Minimum Cell Number (MCN)</strong> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\textrm{MCN}(D,\epsilon) = \min_{XY&lt;B(n)} \{\log(XY): M(D)_{X,Y} \geq (1-\epsilon)MIC(D)\}.</code>
</p>

<p>More details are provided in the supplementary material (SOM) of the original paper.
</p>
<p>The MINE statistics can be computed for two numeric vectors <code>x</code> and <code>y</code>. 
Otherwise a matrix (or data frame) can be provided and two options are available 
according to the value of <code>master</code>. If <code>master</code> is a column identifier, 
then the MINE statistics are computed for the <em>master</em> variable versus the 
other matrix columns. If <code>master</code> is a set of column identifiers, then all 
mutual MINE statistics are computed among the column subset.
<code>master</code>, <code>alpha</code>, and <code>C</code> refers respectively to the <em>style</em>,
<em>exp</em>, and <em>c</em> parameters of the original <em>java</em> code. 
In the original article, the authors state that the default value <code class="reqn">\alpha=0.6</code> 
(which is the exponent of the search-grid size <code class="reqn">B(n)=n^{\alpha}</code>) has been 
empirically chosen. It is worthwhile noting that <code>alpha</code> and <code>C</code> are 
defined to obtain an heuristic approximation in a reasonable amount of time. In case
of small sample size (<em>n</em>) it is preferable to increase <code>alpha</code> to 1 to 
obtain a solution closer to the theoretical one.
</p>


<h3>Value</h3>

<p>The Maximal Information-Based Nonparametric Exploration (MINE) statistics 
provide quantitative evaluations of different aspects of the relationship 
between two variables. 
In particular <code>mine</code> returns a list of 5 statistics: 
</p>
<table>
<tr><td><code>MIC</code></td>
<td>
 <p><strong>Maximal Information Coefficient.</strong> <br /> 
It is related to the relationship strenght and it can be interpreted as a 
correlation measure. It is symmetric and it ranges in [0,1], where it 
tends to 0 for statistically independent data and it approaches 1 in 
probability for noiseless functional relationships (more details can 
ben found in the original paper). </p>
</td></tr>
<tr><td><code>MAS</code></td>
<td>
 <p><strong>Maximum Asymmetry Score.</strong> <br /> 
It captures the deviation from monotonicity. Note that 
<code class="reqn">\textrm{MAS} &lt; \textrm{MIC}</code>. <br />
<em>Note:</em> it can be useful for detecting periodic relationships 
(unknown frequencies). </p>
</td></tr>
<tr><td><code>MEV</code></td>
<td>
 <p><strong>Maximum Edge Value.</strong> <br /> 
It measures the closeness to being a function. Note that 
<code class="reqn">\textrm{MEV} \leq \textrm{MIC}</code>. </p>
</td></tr>
<tr><td><code>MCN</code></td>
<td>
 <p><strong>Minimum Cell Number.</strong> <br /> 
It is a complexity measure. </p>
</td></tr>
<tr><td><code>MIC-R2</code></td>
<td>
<p>It is the difference between the MIC value and the Pearson
correlation coefficient. </p>
</td></tr> </table>
<p><br />
</p>
<p>When computing <code>mine</code> between two numeric vectors <code>x</code> and <code>y</code>, 
the output is a list of 5 numeric values. When <code>master</code> is provided, 
<code>mine</code> returns a list of 5 matrices having <code>ncol</code> equal to 
<em>m</em>. In particular, if <code>master</code> is a single value, 
then <code>mine</code> returns a list of 5 matrices having 1 column, 
whose rows correspond to the MINE measures between the <em>master</em> 
column versus all. Instead if <code>master</code> is a vector of <em>m</em> indices,
then <code>mine</code> output is a list of 5 <em>m-by-m</em> matrices, whose element 
<em>i,j</em> corresponds to the MINE statistics computed between the <em>i</em> 
and <em>j</em> columns of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Michele Filosi and Roberto Visintainer
</p>


<h3>References</h3>

<p>D. Reshef, Y. Reshef, H. Finucane, S. Grossman, G. McVean, P. Turnbaugh, 
E. Lander, M. Mitzenmacher, P. Sabeti. (2011)
<em>Detecting novel associations in large datasets</em>. 
Science 334, 6062<br />
<a href="http://www.exploredata.net">http://www.exploredata.net</a><br />
(SOM: Supplementary Online Material at
<a href="https://science.sciencemag.org/content/suppl/2011/12/14/334.6062.1518.DC1">https://science.sciencemag.org/content/suppl/2011/12/14/334.6062.1518.DC1</a>)
</p>
<p>D. Albanese, M. Filosi, R. Visintainer, S. Riccadonna, G. Jurman,
C. Furlanello. 
<em>minerva and minepy: a C engine for the MINE suite and its R, Python and MATLAB wrappers</em>. 
Bioinformatics (2013) 29(3): 407-408, doi: <a href="https://doi.org/10.1093/bioinformatics/bts707">10.1093/bioinformatics/bts707</a>.<br />
</p>
<p><em>minepy. Maximal Information-based Nonparametric Exploration in C and Python.</em><br /> 
<a href="http://minepy.sourceforge.net">http://minepy.sourceforge.net</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(runif(50),nrow=5)
mine(x=A, master=1)
mine(x=A, master=c(1,3,5,7,8:10))

x &lt;- runif(10); y &lt;- 3*x+2; plot(x,y,type="l")
mine(x,y)
# MIC = 1 
# MAS = 0
# MEV = 1
# MCN = 2
# MIC-R2 = 0

set.seed(100); x &lt;- runif(10); y &lt;- 3*x+2+rnorm(10,mean=2,sd=5); plot(x,y)
mine(x,y)
# rounded values of MINE statistics
# MIC = 0.61
# MAS = 0
# MEV = 0.61
# MCN = 2
# MIC-R2 = 0.13

t &lt;-seq(-2*pi,2*pi,0.2); y1 &lt;- sin(2*t); plot(t,y1,type="l")
mine(t,y1)
# rounded values of MINE statistics
# MIC = 0.66 
# MAS = 0.37
# MEV = 0.66
# MCN = 3.58
# MIC-R2 = 0.62

y2 &lt;- sin(4*t); plot(t,y2,type="l")
mine(t,y2)
# rounded values of MINE statistics
# MIC = 0.32 
# MAS = 0.18
# MEV = 0.32
# MCN = 3.58
# MIC-R2 = 0.31

# Note that for small n it is better to increase alpha
mine(t,y1,alpha=1)
# rounded values of MINE statistics
# MIC = 1 
# MAS = 0.59
# MEV = 1
# MCN = 5.67
# MIC-R2 = 0.96

mine(t,y2,alpha=1)
# rounded values of MINE statistics
# MIC = 1 
# MAS = 0.59
# MEV = 1
# MCN = 5
# MIC-R2 = 0.99

# Some examples from SOM
x &lt;- runif(n=1000, min=0, max=1)

# Linear relationship
y1 &lt;- x; plot(x,y1,type="l"); mine(x,y1)
# MIC = 1 
# MAS = 0
# MEV = 1
# MCN = 4
# MIC-R2 = 0

# Parabolic relationship
y2 &lt;- 4*(x-0.5)^2; plot(sort(x),y2[order(x)],type="l"); mine(x,y2)
# rounded values of MINE statistics
# MIC = 1 
# MAS = 0.68
# MEV = 1
# MCN = 5.5
# MIC-R2 = 1

# Sinusoidal relationship (varying frequency)
y3 &lt;- sin(6*pi*x*(1+x)); plot(sort(x),y3[order(x)],type="l"); mine(x,y3)
# rounded values of MINE statistics
# MIC = 1 
# MAS = 0.85
# MEV = 1
# MCN = 4.6
# MIC-R2 = 0.96

# Circle relationship
t &lt;- seq(from=0,to=2*pi,length.out=1000)
x4 &lt;- cos(t); y4 &lt;- sin(t); plot(x4, y4, type="l",asp=1)
mine(x4,y4)
# rounded values of MINE statistics
# MIC = 0.68 
# MAS = 0.01
# MEV = 0.32
# MCN = 5.98
# MIC-R2 = 0.68

data(Spellman)
res &lt;- mine(Spellman,master=1,n.cores=1)

## Not run: ## example of multicore computation
res &lt;- mine(Spellman,master=1,n.cores=parallel::detectCores()-1)
## End(Not run)
</code></pre>

<hr>
<h2 id='mine_stat'>This is an helper function to compute one <code>mine</code> statistic.
It take two vectors of the same dimension as an input.</h2><span id='topic+mine_stat'></span>

<h3>Description</h3>

<p>This is an helper function to compute one <code>mine</code> statistic.
It take two vectors of the same dimension as an input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mine_stat(
  x,
  y,
  alpha = 0.6,
  C = 15,
  est = "mic_approx",
  measure = "mic",
  eps = NA_real_,
  p = -1,
  norm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mine_stat_+3A_x">x</code></td>
<td>
<p>Numeric Vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="mine_stat_+3A_y">y</code></td>
<td>
<p>Numeric Vector of size <code>n</code></p>
</td></tr>
<tr><td><code id="mine_stat_+3A_alpha">alpha</code></td>
<td>
<p>numeric value representing parameter for the mine statistic see <code><a href="#topic+mine">mine</a></code></p>
</td></tr>
<tr><td><code id="mine_stat_+3A_c">C</code></td>
<td>
<p>c parameter for the mine statistic see <code><a href="#topic+mine">mine</a></code></p>
</td></tr>
<tr><td><code id="mine_stat_+3A_est">est</code></td>
<td>
<p>character estimation parameter for the mine statistic.
Possible values are <code>"mic_approx"</code> or <code>"mic_e"</code></p>
</td></tr>
<tr><td><code id="mine_stat_+3A_measure">measure</code></td>
<td>
<p>integer indicating which measure to return
available measures are: <code>mic, mas, mev, mcn, tic, gmic</code>. The string could be also uppercase.
For measure <code>mic-r2</code> see details.</p>
</td></tr>
<tr><td><code id="mine_stat_+3A_eps">eps</code></td>
<td>
<p>eps value for MCN statistic should be in (0,1). If NA (default) is passed then the normal MCN statistic is returned.</p>
</td></tr>
<tr><td><code id="mine_stat_+3A_p">p</code></td>
<td>
<p>probability for the generalized mic</p>
</td></tr>
<tr><td><code id="mine_stat_+3A_norm">norm</code></td>
<td>
<p>boolean if require normalization between 0 and 1 for the <code>tic</code> statistic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper function to compute the mine statistic between two variables.
for more details on the available measure and the meaning of the other parameters see also the 
documentation for the <code><a href="#topic+mine">mine</a></code> function.
</p>
<p>For measure <code>mic-r2</code> use the Pearson R coefficient score <code><a href="stats.html#topic+cor">cor</a></code> and the measure <code>mic</code>. 
See the example below.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mine">mine</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(10); y &lt;- 3*x+2;
mine_stat(x,y, measure="mic")

## Measure mic-r2
x &lt;- matrix(rnorm(20), ncol=2, nrow=10)
mmic &lt;- mine_stat(x[,1], x[,2], measure="mic")
r2 &lt;- cor(x[,1], x[,2])

mmic - r2**2

</code></pre>

<hr>
<h2 id='pstats'>Compute pairwise statistics (MIC and normalized TIC) between variables
(convenience function).</h2><span id='topic+pstats'></span>

<h3>Description</h3>

<p>For each statistic, the upper triangle of the matrix is stored by row
(condensed matrix). If m is the number of variables, then for i &lt; j &lt; m, the
statistic between (col) i and j is stored in k = m*i - i*(i+1)/2 - i - 1 + j.
The length of the vectors is n = m*(m-1)/2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pstats(x, alpha = 0.6, C = 15, est = "mic_approx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pstats_+3A_x">x</code></td>
<td>
<p>Numeric Matrix of m-by-n with n variables and m samples.</p>
</td></tr>
<tr><td><code id="pstats_+3A_alpha">alpha</code></td>
<td>
<p>number (0, 1.0] or &gt;=4 if alpha is in (0,1] then B will be max(n^alpha, 4) where n is the
number of samples. If alpha is &gt;=4 then alpha defines directly the B
parameter. If alpha is higher than the number of samples (n) it will be
limited to be n, so B = min(alpha, n).</p>
</td></tr>
<tr><td><code id="pstats_+3A_c">C</code></td>
<td>
<p>number (&gt; 0) determines how many more clumps there will be than columns in
every partition. Default value is 15, meaning that when trying to
draw x grid lines on the x-axis, the algorithm will start with at
most 15*x clumps.</p>
</td></tr>
<tr><td><code id="pstats_+3A_est">est</code></td>
<td>
<p>string (&quot;mic_approx&quot;, &quot;mic_e&quot;) estimator. 
With est=&quot;mic_approx&quot; the original MINE statistics will
be computed, with est=&quot;mic_e&quot; the equicharacteristic matrix is
is evaluated and MIC_e and TIC_e are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of (n x (n-1)/2) rows and 4 columns. The first and second column are
the indexes relative to the columns in the input matrix <code>x</code> for which the statistic is computed for.
Column 3 contains the MIC statistic, while column 4 contains the normalized TIC statistic.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a matrix of random numbers
## 10 variables x 100 samples
x &lt;- matrix(rnorm(1000), ncol=10)
res &lt;- pstats(x)

head(res)

</code></pre>

<hr>
<h2 id='Spellman'>CDC15 Yeast Gene Expression Dataset</h2><span id='topic+Spellman'></span><span id='topic+spellman'></span>

<h3>Description</h3>

<p>The Spellman dataset provides the gene expression data measured (on a custom platform) 
in <em>Saccharomyces cerevisiae</em> cell cultures that have been synchronized at 
different points of the cell cycle by using a temperature-sensitive mutation 
(<em>cdc15-2</em>), which arrestes cells late in mitosis at the restrictive 
temperature (it can cause heat-shock). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spellman</code></pre>


<h3>Format</h3>

<p>23 rows x 4382 columns: 4381 transcripts (columns 2:4382)
measured at 23 timepoints (column 1).</p>


<h3>Source</h3>

<p>The original data were published by Spellman and colleagues in Mol. 
Biol. Cell (1998) as the Botstein dataset. Here we include the version of the 
dataset as processed by Reshef and colleagues for the MINE statistics original 
article published in Science (2011) (details are provided in the supplementary material).</p>


<h3>References</h3>

<p>D. Reshef, Y. Reshef, H. Finucane, S. Grossman, G. McVean, P. Turnbaugh, 
E. Lander, M. Mitzenmacher, P. Sabeti. (2011)
<em>Detecting novel associations in large datasets</em>. 
Science 334, 6062  
(<a href="http://www.exploredata.net">http://www.exploredata.net</a>).
</p>
<p>P. T. Spellman, G. Sherlock, M. Q. Zhang, V. R. Iyer, K. Anders, M. B. Eisen,
P. O. Brown, D. Botstein, B. Futcher. (1998)
<em>Comprehensive Identification of Cell Cycle–regulated Genes of the Yeast 
Saccharomyces cerevisiae by Microarray Hybridization</em>.
Mol. Biol. Cell, 9:12 3273&ndash;3297.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
