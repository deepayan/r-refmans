<!DOCTYPE html><html><head><title>Help for package TRexSelector</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TRexSelector}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_dummies'><p>Add dummy predictors to the original predictor matrix</p></a></li>
<li><a href='#add_dummies_GVS'><p>Add dummy predictors to the original predictor matrix, as required by the T-Rex+GVS selector (<a href="https://doi.org/10.23919/EUSIPCO55093.2022.9909883">doi:10.23919/EUSIPCO55093.2022.9909883</a>)</p></a></li>
<li><a href='#FDP'><p>False discovery proportion (FDP)</p></a></li>
<li><a href='#fdp_hat'><p>Computes the conservative FDP estimate of the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>)</p></a></li>
<li><a href='#Gauss_data'><p>Toy data generated from a Gaussian linear model</p></a></li>
<li><a href='#lm_dummy'><p>Perform one random experiment</p></a></li>
<li><a href='#Phi_prime_fun'><p>Computes the Deflated Relative Occurrences</p></a></li>
<li><a href='#random_experiments'><p>Run K random experiments</p></a></li>
<li><a href='#screen_trex'><p>Run the Screen-T-Rex selector (<a href="https://doi.org/10.1109/SSP53291.2023.10207957">doi:10.1109/SSP53291.2023.10207957</a>)</p></a></li>
<li><a href='#select_var_fun'><p>Compute set of selected variables</p></a></li>
<li><a href='#select_var_fun_DA_BT'><p>Compute set of selected variables for the T-Rex+DA+BT selector T-Rex+DA+BT selector (<a href="https://doi.org/10.48550/arXiv.2401.15796">doi:10.48550/arXiv.2401.15796</a>)</p></a></li>
<li><a href='#TPP'><p>True positive proportion (TPP)</p></a></li>
<li><a href='#trex'><p>Run the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>T-Rex Selector: High-Dimensional Variable Selection &amp; FDR
Control</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-23</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs fast variable selection in high-dimensional settings while controlling the 
    false discovery rate (FDR) at a user-defined target level. The package is based on the paper 
    Machkour, Muma, and Palomar (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jasin Machkour &lt;jasin.machkour@tu-darmstadt.de&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jasinmachkour/TRexSelector">https://github.com/jasinmachkour/TRexSelector</a>,
<a href="https://arxiv.org/abs/2110.06048">https://arxiv.org/abs/2110.06048</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jasinmachkour/TRexSelector/issues">https://github.com/jasinmachkour/TRexSelector/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, patchwork, WGCNA, fastcluster,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, stats, tlars, parallel, doParallel, foreach, doRNG,
methods, glmnet, boot</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-23 22:36:14 UTC; jasinmachkour</td>
</tr>
<tr>
<td>Author:</td>
<td>Jasin Machkour [aut, cre],
  Simon Tien [aut],
  Daniel P. Palomar [aut],
  Michael Muma [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 23:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_dummies'>Add dummy predictors to the original predictor matrix</h2><span id='topic+add_dummies'></span>

<h3>Description</h3>

<p>Sample num_dummies dummy predictors from the univariate standard normal distribution and append them to the predictor matrix X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dummies(X, num_dummies)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dummies_+3A_x">X</code></td>
<td>
<p>Real valued predictor matrix.</p>
</td></tr>
<tr><td><code id="add_dummies_+3A_num_dummies">num_dummies</code></td>
<td>
<p>Number of dummies that are appended to the predictor matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Enlarged predictor matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 50
p &lt;- 100
X &lt;- matrix(stats::rnorm(n * p), nrow = n, ncol = p)
add_dummies(X = X, num_dummies = p)
</code></pre>

<hr>
<h2 id='add_dummies_GVS'>Add dummy predictors to the original predictor matrix, as required by the T-Rex+GVS selector (<a href="https://doi.org/10.23919/EUSIPCO55093.2022.9909883">doi:10.23919/EUSIPCO55093.2022.9909883</a>)</h2><span id='topic+add_dummies_GVS'></span>

<h3>Description</h3>

<p>Generate num_dummies dummy predictors as required for the T-Rex+GVS selector (<a href="https://doi.org/10.23919/EUSIPCO55093.2022.9909883">doi:10.23919/EUSIPCO55093.2022.9909883</a>) and append them to the predictor matrix X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dummies_GVS(X, num_dummies, corr_max = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dummies_GVS_+3A_x">X</code></td>
<td>
<p>Real valued predictor matrix.</p>
</td></tr>
<tr><td><code id="add_dummies_GVS_+3A_num_dummies">num_dummies</code></td>
<td>
<p>Number of dummies that are appended to the predictor matrix. Has to be a multiple of the number of original variables.</p>
</td></tr>
<tr><td><code id="add_dummies_GVS_+3A_corr_max">corr_max</code></td>
<td>
<p>Maximum allowed correlation between any two predictors from different clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Enlarged predictor matrix for the T-Rex+GVS selector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 50
p &lt;- 100
X &lt;- matrix(stats::rnorm(n * p), nrow = n, ncol = p)
add_dummies_GVS(X = X, num_dummies = p)
</code></pre>

<hr>
<h2 id='FDP'>False discovery proportion (FDP)</h2><span id='topic+FDP'></span>

<h3>Description</h3>

<p>Computes the FDP based on the estimated and the true regression coefficient vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FDP(beta_hat, beta, eps = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FDP_+3A_beta_hat">beta_hat</code></td>
<td>
<p>Estimated regression coefficient vector.</p>
</td></tr>
<tr><td><code id="FDP_+3A_beta">beta</code></td>
<td>
<p>True regression coefficient vector.</p>
</td></tr>
<tr><td><code id="FDP_+3A_eps">eps</code></td>
<td>
<p>Numerical zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>False discovery proportion (FDP).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Gauss_data")
X &lt;- Gauss_data$X
y &lt;- c(Gauss_data$y)
beta &lt;- Gauss_data$beta

set.seed(1234)
res &lt;- trex(X, y)
beta_hat &lt;- res$selected_var

FDP(beta_hat = beta_hat, beta = beta)
</code></pre>

<hr>
<h2 id='fdp_hat'>Computes the conservative FDP estimate of the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>)</h2><span id='topic+fdp_hat'></span>

<h3>Description</h3>

<p>Computes the conservative FDP estimate of the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdp_hat(V, Phi, Phi_prime, eps = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdp_hat_+3A_v">V</code></td>
<td>
<p>Voting level grid.</p>
</td></tr>
<tr><td><code id="fdp_hat_+3A_phi">Phi</code></td>
<td>
<p>Vector of relative occurrences.</p>
</td></tr>
<tr><td><code id="fdp_hat_+3A_phi_prime">Phi_prime</code></td>
<td>
<p>Vector of deflated relative occurrences.</p>
</td></tr>
<tr><td><code id="fdp_hat_+3A_eps">eps</code></td>
<td>
<p>Numerical zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of conservative FDP estimates for each value of the voting level grid.
</p>

<hr>
<h2 id='Gauss_data'>Toy data generated from a Gaussian linear model</h2><span id='topic+Gauss_data'></span>

<h3>Description</h3>

<p>A data set containing a predictor matrix X with n = 50 observations
and p = 100 variables (predictors), and a sparse parameter vector beta
with associated support vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gauss_data
</code></pre>


<h3>Format</h3>

<p>A list containing a matrix X and vectors y, beta, and support:
</p>

<dl>
<dt>X</dt><dd><p>Predictor matrix, n = 50, p = 100.</p>
</dd>
<dt>y</dt><dd><p>Response vector.</p>
</dd>
<dt>beta</dt><dd><p>Parameter vector.</p>
</dd>
<dt>support</dt><dd><p>Support vector.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Generated as follows:
set.seed(789)
n &lt;- 50
p &lt;- 100
X &lt;- matrix(stats::rnorm(n * p), nrow = n, ncol = p)
beta &lt;- c(rep(5, times = 3), rep(0, times = 97))
support &lt;- beta &gt; 0
y &lt;- X %*% beta + stats::rnorm(n)
Gauss_data &lt;- list(
  X = X,
  y = y,
  beta = beta,
  support = support
)
</code></pre>

<hr>
<h2 id='lm_dummy'>Perform one random experiment</h2><span id='topic+lm_dummy'></span>

<h3>Description</h3>

<p>Run one random experiment of the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>), i.e., generates dummies, appends them to the predictor matrix, and runs
the forward selection algorithm until it is terminated after T_stop dummies have been selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_dummy(
  X,
  y,
  model_tlars,
  T_stop = 1,
  num_dummies = ncol(X),
  method = "trex",
  GVS_type = "IEN",
  type = "lar",
  corr_max = 0.5,
  lambda_2_lars = NULL,
  early_stop = TRUE,
  verbose = TRUE,
  intercept = FALSE,
  standardize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_dummy_+3A_x">X</code></td>
<td>
<p>Real valued predictor matrix.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_model_tlars">model_tlars</code></td>
<td>
<p>Object of the class tlars_cpp. It contains all state variables of the previous T-LARS step (necessary for warm-starts, i.e., restarting
the forward selection process exactly where it was previously terminated).</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_t_stop">T_stop</code></td>
<td>
<p>Number of included dummies after which the random experiments (i.e., forward selection processes) are stopped.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_num_dummies">num_dummies</code></td>
<td>
<p>Number of dummies that are appended to the predictor matrix.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_method">method</code></td>
<td>
<p>'trex' for the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>),
'trex+GVS' for the T-Rex+GVS selector (<a href="https://doi.org/10.23919/EUSIPCO55093.2022.9909883">doi:10.23919/EUSIPCO55093.2022.9909883</a>),
'trex+DA+AR1' for the T-Rex+DA+AR1 selector,
'trex+DA+equi' for the T-Rex+DA+equi selector,
'trex+DA+BT' for the T-Rex+DA+BT selector (<a href="https://doi.org/10.48550/arXiv.2401.15796">doi:10.48550/arXiv.2401.15796</a>),
'trex+DA+NN' for the T-Rex+DA+NN selector (<a href="https://doi.org/10.48550/arXiv.2401.15139">doi:10.48550/arXiv.2401.15139</a>).</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_gvs_type">GVS_type</code></td>
<td>
<p>'IEN' for the Informed Elastic Net (<a href="https://doi.org/10.1109/CAMSAP58249.2023.10403489">doi:10.1109/CAMSAP58249.2023.10403489</a>),
'EN' for the ordinary Elastic Net (<a href="https://doi.org/10.1111/j.1467-9868.2005.00503.x">doi:10.1111/j.1467-9868.2005.00503.x</a>).</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_type">type</code></td>
<td>
<p>'lar' for 'LARS' and 'lasso' for Lasso.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_corr_max">corr_max</code></td>
<td>
<p>Maximum allowed correlation between any two predictors from different clusters.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_lambda_2_lars">lambda_2_lars</code></td>
<td>
<p>lambda_2-value for LARS-based Elastic Net.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_early_stop">early_stop</code></td>
<td>
<p>Logical. If TRUE, then the forward selection process is stopped after T_stop dummies have been included. Otherwise
the entire solution path is computed.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE progress in computations is shown when performing T-LARS steps on the created model.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_intercept">intercept</code></td>
<td>
<p>Logical. If TRUE an intercept is included.</p>
</td></tr>
<tr><td><code id="lm_dummy_+3A_standardize">standardize</code></td>
<td>
<p>Logical. If TRUE the predictors are standardized and the response is centered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of the class tlars_cpp.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
eps &lt;- .Machine$double.eps
n &lt;- 75
p &lt;- 100
X &lt;- matrix(stats::rnorm(n * p), nrow = n, ncol = p)
beta &lt;- c(rep(3, times = 3), rep(0, times = 97))
y &lt;- X %*% beta + rnorm(n)
res &lt;- lm_dummy(X = X, y = y, T_stop = 1, num_dummies = 5 * p)
beta_hat &lt;- res$get_beta()[seq(p)]
support &lt;- abs(beta_hat) &gt; eps
support
</code></pre>

<hr>
<h2 id='Phi_prime_fun'>Computes the Deflated Relative Occurrences</h2><span id='topic+Phi_prime_fun'></span>

<h3>Description</h3>

<p>Computes the vector of deflated relative occurrences for all variables (i.e., j = 1,..., p) and T = T_stop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Phi_prime_fun(
  p,
  T_stop,
  num_dummies,
  phi_T_mat,
  Phi,
  eps = .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Phi_prime_fun_+3A_p">p</code></td>
<td>
<p>Number of candidate variables.</p>
</td></tr>
<tr><td><code id="Phi_prime_fun_+3A_t_stop">T_stop</code></td>
<td>
<p>Number of included dummies after which the random experiments (i.e., forward selection processes) are stopped.</p>
</td></tr>
<tr><td><code id="Phi_prime_fun_+3A_num_dummies">num_dummies</code></td>
<td>
<p>Number of dummies</p>
</td></tr>
<tr><td><code id="Phi_prime_fun_+3A_phi_t_mat">phi_T_mat</code></td>
<td>
<p>Matrix of relative occurrences for all variables (i.e., j = 1,..., p) and for T = 1, ..., T_stop.</p>
</td></tr>
<tr><td><code id="Phi_prime_fun_+3A_phi">Phi</code></td>
<td>
<p>Vector of relative occurrences for all variables (i.e., j = 1,..., p) at T = T_stop.</p>
</td></tr>
<tr><td><code id="Phi_prime_fun_+3A_eps">eps</code></td>
<td>
<p>Numerical zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of deflated relative occurrences for all variables (i.e., j = 1,..., p) and T = T_stop.
</p>

<hr>
<h2 id='random_experiments'>Run K random experiments</h2><span id='topic+random_experiments'></span>

<h3>Description</h3>

<p>Run K early terminated T-Rex (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>) random experiments and
compute the matrix of relative occurrences for all variables and all numbers of included variables before stopping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_experiments(
  X,
  y,
  K = 20,
  T_stop = 1,
  num_dummies = ncol(X),
  method = "trex",
  GVS_type = "EN",
  type = "lar",
  corr_max = 0.5,
  lambda_2_lars = NULL,
  early_stop = TRUE,
  lars_state_list,
  verbose = TRUE,
  intercept = FALSE,
  standardize = TRUE,
  dummy_coef = FALSE,
  parallel_process = FALSE,
  parallel_max_cores = min(K, max(1, parallel::detectCores(logical = FALSE))),
  seed = NULL,
  eps = .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_experiments_+3A_x">X</code></td>
<td>
<p>Real valued predictor matrix.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_k">K</code></td>
<td>
<p>Number of random experiments.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_t_stop">T_stop</code></td>
<td>
<p>Number of included dummies after which the random experiments (i.e., forward selection processes) are stopped.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_num_dummies">num_dummies</code></td>
<td>
<p>Number of dummies that are appended to the predictor matrix.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_method">method</code></td>
<td>
<p>'trex' for the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>),
'trex+GVS' for the T-Rex+GVS selector (<a href="https://doi.org/10.23919/EUSIPCO55093.2022.9909883">doi:10.23919/EUSIPCO55093.2022.9909883</a>),
'trex+DA+AR1' for the T-Rex+DA+AR1 selector,
'trex+DA+equi' for the T-Rex+DA+equi selector,
'trex+DA+BT' for the T-Rex+DA+BT selector (<a href="https://doi.org/10.48550/arXiv.2401.15796">doi:10.48550/arXiv.2401.15796</a>),
'trex+DA+NN' for the T-Rex+DA+NN selector (<a href="https://doi.org/10.48550/arXiv.2401.15139">doi:10.48550/arXiv.2401.15139</a>).</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_gvs_type">GVS_type</code></td>
<td>
<p>'IEN' for the Informed Elastic Net (<a href="https://doi.org/10.1109/CAMSAP58249.2023.10403489">doi:10.1109/CAMSAP58249.2023.10403489</a>),
'EN' for the ordinary Elastic Net (<a href="https://doi.org/10.1111/j.1467-9868.2005.00503.x">doi:10.1111/j.1467-9868.2005.00503.x</a>).</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_type">type</code></td>
<td>
<p>'lar' for 'LARS' and 'lasso' for Lasso.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_corr_max">corr_max</code></td>
<td>
<p>Maximum allowed correlation between any two predictors from different clusters (for method = 'trex+GVS').</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_lambda_2_lars">lambda_2_lars</code></td>
<td>
<p>lambda_2-value for LARS-based Elastic Net.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_early_stop">early_stop</code></td>
<td>
<p>Logical. If TRUE, then the forward selection process is stopped after T_stop dummies have been included. Otherwise
the entire solution path is computed.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_lars_state_list">lars_state_list</code></td>
<td>
<p>If parallel_process = TRUE: List of state variables of the previous T-LARS steps of the K random experiments
(necessary for warm-starts, i.e., restarting the forward selection process exactly where it was previously terminated).
If parallel_process = FALSE: List of objects of the class tlars_cpp associated with the K random experiments
(necessary for warm-starts, i.e., restarting the forward selection process exactly where it was previously terminated).</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE progress in computations is shown.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_intercept">intercept</code></td>
<td>
<p>Logical. If TRUE an intercept is included.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_standardize">standardize</code></td>
<td>
<p>Logical. If TRUE the predictors are standardized and the response is centered.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_dummy_coef">dummy_coef</code></td>
<td>
<p>Logical. If TRUE a matrix containing the terminal dummy coefficient vectors of all K random experiments as rows is returned.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_parallel_process">parallel_process</code></td>
<td>
<p>Logical. If TRUE random experiments are executed in parallel.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_parallel_max_cores">parallel_max_cores</code></td>
<td>
<p>Maximum number of cores to be used for parallel processing.</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator (ignored if parallel_process = FALSE).</p>
</td></tr>
<tr><td><code id="random_experiments_+3A_eps">eps</code></td>
<td>
<p>Numerical zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the results of the K random experiments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
data("Gauss_data")
X &lt;- Gauss_data$X
y &lt;- c(Gauss_data$y)
res &lt;- random_experiments(X = X, y = y)
relative_occurrences_matrix &lt;- res$phi_T_mat
relative_occurrences_matrix
</code></pre>

<hr>
<h2 id='screen_trex'>Run the Screen-T-Rex selector (<a href="https://doi.org/10.1109/SSP53291.2023.10207957">doi:10.1109/SSP53291.2023.10207957</a>)</h2><span id='topic+screen_trex'></span>

<h3>Description</h3>

<p>The Screen-T-Rex selector (<a href="https://doi.org/10.1109/SSP53291.2023.10207957">doi:10.1109/SSP53291.2023.10207957</a>) performs very fast variable selection in high-dimensional settings while
informing the user about the automatically selected false discovery rate (FDR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screen_trex(
  X,
  y,
  K = 20,
  R = 1000,
  method = "trex",
  bootstrap = FALSE,
  conf_level_grid = seq(0, 1, by = 0.001),
  cor_coef = NA,
  type = "lar",
  corr_max = 0.5,
  lambda_2_lars = NULL,
  rho_thr_DA = 0.02,
  parallel_process = FALSE,
  parallel_max_cores = min(K, max(1, parallel::detectCores(logical = FALSE))),
  seed = NULL,
  eps = .Machine$double.eps,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screen_trex_+3A_x">X</code></td>
<td>
<p>Real valued predictor matrix.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_k">K</code></td>
<td>
<p>Number of random experiments.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_r">R</code></td>
<td>
<p>Number of bootstrap resamples.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_method">method</code></td>
<td>
<p>'trex' for the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>),
'trex+GVS' for the T-Rex+GVS selector (<a href="https://doi.org/10.23919/EUSIPCO55093.2022.9909883">doi:10.23919/EUSIPCO55093.2022.9909883</a>),
'trex+DA+AR1' for the T-Rex+DA+AR1 selector,
'trex+DA+equi' for the T-Rex+DA+equi selector.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Logical. If TRUE Screen-T-Rex is carried out with bootstrapping.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_conf_level_grid">conf_level_grid</code></td>
<td>
<p>Confidence level grid for the bootstrap confidence intervals.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_cor_coef">cor_coef</code></td>
<td>
<p>AR(1) autocorrelation coefficient for the T-Rex+DA+AR1 selector or equicorrelation coefficient for the T-Rex+DA+equi selector.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_type">type</code></td>
<td>
<p>'lar' for 'LARS' and 'lasso' for Lasso.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_corr_max">corr_max</code></td>
<td>
<p>Maximum allowed correlation between any two predictors from different clusters.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_lambda_2_lars">lambda_2_lars</code></td>
<td>
<p>lambda_2-value for LARS-based Elastic Net.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_rho_thr_da">rho_thr_DA</code></td>
<td>
<p>Correlation threshold for the T-Rex+DA+AR1 selector and the T-Rex+DA+equi selector (i.e., method = 'trex+DA+AR1' or 'trex+DA+equi').</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_parallel_process">parallel_process</code></td>
<td>
<p>Logical. If TRUE random experiments are executed in parallel.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_parallel_max_cores">parallel_max_cores</code></td>
<td>
<p>Maximum number of cores to be used for parallel processing.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator (ignored if parallel_process = FALSE).</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_eps">eps</code></td>
<td>
<p>Numerical zero.</p>
</td></tr>
<tr><td><code id="screen_trex_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE progress in computations is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated support vector, the automatically selected false discovery rate (FDR) and additional information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Gauss_data")
X &lt;- Gauss_data$X
y &lt;- c(Gauss_data$y)
set.seed(123)
res &lt;- screen_trex(X = X, y = y)
selected_var &lt;- res$selected_var
selected_var
</code></pre>

<hr>
<h2 id='select_var_fun'>Compute set of selected variables</h2><span id='topic+select_var_fun'></span>

<h3>Description</h3>

<p>Computes the set of selected variables and returns the estimated support vector for the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_var_fun(p, tFDR, T_stop, FDP_hat_mat, Phi_mat, V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_var_fun_+3A_p">p</code></td>
<td>
<p>Number of candidate variables.</p>
</td></tr>
<tr><td><code id="select_var_fun_+3A_tfdr">tFDR</code></td>
<td>
<p>Target FDR level (between 0 and 1, i.e., 0% and 100%).</p>
</td></tr>
<tr><td><code id="select_var_fun_+3A_t_stop">T_stop</code></td>
<td>
<p>Number of included dummies after which the random experiments (i.e., forward selection processes) are stopped.</p>
</td></tr>
<tr><td><code id="select_var_fun_+3A_fdp_hat_mat">FDP_hat_mat</code></td>
<td>
<p>Matrix whose rows are the vectors of conservative FDP estimates for each value of the voting level grid.</p>
</td></tr>
<tr><td><code id="select_var_fun_+3A_phi_mat">Phi_mat</code></td>
<td>
<p>Matrix of relative occurrences as determined by the T-Rex calibration algorithm.</p>
</td></tr>
<tr><td><code id="select_var_fun_+3A_v">V</code></td>
<td>
<p>Voting level grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated support vector.
</p>

<hr>
<h2 id='select_var_fun_DA_BT'>Compute set of selected variables for the T-Rex+DA+BT selector T-Rex+DA+BT selector (<a href="https://doi.org/10.48550/arXiv.2401.15796">doi:10.48550/arXiv.2401.15796</a>)</h2><span id='topic+select_var_fun_DA_BT'></span>

<h3>Description</h3>

<p>Computes the set of selected variables and returns the estimated support vector for the T-Rex+DA+BT selector (<a href="https://doi.org/10.48550/arXiv.2401.15796">doi:10.48550/arXiv.2401.15796</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_var_fun_DA_BT(
  p,
  tFDR,
  T_stop,
  FDP_hat_array_BT,
  Phi_array_BT,
  V,
  rho_grid
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_var_fun_DA_BT_+3A_p">p</code></td>
<td>
<p>Number of candidate variables.</p>
</td></tr>
<tr><td><code id="select_var_fun_DA_BT_+3A_tfdr">tFDR</code></td>
<td>
<p>Target FDR level (between 0 and 1, i.e., 0% and 100%).</p>
</td></tr>
<tr><td><code id="select_var_fun_DA_BT_+3A_t_stop">T_stop</code></td>
<td>
<p>Number of included dummies after which the random experiments (i.e., forward selection processes) are stopped.</p>
</td></tr>
<tr><td><code id="select_var_fun_DA_BT_+3A_fdp_hat_array_bt">FDP_hat_array_BT</code></td>
<td>
<p>Array containing the conservative FDP estimates for all variables (dimension 1),
values of the voting level grid (dimension 2), and values of the dendrogram grid (dimension 3).</p>
</td></tr>
<tr><td><code id="select_var_fun_DA_BT_+3A_phi_array_bt">Phi_array_BT</code></td>
<td>
<p>Array of relative occurrences as determined by the T-Rex calibration algorithm.</p>
</td></tr>
<tr><td><code id="select_var_fun_DA_BT_+3A_v">V</code></td>
<td>
<p>Voting level grid.</p>
</td></tr>
<tr><td><code id="select_var_fun_DA_BT_+3A_rho_grid">rho_grid</code></td>
<td>
<p>Dendrogram grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the estimated support vector, etc.
</p>

<hr>
<h2 id='TPP'>True positive proportion (TPP)</h2><span id='topic+TPP'></span>

<h3>Description</h3>

<p>Computes the TPP based on the estimated and the true regression coefficient vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TPP(beta_hat, beta, eps = .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TPP_+3A_beta_hat">beta_hat</code></td>
<td>
<p>Estimated regression coefficient vector.</p>
</td></tr>
<tr><td><code id="TPP_+3A_beta">beta</code></td>
<td>
<p>True regression coefficient vector.</p>
</td></tr>
<tr><td><code id="TPP_+3A_eps">eps</code></td>
<td>
<p>Numerical zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>True positive proportion (TPP).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Gauss_data")
X &lt;- Gauss_data$X
y &lt;- c(Gauss_data$y)
beta &lt;- Gauss_data$beta

set.seed(1234)
res &lt;- trex(X, y)
beta_hat &lt;- res$selected_var

TPP(beta_hat = beta_hat, beta = beta)
</code></pre>

<hr>
<h2 id='trex'>Run the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>)</h2><span id='topic+trex'></span>

<h3>Description</h3>

<p>The T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>) performs fast variable selection in high-dimensional settings while
controlling the false discovery rate (FDR) at a user-defined target level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trex(
  X,
  y,
  tFDR = 0.2,
  K = 20,
  max_num_dummies = 10,
  max_T_stop = TRUE,
  method = "trex",
  GVS_type = "IEN",
  cor_coef = NA,
  type = "lar",
  corr_max = 0.5,
  lambda_2_lars = NULL,
  rho_thr_DA = 0.02,
  hc_dist = "single",
  hc_grid_length = min(20, ncol(X)),
  parallel_process = FALSE,
  parallel_max_cores = min(K, max(1, parallel::detectCores(logical = FALSE))),
  seed = NULL,
  eps = .Machine$double.eps,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trex_+3A_x">X</code></td>
<td>
<p>Real valued predictor matrix.</p>
</td></tr>
<tr><td><code id="trex_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="trex_+3A_tfdr">tFDR</code></td>
<td>
<p>Target FDR level (between 0 and 1, i.e., 0% and 100%).</p>
</td></tr>
<tr><td><code id="trex_+3A_k">K</code></td>
<td>
<p>Number of random experiments.</p>
</td></tr>
<tr><td><code id="trex_+3A_max_num_dummies">max_num_dummies</code></td>
<td>
<p>Integer factor determining the maximum number of dummies as a multiple of the number of original variables p
(i.e., num_dummies = max_num_dummies * p).</p>
</td></tr>
<tr><td><code id="trex_+3A_max_t_stop">max_T_stop</code></td>
<td>
<p>If TRUE the maximum number of dummies that can be included before stopping is set to ceiling(n / 2),
where n is the number of data points/observations.</p>
</td></tr>
<tr><td><code id="trex_+3A_method">method</code></td>
<td>
<p>'trex' for the T-Rex selector (<a href="https://doi.org/10.48550/arXiv.2110.06048">doi:10.48550/arXiv.2110.06048</a>),
'trex+GVS' for the T-Rex+GVS selector (<a href="https://doi.org/10.23919/EUSIPCO55093.2022.9909883">doi:10.23919/EUSIPCO55093.2022.9909883</a>),
'trex+DA+AR1' for the T-Rex+DA+AR1 selector,
'trex+DA+equi' for the T-Rex+DA+equi selector,
'trex+DA+BT' for the T-Rex+DA+BT selector (<a href="https://doi.org/10.48550/arXiv.2401.15796">doi:10.48550/arXiv.2401.15796</a>),
'trex+DA+NN' for the T-Rex+DA+NN selector (<a href="https://doi.org/10.48550/arXiv.2401.15139">doi:10.48550/arXiv.2401.15139</a>).</p>
</td></tr>
<tr><td><code id="trex_+3A_gvs_type">GVS_type</code></td>
<td>
<p>'IEN' for the Informed Elastic Net (<a href="https://doi.org/10.1109/CAMSAP58249.2023.10403489">doi:10.1109/CAMSAP58249.2023.10403489</a>),
'EN' for the ordinary Elastic Net (<a href="https://doi.org/10.1111/j.1467-9868.2005.00503.x">doi:10.1111/j.1467-9868.2005.00503.x</a>).</p>
</td></tr>
<tr><td><code id="trex_+3A_cor_coef">cor_coef</code></td>
<td>
<p>AR(1) autocorrelation coefficient for the T-Rex+DA+AR1 selector or equicorrelation coefficient for the T-Rex+DA+equi selector.</p>
</td></tr>
<tr><td><code id="trex_+3A_type">type</code></td>
<td>
<p>'lar' for 'LARS' and 'lasso' for Lasso.</p>
</td></tr>
<tr><td><code id="trex_+3A_corr_max">corr_max</code></td>
<td>
<p>Maximum allowed correlation between any two predictors from different clusters (for method = 'trex+GVS').</p>
</td></tr>
<tr><td><code id="trex_+3A_lambda_2_lars">lambda_2_lars</code></td>
<td>
<p>lambda_2-value for LARS-based Elastic Net.</p>
</td></tr>
<tr><td><code id="trex_+3A_rho_thr_da">rho_thr_DA</code></td>
<td>
<p>Correlation threshold for the T-Rex+DA+AR1 selector and the T-Rex+DA+equi selector (i.e., method = 'trex+DA+AR1' or 'trex+DA+equi').</p>
</td></tr>
<tr><td><code id="trex_+3A_hc_dist">hc_dist</code></td>
<td>
<p>Distance measure of the hierarchical clustering/dendrogram (only for trex+DA+BT):
'single' for single-linkage, &quot;complete&quot; for complete linkage, &quot;average&quot; for average linkage (see <a href="stats.html#topic+hclust">hclust</a> for more options).</p>
</td></tr>
<tr><td><code id="trex_+3A_hc_grid_length">hc_grid_length</code></td>
<td>
<p>Length of the height-cutoff-grid for the dendrogram (integer between 1 and the number of original variables p).</p>
</td></tr>
<tr><td><code id="trex_+3A_parallel_process">parallel_process</code></td>
<td>
<p>Logical. If TRUE random experiments are executed in parallel.</p>
</td></tr>
<tr><td><code id="trex_+3A_parallel_max_cores">parallel_max_cores</code></td>
<td>
<p>Maximum number of cores to be used for parallel processing.</p>
</td></tr>
<tr><td><code id="trex_+3A_seed">seed</code></td>
<td>
<p>Seed for random number generator (ignored if parallel_process = FALSE).</p>
</td></tr>
<tr><td><code id="trex_+3A_eps">eps</code></td>
<td>
<p>Numerical zero.</p>
</td></tr>
<tr><td><code id="trex_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE progress in computations is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated support vector and additional information, including the number of used dummies and the number of included dummies before stopping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Gauss_data")
X &lt;- Gauss_data$X
y &lt;- c(Gauss_data$y)
set.seed(1234)
res &lt;- trex(X = X, y = y)
selected_var &lt;- res$selected_var
selected_var
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
