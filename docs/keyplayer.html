<!DOCTYPE html><html lang="en"><head><title>Help for package keyplayer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {keyplayer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#contract'><p>Group the Chosen Players in a Network</p></a></li>
<li><a href='#delta.score'><p>The change on objective function for greedy search implimentation</p></a></li>
<li><a href='#diffusion'><p>Compute the Diffusion Centrality Score in a Network</p></a></li>
<li><a href='#fragment'><p>Compute the Fragmentation Centrality Score in a Netwrok</p></a></li>
<li><a href='#Friends'><p>The friendship network of 21 managers in a high-tech company</p></a></li>
<li><a href='#group.mreach.closeness'><p>Compute the Group-level mreach.closeness Centrality Score in a Netwrok</p></a></li>
<li><a href='#group.mreach.degree'><p>Compute the group-level mreach.degree Centrality Score in a Netwrok</p></a></li>
<li><a href='#kpcent'><p>Compute Group Centraltiy in a Network</p></a></li>
<li><a href='#kpnode'><p>Return the most central player in sequentially reduced networks</p></a></li>
<li><a href='#kpset'><p>Selecting the Most Central Group of Players in a Network</p></a></li>
<li><a href='#mreach.closeness'><p>Compute the M-reach Closeness Centrality Score in a Netwrok</p></a></li>
<li><a href='#mreach.degree'><p>Compute the M-reach Degree Centrality Score in a Netwrok</p></a></li>
<li><a href='#topnode'><p>Orders players by individual centrality from high to low</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Locating Key Players in Social Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Weihua An; Yu-Hsin Liu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Weihua An &lt;weihua.an@emory.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes group centrality scores and identifies the most central group of players in a network.</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, sna, matpow, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-05 23:41:47 UTC; WAN3</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-08 08:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='contract'>Group the Chosen Players in a Network</h2><span id='topic+contract'></span>

<h3>Description</h3>

<p><code>contract</code> combines selected nodes into one large pseudo-node and provides a reduced network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract(adj.matrix, nodes, method = c("min", "max", "union", "add"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contract_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network.
The inputted adjacency matrix for the diffusion centrality should
be properly transfomred to the probability interpretation.</p>
</td></tr>
<tr><td><code id="contract_+3A_nodes">nodes</code></td>
<td>
<p>Integer indicating the column index of the chosen player
in the adjacenncy matrix.</p>
</td></tr>
<tr><td><code id="contract_+3A_method">method</code></td>
<td>
<p>Indication of which grouping criterion should be used.<br />
<code>method="min"</code> indicates the &quot;minimum&quot; criterion (edge values as distances).<br />
<code>method="max"</code> indicates the &quot;maximum&quot; criterion (edge values as non-cummulative strengths).<br />
<code>method="add"</code> indicates the &quot;addition&quot; criterion (edge values as cummulative strengths).<br />
<code>method="union"</code> indicates the &quot;union&quot; criterion (edge values as probability).<br />
The default is &quot;min&quot;. See details for examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimum Criterion: the edge value between a group and an outside node
is measured as the minimal value among all the (nonzero) edge values between
any node in the group and the outside node. Suggested if edge values are
interpreted as distances.<br />
<em>Example: suppose node A to C has distance 2 and B to C has distance 1,
then according to the minimum criterion, the distance between C and
the merged set AB is 1. Note that if B and C are not connected,
the algorithm takes the distance between A and C to describe
the distance between AB and C.</em>
</p>
<p>Maximun Criterion: the edge value between a group and an outside node
is measured as the maximal value among all the (nonzero) edge values between
any node in the group and the outside node. Suggested if edge values are
interpreted as non-cummulative strengths. <br />
<em>Example: we keep using the above example, but the figure now indicates
the strength of tie. According to the maximum criterion, the strength of tie
between AB and C is 2.</em>
</p>
<p>Addition Criterion: the edge value between a group and an outside node
is measured as the sum of all the edge values between any node in the group
and the outside node. Suggested if edge values are as cummulative strengths. <br />
<em>Example: according to the addition criterion, the strength of tie between
AB and C is 3</em>
</p>
<p>Union Criterion: the edge value between a group and an outside node is measured
as the probability that there is at least one path connecting the group with
the outside node. Suggested if edge values are as probability. <br />
<em>Example: suppose A has probability 0.2 to reach C and B has probability
0.5 to reach C, then C can be reached from merged AB with probability
1-(1-0.2)*(1-0.5)=0.6 according to the union criterion.</em>
</p>


<h3>Value</h3>

<p>A new adjacency matrix after contracting the chosen nodes (named
<code>set</code>).
</p>


<h3>Author(s)</h3>

<p>Weihua An <a href="mailto:weihua.an@emory.edu">weihua.an@emory.edu</a>; Yu-Hsin Liu <a href="mailto:ugeneliu@meta.com">ugeneliu@meta.com</a>
</p>


<h3>References</h3>

<p>An, Weihua and Yu-Hsin Liu (2016). &quot;keyplayer: An R Package for Locating Key Players in Social Networks.&quot;
<em>The R Journal</em>, 8(1): 257-268.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kpcent">kpcent</a></code>;
<code><a href="#topic+kpset">kpset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 5x5 weighted and directed adjacency matrix, where edge values
# represent the strength of tie
W &lt;- matrix(
  c(0,1,3,0,0,
    0,0,0,4,0,
    1,1,0,2,0,
    0,0,0,0,3,
    0,2,0,0,0),
    nrow=5, ncol=5, byrow = TRUE)

# If the strength is believed to be non-accumulative for a group of nodes,
# it is proper to use the "maximum" criterion to contract node 2 and 3
contract(W,c(2,3),"max")

# Transform the edge value to probability interpretaion
P &lt;- W *0.2

# Contract node 2 and 3 using the "union" criterion as it is proper for
# probability matrix input
contract(P,c(2,3),"union")

</code></pre>

<hr>
<h2 id='delta.score'>The change on objective function for greedy search implimentation</h2><span id='topic+delta.score'></span>

<h3>Description</h3>

<p><code>delta.score</code> calculates the change in group centrality score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.score(
  adj.matrix,
  candidate,
  residual,
  i,
  j,
  type,
  M = Inf,
  T = ncol(adj.matrix),
  method,
  binary = FALSE,
  cmode,
  large = TRUE,
  geodist.precomp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="delta.score_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>The adjacency matrix of the network.</p>
</td></tr>
<tr><td><code id="delta.score_+3A_candidate">candidate</code></td>
<td>
<p>An initial set of players selected.</p>
</td></tr>
<tr><td><code id="delta.score_+3A_residual">residual</code></td>
<td>
<p>The remaining players in the network without members in the initial set.</p>
</td></tr>
<tr><td><code id="delta.score_+3A_i">i</code></td>
<td>
<p>The specific member in the candidate set to be replaced</p>
</td></tr>
<tr><td><code id="delta.score_+3A_j">j</code></td>
<td>
<p>The specific member in the residual set to replace <code>i</code> in the candidate set</p>
</td></tr>
<tr><td><code id="delta.score_+3A_type">type</code></td>
<td>
<p>Choose
<code>type="betweenness"</code> for betweenness centrality,
<code>type="closeness"</code> for closeness centrality,
<code>type="degree"</code> for degree centraslity,
<code>type="diffusion"</code> for diffusion centrality.
<code>type="evcent"</code> for eigenvector centrality,
<code>type="fragment"</code> for fragmentation centrality,
<code>type="mreach.degree"</code> for mreach.degree centrality, and
<code>type="mreach.closeness"</code> for mreach.closeness centrality.</p>
</td></tr>
<tr><td><code id="delta.score_+3A_m">M</code></td>
<td>
<p>Positive number indicating the maximum distance between two nodes,
above witch the two nodes are considered disconnected. The default is
<code>Inf</code>.
The option is applicable to mreach.degree, mreach.closeness, fragmentation,
and diffusion centralities.</p>
</td></tr>
<tr><td><code id="delta.score_+3A_t">T</code></td>
<td>
<p>Integer indicating the maximum number of iterations
of communication process. For diffusion centrality only.
In the first iteration, the adjacency matrix
is as the input. In the nth iteration, the adjacency matrix becomes
the input adjacency matrix to the power of n. By default, T is the network size.</p>
</td></tr>
<tr><td><code id="delta.score_+3A_method">method</code></td>
<td>
<p>Indication of which grouping criterion should be used.
<code>method="min"</code> indicates the &quot;minimum&quot; criterion (edge values as distances).
<code>method="max"</code> indicates the &quot;maximum&quot; criterion (edge values as non-cummulative strengths).
<code>method="add"</code> indicates the &quot;addition&quot; criterion (edge values as cummulative strengths).
<code>method="union"</code> indicates the &quot;union&quot; criterion (edge values as probability).
By default, the minimun criterion is used for betweenness, closeness, fragmentation,
mreach.degree, and mreach.closeness centralities.
The maximun criterion is used for degree and eigenvector centralities.
The union criterion is used for diffusion centrality.</p>
</td></tr>
<tr><td><code id="delta.score_+3A_binary">binary</code></td>
<td>
<p>If <code>TRUE</code>, the adjacency matrix is binarized.
If <code>FALSE</code>, the edge values are considered. By default, <code>binary=FALSE</code></p>
</td></tr>
<tr><td><code id="delta.score_+3A_cmode">cmode</code></td>
<td>
<p>String indicating the type of centrality being evaluated.
The option is applicable to degree, mreach.degree, and mreach.closeness centralities.
The default is to report the total degree.
<code>cmode="outdegree"</code> and <code>cmode="indegree"</code> refer to indegree and outdegree
respectively. If <code>cmode="all"</code>, all the three types are reported.
The option can also applicable to closeness centrality.
See <code><a href="sna.html#topic+closeness">closeness</a></code> Details section.
The default is to use the Gil-Schmidt power index.</p>
</td></tr>
<tr><td><code id="delta.score_+3A_large">large</code></td>
<td>
<p>Logical scalar, whether the computation method for large network is
implemented. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used; otherwise the method implemented in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="delta.score_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the graph to be
analyzed (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The change in group centrality score
</p>

<hr>
<h2 id='diffusion'>Compute the Diffusion Centrality Score in a Network</h2><span id='topic+diffusion'></span>

<h3>Description</h3>

<p><code>diffusion</code> measures player's ability to disseminate information through all the
possible paths. For each path from i to j there is a reaching probability
<code class="reqn">P_{ij}</code>, which is specified in the inputted adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffusion(adj.matrix, node, T = ncol(adj.matrix))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diffusion_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the probability matrix.</p>
</td></tr>
<tr><td><code id="diffusion_+3A_node">node</code></td>
<td>
<p>Integer indicating the column index of the chosen player
in the adjacenncy matrix. If not specified, scores for all nodes will be reported.</p>
</td></tr>
<tr><td><code id="diffusion_+3A_t">T</code></td>
<td>
<p>Integer indicating the maximum number of iterations
of communication process. In the first iteration, the adjacency matrix
is as the input. In the nth iteration, the adjacency matrix becomes
the input adjacency matrix to the power of n. By default, T is the network size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diffusion centrality measures the expected number of information receivers from a particular node (Banerjee et.al. 2013). The measure can approximate the degree, Katz-Bonacich, or
eigenvector centrality when proper parameters are chosen. See Banerjee et.al. (2014) for details and proofs.
</p>
<p>In its original parametrization (Banerjee et.al. 2013), P=q*g, where q is a measure of the information passing probability and g the adjacency matrix. For simplication and consistency with other centrality measures, the current packages asks users to input the probability matrix P directly.
With information on q and the adjacency matrix, the probability matrix P can easily be calculated by their product.
</p>


<h3>Value</h3>

<p>A vector indicating the defusion centrality score(s) of
the chosen player(s).
</p>


<h3>Author(s)</h3>

<p>Weihua An <a href="mailto:weihua.an@emory.edu">weihua.an@emory.edu</a>; Yu-Hsin Liu <a href="mailto:ugeneliu@meta.com">ugeneliu@meta.com</a>
</p>


<h3>References</h3>

<p>An, Weihua and Yu-Hsin Liu (2016). &quot;keyplayer: An R Package for Locating Key Players in Social Networks.&quot;
<em>The R Journal</em>, 8(1): 257-268.<br />
</p>
<p>Banerjee, A., A. Chandrasekhar, E. Duflo, and M. Jackson (2013):
&quot;Diffusion of Microfinance,&quot; <em>Science</em>, Vol. 341. p.363<br />
</p>
<p>Banerjee, A., A. Chandrasekhar, E. Duflo, and M. Jackson (2014):
&quot;Gossip: Identifying Central Individuals in a Social Network,&quot;
Working Paper.<br />
</p>


<h3>See Also</h3>

<p><code><a href="matpow.html#topic+matpow">matpow</a></code>;
<code><a href="#topic+kpcent">kpcent</a></code>;
<code><a href="#topic+kpset">kpset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 5x5 weighted and directed adjacency matrix, where edge values
# represent the strength of tie
W &lt;- matrix(
  c(0,1,3,0,0,
    0,0,0,4,0,
    1,1,0,2,0,
    0,0,0,0,3,
    0,2,0,0,0),
    nrow=5, ncol=5, byrow = TRUE)

# Transform the edge value to probability interpretaion
P &lt;- W *0.2

# List the diffusion centrality score for every node
diffusion(P, T = 2)

</code></pre>

<hr>
<h2 id='fragment'>Compute the Fragmentation Centrality Score in a Netwrok</h2><span id='topic+fragment'></span>

<h3>Description</h3>

<p><code>fragment</code> measures the extent of fragmentation of a network after a
set of nodes is removed from the network. The more fragmented the residual network is, the more central a node is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fragment(
  adj.matrix,
  nodes,
  M = Inf,
  binary = FALSE,
  large = TRUE,
  geodist.precomp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fragment_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network.</p>
</td></tr>
<tr><td><code id="fragment_+3A_nodes">nodes</code></td>
<td>
<p>Integer indicating the column index of the chosen player
in the adjacenncy matrix. If there are multiple players,
use <code>c(index1,index2,...)</code>.
If not specified, scores for all nodes will be reported.</p>
</td></tr>
<tr><td><code id="fragment_+3A_m">M</code></td>
<td>
<p>Number indicating the maximum geodistance between two nodes,
above witch the two nodes are considered disconnected.
M hence defines the reachable set. The default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="fragment_+3A_binary">binary</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, the adjacency matrix is binarized.
If <code>FALSE</code>, the edge values are considered. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fragment_+3A_large">large</code></td>
<td>
<p>Logical scalar, whether the computation method for large network is
implemented. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used; otherwise the method implemented in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="fragment_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the graph to be
analyzed (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A natural way to apply the fragmentation centrality is in the
context of counter-terrorism, as shown in Borgatti (2006).
The measure uses geodistances to compute the fragmentation level of the
residual network, and thus edge values should be properly adjusted to
distance interpretation. The fragmentation centrality is not directional
as edge values are counted aggregately at the network level.
</p>


<h3>Value</h3>

<p>Vector indicating fragment score(s) of the chosen player(s).
Score is normalized to [0,1].
</p>


<h3>Author(s)</h3>

<p>Weihua An <a href="mailto:weihua.an@emory.edu">weihua.an@emory.edu</a>; Yu-Hsin Liu <a href="mailto:ugeneliu@meta.com">ugeneliu@meta.com</a>
</p>


<h3>References</h3>

<p>An, Weihua and Yu-Hsin Liu (2016). &quot;keyplayer: An R Package for Locating Key Players in Social Networks.&quot;
<em>The R Journal</em>, 8(1): 257-268.<br />
</p>
<p>Borgatti, Stephen P. 2006. &quot;Identifying Sets of Key Players in a Network.&quot;
<em>Computational, Mathematical and Organizational Theory</em>, 12(1):21-34.<br />
</p>
<p>Butts, Carter T. (2014). sna: Tools for Social Network Analysis. R package
version 2.3-2. <a href="https://cran.r-project.org/package=sna">https://cran.r-project.org/package=sna</a><br />
</p>
<p>Csardi, G and Nepusz, T (2006). &quot;The igraph software package for complex network research.&quot;
InterJournal, Complex Systems 1695. <a href="https://igraph.org/">https://igraph.org/</a> <br />
</p>


<h3>See Also</h3>

<p><code><a href="sna.html#topic+geodist">geodist</a></code>;
<code><a href="igraph.html#topic+shortest.paths">shortest.paths</a></code>;
<code><a href="#topic+kpcent">kpcent</a></code>;
<code><a href="#topic+kpset">kpset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 5x5 weighted and directed adjacency matrix, where edge values
# represent the strength of tie
W &lt;- matrix(
  c(0,1,3,0,0,
    0,0,0,4,0,
    1,1,0,2,0,
    0,0,0,0,3,
    0,2,0,0,0),
    nrow=5, ncol=5, byrow = TRUE)

# Transform the edge value to distance interpretaion
A &lt;- W
A[W!=0] &lt;- 1/W[W!=0]

# List the fragmentation centrality scores for every node
fragment(A)

</code></pre>

<hr>
<h2 id='Friends'>The friendship network of 21 managers in a high-tech company</h2><span id='topic+Friends'></span>

<h3>Description</h3>

<p>The friendship network of 21 managers in a high-tech company
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Friends")
</code></pre>


<h3>Format</h3>

<p>A network object for the friendship network of 21 managers in a high-tech company (Krackhardt, 1987).
It is a directed network including 21 nodes and 60 edges. There are two node atrributes. &quot;Dept&quot; shows the department affiliations (1-4).
&quot;Level&quot; shows the rank of the managers in the company (1-3).
</p>
<p>@source D. Krackhardt. &quot;Cognitive social structures.&quot; Social Networks, 9:109-134, 1987.
</p>

<hr>
<h2 id='group.mreach.closeness'>Compute the Group-level mreach.closeness Centrality Score in a Netwrok</h2><span id='topic+group.mreach.closeness'></span>

<h3>Description</h3>

<p><code>mreach.closeness</code> refines the <code><a href="#topic+mreach.degree">mreach.degree</a></code> centrality by
using the (inverse) geodistance as weights.
The edge values should be properly interpreted as distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.mreach.closeness(
  adj.matrix,
  nodes,
  M = Inf,
  method = "min",
  binary = FALSE,
  cmode = "total",
  large = TRUE,
  geodist.precomp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.mreach.closeness_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network.</p>
</td></tr>
<tr><td><code id="group.mreach.closeness_+3A_nodes">nodes</code></td>
<td>
<p>Integer indicating the column index of the chosen player
in the adjacenncy matrix. If there are multiple players,
use <code>c(index1,index2,...)</code></p>
</td></tr>
<tr><td><code id="group.mreach.closeness_+3A_m">M</code></td>
<td>
<p>Number indicating the maximum distance between two nodes,
above witch the two nodes are considered disconnected. The default is
<code>Inf</code>.</p>
</td></tr>
<tr><td><code id="group.mreach.closeness_+3A_method">method</code></td>
<td>
<p>Indication of which grouping criterion should be used.
<code>method="min"</code> indicates the &quot;minimum&quot; criterion (edge values as distances).
<code>method="max"</code> indicates the &quot;maximum&quot; criterion (edge values as non-cummulative strengths).
<code>method="add"</code> indicates the &quot;addition&quot; criterion (edge values as cummulative strengths).
<code>method="union"</code> indicates the &quot;union&quot; criterion (edge values as probability).
The default is the &quot;minimum&quot; criterion for mrach.closeness centrality.</p>
</td></tr>
<tr><td><code id="group.mreach.closeness_+3A_binary">binary</code></td>
<td>
<p>If <code>TRUE</code>, the adjacency matrix is binarized.
If <code>FALSE</code>, the edge values are considered.</p>
</td></tr>
<tr><td><code id="group.mreach.closeness_+3A_cmode">cmode</code></td>
<td>
<p>String indicating the type of centrality being evaluated.
The default is to report the total degree.
<code>"outdegree"</code> and <code>"indegree"</code> refer to indegree and outdegree
respectively. If <code>"all"</code>, all the three types are reported.</p>
</td></tr>
<tr><td><code id="group.mreach.closeness_+3A_large">large</code></td>
<td>
<p>Logical scalar, whether the computation method for large network is
implemented. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used; otherwise the method implemented in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="group.mreach.closeness_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the graph to be
analyzed (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector indicating the outdegree, indegree, or total-degree
cohesion score of the chosen players; or a data frame containing all
the above information. Note that the outdegree and indegree scores are normalized
to [0,1]. This means that the total-degree score is between [0,2].
</p>


<h3>Author(s)</h3>

<p>Weihua An <a href="mailto:weihua.an@emory.edu">weihua.an@emory.edu</a>; Yu-Hsin Liu <a href="mailto:ugeneliu@meta.com">ugeneliu@meta.com</a>
</p>

<hr>
<h2 id='group.mreach.degree'>Compute the group-level mreach.degree Centrality Score in a Netwrok</h2><span id='topic+group.mreach.degree'></span>

<h3>Description</h3>

<p><code>group.mreach.degree</code> computes the size of the reachable nodes from a particular node within M steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group.mreach.degree(
  adj.matrix,
  nodes,
  M = Inf,
  method = "min",
  binary = TRUE,
  cmode = "total",
  large = TRUE,
  geodist.precomp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group.mreach.degree_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network.</p>
</td></tr>
<tr><td><code id="group.mreach.degree_+3A_nodes">nodes</code></td>
<td>
<p>Integer indicating the column index of the chosen player
in the adjacenncy matrix. If there are multiple players,
use <code>c(index1,index2,...)</code></p>
</td></tr>
<tr><td><code id="group.mreach.degree_+3A_m">M</code></td>
<td>
<p>Number indicating the maximum distance between two nodes,
above which the two nodes are considered disconnected.
m hence defines a reachable set. The default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="group.mreach.degree_+3A_method">method</code></td>
<td>
<p>Indication of which grouping criterion should be used.
<code>method="min"</code> indicates the &quot;minimum&quot; criterion (edge values as distances).
<code>method="max"</code> indicates the &quot;maximum&quot; criterion (edge values as non-cummulative strengths).
<code>method="add"</code> indicates the &quot;addition&quot; criterion (edge values as cummulative strengths).
<code>method="union"</code> indicates the &quot;union&quot; criterion (edge values as probability).
The default is the &quot;minimum&quot; criterion for mreach.degree centrality.</p>
</td></tr>
<tr><td><code id="group.mreach.degree_+3A_binary">binary</code></td>
<td>
<p>If <code>TRUE</code>, the adjacency matrix is binarized.
If <code>FALSE</code>, the edge values are considered.</p>
</td></tr>
<tr><td><code id="group.mreach.degree_+3A_cmode">cmode</code></td>
<td>
<p>String indicating the type of centrality being evaluated.
The default is to report the total degree.
<code>"outdegree"</code> and <code>"indegree"</code> refer to indegree and outdegree
respectively. If <code>"all"</code>, all the three types are reported.</p>
</td></tr>
<tr><td><code id="group.mreach.degree_+3A_large">large</code></td>
<td>
<p>Logical scalar, whether the computation method for large network is
implemented. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used; otherwise the method implemented in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="group.mreach.degree_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the graph to be
analyzed (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector indicating the outdegree, indegree, or total-degree
mreach.degree score of the chosen player(s); or a data frame containing all
the above information.
</p>


<h3>Author(s)</h3>

<p>Weihua An <a href="mailto:weihua.an@emory.edu">weihua.an@emory.edu</a>; Yu-Hsin Liu <a href="mailto:ugeneliu@meta.com">ugeneliu@meta.com</a>
</p>

<hr>
<h2 id='kpcent'>Compute Group Centraltiy in a Network</h2><span id='topic+kpcent'></span>

<h3>Description</h3>

<p><code>kpcent</code> reports the group-level centrality scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kpcent(
  adj.matrix,
  nodes,
  type,
  M = Inf,
  T = ncol(adj.matrix),
  method,
  binary = FALSE,
  cmode,
  large = TRUE,
  geodist.precomp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kpcent_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network or the probability matrix in the case of calculating diffusion centrality.</p>
</td></tr>
<tr><td><code id="kpcent_+3A_nodes">nodes</code></td>
<td>
<p>Integer indicating the column index of the chosen player
in the adjacenncy matrix. If there are multiple players,
use <code>c(index1,index2,...)</code></p>
</td></tr>
<tr><td><code id="kpcent_+3A_type">type</code></td>
<td>
<p><code>type="betweenness"</code> for <code><a href="sna.html#topic+betweenness">betweenness</a></code> centrality. <br />
<code>type="closeness"</code> for <code><a href="sna.html#topic+closeness">closeness</a></code> centrality. <br />
<code>type="degree"</code> for <code><a href="sna.html#topic+degree">degree</a></code> centraslity. <br />
<code>type="diffusion"</code> for <code><a href="#topic+diffusion">diffusion</a></code> centrality. <br />
<code>type="evcent"</code> for <code><a href="sna.html#topic+evcent">evcent</a></code> (eigenvector) centrality. <br />
<code>type="fragment"</code> for <code><a href="#topic+fragment">fragment</a></code> centrality. <br />
<code>type="mreach.degree"</code> for <code><a href="#topic+mreach.degree">mreach.degree</a></code> centrality. <br />
<code>type="mreach.closeness"</code> for <code><a href="#topic+mreach.closeness">mreach.closeness</a></code> centrality. <br /></p>
</td></tr>
<tr><td><code id="kpcent_+3A_m">M</code></td>
<td>
<p>Positive number indicating the maximum geodistance between two nodes,
above witch the two nodes are considered disconnected. The default is
<code>Inf</code>. The option is applicable to mreach.degree, mreach.closeness,
and fragmentation centralities.</p>
</td></tr>
<tr><td><code id="kpcent_+3A_t">T</code></td>
<td>
<p>Integer indicating the maximum number of iterations
of communication process. For diffusion centrality only. By default, T is the network size.</p>
</td></tr>
<tr><td><code id="kpcent_+3A_method">method</code></td>
<td>
<p>Indication of which grouping criterion should be used. <br />
<code>"min"</code> indicates the &quot;minimum&quot; criterion and is the default for
betweenness, closeness, fragmentation, and M-reach centralities. <br />
<code>"max"</code> indicates the &quot;maximum&quot; criterion and is the default for
degree and eigenvector centralities.<br />
<code>"add"</code> indicates the &quot;addition&quot; criterion.<br />
<code>"union"</code> indicates the &quot;union&quot; criterion and is the default for
diffusion centrality.<br />
See Details section for explanations on grouping method.</p>
</td></tr>
<tr><td><code id="kpcent_+3A_binary">binary</code></td>
<td>
<p>If <code>TRUE</code>, the adjacency matrix is binarized.
If <code>FALSE</code>, the edge values are considered. By default, <code>binary=FALSE</code></p>
</td></tr>
<tr><td><code id="kpcent_+3A_cmode">cmode</code></td>
<td>
<p>String indicating the type of centrality being evaluated.
The option is applicable to degree and M-reach centralities.
<code>"outdegree"</code>, <code>"indegree"</code>, and <code>"total"</code> refer to
indegree, outdegree, and (total) degree respectively. <code>"all"</code> reports
all the above measures. The default is to report the total degree.
Note for closeness centrality, we use the Gil-Schmidt power index when <code>large=FALSE</code>.
See <code><a href="sna.html#topic+closeness">closeness</a></code> for explanation. When
large=<code>TRUE</code>, the function reports the standard closeness score.</p>
</td></tr>
<tr><td><code id="kpcent_+3A_large">large</code></td>
<td>
<p>Logical scalar, whether the computation method for large network is
implemented. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used; otherwise the method implemented in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="kpcent_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the graph to be
analyzed (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic idea of measuring the group-level centrality is to treat
a group of nodes as a large pseudo-node. We propose several methods to measure
the tie status between this pseudo node and other nodes, responding to several
common edge value interpretations (An and Liu, 2015).
</p>
<p>Minimum Criterion: the edge value between a group and an outside node
is measured as the minimal value among all the (nonzero) edge values between
any node in the group and the outside node. Suggested if edge values are
interpreted as distances.<br />
<em>Example: suppose node A to C has distance 2 and B to C has distance 1,
then according to the minimum criterion, the distance between C and
the merged set AB is 1. Note that if B and C are not connected,
the algorithm takes the distance between A and C to describe
the distance between AB and C.</em>
</p>
<p>Maximun Criterion: the edge value between a group and an outside node
is measured as the maximal value among all the (nonzero) edge values between
any node in the group and the outside node. Suggested if edge values are
interpreted as non-cummulative strengths. <br />
<em>Example: we keep using the above example, but the figure now indicates
the strength of tie. According to the maximum criterion, the strength of tie
between AB and C is 2.</em>
</p>
<p>Addition Criterion: the edge value between a group and an outside node
is measured as the sum of all the edge values between any node in the group
and the outside node. Suggested if edge values are as cummulative strengths. <br />
<em>Example: according to the addition criterion, the strength of tie between
AB and C is 3</em>
</p>
<p>Union Criterion: the edge value between a group and an outside node is measured
as the probability that there is at least one path connecting the group with
the outside node. Suggested if edge values are as probability. <br />
<em>Example: suppose A has probability 0.2 to reach C and B has probability
0.5 to reach C, then C can be reached from merged AB with probability
1-(1-0.2)*(1-0.5)=0.6 according to the union criterion.</em>
</p>


<h3>Value</h3>

<p>A vector indicating the centrality score of a group.
</p>


<h3>Author(s)</h3>

<p>Weihua An <a href="mailto:weihua.an@emory.edu">weihua.an@emory.edu</a>; Yu-Hsin Liu <a href="mailto:ugeneliu@meta.com">ugeneliu@meta.com</a>
</p>


<h3>References</h3>

<p>An, Weihua. (2015). &quot;Multilevel Meta Network Analysis with Application to Studying Network Dynamics of Network Interventions.&quot; <em>Social Networks</em> 43: 48-56.<br />
</p>
<p>An, Weihua and Yu-Hsin Liu (2016). &quot;keyplayer: An R Package for Locating Key Players in Social Networks.&quot;
<em>The R Journal</em>, 8(1): 257-268.<br />
</p>
<p>Banerjee, A., A. Chandrasekhar, E. Duflo, and M. Jackson (2013):
&quot;Diffusion of Microfinance,&quot; <em>Science</em>, Vol. 341. p.363<br />
</p>
<p>Banerjee, A., A. Chandrasekhar, E. Duflo, and M. Jackson (2014):
&quot;Gossip: Identifying Central Individuals in a Social Network,&quot;
Working Paper.<br />
</p>
<p>Borgatti, Stephen P. (2006). &quot;Identifying Sets of Key Players in a Network.&quot;
<em>Computational, Mathematical and Organizational Theory</em>, 12(1):21-34.<br />
</p>
<p>Butts, Carter T. (2014). sna: Tools for Social Network Analysis. R package
version 2.3-2. <a href="https://cran.r-project.org/package=sna">https://cran.r-project.org/package=sna</a><br />
</p>
<p>Csardi, G and Nepusz, T (2006). &quot;The igraph software package for complex network research.&quot;
InterJournal, Complex Systems 1695. <a href="https://igraph.org/">https://igraph.org/</a> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+contract">contract</a></code>
<code><a href="#topic+kpset">kpset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 5x5 weighted and directed adjacency matrix,
# where edge values represent the strength of tie
W &lt;- matrix(
  c(0,1,3,0,0,
    0,0,0,4,0,
    1,1,0,2,0,
    0,0,0,0,3,
    0,2,0,0,0),
    nrow=5, ncol=5, byrow = TRUE)

# List the degree centrality for group of node 2 and 3
kpcent(W,c(2,3),type="degree")

# Transform the edge value to distance interpretaion
# Compute the fragmentation centrality for node 2
A &lt;- W
A[W!=0] &lt;- 1/W[W!=0]
kpcent(A,2,type="fragment")

# Replicate the group-level degree centrality (normalized) when the weights
# are given by the inverse distances and report the outgoing score only
kpcent(A,c(2,3),type="mreach.closeness",binary=TRUE,M=1,cmode="outdegree")

# Transform the edge value to probability interpretation
# Compute the diffusion centrality with number of iteration 20
P &lt;- 0.1*W
kpcent(P,c(2,3),type="diffusion",T=20)

</code></pre>

<hr>
<h2 id='kpnode'>Return the most central player in sequentially reduced networks</h2><span id='topic+kpnode'></span>

<h3>Description</h3>

<p><code>kpnode</code> returns the node with the highest centrality score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kpnode(
  adj.matrix,
  type,
  M = Inf,
  T = ncol(adj.matrix),
  method,
  binary = FALSE,
  cmode,
  large = TRUE,
  geodist.precomp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kpnode_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network.</p>
</td></tr>
<tr><td><code id="kpnode_+3A_type">type</code></td>
<td>
<p><code>type="betweenness"</code> for <code><a href="sna.html#topic+betweenness">betweenness</a></code> centrality. <br />
<code>type="closeness"</code> for <code><a href="sna.html#topic+closeness">closeness</a></code> centrality. <br />
<code>type="degree"</code> for <code><a href="sna.html#topic+degree">degree</a></code> centraslity. <br />
<code>type="diffusion"</code> for <code><a href="#topic+diffusion">diffusion</a></code> centrality. <br />
<code>type="evcent"</code> for <code><a href="sna.html#topic+evcent">evcent</a></code> (eigenvector) centrality. <br />
<code>type="fragment"</code> for <code><a href="#topic+fragment">fragment</a></code> centrality. <br />
<code>type="mreach.degree"</code> for <code><a href="#topic+mreach.degree">mreach.degree</a></code> centrality. <br />
<code>type="mreach.closeness"</code> for <code><a href="#topic+mreach.closeness">mreach.closeness</a></code> centrality. <br /></p>
</td></tr>
<tr><td><code id="kpnode_+3A_m">M</code></td>
<td>
<p>Positive number indicating the maximum geodistance between two nodes,
above witch the two nodes are considered disconnected. The default is
<code>Inf</code>. The option is applicable to mreach.degree, mreach.closeness,
and fragmentation centralities.</p>
</td></tr>
<tr><td><code id="kpnode_+3A_t">T</code></td>
<td>
<p>Integer indicating the maximum number of iterations
of communication process. For diffusion centrality only.
In the first iteration, the adjacency matrix
is as the input. In the nth iteration, the adjacency matrix becomes
the input adjacency matrix to the power of n. By default, T is the network size.</p>
</td></tr>
<tr><td><code id="kpnode_+3A_method">method</code></td>
<td>
<p>Indication of which grouping criterion should be used. <br />
<code>"min"</code> indicates the &quot;minimum&quot; criterion and is suggested for
betweenness, closeness, fragmentation, and M-reach centralities. <br />
<code>"max"</code> indicates the &quot;maximum&quot; criterion and is suggested for
degree and eigenvector centralities.<br />
<code>"add"</code> indicates the &quot;addition&quot; criterion and is suggested for
degree and eigenvector centralities as an altenative of &quot;max&quot;.<br />
<code>"union"</code> indicates the &quot;union&quot; criterion and is suggested for
diffusion centrality.<br />
By default, kpset uses &quot;min&quot;.
See <code><a href="#topic+kpcent">kpcent</a></code> Details section for explanations on grouping method.</p>
</td></tr>
<tr><td><code id="kpnode_+3A_binary">binary</code></td>
<td>
<p>If <code>TRUE</code>, the adjacency matrix is binarized.
If <code>FALSE</code>, the edge values are considered. By default, <code>binary=FALSE</code></p>
</td></tr>
<tr><td><code id="kpnode_+3A_cmode">cmode</code></td>
<td>
<p>String indicating the type of centrality being evaluated.
The option is applicable to degree and M-reach centralities.
<code>"outdegree"</code>, <code>"indegree"</code>, and <code>"total"</code> refer to
indegree, outdegree, and (total) degree respectively. <code>"all"</code> reports
all the above measures. The default is to report the total degree.
The option also applies to closeness centrality, but with different options.
The default is to use the Gil-Schmidt power index as the closeness measure.
See <code><a href="sna.html#topic+closeness">closeness</a></code> for complete options.</p>
</td></tr>
<tr><td><code id="kpnode_+3A_large">large</code></td>
<td>
<p>Logical scalar, whether the computation method for large network is
implemented. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used; otherwise the method implemented in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="kpnode_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the graph to be
analyzed (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The most central player and its centrality score
</p>

<hr>
<h2 id='kpset'>Selecting the Most Central Group of Players in a Network</h2><span id='topic+kpset'></span>

<h3>Description</h3>

<p><code>kpset</code> helps identify the most central group of players in a social network given a sepcified centraliy measure and a target group size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kpset(
  adj.matrix,
  size,
  type = "degree",
  M = Inf,
  T = ncol(adj.matrix),
  method = "min",
  binary = FALSE,
  cmode = "total",
  large = TRUE,
  geodist.precomp = NULL,
  seed = "top",
  parallel = FALSE,
  cluster = 2,
  round = 10,
  iteration = ncol(adj.matrix)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kpset_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network or in the case of diffusion centrality a probability matrix.</p>
</td></tr>
<tr><td><code id="kpset_+3A_size">size</code></td>
<td>
<p>Integer indicating the target size of players.</p>
</td></tr>
<tr><td><code id="kpset_+3A_type">type</code></td>
<td>
<p>A string indicating the type of centrality measure to be used. Should be one of <code>"degree"</code> for degree centrality,
<code>"closeness"</code> for closeness centrality, <code>"betweenness"</code> for betweenness centrality, <code>"evcent"</code> for eigenvector centrality,
<code>"mreach.degree"</code> for M-reach degree centrality, <code>"mreach.closeness"</code> for M-reach closeness centrality,
<code>"fragment"</code> for fragment centrality, and <code>"diffusion"</code> for diffusion centrality.</p>
</td></tr>
<tr><td><code id="kpset_+3A_m">M</code></td>
<td>
<p>Positive number indicating the maximum geodistance between two nodes,
above which the two nodes are considered disconnected. The default is <code>Inf</code>.
The option is applicable to M-reach degree, M-reach closeness, and fragmentation centralities..</p>
</td></tr>
<tr><td><code id="kpset_+3A_t">T</code></td>
<td>
<p>Integer indicating the maximum number of iterations
in the communication process. By default, T is the network size.</p>
</td></tr>
<tr><td><code id="kpset_+3A_method">method</code></td>
<td>
<p>Indication of which grouping criterion should be used. <br />
<code>"min"</code> indicates the &quot;minimum&quot; criterion and is suggested for
betweenness, closeness, fragmentation, and M-reach centralities. <br />
<code>"max"</code> indicates the &quot;maximum&quot; criterion and is suggested for
degree and eigenvector centralities.<br />
<code>"add"</code> indicates the &quot;addition&quot; criterion and is suggested for
degree and eigenvector centralities as an altenative of &quot;max&quot;.<br />
<code>"union"</code> indicates the &quot;union&quot; criterion and is suggested for
diffusion centrality.<br />
The default is &quot;min&quot;.
See <code><a href="#topic+kpcent">kpcent</a></code> Details section for explanations on grouping method.</p>
</td></tr>
<tr><td><code id="kpset_+3A_binary">binary</code></td>
<td>
<p>If <code>TRUE</code>, the input matrix is binarized.
If <code>FALSE</code>, the edge values are considered. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kpset_+3A_cmode">cmode</code></td>
<td>
<p>String indicating the type of centrality being evaluated.
The option is applicable to degree and M-reach centralities.
<code>"outdegree"</code>, <code>"indegree"</code>, and <code>"total"</code> refer to
indegree, outdegree, and total degree, respectively. <code>"all"</code> reports
all the above measures. The default is to report the total degree.
Note for closeness centrality, we use the Gil-Schmidt power index when <code>large=FALSE</code>.
See <code><a href="sna.html#topic+closeness">closeness</a></code> for explanation. When
large=<code>TRUE</code>, the function reports the standard closeness score.</p>
</td></tr>
<tr><td><code id="kpset_+3A_large">large</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used for computing geodistance and related centrality measures; otherwise the method in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="kpset_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the network to be
analyzed (optional).</p>
</td></tr>
<tr><td><code id="kpset_+3A_seed">seed</code></td>
<td>
<p>String indicating the seeding method or a vector of the seeds specified by user.
If <code>"top"</code>, players with the high individual centrality
are used as the seeds. If <code>"random"</code>, seeds are randomly sampled.
The default is <code>"top"</code> for efficiency.</p>
</td></tr>
<tr><td><code id="kpset_+3A_parallel">parallel</code></td>
<td>
<p>Logical scalar. IF <code>TRUE</code>, the parallel computation is
implement. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kpset_+3A_cluster">cluster</code></td>
<td>
<p>Integer indicating the number of CPU cores to be used for parallel computation.</p>
</td></tr>
<tr><td><code id="kpset_+3A_round">round</code></td>
<td>
<p>Integer indicating the &quot;length&quot; of search,
namely, the number of loops over the nodes in the candidate set.</p>
</td></tr>
<tr><td><code id="kpset_+3A_iteration">iteration</code></td>
<td>
<p>Integer indicating the &quot;width&quot; of search in each round,
namely, the number of loops over the nodes in the residual set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most central group of players in a network is not necessarily the set of players who are the most
central as individuals because there may be redundancy in their connections.
Currenlty a greedy search algorithm is implemented in this package to identify the most central group of key players. The basic steps are shown as follows.
</p>

<ol>
<li><p> Select an initial candidate set <em>C</em>. The residual set is denoted as <em>R</em>.
</p>
</li>
<li><p> Update the candidate set <em>C</em>.
</p>

<ul>
<li><p> Start with the first node in <em>C</em>. Try to swap it with nodes in <em>R</em> sequentially (loop 1).
Make the swap if it improves the centrality score of the resulting <em>C</em>.
The number of loop 1 is defined as the number of iterations (over the nodes in the residual set).
</p>
</li>
<li><p> Repeat step 1 for each node in <em>C</em> sequentially (loop 2). The number of loop 2 is
defined as the number of rounds (over the nodes in the candidate set).
</p>
</li>
<li><p> Stop if (a) the change in <em>C</em>'s centrality score is negligible
(i.e. it is smaller than a pre-specified threshold determined by both
the network size and edge values.)
or (b) the process reaches a specified number
of rounds.
</p>
</li></ul>

</li>
<li><p> Return the final candidate set and the centrality score.
</p>
</li></ol>

<p>It is recommended to run <code>kpset</code> several times with different seeds so that the algorithm will not be trapped in a local optimum.
To facilitate the search in large networks, users may specify a reasonable number of iterations
or rounds and/or utilize parallel computation. During parallel computation, for each cluster and each iteration
the algorithm randomly picks a node from the candidate set and the residual set, respectively,
and swaps the two if it improves the centrality score of the candidate set. It repeats this process until exhausting the specified iterations and rounds
and then compare and combine the results from the clusters.
</p>


<h3>Value</h3>

<p><code>kpset</code> returns the column indices of the players who form
the most central set and its centrality score.
</p>


<h3>Author(s)</h3>

<p>Weihua An <a href="mailto:weihua.an@emory.edu">weihua.an@emory.edu</a>; Yu-Hsin Liu <a href="mailto:ugeneliu@meta.com">ugeneliu@meta.com</a>
</p>


<h3>References</h3>

<p>An, Weihua. (2015). &quot;Multilevel Meta Network Analysis with Application to Studying Network Dynamics of Network Interventions.&quot; <em>Social Networks</em> 43: 48-56.<br />
</p>
<p>An, Weihua and Yu-Hsin Liu (2016). &quot;keyplayer: An R Package for Locating Key Players in Social Networks.&quot;
<em>The R Journal</em>, 8(1): 257-268.<br />
</p>
<p>Borgatti, Stephen P. (2006). &quot;Identifying Sets of Key Players in a Network.&quot; <em>Computational, Mathematical and Organizational Theory</em>, 12(1):21-34.<br />
</p>
<p>Butts, Carter T. (2014). sna: Tools for Social Network Analysis. R package
version 2.3-2. <a href="https://CRAN.R-project.org/package=sna">https://CRAN.R-project.org/package=sna</a><br />
</p>
<p>Csardi, G and Nepusz, T (2006). &quot;The igraph software package for complex network research.&quot;
InterJournal, Complex Systems 1695. <a href="https://igraph.org">https://igraph.org</a> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kpcent">kpcent</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 5x5 weighted and directed adjacency matrix
W &lt;- matrix(
  c(0,1,3,0,0,
    0,0,0,4,0,
    1,1,0,2,0,
    0,0,0,0,3,
    0,2,0,0,0),
    nrow=5, ncol=5, byrow = TRUE)

# Find the most central player set sized 2 in terms of the degree centrality
kpset(W,size=2,type="degree")

# Find two most central players in terms of indegree
# via parallel computation using 5 cpu cores
kpset(W,size=2,type="degree", cmode="indegree", parallel = TRUE, cluster = 2)

</code></pre>

<hr>
<h2 id='mreach.closeness'>Compute the M-reach Closeness Centrality Score in a Netwrok</h2><span id='topic+mreach.closeness'></span>

<h3>Description</h3>

<p><code>mreach.closeness</code> refines the <code><a href="#topic+mreach.degree">mreach.degree</a></code> centrality by
using the (inverse) geodistance as weights.
The edge values should be properly interpreted as distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mreach.closeness(
  adj.matrix,
  node,
  M = Inf,
  binary = FALSE,
  cmode = "all",
  large = TRUE,
  geodist.precomp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mreach.closeness_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network.</p>
</td></tr>
<tr><td><code id="mreach.closeness_+3A_node">node</code></td>
<td>
<p>Integer indicating the column index of the chosen player
in the adjacenncy matrix. If not specified, scores for all nodes will be reported.</p>
</td></tr>
<tr><td><code id="mreach.closeness_+3A_m">M</code></td>
<td>
<p>Number indicating the maximum geodistance between two nodes,
above witch the two nodes are considered disconnected.
M hence defines the reachable set. The default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="mreach.closeness_+3A_binary">binary</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, the adjacency matrix is binarized.
If <code>FALSE</code>, the edge values are considered.</p>
</td></tr>
<tr><td><code id="mreach.closeness_+3A_cmode">cmode</code></td>
<td>
<p>String indicating the type of centrality being evaluated.
<code>"outdegree"</code>, <code>"indegree"</code>, and <code>"total"</code> refer to
indegree, outdegree, and (total) degree respectively. <code>"all"</code> reports
all the above measures and is the default.</p>
</td></tr>
<tr><td><code id="mreach.closeness_+3A_large">large</code></td>
<td>
<p>Logical scalar, whether the computation method for large network is
implemented. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used; otherwise the method implemented in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="mreach.closeness_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the graph to be
analyzed (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mreach.closeness</code> refines the <code><a href="#topic+mreach.degree">mreach.degree</a></code> centrality
by using the (inverse) geodistance as weights, just as <code><a href="sna.html#topic+closeness">closeness</a></code>
centrality refines <code><a href="sna.html#topic+degree">degree</a></code> centrality.
It captures the degree centrality when M is properly set (e.g. M=1 in a binarized network).
It captures the Gil-Schmidt power index (Gil and Schmidt, 1996)
and the cohesion centrality (Borgatti, 2006) when M is sufficiently large
(unconstrained). The normalization factor takes care of non-binary
edge values. Also note that the geodistance matrix does
not necessarily to be symmetric.
</p>


<h3>Value</h3>

<p>A vector indicating the outdegree, indegree, or total-degree
cohesion score of the chosen player; or a data frame containing all
the above information. Note that the outdegree and indegree scores are normalized
to [0,1]. This means that the total-degree score is between [0,2].
</p>


<h3>Author(s)</h3>

<p>Weihua An <a href="mailto:weihua.an@emory.edu">weihua.an@emory.edu</a>; Yu-Hsin Liu <a href="mailto:ugeneliu@meta.com">ugeneliu@meta.com</a>
</p>


<h3>References</h3>

<p>An, Weihua and Yu-Hsin Liu (2016). &quot;keyplayer: An R Package for Locating Key Players in Social Networks.&quot;
<em>The R Journal</em>, 8(1): 257-268.<br />
</p>
<p>Borgatti, Stephen P. (2006). &quot;Identifying Sets of Key Players in a Network.&quot;
<em>Computational, Mathematical and Organizational Theory</em>, 12(1):21-34.<br />
</p>
<p>Butts, Carter T. (2014). sna: Tools for Social Network Analysis. R package
version 2.3-2. <a href="https://cran.r-project.org/package=sna">https://cran.r-project.org/package=sna</a><br />
</p>
<p>Csardi, G and Nepusz, T (2006). &quot;The igraph software package for complex network research.&quot;
InterJournal, Complex Systems 1695. <a href="https://igraph.org/">https://igraph.org/</a> <br />
</p>
<p>Gil, J and Schmidt, S (1996). &quot;The Origin of the Mexican Network of Power.&quot;
Proceedings of the International Social Network Conference, Charleston, SC, 22-25.<br />
</p>


<h3>See Also</h3>

<p><code><a href="sna.html#topic+geodist">geodist</a></code>;
<code><a href="igraph.html#topic+shortest.paths">shortest.paths</a></code>;
<code><a href="#topic+mreach.degree">mreach.degree</a></code>;
<code><a href="#topic+kpcent">kpcent</a></code>;
<code><a href="#topic+kpset">kpset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 5x5 weighted and directed adjacency matrix, where edge values
# represent the strength of tie
W &lt;- matrix(
  c(0,1,3,0,0,
    0,0,0,4,0,
    1,1,0,2,0,
    0,0,0,0,3,
    0,2,0,0,0),
    nrow=5, ncol=5, byrow = TRUE)

# Transform the edge value to distance interpretaion
A &lt;- W
A[W!=0] &lt;- 1/W[W!=0]

# List all types of 2-reach closeness scores for every node
mreach.closeness(A,M=2,cmode="all",large=FALSE)

</code></pre>

<hr>
<h2 id='mreach.degree'>Compute the M-reach Degree Centrality Score in a Netwrok</h2><span id='topic+mreach.degree'></span>

<h3>Description</h3>

<p><code>mreach.degree</code> computes the size of reachable nodes from a particular node within M steps.
M-reach degree centrality generalizes the <code><a href="sna.html#topic+degree">degree</a></code> centrality
by delimiting specific neighborhoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mreach.degree(
  adj.matrix,
  node,
  M = Inf,
  binary = TRUE,
  cmode = "all",
  large = TRUE,
  geodist.precomp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mreach.degree_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network.</p>
</td></tr>
<tr><td><code id="mreach.degree_+3A_node">node</code></td>
<td>
<p>Integer indicating the column index of the chosen player
in the adjacenncy matrix. If not specified, scores for all nodes will be reported.</p>
</td></tr>
<tr><td><code id="mreach.degree_+3A_m">M</code></td>
<td>
<p>Number indicating the maximum geodistance between two nodes,
above which the two nodes are considered disconnected.
M hence defines the reachable set. The default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="mreach.degree_+3A_binary">binary</code></td>
<td>
<p>Logical scalar. If <code>TRUE</code>, the adjacency matrix is binarized,
and thus M essentially means steps. If <code>FALSE</code>, the edge values are
considered.</p>
</td></tr>
<tr><td><code id="mreach.degree_+3A_cmode">cmode</code></td>
<td>
<p>String indicating the type of centrality being evaluated.
<code>"outdegree"</code>, <code>"indegree"</code>, and <code>"total"</code> refer to
indegree, outdegree, and (total) degree respectively. <code>"all"</code> reports
all the above measures and is the default.</p>
</td></tr>
<tr><td><code id="mreach.degree_+3A_large">large</code></td>
<td>
<p>Logical scalar, whether the computation method for large network is
implemented. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used; otherwise the method implemented in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="mreach.degree_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the graph to be
analyzed (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interprtation of the measure in binary and weighted adjacency matrix
are slightly different. In binary networks, the reachable set of nodes is defined by nodes that
are reachable within M steps. In weighted networks, the reachable set
is defined by nodes that are reachable within geodistance M.
</p>


<h3>Value</h3>

<p>A vector indicating the outdegree, indegree, or total-degree
mreach.degree score of the chosen node; or a data frame containing all
the above information.
</p>


<h3>Author(s)</h3>

<p>Weihua An <a href="mailto:weihua.an@emory.edu">weihua.an@emory.edu</a>; Yu-Hsin Liu <a href="mailto:ugeneliu@meta.com">ugeneliu@meta.com</a>
</p>


<h3>References</h3>

<p>An, Weihua and Yu-Hsin Liu (2016). &quot;keyplayer: An R Package for Locating Key Players in Social Networks.&quot;
<em>The R Journal</em>, 8(1): 257-268.<br />
</p>
<p>Butts, Carter T. (2014). sna: Tools for Social Network Analysis. R package
version 2.3-2. <a href="https://cran.r-project.org/package=sna">https://cran.r-project.org/package=sna</a><br />
</p>
<p>Csardi, G and Nepusz, T (2006). &quot;The igraph software package for complex network research.&quot;
InterJournal, Complex Systems 1695. <a href="https://igraph.org/">https://igraph.org/</a> <br />
</p>


<h3>See Also</h3>

<p><code><a href="sna.html#topic+geodist">geodist</a></code>;
<code><a href="igraph.html#topic+shortest.paths">shortest.paths</a></code>;
<code><a href="#topic+mreach.closeness">mreach.closeness</a></code>;
<code><a href="#topic+kpcent">kpcent</a></code>;
<code><a href="#topic+kpset">kpset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a 5x5 weighted and directed adjacency matrix,
# where edge values represent the strength of tie
W &lt;- matrix(
  c(0,1,3,0,0,
    0,0,0,4,0,
    1,1,0,2,0,
    0,0,0,0,3,
    0,2,0,0,0),
    nrow=5, ncol=5, byrow = TRUE)


# List the 2-reach degree scores for every node where W is binarized
mreach.degree(W,M=2,cmode="all",large=FALSE)

</code></pre>

<hr>
<h2 id='topnode'>Orders players by individual centrality from high to low</h2><span id='topic+topnode'></span>

<h3>Description</h3>

<p><code>topnode</code> Orders players by individual centrality from high to low
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topnode(
  adj.matrix,
  type,
  M = Inf,
  T = ncol(adj.matrix),
  method,
  binary = FALSE,
  cmode,
  large = TRUE,
  geodist.precomp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topnode_+3A_adj.matrix">adj.matrix</code></td>
<td>
<p>Matrix indicating the adjacency matrix of the network.</p>
</td></tr>
<tr><td><code id="topnode_+3A_type">type</code></td>
<td>
<p><code>type="betweenness"</code> for <code><a href="sna.html#topic+betweenness">betweenness</a></code> centrality. <br />
<code>type="closeness"</code> for <code><a href="sna.html#topic+closeness">closeness</a></code> centrality. <br />
<code>type="degree"</code> for <code><a href="sna.html#topic+degree">degree</a></code> centraslity. <br />
<code>type="diffusion"</code> for <code><a href="#topic+diffusion">diffusion</a></code> centrality. <br />
<code>type="evcent"</code> for <code><a href="sna.html#topic+evcent">evcent</a></code> (eigenvector) centrality. <br />
<code>type="fragment"</code> for <code><a href="#topic+fragment">fragment</a></code> centrality. <br />
<code>type="mreach.degree"</code> for <code><a href="#topic+mreach.degree">mreach.degree</a></code> centrality. <br />
<code>type="mreach.closeness"</code> for <code><a href="#topic+mreach.closeness">mreach.closeness</a></code> centrality. <br /></p>
</td></tr>
<tr><td><code id="topnode_+3A_m">M</code></td>
<td>
<p>Positive number indicating the maximum geodistance between two nodes,
above witch the two nodes are considered disconnected. The default is
<code>Inf</code>. The option is applicable to mreach.degree, mreach.closeness,
and fragmentation centralities.</p>
</td></tr>
<tr><td><code id="topnode_+3A_t">T</code></td>
<td>
<p>Integer indicating the maximum number of iterations
of communication process. For diffusion centrality only.
In the first iteration, the adjacency matrix
is as the input. In the nth iteration, the adjacency matrix becomes
the input adjacency matrix to the power of n. By default, T is the network size.</p>
</td></tr>
<tr><td><code id="topnode_+3A_method">method</code></td>
<td>
<p>Indication of which grouping criterion should be used. <br />
<code>"min"</code> indicates the &quot;minimum&quot; criterion and is suggested for
betweenness, closeness, fragmentation, and M-reach centralities. <br />
<code>"max"</code> indicates the &quot;maximum&quot; criterion and is suggested for
degree and eigenvector centralities.<br />
<code>"add"</code> indicates the &quot;addition&quot; criterion and is suggested for
degree and eigenvector centralities as an altenative of &quot;max&quot;.<br />
<code>"union"</code> indicates the &quot;union&quot; criterion and is suggested for
diffusion centrality.<br />
By default, kpset uses &quot;min&quot;.
See <code><a href="#topic+kpcent">kpcent</a></code> Details section for explanations on grouping method.</p>
</td></tr>
<tr><td><code id="topnode_+3A_binary">binary</code></td>
<td>
<p>If <code>TRUE</code>, the adjacency matrix is binarized.
If <code>FALSE</code>, the edge values are considered. By default, <code>binary=FALSE</code></p>
</td></tr>
<tr><td><code id="topnode_+3A_cmode">cmode</code></td>
<td>
<p>String indicating the type of centrality being evaluated.
The option is applicable to degree and M-reach centralities.
<code>"outdegree"</code>, <code>"indegree"</code>, and <code>"total"</code> refer to
indegree, outdegree, and (total) degree respectively. <code>"all"</code> reports
all the above measures. The default is to report the total degree.
The option also applies to closeness centrality, but with different options.
The default is to use the Gil-Schmidt power index as the closeness measure.
See <code><a href="sna.html#topic+closeness">closeness</a></code> for complete options.</p>
</td></tr>
<tr><td><code id="topnode_+3A_large">large</code></td>
<td>
<p>Logical scalar, whether the computation method for large network is
implemented. If <code>TRUE</code> (the default), the method implmented in <span class="pkg">igraph</span> is
used; otherwise the method implemented in <span class="pkg">sna</span> is used.</p>
</td></tr>
<tr><td><code id="topnode_+3A_geodist.precomp">geodist.precomp</code></td>
<td>
<p>Geodistance precomputed for the graph to be
analyzed (optional).
#'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices by individual centrality from high to low
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
