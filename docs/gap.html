<!DOCTYPE html><html><head><title>Help for package gap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a2g'><p>Allele-to-genotype conversion</p></a></li>
<li><a href='#ab'><p>Test/Power calculation for mediating effect</p></a></li>
<li><a href='#AE3'><p>AE model using nuclear family trios</p></a></li>
<li><a href='#allele.recode'><p>Allele recoding</p></a></li>
<li><a href='#asplot'><p>Regional association plot</p></a></li>
<li><a href='#b2r'><p>Obtain correlation coefficients and their variance-covariances</p></a></li>
<li><a href='#BFDP'><p>Bayesian false-discovery probability</p></a></li>
<li><a href='#bt'><p>Bradley-Terry model for contingency table</p></a></li>
<li><a href='#ccsize'><p>Power and sample size for case-cohort design</p></a></li>
<li><a href='#chow.test'><p>Chow's test for heterogeneity in two regressions</p></a></li>
<li><a href='#chr_pos_a1_a2'><p>SNP id by chr:pos+a1/a2</p></a></li>
<li><a href='#ci2ms'><p>Effect size and standard error from confidence interval</p></a></li>
<li><a href='#circos.cis.vs.trans.plot'><p>circos plot of cis/trans classification</p></a></li>
<li><a href='#circos.cnvplot'><p>circos plot of CNVs.</p></a></li>
<li><a href='#circos.mhtplot'><p>circos Manhattan plot with gene annotation</p></a></li>
<li><a href='#circos.mhtplot2'><p>Another circos Manhattan plot</p></a></li>
<li><a href='#cis.vs.trans.classification'><p>A cis/trans classifier</p></a></li>
<li><a href='#cnvplot'><p>genomewide plot of CNVs</p></a></li>
<li><a href='#comp.score'><p>score statistics for testing genetic linkage of quantitative trait</p></a></li>
<li><a href='#cs'><p>Credible set</p></a></li>
<li><a href='#ESplot'><p>Effect-size plot</p></a></li>
<li><a href='#fbsize'><p>Sample size for family-based linkage and association design</p></a></li>
<li><a href='#FPRP'><p>False-positive report probability</p></a></li>
<li><a href='#g2a'><p>Conversion of a genotype identifier to alleles</p></a></li>
<li><a href='#gap'><p>Genetic analysis package</p></a></li>
<li><a href='#gc.em'><p>Gene counting for haplotype analysis</p></a></li>
<li><a href='#gc.lambda'><p>Estimation of the genomic control inflation statistic (lambda)</p></a></li>
<li><a href='#gcontrol'><p>genomic control</p></a></li>
<li><a href='#gcontrol2'><p>genomic control based on p values</p></a></li>
<li><a href='#gcp'><p>Permutation tests using GENECOUNTING</p></a></li>
<li><a href='#genecounting'><p>Gene counting for haplotype analysis</p></a></li>
<li><a href='#geno.recode'><p>Genotype recoding</p></a></li>
<li><a href='#get_b_se'><p>Get b and se from AF, n, and z</p></a></li>
<li><a href='#get_pve_se'><p>Get pve and its standard error from n, z</p></a></li>
<li><a href='#get_sdy'><p>Get sd(y) from AF, n, b, se</p></a></li>
<li><a href='#gif'><p>Kinship coefficient and genetic index of familiality</p></a></li>
<li><a href='#grid2d'><p>Two-dimensional grid</p></a></li>
<li><a href='#h2_mzdz'><p>Heritability estimation according to twin correlations</p></a></li>
<li><a href='#h2.jags'><p>Heritability estimation based on genomic relationship matrix using JAGS</p></a></li>
<li><a href='#h2G'><p>Heritability and its variance</p></a></li>
<li><a href='#h2GE'><p>Heritability and its variance when there is an environment component</p></a></li>
<li><a href='#h2l'><p>Heritability under the liability threshold model</p></a></li>
<li><a href='#hap'><p>Haplotype reconstruction</p></a></li>
<li><a href='#hap.control'><p>Control for haplotype reconstruction</p></a></li>
<li><a href='#hap.em'><p>Gene counting for haplotype analysis</p></a></li>
<li><a href='#hap.score'><p>Score statistics for association of traits with haplotypes</p></a></li>
<li><a href='#hg18'><p>Chromosomal lengths for build 36</p></a></li>
<li><a href='#hg19'><p>Chromosomal lengths for build 37</p></a></li>
<li><a href='#hg38'><p>Chromosomal lengths for build 38</p></a></li>
<li><a href='#hmht.control'><p>Controls for highlights</p></a></li>
<li><a href='#htr'><p>Haplotype trend regression</p></a></li>
<li><a href='#hwe'><p>Hardy-Weinberg equlibrium test for a multiallelic marker</p></a></li>
<li><a href='#hwe.cc'><p>A likelihood ratio test of population Hardy-Weinberg equilibrium for case-control studies</p></a></li>
<li><a href='#hwe.hardy'><p>Hardy-Weinberg equilibrium test using MCMC</p></a></li>
<li><a href='#hwe.jags'><p>Hardy-Weinberg equlibrium test for a multiallelic marker using JAGS</p></a></li>
<li><a href='#inv_chr_pos_a1_a2'><p>Retrieval of chr:pos+a1/a2 according to SNP id</p></a></li>
<li><a href='#invnormal'><p>Inverse normal transformation</p></a></li>
<li><a href='#ixy'><p>Conversion of chrosome name from strings</p></a></li>
<li><a href='#KCC'><p>Disease prevalences in cases and controls</p></a></li>
<li><a href='#kin.morgan'><p>kinship matrix for simple pedigree</p></a></li>
<li><a href='#klem'><p>Haplotype frequency estimation based on a genotype table of two multiallelic markers</p></a></li>
<li><a href='#labelManhattan'><p>Annotate Manhattan or Miami Plot</p></a></li>
<li><a href='#LD22'><p>LD statistics for two diallelic markers</p></a></li>
<li><a href='#LDkl'><p>LD statistics for two multiallelic markers</p></a></li>
<li><a href='#log10p'><p>log10(p) for a normal deviate z</p></a></li>
<li><a href='#log10pvalue'><p>log10(p) for a P value including its scientific format</p></a></li>
<li><a href='#logp'><p>log(p) for a normal deviate z</p></a></li>
<li><a href='#makeped'><p>A function to prepare pedigrees in post-MAKEPED format</p></a></li>
<li><a href='#masize'><p>Sample size calculation for mediation analysis</p></a></li>
<li><a href='#MCMCgrm'><p>Mixed modeling with genetic relationship matrices</p></a></li>
<li><a href='#METAL_forestplot'><p>forest plot as R/meta's forest for METAL outputs</p></a></li>
<li><a href='#metap'><p>Meta-analysis of p values</p></a></li>
<li><a href='#metareg'><p>Fixed and random effects model for meta-analysis</p></a></li>
<li><a href='#mht.control'><p>Controls for mhtplot</p></a></li>
<li><a href='#mhtplot'><p>Manhattan plot</p></a></li>
<li><a href='#mhtplot.trunc'><p>Truncated Manhattan plot</p></a></li>
<li><a href='#mhtplot2'><p>Manhattan plot with annotations</p></a></li>
<li><a href='#mia'><p>Multiple imputation analysis for hap</p></a></li>
<li><a href='#miamiplot'><p>Miami plot</p></a></li>
<li><a href='#miamiplot2'><p>Miami Plot</p></a></li>
<li><a href='#mr'><p>Mendelian randomization analysis</p></a></li>
<li><a href='#mr_forestplot'><p>Mendelian Randomization forest plot</p></a></li>
<li><a href='#mtdt'><p>Transmission/disequilibrium test of a multiallelic marker</p></a></li>
<li><a href='#mtdt2'><p>Transmission/disequilibrium test of a multiallelic marker by Bradley-Terry model</p></a></li>
<li><a href='#muvar'><p>Means and variances under 1- and 2- locus (biallelic) QTL model</p></a></li>
<li><a href='#mvmeta'><p>Multivariate meta-analysis based on generalized least squares</p></a></li>
<li><a href='#pbsize'><p>Power for population-based association design</p></a></li>
<li><a href='#pbsize2'><p>Power for case-control association design</p></a></li>
<li><a href='#pedtodot'><p>Converting pedigree(s) to dot file(s)</p></a></li>
<li><a href='#pedtodot_verbatim'><p>Pedigree-drawing with graphviz</p></a></li>
<li><a href='#pfc'><p>Probability of familial clustering of disease</p></a></li>
<li><a href='#pfc.sim'><p>Probability of familial clustering of disease</p></a></li>
<li><a href='#pgc'><p>Preparing weight for GENECOUNTING</p></a></li>
<li><a href='#plot.hap.score'><p>Plot haplotype frequencies versus haplotype score statistics</p></a></li>
<li><a href='#print.hap.score'><p>Print a hap.score object</p></a></li>
<li><a href='#pvalue'><p>P value for a normal deviate</p></a></li>
<li><a href='#qqfun'><p>Quantile-comparison plots</p></a></li>
<li><a href='#qqunif'><p>Q-Q plot for uniformly distributed random variable</p></a></li>
<li><a href='#qtl2dplot'><p>2D QTL plot</p></a></li>
<li><a href='#qtl2dplotly'><p>2D QTL plotly</p></a></li>
<li><a href='#qtl3dplotly'><p>3D QTL plot</p></a></li>
<li><a href='#qtlClassifier'><p>A QTL cis/trans classifier</p></a></li>
<li><a href='#read.ms.output'><p>A utility function to read ms output</p></a></li>
<li><a href='#ReadGRM'><p>A function to read GRM file</p></a></li>
<li><a href='#ReadGRMBin'><p>A function to read GRM binary files</p></a></li>
<li><a href='#revStrand'><p>Allele on the reverse strand</p></a></li>
<li><a href='#runshinygap'><p>Start shinygap</p></a></li>
<li><a href='#s2k'><p>Statistics for 2 by K table</p></a></li>
<li><a href='#sentinels'><p>Sentinel identification from GWAS summary statistics</p></a></li>
<li><a href='#snpHWE'><p>Functions for single nucleotide polymorphisms</p></a></li>
<li><a href='#snptest_sample'><p>A utility to generate SNPTEST sample file</p></a></li>
<li><a href='#tscc'><p>Power calculation for two-stage case-control design</p></a></li>
<li><a href='#whscore'><p>Whittemore-Halpern scores for allele-sharing</p></a></li>
<li><a href='#WriteGRM'><p>A function to write GRM file</p></a></li>
<li><a href='#WriteGRMBin'><p>A function to write GRM binary file</p></a></li>
<li><a href='#xy'><p>Conversion of chromosome names to strings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genetic Analysis Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-8-25</td>
</tr>
<tr>
<td>Description:</td>
<td>As first reported [Zhao, J. H. 2007. "gap: Genetic Analysis Package". J Stat Soft 23(8):1-18.
        &lt;<a href="https://doi.org/10.18637%2Fjss.v023.i08">doi:10.18637/jss.v023.i08</a>&gt;], it is designed as an integrated package for genetic data
        analysis of both population and family data. Currently, it contains functions for
        sample size calculations of both population-based and family-based designs, probability
        of familial disease aggregation, kinship calculation, statistics in linkage analysis,
        and association analysis involving genetic markers including haplotype analysis with or
        without environmental covariates. Over years, the package has been developed in-between
        many projects hence also in line with the name (gap).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jinghuazhao/R">https://github.com/jinghuazhao/R</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jinghuazhao/R/issues">https://github.com/jinghuazhao/R/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), gap.datasets (&ge; 0.0.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, plotly, Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BradleyTerry2, DiagrammeR, DOT, MASS, Matrix, MCMCglmm,
R2jags, bdsmatrix, bookdown, calibrate, circlize, coda,
cowplot, coxme, foreign, genetics, grid, haplo.stats,
htmlwidgets, jsonlite, kinship2, knitr, lattice, magic,
manhattanly, matrixStats, meta, metafor, nlme, pedigree,
pedigreemm, plotrix, readr, reshape, rmarkdown, rms, survival</td>
</tr>
<tr>
<td>Enhances:</td>
<td>shiny</td>
</tr>
<tr>
<td>LazyData:</td>
<td>Yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>Yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Author:</td>
<td>Jing Hua Zhao <a href="https://orcid.org/0000-0002-1463-5870"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (0000-0003-4930-3582),
  Kurt Hornik [ctb],
  Brian Ripley [ctb],
  Uwe Ligges [ctb],
  Achim Zeileis [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jing Hua Zhao &lt;jinghuazhao@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-26 14:10:07 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 16:30:43 UTC; jhz22</td>
</tr>
</table>
<hr>
<h2 id='a2g'>Allele-to-genotype conversion</h2><span id='topic+a2g'></span>

<h3>Description</h3>

<p>Allele-to-genotype conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2g(a1, a2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a2g_+3A_a1">a1</code></td>
<td>
<p>first allele.</p>
</td></tr>
<tr><td><code id="a2g_+3A_a2">a2</code></td>
<td>
<p>second allele.</p>
</td></tr>
</table>

<hr>
<h2 id='ab'>Test/Power calculation for mediating effect</h2><span id='topic+ab'></span>

<h3>Description</h3>

<p>Test/Power calculation for mediating effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ab(
  type = "power",
  n = 25000,
  a = 0.15,
  sa = 0.01,
  b = log(1.19),
  sb = 0.01,
  alpha = 0.05,
  fold = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ab_+3A_type">type</code></td>
<td>
<p>string option: &quot;test&quot;, &quot;power&quot;.</p>
</td></tr>
<tr><td><code id="ab_+3A_n">n</code></td>
<td>
<p>default sample size to be used for power calculation.</p>
</td></tr>
<tr><td><code id="ab_+3A_a">a</code></td>
<td>
<p>regression coefficient from indepdendent variable to mediator.</p>
</td></tr>
<tr><td><code id="ab_+3A_sa">sa</code></td>
<td>
<p>SE(a).</p>
</td></tr>
<tr><td><code id="ab_+3A_b">b</code></td>
<td>
<p>regression coefficient from mediator variable to outcome.</p>
</td></tr>
<tr><td><code id="ab_+3A_sb">sb</code></td>
<td>
<p>SE(b).</p>
</td></tr>
<tr><td><code id="ab_+3A_alpha">alpha</code></td>
<td>
<p>size of siginficance test for power calculation.</p>
</td></tr>
<tr><td><code id="ab_+3A_fold">fold</code></td>
<td>
<p>fold change for power calculation, as appropriate for a range of sample sizes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests for or obtains power of mediating effect based on estimates of
two regression coefficients and their standard errors. Note that for binary outcome
or mediator, one should use log-odds ratio and its standard error.
</p>


<h3>Value</h3>

<p>The returned value are z-test and significance level for significant testing or sample size/power for a
given fold change of the default sample size.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Freathy RM, Timpson NJ, Lawlor DA, Pouta A, Ben-Shlomo Y, Ruokonen A, Ebrahim S, Shields B, Zeggini E, Weedon MN, Lindgren CM, Lango H, Melzer D, Ferrucci L, Paolisso G, Neville MJ, Karpe F, Palmer CN, Morris AD, Elliott P, Jarvelin MR, Smith GD, McCarthy MI, Hattersley AT, Frayling TM (2008).
&ldquo;Common variation in the FTO gene alters diabetes-related metabolic traits to the extent expected given its effect on BMI.&rdquo;
<em>Diabetes</em>, <b>57</b>(5), 1419-26.
ISSN 0012-1797 (Print) 0012-1797, <a href="https://doi.org/10.2337/db07-1466">doi:10.2337/db07-1466</a>.
</p>
<p>Kline RB. Principles and practice of structural equation modeling, Second Edition. The Guilford Press 2005.
</p>
<p>MacKinnon DP. Introduction to Statistical Mediation Analysis. Taylor &amp; Francis Group 2008.
</p>
<p>Preacher KJ, Leonardelli GJ. Calculation for the Sobel Test-An interactive calculation tool for mediation tests
https://quantpsy.org/sobel/sobel.htm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccsize">ccsize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ab()
n &lt;- power &lt;- vector()
for (j in 1:10)
{
   z &lt;- ab(fold=j*0.01)
   n[j] &lt;- z[1]
   power[j] &lt;- z[2]
}
plot(n,power,xlab="Sample size",ylab="Power")
title("SNP-BMI-T2D association in EPIC-Norfolk study")

## End(Not run)

</code></pre>

<hr>
<h2 id='AE3'>AE model using nuclear family trios</h2><span id='topic+AE3'></span>

<h3>Description</h3>

<p>AE model using nuclear family trios
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AE3(model, random, data, seed = 1234, n.sim = 50000, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AE3_+3A_model">model</code></td>
<td>
<p>a linear mixed model formula, see example below.</p>
</td></tr>
<tr><td><code id="AE3_+3A_random">random</code></td>
<td>
<p>random effect, see exampe below.</p>
</td></tr>
<tr><td><code id="AE3_+3A_data">data</code></td>
<td>
<p>data to be analyzed.</p>
</td></tr>
<tr><td><code id="AE3_+3A_seed">seed</code></td>
<td>
<p>random number seed.</p>
</td></tr>
<tr><td><code id="AE3_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="AE3_+3A_verbose">verbose</code></td>
<td>
<p>a flag for printing out results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is adapted from example 7.1 of Rabe-Hesketh et al. (2008). It
also procides heritability estimate and confidence intervals.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> lme.result the linear mixed model result.
</p>
</li>
<li><p> h2 the heritability estimate.
</p>
</li>
<li><p> CL confidence intervals.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from f.mbf.R from the paper.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Rabe-Hesketh S, Skrondal A, Gjessing HK (2008).
&ldquo;Biometrical modeling of twin and family data using standard mixed model software.&rdquo;
<em>Biometrics</em>, <b>64</b>(1), 280-8.
ISSN 0006-341X (Print) 0006-341x, <a href="https://doi.org/10.1111/j.1541-0420.2007.00803.x">doi:10.1111/j.1541-0420.2007.00803.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(gap.datasets)
AE3(bwt ~ male + first + midage + highage + birthyr,
    list(familyid = pdIdent(~var1 + var2 + var3 -1)), mfblong)

## End(Not run)

</code></pre>

<hr>
<h2 id='allele.recode'>Allele recoding</h2><span id='topic+allele.recode'></span>

<h3>Description</h3>

<p>Allele recoding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allele.recode(a1, a2, miss.val = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allele.recode_+3A_a1">a1</code></td>
<td>
<p>first allele.</p>
</td></tr>
<tr><td><code id="allele.recode_+3A_a2">a2</code></td>
<td>
<p>second allele.</p>
</td></tr>
<tr><td><code id="allele.recode_+3A_miss.val">miss.val</code></td>
<td>
<p>missing value.</p>
</td></tr>
</table>

<hr>
<h2 id='asplot'>Regional association plot</h2><span id='topic+asplot'></span>

<h3>Description</h3>

<p>Regional association plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asplot(
  locus,
  map,
  genes,
  flanking = 1000,
  best.pval = NULL,
  sf = c(4, 4),
  logpmax = 10,
  pch = 21
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asplot_+3A_locus">locus</code></td>
<td>
<p>Data frame with columns c(&quot;CHR&quot;, &quot;POS&quot;, &quot;NAME&quot;, &quot;PVAL&quot;, &quot;RSQR&quot;) containing association results.</p>
</td></tr>
<tr><td><code id="asplot_+3A_map">map</code></td>
<td>
<p>Genetic map, i.e, c(&quot;POS&quot;,&quot;THETA&quot;,&quot;DIST&quot;).</p>
</td></tr>
<tr><td><code id="asplot_+3A_genes">genes</code></td>
<td>
<p>Gene annotation with columns c(&quot;START&quot;, &quot;STOP&quot;, &quot;STRAND&quot;, &quot;GENE&quot;).</p>
</td></tr>
<tr><td><code id="asplot_+3A_flanking">flanking</code></td>
<td>
<p>Flanking length.</p>
</td></tr>
<tr><td><code id="asplot_+3A_best.pval">best.pval</code></td>
<td>
<p>Best p value for the locus of interest.</p>
</td></tr>
<tr><td><code id="asplot_+3A_sf">sf</code></td>
<td>
<p>scale factors for p values and recombination rates, smaller values are necessary for gene dense regions.</p>
</td></tr>
<tr><td><code id="asplot_+3A_logpmax">logpmax</code></td>
<td>
<p>Maximum value for -log10(p).</p>
</td></tr>
<tr><td><code id="asplot_+3A_pch">pch</code></td>
<td>
<p>Plotting character for the SNPs to be highlighted, e.g., 21 and 23 refer to circle and diamond.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function obtains regional association plot for a particular locus, based on
the information about recombinatino rates, linkage disequilibria between the
SNP of interest and neighbouring ones, and single-point association tests p values.
</p>
<p>Note that the best p value is not necessarily within locus in the original design.
</p>


<h3>Author(s)</h3>

<p>Paul de Bakker, Jing Hua Zhao, Shengxu Li
</p>


<h3>References</h3>

<p>Saxena R, Voight BF, Lyssenko V, Burtt NP, de Bakker PI, Chen H, Roix JJ, Kathiresan S, Hirschhorn JN, Daly MJ, Hughes TE, Groop L, Altshuler D, Almgren P, Florez JC, Meyer J, Ardlie K, Bengtsson Boström K, Isomaa B, Lettre G, Lindblad U, Lyon HN, Melander O, Newton-Cheh C, Nilsson P, Orho-Melander M, Råstam L, Speliotes EK, Taskinen MR, Tuomi T, Guiducci C, Berglund A, Carlson J, Gianniny L, Hackett R, Hall L, Holmkvist J, Laurila E, Sjögren M, Sterner M, Surti A, Svensson M, Svensson M, Tewhey R, Blumenstiel B, Parkin M, Defelice M, Barry R, Brodeur W, Camarata J, Chia N, Fava M, Gibbons J, Handsaker B, Healy C, Nguyen K, Gates C, Sougnez C, Gage D, Nizzari M, Gabriel SB, Chirn GW, Ma Q, Parikh H, Richardson D, Ricke D, Purcell S (2007).
&ldquo;Genome-wide association analysis identifies loci for type 2 diabetes and triglyceride levels.&rdquo;
<em>Science</em>, <b>316</b>(5829), 1331-6.
ISSN 0036-8075, <a href="https://doi.org/10.1126/science.1142358">doi:10.1126/science.1142358</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(gap.datasets)
asplot(CDKNlocus, CDKNmap, CDKNgenes)
title("CDKN2A/CDKN2B Region")
asplot(CDKNlocus, CDKNmap, CDKNgenes, best.pval=5.4e-8, sf=c(3,6))

## NCBI2R

options(stringsAsFactors=FALSE)
p &lt;- with(CDKNlocus,data.frame(SNP=NAME,PVAL))
hit &lt;- subset(p,PVAL==min(PVAL,na.rm=TRUE))$SNP

library(NCBI2R)
# LD under build 36
chr_pos &lt;- GetSNPInfo(with(p,SNP))[c("chr","chrpos")]
l &lt;- with(chr_pos,min(as.numeric(chrpos),na.rm=TRUE))
u &lt;- with(chr_pos,max(as.numeric(chrpos),na.rm=TRUE))
LD &lt;- with(chr_pos,GetLDInfo(unique(chr),l,u))
# We have complaints; a possibility is to get around with 
# https://ftp.ncbi.nlm.nih.gov/hapmap/
hit_LD &lt;- subset(LD,SNPA==hit)
hit_LD &lt;- within(hit_LD,{RSQR=r2})
info &lt;- GetSNPInfo(p$SNP)
haldane &lt;- function(x) 0.5*(1-exp(-2*x))
locus &lt;- with(info, data.frame(CHR=chr,POS=chrpos,NAME=marker,
                    DIST=(chrpos-min(chrpos))/1000000,
                    THETA=haldane((chrpos-min(chrpos))/100000000)))
locus &lt;- merge.data.frame(locus,hit_LD,by.x="NAME",by.y="SNPB",all=TRUE)
locus &lt;- merge.data.frame(locus,p,by.x="NAME",by.y="SNP",all=TRUE)
locus &lt;- subset(locus,!is.na(POS))
ann &lt;- AnnotateSNPList(p$SNP)
genes &lt;- with(ann,data.frame(ID=locusID,CLASS=fxn_class,PATH=pathways,
                             START=GeneLowPoint,STOP=GeneHighPoint,
                             STRAND=ori,GENE=genesymbol,BUILD=build,CYTO=cyto))
attach(genes)
ugenes &lt;- unique(GENE)
ustart &lt;- as.vector(as.table(by(START,GENE,min))[ugenes])
ustop &lt;- as.vector(as.table(by(STOP,GENE,max))[ugenes])
ustrand &lt;- as.vector(as.table(by(as.character(STRAND),GENE,max))[ugenes])
detach(genes)
genes &lt;- data.frame(START=ustart,STOP=ustop,STRAND=ustrand,GENE=ugenes)
genes &lt;- subset(genes,START!=0)
rm(l,u,ugenes,ustart,ustop,ustrand)
# Assume we have the latest map as in CDKNmap
asplot(locus,CDKNmap,genes)

## End(Not run)

</code></pre>

<hr>
<h2 id='b2r'>Obtain correlation coefficients and their variance-covariances</h2><span id='topic+b2r'></span>

<h3>Description</h3>

<p>Obtain correlation coefficients and their variance-covariances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b2r(b, s, rho, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b2r_+3A_b">b</code></td>
<td>
<p>the vector of linear regression coefficients.</p>
</td></tr>
<tr><td><code id="b2r_+3A_s">s</code></td>
<td>
<p>the corresponding vector of standard errors.</p>
</td></tr>
<tr><td><code id="b2r_+3A_rho">rho</code></td>
<td>
<p>triangular array of between-SNP correlation.</p>
</td></tr>
<tr><td><code id="b2r_+3A_n">n</code></td>
<td>
<p>the sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts linear regression coefficients of phenotype on
single nucleotide polymorphisms (SNPs) into Pearson correlation coefficients
with their variance-covariance matrix. It is useful as a preliminary step
for meta-analyze SNP-trait associations at a given region. Between-SNP
correlations (e.g., from HapMap) are required as auxiliary information.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> r the vector of correlation coefficients.
</p>
</li>
<li><p> V the variance-covariance matrix of correlations.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Elston RC (1975).
&ldquo;On the correlation between correlations.&rdquo;
<em>Biometrika</em>, <b>62</b>(1), 133-140.
ISSN 0006-3444, <a href="https://doi.org/10.1093/biomet/62.1.133">doi:10.1093/biomet/62.1.133</a>.
</p>
<p>Becker BJ (2000).
&ldquo;Multivariate meta-analysis.&rdquo;
In Tinsley HE, Brown SD (eds.), <em>Handbook of Applied Multivariate Statistics and Mathematical Modeling</em>, chapter 17, 499-525.
Academic Press, San Diego.
ISBN 978-0126913606, <a href="https://www.amazon.com/dp/0126913609/">https://www.amazon.com/dp/0126913609/</a>.
</p>
<p>Casella G, Berger RL (2002).
<em>Statistical Inference</em>, 2 edition.
Duxbury.
ISBN 978-0-534-24312-8, <a href="https://www.amazon.com/dp/7111109457/">https://www.amazon.com/dp/7111109457/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvmeta">mvmeta</a></code>, <code><a href="#topic+LD22">LD22</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
n &lt;- 10
r &lt;- c(1,0.2,1,0.4,0.5,1)
b &lt;- c(0.1,0.2,0.3)
s &lt;- c(0.4,0.3,0.2)
bs &lt;- b2r(b,s,r,n)

## End(Not run)

</code></pre>

<hr>
<h2 id='BFDP'>Bayesian false-discovery probability</h2><span id='topic+BFDP'></span>

<h3>Description</h3>

<p>Bayesian false-discovery probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BFDP(a, b, pi1, W, logscale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BFDP_+3A_a">a</code></td>
<td>
<p>parameter value at which the power is to be evaluated.</p>
</td></tr>
<tr><td><code id="BFDP_+3A_b">b</code></td>
<td>
<p>the variance for a, or the uppoer point (<code class="reqn">RR_{hi}</code>) of a 95%CI if logscale=FALSE.</p>
</td></tr>
<tr><td><code id="BFDP_+3A_pi1">pi1</code></td>
<td>
<p>the prior probabiility of a non-null association.</p>
</td></tr>
<tr><td><code id="BFDP_+3A_w">W</code></td>
<td>
<p>the prior variance.</p>
</td></tr>
<tr><td><code id="BFDP_+3A_logscale">logscale</code></td>
<td>
<p>FALSE=the orginal scale, TRUE=the log scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates BFDP, the approximate <code class="reqn">P(H_0|\hat\theta)</code>,
given an estiamte of the log relative risk, <code class="reqn">\hat\theta</code>, the variance of
this estimate, <code class="reqn">V</code>, the prior variance, <code class="reqn">W</code>, and the prior probability of
a non-null association. When logscale=TRUE, the function accepts an estimate of the relative
risk, <code class="reqn">\hat{RR}</code>, and the upper point of a 95% confidence interval <code class="reqn">RR_{hi}</code>.
</p>


<h3>Value</h3>

<p>The returned value is a list with the following components:
PH0. probability given a,b).
PH1. probability given a,b,W).
BF. Bayes factor, <code class="reqn">P_{H_0}/P_{H_1}</code>.
BFDP. Bayesian false-discovery probability.
ABF. approxmiate Bayes factor.
ABFDP. approximate Bayesian false-discovery probability.
</p>


<h3>Note</h3>

<p>Adapted from BFDP functions by Jon Wakefield on 17th April, 2007.
</p>


<h3>Author(s)</h3>

<p>Jon Wakefield, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Wakefield J (2007).
&ldquo;A Bayesian measure of the probability of false discovery in genetic epidemiology studies.&rdquo;
<em>Am J Hum Genet</em>, <b>81</b>(2), 208-27.
ISSN 0002-9297 (Print) 0002-9297, <a href="https://doi.org/10.1086/519024">doi:10.1086/519024</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FPRP">FPRP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example from BDFP.xls by Jon Wakefield and Stephanie Monnier
# Step 1 - Pre-set an BFDP-level threshold for noteworthiness: BFDP values below this
#          threshold are noteworthy
# The threshold is given by R/(1+R) where R is the ratio of the cost of a false
# non-discovery to the cost of a false discovery

T &lt;- 0.8

# Step 2 - Enter up values for the prior that there is an association

pi0 &lt;- c(0.7,0.5,0.01,0.001,0.00001,0.6)

# Step 3 - Enter the value of the OR that is the 97.5% point of the prior, for example
#          if we pick the value 1.5 we believe that the prior probability that the
#          odds ratio is bigger than 1.5 is 0.025.

ORhi &lt;- 3

W &lt;- (log(ORhi)/1.96)^2
W

# Step 4 - Enter OR estimate and 95% confidence interval (CI) to obtain BFDP

OR &lt;- 1.316
OR_L &lt;- 1.10
OR_U &lt;- 2.50
logOR &lt;- log(OR)
selogOR &lt;- (log(OR_U)-log(OR))/1.96
r &lt;- W/(W+selogOR^2)
r
z &lt;- logOR/selogOR
z
ABF &lt;- exp(-z^2*r/2)/sqrt(1-r)
ABF
FF &lt;- (1-pi0)/pi0
FF
BFDPex &lt;- FF*ABF/(FF*ABF+1)
BFDPex
pi0[BFDPex&gt;T]

## now turn to BFDP

pi0 &lt;- c(0.7,0.5,0.01,0.001,0.00001,0.6)
ORhi &lt;- 3
OR &lt;- 1.316
OR_U &lt;- 2.50
W &lt;- (log(ORhi)/1.96)^2
z &lt;- BFDP(OR,OR_U,pi0,W)
z

## End(Not run)
</code></pre>

<hr>
<h2 id='bt'>Bradley-Terry model for contingency table</h2><span id='topic+bt'></span>

<h3>Description</h3>

<p>Bradley-Terry model for contingency table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bt_+3A_x">x</code></td>
<td>
<p>the data table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates statistics under Bradley-Terry model.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> y A column of 1.
</p>
</li>
<li><p> count the frequency count/weight.
</p>
</li>
<li><p> allele the design matrix.
</p>
</li>
<li><p> bt.glm a glm.fit object.
</p>
</li>
<li><p> etdt.dat a data table that can be used by ETDT.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from a SAS macro for data in the example section.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Bradley RA, Terry ME (1952).
&ldquo;Rank analysis of incomplete block designs.&rdquo;
<em>Biometrika</em>, <b>39</b>, 324-335.
</p>
<p>Sham PC, Curtis D (1995).
&ldquo;An extended transmission/disequilibrium test (TDT) for multi-allele marker loci.&rdquo;
<em>Ann Hum Genet</em>, <b>59</b>(3), 323-36.
ISSN 0003-4800 (Print) 0003-4800, <a href="https://doi.org/10.1111/j.1469-1809.1995.tb00751.x">doi:10.1111/j.1469-1809.1995.tb00751.x</a>.
</p>
<p>Copeman JB, Cucca F, Hearne CM, Cornall RJ, Reed PW, Rønningen KS, Undlien DE, Nisticò L, Buzzetti R, Tosi R, et al. (1995).
&ldquo;Linkage disequilibrium mapping of a type 1 diabetes susceptibility gene (IDDM7) to chromosome 2q31-q33.&rdquo;
<em>Nat Genet</em>, <b>9</b>(1), 80-5.
ISSN 1061-4036 (Print) 1061-4036, <a href="https://doi.org/10.1038/ng0195-80">doi:10.1038/ng0195-80</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mtdt">mtdt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- matrix(c(0,0, 0, 2, 0,0, 0, 0, 0, 0, 0, 0,
              0,0, 1, 3, 0,0, 0, 2, 3, 0, 0, 0,
              2,3,26,35, 7,0, 2,10,11, 3, 4, 1,
              2,3,22,26, 6,2, 4, 4,10, 2, 2, 0,
              0,1, 7,10, 2,0, 0, 2, 2, 1, 1, 0,
              0,0, 1, 4, 0,1, 0, 1, 0, 0, 0, 0,
              0,2, 5, 4, 1,1, 0, 0, 0, 2, 0, 0,
              0,0, 2, 6, 1,0, 2, 0, 2, 0, 0, 0,
              0,3, 6,19, 6,0, 0, 2, 5, 3, 0, 0,
              0,0, 3, 1, 1,0, 0, 0, 1, 0, 0, 0,
              0,0, 0, 2, 0,0, 0, 0, 0, 0, 0, 0,
              0,0, 1, 0, 0,0, 0, 0, 0, 0, 0, 0),nrow=12)

# Bradley-Terry model, only deviance is available in glm
# (SAS gives score and Wald statistics as well)
bt.ex&lt;-bt(x)
anova(bt.ex$bt.glm)
summary(bt.ex$bt.glm)

## End(Not run)

</code></pre>

<hr>
<h2 id='ccsize'>Power and sample size for case-cohort design</h2><span id='topic+ccsize'></span>

<h3>Description</h3>

<p>Power and sample size for case-cohort design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccsize(n, q, pD, p1, theta, alpha, beta = 0.2, power = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccsize_+3A_n">n</code></td>
<td>
<p>the total number of subjects in the cohort.</p>
</td></tr>
<tr><td><code id="ccsize_+3A_q">q</code></td>
<td>
<p>the sampling fraction of the subcohort.</p>
</td></tr>
<tr><td><code id="ccsize_+3A_pd">pD</code></td>
<td>
<p>the proportion of the failures in the full cohort.</p>
</td></tr>
<tr><td><code id="ccsize_+3A_p1">p1</code></td>
<td>
<p>proportions of the two groups (p2=1-p1).</p>
</td></tr>
<tr><td><code id="ccsize_+3A_theta">theta</code></td>
<td>
<p>log-hazard ratio for two groups.</p>
</td></tr>
<tr><td><code id="ccsize_+3A_alpha">alpha</code></td>
<td>
<p>type I error &ndash; significant level.</p>
</td></tr>
<tr><td><code id="ccsize_+3A_beta">beta</code></td>
<td>
<p>type II error.</p>
</td></tr>
<tr><td><code id="ccsize_+3A_power">power</code></td>
<td>
<p>if specified, the power for which sample size is calculated.</p>
</td></tr>
<tr><td><code id="ccsize_+3A_verbose">verbose</code></td>
<td>
<p>error messages are explicitly printed out.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power of the test is according to
</p>
<p style="text-align: center;"><code class="reqn">\Phi\left(Z_\alpha+m^{1/2}\theta\sqrt{\frac{p_1p_2p_D}{q+(1-q)p_D}}\right)</code>
</p>

<p>where <code class="reqn">\alpha</code> is the significance level, <code class="reqn">\theta</code> is the log-hazard ratio for two groups, <code class="reqn">p_j</code>,
j=1, 2, are the proportion of the two groups in the population. <code class="reqn">m</code> is the total number of subjects in the subcohort,
<code class="reqn">p_D</code> is the proportion of the failures in the full cohort, and <code class="reqn">q</code> is the sampling fraction of the subcohort.
</p>
<p>Alternatively, the sample size required for the subcohort is </p>
<p style="text-align: center;"><code class="reqn">m=nBp_D/(n-B(1-p_D))</code>
</p>

<p>where <code class="reqn">B=(Z_{1-\alpha}+Z_\beta)^2/(\theta^2p_1p_2p_D)</code>, and <code class="reqn">n</code> is the size of cohort.
</p>
<p>When infeaisble configurations are specified, a sample size of -999 is returned.
</p>


<h3>Value</h3>

<p>The returned value is a value indicating the power or required sample size.
</p>


<h3>Note</h3>

<p>Programmed for EPIC study.
keywords misc
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Cai J, Zeng D (2004).
&ldquo;Sample size/power calculation for case-cohort studies.&rdquo;
<em>Biometrics</em>, <b>60</b>(4), 1015-24.
ISSN 0006-341X (Print) 0006-341x, <a href="https://doi.org/10.1111/j.0006-341X.2004.00257.x">doi:10.1111/j.0006-341X.2004.00257.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbsize">pbsize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Table 1 of Cai &amp; Zeng (2004).
outfile &lt;- "table1.txt"
cat("n","pD","p1","theta","q","power\n",file=outfile,sep="\t")
alpha &lt;- 0.05
n &lt;- 1000
for(pD in c(0.10,0.05))
{
   for(p1 in c(0.3,0.5))
   {
      for(theta in c(0.5,1.0))
      {
         for(q in c(0.1,0.2))
         {
            power &lt;- ccsize(n,q,pD,p1,alpha,theta)
            cat(n,"\t",pD,"\t",p1,"\t",theta,"\t",q,"\t",signif(power,3),"\n",
                file=outfile,append=TRUE)
         }
      }
   }
}
n &lt;- 5000
for(pD in c(0.05,0.01))
{
   for(p1 in c(0.3,0.5))
   {
      for(theta in c(0.5,1.0))
      {
         for(q in c(0.01,0.02))
         {
            power &lt;- ccsize(n,q,pD,p1,alpha,theta)
            cat(n,"\t",pD,"\t",p1,"\t",theta,"\t",q,"\t",signif(power,3),"\n",
                file=outfile,append=TRUE)
         }
      }
   }
}
table1&lt;-read.table(outfile,header=TRUE,sep="\t")
unlink(outfile)
# ARIC study
outfile &lt;- "aric.txt"
n &lt;- 15792
pD &lt;- 0.03
p1 &lt;- 0.25
alpha &lt;- 0.05
theta &lt;- c(1.35,1.40,1.45)
beta1 &lt;- 0.8
s_nb &lt;- c(1463,722,468)
cat("n","pD","p1","hr","q","power","ssize\n",file=outfile,sep="\t")
for(i in 1:3)
{
  q &lt;- s_nb[i]/n
  power &lt;- ccsize(n,q,pD,p1,alpha,log(theta[i]))
  ssize &lt;- ccsize(n,q,pD,p1,alpha,log(theta[i]),beta1)
  cat(n,"\t",pD,"\t",p1,"\t",theta[i],"\t",q,"\t",signif(power,3),"\t",ssize,"\n",
      file=outfile,append=TRUE)
}
aric&lt;-read.table(outfile,header=TRUE,sep="\t")
unlink(outfile)
# EPIC study
outfile &lt;- "epic.txt"
n &lt;- 25000
alpha &lt;- 0.00000005
power &lt;- 0.8
s_pD &lt;- c(0.3,0.2,0.1,0.05)
s_p1 &lt;- seq(0.1,0.5,by=0.1)
s_hr &lt;- seq(1.1,1.4,by=0.1)
cat("n","pD","p1","hr","alpha","ssize\n",file=outfile,sep="\t")
# direct calculation
for(pD in s_pD)
{
   for(p1 in s_p1)
   {
      for(hr in s_hr)
      {
         ssize &lt;- ccsize(n,q,pD,p1,alpha,log(hr),power)
         if (ssize&gt;0) cat(n,"\t",pD,"\t",p1,"\t",hr,"\t",alpha,"\t",ssize,"\n",
                          file=outfile,append=TRUE)
      }
   }
}
epic&lt;-read.table(outfile,header=TRUE,sep="\t")
unlink(outfile)
# exhaustive search
outfile &lt;- "search.txt"
s_q &lt;- seq(0.01,0.5,by=0.01)
cat("n","pD","p1","hr","nq","alpha","power\n",file=outfile,sep="\t")
for(pD in s_pD)
{
   for(p1 in s_p1)
   {
      for(hr in s_hr)
      {
         for(q in s_q)
         {
            power &lt;- ccsize(n,q,pD,p1,alpha,log(hr))
            cat(n,"\t",pD,"\t",p1,"\t",hr,"\t",q*n,"\t",alpha,"\t",power,"\n",
                file=outfile,append=TRUE)
         }
      }
   }
}
search&lt;-read.table(outfile,header=TRUE,sep="\t")
unlink(outfile)

## End(Not run)
</code></pre>

<hr>
<h2 id='chow.test'>Chow's test for heterogeneity in two regressions</h2><span id='topic+chow.test'></span>

<h3>Description</h3>

<p>Chow's test for heterogeneity in two regressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chow.test(y1, x1, y2, x2, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chow.test_+3A_y1">y1</code></td>
<td>
<p>a vector of dependent variable.</p>
</td></tr>
<tr><td><code id="chow.test_+3A_x1">x1</code></td>
<td>
<p>a matrix of independent variables.</p>
</td></tr>
<tr><td><code id="chow.test_+3A_y2">y2</code></td>
<td>
<p>a vector of dependent variable.</p>
</td></tr>
<tr><td><code id="chow.test_+3A_x2">x2</code></td>
<td>
<p>a matrix of independent variables.</p>
</td></tr>
<tr><td><code id="chow.test_+3A_x">x</code></td>
<td>
<p>a known matrix of independent variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Chow's test is for differences between two or more regressions.  Assuming that
errors in regressions 1 and 2 are normally distributed with zero mean and
homoscedastic variance, and they are independent of each other, the test of
regressions from sample sizes <code class="reqn">n_1</code> and <code class="reqn">n_2</code> is then carried out using
the following steps.  1.  Run a regression on the combined sample with size
<code class="reqn">n=n_1+n_2</code> and obtain within group sum of squares called <code class="reqn">S_1</code>.  The
number of degrees of freedom is <code class="reqn">n_1+n_2-k</code>, with <code class="reqn">k</code> being the number
of parameters estimated, including the intercept.  2.  Run two regressions on
the two individual samples with sizes <code class="reqn">n_1</code> and <code class="reqn">n_2</code>, and obtain their
within group sums of square <code class="reqn">S_2+S_3</code>, with <code class="reqn">n_1+n_2-2k</code> degrees of
freedom.  3.  Conduct an <code class="reqn">F_{(k,n_1+n_2-2k)}</code> test defined by </p>
<p style="text-align: center;"><code class="reqn">F =
\frac{[S_1-(S_2+S_3)]/k}{[(S_2+S_3)/(n_1+n_2-2k)]}</code>
</p>
<p> If the <code class="reqn">F</code> statistic
exceeds the critical <code class="reqn">F</code>, we reject the null hypothesis that the two
regressions are equal.
</p>
<p>In the case of haplotype trend regression, haplotype frequencies from combined
data are known, so can be directly used.
</p>


<h3>Value</h3>

<p>The returned value is a vector containing (please use subscript to access them):
</p>

<ul>
<li><p> F the F statistic.
</p>
</li>
<li><p> df1 the numerator degree(s) of freedom.
</p>
</li>
<li><p> df2 the denominator degree(s) of freedom.
</p>
</li>
<li><p> p the p value for the F test.
</p>
</li></ul>



<h3>Note</h3>

<p>adapted from chow.R.
</p>


<h3>Author(s)</h3>

<p>Shigenobu Aoki, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Chow GC (1960).
&ldquo;Tests of Equality Between Sets of Coefficients in Two Linear Regressions.&rdquo;
<em>Econometrica</em>, <b>28</b>(3), 591-605.
ISSN 00129682, 14680262, <a href="https://doi.org/10.2307/1910133">doi:10.2307/1910133</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+htr">htr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat1 &lt;- matrix(c(
     1.2, 1.9, 0.9,
     1.6, 2.7, 1.3,
     3.5, 3.7, 2.0,
     4.0, 3.1, 1.8,
     5.6, 3.5, 2.2,
     5.7, 7.5, 3.5,
     6.7, 1.2, 1.9,
     7.5, 3.7, 2.7,
     8.5, 0.6, 2.1,
     9.7, 5.1, 3.6), byrow=TRUE, ncol=3)

dat2 &lt;- matrix(c(
     1.4, 1.3, 0.5,
     1.5, 2.3, 1.3,
     3.1, 3.2, 2.5,
     4.4, 3.6, 1.1,
     5.1, 3.1, 2.8,
     5.2, 7.3, 3.3,
     6.5, 1.5, 1.3,
     7.8, 3.2, 2.2,
     8.1, 0.1, 2.8,
     9.5, 5.6, 3.9), byrow=TRUE, ncol=3)

y1&lt;-dat1[,3]
y2&lt;-dat2[,3]
x1&lt;-dat1[,1:2]
x2&lt;-dat2[,1:2]
chow.test.r&lt;-chow.test(y1,x1,y2,x2)
# from http://aoki2.si.gunma-u.ac.jp/R/

## End(Not run)

</code></pre>

<hr>
<h2 id='chr_pos_a1_a2'>SNP id by chr:pos+a1/a2</h2><span id='topic+chr_pos_a1_a2'></span>

<h3>Description</h3>

<p>SNP id by chr:pos+a1/a2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chr_pos_a1_a2(
  chr,
  pos,
  a1,
  a2,
  prefix = "chr",
  seps = c(":", "_", "_"),
  uppercase = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chr_pos_a1_a2_+3A_chr">chr</code></td>
<td>
<p>Chromosome.</p>
</td></tr>
<tr><td><code id="chr_pos_a1_a2_+3A_pos">pos</code></td>
<td>
<p>Position.</p>
</td></tr>
<tr><td><code id="chr_pos_a1_a2_+3A_a1">a1</code></td>
<td>
<p>Allele 1.</p>
</td></tr>
<tr><td><code id="chr_pos_a1_a2_+3A_a2">a2</code></td>
<td>
<p>Allele 2.</p>
</td></tr>
<tr><td><code id="chr_pos_a1_a2_+3A_prefix">prefix</code></td>
<td>
<p>Prefix of the identifier.</p>
</td></tr>
<tr><td><code id="chr_pos_a1_a2_+3A_seps">seps</code></td>
<td>
<p>Delimiters.</p>
</td></tr>
<tr><td><code id="chr_pos_a1_a2_+3A_uppercase">uppercase</code></td>
<td>
<p>A flag to return in upper case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates unique identifiers for variants
</p>


<h3>Value</h3>

<p>Identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rs12075
chr_pos_a1_a2(1,159175354,"A","G",prefix="chr",seps=c(":","_","_"),uppercase=TRUE)
</code></pre>

<hr>
<h2 id='ci2ms'>Effect size and standard error from confidence interval</h2><span id='topic+ci2ms'></span>

<h3>Description</h3>

<p>Effect size and standard error from confidence interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci2ms(ci, logscale = TRUE, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci2ms_+3A_ci">ci</code></td>
<td>
<p>confidence interval (CI). The delimiter between lower and upper limit is either a hyphen (-) or en dash (–).</p>
</td></tr>
<tr><td><code id="ci2ms_+3A_logscale">logscale</code></td>
<td>
<p>a flag indicating the confidence interval is based on a log-scale.</p>
</td></tr>
<tr><td><code id="ci2ms_+3A_alpha">alpha</code></td>
<td>
<p>Type 1 error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Effect size is a measure of strength of the relationship between two variables in a population or parameter estimate of that population.
Without loss of generality, denote <code>m</code> and <code>s</code> to be the mean and standard deviation of a sample from <code class="reqn">N(\mu,\sigma^2)</code>).
Let <code class="reqn">z \sim N(0,1)</code> with cutoff point <code class="reqn">z_\alpha</code>, confidence limits <code>L</code>, <code>U</code> in a CI are defined as follows,
</p>
<p style="text-align: center;"><code class="reqn">
\begin{aligned}
L &amp; = m - z_\alpha s \cr
U &amp; = m + z_\alpha s
\end{aligned}
</code>
</p>

<p><code class="reqn">\Rightarrow</code> <code class="reqn">U + L = 2 m</code>, <code class="reqn">U - L=2 z_\alpha s</code>. Consequently,
</p>
<p style="text-align: center;"><code class="reqn">
\begin{aligned}
m &amp; = \frac{U + L}{2} \cr
s &amp; = \frac{U - L}{2 z_\alpha}
\end{aligned}
</code>
</p>

<p>Effect size in epidemiological studies on a binary outcome is typically reported as odds ratio from a logistic regression
or hazard ratio from a Cox regression, <code class="reqn">L\equiv\log(L)</code>, <code class="reqn">U\equiv\log(U)</code>.
</p>


<h3>Value</h3>

<p>Based on CI, the function provides a list containing estimates
</p>

<ul>
<li><p> m effect size (log(OR))
</p>
</li>
<li><p> s standard error
</p>
</li>
<li><p> direction a decrease/increase (-/+) sign such that <code>sign(m)</code>=-1, 0, 1, is labelled &quot;-&quot;, &quot;0&quot;, &quot;+&quot;, respectively as in PhenoScanner.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># rs3784099 and breast cancer recurrence/mortality
ms &lt;- ci2ms("1.28-1.72")
print(ms)
# Vector input
ci2 &lt;- c("1.28-1.72","1.25-1.64")
ms2 &lt;- ci2ms(ci2)
print(ms2)
</code></pre>

<hr>
<h2 id='circos.cis.vs.trans.plot'>circos plot of cis/trans classification</h2><span id='topic+circos.cis.vs.trans.plot'></span>

<h3>Description</h3>

<p>circos plot of cis/trans classification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circos.cis.vs.trans.plot(hits, panel, id, radius = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circos.cis.vs.trans.plot_+3A_hits">hits</code></td>
<td>
<p>A text file as input data with varibles named &quot;CHR&quot;,&quot;BP&quot;,&quot;SNP&quot;,&quot;prot&quot;.</p>
</td></tr>
<tr><td><code id="circos.cis.vs.trans.plot_+3A_panel">panel</code></td>
<td>
<p>Protein panel with prot(ein), uniprot (id) and &quot;chr&quot;,&quot;start&quot;,&quot;end&quot;,&quot;gene&quot;.</p>
</td></tr>
<tr><td><code id="circos.cis.vs.trans.plot_+3A_id">id</code></td>
<td>
<p>Identifier.</p>
</td></tr>
<tr><td><code id="circos.cis.vs.trans.plot_+3A_radius">radius</code></td>
<td>
<p>The flanking distance as cis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements a circos plot at the early stage of SCALLOP-INF meta-analysis.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  circos.cis.vs.trans.plot(hits="INF1.merge", panel=inf1, id="uniprot")

## End(Not run)
</code></pre>

<hr>
<h2 id='circos.cnvplot'>circos plot of CNVs.</h2><span id='topic+circos.cnvplot'></span>

<h3>Description</h3>

<p>circos plot of CNVs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circos.cnvplot(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circos.cnvplot_+3A_data">data</code></td>
<td>
<p>CNV data containing chromosome, start, end and freq.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots frequency of CNVs.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
circos.cnvplot(cnv)

## End(Not run)
</code></pre>

<hr>
<h2 id='circos.mhtplot'>circos Manhattan plot with gene annotation</h2><span id='topic+circos.mhtplot'></span>

<h3>Description</h3>

<p>circos Manhattan plot with gene annotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circos.mhtplot(data, glist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circos.mhtplot_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="circos.mhtplot_+3A_glist">glist</code></td>
<td>
<p>A gene list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates circos Manhattan plot with gene annotation.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(gap.datasets)
glist &lt;- c("IRS1","SPRY2","FTO","GRIK3","SNED1","HTR1A","MARCH3","WISP3",
           "PPP1R3B","RP1L1","FDFT1","SLC39A14","GFRA1","MC4R")
circos.mhtplot(mhtdata,glist)

## End(Not run)

</code></pre>

<hr>
<h2 id='circos.mhtplot2'>Another circos Manhattan plot</h2><span id='topic+circos.mhtplot2'></span>

<h3>Description</h3>

<p>Another circos Manhattan plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circos.mhtplot2(dat, labs, species = "hg18", ticks = 0:3 * 10, y = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circos.mhtplot2_+3A_dat">dat</code></td>
<td>
<p>Data to be plotted with variables chr, pos, log10p.</p>
</td></tr>
<tr><td><code id="circos.mhtplot2_+3A_labs">labs</code></td>
<td>
<p>Data on labels.</p>
</td></tr>
<tr><td><code id="circos.mhtplot2_+3A_species">species</code></td>
<td>
<p>Genome build.</p>
</td></tr>
<tr><td><code id="circos.mhtplot2_+3A_ticks">ticks</code></td>
<td>
<p>Tick positions.</p>
</td></tr>
<tr><td><code id="circos.mhtplot2_+3A_y">y</code></td>
<td>
<p>Starting position of y-axis label.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is adapted from work for a recent publication. It enables a y-axis to the -log10(P) for association statistics
</p>


<h3>Value</h3>

<p>There is no return value but a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(gap.datasets)
library(dplyr)
glist &lt;- c("IRS1","SPRY2","FTO","GRIK3","SNED1","HTR1A","MARCH3","WISP3",
           "PPP1R3B","RP1L1","FDFT1","SLC39A14","GFRA1","MC4R")
testdat &lt;- mhtdata[c("chr","pos","p","gene","start","end")] %&gt;%
           rename(log10p=p) %&gt;%
           mutate(chr=paste0("chr",chr),log10p=-log10(log10p))
dat &lt;- mutate(testdat,start=pos,end=pos) %&gt;%
       select(chr,start,end,log10p)
labs &lt;- subset(testdat,gene %in% glist) %&gt;%
        group_by(gene,chr,start,end) %&gt;%
        summarize() %&gt;%
        mutate(cols="blue") %&gt;%
        select(chr,start,end,gene,cols)
labs[2,"cols"] &lt;- "red"
circos.mhtplot2(dat,labs,ticks=0:2*10)
# https://www.rapidtables.com/web/color/RGB_Color.html

## End(Not run)
</code></pre>

<hr>
<h2 id='cis.vs.trans.classification'>A cis/trans classifier</h2><span id='topic+cis.vs.trans.classification'></span>

<h3>Description</h3>

<p>A cis/trans classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cis.vs.trans.classification(hits, panel, id, radius = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cis.vs.trans.classification_+3A_hits">hits</code></td>
<td>
<p>Data to be used, which contains prot, Chr, bp, id and/or other information such as SNPid.</p>
</td></tr>
<tr><td><code id="cis.vs.trans.classification_+3A_panel">panel</code></td>
<td>
<p>Panel data.</p>
</td></tr>
<tr><td><code id="cis.vs.trans.classification_+3A_id">id</code></td>
<td>
<p>Identifier.</p>
</td></tr>
<tr><td><code id="cis.vs.trans.classification_+3A_radius">radius</code></td>
<td>
<p>The flanking distance for variants.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function classifies variants into cis/trans category according to a panel which contains id, chr, start, end, gene variables.
</p>


<h3>Value</h3>

<p>The cis/trans classification.
</p>


<h3>Author(s)</h3>

<p>James Peters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cis.vs.trans.classification(hits=jma.cojo, panel=inf1, id="uniprot")
## Not run: 
INF &lt;- Sys.getenv("INF")
f &lt;- file.path(INF,"work","INF1.merge")
clumped &lt;- read.delim(f,as.is=TRUE)
hits &lt;- merge(clumped[c("CHR","POS","MarkerName","prot","log10p")],
              inf1[c("prot","uniprot")],by="prot")
names(hits) &lt;- c("prot","Chr","bp","SNP","log10p","uniprot")
cistrans &lt;- cis.vs.trans.classification(hits,inf1,"uniprot")
cis.vs.trans &lt;- with(cistrans,data)
knitr::kable(with(cistrans,table),caption="Table 1. cis/trans classification")
with(cistrans,total)

## End(Not run)
</code></pre>

<hr>
<h2 id='cnvplot'>genomewide plot of CNVs</h2><span id='topic+cnvplot'></span>

<h3>Description</h3>

<p>genomewide plot of CNVs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnvplot(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnvplot_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a plot containing genomewide copy number variants (CNV) chr, start, end, freq(uencies).
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knitr::kable(cnv,caption="A CNV dataset")
cnvplot(cnv)
</code></pre>

<hr>
<h2 id='comp.score'>score statistics for testing genetic linkage of quantitative trait</h2><span id='topic+comp.score'></span>

<h3>Description</h3>

<p>score statistics for testing genetic linkage of quantitative trait
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp.score(
  ibddata = "ibd_dist.out",
  phenotype = "pheno.dat",
  mean = 0,
  var = 1,
  h2 = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp.score_+3A_ibddata">ibddata</code></td>
<td>
<p>The output file from GENEHUNTER using command &quot;dump ibd&quot;. The default file name is <code class="reqn">ibd_dist.out</code>.</p>
</td></tr>
<tr><td><code id="comp.score_+3A_phenotype">phenotype</code></td>
<td>
<p>The file of pedigree structure and trait value.
The default file name is &quot;pheno.dat&quot;. Columns (no headings) are:
family ID, person ID, father ID, mother ID, gender, trait value,
where Family ID and person ID must be numbers, not characters.
Use character &quot;NA&quot; for missing phenotypes.</p>
</td></tr>
<tr><td><code id="comp.score_+3A_mean">mean</code></td>
<td>
<p>(population) mean of the trait, with a default value of 0.</p>
</td></tr>
<tr><td><code id="comp.score_+3A_var">var</code></td>
<td>
<p>(population) variance of the trait, with a default value of 1.</p>
</td></tr>
<tr><td><code id="comp.score_+3A_h2">h2</code></td>
<td>
<p>heritability of the trait, with a default value of 0.3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function empirically estimate the variance of the score functions.
The variance-covariance matrix consists of two parts: the additive
part and the part for the individual-specific environmental effect.
Other reasonable decompositions are possible.
</p>
<p>This program has the following improvement over &quot;score.r&quot;:
</p>

<ol>
<li><p> It works with selected nuclear families
</p>
</li>
<li><p> Trait data on parents (one parent or two parents), if available,
are utilized.
</p>
</li>
<li><p> Besides a statistic assuming no locus-specific dominance effect,
it also computes a statistic that allows for such effect.
It computes two statistics instead of one.
</p>
</li></ol>

<p>Function &quot;merge&quot; is used to merge the IBD data for a pair with the
transformed trait data (i.e., <code class="reqn">w_kw_l</code>).
</p>


<h3>Value</h3>

<p>a matrix with each row containing the location and the statistics and their p-values.
</p>


<h3>Note</h3>

<p>Adapt from score2.r.
</p>


<h3>Author(s)</h3>

<p>Yingwei Peng, Kai Wang
</p>


<h3>References</h3>

<p>Kruglyak L, Daly MJ, Reeve-Daly MP, Lander ES (1996).
&ldquo;Parametric and nonparametric linkage analysis: a unified multipoint approach.&rdquo;
<em>Am J Hum Genet</em>, <b>58</b>(6), 1347-63.
ISSN 0002-9297 (Print) 0002-9297.
</p>
<p>Kruglyak L, Lander ES (1998).
&ldquo;Faster multipoint linkage analysis using Fourier transforms.&rdquo;
<em>J Comput Biol</em>, <b>5</b>(1), 1-7.
ISSN 1066-5277 (Print) 1066-5277, <a href="https://doi.org/10.1089/cmb.1998.5.1">doi:10.1089/cmb.1998.5.1</a>.
</p>
<p>Wang K (2005).
&ldquo;A likelihood approach for quantitative-trait-locus mapping with selected pedigrees.&rdquo;
<em>Biometrics</em>, <b>61</b>(2), 465-73.
ISSN 0006-341X (Print) 0006-341x, <a href="https://doi.org/10.1111/j.1541-0420.2005.031213.x">doi:10.1111/j.1541-0420.2005.031213.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# An example based on GENEHUNTER version 2.1, with quantitative trait data in file
# "pheno.dat" generated from the  standard normal distribution. The following
# exmaple shows that it is possible to automatically call GENEHUNTER using R
# function "system".

cwd &lt;- getwd()
cs.dir &lt;- file.path(find.package("gap"),"tests/comp.score")
setwd(cs.dir)
dir()
# system("gh &lt; gh.inp")
cs.default &lt;- comp.score()
setwd(cwd)

## End(Not run)

</code></pre>

<hr>
<h2 id='cs'>Credible set</h2><span id='topic+cs'></span>

<h3>Description</h3>

<p>Credible set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cs(tbl, b = "Effect", se = "StdErr", log_p = NULL, cutoff = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cs_+3A_tbl">tbl</code></td>
<td>
<p>Input data.</p>
</td></tr>
<tr><td><code id="cs_+3A_b">b</code></td>
<td>
<p>Effect size.</p>
</td></tr>
<tr><td><code id="cs_+3A_se">se</code></td>
<td>
<p>Standard error.</p>
</td></tr>
<tr><td><code id="cs_+3A_log_p">log_p</code></td>
<td>
<p>if not NULL it will be used to derive z-statistic</p>
</td></tr>
<tr><td><code id="cs_+3A_cutoff">cutoff</code></td>
<td>
<p>Threshold for inclusion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements credible set as in fine-mapping.
</p>


<h3>Value</h3>

<p>Credible set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
\preformatted{
  zcat METAL/4E.BP1-1.tbl.gz | \
  awk 'NR==1 || ($1==4 &amp;&amp; $2 &gt;= 187158034 - 1e6 &amp;&amp; $2 &lt; 187158034 + 1e6)' &gt; 4E.BP1.z
}
  tbl &lt;- within(read.delim("4E.BP1.z"),{logp &lt;- logp(Effect/StdErr)})
  z &lt;- cs(tbl)
  l &lt;- cs(tbl,log_p="logp")

## End(Not run)
</code></pre>

<hr>
<h2 id='ESplot'>Effect-size plot</h2><span id='topic+ESplot'></span>

<h3>Description</h3>

<p>Effect-size plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ESplot(ESdat, alpha = 0.05, fontsize = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ESplot_+3A_esdat">ESdat</code></td>
<td>
<p>A data frame consisting of model id, parameter estimates and standard errors.</p>
</td></tr>
<tr><td><code id="ESplot_+3A_alpha">alpha</code></td>
<td>
<p>Type-I error rate used to construct 100(1-alpha) confidence interval.</p>
</td></tr>
<tr><td><code id="ESplot_+3A_fontsize">fontsize</code></td>
<td>
<p>size of font.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function accepts parameter estimates and their standard errors for a range of models.
</p>


<h3>Value</h3>

<p>A high resolution plot object.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rs12075 &lt;- data.frame(id=c("CCL2","CCL7","CCL8","CCL11","CCL13","CXCL6","Monocytes"),
                      b=c(0.1694,-0.0899,-0.0973,0.0749,0.189,0.0816,0.0338387),
                      se=c(0.0113,0.013,0.0116,0.0114,0.0114,0.0115,0.00713386))
ESplot(rs12075)

# The function replaces an older implementation.
within(data.frame(
       id=c("Basic model","Adjusted","Moderately adjusted","Heavily adjusted","Other"),
       b=log(c(4.5,3.5,2.5,1.5,1)),
       se=c(0.2,0.1,0.2,0.3,0.2)
), {
   lcl &lt;- exp(b-1.96*se)
   ucl &lt;- exp(b+1.96*se)
   x &lt;- seq(-2,8,length=length(id))
   y &lt;- 1:length(id)
   plot(x,y,type="n",xlab="",ylab="",axes=FALSE)
   points((lcl+ucl)/2,y,pch=22,bg="black",cex=3)
   segments(lcl,y,ucl,y,lwd=3,lty="solid")
   axis(1,cex.axis=1.5,lwd=0.5)
   par(las=1)
   abline(v=1)
   axis(2,labels=id,at=y,lty="blank",hadj=0.2,cex.axis=1.5)
   title("A fictitious plot")
})
</code></pre>

<hr>
<h2 id='fbsize'>Sample size for family-based linkage and association design</h2><span id='topic+fbsize'></span>

<h3>Description</h3>

<p>Sample size for family-based linkage and association design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbsize(
  gamma,
  p,
  alpha = c(1e-04, 1e-08, 1e-08),
  beta = 0.2,
  debug = 0,
  error = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fbsize_+3A_gamma">gamma</code></td>
<td>
<p>genotype relative risk assuming multiplicative model.</p>
</td></tr>
<tr><td><code id="fbsize_+3A_p">p</code></td>
<td>
<p>frequency of disease allele.</p>
</td></tr>
<tr><td><code id="fbsize_+3A_alpha">alpha</code></td>
<td>
<p>Type I error rates for ASP linkage, TDT and ASP-TDT.</p>
</td></tr>
<tr><td><code id="fbsize_+3A_beta">beta</code></td>
<td>
<p>Type II error rate.</p>
</td></tr>
<tr><td><code id="fbsize_+3A_debug">debug</code></td>
<td>
<p>verbose output.</p>
</td></tr>
<tr><td><code id="fbsize_+3A_error">error</code></td>
<td>
<p>0=use the correct formula,1=the original paper.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements Risch and Merikangas (1996) statistics
evaluating power for family-based linkage (affected sib pairs, ASP) and
association design. They are potentially useful in the prospect of
genome-wide association studies.
</p>
<p>The function calls auxiliary functions sn() and strlen; <code>sn()</code>
contains the necessary thresholds for power calculation while
<code>strlen()</code> evaluates length of a string (generic).
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> gamma input gamma.
</p>
</li>
<li><p> p input p.
</p>
</li>
<li><p> n1 sample size for ASP.
</p>
</li>
<li><p> n2 sample size for TDT.
</p>
</li>
<li><p> n3 sample size for ASP-TDT.
</p>
</li>
<li><p> lambdao lambda o.
</p>
</li>
<li><p> lambdas lambda s.
</p>
</li></ul>



<h3>Note</h3>

<p>extracted from rm.c.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Risch, N. and K. Merikangas (1996). The future of genetic studies of
complex human diseases. Science 273(September): 1516-1517.
</p>
<p>Risch, N. and K. Merikangas (1997). Reply to Scott el al. Science
275(February): 1329-1330.
</p>
<p>Scott, W. K., M. A. Pericak-Vance, et al. (1997). Genetic analysis of
complex diseases. Science 275: 1327.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbsize">pbsize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>models &lt;- matrix(c(
   4.0, 0.01,
   4.0, 0.10,
   4.0, 0.50, 
   4.0, 0.80,
   2.0, 0.01,
   2.0, 0.10,
   2.0, 0.50,
   2.0, 0.80,
   1.5, 0.01,    
   1.5, 0.10,
   1.5, 0.50,
   1.5, 0.80), ncol=2, byrow=TRUE)
outfile &lt;- "fbsize.txt"
cat("gamma","p","Y","N_asp","P_A","H1","N_tdt","H2","N_asp/tdt","L_o","L_s\n",
    file=outfile,sep="\t")
for(i in 1:12) {
  g &lt;- models[i,1]
  p &lt;- models[i,2]
  z &lt;- fbsize(g,p)
  cat(z$gamma,z$p,z$y,z$n1,z$pA,z$h1,z$n2,z$h2,z$n3,z$lambdao,z$lambdas,file=outfile,
      append=TRUE,sep="\t")
  cat("\n",file=outfile,append=TRUE)
}
table1 &lt;- read.table(outfile,header=TRUE,sep="\t")
nc &lt;- c(4,7,9)
table1[,nc] &lt;- ceiling(table1[,nc])
dc &lt;- c(3,5,6,8,10,11)
table1[,dc] &lt;- round(table1[,dc],2)
unlink(outfile)
# APOE-4, Scott WK, Pericak-Vance, MA &amp; Haines JL
# Genetic analysis of complex diseases 1327
g &lt;- 4.5
p &lt;- 0.15
cat("\nAlzheimer's:\n\n")
fbsize(g,p)
# note to replicate the Table we need set alpha=9.961139e-05,4.910638e-08 and
# beta=0.2004542 or reset the quantiles in fbsize.R

</code></pre>

<hr>
<h2 id='FPRP'>False-positive report probability</h2><span id='topic+FPRP'></span>

<h3>Description</h3>

<p>False-positive report probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FPRP(a, b, pi0, ORlist, logscale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FPRP_+3A_a">a</code></td>
<td>
<p>parameter value at which the power is to be evaluated.</p>
</td></tr>
<tr><td><code id="FPRP_+3A_b">b</code></td>
<td>
<p>the variance for a, or the uppoer point of a 95%CI if logscale=FALSE.</p>
</td></tr>
<tr><td><code id="FPRP_+3A_pi0">pi0</code></td>
<td>
<p>the prior probabiility that <code class="reqn">H_0</code> is true.</p>
</td></tr>
<tr><td><code id="FPRP_+3A_orlist">ORlist</code></td>
<td>
<p>a vector of ORs that is most likely.</p>
</td></tr>
<tr><td><code id="FPRP_+3A_logscale">logscale</code></td>
<td>
<p>FALSE=a,b in orginal scale, TRUE=a, b in log scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the false positive report probability (FPRP), the probability of no true
association beteween a genetic variant and disease given a statistically significant finding,
which depends not only on the observed P value but also on both the prior probability that the
assocition is real and the statistical power of the test. An associate result is the
false negative reported probability (FNRP).  See example for the recommended steps.
</p>
<p>The FPRP and FNRP are derived as follows. Let <code class="reqn">H_0</code>=null hypothesis (no association),
<code class="reqn">H_A</code>=alternative hypothesis (association). Since classic frequentist theory considers
they are fixed, one has to resort to Bayesian framework by introduing prior,
<code class="reqn">\pi=P(H_0=TRUE)=P(association)</code>. Let <code class="reqn">T</code>=test statistic, and <code class="reqn">P(T&gt;z_\alpha|H_0=TRUE)=P(rejecting\ 
H_0|H_0=TRUE)=\alpha</code>, <code class="reqn">P(T&gt;z_\alpha|H_0=FALSE)=P(rejecting\ H_0|H_A=TRUE)=1-\beta</code>. The joint
probability of test and truth of hypothesis can be expressed by <code class="reqn">\alpha</code>, <code class="reqn">\beta</code> and <code class="reqn">\pi</code>.
</p>
<p>Joint probability of significance of test and truth of hypothesis
</p>

<table>
<tr>
 <td style="text-align: left;">
Truth of <code class="reqn">H_A</code> </td><td style="text-align: left;"> significant </td><td style="text-align: left;"> nonsignificant </td><td style="text-align: left;"> Total</td>
</tr>
<tr>
 <td style="text-align: left;">
TRUE </td><td style="text-align: left;"> <code class="reqn">(1-\beta)\pi</code> </td><td style="text-align: left;"> <code class="reqn">\beta\pi</code> </td><td style="text-align: left;"> <code class="reqn">\pi</code></td>
</tr>
<tr>
 <td style="text-align: left;">
FALSE </td><td style="text-align: left;"> <code class="reqn">\alpha (1-\pi)</code> </td><td style="text-align: left;"> <code class="reqn">(1-\alpha)(1-\pi)</code> </td><td style="text-align: left;"> <code class="reqn">1-\pi</code></td>
</tr>
<tr>
 <td style="text-align: left;">
Total </td><td style="text-align: left;"> <code class="reqn">(1-\beta)\pi+\alpha (1-\pi)</code> </td><td style="text-align: left;"> <code class="reqn">\beta\pi+(1-\alpha)(1-\pi)</code> </td><td style="text-align: left;"> 1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>We have <code class="reqn">FPRP=P(H_0=TRUE|T&gt;z_\alpha)= 
\alpha(1-\pi)/[\alpha(1-\pi)+(1-\beta)\pi]=\{1+\pi/(1-\pi)][(1-\beta)/\alpha]\}^{-1}</code>
and similarly <code class="reqn">FNRP=\{1+[(1-\alpha)/\beta][(1-\pi)/\pi]\}^{-1}</code>.
</p>


<h3>Value</h3>

<p>The returned value is a list with compoents,
p p value corresponding to a,b.
power the power corresponding to the vector of ORs.
FPRP False-positive report probability.
FNRP False-negative report probability.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Wacholder S, Chanock S, Garcia-Closas M, El Ghormli L, Rothman N (2004).
&ldquo;Assessing the probability that a positive report is false: an approach for molecular epidemiology studies.&rdquo;
<em>J Natl Cancer Inst</em>, <b>96</b>(6), 434-42.
ISSN 0027-8874 (Print) 0027-8874, <a href="https://doi.org/10.1093/jnci/djh075">doi:10.1093/jnci/djh075</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BFDP">BFDP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example by Laure El ghormli &amp; Sholom Wacholder on 25-Feb-2004
# Step 1 - Pre-set an FPRP-level criterion for noteworthiness

T &lt;- 0.2

# Step 2 - Enter values for the prior that there is an association

pi0 &lt;- c(0.25,0.1,0.01,0.001,0.0001,0.00001)

# Step 3 - Enter values of odds ratios (OR) that are most likely, assuming that
#          there is a non-null association

ORlist &lt;- c(1.2,1.5,2.0)

# Step 4 - Enter OR estimate and 95% confidence interval (CI) to obtain FPRP 												

OR &lt;- 1.316
ORlo &lt;- 1.08
ORhi &lt;- 1.60

logOR &lt;- log(OR)
selogOR &lt;- abs(logOR-log(ORhi))/1.96
p &lt;- ifelse(logOR&gt;0,2*(1-pnorm(logOR/selogOR)),2*pnorm(logOR/selogOR))
p
q &lt;- qnorm(1-p/2)
POWER &lt;- ifelse(log(ORlist)&gt;0,1-pnorm(q-log(ORlist)/selogOR),
                pnorm(-q-log(ORlist)/selogOR))
POWER
FPRPex &lt;- t(p*(1-pi0)/(p*(1-pi0)+POWER\
row.names(FPRPex) &lt;- pi0
colnames(FPRPex) &lt;- ORlist
FPRPex
FPRPex&gt;T

## now turn to FPRP
OR &lt;- 1.316
ORhi &lt;- 1.60
ORlist &lt;- c(1.2,1.5,2.0)
pi0 &lt;- c(0.25,0.1,0.01,0.001,0.0001,0.00001)
z &lt;- FPRP(OR,ORhi,pi0,ORlist,logscale=FALSE)
z

## End(Not run)

</code></pre>

<hr>
<h2 id='g2a'>Conversion of a genotype identifier to alleles</h2><span id='topic+g2a'></span>

<h3>Description</h3>

<p>Conversion of a genotype identifier to alleles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g2a(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g2a_+3A_g">g</code></td>
<td>
<p>a genotype identifier.</p>
</td></tr>
</table>

<hr>
<h2 id='gap'>Genetic analysis package</h2><span id='topic+gap'></span><span id='topic+_PACKAGE'></span><span id='topic+gap-package'></span>

<h3>Description</h3>

<p>As is first reported, it is designed as an integrated package for genetic data
analysis of both population and family data. Currently, it contains functions for
sample size calculations of both population-based and family-based designs, probability
of familial disease aggregation, kinship calculation, statistics in linkage analysis,
and association analysis involving genetic markers including haplotype analysis with or
without environmental covariates. Over years, the package has been developed in-between
many projects hence also in line with the name (gap).
</p>


<h3>Details</h3>

<p>We have incorporated functions for a wide range of problems as shown below.
</p>

<table>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>ANALYSIS</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
AE3               </td><td style="text-align: left;">      AE model using nuclear family trios</td>
</tr>
<tr>
 <td style="text-align: left;">
bt                </td><td style="text-align: left;">      Bradley-Terry model for contingency table</td>
</tr>
<tr>
 <td style="text-align: left;">
ccsize            </td><td style="text-align: left;">      Power and sample size for case-cohort design</td>
</tr>
<tr>
 <td style="text-align: left;">
cs                </td><td style="text-align: left;">      Credibel set</td>
</tr>
<tr>
 <td style="text-align: left;">
fbsize            </td><td style="text-align: left;">      Sample size for family-based linkage and association design</td>
</tr>
<tr>
 <td style="text-align: left;">
gc.em             </td><td style="text-align: left;">      Gene counting for haplotype analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
gcontrol          </td><td style="text-align: left;">      genomic control</td>
</tr>
<tr>
 <td style="text-align: left;">
gcontrol2         </td><td style="text-align: left;">      genomic control based on p values</td>
</tr>
<tr>
 <td style="text-align: left;">
gcp               </td><td style="text-align: left;">      Permutation tests using GENECOUNTING</td>
</tr>
<tr>
 <td style="text-align: left;">
gc.lambda         </td><td style="text-align: left;">      Estimation of the genomic control inflation statistic (lambda)</td>
</tr>
<tr>
 <td style="text-align: left;">
genecounting      </td><td style="text-align: left;">      Gene counting for haplotype analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
gif               </td><td style="text-align: left;">      Kinship coefficient and genetic index of familiality</td>
</tr>
<tr>
 <td style="text-align: left;">
hap               </td><td style="text-align: left;">      Haplotype reconstruction</td>
</tr>
<tr>
 <td style="text-align: left;">
hap.em            </td><td style="text-align: left;">      Gene counting for haplotype analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
hap.score         </td><td style="text-align: left;">      Score statistics for association of traits with haplotypes</td>
</tr>
<tr>
 <td style="text-align: left;">
htr               </td><td style="text-align: left;">      Haplotype trend regression</td>
</tr>
<tr>
 <td style="text-align: left;">
h2.jags           </td><td style="text-align: left;">      Heritability estimation based on genomic relationship matrix using JAGS</td>
</tr>
<tr>
 <td style="text-align: left;">
hwe               </td><td style="text-align: left;">      Hardy-Weinberg equilibrium test for a multiallelic marker</td>
</tr>
<tr>
 <td style="text-align: left;">
hwe.cc            </td><td style="text-align: left;">      A likelihood ratio test of population Hardy-Weinberg equilibrium </td>
</tr>
<tr>
 <td style="text-align: left;">
hwe.hardy         </td><td style="text-align: left;">      Hardy-Weinberg equilibrium test using MCMC</td>
</tr>
<tr>
 <td style="text-align: left;">
hwe.jags          </td><td style="text-align: left;">      Hardy-Weinberg equlibrium test for a multiallelic marker using JAGS</td>
</tr>
<tr>
 <td style="text-align: left;">
invnormal         </td><td style="text-align: left;">      inverse Normal transformation</td>
</tr>
<tr>
 <td style="text-align: left;">
kin.morgan        </td><td style="text-align: left;">      kinship matrix for simple pedigree</td>
</tr>
<tr>
 <td style="text-align: left;">
LD22              </td><td style="text-align: left;">      LD statistics for two diallelic markers</td>
</tr>
<tr>
 <td style="text-align: left;">
LDkl              </td><td style="text-align: left;">      LD statistics for two multiallelic markers</td>
</tr>
<tr>
 <td style="text-align: left;">
lambda1000        </td><td style="text-align: left;">      A standardized estimate of the genomic inflation scaling to</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">      a study of 1,000 cases and 1,000 controls</td>
</tr>
<tr>
 <td style="text-align: left;">
log10p            </td><td style="text-align: left;">      log10(p) for a standard normal deviate</td>
</tr>
<tr>
 <td style="text-align: left;">
log10pvalue       </td><td style="text-align: left;">      log10(p) for a P value including its scientific format</td>
</tr>
<tr>
 <td style="text-align: left;">
logp              </td><td style="text-align: left;">      log(p) for a normal deviate</td>
</tr>
<tr>
 <td style="text-align: left;">
masize            </td><td style="text-align: left;">      Sample size calculation for mediation analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
MCMCgrm           </td><td style="text-align: left;">	    Mixed modeling with genetic relationship matrices</td>
</tr>
<tr>
 <td style="text-align: left;">
mia               </td><td style="text-align: left;">      multiple imputation analysis for hap</td>
</tr>
<tr>
 <td style="text-align: left;">
mr                </td><td style="text-align: left;">      Mendelian randomization analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
mtdt              </td><td style="text-align: left;">      Transmission/disequilibrium test of a multiallelic marker</td>
</tr>
<tr>
 <td style="text-align: left;">
mtdt2             </td><td style="text-align: left;">      Transmission/disequilibrium test of a multiallelic marker</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">      by Bradley-Terry model</td>
</tr>
<tr>
 <td style="text-align: left;">
mvmeta            </td><td style="text-align: left;">      Multivariate meta-analysis based on generalized least squares</td>
</tr>
<tr>
 <td style="text-align: left;">
pbsize            </td><td style="text-align: left;">      Power for population-based association design</td>
</tr>
<tr>
 <td style="text-align: left;">
pbsize2           </td><td style="text-align: left;">      Power for case-control association design</td>
</tr>
<tr>
 <td style="text-align: left;">
pfc               </td><td style="text-align: left;">      Probability of familial clustering of disease</td>
</tr>
<tr>
 <td style="text-align: left;">
pfc.sim           </td><td style="text-align: left;">      Probability of familial clustering of disease</td>
</tr>
<tr>
 <td style="text-align: left;">
pgc               </td><td style="text-align: left;">      Preparing weight for GENECOUNTING</td>
</tr>
<tr>
 <td style="text-align: left;">
print.hap.score   </td><td style="text-align: left;">      Print a hap.score object</td>
</tr>
<tr>
 <td style="text-align: left;">
s2k               </td><td style="text-align: left;">      Statistics for 2 by K table</td>
</tr>
<tr>
 <td style="text-align: left;">
sentinels         </td><td style="text-align: left;">      Sentinel identification from GWAS summary statistics</td>
</tr>
<tr>
 <td style="text-align: left;">
tscc              </td><td style="text-align: left;">      Power calculation for two-stage case-control design</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>GRAPHICS</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
asplot            </td><td style="text-align: left;">      Regional association plot</td>
</tr>
<tr>
 <td style="text-align: left;">
ESplot            </td><td style="text-align: left;">      Effect-size plot</td>
</tr>
<tr>
 <td style="text-align: left;">
circos.cis.vs.trans.plot </td><td style="text-align: left;"> circos plot of cis/trans classification</td>
</tr>
<tr>
 <td style="text-align: left;">
circos.cnvplot    </td><td style="text-align: left;">      circos plot of CNVs</td>
</tr>
<tr>
 <td style="text-align: left;">
circos.mhtplot    </td><td style="text-align: left;">      circos Manhattan plot with gene annotation</td>
</tr>
<tr>
 <td style="text-align: left;">
circos.mhtplot2   </td><td style="text-align: left;">      Another circos Manhattan plot</td>
</tr>
<tr>
 <td style="text-align: left;">
cnvplot           </td><td style="text-align: left;">      genomewide plot of CNVs</td>
</tr>
<tr>
 <td style="text-align: left;">
labelManhattan    </td><td style="text-align: left;">      Annotate Manhattan or Miami Plot</td>
</tr>
<tr>
 <td style="text-align: left;">
makeRLEplot       </td><td style="text-align: left;">      make relative log expression plot</td>
</tr>
<tr>
 <td style="text-align: left;">
METAL_forestplot  </td><td style="text-align: left;">      forest plot as R/meta's forest for METAL outputs</td>
</tr>
<tr>
 <td style="text-align: left;">
mhtplot           </td><td style="text-align: left;">      Manhattan plot</td>
</tr>
<tr>
 <td style="text-align: left;">
mhtplot2          </td><td style="text-align: left;">      Manhattan plot with annotations</td>
</tr>
<tr>
 <td style="text-align: left;">
mhtplot.trunc     </td><td style="text-align: left;">      truncated Manhattan plot</td>
</tr>
<tr>
 <td style="text-align: left;">
miamiplot         </td><td style="text-align: left;">      Miami plot</td>
</tr>
<tr>
 <td style="text-align: left;">
miamiplot2        </td><td style="text-align: left;">      Miami plot</td>
</tr>
<tr>
 <td style="text-align: left;">
mr_forestplot     </td><td style="text-align: left;">      Mendelian Randomization forest plot</td>
</tr>
<tr>
 <td style="text-align: left;">
pedtodot          </td><td style="text-align: left;">      Converting pedigree(s) to dot file(s)</td>
</tr>
<tr>
 <td style="text-align: left;">
pedtodot_verbatim </td><td style="text-align: left;">      Pedigree-drawing with graphviz</td>
</tr>
<tr>
 <td style="text-align: left;">
plot.hap.score    </td><td style="text-align: left;">      Plot haplotype frequencies versus haplotype score statistics</td>
</tr>
<tr>
 <td style="text-align: left;">
qqfun             </td><td style="text-align: left;">      Quantile-comparison plots</td>
</tr>
<tr>
 <td style="text-align: left;">
qqunif            </td><td style="text-align: left;">      Q-Q plot for uniformly distributed random variable</td>
</tr>
<tr>
 <td style="text-align: left;">
qtl2dplot         </td><td style="text-align: left;">      2D QTL plot</td>
</tr>
<tr>
 <td style="text-align: left;">
qtl2dplotly       </td><td style="text-align: left;">      2D QTL plotly</td>
</tr>
<tr>
 <td style="text-align: left;">
qtl3dplotly       </td><td style="text-align: left;">      3D QTL plotly</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>UTITLITIES</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
SNP               </td><td style="text-align: left;">      Functions for single nucleotide polymorphisms (SNPs)</td>
</tr>
<tr>
 <td style="text-align: left;">
BFDP              </td><td style="text-align: left;">      Bayesian false-discovery probability</td>
</tr>
<tr>
 <td style="text-align: left;">
FPRP              </td><td style="text-align: left;">      False-positive report probability</td>
</tr>
<tr>
 <td style="text-align: left;">
ab                </td><td style="text-align: left;">      Test/Power calculation for mediating effect</td>
</tr>
<tr>
 <td style="text-align: left;">
b2r               </td><td style="text-align: left;">      Obtain correlation coefficients and their variance-covariances</td>
</tr>
<tr>
 <td style="text-align: left;">
chow.test         </td><td style="text-align: left;">      Chow's test for heterogeneity in two regressions</td>
</tr>
<tr>
 <td style="text-align: left;">
chr_pos_a1_a2     </td><td style="text-align: left;">      Form SNPID from chromosome, posistion and alleles</td>
</tr>
<tr>
 <td style="text-align: left;">
ci2ms             </td><td style="text-align: left;">      Effect size and standard error from confidence interval</td>
</tr>
<tr>
 <td style="text-align: left;">
cis.vs.trans.classification </td><td style="text-align: left;"> a cis/trans classifier</td>
</tr>
<tr>
 <td style="text-align: left;">
comp.score        </td><td style="text-align: left;">      score statistics for testing genetic linkage of quantitative trait</td>
</tr>
<tr>
 <td style="text-align: left;">
GRM functions     </td><td style="text-align: left;">      ReadGRM, ReadGRMBin, ReadGRMPLINK, ReadGRMPCA, WriteGRM,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">      WriteGRMBin, WriteGRMSAS</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">      handle genomic relationship matrix involving other software</td>
</tr>
<tr>
 <td style="text-align: left;">
get_b_se          </td><td style="text-align: left;">      Get b and se from AF, n, and z</td>
</tr>
<tr>
 <td style="text-align: left;">
get_pve_se        </td><td style="text-align: left;">      Get pve and its standard error from n, z</td>
</tr>
<tr>
 <td style="text-align: left;">
get_sdy           </td><td style="text-align: left;">      Get sd(y) from AF, n, b, se</td>
</tr>
<tr>
 <td style="text-align: left;">
h2G               </td><td style="text-align: left;">      A utility function for heritability</td>
</tr>
<tr>
 <td style="text-align: left;">
h2GE              </td><td style="text-align: left;">      A utility function for heritability involving gene-environment interaction</td>
</tr>
<tr>
 <td style="text-align: left;">
h2l               </td><td style="text-align: left;">      A utility function for converting observed heritability to its counterpart</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">      under liability threshold model</td>
</tr>
<tr>
 <td style="text-align: left;">
h2_mzdz           </td><td style="text-align: left;">      Heritability estimation according to twin correlations</td>
</tr>
<tr>
 <td style="text-align: left;">
klem              </td><td style="text-align: left;">      Haplotype frequency estimation based on a genotype table</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">      of two multiallelic markers</td>
</tr>
<tr>
 <td style="text-align: left;">
makeped           </td><td style="text-align: left;">      A function to prepare pedigrees in post-MAKEPED format</td>
</tr>
<tr>
 <td style="text-align: left;">
metap             </td><td style="text-align: left;">      Meta-analysis of p values</td>
</tr>
<tr>
 <td style="text-align: left;">
metareg           </td><td style="text-align: left;">      Fixed and random effects model for meta-analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
muvar             </td><td style="text-align: left;">      Means and variances under 1- and 2- locus (diallelic) QTL model</td>
</tr>
<tr>
 <td style="text-align: left;">
qtlClassifier     </td><td style="text-align: left;">      A QTL cis/trans classifier</td>
</tr>
<tr>
 <td style="text-align: left;">
read.ms.output    </td><td style="text-align: left;">      A utility function to read ms output</td>
</tr>
<tr>
 <td style="text-align: left;">
revStrand         </td><td style="text-align: left;">      Allele on the reverse strand</td>
</tr>
<tr>
 <td style="text-align: left;">
runshinygap       </td><td style="text-align: left;">      Start shinygap</td>
</tr>
<tr>
 <td style="text-align: left;">
snptest_sample    </td><td style="text-align: left;">      A utility to generate SNPTEST sample file</td>
</tr>
<tr>
 <td style="text-align: left;">
whscore           </td><td style="text-align: left;">      Whittemore-Halpern scores for allele-sharing</td>
</tr>
<tr>
 <td style="text-align: left;">
weighted.median   </td><td style="text-align: left;">      Weighted median with interpolation</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Usage</h3>

<p>Vignettes on package usage:
</p>

<ul>
<li><p> Genetic Analysis Package. <code>vignette("gap")</code>.
</p>
</li>
<li><p> Shiny for Genetic Analysis Package (gap) Designs. <code>vignette("shinygap")</code>.
</p>
</li>
<li><p> JSS paper: Genetic Analysis Package. <code>vignette("jss")</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jing Hua Zhao in collaboration with other colleagues and with
help from Kurt Hornik, Brian Ripley, Uwe Ligges and Achim Zeileis
</p>
<p>maitained by Jing Hua Zhao <a href="mailto:jinghuazhao@hotmail.com">jinghuazhao@hotmail.com</a>
</p>


<h3>References</h3>

<p>Zhao JH (2007).
&ldquo;gap: genetic analysis package.&rdquo;
<em>Journal of Statistical Software</em>, <b>23</b>(8), 1-18.
<a href="https://doi.org/10.18637/jss.v023.i08">doi:10.18637/jss.v023.i08</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jinghuazhao/R">https://github.com/jinghuazhao/R</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jinghuazhao/R/issues">https://github.com/jinghuazhao/R/issues</a>
</p>
</li></ul>


<hr>
<h2 id='gc.em'>Gene counting for haplotype analysis</h2><span id='topic+gc.em'></span>

<h3>Description</h3>

<p>Gene counting for haplotype analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gc.em(
  data,
  locus.label = NA,
  converge.eps = 1e-06,
  maxiter = 500,
  handle.miss = 0,
  miss.val = 0,
  control = gc.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gc.em_+3A_data">data</code></td>
<td>
<p>Matrix of alleles, such that each locus has a pair of
adjacent columns of alleles, and the order of columns
corresponds to the order of loci on a chromosome. If
there are K loci, then ncol(data) = 2*K. Rows represent
alleles for each subject.</p>
</td></tr>
<tr><td><code id="gc.em_+3A_locus.label">locus.label</code></td>
<td>
<p>Vector of  labels  for  loci,  of  length  K  (see definition of data matrix).</p>
</td></tr>
<tr><td><code id="gc.em_+3A_converge.eps">converge.eps</code></td>
<td>
<p>Convergence criterion, based on absolute  change in log likelihood (lnlike).</p>
</td></tr>
<tr><td><code id="gc.em_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations of EM.</p>
</td></tr>
<tr><td><code id="gc.em_+3A_handle.miss">handle.miss</code></td>
<td>
<p>a flag for handling missing genotype data, 0=no, 1=yes.</p>
</td></tr>
<tr><td><code id="gc.em_+3A_miss.val">miss.val</code></td>
<td>
<p>missing value.</p>
</td></tr>
<tr><td><code id="gc.em_+3A_control">control</code></td>
<td>
<p>a function, see <a href="#topic+genecounting">genecounting</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gene counting for haplotype analysis with missing data, adapted for hap.score
</p>


<h3>Value</h3>

<p>List with components:
</p>

<ul>
<li><p> converge Indicator of convergence of the EM algorithm (1=converged, 0 = failed).
</p>
</li>
<li><p> niter Number of iterations completed in the EM alogrithm.
</p>
</li>
<li><p> locus.info A list with  a  component for each locus.  Each
component is also a list, and  the  items of a locus-
specific list are the locus name and a vector for the
unique alleles for the locus.
</p>
</li>
<li><p> locus.label Vector of labels for loci, of length K (see definition of input values).
</p>
</li>
<li><p> haplotype Matrix of unique haplotypes. Each row represents a
unique haplotype, and the number of columns is the number of loci.
</p>
</li>
<li><p> hap.prob Vector of mle's of haplotype probabilities.  The ith
element of hap.prob corresponds to the ith row of haplotype.
</p>
</li>
<li><p> hap.prob.noLD Similar to hap.prob, but assuming no linkage disequilibrium.
</p>
</li>
<li><p> lnlike Value of lnlike at last EM iteration (maximum lnlike if converged).
</p>
</li>
<li><p> lr Likelihood ratio statistic to test no linkage disequilibrium among all loci.
</p>
</li>
<li><p> indx.subj Vector for index of subjects, after  expanding  to
all possible  pairs  of  haplotypes  for  each person. If
indx=i, then i is the ith row of input matrix data. If the
ith subject has  n possible  pairs  of haplotypes that
correspond to their marker phenotype, then i is repeated n times.
</p>
</li>
<li><p> nreps Vector for the count of haplotype pairs that map to
each subject's marker genotypes.
</p>
</li>
<li><p> hap1code Vector of codes for each subject's first haplotype.
The values in hap1code are the row numbers of the unique
haplotypes in the returned matrix haplotype.
</p>
</li>
<li><p> hap2code Similar to hap1code, but for  each  subject's  second haplotype.
</p>
</li>
<li><p> post Vector of posterior probabilities of pairs of
haplotypes for a person, given thier marker phenotypes.
</p>
</li>
<li><p> htrtable A table which can be used in haplotype trend regression.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from GENECOUNTING.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Zhao JH, Lissarrague S, Essioux L, Sham PC (2002).
&ldquo;GENECOUNTING: haplotype analysis with missing genotypes.&rdquo;
<em>Bioinformatics</em>, <b>18</b>(12), 1694-5.
ISSN 1367-4803 (Print) 1367-4803, <a href="https://doi.org/10.1093/bioinformatics/18.12.1694">doi:10.1093/bioinformatics/18.12.1694</a>.
</p>
<p>Zhao JH, Sham PC (2003).
&ldquo;Generic number systems and haplotype analysis.&rdquo;
<em>Comput Methods Programs Biomed</em>, <b>70</b>(1), 1-9.
ISSN 0169-2607 (Print) 0169-2607, <a href="https://doi.org/10.1016/s0169-2607%2801%2900193-6">doi:10.1016/s0169-2607(01)00193-6</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genecounting">genecounting</a></code>, <code><a href="#topic+LDkl">LDkl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(hla)
gc.em(hla[,3:8],locus.label=c("DQR","DQA","DQB"),control=gc.control(assignment="t"))

## End(Not run)

</code></pre>

<hr>
<h2 id='gc.lambda'>Estimation of the genomic control inflation statistic (lambda)</h2><span id='topic+gc.lambda'></span>

<h3>Description</h3>

<p>Estimation of the genomic control inflation statistic (lambda)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gc.lambda(x, logscale = FALSE, z = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gc.lambda_+3A_x">x</code></td>
<td>
<p>A real vector (p or z).</p>
</td></tr>
<tr><td><code id="gc.lambda_+3A_logscale">logscale</code></td>
<td>
<p>A logical variable such that x as -log10(p).</p>
</td></tr>
<tr><td><code id="gc.lambda_+3A_z">z</code></td>
<td>
<p>A flag to indicate x as a vector of z values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimate of inflation factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
p &lt;- runif(100)
gc.lambda(p)
lp &lt;- -log10(p)
gc.lambda(lp,logscale=TRUE)
z &lt;- qnorm(p/2)
gc.lambda(z,z=TRUE)
</code></pre>

<hr>
<h2 id='gcontrol'>genomic control</h2><span id='topic+gcontrol'></span>

<h3>Description</h3>

<p>genomic control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcontrol(
  data,
  zeta = 1000,
  kappa = 4,
  tau2 = 1,
  epsilon = 0.01,
  ngib = 500,
  burn = 50,
  idum = 2348
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcontrol_+3A_data">data</code></td>
<td>
<p>the data matrix.</p>
</td></tr>
<tr><td><code id="gcontrol_+3A_zeta">zeta</code></td>
<td>
<p>program constant with default value 1000.</p>
</td></tr>
<tr><td><code id="gcontrol_+3A_kappa">kappa</code></td>
<td>
<p>multiplier in prior for mean with default value 4.</p>
</td></tr>
<tr><td><code id="gcontrol_+3A_tau2">tau2</code></td>
<td>
<p>multiplier in prior for variance with default value 1.</p>
</td></tr>
<tr><td><code id="gcontrol_+3A_epsilon">epsilon</code></td>
<td>
<p>prior probability of marker association with default value 0.01.</p>
</td></tr>
<tr><td><code id="gcontrol_+3A_ngib">ngib</code></td>
<td>
<p>number of Gibbs steps, with default value 500.</p>
</td></tr>
<tr><td><code id="gcontrol_+3A_burn">burn</code></td>
<td>
<p>number of burn-ins with default value 50.</p>
</td></tr>
<tr><td><code id="gcontrol_+3A_idum">idum</code></td>
<td>
<p>seed for pseudorandom number sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayesian genomic control statistics with the following parameters,
</p>

<table>
<tr>
 <td style="text-align: left;">
n </td><td style="text-align: left;"> number of loci under consideration </td>
</tr>
<tr>
 <td style="text-align: left;">
lambdahat </td><td style="text-align: left;"> median(of the n trend statistics)/0.46 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Prior for noncentrality parameter Ai is </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> Normal(sqrt(lambdahat)kappa,lambdahat*tau2) </td>
</tr>
<tr>
 <td style="text-align: left;">
kappa </td><td style="text-align: left;"> multiplier in prior above, set at 1.6 * sqrt(log(n)) </td>
</tr>
<tr>
 <td style="text-align: left;">
tau2  </td><td style="text-align: left;"> multiplier in prior above </td>
</tr>
<tr>
 <td style="text-align: left;">
epsilon </td><td style="text-align: left;"> prior probability a marker is associated, set at 10/n </td>
</tr>
<tr>
 <td style="text-align: left;">
ngib </td><td style="text-align: left;"> number of cycles for the Gibbs sampler after burn in </td>
</tr>
<tr>
 <td style="text-align: left;">
burn </td><td style="text-align: left;"> number of cycles for the Gibbs sampler to burn in
</td>
</tr>

</table>

<p>Armitage's trend test along with the posterior probability that each marker is
associated with the disorder is given. The latter is not a p-value but any value
greater than 0.5 (pout) suggests association.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> deltot the probability of being an outlier.
</p>
</li>
<li><p> x2 the <code class="reqn">\chi^2</code> statistic.
</p>
</li>
<li><p> A the A vector.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from gcontrol by Bobby Jones and Kathryn Roeder,
use -Dexecutable for standalone program, function getnum in the original
code needs \
</p>


<h3>Author(s)</h3>

<p>Bobby Jones, Jing Hua Zhao
</p>


<h3>Source</h3>

<p><a href="https://www.cmu.edu/dietrich/statistics-datascience/index.html">https://www.cmu.edu/dietrich/statistics-datascience/index.html</a>
</p>


<h3>References</h3>

<p>Devlin B, Roeder K (1999).
&ldquo;Genomic control for association studies.&rdquo;
<em>Biometrics</em>, <b>55</b>(4), 997-1004.
ISSN 0006-341X (Print) 0006-341x, <a href="https://doi.org/10.1111/j.0006-341x.1999.00997.x">doi:10.1111/j.0006-341x.1999.00997.x</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
test&lt;-c(1,2,3,4,5,6,  1,2,1,23,1,2, 100,1,2,12,1,1, 
        1,2,3,4,5,61, 1,2,11,23,1,2, 10,11,2,12,1,11)
test&lt;-matrix(test,nrow=6,byrow=T)
gcontrol(test)

## End(Not run)
</code></pre>

<hr>
<h2 id='gcontrol2'>genomic control based on p values</h2><span id='topic+gcontrol2'></span>

<h3>Description</h3>

<p>genomic control based on p values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcontrol2(p, col = palette()[4], lcol = palette()[2], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcontrol2_+3A_p">p</code></td>
<td>
<p>a vector of observed p values.</p>
</td></tr>
<tr><td><code id="gcontrol2_+3A_col">col</code></td>
<td>
<p>colour for points in the Q-Q plot.</p>
</td></tr>
<tr><td><code id="gcontrol2_+3A_lcol">lcol</code></td>
<td>
<p>colour for the diagonal line in the Q-Q plot.</p>
</td></tr>
<tr><td><code id="gcontrol2_+3A_...">...</code></td>
<td>
<p>other options for plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function obtains 1-df <code class="reqn">\chi^2</code> statistics (observed) according
to a vector of p values, and the inflation factor (lambda) according
to medians of the observed and expected statistics. The latter is based
on the empirical distribution function (EDF) of 1-df <code class="reqn">\chi^2</code> statstics.
</p>
<p>It would be appropriate for genetic association analysis as of 1-df Armitage trend test
for case-control data; for 1-df additive model with continuous outcome one has to
consider the compatibility with p values based on z-/t- statistics.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li><p> x the expected <code class="reqn">\chi^2</code> statistics.
</p>
</li>
<li><p> y the observed <code class="reqn">\chi^2</code> statistics.
</p>
</li>
<li><p> lambda the inflation factor.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Devlin B, Roeder K (1999) Genomic control for association studies.
Biometrics 55:997-1004
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x2 &lt;- rchisq(100,1,.1)
p &lt;- pchisq(x2,1,lower.tail=FALSE)
r &lt;- gcontrol2(p)
print(r$lambda)

## End(Not run)

</code></pre>

<hr>
<h2 id='gcp'>Permutation tests using GENECOUNTING</h2><span id='topic+gcp'></span>

<h3>Description</h3>

<p>Permutation tests using GENECOUNTING
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcp(
  y,
  cc,
  g,
  handle.miss = 1,
  miss.val = 0,
  n.sim = 0,
  locus.label = NULL,
  quietly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcp_+3A_y">y</code></td>
<td>
<p>A column of 0/1 indicating cases and controls.</p>
</td></tr>
<tr><td><code id="gcp_+3A_cc">cc</code></td>
<td>
<p>analysis indicator, 0 = marker-marker, 1 = case-control.</p>
</td></tr>
<tr><td><code id="gcp_+3A_g">g</code></td>
<td>
<p>the multilocus genotype data.</p>
</td></tr>
<tr><td><code id="gcp_+3A_handle.miss">handle.miss</code></td>
<td>
<p>a flag with value 1 indicating missing data are allowed.</p>
</td></tr>
<tr><td><code id="gcp_+3A_miss.val">miss.val</code></td>
<td>
<p>missing value.</p>
</td></tr>
<tr><td><code id="gcp_+3A_n.sim">n.sim</code></td>
<td>
<p>the number of permutations.</p>
</td></tr>
<tr><td><code id="gcp_+3A_locus.label">locus.label</code></td>
<td>
<p>label of each locus.</p>
</td></tr>
<tr><td><code id="gcp_+3A_quietly">quietly</code></td>
<td>
<p>a flag if TRUE will suppress the screen output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a R port of the GENECOUNTING/PERMUTE program which
generates EHPLUS-type statistics including z-tests for individual haplotypes
</p>


<h3>Value</h3>

<p>The returned value is a list containing (p.sim and ph when n.sim &gt; 0):
</p>

<ul>
<li><p> x2obs the observed chi-squared statistic.
</p>
</li>
<li><p> pobs the associated p value.
</p>
</li>
<li><p> zobs the observed z value for individual haplotypes.
</p>
</li>
<li><p> p.sim simulated p value for the global chi-squared statistic.
</p>
</li>
<li><p> ph simulated p values for individual haplotypes.
</p>
</li></ul>



<h3>Note</h3>

<p>Built on gcp.c.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Zhao JH, Curtis D, Sham PC (2000).
&ldquo;Model-free analysis and permutation tests for allelic associations.&rdquo;
<em>Hum Hered</em>, <b>50</b>(2), 133-9.
ISSN 0001-5652 (Print) 0001-5652, <a href="https://doi.org/10.1159/000022901">doi:10.1159/000022901</a>.
</p>
<p>Zhao JH (2004).
&ldquo;2LD. GENECOUNTING and HAP: computer programs for linkage disequilibrium analysis.&rdquo;
<em>Bioinformatics</em>, <b>20</b>(8), 1325-6.
ISSN 1367-4803 (Print) 1367-4803, <a href="https://doi.org/10.1093/bioinformatics/bth071">doi:10.1093/bioinformatics/bth071</a>.
</p>
<p>Zhao JH, Qian WD (2003) Association analysis of unrelated individuals using
polymorphic genetic markers &ndash; methods, implementation and application, Royal
Statistical Society, Hassallt-Diepenbeek, Belgium.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genecounting">genecounting</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(fsnps)
y&lt;-fsnps$y
cc&lt;-1
g&lt;-fsnps[,3:10]

gcp(y,cc,g,miss.val="Z",n.sim=5)
hap.score(y,g,method="hap",miss.val="Z")

## End(Not run)

</code></pre>

<hr>
<h2 id='genecounting'>Gene counting for haplotype analysis</h2><span id='topic+genecounting'></span>

<h3>Description</h3>

<p>Gene counting for haplotype analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genecounting(data, weight = NULL, loci = NULL, control = gc.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genecounting_+3A_data">data</code></td>
<td>
<p>genotype table.</p>
</td></tr>
<tr><td><code id="genecounting_+3A_weight">weight</code></td>
<td>
<p>a column of frequency weights.</p>
</td></tr>
<tr><td><code id="genecounting_+3A_loci">loci</code></td>
<td>
<p>an array containing number of alleles at each locus.</p>
</td></tr>
<tr><td><code id="genecounting_+3A_control">control</code></td>
<td>
<p>is a function with the following arguments:
</p>

<ul>
<li><p> xdata. a flag indicating if the data involves X chromosome, if so, the
first column of data indicates sex of each subject: 1=male, 2=female. The marker
data are no different from the autosomal version for females, but for males, two copies
of the single allele present at a given locus.
</p>
</li>
<li><p> convll. set convergence criteria according to log-likelihood, if its value set to 1
</p>
</li>
<li><p> handle.miss. to handle missing data, if its value set to 1
</p>
</li>
<li><p> eps. the actual convergence criteria, with default value 1e-5
</p>
</li>
<li><p> tol. tolerance for genotype probabilities with default value 1e-8
</p>
</li>
<li><p> maxit. maximum number of iterations, with default value 50
</p>
</li>
<li><p> pl. criteria for trimming haplotypes according to posterior probabilities
</p>
</li>
<li><p> assignment. filename containing haplotype assignment
</p>
</li>
<li><p> verbose. If TRUE, yields print out from the C routine
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Gene counting for haplotype analysis with missing data.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> h haplotype frequency estimates under linkage disequilibrium (LD).
</p>
</li>
<li><p> h0 haplotype frequency estimates under linkage equilibrium (no LD).
</p>
</li>
<li><p> prob genotype probability estimates.
</p>
</li>
<li><p> l0 log-likelihood under linkage equilibrium.
</p>
</li>
<li><p> l1 log-likelihood under linkage disequilibrium.
</p>
</li>
<li><p> hapid unique haplotype identifier (defunct, see <code>gc.em</code>).
</p>
</li>
<li><p> npusr number of parameters according user-given alleles.
</p>
</li>
<li><p> npdat number of parameters according to observed.
</p>
</li>
<li><p> htrtable design matrix for haplotype trend regression (defunct, see <code>gc.em</code>).
</p>
</li>
<li><p> iter number of iterations used in gene counting.
</p>
</li>
<li><p> converge a flag indicating convergence status of gene counting.
</p>
</li>
<li><p> di0 haplotype diversity under no LD, defined as <code class="reqn">1-\sum (h_0^2)</code>.
</p>
</li>
<li><p> di1 haplotype diversity under LD, defined as <code class="reqn">1-\sum (h^2))</code>.
</p>
</li>
<li><p> resid residuals in terms of frequency weights = o - e.
</p>
</li></ul>



<h3>Note</h3>

<p>adapted from GENECOUNTING.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Zhao JH, Lissarrague S, Essioux L, Sham PC (2002).
&ldquo;GENECOUNTING: haplotype analysis with missing genotypes.&rdquo;
<em>Bioinformatics</em>, <b>18</b>(12), 1694-5.
ISSN 1367-4803 (Print) 1367-4803, <a href="https://doi.org/10.1093/bioinformatics/18.12.1694">doi:10.1093/bioinformatics/18.12.1694</a>.
</p>
<p>Zhao JH, Sham PC (2003).
&ldquo;Generic number systems and haplotype analysis.&rdquo;
<em>Comput Methods Programs Biomed</em>, <b>70</b>(1), 1-9.
ISSN 0169-2607 (Print) 0169-2607, <a href="https://doi.org/10.1016/s0169-2607%2801%2900193-6">doi:10.1016/s0169-2607(01)00193-6</a>.
</p>
<p>Zhao JH (2004).
&ldquo;2LD. GENECOUNTING and HAP: computer programs for linkage disequilibrium analysis.&rdquo;
<em>Bioinformatics</em>, <b>20</b>(8), 1325-6.
ISSN 1367-4803 (Print) 1367-4803, <a href="https://doi.org/10.1093/bioinformatics/bth071">doi:10.1093/bioinformatics/bth071</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gc.em">gc.em</a></code>, <code><a href="#topic+LDkl">LDkl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(gap.datasets)
# HLA data
data(hla)
hla.gc &lt;- genecounting(hla[,3:8])
summary(hla.gc)
hla.gc$l0
hla.gc$l1

# ALDH2 data
data(aldh2)
control &lt;- gc.control(handle.miss=1,assignment="ALDH2.out")
aldh2.gc &lt;- genecounting(aldh2[,3:6],control=control)
summary(aldh2.gc)
aldh2.gc$l0
aldh2.gc$l1

# Chromosome X data
# assuming allelic data have been extracted in columns 3-13
# and column 3 is sex
filespec &lt;- system.file("tests/genecounting/mao.dat")
mao2 &lt;- read.table(filespec)
dat &lt;- mao2[,3:13]
loci &lt;- c(12,9,6,5,3)
contr &lt;- gc.control(xdata=TRUE,handle.miss=1)
mao.gc &lt;- genecounting(dat,loci=loci,control=contr)
mao.gc$npusr
mao.gc$npdat

## End(Not run)
</code></pre>

<hr>
<h2 id='geno.recode'>Genotype recoding</h2><span id='topic+geno.recode'></span>

<h3>Description</h3>

<p>Genotype recoding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno.recode(geno, miss.val = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno.recode_+3A_geno">geno</code></td>
<td>
<p>genotype.</p>
</td></tr>
<tr><td><code id="geno.recode_+3A_miss.val">miss.val</code></td>
<td>
<p>missing value.</p>
</td></tr>
</table>

<hr>
<h2 id='get_b_se'>Get b and se from AF, n, and z</h2><span id='topic+get_b_se'></span>

<h3>Description</h3>

<p>The function obtains effect size and its standard error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_b_se(f, n, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_b_se_+3A_f">f</code></td>
<td>
<p>Allele frequency.</p>
</td></tr>
<tr><td><code id="get_b_se_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="get_b_se_+3A_z">z</code></td>
<td>
<p>z-statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>b and se.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  library(dplyr)
  # eQTLGen
  cis_pQTL &lt;- merge(read.delim('eQTLGen.lz') %&gt;%
              filter(GeneSymbol=="LTBR"),read.delim("eQTLGen.AF"),by="SNP") %&gt;%
              mutate(data.frame(get_b_se(AlleleB_all,NrSamples,Zscore)))
  head(cis_pQTL,1)
        SNP    Pvalue SNPChr  SNPPos AssessedAllele OtherAllele Zscore
  rs1003563 2.308e-06     12 6424577              A           G 4.7245
             Gene GeneSymbol GeneChr GenePos NrCohorts NrSamples         FDR
  ENSG00000111321       LTBR      12 6492472        34     23991 0.006278872
  BonferroniP hg19_chr hg19_pos AlleleA AlleleB allA_total allAB_total
            1       12  6424577       A       G       2574        8483
  allB_total AlleleB_all          b          se
        7859   0.6396966 0.04490488 0.009504684

## End(Not run)
</code></pre>

<hr>
<h2 id='get_pve_se'>Get pve and its standard error from n, z</h2><span id='topic+get_pve_se'></span>

<h3>Description</h3>

<p>Get pve and its standard error from n, z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pve_se(n, z, correction = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pve_se_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="get_pve_se_+3A_z">z</code></td>
<td>
<p>z-statistic, i.e., b/se when they are available instead.</p>
</td></tr>
<tr><td><code id="get_pve_se_+3A_correction">correction</code></td>
<td>
<p>if TRUE an correction based on t-statistic is applied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function obtains proportion of explained variance of a continuous outcome.
</p>


<h3>Value</h3>

<p>pve and its se.
</p>

<hr>
<h2 id='get_sdy'>Get sd(y) from AF, n, b, se</h2><span id='topic+get_sdy'></span>

<h3>Description</h3>

<p>Get sd(y) from AF, n, b, se
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sdy(f, n, b, se, method = "mean", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sdy_+3A_f">f</code></td>
<td>
<p>Allele frequency.</p>
</td></tr>
<tr><td><code id="get_sdy_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="get_sdy_+3A_b">b</code></td>
<td>
<p>effect size.</p>
</td></tr>
<tr><td><code id="get_sdy_+3A_se">se</code></td>
<td>
<p>standard error.</p>
</td></tr>
<tr><td><code id="get_sdy_+3A_method">method</code></td>
<td>
<p>method of averaging: &quot;mean&quot; or &quot;median&quot;.</p>
</td></tr>
<tr><td><code id="get_sdy_+3A_...">...</code></td>
<td>
<p>argument(s) passed to method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function obtains standard error of a continuous outcome.
</p>


<h3>Value</h3>

<p>sd(y).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1)
X1 &lt;- matrix(rbinom(1200,1,0.4),ncol=2)
X2 &lt;- matrix(rbinom(1000,1,0.6),ncol=2)
colnames(X1) &lt;- colnames(X2) &lt;- c("f1","f2")
Y1 &lt;- rnorm(600,apply(X1,1,sum),2)
Y2 &lt;- rnorm(500,2*apply(X2,1,sum),5)
summary(lm1 &lt;- lm(Y1~f1+f2,data=as.data.frame(X1)))
summary(lm2 &lt;- lm(Y2~f1+f2,data=as.data.frame(X2)))
b1 &lt;- coef(lm1)
b2 &lt;- coef(lm2)
v1 &lt;- vcov(lm1)
v2 &lt;- vcov(lm2)
require(coloc)
## Bayesian approach, esp. when only p values are available
abf &lt;- coloc.abf(list(beta=b1, varbeta=diag(v1), N=nrow(X1), sdY=sd(Y1), type="quant"),
                 list(beta=b2, varbeta=diag(v2), N=nrow(X2), sdY=sd(Y2), type="quant"))
abf
# sdY
cat("sd(Y)=",sd(Y1),"==&gt; Estimates:",sqrt(diag(var(X1)*b1[-1]^2+var(X1)*v1[-1,-1]*nrow(X1))),"\n")
for(k in 1:2)
{
  k1 &lt;- k + 1
  cat("Based on b",k," sd(Y1) = ",sqrt(var(X1[,k])*(b1[k1]^2+nrow(X1)*v1[k1,k1])),"\n",sep="")
}
cat("sd(Y)=",sd(Y2),"==&gt; Estimates:",sqrt(diag(var(X2)*b2[-1]^2+var(X2)*v2[-1,-1]*nrow(X2))),"\n")
for(k in 1:2)
{
  k1 &lt;- k + 1
  cat("Based on b",k," sd(Y2) = ",sqrt(var(X2[,k])*(b2[k1]^2+nrow(X2)*v2[k1,k1])),"\n",sep="")
}
get_sdy(0.6396966,23991,0.04490488,0.009504684)

## End(Not run)
</code></pre>

<hr>
<h2 id='gif'>Kinship coefficient and genetic index of familiality</h2><span id='topic+gif'></span>

<h3>Description</h3>

<p>Kinship coefficient and genetic index of familiality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gif(data, gifset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gif_+3A_data">data</code></td>
<td>
<p>the trio data of a pedigree.</p>
</td></tr>
<tr><td><code id="gif_+3A_gifset">gifset</code></td>
<td>
<p>a subgroup of pedigree members.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The genetic index of familality is defined as the mean kinship between
all pairs of individuals in a set multiplied by 100,000. Formally, it
is defined in (Gholami and Thomas 1994) as
</p>
<p style="text-align: center;"><code class="reqn">100,000 \times \frac{2}{n(n-1)}\sum_{i=1}^{n-1}\sum_{j=i+1}^n k_{ij}</code>
</p>

<p>where <code class="reqn">n</code> is the number of individuals in the set and <code class="reqn">k_{ij}</code> is the
kinship coefficient between individuals <code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
<p>The scaling is purely for convenience of presentation.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> gifval the genetic index of familiarity.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from gif.c, testable with -Dexecutable as standalone program,
which can be use for any pair of indidivuals
</p>


<h3>Author(s)</h3>

<p>Alun Thomas, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Gholami K, Thomas A (1994).
&ldquo;A linear time algorithm for calculation of multiple pairwise kinship coefficients and the genetic index of familiality.&rdquo;
<em>Comput Biomed Res</em>, <b>27</b>(5), 342-50.
ISSN 0010-4809 (Print) 0010-4809, <a href="https://doi.org/10.1006/cbmr.1994.1026">doi:10.1006/cbmr.1994.1026</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfc">pfc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
test&lt;-c(
 5,      0,      0,
 1,      0,      0,
 9,      5,      1,
 6,      0,      0,
10,      9,      6,
15,      9,      6,
21,     10,     15,
 3,      0,      0,
18,      3,     15,
23,     21,     18,
 2,      0,      0,
 4,      0,      0,
 7,      0,      0,
 8,      4,      7,
11,      5,      8,
12,      9,      6,
13,      9,      6,
14,      5,      8,
16,     14,      6,
17,     10,      2,
19,      9,     11,
20,     10,     13,
22,     21,     20)
test&lt;-matrix(test,ncol=3,byrow=TRUE)
gif(test,gifset=c(20,21,22))

# all individuals
gif(test,gifset=1:23)

## End(Not run)

</code></pre>

<hr>
<h2 id='grid2d'>Two-dimensional grid</h2><span id='topic+grid2d'></span>

<h3>Description</h3>

<p>This function build 2-d grids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid2d(
  chrlen,
  plot = TRUE,
  cex.labels = 0.6,
  xlab = "QTL position",
  ylab = "Gene position"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid2d_+3A_chrlen">chrlen</code></td>
<td>
<p>Lengths of chromosomes; e.g., hg18, hg19 or hg38.</p>
</td></tr>
<tr><td><code id="grid2d_+3A_plot">plot</code></td>
<td>
<p>A flag for plot.</p>
</td></tr>
<tr><td><code id="grid2d_+3A_cex.labels">cex.labels</code></td>
<td>
<p>A scaling factor for labels.</p>
</td></tr>
<tr><td><code id="grid2d_+3A_xlab">xlab</code></td>
<td>
<p>X-axis title.</p>
</td></tr>
<tr><td><code id="grid2d_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis title.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two variables:
</p>

<ul>
<li><p> n Number of chromosomes.
</p>
</li>
<li><p> CM Cumulative lengths starting from 0.
</p>
</li></ul>


<hr>
<h2 id='h2_mzdz'>Heritability estimation according to twin correlations</h2><span id='topic+h2_mzdz'></span>

<h3>Description</h3>

<p>Heritability estimation according to twin correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2_mzdz(
  mzDat = NULL,
  dzDat = NULL,
  rmz = NULL,
  rdz = NULL,
  nmz = NULL,
  ndz = NULL,
  selV = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h2_mzdz_+3A_mzdat">mzDat</code></td>
<td>
<p>a data frame for monzygotic twins (MZ).</p>
</td></tr>
<tr><td><code id="h2_mzdz_+3A_dzdat">dzDat</code></td>
<td>
<p>a data frame for dizygotic twins (DZ).</p>
</td></tr>
<tr><td><code id="h2_mzdz_+3A_rmz">rmz</code></td>
<td>
<p>correlation for MZ twins.</p>
</td></tr>
<tr><td><code id="h2_mzdz_+3A_rdz">rdz</code></td>
<td>
<p>correlation for DZ twins.</p>
</td></tr>
<tr><td><code id="h2_mzdz_+3A_nmz">nmz</code></td>
<td>
<p>sample size for MZ twins.</p>
</td></tr>
<tr><td><code id="h2_mzdz_+3A_ndz">ndz</code></td>
<td>
<p>sample size for DZ twins.</p>
</td></tr>
<tr><td><code id="h2_mzdz_+3A_selv">selV</code></td>
<td>
<p>names of variables for twin and cotwin.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given MZ/DZ data or their correlations and sample sizes, it obtains
heritability and variance estimates under an ACE model as in
<a href="https://doi.org/10.1038/s41562-023-01530-y">doi:10.1038/s41562-023-01530-y</a> and Keeping (1995).
</p>


<h3>Value</h3>

<p>A data.frame with variables h2, c2, e2, vh2, vc2, ve2.
</p>


<h3>References</h3>

<p>Elks CE, den Hoed M, Zhao JH, Sharp SJ, Wareham NJ, Loos RJ, Ong KK (2012).
&ldquo;Variability in the heritability of body mass index: a systematic review and meta-regression.&rdquo;
<em>Front Endocrinol (Lausanne)</em>, <b>3</b>, 29.
ISSN 1664-2392, <a href="https://doi.org/10.3389/fendo.2012.00029">doi:10.3389/fendo.2012.00029</a>.
</p>
<p>Keeping ES (1995).
<em>Introduction to statistical inference</em>,  Dover books on mathematics, Dover edition.
Dover Publications, New York.
ISBN 9780486685021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(mvtnorm)
set.seed(12345)
mzm &lt;- as.data.frame(rmvnorm(195, c(22.75,22.75),
                     matrix(2.66^2*c(1, 0.67, 0.67, 1), 2)))
dzm &lt;- as.data.frame(rmvnorm(130, c(23.44,23.44),
                     matrix(2.75^2*c(1, 0.32, 0.32, 1), 2)))
mzw &lt;- as.data.frame(rmvnorm(384, c(21.44,21.44),
                     matrix(3.08^2*c(1, 0.72, 0.72, 1), 2)))
dzw &lt;- as.data.frame(rmvnorm(243, c(21.72,21.72),
                     matrix(3.12^2*c(1, 0.33, 0.33, 1), 2)))
selVars &lt;- c('bmi1','bmi2')
names(mzm) &lt;- names(dzm) &lt;- names(mzw) &lt;- names(dzw) &lt;- selVars
ACE_CI &lt;- function(mzData,dzData,n.sim=5,selV=NULL,verbose=TRUE)
{
  ACE_obs &lt;- h2_mzdz(mzDat=mzData,dzDat=dzData,selV=selV)
  cat("\n\nheritability according to correlations\n\n")
  print(format(ACE_obs,digits=3),row.names=FALSE)
  nmz &lt;- nrow(mzData)
  ndz &lt;- nrow(dzData)
  r &lt;- data.frame()
  for(i in 1:n.sim)
  {
    cat("\rRunning # ",i,"/", n.sim,"\r",sep="")
    sampled_mz &lt;- sample(1:nmz, replace=TRUE)
    sampled_dz &lt;- sample(1:ndz, replace=TRUE)
    mzDat &lt;- mzData[sampled_mz,]
    dzDat &lt;- dzData[sampled_dz,]
    ACE_i &lt;- h2_mzdz(mzDat=mzDat,dzDat=dzDat,selV=selV)
    if (verbose) print(ACE_i)
    r &lt;- rbind(r,ACE_i)
  }
  m &lt;- apply(r,2,mean,na.rm=TRUE)
  s &lt;- apply(r,2,sd,na.rm=TRUE)
  allr &lt;- data.frame(mean=m,sd=s,lcl=m-1.96*s,ucl=m+1.96*s)
  print(format(allr,digits=3))
}
ACE_CI(mzm,dzm,n.sim=500,selV=selVars,verbose=FALSE)
ACE_CI(mzw,dzw,n.sim=500,selV=selVars,verbose=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='h2.jags'>Heritability estimation based on genomic relationship matrix using JAGS</h2><span id='topic+h2.jags'></span>

<h3>Description</h3>

<p>Heritability estimation based on genomic relationship matrix using JAGS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2.jags(
  y,
  x,
  G,
  eps = 1e-04,
  sigma.p = 0,
  sigma.r = 1,
  parms = c("b", "p", "r", "h2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h2.jags_+3A_y">y</code></td>
<td>
<p>outcome vector.</p>
</td></tr>
<tr><td><code id="h2.jags_+3A_x">x</code></td>
<td>
<p>covariate matrix.</p>
</td></tr>
<tr><td><code id="h2.jags_+3A_g">G</code></td>
<td>
<p>genomic relationship matrix.</p>
</td></tr>
<tr><td><code id="h2.jags_+3A_eps">eps</code></td>
<td>
<p>a positive diagonal perturbation to G.</p>
</td></tr>
<tr><td><code id="h2.jags_+3A_sigma.p">sigma.p</code></td>
<td>
<p>initial parameter values.</p>
</td></tr>
<tr><td><code id="h2.jags_+3A_sigma.r">sigma.r</code></td>
<td>
<p>initial parameter values.</p>
</td></tr>
<tr><td><code id="h2.jags_+3A_parms">parms</code></td>
<td>
<p>monitored parmeters.</p>
</td></tr>
<tr><td><code id="h2.jags_+3A_...">...</code></td>
<td>
<p>parameters passed to jags, e.g., n.chains, n.burnin, n.iter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs Bayesian heritability estimation using genomic relationship matrix.
</p>


<h3>Value</h3>

<p>The returned value is a fitted model from jags().
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
keywords htest
</p>


<h3>References</h3>

<p>Zhao JH, Luan JA, Congdon P (2018).
&ldquo;Bayesian Linear Mixed Models with Polygenic Effects.&rdquo;
<em>Journal of Statistical Software</em>, <b>85</b>(6), 1 - 27.
<a href="https://doi.org/10.18637/jss.v085.i06">doi:10.18637/jss.v085.i06</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(gap.datasets)
set.seed(1234567)
meyer &lt;- within(meyer,{
    y[is.na(y)] &lt;- rnorm(length(y[is.na(y)]),mean(y,na.rm=TRUE),sd(y,na.rm=TRUE))
    g1 &lt;- ifelse(generation==1,1,0)
    g2 &lt;- ifelse(generation==2,1,0)
    id &lt;- animal
    animal &lt;- ifelse(!is.na(animal),animal,0)
    dam &lt;- ifelse(!is.na(dam),dam,0)
    sire &lt;- ifelse(!is.na(sire),sire,0)
})
G &lt;- kin.morgan(meyer)$kin.matrix*2
library(regress)
r &lt;- regress(y~-1+g1+g2,~G,data=meyer)
r
with(r,h2G(sigma,sigma.cov))
eps &lt;- 0.001
y &lt;- with(meyer,y)
x &lt;- with(meyer,cbind(g1,g2))
ex &lt;- h2.jags(y,x,G,sigma.p=0.03,sigma.r=0.014)
print(ex)

## End(Not run)

</code></pre>

<hr>
<h2 id='h2G'>Heritability and its variance</h2><span id='topic+h2G'></span>

<h3>Description</h3>

<p>Heritability and its variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2G(V, VCOV, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h2G_+3A_v">V</code></td>
<td>
<p>Variance estimates.</p>
</td></tr>
<tr><td><code id="h2G_+3A_vcov">VCOV</code></td>
<td>
<p>Variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="h2G_+3A_verbose">verbose</code></td>
<td>
<p>Detailed output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of phenotypic variance/heritability estimates and their variances.
</p>

<hr>
<h2 id='h2GE'>Heritability and its variance when there is an environment component</h2><span id='topic+h2GE'></span>

<h3>Description</h3>

<p>Heritability and its variance when there is an environment component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2GE(V, VCOV, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h2GE_+3A_v">V</code></td>
<td>
<p>Variance estimates.</p>
</td></tr>
<tr><td><code id="h2GE_+3A_vcov">VCOV</code></td>
<td>
<p>Variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="h2GE_+3A_verbose">verbose</code></td>
<td>
<p>Detailed output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of phenotypic variance/heritability/GxE interaction esimates and their variances.
</p>

<hr>
<h2 id='h2l'>Heritability under the liability threshold model</h2><span id='topic+h2l'></span>

<h3>Description</h3>

<p>Heritability under the liability threshold model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h2l(K = 0.05, P = 0.5, h2, se, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="h2l_+3A_k">K</code></td>
<td>
<p>Disease prevalence.</p>
</td></tr>
<tr><td><code id="h2l_+3A_p">P</code></td>
<td>
<p>Phenotypeic variance.</p>
</td></tr>
<tr><td><code id="h2l_+3A_h2">h2</code></td>
<td>
<p>Heritability estimate.</p>
</td></tr>
<tr><td><code id="h2l_+3A_se">se</code></td>
<td>
<p>Standard error.</p>
</td></tr>
<tr><td><code id="h2l_+3A_verbose">verbose</code></td>
<td>
<p>Detailed output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the input heritability estimate/standard error and their counterpart under liability threshold model, the normal deviate..
</p>

<hr>
<h2 id='hap'>Haplotype reconstruction</h2><span id='topic+hap'></span>

<h3>Description</h3>

<p>Haplotype reconstruction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hap(
  id,
  data,
  nloci,
  loci = rep(2, nloci),
  names = paste("loci", 1:nloci, sep = ""),
  control = hap.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hap_+3A_id">id</code></td>
<td>
<p>a column of subject id.</p>
</td></tr>
<tr><td><code id="hap_+3A_data">data</code></td>
<td>
<p>genotype table.</p>
</td></tr>
<tr><td><code id="hap_+3A_nloci">nloci</code></td>
<td>
<p>number of loci.</p>
</td></tr>
<tr><td><code id="hap_+3A_loci">loci</code></td>
<td>
<p>number of alleles at all loci.</p>
</td></tr>
<tr><td><code id="hap_+3A_names">names</code></td>
<td>
<p>locus names.</p>
</td></tr>
<tr><td><code id="hap_+3A_control">control</code></td>
<td>
<p>is a call to hap.control().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Haplotype reconstruction using sorting and trimming algorithms.
</p>
<p>The package can hanlde much larger number of multiallelic loci.
For large sample size with relatively small number of multiallelic
loci, genecounting should be used.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> l1 log-likelihood assuming linkage disequilibrium.
</p>
</li>
<li><p> converge convergence status, 0=failed, 1=succeeded.
</p>
</li>
<li><p> niter number of iterations.
</p>
</li></ul>



<h3>Note</h3>

<p>adapted from hap.
</p>


<h3>References</h3>

<p>Clayton DG (2001) SNPHAP. https://github.com/chr1swallace/snphap.
</p>
<p>Zhao JH and W Qian (2003) Association analysis of unrelated individuals
using polymorphic genetic markers. RSS 2003, Hassalt, Belgium
</p>
<p>Zhao JH (2004).
&ldquo;2LD. GENECOUNTING and HAP: computer programs for linkage disequilibrium analysis.&rdquo;
<em>Bioinformatics</em>, <b>20</b>(8), 1325-6.
ISSN 1367-4803 (Print) 1367-4803, <a href="https://doi.org/10.1093/bioinformatics/bth071">doi:10.1093/bioinformatics/bth071</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genecounting">genecounting</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(gap.datasets)
# 4 SNP example, to generate hap.out and assign.out alone
data(fsnps)
hap(id=fsnps[,1],data=fsnps[,3:10],nloci=4)
dir()

# to generate results of imputations
control &lt;- hap.control(ss=1,mi=5,hapfile="h",assignfile="a")
hap(id=fsnps[,1],data=fsnps[,3:10],nloci=4,control=control)
dir()

## End(Not run)

</code></pre>

<hr>
<h2 id='hap.control'>Control for haplotype reconstruction</h2><span id='topic+hap.control'></span>

<h3>Description</h3>

<p>Control for haplotype reconstruction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hap.control(
  mb = 0,
  pr = 0,
  po = 0.001,
  to = 0.001,
  th = 1,
  maxit = 100,
  n = 0,
  ss = 0,
  rs = 0,
  rp = 0,
  ro = 0,
  rv = 0,
  sd = 0,
  mm = 0,
  mi = 0,
  mc = 50,
  ds = 0.1,
  de = 0,
  q = 0,
  hapfile = "hap.out",
  assignfile = "assign.out"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hap.control_+3A_mb">mb</code></td>
<td>
<p>Maximum dynamic storage to be allocated, in Mb.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_pr">pr</code></td>
<td>
<p>Prior (ie population) probability threshold.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_po">po</code></td>
<td>
<p>Posterior probability threshold.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_to">to</code></td>
<td>
<p>Log-likelihood convergence tolerance.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_th">th</code></td>
<td>
<p>Posterior probability threshold for output.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_maxit">maxit</code></td>
<td>
<p>Maximum EM iteration.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_n">n</code></td>
<td>
<p>Force numeric allele coding (1/2) on output (off).</p>
</td></tr>
<tr><td><code id="hap.control_+3A_ss">ss</code></td>
<td>
<p>Tab-delimited speadsheet file output (off).</p>
</td></tr>
<tr><td><code id="hap.control_+3A_rs">rs</code></td>
<td>
<p>Random starting points for each EM iteration (off).</p>
</td></tr>
<tr><td><code id="hap.control_+3A_rp">rp</code></td>
<td>
<p>Restart from random prior probabilities.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_ro">ro</code></td>
<td>
<p>Loci added in random order (off).</p>
</td></tr>
<tr><td><code id="hap.control_+3A_rv">rv</code></td>
<td>
<p>Loci added in reverse order (off).</p>
</td></tr>
<tr><td><code id="hap.control_+3A_sd">sd</code></td>
<td>
<p>Set seed for random number generator (use date+time).</p>
</td></tr>
<tr><td><code id="hap.control_+3A_mm">mm</code></td>
<td>
<p>Repeat final maximization multiple times.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_mi">mi</code></td>
<td>
<p>Create multiple imputed datasets. If set &gt;0.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_mc">mc</code></td>
<td>
<p>Number of MCMC steps between samples.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_ds">ds</code></td>
<td>
<p>Starting value of Dirichlet prior parameter.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_de">de</code></td>
<td>
<p>Finishing value of Dirichlet prior parameter.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_q">q</code></td>
<td>
<p>Quiet operation (off).</p>
</td></tr>
<tr><td><code id="hap.control_+3A_hapfile">hapfile</code></td>
<td>
<p>a file for haplotype frequencies.</p>
</td></tr>
<tr><td><code id="hap.control_+3A_assignfile">assignfile</code></td>
<td>
<p>a file for haplotype assignment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the parameter specifications to the function.
</p>

<hr>
<h2 id='hap.em'>Gene counting for haplotype analysis</h2><span id='topic+hap.em'></span>

<h3>Description</h3>

<p>Gene counting for haplotype analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hap.em(
  id,
  data,
  locus.label = NA,
  converge.eps = 1e-06,
  maxiter = 500,
  miss.val = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hap.em_+3A_id">id</code></td>
<td>
<p>a vector of individual IDs.</p>
</td></tr>
<tr><td><code id="hap.em_+3A_data">data</code></td>
<td>
<p>Matrix of alleles, such that each locus has a pair of
adjacent columns of alleles, and the order of columns
corresponds to the order of loci on a  chromosome. If
there are K loci, then ncol(data) = 2*K. Rows represent
alleles for each subject.</p>
</td></tr>
<tr><td><code id="hap.em_+3A_locus.label">locus.label</code></td>
<td>
<p>Vector of  labels  for  loci,  of  length  K  (see definition of data matrix).</p>
</td></tr>
<tr><td><code id="hap.em_+3A_converge.eps">converge.eps</code></td>
<td>
<p>Convergence criterion, based on absolute  change in log likelihood (lnlike).</p>
</td></tr>
<tr><td><code id="hap.em_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations of EM.</p>
</td></tr>
<tr><td><code id="hap.em_+3A_miss.val">miss.val</code></td>
<td>
<p>missing value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gene counting for haplotype analysis with missing data, adapted for <code>hap.score</code>.
</p>


<h3>Value</h3>

<p>List with components:
</p>

<ul>
<li><p> converge Indicator of convergence of the EM algorithm (1=converged, 0 = failed).
</p>
</li>
<li><p> niter Number of iterations completed in the EM alogrithm.
</p>
</li>
<li><p> locus.info A list with  a  component for each locus.  Each
component is also a list, and  the  items of a locus-
specific list are the locus name and a vector for the
unique alleles for the locus.
</p>
</li>
<li><p> locus.label Vector of  labels for loci, of length K (see definition of input values).
</p>
</li>
<li><p> haplotype Matrix of unique haplotypes. Each row represents a
unique haplotype, and the number of columns is the number of loci.
</p>
</li>
<li><p> hap.prob Vector of mle's of haplotype probabilities.  The ith
element of hap.prob corresponds to the ith row of haplotype.
</p>
</li>
<li><p> lnlike Value of lnlike at last EM iteration (maximum lnlike if converged).
</p>
</li>
<li><p> indx.subj Vector for index of subjects, after  expanding  to
all possible  pairs  of  haplotypes  for  each person. If
indx=i, then i is the ith row of input matrix data. If the
ith subject has  n possible  pairs  of haplotypes that
correspond to their marker phenotype, then i is repeated n times.
</p>
</li>
<li><p> nreps Vector for the count of haplotype pairs that map to
each subject's marker genotypes.
</p>
</li>
<li><p> hap1code Vector of codes for each subject's first haplotype.
The values in hap1code are the row numbers of the unique
haplotypes in the returned matrix haplotype.
</p>
</li>
<li><p> hap2code Similar to hap1code, but for  each  subject's  second haplotype.
</p>
</li>
<li><p> post Vector of posterior probabilities of pairs of
haplotypes for a person, given thier marker phenotypes.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from HAP.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hap">hap</a></code>, <code><a href="#topic+LDkl">LDkl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(hla)
hap.em(id=1:length(hla[,1]),data=hla[,3:8],locus.label=c("DQR","DQA","DQB"))

## End(Not run)

</code></pre>

<hr>
<h2 id='hap.score'>Score statistics for association of traits with haplotypes</h2><span id='topic+hap.score'></span>

<h3>Description</h3>

<p>Score statistics for association of traits with haplotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hap.score(
  y,
  geno,
  trait.type = "gaussian",
  offset = NA,
  x.adj = NA,
  skip.haplo = 0.005,
  locus.label = NA,
  miss.val = 0,
  n.sim = 0,
  method = "gc",
  id = NA,
  handle.miss = 0,
  mloci = NA,
  sexid = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hap.score_+3A_y">y</code></td>
<td>
<p>Vector of trait values. For  trait.type  =  &quot;binomial&quot;,  y  must have values of 1 for event, 0 for no event.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_geno">geno</code></td>
<td>
<p>Matrix of alleles, such that each locus has a pair of adjacent columns of alleles, and the order of columns corresponds to the order of loci on a chromosome. If there are K loci, then ncol(geno) = 2*K. Rows represent alleles for each subject.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_trait.type">trait.type</code></td>
<td>
<p>Character string  defining  type  of  trait, with values of &quot;gaussian&quot;, &quot;binomial&quot;, &quot;poisson&quot;, &quot;ordinal&quot;.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_offset">offset</code></td>
<td>
<p>Vector of offset when trait.type = &quot;poisson&quot;.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_x.adj">x.adj</code></td>
<td>
<p>Matrix of non-genetic covariates used to adjust the score statistics. Note that intercept should not be included, as it will be added in this function.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_skip.haplo">skip.haplo</code></td>
<td>
<p>Skip score statistics for haplotypes with frequencies &lt; skip.haplo.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_locus.label">locus.label</code></td>
<td>
<p>Vector of labels for loci, of length K (see definition of geno matrix).</p>
</td></tr>
<tr><td><code id="hap.score_+3A_miss.val">miss.val</code></td>
<td>
<p>Vector of codes for missing values of alleles.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_n.sim">n.sim</code></td>
<td>
<p>Number of simulations for empirical p-values.  If n.sim=0, no empirical p-values are computed.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_method">method</code></td>
<td>
<p>method of haplotype frequency estimation, &quot;gc&quot; or &quot;hap&quot;.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_id">id</code></td>
<td>
<p>an added option which contains the individual IDs.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_handle.miss">handle.miss</code></td>
<td>
<p>flag to handle missing genotype data, 0=no, 1=yes.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_mloci">mloci</code></td>
<td>
<p>maximum number of loci/sites with missing data to be allowed in the analysis.</p>
</td></tr>
<tr><td><code id="hap.score_+3A_sexid">sexid</code></td>
<td>
<p>flag to indicator sex for data from X chromosome, i=male, 2=female.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compute score statistics to evaluate the association of a trait with haplotypes, when linkage phase is unknown and diploid marker
phenotypes are observed among unrelated subjects. For now, only autosomal loci are considered. This package haplo.score
which this function is based is greatly acknowledged.
</p>
<p>This is a version which substitutes haplo.em.
</p>


<h3>Value</h3>

<p>List with the following components:
</p>

<ul>
<li><p> score.global Global statistic to test association of trait with haplotypes that have frequencies &gt;= skip.haplo.
</p>
</li>
<li><p> df Degrees of freedom for score.global.
</p>
</li>
<li><p> score.global.p P-value of score.global based on chi-square distribution, with degrees of freedom equal to df.
</p>
</li>
<li><p> score.global.p.sim P-value of score.global based on simulations (set equal to NA when n.sim=0).
</p>
</li>
<li><p> score.haplo Vector of score statistics for individual haplotypes that have frequencies &gt;= skip.haplo.
</p>
</li>
<li><p> score.haplo.p Vector of p-values for score.haplo, based on a chi-square distribution with 1 df.
</p>
</li>
<li><p> score.haplo.p.sim Vector of p-values for score.haplo, based on  simulations (set equal to NA when n.sim=0).
</p>
</li>
<li><p> score.max.p.sim P-value  of  maximum  score.haplo, based on simulations (set equal to NA when n.sim=0).
</p>
</li>
<li><p> haplotype Matrix of hapoltypes  analyzed.  The ith row of haplotype corresponds to the ith item of score.haplo, score.haplo.p, and score.haplo.p.sim.
</p>
</li>
<li><p> hap.prob Vector of haplotype probabilies, corresponding to the haplotypes in the matrix haplotype.
</p>
</li>
<li><p> locus.label Vector of labels for loci, of length K (same as input argument).
</p>
</li>
<li><p> n.sim Number of simulations.
</p>
</li>
<li><p> n.val.global Number of valid simulated global statistics.
</p>
</li>
<li><p> n.val.haplo Number of valid simulated score statistics (score.haplo) for individual haplotypes.
</p>
</li></ul>



<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM, Poland GA (2002).
&ldquo;Score tests for association between traits and haplotypes when linkage phase is ambiguous.&rdquo;
<em>Am J Hum Genet</em>, <b>70</b>(2), 425-34.
ISSN 0002-9297 (Print) 0002-9297, <a href="https://doi.org/10.1086/338688">doi:10.1086/338688</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(hla)
y&lt;-hla[,2]
geno&lt;-hla[,3:8]
# complete data
hap.score(y,geno,locus.label=c("DRB","DQA","DQB"))
# incomplete genotype data
hap.score(y,geno,locus.label=c("DRB","DQA","DQB"),handle.miss=1,mloci=1)
unlink("assign.dat")

### note the differences in p values in the following runs
data(aldh2)
# to subset the data since hap doesn't handle one allele missing
deleted&lt;-c(40,239,256)
aldh2[deleted,]
aldh2&lt;-aldh2[-deleted,]
y&lt;-aldh2[,2]
geno&lt;-aldh2[,3:18]
# only one missing locus
hap.score(y,geno,handle.miss=1,mloci=1,method="hap")
# up to seven missing loci and with 10,000 permutations
hap.score(y,geno,handle.miss=1,mloci=7,method="hap",n.sim=10000)

# hap.score takes considerably longer time and does not handle missing data
hap.score(y,geno,n.sim=10000)

## End(Not run)

</code></pre>

<hr>
<h2 id='hg18'>Chromosomal lengths for build 36</h2><span id='topic+hg18'></span>

<h3>Description</h3>

<p>Data are used in other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hg18
</code></pre>


<h3>Format</h3>

<p>A vector containing lengths of chromosomes.
</p>


<h3>Details</h3>

<p>generated from GRCh.R.
</p>

<hr>
<h2 id='hg19'>Chromosomal lengths for build 37</h2><span id='topic+hg19'></span>

<h3>Description</h3>

<p>Data are used in other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hg19
</code></pre>


<h3>Format</h3>

<p>A vector containing lengths of chromosomes.
</p>

<hr>
<h2 id='hg38'>Chromosomal lengths for build 38</h2><span id='topic+hg38'></span>

<h3>Description</h3>

<p>Data are used in other functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hg38
</code></pre>


<h3>Format</h3>

<p>A vector containing lengths of chromosomes.
</p>

<hr>
<h2 id='hmht.control'>Controls for highlights</h2><span id='topic+hmht.control'></span>

<h3>Description</h3>

<p>Specification of highlights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmht.control(
  data = NULL,
  colors = NULL,
  yoffset = 0.25,
  cex = 1.5,
  boxed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hmht.control_+3A_data">data</code></td>
<td>
<p>Data.</p>
</td></tr>
<tr><td><code id="hmht.control_+3A_colors">colors</code></td>
<td>
<p>Colors.</p>
</td></tr>
<tr><td><code id="hmht.control_+3A_yoffset">yoffset</code></td>
<td>
<p>Y offset.</p>
</td></tr>
<tr><td><code id="hmht.control_+3A_cex">cex</code></td>
<td>
<p>Scaling factor.</p>
</td></tr>
<tr><td><code id="hmht.control_+3A_boxed">boxed</code></td>
<td>
<p>Label in box.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list as above.
</p>

<hr>
<h2 id='htr'>Haplotype trend regression</h2><span id='topic+htr'></span>

<h3>Description</h3>

<p>Haplotype trend regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>htr(y, x, n.sim = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="htr_+3A_y">y</code></td>
<td>
<p>a vector of phenotype.</p>
</td></tr>
<tr><td><code id="htr_+3A_x">x</code></td>
<td>
<p>a haplotype table.</p>
</td></tr>
<tr><td><code id="htr_+3A_n.sim">n.sim</code></td>
<td>
<p>the number of permutations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Haplotype trend regression (with permutation)
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> f the F statistic for overall association.
</p>
</li>
<li><p> p the p value for overall association.
</p>
</li>
<li><p> fv the F statistics for individual haplotypes.
</p>
</li>
<li><p> pi the p values for individual haplotypes.
</p>
</li></ul>



<h3>Note</h3>

<p>adapted from emgi.cpp, a pseudorandom number seed will be added on.
</p>


<h3>Author(s)</h3>

<p>Dimitri Zaykin, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Zaykin DV, Westfall PH, Young SS, Karnoub MA, Wagner MJ, Ehm MG (2002).
&ldquo;Testing association of statistically inferred haplotypes with discrete and continuous traits in samples of unrelated individuals.&rdquo;
<em>Hum Hered</em>, <b>53</b>(2), 79-91.
ISSN 0001-5652 (Print) 0001-5652, <a href="https://doi.org/10.1159/000057986">doi:10.1159/000057986</a>.
</p>
<p>Xie R, Stram DO (2005).
&ldquo;Asymptotic equivalence between two score tests for haplotype-specific risk in general linear models.&rdquo;
<em>Genetic Epidemiology</em>, <b>29</b>(2), 166-170.
ISSN 0741-0395, <a href="https://doi.org/10.1002/gepi.20087">doi:10.1002/gepi.20087</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hap.score">hap.score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# 26-10-03
# this is now part of demo
test2&lt;-read.table("test2.dat")
y&lt;-test2[,1]
x&lt;-test2[,-1]
y&lt;-as.matrix(y)
x&lt;-as.matrix(x)
htr.test2&lt;-htr(y,x)
htr.test2
htr.test2&lt;-htr(y,x,n.sim=10)
htr.test2

# 13-11-2003
require(gap.datasets)
data(apoeapoc)
apoeapoc.gc&lt;-gc.em(apoeapoc[,5:8])
y&lt;-apoeapoc$y
for(i in 1:length(y)) if(y[i]==2) y[i]&lt;-1
htr(y,apoeapoc.gc$htrtable)

# 20-8-2008
# part of the example from useR!2008 tutorial by Andrea Foulkes
# It may be used beyond the generalized linear model (GLM) framework
HaploEM &lt;- haplo.em(Geno,locus.label=SNPnames)
HapMat &lt;- HapDesign(HaploEM)
m1 &lt;- lm(Trait~HapMat)
m2 &lt;- lm(Trait~1)
anova(m2,m1)

## End(Not run)

</code></pre>

<hr>
<h2 id='hwe'>Hardy-Weinberg equlibrium test for a multiallelic marker</h2><span id='topic+hwe'></span>

<h3>Description</h3>

<p>Hardy-Weinberg equlibrium test for a multiallelic marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwe(data, data.type = "allele", yates.correct = FALSE, miss.val = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hwe_+3A_data">data</code></td>
<td>
<p>A rectangular data containing the genotype, or an array of genotype counts.</p>
</td></tr>
<tr><td><code id="hwe_+3A_data.type">data.type</code></td>
<td>
<p>An option taking values &quot;allele&quot;, &quot;genotype&quot;, &quot;count&quot;  if data is alleles, genotype or genotype count.</p>
</td></tr>
<tr><td><code id="hwe_+3A_yates.correct">yates.correct</code></td>
<td>
<p>A flag indicating if Yates' correction is used for Pearson <code class="reqn">\chi^2</code> statistic.</p>
</td></tr>
<tr><td><code id="hwe_+3A_miss.val">miss.val</code></td>
<td>
<p>A list of missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hardy-Weinberg equilibrium test.
</p>
<p>This function obtains Hardy-Weinberg equilibrium test statistics. It can
handle data coded as allele numbers (default), genotype identifiers (by
setting data.type=&quot;genotype&quot;) and counts corresponding to individual genotypes
(by setting data.type=&quot;count&quot;) which requires that genotype counts for all n(n+1) possible genotypes,
with n being the number of alleles.
</p>
<p>For highly polymorphic markers when asymptotic results do not hold, please resort to <code><a href="#topic+hwe.hardy">hwe.hardy</a></code>.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> allele.freq Frequencies of alleles.
</p>
</li>
<li><p> x2 Pearson <code class="reqn">\chi^2</code>.
</p>
</li>
<li><p> p.x2 p value for <code class="reqn">\chi^2</code>.
</p>
</li>
<li><p> lrt Log-likelihood ratio test statistic.
</p>
</li>
<li><p> p.lrt p value for lrt.
</p>
</li>
<li><p> df Degree(s) of freedom.
</p>
</li>
<li><p> rho <code class="reqn">\sqrt{\chi^2/N}</code> the contingency table coefficient.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>See Also</h3>

<p><a href="#topic+hwe.hardy">hwe.hardy</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
a &lt;- c(3,2,2)
a.out &lt;- hwe(a,data.type="genotype")
a.out
a.out &lt;- hwe(a,data.type="count")
a.out
require(haplo.stats)
data(hla)
hla.DQR &lt;- hwe(hla[,3:4])
summary(hla.DQR)
# multiple markers
s &lt;- vector()
for(i in seq(3,8,2))
{
  hwe_i &lt;- hwe(hla[,i:(i+1)])
  s &lt;- rbind(s,hwe_i)
}
s

## End(Not run)

</code></pre>

<hr>
<h2 id='hwe.cc'>A likelihood ratio test of population Hardy-Weinberg equilibrium for case-control studies</h2><span id='topic+hwe.cc'></span>

<h3>Description</h3>

<p>A likelihood ratio test of population Hardy-Weinberg equilibrium for case-control studies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwe.cc(model, case, ctrl, k0, initial1, initial2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hwe.cc_+3A_model">model</code></td>
<td>
<p>model specification, dominant, recessive.</p>
</td></tr>
<tr><td><code id="hwe.cc_+3A_case">case</code></td>
<td>
<p>a vector of genotype counts in cases.</p>
</td></tr>
<tr><td><code id="hwe.cc_+3A_ctrl">ctrl</code></td>
<td>
<p>a vector of genotype counts in controls.</p>
</td></tr>
<tr><td><code id="hwe.cc_+3A_k0">k0</code></td>
<td>
<p>prevalence of disease in the population.</p>
</td></tr>
<tr><td><code id="hwe.cc_+3A_initial1">initial1</code></td>
<td>
<p>initial values for beta, gamma, and q.</p>
</td></tr>
<tr><td><code id="hwe.cc_+3A_initial2">initial2</code></td>
<td>
<p>initial values for logit(p) and log(gamma).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A likelihood ratio test of population Hardy-Weinberg equilibrium for case-control studies
</p>
<p>This is a collection of utility functions. The null hypothesis declares that the proportions of
genotypes are according to Hardy-Weinberg law, while under the alternative hypothesis, the expected
genotype counts are according to the probabilities that particular genotypes are obtained conditional
on the prevalence of disease in the population. In so doing, Hardy-Weinberg equilibrium is considered
using both case and control samples but pending on the disease model such that 2-parameter multiplicative
model is built on baseline genotype <code class="reqn">\alpha</code>, <code class="reqn">\alpha\beta</code> and
<code class="reqn">\alpha\gamma</code>.
</p>


<h3>Value</h3>

<p>The returned value is a list with the following components.
</p>

<ul>
<li><p> Cox statistics under a general model.
</p>
</li>
<li><p> t2par under the null hypothesis.
</p>
</li>
<li><p> t3par under the alternative hypothesis.
</p>
</li>
<li><p> lrt.stat the log-likelihood ratio statistic.
</p>
</li>
<li><p> pval the corresponding p value.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Chang Yu, Li Wang, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Yu C, Zhang S, Zhou C, Sile S (2009).
&ldquo;A likelihood ratio test of population Hardy-Weinberg equilibrium for case-control studies.&rdquo;
<em>Genet Epidemiol</em>, <b>33</b>(3), 275-80.
ISSN 0741-0395 (Print) 0741-0395, <a href="https://doi.org/10.1002/gepi.20381">doi:10.1002/gepi.20381</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hwe">hwe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Saba Sile, email of Jan 26, 2007, data always in order of GG AG AA, p=Pr(G),
### q=1-p=Pr(A)
case=c(155,27,4)
ctrl=c(408,55,15)
k0=.2
initial1=c(1.0,0.94,0.0904)
initial2=c(logit(1-0.0904),log(0.94))
hwe.cc("recessive",case,ctrl,k0, initial1, initial2)

### John Phillips III, TGFb1 data codon 10: TT CT CC, CC is abnormal and increasing
### TGFb1 activity
case=c(29,78,13)
ctrl=c(17,28,6)
k0 &lt;- 1e-5
initial1 &lt;- c(2.45,2.45,0.34)
initial2 &lt;- c(logit(1-0.34),log(2.45))
hwe.cc("dominant",case,ctrl,k0,initial1,initial2)

## End(Not run)

</code></pre>

<hr>
<h2 id='hwe.hardy'>Hardy-Weinberg equilibrium test using MCMC</h2><span id='topic+hwe.hardy'></span>

<h3>Description</h3>

<p>Hardy-Weinberg equilibrium test using MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwe.hardy(a, alleles = 3, seed = 3000, sample = c(1000, 1000, 5000))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hwe.hardy_+3A_a">a</code></td>
<td>
<p>an array containing the genotype counts, as integer.</p>
</td></tr>
<tr><td><code id="hwe.hardy_+3A_alleles">alleles</code></td>
<td>
<p>number of allele at the locus, greater than or equal to 3, as integer.</p>
</td></tr>
<tr><td><code id="hwe.hardy_+3A_seed">seed</code></td>
<td>
<p>pseudo-random number seed, as integer.</p>
</td></tr>
<tr><td><code id="hwe.hardy_+3A_sample">sample</code></td>
<td>
<p>optional, parameters for MCMC containing number of chunks,
size of a chunk and burn-in steps, as integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hardy-Weinberg equilibrium test by MCMC
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> method Hardy-Weinberg equilibrium test using MCMC.
</p>
</li>
<li><p> data.name name of used data if <code>x</code> is given.
</p>
</li>
<li><p> p.value Monte Carlo p value.
</p>
</li>
<li><p> p.value.se standard error of Monte Carlo p value.
</p>
</li>
<li><p> switches percentage of switches (partial, full and altogether).
</p>
</li></ul>



<h3>Note</h3>

<p>Codes are commented for taking x a genotype object, as genotype to prepare
<code>a</code> and <code>alleles</code> on the fly.
</p>
<p>Adapted from HARDY, testable with -Dexecutable as standalone program.
</p>
<p>keywords htest
</p>


<h3>Author(s)</h3>

<p>Sun-Wei Guo, Jing Hua Zhao, Gregor Gorjanc
</p>


<h3>Source</h3>

<p>https://sites.stat.washington.edu/thompson/Genepi/pangaea.shtml
</p>


<h3>References</h3>

<p>Guo SW, Thompson EA (1992).
&ldquo;Performing the exact test of Hardy-Weinberg proportion for multiple alleles.&rdquo;
<em>Biometrics</em>, <b>48</b>(2), 361-72.
ISSN 0006-341X (Print) 0006-341x.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hwe">hwe</a></code>, <code><a href="genetics.html#topic+HWE.test">genetics::HWE.test</a></code>, <code><a href="genetics.html#topic+genotype">genetics::genotype</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 # example 2 from hwe.doc:
   a&lt;-c(
   3,
   4, 2,
   2, 2, 2,
   3, 3, 2, 1,
   0, 1, 0, 0, 0,
   0, 0, 0, 0, 0, 1,
   0, 0, 1, 0, 0, 0, 0,
   0, 0, 0, 2, 1, 0, 0, 0)
   ex2 &lt;- hwe.hardy(a=a,alleles=8)

   # example using HLA
   data(hla)
   x &lt;- hla[,3:4]
   y &lt;- pgc(x,handle.miss=0,with.id=1)
   n.alleles &lt;- max(x,na.rm=TRUE)
   z &lt;- vector("numeric",n.alleles*(n.alleles+1)/2)
   z[y$idsave] &lt;- y$wt
   hwe.hardy(a=z,alleles=n.alleles)

   # with use of class 'genotype'
   # this is to be fixed
   library(genetics)
   hlagen &lt;- genotype(a1=x$DQR.a1, a2=x$DQR.a2,
                      alleles=sort(unique(c(x$DQR.a1, x$DQR.a2))))
   hwe.hardy(hlagen)

   # comparison with hwe
   hwe(z,data.type="count")

   # to create input file for HARDY
   print.tri&lt;-function (xx,n) {
       cat(n,"\n")
       for(i in 1:n) {
           for(j in 1:i) {
               cat(xx[i,j]," ")
           }
       cat("\n")
       }
       cat("100 170 1000\n")
   }
   xx&lt;-matrix(0,n.alleles,n.alleles)
   xxx&lt;-lower.tri(xx,diag=TRUE)
   xx[xxx]&lt;-z
   sink("z.dat")
   print.tri(xx,n.alleles)
   sink()
   # now call as: hwe z.dat z.out

## End(Not run)

</code></pre>

<hr>
<h2 id='hwe.jags'>Hardy-Weinberg equlibrium test for a multiallelic marker using JAGS</h2><span id='topic+hwe.jags'></span>

<h3>Description</h3>

<p>Hardy-Weinberg equlibrium test for a multiallelic marker using JAGS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwe.jags(
  k,
  n,
  delta = rep(1/k, k),
  lambda = 0,
  lambdamu = -1,
  lambdasd = 1,
  parms = c("p", "f", "q", "theta", "lambda"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hwe.jags_+3A_k">k</code></td>
<td>
<p>number of alleles.</p>
</td></tr>
<tr><td><code id="hwe.jags_+3A_n">n</code></td>
<td>
<p>a vector of k(k+1)/2 genotype counts.</p>
</td></tr>
<tr><td><code id="hwe.jags_+3A_delta">delta</code></td>
<td>
<p>initial parameter values.</p>
</td></tr>
<tr><td><code id="hwe.jags_+3A_lambda">lambda</code></td>
<td>
<p>initial parameter values.</p>
</td></tr>
<tr><td><code id="hwe.jags_+3A_lambdamu">lambdamu</code></td>
<td>
<p>initial parameter values.</p>
</td></tr>
<tr><td><code id="hwe.jags_+3A_lambdasd">lambdasd</code></td>
<td>
<p>initial parameter values.</p>
</td></tr>
<tr><td><code id="hwe.jags_+3A_parms">parms</code></td>
<td>
<p>monitored parmeters.</p>
</td></tr>
<tr><td><code id="hwe.jags_+3A_...">...</code></td>
<td>
<p>parameters passed to jags, e.g., n.chains, n.burnin, n.iter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hardy-Weinberg equilibrium test.
</p>
<p>This function performs Bayesian Hardy-Weinberg equilibrium test, which mirrors <a href="#topic+hwe.hardy">hwe.hardy</a>,
another implementation for highly polymorphic markers when asymptotic results do not hold.
</p>


<h3>Value</h3>

<p>The returned value is a fitted model from jags().
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao, Jon Wakefield
</p>


<h3>References</h3>

<p>Wakefield J (2010).
&ldquo;Bayesian methods for examining Hardy-Weinberg equilibrium.&rdquo;
<em>Biometrics</em>, <b>66</b>(1), 257-65.
ISSN 0006-341X (Print) 0006-341x, <a href="https://doi.org/10.1111/j.1541-0420.2009.01267.x">doi:10.1111/j.1541-0420.2009.01267.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hwe.hardy">hwe.hardy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ex1 &lt;- hwe.jags(4,c(5,6,1,7,11,2,8,19,26,15))
print(ex1)
ex2 &lt;- hwe.jags(2,c(49,45,6))
print(ex2)
ex3 &lt;- hwe.jags(4,c(0,3,1,5,18,1,3,7,5,2),lambda=0.5,lambdamu=-2.95,lambdasd=1.07)
print(ex3)
ex4 &lt;- hwe.jags(9,c(1236,120,3,18,0,0,982,55,7,249,32,1,0,12,0,2582,132,20,1162,29,
                    1312,6,0,0,4,0,4,0,2,0,0,0,0,0,0,0,115,5,2,53,1,149,0,0,4),
                delta=c(1,1,1,1,1,1,1,1,1),lambdamu=-4.65,lambdasd=0.21)
print(ex4)
ex5 &lt;- hwe.jags(8,n=c(
         3,
         4, 2,
         2, 2, 2,
         3, 3, 2, 1,
         0, 1, 0, 0, 0,
         0, 0, 0, 0, 0, 1,
         0, 0, 1, 0, 0, 0, 0,
         0, 0, 0, 2, 1, 0, 0, 0))
print(ex5)

# Data and code accordining to the following URL,
# http://darwin.eeb.uconn.edu/eeb348-notes/testing-hardy-weinberg.pdf
hwe.jags.ABO &lt;- function(n,...)
{
  hwe &lt;- function() {
     # likelihood
     pi[1] &lt;- p.a*p.a + 2*p.a*p.o
     pi[2] &lt;- 2*p.a*p.b
     pi[3] &lt;- p.b*p.b + 2*p.b*p.o
     pi[4] &lt;- p.o*p.o
     n[1:4] ~ dmulti(pi[],N)
     # priors
     a1 ~ dexp(1)
     b1 ~ dexp(1)
     o1 ~ dexp(1)
     p.a &lt;- a1/(a1 + b1 + o1)
     p.b &lt;- b1/(a1 + b1 + o1)
     p.o &lt;- o1/(a1 + b1 + o1)
  }
  hwd &lt;- function() {
     # likelihood
     pi[1] &lt;- p.a*p.a + f*p.a*(1-p.a) + 2*p.a*p.o*(1-f)
     pi[2] &lt;- 2*p.a*p.b*(1-f)
     pi[3] &lt;- p.b*p.b + f*p.b*(1-p.b) + 2*p.b*p.o*(1-f)
     pi[4] &lt;- p.o*p.o + f*p.o*(1-p.o)
     n[1:4] ~ dmulti(pi[],N)
     # priors
     a1 ~ dexp(1)
     b1 ~ dexp(1)
     o1 ~ dexp(1)
     p.a &lt;- a1/(a1 + b1 + o1)
     p.b &lt;- b1/(a1 + b1 + o1)
     p.o &lt;- o1/(a1 + b1 + o1)
     f ~ dunif(0,1)
  }
  N &lt;- sum(n)
  ABO.hwe &lt;- R2jags::jags(list(n=n,N=N),,c("pi","p.a","p.b","p.o"),hwe,...)
  ABO.hwd &lt;- R2jags::jags(list(n=n,N=N),,c("pi","p.a","p.b","p.o","f"),hwd,...)
  invisible(list(hwe=ABO.hwe,hwd=ABO.hwd))
}
hwe.jags.ABO.results &lt;- hwe.jags.ABO(n=c(862, 131, 365, 702))
hwe.jags.ABO.results

## End(Not run)

</code></pre>

<hr>
<h2 id='inv_chr_pos_a1_a2'>Retrieval of chr:pos+a1/a2 according to SNP id</h2><span id='topic+inv_chr_pos_a1_a2'></span>

<h3>Description</h3>

<p>This function obtains information embedded in  unique identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_chr_pos_a1_a2(chr_pos_a1_a2, prefix = "chr", seps = c(":", "_", "_"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_chr_pos_a1_a2_+3A_chr_pos_a1_a2">chr_pos_a1_a2</code></td>
<td>
<p>SNP id.</p>
</td></tr>
<tr><td><code id="inv_chr_pos_a1_a2_+3A_prefix">prefix</code></td>
<td>
<p>Prefix of the identifier.</p>
</td></tr>
<tr><td><code id="inv_chr_pos_a1_a2_+3A_seps">seps</code></td>
<td>
<p>Delimiters of fields.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the following variables:
</p>

<ul>
<li><p> chr Chromosome.
</p>
</li>
<li><p> pos Position.
</p>
</li>
<li><p> a1 Allele 1.
</p>
</li>
<li><p> a2 Allele 2.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># rs12075
inv_chr_pos_a1_a2("chr1:159175354_A_G",prefix="chr",seps=c(":","_","_"))
</code></pre>

<hr>
<h2 id='invnormal'>Inverse normal transformation</h2><span id='topic+invnormal'></span>

<h3>Description</h3>

<p>Inverse normal transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invnormal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invnormal_+3A_x">x</code></td>
<td>
<p>Data with missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transformed value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:10
z &lt;- invnormal(x)
plot(z,x,type="b")
</code></pre>

<hr>
<h2 id='ixy'>Conversion of chrosome name from strings</h2><span id='topic+ixy'></span>

<h3>Description</h3>

<p>This function converts 1:22, X, Y back to 1:24.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ixy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ixy_+3A_x">x</code></td>
<td>
<p>Chromosome name in strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>As indicated.
</p>

<hr>
<h2 id='KCC'>Disease prevalences in cases and controls</h2><span id='topic+KCC'></span>

<h3>Description</h3>

<p>Disease prevalences in cases and controls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KCC(model, GRR, p1, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KCC_+3A_model">model</code></td>
<td>
<p>disease model (one of &quot;multiplicative&quot;,&quot;additive&quot;,&quot;recessive&quot;,&quot;dominant&quot;,&quot;overdominant&quot;).</p>
</td></tr>
<tr><td><code id="KCC_+3A_grr">GRR</code></td>
<td>
<p>genotype relative risk.</p>
</td></tr>
<tr><td><code id="KCC_+3A_p1">p1</code></td>
<td>
<p>disease allele frequency.</p>
</td></tr>
<tr><td><code id="KCC_+3A_k">K</code></td>
<td>
<p>disease prevalence in the whole population.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>KCC calculates disease prevalences in cases and controls for a given genotype relative risk,
allele frequency and prevalencen of the disease in the whole population. It is used by tscc
and pbsize2.
</p>


<h3>Value</h3>

<p>A list of two elements:
</p>

<ul>
<li><p> pprime prevlence in cases.
</p>
</li>
<li><p> p prevalence in controls.
</p>
</li></ul>


<hr>
<h2 id='kin.morgan'>kinship matrix for simple pedigree</h2><span id='topic+kin.morgan'></span>

<h3>Description</h3>

<p>kinship matrix for simple pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kin.morgan(ped, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kin.morgan_+3A_ped">ped</code></td>
<td>
<p>individual's id, father's id and mother's id.</p>
</td></tr>
<tr><td><code id="kin.morgan_+3A_verbose">verbose</code></td>
<td>
<p>an option to print out the original pedigree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>kinship matrix according to Morgan v2.1.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> kin the kinship matrix in vector form.
</p>
</li>
<li><p> kin.matrix the kinship matrix.
</p>
</li></ul>



<h3>Note</h3>

<p>The input data is required to be sorted so that parents preceed their children.
</p>


<h3>Author(s)</h3>

<p>Morgan development team, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Morgan V2.1 <a href="https://sites.stat.washington.edu/thompson/Genepi/MORGAN/Morgan.shtml">https://sites.stat.washington.edu/thompson/Genepi/MORGAN/Morgan.shtml</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gif">gif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Werner syndrome pedigree
werner&lt;-c(
 1, 0,  0,  1,
 2, 0,  0,  2,
 3, 0,  0,  2,
 4, 1,  2,  1,
 5, 0,  0,  1,
 6, 1,  2,  2,
 7, 1,  2,  2,
 8, 0,  0,  1,
 9, 4,  3,  2,
10, 5,  6,  1,
11, 5,  6,  2,
12, 8,  7,  1,
13,10,  9,  2,
14,12, 11,  1,
15,14, 13,  1)
werner&lt;-t(matrix(werner,nrow=4))
kin.morgan(werner[,1:3])

## End(Not run)

</code></pre>

<hr>
<h2 id='klem'>Haplotype frequency estimation based on a genotype table of two multiallelic markers</h2><span id='topic+klem'></span>

<h3>Description</h3>

<p>Haplotype frequency estimation using expectation-maximization algorithm based on a table of genotypes of two multiallelic markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>klem(obs, k = 2, l = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="klem_+3A_obs">obs</code></td>
<td>
<p>a table of genotype counts.</p>
</td></tr>
<tr><td><code id="klem_+3A_k">k</code></td>
<td>
<p>number of alleles at marker 1.</p>
</td></tr>
<tr><td><code id="klem_+3A_l">l</code></td>
<td>
<p>number of alleles at marker 2.
</p>
<p>The dimension of the genotype table should be k*(k+1)/2 x l*(l+1)/2.
</p>
<p>Modified from 2ld.c.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> h haplotype Frequencies.
</p>
</li>
<li><p> l0 log-likelihood under linkage equilibrium.
</p>
</li>
<li><p> l1 log-likelihood under linkage disequilibrium.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genecounting">genecounting</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# an example with known genotype counts 
z &lt;- klem(obs=1:9)
# an example with imputed genotypes at SH2B1
source(file.path(find.package("gap"),"scripts","SH2B1.R"),echo=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='labelManhattan'>Annotate Manhattan or Miami Plot</h2><span id='topic+labelManhattan'></span>

<h3>Description</h3>

<p>Annotate Manhattan or Miami Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelManhattan(
  chr,
  pos,
  name,
  gwas,
  gwasChrLab = "chr",
  gwasPosLab = "pos",
  gwasPLab = "p",
  gwasZLab = "NULL",
  chrmaxpos,
  textPos = 4,
  angle = 0,
  miamiBottom = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labelManhattan_+3A_chr">chr</code></td>
<td>
<p>A vector of chromosomes for the markers to be labelled.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_pos">pos</code></td>
<td>
<p>A vector of positions on the chromosome for the markers to be labelled. These must correspond to markers in the GWAS dataset used to make the manhattan plot.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_name">name</code></td>
<td>
<p>A vector of labels to be added next to the points specified by <span class="env">chr</span> and <span class="env">pos</span>.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_gwas">gwas</code></td>
<td>
<p>The same GWAS dataset used to plot the existing Manhattan or Miami plot to be annotated.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_gwaschrlab">gwasChrLab</code></td>
<td>
<p>The name of the column in <span class="env">gwas</span> containing chromosome number. Defaults to &lsquo;<span class="samp">&#8288;"chr"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_gwasposlab">gwasPosLab</code></td>
<td>
<p>The name of the column in <span class="env">gwas</span> containing position. Defaults to &lsquo;<span class="samp">&#8288;"pos"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_gwasplab">gwasPLab</code></td>
<td>
<p>The name of the column in <span class="env">gwas</span> containing p-values. Defaults to &lsquo;<span class="samp">&#8288;"p"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_gwaszlab">gwasZLab</code></td>
<td>
<p>The name of the column in <span class="env">gwas</span> containing z-values. Defaults to &lsquo;<span class="samp">&#8288;"NULL"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_chrmaxpos">chrmaxpos</code></td>
<td>
<p>Data frame containing x coordinates for chromosome start positions, generated by <code><a href="#topic+labelManhattan">labelManhattan</a></code>.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_textpos">textPos</code></td>
<td>
<p>An integer or vector dictating where the label should be plotted relative to each point. Good for avoiding overlapping labels. Provide an integer to plot all points in the same relative position or use a vector to specify position for each label. Passed to the <span class="option">pos</span> option of <code><a href="graphics.html#topic+text">graphics::text</a></code>. Defaults to &lsquo;<span class="samp">&#8288;4&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_angle">angle</code></td>
<td>
<p>An integer or vector dictating the plot angle of the label for each point. rovide an integer to plot all points in the same relative position or use a vector to specify position for each label.Passed to the <span class="option">srt</span> option of <code><a href="graphics.html#topic+text">graphics::text</a></code>. Defaults to &lsquo;<span class="samp">&#8288;0&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="labelManhattan_+3A_miamibottom">miamiBottom</code></td>
<td>
<p>If &lsquo;<span class="samp">&#8288;TRUE&#8288;</span>&rsquo;, labels will be plotted on the lower region of a Miami plot. If &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;, labels will be plotted on the upper region. Defaults to &lsquo;<span class="samp">&#8288;FALSE&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Add labels beside specified points on a Manhattan or Miami plot. Ideal for adding locus names to peaks. Currently only designed to work with <code><a href="#topic+miamiplot2">miamiplot2</a></code>.
</p>


<h3>Value</h3>

<p>Adds annotation to existing Manhattan or Miami plot
</p>


<h3>Note</h3>

<p>Extended to handle extreme P values.
</p>


<h3>Author(s)</h3>

<p>Jonathan Marten
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
labelManhattan(c(4,5,11,19),c(9994215,16717922,45538760,51699256),
               c("GENE1","GENE2","GENE3","GENE4"),
               gwas1,chrmaxpos=chrmaxpos)
labelManhattan(geneLabels$chr,geneLabel$pos,geneLabel$geneName,gwas1,chrmaxpos=chrmaxpos)

## End(Not run)
</code></pre>

<hr>
<h2 id='LD22'>LD statistics for two diallelic markers</h2><span id='topic+LD22'></span>

<h3>Description</h3>

<p>LD statistics for two diallelic markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LD22(h, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD22_+3A_h">h</code></td>
<td>
<p>a vector of haplotype frequencies.</p>
</td></tr>
<tr><td><code id="LD22_+3A_n">n</code></td>
<td>
<p>number of haplotypes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to perform permutation test of <code class="reqn">r^2</code> by re-ordering the genotype through
R's sample function, obtaining the haplotype frequencies by <code><a href="#topic+gc.em">gc.em</a></code>
or <code><a href="#topic+genecounting">genecounting</a></code>, supplying the estimated haplotype frequencies to
the current function and record x2, and comparing the observed x2 and that from the
replicates.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> h the original haplotype frequency vector.
</p>
</li>
<li><p> n the number of haplotypes.
</p>
</li>
<li><p> D the linkage disequilibrium parameter.
</p>
</li>
<li><p> VarD the variance of D.
</p>
</li>
<li><p> Dmax the maximum of D.
</p>
</li>
<li><p> VarDmax the variance of Dmax.
</p>
</li>
<li><p> Dprime the scaled disequilibrium parameter.
</p>
</li>
<li><p> VarDprime the variance of Dprime.
</p>
</li>
<li><p> x2 the Chi-squared statistic.
</p>
</li>
<li><p> lor the log(OR) statistic.
</p>
</li>
<li><p> vlor the var(log(OR)) statistic.
</p>
</li></ul>



<h3>Note</h3>

<p>extracted from 2ld.c, worked 28/6/03, tables are symmetric do not fix, see kbyl below
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Zabetian CP, Buxbaum SG, Elston RC, Köhnke MD, Anderson GM, Gelernter J, Cubells JF (2003).
&ldquo;The structure of linkage disequilibrium at the DBH locus strongly influences the magnitude of association between diallelic markers and plasma dopamine beta-hydroxylase activity.&rdquo;
<em>Am J Hum Genet</em>, <b>72</b>(6), 1389-400.
ISSN 0002-9297 (Print) 0002-9297, <a href="https://doi.org/10.1086/375499">doi:10.1086/375499</a>.
</p>
<p>Zapata C, Alvarez G, Carollo C (1997).
&ldquo;Approximate variance of the standardized measure of gametic disequilibrium D'.&rdquo;
<em>Am J Hum Genet</em>, <b>61</b>(3), 771-4.
ISSN 0002-9297 (Print) 0002-9297, <a href="https://doi.org/10.1016/s0002-9297%2807%2964342-0">doi:10.1016/s0002-9297(07)64342-0</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LDkl">LDkl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
h &lt;- c(0.442356,0.291532,0.245794,0.020319)
n &lt;- 481*2
t &lt;- LD22(h,n)

## End(Not run)

</code></pre>

<hr>
<h2 id='LDkl'>LD statistics for two multiallelic markers</h2><span id='topic+LDkl'></span>

<h3>Description</h3>

<p>LD statistics for two multiallelic loci. For two diallelic makers,
the familiar <code class="reqn">r^2</code> has standard error seX2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDkl(n1 = 2, n2 = 2, h, n, optrho = 2, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDkl_+3A_n1">n1</code></td>
<td>
<p>number of alleles at marker 1.</p>
</td></tr>
<tr><td><code id="LDkl_+3A_n2">n2</code></td>
<td>
<p>number of alleles at marker 2.</p>
</td></tr>
<tr><td><code id="LDkl_+3A_h">h</code></td>
<td>
<p>a vector of haplotype frequencies.</p>
</td></tr>
<tr><td><code id="LDkl_+3A_n">n</code></td>
<td>
<p>number of haplotypes.</p>
</td></tr>
<tr><td><code id="LDkl_+3A_optrho">optrho</code></td>
<td>
<p>type of contingency table association, 0=Pearson, 1=Tschuprow, 2=Cramer (default).</p>
</td></tr>
<tr><td><code id="LDkl_+3A_verbose">verbose</code></td>
<td>
<p>detailed output of individual statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> n1 the number of alleles at marker 1.
</p>
</li>
<li><p> n2 the number of alleles at marker 2.
</p>
</li>
<li><p> h the haplotype frequency vector.
</p>
</li>
<li><p> n the number of haplotypes.
</p>
</li>
<li><p> Dp D'.
</p>
</li>
<li><p> VarDp variance of D'.
</p>
</li>
<li><p> Dijtable table of Dij.
</p>
</li>
<li><p> VarDijtable table of variances for Dij.
</p>
</li>
<li><p> Dmaxtable table of Dmax.
</p>
</li>
<li><p> Dijptable table of Dij'.
</p>
</li>
<li><p> VarDijptable table of variances for Dij'.
</p>
</li>
<li><p> X2table table of Chi-squares (based on Dij).
</p>
</li>
<li><p> ptable table of p values.
</p>
</li>
<li><p> x2 the Chi-squared statistic.
</p>
</li>
<li><p> seX2 the standard error of x2/n.
</p>
</li>
<li><p> rho the measure of association.
</p>
</li>
<li><p> seR the standard error of rho.
</p>
</li>
<li><p> optrho the method for calculating rho.
</p>
</li>
<li><p> klinfo the Kullback-Leibler information.
</p>
</li></ul>



<h3>Note</h3>

<p>adapted from 2ld.c.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Bishop YMM, Fienberg SE, Holland PW (1975).
<em>Discrete multivariate analysis: theory and practice</em>.
MIT Press, Cambridge, Mass.
ISBN 9780262021135.
</p>
<p>Cramer H (1946).
<em>Mathematical Methods of Statistics</em>.
Princeton Univ. Press.
</p>
<p>Zapata C, Carollo C, Rodriguez S (2001).
&ldquo;Sampling variance and distribution of the D' measure of overall gametic disequilibrium between multiallelic loci.&rdquo;
<em>Ann Hum Genet</em>, <b>65</b>(Pt 4), 395-406.
ISSN 0003-4800 (Print) 0003-4800, <a href="https://doi.org/10.1017/s0003480001008697">doi:10.1017/s0003480001008697</a>.
</p>
<p>Zhao JH (2004).
&ldquo;2LD. GENECOUNTING and HAP: computer programs for linkage disequilibrium analysis.&rdquo;
<em>Bioinformatics</em>, <b>20</b>(8), 1325-6.
ISSN 1367-4803 (Print) 1367-4803, <a href="https://doi.org/10.1093/bioinformatics/bth071">doi:10.1093/bioinformatics/bth071</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LD22">LD22</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# two examples in the C program 2LD:
# two SNPs as in 2by2.dat
# this can be compared with output from LD22

h &lt;- c(0.442356,0.291532,0.245794,0.020319)
n &lt;- 481*2
t &lt;- LDkl(2,2,h,n)
t

# two multiallelic markers as in kbyl.dat
# the two-locus haplotype vector is in file "kbyl.dat"
# The data is now available from 2ld in Haplotype-Analysis

filespec &lt;- system.file("kbyl.dat")
h &lt;- scan(filespec,skip=1)
t &lt;- LDkl(9,5,h,213*2,verbose=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='log10p'>log10(p) for a normal deviate z</h2><span id='topic+log10p'></span>

<h3>Description</h3>

<p>log10(p) for a normal deviate z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log10p(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log10p_+3A_z">z</code></td>
<td>
<p>normal deviate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>log10(P)</code>
</p>


<h3>Author(s)</h3>

<p>James Peters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log10p(100)
</code></pre>

<hr>
<h2 id='log10pvalue'>log10(p) for a P value including its scientific format</h2><span id='topic+log10pvalue'></span>

<h3>Description</h3>

<p>log10(p) for a P value including its scientific format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log10pvalue(p = NULL, base = NULL, exponent = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log10pvalue_+3A_p">p</code></td>
<td>
<p>value.</p>
</td></tr>
<tr><td><code id="log10pvalue_+3A_base">base</code></td>
<td>
<p>base part in scientific format.</p>
</td></tr>
<tr><td><code id="log10pvalue_+3A_exponent">exponent</code></td>
<td>
<p>exponent part in scientific format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>log10(P)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>log10pvalue(1e-323)
log10pvalue(base=1,exponent=-323)
</code></pre>

<hr>
<h2 id='logp'>log(p) for a normal deviate z</h2><span id='topic+logp'></span>

<h3>Description</h3>

<p>log(p) for a normal deviate z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logp(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logp_+3A_z">z</code></td>
<td>
<p>normal deviate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>log(P)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logp(100)
</code></pre>

<hr>
<h2 id='makeped'>A function to prepare pedigrees in post-MAKEPED format</h2><span id='topic+makeped'></span>

<h3>Description</h3>

<p>A function to prepare pedigrees in post-MAKEPED format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeped(
  pifile = "pedfile.pre",
  pofile = "pedfile.ped",
  auto.select = 1,
  with.loop = 0,
  loop.file = NA,
  auto.proband = 1,
  proband.file = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeped_+3A_pifile">pifile</code></td>
<td>
<p>input filename.</p>
</td></tr>
<tr><td><code id="makeped_+3A_pofile">pofile</code></td>
<td>
<p>output filename.</p>
</td></tr>
<tr><td><code id="makeped_+3A_auto.select">auto.select</code></td>
<td>
<p>no loops in pedigrees and probands are selected automatically? 0=no, 1=yes.</p>
</td></tr>
<tr><td><code id="makeped_+3A_with.loop">with.loop</code></td>
<td>
<p>input data with loops? 0=no, 1=yes.</p>
</td></tr>
<tr><td><code id="makeped_+3A_loop.file">loop.file</code></td>
<td>
<p>filename containing pedigree id and an individual id for each loop, set if with.loop=1.</p>
</td></tr>
<tr><td><code id="makeped_+3A_auto.proband">auto.proband</code></td>
<td>
<p>probands are selected automatically? 0=no, 1=yes.</p>
</td></tr>
<tr><td><code id="makeped_+3A_proband.file">proband.file</code></td>
<td>
<p>filename containing pedigree id and proband id, set if auto.proband=0 (not implemented).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many computer programs for genetic data analysis requires pedigree data to be in the so-called
&ldquo;post-MAKEPED&rdquo; format. This function performs this translation and allows for some
inconsistences to be detected.
</p>
<p>The first four columns of the input file contains the following information:
</p>
<p>pedigree ID, individual ID, father's ID, mother's ID, sex
</p>
<p>Either father's or mother's id is set to 0 for founders, i.e. individuals with no parents.
Numeric coding for sex is 0=unknown, 1=male, 2=female. These can be followed by satellite
information such as disease phenotype and marker information.
</p>
<p>The output file has extra information extracted from data above.
</p>
<p>Before invoking makeped, input file, loop file and proband file have to be prepared.
</p>
<p>By default, auto.select=1, so translation proceeds without considering loops and proband statuses.
If there are loops in the pedigrees, then set auto.select=0, with.loop=1, loop.file=&quot;filespec&quot;.
</p>
<p>There may be several versions of makeped available, but their differences with this port should
be minor.
</p>


<h3>Note</h3>

<p>adapted from makeped.c by W Li and others.
keywords datagen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cwd &lt;- getwd()
cs.dir &lt;- file.path(find.package("gap.examples"),"tests","kinship")
setwd(cs.dir)
dir()
makeped("ped7.pre","ped7.ped",0,1,"ped7.lop")
setwd(cwd)
# https://lab.rockefeller.edu/ott/

## End(Not run)

</code></pre>

<hr>
<h2 id='masize'>Sample size calculation for mediation analysis</h2><span id='topic+masize'></span>

<h3>Description</h3>

<p>The function computes sample size for regression problems where the goal is to assess mediation of the effects of a
primary predictor by an intermediate variable or mediator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>masize(model, opts, alpha = 0.025, gamma = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="masize_+3A_model">model</code></td>
<td>
<p>&quot;lineari&quot;, &quot;logisticj&quot;, &quot;poissonk&quot;, &quot;coxl&quot;, where i,j,k,l range from 1 to 4,5,9,9, respectively.</p>
</td></tr>
<tr><td><code id="masize_+3A_opts">opts</code></td>
<td>
<p>A list specific to the model
</p>

<table>
<tr>
 <td style="text-align: left;">
b1 </td><td style="text-align: left;"> regression coefficient for the primary predictor X1</td>
</tr>
<tr>
 <td style="text-align: left;">
b2 </td><td style="text-align: left;"> regression coefficient for the mediator X2</td>
</tr>
<tr>
 <td style="text-align: left;">
rho </td><td style="text-align: left;"> correlation between X1 and X2</td>
</tr>
<tr>
 <td style="text-align: left;">
sdx1, sdx2 </td><td style="text-align: left;"> standard deviations (SDs) of X1 and X2</td>
</tr>
<tr>
 <td style="text-align: left;">
f1, f2 </td><td style="text-align: left;"> prevalence of binary X1 and X2</td>
</tr>
<tr>
 <td style="text-align: left;">
sdy </td><td style="text-align: left;"> residual SD of the outcome for the linear model</td>
</tr>
<tr>
 <td style="text-align: left;">
p </td><td style="text-align: left;"> marginal prevalence of the binary outcome in the logistic model</td>
</tr>
<tr>
 <td style="text-align: left;">
m </td><td style="text-align: left;"> marginal mean of the count outcome in a Poisson model</td>
</tr>
<tr>
 <td style="text-align: left;">
f </td><td style="text-align: left;"> proportion of uncensored observations for the Cox model</td>
</tr>
<tr>
 <td style="text-align: left;">
fc </td><td style="text-align: left;"> proportion of observations censored early</td>
</tr>
<tr>
 <td style="text-align: left;">
alpha </td><td style="text-align: left;"> one-sided type-I error rate</td>
</tr>
<tr>
 <td style="text-align: left;">
gamma </td><td style="text-align: left;"> type-II error rate</td>
</tr>
<tr>
 <td style="text-align: left;">
ns </td><td style="text-align: left;"> number of observations to be simulated</td>
</tr>
<tr>
 <td style="text-align: left;">
seed </td><td style="text-align: left;"> random number seed
</td>
</tr>

</table>

<p>For linear model, the arguments are b2, rho, sdx2, sdy, alpha, and gamma. For cases CpBm and BpBm, set sdx2 =
<code class="reqn">\sqrt{f2(1-f2)}</code>. Three alternative functions are included for the linear model. These functions
make it possible to supply other combinations of input parameters affecting mediation:
</p>

<table>
<tr>
 <td style="text-align: left;">
b1* </td><td style="text-align: left;"> coefficient for the primary predictor </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> in the reduced model excluding the mediator (b1star)</td>
</tr>
<tr>
 <td style="text-align: left;">
b1  </td><td style="text-align: left;"> coefficient for the primary predictor </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> in the full model including the mediator </td>
</tr>
<tr>
 <td style="text-align: left;">
PTE </td><td style="text-align: left;"> proportion of the effect of the primary predictor </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> explained by the mediator, defined as (b1*-b1)/b1*</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>These alternative functions for the linear model require specification of an extra parameter, but are provided for
convenience, along with two utility files for computing PTE and b1* from the other parameters. The required arguments
are explained in comments within the R code.</p>
</td></tr>
<tr><td><code id="masize_+3A_alpha">alpha</code></td>
<td>
<p>Type-I error rate, one-sided.</p>
</td></tr>
<tr><td><code id="masize_+3A_gamma">gamma</code></td>
<td>
<p>Type-II error rate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mediation has been thought of in terms of the proportion of effect explained, or the relative attenuation of b1, the
coefficient for the primary predictor X1, when the mediator, X2, is added to the model. The goal is to show that b1*,
the coefficient for X1 in the reduced model (i.e., the model with only X1, differs from b1, its coefficient in the full
model (i.e., the model with both X1 and the mediator X2. If X1 and X2 are correlated, then showing that b2, the
coefficient for X2, differs from zero is equivalent to showing b1* differs from b1. Thus the problem reduces to
detecting an effect of X2, controlling for X1. In short, it amounts to the more familiar problem of inflating sample
size to account for loss of precision due to adjustment for X1.
</p>
<p>The approach here is to approximate the expected information matrix from the regression model including both X1 and X2,
to obtain the expected standard error of the estimate of b2, evaluated at the MLE. The sample size follows from
comparing the Wald test statistic (i.e., the ratio of the estimate of b2 to its SE) to the standard normal distribution,
with the expected value of the numerator and denominator of the statistic computed under the alternative hypothesis.
This reflects the Wald test for the statistical significance of a coefficient implemented in most regression packages.
</p>
<p>The function provides methods to calculate sample sizes for the mediation problem for linear, logistic, Poisson, and Cox
regression models in four cases for each model:
</p>

<table>
<tr>
 <td style="text-align: left;">
CpCm </td><td style="text-align: left;"> continuous primary predictor, continuous mediator</td>
</tr>
<tr>
 <td style="text-align: left;">
BpCm </td><td style="text-align: left;"> binary primary predictor, continuous mediator</td>
</tr>
<tr>
 <td style="text-align: left;">
CpBm </td><td style="text-align: left;"> continuous primary predictor, binary mediator</td>
</tr>
<tr>
 <td style="text-align: left;">
BpBm </td><td style="text-align: left;"> binary primary predictor, binary mediator
</td>
</tr>

</table>

<p>The function is also generally applicable to the analogous problem of calculating sample size adequate to detect the
effect of a primary predictor in the presence of confounding. Simply treat X2 as the primary predictor and consider X1
the confounder.
</p>
<p>For linear model, a single function, linear, implements the analytic solution for all four cases, based on Hsieh et al.,
is to inflate sample size by a variance inflation factor, <code class="reqn">1/(1-rho^2)</code>, where rho is the correlation of X1 and X2.
This also turns out to be the analytic solution in cases CpCm and BpCm for the Poisson model, and underlies approximate
solutions for the logistic and Cox models. An analytic solution is also given for cases CpBm and BpBm for the Poisson
model. Since analytic solutions are not available for the logistic and Cox models, a simulation approach is used to
obtain the expected information matrix instead.
</p>
<p>For logistic model, the approximate solution due to Hsieh is implemented in the function logistic.approx, and can be
used for all four cases. Arguments are p, b2, rho, sdx2, alpha, and gamma. For a binary mediator with prevalence f2,
sdx2 should be reset to <code class="reqn">\sqrt{f2(1-f2)}</code>. Simulating the information matrix of the logistic model
provides somewhat more accurate sample size estimates than the Hsieh approximation. The functions for cases CpCm, BpCm,
CpBm, and BpBm are respectively logistic.ccs, logistic.bcs, logistic.cbs, and logistic.bbs, as for the Poisson and Cox
models. Arguments for these functions include p, b1, sdx1 or f1, b2, sdx2 or f2, rho, alpha, gamma, and ns. As in other
functions, sdx1, sdx2, alpha, and gamma are set to the defaults listed above. These four functions call two utility
functions, getb0 (to calculate the intercept parameter from the others) and antilogit, which are supplied.
</p>
<p>For Poisson model, The function implementing the approximate solution based on the variance inflation factor is
poisson.approx, and can be used for all four cases. Arguments are EY (the marginal mean of the Poisson outcome), b2,
sdx2, rho, alpha and gamma, with sdx2, alpha and gamma set to the usual defaults; use
sdx2=<code class="reqn">\sqrt{f2(1-f2)}</code> for a binary mediator with prevalence f2 (cases CpBm and BpBm). For cases
CpCm and BpCm (continuous mediators), the approximate formula is also the analytic solution. For these cases, we supply
redundant functions poisson.cc and poisson.bc, with the same arguments and defaults as for poisson.approx (it's the same
function). For the two cases with binary mediators, the functions are poisson.cb and poisson.bb. In addition to m, b2,
f2, rho, alpha, and gamma, b1 and sdx1 or f1 must be specified. Defaults are as usual. Functions using simulation for
the Poisson model are available: poisson.ccs, poisson.bcs, poisson.cbs, and poisson.bbs. As in the logistic case, these
require arguments b1 and sdx1 or f1. For this case, however, the analytic functions are faster, avoid simulation error,
and should be used. We include these functions as templates that could be adapted to other joint predictor
distributions.
For Cox model, the function implementing the approximate solution, using the variance inflation factor and derived by
Schmoor et al., is cox.approx, and can be used for all four cases. Arguments are b2, sdx2, rho, alpha, gamma, and f. For
binary X2 set sdx2 = <code class="reqn">\sqrt{f2(1-f2)}</code>. The approximation works very well for cases CpCm and BpCm
(continuous mediators), but is a bit less accurate for cases CpBm and BpBm (binary mediators). We get some improvement
for those cases using the simulation approach. This approach is implemented for all four, as functions cox.ccs, cox.bcs,
cox.cbs, and cox.bbs. Arguments are b1, sdx1 or f1, b2, sdx2 or f2, rho, alpha, gamma, f, and ns, with defaults as
described above. Slight variants of these functions, cox.ccs2, cox.bcs2, cox.cbs2, and cox.bbs2, make it possible to
allow for early censoring of a fraction fc of observations; but in our experience this has virtually no effect, even
with values of fc of 0.5. The default for fc is 0.
</p>
<p>A summary of the argumentss is as follows, noting that additional parameter seed can be supplied for simulation-based
method.
</p>

<table>
<tr>
 <td style="text-align: left;">
model </td><td style="text-align: left;"> arguments </td><td style="text-align: left;"> description</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
linear1 </td><td style="text-align: left;"> b2, rho, sdx2, sdy </td><td style="text-align: left;"> linear </td>
</tr>
<tr>
 <td style="text-align: left;">
linear2 </td><td style="text-align: left;"> b1star, PTE, rho, sdx1, sdy </td><td style="text-align: left;"> lineara</td>
</tr>
<tr>
 <td style="text-align: left;">
linear3 </td><td style="text-align: left;"> b1star, b2, PTE, sdx1, sdx2, sdy </td><td style="text-align: left;"> linearb</td>
</tr>
<tr>
 <td style="text-align: left;">
linear4 </td><td style="text-align: left;"> b1star, b1, b2, sdx1, sdx2, sdy </td><td style="text-align: left;"> linearc</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
logistic1 </td><td style="text-align: left;"> p, b2, rho, sdx2 </td><td style="text-align: left;"> logistic.approx</td>
</tr>
<tr>
 <td style="text-align: left;">
logistic2 </td><td style="text-align: left;"> p, b1, b2, rho, sdx1, sdx2, ns </td><td style="text-align: left;"> logistic.ccs</td>
</tr>
<tr>
 <td style="text-align: left;">
logistic3 </td><td style="text-align: left;"> p, b1, f1, b2, rho, sdx2, ns </td><td style="text-align: left;"> logistic.bcs</td>
</tr>
<tr>
 <td style="text-align: left;">
logistic4 </td><td style="text-align: left;"> p, b1, b2, f2, rho, sdx1, ns </td><td style="text-align: left;"> logistic.cbs</td>
</tr>
<tr>
 <td style="text-align: left;">
logistic5 </td><td style="text-align: left;"> p, b1, f1, b2, f2, rho, ns </td><td style="text-align: left;"> logistic.bbs</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
poisson1 </td><td style="text-align: left;"> m, b2, rho, sdx2 </td><td style="text-align: left;"> poisson.approx</td>
</tr>
<tr>
 <td style="text-align: left;">
poisson2 </td><td style="text-align: left;"> m, b2, rho, sdx2 </td><td style="text-align: left;"> poisson.cc</td>
</tr>
<tr>
 <td style="text-align: left;">
poisson3 </td><td style="text-align: left;"> m, b2, rho, sdx2 </td><td style="text-align: left;"> poisson.bc</td>
</tr>
<tr>
 <td style="text-align: left;">
poisson4 </td><td style="text-align: left;"> m, b1, b2, f2, rho, sdx1 </td><td style="text-align: left;"> poisson.cb</td>
</tr>
<tr>
 <td style="text-align: left;">
poisson5 </td><td style="text-align: left;"> m, b1, f1, b2, f2, rho </td><td style="text-align: left;"> poisson.bb</td>
</tr>
<tr>
 <td style="text-align: left;">
poisson6 </td><td style="text-align: left;"> m, b1, b2, rho, sdx1, sdx2, ns </td><td style="text-align: left;"> poisson.ccs</td>
</tr>
<tr>
 <td style="text-align: left;">
poisson7 </td><td style="text-align: left;"> m, b1, f1, b2, rho, sdx2, ns </td><td style="text-align: left;"> poisson.bcs</td>
</tr>
<tr>
 <td style="text-align: left;">
poisson8 </td><td style="text-align: left;"> m, b1, b2, f2, rho, sdx1, ns </td><td style="text-align: left;"> poisson.cbs</td>
</tr>
<tr>
 <td style="text-align: left;">
poisson9 </td><td style="text-align: left;"> m, b1, f1, b2, f2, rho, ns</td><td style="text-align: left;"> poisson.bbs</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
cox1 </td><td style="text-align: left;"> b2, rho, f, sdx2 </td><td style="text-align: left;"> cox.approx</td>
</tr>
<tr>
 <td style="text-align: left;">
cox2 </td><td style="text-align: left;"> b1, b2, rho, f, sdx1, sdx2, ns </td><td style="text-align: left;"> cox.ccs</td>
</tr>
<tr>
 <td style="text-align: left;">
cox3 </td><td style="text-align: left;"> b1, f1, b2, rho, f, sdx2, ns</td><td style="text-align: left;"> cox.bcs</td>
</tr>
<tr>
 <td style="text-align: left;">
cox4 </td><td style="text-align: left;"> b1, b2, f2, rho, f, sdx1, ns</td><td style="text-align: left;"> cox.cbs</td>
</tr>
<tr>
 <td style="text-align: left;">
cox5 </td><td style="text-align: left;"> b1, f1, b2, f2, rho, f, ns</td><td style="text-align: left;"> cox.bbs</td>
</tr>
<tr>
 <td style="text-align: left;">
cox6 </td><td style="text-align: left;"> b1, b2, rho, f, fc, sdx1, sdx2, ns</td><td style="text-align: left;"> cox.ccs2</td>
</tr>
<tr>
 <td style="text-align: left;">
cox7 </td><td style="text-align: left;"> b1, f1, b2, rho, f, fc, sdx2, ns</td><td style="text-align: left;"> cox.bcs2</td>
</tr>
<tr>
 <td style="text-align: left;">
cox8 </td><td style="text-align: left;"> b1, b2, f2, rho, f, fc, sdx1, ns</td><td style="text-align: left;"> cox.cbs2</td>
</tr>
<tr>
 <td style="text-align: left;">
cox9 </td><td style="text-align: left;"> b1, f1, b2, f2, rho, f, fc, ns</td><td style="text-align: left;"> cox.bbs2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A short description of model (desc, b=binary, c=continuous, s=simulation) and sample size (n). In the case of Cox model,
number of events (d) is also indicated.
</p>


<h3>References</h3>

<p>Hsieh FY, Bloch DA, Larsen MD (1998).
&ldquo;A simple method of sample size calculation for linear and logistic regression.&rdquo;
<em>Stat Med</em>, <b>17</b>(14), 1623-34.
ISSN 0277-6715 (Print) 0277-6715, <a href="https://doi.org/10.1002/%28sici%291097-0258%2819980730%2917%3A14%3C1623%3A%3Aaid-sim871%3E3.0.co%3B2-s">doi:10.1002/(sici)1097-0258(19980730)17:14&lt;1623::aid-sim871&gt;3.0.co;2-s</a>.
</p>
<p>Schmoor C, Sauerbrei W, Schumacher M (2000).
&ldquo;Sample size considerations for the evaluation of prognostic factors in survival analysis.&rdquo;
<em>Stat Med</em>, <b>19</b>(4), 441-52.
ISSN 0277-6715 (Print) 0277-6715, <a href="https://doi.org/10.1002/%28sici%291097-0258%2820000229%2919%3A4%3C441%3A%3Aaid-sim349%3E3.0.co%3B2-n">doi:10.1002/(sici)1097-0258(20000229)19:4&lt;441::aid-sim349&gt;3.0.co;2-n</a>.
</p>
<p>Vittinghoff E, Sen S, McCulloch CE (2009).
&ldquo;Sample size calculations for evaluating mediation.&rdquo;
<em>Stat Med</em>, <b>28</b>(4), 541-57.
ISSN 0277-6715 (Print) 0277-6715, <a href="https://doi.org/10.1002/sim.3491">doi:10.1002/sim.3491</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ab">ab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## linear model
# CpCm
opts &lt;- list(b2=0.5, rho=0.3, sdx2=1, sdy=1)
masize("linear1",opts)
# BpBm
opts &lt;- list(b2=0.75, rho=0.3, f2=0.25, sdx2=sqrt(0.25*0.75), sdy=3)
masize("linear1",opts,gamma=0.1)

## logistic model
# CpBm
opts &lt;- list(p=0.25, b2=log(0.5), rho=0.5, sdx2=0.5)
masize("logistic1",opts)
opts &lt;- list(p=0.25, b1=log(1.5), sdx1=1, b2=log(0.5), f2=0.5, rho=0.5, ns=10000,
             seed=1234)
masize("logistic4",opts)
opts &lt;- list(p=0.25, b1=log(1.5), sdx1=1, b2=log(0.5), f2=0.5, rho=0.5, ns=10000,
             seed=1234)
masize("logistic4",opts)
opts &lt;- list(p=0.25, b1=log(1.5), sdx1=4.5, b2=log(0.5), f2=0.5, rho=0.5, ns=50000,
             seed=1234)
masize("logistic4",opts)

## Poisson model
# BpBm
opts &lt;- list(m=0.5, b2=log(1.25), rho=0.3, sdx2=sqrt(0.25*0.75))
masize("poisson1",opts)
opts &lt;- list(m=0.5, b1=log(1.4), f1=0.25, b2=log(1.25), f2=0.25, rho=0.3)
masize("poisson5",opts)
opts &lt;- c(opts,ns=10000, seed=1234)
masize("poisson9",opts)

## Cox model
# BpBm
opts &lt;- list(b2=log(1.5), rho=0.45, f=0.2, sdx2=sqrt(0.25*0.75))
masize("cox1",opts)
opts &lt;- list(b1=log(2), f1=0.5, b2=log(1.5), f2=0.25, rho=0.45, f=0.2, seed=1234)
masize("cox5",c(opts, ns=10000))
masize("cox5",c(opts, ns=50000))

## End(Not run)

</code></pre>

<hr>
<h2 id='MCMCgrm'>Mixed modeling with genetic relationship matrices</h2><span id='topic+MCMCgrm'></span>

<h3>Description</h3>

<p>Mixed modeling with genetic relationship matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCgrm(
  model,
  prior,
  data,
  GRM,
  eps = 0,
  n.thin = 10,
  n.burnin = 3000,
  n.iter = 13000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCgrm_+3A_model">model</code></td>
<td>
<p>statistical model.</p>
</td></tr>
<tr><td><code id="MCMCgrm_+3A_prior">prior</code></td>
<td>
<p>a list of priors for parameters in the model above.</p>
</td></tr>
<tr><td><code id="MCMCgrm_+3A_data">data</code></td>
<td>
<p>a data.frame containing outcome and covariates.</p>
</td></tr>
<tr><td><code id="MCMCgrm_+3A_grm">GRM</code></td>
<td>
<p>a relationship matrix.</p>
</td></tr>
<tr><td><code id="MCMCgrm_+3A_eps">eps</code></td>
<td>
<p>a small number added to the diagonal of the a nonpositive definite GRM.</p>
</td></tr>
<tr><td><code id="MCMCgrm_+3A_n.thin">n.thin</code></td>
<td>
<p>thinning parameter in the MCMC.</p>
</td></tr>
<tr><td><code id="MCMCgrm_+3A_n.burnin">n.burnin</code></td>
<td>
<p>the number of burn-in's.</p>
</td></tr>
<tr><td><code id="MCMCgrm_+3A_n.iter">n.iter</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code id="MCMCgrm_+3A_...">...</code></td>
<td>
<p>other options as appropriate for MCMCglmm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixed modeling with genomic relationship matrix. This is appropriate with relationship
matrix derived from family structures or unrelated individuals based on whole genome data.
</p>
<p>The function was created to address a number of issues involving mixed modelling with
family data or population sample with whole genome data. First, the implementaiton
will shed light on the uncertainty involved with polygenic effect in that posterior
distributions can be obtained. Second, while the model can be used with the MCMCglmm
package there is often issues with the specification of pedigree structures but this
is less of a problem with genetic relationship matrices. We can use established
algorithms to generate kinship or genomic relationship matrix as input to the MCMCglmm
function. Third, it is more intuitive to specify function arguments in line with other
packages such as R2OpenBUGS, R2jags or glmmBUGS. In addition, our experiences of tuning
the model would help to reset the input and default values.
</p>


<h3>Value</h3>

<p>The returned value is an object as generated by MCMCglmm.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Hadfield JD (2010).
&ldquo;MCMC Methods for Multi-Response Generalized Linear Mixed Models: The MCMCglmm R Package.&rdquo;
<em>Journal of Statistical Software</em>, <b>33</b>(2), 1 - 22.
<a href="https://doi.org/10.18637/jss.v033.i02">doi:10.18637/jss.v033.i02</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### with kinship

# library(kinship) 
# fam &lt;- with(l51,makefamid(id,fid,mid))
# s &lt;-with(l51, makekinship(fam, id, fid, mid))
# K &lt;- as.matrix(s)*2   

### with gap

s &lt;- kin.morgan(l51)
K &lt;- with(s,kin.matrix*2)
prior &lt;- list(R=list(V=1, nu=0.002), G=list(G1=list(V=1, nu=0.002)))
m &lt;- MCMCgrm(qt~1,prior,l51,K)
save(m,file="l51.m")
pdf("l51.pdf")
plot(m)
dev.off()

# A real analysis on bats
## data
bianfu.GRM &lt;- read.table("bianfu.GRM.txt", header = TRUE)
bianfu.GRM[1:5,1:6]
Data &lt;- read.table(file = "PHONE.txt", header = TRUE, 
                   colClasses=c(rep("factor",3),rep("numeric",7)))
## MCMCgrm
library("MCMCglmm")
GRM &lt;- as.matrix(bianfu.GRM[,-1])
colnames(GRM) &lt;- rownames(GRM) &lt;- bianfu.GRM[,1]
library(gap)
names(Data)[1] &lt;- "id"
prior &lt;- list(G = list(G1 = list(V = 1, nu = 0.002)), R = list(V = 1, nu = 0.002))
model1.1 &lt;- MCMCgrm(WEIGTHT ~ 1, prior, Data, GRM, n.burnin=100, n.iter=1000, verbose=FALSE)
## an alternative
names(Data)[1] &lt;- "animal"
N &lt;- nrow(Data)
i &lt;- rep(1:N, rep(N, N))
j &lt;- rep(1:N, N)
s &lt;- Matrix::spMatrix(N, N, i, j, as.vector(GRM))
Ginv &lt;- Matrix::solve(s)
class(Ginv) &lt;- "dgCMatrix"
rownames(Ginv) &lt;- Ginv@Dimnames[[1]] &lt;- with(Data, animal)
model1.2 &lt;- MCMCglmm(WEIGTHT ~ 1, random= ~ animal, data = Data,
  ginverse=list(animal=Ginv), prior = prior, burnin=100, nitt=1000, verbose=FALSE)
## without missing data
model1.3 &lt;- MCMCglmm(Peak_Freq ~ WEIGTHT, random = ~ animal, 
  data=subset(Data,!is.na(Peak_Freq)&amp;!is.na(WEIGTHT)), 
  ginverse=list(animal=Ginv), prior = prior, burnin=100, nitt=1000, verbose=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='METAL_forestplot'>forest plot as R/meta's forest for METAL outputs</h2><span id='topic+METAL_forestplot'></span>

<h3>Description</h3>

<p>forest plot as R/meta's forest for METAL outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>METAL_forestplot(
  tbl,
  all,
  rsid,
  package = "meta",
  method = "REML",
  split = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="METAL_forestplot_+3A_tbl">tbl</code></td>
<td>
<p>Meta-anslysis summary statistics.</p>
</td></tr>
<tr><td><code id="METAL_forestplot_+3A_all">all</code></td>
<td>
<p>statistics from all contributing studies.</p>
</td></tr>
<tr><td><code id="METAL_forestplot_+3A_rsid">rsid</code></td>
<td>
<p>SNPID-rsid mapping file.</p>
</td></tr>
<tr><td><code id="METAL_forestplot_+3A_package">package</code></td>
<td>
<p>&quot;meta&quot; or &quot;metafor&quot; package.</p>
</td></tr>
<tr><td><code id="METAL_forestplot_+3A_method">method</code></td>
<td>
<p>an explcit flag for fixed/random effects model.</p>
</td></tr>
<tr><td><code id="METAL_forestplot_+3A_split">split</code></td>
<td>
<p>when TRUE, individual prot-MarkerName.pdf will be generated.</p>
</td></tr>
<tr><td><code id="METAL_forestplot_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>meta::forest</code> or <code>metafor::forest</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions takes a meta-data from METAL (tbl) and data from contributing studies (all)
for forest plot. It also takes a SNPID-rsid mapping (rsid) as contributing studies often
involve discrepancies in rsid so it is appropriate to use SNPID, i.e., chr:pos_A1_A2 (A1&lt;=A2).
</p>
<p>The study-specific and total sample sizes (<code>N</code>) can be customised from METAL commands. By default, the input triplets each contain
a <code>MarkerName</code> variable which is the unique SNP identifier (e.g., chr:pos:a1:a2) and the <code>tbl</code> argument has variables
<code>A1</code> and <code>A2</code> as produced by METAL while the <code>all</code> argument has <code>EFFECT_ALLELE</code> and <code>REFERENCE_ALLELE</code> as with a <code>study</code> variable
indicating study name. Another variable common the <code>tbl</code> and <code>all</code> is <code>prot</code> variable as the function was developed in a protein
based meta-analysis. As noted above, the documentation example also has variable <code>N</code>.
From these all information is in place for generation of a list of forest plots through a batch run.
</p>
<p>CUSTOMVARIABLE N<br />
LABEL N as N<br />
WEIGHTLABEL N
</p>


<h3>Value</h3>

<p>It will generate a forest plot specified by pdf for direction-adjusted effect sizes.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Schwarzer G (2007).
&ldquo;meta: An R package for meta-analysis.&rdquo;
<em>R News</em>, <b>7</b>, 40-45.
<a href="https://cran.r-project.org/doc/Rnews/Rnews_2007-3.pdf">https://cran.r-project.org/doc/Rnews/Rnews_2007-3.pdf</a>.
</p>
<p>Willer CJ, Li Y, Abecasis GR (2010).
&ldquo;METAL: fast and efficient meta-analysis of genomewide association scans.&rdquo;
<em>Bioinformatics</em>, <b>26</b>(17), 2190-1.
ISSN 1367-4803 (Print) 1367-4803, <a href="https://doi.org/10.1093/bioinformatics/btq340">doi:10.1093/bioinformatics/btq340</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 data(OPG, package="gap.datasets")
 meta::settings.meta(method.tau="DL")
 METAL_forestplot(OPGtbl,OPGall,OPGrsid,width=8.75,height=5,digits.TE=2,digits.se=2,
                  col.diamond="black",col.inside="black",col.square="black")
 METAL_forestplot(OPGtbl,OPGall,OPGrsid,package="metafor",method="FE",xlab="Effect",
                  showweights=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='metap'>Meta-analysis of p values</h2><span id='topic+metap'></span>

<h3>Description</h3>

<p>Meta-analysis of p values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metap(data, N, verbose = "Y", prefixp = "p", prefixn = "n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metap_+3A_data">data</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="metap_+3A_n">N</code></td>
<td>
<p>Number of studies.</p>
</td></tr>
<tr><td><code id="metap_+3A_verbose">verbose</code></td>
<td>
<p>Control of detailed output.</p>
</td></tr>
<tr><td><code id="metap_+3A_prefixp">prefixp</code></td>
<td>
<p>Prefix of p value, with default value &quot;p&quot;.</p>
</td></tr>
<tr><td><code id="metap_+3A_prefixn">prefixn</code></td>
<td>
<p>Preifx of sample size, with default value &quot;n&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the method of meta-analysis used in the Genetic Investigation
of ANThropometric Traits (GIANT) consortium, which is based on normal approximation
of p values and weighted by sample sizes from individual studies.
</p>


<h3>Value</h3>


<ul>
<li><p> x2 Fisher's chi-squared statistics.
</p>
</li>
<li><p> p P values from Fisher's method according to chi-squared distribution with 2*N degree(s) of freedom.
</p>
</li>
<li><p> z Combined z value.
</p>
</li>
<li><p> p1 One-sided p value.
</p>
</li>
<li><p> p2 Two-sided p value.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metareg">metareg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
s &lt;- data.frame(p1=0.1^rep(8:2,each=7,times=1),n1=rep(32000,49),
                p2=0.1^rep(8:2,each=1,times=7),n2=rep(8000,49))
cbind(s,metap(s,2))

# Speliotes, Elizabeth K., M.D. [ESPELIOTES@PARTNERS.ORG]
# 22-2-2008 MRC-Epid JHZ

np &lt;- 7
p &lt;- 0.1^((np+1):2)
z &lt;- qnorm(1-p/2)
n &lt;- c(32000,8000)
n1 &lt;- n[1]

s1 &lt;- s2 &lt;- vector("numeric")

for (i in 1:np)
{
   a &lt;- z[i]
   for (j in 1:np)
   {
       b &lt;- z[j]
       metaz1 &lt;- (sqrt(n1)*a+sqrt(n[1])*b)/sqrt(n1+n[1])
       metap1 &lt;- pnorm(-abs(metaz1))
       metaz2 &lt;- (sqrt(n1)*a+sqrt(n[2])*b)/sqrt(n1+n[2])
       metap2 &lt;- pnorm(-abs(metaz2))
       k &lt;- (i-1)*np+j
       cat(k,"\t",p[i],"\t",p[j],"\t",metap1,metaz1,"\t",metap2,metaz2,"\n")
       s1[k] &lt;- metap1
       s2[k] &lt;- metap2
  }
}

q &lt;- -log10(sort(p,decreasing=TRUE))
t1 &lt;- matrix(-log10(sort(s1,decreasing=TRUE)),np,np)
t2 &lt;- matrix(-log10(sort(s2,decreasing=TRUE)),np,np)

par(mfrow=c(1,2),bg="white",mar=c(4.2,3.8,0.2,0.2))
persp(q,q,t1)
persp(q,q,t2)

## End(Not run)

</code></pre>

<hr>
<h2 id='metareg'>Fixed and random effects model for meta-analysis</h2><span id='topic+metareg'></span>

<h3>Description</h3>

<p>Fixed and random effects model for meta-analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metareg(data, N, verbose = "Y", prefixb = "b", prefixse = "se")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metareg_+3A_data">data</code></td>
<td>
<p>Data frame to be used.</p>
</td></tr>
<tr><td><code id="metareg_+3A_n">N</code></td>
<td>
<p>Number of studies.</p>
</td></tr>
<tr><td><code id="metareg_+3A_verbose">verbose</code></td>
<td>
<p>A control for screen output.</p>
</td></tr>
<tr><td><code id="metareg_+3A_prefixb">prefixb</code></td>
<td>
<p>Prefix of estimate; default value is &quot;b&quot;.</p>
</td></tr>
<tr><td><code id="metareg_+3A_prefixse">prefixse</code></td>
<td>
<p>Prefix of standard error; default value is &quot;se&quot;.
The function accepts a wide format data with estimates as <code class="reqn">b1,...,bN</code>
and standard errors as <code class="reqn">se1,...,seN</code>. More generally, they can be specified
by prefixes in the function argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">k=n</code> studies with <code class="reqn">b_1, ..., b_N</code> being <code class="reqn">\beta</code>'s and
<code class="reqn">se_1, ..., se_N</code> standard errors from regression, the fixed effects
model uses inverse variance weighting such that <code class="reqn">w_1=1/se_1^2</code>, ...,
<code class="reqn">w_N=1/se_N^2</code> and the combined <code class="reqn">\beta</code> as the weighted average,
<code class="reqn">\beta_f=(b_1*w_1+...+b_N*w_N)/w</code>, with <code class="reqn">w=w_1+...+w_N</code>
being the total weight, the se for this estimate is <code class="reqn">se_f=\sqrt{1/w}</code>.
A normal z-statistic is obtained as <code class="reqn">z_f=\beta_f/se_f</code>, and the
corresponding p value <code class="reqn">p_f=2*pnorm(-abs(z_f))</code>. For the random effects
model, denote <code class="reqn">q_w=w_1*(b_1-\beta_f)^2+...+w_N*(b_N-\beta_f)^2</code>
and <code class="reqn">dl=max(0,(q_w-(k-1))/(w-(w_1^2+...+w_N^2)/w))</code>, corrected
weights are obtained such that <code class="reqn">{w_1}_c=1/(1/w_1+dl)</code>, ...,
<code class="reqn">{w_N}_c=1/(1/w_N+dl)</code>, totaling <code class="reqn">w_c={w_1}_c+...+{w_N}_c</code>.
The combined <code class="reqn">\beta</code> and se are then <code class="reqn">\beta_r=(b_1*{w_1}_c+...+b_N*{w_N}_c)/w_c</code>
and <code class="reqn">se_r=\sqrt(1/w_c)</code>, leading to a z-statistic
<code class="reqn">z_r=\beta_r/se_r</code> and a p-value <code class="reqn">p_r=2*pnorm(-abs(z_r))</code>. Moreover, a
p-value testing for heterogeneity is <code class="reqn">p_{heter}=pchisq(q_w,k-1,lower.tail=FALSE)</code>.
</p>


<h3>Value</h3>

<p>The returned value is a data frame with the following variables:
</p>

<ul>
<li><p> p_f P value (fixed effects model).
</p>
</li>
<li><p> p_r P value (random effects model).
</p>
</li>
<li><p> beta_f regression coefficient.
</p>
</li>
<li><p> beta_r regression coefficient.
</p>
</li>
<li><p> se_f standard error.
</p>
</li>
<li><p> se_r standard error.
</p>
</li>
<li><p> z_f z value.
</p>
</li>
<li><p> z_r z value.
</p>
</li>
<li><p> p_heter heterogeneity test p value.
</p>
</li>
<li><p> i2 <code class="reqn">I^2</code> statistic.
</p>
</li>
<li><p> k No of tests used.
</p>
</li>
<li><p> eps smallest double-precision number.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from a SAS macro, 23-7-2009 MRC-Epid JHZ
</p>


<h3>Author(s)</h3>

<p>Shengxu Li, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Higgins JP, Thompson SG, Deeks JJ, Altman DG (2003).
&ldquo;Measuring inconsistency in meta-analyses.&rdquo;
<em>BMJ</em>, <b>327</b>(7414), 557-60.
ISSN 0959-8138 (Print) 0959-8138, <a href="https://doi.org/10.1136/bmj.327.7414.557">doi:10.1136/bmj.327.7414.557</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
abc &lt;- data.frame(chromosome=1,rsn='abcd',startpos=1234,
                  b1=1,se1=2,p1=0.1,b2=2,se2=6,p2=0,b3=3,se3=8,p3=0.5)
metareg(abc,3)
abc2 &lt;- data.frame(b1=c(1,2),se1=c(2,4),b2=c(2,3),se2=c(4,6),b3=c(3,4),se3=c(6,8))
print(metareg(abc2,3))

## End(Not run)

</code></pre>

<hr>
<h2 id='mht.control'>Controls for mhtplot</h2><span id='topic+mht.control'></span>

<h3>Description</h3>

<p>Parameter specification through function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mht.control(
  type = "p",
  usepos = FALSE,
  logscale = TRUE,
  base = 10,
  cutoffs = NULL,
  colors = NULL,
  labels = NULL,
  srt = 45,
  gap = NULL,
  cex = 0.4,
  yline = 3,
  xline = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mht.control_+3A_type">type</code></td>
<td>
<p>Type of plot.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_usepos">usepos</code></td>
<td>
<p>A flag.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_logscale">logscale</code></td>
<td>
<p>A flag for log-scale.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_base">base</code></td>
<td>
<p>Base of log.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_cutoffs">cutoffs</code></td>
<td>
<p>Cutoffs of P-value, etc.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_colors">colors</code></td>
<td>
<p>Colours for chromosomes.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_labels">labels</code></td>
<td>
<p>Labels for chromosomes.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_srt">srt</code></td>
<td>
<p>Rotation degrees.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_gap">gap</code></td>
<td>
<p>Gap between data points.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_cex">cex</code></td>
<td>
<p>Scaling factor of data points.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_yline">yline</code></td>
<td>
<p>Vertical adjustment.</p>
</td></tr>
<tr><td><code id="mht.control_+3A_xline">xline</code></td>
<td>
<p>Horiztonal adjustment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list as above.
</p>

<hr>
<h2 id='mhtplot'>Manhattan plot</h2><span id='topic+mhtplot'></span>

<h3>Description</h3>

<p>Manhattan plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhtplot(data, control = mht.control(), hcontrol = hmht.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mhtplot_+3A_data">data</code></td>
<td>
<p>a data frame with three columns representing chromosome, position and p values.</p>
</td></tr>
<tr><td><code id="mhtplot_+3A_control">control</code></td>
<td>
<p>A control function named mht.control() with the following arguments:
</p>

<ul>
<li><p> type a flag with value &quot;p&quot; or &quot;l&quot; indicating if points or lines are to be drawn.
</p>
</li>
<li><p> usepos a flag to use real chromosomal positions as composed to ordinal positions with default value FALSE.
</p>
</li>
<li><p> logscale a flag to indicate if p value is to be log-transformed with default value TRUE.
</p>
</li>
<li><p> base the base of the logarithm with default value 10.
</p>
</li>
<li><p> cutoffs the cut-offs where horizontal line(s) are drawn with default value NULL.
</p>
</li>
<li><p> colors the color for different chromosome(s), and random if unspecified with default values NULL.
</p>
</li>
<li><p> labels labels for the ticks on x-axis with default value NULL.
</p>
</li>
<li><p> srt degree to which labels are rotated with default value of 45.
</p>
</li>
<li><p> gap gap between chromosomes with default value NULL.
</p>
</li>
<li><p> cex cex for the data points.
</p>
</li>
<li><p> yline Margin line position.
</p>
</li>
<li><p> xline Margin line position.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mhtplot_+3A_hcontrol">hcontrol</code></td>
<td>
<p>A control function named hmht.control() with the following arguments:
</p>

<ul>
<li><p> data. chunk of data to be highlighted with default value NULL.
</p>
</li>
<li><p> colors. colors for annotated genes.
</p>
</li>
<li><p> yoffset. offset above the data point showing most significant p value with default value 0.5.
</p>
</li>
<li><p> cex shrinkage factor for data points with default value 1.5.
</p>
</li>
<li><p> boxed if the label for the highlited region with default value FALSE.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mhtplot_+3A_...">...</code></td>
<td>
<p>other options in compatible with the R plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate Manhattan plot, e.g., of genomewide significance (p values) and
a random variable that is uniformly distributed. By default, a log10-transformation is applied.
Note that with real chromosomal positions, it is also appropriate to plot and some but not all chromosomes.
</p>
<p>It is possible to specify options such as xlab and ylim when the plot is requested for data in other context.
</p>


<h3>Value</h3>

<p>The plot is shown on or saved to the appropriate device.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qqunif">qqunif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# foo example
test &lt;- matrix(c(1,1,4,1,1,6,1,10,3,2,1,5,2,2,6,2,4,8),byrow=TRUE,6)
mhtplot(test)
mhtplot(test,mht.control(logscale=FALSE))

# fake example with Affy500k data
affy &lt;-c(40220, 41400, 33801, 32334, 32056, 31470, 25835, 27457, 22864, 28501, 26273,
         24954, 19188, 15721, 14356, 15309, 11281, 14881, 6399, 12400, 7125, 6207)
CM &lt;- cumsum(affy)
n.markers &lt;- sum(affy)
n.chr &lt;- length(affy)
test &lt;- data.frame(chr=rep(1:n.chr,affy),pos=1:n.markers,p=runif(n.markers))

# to reduce size of the plot
# bitmap("mhtplot.bmp",res=72*5)
oldpar &lt;- par()
par(cex=0.6)
colors &lt;- rep(c("blue","green"),11)
# other colors, e.g.
# colors &lt;- c("red","blue","green","cyan","yellow","gray","magenta","red","blue","green",
#             "cyan","yellow","gray","magenta","red","blue","green","cyan","yellow","gray",
#             "magenta","red")
mhtplot(test,control=mht.control(colors=colors),pch=19,srt=0)
title("A simulated example according to EPIC-Norfolk QCed SNPs")
axis(2)
axis(1,pos=0,labels=FALSE,tick=FALSE)
abline(0,0)
# dev.off()
par(oldpar)

mhtplot(test,control=mht.control(usepos=TRUE,colors=colors,gap=10000),pch=19,bg=colors)
title("Real positions with a gap of 10000 bp between chromosomes")
box()

png("manhattan.png",height=3600,width=6000,res=600)
opar &lt;- par()
par(cex=0.4)
ops &lt;- mht.control(colors=rep(c("lightgray","lightblue"),11),srt=0,yline=2.5,xline=2)
require(gap.datasets)
mhtplot(mhtdata[,c("chr","pos","p")],ops,xlab="",ylab="",srt=0)
axis(2,at=1:16)
title("An adaptable plot as .png")
par(opar)
dev.off()

data &lt;- with(mhtdata,cbind(chr,pos,p))
glist &lt;- c("IRS1","SPRY2","FTO","GRIK3","SNED1","HTR1A","MARCH3","WISP3","PPP1R3B",
         "RP1L1","FDFT1","SLC39A14","GFRA1","MC4R")
hdata &lt;- subset(mhtdata,gene\
color &lt;- rep(c("lightgray","gray"),11)
glen &lt;- length(glist)
hcolor &lt;- rep("red",glen)
par(las=2, xpd=TRUE, cex.axis=1.8, cex=0.4)
ops &lt;- mht.control(colors=color,yline=1.5,xline=3,labels=paste("chr",1:22,sep=""),
                   srt=270)
hops &lt;- hmht.control(data=hdata,colors=hcolor)
mhtplot(data,ops,hops,pch=19)
axis(2,pos=2,at=1:16)
title("Manhattan plot with genes highlighted",cex.main=1.8)

mhtplot(data,mht.control(cutoffs=c(4,6,8,16)),pch=19)
title("Another plain Manhattan plot")

# Miami plot

test &lt;- within(test, {pr=1-p})
miamiplot(test,chr="chr",bp="pos",p="p",pr="pr")

## End(Not run)
</code></pre>

<hr>
<h2 id='mhtplot.trunc'>Truncated Manhattan plot</h2><span id='topic+mhtplot.trunc'></span>

<h3>Description</h3>

<p>Truncated Manhattan plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhtplot.trunc(
  x,
  chr = "CHR",
  bp = "BP",
  p = NULL,
  log10p = NULL,
  z = NULL,
  snp = "SNP",
  col = c("gray10", "gray60"),
  chrlabs = NULL,
  suggestiveline = -log10(1e-05),
  genomewideline = -log10(5e-08),
  highlight = NULL,
  annotatelog10P = NULL,
  annotateTop = FALSE,
  cex.mtext = 1.5,
  cex.text = 0.7,
  mtext.line = 2,
  y.ax.space = 5,
  y.brk1 = NULL,
  y.brk2 = NULL,
  trunc.yaxis = TRUE,
  cex.axis = 1.2,
  delta = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mhtplot.trunc_+3A_x">x</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_chr">chr</code></td>
<td>
<p>Chromosome.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_bp">bp</code></td>
<td>
<p>Position.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_p">p</code></td>
<td>
<p>p values, e.g., &quot;1.23e-600&quot;.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_log10p">log10p</code></td>
<td>
<p>log10(p).</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_z">z</code></td>
<td>
<p>z statistic, i.e., BETA/SE.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_snp">snp</code></td>
<td>
<p>SNP. Pending on the setup it could either of variant or gene ID(s).</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_col">col</code></td>
<td>
<p>Colours.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_chrlabs">chrlabs</code></td>
<td>
<p>Chromosome labels, 1,2,...22,23,24,25.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_suggestiveline">suggestiveline</code></td>
<td>
<p>Suggestive line.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_genomewideline">genomewideline</code></td>
<td>
<p>Genomewide line.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_highlight">highlight</code></td>
<td>
<p>A list of SNPs to be highlighted.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_annotatelog10p">annotatelog10P</code></td>
<td>
<p>Threshold of -log10(P) to annotate.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_annotatetop">annotateTop</code></td>
<td>
<p>Annotate top.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_cex.mtext">cex.mtext</code></td>
<td>
<p>axis label extension factor.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_cex.text">cex.text</code></td>
<td>
<p>SNP label extension factor.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_mtext.line">mtext.line</code></td>
<td>
<p>position of the y lab.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_y.ax.space">y.ax.space</code></td>
<td>
<p>interval of ticks of the y axis.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_y.brk1">y.brk1</code></td>
<td>
<p>lower -log10(P) break point.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_y.brk2">y.brk2</code></td>
<td>
<p>upper -log10(P) break point.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_trunc.yaxis">trunc.yaxis</code></td>
<td>
<p>do not truncate y-axisx when FALSE.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_cex.axis">cex.axis</code></td>
<td>
<p>extension factor for x-, y-axis.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_delta">delta</code></td>
<td>
<p>a value to enable column(s) of red points.</p>
</td></tr>
<tr><td><code id="mhtplot.trunc_+3A_...">...</code></td>
<td>
<p>other options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate truncated Manhattan plot, e.g., of genomewide significance (P values) or a random variable that is uniformly distributed.
</p>
<p>The rationale of this function is to extend mhtplot() to handle extremely small p values as often seen from a protein GWAS. Optionally, the function also draws an ordinary Manhattan plot.
</p>


<h3>Value</h3>

<p>The plot is shown on or saved to the appropriate device.
</p>


<h3>Author(s)</h3>

<p>James Peters, Jing Hua Zhao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mhtplot">mhtplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
options(width=120)
require(gap.datasets)
mhtdata &lt;- within(mhtdata, {z=qnorm(p/2, lower.tail=FALSE)})
mhtplot.trunc(mhtdata, chr = "chr", bp = "pos", z = "z", snp = "rsn",
              y.brk1=6, y.brk2=10, y.ax.space=1, mtext.line=2.5)
# https://portals.broadinstitute.org/collaboration/
# giant/images/c/c8/Meta-analysis_Locke_et_al%2BUKBiobank_2018_UPDATED.txt.gz
gz &lt;- gzfile("work/Meta-analysis_Locke_et_al+UKBiobank_2018_UPDATED.txt.gz")
BMI &lt;- within(read.delim(gz,as.is=TRUE), {Z &lt;- BETA/SE})
print(subset(BMI[c("CHR","POS","SNP","P")],CHR!=16 &amp; P&lt;=1e-150))
library(Rmpfr)
print(within(subset(BMI, P==0, select=c(CHR,POS,SNP,Z)),
             {P &lt;- format(2*pnorm(mpfr(abs(Z),100),lower.tail=FALSE));
              Pvalue &lt;- pvalue(Z); log10P &lt;- -log10p(Z)}))
png("BMI.png", res=300, units="in", width=9, height=6)
par(oma=c(0,0,0,0), mar=c(5,6.5,1,1))
mhtplot.trunc(BMI, chr="CHR", bp="POS", z="Z", snp="SNP",
              suggestiveline=FALSE, genomewideline=-log10(1e-8),
              cex.mtext=1.2, cex.text=1.2,
              annotatelog10P=156, annotateTop = FALSE,
              highlight=c("rs13021737","rs17817449","rs6567160"),
              mtext.line=3, y.brk1=200, y.brk2=280, trunc.yaxis=TRUE,
              cex.axis=1.2, cex=0.5,
              y.ax.space=20,
              col = c("blue4", "skyblue")
)
dev.off()

## End(Not run)
</code></pre>

<hr>
<h2 id='mhtplot2'>Manhattan plot with annotations</h2><span id='topic+mhtplot2'></span>

<h3>Description</h3>

<p>Manhattan plot with annotations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhtplot2(data, control = mht.control(), hcontrol = hmht.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mhtplot2_+3A_data">data</code></td>
<td>
<p>a data frame with three columns representing chromosome, position and p values.</p>
</td></tr>
<tr><td><code id="mhtplot2_+3A_control">control</code></td>
<td>
<p>A control function named mht.control() with the following arguments:
</p>

<ul>
<li><p> type a flag with value &quot;p&quot; or &quot;l&quot; indicating if points or lines are to be drawn.
</p>
</li>
<li><p> usepos a flag to use real chromosomal positions as composed to ordinal positions with default value FALSE.
</p>
</li>
<li><p> logscale a flag to indicate if p value is to be log-transformed with default value TRUE.
</p>
</li>
<li><p> base the base of the logarithm with default value 10.
</p>
</li>
<li><p> cutoffs the cut-offs where horizontal line(s) are drawn with default value NULL.
</p>
</li>
<li><p> colors the color for different chromosome(s), and random if unspecified with default values NULL.
</p>
</li>
<li><p> labels labels for the ticks on x-axis with default value NULL.
</p>
</li>
<li><p> srt degree to which labels are rotated with default value of 45.
</p>
</li>
<li><p> gap gap between chromosomes with default value NULL.
</p>
</li>
<li><p> cex cex for the data points.
</p>
</li>
<li><p> yline Margin line position.
</p>
</li>
<li><p> xline Margin line position.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mhtplot2_+3A_hcontrol">hcontrol</code></td>
<td>
<p>A control function named hmht.control() with the following arguments:
</p>

<ul>
<li><p> data chunk of data to be highlighted with default value NULL.
</p>
</li>
<li><p> colors colors for annotated genes.
</p>
</li>
<li><p> yoffset offset above the data point showing most significant p value with default value 0.5.
</p>
</li>
<li><p> cex shrinkage factor for data points with default value 1.5.
</p>
</li>
<li><p> boxed if the label for the highlited region with default value FALSE.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mhtplot2_+3A_...">...</code></td>
<td>
<p>other options in compatible with the R plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate Manhattan plot with annotations. The function is generic and for instance could be used for genomewide
p values or any random variable that is uniformly distributed. By default, a log10-transformation is applied.
Note that with real chromosomal positions, it is also appropriate to plot and some but not all chromosomes.
</p>
<p>It is possible to specify options such as xlab, ylim and font family when the plot is requested for data in other
context.
</p>
<p>To maintain back compatibility options as in <code><a href="#topic+mhtplot">mhtplot</a></code> are used. The positions of the horizontal
labels are now in the middle rather than at the beginning of their bands in the plot.
</p>


<h3>Value</h3>

<p>The plot is shown on or saved to the appropriate device.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>den Hoed M, Eijgelsheim M, Esko T, Brundel BJ, Peal DS, Evans DM, Nolte IM, Segrè AV, Holm H, Handsaker RE, Westra HJ, Johnson T, Isaacs A, Yang J, Lundby A, Zhao JH, Kim YJ, Go MJ, Almgren P, Bochud M, Boucher G, Cornelis MC, Gudbjartsson D, Hadley D, van der Harst P, Hayward C, den Heijer M, Igl W, Jackson AU, Kutalik Z, Luan J, Kemp JP, Kristiansson K, Ladenvall C, Lorentzon M, Montasser ME, Njajou OT, O'Reilly PF, Padmanabhan S, St Pourcain B, Rankinen T, Salo P, Tanaka T, Timpson NJ, Vitart V, Waite L, Wheeler W, Zhang W, Draisma HH, Feitosa MF, Kerr KF, Lind PA, Mihailov E, Onland-Moret NC, Song C, Weedon MN, Xie W, Yengo L, Absher D, Albert CM, Alonso A, Arking DE, de Bakker PI, Balkau B, Barlassina C, Benaglio P, Bis JC, Bouatia-Naji N, Brage S, Chanock SJ, Chines PS, Chung M, Darbar D, Dina C, Dörr M, Elliott P, Felix SB, Fischer K, Fuchsberger C, de Geus EJ, Goyette P, Gudnason V, Harris TB, Hartikainen AL, Havulinna AS, Heckbert SR, Hicks AA, Hofman A, Holewijn S, Hoogstra-Berends F, Hottenga JJ, Jensen MK, Johansson A, Junttila J, Kääb S, Kanon B, Ketkar S, Khaw KT, Knowles JW, Kooner AS, others (2013).
&ldquo;Identification of heart rate-associated loci and their effects on cardiac conduction and rhythm disorders.&rdquo;
<em>Nat Genet</em>, <b>45</b>(6), 621-31.
ISSN 1061-4036 (Print) 1061-4036, <a href="https://doi.org/10.1038/ng.2610">doi:10.1038/ng.2610</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
The following example uses only chromosomes 14 and 20 of the Nat Genet paper.

mdata &lt;- within(hr1420,{
  c1&lt;-colour==1
  c2&lt;-colour==2
  c3&lt;-colour==3
  colour[c1] &lt;- 62
  colour[c2] &lt;- 73
  colour[c3] &lt;- 552
})
mdata &lt;- mdata[,c("CHR","POS","P","gene","colour")]
ops &lt;- mht.control(colors=rep(c("lightgray","gray"),11),yline=1.5,xline=2,srt=0)
hops &lt;- hmht.control(data=subset(mdata,!is.na(gene)))
v &lt;- "Verdana"
ifelse(Sys.info()['sysname']=="Windows", windowsFonts(ffamily=windowsFont(v)),
       ffamily &lt;- v)
tiff("mh.tiff", width=.03937*189, height=.03937*189/2, units="in", res=1200,
     compress="lzw")
par(las=2, xpd=TRUE, cex.axis=1.8, cex=0.4)
mhtplot2(with(mdata,cbind(CHR,POS,P,colour)),ops,hops,pch=19,
         ylab=expression(paste(plain("-"),log[10],plain("p-value"),sep=" ")),
         family="ffamily")
axis(2,pos=2,at=seq(0,25,5),family="ffamily",cex=0.5,cex.axis=1.1)
dev.off()

# To exemplify the use of chr, pos and p without gene annotation
# in response to query from Vallejo, Roger &lt;Roger.Vallejo@ARS.USDA.GOV&gt;
opar &lt;- par()
par(cex=0.4)
ops &lt;- mht.control(colors=rep(c("lightgray","lightblue"),11),srt=0,yline=2.5,xline=2)
mhtplot2(data.frame(mhtdata[,c("chr","pos","p")],gene=NA,color=NA),ops,xlab="",ylab="",srt=0)
axis(2,at=1:16)
title("data in mhtplot used by mhtplot2")
par(opar)

## End(Not run)
</code></pre>

<hr>
<h2 id='mia'>Multiple imputation analysis for hap</h2><span id='topic+mia'></span>

<h3>Description</h3>

<p>Multiple imputation analysis for hap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mia(
  hapfile = "hap.out",
  assfile = "assign.out",
  miafile = "mia.out",
  so = 0,
  ns = 0,
  mi = 0,
  allsnps = 0,
  sas = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mia_+3A_hapfile">hapfile</code></td>
<td>
<p>hap haplotype output file name.</p>
</td></tr>
<tr><td><code id="mia_+3A_assfile">assfile</code></td>
<td>
<p>hap assignment output file name.</p>
</td></tr>
<tr><td><code id="mia_+3A_miafile">miafile</code></td>
<td>
<p>mia output file name.</p>
</td></tr>
<tr><td><code id="mia_+3A_so">so</code></td>
<td>
<p>to generate results according to subject order.</p>
</td></tr>
<tr><td><code id="mia_+3A_ns">ns</code></td>
<td>
<p>do not sort in subject order.</p>
</td></tr>
<tr><td><code id="mia_+3A_mi">mi</code></td>
<td>
<p>number of multiple imputations used in hap.</p>
</td></tr>
<tr><td><code id="mia_+3A_allsnps">allsnps</code></td>
<td>
<p>all loci are SNPs.</p>
</td></tr>
<tr><td><code id="mia_+3A_sas">sas</code></td>
<td>
<p>produce SAS data step program.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This command reads outputs from hap session that uses multiple imputations, i.e. -mi# option. To
simplify matters it assumes -ss option is specified together with -mi option there.
</p>
<p>This is a very naive version of MIANALYZE, but can produce results for PROC MIANALYZE of SAS.
</p>
<p>It simply extracts outputs from hap.
</p>


<h3>Value</h3>

<p>The returned value is a list.
</p>


<h3>Note</h3>

<p>adapted from hap, in fact cline.c and cline.h are not used.
keywords utilities
</p>


<h3>References</h3>

<p>Zhao JH and W Qian (2003) Association analysis of unrelated individuals
using polymorphic genetic markers. RSS 2003, Hassalt, Belgium
</p>
<p>Clayton DG (2001) SNPHAP. https://github.com/chr1swallace/snphap.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hap">hap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# 4 SNP example, to generate hap.out and assign.out alone
data(fsnps)
hap(id=fsnps[,1],data=fsnps[,3:10],nloci=4)

# to generate results of imputations
control &lt;- hap.control(ss=1,mi=5)
hap(id=fsnps[,1],data=fsnps[,3:10],nloci=4,control=control)

# to extract information from the second run above
mia(so=1,ns=1,mi=5)
file.show("mia.out")

## commands to check out where the output files are as follows:
## Windows
# system("command.com")
## Unix
# system("csh")

## End(Not run)

</code></pre>

<hr>
<h2 id='miamiplot'>Miami plot</h2><span id='topic+miamiplot'></span>

<h3>Description</h3>

<p>Miami plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miamiplot(
  x,
  chr = "CHR",
  bp = "BP",
  p = "P",
  pr = "PR",
  snp = "SNP",
  col = c("midnightblue", "chartreuse4"),
  col2 = c("royalblue1", "seagreen1"),
  ymax = NULL,
  highlight = NULL,
  highlight.add = NULL,
  pch = 19,
  cex = 0.75,
  cex.lab = 1,
  xlab = "Chromosome",
  ylab = "-log10(P) [y&gt;0]; log10(P) [y&lt;0]",
  lcols = c("red", "black"),
  lwds = c(5, 2),
  ltys = c(1, 2),
  main = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miamiplot_+3A_x">x</code></td>
<td>
<p>Input data.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_chr">chr</code></td>
<td>
<p>Chromsome.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_bp">bp</code></td>
<td>
<p>Position.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_p">p</code></td>
<td>
<p>P value.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_pr">pr</code></td>
<td>
<p>P value of the other GWAS.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_snp">snp</code></td>
<td>
<p>Marker.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_col">col</code></td>
<td>
<p>Colors.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_col2">col2</code></td>
<td>
<p>Colors.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_ymax">ymax</code></td>
<td>
<p>Max y.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_highlight">highlight</code></td>
<td>
<p>Highlight flag.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_highlight.add">highlight.add</code></td>
<td>
<p>Highlight meta-data.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_pch">pch</code></td>
<td>
<p>Symbol.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_cex">cex</code></td>
<td>
<p>cex.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_cex.lab">cex.lab</code></td>
<td>
<p>cex for labels.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_lcols">lcols</code></td>
<td>
<p>Colors.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_lwds">lwds</code></td>
<td>
<p>lwd.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_ltys">ltys</code></td>
<td>
<p>lty.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_main">main</code></td>
<td>
<p>Main title.</p>
</td></tr>
<tr><td><code id="miamiplot_+3A_...">...</code></td>
<td>
<p>Additional options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows for contrast of genomewide P values from two GWASs. It is conceptually simpler than at the first sight since it involves only one set of chromosomal positions.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  mhtdata &lt;- within(mhtdata,{pr=p})
  miamiplot(mhtdata,chr="chr",bp="pos",p="p",pr="pr",snp="rsn")

## End(Not run)
</code></pre>

<hr>
<h2 id='miamiplot2'>Miami Plot</h2><span id='topic+miamiplot2'></span>

<h3>Description</h3>

<p>Miami Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miamiplot2(
  gwas1,
  gwas2,
  name1 = "GWAS 1",
  name2 = "GWAS 2",
  chr1 = "chr",
  chr2 = "chr",
  pos1 = "pos",
  pos2 = "pos",
  p1 = "p",
  p2 = "p",
  z1 = NULL,
  z2 = NULL,
  sug = 1e-05,
  sig = 5e-08,
  pcutoff = 0.1,
  topcols = c("green3", "darkgreen"),
  botcols = c("royalblue1", "navy"),
  yAxisInterval = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miamiplot2_+3A_gwas1">gwas1</code></td>
<td>
<p>The first of two GWAS datasets to plot, in the upper region.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_gwas2">gwas2</code></td>
<td>
<p>The second of two GWAS datasets to plot, in the lower region.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_name1">name1</code></td>
<td>
<p>The name of the first dataset, plotted above the upper plot region. Defaults to &lsquo;<span class="samp">&#8288;"GWAS 1"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_name2">name2</code></td>
<td>
<p>The name of the second dataset, plotted below the lower plot region. Defaults to &lsquo;<span class="samp">&#8288;"GWAS 2"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_chr1">chr1</code></td>
<td>
<p>The name of the column containing chromosome number in <span class="env">gwas1</span>. Defaults to &lsquo;<span class="samp">&#8288;"chr"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_chr2">chr2</code></td>
<td>
<p>The name of the column containing chromosome number in <span class="env">gwas2</span>. Defaults to &lsquo;<span class="samp">&#8288;"chr"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_pos1">pos1</code></td>
<td>
<p>The name of the column containing SNP position in <span class="env">gwas1</span>. Defaults to &lsquo;<span class="samp">&#8288;"pos"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_pos2">pos2</code></td>
<td>
<p>The name of the column containing SNP position in <span class="env">gwas2</span>. Defaults to &lsquo;<span class="samp">&#8288;"pos"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_p1">p1</code></td>
<td>
<p>The name of the column containing p-values in <span class="env">gwas1</span>. Defaults to &lsquo;<span class="samp">&#8288;"p"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_p2">p2</code></td>
<td>
<p>The name of the column containing p-values in <span class="env">gwas2</span>. Defaults to &lsquo;<span class="samp">&#8288;"p"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_z1">z1</code></td>
<td>
<p>The name of the column containing z-values in <span class="env">gwas1</span>. Defaults to &lsquo;<span class="samp">&#8288;"NULL"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_z2">z2</code></td>
<td>
<p>The name of the column containing z-values in <span class="env">gwas2</span>. Defaults to &lsquo;<span class="samp">&#8288;"NULL"&#8288;</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_sug">sug</code></td>
<td>
<p>The threshold for suggestive significance, plotted as a light grey dashed line.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_sig">sig</code></td>
<td>
<p>The threshold for genome-wide significance, plotted as a dark grey dashed line.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_pcutoff">pcutoff</code></td>
<td>
<p>The p-value threshold below which SNPs will be ignored. Defaults to 0.1. It is not recommended to set this higher as it will narrow the central gap between the two plot region where the chromosome number is plotted.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_topcols">topcols</code></td>
<td>
<p>A vector of two colours to plot alternating chromosomes in for the upper plot. Defaults to green3 and darkgreen.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_botcols">botcols</code></td>
<td>
<p>A vector of two colours to plot alternating chromosomes in for the lower plot. Defaults to royalblue1 and navy.</p>
</td></tr>
<tr><td><code id="miamiplot2_+3A_yaxisinterval">yAxisInterval</code></td>
<td>
<p>The interval between tick marks on the y-axis. Defaults to 5, 2 may be more suitable for plots with larger minimum p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a Miami plot to compare results from two genome-wide association analyses.
</p>


<h3>Value</h3>

<p>In addition to creading a Miami plot, the function returns a data frame containing x coordinates for chromosome start positions (required for <code><a href="#topic+labelManhattan">labelManhattan</a></code>)
</p>


<h3>Note</h3>

<p>Extended to handle extreme P values.
</p>


<h3>Author(s)</h3>

<p>Jonathan Marten
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# miamiplot2(gwas1, gwas2)
# chrmaxpos &lt;- miamiplot2(gwas1, gwas2)
gwas &lt;- within(mhtdata[c("chr","pos","p")], {z=qnorm(p/2)})
chrmaxpos &lt;- miamiplot2(gwas,gwas,name1="Batch 2",name2="Batch 1",z1="z",z2="z")
labelManhattan(chr=c(2,16),pos=c(226814165,52373776),name=c("AnonymousGene","FTO"),
               gwas,gwasZLab="z",chrmaxpos=chrmaxpos)

## End(Not run)
</code></pre>

<hr>
<h2 id='mr'>Mendelian randomization analysis</h2><span id='topic+mr'></span>

<h3>Description</h3>

<p>Mendelian randomization analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mr(data, X, Y, alpha = 0.05, other_plots = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mr_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="mr_+3A_x">X</code></td>
<td>
<p>Exposure.</p>
</td></tr>
<tr><td><code id="mr_+3A_y">Y</code></td>
<td>
<p>Outcome.</p>
</td></tr>
<tr><td><code id="mr_+3A_alpha">alpha</code></td>
<td>
<p>type I error rate for confidence intervals.</p>
</td></tr>
<tr><td><code id="mr_+3A_other_plots">other_plots</code></td>
<td>
<p>To add funnel and forest plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function initially intends to rework on GSMR outputs, but it would be appropriate for general use.
</p>


<h3>Value</h3>

<p>The result and plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(gap)
mrdat &lt;- '
 rs188743906  0.6804   0.1104  0.00177 0.01660        NA        NA
   rs2289779 -0.0788   0.0134  0.00104 0.00261 -0.007543 0.0092258
 rs117804300 -0.2281   0.0390 -0.00392 0.00855  0.109372 0.0362219
   rs7033492 -0.0968   0.0147 -0.00585 0.00269  0.022793 0.0119903
  rs10793962  0.2098   0.0212  0.00378 0.00536 -0.014567 0.0138196
    rs635634 -0.2885   0.0153 -0.02040 0.00334  0.077157 0.0117123
    rs176690 -0.0973   0.0142  0.00293 0.00306 -0.000007 0.0107781
 rs147278971 -0.2336   0.0378 -0.01240 0.00792  0.079873 0.0397491
  rs11562629  0.1155   0.0181  0.00960 0.00378 -0.010040 0.0151460
'
v &lt;- c("SNP", "b.LIF.R", "SE.LIF.R", "b.FEV1", "SE.FEV1", "b.CAD", "SE.CAD")
mrdat &lt;- setNames(as.data.frame(scan(file=textConnection(mrdat),
                                     what=list("",0,0,0,0,0,0))), v)
knitr::kable(mrdat,caption="Table 2. LIF.R and CAD/FEV1")
res &lt;- mr(mrdat, "LIF.R", c("CAD","FEV1"), other_plots=TRUE)
s &lt;- res$r[-1,]
colnames(s) &lt;- res$r[1,]
r &lt;- matrix(as.numeric(s[,-1]),nrow(s),dimnames=list(res$r[-1,1],res$r[1,-1]))
p &lt;- sapply(c("IVW","EGGER","WM","PWM"), function(x)
     format(2*pnorm(-abs(r[,paste0("b",x)]/r[,paste0("seb",x)])),digits=3,scientific=TRUE))
rp &lt;- t(data.frame(round(r,3),p))
knitr::kable(rp,align="r",caption="Table 3. LIFR variant rs635634 and CAD/FEV1")
</code></pre>

<hr>
<h2 id='mr_forestplot'>Mendelian Randomization forest plot</h2><span id='topic+mr_forestplot'></span>

<h3>Description</h3>

<p>Mendelian Randomization forest plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mr_forestplot(dat, sm = "", title = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mr_forestplot_+3A_dat">dat</code></td>
<td>
<p>A data.frame with outcome id, effect size and standard error.</p>
</td></tr>
<tr><td><code id="mr_forestplot_+3A_sm">sm</code></td>
<td>
<p>Summary measure such as OR, RR, MD.</p>
</td></tr>
<tr><td><code id="mr_forestplot_+3A_title">title</code></td>
<td>
<p>Title of the meta-analysis.</p>
</td></tr>
<tr><td><code id="mr_forestplot_+3A_...">...</code></td>
<td>
<p>Other options for meta::forest().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper of meta::forest() for multi-outcome Mendelian Randomization. It allows for the flexibility of both binary and continuous outcomes with and without summary level statistics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 tnfb &lt;- '
             "multiple sclerosis"  0.69058600 0.059270400
   "systemic lupus erythematosus"  0.76687500 0.079000500
         "sclerosing cholangitis"  0.62671500 0.075954700
  "juvenile idiopathic arthritis" -1.17577000 0.160293000
                      "psoriasis"  0.00582586 0.000800016
           "rheumatoid arthritis" -0.00378072 0.000625160
     "inflammatory bowel disease" -0.14334200 0.025272500
         "ankylosing spondylitis" -0.00316852 0.000626225
                 "hypothyroidism" -0.00432054 0.000987324
              "allergic rhinitis"  0.00393075 0.000926002
         "IgA glomerulonephritis" -0.32696600 0.105262000
                  "atopic eczema" -0.00204018 0.000678061
 '
 require(dplyr)
 tnfb &lt;- as.data.frame(scan(file=textConnection(tnfb),what=list("",0,0))) %&gt;%
         setNames(c("outcome","Effect","StdErr")) %&gt;%
         mutate(outcome=gsub("\\b(^[a-z])","\\U\\1",outcome,perl=TRUE))

 # default output
 mr_forestplot(tnfb, colgap.forest.left="0.05cm", fontsize=14, leftlabs=c("Outcome","b","SE"),
               common=FALSE, random=FALSE, print.I2=FALSE, print.pval.Q=FALSE, print.tau2=FALSE,
               spacing=1.6,digits.TE=2,digits.se=2)
 # no summary level statistics
 mr_forestplot(tnfb, colgap.forest.left="0.05cm", fontsize=14,
               leftcols="studlab", leftlabs="Outcome", plotwidth="3inch", sm="OR", rightlabs="ci", 
               sortvar=tnfb[["Effect"]],
               common=FALSE, random=FALSE, print.I2=FALSE, print.pval.Q=FALSE, print.tau2=FALSE,
               backtransf=TRUE, spacing=1.6)
 # with P values
 mr_forestplot(tnfb,colgap.forest.left="0.05cm", fontsize=14,
               leftcols=c("studlab"), leftlabs=c("Outcome"),
               plotwidth="3inch", sm="OR", sortvar=tnfb[["Effect"]],
               rightcols=c("effect","ci","pval"), rightlabs=c("OR","95%CI","P"),
               digits=3, digits.pval=2, scientific.pval=TRUE,
               common=FALSE, random=FALSE, print.I2=FALSE, print.pval.Q=FALSE, print.tau2=FALSE,
               addrow=TRUE, backtransf=TRUE, spacing=1.6)

## End(Not run)
</code></pre>

<hr>
<h2 id='mtdt'>Transmission/disequilibrium test of a multiallelic marker</h2><span id='topic+mtdt'></span>

<h3>Description</h3>

<p>Transmission/disequilibrium test of a multiallelic marker
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtdt(x, n.sim = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtdt_+3A_x">x</code></td>
<td>
<p>the data table.</p>
</td></tr>
<tr><td><code id="mtdt_+3A_n.sim">n.sim</code></td>
<td>
<p>the number of simulations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates transmission-disequilibrium statistics involving multiallelic marker.
Inside the function are tril and triu used to obtain lower and upper triangular matrices.
</p>


<h3>Value</h3>

<p>It returned list contains the following components:
</p>

<ul>
<li><p> SE Spielman-Ewens Chi-square from the observed data.
</p>
</li>
<li><p> ST Stuart or score Statistic from the observed data.
</p>
</li>
<li><p> pSE the simulated p value.
</p>
</li>
<li><p> sSE standard error of the simulated p value.
</p>
</li>
<li><p> pST the simulated p value.
</p>
</li>
<li><p> sST standard error of the simulated p value.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mike Miller, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Miller MB (1997).
&ldquo;Genomic scanning and the transmission/disequilibrium test: analysis of error rates.&rdquo;
<em>Genet Epidemiol</em>, <b>14</b>(6), 851-6.
ISSN 0741-0395 (Print) 0741-0395, <a href="https://doi.org/10.1002/%28sici%291098-2272%281997%2914%3A6%3C854%3A%3Aaid-gepi48%3E3.3.co%3B2-7">doi:10.1002/(sici)1098-2272(1997)14:6&lt;854::aid-gepi48&gt;3.3.co;2-7</a>.
</p>
<p>Sham PC, Curtis D (1995).
&ldquo;An extended transmission/disequilibrium test (TDT) for multi-allele marker loci.&rdquo;
<em>Ann Hum Genet</em>, <b>59</b>(3), 323-36.
ISSN 0003-4800 (Print) 0003-4800, <a href="https://doi.org/10.1111/j.1469-1809.1995.tb00751.x">doi:10.1111/j.1469-1809.1995.tb00751.x</a>.
</p>
<p>Spielman RS, Ewens WJ (1996).
&ldquo;The TDT and other family-based tests for linkage disequilibrium and association.&rdquo;
<em>Am J Hum Genet</em>, <b>59</b>(5), 983-9.
ISSN 0002-9297 (Print) 0002-9297.
</p>
<p>Zhao JH, Sham PC, Curtis D (1999).
&ldquo;A program for the Monte Carlo evaluation of significance of the extended transmission/disequilibrium test.&rdquo;
<em>Am J Hum Genet</em>, <b>64</b>, 1484-1485.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bt">bt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- matrix(c(0,0, 0, 2, 0,0, 0, 0, 0, 0, 0, 0,
              0,0, 1, 3, 0,0, 0, 2, 3, 0, 0, 0,
              2,3,26,35, 7,0, 2,10,11, 3, 4, 1,
              2,3,22,26, 6,2, 4, 4,10, 2, 2, 0,
              0,1, 7,10, 2,0, 0, 2, 2, 1, 1, 0,
              0,0, 1, 4, 0,1, 0, 1, 0, 0, 0, 0,
              0,2, 5, 4, 1,1, 0, 0, 0, 2, 0, 0,
              0,0, 2, 6, 1,0, 2, 0, 2, 0, 0, 0,
              0,3, 6,19, 6,0, 0, 2, 5, 3, 0, 0,
              0,0, 3, 1, 1,0, 0, 0, 1, 0, 0, 0,
              0,0, 0, 2, 0,0, 0, 0, 0, 0, 0, 0,
              0,0, 1, 0, 0,0, 0, 0, 0, 0, 0, 0),nrow=12)

# See note to bt for the score test obtained by SAS

mtdt(x)

## End(Not run)

</code></pre>

<hr>
<h2 id='mtdt2'>Transmission/disequilibrium test of a multiallelic marker by Bradley-Terry model</h2><span id='topic+mtdt2'></span>

<h3>Description</h3>

<p>Transmission/disequilibrium test of a multiallelic marker by Bradley-Terry model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtdt2(x, verbose = TRUE, n.sim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtdt2_+3A_x">x</code></td>
<td>
<p>the data table.</p>
</td></tr>
<tr><td><code id="mtdt2_+3A_verbose">verbose</code></td>
<td>
<p>To print out test statistics if TRUE.</p>
</td></tr>
<tr><td><code id="mtdt2_+3A_n.sim">n.sim</code></td>
<td>
<p>Number of simulations.</p>
</td></tr>
<tr><td><code id="mtdt2_+3A_...">...</code></td>
<td>
<p>other options compatible with the BTm function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates transmission-disequilibrium statistics involving
multiallelic marker according to Bradley-Terry model.
</p>


<h3>Value</h3>

<p>It returned list contains the following components:
</p>

<ul>
<li><p> c2b A data frame in four-column format showing transmitted vs nontransmitted counts.
</p>
</li>
<li><p> BTm A fitted Bradley-Terry model object.
</p>
</li>
<li><p> X2 Allele-wise, genotype-wise and goodness-of-fit Chi-squared statistics.
</p>
</li>
<li><p> df Degrees of freedom.
</p>
</li>
<li><p> p P value.
</p>
</li>
<li><p> pn Monte Carlo p values when n.sim is specified.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jing Hua Zhao
keywords models
keywords htest
</p>


<h3>References</h3>

<p>Firth D (2005).
&ldquo;Bradley-Terry Models in R.&rdquo;
<em>Journal of Statistical Software</em>, <b>12</b>(1), 1 - 12.
<a href="https://doi.org/10.18637/jss.v012.i01">doi:10.18637/jss.v012.i01</a>.
</p>
<p>Turner H, Firth D (2010) Bradley-Terry models in R: The BradleyTerry2 package.
https://cran.r-project.org/web/packages/BradleyTerry2/vignettes/BradleyTerry.pdf.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mtdt">mtdt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- matrix(c(0,0, 0, 2, 0,0, 0, 0, 0, 0, 0, 0,
              0,0, 1, 3, 0,0, 0, 2, 3, 0, 0, 0,
              2,3,26,35, 7,0, 2,10,11, 3, 4, 1,
              2,3,22,26, 6,2, 4, 4,10, 2, 2, 0,
              0,1, 7,10, 2,0, 0, 2, 2, 1, 1, 0,
              0,0, 1, 4, 0,1, 0, 1, 0, 0, 0, 0,
              0,2, 5, 4, 1,1, 0, 0, 0, 2, 0, 0,
              0,0, 2, 6, 1,0, 2, 0, 2, 0, 0, 0,
              0,3, 6,19, 6,0, 0, 2, 5, 3, 0, 0,
              0,0, 3, 1, 1,0, 0, 0, 1, 0, 0, 0,
              0,0, 0, 2, 0,0, 0, 0, 0, 0, 0, 0,
              0,0, 1, 0, 0,0, 0, 0, 0, 0, 0, 0),nrow=12)

xx &lt;- mtdt2(x,refcat="12")

## End(Not run)

</code></pre>

<hr>
<h2 id='muvar'>Means and variances under 1- and 2- locus (biallelic) QTL model</h2><span id='topic+muvar'></span>

<h3>Description</h3>

<p>Means and variances under 1- and 2- locus (biallelic) QTL model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muvar(
  n.loci = 1,
  y1 = c(0, 1, 1),
  y12 = c(1, 1, 1, 1, 1, 0, 0, 0, 0),
  p1 = 0.99,
  p2 = 0.9
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="muvar_+3A_n.loci">n.loci</code></td>
<td>
<p>number of loci, 1=single locus, 2=two loci.</p>
</td></tr>
<tr><td><code id="muvar_+3A_y1">y1</code></td>
<td>
<p>the genotypic means of aa, Aa and AA.</p>
</td></tr>
<tr><td><code id="muvar_+3A_y12">y12</code></td>
<td>
<p>the genotypic means of aa, Aa and AA at the first locus and bb, Bb and BB at the second locus.</p>
</td></tr>
<tr><td><code id="muvar_+3A_p1">p1</code></td>
<td>
<p>the frequency of the lower allele, or the that for the first locus under a 2-locus model.</p>
</td></tr>
<tr><td><code id="muvar_+3A_p2">p2</code></td>
<td>
<p>the frequency of the lower allele at the second locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function muvar() gives means and variances under 1-locus and 2-locus QTL model (simple);
in the latter case it gives results from different avenues. This function is included for
experimental purpose and yet to be generalized.
</p>


<h3>Value</h3>

<p>Currently it does not return any value except screen output; the results can be kept via R's sink()
command or via modifying the C/R codes.
</p>


<h3>Note</h3>

<p>Adapted from an earlier C program written for the above book.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Sham P (1997).
<em>Statistics in Human Genetics</em>.
Wiley.
ISBN 978-0470689288, <a href="https://www.amazon.com/dp/0470689285/">https://www.amazon.com/dp/0470689285/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# the default 1-locus model
muvar(n.loci=1,y1=c(0,1,1),p1=0.5)

# the default 2-locus model
muvar(n.loci=2,y12=c(1,1,1,1,1,0,0,0,0),p1=0.99,p2=0.9)

## End(Not run)

</code></pre>

<hr>
<h2 id='mvmeta'>Multivariate meta-analysis based on generalized least squares</h2><span id='topic+mvmeta'></span>

<h3>Description</h3>

<p>Multivariate meta-analysis based on generalized least squares
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvmeta(b, V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvmeta_+3A_b">b</code></td>
<td>
<p>the parameter estimates.</p>
</td></tr>
<tr><td><code id="mvmeta_+3A_v">V</code></td>
<td>
<p>the triangular variance-covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts a data matrix of parameter estimates and their variance-covariance matrix
from individual studies and obtain a generalized least squares (GLS) estimate and heterogeneity statistic.
</p>
<p>For instance, this would be appropriate for combining linear correlation coefficients of single
nucleotide polymorphisms (SNPs) for a given region.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> d the compact parameter estimates.
</p>
</li>
<li><p> Psi the compact covariance-covariance matrix.
</p>
</li>
<li><p> X the design matrix.
</p>
</li>
<li><p> beta the pooled parameter estimates.
</p>
</li>
<li><p> cov.beta the pooled variance-covariance matrix.
</p>
</li>
<li><p> X2 the Chi-squared statistic for heterogeneity.
</p>
</li>
<li><p> df the degrees(s) of freedom.
</p>
</li>
<li><p> p the p value.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Hartung J, Knapp G, Sinha BK (2008).
<em>Statistical Meta-analysis with Applications</em>.
Wiley.
ISBN 978-0-470-29089-7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metareg">metareg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example 11.3 from Hartung et al.
#
b &lt;- matrix(c(
0.808, 1.308, 1.379, NA, NA,
NA, 1.266, 1.828, 1.962, NA,
NA, 1.835, NA, 2.568, NA,
NA, 1.272, NA, NA, 2.038,
1.171, 2.024, 2.423, 3.159, NA,
0.681, NA, NA, NA, NA),ncol=5, byrow=TRUE)

psi1 &lt;- psi2 &lt;- psi3 &lt;- psi4 &lt;- psi5 &lt;- psi6 &lt;- matrix(0,5,5)

psi1[1,1] &lt;- 0.0985
psi1[1,2] &lt;- 0.0611
psi1[1,3] &lt;- 0.0623
psi1[2,2] &lt;- 0.1142
psi1[2,3] &lt;- 0.0761
psi1[3,3] &lt;- 0.1215

psi2[2,2] &lt;- 0.0713
psi2[2,3] &lt;- 0.0539
psi2[2,4] &lt;- 0.0561
psi2[3,3] &lt;- 0.0938
psi2[3,4] &lt;- 0.0698
psi2[4,4] &lt;- 0.0981

psi3[2,2] &lt;- 0.1228
psi3[2,4] &lt;- 0.1119
psi3[4,4] &lt;- 0.1790

psi4[2,2] &lt;- 0.0562
psi4[2,5] &lt;- 0.0459
psi4[5,5] &lt;- 0.0815

psi5[1,1] &lt;- 0.0895
psi5[1,2] &lt;- 0.0729
psi5[1,3] &lt;- 0.0806
psi5[1,4] &lt;- 0.0950
psi5[2,2] &lt;- 0.1350
psi5[2,3] &lt;- 0.1151
psi5[2,4] &lt;- 0.1394
psi5[3,3] &lt;- 0.1669
psi5[3,4] &lt;- 0.1609
psi5[4,4] &lt;- 0.2381

psi6[1,1] &lt;- 0.0223

V &lt;- rbind(psi1[upper.tri(psi1,diag=TRUE)],psi2[upper.tri(psi2,diag=TRUE)],
psi3[upper.tri(psi3,diag=TRUE)],psi4[upper.tri(psi4,diag=TRUE)],
psi5[upper.tri(psi5,diag=TRUE)],psi6[upper.tri(psi6,diag=TRUE)])

mvmeta(b,V)

## End(Not run)
</code></pre>

<hr>
<h2 id='pbsize'>Power for population-based association design</h2><span id='topic+pbsize'></span>

<h3>Description</h3>

<p>Power for population-based association design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbsize(kp, gamma = 4.5, p = 0.15, alpha = 5e-08, beta = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbsize_+3A_kp">kp</code></td>
<td>
<p>population disease prevalence.</p>
</td></tr>
<tr><td><code id="pbsize_+3A_gamma">gamma</code></td>
<td>
<p>genotype relative risk assuming multiplicative model.</p>
</td></tr>
<tr><td><code id="pbsize_+3A_p">p</code></td>
<td>
<p>frequency of disease allele.</p>
</td></tr>
<tr><td><code id="pbsize_+3A_alpha">alpha</code></td>
<td>
<p>type I error rate.</p>
</td></tr>
<tr><td><code id="pbsize_+3A_beta">beta</code></td>
<td>
<p>type II error rate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements Scott et al. (1997) statistics for population-based
association design. This is based on a contingency table test and accurate level of
significance can be obtained by Fisher's exact test.
</p>


<h3>Value</h3>

<p>The returned value is scaler containing the required sample size.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
extracted from rm.c.
</p>


<h3>References</h3>

<p>Scott WK, Pericak-Vance MA, Haines JL (1997).
&ldquo;Genetic analysis of complex diseases.&rdquo;
<em>Science</em>, <b>275</b>(5304), 1327; author reply 1329-30.
ISSN 0036-8075 (Print) 0036-8075.
</p>
<p>Long AD, Grote MN, Langley CH (1997). Genetic analysis of complex traits. Science 275: 1328.
</p>
<p>Rosner B (2000).
<em>Fundamentals of biostatistics</em>, 5 edition.
Duxbury, Pacific Grove, CA.
ISBN 9780534370688.
</p>
<p>Armitage P, Colton T (eds.) (2005).
<em>Encyclopedia of biostatistics</em>, 2 edition.
John Wiley, Chichester, West Sussex, England ; Hoboken, NJ.
ISBN 9780470849071.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fbsize">fbsize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kp &lt;- c(0.01,0.05,0.10,0.2)
models &lt;- matrix(c(
    4.0, 0.01,
    4.0, 0.10,
    4.0, 0.50, 
    4.0, 0.80,
    2.0, 0.01,
    2.0, 0.10,
    2.0, 0.50,
    2.0, 0.80,
    1.5, 0.01,    
    1.5, 0.10,
    1.5, 0.50,
    1.5, 0.80), ncol=2, byrow=TRUE)
outfile &lt;- "pbsize.txt"
cat("gamma","p","p1","p5","p10","p20\n",sep="\t",file=outfile)
for(i in 1:dim(models)[1])
{
  g &lt;- models[i,1]
  p &lt;- models[i,2]
  n &lt;- vector()
  for(k in kp) n &lt;- c(n,ceiling(pbsize(k,g,p)))
  cat(models[i,1:2],n,sep="\t",file=outfile,append=TRUE)
  cat("\n",file=outfile,append=TRUE)
} 
table5 &lt;- read.table(outfile,header=TRUE,sep="\t")
unlink(outfile)

# Alzheimer's disease
g &lt;- 4.5
p &lt;- 0.15
alpha &lt;- 5e-8
beta &lt;- 0.2
z1alpha &lt;- qnorm(1-alpha/2)   # 5.45
z1beta &lt;- qnorm(1-beta)
q &lt;- 1-p
pi &lt;- 0.065                   # 0.07 and zbeta generate 163
k &lt;- pi*(g*p+q)^2
s &lt;- (1-pi*g^2)*p^2+(1-pi*g)*2*p*q+(1-pi)*q^2
# LGL formula
lambda &lt;- pi*(g^2*p+q-(g*p+q)^2)/(1-pi*(g*p+q)^2)
# mine
lambda &lt;- pi*p*q*(g-1)^2/(1-k)
n &lt;- (z1alpha+z1beta)^2/lambda
cat("\nPopulation-based result: Kp =",k, "Kq =",s, "n =",ceiling(n),"\n")

</code></pre>

<hr>
<h2 id='pbsize2'>Power for case-control association design</h2><span id='topic+pbsize2'></span>

<h3>Description</h3>

<p>Power for case-control association design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbsize2(
  N,
  fc = 0.5,
  alpha = 0.05,
  gamma = 4.5,
  p = 0.15,
  kp = 0.1,
  model = "additive"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbsize2_+3A_n">N</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code id="pbsize2_+3A_fc">fc</code></td>
<td>
<p>The proportion of cases in the sample.</p>
</td></tr>
<tr><td><code id="pbsize2_+3A_alpha">alpha</code></td>
<td>
<p>Type I error rate.</p>
</td></tr>
<tr><td><code id="pbsize2_+3A_gamma">gamma</code></td>
<td>
<p>The genotype relative risk (GRR).</p>
</td></tr>
<tr><td><code id="pbsize2_+3A_p">p</code></td>
<td>
<p>Frequency of the risk allele.</p>
</td></tr>
<tr><td><code id="pbsize2_+3A_kp">kp</code></td>
<td>
<p>The prevalence of disease in the population.</p>
</td></tr>
<tr><td><code id="pbsize2_+3A_model">model</code></td>
<td>
<p>Disease model, i.e., &quot;multiplicative&quot;,&quot;additive&quot;,&quot;dominant&quot;,&quot;recessive&quot;,&quot;overdominant&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This extends <code><a href="#topic+pbsize">pbsize</a></code> from a multiplicative model for a case-control
design under a range of disease models. Essentially, for given sample sizes(s), a
proportion of which (fc) being cases, the function calculates power estimate for a
given type I error (alpha), genotype relative risk (gamma), frequency of the risk
allele (p), the prevalence of disease in the population (kp) and optionally a disease
model (model). A major difference would be the consideration of case/control
ascertainment in <code><a href="#topic+pbsize">pbsize</a></code>.
</p>
<p>Internally, the function obtains a baseline risk to make the disease model consistent
with Kp as in <code><a href="#topic+tscc">tscc</a></code> and should produce accurate power estimate. It
provides power estimates for given sample size(s) only.
</p>


<h3>Value</h3>

<p>The returned value is the power for the specified design.
</p>


<h3>See Also</h3>

<p>The design follows that of <code><a href="#topic+pbsize">pbsize</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# single calculation
m &lt;- c("multiplicative","recessive","dominant","additive","overdominant")
for(i in 1:5) print(pbsize2(N=50,alpha=5e-2,gamma=1.1,p=0.1,kp=0.1, model=m[i]))

# a range of sample sizes
pbsize2(p=0.1, N=c(25,50,100,200,500), gamma=1.2, kp=.1, alpha=5e-2, model='r')
  
# a power table
m &lt;- sapply(seq(0.1,0.9, by=0.1),
            function(x) pbsize2(p=x, N=seq(100,1000,by=100),
                        gamma=1.2, kp=.1, alpha=5e-2, model='recessive'))
colnames(m) &lt;- seq(0.1,0.9, by=0.1)
rownames(m) &lt;- seq(100,1000,by=100)
print(round(m,2))

## End(Not run)

</code></pre>

<hr>
<h2 id='pedtodot'>Converting pedigree(s) to dot file(s)</h2><span id='topic+pedtodot'></span>

<h3>Description</h3>

<p>Converting pedigree(s) to dot file(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedtodot(
  pedfile,
  makeped = FALSE,
  sink = TRUE,
  page = "B5",
  url = "https://jinghuazhao.github.io/",
  height = 0.5,
  width = 0.75,
  rotate = 0,
  dir = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedtodot_+3A_pedfile">pedfile</code></td>
<td>
<p>a pedigree file in GAS or LINKAGE format, note if
individual's ID is character then it is necessary to specify as.is=T
in the read.table command.</p>
</td></tr>
<tr><td><code id="pedtodot_+3A_makeped">makeped</code></td>
<td>
<p>a logical variable indicating if the pedigree file is post-makeped.</p>
</td></tr>
<tr><td><code id="pedtodot_+3A_sink">sink</code></td>
<td>
<p>a logical variable indicating if .dot file(s) are created.</p>
</td></tr>
<tr><td><code id="pedtodot_+3A_page">page</code></td>
<td>
<p>a string indicating the page size, e.g, A4, A5, B5, Legal, Letter,
Executive, &quot;x,y&quot;, where x, y is the customized page size.</p>
</td></tr>
<tr><td><code id="pedtodot_+3A_url">url</code></td>
<td>
<p>Unified Resource Locator (URL) associated with the diagram(s).</p>
</td></tr>
<tr><td><code id="pedtodot_+3A_height">height</code></td>
<td>
<p>the height of node(s).</p>
</td></tr>
<tr><td><code id="pedtodot_+3A_width">width</code></td>
<td>
<p>the width of node(s).</p>
</td></tr>
<tr><td><code id="pedtodot_+3A_rotate">rotate</code></td>
<td>
<p>if set to 90, the diagram is in landscape.</p>
</td></tr>
<tr><td><code id="pedtodot_+3A_dir">dir</code></td>
<td>
<p>direction of edges, i.e., &quot;none&quot;, &quot;forward&quot;,&quot;back&quot;,&quot;both&quot;. This will be useful
if the diagram is viewed by lneato.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts GAS or LINKAGE formatted pedigree(s) into .dot file
for each pedigree to be used by dot in graphviz, which is a flexible package
for graphics freely available.
</p>
<p>Note that a single PostScript (PDF) file can be obtainaed by <code>dot</code>, <code>fdp</code>,
or <code>neato</code>.
</p>
<div class="sourceCode"><pre>dot -Tps &lt;dot file&gt; -o &lt;ps file&gt;
</pre></div>
<p>or
</p>
<div class="sourceCode"><pre>fdp -Tps &lt;dot file&gt; -o &lt;ps file&gt;
</pre></div>
<p>or
</p>
<div class="sourceCode"><pre>neato -Tps &lt;dot file&gt; -o &lt;ps file&gt;
</pre></div>
<p>See relevant documentations for other formats.
</p>
<p>To preserve the original order of pedigree(s) in the data, you can examine the
examples at the end of this document.
</p>
<p>Under Cygwin/Linux/Unix, the PostScript file can be converted to Portable
Document Format (PDF) default to Acrobat.
</p>
<div class="sourceCode"><pre>ps2pdf &lt;ps file&gt;
</pre></div>
<p>Use <code>ps2pdf12</code>, <code>ps2pdf13</code>, or <code>ps2pdf14</code> for appropriate versions of Acrobat
according to information given on the headline of <code style="white-space: pre;">&#8288;&lt;ps file&gt;&#8288;</code>.
</p>
<p>Under Linux, you can also visualize the .dot file directly via command,
</p>
<div class="sourceCode"><pre>dotty &lt;dot file&gt; &amp;
</pre></div>
<p>We can extract the code below (or within <code>pedtodot.Rd</code>) to pedtodot and then
use command:
</p>
<div class="sourceCode"><pre>sh pedtodot &lt;pedigree file&gt;
</pre></div>


<h3>Value</h3>

<p>For each pedigree, the function generates a .dot file to be used by dot. The
collection of all pedigrees (*.dot) can also be put together.
</p>


<h3>Note</h3>

<p>This is based on the gawk script program pedtodot by David Duffy with minor changes.
</p>


<h3>Author(s)</h3>

<p>David Duffy, Jing Hua Zhao
</p>


<h3>See Also</h3>

<p>package sem in CRAN and Rgraphviz in BioConductor <a href="https://www.bioconductor.org/">https://www.bioconductor.org/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example as in R News and Bioinformatics (see also plot.pedigree in package kinship)
# it works from screen paste only
p1 &lt;- scan(nlines=16,what=list(0,0,0,0,0,"",""))
 1   2   3  2  2  7/7  7/10 
 2   0   0  1  1  -/-  -/-  
 3   0   0  2  2  7/9  3/10 
 4   2   3  2  2  7/9  3/7  
 5   2   3  2  1  7/7  7/10 
 6   2   3  1  1  7/7  7/10 
 7   2   3  2  1  7/7  7/10 
 8   0   0  1  1  -/-  -/-  
 9   8   4  1  1  7/9  3/10 
10   0   0  2  1  -/-  -/- 
11   2  10  2  1  7/7  7/7 
12   2  10  2  2  6/7  7/7 
13   0   0  1  1  -/-  -/- 
14  13  11  1  1  7/8  7/8 
15   0   0  1  1  -/-  -/- 
16  15  12  2  1  6/6  7/7 

p2 &lt;- as.data.frame(p1)
names(p2) &lt;-c("id","fid","mid","sex","aff","GABRB1","D4S1645")
p3 &lt;- data.frame(pid=10081,p2)
attach(p3)
pedtodot(p3)
#
# Three examples of pedigree-drawing
# assuming pre-MakePed LINKAGE file in which IDs are characters
pre&lt;-read.table("pheno.pre",as.is=TRUE)[,1:6]
pedtodot(pre)
dir()      
# for post-MakePed LINKAGE file in which IDs are integers
ped &lt;-read.table("pheno.ped")[,1:10]
pedtodot(ped,makeped=TRUE)
dir()
# for a single file with a list of pedigrees ordered data
sink("gaw14.dot")
pedtodot(ped,sink=FALSE)
sink()
file.show("gaw14.dot")
# more details
pedtodot(ped,sink=FALSE,page="B5",url="https://jinghuazhao.github.io/")

# An example from Richard Mott and in the demo
filespec &lt;- system.file("tests/ped.1.3.pre")
pre &lt;- read.table(filespec,as.is=TRUE)
pre
pedtodot(pre,dir="forward")

## End(Not run)

</code></pre>

<hr>
<h2 id='pedtodot_verbatim'>Pedigree-drawing with graphviz</h2><span id='topic+pedtodot_verbatim'></span>

<h3>Description</h3>

<p>Pedigree-drawing with graphviz
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedtodot_verbatim(f, run = FALSE, toDOT = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedtodot_verbatim_+3A_f">f</code></td>
<td>
<p>A data.frame containing pedigrees, each with pedigree id, individual id, father id, mother id, sex and affection status.</p>
</td></tr>
<tr><td><code id="pedtodot_verbatim_+3A_run">run</code></td>
<td>
<p>A flag to run dot/neato on the generated .dot file(s).</p>
</td></tr>
<tr><td><code id="pedtodot_verbatim_+3A_todot">toDOT</code></td>
<td>
<p>A flag to generate script for <code>DOT::dot()</code>.</p>
</td></tr>
<tr><td><code id="pedtodot_verbatim_+3A_...">...</code></td>
<td>
<p>Other flag(s) for <code>DOT::dot()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read a GAS or LINKAGE format pedigree, return a digraph in the dot language and optionally
call dot/neato to make pedigree drawing.
</p>
<p>This is a verbatim translation of the original pedtodot implemneted in Bash/awk in contrast to <code>pedtodot</code> which was largely a mirror.
To check independently, try <code style="white-space: pre;">&#8288;xsel -i &lt; &lt;(cat pedtodot_verbatim.R)&#8288;</code> or <code style="white-space: pre;">&#8288;cat pedtodot_verbatim.R | xsel -i&#8288;</code> and paste into an R session.
</p>


<h3>Value</h3>

<p>No value is returned but outputs in .dot, .pdf, and .svg.
</p>


<h3>Note</h3>

<p>Adapted from Bash/awk script by David Duffy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# pedigree p3 in pedtodot
  pedtodot_verbatim(p3,run=TRUE,toDOT=TRUE,return="verbatim")

## End(Not run)
</code></pre>

<hr>
<h2 id='pfc'>Probability of familial clustering of disease</h2><span id='topic+pfc'></span>

<h3>Description</h3>

<p>Probability of familial clustering of disease
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfc(famdata, enum = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfc_+3A_famdata">famdata</code></td>
<td>
<p>collective information of sib size, number of affected sibs and their frequencies.</p>
</td></tr>
<tr><td><code id="pfc_+3A_enum">enum</code></td>
<td>
<p>a switch taking value 1 if all possible tables are to be enumerated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To calculate exact probability of familial clustering of disease
</p>


<h3>Value</h3>

<p>The returned value is a list containing (tailp,sump,nenum are only available if enum=1:
</p>

<ul>
<li><p> p the probabitly of familial clustering.
</p>
</li>
<li><p> stat the deviances, chi-squares based on binomial and hypergeometric distributions,
the degrees of freedom should take into account the number of marginals used.
</p>
</li>
<li><p> tailp the exact statistical significance.
</p>
</li>
<li><p> sump sum of the probabilities used for error checking.
</p>
</li>
<li><p> nenum the total number of tables enumerated.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from family.for by Dani Zelterman, 25/7/03
</p>


<h3>Author(s)</h3>

<p>Dani Zelterman, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Yu C, Zelterman D (2001).
&ldquo;Exact inference for family disease clusters.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>30</b>(11), 2293-2305.
ISSN 0361-0926, <a href="https://doi.org/10.1081/STA-100107686">doi:10.1081/STA-100107686</a>.
</p>
<p>Yu C, Zelterman D (2002).
&ldquo;Statistical inference for familial disease clusters.&rdquo;
<em>Biometrics</em>, <b>58</b>(3), 481-91.
ISSN 0006-341X (Print) 0006-341x, <a href="https://doi.org/10.1111/j.0006-341x.2002.00481.x">doi:10.1111/j.0006-341x.2002.00481.x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kin.morgan">kin.morgan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# IPF among 203 siblings of 100 COPD patients from Liang KY, SL Zeger,
# Qaquish B. Multivariate regression analyses for categorical data
# (with discussion). J Roy Stat Soc B 1992, 54:3-40

# the degrees of freedom is 15
famtest&lt;-c(
1, 0, 36,
1, 1, 12,
2, 0, 15,
2, 1,  7,
2, 2,  1,
3, 0,  5,
3, 1,  7,
3, 2,  3,
3, 3,  2,
4, 0,  3,
4, 1,  3,
4, 2,  1,
6, 0,  1,
6, 2,  1,
6, 3,  1,
6, 4,  1,
6, 6,  1)
test&lt;-t(matrix(famtest,nrow=3))
famp&lt;-pfc(test)

## End(Not run)

</code></pre>

<hr>
<h2 id='pfc.sim'>Probability of familial clustering of disease</h2><span id='topic+pfc.sim'></span>

<h3>Description</h3>

<p>Probability of familial clustering of disease
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfc.sim(famdata, n.sim = 1e+06, n.loop = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfc.sim_+3A_famdata">famdata</code></td>
<td>
<p>collective information of sib size, number of affected sibs and their frequencies.</p>
</td></tr>
<tr><td><code id="pfc.sim_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulations in a single Monte Carlo run.</p>
</td></tr>
<tr><td><code id="pfc.sim_+3A_n.loop">n.loop</code></td>
<td>
<p>total number of Monte Carlo runs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To calculate probability of familial clustering of disease using Monte Carlo simulation.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> n.sim a copy of the number of simulations in a single Monte Carlo run.
</p>
</li>
<li><p> n.loop the total number of Monte Carlo runs.
</p>
</li>
<li><p> p the observed p value.
</p>
</li>
<li><p> tailpl accumulated probabilities at the lower tails.
</p>
</li>
<li><p> tailpu simulated p values.
</p>
</li></ul>



<h3>Note</h3>

<p>Adapted from runi.for from Change Yu, 5/6/4
</p>


<h3>Author(s)</h3>

<p>Chang Yu, Dani Zelterman
</p>


<h3>References</h3>

<p>Yu C, Zelterman D (2001).
&ldquo;Exact inference for family disease clusters.&rdquo;
<em>Communications in Statistics - Theory and Methods</em>, <b>30</b>(11), 2293-2305.
ISSN 0361-0926, <a href="https://doi.org/10.1081/STA-100107686">doi:10.1081/STA-100107686</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pfc">pfc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Li FP, Fraumeni JF Jr, Mulvihill JJ, Blattner WA, Dreyfus MG, Tucker MA,
# Miller RW. A cancer family syndrome in twenty-four kindreds.
# Cancer Res 1988, 48(18):5358-62. 

# family_size  #_of_affected frequency

famtest&lt;-c(
1, 0, 2,
1, 1, 0,
2, 0, 1,
2, 1, 4,
2, 2, 3,
3, 0, 0,
3, 1, 2,
3, 2, 1,
3, 3, 1,
4, 0, 0,
4, 1, 2,
5, 0, 0,
5, 1, 1,
6, 0, 0,
6, 1, 1,
7, 0, 0,
7, 1, 1,
8, 0, 0,
8, 1, 1,
8, 2, 1,
8, 3, 1,
9, 3, 1)

test&lt;-matrix(famtest,byrow=T,ncol=3)

famp&lt;-pfc.sim(test)

## End(Not run)

</code></pre>

<hr>
<h2 id='pgc'>Preparing weight for GENECOUNTING</h2><span id='topic+pgc'></span>

<h3>Description</h3>

<p>Preparing weight for GENECOUNTING
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgc(data, handle.miss = 1, is.genotype = 0, with.id = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgc_+3A_data">data</code></td>
<td>
<p>the multilocus genotype data for a set of individuals.</p>
</td></tr>
<tr><td><code id="pgc_+3A_handle.miss">handle.miss</code></td>
<td>
<p>a flag to indicate if missing data is kept, 0 = no, 1 = yes.</p>
</td></tr>
<tr><td><code id="pgc_+3A_is.genotype">is.genotype</code></td>
<td>
<p>a flag to indicate if the data is already in the form of genotype identifiers.</p>
</td></tr>
<tr><td><code id="pgc_+3A_with.id">with.id</code></td>
<td>
<p>a flag to indicate if the unique multilocus genotype identifier is generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a R port of the GENECOUNTING/PREPARE program which takes
an array of genotyep data and collapses individuals with the same multilocus
genotype. This function can also be used to prepare for the genotype table in testing
Hardy-Weinberg equilibrium.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> cdata the collapsed genotype data.
</p>
</li>
<li><p> wt the frequency weight.
</p>
</li>
<li><p> obscom the observed number of combinations or genotypes.
</p>
</li>
<li><p> idsave optional, available only if with.id = 1.
</p>
</li></ul>



<h3>Note</h3>

<p>Built on pgc.c.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Zhao JH, Sham PC (2003).
&ldquo;Generic number systems and haplotype analysis.&rdquo;
<em>Comput Methods Programs Biomed</em>, <b>70</b>(1), 1-9.
ISSN 0169-2607 (Print) 0169-2607, <a href="https://doi.org/10.1016/s0169-2607%2801%2900193-6">doi:10.1016/s0169-2607(01)00193-6</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genecounting">genecounting</a></code>, <code><a href="#topic+hwe.hardy">hwe.hardy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(gap.datasets)
data(hla)
x &lt;- hla[,3:8]

# do not handle missing data
y&lt;-pgc(x,handle.miss=0,with.id=1)
hla.gc&lt;-genecounting(y$cdata,y$wt)

# handle missing but with multilocus genotype identifier
pgc(x,handle.miss=1,with.id=1)

# handle missing data with no identifier
pgc(x,handle.miss=1,with.id=0)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.hap.score'>Plot haplotype frequencies versus haplotype score statistics</h2><span id='topic+plot.hap.score'></span>

<h3>Description</h3>

<p>Method function to plot a class of type hap.score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hap.score'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.hap.score_+3A_x">x</code></td>
<td>
<p>The object returned from hap.score (which has class hap.score).</p>
</td></tr>
<tr><td><code id="plot.hap.score_+3A_...">...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.
</p>
<p>This is a plot method function used to plot haplotype frequencies on
the x-axis and haplotype-specific scores on the y-axis. Because
hap.score is a class, the generic plot function
can be used, which in turn calls this plot.hap.score function.
</p>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM,  Poland  GA (2002)
Score tests for association of traits with haplotypes when
linkage phase is ambiguous. Amer J Hum Genet 70:425-34
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hap.score">hap.score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
save &lt;- hap.score(y, geno, trait.type = "gaussian")

# Example illustrating generic plot function:
plot(save)

# Example illustrating specific method plot function:
plot.hap.score(save)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.hap.score'>Print a hap.score object</h2><span id='topic+print.hap.score'></span>

<h3>Description</h3>

<p>Method function to print a class of type hap.score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hap.score'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hap.score_+3A_x">x</code></td>
<td>
<p>The object returned from hap.score (which has class hap.score).</p>
</td></tr>
<tr><td><code id="print.hap.score_+3A_...">...</code></td>
<td>
<p>Optional argunents.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.
</p>
<p>This is a print method function used to print information from
hap.score class, with haplotype-specific information given in a
table. Because hap.score is a class, the generic print function
can be used, which in turn calls this print.hap.score function.
</p>


<h3>References</h3>

<p>Schaid DJ, Rowland CM, Tines DE, Jacobson RM, Poland  GA (2002)
Score tests for association of traits with haplotypes when
linkage phase is ambiguous. Amer J Hum Genet 70:425-34
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hap.score">hap.score</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
save &lt;- hap.score(y, geno, trait.type = "gaussian")

# Example illustrating generic print function:
print(save)

# Example illustrating specific method print function:
print.hap.score(save)

## End(Not run)

</code></pre>

<hr>
<h2 id='pvalue'>P value for a normal deviate</h2><span id='topic+pvalue'></span>

<h3>Description</h3>

<p>P value for a normal deviate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvalue(z, decimals = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pvalue_+3A_z">z</code></td>
<td>
<p>normal deviate.</p>
</td></tr>
<tr><td><code id="pvalue_+3A_decimals">decimals</code></td>
<td>
<p>number of decimal places.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>P value as a string variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvalue(-1.96)
</code></pre>

<hr>
<h2 id='qqfun'>Quantile-comparison plots</h2><span id='topic+qqfun'></span>

<h3>Description</h3>

<p>Quantile-comparison plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqfun(
  x,
  distribution = "norm",
  ylab = deparse(substitute(x)),
  xlab = paste(distribution, "quantiles"),
  main = NULL,
  las = par("las"),
  envelope = 0.95,
  labels = FALSE,
  col = palette()[4],
  lcol = palette()[2],
  xlim = NULL,
  ylim = NULL,
  lwd = 1,
  pch = 1,
  bg = palette()[4],
  cex = 0.4,
  line = c("quartiles", "robust", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqfun_+3A_x">x</code></td>
<td>
<p>vector of numeric values.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_distribution">distribution</code></td>
<td>
<p>root name of comparison distribution &ndash; e.g., <code>norm</code> for the normal distribution; <code>t</code> for the t-distribution.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_ylab">ylab</code></td>
<td>
<p>label for vertical (empirical quantiles) axis.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_xlab">xlab</code></td>
<td>
<p>label for horizontal (comparison quantiles) axis.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_main">main</code></td>
<td>
<p>label for plot.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_las">las</code></td>
<td>
<p>if <code>0</code>, ticks labels are drawn parallel to the axis; set to <code>1</code> for horizontal labels (see <code><a href="graphics.html#topic+par">graphics::par</a></code>).</p>
</td></tr>
<tr><td><code id="qqfun_+3A_envelope">envelope</code></td>
<td>
<p>confidence level for point-wise confidence envelope, or <code>FALSE</code> for no envelope.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_labels">labels</code></td>
<td>
<p>vector of point labels for interactive point identification, or <code>FALSE</code> for no labels.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_col">col</code></td>
<td>
<p>color for points; the default is the <em>fourth</em> entry in the current color palette (see <code><a href="grDevices.html#topic+palette">grDevices::palette</a></code> and <code><a href="graphics.html#topic+par">graphics::par</a></code>).</p>
</td></tr>
<tr><td><code id="qqfun_+3A_lcol">lcol</code></td>
<td>
<p>color for lines; the default is the <em>second</em> entry as above.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_xlim">xlim</code></td>
<td>
<p>the x limits (x1, x2) of the plot. Note that x1 &gt; x2 is allowed and leads to a reversed axis.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_lwd">lwd</code></td>
<td>
<p>line width; default is <code>1</code> (see <code><a href="graphics.html#topic+par">graphics::par</a></code>). Confidence envelopes are drawn at half this line width.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_pch">pch</code></td>
<td>
<p>plotting character for points; default is <code>1</code> (a circle, see <code><a href="graphics.html#topic+par">graphics::par</a></code>).</p>
</td></tr>
<tr><td><code id="qqfun_+3A_bg">bg</code></td>
<td>
<p>background color of points.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_cex">cex</code></td>
<td>
<p>factor for expanding the size of plotted symbols; the default is '.4.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_line">line</code></td>
<td>
<p><code>"quartiles"</code> to pass a line through the quartile-pairs, or <code>"robust"</code> for a robust-regression line; the latter uses the <code>rlm</code> function in the <code>MASS</code> package. Specifying <code>line = "none"</code> suppresses the line.</p>
</td></tr>
<tr><td><code id="qqfun_+3A_...">...</code></td>
<td>
<p>arguments such as <code>df</code> to be passed to the appropriate quantile function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots empirical quantiles of a variable against theoretical quantiles of a comparison distribution.
</p>
<p>Draws theoretical quantile-comparison plots for variables and for studentized residuals from a linear model. A comparison line is drawn on the plot either through the quartiles of the two distributions, or by robust regression.
</p>
<p>Any distribution for which quantile and density functions exist in R (with prefixes <code>q</code> and <code>d</code>, respectively) may be used. Studentized residuals are plotted against the appropriate t-distribution.
</p>
<p>This is adapted from <code><a href="car.html#topic+car-defunct">car::qq.plot</a></code> with different values for points and lines, more options, more transparent code and examples in the current setting. Another similar but sophisticated function is <code><a href="lattice.html#topic+qqmath">lattice::qqmath</a></code>.
</p>


<h3>Value</h3>

<p>These functions are used only for their side effect (to make a graph).
</p>


<h3>Author(s)</h3>

<p>John Fox, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Davison AC (2003).
<em>Statistical Models (Cambridge Series in Statistical and Probabilistic Mathematics)</em>.
Cambridge University Press (2003-08-04).
<a href="https://www.amazon.com/dp/B01A0BLZKM/">https://www.amazon.com/dp/B01A0BLZKM/</a>.
</p>
<p>Leemis LM, McQueston JT (2008).
&ldquo;Univariate Distribution Relationships.&rdquo;
<em>The American Statistician</em>, <b>62</b>(1), 45-53.
ISSN 0003-1305, <a href="https://doi.org/10.1198/000313008X270448">doi:10.1198/000313008X270448</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+qqnorm">stats::qqnorm</a></code>, <code><a href="#topic+qqunif">qqunif</a></code>, <code><a href="#topic+gcontrol2">gcontrol2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
p &lt;- runif(100)
alpha &lt;- 1/log(10)
qqfun(p,dist="unif")
qqfun(-log10(p),dist="exp",rate=alpha,pch=21)
library(car)
qq.plot(p,dist="unif")
qq.plot(-log10(p),dist="exp",rate=alpha)

library(lattice)
qqmath(~ -log10(p), distribution = function(p) qexp(p,rate=alpha))

## End(Not run)

</code></pre>

<hr>
<h2 id='qqunif'>Q-Q plot for uniformly distributed random variable</h2><span id='topic+qqunif'></span>

<h3>Description</h3>

<p>Q-Q plot for uniformly distributed random variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqunif(
  u,
  type = "unif",
  logscale = TRUE,
  base = 10,
  col = palette()[4],
  lcol = palette()[2],
  ci = FALSE,
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqunif_+3A_u">u</code></td>
<td>
<p>a vector of uniformly distributed random variables.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_type">type</code></td>
<td>
<p>string option to specify distribution: &quot;unif&quot;=uniform, &quot;exp&quot;=exponential.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_logscale">logscale</code></td>
<td>
<p>to use logscale.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_base">base</code></td>
<td>
<p>the base of the log function.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_col">col</code></td>
<td>
<p>color for points.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_lcol">lcol</code></td>
<td>
<p>color for the diagonal line.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_ci">ci</code></td>
<td>
<p>logical option to show confidence interval.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_alpha">alpha</code></td>
<td>
<p>1-confidence level, e.g., 0.05.</p>
</td></tr>
<tr><td><code id="qqunif_+3A_...">...</code></td>
<td>
<p>other options as appropriae for the qqplot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces Q-Q plot for a random variable following uniform distribution with or
without using log-scale. Note that the log-scale is by default for type &quot;exp&quot;, which is a plot based on
exponential order statistics. This appears to be more appropriate than the commonly used procedure whereby
the expected value of uniform order statistics is directly log-transformed.
</p>


<h3>Value</h3>

<p>The returned value is a list with components of a qqplot:
</p>

<ul>
<li><p> x expected value for uniform order statistics or its -log(,base) counterpart.
</p>
</li>
<li><p> y observed value or its -log(,base) counterpart.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Balakrishnan N, Nevzorov VB (2003).
<em>A Primer on Statistical Distributions</em>.
Wiley, Hoboken, N.J.
ISBN 9780471427988, <a href="https://www.amazon.com/dp/B011SJAWXG/">https://www.amazon.com/dp/B011SJAWXG/</a>.
</p>
<p>Casella G, Berger RL (2002).
<em>Statistical Inference</em>, 2 edition.
Duxbury.
ISBN 978-0-534-24312-8, <a href="https://www.amazon.com/dp/7111109457/">https://www.amazon.com/dp/7111109457/</a>.
</p>
<p>Davison AC (2003).
<em>Statistical Models (Cambridge Series in Statistical and Probabilistic Mathematics)</em>.
Cambridge University Press (2003-08-04).
<a href="https://www.amazon.com/dp/B01A0BLZKM/">https://www.amazon.com/dp/B01A0BLZKM/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qqfun">qqfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Q-Q Plot for 1000 U(0,1) r.v., marking those &lt;= 1e-5
u_obs &lt;- runif(1000)
r &lt;- qqunif(u_obs,pch=21,bg="blue",bty="n")
u_exp &lt;- r$y
hits &lt;- u_exp &gt;= 2.30103
points(r$x[hits],u_exp[hits],pch=21,bg="green")
legend("topleft",sprintf("GC.lambda=\

## End(Not run)

</code></pre>

<hr>
<h2 id='qtl2dplot'>2D QTL plot</h2><span id='topic+qtl2dplot'></span>

<h3>Description</h3>

<p>2D QTL plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtl2dplot(
  d,
  chrlen = gap::hg19,
  snp_name = "SNP",
  snp_chr = "Chr",
  snp_pos = "bp",
  gene_chr = "p.chr",
  gene_start = "p.start",
  gene_end = "p.end",
  trait = "p.target.short",
  gene = "p.gene",
  TSS = FALSE,
  cis = "cis",
  value = "log10p",
  plot = TRUE,
  cex.labels = 0.6,
  cex.points = 0.6,
  xlab = "QTL position",
  ylab = "Gene position"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtl2dplot_+3A_d">d</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_chrlen">chrlen</code></td>
<td>
<p>lengths of chromosomes for specific build: hg18, hg19, hg38.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_snp_name">snp_name</code></td>
<td>
<p>variant name.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_snp_chr">snp_chr</code></td>
<td>
<p>variant chromosome.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_snp_pos">snp_pos</code></td>
<td>
<p>variant position.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_gene_chr">gene_chr</code></td>
<td>
<p>gene chromosome.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_gene_start">gene_start</code></td>
<td>
<p>gene start position.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_gene_end">gene_end</code></td>
<td>
<p>gene end position.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_trait">trait</code></td>
<td>
<p>trait name.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_gene">gene</code></td>
<td>
<p>gene name.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_tss">TSS</code></td>
<td>
<p>to use TSS when TRUE.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_cis">cis</code></td>
<td>
<p>cis variant when TRUE.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_value">value</code></td>
<td>
<p>A specific value to show.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_plot">plot</code></td>
<td>
<p>to plot when TRUE.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_cex.labels">cex.labels</code></td>
<td>
<p>Axis label extension factor.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_cex.points">cex.points</code></td>
<td>
<p>Data point extension factor.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_xlab">xlab</code></td>
<td>
<p>X-axis title.</p>
</td></tr>
<tr><td><code id="qtl2dplot_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis title.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is both used as its own for a 2d plot and/or generate data for a plotly counterpart.
</p>


<h3>Value</h3>

<p>positional information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
INF &lt;- Sys.getenv("INF")
d &lt;- read.csv(file.path(INF,"work","INF1.merge.cis.vs.trans"),as.is=TRUE)
r &lt;- qtl2dplot(d)

## End(Not run)
</code></pre>

<hr>
<h2 id='qtl2dplotly'>2D QTL plotly</h2><span id='topic+qtl2dplotly'></span>

<h3>Description</h3>

<p>2D QTL plotly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtl2dplotly(
  d,
  chrlen = gap::hg19,
  qtl.id = "SNPid:",
  qtl.prefix = "QTL:",
  qtl.gene = "Gene:",
  target.type = "Protein",
  TSS = FALSE,
  xlab = "QTL position",
  ylab = "Gene position",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtl2dplotly_+3A_d">d</code></td>
<td>
<p>Data in qtl2dplot() format.</p>
</td></tr>
<tr><td><code id="qtl2dplotly_+3A_chrlen">chrlen</code></td>
<td>
<p>Lengths of chromosomes for specific build: hg18, hg19, hg38.</p>
</td></tr>
<tr><td><code id="qtl2dplotly_+3A_qtl.id">qtl.id</code></td>
<td>
<p>QTL id.</p>
</td></tr>
<tr><td><code id="qtl2dplotly_+3A_qtl.prefix">qtl.prefix</code></td>
<td>
<p>QTL prefix.</p>
</td></tr>
<tr><td><code id="qtl2dplotly_+3A_qtl.gene">qtl.gene</code></td>
<td>
<p>QTL gene.</p>
</td></tr>
<tr><td><code id="qtl2dplotly_+3A_target.type">target.type</code></td>
<td>
<p>Type of target, e.g., protein.</p>
</td></tr>
<tr><td><code id="qtl2dplotly_+3A_tss">TSS</code></td>
<td>
<p>to use TSS when TRUE.</p>
</td></tr>
<tr><td><code id="qtl2dplotly_+3A_xlab">xlab</code></td>
<td>
<p>X-axis title.</p>
</td></tr>
<tr><td><code id="qtl2dplotly_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis title.</p>
</td></tr>
<tr><td><code id="qtl2dplotly_+3A_...">...</code></td>
<td>
<p>Additional arguments, e.g., target, log10p, to qtl2dplot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotly figure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
INF &lt;- Sys.getenv("INF")
d &lt;- read.csv(file.path(INF,"work","INF1.merge.cis.vs.trans"),as.is=TRUE)
r &lt;- qtl2dplotly(d)
htmlwidgets::saveWidget(r,file=file.path(INF,"INF1.qtl2dplotly.html"))
r

## End(Not run)
</code></pre>

<hr>
<h2 id='qtl3dplotly'>3D QTL plot</h2><span id='topic+qtl3dplotly'></span>

<h3>Description</h3>

<p>3D QTL plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtl3dplotly(
  d,
  chrlen = gap::hg19,
  zmax = 300,
  qtl.id = "SNPid:",
  qtl.prefix = "QTL:",
  qtl.gene = "Gene:",
  target.type = "Protein",
  TSS = FALSE,
  xlab = "QTL position",
  ylab = "Gene position",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtl3dplotly_+3A_d">d</code></td>
<td>
<p>Data in qtl2d() format.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_chrlen">chrlen</code></td>
<td>
<p>Lengths of chromosomes for specific build: hg18, hg19, hg38.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_zmax">zmax</code></td>
<td>
<p>Maximum value (e.g., -log10p) to truncate, above which they would be set to this value.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_qtl.id">qtl.id</code></td>
<td>
<p>QTL id.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_qtl.prefix">qtl.prefix</code></td>
<td>
<p>QTL prefix.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_qtl.gene">qtl.gene</code></td>
<td>
<p>QTL target gene.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_target.type">target.type</code></td>
<td>
<p>Type of target, e.g., protein.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_tss">TSS</code></td>
<td>
<p>to use TSS when TRUE.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_xlab">xlab</code></td>
<td>
<p>X-axis title.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis title.</p>
</td></tr>
<tr><td><code id="qtl3dplotly_+3A_...">...</code></td>
<td>
<p>Additional arguments, e.g., to qtl2dplot().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotly figure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
suppressMessages(library(dplyr))
INF &lt;- Sys.getenv("INF")
d &lt;- read.csv(file.path(INF,"work","INF1.merge.cis.vs.trans"),as.is=TRUE) %&gt;%
     mutate(log10p=-log10p)
r &lt;- qtl3dplotly(d,zmax=300)
htmlwidgets::saveWidget(r,file=file.path(INF,"INF1.qtl3dplotly.html"))
r

## End(Not run)
</code></pre>

<hr>
<h2 id='qtlClassifier'>A QTL cis/trans classifier</h2><span id='topic+qtlClassifier'></span>

<h3>Description</h3>

<p>A QTL cis/trans classifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtlClassifier(geneSNP, SNPPos, genePos, radius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtlClassifier_+3A_genesnp">geneSNP</code></td>
<td>
<p>data.frame with columns on gene, SNP and biomarker (e.g., expression, protein).</p>
</td></tr>
<tr><td><code id="qtlClassifier_+3A_snppos">SNPPos</code></td>
<td>
<p>data.frame containing SNP, chromosome and position.</p>
</td></tr>
<tr><td><code id="qtlClassifier_+3A_genepos">genePos</code></td>
<td>
<p>data.frame containing gene, chromosome, start and end positions.</p>
</td></tr>
<tr><td><code id="qtlClassifier_+3A_radius">radius</code></td>
<td>
<p>flanking distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function obtains QTL (simply called SNP here) cis/trans classification based on gene positions.
</p>


<h3>Value</h3>

<p>It returns a geneSNP-prefixed data.frame with the following columns:
</p>

<ul>
<li><p> geneChrom gene chromosome.
</p>
</li>
<li><p> geneStart gene start.
</p>
</li>
<li><p> geneEnd gene end.
</p>
</li>
<li><p> SNPChrom pQTL chromosome.
</p>
</li>
<li><p> SNPPos pQTL position.
</p>
</li>
<li><p> Type cis/trans labels.
</p>
</li></ul>



<h3>Note</h3>

<p>This is adapted from iBMQ/eqtlClassifier as an xQTL (x=e, p, me, ...) classifier.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cis.vs.trans.classification">cis.vs.trans.classification</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  merged &lt;- read.delim("INF1.merge",as.is=TRUE)
  hits &lt;- merge(merged[c("CHR","POS","MarkerName","prot","log10p")],
                inf1[c("prot","uniprot")],by="prot")
  names(hits) &lt;- c("prot","Chr","bp","SNP","log10p","uniprot")

  options(width=200)
  geneSNP &lt;- merge(hits[c("prot","SNP","log10p")],
                   inf1[c("prot","gene")],by="prot")[c("gene","SNP","prot","log10p")]
  SNPPos &lt;- hits[c("SNP","Chr","bp")]
  genePos &lt;- inf1[c("gene","chr","start","end")]
  cvt &lt;- qtlClassifier(geneSNP,SNPPos,genePos,1e6)
  cvt
  cistrans &lt;- cis.vs.trans.classification(hits,inf1,"uniprot")
  cis.vs.trans &lt;- with(cistrans,data)
  cistrans.check &lt;- merge(cvt[c("gene","SNP","Type")],cis.vs.trans[c("p.gene","SNP","cis.trans")],
                          by.x=c("gene","SNP"),by.y=c("p.gene","SNP"))
  with(cistrans.check,table(Type,cis.trans))

## End(Not run)

</code></pre>

<hr>
<h2 id='read.ms.output'>A utility function to read ms output</h2><span id='topic+read.ms.output'></span>

<h3>Description</h3>

<p>A utility function to read ms output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ms.output(
  msout,
  is.file = TRUE,
  xpose = TRUE,
  verbose = TRUE,
  outfile = NULL,
  outfileonly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.ms.output_+3A_msout">msout</code></td>
<td>
<p>an ms output.</p>
</td></tr>
<tr><td><code id="read.ms.output_+3A_is.file">is.file</code></td>
<td>
<p>a flag indicating ms output as a system file or an R object.</p>
</td></tr>
<tr><td><code id="read.ms.output_+3A_xpose">xpose</code></td>
<td>
<p>a flag to obtain the tranposed format as it is (when TRUE).</p>
</td></tr>
<tr><td><code id="read.ms.output_+3A_verbose">verbose</code></td>
<td>
<p>when TRUE, display on screen every 1000 for large nsam.</p>
</td></tr>
<tr><td><code id="read.ms.output_+3A_outfile">outfile</code></td>
<td>
<p>to save the haplotypes in a tab-delimited ASCII file.</p>
</td></tr>
<tr><td><code id="read.ms.output_+3A_outfileonly">outfileonly</code></td>
<td>
<p>to reset gametes to NA when nsam/nreps is very large and is useful with outfile.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads in the output of the program ms, a program to generate
samples under a variety of neutral models.
</p>
<p>The argument indicates either a file name or a vector of character strings,
one string for each line of the output of ms. As with the second case, it
is appropriate with system(,intern=TRUE), see example below.
</p>


<h3>Value</h3>

<p>The returned value is a list storing the results:
</p>

<ul>
<li><p> call system call to ms.
</p>
</li>
<li><p> seed random number seed to ms.
</p>
</li>
<li><p> nsam number of copies of the locus in each sample.
</p>
</li>
<li><p> nreps the number of independent samples to generate.
</p>
</li>
<li><p> segsites a vector of the numbers of segregating sites.
</p>
</li>
<li><p> times vectors of time to most recent ancester (TMRCA) and total tree lengths.
</p>
</li>
<li><p> positions positions of polymorphic sites on a scale of (0,1).
</p>
</li>
<li><p> gametes a list of haplotype arrays.
</p>
</li>
<li><p> probs the probability of the specified number of segregating sites
given the genealogical history of the sample and the value to -t option.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>D Davison, RR Hudson, JH Zhao
</p>


<h3>References</h3>

<p>Hudson RR (2002).
&ldquo;Generating samples under a Wright-Fisher neutral model of genetic variation.&rdquo;
<em>Bioinformatics</em>, <b>18</b>(2), 337-8.
ISSN 1367-4803 (Print) 1367-4803, <a href="https://doi.org/10.1093/bioinformatics/18.2.337">doi:10.1093/bioinformatics/18.2.337</a>.
</p>
<p>Press WH, SA Teukolsky, WT Vetterling, BP Flannery (1992). Numerical Recipes in C. Cambridge University Press, Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Assuming ms is on the path

system("ms 5 4 -s 5 &gt; ms.out")
msout1 &lt;- read.ms.output("ms.out")

system("ms 50 4 -s 5 &gt; ms.out")
msout2 &lt;- read.ms.output("ms.out",outfile="out",outfileonly=TRUE)

msout &lt;- system("ms 5 4 -s 5 -L", intern=TRUE)
msout3 &lt;- read.ms.output(msout,FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='ReadGRM'>A function to read GRM file</h2><span id='topic+ReadGRM'></span>

<h3>Description</h3>

<p>A function to read GRM file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadGRM(prefix = 51)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadGRM_+3A_prefix">prefix</code></td>
<td>
<p>file root.</p>
</td></tr>
</table>

<hr>
<h2 id='ReadGRMBin'>A function to read GRM binary files</h2><span id='topic+ReadGRMBin'></span>

<h3>Description</h3>

<p>A function to read GRM binary files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadGRMBin(prefix, AllN = FALSE, size = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadGRMBin_+3A_prefix">prefix</code></td>
<td>
<p>file root.</p>
</td></tr>
<tr><td><code id="ReadGRMBin_+3A_alln">AllN</code></td>
<td>
<p>a logical variable.</p>
</td></tr>
<tr><td><code id="ReadGRMBin_+3A_size">size</code></td>
<td>
<p>size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modified from GCTA documentation
</p>

<hr>
<h2 id='revStrand'>Allele on the reverse strand</h2><span id='topic+revStrand'></span>

<h3>Description</h3>

<p>Allele on the reverse strand
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revStrand(allele)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revStrand_+3A_allele">allele</code></td>
<td>
<p>Allele to reverse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function obtains allele on the reverse strand.
</p>


<h3>Value</h3>

<p>Allele on the reverse strand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  alleles &lt;- c("a","c","G","t")
  reverse_strand(alleles)

## End(Not run)
</code></pre>

<hr>
<h2 id='runshinygap'>Start shinygap</h2><span id='topic+runshinygap'></span>

<h3>Description</h3>

<p>Start shinygap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runshinygap(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runshinygap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the 'runApp' function from the 'shiny' package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function starts the interactive 'shinygap' shiny web application that allows for flexible model specification.
</p>
<p>The 'shiny' based web application allows for flexible model specification for the implemented study designs.
</p>


<h3>Value</h3>

<p>These are design specific.
</p>

<hr>
<h2 id='s2k'>Statistics for 2 by K table</h2><span id='topic+s2k'></span>

<h3>Description</h3>

<p>Statistics for 2 by K table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2k(y1, y2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2k_+3A_y1">y1</code></td>
<td>
<p>a vector containing the first row of a 2 by K contingency table.</p>
</td></tr>
<tr><td><code id="s2k_+3A_y2">y2</code></td>
<td>
<p>a vector containing the second row of a 2 by K contingency table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates one-to-others and maximum accumulated chi-squared
statistics for a 2 by K contingency table.
</p>


<h3>Value</h3>

<p>The returned value is a list containing:
</p>

<ul>
<li><p> x2a the one-to-other chisquare.
</p>
</li>
<li><p> x2b the maximum accumulated chisquare.
</p>
</li>
<li><p> col1 the column index for x2a.
</p>
</li>
<li><p> col2 the column index for x2b.
</p>
</li>
<li><p> p the corresponding p value.
</p>
</li></ul>



<h3>Note</h3>

<p>The lengths of y1 and y2 should be the same.
</p>


<h3>Author(s)</h3>

<p>Chihiro Hirotsu, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Hirotsu C, Aoki S, Inada T, Kitao Y (2001).
&ldquo;An exact test for the association between the disease and alleles at highly polymorphic loci with particular interest in the haplotype analysis.&rdquo;
<em>Biometrics</em>, <b>57</b>, 769-778.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# an example from Mike Neale
# termed 'ugly' contingency table by Patrick Sullivan
y1 &lt;- c(2,15,16,35,132,30,25,7,12,24,10,10,0)
y2 &lt;- c(0, 6,31,49,120,27,15,8,14,25, 3, 9,3)

result &lt;- s2k(y1,y2)

## End(Not run)
</code></pre>

<hr>
<h2 id='sentinels'>Sentinel identification from GWAS summary statistics</h2><span id='topic+sentinels'></span>

<h3>Description</h3>

<p>Sentinel identification from GWAS summary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sentinels(
  p,
  pid,
  st,
  debug = FALSE,
  flanking = 1e+06,
  chr = "Chrom",
  pos = "End",
  b = "Effect",
  se = "StdErr",
  log_p = NULL,
  snp = "MarkerName",
  sep = ","
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sentinels_+3A_p">p</code></td>
<td>
<p>an object containing GWAS summary statistics.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_pid">pid</code></td>
<td>
<p>a phenotype (e.g., protein) name in pGWAS.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_st">st</code></td>
<td>
<p>row number as in p.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_debug">debug</code></td>
<td>
<p>a flag to show the actual data.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_flanking">flanking</code></td>
<td>
<p>the width of flanking region.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_chr">chr</code></td>
<td>
<p>Chromosome name.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_pos">pos</code></td>
<td>
<p>Position.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_b">b</code></td>
<td>
<p>Effect size.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_se">se</code></td>
<td>
<p>Standard error.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_log_p">log_p</code></td>
<td>
<p>log(P).</p>
</td></tr>
<tr><td><code id="sentinels_+3A_snp">snp</code></td>
<td>
<p>Marker name.</p>
</td></tr>
<tr><td><code id="sentinels_+3A_sep">sep</code></td>
<td>
<p>field delimitor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts an object containing GWAS summary statistics for
signal identification as defined by flanking regions. As the associate P value
could be extremely small, the effect size and its standard error are used.
</p>
<p>A distance-based approach was consequently used and reframed as an algorithm here. It takes as input signals multiple correlated variants in
particular region(s) which reach genomewide significance and output three types of sentinels in a region-based manner. For a given protein and a
chromosome, the algorithm proceeds as follows:
</p>
<p>Algorithm sentinels
</p>
<p>Step 1. for a particular collection of genomewide significant variants on a chromosome, the width of the region is calculated according to the start
and end chromosomal positions and if it is smaller than the flanking distance, the variant with the smallest P value is taken as sentinel (I)
otherwise goes to step 2.
</p>
<p>Step 2. The variant at step 1 is only a candidate and a flanking region is generated. If such a region contains no variant the candidate is recorded
as sentinel (II) and a new iteration starts from the variant next to the flanking region.
</p>
<p>Step 3.  When the flanking is possible at step 2 but the P value is still larger than the candidate at step 2, the candidate is again recorded as
sentinel (III) but next iteration starts from the variant just after the variant at the end position; otherwise the variant is updated as a new
candidate where the next iteration starts.
</p>
<p>Note Type I signals are often seen from variants in strong LD at a cis region, type II results seen when a chromosome contains two trans signals,
type III results seen if there are multiple trans signals.
</p>
<p>Typically, input to the function are variants reaching certain level of significance and the functtion identifies minimum p value at the flanking
interval; in the case of another variant in the flanking window has smaller p value it will be used instead.
</p>
<p>For now key variables in p are &quot;MarkerName&quot;, &quot;End&quot;, &quot;Effect&quot;, &quot;StdErr&quot;, &quot;P.value&quot;, where &quot;End&quot; is as in a bed file indicating marker position,
and the function is set up such that row names are numbered as 1:nrow(p); see example below. When log_p is specified, log(P) is used instead, which
is appropriate with output from METAL with LOGPVALUE ON. In this case, the column named log(P) in the output is actually log10(P).
</p>


<h3>Value</h3>

<p>The function give screen output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 ## OPG as a positive control in our pGWAS
 require(gap.datasets)
 data(OPG)
 p &lt;- reshape::rename(OPGtbl, c(Chromosome="Chrom", Position="End"))
 chrs &lt;- with(p, unique(Chrom))
 for(chr in chrs)
 {
   ps &lt;- subset(p[c("Chrom","End","MarkerName","Effect","StdErr")], Chrom==chr)
   row.names(ps) &lt;- 1:nrow(ps)
   sentinels(ps, "OPG", 1)
 }
 subset(OPGrsid,MarkerName=="chr8:120081031_C_T")
 subset(OPGrsid,MarkerName=="chr17:26694861_A_G")
 ## log(P)
 p &lt;- within(p, {logp &lt;- log(P.value)})
 for(chr in chrs)
 {
   ps &lt;- subset(p[c("Chrom","End","MarkerName","logp")], Chrom==chr)
   row.names(ps) &lt;- 1:nrow(ps)
   sentinels(ps, "OPG", 1, log_p="logp")
 }
 ## to obtain variance explained
 tbl &lt;- within(OPGtbl, chi2n &lt;- (Effect/StdErr)^2/N)
 s &lt;- with(tbl, aggregate(chi2n,list(prot),sum))
 names(s) &lt;- c("prot", "h2")
 sd &lt;- with(tbl, aggregate(chi2n,list(prot),sd))
 names(sd) &lt;- c("p1","sd")
 m &lt;- with(tbl, aggregate(chi2n,list(prot),length))
 names(m) &lt;- c("p2","m")
 h2 &lt;- cbind(s,sd,m)
 ord &lt;- with(h2, order(h2))
 sink("h2.dat")
 print(h2[ord, c("prot","h2","sd","m")], row.names=FALSE)
 sink()
 png("h2.png", res=300, units="in", width=12, height=8)
 np &lt;- nrow(h2)
 with(h2[ord,], {
     plot(h2, cex=0.4, pch=16, xaxt="n", xlab="protein", ylab=expression(h^2))
     xtick &lt;- seq(1, np, by=1)
     axis(side=1, at=xtick, labels = FALSE)
     text(x=xtick, par("usr")[3],labels = prot, srt = 75, pos = 1, xpd = TRUE, cex=0.5)
 })
 dev.off()
 write.csv(tbl,file="INF1.csv",quote=FALSE,row.names=FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='snpHWE'>Functions for single nucleotide polymorphisms</h2><span id='topic+snpHWE'></span><span id='topic+PARn'></span><span id='topic+snpPVE'></span><span id='topic+snpPAR'></span>

<h3>Description</h3>

<p>These are a set of functions specifically for single nucleotide
polymorphisms (SNPs), which are biallelic markers. This is
particularly relevant to the genomewide association studies (GWAS)
using GeneChips and in line with the classic generalised single-locus
model. snpHWE is from Abecasis's website and yet to be adapted for
chromosome X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snpHWE(g)

PARn(p, RRlist)

snpPVE(beta, se, N)

snpPAR(RR, MAF, unit = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snpHWE_+3A_g">g</code></td>
<td>
<p>Observed genotype vector.</p>
</td></tr>
<tr><td><code id="snpHWE_+3A_p">p</code></td>
<td>
<p>genotype frequencies.</p>
</td></tr>
<tr><td><code id="snpHWE_+3A_rrlist">RRlist</code></td>
<td>
<p>A list of RRs.</p>
</td></tr>
<tr><td><code id="snpHWE_+3A_beta">beta</code></td>
<td>
<p>Regression coefficient.</p>
</td></tr>
<tr><td><code id="snpHWE_+3A_se">se</code></td>
<td>
<p>Standard error for beta.</p>
</td></tr>
<tr><td><code id="snpHWE_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="snpHWE_+3A_rr">RR</code></td>
<td>
<p>Relative risk.</p>
</td></tr>
<tr><td><code id="snpHWE_+3A_maf">MAF</code></td>
<td>
<p>Minar allele frequency.</p>
</td></tr>
<tr><td><code id="snpHWE_+3A_unit">unit</code></td>
<td>
<p>Unit to exponentiate for homozygote.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>snpHWE</code> gives an exact Hardy-Weinberg Equilibrium (HWE) test and it return -1 in the case of misspecification of genotype counts.
</p>
<p><code>snpPAR</code> calculates the the population attributable risk (PAR) for a particular SNP.
Internally, it calls for an internal function PARn, given a
set of frequencies and associate relative risks (RR). Other
2x2 table statistics familiar to epidemiologists can be added when
necessary.
</p>
<p><code>snpPVE</code> provides proportion of variance explained (PVE) estimate based on the linear regression coefficient and standard error.
For logistic regression, we can have similar idea for log(OR) and log(SE(OR)).
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao, Shengxu Li
</p>

<hr>
<h2 id='snptest_sample'>A utility to generate SNPTEST sample file</h2><span id='topic+snptest_sample'></span>

<h3>Description</h3>

<p>A utility to generate SNPTEST sample file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snptest_sample(
  data,
  sample_file = "snptest.sample",
  ID_1 = "ID_1",
  ID_2 = "ID_2",
  missing = "missing",
  C = NULL,
  D = NULL,
  P = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snptest_sample_+3A_data">data</code></td>
<td>
<p>Data to be used.</p>
</td></tr>
<tr><td><code id="snptest_sample_+3A_sample_file">sample_file</code></td>
<td>
<p>Output filename.</p>
</td></tr>
<tr><td><code id="snptest_sample_+3A_id_1">ID_1</code></td>
<td>
<p>ID_1 as in the sample file.</p>
</td></tr>
<tr><td><code id="snptest_sample_+3A_id_2">ID_2</code></td>
<td>
<p>ID_2 as in the sample file.</p>
</td></tr>
<tr><td><code id="snptest_sample_+3A_missing">missing</code></td>
<td>
<p>Missing data column.</p>
</td></tr>
<tr><td><code id="snptest_sample_+3A_c">C</code></td>
<td>
<p>Continuous variables.</p>
</td></tr>
<tr><td><code id="snptest_sample_+3A_d">D</code></td>
<td>
<p>Discrete variables.</p>
</td></tr>
<tr><td><code id="snptest_sample_+3A_p">P</code></td>
<td>
<p>Phenotypic variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output file in SNPTEST's sample format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d &lt;- data.frame(ID_1=1,ID_2=1,missing=0,PC1=1,PC2=2,D1=1,P1=10)
snptest_sample(d,C=paste0("PC",1:2),D=paste0("D",1:1),P=paste0("P",1:1))

## End(Not run)
</code></pre>

<hr>
<h2 id='tscc'>Power calculation for two-stage case-control design</h2><span id='topic+tscc'></span>

<h3>Description</h3>

<p>Power calculation for two-stage case-control design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tscc(model, GRR, p1, n1, n2, M, alpha.genome, pi.samples, pi.markers, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tscc_+3A_model">model</code></td>
<td>
<p>any in c(&quot;multiplicative&quot;,&quot;additive&quot;,&quot;dominant&quot;,&quot;recessive&quot;).</p>
</td></tr>
<tr><td><code id="tscc_+3A_grr">GRR</code></td>
<td>
<p>genotype relative risk.</p>
</td></tr>
<tr><td><code id="tscc_+3A_p1">p1</code></td>
<td>
<p>the estimated risk allele frequency in cases.</p>
</td></tr>
<tr><td><code id="tscc_+3A_n1">n1</code></td>
<td>
<p>total number of cases.</p>
</td></tr>
<tr><td><code id="tscc_+3A_n2">n2</code></td>
<td>
<p>total number of controls.</p>
</td></tr>
<tr><td><code id="tscc_+3A_m">M</code></td>
<td>
<p>total number of markers.</p>
</td></tr>
<tr><td><code id="tscc_+3A_alpha.genome">alpha.genome</code></td>
<td>
<p>false positive rate at genome level.</p>
</td></tr>
<tr><td><code id="tscc_+3A_pi.samples">pi.samples</code></td>
<td>
<p>sample% to be genotyped at stage 1.</p>
</td></tr>
<tr><td><code id="tscc_+3A_pi.markers">pi.markers</code></td>
<td>
<p>markers% to be selected (also used as the false positive rate at stage 1).</p>
</td></tr>
<tr><td><code id="tscc_+3A_k">K</code></td>
<td>
<p>the population prevalence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives power estimates for two-stage case-control design for genetic association.
</p>
<p>The false positive rates are calculated as follows,
</p>
<p style="text-align: center;"><code class="reqn">P(|z1|&gt;C1)P(|z2|&gt;C2,sign(z1)=sign(z2))</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">P(|z1|&gt;C1)P(|zj|&gt;Cj||z1|&gt;C1)</code>
</p>

<p>for replication-based and joint analyses, respectively; where C1, C2, and Cj
are threshoulds at stages 1, 2 replication and joint analysis,
</p>
<p style="text-align: center;"><code class="reqn">z1 = z(p1,p2,n1,n2,pi.samples)</code>
</p>

<p style="text-align: center;"><code class="reqn">z2 = z(p1,p2,n1,n2,1-pi.samples)</code>
</p>

<p style="text-align: center;"><code class="reqn">zj = sqrt(pi.samples)*z1+sqrt(1-pi.samples)*z2</code>
</p>



<h3>Value</h3>

<p>The returned value is a list containing a copy of the input plus output as follows,
</p>

<ul>
<li><p> model any in c(&quot;multiplicative&quot;,&quot;additive&quot;,&quot;dominant&quot;,&quot;recessive&quot;).
</p>
</li>
<li><p> GRR genotype relative risk.
</p>
</li>
<li><p> p1 the estimated risk allele frequency in cases.
</p>
</li>
<li><p> pprime expected risk allele frequency in cases.
</p>
</li>
<li><p> p expected risk allele frequency in controls.
</p>
</li>
<li><p> n1 total number of cases.
</p>
</li>
<li><p> n2 total number of controls.
</p>
</li>
<li><p> M total number of markers.
</p>
</li>
<li><p> alpha.genome false positive rate at genome level.
</p>
</li>
<li><p> pi.samples sample% to be genotyped at stage 1.
</p>
</li>
<li><p> pi.markers markers% to be selected (also used as the false positive rate at stage 1).
</p>
</li>
<li><p> K the population prevalence.
</p>
</li>
<li><p> C threshoulds for no stage, stage 1, stage 2, joint analysis.
</p>
</li>
<li><p> power power corresponding to C.
</p>
</li></ul>



<h3>Note</h3>

<p><code>solve.skol</code> is adapted from CaTS.
</p>


<h3>Author(s)</h3>

<p>Jing Hua Zhao
</p>


<h3>References</h3>

<p>Skol AD, Scott LJ, Abecasis GR, Boehnke M (2006).
&ldquo;Joint analysis is more efficient than replication-based analysis for two-stage genome-wide association studies.&rdquo;
<em>Nat Genet</em>, <b>38</b>(2), 209-13.
ISSN 1061-4036 (Print) 1061-4036, <a href="https://doi.org/10.1038/ng1706">doi:10.1038/ng1706</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
K &lt;- 0.1
p1 &lt;- 0.4
n1 &lt;- 1000
n2 &lt;- 1000 
M &lt;- 300000
alpha.genome &lt;- 0.05
GRR &lt;- 1.4
p1 &lt;- 0.4
pi.samples &lt;- 0.2
pi.markers &lt;- 0.1

options(echo=FALSE)
cat("sample%,marker%,GRR,(thresholds x 4)(power estimates x 4)","\n")
for(GRR in c(1.3,1.35,1.40))
{
   cat("\n")
   for(pi.samples in c(1.0,0.5,0.4,0.3,0.2))
   {
      if(pi.samples==1.0) s &lt;- 1.0
      else s &lt;- c(0.1,0.05,0.01)
      for(pi.markers in s)
      {
        x &lt;- tscc("multiplicative",GRR,p1,n1,n2,M,alpha.genome,
                  pi.samples,pi.markers,K)
        l &lt;- c(pi.samples,pi.markers,GRR,x$C,x$power)
        l &lt;- sprintf("%.2f %.2f %.2f, %.2f %.2f %.2f %.2f, %.2f %.2f %.2f %.2f",
                     l[1],l[2],l[3],l[4],l[5],l[6],l[7],l[8],l[9],l[10],l[11])
        cat(l,"\n")
      }
      cat("\n")
   }
}
options(echo=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='whscore'>Whittemore-Halpern scores for allele-sharing</h2><span id='topic+whscore'></span>

<h3>Description</h3>

<p>Whittemore-Halpern scores for allele-sharing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whscore(allele, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whscore_+3A_allele">allele</code></td>
<td>
<p>a matrix of alleles of affected pedigree members.</p>
</td></tr>
<tr><td><code id="whscore_+3A_type">type</code></td>
<td>
<p>0 = pairs, 1 = all.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allele sharing score statistics.
</p>


<h3>Value</h3>

<p>The returned value is the value of score statistic.
</p>


<h3>Note</h3>

<p>adapted from GENEHUNTER.
</p>


<h3>Author(s)</h3>

<p>Leonid Kruglyak, Jing Hua Zhao
</p>


<h3>References</h3>

<p>Kruglyak L, Daly MJ, Reeve-Daly MP, Lander ES (1996).
&ldquo;Parametric and nonparametric linkage analysis: a unified multipoint approach.&rdquo;
<em>Am J Hum Genet</em>, <b>58</b>(6), 1347-63.
ISSN 0002-9297 (Print) 0002-9297.
</p>
<p>Whittemore AS, Halpern J (1994).
&ldquo;A class of tests for linkage using affected pedigree members.&rdquo;
<em>Biometrics</em>, <b>50</b>(1), 118-27.
ISSN 0006-341X (Print) 0006-341x.
</p>
<p>Whittemore AS, Halpern J (1994).
&ldquo;Probability of gene identity by descent: computation and applications.&rdquo;
<em>Biometrics</em>, <b>50</b>(1), 109-17.
ISSN 0006-341X (Print) 0006-341x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
c&lt;-matrix(c(1,1,1,2,2,2),ncol=2)
whscore(c,type=1)
whscore(c,type=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='WriteGRM'>A function to write GRM file</h2><span id='topic+WriteGRM'></span>

<h3>Description</h3>

<p>A function to write GRM file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteGRM(prefix = 51, id, N, GRM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WriteGRM_+3A_prefix">prefix</code></td>
<td>
<p>file root.</p>
</td></tr>
<tr><td><code id="WriteGRM_+3A_id">id</code></td>
<td>
<p>id.</p>
</td></tr>
<tr><td><code id="WriteGRM_+3A_n">N</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="WriteGRM_+3A_grm">GRM</code></td>
<td>
<p>a GRM.</p>
</td></tr>
</table>

<hr>
<h2 id='WriteGRMBin'>A function to write GRM binary file</h2><span id='topic+WriteGRMBin'></span>

<h3>Description</h3>

<p>A function to write GRM binary file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteGRMBin(prefix, grm, N, id, size = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WriteGRMBin_+3A_prefix">prefix</code></td>
<td>
<p>file root.</p>
</td></tr>
<tr><td><code id="WriteGRMBin_+3A_grm">grm</code></td>
<td>
<p>a GRM.</p>
</td></tr>
<tr><td><code id="WriteGRMBin_+3A_n">N</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="WriteGRMBin_+3A_id">id</code></td>
<td>
<p>id.</p>
</td></tr>
<tr><td><code id="WriteGRMBin_+3A_size">size</code></td>
<td>
<p>size.</p>
</td></tr>
</table>

<hr>
<h2 id='xy'>Conversion of chromosome names to strings</h2><span id='topic+xy'></span>

<h3>Description</h3>

<p>Conversion of chromosome names to strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xy_+3A_x">x</code></td>
<td>
<p>(alpha)numeric value indicating chromosome.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts x=1:24 to 1:22, X, Y
</p>


<h3>Value</h3>

<p>As indicated.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
