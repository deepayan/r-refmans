<!DOCTYPE html><html lang="en"><head><title>Help for package psfmi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {psfmi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anderson'><p>Data from a placebo-controlled RCT with leukemia patients</p></a></li>
<li><a href='#aortadis'><p>Dataset of patients with a aortadissection</p></a></li>
<li><a href='#bmd'><p>Data of a non-experimental study in more than 300 elderly women</p></a></li>
<li><a href='#boot_MI'><p>Bootstrap validation in Multiply Imputed datasets</p></a></li>
<li><a href='#bw_single'><p>Predictor selection function for backward selection of</p>
Linear and Logistic regression models.</a></li>
<li><a href='#chlrform'><p>Data about concentration of ß2-microglobuline in urine as indicator for possible damage to the kidney</p></a></li>
<li><a href='#chol_long'><p>Long dataset of persons from the The Amsterdam Growth and Health Longitudinal Study (AGHLS)</p></a></li>
<li><a href='#chol_wide'><p>Wide dataset of persons from the The Amsterdam Growth and Health Longitudinal Study (AGHLS)</p></a></li>
<li><a href='#clean_P'><p>Function to clean variables</p></a></li>
<li><a href='#coxph_bw'><p>Predictor selection function for backward selection of Cox regression models in</p>
single complete dataset.</a></li>
<li><a href='#coxph_fw'><p>Predictor selection function for forward selection of Cox regression models in</p>
single complete dataset.</a></li>
<li><a href='#cv_MI'><p>Cross-validation in Multiply Imputed datasets</p></a></li>
<li><a href='#cv_MI_RR'><p>Cross-validation in Multiply Imputed datasets</p></a></li>
<li><a href='#day2_dataset4_mi'><p>Dataset of low back pain patients with missing values</p></a></li>
<li><a href='#glm_bw'><p>Function for backward selection of Linear and Logistic regression models.</p></a></li>
<li><a href='#glm_fw'><p>Function for forward selection of Linear and Logistic regression models.</p></a></li>
<li><a href='#hipstudy'><p>Dataset of elderly patients with a hip fracture</p></a></li>
<li><a href='#hipstudy_external'><p>External Dataset of elderly patients with a hip fracture</p></a></li>
<li><a href='#hoorn_basic'><p>Dataset of the Hoorn Study</p></a></li>
<li><a href='#hoslem_test'><p>Calculates the Hosmer and Lemeshow goodness of fit test.</p></a></li>
<li><a href='#infarct'><p>Data of a patient-control study regarding the relationship between MI and smoking</p></a></li>
<li><a href='#ipdna_md'><p>Example dataset for the psfmi_mm function</p></a></li>
<li><a href='#km_estimates'><p>Kaplan-Meier risk estimates for Net Reclassification Index analysis</p></a></li>
<li><a href='#km_fit'><p>Kaplan-Meier (KM) estimate at specific time point</p></a></li>
<li><a href='#lbp_orig'><p>Example dataset for psfmi_perform function, method boot_MI</p></a></li>
<li><a href='#lbpmi_extval'><p>Example dataset of Low Back Pain Patients for external validation</p></a></li>
<li><a href='#lbpmicox'><p>Example dataset for psfmi_coxr function</p></a></li>
<li><a href='#lbpmilr'><p>Example dataset for psfmi_lr function</p></a></li>
<li><a href='#lbpmilr_dev'><p>Example dataset for mivalext_lr function</p></a></li>
<li><a href='#lungvolume'><p>Data of the development of lung and heartvolume of unborn babies</p></a></li>
<li><a href='#mammaca'><p>Data of a study among women with breast cancer</p></a></li>
<li><a href='#mean_auc_log'><p>Function to calulate mean auc values</p></a></li>
<li><a href='#men'><p>Data of 613 patients with meningitis</p></a></li>
<li><a href='#MI_boot'><p>Bootstrap validation in Multiply Imputed datasets</p></a></li>
<li><a href='#MI_cv_naive'><p>Naive method for Cross-validation in Multiply Imputed datasets</p></a></li>
<li><a href='#miceImp'><p>Wrapper function around mice</p></a></li>
<li><a href='#mivalext_lr'><p>External Validation of logistic prediction models in</p>
multiply imputed datasets</a></li>
<li><a href='#nri_cox'><p>Net Reclassification Index for Cox Regression Models</p></a></li>
<li><a href='#nri_est'><p>Calculation of Net Reclassification Index measures</p></a></li>
<li><a href='#pool_auc'><p>Calculates the pooled C-statistic (Area Under the ROC Curve) across Multiply Imputed datasets</p></a></li>
<li><a href='#pool_compare_models'><p>Compare the fit and performance of prediction models across Multipy Imputed data</p></a></li>
<li><a href='#pool_D2'><p>Combines the Chi Square statistics across Multiply Imputed datasets</p></a></li>
<li><a href='#pool_D4'><p>Pools the Likelihood Ratio tests across Multiply Imputed datasets ( method D4)</p></a></li>
<li><a href='#pool_intadj'><p>Provides pooled adjusted intercept after shrinkage of pooled coefficients</p>
in multiply imputed datasets</a></li>
<li><a href='#pool_performance'><p>Pooling performance measures across multiply imputed datasets</p></a></li>
<li><a href='#pool_performance_internal'><p>Pooling performance measures over multiply imputed datasets</p></a></li>
<li><a href='#pool_reclassification'><p>Function to pool NRI measures over Multiply Imputed datasets</p></a></li>
<li><a href='#pool_RR'><p>Function to combine estimates by using Rubin's Rules</p></a></li>
<li><a href='#psfmi_coxr'><p>Pooling and Predictor selection function for backward or forward selection of</p>
Cox regression models across multiply imputed data.</a></li>
<li><a href='#psfmi_coxr_bw'><p>Backward selection of Cox regression models in multiply imputed data.</p></a></li>
<li><a href='#psfmi_coxr_fw'><p>Forward selection of Cox regression models across multiply imputed data.</p></a></li>
<li><a href='#psfmi_lm'><p>Pooling and Predictor selection function for backward or forward selection of</p>
Linear regression models across multiply imputed data.</a></li>
<li><a href='#psfmi_lm_bw'><p>Backward selection of Linear regression models across multiply imputed data.</p></a></li>
<li><a href='#psfmi_lm_fw'><p>Forward selection of Linear regression models across multiply imputed data.</p></a></li>
<li><a href='#psfmi_lr'><p>Pooling and Predictor selection function for backward or forward selection of</p>
Logistic regression models across multiply imputed data.</a></li>
<li><a href='#psfmi_lr_bw'><p>Backward selection of Logistic regression models in multiply imputed data.</p></a></li>
<li><a href='#psfmi_lr_fw'><p>Forward selection of Logistic regression models in multiply imputed data.</p></a></li>
<li><a href='#psfmi_mm'><p>Pooling and Predictor selection function for multilevel</p>
models in multiply imputed datasets</a></li>
<li><a href='#psfmi_mm_multiparm'><p>Multiparameter pooling methods called by psfmi_mm</p></a></li>
<li><a href='#psfmi_perform'><p>Internal validation and performance of logistic prediction models across Multiply Imputed datasets</p></a></li>
<li><a href='#psfmi_stab'><p>Function to evaluate bootstrap predictor and model stability in multiply imputed datasets.</p></a></li>
<li><a href='#psfmi_validate'><p>Internal validation and performance of logistic prediction models across Multiply Imputed datasets</p></a></li>
<li><a href='#risk_coxph'><p>Risk calculation at specific time point for Cox model</p></a></li>
<li><a href='#RR_diff_prop'><p>Function to apply RR to pool difference of NRI and AUC values</p></a></li>
<li><a href='#rsq_nagel'><p>Nagelkerke's R-square calculation for logistic regression / glm models</p></a></li>
<li><a href='#rsq_surv'><p>R-square calculation for Cox regression models</p></a></li>
<li><a href='#sbp_age'><p>Dataset with blood pressure measurements</p></a></li>
<li><a href='#sbp_qas'><p>Dataset with blood pressure measurements</p></a></li>
<li><a href='#scaled_brier'><p>Calculates the scaled Brier score</p></a></li>
<li><a href='#smoking'><p>Survival data about smoking</p></a></li>
<li><a href='#stab_single'><p>Function to evaluate bootstrap predictor and model stability.</p></a></li>
<li><a href='#weight'><p>Dataset of persons from the The Amsterdam Growth and Health Longitudinal Study (AGHLS)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, norm, survival, mitools, pROC, rms, magrittr,
rsample, mice, mitml, cvAUC, dplyr, purrr, tidyr, tibble,
stringr, lme4, car</td>
</tr>
<tr>
<td>Suggests:</td>
<td>foreign (&ge; 0.8-80), knitr, rmarkdown, testthat (&ge; 3.0.0),
bookdown, readr, gtools, covr</td>
</tr>
<tr>
<td>Title:</td>
<td>Prediction Model Pooling, Selection and Performance Evaluation
Across Multiply Imputed Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
	Pooling, backward and forward selection of linear, logistic and Cox regression models in 
	multiply imputed datasets. Backward and forward selection can be done 
	from the pooled model using Rubin's Rules (RR), the D1, D2, D3, D4 and 
	the median p-values method. This is also possible for Mixed models. 
	The models can contain continuous, dichotomous, categorical and restricted 
	cubic spline predictors and interaction terms between	all these type of predictors. 
	The stability of the models	can be evaluated using (cluster) bootstrapping. The package 
	further contains functions to pool model performance measures as ROC/AUC, Reclassification, 
	R-squared, scaled Brier score, H&amp;L test and calibration	plots for logistic regression models. 
	Internal validation can be done across multiply imputed datasets with cross-validation or 
	bootstrapping. The adjusted intercept after shrinkage of pooled regression coefficients 
	can be obtained. Backward and forward selection as part of internal validation is possible. 
	A function to externally validate logistic prediction models in multiple imputed 
	datasets is available and a function to compare models. For Cox models a strata variable
	can be included.
	Eekhout (2017) &lt;<a href="https://doi.org/10.1186%2Fs12874-017-0404-7">doi:10.1186/s12874-017-0404-7</a>&gt;.
	Wiel (2009) &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxp011">doi:10.1093/biostatistics/kxp011</a>&gt;.
	Marshall (2009) &lt;<a href="https://doi.org/10.1186%2F1471-2288-9-57">doi:10.1186/1471-2288-9-57</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mwheymans.github.io/psfmi/">https://mwheymans.github.io/psfmi/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mwheymans/psfmi/issues/">https://github.com/mwheymans/psfmi/issues/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-16 09:44:07 UTC; mwhey</td>
</tr>
<tr>
<td>Author:</td>
<td>Martijn Heymans <a href="https://orcid.org/0000-0002-3889-0921"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Iris Eekhout [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martijn Heymans &lt;mw.heymans@amsterdamumc.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-17 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anderson'>Data from a placebo-controlled RCT with leukemia patients</h2><span id='topic+anderson'></span>

<h3>Description</h3>

<p>Data from a placebo-controlled RCT with leukemia patients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(anderson)</code></pre>


<h3>Format</h3>

<p>A data frame with 348 observations on the following 5 variables.
</p>

<dl>
<dt><code>remission</code></dt><dd><p>continuous:remission in weeks</p>
</dd>
<dt><code>status</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>treatment</code></dt><dd><p>dichotomous: 0=placebo, 1=verum</p>
</dd>
<dt><code>sex</code></dt><dd><p>dichotomous: 0=female, 1=male</p>
</dd>
<dt><code>log_wbc</code></dt><dd><p>continuous: Log (number of white blood cells)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(anderson)
## maybe str(anderson)
</code></pre>

<hr>
<h2 id='aortadis'>Dataset of patients with a aortadissection</h2><span id='topic+aortadis'></span>

<h3>Description</h3>

<p>Original dataset of patients with a aortadissection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(aortadis)</code></pre>


<h3>Format</h3>

<p>A data frame with 226 observations on the following 10 variables.
</p>

<dl>
<dt><code>Gender</code></dt><dd><p>dichotomous, 1=yes, 0=no</p>
</dd>
<dt><code>Age</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Age_C</code></dt><dd><p>categorical: 0 = &lt; 50 years, 1 = 50-59 years, 2 = 60-69 years, 3 = 70-79 years, 4 = 80 years and older</p>
</dd>
<dt><code>Aortadis</code></dt><dd><p>dichotomous, 1=yes, 0=no</p>
</dd>
<dt><code>Acute</code></dt><dd><p>dichotomous, 1=yes, 0=no</p>
</dd>
<dt><code>Acute3</code></dt><dd><p>categorical: 0 = No, 1 = Little, 2 = Much</p>
</dd>
<dt><code>Stomach_Ache</code></dt><dd><p>dichotomous, 1=yes, 0=no</p>
</dd>
<dt><code>Hyper</code></dt><dd><p>dichotomous, Hypertensio, 1=yes, 0=no</p>
</dd>
<dt><code>Smoking</code></dt><dd><p>dichotomous, 1=yes, 0=no</p>
</dd>
<dt><code>Radiation</code></dt><dd><p>dichotomous, 1=yes, 0=no</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(aortadis)
## maybe str(aortadis)
</code></pre>

<hr>
<h2 id='bmd'>Data of a non-experimental study in more than 300 elderly women</h2><span id='topic+bmd'></span>

<h3>Description</h3>

<p>Data of a non-experimental study in more than 300 elderly women
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bmd)</code></pre>


<h3>Format</h3>

<p>A data frame with 348 observations on the following 5 variables.
</p>

<dl>
<dt><code>bmd</code></dt><dd><p>continuous</p>
</dd>
<dt><code>age</code></dt><dd><p>continuous: years</p>
</dd>
<dt><code>menopaus</code></dt><dd><p>continuous: age of menopause</p>
</dd>
<dt><code>weight</code></dt><dd><p>continuous: weight in kg</p>
</dd>
<dt><code>walkscor</code></dt><dd><p>dichotomous: score on a walking test, 0=normal, 1=impaired</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(bmd)
## maybe str(bmd)
</code></pre>

<hr>
<h2 id='boot_MI'>Bootstrap validation in Multiply Imputed datasets</h2><span id='topic+boot_MI'></span>

<h3>Description</h3>

<p><code>boot_MI</code> Bootstrapping followed by Multiple Imputation for internal validation.
Called by function <code>psfmi_perform</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_MI(
  pobj,
  data_orig,
  nboot = 10,
  nimp_mice,
  p.crit,
  direction,
  miceImp,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot_MI_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>pmods</code> (pooled models), produced by a previous
call to <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="boot_MI_+3A_data_orig">data_orig</code></td>
<td>
<p>dataframe of original dataset that contains missing data.</p>
</td></tr>
<tr><td><code id="boot_MI_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap resamples, default is 10.</p>
</td></tr>
<tr><td><code id="boot_MI_+3A_nimp_mice">nimp_mice</code></td>
<td>
<p>Numerical scalar. Number of multiple imputation runs.</p>
</td></tr>
<tr><td><code id="boot_MI_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium used for backward
or forward selection during validation. When set at 1, validation is done
without variable selection.</p>
</td></tr>
<tr><td><code id="boot_MI_+3A_direction">direction</code></td>
<td>
<p>The direction of predictor selection, &quot;BW&quot; is for backward selection and
&quot;FW&quot; for forward selection.</p>
</td></tr>
<tr><td><code id="boot_MI_+3A_miceimp">miceImp</code></td>
<td>
<p>Wrapper function around the <code>mice</code> function.</p>
</td></tr>
<tr><td><code id="boot_MI_+3A_...">...</code></td>
<td>
<p>Arguments as predictorMatrix, seed, maxit, etc that can be adjusted for
the <code>mice</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function bootstraps from the incomplete dataset and applies MI in each 
bootstrap sample. The model that is selected by the <code>psfmi_lr</code> function is
validated. When p.crit != 1, internal validation is conducted with variable selection.
The performance measures in the multiply imputed bootstrap samples are tested in the 
original multiply imputed datasets (pooled) to determine the optimism.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>
</p>

<hr>
<h2 id='bw_single'>Predictor selection function for backward selection of
Linear and Logistic regression models.</h2><span id='topic+bw_single'></span>

<h3>Description</h3>

<p><code>bw_single</code> Backward selection of Linear and Logistic regression
models using as selection method the likelihood-ratio Chi-square value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_single(
  data,
  formula = NULL,
  Outcome = NULL,
  predictors = NULL,
  p.crit = 1,
  cat.predictors = NULL,
  spline.predictors = NULL,
  int.predictors = NULL,
  keep.predictors = NULL,
  nknots = NULL,
  model_type = "binomial"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bw_single_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by glm.
See under &quot;Details&quot; and &quot;Examples&quot; how these can be specified.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the outcome variable.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, gnder10, etc.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_cat.predictors">cat.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
categorical variables. Default is NULL categorical predictors.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_spline.predictors">spline.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
(restricted cubic) spline variables. Default is NULL spline predictors. See details.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_int.predictors">int.predictors</code></td>
<td>
<p>A single string or a vector of strings with the names of the variables that form
an interaction pair, separated by a “:” symbol.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_keep.predictors">keep.predictors</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_nknots">nknots</code></td>
<td>
<p>A numerical vector that defines the number of knots for each spline predictor separately.</p>
</td></tr>
<tr><td><code id="bw_single_+3A_model_type">model_type</code></td>
<td>
<p>A character vector. If &quot;binomial&quot; a logistic regression model is used (default) and for 
&quot;linear&quot; a linear regression model is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula object has the form <code>Outcome ~ terms</code>. Categorical variables has to
be defined as <code>Outcome ~ factor(variable)</code>, restricted cubic spline variables as
<code>Outcome ~ rcs(variable, 3)</code>. Interaction terms can be defined as
<code>Outcome ~ variable1*variable2</code> or <code>Outcome ~ variable1 + variable2 + variable1:variable2</code>.
All variables in the terms part have to be separated by a &quot;+&quot;.
</p>


<h3>Value</h3>

<p>An object of class <code>smods</code> (single models) from
which the following objects can be extracted: original dataset as <code>data</code>, final selected
model as <code>RR_model_final</code>, model at each selection step <code>RR_model_setp</code>,
p-values at final step according to selection method as <code>multiparm_final</code>, and
at each step as <code>multiparm_step</code>, formula object at final step as <code>formula_final</code>, 
and at each step as <code>formula_step</code> and for start model as <code>formula_initial</code>, 
predictors included at each selection step as <code>predictors_in</code>, predictors excluded
at each step as <code>predictors_out</code>, and <code>Outcome</code>, <code>anova_test</code>, <code>p.crit</code>, <code>call</code>,
<code>model_type</code>, <code>predictors_final</code> for names of predictors in final selection step and 
<code>predictors_initial</code> for names of predictors in start model.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>References</h3>

<p>http://missingdatasolutions.rbind.io/
</p>

<hr>
<h2 id='chlrform'>Data about concentration of ß2-microglobuline in urine as indicator for possible damage to the kidney</h2><span id='topic+chlrform'></span>

<h3>Description</h3>

<p>Data about concentration of ß2-microglobuline in urine as indicator for possible damage to the kidney
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chlrform)</code></pre>


<h3>Format</h3>

<p>A data frame with 348 observations on the following 5 variables.
</p>

<dl>
<dt><code>pt_id</code></dt><dd><p>continuous</p>
</dd>
<dt><code>sport</code></dt><dd><p>categorical: 0 = football player, 1 = outdoorswimmer and 2 = indoor swimmer)</p>
</dd>
<dt><code>gammagt</code></dt><dd><p>continuous: liver damage</p>
</dd>
<dt><code>b2</code></dt><dd><p>continuous: beta2 microglobuline in mg per mol</p>
</dd>
<dt><code>age</code></dt><dd><p>continuous: age in years</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(chlrform)
## maybe str(chlrform)
</code></pre>

<hr>
<h2 id='chol_long'>Long dataset of persons from the The Amsterdam Growth and Health Longitudinal Study (AGHLS)</h2><span id='topic+chol_long'></span>

<h3>Description</h3>

<p>Long dataset of persons from the The Amsterdam Growth and Health Longitudinal Study (AGHLS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chol_long)</code></pre>


<h3>Format</h3>

<p>A data frame with 588 observations on the following 7 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>continuous</p>
</dd>
<dt><code>fitness</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Smoking</code></dt><dd><p>dichotomous, 1=yes, 0=no</p>
</dd>
<dt><code>Sex</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Time</code></dt><dd><p>categorical</p>
</dd>
<dt><code>Cholesterol</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SumSkinfolds</code></dt><dd><p>continuous</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(chol_long)
## maybe str(chol_long)
</code></pre>

<hr>
<h2 id='chol_wide'>Wide dataset of persons from the The Amsterdam Growth and Health Longitudinal Study (AGHLS)</h2><span id='topic+chol_wide'></span>

<h3>Description</h3>

<p>Wide dataset of persons from the The Amsterdam Growth and Health Longitudinal Study (AGHLS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chol_wide)</code></pre>


<h3>Format</h3>

<p>A data frame with 147 observations on the following 7 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Cholesterol1</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SumSkinfolds1</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Cholesterol2</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SumSkinfolds2</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Cholesterol3</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SumSkinfolds3</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Cholesterol4</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SumSkinfolds4</code></dt><dd><p>continuous</p>
</dd>
<dt><code>fitness</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Smoking</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Sex</code></dt><dd><p>dichotomous</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(chol_wide)
## maybe str(chol_wide)
</code></pre>

<hr>
<h2 id='clean_P'>Function to clean variables</h2><span id='topic+clean_P'></span>

<h3>Description</h3>

<p>Function to clean variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_P(variable)
</code></pre>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>

<hr>
<h2 id='coxph_bw'>Predictor selection function for backward selection of Cox regression models in
single complete dataset.</h2><span id='topic+coxph_bw'></span>

<h3>Description</h3>

<p><code>coxph_bw</code> Backward selection of Cox regression models in single complete dataset 
using as selection method the partial likelihood-ratio statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxph_bw(
  data,
  formula = NULL,
  status = NULL,
  time = NULL,
  predictors = NULL,
  p.crit = 1,
  cat.predictors = NULL,
  spline.predictors = NULL,
  int.predictors = NULL,
  keep.predictors = NULL,
  nknots = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coxph_bw_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by coxph.
See under &quot;Details&quot; and &quot;Examples&quot; how these can be specified.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_status">status</code></td>
<td>
<p>The status variable, normally 0=censoring, 1=event.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_time">time</code></td>
<td>
<p>Survival time.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, gnder10, etc.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_cat.predictors">cat.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
categorical variables. Default is NULL categorical predictors.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_spline.predictors">spline.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
(restricted cubic) spline variables. Default is NULL spline predictors. See details.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_int.predictors">int.predictors</code></td>
<td>
<p>A single string or a vector of strings with the names of the variables that form
an interaction pair, separated by a “:” symbol.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_keep.predictors">keep.predictors</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
<tr><td><code id="coxph_bw_+3A_nknots">nknots</code></td>
<td>
<p>A numerical vector that defines the number of knots for each spline predictor separately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula object has the form <code>Surv(time, status) ~ terms</code>. Categorical variables has to
be defined as <code>Surv(time, status) ~ factor(variable)</code>, restricted cubic spline variables as
<code>Surv(time, status) ~ rcs(variable, 3)</code>. Interaction terms can be defined as
<code>Surv(time, status) ~ variable1*variable2</code> or <code>Surv(time, status) ~ variable1 + variable2 + 
 variable1:variable2</code>. All variables in the terms part have to be separated by a &quot;+&quot;.
</p>


<h3>Value</h3>

<p>An object of class <code>smods</code> (single models) from
which the following objects can be extracted: original dataset as <code>data</code>, final selected
model as <code>RR_model_final</code>, model at each selection step <code>RR_model</code>,
p-values at final step <code>multiparm_final</code>, and at each step as <code>multiparm</code>, 
formula object at final step as <code>formula_final</code>, 
and at each step as <code>formula_step</code> and for start model as <code>formula_initial</code>, 
predictors included at each selection step as <code>predictors_in</code>, predictors excluded
at each step as <code>predictors_out</code>, and <code>time</code>, <code>status</code>, <code>p.crit</code>, <code>call</code>,
<code>model_type</code>, <code>predictors_final</code> for names of predictors in final selection step and 
<code>predictors_initial</code> for names of predictors in start model and <code>keep.predictors</code> for
variables that are forced in the model during selection.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>References</h3>

<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lbpmicox1 &lt;- subset(psfmi::lbpmicox, Impnr==1) # extract first imputed dataset
res_single &lt;- coxph_fw(data=lbpmicox1, p.crit = 0.05, formula=Surv(Time, Status) ~
                           Previous +  Radiation + Onset + Age + Tampascale + 
                           Pain + JobControl + factor(Satisfaction), 
                           spline.predictors = "Function",
                           nknots = 3)
         
res_single$RR_model_final
res_single$multiparm_final

</code></pre>

<hr>
<h2 id='coxph_fw'>Predictor selection function for forward selection of Cox regression models in 
single complete dataset.</h2><span id='topic+coxph_fw'></span>

<h3>Description</h3>

<p><code>coxph_bw</code> Forward selection of Cox regression models in single complete 
dataset using as selection method the partial likelihood-ratio statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxph_fw(
  data,
  formula = NULL,
  status = NULL,
  time = NULL,
  predictors = NULL,
  p.crit = 1,
  cat.predictors = NULL,
  spline.predictors = NULL,
  int.predictors = NULL,
  keep.predictors = NULL,
  nknots = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coxph_fw_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by coxph.
See under &quot;Details&quot; and &quot;Examples&quot; how these can be specified.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_status">status</code></td>
<td>
<p>The status variable, normally 0=censoring, 1=event.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_time">time</code></td>
<td>
<p>Survival time.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, gnder10, etc.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_cat.predictors">cat.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
categorical variables. Default is NULL categorical predictors.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_spline.predictors">spline.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
(restricted cubic) spline variables. Default is NULL spline predictors. See details.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_int.predictors">int.predictors</code></td>
<td>
<p>A single string or a vector of strings with the names of the variables that form
an interaction pair, separated by a “:” symbol.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_keep.predictors">keep.predictors</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
<tr><td><code id="coxph_fw_+3A_nknots">nknots</code></td>
<td>
<p>A numerical vector that defines the number of knots for each spline predictor separately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula object has the form <code>Surv(time, status) ~ terms</code>. Categorical variables has to
be defined as <code>Surv(time, status) ~ factor(variable)</code>, restricted cubic spline variables as
<code>Surv(time, status) ~ rcs(variable, 3)</code>. Interaction terms can be defined as
<code>Surv(time, status) ~ variable1*variable2</code> or <code>Surv(time, status) ~ variable1 + variable2 + 
 variable1:variable2</code>. All variables in the terms part have to be separated by a &quot;+&quot;.
</p>


<h3>Value</h3>

<p>An object of class <code>smods</code> (single models) from
which the following objects can be extracted: original dataset as <code>data</code>, final selected
model as <code>RR_model_final</code>, model at each selection step <code>RR_model</code>,
p-values at final step <code>multiparm_final</code>, and at each step as <code>multiparm</code>, 
formula object at final step as <code>formula_final</code>, 
and at each step as <code>formula_step</code> and for start model as <code>formula_initial</code>, 
predictors included at each selection step as <code>predictors_in</code>, predictors excluded
at each step as <code>predictors_out</code>, and <code>time</code>, <code>status</code>, <code>p.crit</code>, <code>call</code>,
<code>model_type</code>, <code>predictors_final</code> for names of predictors in final selection step and 
<code>predictors_initial</code> for names of predictors in start model and <code>keep.predictors</code> for
variables that are forced in the model during selection.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>References</h3>

<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lbpmicox1 &lt;- subset(psfmi::lbpmicox, Impnr==1) # extract first imputed dataset
res_single &lt;- coxph_bw(data=lbpmicox1, p.crit = 0.05, formula=Surv(Time, Status) ~
                           Previous +  Radiation + Onset + Age + Tampascale + 
                           Pain + JobControl + factor(Satisfaction), 
                           spline.predictors = "Function",
                           nknots = 3)
         
res_single$RR_model_final
res_single$multiparm_final

</code></pre>

<hr>
<h2 id='cv_MI'>Cross-validation in Multiply Imputed datasets</h2><span id='topic+cv_MI'></span>

<h3>Description</h3>

<p><code>cv_MI</code> Cross-validation by applying multiple single imputation runs in train
and test folds. Called by function <code>psfmi_perform</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_MI(pobj, data_orig, folds, nimp_cv, BW, p.crit, miceImp, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv_MI_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>pmods</code> (pooled models), produced by a previous
call to <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="cv_MI_+3A_data_orig">data_orig</code></td>
<td>
<p>dataframe of original dataset that contains missing data.</p>
</td></tr>
<tr><td><code id="cv_MI_+3A_folds">folds</code></td>
<td>
<p>The number of folds, default is 3.</p>
</td></tr>
<tr><td><code id="cv_MI_+3A_nimp_cv">nimp_cv</code></td>
<td>
<p>Numerical scalar. Number of (multiple) imputation runs.</p>
</td></tr>
<tr><td><code id="cv_MI_+3A_bw">BW</code></td>
<td>
<p>If TRUE backward selection is conducted within cross-validation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cv_MI_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium used for backward during
cross-validation. When set at 1, pooling and internal validation is done without
backward selection.</p>
</td></tr>
<tr><td><code id="cv_MI_+3A_miceimp">miceImp</code></td>
<td>
<p>Wrapper function around the <code>mice</code> function.</p>
</td></tr>
<tr><td><code id="cv_MI_+3A_...">...</code></td>
<td>
<p>Arguments as predictorMatrix, seed, maxit, etc that can be adjusted for
the <code>mice</code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>
</p>

<hr>
<h2 id='cv_MI_RR'>Cross-validation in Multiply Imputed datasets</h2><span id='topic+cv_MI_RR'></span>

<h3>Description</h3>

<p><code>cv_MI_RR</code> Cross-validation by applying multiply imputed pooled models in train
and test folds. Called by function <code>psfmi_perform</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv_MI_RR(pobj, data_orig, folds, nimp_mice, p.crit, BW, miceImp, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv_MI_RR_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>pmods</code> (pooled models), produced by a previous
call to <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="cv_MI_RR_+3A_data_orig">data_orig</code></td>
<td>
<p>dataframe of original dataset that contains missing data.</p>
</td></tr>
<tr><td><code id="cv_MI_RR_+3A_folds">folds</code></td>
<td>
<p>The number of folds, default is 3.</p>
</td></tr>
<tr><td><code id="cv_MI_RR_+3A_nimp_mice">nimp_mice</code></td>
<td>
<p>Numerical scalar. Number of multiple imputation runs.</p>
</td></tr>
<tr><td><code id="cv_MI_RR_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium used for backward during
cross-validation. When set at 1, pooling and internal validation is done without
backward selection.</p>
</td></tr>
<tr><td><code id="cv_MI_RR_+3A_bw">BW</code></td>
<td>
<p>If TRUE backward selection is conducted within cross-validation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cv_MI_RR_+3A_miceimp">miceImp</code></td>
<td>
<p>Wrapper function around the <code>mice</code> function.</p>
</td></tr>
<tr><td><code id="cv_MI_RR_+3A_...">...</code></td>
<td>
<p>Arguments as predictorMatrix, seed, maxit, etc that can be adjusted for
the <code>mice</code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>
</p>

<hr>
<h2 id='day2_dataset4_mi'>Dataset of low back pain patients with missing values</h2><span id='topic+day2_dataset4_mi'></span>

<h3>Description</h3>

<p>Dataset of low back pain patients with missing values in 2 variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(day2_dataset4_mi)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 8 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>continuous: unique patient numbers</p>
</dd>
<dt><code>Pain</code></dt><dd><p>continuous: Pain intensity</p>
</dd>
<dt><code>Tampa</code></dt><dd><p>continuous: Fear of Movement scale</p>
</dd>
<dt><code>Function</code></dt><dd><p>continuous: Functional Status</p>
</dd>
<dt><code>JobSocial</code></dt><dd><p>continuous</p>
</dd>
<dt><code>FAB</code></dt><dd><p>continuous: Fear Avoidance Beliefs</p>
</dd>
<dt><code>Gender</code></dt><dd><p>dichotomous: 1 = male, 0 = female</p>
</dd>
<dt><code>Radiation</code></dt><dd><p>dichotomous: 1 = yes, 0 = no</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(day2_dataset4_mi)
## maybe str(day2_dataset4_mi)
</code></pre>

<hr>
<h2 id='glm_bw'>Function for backward selection of Linear and Logistic regression models.</h2><span id='topic+glm_bw'></span>

<h3>Description</h3>

<p><code>glm_bw</code> Backward selection of Linear and Logistic regression
models in single dataset using as selection method the likelihood-ratio test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm_bw(
  data,
  formula = NULL,
  Outcome = NULL,
  predictors = NULL,
  p.crit = 1,
  cat.predictors = NULL,
  spline.predictors = NULL,
  int.predictors = NULL,
  keep.predictors = NULL,
  nknots = NULL,
  model_type = "binomial"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm_bw_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by glm.
See under &quot;Details&quot; and &quot;Examples&quot; how these can be specified.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the outcome variable.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, gnder10, etc.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_cat.predictors">cat.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
categorical variables. Default is NULL categorical predictors.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_spline.predictors">spline.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
(restricted cubic) spline variables. Default is NULL spline predictors. See details.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_int.predictors">int.predictors</code></td>
<td>
<p>A single string or a vector of strings with the names of the variables that form
an interaction pair, separated by a “:” symbol.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_keep.predictors">keep.predictors</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_nknots">nknots</code></td>
<td>
<p>A numerical vector that defines the number of knots for each spline predictor separately.</p>
</td></tr>
<tr><td><code id="glm_bw_+3A_model_type">model_type</code></td>
<td>
<p>A character vector. If &quot;binomial&quot; a logistic regression model is used (default) and for 
&quot;linear&quot; a linear regression model is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula object has the form <code>Outcome ~ terms</code>. Categorical variables has to
be defined as <code>Outcome ~ factor(variable)</code>, restricted cubic spline variables as
<code>Outcome ~ rcs(variable, 3)</code>. Interaction terms can be defined as
<code>Outcome ~ variable1*variable2</code> or <code>Outcome ~ variable1 + variable2 + variable1:variable2</code>.
All variables in the terms part have to be separated by a &quot;+&quot;.
</p>


<h3>Value</h3>

<p>An object of class <code>smods</code> (single models) from
which the following objects can be extracted: original dataset as <code>data</code>, 
model at each selection step <code>RR_model</code>, final selected model as <code>RR_model_final</code>, 
p-values at final step <code>multiparm_final</code>, and at each step as <code>multiparm</code>, 
formula object at final step as <code>formula_final</code>, 
and at each step as <code>formula_step</code> and for start model as <code>formula_initial</code>, 
predictors included at each selection step as <code>predictors_in</code>, predictors excluded
at each step as <code>predictors_out</code>, and <code>Outcome</code>, <code>p.crit</code>, <code>call</code>,
<code>model_type</code>, <code>predictors_final</code> for names of predictors in final selection step and 
<code>predictors_initial</code> for names of predictors in start model and <code>keep.predictors</code> for
variables that are forced in the model during selection.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>References</h3>

<p>http://missingdatasolutions.rbind.io/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data1 &lt;- subset(psfmi::lbpmilr, Impnr==1) # extract first imputed dataset
res_single &lt;- glm_bw(data=data1, p.crit = 0.05, formula=Chronic ~
       Tampascale + Smoking + factor(Satisfaction), model_type="binomial")
         
res_single$RR_model_final

res_single &lt;- glm_bw(data=data1, p.crit = 0.05, formula=Pain ~
         Tampascale  + Smoking + factor(Satisfaction), model_type="linear")
         
res_single$RR_model_final

</code></pre>

<hr>
<h2 id='glm_fw'>Function for forward selection of Linear and Logistic regression models.</h2><span id='topic+glm_fw'></span>

<h3>Description</h3>

<p><code>glm_fw</code> Forward selection of Linear and Logistic regression
models in single dataset using as selection method the likelihood-ratio test statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm_fw(
  data,
  formula = NULL,
  Outcome = NULL,
  predictors = NULL,
  p.crit = 1,
  cat.predictors = NULL,
  spline.predictors = NULL,
  int.predictors = NULL,
  keep.predictors = NULL,
  nknots = NULL,
  model_type = "binomial"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="glm_fw_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by glm.
See under &quot;Details&quot; and &quot;Examples&quot; how these can be specified.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the outcome variable.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, gnder10, etc.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the full model without selection.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_cat.predictors">cat.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
categorical variables. Default is NULL categorical predictors.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_spline.predictors">spline.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
(restricted cubic) spline variables. Default is NULL spline predictors. See details.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_int.predictors">int.predictors</code></td>
<td>
<p>A single string or a vector of strings with the names of the variables that form
an interaction pair, separated by a “:” symbol.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_keep.predictors">keep.predictors</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_nknots">nknots</code></td>
<td>
<p>A numerical vector that defines the number of knots for each spline predictor separately.</p>
</td></tr>
<tr><td><code id="glm_fw_+3A_model_type">model_type</code></td>
<td>
<p>A character vector. If &quot;binomial&quot; a logistic regression model is used (default) and for 
&quot;linear&quot; a linear regression model is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula object has the form <code>Outcome ~ terms</code>. Categorical variables has to
be defined as <code>Outcome ~ factor(variable)</code>, restricted cubic spline variables as
<code>Outcome ~ rcs(variable, 3)</code>. Interaction terms can be defined as
<code>Outcome ~ variable1*variable2</code> or <code>Outcome ~ variable1 + variable2 + variable1:variable2</code>.
All variables in the terms part have to be separated by a &quot;+&quot;.
</p>


<h3>Value</h3>

<p>An object of class <code>smods</code> (single models) from
which the following objects can be extracted: original dataset as <code>data</code>, 
model at each selection step <code>RR_model</code>, final selected model as <code>RR_model_final</code>, 
p-values at final step <code>multiparm_final</code>, and at each step as <code>multiparm</code>, 
formula object at final step as <code>formula_final</code>, 
and at each step as <code>formula_step</code> and for start model as <code>formula_initial</code>, 
predictors included at each selection step as <code>predictors_in</code>, predictors excluded
at each step as <code>predictors_out</code>, and <code>Outcome</code>, <code>p.crit</code>, <code>call</code>,
<code>model_type</code>, <code>predictors_final</code> for names of predictors in final selection step and 
<code>predictors_initial</code> for names of predictors in start model and <code>keep.predictors</code> for
variables that are forced in the model during selection.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>References</h3>

<p>http://missingdatasolutions.rbind.io/
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data1 &lt;- subset(psfmi::lbpmilr, Impnr==1) # extract first imputed dataset
res_single &lt;- glm_fw(data=data1, p.crit = 0.05, formula=Chronic ~
       Tampascale + Smoking + factor(Satisfaction), model_type="binomial")
         
res_single$RR_model_final

res_single &lt;- glm_fw(data=data1, p.crit = 0.05, formula=Pain ~
         Tampascale  + Smoking + factor(Satisfaction), model_type="linear")
         
res_single$RR_model_final

</code></pre>

<hr>
<h2 id='hipstudy'>Dataset of elderly patients with a hip fracture</h2><span id='topic+hipstudy'></span>

<h3>Description</h3>

<p>Original dataset of elderly patients with a hip fracture
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hipstudy)</code></pre>


<h3>Format</h3>

<p>A data frame with 426 observations on the following 18 variables.
</p>

<dl>
<dt><code>pat_id</code></dt><dd><p>continuous: unique patient numbers</p>
</dd>
<dt><code>Gender</code></dt><dd><p>dichotomous: 1 = male, 0 = female</p>
</dd>
<dt><code>Age</code></dt><dd><p>continuous: Years</p>
</dd>
<dt><code>Mobility</code></dt><dd><p>categorical: 1 = No tools, 2 = Stick / walker, 3 = Wheelchair / bed</p>
</dd>
<dt><code>Dementia</code></dt><dd><p>dichotomous: 2=yes, 1=no</p>
</dd>
<dt><code>Home</code></dt><dd><p>categorical: 1 = Independent, 2 = Elderly house, 3 = Nursering</p>
</dd>
<dt><code>Comorbidity</code></dt><dd><p>continuous: Number of Co_morbidities (0-4)</p>
</dd>
<dt><code>ASA</code></dt><dd><p>continuous: ASA score (1-4)</p>
</dd>
<dt><code>Hemoglobine</code></dt><dd><p>continuous: Hemoglobine pre-operative</p>
</dd>
<dt><code>Leucocytes</code></dt><dd><p>continuous: Leucocytes preoperative</p>
</dd>
<dt><code>Thrombocytes</code></dt><dd><p>continuous: Thrombocytes preoperative</p>
</dd>
<dt><code>CRP</code></dt><dd><p>continuous: C-reactive protein (CRP) preoperative</p>
</dd>
<dt><code>Creatinine</code></dt><dd><p>continuous: Creatinine preoperative</p>
</dd>
<dt><code>Urea</code></dt><dd><p>continuous: Urea preoperative</p>
</dd>
<dt><code>Albumine</code></dt><dd><p>continuous: Albumin preoperative</p>
</dd>
<dt><code>Fracture</code></dt><dd><p>dichotomous: 1 = per or subtrochanter fracture, 0 = collum fracture</p>
</dd>
<dt><code>Delay</code></dt><dd><p>continuous: time till operation in days</p>
</dd>
<dt><code>Mortality</code></dt><dd><p>dichotomous: 1 = yes, 0 = no</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(hipstudy)
## maybe str(hipstudy)
</code></pre>

<hr>
<h2 id='hipstudy_external'>External Dataset of elderly patients with a hip fracture</h2><span id='topic+hipstudy_external'></span>

<h3>Description</h3>

<p>External dataset of elderly patients with a hip fracture
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hipstudy_external)</code></pre>


<h3>Format</h3>

<p>A data frame with 381 observations on the following 17 variables.
</p>

<dl>
<dt><code>Gender</code></dt><dd><p>dichotomous: 1 = male, 0 = female</p>
</dd>
<dt><code>Age</code></dt><dd><p>continuous: Years</p>
</dd>
<dt><code>Mobility</code></dt><dd><p>categorical: 1 = No tools, 2 = Stick / walker, 3 = Wheelchair / bed</p>
</dd>
<dt><code>Dementia</code></dt><dd><p>dichotomous: 2=yes, 1=no</p>
</dd>
<dt><code>Home</code></dt><dd><p>categorical: 1 = Independent, 2 = Elderly house, 3 = Nursering</p>
</dd>
<dt><code>Comorbidity</code></dt><dd><p>continuous: Number of Co-morbidities</p>
</dd>
<dt><code>ASA</code></dt><dd><p>continuous: ASA score</p>
</dd>
<dt><code>Hemoglobine</code></dt><dd><p>continuous: Hemoglobine preoperative</p>
</dd>
<dt><code>Leucocytes</code></dt><dd><p>continuous: Leucocytes preoperative</p>
</dd>
<dt><code>Thrombocytes</code></dt><dd><p>continuous: Thrombocytes preoperative</p>
</dd>
<dt><code>CRP</code></dt><dd><p>continuous: Creactive protein (CRP) preoperative</p>
</dd>
<dt><code>Creatinine</code></dt><dd><p>continuous: Creatinine preoperative</p>
</dd>
<dt><code>Urea</code></dt><dd><p>continuous: Urea preoperative</p>
</dd>
<dt><code>Albumine</code></dt><dd><p>continuous: Albumin preoperative</p>
</dd>
<dt><code>Fracture</code></dt><dd><p>dichotomous: 1 = per or subtrochanter fracture, 0 = collum fracture</p>
</dd>
<dt><code>Delay</code></dt><dd><p>continuous: time till operation in days</p>
</dd>
<dt><code>Mortality</code></dt><dd><p>dichotomous: 1 = yes, 0 = no</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(hipstudy_external)
## maybe str(hipstudy_external)
</code></pre>

<hr>
<h2 id='hoorn_basic'>Dataset of the Hoorn Study</h2><span id='topic+hoorn_basic'></span>

<h3>Description</h3>

<p>Dataset of the Hoorn Study
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hoorn_basic)</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations on the following 12 variables.
</p>

<dl>
<dt><code>patnr</code></dt><dd><p>continuous</p>
</dd>
<dt><code>sbldsys1</code></dt><dd><p>continuous: Systolic Blood Pressure 1</p>
</dd>
<dt><code>sbldsys2</code></dt><dd><p>continuous: Systolic Blood Pressure 2</p>
</dd>
<dt><code>sbldds1</code></dt><dd><p>continuous: Diastolic Blood Pressure 1</p>
</dd>
<dt><code>sbldds2</code></dt><dd><p>continuous: Diastolic Blood Pressure 2</p>
</dd>
<dt><code>sex</code></dt><dd><p>dichotomous: 1=male, 2=female</p>
</dd>
<dt><code>sfructo</code></dt><dd><p>continuous: fructosamine level in the blood </p>
</dd>
<dt><code>sglucn</code></dt><dd><p>continuous</p>
</dd>
<dt><code>dmknown</code></dt><dd><p>dichotomous: 0=no, 1=yes</p>
</dd>
<dt><code>dmdiet</code></dt><dd><p>dichotomous: 0=no, 1=yes</p>
</dd>
<dt><code>infarct</code></dt><dd><p>dichotomous: 0=no, 1=yes</p>
</dd>
<dt><code>hypten</code></dt><dd><p>dichotomous: 0=no, 1=yes</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(hoorn_basic)
## maybe str(hoorn_basic)
</code></pre>

<hr>
<h2 id='hoslem_test'>Calculates the Hosmer and Lemeshow goodness of fit test.</h2><span id='topic+hoslem_test'></span>

<h3>Description</h3>

<p><code>hoslem_test</code> the Hosmer and Lemeshow goodness of fit test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hoslem_test(y, yhat, g = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hoslem_test_+3A_y">y</code></td>
<td>
<p>a vector of observations (0/1).</p>
</td></tr>
<tr><td><code id="hoslem_test_+3A_yhat">yhat</code></td>
<td>
<p>a vector of predicted probabilities.</p>
</td></tr>
<tr><td><code id="hoslem_test_+3A_g">g</code></td>
<td>
<p>Number of groups tested. Default is 10. Can not be &lt; 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Chi-squared test statistic, the p-value, the observed and 
expected frequencies.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>References</h3>

<p>Kleinman K and Horton NJ. (2014). SAS and R: Data Management, 
Statistical Analysis, and Graphics. 2nd Edition. Chapman &amp; Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool_performance">pool_performance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fit &lt;- glm(Mortality ~ Dementia + factor(Mobility) + ASA + 
   Gender + Age, data=hipstudy, family=binomial) 
   pred &lt;- predict(fit, type = "response")
  
  hoslem_test(fit$y, pred)
 
</code></pre>

<hr>
<h2 id='infarct'>Data of a patient-control study regarding the relationship between MI and smoking</h2><span id='topic+infarct'></span>

<h3>Description</h3>

<p>Data of a patient-control study regarding the relationship between MI and smoking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(infarct)</code></pre>


<h3>Format</h3>

<p>A data frame with 420 observations on the following 10 variables.
</p>

<dl>
<dt><code>ppnr</code></dt><dd><p>continuous</p>
</dd>
<dt><code>infarct</code></dt><dd><p>dichotomous: 1=yes, 0=no</p>
</dd>
<dt><code>smoking</code></dt><dd><p>dichotomous: 1=yes, 0=no</p>
</dd>
<dt><code>alcohol</code></dt><dd><p>categorical</p>
</dd>
<dt><code>active</code></dt><dd><p>dichotomous: 1=active, 0=inactive</p>
</dd>
<dt><code>sex</code></dt><dd><p>dichotomous: 1=male, 0=female</p>
</dd>
<dt><code>profession</code></dt><dd><p>categorical: 1=epidemiologist, 2=statistician, 3=other</p>
</dd>
<dt><code>bmi</code></dt><dd><p>continuous: body mass index</p>
</dd>
<dt><code>sys</code></dt><dd><p>continuous: systolic blood pressure</p>
</dd>
<dt><code>dias</code></dt><dd><p>continuous: diastolic blood pressure</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(infarct)
## maybe str(infarct)
</code></pre>

<hr>
<h2 id='ipdna_md'>Example dataset for the psfmi_mm function</h2><span id='topic+ipdna_md'></span>

<h3>Description</h3>

<p>5 imputed datasets of the first 10 centres of the IPDNa dataset in the micemd package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ipdna_md)</code></pre>


<h3>Format</h3>

<p>A data frame with 13390 observations on the following 13 variables.
</p>

<dl>
<dt><code>.imp</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>.id</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>centre</code></dt><dd><p>cluster variable</p>
</dd>
<dt><code>gender</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>bmi</code></dt><dd><p>continuous</p>
</dd>
<dt><code>age</code></dt><dd><p>continuous</p>
</dd>
<dt><code>sbp</code></dt><dd><p>continuous</p>
</dd>
<dt><code>dbp</code></dt><dd><p>continuous</p>
</dd>
<dt><code>hr</code></dt><dd><p>continuous</p>
</dd>
<dt><code>lvef</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>bnp</code></dt><dd><p>categorical</p>
</dd>
<dt><code>afib</code></dt><dd><p>continuous</p>
</dd>
<dt><code>bmi_cat</code></dt><dd><p>categorical</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(ipdna_md)
## maybe str(ipdna_md)

#summary per study
by(ipdna_md, ipdna_md$centre, summary)
</code></pre>

<hr>
<h2 id='km_estimates'>Kaplan-Meier risk estimates for Net Reclassification Index analysis</h2><span id='topic+km_estimates'></span>

<h3>Description</h3>

<p><code>km_estimates</code> Kaplan-Meier risk estimates for Net Reclassification Index analysis 
for Cox Regression Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>km_estimates(data, p0, p1, time, status, t_risk, cutoff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="km_estimates_+3A_data">data</code></td>
<td>
<p>Data frame with relevant predictors</p>
</td></tr>
<tr><td><code id="km_estimates_+3A_p0">p0</code></td>
<td>
<p>risk outcome probabilities for reference model.</p>
</td></tr>
<tr><td><code id="km_estimates_+3A_p1">p1</code></td>
<td>
<p>risk outcome probabilities for new model.</p>
</td></tr>
<tr><td><code id="km_estimates_+3A_time">time</code></td>
<td>
<p>Character vector. Name of time variable.</p>
</td></tr>
<tr><td><code id="km_estimates_+3A_status">status</code></td>
<td>
<p>Character vector. Name of status variable.</p>
</td></tr>
<tr><td><code id="km_estimates_+3A_t_risk">t_risk</code></td>
<td>
<p>Follow-up value to calculate cases, controls. See details.</p>
</td></tr>
<tr><td><code id="km_estimates_+3A_cutoff">cutoff</code></td>
<td>
<p>A numerical vector that defines the outcome probability cutoff values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Follow-up for which cases and controls are determined. For censored cases before this follow-up 
the expected risk of being a case is calculated by using the Kaplan-Meier value to calculate
the expected number of cases. These expected numbers are used to calculate the NRI proportions. 
(These are not shown by function <code>nricens</code>).
</p>


<h3>Value</h3>

<p>An object from which the following objects can be extracted: 
</p>

<ul>
<li>  <p><code>data</code> dataset. 
</p>
</li>
<li>  <p><code>prob_orig</code> outcome risk probabilities at t_risk for reference model.
</p>
</li>
<li>  <p><code>prob_new</code> outcome risk probabilities at t_risk for new model.
</p>
</li>
<li>  <p><code>time</code> name of time variable.
</p>
</li>
<li>  <p><code>status</code> name of status variable.
</p>
</li>
<li>  <p><code>cutoff</code> cutoff value for survival probability. 
</p>
</li>
<li>  <p><code>t_risk</code> follow-up time used to calculate outcome (risk) probabilities.
</p>
</li>
<li>  <p><code>reclass_totals</code> table with total reclassification numbers.
</p>
</li>
<li>  <p><code>reclass_cases</code> table with reclassification numbers for cases.
</p>
</li>
<li>  <p><code>reclass_controls</code> table with reclassification numbers for controls.
</p>
</li>
<li>  <p><code>totals</code> totals of controls, cases, censored cases.
</p>
</li>
<li>  <p><code>km_est</code> totals of cases calculated using Kaplan-Meiers risk estimates.
</p>
</li>
<li>  <p><code>nri_est</code> reclassification measures.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Martijn Heymans, 2023
</p>


<h3>References</h3>

<p>Cook NR, Ridker PM. Advances in measuring the effect of individual predictors of 
cardiovascular risk: the role of reclassification measures. Ann Intern Med. 2009;150(11):795-802.
</p>
<p>Steyerberg EW, Pencina MJ. Reclassification calculations for persons with incomplete 
follow-up. Ann Intern Med. 2010;152(3):195-6 (author reply 196-7).
</p>
<p>Pencina MJ, D'Agostino RB Sr, Steyerberg EW. Extensions of net reclassification 
improvement calculations to measure usefulness of new biomarkers. Stat Med. 2011;30(1):11-21
</p>
<p>Inoue E (2018). nricens: NRI for Risk Prediction Models with Time to Event and Binary 
Response Data. R package version 1.6, &lt;https://CRAN.R-project.org/package=nricens&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(survival)
  lbpmicox1 &lt;- subset(psfmi::lbpmicox, Impnr==1) # extract dataset
  
  fit_cox0 &lt;- 
      coxph(Surv(Time, Status) ~ Duration + Pain, data=lbpmicox1, x=TRUE)
  fit_cox1 &lt;- 
      coxph(Surv(Time, Status) ~ Duration + Pain + Function + Radiation, 
      data=lbpmicox1, x=TRUE)

  p0 &lt;- risk_coxph(fit_cox0, t_risk=80)
  p1 &lt;- risk_coxph(fit_cox1, t_risk=80)
  
  res_km &lt;- km_estimates(data=lbpmicox1,
                      p0=p0,
                      p1=p1,
                      time = "Time",
                      status = "Status",
                      cutoff=0.45,
                      t_risk=80)

</code></pre>

<hr>
<h2 id='km_fit'>Kaplan-Meier (KM) estimate at specific time point</h2><span id='topic+km_fit'></span>

<h3>Description</h3>

<p>Kaplan-Meier (KM) estimate at specific time point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>km_fit(time, status, t_risk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="km_fit_+3A_time">time</code></td>
<td>
<p>Character vector. Name of time variable.</p>
</td></tr>
<tr><td><code id="km_fit_+3A_status">status</code></td>
<td>
<p>Character vector. Name of status variable.</p>
</td></tr>
<tr><td><code id="km_fit_+3A_t_risk">t_risk</code></td>
<td>
<p>Follow-up value to calculate cases, controls. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>KM estimate at specific time point
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2023
</p>


<h3>References</h3>

<p>Pencina MJ, D'Agostino RB Sr, Steyerberg EW. Extensions of net reclassification 
improvement calculations to measure usefulness of new biomarkers. Stat Med. 2011;30(1):11-21
</p>
<p>Inoue E (2018). nricens: NRI for Risk Prediction Models with Time to Event and Binary 
Response Data. R package version 1.6, &lt;https://CRAN.R-project.org/package=nricens&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+km_fit">km_fit</a></code>
</p>

<hr>
<h2 id='lbp_orig'>Example dataset for psfmi_perform function, method boot_MI</h2><span id='topic+lbp_orig'></span>

<h3>Description</h3>

<p>Original dataset with missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lbp_orig)</code></pre>


<h3>Format</h3>

<p>A data frame with 159 observations on the following 15 variables.
</p>

<dl>
<dt><code>Chronic</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Gender</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Carrying</code></dt><dd><p>categorical</p>
</dd>
<dt><code>Pain</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Tampascale</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Function</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Radiation</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Age</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Smoking</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Satisfaction</code></dt><dd><p>categorical</p>
</dd>
<dt><code>JobControl</code></dt><dd><p>continuous</p>
</dd>
<dt><code>JobDemands</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SocialSupport</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Duration</code></dt><dd><p>continuous</p>
</dd>
<dt><code>BMI</code></dt><dd><p>continuous</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(lbp_orig)
## maybe str(lbp_orig)
</code></pre>

<hr>
<h2 id='lbpmi_extval'>Example dataset of Low Back Pain Patients for external validation</h2><span id='topic+lbpmi_extval'></span>

<h3>Description</h3>

<p>Five multiply imputed datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lbpmi_extval
</code></pre>


<h3>Format</h3>

<p>A data frame with 400 rows and 17 variables.
</p>

<dl>
<dt><code>Impnr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>ID</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Chronic</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Gender</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Carrying</code></dt><dd><p>categorical</p>
</dd>
<dt><code>Pain</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Tampascale</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Function</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Radiation</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Age</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Smoking</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Satisfaction</code></dt><dd><p>categorical</p>
</dd>
<dt><code>JobControl</code></dt><dd><p>continuous</p>
</dd>
<dt><code>JobDemands</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SocialSupport</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Duration</code></dt><dd><p>continuous</p>
</dd>
<dt><code>BMI</code></dt><dd><p>continuous</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'> data(lbpmi_extval)
 ## maybe str(lbpmi_extval)\
 
</code></pre>

<hr>
<h2 id='lbpmicox'>Example dataset for psfmi_coxr function</h2><span id='topic+lbpmicox'></span>

<h3>Description</h3>

<p>10 imputed datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lbpmicox)</code></pre>


<h3>Format</h3>

<p>A data frame with 2650 observations on the following 18 variables.
</p>

<dl>
<dt><code>Impnr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>patnr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Status</code></dt><dd><p>dichotomous event </p>
</dd>
<dt><code>Time</code></dt><dd><p>continuous follow up time variable</p>
</dd>
<dt><code>Duration</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Previous</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Radiation</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Onset</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Age</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Tampascale</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Pain</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Function</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Satisfaction</code></dt><dd><p>categorical</p>
</dd>
<dt><code>JobControl</code></dt><dd><p>continuous</p>
</dd>
<dt><code>JobDemand</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Social</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Expectation</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Expect_cat</code></dt><dd><p>categorical</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(lbpmicox)
## maybe str(lbpmicox)
</code></pre>

<hr>
<h2 id='lbpmilr'>Example dataset for psfmi_lr function</h2><span id='topic+lbpmilr'></span>

<h3>Description</h3>

<p>10 imputed datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lbpmilr)</code></pre>


<h3>Format</h3>

<p>A data frame with 1590 observations on the following 17 variables.
</p>

<dl>
<dt><code>Impnr</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>ID</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Chronic</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Gender</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Carrying</code></dt><dd><p>categorical</p>
</dd>
<dt><code>Pain</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Tampascale</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Function</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Radiation</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Age</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Smoking</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Satisfaction</code></dt><dd><p>categorical</p>
</dd>
<dt><code>JobControl</code></dt><dd><p>continuous</p>
</dd>
<dt><code>JobDemands</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SocialSupport</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Duration</code></dt><dd><p>continuous</p>
</dd>
<dt><code>BMI</code></dt><dd><p>continuous</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(lbpmilr)
## maybe str(lbpmilr)
</code></pre>

<hr>
<h2 id='lbpmilr_dev'>Example dataset for mivalext_lr function</h2><span id='topic+lbpmilr_dev'></span>

<h3>Description</h3>

<p>1 development dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lbpmilr_dev)</code></pre>


<h3>Format</h3>

<p>A data frame with 108 observations on the following 16 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Chronic</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Gender</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Carrying</code></dt><dd><p>categorical</p>
</dd>
<dt><code>Pain</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Tampascale</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Function</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Radiation</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Age</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Smoking</code></dt><dd><p>dichotomous</p>
</dd>
<dt><code>Satisfaction</code></dt><dd><p>categorical</p>
</dd>
<dt><code>JobControl</code></dt><dd><p>continuous</p>
</dd>
<dt><code>JobDemands</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SocialSupport</code></dt><dd><p>continuous</p>
</dd>
<dt><code>Duration</code></dt><dd><p>continuous</p>
</dd>
<dt><code>BMI</code></dt><dd><p>continuous</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(lbpmilr_dev)
## maybe str(lbpmilr_dev)
</code></pre>

<hr>
<h2 id='lungvolume'>Data of the development of lung and heartvolume of unborn babies</h2><span id='topic+lungvolume'></span>

<h3>Description</h3>

<p>Data regarding the development of lung and heartvolume of unborn babies in the 18 till 34 week of pregnancy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lungvolume)</code></pre>


<h3>Format</h3>

<p>A data frame with 152 observations on the following 6 variables.
</p>

<dl>
<dt><code>pat_id</code></dt><dd><p>continuous</p>
</dd>
<dt><code>week</code></dt><dd><p>continuous: week pregnancy</p>
</dd>
<dt><code>weight</code></dt><dd><p>continuous: weight in grams</p>
</dd>
<dt><code>lungvol</code></dt><dd><p>continuous: lung volume</p>
</dd>
<dt><code>heartvol</code></dt><dd><p>continuous: heart volume</p>
</dd>
<dt><code>Nweek</code></dt><dd><p>categorical: Percentile Group of week</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(lungvolume)
## maybe str(lungvolume)
</code></pre>

<hr>
<h2 id='mammaca'>Data of a study among women with breast cancer</h2><span id='topic+mammaca'></span>

<h3>Description</h3>

<p>Data of a study among women with breast cancer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mammaca)</code></pre>


<h3>Format</h3>

<p>A data frame with 1207 observations on the following 10 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>continuous</p>
</dd>
<dt><code>time</code></dt><dd><p>continuous, Time (months)</p>
</dd>
<dt><code>status</code></dt><dd><p>dichotomous: 1=yes, 0=no</p>
</dd>
<dt><code>er</code></dt><dd><p>Estrogen Receptor Status, 1=positive, 0=negative</p>
</dd>
<dt><code>age</code></dt><dd><p>continuous</p>
</dd>
<dt><code>histgrad</code></dt><dd><p>categorical</p>
</dd>
<dt><code>ln_yesno</code></dt><dd><p>lymph nodes, 0=no, 1=yes</p>
</dd>
<dt><code>pathsd</code></dt><dd><p>dichotomous: Pathological Tumor Size</p>
</dd>
<dt><code>pr</code></dt><dd><p>dichotomous: Progesterone Receptor Status, 0=negative, 1=positive</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(mammaca)
## maybe str(mammaca)
</code></pre>

<hr>
<h2 id='mean_auc_log'>Function to calulate mean auc values</h2><span id='topic+mean_auc_log'></span>

<h3>Description</h3>

<p>Function to calulate mean auc values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_auc_log(auc, backtransform = TRUE)
</code></pre>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>

<hr>
<h2 id='men'>Data of 613 patients with meningitis</h2><span id='topic+men'></span>

<h3>Description</h3>

<p>Data of 613 patients with meningitis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(men)</code></pre>


<h3>Format</h3>

<p>A data frame with 420 observations on the following 10 variables.
</p>

<dl>
<dt><code>pt_id</code></dt><dd><p>continuous</p>
</dd>
<dt><code>sex</code></dt><dd><p>dichotomous: 0=male, 1=female</p>
</dd>
<dt><code>predisp</code></dt><dd><p>dichotomous: 0=no, 1=yes</p>
</dd>
<dt><code>mensepsi</code></dt><dd><p>categorical: disease characteristics at admission, 1=menigitis, 2=sepsis, 3=other</p>
</dd>
<dt><code>coma</code></dt><dd><p>dichotomous: coma at admission, 0=no, 1=coma</p>
</dd>
<dt><code>diastol</code></dt><dd><p>continuous: diastolic blood pressure at admission</p>
</dd>
<dt><code>course</code></dt><dd><p>dichotomous: disease course, 0=alive, 1=deceased</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(men)
## maybe str(men)
</code></pre>

<hr>
<h2 id='MI_boot'>Bootstrap validation in Multiply Imputed datasets</h2><span id='topic+MI_boot'></span>

<h3>Description</h3>

<p><code>MI_boot</code> Bootstrapping in each (original) Multiply Imputed dataset for internal validation.
Called by function <code>psfmi_perform</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI_boot(pobj, p.crit, nboot, direction)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MI_boot_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>pmods</code> (pooled models), produced by a previous
call to <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="MI_boot_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium used for backward
or forward selection during in the bootstrap samples. When set at 1, validation is done
without variable selection.</p>
</td></tr>
<tr><td><code id="MI_boot_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap resamples, default is 10.</p>
</td></tr>
<tr><td><code id="MI_boot_+3A_direction">direction</code></td>
<td>
<p>The direction of predictor selection, &quot;BW&quot; is for backward selection and
&quot;FW&quot; for forward selection.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>
</p>

<hr>
<h2 id='MI_cv_naive'>Naive method for Cross-validation in Multiply Imputed datasets</h2><span id='topic+MI_cv_naive'></span>

<h3>Description</h3>

<p><code>MI_cv_naive</code> Cross-validation by applying multiply imputed pooled models in train
and test folds. Called by function <code>psfmi_perform</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MI_cv_naive(pobj, folds = 3, p.crit = 1, BW = FALSE, cv_naive_appt = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MI_cv_naive_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>pmods</code> (pooled models), produced by a previous
call to <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="MI_cv_naive_+3A_folds">folds</code></td>
<td>
<p>The number of folds, default is 3.</p>
</td></tr>
<tr><td><code id="MI_cv_naive_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium used for backward during
cross-validation. When set at 1, pooling and internal validation is done without
backward selection.</p>
</td></tr>
<tr><td><code id="MI_cv_naive_+3A_bw">BW</code></td>
<td>
<p>If TRUE backward selection is conducted within cross-validation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="MI_cv_naive_+3A_cv_naive_appt">cv_naive_appt</code></td>
<td>
<p>Default is TRUE for showing the cross-validation apparent (train) and
test results. Set to FALSE to only give test results.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>
</p>

<hr>
<h2 id='miceImp'>Wrapper function around mice</h2><span id='topic+miceImp'></span>

<h3>Description</h3>

<p>Wrapper function around mice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miceImp(data, ...)
</code></pre>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>

<hr>
<h2 id='mivalext_lr'>External Validation of logistic prediction models in 
multiply imputed datasets</h2><span id='topic+mivalext_lr'></span>

<h3>Description</h3>

<p><code>mivalext_lr</code> External validation of logistic prediction models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mivalext_lr(
  data.val = NULL,
  data.orig = NULL,
  nimp = 5,
  impvar = NULL,
  formula = NULL,
  lp.orig = NULL,
  cal.plot = FALSE,
  plot.indiv,
  val.check = FALSE,
  g = 10,
  groups_cal = 10,
  plot.method = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mivalext_lr_+3A_data.val">data.val</code></td>
<td>
<p>Data frame with stacked multiply imputed validation datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_data.orig">data.orig</code></td>
<td>
<p>A single data frame containing the original dataset
that was used to develop the model. Used to estimate the original regression
coefficients in case lp.orig is not provided.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by glm.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_lp.orig">lp.orig</code></td>
<td>
<p>Numeric vector of the original coefficient values that are
externally validated.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_cal.plot">cal.plot</code></td>
<td>
<p>If TRUE a calibration plot is generated. Default is FALSE.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_plot.indiv">plot.indiv</code></td>
<td>
<p>This argument is deprecated; please use plot.method instead.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_val.check">val.check</code></td>
<td>
<p>logical vector. If TRUE the names of the predictors of the LP
are provided and can be used as information for the order of the coefficient
values as input for lp.orig. If FALSE (default) validation procedure is executed
with coefficient values fitted in the order as used under lp.orig.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_g">g</code></td>
<td>
<p>A numerical scalar. Number of groups for the Hosmer and
Lemeshow test. Default is 10.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_groups_cal">groups_cal</code></td>
<td>
<p>A numerical scalar. Number of groups used on the calibration plot. 
Default is 10. If the range of predicted probabilities is low, less than 10 groups 
can be chosen.</p>
</td></tr>
<tr><td><code id="mivalext_lr_+3A_plot.method">plot.method</code></td>
<td>
<p>If &quot;mean&quot; one calibration plot is generated, first taking the 
mean of the linear predictor values across the multiply imputed datasets (default), if 
&quot;individual&quot; the calibration plot in each imputed dataset is plotted, 
if &quot;overlay&quot; calibration plots from each imputed datasets are plotted in one figure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following information of the externally validated model is provided:
<code>calibrate</code> with information of <code>pooled_int</code> and <code>pooled_slope</code> that is
the pooled linear predictor (LP), after the LP is freely estimated in each external imputed 
dataset <code>Outcome ~ a + LP</code> (provides information about miscalibration in intercept 
and slope), <code>pooled_offset_int</code> as <code>Outcome ~ a + offset(LP)</code> and 
<code>pooled_offset_slope</code> as <code>Outcome ~ a + LP + offset(LP)</code> with information 
about miscalibration in intercept and slope separately by using an offset procedure 
(see Steyerberg, p. 300), <code>coef_pooled</code> with the pooled coefficients when the model 
is freely estimated in imputed datasets, <code>ROC</code> pooled ROC curve (back transformed 
after pooling log transformed ROC curves), <code>R2</code> pooled Nagelkerke R-Square value 
(back transformed after pooling Fisher transformed values), <code>HLtest</code> pooled Hosmer 
and Lemeshow Test (using function <code>pool_D2</code>). In addition information is provided about 
<code>nimp</code>, <code>impvar</code>, <code>formula</code>, <code>val_ckeck</code>, <code>g</code> and <code>coef_check</code>. 
When the external validation is very poor, the R2 can become negative due to the poor fit of 
the model in the external dataset (in that case you may report a R2 of zero).
</p>


<h3>Value</h3>

<p>A <code>mivalext_lr</code> object from which the following objects 
can be extracted: <code>calibrate</code> with information about 
mis-calibration in intercept and slope with and without offset procedure, 
<code>coef_pooled</code>, coefficients pooled, ROC results as <code>ROC</code>, 
R squared results as <code>R2</code>, Hosmer and Lemeshow test as <code>HL_test</code>, 
<code>nimp</code>, <code>formula</code>, <code>impvar</code>, <code>val.check</code>, <code>g</code>, 
<code>coef.check</code> and <code>groups_cal</code>.
</p>


<h3>References</h3>

<p>F. Harrell. Regression Modeling Strategies. With Applications to
Linear Models, Logistic and Ordinal Regression, and Survival Analysis. 2nd Edition.
Springer, New York, NY, 2015.
</p>
<p>EW. Steyerberg (2019). Clinical Prediction MOdels. A Practical Approach
to Development, Validation, and Updating (2nd edition). Springer Nature Switzerland AG.
</p>
<p>Van Buuren S. (2018). Flexible Imputation of Missing Data. 2nd Edition. Chapman &amp;
Hall/CRC Interdisciplinary Statistics. Boca Raton.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mivalext_lr(data.val=lbpmilr, nimp=5, impvar="Impnr", 
  formula = Chronic ~ Gender + factor(Carrying)  + Function + 
  Tampascale + Age, lp.orig=c(-10, -0.35, 1.00, 1.00, -0.04, 0.26, -0.01),
  cal.plot=TRUE, val.check = FALSE)

</code></pre>

<hr>
<h2 id='nri_cox'>Net Reclassification Index for Cox Regression Models</h2><span id='topic+nri_cox'></span>

<h3>Description</h3>

<p><code>nri_cox</code> Net Reclassification Index for Cox Regression Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nri_cox(data, formula0, formula1, t_risk, cutoff, B = FALSE, nboot = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nri_cox_+3A_data">data</code></td>
<td>
<p>Data frame with relevant predictors</p>
</td></tr>
<tr><td><code id="nri_cox_+3A_formula0">formula0</code></td>
<td>
<p>A formula object to specify the reference model as normally used by glm.
See under &quot;Details&quot; and &quot;Examples&quot; how these can be specified.</p>
</td></tr>
<tr><td><code id="nri_cox_+3A_formula1">formula1</code></td>
<td>
<p>A formula object to specify the new model as normally used by glm.</p>
</td></tr>
<tr><td><code id="nri_cox_+3A_t_risk">t_risk</code></td>
<td>
<p>Follow-up value to calculate cases, controls. See details.</p>
</td></tr>
<tr><td><code id="nri_cox_+3A_cutoff">cutoff</code></td>
<td>
<p>A numerical vector that defines the outcome probability cutoff values.</p>
</td></tr>
<tr><td><code id="nri_cox_+3A_b">B</code></td>
<td>
<p>A logical  scalar. If TRUE bootstrap confidence intervals are calculated, if FALSE only
the NRI estimates are reported.</p>
</td></tr>
<tr><td><code id="nri_cox_+3A_nboot">nboot</code></td>
<td>
<p>A numerical scalar. Number of bootstrap samples to derive the percentile bootstrap
confidence intervals. Default is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula object has the form <code>Outcome ~ terms</code>. Categorical variables has to
be defined as <code>Outcome ~ factor(variable)</code>, restricted cubic spline variables as
<code>Outcome ~ rcs(variable, 3)</code>. Interaction terms can be defined as
<code>Outcome ~ variable1*variable2</code> or <code>Outcome ~ variable1 + variable2 + variable1:variable2</code>.
All variables in the terms part have to be separated by a &quot;+&quot;. If a formula
object is used set predictors, cat.predictors, spline.predictors or int.predictors
at the default value of NULL.
</p>
<p>Follow-up for which cases nd controls are determined. For censored cases before this follow-up 
the expected risk of being a case is calculated by using the Kaplan-Meier value to calculate
the expected number of cases.These expected numbers are used to calculate the NRI proportions 
but are not shown by function <code>nricens</code>.
</p>


<h3>Value</h3>

<p>An object from which the following objects can be extracted: 
</p>

<ul>
<li>  <p><code>data</code> dataset. 
</p>
</li>
<li>  <p><code>prob_orig</code> outcome risk probabilities at t_risk for reference model.
</p>
</li>
<li>  <p><code>prob_new</code> outcome risk probabilities at t_risk for new model.
</p>
</li>
<li>  <p><code>time</code> name of time variable.
</p>
</li>
<li>  <p><code>status</code> name of status variable.
</p>
</li>
<li>  <p><code>cutoff</code> cutoff value for survival probability. 
</p>
</li>
<li>  <p><code>t_risk</code> follow-up time used to calculate outcome (risk) probabilities.
</p>
</li>
<li>  <p><code>reclass_totals</code> table with total reclassification numbers.
</p>
</li>
<li>  <p><code>reclass_cases</code> table with reclassification numbers for cases.
</p>
</li>
<li>  <p><code>reclass_controls</code> table with reclassification numbers for controls.
</p>
</li>
<li>  <p><code>totals</code> totals of controls, cases, censored cases.
</p>
</li>
<li>  <p><code>km_est</code> totals of cases calculated using Kaplan-Meiers risk estimates.
</p>
</li>
<li>  <p><code>nri_est</code> reclassification measures.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Martijn Heymans, 2023
</p>


<h3>References</h3>

<p>Cook NR, Ridker PM. Advances in measuring the effect of individual predictors of 
cardiovascular risk: the role of reclassification measures. Ann Intern Med. 2009;150(11):795-802.
</p>
<p>Steyerberg EW, Pencina MJ. Reclassification calculations for persons with incomplete 
follow-up. Ann Intern Med. 2010;152(3):195-6; author reply 196-7.
</p>
<p>Pencina MJ, D'Agostino RB Sr, Steyerberg EW. Extensions of net reclassification 
improvement calculations to measure usefulness of new biomarkers. Stat Med. 2011;30(1):11-21
</p>
<p>Inoue E (2018). nricens: NRI for Risk Prediction Models with Time to Event and Binary 
Response Data. R package version 1.6, &lt;https://CRAN.R-project.org/package=nricens&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(survival)
  lbpmicox1 &lt;- subset(psfmi::lbpmicox, Impnr==1) # extract one dataset
  risk_est &lt;- nri_cox(data=lbpmicox1, formula0 = Surv(Time, Status) ~ Duration + Pain,
                   formula1 = Surv(Time, Status) ~ Duration + Pain + Function + Radiation,
                   t_risk = 80, cutoff=c(0.45), B=TRUE, nboot=10)

</code></pre>

<hr>
<h2 id='nri_est'>Calculation of Net Reclassification Index measures</h2><span id='topic+nri_est'></span>

<h3>Description</h3>

<p><code>nri_est</code> Calculation of proportion of Reclassified persons and NRI for Cox 
Regression Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nri_est(data, p0, p1, time, status, t_risk, cutoff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nri_est_+3A_data">data</code></td>
<td>
<p>Data frame with relevant predictors</p>
</td></tr>
<tr><td><code id="nri_est_+3A_p0">p0</code></td>
<td>
<p>risk outcome probabilities for reference model.</p>
</td></tr>
<tr><td><code id="nri_est_+3A_p1">p1</code></td>
<td>
<p>risk outcome probabilities for new model.</p>
</td></tr>
<tr><td><code id="nri_est_+3A_time">time</code></td>
<td>
<p>Character vector. Name of time variable.</p>
</td></tr>
<tr><td><code id="nri_est_+3A_status">status</code></td>
<td>
<p>Character vector. Name of status variable.</p>
</td></tr>
<tr><td><code id="nri_est_+3A_t_risk">t_risk</code></td>
<td>
<p>Follow-up value to calculate cases, controls. See details.</p>
</td></tr>
<tr><td><code id="nri_est_+3A_cutoff">cutoff</code></td>
<td>
<p>A numerical vector that defines the outcome probability cutoff values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Follow-up for which cases nd controls are determined. For censored cases before this follow-up 
the expected risk of being a case is calculated by using the Kaplan-Meier value to calculate
the expected number of cases. These expected numbers are used to calculate the NRI proportions 
but are not shown by function <code>nricens</code>.
</p>


<h3>Value</h3>

<p>An object from which the following objects can be extracted: 
</p>

<ul>
<li>  <p><code>prop_up_case</code> proportion of cases reclassified upwards. 
</p>
</li>
<li>  <p><code>prop_down_case</code> proportion of cases reclassified downwards.
</p>
</li>
<li>  <p><code>prop_up_ctr</code> proportion of controls reclassified upwards.
</p>
</li>
<li>  <p><code>prop_down_ctr</code> proportion of controls reclassified downwards.
</p>
</li>
<li>  <p><code>nri_plus</code> proportion reclassified for events.
</p>
</li>
<li>  <p><code>nri_min</code> proportion reclassified for nonevents. 
</p>
</li>
<li>  <p><code>nri</code> net reclassification improvement.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Martijn Heymans, 2023
</p>


<h3>References</h3>

<p>Cook NR, Ridker PM. Advances in measuring the effect of individual predictors of 
cardiovascular risk: the role of reclassification measures. Ann Intern Med. 2009;150(11):795-802.
</p>
<p>Steyerberg EW, Pencina MJ. Reclassification calculations for persons with incomplete 
follow-up. Ann Intern Med. 2010;152(3):195-6; author reply 196-7.
</p>
<p>Pencina MJ, D'Agostino RB Sr, Steyerberg EW. Extensions of net reclassification 
improvement calculations to measure usefulness of new biomarkers. Stat Med. 2011;30(1):11-21
</p>
<p>Inoue E (2018). nricens: NRI for Risk Prediction Models with Time to Event and Binary 
Response Data. R package version 1.6, &lt;https://CRAN.R-project.org/package=nricens&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(survival)
  lbpmicox1 &lt;- subset(psfmi::lbpmicox, Impnr==1) # extract dataset
  
  fit_cox0 &lt;- 
    coxph(Surv(Time, Status) ~ Duration + Pain, data=lbpmicox1, x=TRUE)
  fit_cox1 &lt;- 
    coxph(Surv(Time, Status) ~ Duration + Pain + Function + Radiation, 
    data=lbpmicox1, x=TRUE)

  p0 &lt;- risk_coxph(fit_cox0, t_risk=80)
  p1 &lt;- risk_coxph(fit_cox1, t_risk=80)
  
  nri &lt;- nri_est(data=lbpmicox1,
                      p0=p0,
                      p1=p1,
                      time = "Time",
                      status = "Status",
                      cutoff=0.45,
                      t_risk=80)

</code></pre>

<hr>
<h2 id='pool_auc'>Calculates the pooled C-statistic (Area Under the ROC Curve) across Multiply Imputed datasets</h2><span id='topic+pool_auc'></span>

<h3>Description</h3>

<p><code>pool_auc</code> Calculates the pooled C-statistic and 95
by using Rubin's Rules. The C-statistic values are log transformed before pooling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_auc(est_auc, est_se, nimp = 5, log_auc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_auc_+3A_est_auc">est_auc</code></td>
<td>
<p>A list of C-statistic (AUC/ROC) values estimated in Multiply Imputed datasets.</p>
</td></tr>
<tr><td><code id="pool_auc_+3A_est_se">est_se</code></td>
<td>
<p>A list of standard errors of C-statistic values estimated 
in Multiply Imputed datasets.</p>
</td></tr>
<tr><td><code id="pool_auc_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="pool_auc_+3A_log_auc">log_auc</code></td>
<td>
<p>If TRUE natural logarithmic transformation is applied before
pooling and finally back transformed. If FALSE the raw values are pooled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pooled C-statistic value and the 95
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>, <code><a href="#topic+pool_performance">pool_performance</a></code>
</p>

<hr>
<h2 id='pool_compare_models'>Compare the fit and performance of prediction models across Multipy Imputed data</h2><span id='topic+pool_compare_models'></span>

<h3>Description</h3>

<p><code>pool_compare_model</code> Compares the fit and performance of prediction models 
in multiply imputed data sets by using clinical important performance measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_compare_models(
  pobj,
  compare.predictors = NULL,
  compare.group = NULL,
  cutoff = 0.5,
  boot_auc = FALSE,
  nboot = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_compare_models_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>pmods</code> (pooled models), produced by a previous
call to <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="pool_compare_models_+3A_compare.predictors">compare.predictors</code></td>
<td>
<p>Character vector with the names of the predictors that are 
compared. See details.</p>
</td></tr>
<tr><td><code id="pool_compare_models_+3A_compare.group">compare.group</code></td>
<td>
<p>Character vector with the names of the group of predictors that are 
compared. See details.</p>
</td></tr>
<tr><td><code id="pool_compare_models_+3A_cutoff">cutoff</code></td>
<td>
<p>A numerical scalar. Cutoff used for the categorical NRI value. More than one
cutoff value can be used.</p>
</td></tr>
<tr><td><code id="pool_compare_models_+3A_boot_auc">boot_auc</code></td>
<td>
<p>If TRUE the standard error of the AUC is calculated with stratified
bootstrapping. If FALSE (is default), the standard error is calculated with De Long's
method.</p>
</td></tr>
<tr><td><code id="pool_compare_models_+3A_nboot">nboot</code></td>
<td>
<p>A numerical scalar. The number of bootstrap samples for the AUC standard error, used 
when boot_auc is TRUE. Default is 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fit of the models are compared by using the D3 method for pooling Likelihood ratio 
statistics (method of Meng and Rubin). The pooled AIC difference is calculated according to
the formula <code>AIC = D - 2*p</code>, where D is the pooled likelihood ratio tests of 
constrained models (numerator in D3 statistic) and p is the difference in number of parameters 
between the full and restricted models that are compared. The pooled AUC difference  
is calculated, after the standard error is obtained in each imputed data set by method 
DeLong or bootstrapping. The NRI categorical and continuous and IDI are calculated in each 
imputed data set and pooled.
</p>


<h3>Value</h3>

<p>An object from which the following objects can be extracted: 
</p>

<ul>
<li>  <p><code>DR_stats</code> p-value of the D3 statistic, the D3 statistic, LRT fixed is the 
likelihood Ratio test value of the constrained models.
</p>
</li>
<li>  <p><code>stats_compare</code> Mean of LogLik0, LogLik1, AIC0, AIC1, AIC_diff values of the 
restricted (containing a 0) and full models (containing a 1).
</p>
</li>
<li>  <p><code>NRI</code> pooled values for the categorical and continuous Net Reclassification
improvement values and the Integrated Discrimination improvement.
</p>
</li>
<li>  <p><code>AUC_stats</code> Pooled Area Under the Curve of restricted and full models. 
</p>
</li>
<li>  <p><code>AUC_diff</code> Pooled difference in AUC. 
</p>
</li>
<li>  <p><code>formula_test</code> regression formula of full model.
</p>
</li>
<li>  <p><code>cutoff</code> Cutoff value used for reclassification values.
</p>
</li>
<li>  <p><code>formula_null</code> regression formula of null model
</p>
</li>
<li>  <p><code>compare_predictors</code> Predictors used in full model.
</p>
</li>
<li>  <p><code>compare_group</code> group of predictors used in full model.
</p>
</li></ul>



<h3>References</h3>

<p>Eekhout I, van de Wiel MA, Heymans MW. Methods for significance testing of categorical
covariates in logistic regression models after multiple imputation: power and applicability
analysis. BMC Med Res Methodol. 2017;17(1):129.
</p>
<p>Consentino F, Claeskens G. Order Selection tests with multiply imputed data
Computational Statistics and Data Analysis.2010;54:2284-2295.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> pool_lr &lt;- psfmi_lr(data=lbpmilr, p.crit = 1, direction="FW", nimp=10, impvar="Impnr", 
 Outcome="Chronic", predictors=c("Radiation"), cat.predictors = ("Satisfaction"),
 int.predictors = NULL, spline.predictors="Tampascale", nknots=3, method="D1")

 res_compare &lt;- pool_compare_models(pool_lr, compare.predictors = c("Pain", "Duration", 
 "Function"), cutoff = 0.4)
 res_compare

 
</code></pre>

<hr>
<h2 id='pool_D2'>Combines the Chi Square statistics across Multiply Imputed datasets</h2><span id='topic+pool_D2'></span>

<h3>Description</h3>

<p><code>pool_D2</code> The D2 statistic to combine the Chi square values 
across Multiply Imputed datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_D2(dw, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_D2_+3A_dw">dw</code></td>
<td>
<p>a vector of Chi square values obtained after multiple imputation.</p>
</td></tr>
<tr><td><code id="pool_D2_+3A_v">v</code></td>
<td>
<p>single value for the degrees of freedom of the Chi square statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pooled chi square values as the D2 statistic, the p-value,
the numerator, df1 and denominator, df2 degrees of freedom for the
F-test.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>References</h3>

<p>Eekhout I, van de Wiel MA, Heymans MW. Methods for significance testing of categorical
covariates in logistic regression models after multiple imputation: power and applicability
analysis. BMC Med Res Methodol. 2017;17(1):129.
</p>
<p>Van Buuren S. (2018). Flexible Imputation of Missing Data. 2nd Edition. Chapman &amp; Hall/CRC
Interdisciplinary Statistics. Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pool_D2(c(2.25, 3.95, 6.24, 5.27, 2.81), 4) 
 
</code></pre>

<hr>
<h2 id='pool_D4'>Pools the Likelihood Ratio tests across Multiply Imputed datasets ( method D4)</h2><span id='topic+pool_D4'></span>

<h3>Description</h3>

<p><code>pool_D4</code> The D4 statistic to combine the likelihood ratio tests (LRT)
across Multiply Imputed datasets according method D4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_D4(data, nimp, impvar, fm0, fm1, robust = TRUE, model_type = "binomial")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_D4_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="pool_D4_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="pool_D4_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="pool_D4_+3A_fm0">fm0</code></td>
<td>
<p>the null model.</p>
</td></tr>
<tr><td><code id="pool_D4_+3A_fm1">fm1</code></td>
<td>
<p>the (nested) model to compare. Must be larger than the null model.</p>
</td></tr>
<tr><td><code id="pool_D4_+3A_robust">robust</code></td>
<td>
<p>if TRUE a robust LRT is used (algorithm 1 in Chan and Meng), otherwise 
algorithm 2 is used.</p>
</td></tr>
<tr><td><code id="pool_D4_+3A_model_type">model_type</code></td>
<td>
<p>if TRUE (default) a logistic regression model is fitted, otherwise
a linear regression model is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The D4 statistic, the numerator, df1 and denominator, df2 degrees of freedom 
for the F-test.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>References</h3>

<p>Chan, K. W., &amp; Meng, X.-L. (2019). Multiple improvements of multiple 
imputation likelihood ratio tests. ArXiv:1711.08822 [Math, Stat]. https://arxiv.org/abs/1711.08822
</p>
<p>Grund, Simon, Oliver Lüdtke, and Alexander Robitzsch. 2021. “Pooling Methods for 
Likelihood Ratio Tests in Multiply Imputed Data Sets.” PsyArXiv. January 29. doi:10.31234/osf.io/d459g.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fm0 &lt;- Chronic ~ BMI + factor(Carrying) + 
  Satisfaction + SocialSupport + Smoking
fm1 &lt;- Chronic ~ BMI + factor(Carrying) + 
  Satisfaction +  SocialSupport + Smoking +
  Radiation

psfmi::pool_D4(data=lbpmilr, nimp=10, impvar="Impnr",
               fm0=fm0, fm1=fm1, robust = TRUE)
   
</code></pre>

<hr>
<h2 id='pool_intadj'>Provides pooled adjusted intercept after shrinkage of pooled coefficients 
in multiply imputed datasets</h2><span id='topic+pool_intadj'></span>

<h3>Description</h3>

<p><code>pool_intadj</code> Provides pooled adjusted intercept after shrinkage of the pooled coefficients 
in multiply imputed datasets for models selected with the <code>psfmi_lr</code> function and 
internally validated with the <code>psfmi_perform</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_intadj(pobj, shrinkage_factor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_intadj_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>smodsmi</code> (selected models in multiply imputed datasets), 
produced by a previous call to <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="pool_intadj_+3A_shrinkage_factor">shrinkage_factor</code></td>
<td>
<p>A numerical scalar. Shrinkage factor value as a result of internal validation
with the <code>psfmi_perform</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides the pooled adjusted intercept after shrinkage of pooled
regression coefficients in multiply imputed datasets. The function is only available 
for logistic regression models without random effects.
</p>


<h3>Value</h3>

<p>A <code>pool_intadj</code> object from which the following objects can be extracted: <code>int_adj</code>, 
the adjusted intercept value, <code>coef_shrink_pooled</code>, the pooled regression coefficients 
after shrinkage, <code>coef_orig_pooled</code>, the (original) pooled regression coefficients before
shrinkage and <code>nimp</code>, the number of imputed datasets.
</p>


<h3>References</h3>

<p>F. Harrell. Regression Modeling Strategies. With Applications to
Linear Models, Logistic and Ordinal Regression, and Survival Analysis (2nd edition). Springer,
New York, NY, 2015.
</p>
<p>EW. Steyerberg (2019). Clinical Prediction MOdels. A Practical Approach 
to Development, Validation, and Updating (2nd edition). Springer Nature Switzerland AG.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'> res_psfmi &lt;- psfmi_lr(data=lbpmilr, nimp=5, impvar="Impnr", Outcome="Chronic",
           predictors=c("Gender", "Pain","Tampascale","Smoking","Function", 
           "Radiation", "Age"), p.crit = 1, method="D1", direction="BW")
 res_psfmi$RR_Model

## Not run: 
 set.seed(100)
 res_val &lt;- psfmi_perform(res_psfmi, method = "MI_boot", nboot=10, 
   int_val = TRUE, p.crit=1, cal.plot=FALSE, plot.indiv=FALSE)
 res_val$intval

 res &lt;- pool_intadj(res_psfmi, shrinkage_factor = 0.9774058)
 res$int_adj
 res$coef_shrink_pooled
 
## End(Not run) 
  
</code></pre>

<hr>
<h2 id='pool_performance'>Pooling performance measures across multiply imputed datasets</h2><span id='topic+pool_performance'></span>

<h3>Description</h3>

<p><code>pool_performance</code> Pooling performance measures for logistic
and Cox regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_performance(
  data,
  formula,
  nimp,
  impvar,
  plot.indiv,
  model_type = "binomial",
  cal.plot = TRUE,
  plot.method = "mean",
  groups_cal = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_performance_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded 
from the dataset.</p>
</td></tr>
<tr><td><code id="pool_performance_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by glm
or coxph. See details.</p>
</td></tr>
<tr><td><code id="pool_performance_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="pool_performance_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes 
the imputed datasets.</p>
</td></tr>
<tr><td><code id="pool_performance_+3A_plot.indiv">plot.indiv</code></td>
<td>
<p>This argument is deprecated; please use plot.method instead.</p>
</td></tr>
<tr><td><code id="pool_performance_+3A_model_type">model_type</code></td>
<td>
<p>If &quot;binomial&quot; (default), performance measures are calculated
for logistic regression models, if &quot;survival&quot; for Cox regression models. See details.</p>
</td></tr>
<tr><td><code id="pool_performance_+3A_cal.plot">cal.plot</code></td>
<td>
<p>If TRUE a calibration plot is generated. Default is TRUE. 
model_type must be &quot;binomial&quot;.</p>
</td></tr>
<tr><td><code id="pool_performance_+3A_plot.method">plot.method</code></td>
<td>
<p>If &quot;mean&quot; one calibration plot is generated, first taking the 
mean of the linear predictor across the multiply imputed datasets (default), if 
&quot;individual&quot; the calibration plot of each imputed dataset is plotted, 
if &quot;overlay&quot; calibration plots from each imputed datasets are plotted in one figure.</p>
</td></tr>
<tr><td><code id="pool_performance_+3A_groups_cal">groups_cal</code></td>
<td>
<p>A numerical scalar. Number of groups used on the calibration plot and. 
for the Hosmer and Lemeshow test. Default is 10. If the range of predicted probabilities. 
is low, less than 10 groups can be chosen, but not &lt; 3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula object for logistic regression models has the form 
<code>formula = Outcome ~ terms</code>. For Cox regression models the formula object must
be defined as <code>Surv(time, status) ~ terms</code>. For Cox models calibration curves 
can not be generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> perf &lt;- pool_performance(data=lbpmilr, nimp=5, impvar="Impnr", 
 formula = Chronic ~ Gender + Pain + Tampascale + 
 Smoking + Function + Radiation + Age + factor(Carrying), 
 cal.plot=TRUE, plot.method="mean", 
 groups_cal=10, model_type="binomial")
 
 perf$ROC_pooled
 perf$R2_pooled
 
</code></pre>

<hr>
<h2 id='pool_performance_internal'>Pooling performance measures over multiply imputed datasets</h2><span id='topic+pool_performance_internal'></span>

<h3>Description</h3>

<p><code>pool_performance_internal</code> Pooling performance measures
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_performance_internal(data, formula, nimp, impvar)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_performance_internal_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded 
from the dataset.</p>
</td></tr>
<tr><td><code id="pool_performance_internal_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by glm.</p>
</td></tr>
<tr><td><code id="pool_performance_internal_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="pool_performance_internal_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes 
the imputed datasets.</p>
</td></tr>
</table>

<hr>
<h2 id='pool_reclassification'>Function to pool NRI measures over Multiply Imputed datasets</h2><span id='topic+pool_reclassification'></span>

<h3>Description</h3>

<p><code>pool_reclassification</code> Function to pool categorical and continuous NRI
and IDI over Multiply Imputed datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_reclassification(datasets, cutoff = cutoff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_reclassification_+3A_datasets">datasets</code></td>
<td>
<p>a list of data frames corresponding to the multiply imputed
datasets, within each dataset in the first column the predicted probabilities
of model 1, in the second column those of model 2 and in the third column
the observed outcomes coded as '0'and '1'.</p>
</td></tr>
<tr><td><code id="pool_reclassification_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff value for the categorical NRI, must lie between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by the function <code>pool_compare_model</code>
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>

<hr>
<h2 id='pool_RR'>Function to combine estimates by using Rubin's Rules</h2><span id='topic+pool_RR'></span>

<h3>Description</h3>

<p><code>pool_RR</code> Rubin's Rules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool_RR(est, se, conf.level = 0.95, n, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pool_RR_+3A_est">est</code></td>
<td>
<p>A vector of multiple parameter estimates</p>
</td></tr>
<tr><td><code id="pool_RR_+3A_se">se</code></td>
<td>
<p>A vector of multiple standard error estimates</p>
</td></tr>
<tr><td><code id="pool_RR_+3A_conf.level">conf.level</code></td>
<td>
<p>desired confidence limits</p>
</td></tr>
<tr><td><code id="pool_RR_+3A_n">n</code></td>
<td>
<p>sample size in completed dataset</p>
</td></tr>
<tr><td><code id="pool_RR_+3A_k">k</code></td>
<td>
<p>number of parameters to pool</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>

<hr>
<h2 id='psfmi_coxr'>Pooling and Predictor selection function for backward or forward selection of
Cox regression models across multiply imputed data.</h2><span id='topic+psfmi_coxr'></span>

<h3>Description</h3>

<p><code>psfmi_coxr</code> Pooling and backward or forward selection of Cox regression
prediction models in multiply imputed data using selection methods D1, D2 and MPR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_coxr(
  data,
  formula = NULL,
  nimp = 5,
  impvar = NULL,
  time,
  status,
  predictors = NULL,
  cat.predictors = NULL,
  spline.predictors = NULL,
  int.predictors = NULL,
  keep.predictors = NULL,
  strata.variable = NULL,
  nknots = NULL,
  p.crit = 1,
  method = "RR",
  direction = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_coxr_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by coxph.
See under &quot;Details&quot; and &quot;Examples&quot; how these can be specified. If a formula
object is used set predictors, cat.predictors, spline.predictors or int.predictors
at the default value of NULL.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_time">time</code></td>
<td>
<p>Survival time.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_status">status</code></td>
<td>
<p>The status variable, normally 0=censoring, 1=event.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, gnder10, etc.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_cat.predictors">cat.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
categorical variables. Default is NULL categorical predictors.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_spline.predictors">spline.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
(restricted cubic) spline variables. Default is NULL spline predictors. See details.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_int.predictors">int.predictors</code></td>
<td>
<p>A single string or a vector of strings with the names of the variables that form
an interaction pair, separated by a “:” symbol.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_keep.predictors">keep.predictors</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. Categorical and interaction variables are allowed.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_strata.variable">strata.variable</code></td>
<td>
<p>A single string including the strata variable. See under &quot;Details&quot; 
and &quot;Examples&quot; how such a variable can be specified.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_nknots">nknots</code></td>
<td>
<p>A numerical vector that defines the number of knots for each spline predictor separately.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterion. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;RR&quot;, D1&quot;, &quot;D2&quot;, or &quot;MPR&quot;.
See details for more information. Default is &quot;RR&quot;.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_+3A_direction">direction</code></td>
<td>
<p>The direction of predictor selection, &quot;BW&quot; means backward selection and &quot;FW&quot;
means forward selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic pooling procedure to derive pooled coefficients, standard errors, 95
confidence intervals and p-values is Rubin's Rules (RR). However, RR is only possible when
the model included continuous or dichotomous variables. Specific procedures are
available when the model also included categorical (&gt; 2 categories) or restricted cubic spline
variables. These pooling methods are: “D1” is pooling of the total covariance matrix,
”D2” is pooling of Chi-square values and “MPR” is pooling of median p-values (MPR rule).
Spline regression coefficients are defined by using the rcs function for restricted cubic
splines of the rms package. A minimum number of 3 knots as defined under knots is required.
</p>
<p>A typical formula object has the form <code>Surv(time, status) ~ terms</code>. Categorical variables has to
be defined as <code>Surv(time, status) ~ factor(variable)</code>, restricted cubic spline variables as
<code>Surv(time, status) ~ rcs(variable, 3)</code>. Interaction terms can be defined as
<code>Surv(time, status) ~ variable1*variable2</code> or <code>Surv(time, status) ~ variable1 + variable2 + 
 variable1:variable2</code>. All variables in the terms part have to be separated by a &quot;+&quot;. If a formula
object is used set predictors, cat.predictors, spline.predictors or int.predictors
at the default value of NULL. For Cox models also a strata variable is allowed to include in 
the formula as <code>Surv(time, status) ~ strata(variable) + terms</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>pmods</code> (multiply imputed models) from
which the following objects can be extracted: 
</p>

<ul>
<li>  <p><code>data</code> imputed datasets
</p>
</li>
<li>  <p><code>RR_model</code> pooled model at each selection step
</p>
</li>
<li>  <p><code>RR_model_final</code> final selected pooled model
</p>
</li>
<li>  <p><code>multiparm</code> pooled p-values at each step according to pooling method
</p>
</li>
<li>  <p><code>multiparm_final</code> pooled p-values at final step according to pooling method
</p>
</li>
<li>  <p><code>multiparm_out</code> (only when direction = &quot;FW&quot;) pooled p-values of removed predictors 
</p>
</li>
<li>  <p><code>formula_step</code> formula object at each step
</p>
</li>
<li>  <p><code>formula_final</code> formula object at final step
</p>
</li>
<li>  <p><code>formula_initial</code> formula object at final step
</p>
</li>
<li>  <p><code>predictors_in</code> predictors included at each selection step
</p>
</li>
<li>  <p><code>predictors_out</code> predictors excluded at each step
</p>
</li>
<li>  <p><code>impvar</code> name of variable used to distinguish imputed datasets
</p>
</li>
<li>  <p><code>nimp</code> number of imputed datasets
</p>
</li>
<li>  <p><code>status</code> name of the status variable
</p>
</li>
<li>  <p><code>time</code> name of the time variable
</p>
</li>
<li>  <p><code>method</code> selection method
</p>
</li>
<li>  <p><code>p.crit</code> p-value selection criterium
</p>
</li>
<li>  <p><code>call</code> function call
</p>
</li>
<li>  <p><code>model_type</code> type of regression model used
</p>
</li>
<li>  <p><code>direction</code> direction of predictor selection
</p>
</li>
<li>  <p><code>predictors_final</code> names of predictors in final selection step
</p>
</li>
<li>  <p><code>predictors_initial</code> names of predictors in start model
</p>
</li>
<li>  <p><code>keep.predictors</code> names of predictors that were forced in the model
</p>
</li>
<li>  <p><code>strata.variable</code> names of the strata variable in the model    
</p>
</li></ul>



<h3>Vignettes</h3>

<p>https://mwheymans.github.io/psfmi/articles/psfmi_CoxModels.html
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>References</h3>

<p>Eekhout I, van de Wiel MA, Heymans MW. Methods for significance testing of categorical
covariates in logistic regression models after multiple imputation: power and applicability
analysis. BMC Med Res Methodol. 2017;17(1):129.
</p>
<p>Enders CK (2010). Applied missing data analysis. New York: The Guilford Press.
</p>
<p>van de Wiel MA, Berkhof J, van Wieringen WN. Testing the prediction error difference between
2 predictors. Biostatistics. 2009;10:550-60.
</p>
<p>Marshall A, Altman DG, Holder RL, Royston P. Combining estimates of interest in prognostic
modelling studies after multiple imputation: current practice and guidelines. BMC Med Res Methodol.
2009;9:57.
</p>
<p>Van Buuren S. (2018). Flexible Imputation of Missing Data. 2nd Edition. Chapman &amp; Hall/CRC
Interdisciplinary Statistics. Boca Raton.
</p>
<p>EW. Steyerberg (2019). Clinical Prediction MOdels. A Practical Approach
to Development, Validation, and Updating (2nd edition). Springer Nature Switzerland AG.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'> pool_coxr &lt;- psfmi_coxr(formula = Surv(Time, Status) ~ Pain + Tampascale +
                       Radiation + Radiation*Pain + Age + Duration + Previous,
                     data=lbpmicox, p.crit = 0.05, direction="BW", nimp=5, impvar="Impnr",
                     keep.predictors = "Radiation*Pain", method="D1")
                     
 pool_coxr$RR_model_final
 
 pool_coxr &lt;- psfmi_coxr(formula = Surv(Time, Status) ~ Pain + Tampascale +
                       Previous + strata(Radiation), data=lbpmicox, p.crit = 0.05, 
                       direction="BW", nimp=5, impvar="Impnr", method="D1")
                     
 pool_coxr$RR_model_final
 
</code></pre>

<hr>
<h2 id='psfmi_coxr_bw'>Backward selection of Cox regression models in multiply imputed data.</h2><span id='topic+psfmi_coxr_bw'></span>

<h3>Description</h3>

<p><code>psfmi_coxr_bw</code> Backward selection of Cox regression
models in multiply imputed data using selection methods RR, D1, D2 and MPR.
Function is called by <code>psfmi_coxr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_coxr_bw(
  data,
  nimp,
  impvar,
  status,
  time,
  P,
  p.crit,
  method,
  keep.P,
  strata.P
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_coxr_bw_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_bw_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_bw_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_bw_+3A_status">status</code></td>
<td>
<p>The status variable, normally 0=censoring, 1=event.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_bw_+3A_time">time</code></td>
<td>
<p>Follow up time.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_bw_+3A_p">P</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, BMI10, etc.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_bw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_bw_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;RR&quot;, D1&quot;, &quot;D2&quot; or &quot;MPR&quot;.
See details for more information. Default is &quot;RR&quot;.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_bw_+3A_keep.p">keep.P</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_bw_+3A_strata.p">strata.P</code></td>
<td>
<p>A single string including the strata variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>

<hr>
<h2 id='psfmi_coxr_fw'>Forward selection of Cox regression models across multiply imputed data.</h2><span id='topic+psfmi_coxr_fw'></span>

<h3>Description</h3>

<p><code>psfmi_coxr_fw</code> Forward selection of Cox regression
models across multiply imputed data using selection methods RR, D1, D2 and MPR.
Function is called by <code>psfmi_coxr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_coxr_fw(
  data,
  nimp,
  impvar,
  status,
  time,
  p.crit,
  P,
  keep.P,
  method,
  strata.P
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_coxr_fw_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_fw_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_fw_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_fw_+3A_status">status</code></td>
<td>
<p>The status variable, normally 0=censoring, 1=event.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_fw_+3A_time">time</code></td>
<td>
<p>Follow up time.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_fw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_fw_+3A_p">P</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, BMI10, etc.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_fw_+3A_keep.p">keep.P</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_fw_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;RR&quot;, D1&quot;, &quot;D2&quot; or &quot;MPR&quot;.
See details for more information. Default is &quot;RR&quot;.</p>
</td></tr>
<tr><td><code id="psfmi_coxr_fw_+3A_strata.p">strata.P</code></td>
<td>
<p>A single string including the strata variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>

<hr>
<h2 id='psfmi_lm'>Pooling and Predictor selection function for backward or forward selection of
Linear regression models across multiply imputed data.</h2><span id='topic+psfmi_lm'></span>

<h3>Description</h3>

<p><code>psfmi_lm</code> Pooling and backward or forward selection of Linear regression
models in multiply imputed data using selection methods RR, D1, D2 and MPR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_lm(
  data,
  formula = NULL,
  nimp = 5,
  impvar = NULL,
  Outcome = NULL,
  predictors = NULL,
  cat.predictors = NULL,
  spline.predictors = NULL,
  int.predictors = NULL,
  keep.predictors = NULL,
  nknots = NULL,
  p.crit = 1,
  method = "RR",
  direction = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_lm_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by glm.
See under &quot;Details&quot; and &quot;Examples&quot; how these can be specified. If a formula
object is used set predictors, cat.predictors, spline.predictors or int.predictors
at the default value of NULL.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the continuous outcome variable.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, gender10, etc.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_cat.predictors">cat.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
categorical variables. Default is NULL categorical predictors.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_spline.predictors">spline.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
(restricted cubic) spline variables. Default is NULL spline predictors. See details.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_int.predictors">int.predictors</code></td>
<td>
<p>A single string or a vector of strings with the names of the variables that form
an interaction pair, separated by a “:” symbol.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_keep.predictors">keep.predictors</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_nknots">nknots</code></td>
<td>
<p>A numerical vector that defines the number of knots for each spline predictor separately.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;RR&quot;, D1&quot;, &quot;D2&quot;, &quot;D3&quot; or &quot;MPR&quot;.
See details for more information. Default is &quot;RR&quot;.</p>
</td></tr>
<tr><td><code id="psfmi_lm_+3A_direction">direction</code></td>
<td>
<p>The direction of predictor selection, &quot;BW&quot; means backward selection and &quot;FW&quot;
means forward selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic pooling procedure to derive pooled coefficients, standard errors, 95
confidence intervals and p-values is Rubin's Rules (RR). However, RR is only possible when
the model included continuous or dichotomous variables. Specific procedures are
available when the model also included categorical (&gt; 2 categories) or restricted cubic spline
variables. These pooling methods are: “D1” is pooling of the total covariance matrix,
”D2” is pooling of Chi-square values and “MPR” is pooling of median p-values (MPR rule).
Spline regression coefficients are defined by using the rcs function for restricted cubic
splines of the rms package. A minimum number of 3 knots as defined under knots is required.
</p>
<p>A typical formula object has the form <code>Outcome ~ terms</code>. Categorical variables has to
be defined as <code>Outcome ~ factor(variable)</code>, restricted cubic spline variables as
<code>Outcome ~ rcs(variable, 3)</code>. Interaction terms can be defined as
<code>Outcome ~ variable1*variable2</code> or <code>Outcome ~ variable1 + variable2 + variable1:variable2</code>.
All variables in the terms part have to be separated by a &quot;+&quot;. If a formula
object is used set predictors, cat.predictors, spline.predictors or int.predictors
at the default value of NULL.
</p>


<h3>Value</h3>

<p>An object of class <code>pmods</code> (multiply imputed models) from
which the following objects can be extracted: 
</p>

<ul>
<li>  <p><code>data</code> imputed datasets
</p>
</li>
<li>  <p><code>RR_model</code> pooled model at each selection step
</p>
</li>
<li>  <p><code>RR_model_final</code> final selected pooled model
</p>
</li>
<li>  <p><code>multiparm</code> pooled p-values at each step according to pooling method
</p>
</li>
<li>  <p><code>multiparm_final</code> pooled p-values at final step according to pooling method
</p>
</li>
<li>  <p><code>multiparm_out</code> (only when direction = &quot;FW&quot;) pooled p-values of removed predictors 
</p>
</li>
<li>  <p><code>formula_step</code> formula object at each step
</p>
</li>
<li>  <p><code>formula_final</code> formula object at final step
</p>
</li>
<li>  <p><code>formula_initial</code> formula object at final step
</p>
</li>
<li>  <p><code>predictors_in</code> predictors included at each selection step
</p>
</li>
<li>  <p><code>predictors_out</code> predictors excluded at each step
</p>
</li>
<li>  <p><code>impvar</code> name of variable used to distinguish imputed datasets
</p>
</li>
<li>  <p><code>nimp</code> number of imputed datasets
</p>
</li>
<li>  <p><code>Outcome</code> name of the outcome variable
</p>
</li>
<li>  <p><code>method</code> selection method
</p>
</li>
<li>  <p><code>p.crit</code> p-value selection criterium
</p>
</li>
<li>  <p><code>call</code> function call
</p>
</li>
<li>  <p><code>model_type</code> type of regression model used
</p>
</li>
<li>  <p><code>direction</code> direction of predictor selection
</p>
</li>
<li>  <p><code>predictors_final</code> names of predictors in final selection step
</p>
</li>
<li>  <p><code>predictors_initial</code> names of predictors in start model
</p>
</li>
<li>  <p><code>keep.predictors</code> names of predictors that were forced in the model    
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>References</h3>

<p>Enders CK (2010). Applied missing data analysis. New York: The Guilford Press.
</p>
<p>van de Wiel MA, Berkhof J, van Wieringen WN. Testing the prediction error difference between
2 predictors. Biostatistics. 2009;10:550-60.
</p>
<p>Marshall A, Altman DG, Holder RL, Royston P. Combining estimates of interest in prognostic
modelling studies after multiple imputation: current practice and guidelines. BMC Med Res Methodol.
2009;9:57.
</p>
<p>Van Buuren S. (2018). Flexible Imputation of Missing Data. 2nd Edition. Chapman &amp; Hall/CRC
Interdisciplinary Statistics. Boca Raton.
</p>
<p>EW. Steyerberg (2019). Clinical Prediction MOdels. A Practical Approach
to Development, Validation, and Updating (2nd edition). Springer Nature Switzerland AG.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pool_lm &lt;- psfmi_lm(data=lbpmilr, formula = Pain ~ factor(Satisfaction) + 
  rcs(Tampascale,3) + Radiation + 
  Radiation*factor(Satisfaction) + Age + Duration + BMI,
  p.crit = 0.05, direction="FW", nimp=5, impvar="Impnr", 
  keep.predictors = c("Radiation*factor(Satisfaction)", "Age"), method="D1")
  
  pool_lm$RR_model_final

</code></pre>

<hr>
<h2 id='psfmi_lm_bw'>Backward selection of Linear regression models across multiply imputed data.</h2><span id='topic+psfmi_lm_bw'></span>

<h3>Description</h3>

<p><code>psfmi_lm_bw</code> Backward selection of Linear regression
models across multiply imputed data using selection methods RR, D1, D2, D4 and MPR.
Function is called by <code>psfmi_lm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_lm_bw(data, nimp, impvar, Outcome, P, p.crit, method, keep.P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_lm_bw_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="psfmi_lm_bw_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_lm_bw_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_lm_bw_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the continuous outcome variable.</p>
</td></tr>
<tr><td><code id="psfmi_lm_bw_+3A_p">P</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, BMI10, etc.</p>
</td></tr>
<tr><td><code id="psfmi_lm_bw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_lm_bw_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;RR&quot;, D1&quot;, &quot;D2&quot; or &quot;MPR&quot;.
See details for more information. Default is &quot;RR&quot;.</p>
</td></tr>
<tr><td><code id="psfmi_lm_bw_+3A_keep.p">keep.P</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>

<hr>
<h2 id='psfmi_lm_fw'>Forward selection of Linear regression models across multiply imputed data.</h2><span id='topic+psfmi_lm_fw'></span>

<h3>Description</h3>

<p><code>psfmi_lm_fw</code> Forward selection of Linear regression
models across multiply imputed data using selection methods RR, D1, D2, D4 and MPR.
Function is called by <code>psfmi_lm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_lm_fw(data, nimp, impvar, Outcome, P, p.crit, method, keep.P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_lm_fw_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="psfmi_lm_fw_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_lm_fw_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_lm_fw_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the continuous outcome variable.</p>
</td></tr>
<tr><td><code id="psfmi_lm_fw_+3A_p">P</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, BMI10, etc.</p>
</td></tr>
<tr><td><code id="psfmi_lm_fw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_lm_fw_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;RR&quot;, D1&quot;, &quot;D2&quot;, &quot;D4&quot;, or &quot;MPR&quot;.
See details for more information. Default is &quot;RR&quot;.</p>
</td></tr>
<tr><td><code id="psfmi_lm_fw_+3A_keep.p">keep.P</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. Categorical and interaction variables are allowed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>

<hr>
<h2 id='psfmi_lr'>Pooling and Predictor selection function for backward or forward selection of
Logistic regression models across multiply imputed data.</h2><span id='topic+psfmi_lr'></span>

<h3>Description</h3>

<p><code>psfmi_lr</code> Pooling and backward or forward selection of Logistic regression
models across multiply imputed data using selection methods RR, D1, D2, D3, D4 and MPR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_lr(
  data,
  formula = NULL,
  nimp = 5,
  impvar = NULL,
  Outcome = NULL,
  predictors = NULL,
  cat.predictors = NULL,
  spline.predictors = NULL,
  int.predictors = NULL,
  keep.predictors = NULL,
  nknots = NULL,
  p.crit = 1,
  method = "RR",
  direction = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_lr_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_formula">formula</code></td>
<td>
<p>A formula object to specify the model as normally used by glm.
See under &quot;Details&quot; and &quot;Examples&quot; how these can be specified. If a formula
object is used set predictors, cat.predictors, spline.predictors or int.predictors
at the default value of NULL.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the outcome variable.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, gender10, etc.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_cat.predictors">cat.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
categorical variables. Default is NULL categorical predictors.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_spline.predictors">spline.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
(restricted cubic) spline variables. Default is NULL spline predictors. See details.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_int.predictors">int.predictors</code></td>
<td>
<p>A single string or a vector of strings with the names of the variables that form
an interaction pair, separated by a “:” symbol.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_keep.predictors">keep.predictors</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_nknots">nknots</code></td>
<td>
<p>A numerical vector that defines the number of knots for each spline predictor separately.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;RR&quot;, D1&quot;, &quot;D2&quot;, &quot;D3&quot;, &quot;D4&quot;, or &quot;MPR&quot;.
See details for more information. Default is &quot;RR&quot;.</p>
</td></tr>
<tr><td><code id="psfmi_lr_+3A_direction">direction</code></td>
<td>
<p>The direction of predictor selection, &quot;BW&quot; means backward selection and &quot;FW&quot;
means forward selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic pooling procedure to derive pooled coefficients, standard errors, 95
confidence intervals and p-values is Rubin's Rules (RR). However, RR is only possible when
the model included continuous or dichotomous variables. Specific procedures are
available when the model also included categorical (&gt; 2 categories) or restricted cubic spline
variables. These pooling methods are: “D1” is pooling of the total covariance matrix,
”D2” is pooling of Chi-square values, “D3” and &quot;D4&quot; is pooling Likelihood ratio statistics
(method of Meng and Rubin) and “MPR” is pooling of median p-values (MPR rule).
Spline regression coefficients are defined by using the rcs function for restricted cubic
splines of the rms package. A minimum number of 3 knots as defined under knots is required.
</p>
<p>A typical formula object has the form <code>Outcome ~ terms</code>. Categorical variables has to
be defined as <code>Outcome ~ factor(variable)</code>, restricted cubic spline variables as
<code>Outcome ~ rcs(variable, 3)</code>. Interaction terms can be defined as
<code>Outcome ~ variable1*variable2</code> or <code>Outcome ~ variable1 + variable2 + variable1:variable2</code>.
All variables in the terms part have to be separated by a &quot;+&quot;. If a formula
object is used set predictors, cat.predictors, spline.predictors or int.predictors
at the default value of NULL.
</p>


<h3>Value</h3>

<p>An object of class <code>pmods</code> (multiply imputed models) from
which the following objects can be extracted: 
</p>

<ul>
<li>  <p><code>data</code> imputed datasets
</p>
</li>
<li>  <p><code>RR_model</code> pooled model at each selection step
</p>
</li>
<li>  <p><code>RR_model_final</code> final selected pooled model
</p>
</li>
<li>  <p><code>multiparm</code> pooled p-values at each step according to pooling method
</p>
</li>
<li>  <p><code>multiparm_final</code> pooled p-values at final step according to pooling method
</p>
</li>
<li>  <p><code>multiparm_out</code> (only when direction = &quot;FW&quot;) pooled p-values of removed predictors 
</p>
</li>
<li>  <p><code>formula_step</code> formula object at each step
</p>
</li>
<li>  <p><code>formula_final</code> formula object at final step
</p>
</li>
<li>  <p><code>formula_initial</code> formula object at final step
</p>
</li>
<li>  <p><code>predictors_in</code> predictors included at each selection step
</p>
</li>
<li>  <p><code>predictors_out</code> predictors excluded at each step
</p>
</li>
<li>  <p><code>impvar</code> name of variable used to distinguish imputed datasets
</p>
</li>
<li>  <p><code>nimp</code> number of imputed datasets
</p>
</li>
<li>  <p><code>Outcome</code> name of the outcome variable
</p>
</li>
<li>  <p><code>method</code> selection method
</p>
</li>
<li>  <p><code>p.crit</code> p-value selection criterium
</p>
</li>
<li>  <p><code>call</code> function call
</p>
</li>
<li>  <p><code>model_type</code> type of regression model used
</p>
</li>
<li>  <p><code>direction</code> direction of predictor selection
</p>
</li>
<li>  <p><code>predictors_final</code> names of predictors in final selection step
</p>
</li>
<li>  <p><code>predictors_initial</code> names of predictors in start model
</p>
</li>
<li>  <p><code>keep.predictors</code> names of predictors that were forced in the model    
</p>
</li></ul>



<h3>Vignettes</h3>

<p>https://mwheymans.github.io/psfmi/articles/psfmi_LogisticModels.html
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>References</h3>

<p>Eekhout I, van de Wiel MA, Heymans MW. Methods for significance testing of categorical
covariates in logistic regression models after multiple imputation: power and applicability
analysis. BMC Med Res Methodol. 2017;17(1):129.
</p>
<p>Enders CK (2010). Applied missing data analysis. New York: The Guilford Press.
</p>
<p>Meng X-L, Rubin DB. Performing likelihood ratio tests with multiply-imputed data sets.
Biometrika.1992;79:103-11.
</p>
<p>van de Wiel MA, Berkhof J, van Wieringen WN. Testing the prediction error difference between
2 predictors. Biostatistics. 2009;10:550-60.
</p>
<p>Marshall A, Altman DG, Holder RL, Royston P. Combining estimates of interest in prognostic
modelling studies after multiple imputation: current practice and guidelines. BMC Med Res Methodol.
2009;9:57.
</p>
<p>Van Buuren S. (2018). Flexible Imputation of Missing Data. 2nd Edition. Chapman &amp; Hall/CRC
Interdisciplinary Statistics. Boca Raton.
</p>
<p>EW. Steyerberg (2019). Clinical Prediction MOdels. A Practical Approach
to Development, Validation, and Updating (2nd edition). Springer Nature Switzerland AG.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pool_lr &lt;- psfmi_lr(data=lbpmilr, formula = Chronic ~ Pain + 
  factor(Satisfaction) + rcs(Tampascale,3) + Radiation + 
  Radiation*factor(Satisfaction) + Age + Duration + BMI,
  p.crit = 0.05, direction="FW", nimp=5, impvar="Impnr", 
  keep.predictors = c("Radiation*factor(Satisfaction)", "Age"), method="D1")
  
  pool_lr$RR_model_final

</code></pre>

<hr>
<h2 id='psfmi_lr_bw'>Backward selection of Logistic regression models in multiply imputed data.</h2><span id='topic+psfmi_lr_bw'></span>

<h3>Description</h3>

<p><code>psfmi_lr_bw</code> Backward selection of Logistic regression
models in multiply imputed data using selection methods RR, D1, D2, D3 and MPR.
Function is called by <code>psfmi_lr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_lr_bw(data, nimp, impvar, Outcome, P, p.crit, method, keep.P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_lr_bw_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="psfmi_lr_bw_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_lr_bw_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_lr_bw_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the outcome variable.</p>
</td></tr>
<tr><td><code id="psfmi_lr_bw_+3A_p">P</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, BMI10, etc.</p>
</td></tr>
<tr><td><code id="psfmi_lr_bw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_lr_bw_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;RR&quot;, D1&quot;, &quot;D2&quot;, &quot;D3&quot; or &quot;MPR&quot;.
See details for more information. Default is &quot;RR&quot;.</p>
</td></tr>
<tr><td><code id="psfmi_lr_bw_+3A_keep.p">keep.P</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. All type of variables are allowed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>

<hr>
<h2 id='psfmi_lr_fw'>Forward selection of Logistic regression models in multiply imputed data.</h2><span id='topic+psfmi_lr_fw'></span>

<h3>Description</h3>

<p><code>psfmi_lr_fw</code> Forward selection of Logistic regression
models across multiply imputed data using selection methods RR, D1, D2, D3 and MPR.
Function is called by <code>psfmi_lr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_lr_fw(data, nimp, impvar, Outcome, P, p.crit, method, keep.P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_lr_fw_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1.</p>
</td></tr>
<tr><td><code id="psfmi_lr_fw_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_lr_fw_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_lr_fw_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the outcome variable.</p>
</td></tr>
<tr><td><code id="psfmi_lr_fw_+3A_p">P</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined. Give predictors unique names
and do not use predictor name combinations with numbers as, age2, BMI10, etc.</p>
</td></tr>
<tr><td><code id="psfmi_lr_fw_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_lr_fw_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;RR&quot;, D1&quot;, &quot;D2&quot;, &quot;D3&quot; or &quot;MPR&quot;.
See details for more information. Default is &quot;RR&quot;.</p>
</td></tr>
<tr><td><code id="psfmi_lr_fw_+3A_keep.p">keep.P</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. Categorical and interaction variables are allowed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>

<hr>
<h2 id='psfmi_mm'>Pooling and Predictor selection function for multilevel
models in multiply imputed datasets</h2><span id='topic+psfmi_mm'></span>

<h3>Description</h3>

<p><code>psfmi_mm</code> Pooling and backward selection for 2 level (generalized)
linear mixed models in multiply imputed datasets using different selection methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_mm(
  data,
  nimp = 5,
  impvar = NULL,
  clusvar = NULL,
  Outcome,
  predictors = NULL,
  random.eff = NULL,
  family = "linear",
  p.crit = 1,
  cat.predictors = NULL,
  spline.predictors = NULL,
  int.predictors = NULL,
  keep.predictors = NULL,
  nknots = NULL,
  method = "RR",
  print.method = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_mm_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1 and the clusters should be 
distinguished by a cluster variable, specified under clusvar.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_clusvar">clusvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
clusters.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the outcome variable.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_predictors">predictors</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_random.eff">random.eff</code></td>
<td>
<p>Character vector to specify the random effects as used by the 
<code>lmer</code> and <code>glmer</code> functions of the <code>lme4</code> package.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_family">family</code></td>
<td>
<p>Character vector to specify the type of model, &quot;linear&quot; is used to 
call the <code>lmer</code> function and &quot;binomial&quot; is used to call the <code>glmer</code>
function of the <code>lme4</code> package. See details for more information.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1 
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_cat.predictors">cat.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
categorical variables. Default is NULL categorical predictors.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_spline.predictors">spline.predictors</code></td>
<td>
<p>A single string or a vector of strings to define the
(restricted cubic) spline variables. Default is NULL spline predictors. See details.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_int.predictors">int.predictors</code></td>
<td>
<p>A single string or a vector of strings with the names of the 
variables that form an interaction pair, separated by a “:” symbol.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_keep.predictors">keep.predictors</code></td>
<td>
<p>A single string or a vector of strings including the variables that are forced
in the model during predictor selection. Categorical and interaction variables are allowed.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_nknots">nknots</code></td>
<td>
<p>A numerical vector that defines the number of knots for each spline predictor separately.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot; or &quot;MPR&quot;.
See details for more information.</p>
</td></tr>
<tr><td><code id="psfmi_mm_+3A_print.method">print.method</code></td>
<td>
<p>logical vector. If TRUE full matrix with p-values of all variables according to
chosen method (under method) is shown. If FALSE (default) p-value for categorical variables according
to method are shown and for continuous and dichotomous predictors Rubin’s Rules are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic pooling procedure to derive pooled coefficients, standard errors, 95
confidence intervals and p-values is Rubin's Rules (RR). Specific procedures are
available to derive pooled p-values for categorical (&gt; 2 categories) and spline variables.
print.method allows to choose between the pooling methods: D1, D2 and D3 and MPR for pooling of 
median p-values (MPR rule). The D1, D2 and D3 methods are called from the package <code>mitml</code>.
For Logistic multilevel models (that are estimated using the <code>glmer</code> function), the D3 method
is not yet available. Spline regression coefficients are defined by using the rcs function for 
restricted cubic splines of the rms package. A minimum number of 3 knots as defined under knots is required.
</p>


<h3>Value</h3>

<p>An object of class <code>smodsmi</code> (selected models in multiply imputed datasets) from 
which the following objects can be extracted: imputed datasets as <code>data</code>, selected 
pooled model as <code>RR_model</code>, pooled p-values according to pooling method as <code>multiparm</code>, 
random effects as <code>random.eff</code>, predictors included at each selection step as <code>predictors_in</code>, 
predictors excluded at each step as <code>predictors_out</code>, and <code>family</code>, <code>impvar</code>, <code>clusvar</code>, 
<code>nimp</code>, <code>Outcome</code>, <code>method</code>, <code>p.crit</code>, <code>predictors</code>, <code>cat.predictors</code>, 
<code>keep.predictors</code>, <code>int.predictors</code>, <code>spline.predictors</code>, <code>knots</code>, <code>print.method</code>, 
<code>model_type</code>, <code>call</code>, <code>predictors_final</code> for names of predictors in final step and 
<code>fit.formula</code> is the regression formula of start model.
</p>


<h3>References</h3>

<p>Eekhout I, van de Wiel MA, Heymans MW. Methods for significance testing of categorical
covariates in logistic regression models after multiple imputation: power and applicability
analysis. BMC Med Res Methodol. 2017;17(1):129.
</p>
<p>Enders CK (2010). Applied missing data analysis. New York: The Guilford Press.
</p>
<p>Meng X-L, Rubin DB. Performing likelihood ratio tests with multiply-imputed data sets.
Biometrika.1992;79:103-11.
</p>
<p>van de Wiel MA, Berkhof J, van Wieringen WN. Testing the prediction error difference between
2 predictors. Biostatistics. 2009;10:550-60.
</p>
<p>mitml package https://cran.r-project.org/web/packages/mitml/index.html
</p>
<p>Van Buuren S. (2018). Flexible Imputation of Missing Data. 2nd Edition. Chapman &amp; Hall/CRC
Interdisciplinary Statistics. Boca Raton.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  pool_mm &lt;- psfmi_mm(data=ipdna_md, nimp=5, impvar=".imp", family="linear",
  predictors=c("gender", "afib", "sbp"), clusvar = "centre",
  random.eff="( 1 | centre)", Outcome="dbp", cat.predictors = "bmi_cat",
  p.crit=0.15, method="D1", print.method = FALSE)
  pool_mm$RR_Model
  pool_mm$multiparm

## End(Not run)

</code></pre>

<hr>
<h2 id='psfmi_mm_multiparm'>Multiparameter pooling methods called by psfmi_mm</h2><span id='topic+psfmi_mm_multiparm'></span>

<h3>Description</h3>

<p><code>psfmi_mm_multiparm</code> Function to pool according to D1, D2 and D3 methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_mm_multiparm(
  data,
  nimp,
  impvar,
  Outcome,
  P,
  p.crit,
  family,
  random.eff,
  method,
  print.method
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_mm_multiparm_+3A_data">data</code></td>
<td>
<p>Data frame with stacked multiple imputed datasets.
The original dataset that contains missing values must be excluded from the
dataset. The imputed datasets must be distinguished by an imputation variable,
specified under impvar, and starting by 1 and the clusters should be 
distinguished by a cluster variable, specified under clusvar.</p>
</td></tr>
<tr><td><code id="psfmi_mm_multiparm_+3A_nimp">nimp</code></td>
<td>
<p>A numerical scalar. Number of imputed datasets. Default is 5.</p>
</td></tr>
<tr><td><code id="psfmi_mm_multiparm_+3A_impvar">impvar</code></td>
<td>
<p>A character vector. Name of the variable that distinguishes the
imputed datasets.</p>
</td></tr>
<tr><td><code id="psfmi_mm_multiparm_+3A_outcome">Outcome</code></td>
<td>
<p>Character vector containing the name of the outcome variable.</p>
</td></tr>
<tr><td><code id="psfmi_mm_multiparm_+3A_p">P</code></td>
<td>
<p>Character vector with the names of the predictor variables.
At least one predictor variable has to be defined.</p>
</td></tr>
<tr><td><code id="psfmi_mm_multiparm_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium. A value of 1 
provides the pooled model without selection.</p>
</td></tr>
<tr><td><code id="psfmi_mm_multiparm_+3A_family">family</code></td>
<td>
<p>Character vector to specify the type of model, &quot;linear&quot; is used to 
call the <code>lmer</code> function and &quot;binomial&quot; is used to call the <code>glmer</code>
function of the <code>lme4</code> package. See details for more information.</p>
</td></tr>
<tr><td><code id="psfmi_mm_multiparm_+3A_random.eff">random.eff</code></td>
<td>
<p>Character vector to specify the random effects as used by the 
<code>lmer</code> and <code>glmer</code> functions of the <code>lme4</code> package.</p>
</td></tr>
<tr><td><code id="psfmi_mm_multiparm_+3A_method">method</code></td>
<td>
<p>A character vector to indicate the pooling method for p-values to pool the
total model or used during predictor selection. This can be &quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot; or &quot;MPR&quot;.
See details for more information.</p>
</td></tr>
<tr><td><code id="psfmi_mm_multiparm_+3A_print.method">print.method</code></td>
<td>
<p>logical vector. If TRUE full matrix with p-values of 
all variables according to chosen method (under method) is shown. If FALSE (default) 
p-value for categorical variables according to method are shown and for continuous 
and dichotomous predictors Rubin’s Rules are used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
 psfmi_mm_multiparm(data=ipdna_md, nimp=5, impvar=".imp", family="linear",
 P=c("gender", "bnp", "dbp", "lvef", "bmi_cat"),
 random.eff="( 1 | centre)", Outcome="sbp",
 p.crit=0.05, method="D1", print.method = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='psfmi_perform'>Internal validation and performance of logistic prediction models across Multiply Imputed datasets</h2><span id='topic+psfmi_perform'></span>

<h3>Description</h3>

<p><code>psfmi_perform</code> Evaluate Performance of logistic regression models selected with
the <code>psfmi_lr</code> function of the <code>psfmi</code> package by using cross-validation
or bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_perform(
  pobj,
  val_method = NULL,
  data_orig = NULL,
  int_val = TRUE,
  nboot = 10,
  folds = 3,
  nimp_cv = 5,
  nimp_mice = 5,
  p.crit = 1,
  BW = FALSE,
  direction = NULL,
  cv_naive_appt = FALSE,
  cal.plot = FALSE,
  plot.method = "mean",
  groups_cal = 5,
  miceImp,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_perform_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>pmods</code> (pooled models), produced by a previous
call to <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_val_method">val_method</code></td>
<td>
<p>Method for internal validation. MI_boot for first Multiple Imputation and
than bootstrapping in each imputed dataset and boot_MI for first bootstrapping and than
multiple imputation in each bootstrap sample, and cv_MI, cv_MI_RR and
MI_cv_naive for the combinations of cross-validation and multiple imputation.
To use cv_MI, cv_MI_RR and boot_MI, data_orig has to be specified. See details for more information.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_data_orig">data_orig</code></td>
<td>
<p>dataframe of original dataset that contains missing data for methods
cv_MI, cv_MI_RR and boot_MI.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_int_val">int_val</code></td>
<td>
<p>If TRUE internal validation is conducted using bootstrapping or cross-validation.
Default is TRUE. If FALSE only apparent performance measures are calculated.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap resamples, default is 10. Used for methods boot_MI and MI_boot.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_folds">folds</code></td>
<td>
<p>The number of folds, default is 3. Used for methods cv_MI, cv_MI_RR and MI_cv_naive.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_nimp_cv">nimp_cv</code></td>
<td>
<p>Numerical scalar. Number of (multiple) imputation runs for method cv_MI.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_nimp_mice">nimp_mice</code></td>
<td>
<p>Numerical scalar. Number of imputed datasets for method cv_MI_RR and boot_MI.
When not defined, the number of multiply imputed datasets is used of the
previous call to the function <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium used for backward or forward
selection during validation. When set at 1, pooling and internal validation is done without
backward selection.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_bw">BW</code></td>
<td>
<p>Only used for methods cv_MI, cv_MI_RR and MI_cv_naive. If TRUE backward selection is
conducted within cross-validation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_direction">direction</code></td>
<td>
<p>Can be used together with val_methods boot_MI and MI_boot. The direction of
predictor selection, &quot;BW&quot; is for backward selection and &quot;FW&quot; for forward selection.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_cv_naive_appt">cv_naive_appt</code></td>
<td>
<p>Can be used in combination with val_method MI_cv_naive. Default is TRUE for
showing the cross-validation apparent (train) and test results. Set to FALSE to only give test results.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_cal.plot">cal.plot</code></td>
<td>
<p>If TRUE a calibration plot is generated. Default is FALSE. Can be used in combination
with int_val = FALSE.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_plot.method">plot.method</code></td>
<td>
<p>If &quot;mean&quot; one calibration plot is generated, first taking the 
mean of the linear predictor across the multiply imputed datasets (default), if 
&quot;individual&quot; the calibration plot of each imputed dataset is plotted, 
if &quot;overlay&quot; calibration plots from each imputed datasets are plotted in one figure.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_groups_cal">groups_cal</code></td>
<td>
<p>A numerical scalar. Number of groups used on the calibration plot and. 
for the Hosmer and Lemeshow test. Default is 10. If the range of predicted probabilities. 
is low, less than 10 groups can be chosen, but not &lt; 3.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_miceimp">miceImp</code></td>
<td>
<p>Wrapper function around the <code>mice</code> function.</p>
</td></tr>
<tr><td><code id="psfmi_perform_+3A_...">...</code></td>
<td>
<p>Arguments as predictorMatrix, seed, maxit, etc that can be adjusted for
the <code>mice</code> function. To be used in combination with validation methods cv_MI,
cv_MI_RR and MI_boot. For method cv_MI the number of imputed datasets is fixed at 1 and cannot
be changed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal validation five methods can be used, cv_MI, cv_MI_RR, MI_cv_naive,
MI_boot and boot_MI. Method cv_MI uses imputation within each cross-validation fold definition.
By repeating this in several imputation runs, multiply imputed datasets are generated. Method
cv_MI_RR uses multiple imputation within the cross-validation definition. MI_cv_naive, applies
cross-validation within each imputed dataset. MI_boot draws for each bootstrap step the same
cases in all imputed datasets. With boot_MI first bootstrap samples are drawn from the original
dataset with missing values and than multiple imputation is applied. For multiple imputation
the <code>mice</code> function from the <code>mice</code> package is used. It is recommended to use a minumum
of 100 imputation runs for method cv_MI or 100 bootstrap samples for method boot_MI or MI_boot.
Methods cv_MI, cv_MI_RR and MI_cv_naive can be combined with backward selection during
cross-validation and with methods boot_MI and MI_boot, backward and forward selection can
be used. For methods cv_MI and cv_MI_RR the outcome in the original dataset has to be complete.
</p>


<h3>Value</h3>

<p>A <code>psfmi_perform</code> object from which the following objects can be extracted: <code>res_boot</code>,
result of pooled performance (in multiply imputed datasets) at each bootstrap step of ROC app (pooled
ROC), ROC test (pooled ROC after bootstrap model is applied in original multiply imputed datasets),
same for R2 app (Nagelkerke's R2), R2 test, Scaled Brier app and Scaled Brier test. Information is also provided
about testing the Calibration slope at each bootstrap step as interc test and Slope test.
The performance measures are pooled by a call to the function <code>pool_performance</code>. Another
object that can be extracted is <code>intval</code>, with information of the AUC, R2, Scaled Brier score and
Calibration slope averaged over the bootstrap samples, in terms of: Orig (original datasets),
Apparent (models applied in bootstrap samples), Test (bootstrap models are applied in original datasets),
Optimism (difference between apparent and test) and Corrected (original corrected for optimism).
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>References</h3>

<p>Heymans MW, van Buuren S, Knol DL, van Mechelen W, de Vet HC. Variable selection under
multiple imputation using the bootstrap in a prognostic study. BMC Med Res Methodol. 2007(13);7:33.
</p>
<p>F. Harrell. Regression Modeling Strategies. With Applications to
Linear Models, Logistic and Ordinal Regression, and Survival Analysis (2nd edition). Springer,
New York, NY, 2015.
</p>
<p>Van Buuren S. (2018). Flexible Imputation of Missing Data. 2nd Edition. Chapman &amp;
Hall/CRC Interdisciplinary Statistics. Boca Raton.
</p>
<p>Harel, O. (2009). The estimation of R2 and adjusted R2 in
incomplete data sets using multiple imputation. Journal of Applied Statistics,
36(10), 1109-1118.
</p>
<p>Musoro JZ, Zwinderman AH, Puhan MA, ter Riet G, Geskus RB. Validation of prediction
models based on lasso regression with multiply imputed data. BMC Med Res Methodol. 2014;14:116.
</p>
<p>Wahl S, Boulesteix AL, Zierer A, Thorand B, van de Wiel MA. Assessment of
predictive performance in incomplete data by combining internal validation and multiple
imputation. BMC Med Res Methodol. 2016;16(1):144.
</p>
<p>EW. Steyerberg (2019). Clinical Prediction MOdels. A Practical Approach
to Development, Validation, and Updating (2nd edition). Springer Nature Switzerland AG.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>

<hr>
<h2 id='psfmi_stab'>Function to evaluate bootstrap predictor and model stability in multiply imputed datasets.</h2><span id='topic+psfmi_stab'></span>

<h3>Description</h3>

<p><code>psfmi_stab</code> Stability analysis of predictors and prediction models selected with
the <code>psfmi_lr</code>, <code>psfmi_coxr</code> or <code>psfmi_mm</code> functions of the <code>psfmi</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_stab(
  pobj,
  boot_method = NULL,
  nboot = 20,
  p.crit = 0.05,
  start_model = TRUE,
  direction = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_stab_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>pmods</code> (pooled models), produced by a previous call to
<code>psfmi_lr</code>, <code>psfmi_coxr</code> or <code>psfmi_mm</code>.</p>
</td></tr>
<tr><td><code id="psfmi_stab_+3A_boot_method">boot_method</code></td>
<td>
<p>A single string to define the bootstrap method. Use &quot;single&quot; after a call to
<code>psfmi_lr</code> and <code>psfmi_coxr</code> and &quot;cluster&quot; after a call to <code>psfmi_mm</code>.</p>
</td></tr>
<tr><td><code id="psfmi_stab_+3A_nboot">nboot</code></td>
<td>
<p>A numerical scalar. Number of bootstrap samples to evaluate the stability. Default is 20.</p>
</td></tr>
<tr><td><code id="psfmi_stab_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. Used as P-value selection criterium during bootstrap model selection.</p>
</td></tr>
<tr><td><code id="psfmi_stab_+3A_start_model">start_model</code></td>
<td>
<p>If TRUE the bootstrap evaluation takes place from the start model of object pobj, if
FALSE the final model is used for the evaluation.</p>
</td></tr>
<tr><td><code id="psfmi_stab_+3A_direction">direction</code></td>
<td>
<p>The direction of predictor selection, &quot;BW&quot; for backward selection and &quot;FW&quot;
for forward selection.
#'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function evaluates predictor selection frequency in stratified or cluster bootstrap samples.
The stratification factor is the variable that separates the imputed datasets. The same bootstrap cases
are drawn in each bootstrap sample. It uses as input an object of class <code>pmods</code> as a result of a
previous call to the <code>psfmi_lr</code>, <code>psfmi_coxr</code> or <code>psfmi_mm</code> functions.
In combination with the <code>psfmi_mm</code> function a cluster bootstrap method is used where bootstrapping
is used on the level of the clusters only (and not also within the clusters).
</p>


<h3>Value</h3>

<p>A <code>psfmi_stab</code> object from which the following objects can be extracted: bootstrap
inclusion (selection) frequency of each predictor <code>bif</code>, total number each predictor is
included in the bootstrap samples as <code>bif_total</code>, percentage a predictor is selected
in each bootstrap sample as <code>bif_perc</code> and number of times a prediction model is selected in
the bootstrap samples as <code>model_stab</code>.
</p>


<h3>Vignettes</h3>

<p>https://mwheymans.github.io/psfmi/articles/psfmi_StabilityAnalysis.html
</p>


<h3>References</h3>

<p>Heymans MW, van Buuren S. et al. Variable selection under multiple imputation using the bootstrap
in a prognostic study. BMC Med Res Methodol. 2007;13:7-33.
</p>
<p>Eekhout I, van de Wiel MA, Heymans MW. Methods for significance testing of categorical
covariates in logistic regression models after multiple imputation: power and applicability
analysis. BMC Med Res Methodol. 2017;17(1):129.
</p>
<p>Sauerbrei W, Schumacher M. A bootstrap resampling procedure for model building:
application to the Cox regression model. Stat Med. 1992;11:2093–109.
</p>
<p>Royston P, Sauerbrei W (2008) Multivariable model-building – a pragmatic approach to
regression analysis based on fractional polynomials for modelling continuous variables. (2008).
Chapter 8, Model Stability. Wiley, Chichester
</p>
<p>Heinze G, Wallisch C, Dunkler D. Variable selection - A review and
recommendations for the practicing statistician. Biom J. 2018;60(3):431-449.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'> pool_lr &lt;- psfmi_coxr(formula = Surv(Time, Status) ~ Pain + factor(Satisfaction) + 
   rcs(Tampascale,3) + Radiation + Radiation*factor(Satisfaction) + Age + Duration + 
   Previous + Radiation*rcs(Tampascale, 3), data=lbpmicox, p.crit = 0.157, direction="FW",
   nimp=5, impvar="Impnr", keep.predictors = NULL, method="D1")

 pool_lr$RR_Model
 pool_lr$multiparm

## Not run: 
 stab_res &lt;- psfmi_stab(pool_lr, direction="FW", start_model = TRUE,
     boot_method = "single", nboot=20, p.crit=0.05)
 stab_res$bif
 stab_res$bif_perc
 stab_res$model_stab

## End(Not run)

</code></pre>

<hr>
<h2 id='psfmi_validate'>Internal validation and performance of logistic prediction models across Multiply Imputed datasets</h2><span id='topic+psfmi_validate'></span>

<h3>Description</h3>

<p><code>psfmi_validate</code> Evaluate Performance of logistic regression models selected with
the <code>psfmi_lr</code> function of the <code>psfmi</code> package by using cross-validation
or bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psfmi_validate(
  pobj,
  val_method = NULL,
  data_orig = NULL,
  int_val = TRUE,
  nboot = 10,
  folds = 3,
  nimp_cv = 5,
  nimp_mice = 5,
  p.crit = 1,
  BW = FALSE,
  direction = NULL,
  cv_naive_appt = FALSE,
  cal.plot = FALSE,
  plot.method = "mean",
  groups_cal = 5,
  miceImp,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="psfmi_validate_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>pmods</code> (pooled models), produced by a previous
call to <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_val_method">val_method</code></td>
<td>
<p>Method for internal validation. MI_boot for first Multiple Imputation and
than bootstrapping in each imputed dataset and boot_MI for first bootstrapping and than
multiple imputation in each bootstrap sample, and cv_MI, cv_MI_RR and
MI_cv_naive for the combinations of cross-validation and multiple imputation.
To use cv_MI, cv_MI_RR and boot_MI, data_orig has to be specified. See details for more information.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_data_orig">data_orig</code></td>
<td>
<p>dataframe of original dataset that contains missing data for methods
cv_MI, cv_MI_RR and boot_MI.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_int_val">int_val</code></td>
<td>
<p>If TRUE internal validation is conducted using bootstrapping or cross-validation.
Default is TRUE. If FALSE only apparent performance measures are calculated.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_nboot">nboot</code></td>
<td>
<p>The number of bootstrap resamples, default is 10. Used for methods boot_MI and MI_boot.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_folds">folds</code></td>
<td>
<p>The number of folds, default is 3. Used for methods cv_MI, cv_MI_RR and MI_cv_naive.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_nimp_cv">nimp_cv</code></td>
<td>
<p>Numerical scalar. Number of (multiple) imputation runs for method cv_MI.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_nimp_mice">nimp_mice</code></td>
<td>
<p>Numerical scalar. Number of imputed datasets for method cv_MI_RR and boot_MI.
When not defined, the number of multiply imputed datasets is used of the
previous call to the function <code>psfmi_lr</code>.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. P-value selection criterium used for backward or forward
selection during validation. When set at 1, pooling and internal validation is done without
backward selection.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_bw">BW</code></td>
<td>
<p>Only used for methods cv_MI, cv_MI_RR and MI_cv_naive. If TRUE backward selection is
conducted within cross-validation. Default is FALSE.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_direction">direction</code></td>
<td>
<p>Can be used together with val_methods boot_MI and MI_boot. The direction of
predictor selection, &quot;BW&quot; is for backward selection and &quot;FW&quot; for forward selection.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_cv_naive_appt">cv_naive_appt</code></td>
<td>
<p>Can be used in combination with val_method MI_cv_naive. Default is TRUE for
showing the cross-validation apparent (train) and test results. Set to FALSE to only give test results.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_cal.plot">cal.plot</code></td>
<td>
<p>If TRUE a calibration plot is generated. Default is FALSE. Can be used in combination
with int_val = FALSE.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_plot.method">plot.method</code></td>
<td>
<p>If &quot;mean&quot; one calibration plot is generated, first taking the 
mean of the linear predictor across the multiply imputed datasets (default), if 
&quot;individual&quot; the calibration plot of each imputed dataset is plotted, 
if &quot;overlay&quot; calibration plots from each imputed datasets are plotted in one figure.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_groups_cal">groups_cal</code></td>
<td>
<p>A numerical scalar. Number of groups used on the calibration plot and. 
for the Hosmer and Lemeshow test. Default is 10. If the range of predicted probabilities. 
is low, less than 10 groups can be chosen, but not &lt; 3.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_miceimp">miceImp</code></td>
<td>
<p>Wrapper function around the <code>mice</code> function.</p>
</td></tr>
<tr><td><code id="psfmi_validate_+3A_...">...</code></td>
<td>
<p>Arguments as predictorMatrix, seed, maxit, etc that can be adjusted for
the <code>mice</code> function. To be used in combination with validation methods cv_MI,
cv_MI_RR and MI_boot. For method cv_MI the number of imputed datasets is fixed at 1 and cannot
be changed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For internal validation five methods can be used, cv_MI, cv_MI_RR, MI_cv_naive,
MI_boot and boot_MI. Method cv_MI uses imputation within each cross-validation fold definition.
By repeating this in several imputation runs, multiply imputed datasets are generated. Method
cv_MI_RR uses multiple imputation within the cross-validation definition. MI_cv_naive, applies
cross-validation within each imputed dataset. MI_boot draws for each bootstrap step the same
cases in all imputed datasets. With boot_MI first bootstrap samples are drawn from the original
dataset with missing values and than multiple imputation is applied. For multiple imputation
the <code>mice</code> function from the <code>mice</code> package is used. It is recommended to use a minumum
of 100 imputation runs for method cv_MI or 100 bootstrap samples for method boot_MI or MI_boot.
Methods cv_MI, cv_MI_RR and MI_cv_naive can be combined with backward selection during
cross-validation and with methods boot_MI and MI_boot, backward and forward selection can
be used. For methods cv_MI and cv_MI_RR the outcome in the original dataset has to be complete.
</p>


<h3>Value</h3>

<p>A <code>psfmi_perform</code> object from which the following objects can be extracted: <code>res_boot</code>,
result of pooled performance (in multiply imputed datasets) at each bootstrap step of ROC app (pooled
ROC), ROC test (pooled ROC after bootstrap model is applied in original multiply imputed datasets),
same for R2 app (Nagelkerke's R2), R2 test, Scaled Brier app and Scaled Brier test. Information is also provided
about testing the Calibration slope at each bootstrap step as interc test and Slope test.
The performance measures are pooled by a call to the function <code>pool_performance</code>. Another
object that can be extracted is <code>intval</code>, with information of the AUC, R2, Scaled Brier score and
Calibration slope averaged over the bootstrap samples, in terms of: Orig (original datasets),
Apparent (models applied in bootstrap samples), Test (bootstrap models are applied in original datasets),
Optimism (difference between apparent and test) and Corrected (original corrected for optimism).
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>References</h3>

<p>Heymans MW, van Buuren S, Knol DL, van Mechelen W, de Vet HC. Variable selection under
multiple imputation using the bootstrap in a prognostic study. BMC Med Res Methodol. 2007(13);7:33.
</p>
<p>F. Harrell. Regression Modeling Strategies. With Applications to
Linear Models, Logistic and Ordinal Regression, and Survival Analysis (2nd edition). Springer,
New York, NY, 2015.
</p>
<p>Van Buuren S. (2018). Flexible Imputation of Missing Data. 2nd Edition. Chapman &amp;
Hall/CRC Interdisciplinary Statistics. Boca Raton.
</p>
<p>Harel, O. (2009). The estimation of R2 and adjusted R2 in
incomplete data sets using multiple imputation. Journal of Applied Statistics,
36(10), 1109-1118.
</p>
<p>Musoro JZ, Zwinderman AH, Puhan MA, ter Riet G, Geskus RB. Validation of prediction
models based on lasso regression with multiply imputed data. BMC Med Res Methodol. 2014;14:116.
</p>
<p>Wahl S, Boulesteix AL, Zierer A, Thorand B, van de Wiel MA. Assessment of
predictive performance in incomplete data by combining internal validation and multiple
imputation. BMC Med Res Methodol. 2016;16(1):144.
</p>
<p>EW. Steyerberg (2019). Clinical Prediction MOdels. A Practical Approach
to Development, Validation, and Updating (2nd edition). Springer Nature Switzerland AG.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pool_lr &lt;- psfmi_lr(data=lbpmilr, formula = Chronic ~ Pain + JobDemands + rcs(Tampascale, 3) +
           factor(Satisfaction) + Smoking, p.crit = 1, direction="FW",
           nimp=5, impvar="Impnr", method="D1")
           
pool_lr$RR_model

res_perf &lt;- psfmi_validate(pool_lr, val_method = "cv_MI", data_orig = lbp_orig, folds=3,
            nimp_cv = 2, p.crit=0.05, BW=TRUE, miceImp = miceImp, printFlag = FALSE)
            
res_perf

## Not run: 
 set.seed(200)
  res_val &lt;- psfmi_validate(pobj, val_method = "boot_MI", data_orig = lbp_orig, nboot = 5,
  p.crit=0.05, BW=TRUE, miceImp = miceImp, nimp_mice = 5, printFlag = FALSE, direction = "FW")
  
  res_val$stats_val

## End(Not run)

</code></pre>

<hr>
<h2 id='risk_coxph'>Risk calculation at specific time point for Cox model</h2><span id='topic+risk_coxph'></span>

<h3>Description</h3>

<p>Risk calculation at specific time point for Cox model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>risk_coxph(mod, t_risk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="risk_coxph_+3A_mod">mod</code></td>
<td>
<p>a Cox regression model object.</p>
</td></tr>
<tr><td><code id="risk_coxph_+3A_t_risk">t_risk</code></td>
<td>
<p>Follow-up value to calculate cases, controls. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cox regression Risk estimates at specific time point.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2023
</p>


<h3>References</h3>

<p>Pencina MJ, D'Agostino RB Sr, Steyerberg EW. Extensions of net reclassification 
improvement calculations to measure usefulness of new biomarkers. Stat Med. 2011;30(1):11-21
</p>
<p>Inoue E (2018). nricens: NRI for Risk Prediction Models with Time to Event and Binary 
Response Data. R package version 1.6, &lt;https://CRAN.R-project.org/package=nricens&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nri_cox">nri_cox</a></code>
</p>

<hr>
<h2 id='RR_diff_prop'>Function to apply RR to pool difference of NRI and AUC values</h2><span id='topic+RR_diff_prop'></span>

<h3>Description</h3>

<p>Function to apply RR to pool difference of NRI and AUC values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RR_diff_prop(est, se)
</code></pre>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>

<hr>
<h2 id='rsq_nagel'>Nagelkerke's R-square calculation for logistic regression / glm models</h2><span id='topic+rsq_nagel'></span>

<h3>Description</h3>

<p>Nagelkerke's R-square calculation for logistic regression / glm models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsq_nagel(fitobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsq_nagel_+3A_fitobj">fitobj</code></td>
<td>
<p>a logistic regression model object of &quot;glm&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value for the explained variance.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>, <code><a href="#topic+pool_performance">pool_performance</a></code>
</p>

<hr>
<h2 id='rsq_surv'>R-square calculation for Cox regression models</h2><span id='topic+rsq_surv'></span>

<h3>Description</h3>

<p>R-square calculation for Cox regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsq_surv(fitobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsq_surv_+3A_fitobj">fitobj</code></td>
<td>
<p>a Cox regression model object of &quot;coxph&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value for the explained variance.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2021
</p>


<h3>References</h3>

<p>F. Harrell. Regression Modeling Strategies. With Applications to
Linear Models, Logistic and Ordinal Regression, and Survival Analysis. 2nd Edition.
Springer, New York, NY, 2015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pool_performance">pool_performance</a></code>
</p>

<hr>
<h2 id='sbp_age'>Dataset with blood pressure measurements</h2><span id='topic+sbp_age'></span>

<h3>Description</h3>

<p>Dataset with blood pressure measurements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sbp_age)</code></pre>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 3 variables.
</p>

<dl>
<dt><code>pat_id</code></dt><dd><p>continuous</p>
</dd>
<dt><code>sbp</code></dt><dd><p>continuous: systolic blood pressure</p>
</dd>
<dt><code>age</code></dt><dd><p>continuous: age (years)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(sbp_age)
## maybe str(sbp_age)
</code></pre>

<hr>
<h2 id='sbp_qas'>Dataset with blood pressure measurements</h2><span id='topic+sbp_qas'></span>

<h3>Description</h3>

<p>Dataset with blood pressure measurements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sbp_qas)</code></pre>


<h3>Format</h3>

<p>A data frame with 32 observations on the following 5 variables.
</p>

<dl>
<dt><code>pat_id</code></dt><dd><p>continuous</p>
</dd>
<dt><code>sbp</code></dt><dd><p>continuous: systolic blood pressure</p>
</dd>
<dt><code>bmi</code></dt><dd><p>continuous: body mass index</p>
</dd>
<dt><code>age</code></dt><dd><p>continuous: age (years)</p>
</dd>
<dt><code>smk</code></dt><dd><p>dichotomous: 0 = no, 1 = yes</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(sbp_qas)
## maybe str(sbp_qas)
</code></pre>

<hr>
<h2 id='scaled_brier'>Calculates the scaled Brier score</h2><span id='topic+scaled_brier'></span>

<h3>Description</h3>

<p>Calculates the scaled Brier score
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaled_brier(obs, pred)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaled_brier_+3A_obs">obs</code></td>
<td>
<p>Observed outcomes.</p>
</td></tr>
<tr><td><code id="scaled_brier_+3A_pred">pred</code></td>
<td>
<p>Predicted outcomes in the form of probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value for the scaled Brier score.
</p>


<h3>Author(s)</h3>

<p>Martijn Heymans, 2020
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psfmi_perform">psfmi_perform</a></code>, <code><a href="#topic+pool_performance">pool_performance</a></code>
</p>

<hr>
<h2 id='smoking'>Survival data about smoking</h2><span id='topic+smoking'></span>

<h3>Description</h3>

<p>Survival data about smoking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(smoking)</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 3 variables.
</p>

<dl>
<dt><code>smoking</code></dt><dd><p>dichotomous: 1=yes, 0=no</p>
</dd>
<dt><code>time</code></dt><dd><p>continuous: Survival time in years</p>
</dd>
<dt><code>death</code></dt><dd><p>dichotomous: Status at end of study</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(smoking)
## maybe str(smoking)
</code></pre>

<hr>
<h2 id='stab_single'>Function to evaluate bootstrap predictor and model stability.</h2><span id='topic+stab_single'></span>

<h3>Description</h3>

<p><code>stab_single</code> Stability analysis of predictors and prediction models selected with
the <code>glm_bw</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stab_single(pobj, nboot = 20, p.crit = 0.05, start_model = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stab_single_+3A_pobj">pobj</code></td>
<td>
<p>An object of class <code>smods</code> (single models), produced by a previous call to
<code>glm_bw</code>.</p>
</td></tr>
<tr><td><code id="stab_single_+3A_nboot">nboot</code></td>
<td>
<p>A numerical scalar. Number of bootstrap samples to evaluate the stability. Default is 20.</p>
</td></tr>
<tr><td><code id="stab_single_+3A_p.crit">p.crit</code></td>
<td>
<p>A numerical scalar. Used as P-value selection criterium during bootstrap model selection.</p>
</td></tr>
<tr><td><code id="stab_single_+3A_start_model">start_model</code></td>
<td>
<p>If TRUE the bootstrap evaluation takes place from the start model of object pobj, if
FALSE the final model is used for the evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function evaluates predictor selection frequency in bootstrap samples.
It uses as input an object of class <code>smods</code> as a result of a
previous call to the <code>glm_bw</code>.
</p>


<h3>Value</h3>

<p>A <code>psfmi_stab</code> object from which the following objects can be extracted: bootstrap
inclusion (selection) frequency of each predictor <code>bif</code>, total number each predictor is
included in the bootstrap samples as <code>bif_total</code>, percentage a predictor is selected
in each bootstrap sample as <code>bif_perc</code> and number of times a prediction model is selected in
the bootstrap samples as <code>model_stab</code>.
</p>


<h3>References</h3>

<p>Heymans MW, van Buuren S. et al. Variable selection under multiple imputation using the bootstrap
in a prognostic study. BMC Med Res Methodol. 2007;13:7-33.
</p>
<p>Sauerbrei W, Schumacher M. A bootstrap resampling procedure for model building:
application to the Cox regression model. Stat Med. 1992;11:2093–109.
</p>
<p>Royston P, Sauerbrei W (2008) Multivariable model-building – a pragmatic approach to
regression analysis based on fractional polynomials for modelling continuous variables. (2008).
Chapter 8, Model Stability. Wiley, Chichester.
</p>
<p>Heinze G, Wallisch C, Dunkler D. Variable selection - A review and
recommendations for the practicing statistician. Biom J. 2018;60(3):431-449.
</p>
<p>http://missingdatasolutions.rbind.io/
</p>


<h3>Examples</h3>

<pre><code class='language-R'> model_lr &lt;- glm_bw(formula = Radiation ~ Pain + factor(Satisfaction) + 
   rcs(Tampascale,3) + Age + Duration + JobControl + JobDemands + SocialSupport, 
   data=lbpmilr_dev, p.crit = 0.05)

## Not run: 
 stab_res &lt;- stab_single(model_lr, start_model = TRUE, nboot=20, p.crit=0.05)
 stab_res$bif
 stab_res$bif_perc
 stab_res$model_stab

## End(Not run)

</code></pre>

<hr>
<h2 id='weight'>Dataset of persons from the The Amsterdam Growth and Health Longitudinal Study (AGHLS)</h2><span id='topic+weight'></span>

<h3>Description</h3>

<p>Dataset of persons from the The Amsterdam Growth and Health Longitudinal Study (AGHLS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(weight)</code></pre>


<h3>Format</h3>

<p>A data frame with 450 observations on the following 7 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>continuous</p>
</dd>
<dt><code>SBP</code></dt><dd><p>continuous: Systolic Blood Pressure</p>
</dd>
<dt><code>LDL</code></dt><dd><p>continuous: Cholesterol</p>
</dd>
<dt><code>Glucose</code></dt><dd><p>continuous</p>
</dd>
<dt><code>HDL</code></dt><dd><p>continuous: Cholesterol</p>
</dd>
<dt><code>Gender</code></dt><dd><p>dichotomous: 1=male, 0=female</p>
</dd>
<dt><code>Weight</code></dt><dd><p>continuous: bodyweight</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(weight)
## maybe str(weight)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
