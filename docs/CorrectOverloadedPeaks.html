<!DOCTYPE html><html><head><title>Help for package CorrectOverloadedPeaks</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CorrectOverloadedPeaks}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#base64decode'><p>base64decode.</p></a></li>
<li><a href='#CorrectOverloadedPeaks'><p>Correct Overloaded Peaks from GC-MS data.</p></a></li>
<li><a href='#FitGaussPeak'><p>Extrapolate a flat top peak using a Gauss approach.</p></a></li>
<li><a href='#FitPeakByIsotopicRatio'><p>Extrapolate a flat top peak using isotopic ratios.</p></a></li>
<li><a href='#ModelGaussPeak'><p>Create and modify parameters of an artificial chromatographic peak.</p></a></li>
<li><a href='#mzXML_data'><p>mzXML_data.</p></a></li>
<li><a href='#read.mzData'><p>read.mzData.</p></a></li>
<li><a href='#read.mzXML'><p>Read and write standard mzXML files.</p></a></li>
<li><a href='#verify_suggested'><p>verify_suggested.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Correct Overloaded Peaks from GC-APCI-MS Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Lisec [aut, cre]</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyzes and modifies metabolomics raw data (generated using GC-APCI-MS, Gas Chromatography-Atmospheric Pressure Chemical Ionization-Mass Spectrometry) to correct overloaded signals, i.e. ion intensities exceeding detector saturation leading to a cut-off peak. Data in xcmsRaw format are accepted as input and mzXML files can be processed alternatively. Overloaded signals are detected automatically and modified using an Gaussian or Isotopic-Ratio approach, QC plots are generated and corrected data are stored within the original xcmsRaw or mzXML respectively to allow further processing.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;doi:10.1021/acs.analchem.6b02515&gt;</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bitops, digest, knitr, methods, rmarkdown, xcms, XML, xml2</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-08 10:52:21 UTC; jlisec</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Lisec &lt;jan.lisec@bam.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-08 21:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='base64decode'>base64decode.</h2><span id='topic+base64decode'></span><span id='topic+base64encode'></span>

<h3>Description</h3>

<p>'base64decode' is a copy of a similar function from the caTools 
package as this package is about to be archived (07/2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64decode(z, what, size = NA, signed = TRUE, endian = .Platform$endian)

base64encode(x, size = NA, endian = .Platform$endian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64decode_+3A_z">z</code></td>
<td>
<p>The base64 encoded string.</p>
</td></tr>
<tr><td><code id="base64decode_+3A_what">what</code></td>
<td>
<p>Define output type of z (e.g. 'numeric').</p>
</td></tr>
<tr><td><code id="base64decode_+3A_size">size</code></td>
<td>
<p>Encoding size (provide if you know it).</p>
</td></tr>
<tr><td><code id="base64decode_+3A_signed">signed</code></td>
<td>
<p>Parameter passed through to 'readBin'.</p>
</td></tr>
<tr><td><code id="base64decode_+3A_endian">endian</code></td>
<td>
<p>Parameter passed through to 'readBin'.</p>
</td></tr>
<tr><td><code id="base64decode_+3A_x">x</code></td>
<td>
<p>The value vector to be encoded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&lsquo;base64decode' will convert base64 encoded strings into R values.#&rsquo;
</p>


<h3>Value</h3>

<p>Decoded value of z.#'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# you need to have the bitops package installed to run the example
x &lt;- c(10, 0.2, 123456)
(z &lt;- base64encode(x = x))
base64decode(z = z, what = "numeric")
(x &lt;- as.integer(x))
(z &lt;- base64encode(x = x))
base64decode(z = z, what = "int")

## End(Not run)
</code></pre>

<hr>
<h2 id='CorrectOverloadedPeaks'>Correct Overloaded Peaks from GC-MS data.</h2><span id='topic+CorrectOverloadedPeaks'></span>

<h3>Description</h3>

<p><code>CorrectOverloadedPeaks</code> will take an xcmsRaw data structure 
(or any imported mzXML) and search for overloaded peaks within the mass traces. 
It will correct overloaded peaks automatically using an Gaussian or 
IsotopicRatio approach, generate QC plots and write the corrected data 
back into the original xcmsRaw.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CorrectOverloadedPeaks(
  data = NULL,
  method = c("Isoratio", "Gauss", "EMG"),
  detection_limit = 1,
  ds = NULL,
  silent = TRUE,
  testing = FALSE,
  attotwm = FALSE,
  region = NULL,
  peak = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CorrectOverloadedPeaks_+3A_data">data</code></td>
<td>
<p>An xcmsRaw-object or an mzXML-object as imported by <code><a href="#topic+read.mzXML">read.mzXML</a></code>.</p>
</td></tr>
<tr><td><code id="CorrectOverloadedPeaks_+3A_method">method</code></td>
<td>
<p>Either Gauss or EMG (usually better results) or Isoratio (more robust for non-Gaussian peak shapes).</p>
</td></tr>
<tr><td><code id="CorrectOverloadedPeaks_+3A_detection_limit">detection_limit</code></td>
<td>
<p>If=1 only peaks hitting detector saturation (ds) will be corrected, can be lowered to 0.95 to catch also peaks going into saturation.</p>
</td></tr>
<tr><td><code id="CorrectOverloadedPeaks_+3A_ds">ds</code></td>
<td>
<p>Detector saturation. Will be determined based on data if not specified explicitly.</p>
</td></tr>
<tr><td><code id="CorrectOverloadedPeaks_+3A_silent">silent</code></td>
<td>
<p>QC-plots will be generated if silent=FALSE and additional Warnings() will be generated.</p>
</td></tr>
<tr><td><code id="CorrectOverloadedPeaks_+3A_testing">testing</code></td>
<td>
<p>Will automatically set silent=FALSE and store all extracted regions with overloaded peaks in the working directory as <code>cor_df_all.RData</code>.</p>
</td></tr>
<tr><td><code id="CorrectOverloadedPeaks_+3A_attotwm">attotwm</code></td>
<td>
<p>All-the-Time-of-the-World-Mode. If calculation time doesn't matter try this out. :)</p>
</td></tr>
<tr><td><code id="CorrectOverloadedPeaks_+3A_region">region</code></td>
<td>
<p>From an initial QC-Plot file you may reprocess a specific overloaded region. Don't forget to specify the ds parameter explicitly.</p>
</td></tr>
<tr><td><code id="CorrectOverloadedPeaks_+3A_peak">peak</code></td>
<td>
<p>You may further restrict the reprocessing to a specific peak within the region.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a high level function to batch pre-process metabolomics data 
which are partially overloaded before continuing with the standard workflow 
of peak identification etc.. It relies internally on <code><a href="#topic+FitGaussPeak">FitGaussPeak</a></code> 
and <code><a href="#topic+FitPeakByIsotopicRatio">FitPeakByIsotopicRatio</a></code> to modify data of individual intensity 
signal. Basically the function aims to identify automatically overloaded regions
and extracts base peak chromatograms for all overloaded m/z traces within these 
regions, which are corrected and put back into the original data structure. 
For simplicity some potentially interesting parameters are hidden at the top of 
the function definition. They have been set to values determined empirically to 
be working for a Bruker impact II MS (high-res QTOF) coupled to GC and LC via 
APCI and ESI respectively. For more details please 
see <a href="https://doi.org/10.1021/acs.analchem.6b02515">doi:10.1021/acs.analchem.6b02515</a>.
</p>


<h3>Value</h3>

<p>An corrected xcmsRaw- or mzXML-object which can be exported to file. Additionally a QC-plot pdf-file if silent=FALSE.
</p>


<h3>References</h3>

<p><a href="https://doi.org/10.1021/acs.analchem.6b02515">doi:10.1021/acs.analchem.6b02515</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelGaussPeak">ModelGaussPeak</a></code>
</p>
<p><code><a href="#topic+FitGaussPeak">FitGaussPeak</a></code>
</p>
<p><code><a href="#topic+FitPeakByIsotopicRatio">FitPeakByIsotopicRatio</a></code>
</p>
<p><code><a href="#topic+read.mzXML">read.mzXML</a></code>
</p>
<p><code><a href="#topic+write.mzXML">write.mzXML</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # load mzXML test data
  data(mzXML_data)
  CorrectOverloadedPeaks(data = mzXML_data, method = "EMG", silent = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='FitGaussPeak'>Extrapolate a flat top peak using a Gauss approach.</h2><span id='topic+FitGaussPeak'></span>

<h3>Description</h3>

<p><code>FitGaussPeak</code> will take retention time ('x') and intensity ('y') data and extrapolate all points above
a certain threshold based on further parameters using a Gaussian approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitGaussPeak(
  x,
  y,
  scale_range = c(1, 10),
  steps = 10,
  cutoff = 0.95,
  idx = NULL,
  weight_front = 0.5,
  strip_data = "none",
  account_for_baseline_offset = TRUE,
  method = c("Gauss", "EMG")[1],
  silent = TRUE,
  fix_sd = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitGaussPeak_+3A_x">x</code></td>
<td>
<p>A numeric vector, retention times.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_y">y</code></td>
<td>
<p>A numeric vector, ion intensities.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_scale_range">scale_range</code></td>
<td>
<p>Specifies the expected range for the true peak to exceed the observed, where scale_range=c(1,100) would assume anything between not overloaded and 100-fold overloaded.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_steps">steps</code></td>
<td>
<p>Specifies a step parameter used to create a sequence within 'scale_range' to test for good fits, higher=more precision, fewer=faster.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_cutoff">cutoff</code></td>
<td>
<p>Overloaded peaks will be screwed from Gaussian shape already when approaching detector saturation (DS), cutoff=0.95 ensures that points just before DS will not be used to model fit.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_idx">idx</code></td>
<td>
<p>If not NULL, 'idx' is expected to specify points to correct explicitly (as a numeric-vector within 1:length(x)).</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_weight_front">weight_front</code></td>
<td>
<p>A weighting parameter to punish deviations in peak front and tail differently; 0.5=use front/tail equally, 1=use only front, 0=use only tail.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_strip_data">strip_data</code></td>
<td>
<p>Use all provided data if 'none' (default). Strip 'front' or 'tail' data in case you observe peak fronting or tailing respectively.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_account_for_baseline_offset">account_for_baseline_offset</code></td>
<td>
<p>If TRUE will subtract min(y) from y before fitting parameters.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_method">method</code></td>
<td>
<p>The method for peak shape calculation. Can be 'Gauss' or 'EMG' (exponentially modified gauss).</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_silent">silent</code></td>
<td>
<p>For testing purposes some QC-plot will be generated if silent=FALSE.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_fix_sd">fix_sd</code></td>
<td>
<p>Supply a fix standard deviation (sd) for the peak or leave NULL to estimate sd within function.</p>
</td></tr>
<tr><td><code id="FitGaussPeak_+3A_...">...</code></td>
<td>
<p>passed to the QC plot function, e.g. 'main' or 'xlab'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly used internally (<code><a href="#topic+CorrectOverloadedPeaks">CorrectOverloadedPeaks</a></code>) but can be of value on it's
own to test brute force peak reconstruction given that appropriate base peak chromatograms are available.
</p>


<h3>Value</h3>

<p>An annotated plot of the mass spectrum and detailed information within the console (if silent=FALSE) and
the optimal fitted data points (vector of length(y), returned invisible).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load test data
data("mzXML_data")
names(mzXML_data)
str(mzXML_data[["scan"]][[1]])
pk &lt;- ModelGaussPeak(height=10^7, width=3, scan_rate=10, e=0, ds=8*10^6, base_line=10^2)
plot(pk, main="Gaussian peak of true intensity 10^7 but cutt off at 8*10^6")
idx &lt;- pk[,"int"]&gt;0.005 * max(pk[,"int"])
tmp &lt;- FitGaussPeak(x=pk[idx,"rt"], y=pk[idx,"int"], silent=FALSE, xlab="RT", ylab="Intensity")

</code></pre>

<hr>
<h2 id='FitPeakByIsotopicRatio'>Extrapolate a flat top peak using isotopic ratios.</h2><span id='topic+FitPeakByIsotopicRatio'></span>

<h3>Description</h3>

<p><code>FitPeakByIsotopicRatio</code> will take a data frame containing peak data for retention time ('RT'), as well as
mass and intensity information of M0, M+1 and M+2 and extrapolate all points above a certain threshold for Int_M0
based on further parameters using an IsotopicRatio approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitPeakByIsotopicRatio(cor_df = NULL, idx = NULL, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitPeakByIsotopicRatio_+3A_cor_df">cor_df</code></td>
<td>
<p>A data frame containing information about the overloaded area; columns=(Scan, RT, mz0, int0, mz1, int1, mz2, int2, modified).</p>
</td></tr>
<tr><td><code id="FitPeakByIsotopicRatio_+3A_idx">idx</code></td>
<td>
<p>If not NULL, 'idx' is expected to specify points to correct explicitly (as a numeric-vector within 1:length(x)).</p>
</td></tr>
<tr><td><code id="FitPeakByIsotopicRatio_+3A_silent">silent</code></td>
<td>
<p>For testing purposes some QC-plot will be generated if silent=FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Isotopic ratios within ion traces of molecules can be considered stable. If this ratio is changed because one molecule,
let's say the M+0, is exceeding the detector range while another (say M+1) is still quantifiable, we therefore may
attempt to modify M+0 by multiplying the values of M+1 with a constant (the stable ratio). This constant is determined
ideally from the values within the peak front.
As this function is mainly used internally (<code><a href="#topic+CorrectOverloadedPeaks">CorrectOverloadedPeaks</a></code>), it is not very flexible with respect
to the input format. Please prepare a dataframe according to the parameter specifications or process a file using
<code><a href="#topic+CorrectOverloadedPeaks">CorrectOverloadedPeaks</a></code> with testing=TRUE, which will generate a list structure of such dataframes.
</p>


<h3>Value</h3>

<p>An annotated plot of the mass spectrum and detailed information within the console.
Main result will be returned invisible.
</p>

<hr>
<h2 id='ModelGaussPeak'>Create and modify parameters of an artificial chromatographic peak.</h2><span id='topic+ModelGaussPeak'></span>

<h3>Description</h3>

<p><code>ModelGaussPeak</code> will create a potentially overloaded Gaussian peak of requested width and height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModelGaussPeak(
  height = 10^7,
  width = 4,
  scan_rate = 10,
  e = 0,
  ds = 10^7,
  base_line = 10^2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ModelGaussPeak_+3A_height">height</code></td>
<td>
<p>True peak height (=intensity counts).</p>
</td></tr>
<tr><td><code id="ModelGaussPeak_+3A_width">width</code></td>
<td>
<p>Peak width in time units (preferably seconds).</p>
</td></tr>
<tr><td><code id="ModelGaussPeak_+3A_scan_rate">scan_rate</code></td>
<td>
<p>Is determining the resolution of data points per time unit (preferably seconds).</p>
</td></tr>
<tr><td><code id="ModelGaussPeak_+3A_e">e</code></td>
<td>
<p>Error term giving the percent amount of deviation from the ideal Gaussian curve for individual data points.</p>
</td></tr>
<tr><td><code id="ModelGaussPeak_+3A_ds">ds</code></td>
<td>
<p>Detector saturation. Intensity values will be cut off at this point if requested.</p>
</td></tr>
<tr><td><code id="ModelGaussPeak_+3A_base_line">base_line</code></td>
<td>
<p>Defines if peak is supposed to have a higher base level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main task of <code><a href="#topic+ModelGaussPeak">ModelGaussPeak</a></code> is to create peak data in Gaussian shape for testing. 
Width is meant in the chromatographic sense, i.e. the time between peak front and tail hitting the baseline.
</p>


<h3>Value</h3>

<p>Dataframe with columns 'rt' and 'int'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ylim &lt;- c(0,10^7)
par(mfrow=c(1,5))
pk &lt;- ModelGaussPeak(height=10^7, width=4, scan_rate=10, e=0, ds=10^7, base_line=10^2)
plot(pk,ylim=ylim,main="standard")
pk &lt;- ModelGaussPeak(height=10^7, width=4, scan_rate=10, e=0, ds=8*10^6, base_line=10^2)
plot(pk,ylim=ylim,main="flat top")
pk &lt;- ModelGaussPeak(height=10^7, width=4, scan_rate=10, e=0, ds=8*10^6, base_line=10^5)
plot(pk,ylim=ylim,main="high baseline")
pk &lt;- ModelGaussPeak(height=10^7, width=4, scan_rate=10, e=0.05, ds=8*10^6, base_line=10^5)
plot(pk,ylim=ylim,main="e=5%")
pk &lt;- ModelGaussPeak(height=10^7, width=4, scan_rate=5, e=0.05, ds=8*10^6, base_line=10^5)
plot(pk,ylim=ylim,main="sr=5")

</code></pre>

<hr>
<h2 id='mzXML_data'>mzXML_data.</h2><span id='topic+mzXML_data'></span>

<h3>Description</h3>

<p>mzXML_data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mzXML_data)
</code></pre>


<h3>Format</h3>

<p>A object of class mzXML. A test dataset imported by read.mzXML() from a GC-APCI measurement on a Bruker impact II, exported by Compass to an mzXML file.
</p>


<h3>Source</h3>

<p>Jan Lisec (jan.lisec@bam.de)
</p>

<hr>
<h2 id='read.mzData'>read.mzData.</h2><span id='topic+read.mzData'></span>

<h3>Description</h3>

<p><code>read.mzData</code> will import mzData as xcmsRaw-class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.mzData(filename, fmt = c("xcmsRaw"), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.mzData_+3A_filename">filename</code></td>
<td>
<p>A mzData file as exported by 'xcms::write.mzdata()'.</p>
</td></tr>
<tr><td><code id="read.mzData_+3A_fmt">fmt</code></td>
<td>
<p>Output format. Currently only xcmsRaw is supported.</p>
</td></tr>
<tr><td><code id="read.mzData_+3A_verbose">verbose</code></td>
<td>
<p>Print messages to console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main task of read.mzData functions is to import mzData files to R. 
Currently 'xcmsRaw' is supported as an output format. I created this 
function for legacy reasons as the mzData import is no longer supported 
by 'mzR' and consequently 'xcms' since 09/2021.
This is a quick and dirty implementation. It will work only for mslevel=1
and a fixed set of base64 encoding parameters (size = 4, endian = &quot;big&quot;).
However, feel free to send me an e-mail if you are interested in using
the function but cant get it working.
</p>


<h3>Value</h3>

<p>A generic R object of class xcmsRaw.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data(mzXML_data)
  write.mzXML(mzXML = mzXML_data, filename = "test.mzXML")
  x &lt;- xcms::xcmsRaw("test.mzXML",  profstep=0)
  xcms::write.mzdata(x, file="test.mzData")
  x2 &lt;- read.mzData(filename = "test.mzData")
  identical(str(x), str(x2))
  identical(x@env$intensity, x2@env$intensity)
  identical(x@env$mz, x2@env$mz)
  identical(x@scanindex, x2@scanindex)
  file.remove(c('test.mzData', 'test.mzXML'))

## End(Not run) 

</code></pre>

<hr>
<h2 id='read.mzXML'>Read and write standard mzXML files.</h2><span id='topic+read.mzXML'></span><span id='topic+write.mzXML'></span><span id='topic+new.mzXML'></span>

<h3>Description</h3>

<p>'read.mzXML' and 'write.mzXML' are copied from the caMassClass 
package which is no longer actively on CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.mzXML(filename)

write.mzXML(mzXML, filename, precision = c("32", "64"))

new.mzXML()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.mzXML_+3A_filename">filename</code></td>
<td>
<p>The mzXML file name to be read or written.</p>
</td></tr>
<tr><td><code id="read.mzXML_+3A_mzxml">mzXML</code></td>
<td>
<p>The generic mzXML object</p>
</td></tr>
<tr><td><code id="read.mzXML_+3A_precision">precision</code></td>
<td>
<p>Either '32' or '64' byte.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main task of 'read.mzXML' and 'write.mzXML' functions 
is to extract and save scan data of mzXML files. In addition attempt is 
made to keep all other sections of mzXML file as unparsed XML code, so 
the data can be extracted latter or saved into new mzXML files. Those 
unparsed sections are stored as XML text.
</p>


<h3>Value</h3>

<p>A generic R object of class mzXML for 'read.mzXML' and NULL for 'write.mzXML'.
</p>
<p>Nothing. mzXML object is exported to filename. If it was imported using <code><a href="#topic+read.mzXML">read.mzXML</a></code> it should contain all previous fields.
</p>

<hr>
<h2 id='verify_suggested'>verify_suggested.</h2><span id='topic+verify_suggested'></span>

<h3>Description</h3>

<p>Check if packages are available and stop function otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_suggested(pkg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_suggested_+3A_pkg">pkg</code></td>
<td>
<p>Package names to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
