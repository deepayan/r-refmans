<!DOCTYPE html><html><head><title>Help for package stabs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stabs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_folds'>
<p>Check if folds result from subsampling with p = 0.5.</p></a></li>
<li><a href='#Fitting+20Functions'>
<p>Fit Functions for Stability Selection</p></a></li>
<li><a href='#parameters'><p> Method to Extract Parameters</p></a></li>
<li><a href='#plot.stabsel'>
<p>Plot and Print Methods for Stability Selection</p></a></li>
<li><a href='#run_stabsel'>
<p>Run Stability Selection</p></a></li>
<li><a href='#selected'><p> Method to Extract Selected Variables</p></a></li>
<li><a href='#stabsel'>
<p>Stability Selection</p></a></li>
<li><a href='#stabsel_parameters'>
<p>Compute Error Bounds for Stability Selection</p></a></li>
<li><a href='#stabsel.stabsel'>
<p>Change Parameters of Stability Selection</p></a></li>
<li><a href='#subsample'><p> Draw Random Subsamples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Stability Selection with Error Control</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-01-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Resampling procedures to assess the stability of selected variables
    with additional finite sample error control for high-dimensional variable
    selection procedures such as Lasso or boosting. Both, standard stability
    selection (Meinshausen &amp; Buhlmann, 2010, &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2010.00740.x">doi:10.1111/j.1467-9868.2010.00740.x</a>&gt;) 
    and complementary pairs stability selection with improved error bounds 
    (Shah &amp; Samworth, 2013, &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2011.01034.x">doi:10.1111/j.1467-9868.2011.01034.x</a>&gt;) are
    implemented. The package can be combined with arbitrary user specified
    variable selection approaches.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), methods, stats, parallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glmnet, lars, mboost (&gt; 2.3-0), gamboostLSS (&ge; 1.2-0),
TH.data, hdi, testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hofnerb/stabs">https://github.com/hofnerb/stabs</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-28 09:19:53 UTC; Benjamin (PEI)</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Hofner [aut, cre],
  Torsten Hothorn [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Hofner &lt;benjamin.hofner@pei.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-29 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_folds'>
Check if folds result from subsampling with p = 0.5.
</h2><span id='topic+check_folds'></span>

<h3>Description</h3>

<p>(Internal) function that checks if folds result from subsampling with
p = 0.5 and adds complementary pairs if needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_folds(folds, B, n, sampling.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_folds_+3A_folds">folds</code></td>
<td>
<p> a weight matrix that represents the subsamples.</p>
</td></tr>
<tr><td><code id="check_folds_+3A_b">B</code></td>
<td>
<p> number of subsampling replicates. </p>
</td></tr>
<tr><td><code id="check_folds_+3A_n">n</code></td>
<td>
<p> the number of observations; needed for internal checks.</p>
</td></tr>
<tr><td><code id="check_folds_+3A_sampling.type">sampling.type</code></td>
<td>
<p> sampling type to be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function used to check if <code>folds</code> are
specified correctly. For details (e.g. on arguments) see
<code><a href="#topic+stabsel">stabsel</a></code>.
</p>


<h3>Value</h3>

<p>A matrix containing the <code>folds</code>, possibly after adding the
complementary pairs.
</p>


<h3>References</h3>

<p>B. Hofner, L. Boccuto and M. Goeker (2015), Controlling false
discoveries in high-dimensional situations: Boosting with stability
selection. <em>BMC Bioinformatics</em>, 16:144.<br />
doi: <a href="https://doi.org/10.1186/s12859-015-0575-3">10.1186/s12859-015-0575-3</a>.
</p>


<h3>See Also</h3>

<p>For details see <code><a href="#topic+stabsel">stabsel</a></code>.
</p>

<hr>
<h2 id='Fitting+20Functions'>
Fit Functions for Stability Selection
</h2><span id='topic+fitfun'></span><span id='topic+fitfuns'></span><span id='topic+glmnet.lasso'></span><span id='topic+glmnet.lasso_maxCoef'></span><span id='topic+lars.lasso'></span><span id='topic+lars.stepwise'></span>

<h3>Description</h3>

<p>Functions that fit a model until <code class="reqn">q</code> variables are selected and
that returns the indices (and names) of the selected variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## package lars:
lars.lasso(x, y, q, ...)
lars.stepwise(x, y, q, ...)

## package glmnet:
glmnet.lasso(x, y, q, type = c("conservative", "anticonservative"), ...)
glmnet.lasso_maxCoef(x, y, q, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fitting+2B20Functions_+3A_x">x</code></td>
<td>
<p>a matrix containing the predictors or an object of class
<code>"mboost"</code>.</p>
</td></tr>
<tr><td><code id="Fitting+2B20Functions_+3A_y">y</code></td>
<td>
<p>a vector or matrix containing the outcome.</p>
</td></tr>
<tr><td><code id="Fitting+2B20Functions_+3A_q">q</code></td>
<td>
<p>number of (unique) selected variables (or groups of variables
depending on the model) that are selected on each subsample.</p>
</td></tr>
<tr><td><code id="Fitting+2B20Functions_+3A_type">type</code></td>
<td>
<p> a charachter vector specifying if the number of selected
variables per subsample is <code class="reqn">\leq q</code> (<code>type = "conservative"</code>) 
or <code class="reqn">\geq q</code> (<code>type = "anticonservative"</code>). The conservative
version <em>ensures</em> that the PFER is controlled.</p>
</td></tr>
<tr><td><code id="Fitting+2B20Functions_+3A_...">...</code></td>
<td>
<p> additional arguments passed to the underlying fitting function.
See the example on <code>glmnet.lasso_maxCoef</code> in <code><a href="#topic+stabsel">stabsel</a></code> for 
the specification of additional arguments via <code><a href="#topic+stabsel">stabsel</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All fitting functions are named after the package and the type of
model that is fitted: <code>package_name.model</code>, e.g.,
<code>glmnet.lasso</code> stands for a lasso model that is fitted using the
package <span class="pkg">glmnet</span>.
</p>
<p><code>glmnet.lasso_maxCoef</code> fits a lasso model with a given penalty parameter 
and returns the <code>q</code> largest coefficients. If one wants to use
<code>glmnet.lasso_maxCoef</code>, one must specify the penalty parameter
<code>lambda</code> (via the <code>...</code> argument) or in
<code><a href="#topic+stabsel">stabsel</a></code> via <code>args.fitfun(lambda = )</code>. Note that usually, 
the penalty parameter cannot be specified but is chosen such that <code>q</code>
variables are selected. For an example on how to use 
<code>glmnet.lasso_maxCoef</code> see <code><a href="#topic+stabsel">stabsel</a></code>.
</p>


<h3>Value</h3>

<p>A named list with elements
</p>
<table>
<tr><td><code>selected</code></td>
<td>
<p>logical. A vector that indicates which variable was
selected.</p>
</td></tr>
<tr><td><code>path</code></td>
<td>
<p>logical. A matrix that indicates which variable was
selected in which step. Each row represents one variable, the
columns represent the steps.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+stabsel">stabsel</a></code> for stability selection itself.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (require("TH.data")) {
      ## make data set available
      data("bodyfat", package = "TH.data")
  } else {
      ## simulate some data if TH.data not available. 
      ## Note that results are non-sense with this data.
      bodyfat &lt;- matrix(rnorm(720), nrow = 72, ncol = 10)
  }
  
  if (require("lars")) {
      ## selected variables
      lars.lasso(bodyfat[, -2], bodyfat[,2], q = 3)$selected
      lars.stepwise(bodyfat[, -2], bodyfat[,2], q = 3)$selected
  }
  
  if (require("glmnet")) {
      glmnet.lasso(bodyfat[, -2], bodyfat[,2], q = 3)$selected
      ## selection path
      glmnet.lasso(bodyfat[, -2], bodyfat[,2], q = 3)$path
  
      ## Using the anticonservative glmnet.lasso (see args.fitfun):
      stab.glmnet &lt;- stabsel(x = bodyfat[, -2], y = bodyfat[,2],
                             fitfun = glmnet.lasso, 
                             args.fitfun = list(type = "anticonservative"), 
                             cutoff = 0.75, PFER = 1)
  }
</code></pre>

<hr>
<h2 id='parameters'> Method to Extract Parameters</h2><span id='topic+parameters'></span><span id='topic+stabsel_parameters.stabsel'></span>

<h3>Description</h3>

<p>Extract stability selection parameters, i.e., tuning parameters, from
a <code>stabsel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(object)

## extract parameters from a stabsel model
## (same as parameters(p) )
## S3 method for class 'stabsel'
stabsel_parameters(p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameters_+3A_object">object</code></td>
<td>
<p> an object of class <code>"stabsel"</code> or
<code>"stabsel_parameters"</code>. </p>
</td></tr>
<tr><td><code id="parameters_+3A_p">p</code></td>
<td>
<p>an object of class <code>"stabsel"</code>.</p>
</td></tr>
<tr><td><code id="parameters_+3A_...">...</code></td>
<td>
<p> additional arguments, currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+stabsel_parameters">stabsel_parameters</a></code> with a special
<code>print</code> method. See there for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stabsel">stabsel</a></code> to run stability selection and
<code><a href="#topic+stabsel_parameters">stabsel_parameters</a></code> for details on the parameters.
</p>

<hr>
<h2 id='plot.stabsel'>
Plot and Print Methods for Stability Selection
</h2><span id='topic+plot'></span><span id='topic+plot.stabsel'></span><span id='topic+print.stabsel'></span>

<h3>Description</h3>

<p>Display results of stability selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stabsel'
plot(x, main = deparse(x$call), type = c("maxsel", "paths"),
     xlab = NULL, ylab = NULL, col = NULL, ymargin = 10, np = sum(x$max &gt; 0),
     labels = NULL, ...)
## S3 method for class 'stabsel'
print(x, decreasing = FALSE, print.all = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.stabsel_+3A_x">x</code></td>
<td>
<p>object of class <code>stabsel</code>.</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_main">main</code></td>
<td>
<p>main title for the plot.</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_type">type</code></td>
<td>
<p>plot type; either stability paths (<code>"paths"</code>) or a
plot of the maximum selection frequency (<code>"maxsel"</code>).</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_xlab">xlab</code>, <code id="plot.stabsel_+3A_ylab">ylab</code></td>
<td>
<p>labels for the x- and y-axis of the plot. Per
default, sensible labels are used depending on the <code>type</code> of
the plot.</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_col">col</code></td>
<td>
<p>a vector of colors; Typically, one can specify a single
color or one color for each variable. Per default, colors depend on
the maximal selection frequency of the variable and range from grey
to red.</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_ymargin">ymargin</code></td>
<td>
<p>(temporarily) specifies the y margin of of the plot in
lines (see argument <code>"mar"</code> of function <code><a href="graphics.html#topic+par">par</a></code>).
This only affects the right margin for <code>type = "paths"</code> and
the left margin for <code>type = "maxsel"</code>. Explicit user specified
margins are kept and are not overwritten.</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_np">np</code></td>
<td>
<p>number of variables to plot for the maximum selection
frequency plot (<code>type = "maxsel"</code>); the first <code>np</code>
variables with highest selection frequency are plotted.</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_labels">labels</code></td>
<td>
<p>variable labels for the plot; one label per variable / effect
must be specified. Per default, the names of <code>x$max</code> are used.</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. Should the selection frequencies be printed
in descending order (<code>TRUE</code>) or in ascending order
(<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_print.all">print.all</code></td>
<td>
<p>logical. Should all selection frequencies be
displayed or only those that are greater than zero?</p>
</td></tr>
<tr><td><code id="plot.stabsel_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>plot</code> and <code>print</code>
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the stability selection procedure
by Meinshausen and Buehlmann (2010) and the improved error bounds by
Shah and Samworth (2013).
</p>
<p>Two of the three arguments <code>cutoff</code>, <code>q</code> and <code>PFER</code>
<em>must</em> be specified. The per-family error rate (PFER), i.e., the
expected number of false positives <code class="reqn">E(V)</code>, where <code class="reqn">V</code> is the
number of false positives, is bounded by the argument <code>PFER</code>.
</p>
<p>As controlling the PFER is more conservative as controlling the
family-wise error rate (FWER), the procedure also controlls the FWER,
i.e., the probability of selecting at least one non-influential
variable (or model component) is less than <code>PFER</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>stabsel</code> with a special <code>print</code> method.
The object has the following elements:
</p>
<table>
<tr><td><code>phat</code></td>
<td>
<p>selection probabilities.</p>
</td></tr>
<tr><td><code>selected</code></td>
<td>
<p>elements with maximal selection probability greater
<code>cutoff</code>.</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>maximum of selection probabilities.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>cutoff used.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>average number of selected variables used.</p>
</td></tr>
<tr><td><code>PFER</code></td>
<td>
<p>per-family error rate.</p>
</td></tr>
<tr><td><code>sampling.type</code></td>
<td>
<p>the sampling type used for stability selection.</p>
</td></tr>
<tr><td><code>assumption</code></td>
<td>
<p>the assumptions made on the selection
probabilities.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>B. Hofner, L. Boccuto and M. Goeker (2015), Controlling false
discoveries in high-dimensional situations: Boosting with stability
selection. <em>BMC Bioinformatics</em>, 16:144.<br />
doi: <a href="https://doi.org/10.1186/s12859-015-0575-3">10.1186/s12859-015-0575-3</a>.
</p>
<p>N. Meinshausen and P. Buehlmann (2010), Stability selection.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>72</b>, 417&ndash;473.
</p>
<p>R.D. Shah and R.J. Samworth (2013), Variable selection with error
control: another look at stability selection. <em>Journal of the Royal
Statistical Society, Series B</em>, <b>75</b>, 55&ndash;80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stabsel">stabsel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (require("TH.data")) {
      ## make data set available
      data("bodyfat", package = "TH.data")
  } else {
      ## simulate some data if TH.data not available. 
      ## Note that results are non-sense with this data.
      bodyfat &lt;- matrix(rnorm(720), nrow = 72, ncol = 10)
  }
  
  ## set seed
  set.seed(1234)

  ####################################################################
  ### using stability selection with Lasso methods:

  if (require("lars")) {
      (stab.lasso &lt;- stabsel(x = bodyfat[, -2], y = bodyfat[,2],
                             fitfun = lars.lasso, cutoff = 0.75,
                             PFER = 1))
      par(mfrow = c(2, 1))
      plot(stab.lasso, ymargin = 6)
      opar &lt;- par(mai = par("mai") * c(1, 1, 1, 2.7))
      plot(stab.lasso, type = "paths")
  }
</code></pre>

<hr>
<h2 id='run_stabsel'>
Run Stability Selection
</h2><span id='topic+run_stabsel'></span>

<h3>Description</h3>

<p>(Internal) function that is used to run stability selection (i.e. to
apply the fit-function to the subsamples. This function is not intended
to be directly called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_stabsel(fitter, args.fitter, n, p, cutoff, q, PFER, folds, B, assumption,
            sampling.type, papply, verbose, FWER, eval, names,
            mc.preschedule = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_stabsel_+3A_fitter">fitter</code></td>
<td>
<p>a function to fit the model on subsamples. See argument
<code>fitfun</code> of <code><a href="#topic+stabsel">stabsel</a></code> for details.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_args.fitter">args.fitter</code></td>
<td>
<p>a named list containing additional arguments that are
passed to <code>fitter</code>. See argument <code>args.fitfun</code>
<code><a href="#topic+stabsel">stabsel</a></code> for details.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_n">n</code></td>
<td>
<p> the number of observations; needed for internal checks.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_p">p</code></td>
<td>
<p> number of possible predictors (including intercept if
applicable).</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff between 0.5 and 1. </p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_q">q</code></td>
<td>
<p>number of (unique) selected variables (or groups of variables
depending on the model) that are selected on each subsample.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_pfer">PFER</code></td>
<td>
<p> upper bound for the per-family error rate.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_folds">folds</code></td>
<td>
<p> a weight matrix that represents the subsamples.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_b">B</code></td>
<td>
<p> number of subsampling replicates. </p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_assumption">assumption</code></td>
<td>
<p> distributional assumption.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_sampling.type">sampling.type</code></td>
<td>
<p> sampling type to be used.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_papply">papply</code></td>
<td>
<p> (parallel) apply function.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_verbose">verbose</code></td>
<td>
<p> logical (default: <code>TRUE</code>) that determines wether
<code>warnings</code> should be issued.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_fwer">FWER</code></td>
<td>
<p> deprecated. Only for compatibility with older versions,
use PFER instead.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_eval">eval</code></td>
<td>
<p> logical. Determines whether stability selection is
evaluated.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_names">names</code></td>
<td>
<p> variable names that are used to label the results.</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>
<p> preschedule tasks?</p>
</td></tr>
<tr><td><code id="run_stabsel_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to next function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an internal function that fits the actual models to the
subsamples, i.e., this is the work horse that runs stability
selection. Usually, one should use  <code><a href="#topic+stabsel">stabsel</a></code>, which
internally calls <code>run_stabsel</code>.
</p>
<p><code>run_stabsel</code> can be used by expert users to implement stability
selection methods for new model types.
</p>
<p>For details (e.g. on arguments) see <code><a href="#topic+stabsel">stabsel</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>stabsel</code> with the following elements:
</p>
<table>
<tr><td><code>phat</code></td>
<td>
<p>selection probabilities.</p>
</td></tr>
<tr><td><code>selected</code></td>
<td>
<p>elements with maximal selection probability greater
<code>cutoff</code>.</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>maximum of selection probabilities.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>cutoff used.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>average number of selected variables used.</p>
</td></tr>
<tr><td><code>PFER</code></td>
<td>
<p>per-family error rate.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of effects subject to selection.</p>
</td></tr>
<tr><td><code>sampling.type</code></td>
<td>
<p>the sampling type used for stability selection.</p>
</td></tr>
<tr><td><code>assumption</code></td>
<td>
<p>the assumptions made on the selection
probabilities.</p>
</td></tr>
</table>


<h3>References</h3>

<p>B. Hofner, L. Boccuto and M. Goeker (2015), Controlling false
discoveries in high-dimensional situations: Boosting with stability
selection. <em>BMC Bioinformatics</em>, 16:144.<br />
doi: <a href="https://doi.org/10.1186/s12859-015-0575-3">10.1186/s12859-015-0575-3</a>.
</p>


<h3>See Also</h3>

<p>For details see <code><a href="#topic+stabsel">stabsel</a></code>.
</p>

<hr>
<h2 id='selected'> Method to Extract Selected Variables </h2><span id='topic+selected'></span><span id='topic+selected.stabsel'></span>

<h3>Description</h3>

<p>Extract selected variables from a <code>stabsel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selected(object, ...)
## S3 method for class 'stabsel'
selected(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selected_+3A_object">object</code></td>
<td>
<p> an object of class <code>"stabsel"</code>. </p>
</td></tr>
<tr><td><code id="selected_+3A_...">...</code></td>
<td>
<p> additional arguments passed to specific <code>selected</code>
methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ids of variables selected during the stability selection process
can be extracted using <code>selected()</code>.
</p>

<hr>
<h2 id='stabsel'>
Stability Selection
</h2><span id='topic+stabsel'></span><span id='topic+stabsel.matrix'></span><span id='topic+stabsel.data.frame'></span>

<h3>Description</h3>

<p>Selection of influential variables or model components with error control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## generic stability selection funcion
stabsel(x, ...)

## a method to fit models with stability selection
## S3 method for class 'matrix'
stabsel(x, y, fitfun = lars.lasso,
        args.fitfun = list(), cutoff, q, PFER,
        folds = subsample(rep(1, nrow(x)), B = B),
        B = ifelse(sampling.type == "MB", 100, 50),
        assumption = c("unimodal", "r-concave", "none"),
        sampling.type = c("SS", "MB"),
        papply = mclapply, mc.preschedule = FALSE,
        verbose = TRUE, FWER, eval = TRUE, ...)

## essentially a wrapper for data.frames (see details)
## S3 method for class 'data.frame'
stabsel(x,  y, intercept = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsel_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+matrix">matrix</a></code> or a <code><a href="base.html#topic+data.frame">data.frame</a></code>
containing the predictors.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_y">y</code></td>
<td>
<p>a vector or matrix containing the outcome.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_intercept">intercept</code></td>
<td>
<p>logical. If <code>x</code> is a <code><a href="base.html#topic+data.frame">data.frame</a></code>,
this argument determines if the resulting model matrix should
contain a separate intercept or not.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_fitfun">fitfun</code></td>
<td>
<p>a function that takes the arguments <code>x</code>, <code>y</code>
as above, and additionally the number of variables to include in
each model <code>q</code>. The function then needs to fit the model and to
return a logical vector that indicates which variable was selected
(among the <code>q</code> selected variables).</p>
</td></tr>
<tr><td><code id="stabsel_+3A_args.fitfun">args.fitfun</code></td>
<td>
<p>a named list containing additional arguments that are
passed to the fitting function; see also argument <code>args</code> in
<code><a href="base.html#topic+do.call">do.call</a></code>.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff between 0.5 and 1. Preferably a value between 0.6
and 0.9 should be used.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_q">q</code></td>
<td>
<p>number of (unique) selected variables (or groups of variables
depending on the model) that are selected on each subsample.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_pfer">PFER</code></td>
<td>
<p>upper bound for the per-family error rate. This
specifies the amount of falsely selected base-learners, which is
tolerated. See details.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_folds">folds</code></td>
<td>
<p> a weight matrix with number of rows equal to the number
of observations, see <code><a href="#topic+subsample">subsample</a></code>. Usually one should not
change the default here as subsampling with a fraction of <code class="reqn">1/2</code>
is needed for the error bounds to hold. One usage scenario where
specifying the folds by hand might be the case when one has
dependent data (e.g. clusters) and thus wants to draw clusters
(i.e., multiple rows together) not individuals.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_assumption">assumption</code></td>
<td>
<p> Defines the type of assumptions on the
distributions of the selection probabilities and simultaneous
selection probabilities. Only applicable for
<code>sampling.type = "SS"</code>. Per default, <code>"unimodality"</code> is assumed.
For <code>sampling.type = "MB"</code> we always use <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_sampling.type">sampling.type</code></td>
<td>
<p> use sampling scheme of of Shah &amp; Samworth
(2013), i.e., with complementarty pairs (<code>sampling.type = "SS"</code>),
or the original sampling scheme of Meinshausen &amp; Buehlmann (2010).</p>
</td></tr>
<tr><td><code id="stabsel_+3A_b">B</code></td>
<td>
<p> number of subsampling replicates. Per default, we use 50
complementary pairs for the error bounds of Shah &amp; Samworth (2013)
and 100 for the error bound derived in  Meinshausen &amp; Buehlmann
(2010). As we use <code class="reqn">B</code> complementray pairs in the former case
this leads to <code class="reqn">2B</code> subsamples.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_papply">papply</code></td>
<td>
<p> (parallel) apply function, defaults to
<code><a href="parallel.html#topic+mclapply">mclapply</a></code>. Alternatively, <code>parLapply</code>
can be used. In the latter case, usually more setup is needed (see
example of <code><a href="mboost.html#topic+cvrisk">cvrisk</a></code> for some details).</p>
</td></tr>
<tr><td><code id="stabsel_+3A_mc.preschedule">mc.preschedule</code></td>
<td>

<p>preschedule tasks if <code>papply = <a href="parallel.html#topic+mclapply">mclapply</a></code> (default:
<code>mc.preschedule = FALSE</code>)? For details see <code><a href="parallel.html#topic+mclapply">mclapply</a></code>.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_verbose">verbose</code></td>
<td>
<p> logical (default: <code>TRUE</code>) that determines wether
<code>warnings</code> should be issued. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_fwer">FWER</code></td>
<td>
<p> deprecated. Only for compatibility with older versions,
use PFER instead.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_eval">eval</code></td>
<td>
<p> logical. Determines whether stability selection is
evaluated (<code>eval = TRUE</code>; default) or if only the parameter
combination is returned.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_...">...</code></td>
<td>
<p> additional arguments to parallel apply methods such as
<code><a href="parallel.html#topic+mclapply">mclapply</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the stability selection procedure by
Meinshausen and Buehlmann (2010) and the improved error bounds by Shah
and Samworth (2013). For details see also Hofner et al. (2014). The
error bounds are implemented in the function
<code><a href="#topic+stabsel_parameters">stabsel_parameters</a></code>. Two of the three arguments
<code>cutoff</code>, <code>q</code> and <code>PFER</code> <em>must</em> be specified. The
per-family error rate (PFER), i.e., the expected number of false
positives <code class="reqn">E(V)</code>, where <code class="reqn">V</code> is the number of false positives,
is bounded by the argument <code>PFER</code>.
</p>
<p>As controlling the PFER is more conservative as controlling the
family-wise error rate (FWER), the procedure also controlls the FWER,
i.e., the probability of selecting at least one non-influential
variable (or model component) is less than <code>PFER</code>.
</p>
<p>Predefined <code><a href="#topic+fitfuns">fitfuns</a></code> functions exist but more can be
easily implemented. Note that stepwise regression methods are usually
not advised as they tend to be relatively unstable. See example below.
</p>
<p>The function <code>stabsel</code> for <code><a href="base.html#topic+data.frame">data.frame</a></code>s is
essentially just a wrapper to the <code><a href="base.html#topic+matrix">matrix</a></code> function with
the same argments. The only difference is that in a pre-processing
step, the data set is converted to a model matrix using the function
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. The additional argument <code>intercept</code>
determines if an explicit intercept should be added to the model
matrix. This is often not neccessary but depends on the <code>fitfun</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>stabsel</code> with a special <code>print</code> method.
The object has the following elements:
</p>
<table>
<tr><td><code>phat</code></td>
<td>
<p>selection probabilities.</p>
</td></tr>
<tr><td><code>selected</code></td>
<td>
<p>elements with maximal selection probability greater
<code>cutoff</code>.</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>maximum of selection probabilities.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p>cutoff used.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>average number of selected variables used.</p>
</td></tr>
<tr><td><code>PFER</code></td>
<td>
<p>(realized) upper bound for the per-family error rate.</p>
</td></tr>
<tr><td><code>specifiedPFER</code></td>
<td>
<p>specified upper bound for the per-family error rate.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of effects subject to selection.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the number of subsamples.</p>
</td></tr>
<tr><td><code>sampling.type</code></td>
<td>
<p>the sampling type used for stability selection.</p>
</td></tr>
<tr><td><code>assumption</code></td>
<td>
<p>the assumptions made on the selection
probabilities.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call.</p>
</td></tr>
</table>


<h3>References</h3>

<p>B. Hofner, L. Boccuto and M. Goeker (2015), Controlling false
discoveries in high-dimensional situations: Boosting with stability
selection. <em>BMC Bioinformatics</em>, 16:144.<br />
doi: <a href="https://doi.org/10.1186/s12859-015-0575-3">10.1186/s12859-015-0575-3</a>.
</p>
<p>N. Meinshausen and P. Buehlmann (2010), Stability selection.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>72</b>, 417&ndash;473.
</p>
<p>R.D. Shah and R.J. Samworth (2013), Variable selection with error
control: another look at stability selection. <em>Journal of the Royal
Statistical Society, Series B</em>, <b>75</b>, 55&ndash;80.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stabsel_parameters">stabsel_parameters</a></code> for the computation of error bounds,
<code><a href="#topic+stabsel.stabsel">stabsel.stabsel</a></code> for the fast re-computation of
parameters of a fitted <code>stabsel</code> object,
<code><a href="#topic+fitfun">fitfun</a></code> for available fitting functions and
<code><a href="#topic+plot.stabsel">plot.stabsel</a></code> for available plot functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  if (require("TH.data")) {
      ## make data set available
      data("bodyfat", package = "TH.data")
  } else {
      ## simulate some data if TH.data not available. 
      ## Note that results are non-sense with this data.
      bodyfat &lt;- matrix(rnorm(720), nrow = 72, ncol = 10)
  }
  
  ## set seed
  set.seed(1234)
  
  ####################################################################
  ### using stability selection with Lasso methods:

  if (require("lars")) {
      (stab.lasso &lt;- stabsel(x = bodyfat[, -2], y = bodyfat[,2],
                             fitfun = lars.lasso, cutoff = 0.75,
                             PFER = 1))
      (stab.stepwise &lt;- stabsel(x = bodyfat[, -2], y = bodyfat[,2],
                                fitfun = lars.stepwise, cutoff = 0.75,
                                PFER = 1))
      par(mfrow = c(2, 1))
      plot(stab.lasso, main = "Lasso")
      plot(stab.stepwise, main = "Stepwise Selection")
      ## --&gt; stepwise selection seems to be quite unstable even in this low
      ##     dimensional example!
  }

  ## set seed (again to make results comparable)
  set.seed(1234)
  if (require("glmnet")) {
      (stab.glmnet &lt;- stabsel(x = bodyfat[, -2], y = bodyfat[,2],
                              fitfun = glmnet.lasso, cutoff = 0.75,
                              PFER = 1))
      par(mfrow = c(2, 1))
      plot(stab.glmnet, main = "Lasso (glmnet)")
      if (exists("stab.lasso"))
          plot(stab.lasso, main = "Lasso (lars)")    
  }
  
  
  ## Select variables with maximum coefficients based on lasso estimate
  
  set.seed(1234) # reset seed
  if (require("glmnet")) {
      ## use cross-validated lambda 
      lambda.min &lt;- cv.glmnet(x = as.matrix(bodyfat[, -2]), y = bodyfat[,2])$lambda.min
      (stab.maxCoef &lt;- stabsel(x = bodyfat[, -2], y = bodyfat[,2],
                               fitfun = glmnet.lasso_maxCoef, 
                               # specify additional parameters to fitfun
                               args.fitfun = list(lambda = lambda.min),
                               cutoff = 0.75, PFER = 1))
                               
      ## WARNING: Using a fixed penalty (lambda) is usually not permitted and 
      ##          not sensible. See ?fitfun for details.
      
      ## now compare standard lasso with "maximal parameter estimates" from lasso
      par(mfrow = c(2, 1))
      plot(stab.maxCoef, main = "Lasso (glmnet; Maximum Coefficients)")
      plot(stab.glmnet, main = "Lasso (glmnet)")
      ## --&gt; very different results.
  }

  ####################################################################
  ### using stability selection directly on computed boosting models
  ### from mboost


  if (require("mboost")) {
      ### low-dimensional example
      mod &lt;- glmboost(DEXfat ~ ., data = bodyfat)

      ## compute cutoff ahead of running stabsel to see if it is a sensible
      ## parameter choice.
      ##   p = ncol(bodyfat) - 1 (= Outcome) + 1 ( = Intercept)
      stabsel_parameters(q = 3, PFER = 1, p = ncol(bodyfat) - 1 + 1,
                         sampling.type = "MB")
      ## the same:
      stabsel(mod, q = 3, PFER = 1, sampling.type = "MB", eval = FALSE)

      ### Do not test the following code per default on CRAN as it takes some time to run:
      ## now run stability selection
      (sbody &lt;- stabsel(mod, q = 3, PFER = 1, sampling.type = "MB"))
      opar &lt;- par(mai = par("mai") * c(1, 1, 1, 2.7))
      plot(sbody)
      par(opar)
      plot(sbody, type = "maxsel", ymargin = 6)
      
  }
</code></pre>

<hr>
<h2 id='stabsel_parameters'>
Compute Error Bounds for Stability Selection
</h2><span id='topic+stabsel_parameters'></span><span id='topic+stabsel_parameters.default'></span><span id='topic+print.stabsel_parameters'></span>

<h3>Description</h3>

<p>Compute the missing parameter from the two given parameters
in order to assess suitability of the parameter constellation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabsel_parameters(p, ...)

## Default S3 method:
stabsel_parameters(p, cutoff, q, PFER,
                   B = ifelse(sampling.type == "MB", 100, 50),
                   assumption = c("unimodal", "r-concave", "none"),
                   sampling.type = c("SS", "MB"),
                   verbose = FALSE, FWER, ...)

## S3 method for class 'stabsel_parameters'
print(x, heading = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsel_parameters_+3A_p">p</code></td>
<td>
<p> number of possible predictors (including intercept if
applicable).</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff between 0.5 and 1. Preferably a value between 0.6
and 0.9 should be used.</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_q">q</code></td>
<td>
<p>number of (unique) selected variables (or groups of variables
depending on the model) that are selected on each subsample.</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_pfer">PFER</code></td>
<td>
<p>upper bound for the per-family error rate. This
specifies the amount of falsely selected base-learners, which is
tolerated. See details.</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_b">B</code></td>
<td>
<p> number of subsampling replicates. Per default, we use 50
complementary pairs for the error bounds of Shah &amp; Samworth (2013)
and 100 for the error bound derived in  Meinshausen &amp; Buehlmann
(2010). As we use <code class="reqn">B</code> complementray pairs in the former case
this leads to <code class="reqn">2B</code> subsamples.</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_assumption">assumption</code></td>
<td>
<p> Defines the type of assumptions on the
distributions of the selection probabilities and simultaneous
selection probabilities. Only applicable for
<code>sampling.type = "SS"</code>. For <code>sampling.type = "MB"</code> we
always use code&quot;none&quot;.</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_sampling.type">sampling.type</code></td>
<td>
<p> use sampling scheme of of Shah &amp; Samworth
(2013), i.e., with complementarty pairs (<code>sampling.type = "SS"</code>),
or the original sampling scheme of Meinshausen &amp; Buehlmann (2010).</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_verbose">verbose</code></td>
<td>
<p> logical (default: <code>TRUE</code>) that determines wether
<code>warnings</code> should be issued. </p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_fwer">FWER</code></td>
<td>
<p> deprecated. Only for compatibility with older versions,
use PFER instead.</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_x">x</code></td>
<td>
<p> an object of class <code>"stabsel_parameters"</code>.</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_heading">heading</code></td>
<td>
<p> logical. Specifies if a heading line should be printed.</p>
</td></tr>
<tr><td><code id="stabsel_parameters_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to next function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the error bounds for stability selection
by Meinshausen and Buehlmann (2010) and the improved error bounds by
Shah and Samworth (2013). For details see also Hofner et al. (2014).
</p>
<p>Two of the three arguments <code>cutoff</code>, <code>q</code> and <code>PFER</code>
<em>must</em> be specified. The per-family error rate (PFER), i.e., the
expected number of false positives <code class="reqn">E(V)</code>, where <code class="reqn">V</code> is the
number of false positives, is bounded by the argument <code>PFER</code>.
</p>
<p>For more details see also <code><a href="#topic+stabsel">stabsel</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>stabsel_parameters</code> with a special <code>print</code> method.
The object has the following elements:
</p>
<table>
<tr><td><code>cutoff</code></td>
<td>
<p>cutoff used.</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>average number of selected variables used.</p>
</td></tr>
<tr><td><code>PFER</code></td>
<td>
<p>(realized) upper bound for the per-family error rate.</p>
</td></tr>
<tr><td><code>specifiedPFER</code></td>
<td>
<p>specified upper bound for the per-family error rate.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the number of effects subject to selection.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>the number of subsamples.</p>
</td></tr>
<tr><td><code>sampling.type</code></td>
<td>
<p>the sampling type used for stability selection.</p>
</td></tr>
<tr><td><code>assumption</code></td>
<td>
<p>the assumptions made on the selection
probabilities.</p>
</td></tr>
</table>


<h3>References</h3>

<p>B. Hofner, L. Boccuto and M. Goeker (2015), Controlling false
discoveries in high-dimensional situations: Boosting with stability
selection. <em>BMC Bioinformatics</em>, 16:144.<br />
doi: <a href="https://doi.org/10.1186/s12859-015-0575-3">10.1186/s12859-015-0575-3</a>.
</p>
<p>N. Meinshausen and P. Buehlmann (2010), Stability selection.
<em>Journal of the Royal Statistical Society, Series B</em>,
<b>72</b>, 417&ndash;473.
</p>
<p>R.D. Shah and R.J. Samworth (2013), Variable selection with error
control: another look at stability selection. <em>Journal of the Royal
Statistical Society, Series B</em>, <b>75</b>, 55&ndash;80.
</p>


<h3>See Also</h3>

<p>For more details see also <code><a href="#topic+stabsel">stabsel</a></code>.
</p>

<hr>
<h2 id='stabsel.stabsel'>
Change Parameters of Stability Selection
</h2><span id='topic+stabsel.stabsel'></span>

<h3>Description</h3>

<p>Method to change the parameters <code>cutoff</code>, <code>PFER</code> and
<code>assumption</code> of stability selection that can be altered without
the need to re-run the subsampling process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stabsel'
stabsel(x, cutoff, PFER, assumption = x$assumption, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsel.stabsel_+3A_x">x</code></td>
<td>
<p>an object that results from a call to <code><a href="#topic+stabsel">stabsel</a></code>.</p>
</td></tr>
<tr><td><code id="stabsel.stabsel_+3A_cutoff">cutoff</code></td>
<td>
<p>cutoff between 0.5 and 1. Preferably a value between 0.6
and 0.9 should be used.</p>
</td></tr>
<tr><td><code id="stabsel.stabsel_+3A_pfer">PFER</code></td>
<td>
<p>upper bound for the per-family error rate. This
specifies the amount of falsely selected base-learners, which is
tolerated. See details.</p>
</td></tr>
<tr><td><code id="stabsel.stabsel_+3A_assumption">assumption</code></td>
<td>
<p> Defines the type of assumptions on the
distributions of the selection probabilities and simultaneous
selection probabilities. Only applicable for
<code>sampling.type = "SS"</code>. For <code>sampling.type = "MB"</code> we
always use code&quot;none&quot;.</p>
</td></tr>
<tr><td><code id="stabsel.stabsel_+3A_...">...</code></td>
<td>
<p> additional arguments that are currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows to alter the parameters <code>cutoff</code>,
<code>PFER</code> and <code>assumption</code> of a fitted stability selection
result. All other parameters are re-used from the original stability
selection results. The missing paramter is computed and the selected
variables are updated accordingly.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+stabsel">stabsel</a></code>. For details see there.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stabsel">stabsel</a></code> for the generic function,
<code><a href="#topic+stabsel_parameters">stabsel_parameters</a></code> for the computation of error bounds,
<code><a href="#topic+fitfun">fitfun</a></code> for available fitting functions and
<code><a href="#topic+plot.stabsel">plot.stabsel</a></code> for available plot functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (require("TH.data")) {
      ## make data set available
      data("bodyfat", package = "TH.data")
  } else {
      ## simulate some data if TH.data not available. 
      ## Note that results are non-sense with this data.
      bodyfat &lt;- matrix(rnorm(720), nrow = 72, ncol = 10)
  }
  
  ## set seed
  set.seed(1234)

  ####################################################################
  ### using stability selection with Lasso methods:

  if (require("lars")) {
      (stab.lasso &lt;- stabsel(x = bodyfat[, -2], y = bodyfat[,2],
                             fitfun = lars.lasso, cutoff = 0.75,
                             PFER = 1))

      par(mfrow = c(2, 1))
      plot(stab.lasso)

      ## now change the PFER and the assumption:
      (stab.lasso_cf0.93_rconc &lt;- stabsel(stab.lasso, cutoff = 0.93,
                                          assumption = "r-concave"))
      plot(stab.lasso_cf0.93_rconc)
      ## the cutoff did change and hence the PFER and the selected
      ## variables
  }
</code></pre>

<hr>
<h2 id='subsample'> Draw Random Subsamples </h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>Set up weight matrix for subsampling with sample proportion <code class="reqn">1/2</code>
to be used with <code><a href="#topic+stabsel">stabsel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(weights, B = 100, strata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsample_+3A_weights">weights</code></td>
<td>
<p> a numeric vector of weights for the model to be cross-validated.</p>
</td></tr>
<tr><td><code id="subsample_+3A_b">B</code></td>
<td>
<p> number of folds, per default 25 for <code>bootstrap</code> and
<code>subsampling</code> and 10 for <code>kfold</code>.</p>
</td></tr>
<tr><td><code id="subsample_+3A_strata">strata</code></td>
<td>
<p> a factor of the same length as <code>weights</code> for
stratification.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>subsample</code> can be used to build an appropriate
weight matrix to be used with <code><a href="#topic+stabsel">stabsel</a></code>. See there for
more details.
</p>
<p>If <code>strata</code> is defined sampling is performed in each stratum
separately thus preserving the distribution of the <code>strata</code>
variable in each fold.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stabsel">stabsel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## just a low-dimensional example
  subsample(weights = rep(1, 10), B = 50)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
