<!DOCTYPE html><html><head><title>Help for package VineCopula</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {VineCopula}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.copuladata'><p>Copula Data Objects</p></a></li>
<li><a href='#BetaMatrix'><p>Matrix of Empirical Blomqvist's Beta Values</p></a></li>
<li><a href='#BiCop'><p>Constructing BiCop-objects</p></a></li>
<li><a href='#BiCopCDF'><p>Distribution Function of a Bivariate Copula</p></a></li>
<li><a href='#BiCopCheck'><p>Check for family/parameter consistency in bivariate copula models</p></a></li>
<li><a href='#BiCopChiPlot'><p>Chi-plot for Bivariate Copula Data</p></a></li>
<li><a href='#BiCopCompare'><p>Shiny app for bivariate copula selection</p></a></li>
<li><a href='#BiCopCondSim'><p>Conditional simulation from a Bivariate Copula</p></a></li>
<li><a href='#BiCopDeriv'><p>Derivatives of a Bivariate Copula Density</p></a></li>
<li><a href='#BiCopDeriv2'><p>Second Derivatives of a Bivariate Copula Density</p></a></li>
<li><a href='#BiCopEst'><p>Parameter Estimation for Bivariate Copula Data</p></a></li>
<li><a href='#BiCopEstList'><p>List of Maximum Likelihood Estimates for Several Bivariate Copula Families</p></a></li>
<li><a href='#BiCopGofTest'><p>Goodness-of-Fit Test for Bivariate Copulas</p></a></li>
<li><a href='#BiCopHfunc'><p>Conditional Distribution Function of a Bivariate Copula</p></a></li>
<li><a href='#BiCopHfuncDeriv'><p>Derivatives of the h-Function of a Bivariate Copula</p></a></li>
<li><a href='#BiCopHfuncDeriv2'><p>Second Derivatives of the h-Function of a Bivariate Copula</p></a></li>
<li><a href='#BiCopHinv'><p>Inverse Conditional Distribution Function of a Bivariate Copula</p></a></li>
<li><a href='#BiCopIndTest'><p>Independence Test for Bivariate Copula Data</p></a></li>
<li><a href='#BiCopKDE'><p>Kernel estimate of  a Bivariate Copula Density</p></a></li>
<li><a href='#BiCopKPlot'><p>Kendall's Plot for Bivariate Copula Data</p></a></li>
<li><a href='#BiCopLambda'><p>Lambda-Function (Plot) for Bivariate Copula Data</p></a></li>
<li><a href='#BiCopMetaContour'><p>Contour Plot of Bivariate Meta Distribution</p></a></li>
<li><a href='#BiCopName'><p>Bivariate Copula Family Names</p></a></li>
<li><a href='#BiCopPar2Beta'><p>Blomqvist's Beta Value of a Bivariate Copula</p></a></li>
<li><a href='#BiCopPar2TailDep'><p>Tail Dependence Coefficients of a Bivariate Copula</p></a></li>
<li><a href='#BiCopPar2Tau'><p>Kendall's Tau Value of a Bivariate Copula</p></a></li>
<li><a href='#BiCopPDF'><p>Density of a Bivariate Copula</p></a></li>
<li><a href='#BiCopSelect'><p>Selection and Maximum Likelihood Estimation of Bivariate Copula Families</p></a></li>
<li><a href='#BiCopSim'><p>Simulation from a Bivariate Copula</p></a></li>
<li><a href='#BiCopTau2Par'><p>Parameter of a Bivariate Copula for a given Kendall's Tau Value</p></a></li>
<li><a href='#BiCopVuongClarke'><p>Scoring Goodness-of-Fit Test based on Vuong And Clarke Tests for Bivariate</p>
Copula Data</a></li>
<li><a href='#C2RVine'><p>Transform C-Vine to R-Vine Structure</p></a></li>
<li><a href='#contour.RVineMatrix'><p>Plotting <code>RVineMatrix</code> objects.</p></a></li>
<li><a href='#D2RVine'><p>Transform D-Vine to R-Vine Structure</p></a></li>
<li><a href='#daxreturns'><p>Major German Stocks</p></a></li>
<li><a href='#EmpCDF'><p>Corrected Empirical CDF</p></a></li>
<li><a href='#pairs.copuladata'><p>Pairs Plot of Copula Data</p></a></li>
<li><a href='#plot.BiCop'><p>Plotting tools for BiCop objects</p></a></li>
<li><a href='#pobs'><p>Pseudo-Observations</p></a></li>
<li><a href='#RVineAIC'><p>AIC and BIC of an R-Vine Copula Model</p></a></li>
<li><a href='#RVineClarkeTest'><p>Clarke Test Comparing Two R-Vine Copula Models</p></a></li>
<li><a href='#RVineCopSelect'><p>Sequential Pair-Copula Selection and Estimation for R-Vine Copula Models</p></a></li>
<li><a href='#RVineCor2pcor'><p>(Partial) Correlations for R-Vine Copula Models</p></a></li>
<li><a href='#RVineGofTest'><p>Goodness-of-Fit Tests for R-Vine Copula Models</p></a></li>
<li><a href='#RVineGrad'><p>Gradient of the Log-Likelihood of an R-Vine Copula Model</p></a></li>
<li><a href='#RVineHessian'><p>Hessian Matrix of the Log-Likelihood of an R-Vine Copula Model</p></a></li>
<li><a href='#RVineLogLik'><p>Log-Likelihood of an R-Vine Copula Model</p></a></li>
<li><a href='#RVineMatrix'><p>R-Vine Copula Model in Matrix Notation</p></a></li>
<li><a href='#RVineMatrixCheck'><p>R-Vine Matrix Check</p></a></li>
<li><a href='#RVineMatrixNormalize'><p>Normalization of R-Vine Matrix</p></a></li>
<li><a href='#RVineMatrixSample'><p>Random sampling of R-Vine matrices</p></a></li>
<li><a href='#RVineMLE'><p>Maximum Likelihood Estimation of an R-Vine Copula Model</p></a></li>
<li><a href='#RVinePar2Beta'><p>Blomqvist's Beta Values of an R-Vine Copula Model</p></a></li>
<li><a href='#RVinePar2Tau'><p>Kendall's Tau Values of an R-Vine Copula Model</p></a></li>
<li><a href='#RVinePDF'><p>PDF of an R-Vine Copula Model</p></a></li>
<li><a href='#RVinePIT'><p>Probability Integral Transformation for R-Vine Copula Models</p></a></li>
<li><a href='#RVineSeqEst'><p>Sequential Estimation of an R-Vine Copula Model</p></a></li>
<li><a href='#RVineSim'><p>Simulation from an R-Vine Copula Model</p></a></li>
<li><a href='#RVineStdError'><p>Standard Errors of an R-Vine Copula Model</p></a></li>
<li><a href='#RVineStructureSelect'><p>Sequential Specification of R- and C-Vine Copula Models</p></a></li>
<li><a href='#RVineTreePlot'><p>Visualization of R-Vine Tree Structure</p></a></li>
<li><a href='#RVineVuongTest'><p>Vuong Test Comparing Two R-Vine Copula Models</p></a></li>
<li><a href='#TauMatrix'><p>Matrix of Empirical Kendall's Tau Values</p></a></li>
<li><a href='#VC2copula-deprecated'><p>Deprecated</p></a></li>
<li><a href='#VineCopula-package'><p>Statistical Inference of Vine Copulas</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Inference of Vine Copulas</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for the statistical analysis of regular vine copula 
    models, see Aas et al. (2009) &lt;<a href="https://doi.org/10.1016%2Fj.insmatheco.2007.02.001">doi:10.1016/j.insmatheco.2007.02.001</a>&gt; and 
    Dissman et al. (2013) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2012.08.010">doi:10.1016/j.csda.2012.08.010</a>&gt;.
    The package includes tools for parameter estimation, model selection,
    simulation, goodness-of-fit tests, and visualization. Tools for estimation,
    selection and exploratory data analysis of bivariate copula models are also
    provided.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils, MASS, mvtnorm, methods,
ADGofTest, lattice, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>TSP, shiny, testthat, numDeriv, kdecopula (&ge; 0.8.0), network</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tnagler/VineCopula/issues">https://github.com/tnagler/VineCopula/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tnagler/VineCopula">https://github.com/tnagler/VineCopula</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-08 21:24:37 UTC; n5</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Nagler [aut, cre],
  Ulf Schepsmeier [aut],
  Jakob Stoeber [aut],
  Eike Christian Brechmann [aut],
  Benedikt Graeler [aut],
  Tobias Erhardt [aut],
  Carlos Almeida [ctb],
  Aleksey Min [ctb, ths],
  Claudia Czado [ctb, ths],
  Mathias Hofmann [ctb],
  Matthias Killiches [ctb],
  Harry Joe [ctb],
  Thibault Vatter [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Nagler &lt;mail@tnagler.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-10 19:00:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.copuladata'>Copula Data Objects</h2><span id='topic+as.copuladata'></span><span id='topic+as.copuladata.data.frame'></span><span id='topic+as.copuladata.matrix'></span><span id='topic+as.copuladata.list'></span>

<h3>Description</h3>

<p>The function <code>as.copuladata</code> coerces an object (<code>data.frame</code>,
<code>matrix</code>, <code>list</code>) to a <code>copuladata</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.copuladata(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.copuladata_+3A_data">data</code></td>
<td>
<p>Either a <code>data.frame</code>, a <code>matrix</code> or a <code>list</code>
containing copula data (i.e. data with uniform margins on <code class="reqn">[0,1]</code>). The
<code>list</code> elements have to be vectors of identical length.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tobias Erhardt
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pobs">pobs()</a></code>, <code><a href="#topic+pairs.copuladata">pairs.copuladata()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(daxreturns)

data &lt;- as.matrix(daxreturns)
class(as.copuladata(data))

data &lt;- as.data.frame(daxreturns)
class(as.copuladata(data))

data &lt;- as.list(daxreturns)
names(data) &lt;- names(daxreturns)
class(as.copuladata(data))

</code></pre>

<hr>
<h2 id='BetaMatrix'>Matrix of Empirical Blomqvist's Beta Values</h2><span id='topic+BetaMatrix'></span>

<h3>Description</h3>

<p>This function computes the empirical Blomqvist's beta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BetaMatrix(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BetaMatrix_+3A_data">data</code></td>
<td>
<p>An N x d data matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the empirical Blomqvist's betas.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Blomqvist, N. (1950).  On a measure of dependence between two
random variables. The Annals of Mathematical Statistics, 21(4), 593-600.
</p>
<p>Nelsen, R. (2006). An introduction to copulas.  Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TauMatrix">TauMatrix()</a></code>, <code><a href="#topic+BiCopPar2Beta">BiCopPar2Beta()</a></code>,
<code><a href="#topic+RVinePar2Beta">RVinePar2Beta()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(daxreturns)
data &lt;- as.matrix(daxreturns)

# compute the empirical Blomqvist's betas
BetaMatrix(data)

</code></pre>

<hr>
<h2 id='BiCop'>Constructing BiCop-objects</h2><span id='topic+BiCop'></span>

<h3>Description</h3>

<p>This function creates an object of class <code>BiCop</code> and checks for
family/parameter consistency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCop(family, par, par2 = 0, tau = NULL, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCop_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCop_+3A_par">par</code></td>
<td>
<p>Copula parameter.</p>
</td></tr>
<tr><td><code id="BiCop_+3A_par2">par2</code></td>
<td>
<p>Second parameter for bivariate copulas with two parameters (t,
BB1, BB6, BB7, BB8, Tawn type 1 and type 2; default is <code>par2 = 0</code>).
<code>par2</code> should be an positive integer for the Students's t copula
<code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCop_+3A_tau">tau</code></td>
<td>
<p>numeric; value of Kendall's tau; has to lie in the interval
(-1, 1). Can only be used with one-parameter families and the t copula.
If <code>tau</code> is provided, <code>par</code> will be ignored.</p>
</td></tr>
<tr><td><code id="BiCop_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+BiCop">BiCop()</a></code>. It is a list containing
information about the bivariate copula. Its components are:
</p>
<table>
<tr><td><code>family</code>, <code>par</code>, <code>par2</code></td>
<td>
<p>copula family number and parameter(s),</p>
</td></tr>
<tr><td><code>npars</code></td>
<td>
<p>number of parameters,</p>
</td></tr>
<tr><td><code>familyname</code></td>
<td>
<p>name of the copula family,</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Kendall's tau,</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Blomqvist's beta,</p>
</td></tr>
<tr><td><code>taildep</code></td>
<td>
<p>lower and upper tail dependence coefficients,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call that created the object.</p>
</td></tr>
</table>
<p>Objects of this class are also returned by the <code><a href="#topic+BiCopEst">BiCopEst()</a></code> and
<code><a href="#topic+BiCopSelect">BiCopSelect()</a></code> functions. In this case, further information about
the fit is added.
</p>


<h3>Note</h3>

<p>For a comprehensive summary of the model, use <code>summary(object)</code>;
to see all its contents, use <code>str(object)</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopPDF">BiCopPDF()</a></code>,
<code><a href="#topic+BiCopHfunc">BiCopHfunc()</a></code>,
<code><a href="#topic+BiCopSim">BiCopSim()</a></code>,
<code><a href="#topic+BiCopEst">BiCopEst()</a></code>,
<code><a href="#topic+BiCopSelect">BiCopSelect()</a></code>,
<code><a href="#topic+plot.BiCop">plot.BiCop()</a></code>,
<code><a href="#topic+contour.BiCop">contour.BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create BiCop object for bivariate t-copula
obj &lt;- BiCop(family = 2, par = 0.4, par2 = 6)
obj

## see the object's content or a summary
str(obj)
summary(obj)

## a selection of functions that can be used with BiCop objects
simdata &lt;- BiCopSim(300, obj)  # simulate data
BiCopPDF(0.5, 0.5, obj) # evaluate density in (0.5,0.5)
plot(obj)  # surface plot of copula density
contour(obj)  # contour plot with standard normal margins
print(obj)  # brief overview of BiCop object
summary(obj)  # comprehensive overview of BiCop object

</code></pre>

<hr>
<h2 id='BiCopCDF'>Distribution Function of a Bivariate Copula</h2><span id='topic+BiCopCDF'></span>

<h3>Description</h3>

<p>This function evaluates the cumulative distribution function (CDF) of a
given parametric bivariate copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopCDF(u1, u2, family, par, par2 = 0, obj = NULL, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopCDF_+3A_u1">u1</code>, <code id="BiCopCDF_+3A_u2">u2</code></td>
<td>
<p>numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopCDF_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
defines the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopCDF_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopCDF_+3A_par2">par2</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
second parameter for bivariate copulas with two parameters (BB1, BB6, BB7,
BB8, Tawn type 1 and type 2; default: <code>par2 = 0</code>).</p>
</td></tr>
<tr><td><code id="BiCopCDF_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopCDF_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version <br />
</p>
<pre>BiCopCDF(u1, u2, obj)</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p>A numeric vector of the bivariate copula distribution function
</p>

<ul>
<li><p> of the copula <code>family</code>
</p>
</li>
<li><p> with parameter(s) <code>par</code>, <code>par2</code>
</p>
</li>
<li><p> evaluated at <code>u1</code> and <code>u2</code>.
</p>
</li></ul>



<h3>Note</h3>

<p>The calculation of the cumulative distribution function (CDF) of the
Student's t copula (<code>family = 2</code>) is only approximate. For numerical
reasons, the degree of freedom parameter (<code>par2</code>) is rounded to an
integer before calculation of the CDF.
</p>


<h3>Author(s)</h3>

<p>Eike Brechmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopPDF">BiCopPDF()</a></code>,
<code><a href="#topic+BiCopHfunc">BiCopHfunc()</a></code>,
<code><a href="#topic+BiCopSim">BiCopSim()</a></code>,
<code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate from a bivariate Clayton copula
set.seed(123)
cop &lt;- BiCop(family = 3, par = 3.4)
simdata &lt;- BiCopSim(300, cop)

## evaluate the distribution function of the bivariate Clayton copula
u1 &lt;- simdata[,1]
u2 &lt;- simdata[,2]
BiCopCDF(u1, u2, cop)

## select a bivariate copula for the simulated data
cop &lt;- BiCopSelect(u1, u2)
summary(cop)
## and evaluate its CDF
BiCopCDF(u1, u2, cop)

</code></pre>

<hr>
<h2 id='BiCopCheck'>Check for family/parameter consistency in bivariate copula models</h2><span id='topic+BiCopCheck'></span>

<h3>Description</h3>

<p>The function checks if a certain combination of copula family and parameters
can be used within other functions of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopCheck(family, par, par2 = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopCheck_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopCheck_+3A_par">par</code></td>
<td>
<p>Copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopCheck_+3A_par2">par2</code></td>
<td>
<p>Second parameter for bivariate copulas with two parameters (t,
BB1, BB6, BB7, BB8, Tawn type 1 and type 2; default is <code>par2 = 0</code>).</p>
</td></tr>
<tr><td><code id="BiCopCheck_+3A_...">...</code></td>
<td>
<p>used internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether the family can be used with the parameter
specification.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## check parameter of Clayton copula
BiCopCheck(3, 1)  # works

## Not run: BiCopCheck(3, -1)  # does not work (only positive parameter is allowed)

</code></pre>

<hr>
<h2 id='BiCopChiPlot'>Chi-plot for Bivariate Copula Data</h2><span id='topic+BiCopChiPlot'></span>

<h3>Description</h3>

<p>This function creates a chi-plot of given bivariate copula data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopChiPlot(u1, u2, PLOT = TRUE, mode = "NULL", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopChiPlot_+3A_u1">u1</code>, <code id="BiCopChiPlot_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopChiPlot_+3A_plot">PLOT</code></td>
<td>
<p>Logical; whether the results are plotted. If <code>PLOT = FALSE</code>, the values <code>lambda</code>, <code>chi</code> and <code>control.bounds</code> are
returned (see below; default: <code>PLOT = TRUE</code>).</p>
</td></tr>
<tr><td><code id="BiCopChiPlot_+3A_mode">mode</code></td>
<td>
<p>Character; whether a general, lower or upper chi-plot is
calculated.  Possible values are <code>mode = "NULL"</code>, <code>"upper"</code> and
<code>"lower"</code>. <br /> <code>"NULL"</code> = general chi-plot (default)<br />
<code>"upper"</code> = upper chi-plot<br /> <code>"lower"</code> = lower chi-plot</p>
</td></tr>
<tr><td><code id="BiCopChiPlot_+3A_...">...</code></td>
<td>
<p>Additional plot arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For observations <code class="reqn">u_{i,j},\ i=1,...,N,\ j=1,2,</code> the chi-plot is based on the following two quantities: the
chi-statistics
</p>
<p style="text-align: center;"><code class="reqn">\chi_i = \frac{\hat{F}_{1,2}(u_{i,1},u_{i,2})
- \hat{F}_{1}(u_{i,1})\hat{F}_{2}(u_{i,2})}{
\sqrt{\hat{F}_{1}(u_{i,1})(1-\hat{F}_{1}(u_{i,1}))
\hat{F}_{2}(u_{i,2})(1-\hat{F}_{2}(u_{i,2}))}}, </code>
</p>

<p>and the lambda-statistics
</p>
<p style="text-align: center;"><code class="reqn">\lambda_i = 4 sgn\left( \tilde{F}_{1}(u_{i,1}),\tilde{F}_{2}(u_{i,2}) \right)
\cdot \max\left( \tilde{F}_{1}(u_{i,1})^2,\tilde{F}_{2}(u_{i,2})^2 \right), </code>
</p>

<p>where <code class="reqn">\hat{F}_{1}</code>, <code class="reqn">\hat{F}_{2}</code> and
<code class="reqn">\hat{F}_{1,2}</code> are the empirical distribution functions
of the uniform random variables <code class="reqn">U_1</code> and <code class="reqn">U_2</code> and of
<code class="reqn">(U_1,U_2)</code>, respectively. Further,
<code class="reqn">\tilde{F}_{1}=\hat{F}_{1}-0.5</code> and
<code class="reqn">\tilde{F}_{2}=\hat{F}_{2}-0.5</code>.
</p>
<p>These quantities only depend on the ranks of the data and are scaled to the
interval <code class="reqn">[0,1]</code>. <code class="reqn">\lambda_i</code> measures a distance of a data point
<code class="reqn">\left(u_{i,1},u_{i,2}\right)</code> to the center of the
bivariate data set, while <code class="reqn">\chi_i</code> corresponds to a correlation
coefficient between dichotomized values of <code class="reqn">U_1</code> and <code class="reqn">U_2</code>. Under
independence it holds that <code class="reqn">\chi_i \sim
\mathcal{N}(0,\frac{1}{N})</code> and <code class="reqn">\lambda_i \sim
\mathcal{U}[-1,1]</code> asymptotically, i.e., values of
<code class="reqn">\chi_i</code> close to zero indicate independence&mdash;corresponding to
<code class="reqn">F_{1, 2}=F_{1}F_{2}</code>.
</p>
<p>When plotting these quantities, the pairs of <code class="reqn">\left(\lambda_i, \chi_i
\right)</code> will tend to be located above zero for
positively dependent margins and vice versa for negatively dependent
margins. Control bounds around zero indicate whether there is significant
dependence present.
</p>
<p>If <code>mode = "lower"</code> or <code>"upper"</code>, the above quantities are
calculated only for those <code class="reqn">u_{i,1}</code>'s and <code class="reqn">u_{i,2}</code>'s which are
smaller/larger than the respective means of
<code>u1</code><code class="reqn">=(u_{1,1},...,u_{N,1})</code> and
<code>u2</code><code class="reqn">=(u_{1,2},...,u_{N,2})</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>lambda</code></td>
<td>
<p>Lambda-statistics (x-axis).</p>
</td></tr> <tr><td><code>chi</code></td>
<td>
<p>Chi-statistics
(y-axis).</p>
</td></tr> <tr><td><code>control.bounds</code></td>
<td>
<p>A 2-dimensional vector of bounds
<code class="reqn">((1.54/\sqrt{n},-1.54/\sqrt{n})</code>, where <code class="reqn">n</code> is the length of
<code>u1</code> and where the chosen values correspond to an approximate
significance level of <code class="reqn">10\%</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalia Belgorodski, Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Abberger, K. (2004). A simple graphical method to explore
tail-dependence in stock-return pairs. Discussion Paper, University of
Konstanz, Germany.
</p>
<p>Genest, C. and A. C. Favre (2007). Everything you always wanted to know
about copula modeling but were afraid to ask. Journal of Hydrologic
Engineering, 12 (4), 347-368.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopMetaContour">BiCopMetaContour()</a></code>, <code><a href="#topic+BiCopKPlot">BiCopKPlot()</a></code>,
<code><a href="#topic+BiCopLambda">BiCopLambda()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## chi-plots for bivariate Gaussian copula data

# simulate copula data
fam &lt;- 1
tau &lt;- 0.5
par &lt;- BiCopTau2Par(fam, tau)
cop &lt;- BiCop(fam, par)
set.seed(123)
dat &lt;- BiCopSim(500, cop)

# create chi-plots
op &lt;- par(mfrow = c(1, 3))
BiCopChiPlot(dat[,1], dat[,2], xlim = c(-1,1), ylim = c(-1,1),
             main="General chi-plot")
BiCopChiPlot(dat[,1], dat[,2], mode = "lower", xlim = c(-1,1),
             ylim = c(-1,1), main = "Lower chi-plot")
BiCopChiPlot(dat[,1], dat[,2], mode = "upper", xlim = c(-1,1),
             ylim = c(-1,1), main = "Upper chi-plot")
par(op)

</code></pre>

<hr>
<h2 id='BiCopCompare'>Shiny app for bivariate copula selection</h2><span id='topic+BiCopCompare'></span>

<h3>Description</h3>

<p>The function starts a shiny app which visualizes copula data and allows to
compare it with overlays of density contours or simulated data from different
copula families with fitted parameters. Several specifications for the
margins are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopCompare(u1, u2, familyset = NA, rotations = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopCompare_+3A_u1">u1</code>, <code id="BiCopCompare_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopCompare_+3A_familyset">familyset</code></td>
<td>
<p>Vector of bivariate copula families to select from.
The vector has to include at least one bivariate copula
family that allows for positive and one that allows for negative dependence.
If <code>familyset = NA</code> (default), selection among all possible families is
performed. If a vector of negative numbers is provided, selection among all
but <code>abs(familyset)</code> families is performed. Coding of bivariate copula
families: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopCompare_+3A_rotations">rotations</code></td>
<td>
<p>If <code>TRUE</code>, all rotations of the families in
<code>familyset</code> are included (or subtracted).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+BiCop">BiCop()</a></code> object containing the model selected by the
user.
</p>


<h3>Author(s)</h3>

<p>Matthias Killiches, Thomas Nagler
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data
data(daxreturns)

# find a suitable copula family for the first two stocks
## Not run: fit &lt;- BiCopCompare(daxreturns[, 1], daxreturns[, 2])

</code></pre>

<hr>
<h2 id='BiCopCondSim'>Conditional simulation from a Bivariate Copula</h2><span id='topic+BiCopCondSim'></span>

<h3>Description</h3>

<p>This function simulates from a parametric bivariate copula, where on of
the variables is fixed. I.e., we simulate either from
<code class="reqn">C_{2|1}(u_2|u_1;\theta)</code> or <code class="reqn">C_{1|2}(u_1|u_2;\theta)</code>, which are both
conditional distribution functions of one variable given another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopCondSim(
  N,
  cond.val,
  cond.var,
  family,
  par,
  par2 = 0,
  obj = NULL,
  check.pars = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopCondSim_+3A_n">N</code></td>
<td>
<p>Number of observations simulated.</p>
</td></tr>
<tr><td><code id="BiCopCondSim_+3A_cond.val">cond.val</code></td>
<td>
<p>numeric vector of length <code>N</code> containing the values to
condition on.</p>
</td></tr>
<tr><td><code id="BiCopCondSim_+3A_cond.var">cond.var</code></td>
<td>
<p>either <code>1</code> or <code>2</code>; the variable to condition on.</p>
</td></tr>
<tr><td><code id="BiCopCondSim_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>N</code>; defines the
bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopCondSim_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>N</code>; copula
parameter.</p>
</td></tr>
<tr><td><code id="BiCopCondSim_+3A_par2">par2</code></td>
<td>
<p>numeric; single number or vector of size <code>N</code>; second
parameter for bivariate copulas with two parameters (t, BB1, BB6, BB7, BB8,
Tawn type 1 and type 2; default: <code>par2 = 0</code>). <code>par2</code> should be a
positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopCondSim_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopCondSim_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version
</p>
<pre>BiCopCondSim(N, cond.val, cond.var, obj)</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p>A length <code>N</code> vector of simulated from conditional distributions
related to bivariate copula with <code>family</code> and parameter(s) <code>par</code>,
<code>par2</code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopCDF">BiCopCDF()</a></code>, <code><a href="#topic+BiCopPDF">BiCopPDF()</a></code>,
<code><a href="#topic+RVineSim">RVineSim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create bivariate t-copula
obj &lt;- BiCop(family = 2, par = -0.7, par2 = 4)

# simulate 500 observations of (U1, U2)
sim &lt;- BiCopSim(500, obj)
hist(sim[, 1])  # data have uniform distribution
hist(sim[, 2])  # data have uniform distribution

# simulate 500 observations of (U2 | U1 = 0.7)
sim1 &lt;- BiCopCondSim(500, cond.val = 0.7, cond.var = 1, obj)
hist(sim1)  # not uniform!

# simulate 500 observations of (U1 | U2 = 0.1)
sim2 &lt;- BiCopCondSim(500, cond.val = 0.1, cond.var = 2, obj)
hist(sim2)  # not uniform!

</code></pre>

<hr>
<h2 id='BiCopDeriv'>Derivatives of a Bivariate Copula Density</h2><span id='topic+BiCopDeriv'></span>

<h3>Description</h3>

<p>This function evaluates the derivative of a given parametric bivariate
copula density with respect to its parameter(s) or one of its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopDeriv(
  u1,
  u2,
  family,
  par,
  par2 = 0,
  deriv = "par",
  log = FALSE,
  obj = NULL,
  check.pars = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopDeriv_+3A_u1">u1</code>, <code id="BiCopDeriv_+3A_u2">u2</code></td>
<td>
<p>numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopDeriv_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
defines the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; &ldquo;survival Joe&rdquo;) <br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopDeriv_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopDeriv_+3A_par2">par2</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
second parameter for the t-Copula; default is <code>par2 = 0</code>, should be an
positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopDeriv_+3A_deriv">deriv</code></td>
<td>
<p>Derivative argument <br />
<code>"par"</code> = derivative with respect to the first parameter (default)<br />
<code>"par2"</code> = derivative with respect to the second parameter
(only available for the t-copula) <br />
<code>"u1"</code> = derivative with respect to the first argument <code>u1</code> <br />
<code>"u2"</code> = derivative with respect to the second argument <code>u2</code> <br /></p>
</td></tr>
<tr><td><code id="BiCopDeriv_+3A_log">log</code></td>
<td>
<p>Logical; if <code>TRUE</code> than the derivative of the log-likelihood
is returned (default: <code>log = FALSE</code>; only available for the derivatives
with respect to the parameter(s) (<code>deriv = "par"</code> or <code>deriv = "par2"</code>)).</p>
</td></tr>
<tr><td><code id="BiCopDeriv_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopDeriv_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version <br />
</p>
<pre>BiCopDeriv(u1, u2, obj, deriv = "par", log = FALSE)</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p>A numeric vector of the bivariate copula derivative
</p>

<ul>
<li><p> of the copula <code>family</code>
</p>
</li>
<li><p> with parameter(s) <code>par</code>, <code>par2</code>
</p>
</li>
<li><p> with respect to <code>deriv</code>,
</p>
</li>
<li><p> evaluated at <code>u1</code> and <code>u2</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Schepsmeier, U. and J. Stoeber (2014). Derivatives and Fisher
information of bivariate copulas. Statistical Papers, 55 (2), 525-542. <br />
<a href="https://link.springer.com/article/10.1007/s00362-013-0498-x">https://link.springer.com/article/10.1007/s00362-013-0498-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineGrad">RVineGrad()</a></code>, <code><a href="#topic+RVineHessian">RVineHessian()</a></code>,
<code><a href="#topic+BiCopDeriv2">BiCopDeriv2()</a></code>, <code><a href="#topic+BiCopHfuncDeriv">BiCopHfuncDeriv()</a></code>,
<code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simulate from a bivariate Student-t copula
set.seed(123)
cop &lt;- BiCop(family = 2, par = -0.7, par2 = 4)
simdata &lt;- BiCopSim(100, cop)

## derivative of the bivariate t-copula with respect to the first parameter
u1 &lt;- simdata[,1]
u2 &lt;- simdata[,2]
BiCopDeriv(u1, u2, cop, deriv = "par")

## estimate a Student-t copula for the simulated data
cop &lt;- BiCopEst(u1, u2, family = 2)
## and evaluate its derivative w.r.t. the second argument u2
BiCopDeriv(u1, u2, cop, deriv = "u2")

</code></pre>

<hr>
<h2 id='BiCopDeriv2'>Second Derivatives of a Bivariate Copula Density</h2><span id='topic+BiCopDeriv2'></span>

<h3>Description</h3>

<p>This function evaluates the second derivative of a given parametric
bivariate copula density with respect to its parameter(s) and/or its
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopDeriv2(
  u1,
  u2,
  family,
  par,
  par2 = 0,
  deriv = "par",
  obj = NULL,
  check.pars = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopDeriv2_+3A_u1">u1</code>, <code id="BiCopDeriv2_+3A_u2">u2</code></td>
<td>
<p>numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopDeriv2_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
defines the bivariate copula family:  <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; &ldquo;survival Joe&rdquo;) <br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopDeriv2_+3A_par">par</code></td>
<td>
<p>Copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopDeriv2_+3A_par2">par2</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
second parameter for the t-Copula; default is <code>par2 = 0</code>, should be an
positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopDeriv2_+3A_deriv">deriv</code></td>
<td>
<p>Derivative argument <br />
<code>"par"</code> = second derivative with respect to
the first parameter (default)<br />
<code>"par2"</code> = second derivative with respect to
the second parameter (only available for the t-copula) <br />
<code>"u1"</code> = second derivative with respect to
the first argument <code>u1</code> <br />
<code>"u2"</code> = second derivative with respect to
the second argument <code>u2</code> <br />
<code>"par1par2"</code> = second derivative with respect to
the first and second parameter (only available for the t-copula)
<br /> <code>"par1u1"</code> = second derivative with respect to
the first parameter and the first argument <br />
<code>"par2u1"</code> = second derivative with respect to the
second parameter and the first argument (only available for the t-copula) <br />
<code>"par1u2"</code> = second derivative with respect to
the first parameter and the second argument <br />
<code>"par2u2"</code> = second derivative with respect to
the second parameter and the second argument
(only available for the t-copula) <br /></p>
</td></tr>
<tr><td><code id="BiCopDeriv2_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopDeriv2_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version <br />
</p>
<pre>BiCopDeriv2(u1, u2, obj, deriv = "par")</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p>A numeric vector of the second-order bivariate copula derivative
</p>

<ul>
<li><p> of the copula <code>family</code>
</p>
</li>
<li><p> with parameter(s) <code>par</code>, <code>par2</code>
</p>
</li>
<li><p> with respect to <code>deriv</code>
</p>
</li>
<li><p> evaluated at <code>u1</code> and <code>u2</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Jakob Stoeber
</p>


<h3>References</h3>

<p>Schepsmeier, U. and J. Stoeber (2014). Derivatives and Fisher
information of bivariate copulas. Statistical Papers, 55 (2), 525-542. <br />
<a href="https://link.springer.com/article/10.1007/s00362-013-0498-x">https://link.springer.com/article/10.1007/s00362-013-0498-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineGrad">RVineGrad()</a></code>, <code><a href="#topic+RVineHessian">RVineHessian()</a></code>,
<code><a href="#topic+BiCopDeriv">BiCopDeriv()</a></code>, <code><a href="#topic+BiCopHfuncDeriv">BiCopHfuncDeriv()</a></code>, <code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simulate from a bivariate Student-t copula
set.seed(123)
cop &lt;- BiCop(family = 2, par = -0.7, par2 = 4)
simdata &lt;- BiCopSim(100, cop)

## second derivative of the Student-t copula w.r.t. the first parameter
u1 &lt;- simdata[,1]
u2 &lt;- simdata[,2]
BiCopDeriv2(u1, u2, cop, deriv = "par")

## estimate a Student-t copula for the simulated data
cop &lt;- BiCopEst(u1, u2, family = 2)
## and evaluate its second derivative w.r.t. the second argument u2
BiCopDeriv2(u1, u2, cop, deriv = "u2")

</code></pre>

<hr>
<h2 id='BiCopEst'>Parameter Estimation for Bivariate Copula Data</h2><span id='topic+BiCopEst'></span>

<h3>Description</h3>

<p>This function estimates the parameter(s) of a bivariate copula using either
inversion of empirical Kendall's tau (for one parameter copula families only) or
maximum likelihood estimation for implemented copula families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopEst(
  u1,
  u2,
  family,
  method = "mle",
  se = FALSE,
  max.df = 30,
  max.BB = list(BB1 = c(5, 6), BB6 = c(6, 6), BB7 = c(5, 6), BB8 = c(6, 1)),
  weights = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopEst_+3A_u1">u1</code>, <code id="BiCopEst_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopEst_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopEst_+3A_method">method</code></td>
<td>
<p>indicates the estimation method: either maximum
likelihood estimation (<code>method = "mle"</code>; default) or inversion of
Kendall's tau (<code>method = "itau"</code>). For <code>method = "itau"</code> only
one parameter families and the Student t copula can be used (<code style="white-space: pre;">&#8288;family = 1,2,3,4,5,6,13,14,16,23,24,26,33,34&#8288;</code> or <code>36</code>). For the t-copula,
<code>par2</code> is found by a crude profile likelihood optimization over the
interval (2, 10].</p>
</td></tr>
<tr><td><code id="BiCopEst_+3A_se">se</code></td>
<td>
<p>Logical; whether standard error(s) of parameter estimates is/are
estimated (default: <code>se = FALSE</code>).</p>
</td></tr>
<tr><td><code id="BiCopEst_+3A_max.df">max.df</code></td>
<td>
<p>Numeric; upper bound for the estimation of the degrees of
freedom parameter of the t-copula (default: <code>max.df = 30</code>).</p>
</td></tr>
<tr><td><code id="BiCopEst_+3A_max.bb">max.BB</code></td>
<td>
<p>List; upper bounds for the estimation of the two parameters
(in absolute values) of the BB1, BB6, BB7 and BB8 copulas <br /> (default:
<code>max.BB = list(BB1=c(5,6),BB6=c(6,6),BB7=c(5,6),BB8=c(6,1))</code>).</p>
</td></tr>
<tr><td><code id="BiCopEst_+3A_weights">weights</code></td>
<td>
<p>Numerical; weights for each observation (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method = "itau"</code>, the function computes the empirical Kendall's tau
of the given copula data and exploits the one-to-one relationship of copula
parameter and Kendall's tau which is available for many one parameter
bivariate copula families (see <code><a href="#topic+BiCopPar2Tau">BiCopPar2Tau()</a></code> and
<code><a href="#topic+BiCopTau2Par">BiCopTau2Par()</a></code>). The inversion of Kendall's tau is however not
available for all bivariate copula families (see above). If a two parameter
copula family is chosen and <code>method = "itau"</code>, a warning message is
returned and the MLE is calculated.
</p>
<p>For <code>method = "mle"</code> copula parameters are estimated by maximum
likelihood using starting values obtained by <code>method = "itau"</code>.  If no
starting values are available by inversion of Kendall's tau, starting values
have to be provided given expert knowledge and the boundaries <code>max.df</code>
and <code>max.BB</code> respectively. Note: The MLE is performed via numerical
maximization using the L_BFGS-B method. For the Gaussian, the t- and the
one-parametric Archimedean copulas we can use the gradients, but for the BB
copulas we have to use finite differences for the L_BFGS-B method.
</p>
<p>A warning message is returned if the estimate of the degrees of freedom
parameter of the t-copula is larger than <code>max.df</code>. For high degrees of
freedom the t-copula is almost indistinguishable from the Gaussian and it is
advised to use the Gaussian copula in this case. As a rule of thumb
<code>max.df = 30</code> typically is a good choice. Moreover, standard errors of
the degrees of freedom parameter estimate cannot be estimated in this case.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+BiCop">BiCop()</a></code>, augmented with the following
entries:
</p>
<table>
<tr><td><code>se</code>, <code>se2</code></td>
<td>
<p>standard errors for the parameter estimates (if
<code>se = TRUE</code>,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>log likelihood</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Aikaike's Informaton Criterion,</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian's Informaton Criterion,</p>
</td></tr>
<tr><td><code>emptau</code></td>
<td>
<p>empirical value of Kendall's tau,</p>
</td></tr>
<tr><td><code>p.value.indeptest</code></td>
<td>
<p>p-value of the independence test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a comprehensive summary of the fitted model, use <code>summary(object)</code>;
to see all its contents, use <code>str(object)</code>.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Eike Brechmann, Jakob Stoeber, Carlos Almeida
</p>


<h3>References</h3>

<p>Joe, H. (1997). Multivariate Models and Dependence Concepts.
Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCop">BiCop()</a></code>,
<code><a href="#topic+BiCopPar2Tau">BiCopPar2Tau()</a></code>,
<code><a href="#topic+BiCopTau2Par">BiCopTau2Par()</a></code>,
<code><a href="#topic+RVineSeqEst">RVineSeqEst()</a></code>,
<code><a href="#topic+BiCopSelect">BiCopSelect()</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1: bivariate Gaussian copula
dat &lt;- BiCopSim(500, 1, 0.7)
u1 &lt;- dat[, 1]
v1 &lt;- dat[, 2]

# estimate parameters of Gaussian copula by inversion of Kendall's tau
est1.tau &lt;- BiCopEst(u1, v1, family = 1, method = "itau")
est1.tau  # short overview
summary(est1.tau)  # comprehensive overview
str(est1.tau)  # see all contents of the object

# check if parameter actually coincides with inversion of Kendall's tau
tau1 &lt;- cor(u1, v1, method = "kendall")
all.equal(BiCopTau2Par(1, tau1), est1.tau$par)

# maximum likelihood estimate for comparison
est1.mle &lt;- BiCopEst(u1, v1, family = 1, method = "mle")
summary(est1.mle)


## Example 2: bivariate Clayton and survival Gumbel copulas
# simulate from a Clayton copula
dat &lt;- BiCopSim(500, 3, 2.5)
u2 &lt;- dat[, 1]
v2 &lt;- dat[, 2]

# empirical Kendall's tau
tau2 &lt;- cor(u2, v2, method = "kendall")

# inversion of empirical Kendall's tau for the Clayton copula
BiCopTau2Par(3, tau2)
BiCopEst(u2, v2, family = 3, method = "itau")

# inversion of empirical Kendall's tau for the survival Gumbel copula
BiCopTau2Par(14, tau2)
BiCopEst(u2, v2, family = 14, method = "itau")

# maximum likelihood estimates for comparison
BiCopEst(u2, v2, family = 3, method = "mle")
BiCopEst(u2, v2, family = 14, method = "mle")


</code></pre>

<hr>
<h2 id='BiCopEstList'>List of Maximum Likelihood Estimates for Several Bivariate Copula Families</h2><span id='topic+BiCopEstList'></span>

<h3>Description</h3>

<p>This function allows to compare bivariate copula models across a number of
families w.r.t. the fit statistics log-likelihood, AIC, and BIC. For each
family, the parameters are estimated by maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopEstList(u1, u2, familyset = NA, weights = NA, rotations = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopEstList_+3A_u1">u1</code>, <code id="BiCopEstList_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopEstList_+3A_familyset">familyset</code></td>
<td>
<p>Vector of bivariate copula families to select from.
The vector has to include at least one bivariate copula
family that allows for positive and one that allows for negative dependence.
If <code>familyset = NA</code> (default), selection among all possible families is
performed.  Coding of bivariate copula families: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopEstList_+3A_weights">weights</code></td>
<td>
<p>Numerical; weights for each observation (optional).</p>
</td></tr>
<tr><td><code id="BiCopEstList_+3A_rotations">rotations</code></td>
<td>
<p>If <code>TRUE</code>, all rotations of the families in
<code>familyset</code> are included.</p>
</td></tr>
<tr><td><code id="BiCopEstList_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+BiCopEst">BiCopEst()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First all available copulas are fitted using maximum likelihood estimation.
Then the criteria are computed for all available copula families (e.g., if
<code>u1</code> and <code>u2</code> are negatively
dependent, Clayton, Gumbel, Joe, BB1, BB6, BB7 and BB8 and their survival
copulas are not considered) and the family with the minimum value is chosen.
For observations <code class="reqn">u_{i,j},\ i=1,...,N,\ j=1,2,</code> the AIC of a bivariate copula family <code class="reqn">c</code> with parameter(s)
<code class="reqn">\boldsymbol{\theta}</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">AIC := -2 \sum_{i=1}^N
\ln[c(u_{i,1},u_{i,2}|\boldsymbol{\theta})] + 2k, </code>
</p>
<p> where <code class="reqn">k=1</code> for one parameter
copulas and <code class="reqn">k=2</code> for the two parameter t-, BB1, BB6, BB7 and BB8
copulas. Similarly, the BIC is given by </p>
<p style="text-align: center;"><code class="reqn">BIC := -2 \sum_{i=1}^N
\ln[c(u_{i,1},u_{i,2}|\boldsymbol{\theta})] + \ln(N)k. </code>
</p>
<p> Evidently, if the BIC
is chosen, the penalty for two parameter families is stronger than when
using the AIC.
</p>


<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>models</code></td>
<td>
<p>a list of <code><a href="#topic+BiCop">BiCop()</a></code> objects corresponding to the
'familyset&ldquo; (only families corresponding to the sign of the empirical
Kendall's tau are used),</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>a data frame containing the log-likelihoods, AICs, and BICs
of all the fitted models.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>References</h3>

<p>Akaike, H. (1973). Information theory and an extension of the
maximum likelihood principle. In B. N. Petrov and F. Csaki (Eds.),
Proceedings of the Second International Symposium on Information Theory
Budapest, Akademiai Kiado, pp. 267-281.
</p>
<p>Schwarz, G. E. (1978). Estimating the dimension of a model. Annals of
Statistics 6 (2), 461-464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCop">BiCop()</a></code>,
<code><a href="#topic+BiCopEst">BiCopEst()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## compare models
data(daxreturns)
comp &lt;- BiCopEstList(daxreturns[, 1], daxreturns[, 4])

</code></pre>

<hr>
<h2 id='BiCopGofTest'>Goodness-of-Fit Test for Bivariate Copulas</h2><span id='topic+BiCopGofTest'></span>

<h3>Description</h3>

<p>This function performs a goodness-of-fit test for bivariate copulas, either
based on White's information matrix equality (White, 1982) as introduced by
Huang and Prokhorov (2011) or based on Kendall's process
(Wang and Wells, 2000; Genest et al., 2006). It computes the test statistics
and p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopGofTest(
  u1,
  u2,
  family,
  par = 0,
  par2 = 0,
  method = "white",
  max.df = 30,
  B = 100,
  obj = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopGofTest_+3A_u1">u1</code>, <code id="BiCopGofTest_+3A_u2">u2</code></td>
<td>
<p>Numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopGofTest_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) (only for <code>method = "white"</code>; see details)<br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula (only for <code>method = "kendall"</code>)<br />
<code>8</code> = BB6 copula (only for <code>method = "kendall"</code>)<br />
<code>9</code> = BB7 copula (only for <code>method = "kendall"</code>)<br />
<code>10</code> = BB8 copula (only for <code>method ="kendall"</code>)<br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;;
only for <code>method = "kendall"</code>)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6''; only for `method = "kendall"`)\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;;
only for <code>method = "kendall"</code>)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;;
only for <code>method = "kendall"</code>)<br />
'23' = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees; only for 'method = &quot;kendall&quot;') <br />
'28' = rotated BB6 copula (90 degrees; only for 'method = &quot;kendall&quot;') <br />
'29' = rotated BB7 copula (90 degrees; only for 'method = &quot;kendall&quot;') <br />
'30' = rotated BB8 copula (90 degrees; only for 'method = &quot;kendall&quot;') <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees; only for 'method = &quot;kendall&quot;') <br />
'38' = rotated BB6 copula (270 degrees; only for 'method = &quot;kendall&quot;') <br />
'39' = rotated BB7 copula (270 degrees; only for 'method = &quot;kendall&quot;') <br />
'40' = rotated BB8 copula (270 degrees; only for 'method = &quot;kendall&quot;')</p>
</td></tr>
<tr><td><code id="BiCopGofTest_+3A_par">par</code></td>
<td>
<p>Copula parameter (optional).</p>
</td></tr>
<tr><td><code id="BiCopGofTest_+3A_par2">par2</code></td>
<td>
<p>Second parameter for bivariate t-copula (optional); default:
<code>par2 = 0</code>.</p>
</td></tr>
<tr><td><code id="BiCopGofTest_+3A_method">method</code></td>
<td>
<p>A string indicating the goodness-of-fit method:<br />
<code>"white"</code> = goodness-of-fit test based on White's information matrix
equality (default) <br />
<code>"kendall"</code> = goodness-of-fit test based on Kendall's process</p>
</td></tr>
<tr><td><code id="BiCopGofTest_+3A_max.df">max.df</code></td>
<td>
<p>Numeric; upper bound for the estimation of the degrees of
freedom parameter of the t-copula (default: <code>max.df = 30</code>).</p>
</td></tr>
<tr><td><code id="BiCopGofTest_+3A_b">B</code></td>
<td>
<p>Integer; number of bootstrap samples (default: <code>B = 100</code>).
For <code>B = 0</code> only the the test statistics are returned.<br /> WARNING: If
<code>B</code> is chosen too large, computations will take very long.</p>
</td></tr>
<tr><td><code id="BiCopGofTest_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method = "white"</code>:<br /> This goodness-of fit test uses the information
matrix equality of White (1982) and was investigated by Huang and Prokhorov
(2011). The main contribution is that under correct model specification the
Fisher Information can be equivalently calculated as minus the expected
Hessian matrix or as the expected outer product of the score function. The
null hypothesis is </p>
<p style="text-align: center;"><code class="reqn"> H_0: \boldsymbol{H}(\theta) +
\boldsymbol{C}(\theta) = 0 </code>
</p>
<p> against the alternative </p>
<p style="text-align: center;"><code class="reqn"> H_0:
\boldsymbol{H}(\theta) + \boldsymbol{C}(\theta) \neq 0 , </code>
</p>
<p> where
<code class="reqn">\boldsymbol{H}(\theta)</code> is the expected Hessian matrix and
<code class="reqn">\boldsymbol{C}(\theta)</code> is the expected outer product of the score
function. For the calculation of the test statistic we use the consistent
maximum likelihood estimator <code class="reqn">\hat{\theta}</code> and the sample counter parts
of <code class="reqn">\boldsymbol{H}(\theta)</code> and <code class="reqn">\boldsymbol{C}(\theta)</code>. The
correction of the covariance-matrix in the test statistic for the
uncertainty in the margins is skipped. The implemented tests assumes that
where is no uncertainty in the margins. The correction can be found in Huang
and Prokhorov (2011). It involves two-dimensional integrals.<br /> WARNING: For
the t-copula the test may be unstable. The results for the t-copula
therefore have to be treated carefully.<br /> <br /> <code>method = "kendall"</code>:<br />
This copula goodness-of-fit test is based on Kendall's process as
proposed by Wang and Wells (2000). For computation of p-values, the
parametric bootstrap described by Genest et al. (2006) is used. For
rotated copulas the input arguments are transformed and the goodness-of-fit
procedure for the corresponding non-rotated copula is used.
</p>


<h3>Value</h3>

<p>For <code>method = "white"</code>: </p>
<table>
<tr><td><code>p.value</code></td>
<td>
<p>Asymptotic p-value.</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>The observed test statistic.</p>
</td></tr></table>
<p><br />
For <code>method ="kendall"</code>
</p>
<table>
<tr><td><code>p.value.CvM</code></td>
<td>
<p>Bootstrapped p-value of the goodness-of-fit
test using the Cramer-von Mises statistic (if <code>B &gt; 0</code>).</p>
</td></tr>
<tr><td><code>p.value.KS</code></td>
<td>
<p>Bootstrapped p-value of the goodness-of-fit test using the
Kolmogorov-Smirnov statistic (if <code>B &gt; 0</code>).</p>
</td></tr> <tr><td><code>statistic.CvM</code></td>
<td>
<p>The
observed Cramer-von Mises test statistic.</p>
</td></tr> <tr><td><code>statistic.KS</code></td>
<td>
<p>The observed
Kolmogorov-Smirnov test statistic.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Wanling Huang, Jiying Luo, Eike Brechmann
</p>


<h3>References</h3>

<p>Huang, W. and A. Prokhorov (2014). A goodness-of-fit test for copulas.
Econometric Reviews, 33 (7), 751-771.
</p>
<p>Wang, W. and M. T. Wells (2000). Model selection and semiparametric
inference for bivariate failure-time data. Journal of the American
Statistical Association, 95 (449), 62-72.
</p>
<p>Genest, C., Quessy, J. F., and Remillard, B. (2006). Goodness-of-fit
Procedures for Copula Models Based on the Probability Integral Transformation.
Scandinavian Journal of Statistics, 33(2), 337-366.
Luo J. (2011). Stepwise estimation of D-vines with arbitrary specified
copula pairs and EDA tools. Diploma thesis, Technische Universitaet
Muenchen.<br /> <a href="https://mediatum.ub.tum.de/?id=1079291">https://mediatum.ub.tum.de/?id=1079291</a>.
</p>
<p>White, H. (1982) Maximum likelihood estimation of misspecified models,
Econometrica, 50, 1-26.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopDeriv2">BiCopDeriv2()</a></code>, <code><a href="#topic+BiCopDeriv">BiCopDeriv()</a></code>,
<code><a href="#topic+BiCopIndTest">BiCopIndTest()</a></code>, <code><a href="#topic+BiCopVuongClarke">BiCopVuongClarke()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate from a bivariate Clayton copula

simdata &lt;- BiCopSim(100, 3, 2)
u1 &lt;- simdata[,1]
u2 &lt;- simdata[,2]

# perform White's goodness-of-fit test for the true copula
BiCopGofTest(u1, u2, family = 3)

# perform White's goodness-of-fit test for the Frank copula
BiCopGofTest(u1, u2, family = 5)

# perform Kendall's goodness-of-fit test for the true copula
BiCopGofTest(u1, u2, family = 3, method = "kendall", B=50)

# perform Kendall's goodness-of-fit test for the Frank copula
BiCopGofTest(u1, u2, family = 5, method = "kendall", B=50)

</code></pre>

<hr>
<h2 id='BiCopHfunc'>Conditional Distribution Function of a Bivariate Copula</h2><span id='topic+BiCopHfunc'></span><span id='topic+BiCopHfunc1'></span><span id='topic+BiCopHfunc2'></span>

<h3>Description</h3>

<p>Evaluate the conditional distribution function (h-function)
of a given parametric bivariate copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopHfunc(u1, u2, family, par, par2 = 0, obj = NULL, check.pars = TRUE)

BiCopHfunc1(u1, u2, family, par, par2 = 0, obj = NULL, check.pars = TRUE)

BiCopHfunc2(u1, u2, family, par, par2 = 0, obj = NULL, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopHfunc_+3A_u1">u1</code>, <code id="BiCopHfunc_+3A_u2">u2</code></td>
<td>
<p>numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopHfunc_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
defines the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopHfunc_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopHfunc_+3A_par2">par2</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
second parameter for bivariate copulas with two parameters (t, BB1, BB6,
BB7, BB8, Tawn type 1 and type 2; default: <code>par2 = 0</code>). <code>par2</code>
should be an positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopHfunc_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopHfunc_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The h-function is defined as the conditional distribution function of a
bivariate copula, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">h_1(u_2|u_1;\boldsymbol{\theta}) := P(U_2 \le u_2 | U_1 = u_1)
= \frac{\partial C(u_1, u_2; \boldsymbol{\theta})}{\partial u_1}, </code>
</p>

<p style="text-align: center;"><code class="reqn">h_2(u_1|u_2;\boldsymbol{\theta}) := P(U_1 \le u_1 | U_2 = u_2)
 = \frac{\partial C(u_1, u_2; \boldsymbol{\theta})}{\partial u_2}, </code>
</p>

<p>where <code class="reqn">(U_1, U_2) \sim C</code>, and <code class="reqn">C</code> is a bivariate copula distribution
function with parameter(s) <code class="reqn">\boldsymbol{\theta}</code>.
For more details see Aas et al. (2009). <br /> <br />
</p>
<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative versions
</p>
<pre>BiCopHfunc(u1, u2, obj)
BiCopHfunc1(u1, u2, obj)
BiCopHfunc2(u1, u2, obj)</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p><code>BiCopHfunc</code> returns a list with
</p>
<table>
<tr><td><code>hfunc1</code></td>
<td>
<p>Numeric vector of the conditional distribution
function (h-function) of the copula <code>family</code> with parameter(s)
<code>par</code>, <code>par2</code> evaluated at <code>u2</code> given <code>u1</code>, i.e.,
<code class="reqn">h_1(u_2|u_1;\boldsymbol{\theta})</code>.</p>
</td></tr>
<tr><td><code>hfunc2</code></td>
<td>
<p>Numeric vector of the conditional distribution function
(h-function) of the copula <code>family</code> with parameter(s) <code>par</code>,
<code>par2</code> evaluated at <code>u1</code> given <code>u2</code>, i.e.,
<code class="reqn">h_2(u_1|u_2;\boldsymbol{\theta})</code>.</p>
</td></tr>
</table>
<p><code>BiCopHfunc1</code> is a faster version that only calculates <code>hfunc1</code>;
<code>BiCopHfunc2</code> only calculates <code>hfunc2</code>.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Aas, K., C. Czado, A. Frigessi, and H. Bakken (2009).
Pair-copula constructions of multiple dependence. Insurance: Mathematics and
Economics 44 (2), 182-198.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopHinv">BiCopHinv()</a></code>, <code><a href="#topic+BiCopPDF">BiCopPDF()</a></code>, <code><a href="#topic+BiCopCDF">BiCopCDF()</a></code>,
<code><a href="#topic+RVineLogLik">RVineLogLik()</a></code>, <code><a href="#topic+RVineSeqEst">RVineSeqEst()</a></code>, <code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(daxreturns)

# h-functions of the Gaussian copula
cop &lt;- BiCop(family = 1, par = 0.5)
h &lt;- BiCopHfunc(daxreturns[, 2], daxreturns[, 1], cop)

# or using the fast versions
h1 &lt;- BiCopHfunc1(daxreturns[, 2], daxreturns[, 1], cop)
h2 &lt;- BiCopHfunc2(daxreturns[, 2], daxreturns[, 1], cop)
all.equal(h$hfunc1, h1)
all.equal(h$hfunc2, h2)

</code></pre>

<hr>
<h2 id='BiCopHfuncDeriv'>Derivatives of the h-Function of a Bivariate Copula</h2><span id='topic+BiCopHfuncDeriv'></span>

<h3>Description</h3>

<p>This function evaluates the derivative of a given conditional parametric
bivariate copula (h-function) with respect to its parameter(s) or one of its
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopHfuncDeriv(
  u1,
  u2,
  family,
  par,
  par2 = 0,
  deriv = "par",
  obj = NULL,
  check.pars = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopHfuncDeriv_+3A_u1">u1</code>, <code id="BiCopHfuncDeriv_+3A_u2">u2</code></td>
<td>
<p>numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
defines the bivariate copula family: \ <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; &ldquo;survival Joe&rdquo;) <br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv_+3A_par2">par2</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
second parameter for the t-Copula; default is <code>par2 = 0</code>, should be an
positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv_+3A_deriv">deriv</code></td>
<td>
<p>Derivative argument <br />
<code>"par"</code> = derivative with respect to the first parameter (default)<br />
<code>"par2"</code> = derivative with respect to the second parameter
(only available for the t-copula) <br />
<code>"u2"</code> = derivative with respect to the second argument <code>u2</code> <br /></p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version <br />
</p>
<pre>BiCopHfuncDeriv(u1, u2, obj, deriv = "par")</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p>A numeric vector of the conditional bivariate copula derivative
</p>

<ul>
<li><p> of the copula <code>family</code>,
</p>
</li>
<li><p> with parameter(s) <code>par</code>, <code>par2</code>,
</p>
</li>
<li><p> with respect to <code>deriv</code>,
</p>
</li>
<li><p> evaluated at <code>u1</code> and <code>u2</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Schepsmeier, U. and J. Stoeber (2014). Derivatives and Fisher
information of bivariate copulas. Statistical Papers, 55 (2), 525-542. <br />
<a href="https://link.springer.com/article/10.1007/s00362-013-0498-x">https://link.springer.com/article/10.1007/s00362-013-0498-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineGrad">RVineGrad()</a></code>, <code><a href="#topic+RVineHessian">RVineHessian()</a></code>,
<code><a href="#topic+BiCopDeriv2">BiCopDeriv2()</a></code>, <code><a href="#topic+BiCopDeriv2">BiCopDeriv2()</a></code>,
<code><a href="#topic+BiCopHfuncDeriv">BiCopHfuncDeriv()</a></code>, <code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simulate from a bivariate Student-t copula
set.seed(123)
cop &lt;- BiCop(family = 2, par = -0.7, par2 = 4)
simdata &lt;- BiCopSim(100, cop)

## derivative of the conditional Student-t copula
## with respect to the first parameter
u1 &lt;- simdata[,1]
u2 &lt;- simdata[,2]
BiCopHfuncDeriv(u1, u2, cop, deriv = "par")

## estimate a Student-t copula for the simulated data
cop &lt;- BiCopEst(u1, u2, family = 2)
## and evaluate the derivative of the conditional copula
## w.r.t. the second argument u2
BiCopHfuncDeriv(u1, u2, cop, deriv = "u2")

</code></pre>

<hr>
<h2 id='BiCopHfuncDeriv2'>Second Derivatives of the h-Function of a Bivariate Copula</h2><span id='topic+BiCopHfuncDeriv2'></span>

<h3>Description</h3>

<p>This function evaluates the second derivative of a given conditional
parametric bivariate copula (h-function) with respect to its parameter(s)
and/or its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopHfuncDeriv2(
  u1,
  u2,
  family,
  par,
  par2 = 0,
  deriv = "par",
  obj = NULL,
  check.pars = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopHfuncDeriv2_+3A_u1">u1</code>, <code id="BiCopHfuncDeriv2_+3A_u2">u2</code></td>
<td>
<p>numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv2_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
defines the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; &ldquo;survival Joe&rdquo;) <br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv2_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv2_+3A_par2">par2</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
second parameter for the t-Copula; default is <code>par2 = 0</code>, should be an
positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv2_+3A_deriv">deriv</code></td>
<td>
<p>Derivative argument <br />
<code>"par"</code> = second derivative with respect to
the first parameter (default)<br />
<code>"par2"</code> = second derivative with respect to
the second parameter (only available for the t-copula) <br />
<code>"u2"</code> = second derivative with respect to
the second argument <code>u2</code> <br />
<code>"par1par2"</code> = second derivative with respect to
the first and second parameter (only available for the t-copula) <br />
<code>"par1u2"</code> = second derivative with respect to
the first parameter and the second argument <br />
<code>"par2u2"</code> = second derivative with respect to the second parameter
and the second argument (only available for the t-copula) <br /></p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv2_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopHfuncDeriv2_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version <br />
</p>
<pre>BiCopHfuncDeriv2(u1, u2, obj, deriv = "par")</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p>A numeric vector of the second-order conditional bivariate copula
derivative
</p>

<ul>
<li><p> of the copula <code>family</code>
</p>
</li>
<li><p> with parameter(s) <code>par</code>, <code>par2</code>
</p>
</li>
<li><p> with respect to <code>deriv</code>
</p>
</li>
<li><p> evaluated at <code>u1</code> and <code>u2</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Jakob Stoeber
</p>


<h3>References</h3>

<p>Schepsmeier, U. and J. Stoeber (2014). Derivatives and Fisher
information of bivariate copulas. Statistical Papers, 55 (2), 525-542. <br />
<a href="https://link.springer.com/article/10.1007/s00362-013-0498-x">https://link.springer.com/article/10.1007/s00362-013-0498-x</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineGrad">RVineGrad()</a></code>, <code><a href="#topic+RVineHessian">RVineHessian()</a></code>,
<code><a href="#topic+BiCopDeriv">BiCopDeriv()</a></code>, <code><a href="#topic+BiCopDeriv2">BiCopDeriv2()</a></code>,
<code><a href="#topic+BiCopHfuncDeriv">BiCopHfuncDeriv()</a></code>, <code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simulate from a bivariate Student-t copula
set.seed(123)
cop &lt;- BiCop(family = 2, par = -0.7, par2 = 4)
simdata &lt;- BiCopSim(100, cop)

## second derivative of the conditional bivariate t-copula
## with respect to the first parameter
u1 &lt;- simdata[,1]
u2 &lt;- simdata[,2]
BiCopHfuncDeriv2(u1, u2, cop, deriv = "par")

## estimate a Student-t copula for the simulated data
cop &lt;- BiCopEst(u1, u2, family = 2)
## and evaluate the derivative of the conditional copula
## w.r.t. the second argument u2
BiCopHfuncDeriv2(u1, u2, cop, deriv = "u2")

</code></pre>

<hr>
<h2 id='BiCopHinv'>Inverse Conditional Distribution Function of a Bivariate Copula</h2><span id='topic+BiCopHinv'></span><span id='topic+BiCopHinv1'></span><span id='topic+BiCopHinv2'></span>

<h3>Description</h3>

<p>Evaluate the inverse conditional distribution function
(inverse h-function) of a given parametric bivariate copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopHinv(u1, u2, family, par, par2 = 0, obj = NULL, check.pars = TRUE)

BiCopHinv1(u1, u2, family, par, par2 = 0, obj = NULL, check.pars = TRUE)

BiCopHinv2(u1, u2, family, par, par2 = 0, obj = NULL, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopHinv_+3A_u1">u1</code>, <code id="BiCopHinv_+3A_u2">u2</code></td>
<td>
<p>numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopHinv_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
defines the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopHinv_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopHinv_+3A_par2">par2</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
second parameter for bivariate copulas with two parameters (t, BB1, BB6,
BB7, BB8, Tawn type 1 and type 2; default: <code>par2 = 0</code>). <code>par2</code>
should be an positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopHinv_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopHinv_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The h-function is defined as the conditional distribution function of a
bivariate copula, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">h_1(u_2|u_1;\boldsymbol{\theta}) := P(U_2 \le u_2 | U_1 = u_1)
= \frac{\partial C(u_1, u_2; \boldsymbol{\theta})}{\partial u_1}, </code>
</p>

<p style="text-align: center;"><code class="reqn">h_2(u_1|u_2;\boldsymbol{\theta}) := P(U_1 \le u_1 | U_2 = u_2)
 = \frac{\partial C(u_1, u_2; \boldsymbol{\theta})}{\partial u_2}, </code>
</p>

<p>where <code class="reqn">(U_1, U_2) \sim C</code>, and <code class="reqn">C</code> is a bivariate copula distribution
function with parameter(s) <code class="reqn">\boldsymbol{\theta}</code>.
For more details see Aas et al. (2009). <br /> <br />
</p>
<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version
</p>
<pre>BiCopHinv(u1, u2, obj),
BiCopHinv1(u1, u2, obj),
BiCopHinv2(u1, u2, obj)</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p><code>BiCopHinv</code> returns a list with
</p>
<table>
<tr><td><code>hinv1</code></td>
<td>
<p>Numeric vector of the inverse conditional distribution function
(inverse h-function) of the copula <code>family</code> with parameter(s)
<code>par</code>, <code>par2</code> evaluated at <code>u2</code> given <code>u1</code>, i.e.,
<code class="reqn">h_1^{-1}(u_2|u_1;\boldsymbol{\theta})</code>.</p>
</td></tr>
<tr><td><code>hinv2</code></td>
<td>
<p>Numeric vector of the inverse conditional distribution function
(inverse h-function) of the copula <code>family</code> with parameter(s) <code>par</code>,
<code>par2</code> evaluated at <code>u1</code> given <code>u2</code>, i.e.,
<code class="reqn">h_2^{-1}(u_1|u_2;\boldsymbol{\theta})</code>.</p>
</td></tr>
</table>
<p><code>BiCopHinv1</code> is a faster version that only calculates <code>hinv1</code>;
<code>BiCopHinv2</code> only calculates <code>hinv2</code>.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Thomas Nagler
</p>


<h3>References</h3>

<p>Aas, K., C. Czado, A. Frigessi, and H. Bakken (2009).
Pair-copula constructions of multiple dependence. Insurance: Mathematics and
Economics 44 (2), 182-198.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopHfunc">BiCopHfunc()</a></code>, <code><a href="#topic+BiCopPDF">BiCopPDF()</a></code>, <code><a href="#topic+BiCopCDF">BiCopCDF()</a></code>,
<code><a href="#topic+RVineLogLik">RVineLogLik()</a></code>, <code><a href="#topic+RVineSeqEst">RVineSeqEst()</a></code>, <code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># inverse h-functions of the Gaussian copula
cop &lt;- BiCop(1, 0.5)
hi &lt;- BiCopHinv(0.1, 0.2, cop)

# or using the fast versions
hi1 &lt;- BiCopHinv1(0.1, 0.2, cop)
hi2 &lt;- BiCopHinv2(0.1, 0.2, cop)
all.equal(hi$hinv1, hi1)
all.equal(hi$hinv2, hi2)

# check if it is actually the inverse
cop &lt;- BiCop(3, 3)
all.equal(0.2, BiCopHfunc1(0.1, BiCopHinv1(0.1, 0.2, cop), cop))
all.equal(0.1, BiCopHfunc2(BiCopHinv2(0.1, 0.2, cop), 0.2, cop))

</code></pre>

<hr>
<h2 id='BiCopIndTest'>Independence Test for Bivariate Copula Data</h2><span id='topic+BiCopIndTest'></span>

<h3>Description</h3>

<p>This function returns the p-value of a bivariate asymptotic independence
test based on Kendall's <code class="reqn">\tau</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopIndTest(u1, u2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopIndTest_+3A_u1">u1</code>, <code id="BiCopIndTest_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test exploits the asymptotic normality of the test statistic
</p>
<p style="text-align: center;"><code class="reqn">\texttt{statistic} := T =
\sqrt{\frac{9N(N - 1)}{2(2N + 5)}} \times |\hat{\tau}|, </code>
</p>

<p>where <code class="reqn">N</code> is the number of observations (length of <code>u1</code>) and
<code class="reqn">\hat{\tau}</code> the empirical Kendall's tau of the data vectors <code>u1</code>
and <code>u2</code>. The p-value of the null hypothesis of bivariate independence
hence is asymptotically
</p>
<p style="text-align: center;"><code class="reqn">\texttt{p.value} = 2 \times \left(1 - \Phi\left(T\right)\right), </code>
</p>

<p>where <code class="reqn">\Phi</code> is the standard normal distribution function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>statistic</code></td>
<td>
<p>Test statistic of the independence test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>P-value of the independence test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey Dissmann
</p>


<h3>References</h3>

<p>Genest, C. and A. C. Favre (2007). Everything you always wanted
to know about copula modeling but were afraid to ask. Journal of Hydrologic
Engineering, 12 (4), 347-368.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopGofTest">BiCopGofTest()</a></code>, <code><a href="#topic+BiCopPar2Tau">BiCopPar2Tau()</a></code>,
<code><a href="#topic+BiCopTau2Par">BiCopTau2Par()</a></code>, <code><a href="#topic+BiCopSelect">BiCopSelect()</a></code>,<br />
<code><a href="#topic+RVineCopSelect">RVineCopSelect()</a></code>, <code><a href="#topic+RVineStructureSelect">RVineStructureSelect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1: Gaussian copula with large dependence parameter
cop &lt;- BiCop(1, 0.7)
dat &lt;- BiCopSim(500, cop)

# perform the asymptotic independence test
BiCopIndTest(dat[, 1], dat[, 2])

## Example 2: Gaussian copula with small dependence parameter
cop &lt;- BiCop(1, 0.01)
dat &lt;- BiCopSim(500, cop)

# perform the asymptotic independence test
BiCopIndTest(dat[, 1], dat[, 2])

</code></pre>

<hr>
<h2 id='BiCopKDE'>Kernel estimate of  a Bivariate Copula Density</h2><span id='topic+BiCopKDE'></span>

<h3>Description</h3>

<p>A kernel density estimate of the copula density is visualized. The function
provides the same options as <code><a href="#topic+plot.BiCop">plot.BiCop()</a></code>. Further arguments can
be passed to <code><a href="kdecopula.html#topic+kdecop">kdecopula::kdecop()</a></code> to modify the estimate. The
<code><a href="kdecopula.html#topic+kdecopula">kdecopula::kdecopula-package()</a></code> must be installed to use
this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopKDE(u1, u2, type = "contour", margins, size, kde.pars = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopKDE_+3A_u1">u1</code>, <code id="BiCopKDE_+3A_u2">u2</code></td>
<td>
<p>numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopKDE_+3A_type">type</code></td>
<td>
<p>plot type; either <code>"contour"</code> or <code>"surface"</code> (partial
matching is activated) for a contour or perspective/surface plot
respectively.</p>
</td></tr>
<tr><td><code id="BiCopKDE_+3A_margins">margins</code></td>
<td>
<p>only relevant for types <code>"contour"</code> and
<code>"surface"</code>; options are: <code>"unif"</code> for the original copula density,
<code>"norm"</code> for the transformed density with standard normal margins,
<code>"exp"</code> with standard exponential margins, and  <code>"flexp"</code> with
flipped exponential margins. Default is <code>"norm"</code> for <code>type = "contour"</code>, and <code>"unif"</code> for <code>type = "surface"</code>.
<code>"norm"</code> for the transformed density with standard normal margins
(partial matching is activated). Default is <code>"norm"</code> for <code>type = "contour"</code>, and <code>"unif"</code> for <code>type = "surface"</code>.</p>
</td></tr>
<tr><td><code id="BiCopKDE_+3A_size">size</code></td>
<td>
<p>integer; the plot is based on values on a <code style="white-space: pre;">&#8288;size x size&#8288;</code>
grid; default is 100 for <code>type = "contour"</code>, and 25 for <code>type = "surface"</code>.</p>
</td></tr>
<tr><td><code id="BiCopKDE_+3A_kde.pars">kde.pars</code></td>
<td>
<p>list of arguments passed to
<code><a href="kdecopula.html#topic+kdecop">kdecopula::kdecop()</a></code>.</p>
</td></tr>
<tr><td><code id="BiCopKDE_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="graphics.html#topic+contour">contour()</a></code> or
<code><a href="lattice.html#topic+wireframe">wireframe()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details on estimation see <code><a href="kdecopula.html#topic+kdecop">kdecopula::kdecop()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate data from Joe copula
cop &lt;- BiCop(3, tau = 0.3)
u &lt;- BiCopSim(1000, cop)
contour(cop)  # true contours

# kernel contours with standard normal margins
BiCopKDE(u[, 1], u[, 2])
BiCopKDE(u[, 1], u[, 2], kde.pars = list(mult = 0.5))  # undersmooth
BiCopKDE(u[, 1], u[, 2], kde.pars = list(mult = 2))  # oversmooth

# kernel density with uniform margins
BiCopKDE(u[, 1], u[, 2], type = "surface", zlim = c(0, 4))
plot(cop, zlim = c(0, 4))  # true density

# kernel contours are also used in pairs.copuladata
data(daxreturns)
data &lt;- as.copuladata(daxreturns)
pairs(data[c(4, 5, 14, 15)])

</code></pre>

<hr>
<h2 id='BiCopKPlot'>Kendall's Plot for Bivariate Copula Data</h2><span id='topic+BiCopKPlot'></span>

<h3>Description</h3>

<p>This function creates a Kendall's plot (K-plot) of given bivariate copula
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopKPlot(u1, u2, PLOT = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopKPlot_+3A_u1">u1</code>, <code id="BiCopKPlot_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopKPlot_+3A_plot">PLOT</code></td>
<td>
<p>Logical; whether the results are plotted. If <code>PLOT = FALSE</code>, the values <code>W.in</code> and <code>Hi.sort</code> are returned (see below;
default: <code>PLOT = TRUE</code>).</p>
</td></tr>
<tr><td><code id="BiCopKPlot_+3A_...">...</code></td>
<td>
<p>Additional plot arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For observations <code class="reqn">u_{i,j},\ i=1,...,N,\ j=1,2,</code> the K-plot considers two quantities: First, the ordered values of
the empirical bivariate distribution function
<code class="reqn">H_i:=\hat{F}_{U_1U_2}(u_{i,1},u_{i,2})</code> and, second, <code class="reqn">W_{i:N}</code>,
which are the expected values of the order statistics from a random sample
of size <code class="reqn">N</code> of the random variable <code class="reqn">W=C(U_1,U_2)</code> under the null
hypothesis of independence between <code class="reqn">U_1</code> and <code class="reqn">U_2</code>. <code class="reqn">W_{i:N}</code>
can be calculated as follows </p>
<p style="text-align: center;"><code class="reqn"> W_{i:n}= N {N-1 \choose i-1}
\int\limits_{0}^1 \omega k_0(\omega) ( K_0(\omega) )^{i-1} ( 1-K_0(\omega)
)^{N-i} d\omega, </code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">K_0(\omega) = \omega - \omega \log(\omega), </code>
</p>

<p>and <code class="reqn">k_0(\cdot)</code> is the corresponding density.
</p>
<p>K-plots can be seen as the bivariate copula equivalent to QQ-plots. If the
points of a K-plot lie approximately on the diagonal <code class="reqn">y=x</code>, then
<code class="reqn">U_1</code> and <code class="reqn">U_2</code> are approximately independent. Any deviation from
the diagonal line points towards dependence. In case of positive dependence,
the points of the K-plot should be located above the diagonal line, and vice
versa for negative dependence. The larger the deviation from the diagonal,
the stronger is the degree of dependency. There is a perfect positive
dependence if points <code class="reqn">\left(W_{i:N},H_i\right)</code> lie on the curve
<code class="reqn">K_0(\omega)</code> located above the main diagonal. If points
<code class="reqn">\left(W_{i:N},H_i\right)</code> however lie on the x-axis,
this indicates a perfect negative dependence between <code class="reqn">U_1</code> and
<code class="reqn">U_2</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>W.in</code></td>
<td>
<p>W-statistics (x-axis).</p>
</td></tr> <tr><td><code>Hi.sort</code></td>
<td>
<p>H-statistics
(y-axis).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Natalia Belgorodski, Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Genest, C. and A. C. Favre (2007). Everything you always wanted
to know about copula modeling but were afraid to ask. Journal of Hydrologic
Engineering, 12 (4), 347-368.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopMetaContour">BiCopMetaContour()</a></code>, <code><a href="#topic+BiCopChiPlot">BiCopChiPlot()</a></code>,
<code><a href="#topic+BiCopLambda">BiCopLambda()</a></code>, <code><a href="#topic+BiCopGofTest">BiCopGofTest()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Gaussian and Clayton copulas
n &lt;- 500
tau &lt;- 0.5

# simulate from Gaussian copula
fam &lt;- 1
par &lt;- BiCopTau2Par(fam, tau)
cop1 &lt;- BiCop(fam, par)
set.seed(123)
dat1 &lt;- BiCopSim(n, cop1)

# simulate from Clayton copula
fam &lt;- 3
par &lt;- BiCopTau2Par(fam, tau)
cop2 &lt;- BiCop(fam, par)
set.seed(123)
dat2 &lt;- BiCopSim(n, cop2)

# create K-plots
op &lt;- par(mfrow = c(1, 2))
BiCopKPlot(dat1[,1], dat1[,2], main = "Gaussian copula")
BiCopKPlot(dat2[,1], dat2[,2], main = "Clayton copula")
par(op)

</code></pre>

<hr>
<h2 id='BiCopLambda'>Lambda-Function (Plot) for Bivariate Copula Data</h2><span id='topic+BiCopLambda'></span>

<h3>Description</h3>

<p>This function plots/returns the lambda-function of given bivariate copula
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopLambda(
  u1 = NULL,
  u2 = NULL,
  family = "emp",
  par = 0,
  par2 = 0,
  PLOT = TRUE,
  obj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopLambda_+3A_u1">u1</code>, <code id="BiCopLambda_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code> (default:
<code>u1</code> and <code>u2 = NULL</code>).</p>
</td></tr>
<tr><td><code id="BiCopLambda_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family or indicating
the empirical lambda-function: <br />
<code>"emp"</code> = empirical lambda-function
(default) <br />
<code>1</code> = Gaussian copula; the theoretical lambda-function is simulated
(no closed formula available) <br />
<code>2</code> = Student-t copula; the theoretical lambda-function is simulated
(no closed formula available) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8
copula</p>
</td></tr>
<tr><td><code id="BiCopLambda_+3A_par">par</code></td>
<td>
<p>Copula parameter; if the empirical lambda-function is chosen,
<code>par = NULL</code> or <code>0</code> (default).</p>
</td></tr>
<tr><td><code id="BiCopLambda_+3A_par2">par2</code></td>
<td>
<p>Second copula parameter for t-, BB1, BB6, BB7 and BB8 copulas
(default: <code>par2 = 0</code>).</p>
</td></tr>
<tr><td><code id="BiCopLambda_+3A_plot">PLOT</code></td>
<td>
<p>Logical; whether the results are plotted. If <code>PLOT = FALSE</code>, the values <br /> <code>empLambda</code> and/or <code>theoLambda</code> are
returned (see below; default: <code>PLOT = TRUE</code>).</p>
</td></tr>
<tr><td><code id="BiCopLambda_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopLambda_+3A_...">...</code></td>
<td>
<p>Additional plot arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative versions <br />
</p>
<pre>BiCopLambda(obj, PLOT = TRUE, ...)</pre>
<p>and
</p>
<pre>BiCopLambda((u1, u2, obj, PLOT = TRUE, ...)</pre>
<p>can be used.
</p>


<h3>Value</h3>

<table>
<tr><td><code>empLambda</code></td>
<td>
<p>If the empirical lambda-function is chosen and
<code>PLOT = FALSE</code>, a vector of the empirical lambda's is returned.</p>
</td></tr>
<tr><td><code>theoLambda</code></td>
<td>
<p>If the theoretical lambda-function is chosen and
<code>PLOT = FALSE</code>, a vector of the theoretical lambda's is returned.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code class="reqn">\lambda</code>-function is characteristic for each bivariate copula
family and defined by Kendall's distribution function <code class="reqn">K</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \lambda(v,\theta) := v - K(v,\theta) </code>
</p>
<p> with
</p>
<p style="text-align: center;"><code class="reqn">K(v,\theta) := P(C_{\theta}(U_1,U_2) \leq v),\ \ v\in [0,1]. </code>
</p>

<p>For Archimedean copulas one has the following closed form expression
in terms of the generator function <code class="reqn">\varphi</code> of the copula
<code class="reqn">C_{\theta}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\lambda(v,\theta) = \frac{\varphi(v)}{\varphi '(v)}, </code>
</p>

<p>where <code class="reqn">\varphi '</code> is the derivative of <code class="reqn">\varphi</code>. For
more details see Genest and Rivest (1993) or Schepsmeier (2010).
</p>
<p>For the bivariate Gaussian and Student-t copula no closed form expression for
the theoretical <code class="reqn">\lambda</code>-function exists. Therefore it is simulated based
on samples of size 1000. For all other implemented copula families there are
closed form expressions available.
</p>
<p>The plot of the theoretical <code class="reqn">\lambda</code>-function also shows the limits of
the <code class="reqn">\lambda</code>-function corresponding to Kendall's tau <code class="reqn">=0</code> and
Kendall's tau <code class="reqn">=1</code> (<code class="reqn">\lambda=0</code>).
</p>
<p>For rotated bivariate copulas one has to transform the input arguments
<code>u1</code> and/or <code>u2</code>. In particular, for copulas rotated by 90 degrees
<code>u1</code> has to be set to <code>1-u1</code>, for 270 degrees <code>u2</code> to
<code>1-u2</code> and for survival copulas <code>u1</code> and <code>u2</code> to <code>1-u1</code>
and <code>1-u2</code>, respectively. Then <code class="reqn">\lambda</code>-functions for the
corresponding non-rotated copula families can be considered.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Genest, C. and L.-P. Rivest (1993). Statistical inference
procedures for bivariate Archimedean copulas. Journal of the American
Statistical Association, 88 (423), 1034-1043.
</p>
<p>Schepsmeier, U. (2010). Maximum likelihood estimation of C-vine pair-copula
constructions based on bivariate copulas from different families. Diploma
thesis, Technische Universitaet Muenchen.<br />
<a href="https://mediatum.ub.tum.de/?id=1079296">https://mediatum.ub.tum.de/?id=1079296</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopMetaContour">BiCopMetaContour()</a></code>, <code><a href="#topic+BiCopKPlot">BiCopKPlot()</a></code>,
<code><a href="#topic+BiCopChiPlot">BiCopChiPlot()</a></code>, <code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate from Clayton copula
cop &lt;- BiCop(3, tau = 0.5)
dat &lt;- BiCopSim(1000, cop)

# create lambda-function plots
op &lt;- par(mfrow = c(1, 3))
BiCopLambda(dat[, 1], dat[, 2])  # empirical lambda-function
BiCopLambda(cop)	# theoretical lambda-function
BiCopLambda(dat[, 1], dat[, 2], cop)	# both
par(op)


</code></pre>

<hr>
<h2 id='BiCopMetaContour'>Contour Plot of Bivariate Meta Distribution</h2><span id='topic+BiCopMetaContour'></span>

<h3>Description</h3>

<p>Note: This function is deprecated and only available for backwards
compatibility. See <code><a href="#topic+contour.BiCop">contour.BiCop()</a></code> for contour plots of
parametric copulas, and <code><a href="#topic+BiCopKDE">BiCopKDE()</a></code> for kernel estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopMetaContour(
  u1 = NULL,
  u2 = NULL,
  bw = 1,
  size = 100,
  levels = c(0.01, 0.05, 0.1, 0.15, 0.2),
  family = "emp",
  par = 0,
  par2 = 0,
  PLOT = TRUE,
  margins = "norm",
  margins.par = 0,
  xylim = NA,
  obj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopMetaContour_+3A_u1">u1</code>, <code id="BiCopMetaContour_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code> (default:
<code>u1</code> and <code>u2 = NULL</code>).</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_bw">bw</code></td>
<td>
<p>Bandwidth (smoothing factor; default: <code>bw = 1</code>).</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_size">size</code></td>
<td>
<p>Number of grid points; default: <code>size = 100</code>.</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_levels">levels</code></td>
<td>
<p>Vector of contour levels. For Gaussian, Student-t or
exponential margins the default value (<code>levels = c(0.01, 0.05, 0.1, 0.15, 0.2)</code>) typically is a good choice. For uniform margins we
recommend<br /> <code>levels = c(0.1, 0.3, 0.5, 0.7, 0.9, 1.1, 1.3, 1.5)</code><br />
and for Gamma margins<br /> <code>levels = c(0.005, 0.01, 0.03, 0.05, 0.07, 0.09)</code>.</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family or indicating
an empirical contour plot: <br />
<code>"emp"</code> = empirical contour plot
(default; margins can be specified by <code>margins</code>) <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_par">par</code></td>
<td>
<p>Copula parameter; if empirical contour plot, <code>par = NULL</code> or
<code>0</code> (default).</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_par2">par2</code></td>
<td>
<p>Second copula parameter for t-, BB1, BB6, BB7, BB8, Tawn type 1
and type 2 copulas (default: <code>par2 = 0</code>).</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_plot">PLOT</code></td>
<td>
<p>Logical; whether the results are plotted.  If <code>PLOT = FALSE</code>, the values <code>x</code>, <code>y</code> and <code>z</code> are returned (see below;
default: <code>PLOT = TRUE</code>).</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_margins">margins</code></td>
<td>
<p>Character; margins for the bivariate copula contour plot.
Possible margins are:<br />
<code>"norm"</code> = standard normal margins (default)<br />
<code>"t"</code> = Student t margins with degrees of freedom as
specified by <code>margins.par</code><br />
<code>"gamma"</code> = Gamma margins with shape and scale as
specified by <code>margins.par</code><br />
<code>"exp"</code> = Exponential margins with rate as
specified by <code>margins.par</code><br />
<code>"unif"</code> = uniform margins</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_margins.par">margins.par</code></td>
<td>
<p>Parameter(s) of the distribution of the margins if
necessary (default: <code>margins.par = 0</code>), i.e.,
</p>

<ul>
<li><p> a positive real number for the degrees of freedom of
Student t margins (see <code><a href="stats.html#topic+dt">dt()</a></code>),
</p>
</li>
<li><p> a 2-dimensional vector of positive real numbers for
the shape and scale parameters of Gamma margins (see <code><a href="stats.html#topic+dgamma">dgamma()</a></code>),
</p>
</li>
<li><p> a positive real number for the rate parameter of
exponential margins (see <code><a href="stats.html#topic+dexp">dexp()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_xylim">xylim</code></td>
<td>
<p>A 2-dimensional vector of the x- and y-limits.  By default
(<code>xylim = NA</code>) standard limits for the selected margins are used.</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopMetaContour_+3A_...">...</code></td>
<td>
<p>Additional plot arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>A vector of length <code>size</code> with the x-values of the
kernel density estimator with Gaussian kernel if the empirical contour plot
is chosen and a sequence of values in <code>xylim</code> if the theoretical
contour plot is chosen.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>A vector of length <code>size</code> with the
y-values of the kernel density estimator with Gaussian kernel if the
empirical contour plot is chosen and a sequence of values in <code>xylim</code> if
the theoretical contour plot is chosen.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>A matrix of dimension
<code>size</code> with the values of the density of the meta distribution with
chosen margins (see <code>margins</code> and <code>margins.par</code>) evaluated at the
grid points given by <code>x</code> and <code>y</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The combination <code>family = 0</code> (independence copula) and
<code>margins = "unif"</code> (uniform margins) is not possible because all
<code>z</code>-values are equal.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Alexander Bauer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopChiPlot">BiCopChiPlot()</a></code>, <code><a href="#topic+BiCopKPlot">BiCopKPlot()</a></code>,
<code><a href="#topic+BiCopLambda">BiCopLambda()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## meta Clayton distribution  with Gaussian margins
cop &lt;- BiCop(family = 1, tau = 0.5)
BiCopMetaContour(obj = cop, main = "Clayton - normal margins")
# better:
contour(cop, main = "Clayton - normal margins")

## empirical contour plot with standard normal margins
dat &lt;- BiCopSim(1000, cop)
BiCopMetaContour(dat[, 1], dat[, 2], bw = 2, family = "emp",
                 main = "empirical - normal margins")
# better:
BiCopKDE(dat[, 1], dat[, 2],
        main = "empirical - normal margins")

## empirical contour plot with exponential margins
BiCopMetaContour(dat[, 1], dat[, 2], bw = 2,
                 main = "empirical - exponential margins",
                 margins = "exp", margins.par = 1)
# better:
BiCopKDE(dat[, 1], dat[, 2],
         main = "empirical - exponential margins",
         margins = "exp")

</code></pre>

<hr>
<h2 id='BiCopName'>Bivariate Copula Family Names</h2><span id='topic+BiCopName'></span>

<h3>Description</h3>

<p>This function transforms the bivariate copula family number into its
character expression and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopName(family, short = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopName_+3A_family">family</code></td>
<td>
<p>Bivariate copula family, either its number or its character
expression (see table below).
</p>

<table>
<tr>
 <td style="text-align: right;">
No.        </td><td style="text-align: left;"> Short name         </td><td style="text-align: left;"> Long name </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>0</code>   </td><td style="text-align: left;"> <code>"I"</code>         </td><td style="text-align: left;"> <code>"Independence"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>1</code>   </td><td style="text-align: left;"> <code>"N"</code>         </td><td style="text-align: left;"> <code>"Gaussian"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>2</code>   </td><td style="text-align: left;"> <code>"t"</code>         </td><td style="text-align: left;"> <code>"t"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>3</code>   </td><td style="text-align: left;"> <code>"C"</code>         </td><td style="text-align: left;"> <code>"Clayton"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>4</code>   </td><td style="text-align: left;"> <code>"G"</code>         </td><td style="text-align: left;"> <code>"Gumbel"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>5</code>   </td><td style="text-align: left;"> <code>"F"</code>         </td><td style="text-align: left;"> <code>"Frank"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>6</code>   </td><td style="text-align: left;"> <code>"J"</code>         </td><td style="text-align: left;"> <code>"Joe"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>7</code>   </td><td style="text-align: left;"> <code>"BB1"</code>       </td><td style="text-align: left;"> <code>"BB1"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>8</code>   </td><td style="text-align: left;"> <code>"BB6"</code>       </td><td style="text-align: left;"> <code>"BB6"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>9</code>   </td><td style="text-align: left;"> <code>"BB7"</code>       </td><td style="text-align: left;"> <code>"BB7"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>10</code>  </td><td style="text-align: left;"> <code>"BB8"</code>       </td><td style="text-align: left;"> <code>"Frank-Joe"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>13</code>  </td><td style="text-align: left;"> <code>"SC"</code>        </td><td style="text-align: left;"> <code>"Survival Clayton"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>14</code>  </td><td style="text-align: left;"> <code>"SG"</code>        </td><td style="text-align: left;"> <code>"Survival Gumbel"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>16</code>  </td><td style="text-align: left;"> <code>"SJ"</code>        </td><td style="text-align: left;"> <code>"Survival Joe"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>17</code>  </td><td style="text-align: left;"> <code>"SBB1"</code>      </td><td style="text-align: left;"> <code>"Survival BB1"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>18</code>  </td><td style="text-align: left;"> <code>"SBB6"</code>      </td><td style="text-align: left;"> <code>"Survival BB6"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>19</code>  </td><td style="text-align: left;"> <code>"SBB7"</code>      </td><td style="text-align: left;"> <code>"Survival BB7"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>20</code>  </td><td style="text-align: left;"> <code>"SBB8"</code>      </td><td style="text-align: left;"> <code>"Survival BB8"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>23</code>  </td><td style="text-align: left;"> <code>"C90"</code>       </td><td style="text-align: left;"> <code>"Rotated Clayton 90 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>24</code>  </td><td style="text-align: left;"> <code>"G90"</code>       </td><td style="text-align: left;"> <code>"Rotated Gumbel 90 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>26</code>  </td><td style="text-align: left;"> <code>"J90"</code>       </td><td style="text-align: left;"> <code>"Rotated Joe 90 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>27</code>  </td><td style="text-align: left;"> <code>"BB1_90"</code>    </td><td style="text-align: left;"> <code>"Rotated BB1 90 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>28</code>  </td><td style="text-align: left;"> <code>"BB6_90"</code>    </td><td style="text-align: left;"> <code>"Rotated BB6 90 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>29</code>  </td><td style="text-align: left;"> <code>"BB7_90"</code>    </td><td style="text-align: left;"> <code>"Rotated BB7 90 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>30</code>  </td><td style="text-align: left;"> <code>"BB8_90"</code>    </td><td style="text-align: left;"> <code>"Rotated Frank-Joe 90 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>33</code>  </td><td style="text-align: left;"> <code>"C270"</code>      </td><td style="text-align: left;"> <code>"Rotated Clayton 270 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>34</code>  </td><td style="text-align: left;"> <code>"G270"</code>      </td><td style="text-align: left;"> <code>"Rotated Gumbel 270 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>36</code>  </td><td style="text-align: left;"> <code>"J270"</code>      </td><td style="text-align: left;"> <code>"Rotated Joe 270 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>37</code>  </td><td style="text-align: left;"> <code>"BB1_270"</code>   </td><td style="text-align: left;"> <code>"Rotated BB1 270 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>38</code>  </td><td style="text-align: left;"> <code>"BB6_270"</code>   </td><td style="text-align: left;"> <code>"Rotated BB6 270 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>39</code>  </td><td style="text-align: left;"> <code>"BB7_270"</code>   </td><td style="text-align: left;"> <code>"Rotated BB7 270 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>40</code>  </td><td style="text-align: left;"> <code>"BB8_270"</code>   </td><td style="text-align: left;"> <code>"Rotated Frank-Joe 270 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>104</code> </td><td style="text-align: left;"> <code>"Tawn"</code>      </td><td style="text-align: left;"> <code>"Tawn type 1"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>114</code> </td><td style="text-align: left;"> <code>"Tawn180"</code>   </td><td style="text-align: left;"> <code>"Rotated Tawn type 1 180 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>124</code> </td><td style="text-align: left;"> <code>"Tawn90"</code>    </td><td style="text-align: left;"> <code>"Rotated Tawn type 1 90 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>134</code> </td><td style="text-align: left;"> <code>"Tawn270"</code>   </td><td style="text-align: left;"> <code>"Rotated Tawn type 1 270 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>204</code> </td><td style="text-align: left;"> <code>"Tawn2"</code>     </td><td style="text-align: left;"> <code>"Tawn type 2"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>214</code> </td><td style="text-align: left;"> <code>"Tawn2_180"</code> </td><td style="text-align: left;"> <code>"Rotated Tawn type 2 180 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>224</code> </td><td style="text-align: left;"> <code>"Tawn2_90"</code>  </td><td style="text-align: left;"> <code>"Rotated Tawn type 2 90 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code>234</code> </td><td style="text-align: left;"> <code>"Tawn2_270"</code> </td><td style="text-align: left;"> <code>"Rotated Tawn type 2 270 degrees"</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="BiCopName_+3A_short">short</code></td>
<td>
<p>Logical; if the number of a bivariate copula family is used and
<code>short = TRUE</code> (default), a short version of the corresponding
character expression is returned, otherwise the long version.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed bivariate copula family (see table above).
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineTreePlot">RVineTreePlot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## family number to character expression
family &lt;- 1
BiCopName(family, short = TRUE)	 # short version
BiCopName(family, short = FALSE)	 # long version

## family character expression (short version) to number
family &lt;- "C"
BiCopName(family)	# as number

## family character expression (long version) to number
family &lt;- "Clayton"
BiCopName(family)	# as number

## vectors of families
BiCopName(1:10)    # as character expression
BiCopName(c("Clayton","t","J"))    # as number

</code></pre>

<hr>
<h2 id='BiCopPar2Beta'>Blomqvist's Beta Value of a Bivariate Copula</h2><span id='topic+BiCopPar2Beta'></span>

<h3>Description</h3>

<p>This function computes the theoretical Blomqvist's beta value of a bivariate
copula for given parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopPar2Beta(family, par, par2 = 0, obj = NULL, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopPar2Beta_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>n</code>; defines the
bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>1</code> = Gaussian copula <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' =  rotated Tawn type 2 copula (270 degrees) <br />
Note that the Student's t-copula is not allowed since the CDF of the t-copula
is not implemented (see <code><a href="#topic+BiCopCDF">BiCopCDF()</a></code>).</p>
</td></tr>
<tr><td><code id="BiCopPar2Beta_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>n</code>; copula
parameter.</p>
</td></tr>
<tr><td><code id="BiCopPar2Beta_+3A_par2">par2</code></td>
<td>
<p>numeric; single number or vector of size <code>n</code>; second
parameter for the two parameter BB1, BB6, BB7, BB8, Tawn type 1 and type 2
copulas (default: <code>par2 = 0</code>).</p>
</td></tr>
<tr><td><code id="BiCopPar2Beta_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopPar2Beta_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version <br />
</p>
<pre>BiCopPar2Beta(obj)</pre><p> can be used.
</p>


<h3>Value</h3>

<p>Theoretical value of Blomqvist's beta corresponding to the bivariate
copula <code>family</code> and parameter(s) <code>par</code>, <code>par2</code>.
</p>


<h3>Note</h3>

<p>The number <code>n</code> can be chosen arbitrarily, but must agree across
arguments.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Blomqvist, N. (1950).  On a measure of dependence between two
random variables. The Annals of Mathematical Statistics, 21(4), 593-600.
</p>
<p>Nelsen, R. (2006). An introduction to copulas.  Springer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Gaussian copula
BiCopPar2Beta(family = 1, par = 0.7)
BiCop(1, 0.7)$beta  # alternative

## Example 2: Clayton copula
BiCopPar2Beta(family = 3, par = 2)

## Example 3: different copula families
BiCopPar2Beta(family = c(3,4,6), par = 2:4)

</code></pre>

<hr>
<h2 id='BiCopPar2TailDep'>Tail Dependence Coefficients of a Bivariate Copula</h2><span id='topic+BiCopPar2TailDep'></span>

<h3>Description</h3>

<p>This function computes the theoretical tail dependence coefficients of a
bivariate copula for given parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopPar2TailDep(family, par, par2 = 0, obj = NULL, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopPar2TailDep_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>n</code>; defines the
bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopPar2TailDep_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>n</code>; copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopPar2TailDep_+3A_par2">par2</code></td>
<td>
<p>numeric; single number or vector of size <code>n</code>; second
parameter for bivariate copulas with two parameters (t, BB1, BB6, BB7, BB8,
Tawn type 1 and type 2; default: <code>par2 = 0</code>). <code>par2</code> should be an
positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopPar2TailDep_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopPar2TailDep_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code>BiCop</code> object
<code>obj</code>, the alternative version <br /> </p>
<pre>BiCopPar2TailDep(obj)</pre>
<p>can be used.
</p>


<h3>Value</h3>

<table>
<tr><td><code>lower</code></td>
<td>
<p>Lower tail dependence coefficient for the given
bivariate copula <code>family</code> and parameter(s) <code>par</code>, <code>par2</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \lambda_L = \lim_{u\searrow 0}\frac{C(u,u)}{u} </code>
</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>Upper tail dependence coefficient for the given bivariate
copula family <code>family</code> and parameter(s) <code>par</code>, <code>par2</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \lambda_U = \lim_{u\nearrow 1}\frac{1-2u+C(u,u)}{1-u} </code>
</p>
</td></tr>
</table>
<p>Lower and upper tail dependence coefficients for bivariate copula families
and parameters (<code class="reqn">\theta</code> for one parameter families and the first
parameter of the t-copula with <code class="reqn">\nu</code> degrees of freedom,
<code class="reqn">\theta</code> and <code class="reqn">\delta</code> for the two parameter BB1, BB6, BB7 and BB8 copulas)
are given in the following table.
</p>

<table>
<tr>
 <td style="text-align: left;"> No. </td><td style="text-align: left;"> Lower tail dependence </td><td style="text-align: left;"> Upper tail dependence </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>1</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>2</code> </td><td style="text-align: left;">
<code class="reqn">2t_{\nu+1}\left(-\sqrt{\nu+1}\sqrt{\frac{1-\theta}{1+\theta}}\right)</code>
</td><td style="text-align: left;">
<code class="reqn">2t_{\nu+1}\left(-\sqrt{\nu+1}\sqrt{\frac{1-\theta}{1+\theta}}\right)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>3</code> </td><td style="text-align: left;"> <code class="reqn">2^{-1/\theta}</code> </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>4</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>5</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>6</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>7</code> </td><td style="text-align: left;"> <code class="reqn">2^{-1/(\theta\delta)}</code> </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\delta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>8</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> <code class="reqn">2-2^{1/(\theta\delta)}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>9</code> </td><td style="text-align: left;"> <code class="reqn">2^{-1/\delta}</code> </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>10</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\theta}</code> if <code class="reqn">\delta=1</code> otherwise 0 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>13</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> <code class="reqn">2^{-1/\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>14</code> </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\theta}</code> </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>16</code> </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\theta}</code> </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>17</code> </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\delta}</code> </td><td style="text-align: left;"> <code class="reqn">2^{-1/(\theta\delta)}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>18</code> </td><td style="text-align: left;"> <code class="reqn">2-2^{1/(\theta\delta)}</code> </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>19</code> </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\theta}</code> </td><td style="text-align: left;"> <code class="reqn">2^{-1/\delta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>20</code> </td><td style="text-align: left;"> <code class="reqn">2-2^{1/\theta}</code> if <code class="reqn">\delta=1</code> otherwise 0 </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;23, 33&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;"> <code style="white-space: pre;">&#8288;24, 34&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;26, 36&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;27, 37&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;28, 38&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;29, 39&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;30, 40&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;104,204&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> <code class="reqn">\delta+1-(\delta^{\theta}+1)^{1/\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;114, 214&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">1+\delta-(\delta^{\theta}+1)^{1/\theta}</code> </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;124, 224&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;134, 234&#8288;</code> </td><td style="text-align: left;"> - </td><td style="text-align: left;"> - </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>Note</h3>

<p>The number <code>n</code> can be chosen arbitrarily, but must agree across
arguments.
</p>


<h3>Author(s)</h3>

<p>Eike Brechmann
</p>


<h3>References</h3>

<p>Joe, H. (1997). Multivariate Models and Dependence Concepts.
Chapman and Hall, London.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopPar2Tau">BiCopPar2Tau()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Gaussian copula
BiCopPar2TailDep(1, 0.7)
BiCop(1, 0.7)$taildep  # alternative

## Example 2: Student-t copula
BiCopPar2TailDep(2, c(0.6, 0.7, 0.8), 4)

## Example 3: different copula families
BiCopPar2TailDep(c(3, 4, 6), 2)

</code></pre>

<hr>
<h2 id='BiCopPar2Tau'>Kendall's Tau Value of a Bivariate Copula</h2><span id='topic+BiCopPar2Tau'></span>

<h3>Description</h3>

<p>This function computes the theoretical Kendall's tau value of a bivariate
copula for given parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopPar2Tau(family, par, par2 = 0, obj = NULL, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopPar2Tau_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>m</code>; defines the
bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopPar2Tau_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>n</code>; copula
parameter.</p>
</td></tr>
<tr><td><code id="BiCopPar2Tau_+3A_par2">par2</code></td>
<td>
<p>numeric; single number or vector of size <code>n</code>; second
parameter for bivariate copulas with two parameters (t, BB1, BB6, BB7, BB8,
Tawn type 1 and type 2; default: <code>par2 = 0</code>).  Note that the degrees of
freedom parameter of the t-copula does not need to be set, because the
theoretical Kendall's tau value of the t-copula is independent of this
choice.</p>
</td></tr>
<tr><td><code id="BiCopPar2Tau_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopPar2Tau_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version <br />
</p>
<pre>BiCopPar2Tau(obj)</pre><p> can be used.
</p>


<h3>Value</h3>

<p>Theoretical value of Kendall's tau (vector) corresponding to the
bivariate copula <code>family</code> and parameter vector <code class="reqn">(\theta, \delta) =</code>
<code style="white-space: pre;">&#8288;(par, par2)&#8288;</code>.
</p>

<table>
<tr>
 <td style="text-align: left;"> No. (<code>family</code>) </td><td style="text-align: left;"> Kendall's tau (<code>tau</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;1, 2&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">\frac{2}{\pi}\arcsin(\theta)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;3, 13&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">\frac{\theta}{\theta+2}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;4, 14&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">1-\frac{1}{\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>5</code> </td><td style="text-align: left;"> <code class="reqn">1-\frac{4}{\theta}+4\frac{D_1(\theta)}{\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> with <code class="reqn">D_1(\theta)=\int_0^\theta \frac{x/\theta}{\exp(x)-1}dx</code> (Debye function) </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;6, 16&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">1+\frac{4}{\theta^2}\int_0^1
x\log(x)(1-x)^{2(1-\theta)/\theta}dx</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;7, 17&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">1-\frac{2}{\delta(\theta+2)}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;8, 18&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">1+4\int_0^1 -\log(-(1-t)^\theta+1)
(1-t-(1-t)^{-\theta}+(1-t)^{-\theta}t)/(\delta\theta) dt</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;9, 19&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">1+4\int_0^1 ( (1-(1-t)^{\theta})^{-\delta} - 1)
/( -\theta\delta(1-t)^{\theta-1}(1-(1-t)^{\theta})^{-\delta-1} ) dt</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;10, 20&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">1+4\int_0^1
-\log \left(((1-t\delta)^\theta-1)/((1-\delta)^\theta-1) \right) </code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code class="reqn">* (1-t\delta-(1-t\delta)^{-\theta}+(1-t\delta)^{-\theta}t\delta)/(\theta\delta) dt</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;23, 33&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">\frac{\theta}{2-\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;24, 34&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">-1-\frac{1}{\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;26, 36&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">-1-\frac{4}{\theta^2}\int_0^1
x\log(x)(1-x)^{-2(1+\theta)/\theta}dx</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;27, 37&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">-1-\frac{2}{\delta(2-\theta)}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;28, 38&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">-1-4\int_0^1 -\log(-(1-t)^{-\theta}+1)
(1-t-(1-t)^{\theta}+(1-t)^{\theta}t)/(\delta\theta) dt</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;29, 39&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">-1-4\int_0^1 ( (1-(1-t)^{-\theta})^{\delta} - 1)
/( -\theta\delta(1-t)^{-\theta-1}(1-(1-t)^{-\theta})^{\delta-1} ) dt</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;30, 40&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">-1-4\int_0^1 -\log
\left( ((1+t\delta)^{-\theta}-1)/((1+\delta)^{-\theta}-1) \right)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code class="reqn">* (1+t\delta-(1+t\delta)^{\theta}-(1+t\delta)^{\theta}t\delta)/(\theta\delta) dt</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;104,114&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">\int_0^1 \frac{t(1-t)A^{\prime\prime}(t)}{A(t)}dt</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> with <code class="reqn">A(t) = (1-\delta)t+[(\delta(1-t))^{\theta}+t^{\theta}]^{1/\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;204,214&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">\int_0^1 \frac{t(1-t)A^{\prime\prime}(t)}{A(t)}dt</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> with <code class="reqn">A(t) = (1-\delta)(1-t)+[(1-t)^{-\theta}+(\delta t)^{-\theta}]^{-1/\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;124,134&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">-\int_0^1 \frac{t(1-t)A^{\prime\prime}(t)}{A(t)}dt</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> with <code class="reqn">A(t) = (1-\delta)t+[(\delta(1-t))^{-\theta}+t^{-\theta}]^{-1/\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code style="white-space: pre;">&#8288;224,234&#8288;</code> </td><td style="text-align: left;"> <code class="reqn">-\int_0^1 \frac{t(1-t)A^{\prime\prime}(t)}{A(t)}dt</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> with <code class="reqn">A(t) = (1-\delta)(1-t)+[(1-t)^{-\theta}+(\delta t)^{-\theta}]^{-1/\theta}</code> </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>Note</h3>

<p>The number <code>n</code> can be chosen arbitrarily, but must agree across
arguments.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Tobias Erhardt
</p>


<h3>References</h3>

<p>Joe, H. (1997). Multivariate Models and Dependence Concepts.
Chapman and Hall, London.
</p>
<p>Czado, C., U. Schepsmeier, and A. Min (2012). Maximum likelihood estimation
of mixed C-vines with application to exchange rates. Statistical Modelling,
12(3), 229-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopTau2Par">BiCopTau2Par()</a></code>, <code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Gaussian copula
tau0 &lt;- 0.5
rho &lt;- BiCopTau2Par(family = 1, tau = tau0)
# transform back
tau &lt;- BiCopPar2Tau(family = 1, par = rho)
tau - 2/pi*asin(rho)

## Example 2:
vpar &lt;- seq(from = 1.1, to = 10, length.out = 100)
tauC &lt;- BiCopPar2Tau(family = 3, par = vpar)
tauG &lt;- BiCopPar2Tau(family = 4, par = vpar)
tauF &lt;- BiCopPar2Tau(family = 5, par = vpar)
tauJ &lt;- BiCopPar2Tau(family = 6, par = vpar)
plot(tauC ~ vpar, type = "l", ylim = c(0,1))
lines(tauG ~ vpar, col = 2)
lines(tauF ~ vpar, col = 3)
lines(tauJ ~ vpar, col = 4)

## Example 3: different copula families
theta &lt;- BiCopTau2Par(family = c(3,4,6), tau = c(0.4, 0.5, 0.6))
BiCopPar2Tau(family = c(3,4,6), par = theta)



</code></pre>

<hr>
<h2 id='BiCopPDF'>Density of a Bivariate Copula</h2><span id='topic+BiCopPDF'></span>

<h3>Description</h3>

<p>This function evaluates the probability density function (PDF) of a given
parametric bivariate copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopPDF(u1, u2, family, par, par2 = 0, obj = NULL, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopPDF_+3A_u1">u1</code>, <code id="BiCopPDF_+3A_u2">u2</code></td>
<td>
<p>numeric vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopPDF_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>length(u1)</code>;
defines the bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopPDF_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
copula parameter.</p>
</td></tr>
<tr><td><code id="BiCopPDF_+3A_par2">par2</code></td>
<td>
<p>numeric; single number or vector of size <code>length(u1)</code>;
second parameter for bivariate copulas with two parameters (t, BB1, BB6,
BB7, BB8, Tawn type 1 and type 2; default: <code>par2 = 0</code>). <code>par2</code>
should be an positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopPDF_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopPDF_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version <br />
</p>
<pre>BiCopPDF(u1, u2, obj)</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p>A numeric vector of the bivariate copula density
</p>

<ul>
<li><p> of the copula <code>family</code>
</p>
</li>
<li><p> with parameter(s) <code>par</code>, <code>par2</code>
</p>
</li>
<li><p> evaluated at <code>u1</code> and <code>u2</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Eike Brechmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopCDF">BiCopCDF()</a></code>, <code><a href="#topic+BiCopHfunc">BiCopHfunc()</a></code>,
<code><a href="#topic+BiCopSim">BiCopSim()</a></code>, <code><a href="#topic+BiCop">BiCop()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simulate from a bivariate Student-t copula
cop &lt;- BiCop(family = 2, par = -0.7, par2 = 4)
simdata &lt;- BiCopSim(100, cop)

## evaluate the density of the bivariate t-copula
u1 &lt;- simdata[,1]
u2 &lt;- simdata[,2]
BiCopPDF(u1, u2, cop)

## select a bivariate copula for the simulated data
fit &lt;- BiCopSelect(u1, u2)
summary(fit)
## and evaluate its PDF
round(BiCopPDF(u1, u2, fit), 3)

</code></pre>

<hr>
<h2 id='BiCopSelect'>Selection and Maximum Likelihood Estimation of Bivariate Copula Families</h2><span id='topic+BiCopSelect'></span>

<h3>Description</h3>

<p>This function selects an appropriate bivariate copula family for given
bivariate copula data using one of a range of methods. The corresponding
parameter estimates are obtained by maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopSelect(
  u1,
  u2,
  familyset = NA,
  selectioncrit = "AIC",
  indeptest = FALSE,
  level = 0.05,
  weights = NA,
  rotations = TRUE,
  se = FALSE,
  presel = TRUE,
  method = "mle"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopSelect_+3A_u1">u1</code>, <code id="BiCopSelect_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopSelect_+3A_familyset">familyset</code></td>
<td>
<p>Vector of bivariate copula families to select from.
The vector has to include at least one bivariate copula
family that allows for positive and one that allows for negative dependence.
If <code>familyset = NA</code> (default), selection among all possible families is
performed. If a vector of negative numbers is provided, selection among all
but <code>abs(familyset)</code> families is performed. Coding of bivariate copula
families: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopSelect_+3A_selectioncrit">selectioncrit</code></td>
<td>
<p>Character indicating the criterion for bivariate copula
selection. Possible choices: <code>selectioncrit = "AIC"</code> (default),
<code>"BIC"</code>, or <code>"logLik"</code>.</p>
</td></tr>
<tr><td><code id="BiCopSelect_+3A_indeptest">indeptest</code></td>
<td>
<p>Logical; whether a hypothesis test for the independence of
<code>u1</code> and <code>u2</code> is performed before bivariate copula selection
(default: <code>indeptest = FALSE</code>; see <code><a href="#topic+BiCopIndTest">BiCopIndTest()</a></code>).  The
independence copula is chosen if the null hypothesis of independence cannot
be rejected.</p>
</td></tr>
<tr><td><code id="BiCopSelect_+3A_level">level</code></td>
<td>
<p>Numeric; significance level of the independence test (default:
<code>level = 0.05</code>).</p>
</td></tr>
<tr><td><code id="BiCopSelect_+3A_weights">weights</code></td>
<td>
<p>Numerical; weights for each observation (optional).</p>
</td></tr>
<tr><td><code id="BiCopSelect_+3A_rotations">rotations</code></td>
<td>
<p>If <code>TRUE</code>, all rotations of the families in
<code>familyset</code> are included (or subtracted).</p>
</td></tr>
<tr><td><code id="BiCopSelect_+3A_se">se</code></td>
<td>
<p>Logical; whether standard error(s) of parameter estimates is/are
estimated (default: <code>se = FALSE</code>).</p>
</td></tr>
<tr><td><code id="BiCopSelect_+3A_presel">presel</code></td>
<td>
<p>Logical; whether to exclude families before fitting based on
symmetry properties of the data. Makes the selection about 30% faster
(on average), but may yield slightly worse results in few special cases.</p>
</td></tr>
<tr><td><code id="BiCopSelect_+3A_method">method</code></td>
<td>
<p>indicates the estimation method: either maximum
likelihood estimation (<code>method = "mle"</code>; default) or inversion of
Kendall's tau (<code>method = "itau"</code>). For <code>method = "itau"</code> only
one parameter families and the Student t copula can be used (<code style="white-space: pre;">&#8288;family = 1,2,3,4,5,6,13,14,16,23,24,26,33,34&#8288;</code> or <code>36</code>). For the t-copula,
<code>par2</code> is found by a crude profile likelihood optimization over the
interval (2, 10].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Copulas can be selected according to the Akaike and Bayesian Information
Criteria (AIC and BIC, respectively). First all available copulas are fitted
using maximum likelihood estimation. Then the criteria are computed for all
available copula families (e.g., if <code>u1</code> and <code>u2</code> are negatively
dependent, Clayton, Gumbel, Joe, BB1, BB6, BB7 and BB8 and their survival
copulas are not considered) and the family with the minimum value is chosen.
For observations <code class="reqn">u_{i,j},\ i=1,...,N,\ j=1,2,</code> the AIC of a bivariate copula family <code class="reqn">c</code> with parameter(s)
<code class="reqn">\boldsymbol{\theta}</code> is defined as </p>
<p style="text-align: center;"><code class="reqn">AIC := -2 \sum_{i=1}^N
\ln[c(u_{i,1},u_{i,2}|\boldsymbol{\theta})] + 2k, </code>
</p>
<p> where <code class="reqn">k=1</code> for one parameter
copulas and <code class="reqn">k=2</code> for the two parameter t-, BB1, BB6, BB7 and BB8
copulas. Similarly, the BIC is given by </p>
<p style="text-align: center;"><code class="reqn">BIC := -2 \sum_{i=1}^N
\ln[c(u_{i,1},u_{i,2}|\boldsymbol{\theta})] + \ln(N)k. </code>
</p>
<p> Evidently, if the BIC
is chosen, the penalty for two parameter families is stronger than when
using the AIC.
</p>
<p>Additionally a test for independence can be performed beforehand.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+BiCop">BiCop()</a></code>, augmented with the following
entries:
</p>
<table>
<tr><td><code>se</code>, <code>se2</code></td>
<td>
<p>standard errors for the parameter estimates (if
<code>se = TRUE</code>,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>log likelihood</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Aikaike's Informaton Criterion,</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian's Informaton Criterion,</p>
</td></tr>
<tr><td><code>emptau</code></td>
<td>
<p>empirical value of Kendall's tau,</p>
</td></tr>
<tr><td><code>p.value.indeptest</code></td>
<td>
<p>p-value of the independence test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a comprehensive summary of the fitted model, use
<code>summary(object)</code>; to see all its contents, use <code>str(object)</code>.
</p>
<p>The parameters of the Student t and BB copulas are restricted (see
defaults in <code><a href="#topic+BiCopEst">BiCopEst()</a></code> to avoid being to close to their limiting
cases.
</p>


<h3>Author(s)</h3>

<p>Eike Brechmann, Jeffrey Dissmann, Thomas Nagler
</p>


<h3>References</h3>

<p>Akaike, H. (1973). Information theory and an extension of the
maximum likelihood principle. In B. N. Petrov and F. Csaki (Eds.),
Proceedings of the Second International Symposium on Information Theory
Budapest, Akademiai Kiado, pp. 267-281.
</p>
<p>Brechmann, E. C. (2010). Truncated and simplified regular vines and their
applications. Diploma thesis, Technische Universitaet Muenchen.<br />
<a href="https://mediatum.ub.tum.de/?id=1079285">https://mediatum.ub.tum.de/?id=1079285</a>.
</p>
<p>Manner, H. (2007). Estimation and model selection of copulas with an
application to exchange rates. METEOR research memorandum 07/056, Maastricht
University.
</p>
<p>Schwarz, G. E. (1978). Estimating the dimension of a model. Annals of
Statistics 6 (2), 461-464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCop">BiCop()</a></code>,
<code><a href="#topic+BiCopEst">BiCopEst()</a></code>,
<code><a href="#topic+RVineStructureSelect">RVineStructureSelect()</a></code>,
<code><a href="#topic+RVineCopSelect">RVineCopSelect()</a></code>,
<code><a href="#topic+BiCopIndTest">BiCopIndTest()</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Gaussian copula with large dependence parameter
par &lt;- 0.7
fam &lt;- 1
dat1 &lt;- BiCopSim(500, fam, par)
# select the bivariate copula family and estimate the parameter(s)
cop1 &lt;- BiCopSelect(dat1[, 1], dat1[, 2], familyset = 1:10,
                    indeptest = FALSE, level = 0.05)
cop1  # short overview
summary(cop1)  # comprehensive overview
str(cop1)  # see all contents of the object

## Example 2: Gaussian copula with small dependence parameter
par &lt;- 0.01
fam &lt;- 1
dat2 &lt;- BiCopSim(500, fam, par)
# select the bivariate copula family and estimate the parameter(s)
cop2 &lt;- BiCopSelect(dat2[, 1], dat2[, 2], familyset = 0:10,
                    indeptest = TRUE, level = 0.05)
summary(cop2)

## Example 3: empirical data
data(daxreturns)
cop3 &lt;- BiCopSelect(daxreturns[, 1], daxreturns[, 4], familyset = 0:10)
summary(cop3)

</code></pre>

<hr>
<h2 id='BiCopSim'>Simulation from a Bivariate Copula</h2><span id='topic+BiCopSim'></span>

<h3>Description</h3>

<p>This function simulates from a given parametric bivariate copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopSim(N, family, par, par2 = 0, obj = NULL, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopSim_+3A_n">N</code></td>
<td>
<p>Number of bivariate observations simulated.</p>
</td></tr>
<tr><td><code id="BiCopSim_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>N</code>; defines the
bivariate copula family: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopSim_+3A_par">par</code></td>
<td>
<p>numeric; single number or vector of size <code>N</code>; copula
parameter.</p>
</td></tr>
<tr><td><code id="BiCopSim_+3A_par2">par2</code></td>
<td>
<p>numeric; single number or vector of size <code>N</code>; second
parameter for bivariate copulas with two parameters (t, BB1, BB6, BB7, BB8,
Tawn type 1 and type 2; default: <code>par2 = 0</code>). <code>par2</code> should be a
positive integer for the Students's t copula <code>family = 2</code>.</p>
</td></tr>
<tr><td><code id="BiCopSim_+3A_obj">obj</code></td>
<td>
<p><code>BiCop</code> object containing the family and parameter
specification.</p>
</td></tr>
<tr><td><code id="BiCopSim_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the family and parameter specification is stored in a <code><a href="#topic+BiCop">BiCop()</a></code>
object <code>obj</code>, the alternative version
</p>
<pre>BiCopSim(N, obj)</pre>
<p>can be used.
</p>


<h3>Value</h3>

<p>An <code>N</code> x 2 matrix of data simulated from the bivariate copula
with <code>family</code> and parameter(s) <code>par</code>, <code>par2</code>.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCop">BiCop()</a></code>,
<code><a href="#topic+RVineSim">RVineSim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate from a bivariate t-copula
simdata &lt;- BiCopSim(100, 2, -0.7, par2 = 4)

# or alternatively
obj &lt;- BiCop(family = 2, par = -0.7, par2 = 4)
simdata2 &lt;- BiCopSim(100, obj)

</code></pre>

<hr>
<h2 id='BiCopTau2Par'>Parameter of a Bivariate Copula for a given Kendall's Tau Value</h2><span id='topic+BiCopTau2Par'></span>

<h3>Description</h3>

<p>This function computes the parameter of a (one parameter) bivariate copula
for a given value of Kendall's tau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopTau2Par(family, tau, check.taus = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopTau2Par_+3A_family">family</code></td>
<td>
<p>integer; single number or vector of size <code>n</code>; defines the
bivariate copula family: <br /> <code>0</code> = independence copula <br /> <code>1</code> =
Gaussian copula <br /> <code>2</code> = Student t copula (Here only the first
parameter can be computed) <br /> <code>3</code> = Clayton copula <br /> <code>4</code> =
Gumbel copula <br /> <code>5</code> = Frank copula <br /> <code>6</code> = Joe copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; &ldquo;survival Joe&rdquo;) <br /> <code>23</code>
= rotated Clayton copula (90 degrees) <br /> '24' = rotated Gumbel copula
(90 degrees) <br /> '26' = rotated Joe copula (90 degrees) <br /> '33' =
rotated Clayton copula (270 degrees) <br /> '34' = rotated Gumbel copula
(270 degrees) <br /> '36' = rotated Joe copula (270 degrees)<br /> Note that
(with exception of the t-copula) two parameter bivariate copula families
cannot be used.</p>
</td></tr>
<tr><td><code id="BiCopTau2Par_+3A_tau">tau</code></td>
<td>
<p>numeric; single number or vector of size <code>n</code>; Kendall's tau
value (vector with elements in <code class="reqn">[-1,1]</code>).</p>
</td></tr>
<tr><td><code id="BiCopTau2Par_+3A_check.taus">check.taus</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/tau-consistency are omitted (should only be used with care).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parameter (vector) corresponding to the bivariate copula family and
the value(s) of Kendall's tau (<code class="reqn">\tau</code>). </p>

<table>
<tr>
 <td style="text-align: left;"> No.
(<code>family</code>) </td><td style="text-align: left;"> Parameter (<code>par</code>) </td>
</tr>
<tr>
 <td style="text-align: left;"> <code style="white-space: pre;">&#8288;1, 2&#8288;</code> </td><td style="text-align: left;">
<code class="reqn">\sin(\tau \frac{\pi}{2})</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code style="white-space: pre;">&#8288;3, 13&#8288;</code> </td><td style="text-align: left;">
<code class="reqn">2\frac{\tau}{1-\tau}</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code style="white-space: pre;">&#8288;4, 14&#8288;</code> </td><td style="text-align: left;">
<code class="reqn">\frac{1}{1-\tau}</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code>5</code> </td><td style="text-align: left;"> no closed form
expression (numerical inversion) </td>
</tr>
<tr>
 <td style="text-align: left;"> <code style="white-space: pre;">&#8288;6, 16&#8288;</code> </td><td style="text-align: left;"> no closed form
expression (numerical inversion) </td>
</tr>
<tr>
 <td style="text-align: left;"> <code style="white-space: pre;">&#8288;23, 33&#8288;</code> </td><td style="text-align: left;">
<code class="reqn">2\frac{\tau}{1+\tau}</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code style="white-space: pre;">&#8288;24, 34&#8288;</code> </td><td style="text-align: left;">
<code class="reqn">-\frac{1}{1+\tau}</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> <code style="white-space: pre;">&#8288;26, 36&#8288;</code> </td><td style="text-align: left;"> no closed form
expression (numerical inversion) </td>
</tr>

</table>



<h3>Note</h3>

<p>The number <code>n</code> can be chosen arbitrarily, but must agree across
arguments.
</p>


<h3>Author(s)</h3>

<p>Jakob Stoeber, Eike Brechmann, Tobias Erhardt
</p>


<h3>References</h3>

<p>Joe, H. (1997). Multivariate Models and Dependence Concepts.
Chapman and Hall, London.
</p>
<p>Czado, C., U. Schepsmeier, and A. Min (2012). Maximum likelihood estimation
of mixed C-vines with application to exchange rates. Statistical Modelling,
12(3), 229-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopPar2Tau">BiCopPar2Tau()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1: Gaussian copula
tau0 &lt;- 0.5
rho &lt;- BiCopTau2Par(family = 1, tau = tau0)
BiCop(1, tau = tau0)$par  # alternative

## Example 2:
vtau &lt;- seq(from = 0.1, to = 0.8, length.out = 100)
thetaC &lt;- BiCopTau2Par(family = 3, tau = vtau)
thetaG &lt;- BiCopTau2Par(family = 4, tau = vtau)
thetaF &lt;- BiCopTau2Par(family = 5, tau = vtau)
thetaJ &lt;- BiCopTau2Par(family = 6, tau = vtau)
plot(thetaC ~ vtau, type = "l", ylim = range(thetaF))
lines(thetaG ~ vtau, col = 2)
lines(thetaF ~ vtau, col = 3)
lines(thetaJ ~ vtau, col = 4)

## Example 3: different copula families
theta &lt;- BiCopTau2Par(family = c(3,4,6), tau = c(0.4, 0.5, 0.6))
BiCopPar2Tau(family = c(3,4,6), par = theta)



</code></pre>

<hr>
<h2 id='BiCopVuongClarke'>Scoring Goodness-of-Fit Test based on Vuong And Clarke Tests for Bivariate
Copula Data</h2><span id='topic+BiCopVuongClarke'></span>

<h3>Description</h3>

<p>Based on the Vuong and Clarke tests this function computes a goodness-of-fit
score for each bivariate copula family under consideration. For each
possible pair of copula families the Vuong and the Clarke tests decides
which of the two families fits the given data best and assigns a score&mdash;pro
or contra a copula family&mdash;according to this decision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopVuongClarke(
  u1,
  u2,
  familyset = NA,
  correction = FALSE,
  level = 0.05,
  rotations = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BiCopVuongClarke_+3A_u1">u1</code>, <code id="BiCopVuongClarke_+3A_u2">u2</code></td>
<td>
<p>Data vectors of equal length with values in <code class="reqn">[0,1]</code>.</p>
</td></tr>
<tr><td><code id="BiCopVuongClarke_+3A_familyset">familyset</code></td>
<td>
<p>An integer vector of bivariate copula families under
consideration, i.e., which are compared in the goodness-of-fit test.  If
<code>familyset = NA</code> (default), all possible families are compared.
Possible families are: <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="BiCopVuongClarke_+3A_correction">correction</code></td>
<td>
<p>Correction for the number of parameters.  Possible
choices: <code>correction = FALSE</code> (no correction; default), <code>"Akaike"</code>
and <code>"Schwarz"</code>.</p>
</td></tr>
<tr><td><code id="BiCopVuongClarke_+3A_level">level</code></td>
<td>
<p>Numerical; significance level of the tests (default:
<code>level = 0.05</code>).</p>
</td></tr>
<tr><td><code id="BiCopVuongClarke_+3A_rotations">rotations</code></td>
<td>
<p>If <code>TRUE</code>, all rotations of the families in
<code>familyset</code> are included (or subtracted).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Vuong as well as the Clarke test compare two models against each other
and based on their null hypothesis, allow for a statistically significant
decision among the two models (see the documentations of
<code><a href="#topic+RVineVuongTest">RVineVuongTest()</a></code> and <code><a href="#topic+RVineClarkeTest">RVineClarkeTest()</a></code> for
descriptions of the two tests). In the goodness-of-fit test proposed by
Belgorodski (2010) this is used for bivariate copula selection. It compares
a model 0 to all other possible models under consideration. If model 0 is
favored over another model, a score of &quot;+1&quot; is assigned and similarly a
score of &quot;-1&quot; if the other model is determined to be superior. No score is
assigned, if the respective test cannot discriminate between two models.
Both tests can be corrected for the numbers of parameters used in the
copulas. Either no correction (<code>correction = FALSE</code>), the Akaike
correction (<code>correction = "Akaike"</code>) or the parsimonious Schwarz
correction (<code>correction = "Schwarz"</code>) can be used.
</p>
<p>The models compared here are bivariate parametric copulas and we would like
to determine which family fits the data better than the other families.
E.g., if we would like to test the hypothesis that the bivariate Gaussian
copula fits the data best, then we compare the Gaussian copula against all
other copulas under consideration. In doing so, we investigate the null
hypothesis &quot;The Gaussian copula fits the data better than all other copulas
under consideration&quot;, which corresponds to <code class="reqn">k-1</code> times the hypothesis
&quot;The Gaussian copula <code class="reqn">C_j</code> fits the data better than copula <code class="reqn">C_i</code>&quot;
for all <code class="reqn">i=1,...,k, i\neq j</code>, where <code class="reqn">k</code> is the
number of bivariate copula families under consideration (length of
<code>familyset</code>). This procedure is done not only for one family but for
all families under consideration, i.e., two scores, one based on the Vuong
and one based on the Clarke test, are returned for each bivariate copula
family. If used as a goodness-of-fit procedure, the family with the highest
score should be selected.
</p>
<p>For more and detailed information about the goodness-of-fit test see
Belgorodski (2010).
</p>


<h3>Value</h3>

<p>A matrix with Vuong test scores in the first and Clarke test scores
in the second row. Column names correspond to bivariate copula families (see
above).
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Eike Brechmann, Natalia Belgorodski
</p>


<h3>References</h3>

<p>Belgorodski, N. (2010) Selecting pair-copula families for
regular vines with application to the multivariate analysis of European
stock market indices Diploma thesis, Technische Universitaet Muenchen.
<a href="https://mediatum.ub.tum.de/?id=1079284">https://mediatum.ub.tum.de/?id=1079284</a>.
</p>
<p>Clarke, K. A. (2007). A Simple Distribution-Free Test for Nonnested Model
Selection. Political Analysis, 15, 347-363.
</p>
<p>Vuong, Q. H. (1989). Ratio tests for model selection and non-nested
hypotheses. Econometrica 57 (2), 307-333.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopGofTest">BiCopGofTest()</a></code>, <code><a href="#topic+RVineVuongTest">RVineVuongTest()</a></code>,
<code><a href="#topic+RVineClarkeTest">RVineClarkeTest()</a></code>, <code><a href="#topic+BiCopSelect">BiCopSelect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate from a t-copula
dat &lt;- BiCopSim(500, 2, 0.7, 5)


# apply the test for families 1-6
BiCopVuongClarke(dat[,1], dat[,2], familyset = 1:6)

</code></pre>

<hr>
<h2 id='C2RVine'>Transform C-Vine to R-Vine Structure</h2><span id='topic+C2RVine'></span>

<h3>Description</h3>

<p>This function transforms a C-vine structure from the package CDVine to the
corresponding R-vine structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>C2RVine(order, family, par, par2 = rep(0, length(family)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="C2RVine_+3A_order">order</code></td>
<td>
<p>A d-dimensional vector specifying the order of the root nodes
in the C-vine.</p>
</td></tr>
<tr><td><code id="C2RVine_+3A_family">family</code></td>
<td>
<p>A d*(d-1)/2 vector of pair-copula families with values<br />
<code>0</code> = independence copula <br /> <code>1</code> = Gaussian copula <br /> <code>2</code> =
Student t copula (t-copula) <br /> <code>3</code> = Clayton copula <br /> <code>4</code> =
Gumbel copula <br /> <code>5</code> = Frank copula <br /> <code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br /> <code>8</code> = BB6 copula <br /> <code>9</code> = BB7 copula
<br /> <code>10</code> = BB8 copula <br /> <code>13</code> = rotated Clayton copula (180
degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br /> <code>16</code> = rotated Joe copula (180
degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br /> <code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br /> <code>23</code>
= rotated Clayton copula (90 degrees) <br /> '24' = rotated Gumbel copula
(90 degrees) <br /> '26' = rotated Joe copula (90 degrees) <br /> '27' =
rotated BB1 copula (90 degrees) <br /> '28' = rotated BB6 copula (90
degrees) <br /> '29' = rotated BB7 copula (90 degrees) <br /> '30' =
rotated BB8 copula (90 degrees) <br /> '33' = rotated Clayton copula (270
degrees) <br /> '34' = rotated Gumbel copula (270 degrees) <br /> '36' =
rotated Joe copula (270 degrees) <br /> '37' = rotated BB1 copula (270
degrees) <br /> '38' = rotated BB6 copula (270 degrees) <br /> '39' =
rotated BB7 copula (270 degrees) <br /> '40' = rotated BB8 copula (270
degrees) <br /> '104' = Tawn type 1 copula <br /> '114' = rotated Tawn
type 1 copula (180 degrees) <br /> '124' = rotated Tawn type 1 copula (90
degrees) <br /> '134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br /> '214' = rotated Tawn type 2 copula
(180 degrees) <br /> '224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="C2RVine_+3A_par">par</code></td>
<td>
<p>A d*(d-1)/2 vector of pair-copula parameters.</p>
</td></tr>
<tr><td><code id="C2RVine_+3A_par2">par2</code></td>
<td>
<p>A d*(d-1)/2 vector of second pair-copula parameters (optional;
default:<br /> <code>par2 = rep(0,length(family))</code>), necessary for the t-, BB1,
BB6, BB7, BB8, Tawn type 1 and type 2 copulas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Eike Brechmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>, <code><a href="#topic+D2RVine">D2RVine()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up C-vine copula model with mixed pair-copulas
d &lt;- 4
dd &lt;- d*(d-1)/2
order &lt;- 1:d
family &lt;- c(1, 2, 3, 4, 7, 3)
par &lt;- c(0.5, 0.4, 2, 1.5, 1.2, 1.5)
par2 &lt;- c(0, 5, 0, 0, 2, 0)

# transform to R-vine matrix notation
RVM &lt;- C2RVine(order, family, par, par2)
</code></pre>

<hr>
<h2 id='contour.RVineMatrix'>Plotting <code>RVineMatrix</code> objects.</h2><span id='topic+contour.RVineMatrix'></span><span id='topic+plot.RVineMatrix'></span>

<h3>Description</h3>

<p>There are two plotting generics for <code>RVineMatrix</code> objects.
<code>plot.RVineMatrix</code> plots one or all trees of a given R-vine copula
model. Edges can be labeled with information about the corresponding
pair-copula. <code>contour.RVineMatrix</code> produces a matrix of contour plots
(using <code><a href="#topic+plot.BiCop">plot.BiCop()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RVineMatrix'
contour(x, tree = "ALL", xylim = NULL, cex.nums = 1, data = NULL, ...)

## S3 method for class 'RVineMatrix'
plot(
  x,
  tree = "ALL",
  type = 0,
  edge.labels = NULL,
  legend.pos = "bottomleft",
  interactive = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour.RVineMatrix_+3A_x">x</code></td>
<td>
<p><code>RVineMatrix</code> object.</p>
</td></tr>
<tr><td><code id="contour.RVineMatrix_+3A_tree">tree</code></td>
<td>
<p><code>"ALL"</code> or integer vector; specifies which trees are
plotted.</p>
</td></tr>
<tr><td><code id="contour.RVineMatrix_+3A_xylim">xylim</code></td>
<td>
<p>numeric vector of length 2; sets <code>xlim</code> and <code>ylim</code>
for the contours</p>
</td></tr>
<tr><td><code id="contour.RVineMatrix_+3A_cex.nums">cex.nums</code></td>
<td>
<p>numeric; expansion factor for font of the numbers.</p>
</td></tr>
<tr><td><code id="contour.RVineMatrix_+3A_data">data</code></td>
<td>
<p>a data matrix for creating kernel density contours of each pair.</p>
</td></tr>
<tr><td><code id="contour.RVineMatrix_+3A_...">...</code></td>
<td>
<p>Arguments passed to
<code><a href="network.html#topic+plot.network">network::plot.network()</a></code> or
<code><a href="#topic+plot.BiCop">plot.BiCop()</a></code> respectively.</p>
</td></tr>
<tr><td><code id="contour.RVineMatrix_+3A_type">type</code></td>
<td>
<p>integer; specifies how to make use of variable names: <br />
<code>0</code> = variable names are ignored, <br /> <code>1</code> = variable names are
used to annotate vertices, <br /> <code>2</code> = uses numbers in plot and adds a
legend for variable names.</p>
</td></tr>
<tr><td><code id="contour.RVineMatrix_+3A_edge.labels">edge.labels</code></td>
<td>
<p>character; either a vector of edge labels or one of the
following: <br /> <code>"family"</code> = pair-copula family abbreviation (see
<code><a href="#topic+BiCopName">BiCopName()</a></code>), <br /> <code>"par"</code> =
pair-copula parameters, <br /> <code>"tau"</code> = pair-copula Kendall's tau (by
conversion of parameters) <br /> <code>"family-par"</code> = pair-copula family and
parameters <br /> <code>"family-tau"</code> = pair-copula family and Kendall's tau.</p>
</td></tr>
<tr><td><code id="contour.RVineMatrix_+3A_legend.pos">legend.pos</code></td>
<td>
<p>the <code>x</code> argument for
<code><a href="graphics.html#topic+legend">graphics::legend()</a></code>.</p>
</td></tr>
<tr><td><code id="contour.RVineMatrix_+3A_interactive">interactive</code></td>
<td>
<p>logical; if TRUE, the user is asked to adjust the
positioning of vertices with his mouse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you want the contour boxes to be perfect squares, the plot height should
be <code>1.25/length(tree)*(d - min(tree))</code> times the plot width.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler, Nicole Barthel
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="network.html#topic+plot.network">network::plot.network()</a></code>,
<code><a href="#topic+plot.BiCop">plot.BiCop()</a></code>,
<code><a href="#topic+BiCopName">BiCopName()</a></code>,
<code><a href="graphics.html#topic+legend">graphics::legend()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## build vine model
strucmat &lt;- matrix(c(3,   1, 2, 0, 2, 1, 0, 0, 1), 3, 3)
fammat   &lt;- matrix(c(0,   1, 6, 0, 0, 3, 0, 0, 0), 3, 3)
parmat   &lt;- matrix(c(0, 0.3, 3, 0, 0, 1, 0, 0, 0), 3, 3)
par2mat  &lt;- matrix(c(0,   0, 0, 0, 0, 0, 0, 0, 0), 3, 3)
RVM  &lt;- RVineMatrix(strucmat, fammat, parmat, par2mat)

# plot trees
## Not run: plot(RVM)

# show contour plots
contour(RVM)

</code></pre>

<hr>
<h2 id='D2RVine'>Transform D-Vine to R-Vine Structure</h2><span id='topic+D2RVine'></span>

<h3>Description</h3>

<p>This function transforms a D-vine structure from the package CDVine to the
corresponding R-vine structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D2RVine(order, family, par, par2 = rep(0, length(family)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D2RVine_+3A_order">order</code></td>
<td>
<p>A d-dimensional vector specifying the order of the nodes in the
D-vine.</p>
</td></tr>
<tr><td><code id="D2RVine_+3A_family">family</code></td>
<td>
<p>A d*(d-1)/2 vector of pair-copula families with values<br />
<code>0</code> = independence copula <br /> <code>1</code> = Gaussian copula <br /> <code>2</code> =
Student t copula (t-copula) <br /> <code>3</code> = Clayton copula <br /> <code>4</code> =
Gumbel copula <br /> <code>5</code> = Frank copula <br /> <code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br /> <code>8</code> = BB6 copula <br /> <code>9</code> = BB7 copula
<br /> <code>10</code> = BB8 copula <br /> <code>13</code> = rotated Clayton copula (180
degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br /> <code>16</code> = rotated Joe copula (180
degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br /> <code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br /> <code>23</code>
= rotated Clayton copula (90 degrees) <br /> '24' = rotated Gumbel copula
(90 degrees) <br /> '26' = rotated Joe copula (90 degrees) <br /> '27' =
rotated BB1 copula (90 degrees) <br /> '28' = rotated BB6 copula (90
degrees) <br /> '29' = rotated BB7 copula (90 degrees) <br /> '30' =
rotated BB8 copula (90 degrees) <br /> '33' = rotated Clayton copula (270
degrees) <br /> '34' = rotated Gumbel copula (270 degrees) <br /> '36' =
rotated Joe copula (270 degrees) <br /> '37' = rotated BB1 copula (270
degrees) <br /> '38' = rotated BB6 copula (270 degrees) <br /> '39' =
rotated BB7 copula (270 degrees) <br /> '40' = rotated BB8 copula (270
degrees) <br /> '104' = Tawn type 1 copula <br /> '114' = rotated Tawn
type 1 copula (180 degrees) <br /> '124' = rotated Tawn type 1 copula (90
degrees) <br /> '134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br /> '214' = rotated Tawn type 2 copula
(180 degrees) <br /> '224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="D2RVine_+3A_par">par</code></td>
<td>
<p>A d*(d-1)/2 vector of pair-copula parameters.</p>
</td></tr>
<tr><td><code id="D2RVine_+3A_par2">par2</code></td>
<td>
<p>A d*(d-1)/2 vector of second pair-copula parameters (optional;
default:<br /> <code>par2 = rep(0,length(family))</code>), necessary for the t-, BB1,
BB6, BB7, BB8, Tawn type 1 and type 2 copulas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>, <code><a href="#topic+C2RVine">C2RVine()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up D-vine copula model with mixed pair-copulas
d &lt;- 4
dd &lt;- d*(d-1)/2
order &lt;- 1:d
family &lt;- c(1, 2, 3, 4, 7, 3)
par &lt;- c(0.5, 0.4, 2, 1.5, 1.2, 1.5)
par2 &lt;- c(0, 5, 0, 0, 2, 0)

# transform to R-vine matrix notation
RVM &lt;- D2RVine(order, family, par, par2)
</code></pre>

<hr>
<h2 id='daxreturns'>Major German Stocks</h2><span id='topic+daxreturns'></span>

<h3>Description</h3>

<p>This data set contains transformed standardized residuals of daily log
returns of 15 major German stocks represented in the index DAX observed from
January 2005 to August 2009. Each time series is filtered using a GARCH(1,1)
model with Student t innovations.
</p>


<h3>Format</h3>

<p>A data frame with 1158 observations on 15 variables. Column names
correspond to ticker symbols of the stocks.
</p>


<h3>Source</h3>

<p>Yahoo! Finance
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineStructureSelect">RVineStructureSelect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load the data set
data(daxreturns)

# compute the empirical Kendall's tau matrix
TauMatrix(daxreturns)

</code></pre>

<hr>
<h2 id='EmpCDF'>Corrected Empirical CDF</h2><span id='topic+EmpCDF'></span>

<h3>Description</h3>

<p>The empirical CDF with tail correction, ensuring that its output is never
0 or 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EmpCDF(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EmpCDF_+3A_x">x</code></td>
<td>
<p>numeric vector of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The corrected empirical CDF is defined as
</p>
<p style="text-align: center;"><code class="reqn">
F_n(x) = \frac{1}{n + 1} \min\biggl\{1, \sum_{i = 1}^n 1(X_i \le x)\biggr\}
</code>
</p>



<h3>Value</h3>

<p>A function with signature <code style="white-space: pre;">&#8288;function(x)&#8288;</code> that returns <code class="reqn">F_n(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit ECDF on simulated data
x &lt;- rnorm(100)
cdf &lt;- EmpCDF(x)

# output is bounded away from 0 and 1
cdf(-50)
cdf(50)
</code></pre>

<hr>
<h2 id='pairs.copuladata'>Pairs Plot of Copula Data</h2><span id='topic+pairs.copuladata'></span>

<h3>Description</h3>

<p>This function provides pair plots for copula data. Using default setting it
plots bivariate contour plots on the lower panel, scatter plots and
correlations on the upper panel and histograms on the diagonal panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'copuladata'
pairs(
  x,
  labels = names(x),
  ...,
  lower.panel = lp.copuladata,
  upper.panel = up.copuladata,
  diag.panel = dp.copuladata,
  label.pos = 0.85,
  cex.labels = 1,
  gap = 0,
  method = "kendall",
  ccols = terrain.colors(11),
  margins = "norm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.copuladata_+3A_x">x</code></td>
<td>
<p><code>copuladata</code> object.</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_labels">labels</code></td>
<td>
<p>variable names/labels.</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_...">...</code></td>
<td>
<p>other graphical parameters (see <code><a href="graphics.html#topic+par">graphics::par()</a></code>) or
options passed to <code><a href="#topic+BiCopKDE">BiCopKDE()</a></code>.</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_lower.panel">lower.panel</code></td>
<td>
<p>panel function to be used on the lower diagonal panels
(if not supplied, a default function is used)</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_upper.panel">upper.panel</code></td>
<td>
<p>panel function to be used on the upper diagonal panels
(if not supplied, a default function is used)</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_diag.panel">diag.panel</code></td>
<td>
<p>panel function to be used on the diagonal panels (if not
supplied, a default function is used)</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_label.pos">label.pos</code></td>
<td>
<p>y position of labels in the diagonal panel; default:
<code>label.pos = 0.85</code>.</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_cex.labels">cex.labels</code></td>
<td>
<p>magnification to be used for the labels of the diagonal
panel; default: <code>cex.labels = 1</code>.</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_gap">gap</code></td>
<td>
<p>distance between subplots, in margin lines; default: <code>gap = 0</code>.</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation coefficients
are computed. One of <code>"pearson"</code>, <code>"kendall"</code> (default), or
<code>"spearman"</code></p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_ccols">ccols</code></td>
<td>
<p>color to be used for the contour plots; default: <code>ccols = terrain.colors(30)</code>.</p>
</td></tr>
<tr><td><code id="pairs.copuladata_+3A_margins">margins</code></td>
<td>
<p>character; margins for the contour plots. Options are:<br />
<code>"unif"</code> for the original copula density,
<code>"norm"</code> for the transformed density with standard normal margins,
<code>"exp"</code> with standard exponential margins, and  <code>"flexp"</code> with
flipped exponential margins.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If the default panel functions are used <br /> </p>
 <ul>
<li> <p><code>col</code>
changes only the color of the points in the scatter plot
(<code>upper.panel</code>) <br /> </p>
</li>
<li> <p><code>cex</code> changes only the magnification of
the points in the scatter plot (<code>upper.panel</code>) </p>
</li></ul>



<h3>Author(s)</h3>

<p>Tobias Erhardt
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pairs">graphics::pairs()</a></code>, <code><a href="#topic+as.copuladata">as.copuladata()</a></code>,
<code><a href="#topic+BiCopKDE">BiCopKDE()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(daxreturns)

data &lt;- as.copuladata(daxreturns)
sel &lt;- c(4,5,14,15)

## pairs plot with default settings
pairs(data[sel])

## pairs plot with custom settings
nlevels &lt;- 20
pairs(data[sel], cex = 2, pch = 1, col = "black",
      diag.panel = NULL, label.pos = 0.5,
      cex.labels = 2.5, gap = 1,
      method = "pearson", ccols = heat.colors(nlevels),
      margins = "flexp")

## pairs plot with own panel functions
up &lt;- function(x, y) {
  # upper panel: empirical contour plot
  op &lt;- par(usr = c(-3, 3, -3, 3), new = TRUE)
  BiCopKDE(x, y,
           levels = c(0.01, 0.05, 0.1, 0.15, 0.2),
           margins = "exp",
           axes = FALSE)
  on.exit(par(op))
}

lp &lt;- function(x, y) {
  # lower panel: scatter plot (copula data) and correlation
  op &lt;- par(usr = c(0, 1, 0, 1), new = TRUE)
  points(x, y, pch = 1, col = "black")
  r &lt;- cor(x, y, method = "spearman") # Spearman's rho
  txt &lt;- format(x = r, digits = 3, nsmall = 3)[1]
  text(x = 0.5, y = 0.5, labels = txt, cex = 1 + abs(r) * 2, col = "blue")
  on.exit(par(op))
}

dp &lt;- function(x) {
  # diagonal panel: histograms (copula data)
  op &lt;- par(usr = c(0, 1, 0, 1.5), new = TRUE)
  hist(x, freq = FALSE, add = TRUE, col = "brown", border = "black", main = "")
  abline(h = 1, col = "black", lty = 2)
  on.exit(par(op))
}

nlevels &lt;- 20
pairs(data[sel],
      lower.panel = lp, upper.panel = up, diag.panel = dp, gap = 0.5)

</code></pre>

<hr>
<h2 id='plot.BiCop'>Plotting tools for BiCop objects</h2><span id='topic+plot.BiCop'></span><span id='topic+contour.BiCop'></span>

<h3>Description</h3>

<p>There are several options for plotting BiCop objects. The density of a
bivariate copula density can be visualized as surface/perspective or contour
plot. Optionally, the density can be coupled with standard normal margins
(default for contour plots). Furthermore, a lambda-plot is available (cf.,
<code><a href="#topic+BiCopLambda">BiCopLambda()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BiCop'
plot(x, type = "surface", margins, size, ...)

## S3 method for class 'BiCop'
contour(x, margins = "norm", size = 100L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BiCop_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;BiCop object.&#8288;</code></p>
</td></tr>
<tr><td><code id="plot.BiCop_+3A_type">type</code></td>
<td>
<p>plot type; either <code>"surface"</code>, <code>"contour"</code>, or
<code>"lambda"</code> (partial matching is activated); the latter is only
implemented for a few families (c.f., <code><a href="#topic+BiCopLambda">BiCopLambda()</a></code>).</p>
</td></tr>
<tr><td><code id="plot.BiCop_+3A_margins">margins</code></td>
<td>
<p>only relevant for types <code>"contour"</code> and
<code>"surface"</code>; options are: <code>"unif"</code> for the original copula density,
<code>"norm"</code> for the transformed density with standard normal margins,
<code>"exp"</code> with standard exponential margins, and  <code>"flexp"</code> with
flipped exponential margins. Default is <code>"norm"</code> for <code>type = "contour"</code>, and <code>"unif"</code> for <code>type = "surface"</code>.</p>
</td></tr>
<tr><td><code id="plot.BiCop_+3A_size">size</code></td>
<td>
<p>integer; only relevant for types <code>"contour"</code> and
<code>"surface"</code>; the plot is based on values on a <code class="reqn">size x size</code> grid;
default is 100 for <code>type = "contour"</code>, and 25 for <code>type = "surface"</code>.</p>
</td></tr>
<tr><td><code id="plot.BiCop_+3A_...">...</code></td>
<td>
<p>optional arguments passed to <code><a href="graphics.html#topic+contour">contour()</a></code> or
<code><a href="lattice.html#topic+wireframe">wireframe()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCop">BiCop()</a></code>, <code><a href="graphics.html#topic+contour">contour()</a></code>, <code><a href="lattice.html#topic+wireframe">wireframe()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## construct BiCop object for a Tawn copula
obj &lt;- BiCop(family = 104, par = 2.5, par2 = 0.4)

## plots
plot(obj)  # surface plot of copula density
contour(obj)  # contour plot with standard normal margins
contour(obj, margins = "unif")  # contour plot of copula density

</code></pre>

<hr>
<h2 id='pobs'>Pseudo-Observations</h2><span id='topic+pobs'></span>

<h3>Description</h3>

<p>Compute the pseudo-observations for the given data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pobs(
  x,
  na.last = "keep",
  ties.method = eval(formals(rank)$ties.method),
  lower.tail = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pobs_+3A_x">x</code></td>
<td>
<p><code class="reqn">n\times d</code>-matrix of random variates to be converted to
pseudo-observations.</p>
</td></tr>
<tr><td><code id="pobs_+3A_na.last">na.last</code>, <code id="pobs_+3A_ties.method">ties.method</code></td>
<td>
<p>are passed to <code><a href="base.html#topic+rank">rank()</a></code>; see there.</p>
</td></tr>
<tr><td><code id="pobs_+3A_lower.tail">lower.tail</code></td>
<td>
<p><code><a href="base.html#topic+logical">logical()</a></code> which, if <code>FALSE</code>, returns the
pseudo-observations when applying the empirical marginal survival functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">n</code> realizations
<code class="reqn">\bm{x}_i=(x_{i1},\dots,x_{id})^T</code>,
<code class="reqn">i\in\{1,\dots,n\}</code> of a random vector <code class="reqn">\bm{X}</code>,
the pseudo-observations are defined via <code class="reqn">u_{ij}=r_{ij}/(n+1)</code> for
<code class="reqn">i\in\{1,\dots,n\}</code> and <code class="reqn">j\in\{1,\dots,d\}</code>, where <code class="reqn">r_{ij}</code> denotes the rank of <code class="reqn">x_{ij}</code> among all
<code class="reqn">x_{kj}</code>, <code class="reqn">k\in\{1,\dots,n\}</code>.  The
pseudo-observations can thus also be computed by component-wise applying the
empirical distribution functions to the data and scaling the result by
<code class="reqn">n/(n+1)</code>.  This asymptotically negligible scaling factor is used to
force the variates to fall inside the open unit hypercube, for example, to
avoid problems with density evaluation at the boundaries. Note that
<code>pobs(, lower.tail=FALSE)</code> simply returns <code>1-pobs()</code>.
</p>


<h3>Value</h3>

<p>matrix of the same dimensions as <code>x</code> containing the
pseudo-observations.
</p>


<h3>Note</h3>

<p>This function is adapted from the <code><a href="copula.html#topic+pobs">copula()</a></code> package.
</p>


<h3>Author(s)</h3>

<p>Marius Hofert, Thomas Nagler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simple definition of the function:
pobs

## simulate data from a multivariate normal distribution
library(mvtnorm)
set.seed(123)
Sigma &lt;- matrix(c(2, 1, -0.2, 1, 1, 0.3, -0.2, 0.3, 0.5), 3, 3)
mu &lt;- c(-3, 2, 1)
dat &lt;- rmvnorm(500, sigma = Sigma)
pairs(dat)  # plot observations

## compute pseudo-observations for copula inference
udat &lt;- pobs(dat)
pairs(udat)
# estimate vine copula model
fit &lt;- RVineStructureSelect(udat, familyset = c(1, 2))

</code></pre>

<hr>
<h2 id='RVineAIC'>AIC and BIC of an R-Vine Copula Model</h2><span id='topic+RVineAIC'></span><span id='topic+RVineBIC'></span>

<h3>Description</h3>

<p>These functions calculate the Akaike and Bayesian Information criteria of a
d-dimensional R-vine copula model for a given copula data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineAIC(data, RVM, par = RVM$par, par2 = RVM$par2)

RVineBIC(data, RVM, par = RVM$par, par2 = RVM$par2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineAIC_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineAIC_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object including the structure and
the pair-copula families and parameters.</p>
</td></tr>
<tr><td><code id="RVineAIC_+3A_par">par</code></td>
<td>
<p>A d x d matrix with the pair-copula parameters (optional;
default: <code>par = RVM$par</code>).</p>
</td></tr>
<tr><td><code id="RVineAIC_+3A_par2">par2</code></td>
<td>
<p>A d x d matrix with the second parameters of pair-copula
families with two parameters (optional; default: <code>par2 = RVM$par2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">k</code> denotes the number of parameters of an R-vine copula model with
log-likelihood <code class="reqn">l_{RVine}</code> and parameter set
<code class="reqn">\boldsymbol{\theta}</code>, then the Akaike Information Criterion (AIC)
by Akaike (1973) is defined as
</p>
<p style="text-align: center;"><code class="reqn">AIC := -2 l_{RVine}\left(\boldsymbol{\theta}|\boldsymbol{u}\right) +
2 k,</code>
</p>
<p>  for observations
<code class="reqn">\boldsymbol{u}=(\boldsymbol{u}_1^\prime,...,
\boldsymbol{u}_N^\prime)^\prime</code>.
</p>
<p>Similarly, the Bayesian Information Criterion (BIC) by Schwarz (1978) is
given by </p>
<p style="text-align: center;"><code class="reqn"> BIC := -2
l_{RVine}\left(\boldsymbol{\theta}|\boldsymbol{u}\right) + \log(N) k. </code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>AIC</code>, <code>BIC</code></td>
<td>
<p>The computed AIC or BIC value, respectively.</p>
</td></tr>
<tr><td><code>pair.AIC</code>, <code>pair.BIC</code></td>
<td>
<p>A d x d matrix of individual contributions to the
AIC or BIC value for each pair-copula, respectively. Note: <code>AIC = sum(pair.AIC)</code> and similarly <code>BIC = sum(pair.BIC)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eike Brechmann
</p>


<h3>References</h3>

<p>Akaike, H. (1973). Information theory and an extension of the
maximum likelihood principle. In B. N. Petrov and F. Csaki (Eds.),
Proceedings of the Second International Symposium on Information Theory
Budapest, Akademiai Kiado, pp. 267-281.
</p>
<p>Schwarz, G. E. (1978). Estimating the dimension of a model. Annals of
Statistics 6 (2), 461-464.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineLogLik">RVineLogLik()</a></code>, <code><a href="#topic+RVineVuongTest">RVineVuongTest()</a></code>,
<code><a href="#topic+RVineClarkeTest">RVineClarkeTest()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family, par = par, par2 = par2,
                   names=c("V1", "V2", "V3", "V4", "V5"))

# simulate a sample of size 300 from the R-vine copula model
set.seed(123)
simdata &lt;- RVineSim(300,RVM)

# compute AIC and BIC
RVineAIC(simdata, RVM)
RVineBIC(simdata, RVM)

</code></pre>

<hr>
<h2 id='RVineClarkeTest'>Clarke Test Comparing Two R-Vine Copula Models</h2><span id='topic+RVineClarkeTest'></span>

<h3>Description</h3>

<p>This function performs a Clarke test between two d-dimensional R-vine copula
models as specified by their <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineClarkeTest(data, RVM1, RVM2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineClarkeTest_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineClarkeTest_+3A_rvm1">RVM1</code>, <code id="RVineClarkeTest_+3A_rvm2">RVM2</code></td>
<td>
<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> objects of models 1 and 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test proposed by Clarke (2007) allows to compare non-nested models. For
this let <code class="reqn">c_1</code> and <code class="reqn">c_2</code> be two competing vine copulas in terms of
their densities and with estimated parameter sets
<code class="reqn">\hat{\boldsymbol{\theta}}_1</code> and
<code class="reqn">\hat{\boldsymbol{\theta}}_2</code>. The null hypothesis of
statistical indistinguishability of the two models is </p>
<p style="text-align: center;"><code class="reqn"> </code>
</p>
<p style="text-align: center;"><code class="reqn">H_0: P(m_i &gt; 0) = 0.5\ \forall i=1,..,N, </code>
</p>
<p> where
<code class="reqn">m_i:=\log\left[\frac{c_1(\boldsymbol{u}_i|\hat{\boldsymbol{\theta}}_1)}{c_2(\boldsymbol{u}_i|\hat{\boldsymbol{\theta}}_2)}\right]</code> for observations
<code class="reqn">\boldsymbol{u}_i,\ i=1,...,N</code>.
</p>
<p>Since under statistical equivalence of the two models the log likelihood
ratios of the single observations are uniformly distributed around zero and
in expectation <code class="reqn">50\%</code> of the log likelihood ratios greater than zero,
the test statistic </p>
<p style="text-align: center;"><code class="reqn"> </code>
</p>
<p style="text-align: center;"><code class="reqn">\texttt{statistic} := B = \sum_{i=1}^N
\mathbf{1}_{(0,\infty)}(m_i), </code>
</p>
<p> where <code class="reqn">\mathbf{1}</code> is the indicator function,
is distributed Binomial with parameters <code class="reqn">N</code> and <code class="reqn">p=0.5</code>, and
critical values can easily be obtained. Model 1 is interpreted as
statistically equivalent to model 2 if <code class="reqn">B</code> is not significantly
different from the expected value <code class="reqn">Np = \frac{N}{2}</code>.
</p>
<p>Like AIC and BIC, the Clarke test statistic may be corrected for the number
of parameters used in the models. There are two possible corrections; the
Akaike and the Schwarz corrections, which correspond to the penalty terms in
the AIC and the BIC, respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>statistic</code>, <code>statistic.Akaike</code>, <code>statistic.Schwarz</code></td>
<td>
<p>Test
statistics without correction, with Akaike correction and with Schwarz
correction.</p>
</td></tr> <tr><td><code>p.value</code>, <code>p.value.Akaike</code>, <code>p.value.Schwarz</code></td>
<td>
<p>P-values of
tests without correction, with Akaike correction and with Schwarz
correction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey Dissmann, Eike Brechmann
</p>


<h3>References</h3>

<p>Clarke, K. A. (2007). A Simple Distribution-Free Test for
Nonnested Model Selection. Political Analysis, 15, 347-363.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineVuongTest">RVineVuongTest()</a></code>, <code><a href="#topic+RVineAIC">RVineAIC()</a></code>,
<code><a href="#topic+RVineBIC">RVineBIC()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# vine structure selection time-consuming (~ 20 sec)

# load data set
data(daxreturns)


# select the R-vine structure, families and parameters
RVM &lt;- RVineStructureSelect(daxreturns[,1:5], c(1:6))
RVM$Matrix
RVM$par
RVM$par2

# select the C-vine structure, families and parameters
CVM &lt;- RVineStructureSelect(daxreturns[,1:5], c(1:6), type = "CVine")
CVM$Matrix
CVM$par
CVM$par2

# compare the two models based on the data
clarke &lt;- RVineClarkeTest(daxreturns[,1:5], RVM, CVM)
clarke$statistic
clarke$statistic.Schwarz
clarke$p.value
clarke$p.value.Schwarz

</code></pre>

<hr>
<h2 id='RVineCopSelect'>Sequential Pair-Copula Selection and Estimation for R-Vine Copula Models</h2><span id='topic+RVineCopSelect'></span>

<h3>Description</h3>

<p>This function fits a R-vine copula model to a d-dimensional copula data set.
Pair-copula families are selected using <code><a href="#topic+BiCopSelect">BiCopSelect()</a></code> and
estimated sequentially.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineCopSelect(
  data,
  familyset = NA,
  Matrix,
  selectioncrit = "AIC",
  indeptest = FALSE,
  level = 0.05,
  trunclevel = NA,
  weights = NA,
  rotations = TRUE,
  se = FALSE,
  presel = TRUE,
  method = "mle",
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineCopSelect_+3A_data">data</code></td>
<td>
<p>N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_familyset">familyset</code></td>
<td>
<p>integer vector of pair-copula families to select from.
The vector has to include at least one
pair-copula family that allows for positive and one that allows for negative
dependence. Not listed copula families might be included to better handle
limit cases.  If <code>familyset = NA</code> (default), selection among all
possible families is performed. If a vector of negative numbers is provided,
selection among all but <code>abs(familyset)</code> is performed. Coding of
pair copula families is the same as in <code><a href="#topic+BiCop">BiCop()</a></code>.</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_matrix">Matrix</code></td>
<td>
<p>lower or upper triangular d x d matrix that defines the R-vine
tree structure.</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_selectioncrit">selectioncrit</code></td>
<td>
<p>Character indicating the criterion for pair-copula
selection. Possible choices: <code>selectioncrit = "AIC"</code> (default),
<code>"BIC"</code>, or <code>"logLik"</code> (see <code><a href="#topic+BiCopSelect">BiCopSelect()</a></code>).</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_indeptest">indeptest</code></td>
<td>
<p>Logical; whether a hypothesis test for the independence of
<code>u1</code> and <code>u2</code> is performed before bivariate copula selection
(default: <code>indeptest = FALSE</code>; see <code><a href="#topic+BiCopIndTest">BiCopIndTest()</a></code>).  The
independence copula is chosen for a (conditional) pair if the null
hypothesis of independence cannot be rejected.</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_level">level</code></td>
<td>
<p>numeric; significance level of the independence test (default:
<code>level = 0.05</code>).</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_trunclevel">trunclevel</code></td>
<td>
<p>integer; level of truncation.</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_weights">weights</code></td>
<td>
<p>Numerical; weights for each observation (optional).</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_rotations">rotations</code></td>
<td>
<p>logical; if <code>TRUE</code>, all rotations of the families in
<code>familyset</code> are included.</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_se">se</code></td>
<td>
<p>Logical; whether standard errors are estimated (default: <code>se = FALSE</code>).</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_presel">presel</code></td>
<td>
<p>Logical; whether to exclude families before fitting based on
symmetry properties of the data. Makes the selection about 30\
(on average), but may yield slightly worse results in few special cases.</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_method">method</code></td>
<td>
<p>indicates the estimation method: either maximum
likelihood estimation (<code>method = "mle"</code>; default) or inversion of
Kendall's tau (<code>method = "itau"</code>). For <code>method = "itau"</code> only
one parameter families and the Student t copula can be used (<code style="white-space: pre;">&#8288;family = 1,2,3,4,5,6,13,14,16,23,24,26,33,34&#8288;</code> or <code>36</code>). For the t-copula,
<code>par2</code> is found by a crude profile likelihood optimization over the
interval (2, 10].</p>
</td></tr>
<tr><td><code id="RVineCopSelect_+3A_cores">cores</code></td>
<td>
<p>integer; if <code>cores &gt; 1</code>, estimation will be parallelized
within each tree (using <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>). Note that
parallelization causes substantial overhead and may be slower than
single-threaded computation when dimension, sample size, or family set are
small or <code>method = "itau"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R-vine copula models with unknown structure can be specified using
<code><a href="#topic+RVineStructureSelect">RVineStructureSelect()</a></code>.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object with the selected families
(<code>RVM$family</code>) as well as sequentially
estimated parameters stored in <code>RVM$par</code> and <code>RVM$par2</code>. The object
is augmented by the following information about the fit:
</p>
<table>
<tr><td><code>se</code>, <code>se2</code></td>
<td>
<p>standard errors for the parameter estimates  (if
<code>se = TRUE</code>; note that these are only approximate since they do not
account for the sequential nature of the estimation,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>logLik</code>, <code>pair.logLik</code></td>
<td>
<p>log likelihood (overall and pairwise)</p>
</td></tr>
<tr><td><code>AIC</code>, <code>pair.AIC</code></td>
<td>
<p>Aikaike's Informaton Criterion (overall and pairwise),</p>
</td></tr>
<tr><td><code>BIC</code>, <code>pair.BIC</code></td>
<td>
<p>Bayesian's Informaton Criterion (overall and pairwise),</p>
</td></tr>
<tr><td><code>emptau</code></td>
<td>
<p>matrix of empirical values of Kendall's tau,</p>
</td></tr>
<tr><td><code>p.value.indeptest</code></td>
<td>
<p>matrix of p-values of the independence test.</p>
</td></tr></table>
<p>#'
</p>


<h3>Note</h3>

<p>For a comprehensive summary of the vine copula model, use
<code>summary(object)</code>; to see all its contents, use <code>str(object)</code>.
</p>


<h3>Author(s)</h3>

<p>Eike Brechmann, Thomas Nagler
</p>


<h3>References</h3>

<p>Brechmann, E. C., C. Czado, and K. Aas (2012). Truncated regular
vines in high dimensions with applications to financial data. Canadian
Journal of Statistics 40 (1), 68-85.
</p>
<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka (2013).
Selecting and estimating regular vine copulae and application to financial
returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="#topic+BiCop">BiCop()</a></code>,
<code><a href="#topic+BiCopSelect">BiCopSelect()</a></code>,
<code><a href="#topic+plot.RVineMatrix">plot.RVineMatrix()</a></code>,
<code><a href="#topic+contour.RVineMatrix">contour.RVineMatrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)
# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)
# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)
# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

## define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

## simulate a sample of size 500 from the R-vine copula model
set.seed(123)
simdata &lt;- RVineSim(500, RVM)

## determine the pair-copula families and parameters
RVM1 &lt;- RVineCopSelect(simdata, familyset = c(1, 3, 4, 5 ,6), Matrix)

## see the object's content or a summary
str(RVM1)
summary(RVM1)

## inspect the fitted model using plots
## Not run: plot(RVM1)  # tree structure

contour(RVM1)  # contour plots of all pair-copulas

</code></pre>

<hr>
<h2 id='RVineCor2pcor'>(Partial) Correlations for R-Vine Copula Models</h2><span id='topic+RVineCor2pcor'></span><span id='topic+RVinePcor2cor'></span>

<h3>Description</h3>

<p>Correlations to partial correlations and vice versa for R-vines with
independence, Gaussian and t-copulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineCor2pcor(RVM, corMat)

RVinePcor2cor(RVM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineCor2pcor_+3A_rvm">RVM</code></td>
<td>
<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> defining only the R-vine structure for
<code>Cor2pcor</code> and providing as well the partial correlations for
<code>Pcor2cor</code>.</p>
</td></tr>
<tr><td><code id="RVineCor2pcor_+3A_cormat">corMat</code></td>
<td>
<p>correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>RVM</code></td>
<td>
<p>RVineMatrix with transformed partial correlations (for
<code>Cor2pcor</code>)</p>
</td></tr> <tr><td><code>cor</code></td>
<td>
<p>correlation matrix (for <code>Pcor2cor</code>)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The behavior of <code>RVinePcor2ccor</code> differs from older versions (&lt;=
1.4). The RVM object is now normalized such that the order of the returned
correlation matrix conforms with the correlation matrix of the data. If
<code>RVM$names</code> are non-default, the initial ordering of the variables
cannot be traced back and the matrix has to be interpreted as indicated by
the row- and column names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## create RVineMatrix-object for Gaussian vine
Matrix &lt;- matrix(c(1, 3, 4, 2,
                   0, 3, 4, 2,
                   0, 0, 4, 2,
                   0, 0, 0, 2), 4, 4)
family &lt;- matrix(c(0, 1, 1, 1,
                   0, 0, 1, 1,
                   0, 0, 0, 1,
                   0, 0, 0, 0), 4, 4)
par &lt;- matrix(c(0, 0.2,   0, 0.6,
                0,   0, 0.2, 0.6,
                0,   0,   0, 0.6,
                0,   0,   0,   0), 4, 4)
RVM &lt;- RVineMatrix(Matrix, family, par)

## calculate correlation matrix corresponding to the R-Vine model
newcor &lt;- RVinePcor2cor(RVM)

## transform back to partial correlations
RVineCor2pcor(RVM, newcor)$par

## check if they are equal
all.equal(RVM$par, RVineCor2pcor(RVM, newcor)$par)

</code></pre>

<hr>
<h2 id='RVineGofTest'>Goodness-of-Fit Tests for R-Vine Copula Models</h2><span id='topic+RVineGofTest'></span>

<h3>Description</h3>

<p>This function performs a goodness-of-fit test for R-vine copula models.
There are 15 different goodness-of-fit tests implemented, described in
Schepsmeier (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineGofTest(
  data,
  RVM,
  method = "White",
  statistic = "CvM",
  B = 200,
  alpha = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineGofTest_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineGofTest_+3A_rvm">RVM</code></td>
<td>
<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> objects of the R-vine model under the
null hypothesis. <br />
Only the following copula families are allowed in
<code>RVM$family</code> due to restrictions in <code><a href="#topic+RVineGrad">RVineGrad()</a></code> and
<code><a href="#topic+RVineHessian">RVineHessian()</a></code> <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula)<br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; &ldquo;survival Joe&rdquo;) <br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="RVineGofTest_+3A_method">method</code></td>
<td>
<p>A string indicating the goodness-of-fit method:<br />
<code>"White"</code> = goodness-of-fit test based on White's information matrix
equality (default) <br />
<code>"IR"</code> = goodness-of-fit test based on the
information ratio <br />
<code>"Breymann"</code> = goodness-of-fit test based on the
probability integral transform (PIT) and the aggregation to univariate data
by Breymann et al. (2003). <br />
<code>"Berg"</code> = goodness-of-fit test based on
the probability integral transform (PIT) and the aggregation to univariate
data by Berg and Bakken (2007). <br />
<code>"Berg2"</code> = second goodness-of-fit
test based on the probability integral transform (PIT) and the aggregation
to univariate data by Berg and Bakken (2007). <br />
<code>"ECP"</code> =
goodness-of-fit test based on the empirical copula process (ECP) <br />
<code>"ECP2"</code> = goodness-of-fit test based on the combination of probability
integral transform (PIT) and empirical copula process (ECP) (Genest et al.
2009) <br /></p>
</td></tr>
<tr><td><code id="RVineGofTest_+3A_statistic">statistic</code></td>
<td>
<p>A string indicating the goodness-of-fit test statistic
type:<br /> <code>"CvM"</code> = Cramer-von Mises test statistic (univariate for
<code>"Breymann"</code>, <code>"Berg"</code> and <code>"Berg2"</code>, multivariate for
<code>"ECP"</code> and <code>"ECP2"</code>) <br /> <code>"KS"</code> = Kolmogorov-Smirnov test
statistic (univariate for <code>"Breymann"</code>, <code>"Berg"</code> and
<code>"Berg2"</code>, multivariate for <code>"ECP"</code> and <code>"ECP2"</code>) <br />
<code>"AD"</code> = Anderson-Darling test statistic (only univariate for
<code>"Breymann"</code>, <code>"Berg"</code> and <code>"Berg2"</code>)</p>
</td></tr>
<tr><td><code id="RVineGofTest_+3A_b">B</code></td>
<td>
<p>an integer for the number of bootstrap steps (default <code>B = 200</code>)<br />
For <code>B = 0</code> the asymptotic p-value is returned if available,
otherwise only the test statistic is returned.<br />
WARNING: If <code>B</code> is chosen too large, computations will take very long.</p>
</td></tr>
<tr><td><code id="RVineGofTest_+3A_alpha">alpha</code></td>
<td>
<p>an integer of the set <code style="white-space: pre;">&#8288;2,4,6,...&#8288;</code> for the <code>"Berg2"</code>
goodness-of-fit test (default <code>alpha = 2</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method = "White"</code>: <br />
This goodness-of fit test uses the information
matrix equality of White (1982) and was original investigated by Huang and
Prokhorov (2011) for copulas. <br />
Schepsmeier (2012) enhanced their approach
to the vine copula case. <br />
The main contribution is that under correct
model specification the Fisher Information can be equivalently calculated as
minus the expected Hessian matrix or as the expected outer product of the
score function.
The null hypothesis is
</p>
<p style="text-align: center;"><code class="reqn"> H_0: \boldsymbol{H}(\theta) + \boldsymbol{C}(\theta) = 0 </code>
</p>

<p>against the alternative
</p>
<p style="text-align: center;"><code class="reqn"> H_1: \boldsymbol{H}(\theta) +
\boldsymbol{C}(\theta) \neq 0 , </code>
</p>

<p>where
<code class="reqn">\boldsymbol{H}(\theta)</code> is the expected Hessian matrix and
<code class="reqn">\boldsymbol{C}(\theta)</code> is the expected outer product of the
score function. <br />
For the calculation of the test statistic we use the
consistent maximum likelihood estimator <code class="reqn">\hat{\theta}</code> and the sample
counter parts of <code class="reqn">\boldsymbol{H}(\theta)</code> and
<code class="reqn">\boldsymbol{C}(\theta)</code>. <br />
The correction of the
Covariance-Matrix in the test statistic for the uncertainty in the margins
is skipped. The implemented test assumes that there is no uncertainty in the
margins. The correction can be found in Huang and Prokhorov (2011) for
bivariate copulas and in Schepsmeier (2013) for vine copulas. It involves
multi-dimensional integrals. <br />
</p>
<p><code>method = "IR"</code>: <br />
As the White test the information matrix ratio
test is based on the expected Hessian matrix
<code class="reqn">\boldsymbol{H}(\theta)</code>
and the expected outer product of
the score function <code class="reqn">\boldsymbol{C}(\theta)</code>. <br />
</p>
<p style="text-align: center;"><code class="reqn"> H_0:-\boldsymbol{H}(\theta)^{-1}\boldsymbol{C}(\theta) = I_{p} </code>
</p>

<p>against the alternative
</p>
<p style="text-align: center;"><code class="reqn"> H_1:
-\boldsymbol{H}(\theta)^{-1}\boldsymbol{C}(\theta) \neq I_{p} . </code>
</p>

<p>The test statistic can then be calculated as
</p>
<p style="text-align: center;"><code class="reqn"> IR_n:=tr(\Phi(\theta))/p </code>
</p>
<p> with
<code class="reqn">\Phi(\theta)=-\boldsymbol{H}(\theta)^{-1}\boldsymbol{C}(\theta)</code>,
<code class="reqn">p</code> is the number of parameters, i.e. the length of <code class="reqn">\theta</code>, and
<code class="reqn">tr(A)</code> is the trace of the matrix <code class="reqn">A</code> <br />
For details see Schepsmeier (2013) <br />
</p>
<p><code>method = "Breymann"</code>, <code>method = "Berg"</code> and <code>method = "Berg2"</code>: <br />
These tests are based on the multivariate probability integral
transform (PIT) applied in <code><a href="#topic+RVinePIT">RVinePIT()</a></code>. The multivariate data
<code class="reqn">y_{i}</code> returned form the PIT are aggregated to univariate data by
different aggregation functions <code class="reqn">\Gamma(\cdot)</code> in the sum </p>
<p style="text-align: center;"><code class="reqn">
s_t=\sum_{i=1}^d \Gamma(y_{it}), t=1,...,n </code>
</p>
<p>.
In Breymann et al. (2003) the weight function is suggested as
<code class="reqn">\Gamma(\cdot)=\Phi^{-1}(\cdot)^2</code>, while in
Berg and Bakken (2007) the weight function is either
<code class="reqn">\Gamma(\cdot)=|\cdot-0.5|</code> (<code>method="Berg"</code>) or
<code class="reqn">\Gamma(\cdot)=(\cdot-0.5)^{\alpha},\alpha=2,4,6,...</code>
(<code>method="Berg2"</code>). <br /> Furthermore, the <code>"Berg"</code> and
<code>"Berg2"</code> test are based on the order statistics of the PIT returns.
<br /> See Berg and Bakken (2007) or Schepsmeier (2013) for details. <br />
</p>
<p><code>method = "ECP"</code> and <code>method = "ECP2"</code>: <br />
Both tests are test
for <code class="reqn">H_0: C \in C_0</code> against <code class="reqn">H_1: C \notin C_0</code> where C denotes the
(vine) copula distribution function and <code class="reqn">C_0</code> is a class of parametric
(vine) copulas with <code class="reqn">\Theta\subseteq R^p</code> being the parameter space of
dimension p. They are based on the empirical copula process (ECP)
</p>
<p style="text-align: center;"><code class="reqn">
\hat{C}_n(u)-C_{\hat{\theta}_n}(u), </code>
</p>

<p>with
<code class="reqn">u=(u_1,\ldots,u_d)\in[0,1]^d</code> and
<code class="reqn">\hat{C}_n(u) =
\frac{1}{n+1}\sum_{t=1}^n \boldsymbol{1}_{\{U_{t1}\leq u_1,\ldots,U_{td}\leq
u_d \}} </code>.
The ECP is utilized in a multivariate
Cramer-von Mises (CvM) or multivariate Kolmogorov-Smirnov (KS) based test
statistic. An extension of the ECP-test is the combination of the
multivariate PIT approach with the ECP. The general idea is that the
transformed data of a multivariate PIT should be &quot;close&quot; to the independence
copula Genest et al. (2009). Thus a distance of CvM or KS type between them
is considered. This approach is called ECP2. Again we refer to Schepsmeier
(2013) for details.
</p>


<h3>Value</h3>

<p>For <code>method = "White"</code>:
</p>
<table>
<tr><td><code>White</code></td>
<td>
<p>test statistic</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value, either asymptotic for <code>B = 0</code> or bootstrapped
for <code>B &gt; 0</code></p>
</td></tr>
</table>
<p>For <code>method = "IR"</code>:
</p>
<table>
<tr><td><code>IR</code></td>
<td>
<p>test statistic (raw version as stated above)</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>So far no p-value is returned nigher a asymptotic nor a
bootstrapped one. How to calculated a bootstrapped p-value is explained in
Schepsmeier (2013). Be aware, that the test statistics than have to be adjusted
with the empirical variance.</p>
</td></tr>
</table>
<p>For <code>method = "Breymann"</code>, <code>method = "Berg"</code>
and <code>method = "Berg2"</code>:
</p>
<table>
<tr><td><code>CvM</code>, <code>KS</code>, <code>AD</code></td>
<td>
<p>test statistic according to
the choice of <code>statistic</code></p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p-value, either asymptotic
for <code>B = 0</code> or bootstrapped for <code>B &gt; 0</code>.  A asymptotic p-value is
only available for the Anderson-Darling test statistic if the R-package
<code>ADGofTest</code> is loaded. <br />
Furthermore, a asymptotic p-value can be
calculated for the Kolmogorov-Smirnov test statistic. For the Cramer-von
Mises no asymptotic p-value is available so far.</p>
</td></tr>
</table>
<p>For <code>method = "ECP"</code> and <code>method = "ECP2"</code>:
</p>
<table>
<tr><td><code>CvM</code>, <code>KS</code></td>
<td>
<p>test statistic according to the
choice of <code>statistic</code></p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>bootstrapped p-value</p>
</td></tr> </table>
<p><br />
Warning: The code for all the p-values are not yet approved since some of them are
moved from R-code to C-code. If you need p-values the best way is to write your own
algorithm as suggested in Schepsmeier (2013) to get bootstrapped p-values.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Berg, D. and H. Bakken (2007) A copula goodness-of-fit approach
based on the conditional probability integral transformation.
<a href="https://www.danielberg.no/publications/Btest.pdf">https://www.danielberg.no/publications/Btest.pdf</a>
</p>
<p>Breymann, W., A. Dias and P. Embrechts (2003) Dependence structures for
multivariate high-frequency data in finance. Quantitative Finance 3, 1-14
</p>
<p>Genest, C., B. Remillard, and D. Beaudoin (2009) Goodness-of-fit tests for
copulas: a review and power study.  Insur. Math. Econ. 44, 199-213.
</p>
<p>Huang, w. and A. Prokhorov (2011). A goodness-of-fit test for copulas. to
appear in Econometric Reviews
</p>
<p>Schepsmeier, U. (2013) A goodness-of-fit test for regular vine copula
models.  Preprint <a href="https://arxiv.org/abs/1306.0818">https://arxiv.org/abs/1306.0818</a>
</p>
<p>Schepsmeier, U. (2015) Efficient information based goodness-of-fit tests for
vine copula models with fixed margins. Journal of Multivariate Analysis 138,
34-52.
</p>
<p>White, H. (1982) Maximum likelihood estimation of misspecified models,
Econometrica, 50, 1-26.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopGofTest">BiCopGofTest()</a></code>, <code><a href="#topic+RVinePIT">RVinePIT()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## time-consuming example

# load data set
data(daxreturns)

# select the R-vine structure, families and parameters
RVM &lt;- RVineStructureSelect(daxreturns[,1:5], c(1:6))

# White test with asymptotic p-value
RVineGofTest(daxreturns[,1:5], RVM, B = 0)

# ECP2 test with Cramer-von-Mises test statistic and a bootstrap
# with 200 replications for the calculation of the p-value
RVineGofTest(daxreturns[,1:5], RVM, method = "ECP2",
             statistic = "CvM", B = 200)


</code></pre>

<hr>
<h2 id='RVineGrad'>Gradient of the Log-Likelihood of an R-Vine Copula Model</h2><span id='topic+RVineGrad'></span>

<h3>Description</h3>

<p>This function calculates the gradient of the log-likelihood of a
d-dimensional R-vine copula model with respect to the copula parameter and
evaluates it on a given copula data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineGrad(
  data,
  RVM,
  par = RVM$par,
  par2 = RVM$par2,
  start.V = NA,
  posParams = (RVM$family &gt; 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineGrad_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineGrad_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object including the structure and
the pair-copula families and parameters. <br />
Only the following copula
families are allowed in <code>RVM$family</code> <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula)<br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; &ldquo;survival Joe&rdquo;) <br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="RVineGrad_+3A_par">par</code></td>
<td>
<p>A d x d matrix with the pair-copula parameters (optional;
default: <code>par = RVM$par</code>).</p>
</td></tr>
<tr><td><code id="RVineGrad_+3A_par2">par2</code></td>
<td>
<p>A d x d matrix with the second parameters of pair-copula
families with two parameters (optional; default: <code>par2 = RVM$par2</code>).</p>
</td></tr>
<tr><td><code id="RVineGrad_+3A_start.v">start.V</code></td>
<td>
<p>Transformations (h-functions and log-likelihoods of each
pair-copula) of previous calculations (see output; default: <code>start.V = NA</code>).</p>
</td></tr>
<tr><td><code id="RVineGrad_+3A_posparams">posParams</code></td>
<td>
<p>A d x d matrix indicating which copula has to be considered
in the gradient (default: <code>posParams = (RVM$family &gt; 0)</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ordering of the gradient is due to the ordering of the R-vine matrix.
The gradient starts at the lower right corner of the R-vine matrix and goes
column by column to the left and up, i.e. the first entry of the gradient is
the last entry of the second last column of the <code>par</code>-matrix followed
by the last entry of the third last column and the second last entry of this
column. If there is a copula family with two parameters, i.e. the t-copula,
the derivative with respect to the second parameter is at the end of the
gradient vector in order of their occurrence.
</p>


<h3>Value</h3>

<p>gradient The calculated gradient of the log-likelihood value
of the R-vine copula model. (three matrices: <code>direct</code>, <code>indirect</code>
and <code>value</code>).
</p>


<h3>Note</h3>

<p>The gradient for R-vine copula models with two parameter Archimedean
copulas, i.e. BB1, BB6, BB7, BB8 and their rotated versions can not yet be calculated.
The derivatives of these bivariate copulas are more complicated.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Jakob Stoeber
</p>


<h3>References</h3>

<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka
(2013). Selecting and estimating regular vine copulae and application to
financial returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>
<p>Schepsmeier, U. and J. Stoeber (2014)
Derivatives and Fisher information of bivariate copulas.
Statistical Papers, 55(2), 525-542.
online first: <a href="https://link.springer.com/article/10.1007/s00362-013-0498-x">https://link.springer.com/article/10.1007/s00362-013-0498-x</a>.
</p>
<p>Web supplement: Derivatives and Fisher Information of bivariate copulas.
<a href="https://mediatum.ub.tum.de/node?id=1119201">https://mediatum.ub.tum.de/node?id=1119201</a>
</p>
<p>Stoeber, J. and U. Schepsmeier (2013). Estimating standard errors in regular
vine copula models. Computational Statistics, 28 (6), 2679-2707
<a href="https://link.springer.com/article/10.1007/s00180-013-0423-8#">https://link.springer.com/article/10.1007/s00180-013-0423-8#</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopDeriv">BiCopDeriv()</a></code>,
<code><a href="#topic+BiCopDeriv2">BiCopDeriv2()</a></code>,
<code><a href="#topic+BiCopHfuncDeriv">BiCopHfuncDeriv()</a></code>,
<code><a href="#topic+BiCopHfuncDeriv2">BiCopHfuncDeriv2()</a></code>, <br />
<code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="#topic+RVineMLE">RVineMLE()</a></code>,
<code><a href="#topic+RVineHessian">RVineHessian()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# simulate a sample of size 300 from the R-vine copula model
set.seed(123)
simdata &lt;- RVineSim(300, RVM)

# compute the gradient of the first row of the data
out2 &lt;- RVineGrad(simdata[1,], RVM)
out2$gradient

</code></pre>

<hr>
<h2 id='RVineHessian'>Hessian Matrix of the Log-Likelihood of an R-Vine Copula Model</h2><span id='topic+RVineHessian'></span>

<h3>Description</h3>

<p>This function calculates the Hessian matrix of the log-likelihood of a
d-dimensional R-vine copula model with respect to the copula parameter and
evaluates it on a given copula data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineHessian(data, RVM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineHessian_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineHessian_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object including the structure, the
pair-copula families, and the parameters. <br />
Only the following copula
families are allowed in <code>RVM$family</code> <br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula)<br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; &ldquo;survival Joe&rdquo;) <br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br /></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>hessian</code></td>
<td>
<p>The calculated Hessian matrix of the log-likelihood
value of the R-vine copula model.</p>
</td></tr>
<tr><td><code>der</code></td>
<td>
<p>The product of the gradient
vector with its transposed version.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The Hessian matrix is not available for R-vine copula models with two
parameter Archimedean copulas, i.e. BB1, BB6, BB7, BB8 and their rotated
versions.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Jakob Stoeber
</p>


<h3>References</h3>

<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka
(2013). Selecting and estimating regular vine copulae and application to
financial returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>
<p>Schepsmeier, U. and J. Stoeber (2014)
Derivatives and Fisher information of bivariate copulas.
Statistical Papers, 55(2), 525-542.
online first: <a href="https://link.springer.com/article/10.1007/s00362-013-0498-x">https://link.springer.com/article/10.1007/s00362-013-0498-x</a>.
</p>
<p>Web supplement: Derivatives and Fisher Information of bivariate copulas.
<a href="https://mediatum.ub.tum.de/node?id=1119201">https://mediatum.ub.tum.de/node?id=1119201</a>
</p>
<p>Stoeber, J. and U. Schepsmeier (2013). Estimating standard errors in regular
vine copula models. Computational Statistics, 28 (6), 2679-2707
<a href="https://link.springer.com/article/10.1007/s00180-013-0423-8#">https://link.springer.com/article/10.1007/s00180-013-0423-8#</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopDeriv">BiCopDeriv()</a></code>,
<code><a href="#topic+BiCopDeriv2">BiCopDeriv2()</a></code>,
<code><a href="#topic+BiCopHfuncDeriv">BiCopHfuncDeriv()</a></code>,
<code><a href="#topic+BiCopHfuncDeriv2">BiCopHfuncDeriv2()</a></code>, <br />
<code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="#topic+RVineMLE">RVineMLE()</a></code>,
<code><a href="#topic+RVineGrad">RVineGrad()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# simulate a sample of size 300 from the R-vine copula model
set.seed(123)
simdata &lt;- RVineSim(300, RVM)

# compute the Hessian matrix of the first row of the data
out2 &lt;- RVineHessian(simdata[1,], RVM)
out2$hessian

</code></pre>

<hr>
<h2 id='RVineLogLik'>Log-Likelihood of an R-Vine Copula Model</h2><span id='topic+RVineLogLik'></span>

<h3>Description</h3>

<p>This function calculates the log-likelihood of a d-dimensional R-vine copula
model for a given copula data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineLogLik(
  data,
  RVM,
  par = RVM$par,
  par2 = RVM$par2,
  separate = FALSE,
  verbose = TRUE,
  check.pars = TRUE,
  calculate.V = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineLogLik_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineLogLik_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object including the structure and
the pair-copula families and parameters.</p>
</td></tr>
<tr><td><code id="RVineLogLik_+3A_par">par</code></td>
<td>
<p>A d x d matrix with the pair-copula parameters (optional;
default: <code>par = RVM$par</code>).</p>
</td></tr>
<tr><td><code id="RVineLogLik_+3A_par2">par2</code></td>
<td>
<p>A d x d matrix with the second parameters of pair-copula
families with two parameters (optional; default: <code>par2 = RVM$par2</code>).</p>
</td></tr>
<tr><td><code id="RVineLogLik_+3A_separate">separate</code></td>
<td>
<p>Logical; whether log-likelihoods are returned point wisely
(default: <code>separate = FALSE</code>).</p>
</td></tr>
<tr><td><code id="RVineLogLik_+3A_verbose">verbose</code></td>
<td>
<p>In case something goes wrong, additional output will be
plotted.</p>
</td></tr>
<tr><td><code id="RVineLogLik_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
<tr><td><code id="RVineLogLik_+3A_calculate.v">calculate.V</code></td>
<td>
<p>logical; whether V matrices should be calculated. Default
is <code>TRUE</code>, but requires a lot of memory when dimension is large.
Use <code>FALSE</code> for a memory efficient version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For observations
<code class="reqn">\boldsymbol{u}=(\boldsymbol{u}_1^\prime,...,\boldsymbol{u}_N^\prime)^\prime</code>
the log-likelihood of a <code class="reqn">d</code>-dimensional R-vine copula with <code class="reqn">d-1</code>
trees and corresponding edge sets <code class="reqn">E_1,...,E_{d-1}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\texttt{loglik}:=l_{RVine}\left(\boldsymbol{\theta}|\boldsymbol{u}\right)
</code>
</p>

<p style="text-align: center;"><code class="reqn">=\sum_{i=1}^N \sum_{\ell=1}^{d-1} \sum_{e\in E_\ell}
 \ln[c_{j(e),k(e)|D(e)}(F(u_{i,j(e)}|u_{i,D(e)}),F(u_{i,k(e)}|u_{i,D(e)})|\theta_{j(e),k(e)|D(e)})] </code>
</p>

<p>where <code class="reqn">\boldsymbol{u}_i=(u_{i,1},...,u_{i,d})^\prime\in[0,1]^d,\
i=1,...,N</code>. Further
<code class="reqn">c_{j(e),k(e)|D(e)}</code> denotes a bivariate copula density associated to an
edge <code class="reqn">e</code> and with parameter(s)
<code class="reqn">\boldsymbol{\theta}_{j(e),k(e)|D(e)}</code>.
Conditional distribution functions such as
<code class="reqn">F(u_{i,j(e)}|\boldsymbol{u}_{i,D(e)})</code> are
obtained recursively using the relationship
</p>
<p style="text-align: center;"><code class="reqn">h(u|\boldsymbol{v},\boldsymbol{\theta}) := F(u|\boldsymbol{v}) =
d C_{uv_j|v_{-j}}(F(u|v_{-j}),F(v_j|v_{-j}))/d
F(v_j|v_{-j}), </code>
</p>

<p>where
<code class="reqn">C_{uv_j|\boldsymbol{v}_{-j}}</code> is a bivariate copula
distribution function with parameter(s) <code class="reqn">\boldsymbol{\theta}</code>
and <code class="reqn">\boldsymbol{v}_{-j}</code> denotes a vector with the <code class="reqn">j</code>-th
component <code class="reqn">v_j</code> removed. The notation of h-functions is introduced for
convenience. For more details see Dissmann et al. (2013).
</p>


<h3>Value</h3>

<table>
<tr><td><code>loglik</code></td>
<td>
<p>The calculated log-likelihood value of the R-vine
copula model.</p>
</td></tr> <tr><td><code>V</code></td>
<td>
<p>The stored transformations (h-functions and
log-likelihoods of each pair-copula) which may be used for posterior updates
(three matrices: <code>direct</code>, <code>indirect</code> and <code>value</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Jeffrey Dissmann, Jakob Stoeber
</p>


<h3>References</h3>

<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka
(2013). Selecting and estimating regular vine copulae and application to
financial returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopHfunc">BiCopHfunc()</a></code>, <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="#topic+RVineMLE">RVineMLE()</a></code>, <code><a href="#topic+RVineAIC">RVineAIC()</a></code>, <code><a href="#topic+RVineBIC">RVineBIC()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# simulate a sample of size 300 from the R-vine copula model
set.seed(123)
simdata &lt;- RVineSim(300, RVM)

# compute the log-likelihood
ll &lt;- RVineLogLik(simdata, RVM, separate = FALSE)
ll$loglik

# compute the pointwise log-likelihoods
ll &lt;- RVineLogLik(simdata, RVM, separate = TRUE)
ll$loglik

</code></pre>

<hr>
<h2 id='RVineMatrix'>R-Vine Copula Model in Matrix Notation</h2><span id='topic+RVineMatrix'></span>

<h3>Description</h3>

<p>This function creates an <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object which encodes an
R-vine copula model. It contains the matrix identifying the R-vine tree
structure, the matrix identifying the copula families utilized and two
matrices for corresponding parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineMatrix(
  Matrix,
  family = array(0, dim = dim(Matrix)),
  par = array(NA, dim = dim(Matrix)),
  par2 = array(NA, dim = dim(Matrix)),
  names = NULL,
  check.pars = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineMatrix_+3A_matrix">Matrix</code></td>
<td>
<p>Lower (or upper) triangular d x d matrix that defines the
R-vine tree structure.</p>
</td></tr>
<tr><td><code id="RVineMatrix_+3A_family">family</code></td>
<td>
<p>Lower (or upper) triangular d x d matrix with zero diagonal
entries that assigns the pair-copula families to each (conditional) pair
defined by <code>Matrix</code> (default: <code>family = array(0,dim=dim(Matrix))</code>).  The bivariate copula families are defined as
follows:<br />
<code>0</code> = independence copula <br />
<code>1</code> = Gaussian copula <br />
<code>2</code> = Student t copula (t-copula) <br />
<code>3</code> = Clayton copula <br />
<code>4</code> = Gumbel copula <br />
<code>5</code> = Frank copula <br />
<code>6</code> = Joe copula <br />
<code>7</code> = BB1 copula <br />
<code>8</code> = BB6 copula <br />
<code>9</code> = BB7 copula <br />
<code>10</code> = BB8 copula <br />
<code>13</code> = rotated Clayton copula (180 degrees; <code style="white-space: pre;">&#8288;survival Clayton'') \cr `14` = rotated Gumbel copula (180 degrees; &#8288;</code>survival Gumbel&rdquo;) <br />
<code>16</code> = rotated Joe copula (180 degrees; <code style="white-space: pre;">&#8288;survival Joe'') \cr `17` = rotated BB1 copula (180 degrees; &#8288;</code>survival BB1&rdquo;)<br />
<code>18</code> = rotated BB6 copula (180 degrees; <code style="white-space: pre;">&#8288;survival BB6'')\cr `19` = rotated BB7 copula (180 degrees; &#8288;</code>survival BB7&rdquo;)<br />
<code>20</code> = rotated BB8 copula (180 degrees; &ldquo;survival BB8&rdquo;)<br />
<code>23</code> = rotated Clayton copula (90 degrees) <br />
'24' = rotated Gumbel copula (90 degrees) <br />
'26' = rotated Joe copula (90 degrees) <br />
'27' = rotated BB1 copula (90 degrees) <br />
'28' = rotated BB6 copula (90 degrees) <br />
'29' = rotated BB7 copula (90 degrees) <br />
'30' = rotated BB8 copula (90 degrees) <br />
'33' = rotated Clayton copula (270 degrees) <br />
'34' = rotated Gumbel copula (270 degrees) <br />
'36' = rotated Joe copula (270 degrees) <br />
'37' = rotated BB1 copula (270 degrees) <br />
'38' = rotated BB6 copula (270 degrees) <br />
'39' = rotated BB7 copula (270 degrees) <br />
'40' = rotated BB8 copula (270 degrees) <br />
'104' = Tawn type 1 copula <br />
'114' = rotated Tawn type 1 copula (180 degrees) <br />
'124' = rotated Tawn type 1 copula (90 degrees) <br />
'134' = rotated Tawn type 1 copula (270 degrees) <br />
'204' = Tawn type 2 copula <br />
'214' = rotated Tawn type 2 copula (180 degrees) <br />
'224' = rotated Tawn type 2 copula (90 degrees) <br />
'234' = rotated Tawn type 2 copula (270 degrees) <br /></p>
</td></tr>
<tr><td><code id="RVineMatrix_+3A_par">par</code></td>
<td>
<p>Lower (or upper) triangular d x d matrix with zero diagonal
entries that assigns the (first) pair-copula parameter to each (conditional)
pair defined by <code>Matrix</code> <br /> (default: <code>par = array(NA, dim = dim(Matrix))</code>).</p>
</td></tr>
<tr><td><code id="RVineMatrix_+3A_par2">par2</code></td>
<td>
<p>Lower (or upper) triangular d x d matrix with zero diagonal
entries that assigns the second parameter for pair-copula families with two
parameters to each (conditional) pair defined by <code>Matrix</code> (default:
<code>par2 = array(NA, dim = dim(Matrix))</code>).</p>
</td></tr>
<tr><td><code id="RVineMatrix_+3A_names">names</code></td>
<td>
<p>A vector of names for the d variables; default: <code>names = NULL</code>.</p>
</td></tr>
<tr><td><code id="RVineMatrix_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with
care).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>, i.e., a list with the
following components:
</p>
<table>
<tr><td><code>Matrix</code></td>
<td>
<p>R-vine tree structure matrix.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>pair-copula family matrix with values as above.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>pair-copula parameter matrix.</p>
</td></tr>
<tr><td><code>par2</code></td>
<td>
<p>second pair-copula parameter matrix with parameters necessary for
pair-copula families with two parameters.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>variable names (defaults to <code style="white-space: pre;">&#8288;V1, V2, ...&#8288;</code>).</p>
</td></tr>
<tr><td><code>MaxMat</code>, <code>CondDistr</code></td>
<td>
<p>additional matrices required internally for
evaluating the density etc.,</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>the type of the vine copula structure; possible types are:
</p>

<ul>
<li><p><code style="white-space: pre;">&#8288;"C-vine": &#8288;</code>all trees consist of a star,
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;"D-vine": &#8288;</code>all trees consist of a path,
</p>
</li>
<li><p><code style="white-space: pre;">&#8288;"R-vine": &#8288;</code>all structures that are neither a C- nor D-vine,
</p>
</li></ul>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Kendall's tau matrix,</p>
</td></tr>
<tr><td><code>taildep</code></td>
<td>
<p>matrices of lower and upper tail dependence coefficients,</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Blomqvist's beta matrix.</p>
</td></tr>
</table>
<p>Objects of this class are also returned by the <code><a href="#topic+RVineSeqEst">RVineSeqEst()</a></code>,
<code><a href="#topic+RVineCopSelect">RVineCopSelect()</a></code>, and <code><a href="#topic+RVineStructureSelect">RVineStructureSelect()</a></code>
functions. In this case, further information about the fit is added.
</p>


<h3>Note</h3>

<p>For a comprehensive summary of the vine copula model, use
<code>summary(object)</code>; to see all its contents, use <code>str(object)</code>.<br />
The <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> function automatically checks if the given
matrix is a valid R-vine matrix (see <code><a href="#topic+RVineMatrixCheck">RVineMatrixCheck()</a></code>). <br />
Although the function allows upper triangular matrices as its input, it will
always store them as lower triangular matrices.
</p>


<h3>Author(s)</h3>

<p>Jeffrey Dissmann, Thomas Nagler
</p>


<h3>References</h3>

<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka
(2013). Selecting and estimating regular vine copulae and application to
financial returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrixCheck">RVineMatrixCheck()</a></code>,
<code><a href="#topic+RVineSeqEst">RVineSeqEst()</a></code>,
<code><a href="#topic+RVineCopSelect">RVineCopSelect()</a></code>,
<code><a href="#topic+RVineStructureSelect">RVineStructureSelect()</a></code>,
<code><a href="#topic+RVineSim">RVineSim()</a></code>,
<code><a href="#topic+C2RVine">C2RVine()</a></code>,
<code><a href="#topic+D2RVine">D2RVine()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)
# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)
# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)
# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

## define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

## see the object's content or a summary
str(RVM)
summary(RVM)

## inspect the model using plots
## Not run: plot(RVM)  # tree structure
contour(RVM)  # contour plots of all pair-copulas

## simulate from the vine copula model
plot(RVineSim(500, RVM))

</code></pre>

<hr>
<h2 id='RVineMatrixCheck'>R-Vine Matrix Check</h2><span id='topic+RVineMatrixCheck'></span>

<h3>Description</h3>

<p>The given matrix is tested to be a valid R-vine matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineMatrixCheck(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineMatrixCheck_+3A_m">M</code></td>
<td>
<p>A <code class="reqn">dxd</code> vine matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>code</code></td>
<td>
 <p><code>1</code> for OK; <br />
<code>-4</code> matrix is neither lower nor upper triangular;<br />
<code>-3</code> diagonal can not be put in order d:1;<br />
<code>-2</code> for not permutation of j:d in column d-j; <br />
<code>-1</code> if cannot find proper binary array from array in natural order.  </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The matrix M do not have to be given in natural order or the diagonal
in order d:1. The test checks if it can be done in order to be a valid
R-vine matrix. <br /> If a function in this package needs the natural order the
<code>RVineMatrix</code> object is automatically &quot;normalized&quot;. <br /> The function
<code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> automatically checks if the given R-vine matrix is
valid.
</p>


<h3>Author(s)</h3>

<p>Harry Joe
</p>


<h3>References</h3>

<p>Joe H, Cooke RM and Kurowicka D (2011). Regular vines:
generation algorithm and number of equivalence classes. In Dependence
Modeling: Vine Copula Handbook, pp 219&ndash;231. World Scientific, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A1 &lt;- matrix(c(6, 0, 0, 0, 0, 0,
               5, 5, 0, 0, 0, 0,
               3, 4, 4, 0, 0, 0,
               4, 3, 3, 3, 0, 0,
               1, 1, 2, 2, 2, 0,
               2, 2, 1, 1, 1, 1), 6, 6, byrow = TRUE)
b1 &lt;- RVineMatrixCheck(A1)
print(b1)
# improper vine matrix, code=-1
A2 &lt;- matrix(c(6, 0, 0, 0, 0, 0,
               5, 5, 0, 0, 0, 0,
               4, 4, 4, 0, 0, 0,
               1, 3, 3, 3, 0, 0,
               3, 1, 2, 2, 2, 0,
               2, 2, 1, 1, 1,1 ), 6, 6, byrow = TRUE)
b2 &lt;- RVineMatrixCheck(A2)
print(b2)
# improper vine matrix, code=-2
A3 &lt;- matrix(c(6, 0, 0, 0, 0, 0,
               3, 5, 0, 0, 0, 0,
               3, 4, 4, 0, 0, 0,
               4, 3, 3, 3, 0, 0,
               1, 1, 2, 2, 2, 0,
               2, 2, 1, 1, 1, 1), 6, 6, byrow = TRUE)
b3 &lt;- RVineMatrixCheck(A3)
print(b3)

</code></pre>

<hr>
<h2 id='RVineMatrixNormalize'>Normalization of R-Vine Matrix</h2><span id='topic+RVineMatrixNormalize'></span>

<h3>Description</h3>

<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> is permuted to achieve a natural ordering (i.e.
<code>diag(RVM$Matrix) == d:1</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineMatrixNormalize(RVM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineMatrixNormalize_+3A_rvm">RVM</code></td>
<td>
<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> defining the R-vine structure</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> in natural ordering with
entries in <code>RVM$names</code> keeping track of the reordering.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
Matrix &lt;- matrix(c(5, 2, 3, 1, 4,
                   0, 2, 3, 4, 1,
                   0, 0, 3, 4, 1,
                   0, 0, 0, 4, 1,
                   0, 0, 0, 0, 1), 5, 5)
family &lt;- matrix(1,5,5)

par &lt;- matrix(c(0, 0.2, 0.9, 0.5, 0.8,
                0,   0, 0.1, 0.6, 0.9,
                0,   0,   0, 0.7, 0.5,
                0,   0,   0,   0, 0.8,
                0,   0,   0,   0,   0), 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix, family, par)

# normalise the RVine
RVineMatrixNormalize(RVM)

</code></pre>

<hr>
<h2 id='RVineMatrixSample'>Random sampling of R-Vine matrices</h2><span id='topic+RVineMatrixSample'></span>

<h3>Description</h3>

<p>Sample R-Vine matrices based on the algorithm of Joe et al. (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineMatrixSample(d, size = 1, naturalOrder = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineMatrixSample_+3A_d">d</code></td>
<td>
<p>Dimension of the R-Vine matrices.</p>
</td></tr>
<tr><td><code id="RVineMatrixSample_+3A_size">size</code></td>
<td>
<p>Number of matrices to sample.</p>
</td></tr>
<tr><td><code id="RVineMatrixSample_+3A_naturalorder">naturalOrder</code></td>
<td>
<p>Should the matrices be in the natural order
(default: <code>naturalOrder = FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>size</code> with each element containing one
R-Vine matrix.
</p>


<h3>Note</h3>

<p>For some reason, our implementation of Joe et al.'s algorithm always
returns a star in the first tree. To fix this, we sample a vine matrix of
dimension d + 1 and remove the first tree afterwards
</p>


<h3>Author(s)</h3>

<p>Thibault Vatter
</p>


<h3>References</h3>

<p>Joe H, Cooke RM and Kurowicka D (2011). Regular vines:
generation algorithm and number of equivalence classes. In Dependence
Modeling: Vine Copula Handbook, pp 219&ndash;231. World Scientific, Singapore.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>, <code><a href="#topic+RVineMatrixCheck">RVineMatrixCheck()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Matrix and sample sizes
d &lt;- 10
size &lt;- 5

# Sample R-vine matrices
RVM &lt;- RVineMatrixSample(d, size)
sapply(RVM, RVineMatrixCheck)

# Sample R-vine matrices in the natural order
RVM &lt;- RVineMatrixSample(d, size, naturalOrder = TRUE)
sapply(RVM, RVineMatrixCheck)

</code></pre>

<hr>
<h2 id='RVineMLE'>Maximum Likelihood Estimation of an R-Vine Copula Model</h2><span id='topic+RVineMLE'></span>

<h3>Description</h3>

<p>This function calculates the maximum likelihood estimate (MLE) of the
R-vine copula model parameters using sequential estimates as initial values
(if not provided).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineMLE(
  data,
  RVM,
  start = RVM$par,
  start2 = RVM$par2,
  maxit = 200,
  max.df = 30,
  max.BB = list(BB1 = c(5, 6), BB6 = c(6, 6), BB7 = c(5, 6), BB8 = c(6, 1)),
  grad = FALSE,
  hessian = FALSE,
  se = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineMLE_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object including the structure and
the pair-copula families and parameters (if known).</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_start">start</code></td>
<td>
<p>Lower triangular d x d matrix with zero diagonal entries with
starting values for the pair-copula parameters (optional; otherwise they are
calculated via <br /> <code><a href="#topic+RVineSeqEst">RVineSeqEst()</a></code>; default: <code>start = RVM$par</code>).</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_start2">start2</code></td>
<td>
<p>Lower triangular d x d matrix with zero diagonal entries with
starting values for the second parameters of pair-copula families with two
parameters (optional; otherwise they are calculated via
<code><a href="#topic+RVineSeqEst">RVineSeqEst()</a></code>; default: <code>start2 = RVM$par2</code>).</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iteration steps (optional; default:
<code>maxit = 200</code>).</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_max.df">max.df</code></td>
<td>
<p>Numeric; upper bound for the estimation of the degrees of
freedom parameter of the t-copula (default: <code>max.df = 30</code>; for more
details see <code><a href="#topic+BiCopEst">BiCopEst()</a></code>).</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_max.bb">max.BB</code></td>
<td>
<p>List; upper bounds for the estimation of the two parameters
(in absolute values) of the BB1, BB6, BB7 and BB8 copulas <br /> (default:
<code>max.BB = list(BB1=c(5,6),BB6=c(6,6),BB7=c(5,6),BB8=c(6,1))</code>).</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_grad">grad</code></td>
<td>
<p>If RVM$family only contains one parameter copula families or the
t-copula the analytical gradient can be used for maximization of the
log-likelihood (see <code><a href="#topic+RVineGrad">RVineGrad()</a></code>; default: <code>grad = FALSE</code>).</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_hessian">hessian</code></td>
<td>
<p>Logical; whether the Hessian matrix of parameter estimates is
estimated (default: <code>hessian = FALSE</code>). Note that this is not the
Hessian Matrix calculated via <code><a href="#topic+RVineHessian">RVineHessian()</a></code> but via finite
differences.</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_se">se</code></td>
<td>
<p>Logical; whether standard errors of parameter estimates are
estimated on the basis of the Hessian matrix (see above; default: <code>se = FALSE</code>).</p>
</td></tr>
<tr><td><code id="RVineMLE_+3A_...">...</code></td>
<td>
<p>Further arguments for <code>optim</code> (e.g. <code>factr</code> controls
the convergence of the &quot;L-BFGS-B&quot; method, or <code>trace</code>, a non-negative
integer, determines if tracing information on the progress of the
optimization is produced.) <br /> For more details see the documentation of
<code><a href="stats.html#topic+optim">optim()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>RVM</code></td>
<td>
<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object with the calculated
parameters stored in <code>RVM$par</code> and <code>RVM$par2</code>. Additional
information about the fit is added (e.g., log-likelihood, AIC, BIC).</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>Optimized log-likelihood value corresponding to the estimated
pair-copula parameters.</p>
</td></tr> <tr><td><code>convergence</code></td>
<td>
<p>An integer code indicating
either successful convergence (<code>convergence = 0</code>) or an error:<br />
<code>1</code> = the iteration limit <code>maxit</code> has been reached <br /> <code>51</code> =
a warning from the &quot;L-BFGS-B&quot; method; see component <code>message</code> for
further details <br /> <code>52</code> = an error from the &quot;L-BFGS-B&quot; method; see
component <code>message</code> for further details</p>
</td></tr> <tr><td><code>message</code></td>
<td>
<p>A character
string giving any additional information returned by <code><a href="stats.html#topic+optim">optim()</a></code>, or
<code>NULL</code>.</p>
</td></tr> <tr><td><code>counts</code></td>
<td>
<p>A two-element integer vector giving the number
of calls to <code>fn</code> and <code>gr</code> respectively.  This excludes those calls
needed to compute the Hessian, if requested, and any calls to <code>fn</code> to
compute a finite-difference approximation to the gradient.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>If <code>hessian = TRUE</code>, the Hessian matrix is returned. Its
calculation is on the basis of finite differences (output of <code>optim</code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>RVineMLE</code> uses the L-BFGS-B method for optimization. <br /> If the
analytical gradient is used for maximization, computations may be up to 10
times faster than using finite differences.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Jeffrey Dissmann
</p>


<h3>References</h3>

<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka
(2013). Selecting and estimating regular vine copulae and application to
financial returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>
<p>Stoeber, J. and U. Schepsmeier (2013). Estimating standard errors in regular
vine copula models. Computational Statistics, 1-29
<a href="https://link.springer.com/article/10.1007/s00180-013-0423-8#">https://link.springer.com/article/10.1007/s00180-013-0423-8#</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineSeqEst">RVineSeqEst()</a></code>,
<code><a href="#topic+RVineStructureSelect">RVineStructureSelect()</a></code>,
<code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="#topic+RVineGrad">RVineGrad()</a></code>,
<code><a href="#topic+RVineHessian">RVineHessian()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# simulate a sample of size 300 from the R-vine copula model
set.seed(123)
simdata &lt;- RVineSim(300, RVM)

# compute the MLE
mle &lt;- RVineMLE(simdata, RVM, grad = TRUE, trace = 0)

# compare parameters
round(mle$RVM$par - RVM$par, 2)

</code></pre>

<hr>
<h2 id='RVinePar2Beta'>Blomqvist's Beta Values of an R-Vine Copula Model</h2><span id='topic+RVinePar2Beta'></span>

<h3>Description</h3>

<p>This function computes the values of Blomqvist's beta corresponding to the
parameters of an R-vine copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVinePar2Beta(RVM, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVinePar2Beta_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object. <br /> Note that the Student's
t-copula is not allowed since the CDF of the t-copula is not implemented
(see <code><a href="#topic+BiCopCDF">BiCopCDF()</a></code> and <code><a href="#topic+BiCopPar2Beta">BiCopPar2Beta()</a></code>).</p>
</td></tr>
<tr><td><code id="RVinePar2Beta_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with care).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with the same structure as the family and parameter matrices
of the <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object <code>RVM</code> where the entries are
values of Blomqvist's beta corresponding to the families and parameters of
the R-vine copula model given by <code>RVM</code>.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>, <code><a href="#topic+BiCopPar2Beta">BiCopPar2Beta()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# compute the Blomqvist's beta values
BlomBeta &lt;- RVinePar2Beta(RVM)

</code></pre>

<hr>
<h2 id='RVinePar2Tau'>Kendall's Tau Values of an R-Vine Copula Model</h2><span id='topic+RVinePar2Tau'></span>

<h3>Description</h3>

<p>This function computes the values of Kendall's tau corresponding to the
parameters of an R-vine copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVinePar2Tau(RVM, check.pars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVinePar2Tau_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object.</p>
</td></tr>
<tr><td><code id="RVinePar2Tau_+3A_check.pars">check.pars</code></td>
<td>
<p>logical; default is <code>TRUE</code>; if <code>FALSE</code>, checks
for family/parameter-consistency are omitted (should only be used with care).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with the same structure as the family and parameter matrices
of the <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object <code>RVM</code> where the entries are
values of Kendall's tau corresponding to the families and parameters of the
R-vine copula model given by <code>RVM</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey Dissmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>, <code><a href="#topic+BiCopPar2Tau">BiCopPar2Tau()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# compute the Kendall's tau values
tau &lt;- RVinePar2Tau(RVM)

</code></pre>

<hr>
<h2 id='RVinePDF'>PDF of an R-Vine Copula Model</h2><span id='topic+RVinePDF'></span>

<h3>Description</h3>

<p>This function calculates the probability density function of a d-dimensional
R-vine copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVinePDF(newdata, RVM, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVinePDF_+3A_newdata">newdata</code></td>
<td>
<p>An N x d data matrix that specifies where the density shall
be evaluated.</p>
</td></tr>
<tr><td><code id="RVinePDF_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object including the structure and
the pair-copula families and parameters.</p>
</td></tr>
<tr><td><code id="RVinePDF_+3A_verbose">verbose</code></td>
<td>
<p>In case something goes wrong, additional output will be
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density of a <code class="reqn">d</code>-dimensional R-vine copula with <code class="reqn">d-1</code> trees and
corresponding edge sets <code class="reqn">E_1,...,E_{d-1}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\prod_{\ell=1}^{d-1} \prod_{e\in E_\ell }
c_{j(e),k(e)|D(e)}(F(u_{j(e)}|u_{D(e)}),F(u_{k(e)}|u_{D(e)})|\theta_{j(e),k(e)|D(e)}), </code>
</p>

<p>where
<code class="reqn">\boldsymbol{u}=(u_{1},...,u_{d})^\prime\in[0,1]^d</code>.
Further <code class="reqn">c_{j(e),k(e)|D(e)}</code> denotes a bivariate copula density
associated to an edge <code class="reqn">e</code> and with parameter(s)
<code class="reqn">\boldsymbol{\theta}_{j(e),k(e)|D(e)}</code>.
Conditional distribution functions such as
<code class="reqn">F(u_{j(e)}|\boldsymbol{u}_{D(e)})</code> are obtained
recursively using the relationship
</p>
<p style="text-align: center;"><code class="reqn">h(u|\boldsymbol{v},\boldsymbol{\theta}) := F(u|\boldsymbol{v}) =
d C_{uv_j|v_{-j}}(F(u|v_{-j}),F(v_j|v_{-j}))/d F(v_j|v_{-j}),</code>
</p>

<p>where
<code class="reqn">C_{uv_j|\boldsymbol{v}_{-j}}</code> is a bivariate copula
distribution function with parameter(s) <code class="reqn">\boldsymbol{\theta}</code>
and <code class="reqn">\boldsymbol{v}_{-j}</code> denotes a vector with the <code class="reqn">j</code>-th
component <code class="reqn">v_j</code> removed. The notation of h-functions is introduced for
convenience. For more details see Dissmann et al. (2013).
</p>
<p>The function is actually just a wrapper to <code><a href="#topic+RVineLogLik">RVineLogLik()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>References</h3>

<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka
(2013). Selecting and estimating regular vine copulae and application to
financial returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopHfunc">BiCopHfunc()</a></code>, <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="#topic+RVineMLE">RVineMLE()</a></code>, <code><a href="#topic+RVineAIC">RVineAIC()</a></code>, <code><a href="#topic+RVineBIC">RVineBIC()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# compute the density at (0.1, 0.2, 0.3, 0.4, 0.5)
RVinePDF(c(0.1, 0.2, 0.3, 0.4, 0.5), RVM)

</code></pre>

<hr>
<h2 id='RVinePIT'>Probability Integral Transformation for R-Vine Copula Models</h2><span id='topic+RVinePIT'></span>

<h3>Description</h3>

<p>This function applies the probability integral transformation (PIT) for
R-vine copula models to given copula data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVinePIT(data, RVM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVinePIT_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVinePIT_+3A_rvm">RVM</code></td>
<td>
<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> objects of the R-vine model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multivariate probability integral transformation (PIT) of Rosenblatt
(1952) transforms the copula data <code class="reqn">u = (u_1,\ldots,u_d)</code> with a given
multivariate copula C into independent data in <code class="reqn">[0,1]^d</code>, where d is the
dimension of the data set. <br />
</p>
<p>Let <code class="reqn">u = (u_1,\ldots,u_d)</code> denote copula data of dimension d. Further
let C be the joint cdf of <code class="reqn">u = (u_1,\ldots,u_d)</code>. Then Rosenblatt's
transformation of u, denoted as <code class="reqn">y = (y_1,\ldots,y_d)</code>, is defined as
</p>
<p style="text-align: center;"><code class="reqn"> y_1 := u_1,\ \ y_2 := C(u_2|u_1), \ldots\ y_d :=
C(u_d|u_1,\ldots,u_{d-1}), </code>
</p>
<p> where <code class="reqn">C(u_k|u_1,\ldots,u_{k-1})</code> is the
conditional copula of <code class="reqn">U_k</code> given <code class="reqn">U_1 = u_1,\ldots, U_{k-1} =
u_{k-1}, k = 2,\ldots,d</code>. The data vector <code class="reqn">y = (y_1,\ldots,y_d)</code> is now
i.i.d. with <code class="reqn">y_i \sim U[0, 1]</code>. The algorithm for the R-vine PIT is
given in the appendix of Schepsmeier (2015).
</p>


<h3>Value</h3>

<p>An <code>N</code> x d matrix of PIT data from the given R-vine copula
model.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Rosenblatt, M. (1952).  Remarks on a Multivariate
Transformation. The Annals of Mathematical Statistics 23 (3), 470-472.
</p>
<p>Schepsmeier, U. (2015) Efficient information based goodness-of-fit tests for
vine copula models with fixed margins. Journal of Multivariate Analysis 138,
34-52.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineGofTest">RVineGofTest()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set
data(daxreturns)

# select the R-vine structure, families and parameters
RVM &lt;- RVineStructureSelect(daxreturns[,1:3], c(1:6))

# PIT data
pit &lt;- RVinePIT(daxreturns[,1:3], RVM)

par(mfrow = c(1,2))
plot(daxreturns[,1], daxreturns[,2])	# correlated data
plot(pit[,1], pit[,2])	# i.i.d. data

cor(pit, method = "kendall")

</code></pre>

<hr>
<h2 id='RVineSeqEst'>Sequential Estimation of an R-Vine Copula Model</h2><span id='topic+RVineSeqEst'></span>

<h3>Description</h3>

<p>This function sequentially estimates the pair-copula parameters of a
d-dimensional R-vine copula model as specified by the corresponding
<code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineSeqEst(
  data,
  RVM,
  method = "mle",
  se = FALSE,
  max.df = 30,
  max.BB = list(BB1 = c(5, 6), BB6 = c(6, 6), BB7 = c(5, 6), BB8 = c(6, 1)),
  progress = FALSE,
  weights = NA,
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineSeqEst_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineSeqEst_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object including the structure, the
pair-copula families and the pair-copula parameters (if they are known).</p>
</td></tr>
<tr><td><code id="RVineSeqEst_+3A_method">method</code></td>
<td>
<p>indicates the estimation method: either maximum
likelihood estimation (<code>method = "mle"</code>; default) or inversion of
Kendall's tau (<code>method = "itau"</code>). For <code>method = "itau"</code> only
one parameter families and the Student t copula can be used (<code style="white-space: pre;">&#8288;family = 1,2,3,4,5,6,13,14,16,23,24,26,33,34&#8288;</code> or <code>36</code>). For the t-copula,
<code>par2</code> is found by a crude profile likelihood optimization over the
interval (2, 10].</p>
</td></tr>
<tr><td><code id="RVineSeqEst_+3A_se">se</code></td>
<td>
<p>Logical; whether standard errors are estimated (default: <code>se = FALSE</code>).</p>
</td></tr>
<tr><td><code id="RVineSeqEst_+3A_max.df">max.df</code></td>
<td>
<p>Numeric; upper bound for the estimation of the degrees of
freedom parameter of the t-copula (default: <code>max.df = 30</code>; for more
details see <code><a href="#topic+BiCopEst">BiCopEst()</a></code>).</p>
</td></tr>
<tr><td><code id="RVineSeqEst_+3A_max.bb">max.BB</code></td>
<td>
<p>List; upper bounds for the estimation of the two parameters
(in absolute values) of the BB1, BB6, BB7 and BB8 copulas <br /> (default:
<code>max.BB = list(BB1=c(5,6),BB6=c(6,6),BB7=c(5,6),BB8=c(6,1))</code>).</p>
</td></tr>
<tr><td><code id="RVineSeqEst_+3A_progress">progress</code></td>
<td>
<p>Logical; whether the pairwise estimation progress is printed
(default: <code>progress = FALSE</code>).</p>
</td></tr>
<tr><td><code id="RVineSeqEst_+3A_weights">weights</code></td>
<td>
<p>Numerical; weights for each observation (optional).</p>
</td></tr>
<tr><td><code id="RVineSeqEst_+3A_cores">cores</code></td>
<td>
<p>integer; if <code>cores &gt; 1</code>, estimation will be parallelized
within each tree (using <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>). However, the
overhead caused by parallelization is likely to make the function run slower
unless sample size is really large and <code>method = "itau"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pair-copula parameter estimation is performed tree-wise, i.e., for each
R-vine tree the results from the previous tree(s) are used to calculate the
new copula parameters using <code><a href="#topic+BiCopEst">BiCopEst()</a></code>.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object with the sequentially
estimated parameters stored in <code>RVM$par</code> and <code>RVM$par2</code>. The object
is augmented by the following information about the fit:
</p>
<table>
<tr><td><code>se</code>, <code>se2</code></td>
<td>
<p>standard errors for the parameter estimates (if
<code>se = TRUE</code>); note that these are only approximate since they do not
account for the sequential nature of the estimation,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>logLik</code>, <code>pair.logLik</code></td>
<td>
<p>log likelihood (overall and pairwise)</p>
</td></tr>
<tr><td><code>AIC</code>, <code>pair.AIC</code></td>
<td>
<p>Aikaike's Informaton Criterion (overall and pairwise),</p>
</td></tr>
<tr><td><code>BIC</code>, <code>pair.BIC</code></td>
<td>
<p>Bayesian's Informaton Criterion (overall and pairwise),</p>
</td></tr>
<tr><td><code>emptau</code></td>
<td>
<p>matrix of empirical values of Kendall's tau,</p>
</td></tr>
<tr><td><code>p.value.indeptest</code></td>
<td>
<p>matrix of p-values of the independence test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a comprehensive summary of the fitted model, use
<code>summary(object)</code>; to see all its contents, use <code>str(object)</code>.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Jeffrey Dissmann, Thomas Nagler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="#topic+BiCop">BiCop()</a></code>,
<code><a href="#topic+BiCopEst">BiCopEst()</a></code>,
<code><a href="#topic+plot.RVineMatrix">plot.RVineMatrix()</a></code>,
<code><a href="#topic+contour.RVineMatrix">contour.RVineMatrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# simulate a sample of size 300 from the R-vine copula model
set.seed(123)
simdata &lt;- RVineSim(300, RVM)

# sequential estimation
summary(RVineSeqEst(simdata, RVM, method = "itau", se = TRUE))
summary(RVineSeqEst(simdata, RVM, method = "mle", se = TRUE))

</code></pre>

<hr>
<h2 id='RVineSim'>Simulation from an R-Vine Copula Model</h2><span id='topic+RVineSim'></span>

<h3>Description</h3>

<p>This function simulates from a given R-vine copula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineSim(N, RVM, U = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineSim_+3A_n">N</code></td>
<td>
<p>Number of d-dimensional observations to simulate.</p>
</td></tr>
<tr><td><code id="RVineSim_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object containing the information of
the R-vine copula model. Optionally, a length-<code>N</code> list of
<code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>  objects sharing the same structure, but possibly
different family/parameter can be supplied.</p>
</td></tr>
<tr><td><code id="RVineSim_+3A_u">U</code></td>
<td>
<p>If not <code><a href="base.html#topic+NULL">NULL()</a></code>, an (N,d)-matrix of <code class="reqn">U[0,1]</code> random
variates to be transformed to the copula sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>N</code> x d matrix of data simulated from the given R-vine
copula model.
</p>


<h3>Author(s)</h3>

<p>Jeffrey Dissmann
</p>


<h3>References</h3>

<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka
(2013). Selecting and estimating regular vine copulae and application to
financial returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>, <code><a href="#topic+BiCopSim">BiCopSim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# simulate a sample of size 300 from the R-vine copula model
set.seed(123)
simdata &lt;- RVineSim(300, RVM)

</code></pre>

<hr>
<h2 id='RVineStdError'>Standard Errors of an R-Vine Copula Model</h2><span id='topic+RVineStdError'></span>

<h3>Description</h3>

<p>This function calculates the standard errors of a d-dimensional R-vine
copula model given the Hessian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineStdError(hessian, RVM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineStdError_+3A_hessian">hessian</code></td>
<td>
<p>The Hessian matrix of the given R-vine.</p>
</td></tr>
<tr><td><code id="RVineStdError_+3A_rvm">RVM</code></td>
<td>
<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object including the structure, the
pair-copula families, and the parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>se</code></td>
<td>
<p>The calculated standard errors for the first parameter
matrix. The entries are ordered with respect to the ordering of the
<code>RVM$par</code> matrix.</p>
</td></tr> <tr><td><code>se2</code></td>
<td>
<p>The calculated standard errors for the
second parameter matrix.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The negative Hessian matrix should be positive semidefinite. Otherwise
NAs will be returned in some entries and the non-NA entries may be wrong. If
the negative Hessian matrix is negative definite, then one could try a near
positive matrix. The package <code>Matrix</code> provides a function called
<code>nearPD</code> to estimate a matrix which is positive definite and close to
the given matrix.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier, Jakob Stoeber
</p>


<h3>References</h3>

<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka
(2013). Selecting and estimating regular vine copulae and application to
financial returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>
<p>Schepsmeier, U. and J. Stoeber (2014)
Derivatives and Fisher information of bivariate copulas.
Statistical Papers, 55(2), 525-542.
online first: <a href="https://link.springer.com/article/10.1007/s00362-013-0498-x">https://link.springer.com/article/10.1007/s00362-013-0498-x</a>.
</p>
<p>Web supplement: Derivatives and Fisher Information of bivariate copulas.
<a href="https://mediatum.ub.tum.de/node?id=1119201">https://mediatum.ub.tum.de/node?id=1119201</a>
</p>
<p>Stoeber, J. and U. Schepsmeier (2013). Estimating standard errors in regular
vine copula models. Computational Statistics, 28 (6), 2679-2707
<a href="https://link.springer.com/article/10.1007/s00180-013-0423-8#">https://link.springer.com/article/10.1007/s00180-013-0423-8#</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopDeriv">BiCopDeriv()</a></code>,
<code><a href="#topic+BiCopDeriv2">BiCopDeriv2()</a></code>,
<code><a href="#topic+BiCopHfuncDeriv">BiCopHfuncDeriv()</a></code>,
<code><a href="#topic+BiCopHfuncDeriv2">BiCopHfuncDeriv2()</a></code>, <br />
<code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="#topic+RVineHessian">RVineHessian()</a></code>,
<code><a href="#topic+RVineGrad">RVineGrad()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# define 5-dimensional R-vine tree structure matrix
Matrix &lt;- c(5, 2, 3, 1, 4,
            0, 2, 3, 4, 1,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 1)
Matrix &lt;- matrix(Matrix, 5, 5)

# define R-vine pair-copula family matrix
family &lt;- c(0, 1, 3, 4, 4,
            0, 0, 3, 4, 1,
            0, 0, 0, 4, 1,
            0, 0, 0, 0, 3,
            0, 0, 0, 0, 0)
family &lt;- matrix(family, 5, 5)

# define R-vine pair-copula parameter matrix
par &lt;- c(0, 0.2, 0.9, 1.5, 3.9,
         0, 0, 1.1, 1.6, 0.9,
         0, 0, 0, 1.9, 0.5,
         0, 0, 0, 0, 4.8,
         0, 0, 0, 0, 0)
par &lt;- matrix(par, 5, 5)

# define second R-vine pair-copula parameter matrix
par2 &lt;- matrix(0, 5, 5)

# define RVineMatrix object
RVM &lt;- RVineMatrix(Matrix = Matrix, family = family,
                   par = par, par2 = par2,
                   names = c("V1", "V2", "V3", "V4", "V5"))

# simulate a sample of size 300 from the R-vine copula model
set.seed(123)
simdata &lt;- RVineSim(300, RVM)

# compute the Hessian matrix of the first row of the data
out2 &lt;- RVineHessian(simdata,RVM)

# get the standard errors
RVineStdError(out2$hessian, RVM)

</code></pre>

<hr>
<h2 id='RVineStructureSelect'>Sequential Specification of R- and C-Vine Copula Models</h2><span id='topic+RVineStructureSelect'></span>

<h3>Description</h3>

<p>This function fits either an R- or a C-vine copula model to a d-dimensional
copula data set. Tree structures are determined and appropriate pair-copula
families are selected using <code><a href="#topic+BiCopSelect">BiCopSelect()</a></code> and estimated
sequentially (forward selection of trees).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineStructureSelect(
  data,
  familyset = NA,
  type = 0,
  selectioncrit = "AIC",
  indeptest = FALSE,
  level = 0.05,
  trunclevel = NA,
  progress = FALSE,
  weights = NA,
  treecrit = "tau",
  rotations = TRUE,
  se = FALSE,
  presel = TRUE,
  method = "mle",
  cores = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineStructureSelect_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_familyset">familyset</code></td>
<td>
<p>An integer vector of pair-copula families to select from.
The vector has to include at least one
pair-copula family that allows for positive and one that allows for negative
dependence. Not listed copula families might be included to better handle
limit cases.  If <code>familyset = NA</code> (default), selection among all
possible families is performed.  Coding of pair-copula families is the same
as in <code><a href="#topic+BiCop">BiCop()</a></code>.</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_type">type</code></td>
<td>
<p>Type of the vine model to be specified:<br />
<code>0</code> or <code>"RVine"</code> = R-vine (default) <br />
<code>1</code> or <code>"CVine"</code> = C-vine <br />
C- and D-vine copula models with pre-specified order can be specified using
<code>CDVineCopSelect</code> of the package CDVine. Similarly, R-vine copula
models with pre-specified tree structure can be specified using
<code><a href="#topic+RVineCopSelect">RVineCopSelect()</a></code>.</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_selectioncrit">selectioncrit</code></td>
<td>
<p>Character indicating the criterion for pair-copula
selection. Possible choices:<code>selectioncrit = "AIC"</code> (default),
<code>"BIC"</code>, or <code>"logLik"</code> (see <code><a href="#topic+BiCopSelect">BiCopSelect()</a></code>).</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_indeptest">indeptest</code></td>
<td>
<p>logical; whether a hypothesis test for the independence of
<code>u1</code> and <code>u2</code> is performed before bivariate copula selection
(default: <code>indeptest = FALSE</code>; see <code><a href="#topic+BiCopIndTest">BiCopIndTest()</a></code>).  The
independence copula is chosen for a (conditional) pair if the null
hypothesis of independence cannot be rejected.</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_level">level</code></td>
<td>
<p>numeric; significance level of the independence test
(default: <code>level = 0.05</code>).</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_trunclevel">trunclevel</code></td>
<td>
<p>integer; level of truncation.</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_progress">progress</code></td>
<td>
<p>logical; whether the tree-wise specification progress is
printed (default: <code>progress = FALSE</code>).</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_weights">weights</code></td>
<td>
<p>numeric; weights for each observation (optional).</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_treecrit">treecrit</code></td>
<td>
<p>edge weight for Dissman's structure selection algorithm, see
<em>Details</em>.</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_rotations">rotations</code></td>
<td>
<p>If <code>TRUE</code>, all rotations of the families in
<code>familyset</code> are included.</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_se">se</code></td>
<td>
<p>Logical; whether standard errors are estimated (default: <code>se = FALSE</code>).</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_presel">presel</code></td>
<td>
<p>Logical; whether to exclude families before fitting based on
symmetry properties of the data. Makes the selection about 30\
(on average), but may yield slightly worse results in few special cases.</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_method">method</code></td>
<td>
<p>indicates the estimation method: either maximum
likelihood estimation (<code>method = "mle"</code>; default) or inversion of
Kendall's tau (<code>method = "itau"</code>). For <code>method = "itau"</code> only
one parameter families and the Student t copula can be used (<code style="white-space: pre;">&#8288;family = 1,2,3,4,5,6,13,14,16,23,24,26,33,34&#8288;</code> or <code>36</code>). For the t-copula,
<code>par2</code> is found by a crude profile likelihood optimization over the
interval (2, 10].</p>
</td></tr>
<tr><td><code id="RVineStructureSelect_+3A_cores">cores</code></td>
<td>
<p>integer; if <code>cores &gt; 1</code>, estimation will be parallelized
within each tree (using <code><a href="foreach.html#topic+foreach">foreach::foreach()</a></code>). Note that
parallelization causes substantial overhead and may be slower than
single-threaded computation when dimension, sample size, or family set are
small or <code>method = "itau"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R-vine trees are selected using maximum spanning trees w.r.t. some edge
weights. The most commonly used edge weight is the absolute value of the
empirical Kendall's tau, say <code class="reqn">\hat{\tau}_{ij}</code>. Then, the following
optimization problem is solved for each tree:
</p>
<p style="text-align: center;"><code class="reqn">\max \sum_{\mathrm{edges }\; e_{ij} \in \; \mathrm{ in \; spanning \; tree}} |\hat{\tau}_{ij}|, </code>
</p>

<p>where a spanning tree is a tree on all nodes. The
setting of the first tree selection step is always a complete graph. For
subsequent trees, the setting depends on the R-vine construction principles,
in particular on the proximity condition.
</p>
<p>Some commonly used edge weights are implemented:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"tau"</code> </td><td style="text-align: left;"> absolute value of empirical Kendall's tau. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"rho"</code> </td><td style="text-align: left;"> absolute value of empirical Spearman's rho. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"AIC"</code> </td><td style="text-align: left;"> Akaike information (multiplied by -1). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"BIC"</code> </td><td style="text-align: left;"> Bayesian information criterion (multiplied by -1). </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"cAIC"</code></td><td style="text-align: left;"> corrected Akaike information criterion (multiplied by -1). </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If the data contain NAs, the edge weights in <code>"tau"</code> and <code>"rho"</code> are
multiplied by the square root of the proportion of complete observations. This
penalizes pairs where less observations are used. <br />
</p>
<p>The criteria <code>"AIC"</code>, <code>"BIC"</code>, and <code>"cAIC"</code> require estimation and
model selection for all possible pairs. This is computationally expensive and
much slower than <code>"tau"</code> or <code>"rho"</code>.
The user can also specify a custom function to calculate the edge weights.
The function has to be of type <code>function(u1, u2, weights) ...</code> and must
return a numeric value. The weights argument must exist, but does not has to
be used. For example, <code>"tau"</code> (without using weights) can be implemented
as follows:<br />
<code style="white-space: pre;">&#8288;function(u1, u2, weights)&#8288;</code> <br />
<code>abs(cor(u1, u2, method = "kendall", use = "complete.obs"))</code>
</p>
<p>The root nodes of C-vine trees are determined similarly by identifying the
node with strongest dependencies to all other nodes. That is we take the
node with maximum column sum in the empirical Kendall's tau matrix.
</p>
<p>Note that a possible way to determine the order of the nodes in the D-vine
is to identify a shortest Hamiltonian path in terms of weights
<code class="reqn">1-|\hat{\tau_{ij}|}</code>. This can be established for example using the package
TSP. Example code is shown below.
</p>


<h3>Value</h3>

<p>An <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> object with the selected structure
(<code>RVM$Matrix</code>) and families (<code>RVM$family</code>) as well as sequentially
estimated parameters stored in <code>RVM$par</code> and <code>RVM$par2</code>. The object
is augmented by the following information about the fit:
</p>
<table>
<tr><td><code>se</code>, <code>se2</code></td>
<td>
<p>standard errors for the parameter estimates; note that these
are only approximate since they do not
account for the sequential nature of the estimation,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>logLik</code>, <code>pair.logLik</code></td>
<td>
<p>log likelihood (overall and pairwise)</p>
</td></tr>
<tr><td><code>AIC</code>, <code>pair.AIC</code></td>
<td>
<p>Aikaike's Informaton Criterion (overall and pairwise),</p>
</td></tr>
<tr><td><code>BIC</code>, <code>pair.BIC</code></td>
<td>
<p>Bayesian's Informaton Criterion (overall and pairwise),</p>
</td></tr>
<tr><td><code>emptau</code></td>
<td>
<p>matrix of empirical values of Kendall's tau,</p>
</td></tr>
<tr><td><code>p.value.indeptest</code></td>
<td>
<p>matrix of p-values of the independence test.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For a comprehensive summary of the vine copula model, use
<code>summary(object)</code>; to see all its contents, use <code>str(object)</code>.
</p>


<h3>Author(s)</h3>

<p>Jeffrey Dissmann, Eike Brechmann, Ulf Schepsmeier, Thomas Nagler
</p>


<h3>References</h3>

<p>Brechmann, E. C., C. Czado, and K. Aas (2012). Truncated regular
vines in high dimensions with applications to financial data. Canadian
Journal of Statistics 40 (1), 68-85.
</p>
<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka (2013).
Selecting and estimating regular vine copulae and application to financial
returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code>,
<code><a href="#topic+BiCop">BiCop()</a></code>,
<code><a href="#topic+RVineCopSelect">RVineCopSelect()</a></code>,
<code><a href="#topic+plot.RVineMatrix">plot.RVineMatrix()</a></code>,
<code><a href="#topic+contour.RVineMatrix">contour.RVineMatrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data set
data(daxreturns)

# select the R-vine structure, families and parameters
# using only the first 4 variables and the first 250 observations
# we allow for the copula families: Gauss, t, Clayton, Gumbel, Frank and Joe
daxreturns &lt;- daxreturns[1:250, 1:4]
RVM &lt;- RVineStructureSelect(daxreturns, c(1:6), progress = TRUE)

## see the object's content or a summary
str(RVM)
summary(RVM)

## inspect the fitted model using plots
## Not run: plot(RVM)  # tree structure
contour(RVM)  # contour plots of all pair-copulas

## estimate a C-vine copula model with only Clayton, Gumbel and Frank copulas
CVM &lt;- RVineStructureSelect(daxreturns, c(3,4,5), "CVine")

## determine the order of the nodes in a D-vine using the package TSP
library(TSP)
d &lt;- dim(daxreturns)[2]
M &lt;- 1 - abs(TauMatrix(daxreturns))
hamilton &lt;- insert_dummy(TSP(M), label = "cut")
sol &lt;- solve_TSP(hamilton, method = "repetitive_nn")
order &lt;- cut_tour(sol, "cut")
DVM &lt;- D2RVine(order, family = rep(0,d*(d-1)/2), par = rep(0, d*(d-1)/2))
RVineCopSelect(daxreturns, c(1:6), DVM$Matrix)

</code></pre>

<hr>
<h2 id='RVineTreePlot'>Visualization of R-Vine Tree Structure</h2><span id='topic+RVineTreePlot'></span>

<h3>Description</h3>

<p>Function is deprecated since <code style="white-space: pre;">&#8288;VineCopula 2.0&#8288;</code>. Use
<code><a href="#topic+plot.RVineMatrix">plot.RVineMatrix()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineTreePlot(
  x,
  tree = "ALL",
  type = 0,
  edge.labels = NULL,
  legend.pos = "bottomleft",
  interactive = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineTreePlot_+3A_x">x</code></td>
<td>
<p><code>RVineMatrix</code> object.</p>
</td></tr>
<tr><td><code id="RVineTreePlot_+3A_tree">tree</code></td>
<td>
<p><code>"ALL"</code> or integer vector; specifies which trees are
plotted.</p>
</td></tr>
<tr><td><code id="RVineTreePlot_+3A_type">type</code></td>
<td>
<p>integer; specifies how to make use of variable names: <br />
<code>0</code> = variable names are ignored, <br /> <code>1</code> = variable names are
used to annotate vertices, <br /> <code>2</code> = uses numbers in plot and adds a
legend for variable names.</p>
</td></tr>
<tr><td><code id="RVineTreePlot_+3A_edge.labels">edge.labels</code></td>
<td>
<p>character; either a vector of edge labels or one of the
following: <br /> <code>"family"</code> = pair-copula family abbreviation (see
<code><a href="#topic+BiCopName">BiCopName()</a></code>), <br /> <code>"par"</code> =
pair-copula parameters, <br /> <code>"tau"</code> = pair-copula Kendall's tau (by
conversion of parameters) <br /> <code>"family-par"</code> = pair-copula family and
parameters <br /> <code>"family-tau"</code> = pair-copula family and Kendall's tau.</p>
</td></tr>
<tr><td><code id="RVineTreePlot_+3A_legend.pos">legend.pos</code></td>
<td>
<p>the <code>x</code> argument for
<code><a href="graphics.html#topic+legend">graphics::legend()</a></code>.</p>
</td></tr>
<tr><td><code id="RVineTreePlot_+3A_interactive">interactive</code></td>
<td>
<p>logical; if TRUE, the user is asked to adjust the
positioning of vertices with his mouse.</p>
</td></tr>
<tr><td><code id="RVineTreePlot_+3A_...">...</code></td>
<td>
<p>Arguments passed to
<code><a href="network.html#topic+plot.network">network::plot.network()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Nagler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.RVineMatrix">plot.RVineMatrix()</a></code>
</p>

<hr>
<h2 id='RVineVuongTest'>Vuong Test Comparing Two R-Vine Copula Models</h2><span id='topic+RVineVuongTest'></span>

<h3>Description</h3>

<p>This function performs a Vuong test between two d-dimensional R-vine copula
models as specified by their <code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RVineVuongTest(data, RVM1, RVM2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RVineVuongTest_+3A_data">data</code></td>
<td>
<p>An N x d data matrix (with uniform margins).</p>
</td></tr>
<tr><td><code id="RVineVuongTest_+3A_rvm1">RVM1</code>, <code id="RVineVuongTest_+3A_rvm2">RVM2</code></td>
<td>
<p><code><a href="#topic+RVineMatrix">RVineMatrix()</a></code> objects of models 1 and 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The likelihood-ratio based test proposed by Vuong (1989) can be used for
comparing non-nested models. For this let <code class="reqn">c_1</code> and <code class="reqn">c_2</code> be two
competing vine copulas in terms of their densities and with estimated
parameter sets <code class="reqn">\hat{\boldsymbol{\theta}}_1</code> and
<code class="reqn">\hat{\boldsymbol{\theta}}_2</code>. We then compute the
standardized sum, <code class="reqn">\nu</code>, of the log differences of their pointwise
likelihoods
<code class="reqn">m_i:=\log\left[\frac{c_1(\boldsymbol{u}_i|\hat{\boldsymbol{\theta}}_1)}{c_2(\boldsymbol{u}_i|\hat{\boldsymbol{\theta}}_2)}\right]</code> for observations <code class="reqn">\boldsymbol{u}_i\in[0,1],\
i=1,...,N</code> , i.e.,
</p>
<p style="text-align: center;"><code class="reqn">\texttt{statistic} := \nu = \frac{\frac{1}{n}\sum_{i=1}^N
m_i}{\sqrt{\sum_{i=1}^N\left(m_i - \bar{m} \right)^2}}. </code>
</p>
<p> Vuong
(1989) shows that <code class="reqn">\nu</code> is asymptotically standard normal. According to
the null-hypothesis </p>
<p style="text-align: center;"><code class="reqn">H_0:
E[m_i] = 0\ \forall i=1,...,N, </code>
</p>
<p> we
hence prefer vine model 1 to vine model 2 at level <code class="reqn">\alpha</code> if
</p>
<p style="text-align: center;"><code class="reqn">\nu&gt;\Phi^{-1}\left(1-\frac{\alpha}{2}\right), </code>
</p>
<p> where <code class="reqn">\Phi^{-1}</code> denotes the inverse of the
standard normal distribution function. If
<code class="reqn">\nu&lt;-\Phi^{-1}\left(1-\frac{\alpha}{2}\right)</code>
we choose model 2.  If, however,
<code class="reqn">|\nu|\leq\Phi^{-1}\left(1-\frac{\alpha}{2}\right)</code>, no decision among the models is possible.
</p>
<p>Like AIC and BIC, the Vuong test statistic may be corrected for the number
of parameters used in the models. There are two possible corrections; the
Akaike and the Schwarz corrections, which correspond to the penalty terms in
the AIC and the BIC, respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>statistic</code>, <code>statistic.Akaike</code>, <code>statistic.Schwarz</code></td>
<td>
<p>Test
statistics without correction, with Akaike correction and with Schwarz
correction.</p>
</td></tr> <tr><td><code>p.value</code>, <code>p.value.Akaike</code>, <code>p.value.Schwarz</code></td>
<td>
<p>P-values of
tests without correction, with Akaike correction and with Schwarz
correction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jeffrey Dissmann, Eike Brechmann
</p>


<h3>References</h3>

<p>Vuong, Q. H. (1989). Ratio tests for model selection and
non-nested hypotheses. Econometrica 57 (2), 307-333.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RVineClarkeTest">RVineClarkeTest()</a></code>, <code><a href="#topic+RVineAIC">RVineAIC()</a></code>,
<code><a href="#topic+RVineBIC">RVineBIC()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# vine structure selection time-consuming (~ 20 sec)

# load data set
data(daxreturns)

# select the R-vine structure, families and parameters
RVM &lt;- RVineStructureSelect(daxreturns[,1:5], c(1:6))

# select the C-vine structure, families and parameters
CVM &lt;- RVineStructureSelect(daxreturns[,1:5], c(1:6), type = "CVine")

# compare the two models based on the data
vuong &lt;- RVineVuongTest(daxreturns[,1:5], RVM, CVM)
vuong$statistic
vuong$statistic.Schwarz
vuong$p.value
vuong$p.value.Schwarz


</code></pre>

<hr>
<h2 id='TauMatrix'>Matrix of Empirical Kendall's Tau Values</h2><span id='topic+TauMatrix'></span>

<h3>Description</h3>

<p>This function computes the empirical Kendall's tau using the algorithm by
Knight (1966).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TauMatrix(data, weights = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TauMatrix_+3A_data">data</code></td>
<td>
<p>An N x d data matrix.</p>
</td></tr>
<tr><td><code id="TauMatrix_+3A_weights">weights</code></td>
<td>
<p>Numerical; weights for each observation (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of the empirical Kendall's taus.
</p>


<h3>Author(s)</h3>

<p>Ulf Schepsmeier
</p>


<h3>References</h3>

<p>Knight, W. R. (1966). A computer method for calculating
Kendall's tau with ungrouped data. Journal of the American Statistical
Association 61 (314), 436-439.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+BiCopTau2Par">BiCopTau2Par()</a></code>, <code><a href="#topic+BiCopPar2Tau">BiCopPar2Tau()</a></code>,
<code><a href="#topic+BiCopEst">BiCopEst()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(daxreturns)
Data &lt;- as.matrix(daxreturns)

# compute the empirical Kendall's taus
TauMatrix(Data)

</code></pre>

<hr>
<h2 id='VC2copula-deprecated'>Deprecated</h2><span id='topic+VC2copula-deprecated'></span><span id='topic+copulaFromFamilyIndex'></span><span id='topic+surClaytonCopula-class'></span><span id='topic+surClaytonCopula'></span><span id='topic+dduCopula+2Cmatrix+2CsurClaytonCopula-method'></span><span id='topic+dduCopula+2Cnumeric+2CsurClaytonCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CsurClaytonCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CsurClaytonCopula-method'></span><span id='topic+r90ClaytonCopula-class'></span><span id='topic+dduCopula+2Cmatrix+2Cr90ClaytonCopula-method'></span><span id='topic+dduCopula+2Cnumeric+2Cr90ClaytonCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr90ClaytonCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr90ClaytonCopula-method'></span><span id='topic+r270ClaytonCopula-class'></span><span id='topic+dduCopula+2Cmatrix+2Cr270ClaytonCopula-method'></span><span id='topic+dduCopula+2Cnumeric+2Cr270ClaytonCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr270ClaytonCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr270ClaytonCopula-method'></span><span id='topic+r90ClaytonCopula'></span><span id='topic+r270ClaytonCopula'></span><span id='topic+surGumbelCopula-class'></span><span id='topic+surGumbelCopula'></span><span id='topic+dduCopula+2Cmatrix+2CsurGumbelCopula-method'></span><span id='topic+dduCopula+2Cnumeric+2CsurGumbelCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CsurGumbelCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CsurGumbelCopula-method'></span><span id='topic+r90GumbelCopula-class'></span><span id='topic+dduCopula+2Cmatrix+2Cr90GumbelCopula-method'></span><span id='topic+dduCopula+2Cnumeric+2Cr90GumbelCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr90GumbelCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr90GumbelCopula-method'></span><span id='topic+r270GumbelCopula-class'></span><span id='topic+dduCopula+2Cmatrix+2Cr270GumbelCopula-method'></span><span id='topic+dduCopula+2Cnumeric+2Cr270GumbelCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr270GumbelCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr270GumbelCopula-method'></span><span id='topic+r90GumbelCopula'></span><span id='topic+r270GumbelCopula'></span><span id='topic+joeBiCopula-class'></span><span id='topic+joeBiCopula'></span><span id='topic+dduCopula+2Cnumeric+2CjoeBiCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CjoeBiCopula-method'></span><span id='topic+dduCopula+2Cmatrix+2CjoeBiCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CjoeBiCopula-method'></span><span id='topic+getKendallDistr+2CjoeBiCopula-method'></span><span id='topic+kendallDistribution+2CjoeBiCopula-method'></span><span id='topic+surJoeBiCopula-class'></span><span id='topic+dduCopula+2Cnumeric+2CsurJoeBiCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CsurJoeBiCopula-method'></span><span id='topic+dduCopula+2Cmatrix+2CsurJoeBiCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CsurJoeBiCopula-method'></span><span id='topic+r90JoeBiCopula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr90JoeBiCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr90JoeBiCopula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr90JoeBiCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr90JoeBiCopula-method'></span><span id='topic+r270JoeBiCopula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr270JoeBiCopula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr270JoeBiCopula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr270JoeBiCopula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr270JoeBiCopula-method'></span><span id='topic+surJoeBiCopula'></span><span id='topic+r90JoeBiCopula'></span><span id='topic+r270JoeBiCopula'></span><span id='topic+BB1Copula-class'></span><span id='topic+BB1Copula'></span><span id='topic+dduCopula+2Cnumeric+2CBB1Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CBB1Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2CBB1Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CBB1Copula-method'></span><span id='topic+getKendallDistr+2CBB1Copula-method'></span><span id='topic+kendallDistribution+2CBB1Copula-method'></span><span id='topic+surBB1Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2CsurBB1Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CsurBB1Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2CsurBB1Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CsurBB1Copula-method'></span><span id='topic+r90BB1Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr90BB1Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr90BB1Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr90BB1Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr90BB1Copula-method'></span><span id='topic+r270BB1Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr270BB1Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr270BB1Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr270BB1Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr270BB1Copula-method'></span><span id='topic+surBB1Copula'></span><span id='topic+r90BB1Copula'></span><span id='topic+r270BB1Copula'></span><span id='topic+BB6Copula-class'></span><span id='topic+BB6Copula'></span><span id='topic+dduCopula+2Cnumeric+2CBB6Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CBB6Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2CBB6Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CBB6Copula-method'></span><span id='topic+getKendallDistr+2CBB6Copula-method'></span><span id='topic+kendallDistribution+2CBB6Copula-method'></span><span id='topic+surBB6Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2CsurBB6Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CsurBB6Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2CsurBB6Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CsurBB6Copula-method'></span><span id='topic+r90BB6Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr90BB6Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr90BB6Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr90BB6Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr90BB6Copula-method'></span><span id='topic+r270BB6Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr270BB6Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr270BB6Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr270BB6Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr270BB6Copula-method'></span><span id='topic+surBB6Copula'></span><span id='topic+r90BB6Copula'></span><span id='topic+r270BB6Copula'></span><span id='topic+BB7Copula-class'></span><span id='topic+BB7Copula'></span><span id='topic+dduCopula+2Cnumeric+2CBB7Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CBB7Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2CBB7Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CBB7Copula-method'></span><span id='topic+getKendallDistr+2CBB7Copula-method'></span><span id='topic+kendallDistribution+2CBB7Copula-method'></span><span id='topic+surBB7Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2CsurBB7Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CsurBB7Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2CsurBB7Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CsurBB7Copula-method'></span><span id='topic+r90BB7Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr90BB7Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr90BB7Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr90BB7Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr90BB7Copula-method'></span><span id='topic+r270BB7Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr270BB7Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr270BB7Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr270BB7Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr270BB7Copula-method'></span><span id='topic+surBB7Copula'></span><span id='topic+r90BB7Copula'></span><span id='topic+r270BB7Copula'></span><span id='topic+BB8Copula-class'></span><span id='topic+BBB8Copula'></span><span id='topic+B8Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2CBB8Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CBB8Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2CBB8Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CBB8Copula-method'></span><span id='topic+getKendallDistr+2CBB8Copula-method'></span><span id='topic+kendallDistribution+2CBB8Copula-method'></span><span id='topic+surBB8Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2CsurBB8Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CsurBB8Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2CsurBB8Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CsurBB8Copula-method'></span><span id='topic+r90BB8Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr90BB8Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr90BB8Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr90BB8Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr90BB8Copula-method'></span><span id='topic+r270BB8Copula-class'></span><span id='topic+dduCopula+2Cnumeric+2Cr270BB8Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr270BB8Copula-method'></span><span id='topic+dduCopula+2Cmatrix+2Cr270BB8Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr270BB8Copula-method'></span><span id='topic+BB8Copula'></span><span id='topic+surBB8Copula'></span><span id='topic+r90BB8Copula'></span><span id='topic+r270BB8Copula'></span><span id='topic+tawnT1Copula-class'></span><span id='topic+tawnT1Copula'></span><span id='topic+dduCopula+2Cmatrix+2CtawnT1Copula-method'></span><span id='topic+dduCopula+2Cnumeric+2CtawnT1Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CtawnT1Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CtawnT1Copula-method'></span><span id='topic+surTawnT1Copula-class'></span><span id='topic+dduCopula+2Cmatrix+2CsurTawnT1Copula-method'></span><span id='topic+dduCopula+2Cnumeric+2CsurTawnT1Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CsurTawnT1Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CsurTawnT1Copula-method'></span><span id='topic+r90TawnT1Copula-class'></span><span id='topic+dduCopula+2Cmatrix+2Cr90TawnT1Copula-method'></span><span id='topic+dduCopula+2Cnumeric+2Cr90TawnT1Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr90TawnT1Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr90TawnT1Copula-method'></span><span id='topic+r270TawnT1Copula-class'></span><span id='topic+dduCopula+2Cmatrix+2Cr270TawnT1Copula-method'></span><span id='topic+dduCopula+2Cnumeric+2Cr270TawnT1Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr270TawnT1Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr270TawnT1Copula-method'></span><span id='topic+surTawnT1Copula'></span><span id='topic+r90TawnT1Copula'></span><span id='topic+r270TawnT1Copula'></span><span id='topic+tawnT2Copula-class'></span><span id='topic+tawnT2Copula'></span><span id='topic+dduCopula+2Cmatrix+2CtawnT2Copula-method'></span><span id='topic+dduCopula+2Cnumeric+2CtawnT2Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CtawnT2Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CtawnT2Copula-method'></span><span id='topic+surTawnT2Copula-class'></span><span id='topic+dduCopula+2Cmatrix+2CsurTawnT2Copula-method'></span><span id='topic+dduCopula+2Cnumeric+2CsurTawnT2Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2CsurTawnT2Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2CsurTawnT2Copula-method'></span><span id='topic+r90TawnT2Copula-class'></span><span id='topic+dduCopula+2Cmatrix+2Cr90TawnT2Copula-method'></span><span id='topic+dduCopula+2Cnumeric+2Cr90TawnT2Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr90TawnT2Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr90TawnT2Copula-method'></span><span id='topic+r270TawnT2Copula-class'></span><span id='topic+dduCopula+2Cmatrix+2Cr270TawnT2Copula-method'></span><span id='topic+dduCopula+2Cnumeric+2Cr270TawnT2Copula-method'></span><span id='topic+ddvCopula+2Cmatrix+2Cr270TawnT2Copula-method'></span><span id='topic+ddvCopula+2Cnumeric+2Cr270TawnT2Copula-method'></span><span id='topic+surTawnT2Copula'></span><span id='topic+r90TawnT2Copula'></span><span id='topic+r270TawnT2Copula'></span><span id='topic+vineCopula'></span><span id='topic+vineCopula-class'></span><span id='topic+fitCopula'></span><span id='topic+vineCopula-method'></span>

<h3>Description</h3>

<p>This functionality is deprecated in 'VineCopula'. Use the package 'VC2copula'
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copulaFromFamilyIndex(family, par, par2 = 0)

surClaytonCopula(param = c(1, 1))

r90ClaytonCopula(param = c(1, 1))

r270ClaytonCopula(param = c(1, 1))

surGumbelCopula(param = c(1, 1))

r90GumbelCopula(param = c(1, 1))

r270GumbelCopula(param = c(1, 1))

joeBiCopula(param = c(1, 1))

surJoeBiCopula(param = c(1, 1))

r90JoeBiCopula(param = c(1, 1))

r270JoeBiCopula(param = c(1, 1))

BB1Copula(param = c(1, 1))

surBB1Copula(param = c(1, 1))

r90BB1Copula(param = c(1, 1))

r270BB1Copula(param = c(1, 1))

BB6Copula(param = c(1, 1))

surBB6Copula(param = c(1, 1))

r90BB6Copula(param = c(1, 1))

r270BB6Copula(param = c(1, 1))

BB7Copula(param = c(1, 1))

surBB7Copula(param = c(1, 1))

r90BB7Copula(param = c(1, 1))

r270BB7Copula(param = c(1, 1))

BB8Copula(param = c(1, 1))

surBB8Copula(param = c(1, 1))

r90BB8Copula(param = c(1, 1))

r270BB8Copula(param = c(1, 1))

tawnT1Copula(param = c(1, 1))

surTawnT1Copula(param = c(1, 1))

r90TawnT1Copula(param = c(1, 1))

r270TawnT1Copula(param = c(1, 1))

tawnT2Copula(param = c(1, 1))

surTawnT2Copula(param = c(1, 1))

r90TawnT2Copula(param = c(1, 1))

r270TawnT2Copula(param = c(1, 1))

vineCopula(RVM, type = "CVine")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VC2copula-deprecated_+3A_family">family</code></td>
<td>
<p>..</p>
</td></tr>
<tr><td><code id="VC2copula-deprecated_+3A_par">par</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="VC2copula-deprecated_+3A_par2">par2</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="VC2copula-deprecated_+3A_param">param</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="VC2copula-deprecated_+3A_rvm">RVM</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="VC2copula-deprecated_+3A_type">type</code></td>
<td>
<p>...</p>
</td></tr>
</table>

<hr>
<h2 id='VineCopula-package'>Statistical Inference of Vine Copulas</h2><span id='topic+VineCopula-package'></span><span id='topic+VineCopula'></span>

<h3>Description</h3>

<p>Provides tools for the statistical analysis of regular vine copula 
    models, see Aas et al. (2009) &lt;doi:10.1016/j.insmatheco.2007.02.001&gt; and 
    Dissman et al. (2013) &lt;doi:10.1016/j.csda.2012.08.010&gt;.
    The package includes tools for parameter estimation, model selection,
    simulation, goodness-of-fit tests, and visualization. Tools for estimation,
    selection and exploratory data analysis of bivariate copula models are also
    provided.
</p>


<h3>Details</h3>

<p>Vine copulas are a flexible class of dependence models consisting of
bivariate building blocks (see e.g., Aas et al., 2009). This package is
primarily made for the statistical analysis of vine copula
models. The package includes tools for parameter estimation, model selection,
simulation, goodness-of-fit tests, and visualization. Tools for estimation,
selection and exploratory data analysis of bivariate copula models are
also provided.
</p>
<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> VineCopula</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Statistical Inference of Vine Copulas</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.5.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Provides tools for the statistical analysis of regular vine copula 
    models, see Aas et al. (2009) &lt;doi:10.1016/j.insmatheco.2007.02.001&gt; and 
    Dissman et al. (2013) &lt;doi:10.1016/j.csda.2012.08.010&gt;.
    The package includes tools for parameter estimation, model selection,
    simulation, goodness-of-fit tests, and visualization. Tools for estimation,
    selection and exploratory data analysis of bivariate copula models are also
    provided.</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(
    person("Thomas", "Nagler",, "mail@tnagler.com", role = c("aut", "cre")),
    person("Ulf", "Schepsmeier",, "ulf.schepsmeier@tum.de", role = "aut"),
    person("Jakob", "Stoeber",, role = "aut"),
    person("Eike Christian", "Brechmann",, role = "aut"),
    person("Benedikt", "Graeler",, role = "aut"),
    person("Tobias", "Erhardt",, "tobias.erhardt@tum.de", role = "aut"),
    person("Carlos", "Almeida",, role = "ctb"),
    person("Aleksey", "Min",, role = c("ctb", "ths")),
    person("Claudia", "Czado",, role = c("ctb", "ths")),
    person("Mathias", "Hofmann",, role = "ctb"),
    person("Matthias", "Killiches",, role = "ctb"),
    person("Harry", "Joe",, role = "ctb"),
    person("Thibault", "Vatter",, role = "ctb")
    )</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.1.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> graphics,
grDevices,
stats,
utils,
MASS,
mvtnorm,
methods,
ADGofTest,
lattice,
parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> TSP,
shiny,
testthat,
numDeriv,
kdecopula (&gt;= 0.8.0),
network</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/tnagler/VineCopula/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/tnagler/VineCopula</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Roxygen: </td><td style="text-align: left;"> list(markdown = TRUE)</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Thomas Nagler [aut, cre],
  Ulf Schepsmeier [aut],
  Jakob Stoeber [aut],
  Eike Christian Brechmann [aut],
  Benedikt Graeler [aut],
  Tobias Erhardt [aut],
  Carlos Almeida [ctb],
  Aleksey Min [ctb, ths],
  Claudia Czado [ctb, ths],
  Mathias Hofmann [ctb],
  Matthias Killiches [ctb],
  Harry Joe [ctb],
  Thibault Vatter [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Thomas Nagler &lt;mail@tnagler.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Remark</h3>

<p>The package <code>VineCopula</code> is a continuation of the
package <code>CDVine</code> by U. Schepsmeier and E. C. Brechmann (see Brechmann
and Schepsmeier (2013)). It includes all functions implemented in CDVine for
the bivariate case (BiCop-functions).
</p>


<h3>References</h3>

<p>Aas, K., C. Czado, A. Frigessi, and H. Bakken (2009).
Pair-copula constructions of multiple dependence. Insurance: Mathematics and
Economics 44 (2), 182-198.
</p>
<p>Bedford, T. and R. M. Cooke (2001). Probability density decomposition for
conditionally dependent random variables modeled by vines. Annals of
Mathematics and Artificial intelligence 32, 245-268.
</p>
<p>Bedford, T. and R. M. Cooke (2002). Vines - a new graphical model for
dependent random variables. Annals of Statistics 30, 1031-1068.
</p>
<p>Brechmann, E. C., C. Czado, and K. Aas (2012). Truncated regular vines in
high dimensions with applications to financial data. Canadian Journal of
Statistics 40 (1), 68-85.
</p>
<p>Brechmann, E. C. and C. Czado (2011). Risk management with high-dimensional
vine copulas: An analysis of the Euro Stoxx 50. Statistics &amp; Risk Modeling,
30 (4), 307-342.
</p>
<p>Brechmann, E. C. and U. Schepsmeier (2013). Modeling Dependence with C- and
D-Vine Copulas: The R Package CDVine. Journal of Statistical Software, 52
(3), 1-27. <a href="https://doi.org/10.18637/jss.v052.i03">doi:10.18637/jss.v052.i03</a>.
</p>
<p>Czado, C., U. Schepsmeier, and A. Min (2012). Maximum likelihood estimation
of mixed C-vines with application to exchange rates. Statistical Modelling,
12(3), 229-255.
</p>
<p>Dissmann, J. F., E. C. Brechmann, C. Czado, and D. Kurowicka (2013).
Selecting and estimating regular vine copulae and application to financial
returns. Computational Statistics &amp; Data Analysis, 59 (1), 52-69.
</p>
<p>Eschenburg, P. (2013). Properties of extreme-value copulas Diploma thesis,
Technische Universitaet Muenchen
<a href="https://mediatum.ub.tum.de/node?id=1145695">https://mediatum.ub.tum.de/node?id=1145695</a>
</p>
<p>Joe, H. (1996). Families of m-variate distributions with given margins and
m(m-1)/2 bivariate dependence parameters. In L. Rueschendorf, B. Schweizer,
and M. D. Taylor (Eds.), Distributions with fixed marginals and related
topics, pp. 120-141. Hayward: Institute of Mathematical Statistics.
</p>
<p>Joe, H. (1997). Multivariate Models and Dependence Concepts. London: Chapman
and Hall.
</p>
<p>Knight, W. R. (1966). A computer method for calculating Kendall's tau with
ungrouped data. Journal of the American Statistical Association 61 (314),
436-439.
</p>
<p>Kurowicka, D. and R. M. Cooke (2006). Uncertainty Analysis with High
Dimensional Dependence Modelling. Chichester: John Wiley.
</p>
<p>Kurowicka, D. and H. Joe (Eds.) (2011). Dependence Modeling: Vine Copula
Handbook. Singapore: World Scientific Publishing Co.
</p>
<p>Nelsen, R. (2006).  An introduction to copulas.  Springer
</p>
<p>Schepsmeier, U. and J. Stoeber (2014). Derivatives and Fisher information of
bivariate copulas. Statistical Papers, 55 (2), 525-542. <br />
<a href="https://link.springer.com/article/10.1007/s00362-013-0498-x">https://link.springer.com/article/10.1007/s00362-013-0498-x</a>.
</p>
<p>Schepsmeier, U. (2013) A goodness-of-fit test for regular vine copula
models.  Preprint <a href="https://arxiv.org/abs/1306.0818">https://arxiv.org/abs/1306.0818</a>
</p>
<p>Schepsmeier, U. (2015) Efficient information based goodness-of-fit tests for
vine copula models with fixed margins. Journal of Multivariate Analysis 138,
34-52.
</p>
<p>Stoeber, J. and U. Schepsmeier (2013). Estimating standard errors in regular
vine copula models. Computational Statistics, 28 (6), 2679-2707 <br />
<a href="https://link.springer.com/article/10.1007/s00180-013-0423-8#">https://link.springer.com/article/10.1007/s00180-013-0423-8#</a>.
</p>
<p>White, H. (1982) Maximum likelihood estimation of misspecified models,
Econometrica, 50, 1-26.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
