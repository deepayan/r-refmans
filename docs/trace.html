<!DOCTYPE html><html lang="en"><head><title>Help for package trace</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {trace}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#trace-package'><p>trace: Tandem Repeat Analysis by Capillary Electrophoresis</p></a></li>
<li><a href='#add_metadata'><p>Add Metadata to Fragments List</p></a></li>
<li><a href='#assign_index_peaks'><p>Assign index peaks</p></a></li>
<li><a href='#calculate_instability_metrics'><p>Calculate Repeat Instability Metrics</p></a></li>
<li><a href='#call_repeats'><p>Call Repeats for Fragments</p></a></li>
<li><a href='#cell_line_fsa_list'><p>A list of fsa files</p></a></li>
<li><a href='#example_data'><p>example_data</p></a></li>
<li><a href='#example_data_repeat_table'><p>example_data_repeat_table</p></a></li>
<li><a href='#extract_alleles'><p>Extract Modal Peaks</p></a></li>
<li><a href='#extract_fragments'><p>Extract All Fragments</p></a></li>
<li><a href='#extract_ladder_summary'><p>Extract ladder summary</p></a></li>
<li><a href='#extract_repeat_correction_summary'><p>Extract repeat correction summary</p></a></li>
<li><a href='#extract_trace_table'><p>Extract traces</p></a></li>
<li><a href='#find_alleles'><p>Find Alleles</p></a></li>
<li><a href='#find_fragments'><p>Find fragment peaks</p></a></li>
<li><a href='#find_ladders'><p>Ladder and bp sizing</p></a></li>
<li><a href='#fix_ladders_interactive'><p>Fix ladders interactively</p></a></li>
<li><a href='#fix_ladders_manual'><p>Fix ladders manually</p></a></li>
<li><a href='#fragments'><p>fragments object</p></a></li>
<li><a href='#fragments_repeats'><p>fragments_repeats object</p></a></li>
<li><a href='#fragments_trace'><p>fragments_trace object</p></a></li>
<li><a href='#generate_trace_template'><p>Generate a Quarto file that has the instability pipeline preset</p></a></li>
<li><a href='#metadata'><p>metadata</p></a></li>
<li><a href='#peak_table_to_fragments'><p>Convert Peak Table to Fragments_repeats class</p></a></li>
<li><a href='#plot_batch_correction_samples'><p>Plot correction samples</p></a></li>
<li><a href='#plot_data_channels'><p>plot_data_channels</p></a></li>
<li><a href='#plot_fragments'><p>Plot Peak Data</p></a></li>
<li><a href='#plot_ladders'><p>Plot ladder</p></a></li>
<li><a href='#plot_repeat_correction_model'><p>Plot Repeat Correction Model</p></a></li>
<li><a href='#plot_traces'><p>Plot sample traces</p></a></li>
<li><a href='#read_fsa'><p>Read fsa file</p></a></li>
<li><a href='#remove_fragments'><p>Remove Samples from List</p></a></li>
<li><a href='#repeat_table_to_repeats'><p>Convert Repeat Table to Repeats Fragments</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tandem Repeat Analysis by Capillary Electrophoresis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A pipeline for short tandem repeat instability analysis from fragment analysis data. Inputs of fsa files or peak tables, and a user supplied metadata data-frame. The package identifies ladders, calls peaks, identifies the modal peaks, calls repeats, then calculates repeat instability metrics (e.g. expansion index from Lee et al. (2010) &lt;<a href="https://doi.org/10.1186%2F1752-0509-4-29">doi:10.1186/1752-0509-4-29</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, ggplot2, knitr, rmarkdown, shinytest2, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, lme4, methods, mgcv, plotly, pracma,
seqinr, shiny, stats, utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://zachariahmclean.github.io/trace/">https://zachariahmclean.github.io/trace/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-13 21:00:27 UTC; gusella_lab</td>
</tr>
<tr>
<td>Author:</td>
<td>Zachariah McLean <a href="https://orcid.org/0000-0002-0968-0538"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Kevin Correia [aut],
  Andrew Jiang [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zachariah McLean &lt;zachariah.louis.mclean@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 09:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='trace-package'>trace: Tandem Repeat Analysis by Capillary Electrophoresis</h2><span id='topic+trace'></span><span id='topic+trace-package'></span>

<h3>Description</h3>

<p>A pipeline for short tandem repeat instability analysis from fragment analysis data. Inputs of fsa files or peak tables, and a user supplied metadata data-frame. The package identifies ladders, calls peaks, identifies the modal peaks, calls repeats, then calculates repeat instability metrics (e.g. expansion index from Lee et al. (2010) <a href="https://doi.org/10.1186/1752-0509-4-29">doi:10.1186/1752-0509-4-29</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Zachariah McLean <a href="mailto:zachariah.louis.mclean@gmail.com">zachariah.louis.mclean@gmail.com</a> (<a href="https://orcid.org/0000-0002-0968-0538">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Kevin Correia
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Andrew Jiang [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://zachariahmclean.github.io/trace/">https://zachariahmclean.github.io/trace/</a>
</p>
</li></ul>


<hr>
<h2 id='add_metadata'>Add Metadata to Fragments List</h2><span id='topic+add_metadata'></span>

<h3>Description</h3>

<p>This function adds metadata information to a list of fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_metadata(
  fragments_list,
  metadata_data.frame,
  unique_id = "unique_id",
  metrics_group_id = "metrics_group_id",
  metrics_baseline_control = "metrics_baseline_control",
  batch_run_id = "batch_run_id",
  batch_sample_id = "batch_sample_id",
  batch_sample_modal_repeat = "batch_sample_modal_repeat"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_metadata_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragment objects to which metadata will be added.</p>
</td></tr>
<tr><td><code id="add_metadata_+3A_metadata_data.frame">metadata_data.frame</code></td>
<td>
<p>A data frame containing the metadata information.</p>
</td></tr>
<tr><td><code id="add_metadata_+3A_unique_id">unique_id</code></td>
<td>
<p>(required) A character string indicating the column name for unique sample identifiers in the metadata.</p>
</td></tr>
<tr><td><code id="add_metadata_+3A_metrics_group_id">metrics_group_id</code></td>
<td>
<p>(optional) A character string indicating the column name for sample group identifiers in the metadata. This is for the logical grouping of samples for metrics calculations (see <code><a href="#topic+assign_index_peaks">assign_index_peaks()</a></code>). To skip, provide NA.</p>
</td></tr>
<tr><td><code id="add_metadata_+3A_metrics_baseline_control">metrics_baseline_control</code></td>
<td>
<p>(optional) A character string indicating the column name for baseline control indicators in the metadata. This is to identify the baseline control samples for grouping of samples for metrics calculations (see <code><a href="#topic+assign_index_peaks">assign_index_peaks()</a></code>). To skip, provide NA.</p>
</td></tr>
<tr><td><code id="add_metadata_+3A_batch_run_id">batch_run_id</code></td>
<td>
<p>(optional) A character string indicating the column name for the batch run identifiers in the metadata. This is for either batch correction or repeat correction in <code><a href="#topic+call_repeats">call_repeats()</a></code>. To skip, provide NA.</p>
</td></tr>
<tr><td><code id="add_metadata_+3A_batch_sample_id">batch_sample_id</code></td>
<td>
<p>(optional) A character string indicating the column name for an id of the size standard. For example, a sample code. This is for either batch correction or repeat correction in <code><a href="#topic+call_repeats">call_repeats()</a></code>. To skip, provide NA.</p>
</td></tr>
<tr><td><code id="add_metadata_+3A_batch_sample_modal_repeat">batch_sample_modal_repeat</code></td>
<td>
<p>(optional) A character string indicating column name for the validated modal repeat length of size standard sample. This is for either repeat correction in <code><a href="#topic+call_repeats">call_repeats()</a></code>. To skip, provide NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds specified metadata attributes to each fragment in the list. It matches the unique sample identifiers from the fragments list with those in the metadata data frame. To skip any of the optional columns, make parameter NA.
</p>
<p>There are two key things metadata are required for. First is the grouping of samples (metrics_group_id &amp; metrics_baseline_control) for the calculation of metrics and is used in <code><a href="#topic+assign_index_peaks">assign_index_peaks()</a></code>. For example, specifying a sample where the modal allele is the inherited repeat length (eg a mouse tail sample) or sample(s) at the start of a time-course experiment. This is indicated with a TRUE in the metrics_baseline_control column of the metadata. Samples are then grouped together with the metrics_group_id column of the metadata. Multiple samples can be metrics_baseline_control, which can be helpful for the average repeat gain metric to have a more accurate representation of the average repeat at the start of the experiment.
</p>
<p>The second key thing metadata can be used for is corrections in <code><a href="#topic+call_repeats">call_repeats()</a></code>. There are two main correction approaches in <code><a href="#topic+call_repeats">call_repeats()</a></code> that are somewhat related: either 'batch' or 'repeat'. Batch correction is relatively simple and just requires you to link samples across batches to correct batch-batch variation in repeat sizes. However, even though the repeat size that is return will be precise, it will not be accurate and underestimates the real repeat length. By contrast, repeat correction can be used to accurately call repeat lengths (which also corrects the batch effects). However, the repeat correction will only be as good as your sample used to call the repeat length so this is a challenging and advanced feature. You need to use a sample that reliably returns the same peak as the modal peak, or you need to be willing to understand the shape of the distribution and manually validate the repeat length of each batch_sample_id for each run.
</p>
<p>Batch correction uses common sample(s) across fragment analysis runs to correct systematic batch effects that occur with repeat-containing amplicons in capillary electrophoresis. There are slight fluctuations of size across runs for amplicons containing repeats that result in systematic differences around 1-3 base pairs. So, if samples are to be analyzed for different runs, the absolute bp size is not comparable unless this batch effect is corrected. This is only relevant when the absolute size of a amplicons are compared for grouping metrics as described above (otherwise instability metrics are all relative and it doesn’t matter that there’s systematic batch effects across runs) or when plotting traces from different runs. This correction can be achieved by running a couple of samples in every fragment analysis run, or having a single run that takes a couple of samples from every run together, thereby linking them. These samples are then indicated in the metadata with batch_run_id (to group samples by fragment analysis run) and batch_sample_id (to enable linking samples across batches).
</p>
<p>Finally, samples with known and validated repeat size can be used to accurately call the repeat length (and therefore also correct batch effects) in <code><a href="#topic+call_repeats">call_repeats()</a></code>. Similar to batch correction, batch_run_id (to group samples by fragment analysis run) and batch_sample_id (to enable linking samples across batches) are used, but importantly batch_sample_modal_repeat is also set. The batch_sample_modal_repeat is the validated repeat length of the modal repeat of the sample. This validated repeat length is then used to call the repeat length of the modal repeat for each sample (by each batch_run_id). Importantly, this correction requires you to know with confidence the repeat length of the modal peak of the sample. Therefore it's important that the sample used for repeat correction has a clear and prominent modal peak. If the repeat length is very long, it's common for the modal peak of a sample to change so if you use this feature you're going to have to understand the shape of the distribution of your sample and double check that the correct peak has been called as the modal peak after you have used <code><a href="#topic+find_alleles">find_alleles()</a></code>. If a different peak is selected as the modal peak than usual, you need to go back to the metadata and adjust the repeat size of the size standard (For example, your size standard sample has been validated to have 120 repeats. You run <code><a href="#topic+find_alleles">find_alleles()</a></code> and look at the distribution of peaks and notice that the peak one repeat unit higher is the modal peak this time. Therefore, you're going to need to set the batch_sample_modal_repeat as 121 in the metadata just for that batch_run_id. In the other runs you would keep the batch_sample_modal_repeat as 120.).
</p>


<h3>Value</h3>

<p>This function modifies list of fragments objects in place with metadata added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gm_raw &lt;- trace::example_data
metadata &lt;- trace::metadata

test_fragments &lt;- peak_table_to_fragments(gm_raw,
  data_format = "genemapper5",
  dye_channel = "B",
  min_size_bp = 300
)

add_metadata(
  fragments_list = test_fragments,
  metadata_data.frame = metadata,
  unique_id = "unique_id",
  metrics_group_id = "metrics_group_id",
  metrics_baseline_control = "metrics_baseline_control",
  batch_run_id = "batch_run_id",
  batch_sample_id = "batch_sample_id",
  batch_sample_modal_repeat = "batch_sample_modal_repeat"
)

# skip unwanted metadata by using NA

add_metadata(
  fragments_list = test_fragments,
  metadata_data.frame = metadata,
  unique_id = "unique_id",
  metrics_group_id = "metrics_group_id",
  metrics_baseline_control = "metrics_baseline_control",
  batch_run_id = NA,
  batch_sample_id = NA,
  batch_sample_modal_repeat = NA
)

</code></pre>

<hr>
<h2 id='assign_index_peaks'>Assign index peaks</h2><span id='topic+assign_index_peaks'></span>

<h3>Description</h3>

<p>Assign index peaks in preparation for calculation of instability metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_index_peaks(
  fragments_list,
  grouped = FALSE,
  index_override_dataframe = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_index_peaks_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of &quot;fragments_repeats&quot; class objects representing
fragment data.</p>
</td></tr>
<tr><td><code id="assign_index_peaks_+3A_grouped">grouped</code></td>
<td>
<p>Logical value indicating whether samples should be grouped to
share a common index peak. <code>FALSE</code> will assign the sample's own modal allele as the index peak. <code>TRUE</code> will use metadata to assign the index peak based on the modal peak of another sample (see below for more details).</p>
</td></tr>
<tr><td><code id="assign_index_peaks_+3A_index_override_dataframe">index_override_dataframe</code></td>
<td>
<p>A data.frame to manually set index peaks.
Column 1: unique sample IDs, Column 2: desired index peaks (the order of the
columns is important since the information is pulled by column position rather
than column name). Closest peak in each sample is selected so the number needs to just be approximate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A key part of instability metrics is the index peak. This is the repeat
length used as the reference peak for relative instability metrics calculations, like expansion index.
This is usually the the inherited repeat length of a mouse, or the modal repeat length for the cell line at a starting time point.
</p>
<p>If <code>grouped</code> is set to <code>TRUE</code>, this function groups the samples by their <code>metrics_group_id</code> and uses the samples set as <code>metrics_baseline_control</code> to set the index peak. Use <code><a href="#topic+add_metadata">add_metadata()</a></code> to set these variables. This is useful for cases like inferring repeat size of inherited alleles from mouse tail data. If the samples that are going to be used to assign index peak are from different fragment analysis runs, use <code>correction = "batch"</code> in <code><a href="#topic+call_repeats">call_repeats()</a></code> to make sure the systematic differences between runs are corrected and the correct index peak is assigned. If there are multiple samples used as baseline control, the median value will be used to assign index peak to corresponding samples.
</p>
<p>For mice, if just a few samples have the inherited repeat signal shorter than the expanded population, you could not worry about this and instead use the <code>index_override_dataframe</code>. This can be used to manually override these assigned index repeat values (irrespective of whether <code>grouped</code> is TRUE or FALSE).
</p>
<p>As a final option, the index peak could be manually assigned directly to a <a href="#topic+fragments_repeats">fragments_repeats</a> class using the internal setter function fragments_repeats$set_index_peak().
</p>


<h3>Value</h3>

<p>This function modifies list of fragments_repeats objects in place with index_repeat and index_signal added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fsa_list &lt;- lapply(cell_line_fsa_list, function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

fragments_list &lt;- find_fragments(fsa_list,
  min_bp_size = 300
)

find_alleles(
  fragments_list
)
call_repeats(
  fragments_list
)

add_metadata(
  fragments_list,
  metadata_data.frame = trace::metadata
)

assign_index_peaks(
  fragments_list,
  grouped = TRUE
)

plot_traces(fragments_list[1], xlim = c(100,150))






</code></pre>

<hr>
<h2 id='calculate_instability_metrics'>Calculate Repeat Instability Metrics</h2><span id='topic+calculate_instability_metrics'></span>

<h3>Description</h3>

<p>This function computes instability metrics from a list of fragments_repeats data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_instability_metrics(
  fragments_list,
  peak_threshold = 0.05,
  window_around_index_peak = c(NA, NA),
  percentile_range = c(0.5, 0.75, 0.9, 0.95),
  repeat_range = c(2, 5, 10, 20)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_instability_metrics_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of &quot;fragments_repeats&quot; objects representing fragment data.</p>
</td></tr>
<tr><td><code id="calculate_instability_metrics_+3A_peak_threshold">peak_threshold</code></td>
<td>
<p>The threshold for peak signals to be considered in the calculations, relative to the modal peak signal of the expanded allele.</p>
</td></tr>
<tr><td><code id="calculate_instability_metrics_+3A_window_around_index_peak">window_around_index_peak</code></td>
<td>
<p>A numeric vector (length = 2) defining the range around the index peak. First number specifies repeats before the index peak, second after. For example, <code>c(-5, 40)</code> around an index peak of 100 would analyze repeats 95 to 140. The sign of the numbers does not matter (The absolute value is found).</p>
</td></tr>
<tr><td><code id="calculate_instability_metrics_+3A_percentile_range">percentile_range</code></td>
<td>
<p>A numeric vector of percentiles to compute (e.g., c(0.5, 0.75, 0.9, 0.95)).</p>
</td></tr>
<tr><td><code id="calculate_instability_metrics_+3A_repeat_range">repeat_range</code></td>
<td>
<p>A numeric vector specifying ranges of repeats for the inverse quantile computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each of the columns in the supplied dataframe are explained below:
</p>


<h4>General Information</h4>


<ul>
<li> <p><code>unique_id</code>: A unique identifier for the sample (usually the fsa file name).
</p>
</li></ul>




<h4>Quality Control</h4>


<ul>
<li> <p><code>QC_comments</code>: Quality control comments.
</p>
</li>
<li> <p><code>QC_modal_peak_signal</code>: Quality control status based on the modal peak signal (Low &lt; 500, very low &lt; 100).
</p>
</li>
<li> <p><code>QC_peak_number</code>: Quality control status based on the number of peaks (Low &lt; 20, very low &lt; 10).
</p>
</li>
<li> <p><code>QC_off_scale</code>: Quality control comments for off-scale peaks. Potential peaks that are off-scale are given. However, a caveat is that this could be from any of the channels (ie it could be from the ladder channel but is the same scan as the given repeat).
</p>
</li></ul>




<h4>General sample metrics</h4>


<ul>
<li> <p><code>modal_peak_repeat</code>: The repeat size of the modal peak.
</p>
</li>
<li> <p><code>modal_peak_signal</code>: The signal of the modal peak.
</p>
</li>
<li> <p><code>index_peak_repeat</code>: The repeat size of the index peak (the repeat value closest to the modal peak of the index sample).
</p>
</li>
<li> <p><code>index_peak_signal</code>: The signal of the index peak.
</p>
</li>
<li> <p><code>index_weighted_mean_repeat</code>: The weighted mean repeat size (weighted on the signal of the peaks) of the index sample.
</p>
</li>
<li> <p><code>n_peaks_total</code>: The total number of peaks in the repeat table.
</p>
</li>
<li> <p><code>n_peaks_analysis_subset</code>: The number of peaks in the analysis subset.
</p>
</li>
<li> <p><code>n_peaks_analysis_subset_expansions</code>: The number of expansion peaks in the analysis subset.
</p>
</li>
<li> <p><code>min_repeat</code>: The minimum repeat size in the analysis subset.
</p>
</li>
<li> <p><code>max_repeat</code>: The maximum repeat size in the analysis subset.
</p>
</li>
<li> <p><code>mean_repeat</code>: The mean repeat size in the analysis subset.
</p>
</li>
<li> <p><code>weighted_mean_repeat</code>: The weighted mean repeat size (weight on peak signal) in the analysis subset.
</p>
</li>
<li> <p><code>median_repeat</code>: The median repeat size in the analysis subset.
</p>
</li>
<li> <p><code>max_signal</code>: The maximum peak signal in the analysis subset.
</p>
</li>
<li> <p><code>max_delta_neg</code>: The maximum negative delta to the index peak.
</p>
</li>
<li> <p><code>max_delta_pos</code>: The maximum positive delta to the index peak.
</p>
</li>
<li> <p><code>skewness</code>: The skewness of the repeat size distribution.
</p>
</li>
<li> <p><code>kurtosis</code>: The kurtosis of the repeat size distribution.
</p>
</li></ul>




<h4>Repeat instability metrics</h4>


<ul>
<li> <p><code>modal_repeat_change</code>: The difference between the modal repeat and the index repeat.
</p>
</li>
<li> <p><code>average_repeat_change</code>: The weighted mean of the sample (weighted by peak signal) subtracted by the weighted mean repeat of the index sample(s).
</p>
</li>
<li> <p><code>instability_index_change</code>: The instability index of the sample subtracted by the instability index of the index sample(s). This will be very similar to the average_repeat_change, with the key difference of instability_index_change being that it is an internally calculated metric for each sample, and therefore the random slight fluctuations of bp size (or systematic if across plates for example) will be removed. However, it requires the index peak to be correctly set for each sample, and if set incorrectly, can produce large arbitrary differences.
</p>
</li>
<li> <p><code>instability_index</code>: The instability index based on peak signal and distance to the index peak. (See Lee et al., 2010, <a href="https://doi.org/10.1186/1752-0509-4-29">doi:10.1186/1752-0509-4-29</a>).
</p>
</li>
<li> <p><code>instability_index_abs</code>: The absolute instability index. The absolute value is taken for the &quot;Change from the main allele&quot;.
</p>
</li>
<li> <p><code>expansion_index</code>: The instability index for expansion peaks only.
</p>
</li>
<li> <p><code>contraction_index</code>: The instability index for contraction peaks only.
</p>
</li>
<li> <p><code>expansion_ratio</code>: The ratio of expansion peaks' signals to the main peak signal. Also known as &quot;peak proportional sum&quot; (See Genetic Modifiers of Huntington’s Disease (GeM-HD) Consortium, 2019, <a href="https://doi.org/10.1016/j.cell.2019.06.036">doi:10.1016/j.cell.2019.06.036</a>).
</p>
</li>
<li> <p><code>contraction_ratio</code>: The ratio of contraction peaks' signals to the main peak signal.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;expansion_percentile_*&#8288;</code>: The repeat size at specified percentiles of the cumulative distribution of expansion peaks.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;expansion_percentile_for_repeat_*&#8288;</code>: The percentile rank of specified repeat sizes in the distribution of expansion peaks.
</p>
</li></ul>




<h3>Value</h3>

<p>A data.frame with calculated instability metrics for each sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_raw &lt;- trace::example_data
metadata &lt;- trace::metadata

test_fragments &lt;- peak_table_to_fragments(gm_raw,
  data_format = "genemapper5",
  dye_channel = "B",
  min_size_bp = 400
)

add_metadata(
  fragments_list = test_fragments,
  metadata_data.frame = metadata
)

find_alleles(
  fragments_list = test_fragments,
  peak_region_size_gap_threshold = 6,
  peak_region_signal_threshold_multiplier = 1
)


call_repeats(
  fragments_list = test_fragments,
  assay_size_without_repeat = 87,
  repeat_size = 3
)

assign_index_peaks(
  fragments_list = test_fragments,
  grouped = TRUE
)


# grouped metrics
# uses t=0 samples as indicated in metadata
test_metrics_grouped &lt;- calculate_instability_metrics(
  fragments_list = test_fragments,
  peak_threshold = 0.05,
  window_around_index_peak = c(-40, 40),
  percentile_range = c(0.5, 0.75, 0.9, 0.95),
  repeat_range = c(2, 5, 10, 20)
)
</code></pre>

<hr>
<h2 id='call_repeats'>Call Repeats for Fragments</h2><span id='topic+call_repeats'></span>

<h3>Description</h3>

<p>This function calls the repeat lengths for a list of fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_repeats(
  fragments_list,
  assay_size_without_repeat = 87,
  repeat_size = 3,
  correction = "none",
  force_whole_repeat_units = FALSE,
  force_repeat_pattern = FALSE,
  force_repeat_pattern_size_period = repeat_size * 0.93,
  force_repeat_pattern_size_window = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="call_repeats_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_repeats objects containing fragment data.</p>
</td></tr>
<tr><td><code id="call_repeats_+3A_assay_size_without_repeat">assay_size_without_repeat</code></td>
<td>
<p>An integer specifying the assay size without repeat for repeat calling. This is the length of the sequence flanking the repeat in the PCR product.</p>
</td></tr>
<tr><td><code id="call_repeats_+3A_repeat_size">repeat_size</code></td>
<td>
<p>An integer specifying the repeat size for repeat calling. Default is 3.</p>
</td></tr>
<tr><td><code id="call_repeats_+3A_correction">correction</code></td>
<td>
<p>A character vector of either &quot;batch&quot; to carry out a batch correction from common samples across runs (known repeat length not required), or &quot;repeat&quot; to use samples with validated modal repeat lengths to correct the repeat length. Requires metadata to be added (see <code><a href="#topic+add_metadata">add_metadata()</a></code>) with both &quot;batch&quot; and &quot;repeat&quot; requiring <code>"batch_run_id"</code>, &quot;batch&quot; requiring (<code>"batch_sample_id"</code>) and &quot;repeat&quot; requiring <code>"batch_sample_modal_repeat"</code> (but also benefits from having <code>"batch_sample_id"</code>).</p>
</td></tr>
<tr><td><code id="call_repeats_+3A_force_whole_repeat_units">force_whole_repeat_units</code></td>
<td>
<p>A logical value specifying if the peaks should be forced to be whole repeat units apart. Usually the peaks are slightly under the whole repeat unit if left unchanged.</p>
</td></tr>
<tr><td><code id="call_repeats_+3A_force_repeat_pattern">force_repeat_pattern</code></td>
<td>
<p>A logical value specifying if the peaks should be re called to fit the specific repeat unit pattern. This requires trace information so you must have started with fsa files.</p>
</td></tr>
<tr><td><code id="call_repeats_+3A_force_repeat_pattern_size_period">force_repeat_pattern_size_period</code></td>
<td>
<p>A numeric value to set the peak periodicity bp size. In fragment analysis, the peaks are usually slightly below the actual repeat unit size, so you can use this value to fine tune what the periodicity should be.</p>
</td></tr>
<tr><td><code id="call_repeats_+3A_force_repeat_pattern_size_window">force_repeat_pattern_size_window</code></td>
<td>
<p>A numeric value for the size window when assigning the peak. The algorithm jumps to the predicted scan for the next peak. This value opens a window of the given base pair size neighboring scans to pick the tallest in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has a lot of different options features for determining the repeat length of your samples. This includes i) an option to force the peaks to be whole repeat units apart, ii) corrections to correct batch effects or accurately call repeat length by comparing to samples of known length, and iii) algorithms or re-calling the peaks to remove any contaminating peaks or shoulder-peaks.
</p>
<p>&mdash;&mdash;&mdash;&mdash; correction &mdash;&mdash;&mdash;&mdash;
</p>
<p>There are two main correction approaches that are somewhat related: either 'batch' or 'repeat'. Batch correction is relatively simple and just requires you to link samples across batches to correct batch-batch variation in repeat sizes. However, even though the repeat size that is return will be precise, it will not be accurate and underestimates the real repeat length. By contrast, repeat correction can be used to accurately call repeat lengths (which also corrects the batch effects). However, the repeat correction will only be as good as your sample used to call the repeat length so this is a challenging and advanced feature. You need to use a sample that reliably returns the same peak as the modal peak, or you need to be willing to understand the shape of the distribution and manually validate the repeat length of each batch_sample_id for each run.
</p>

<ul>
<li><p> Batch correction uses common sample(s) across fragment analysis runs to correct systematic batch effects that occur with repeat-containing amplicons in capillary electrophoresis. There are slight fluctuations of size across runs for amplicons containing repeats that result in systematic differences around 1-3 base pairs. So, if samples are to be analyzed for different runs, the absolute bp size is not comparable unless this batch effect is corrected. This is only relevant when the absolute size of a amplicons are compared for grouping metrics as described above (otherwise instability metrics are all relative and it doesn’t matter that there’s systematic batch effects across runs) or when plotting traces from different runs. This correction can be achieved by running a couple of samples in every fragment analysis run, or having a single run that takes a couple of samples from every run together, thereby linking them. These samples are then indicated in the metadata with batch_run_id (to group samples by fragment analysis run) and batch_sample_id (to enable linking samples across batches) (see <code><a href="#topic+add_metadata">add_metadata()</a></code>). Use <code><a href="#topic+plot_batch_correction_samples">plot_batch_correction_samples()</a></code> to plot the samples before and after correction to make sure that is has worked as expected.
</p>
</li>
<li><p> Samples with known and validated repeat size can be used to accurately call the repeat length (and therefore also correct batch effects). Similar to batch correction, batch_run_id (to group samples by fragment analysis run) and batch_sample_id (to enable linking samples across batches) are used, but importantly batch_sample_modal_repeat is also set (see <code><a href="#topic+add_metadata">add_metadata()</a></code>). The batch_sample_modal_repeat is the validated repeat length of the modal repeat of the sample. This validated repeat length is then used to call the repeat length of the modal repeat for each sample (by each batch_run_id). Importantly, this correction requires you to know with confidence the repeat length of the modal peak of the sample. Therefore it's important that the sample used for repeat correction has a clear and prominent modal peak. If the repeat length is very long, it's common for the modal peak of a sample to change so if you use this feature you're going to have to understand the shape of the distribution of your sample and double check that the correct peak has been called as the modal peak after you have used <code><a href="#topic+find_alleles">find_alleles()</a></code>. If a different peak is selected as the modal peak than usual, you need to go back to the metadata and adjust the repeat size of the size standard (For example, your size standard sample has been validated to have 120 repeats. You run <code><a href="#topic+find_alleles">find_alleles()</a></code> and look at the distribution of peaks and notice that the peak one repeat unit higher is the modal peak this time. Therefore, you're going to need to set the batch_sample_modal_repeat as 121 in the metadata just for that batch_run_id. In the other runs you would keep the batch_sample_modal_repeat as 120.). For repeat correction, there are several functions to help visualize and summarize the correction:
</p>

<ul>
<li><p> Use <code><a href="#topic+plot_batch_correction_samples">plot_batch_correction_samples()</a></code> to visualize the same sample across different batches. This can be helpful to make sure that the correction has worked the same across different runs.
</p>
</li>
<li><p> Use <code><a href="#topic+plot_repeat_correction_model">plot_repeat_correction_model()</a></code> to visualize the linear model use to correct repeat length for each <code>batch_run_id</code>. This can be helpful to make sure the supplied repeat length of different samples are lining up within each run.
</p>
</li>
<li><p> Generate a summary table of the predicted repeat length for each sample and the average residuals using <code><a href="#topic+extract_repeat_correction_summary">extract_repeat_correction_summary()</a></code>. This can be helpful to pinpoint the sample(s) that need adjusting.
</p>
</li></ul>

</li></ul>

<p>&mdash;&mdash;&mdash;&mdash;  force_whole_repeat_units &mdash;&mdash;&mdash;&mdash;
</p>
<p>The <code>force_whole_repeat_units</code> option aims to correct for the systematic underestimation in fragment sizes that occurs in capillary electrophoresis. It is independent to the algorithms described above and can be used in conjunction. It modifies repeat lengths in a way that helps align peaks with the underlying repeat pattern, making the repeat lengths whole units (rather than ~0.9 repeats). The calculated repeat lengths start from the main peak's repeat length and increases in increments of the specified <code>repeat_size</code> in either direction. This option basically enables you to get exactly the same result as expansion_index values calculated from data from Genemapper.
</p>
<p>&mdash;&mdash;&mdash;&mdash;  force_repeat_pattern &mdash;&mdash;&mdash;&mdash;
</p>
<p>This parameter re-calls the peaks based on specified (<code>force_repeat_pattern_size_period</code>) periodicity of the peaks. The main application of this algorithm is to solve the issue of contaminating peaks in the expected regular pattern of peaks. We can use the periodicity to jump between peaks and crack open a window (<code>force_repeat_pattern_size_window</code>) to then pick out the tallest scan in the window.
</p>


<h3>Value</h3>

<p>This function modifies list of fragments objects in place with repeats added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_alleles">find_alleles()</a></code>, <code><a href="#topic+add_metadata">add_metadata()</a></code>, <code><a href="#topic+plot_batch_correction_samples">plot_batch_correction_samples()</a></code>, <code><a href="#topic+plot_repeat_correction_model">plot_repeat_correction_model()</a></code>, <code><a href="#topic+extract_repeat_correction_summary">extract_repeat_correction_summary()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fsa_list &lt;- lapply(cell_line_fsa_list[c(16:19)], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

fragments_list &lt;- find_fragments(
  fsa_list,
  min_bp_size = 300
)

find_alleles(fragments_list)

add_metadata(fragments_list,
   metadata[c(16:19), ]
)

# Simple conversion from bp size to repeat size
call_repeats(
  fragments_list,
  assay_size_without_repeat = 87,
  repeat_size = 3
)

plot_traces(fragments_list[1], xlim = c(120, 170))

# Use force_whole_repeat_units algorithm to make sure called
# repeats are the exact number of bp apart

call_repeats(
  fragments_list,
  force_whole_repeat_units = TRUE,
  assay_size_without_repeat = 87,
  repeat_size = 3
)

plot_traces(fragments_list[1], xlim = c(120, 170))


# apply batch correction
call_repeats(
  fragments_list,
  correction = "batch",
  assay_size_without_repeat = 87,
  repeat_size = 3
)

plot_traces(fragments_list[1], xlim = c(120, 170))

# apply repeat correction
call_repeats(
  fragments_list,
  correction = "repeat",
  assay_size_without_repeat = 87,
  repeat_size = 3
)

plot_traces(fragments_list[1], xlim = c(120, 170))

#ensure only periodic peaks are called
call_repeats(
  fragments_list,
  force_repeat_pattern = TRUE,
  force_repeat_pattern_size_period = 2.75,
  assay_size_without_repeat = 87,
  repeat_size = 3
)

plot_traces(fragments_list[1], xlim = c(120, 170))

</code></pre>

<hr>
<h2 id='cell_line_fsa_list'>A list of fsa files</h2><span id='topic+cell_line_fsa_list'></span>

<h3>Description</h3>

<p>A list of fsa files read into R using trace::read_fsa() that for example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_line_fsa_list
</code></pre>


<h3>Format</h3>



<h4><code>cell_line_fsa_list</code></h4>

<p>A list with 92 elements, each one being the contents of an fsa file:
</p>



<h3>Source</h3>

<p><a href="https://doi.org/10.1038/s41467-024-47485-0">doi:10.1038/s41467-024-47485-0</a>
</p>

<hr>
<h2 id='example_data'>example_data</h2><span id='topic+example_data'></span>

<h3>Description</h3>

<p>example_data is genemapper output peak table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_data
</code></pre>


<h3>Format</h3>



<h4><code>example_data</code></h4>

<p>A genemapper output dataframe
</p>



<h3>Source</h3>

<p><a href="https://doi.org/10.1038/s41467-024-47485-0">doi:10.1038/s41467-024-47485-0</a>
</p>

<hr>
<h2 id='example_data_repeat_table'>example_data_repeat_table</h2><span id='topic+example_data_repeat_table'></span>

<h3>Description</h3>

<p>example_data_repeat_table is data with repeats called
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_data_repeat_table
</code></pre>


<h3>Format</h3>



<h4><code>example_data_repeat_table</code></h4>

<p>A genemapper output dataframe
</p>



<h3>Source</h3>

<p><a href="https://doi.org/10.1038/s41467-024-47485-0">doi:10.1038/s41467-024-47485-0</a>
</p>

<hr>
<h2 id='extract_alleles'>Extract Modal Peaks</h2><span id='topic+extract_alleles'></span>

<h3>Description</h3>

<p>Extracts modal peak information from each sample in a list of fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_alleles(fragments_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_alleles_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_repeats objects containing fragment data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing modal peak information for each sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_raw &lt;- trace::example_data

test_fragments &lt;- peak_table_to_fragments(gm_raw,
  data_format = "genemapper5",
  dye_channel = "B",
  min_size_bp = 400
)

find_alleles(
  fragments_list = test_fragments,
  peak_region_size_gap_threshold = 6,
  peak_region_signal_threshold_multiplier = 1
)

extract_alleles(test_fragments)

</code></pre>

<hr>
<h2 id='extract_fragments'>Extract All Fragments</h2><span id='topic+extract_fragments'></span>

<h3>Description</h3>

<p>Extracts peak data from each sample in a list of fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_fragments(fragments_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_fragments_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_repeats objects containing fragment data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing peak data for each sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_raw &lt;- trace::example_data
metadata &lt;- trace::metadata

test_fragments &lt;- peak_table_to_fragments(gm_raw,
  data_format = "genemapper5",
  dye_channel = "B",
  min_size_bp = 400
)

add_metadata(
  fragments_list = test_fragments,
  metadata_data.frame = metadata
)

find_alleles(
  fragments_list = test_fragments
)

call_repeats(
  fragments_list = test_fragments,
  assay_size_without_repeat = 87,
  repeat_size = 3
)

extract_alleles(test_fragments)

</code></pre>

<hr>
<h2 id='extract_ladder_summary'>Extract ladder summary</h2><span id='topic+extract_ladder_summary'></span>

<h3>Description</h3>

<p>Extract a table summarizing the ladder models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_ladder_summary(fragments_trace_list, sort = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_ladder_summary_+3A_fragments_trace_list">fragments_trace_list</code></td>
<td>
<p>a list of fragments trace objects</p>
</td></tr>
<tr><td><code id="extract_ladder_summary_+3A_sort">sort</code></td>
<td>
<p>A logical statement for if the samples should be ordered by average ladder R-squared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ladder peaks are assigned using a custom algorithm that maximizes the fit of detected ladder peaks and given base-pair sizes. This function summarizes the R-squared values of these individual correlations.
</p>


<h3>Value</h3>

<p>a dataframe of ladder quality information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  fsa_list &lt;- lapply(cell_line_fsa_list, function(x) x$clone())

  find_ladders(fsa_list, show_progress_bar = FALSE)

  extract_ladder_summary(fsa_list, sort = TRUE)
</code></pre>

<hr>
<h2 id='extract_repeat_correction_summary'>Extract repeat correction summary</h2><span id='topic+extract_repeat_correction_summary'></span>

<h3>Description</h3>

<p>Extracts a table summarizing the model used to correct repeat length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_repeat_correction_summary(fragments_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_repeat_correction_summary_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_repeats class objects obtained from the <code><a href="#topic+call_repeats">call_repeats()</a></code> function when the <code>correction = "repeat"</code> parameter is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of the samples used for repeat correction, this table pulls out the modal repeat length called by the model (<code>allele_repeat</code>), how far that sample is on average from the linear model in repeat units by finding the average residuals (<code>avg_residual</code>), and the absolute value of the <code>avg_residual</code> (<code>abs_avg_residual</code>)
</p>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fsa_list &lt;- lapply(cell_line_fsa_list[16:19], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

fragments_list &lt;- find_fragments(fsa_list, min_bp_size = 300)

test_alleles &lt;- find_alleles(
  fragments_list 
)

add_metadata(
  fragments_list,
  metadata
)


call_repeats(
  fragments_list = fragments_list,
  correction = "repeat"
)

# finally extract repeat correction summary
extract_repeat_correction_summary(fragments_list)


</code></pre>

<hr>
<h2 id='extract_trace_table'>Extract traces</h2><span id='topic+extract_trace_table'></span>

<h3>Description</h3>

<p>Extract the raw trace from a list of fragments objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_trace_table(fragments_trace_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_trace_table_+3A_fragments_trace_list">fragments_trace_list</code></td>
<td>
<p>a list of fragments objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of the raw trace data. Each row representing a single scan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fsa_list &lt;- lapply(cell_line_fsa_list[1], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

extracted_traces &lt;- extract_trace_table(fsa_list)

</code></pre>

<hr>
<h2 id='find_alleles'>Find Alleles</h2><span id='topic+find_alleles'></span>

<h3>Description</h3>

<p>This function identifies main allele within each fragment object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_alleles(
  fragments_list,
  number_of_alleles = 1,
  peak_region_size_gap_threshold = 6,
  peak_region_signal_threshold_multiplier = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_alleles_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragment objects containing peak data.</p>
</td></tr>
<tr><td><code id="find_alleles_+3A_number_of_alleles">number_of_alleles</code></td>
<td>
<p>Number of alleles to be returned for each fragment. Must either be 1 or 2. Being able to identify two alleles is for cases when you are analyze different human samples with a normal and expanded alleles and you can't do the preferred option of simply ignoring the normal allele in <code><a href="#topic+find_fragments">find_fragments()</a></code> (eg setting the min_bp_size above the normal allele bp size).</p>
</td></tr>
<tr><td><code id="find_alleles_+3A_peak_region_size_gap_threshold">peak_region_size_gap_threshold</code></td>
<td>
<p>Gap threshold for identifying peak regions. The peak_region_size_gap_threshold is a parameter used to determine the maximum allowed gap between peak sizes within a peak region. Adjusting this parameter affects the size range of peaks that can be grouped together in a region. A smaller value makes it more stringent, while a larger value groups peaks with greater size differences, leading to broader peak regions that may encompass wider size ranges.</p>
</td></tr>
<tr><td><code id="find_alleles_+3A_peak_region_signal_threshold_multiplier">peak_region_signal_threshold_multiplier</code></td>
<td>
<p>Multiplier for the peak signal threshold. The peak_region_signal_threshold_multiplier parameter allows adjusting the threshold for identifying peak regions based on peak signals. Increasing this multiplier value will result in higher thresholds, making it more stringent to consider peaks as part of a peak region. Conversely, reducing the multiplier value will make the criteria less strict, potentially leading to more peaks being grouped into peak regions. It's important to note that this parameter's optimal value depends on the characteristics of the data and the specific analysis goals. Choosing an appropriate value for this parameter can help in accurately identifying meaningful peak regions in the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the main alleles for each fragment in the list by identifying clusters of peaks (&quot;peak regions&quot;) with the highest signal intensities. This is based on the idea that PCR amplicons of repeats have clusters of peaks (from somatic mosaicism and PCR artifacts) that help differentiate the main allele of interest from capillary electrophoresis noise/contamination.
</p>
<p>If number_of_alleles = 1, the tallest of peaks will be selected as the allele. This means that if your sample has multiple alleles, you have two options i) make sure that your data is subsetted to only include the allele of interest (using <code>min_bp_size</code> in <code><a href="#topic+find_fragments">find_fragments()</a></code> to make sure that the smaller allele is excluded), or ii) setting number_of_alleles = 2, which will pick the two tallest peaks in their respective peak regions and set the main allele as the larger repeat size, and allele_2 as the shorter repeat size. We recommend the subsetting approach since that is far simpler and less likely to fail, and the second option only if you're doing an experiment analysis a large number of human samples where both the normal and expanded allele repeat lengths vary, which makes it very difficult to find a common bp size that excludes the normal allele.
</p>
<p>The parameters <code>peak_region_signal_threshold_multiplier</code> and <code>peak_region_size_gap_threshold</code> will only need to be adjusted in rare cases if peaks are not being found for some reason. They influence the criteria for identifying peak regions. peak_region_signal_threshold_multiplier is multiplied to the mean height of all the peaks to create a hight threshold for inclusion into the peak region, so most of the time it's already a very low value and probably only needs to be changed if you have very few peaks. peak_region_size_gap_threshold is the distance between the peaks, either bp size, or repeats if repeats have already been called.
</p>


<h3>Value</h3>

<p>This function modifies list of fragments_repeats objects in place with alleles added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fsa_list &lt;- lapply(cell_line_fsa_list[1], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

fragments_list &lt;- find_fragments(fsa_list,
  min_bp_size = 300
)


find_alleles(
  fragments_list,
  peak_region_size_gap_threshold = 6,
  peak_region_signal_threshold_multiplier = 1
)
</code></pre>

<hr>
<h2 id='find_fragments'>Find fragment peaks</h2><span id='topic+find_fragments'></span>

<h3>Description</h3>

<p>Find fragment peaks in continuous trace data and convert to fragments_repeats
class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_fragments(
  fragments_trace_list,
  smoothing_window = 21,
  minimum_peak_signal = 20,
  min_bp_size = 100,
  max_bp_size = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_fragments_+3A_fragments_trace_list">fragments_trace_list</code></td>
<td>
<p>A list of fragments_trace objects containing fragment data.</p>
</td></tr>
<tr><td><code id="find_fragments_+3A_smoothing_window">smoothing_window</code></td>
<td>
<p>numeric: signal smoothing window size passed to pracma::savgol()</p>
</td></tr>
<tr><td><code id="find_fragments_+3A_minimum_peak_signal">minimum_peak_signal</code></td>
<td>
<p>numeric: minimum signal of the raw trace. To have no minimum signal set as &quot;-Inf&quot;.</p>
</td></tr>
<tr><td><code id="find_fragments_+3A_min_bp_size">min_bp_size</code></td>
<td>
<p>numeric: minimum bp size of peaks to consider</p>
</td></tr>
<tr><td><code id="find_fragments_+3A_max_bp_size">max_bp_size</code></td>
<td>
<p>numeric: maximum bp size of peaks to consider</p>
</td></tr>
<tr><td><code id="find_fragments_+3A_...">...</code></td>
<td>
<p>pass additional arguments to pracma::findpeaks(), or change the default arguments
we set. minimum_peak_signal above is passed to pracma::findpeaks() as minpeakheight, and
peakpat has been set to '[+]{6,}[0]*[-]{6,}' so that peaks with flat tops are
still called, see https://stackoverflow.com/questions/47914035/identify-sustained-peaks-using-pracmafindpeaks</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+find_fragments">find_fragments()</a></code> takes in a list of fragments_trace objects and returns a list of new fragments_repeats objects.
</p>
<p>This function is basically a wrapper around pracma::findpeaks. As mentioned above,
the default arguments arguments of pracma::findpeaks can be changed by passing them
to find_fragments with ... .
</p>
<p>If too many and inappropriate peaks are being called, this may also be solved with the different repeat calling algorithms in <code><a href="#topic+call_repeats">call_repeats()</a></code>.
</p>


<h3>Value</h3>

<p>a list of fragments_repeats objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fsa_list &lt;- lapply(cell_line_fsa_list[1], function(x) x$clone())

find_ladders(fsa_list)

fragments_list &lt;- find_fragments(fsa_list,
  min_bp_size = 300
)


# Manually inspect the ladders
plot_traces(fragments_list,
  show_peaks = TRUE, n_facet_col = 1,
  xlim = c(400, 550), ylim = c(0, 1200)
)
</code></pre>

<hr>
<h2 id='find_ladders'>Ladder and bp sizing</h2><span id='topic+find_ladders'></span>

<h3>Description</h3>

<p>Find the ladder peaks in and use that to call bp size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ladders(
  fragments_trace,
  ladder_channel = "DATA.105",
  signal_channel = "DATA.1",
  ladder_sizes = c(50, 75, 100, 139, 150, 160, 200, 250, 300, 340, 350, 400, 450, 490,
    500),
  ladder_start_scan = NULL,
  minimum_peak_signal = NULL,
  scan_subset = NULL,
  ladder_selection_window = 5,
  max_combinations = 2500000,
  warning_rsq_threshold = 0.998,
  show_progress_bar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_ladders_+3A_fragments_trace">fragments_trace</code></td>
<td>
<p>list from 'read_fsa' function</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_ladder_channel">ladder_channel</code></td>
<td>
<p>string: which channel in the fsa file contains the
ladder signal</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_signal_channel">signal_channel</code></td>
<td>
<p>string: which channel in the fsa file contains the data
signal</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_ladder_sizes">ladder_sizes</code></td>
<td>
<p>numeric vector: bp sizes of ladder used in fragment analysis.
defaults to GeneScan™ 500 LIZ™</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_ladder_start_scan">ladder_start_scan</code></td>
<td>
<p>numeric: indicate the scan number to start looking for
ladder peaks. Usually this can be automatically found (when set to NULL) since
there's a big spike right at the start. However, if your ladder peaks
are taller than the big spike, you will need to set this starting scan
number manually.</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_minimum_peak_signal">minimum_peak_signal</code></td>
<td>
<p>numeric: minimum signal of peak from smoothed signal.</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_scan_subset">scan_subset</code></td>
<td>
<p>numeric vector (length 2): filter the ladder and data signal
between the selected scans (eg scan_subset = c(3000, 5000)).
to pracma::savgol().</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_ladder_selection_window">ladder_selection_window</code></td>
<td>
<p>numeric: in the ladder assigning algorithm,
the we iterate through the scans in blocks and test their linear fit ( We can assume that the ladder is linear over a short distance)
This value defines how large that block of peaks should be.</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_max_combinations">max_combinations</code></td>
<td>
<p>numeric: what is the maximum number of ladder
combinations that should be tested</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_warning_rsq_threshold">warning_rsq_threshold</code></td>
<td>
<p>The value for which this function will warn you when parts of the ladder have R-squared values below the specified threshold.</p>
</td></tr>
<tr><td><code id="find_ladders_+3A_show_progress_bar">show_progress_bar</code></td>
<td>
<p>show progress bar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a list of fragments_trace files (the output from read_fsa) and identifies
the ladders in the ladder channel which is used to call the bp size. The output
is a list of fragments_traces.
</p>
<p>In this package, base pair (bp) sizes are assigned using a generalized additive model (GAM) with cubic regression splines. The model is fit to known ladder fragment sizes and their corresponding scan positions, capturing the relationship between scan number and bp size. Once trained, the model predicts bp sizes for all scans by interpolating between the known ladder points. This approach provides a flexible and accurate assignment of bp sizes, accommodating the slightly non-linear relationship.
</p>
<p>Use <code><a href="#topic+plot_data_channels">plot_data_channels()</a></code> to plot the raw data on the fsa file to identify which channel the ladder and data are in.
</p>
<p>The ladder peaks are assigned from largest to smallest. I would recommend excluding
size standard peaks less than 50 bp (eg size standard 35 bp).
</p>
<p>Each ladder should be manually inspected to make sure that is has been correctly assigned.
</p>


<h3>Value</h3>

<p>This function modifies list of fragments_trace objects in place with the ladder assigned and base pair calculated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_data_channels">plot_data_channels()</a></code> to plot the raw data in all channels. <code><a href="#topic+plot_ladders">plot_ladders()</a></code> to plot the assigned ladder
peaks onto the raw ladder signal. <code><a href="#topic+fix_ladders_interactive">fix_ladders_interactive()</a></code> to fix ladders with
incorrectly assigned peaks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fsa_list &lt;- lapply(cell_line_fsa_list[1], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

# Manually inspect the ladders
plot_ladders(fsa_list[1])

</code></pre>

<hr>
<h2 id='fix_ladders_interactive'>Fix ladders interactively</h2><span id='topic+fix_ladders_interactive'></span>

<h3>Description</h3>

<p>An app for fixing ladders
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_ladders_interactive(fragment_trace_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_ladders_interactive_+3A_fragment_trace_list">fragment_trace_list</code></td>
<td>
<p>A list of fragments_trace objects containing fragment data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps you fix ladders that are incorrectly assigned. Run <code>fix_ladders_interactive()</code>
and provide output from <code>find_ladders</code>. In the app, for each sample, click on
line for the incorrect ladder size and drag it to the correct peak.
</p>
<p>Once you are satisfied with the ladders for all the broken samples, click the download
button to generate a file that has the ladder correction data. Read this file
back into R using readRDS, then use <code><a href="#topic+fix_ladders_manual">fix_ladders_manual()</a></code> and supply the ladder
correction data as <code>ladder_df_list</code>. This allows the manually corrected data to
be saved and used within a script so that the correct does not need to be done
every time. An example of what you would need to do:
</p>
<p>ladder_df_list &lt;- readRDS('path/to/exported/data.rds')
test_ladders_fixed &lt;- fix_ladders_manual(test_ladders_broken, ladder_df_list)
</p>


<h3>Value</h3>

<p>interactive shiny app for fixing ladders
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fix_ladders_manual">fix_ladders_manual()</a></code>, <code><a href="#topic+find_ladders">find_ladders()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fsa_list &lt;- lapply(cell_line_fsa_list["20230413_A08.fsa"], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

# to create an example, lets brake one of the ladders
brake_ladder_list &lt;-  list(
   "20230413_A08.fsa" = data.frame(
     size = c(35, 50, 75, 100, 139, 150, 160, 200, 250, 300, 340, 350, 400, 450, 490, 500),
     scan = c(1544, 1621, 1850, 1912, 2143, 2201, 2261, 2506, 2805, 3135, 3380, 3442, 3760, 
              4050, 4284, 4332)
   )
 )

fix_ladders_manual(
  fsa_list,
  brake_ladder_list
)

plot_ladders(fsa_list)


if (interactive()) {
  fix_ladders_interactive(fsa_list)
}

# once you have corrected your ladders in the app, 
# export the data for incorporation into the script.
# You can then re-import the data and fix ladders as described in the help details.

</code></pre>

<hr>
<h2 id='fix_ladders_manual'>Fix ladders manually</h2><span id='topic+fix_ladders_manual'></span>

<h3>Description</h3>

<p>Manually assign the ladder peaks for samples in a fragments_trace_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_ladders_manual(
  fragments_trace_list,
  ladder_df_list,
  warning_rsq_threshold = 0.998
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fix_ladders_manual_+3A_fragments_trace_list">fragments_trace_list</code></td>
<td>
<p>list of fragments_trace objects</p>
</td></tr>
<tr><td><code id="fix_ladders_manual_+3A_ladder_df_list">ladder_df_list</code></td>
<td>
<p>a list of dataframes, with the names being the unique id
and the value being a dataframe. The dataframe has two columns, size (indicating
the bp of the standard) and scan (the scan value of the ladder peak). It's
critical that the element name in the list is the unique id of the sample.</p>
</td></tr>
<tr><td><code id="fix_ladders_manual_+3A_warning_rsq_threshold">warning_rsq_threshold</code></td>
<td>
<p>The value for which this function will warn you when parts of the ladder have R-squared values below the specified threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a fragments_trace list the same length as was supplied.
It goes through each sample and either just returns the same fragments_trace
if the unique id doesn't match the samples that need the ladder fixed, or if
it is one to fix, it will use the supplied dataframe in the ladder_df_list
as the ladder. It then reruns the bp sizing methods on those samples.
</p>
<p>This is best used with <code><a href="#topic+fix_ladders_interactive">fix_ladders_interactive()</a></code> that can generate a <code>ladder_df_list</code>.
</p>


<h3>Value</h3>

<p>This function modifies list of fragments_trace objects in place with the selected ladders fixed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fsa_list &lt;- lapply(cell_line_fsa_list[1], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

# first manually determine the real ladder peaks using your judgment
# the raw ladder signal can be extracted
raw_ladder &lt;- fsa_list[1]$raw_ladder

# or we can look at the "trace_bp_df" to see a dataframe that includes the scan and ladder signal
raw_ladder_df &lt;- fsa_list[[1]]$trace_bp_df[, c("unique_id", "scan", "ladder_signal")]
plot(raw_ladder_df$scan, raw_ladder_df$ladder_signal)

# once you have figured what sizes align with which peak, make a dataframe. The
# fix_ladders_manual() function takes a list as an input so that multiple ladders
# can be fixed. Each sample would have the the list element name as it's unique id.

example_list &lt;- list(
 "20230413_A07.fsa" = data.frame(
   size = c(100, 139, 150, 160, 200, 250, 300, 340, 350, 400, 450, 490, 500),
   scan = c(1909, 2139, 2198, 2257, 2502, 2802, 3131, 3376, 3438, 3756, 4046, 4280, 4328)
 )
)

fix_ladders_manual(
  fsa_list,
  example_list
)

</code></pre>

<hr>
<h2 id='fragments'>fragments object</h2><span id='topic+fragments'></span>

<h3>Description</h3>

<p>An R6 Class representing a fragments object.
</p>


<h3>Details</h3>

<p>This is the parent class of both fragments_trace and fragments_repeats object. The idea is that shared fields and methods are both inherited from this object, but it is not itself directly used.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>unique_id</code></dt><dd><p>unique id of the sample usually the file name</p>
</dd>
<dt><code>metrics_group_id</code></dt><dd><p>sample grouping for metrics calculations. Associated with <code>add_metadata()</code>.</p>
</dd>
<dt><code>metrics_baseline_control</code></dt><dd><p>logical to indicate if sample is the baseline control. Associated with <code>add_metadata()</code>.</p>
</dd>
<dt><code>batch_run_id</code></dt><dd><p>fragment analysis run. Associated with <code>add_metadata()</code>.</p>
</dd>
<dt><code>batch_sample_id</code></dt><dd><p>An id for the sample used as size standard for repeat calculation. Associated with <code>add_metadata()</code>.</p>
</dd>
<dt><code>batch_sample_modal_repeat</code></dt><dd><p>Validated repeat length for the modal repeat repeat in that sample. Associated with <code>add_metadata()</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-fragments-new"><code>fragments$new()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments-print"><code>fragments$print()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments-plot_trace"><code>fragments$plot_trace()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments-clone"><code>fragments$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-fragments-new"></a>



<h4>Method <code>new()</code></h4>

<p>initialization function that is not used since the child classes are the main object of this package.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments$new(unique_id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>unique_id</code></dt><dd><p>unique_id</p>
</dd>
</dl>

</div>


<hr>
<a id="method-fragments-print"></a>



<h4>Method <code>print()</code></h4>

<p>A function to print informative information to the console
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments$print()</pre></div>


<hr>
<a id="method-fragments-plot_trace"></a>



<h4>Method <code>plot_trace()</code></h4>

<p>plot the trace data
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments$plot_trace(
  show_peaks = TRUE,
  x_axis = NULL,
  ylim = NULL,
  xlim = NULL,
  signal_color_threshold = 0.05,
  plot_title = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>show_peaks</code></dt><dd><p>A logical to say if the called peaks should be plotted on top of the trace. Only valid for fragments_repeats objects.</p>
</dd>
<dt><code>x_axis</code></dt><dd><p>Either &quot;size&quot; or &quot;repeats&quot; to indicate what should be plotted on the x-axis.</p>
</dd>
<dt><code>ylim</code></dt><dd><p>numeric vector length two specifying the y axis limits</p>
</dd>
<dt><code>xlim</code></dt><dd><p>numeric vector length two specifying the x axis limits</p>
</dd>
<dt><code>signal_color_threshold</code></dt><dd><p>A threshold value to colour the peaks relative to the tallest peak.</p>
</dd>
<dt><code>plot_title</code></dt><dd><p>A character string for setting the plot title. Defaults to the unique id of the object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A base R plot
</p>


<hr>
<a id="method-fragments-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='fragments_repeats'>fragments_repeats object</h2><span id='topic+fragments_repeats'></span>

<h3>Description</h3>

<p>An R6 Class representing a fragments_repeats object.
</p>


<h3>Details</h3>

<p>The idea behind this class is to store data for processing of the peak level data towards calculation of repeat instability metrics.
</p>
<p>It contains important setters and getters for alleles and index peaks. It's very important that the exactly correct size and repeat value is set for the alleles and index peak. This is used for subsetting etc, so if it's not exactly correct many functions would break.
</p>
<p>It also contains methods for plotting the ladder and traces (if available).
</p>


<h3>Super class</h3>

<p><code><a href="#topic+fragments">trace::fragments</a></code> -&gt; <code>fragments_repeats</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>trace_bp_df</code></dt><dd><p>A dataframe of bp size for every scan from <code>find_ladders()</code>.</p>
</dd>
<dt><code>peak_table_df</code></dt><dd><p>A dataframe containing the fragment peak level information.</p>
</dd>
<dt><code>repeat_table_df</code></dt><dd><p>A dataframe containing the fragment peak level information with the repeat size added. May or may not be the same as peak_table_df depending on what options are chosen in <code>call_repeats</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-fragments_repeats-get_allele_peak"><code>fragments_repeats$get_allele_peak()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments_repeats-set_allele_peak"><code>fragments_repeats$set_allele_peak()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments_repeats-get_index_peak"><code>fragments_repeats$get_index_peak()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments_repeats-set_index_peak"><code>fragments_repeats$set_index_peak()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments_repeats-plot_fragments"><code>fragments_repeats$plot_fragments()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments_repeats-clone"><code>fragments_repeats$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="trace" data-topic="fragments" data-id="initialize"><a href='../../trace/html/fragments.html#method-fragments-initialize'><code>trace::fragments$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="trace" data-topic="fragments" data-id="plot_trace"><a href='../../trace/html/fragments.html#method-fragments-plot_trace'><code>trace::fragments$plot_trace()</code></a></span></li>
<li><span class="pkg-link" data-pkg="trace" data-topic="fragments" data-id="print"><a href='../../trace/html/fragments.html#method-fragments-print'><code>trace::fragments$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-fragments_repeats-get_allele_peak"></a>



<h4>Method <code>get_allele_peak()</code></h4>

<p>This returns a list with the allele information for this object.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_repeats$get_allele_peak()</pre></div>


<hr>
<a id="method-fragments_repeats-set_allele_peak"></a>



<h4>Method <code>set_allele_peak()</code></h4>

<p>This sets a single allele size/repeat. It searches through the appropriate peak table and finds the closest peak to the value that's provided.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_repeats$set_allele_peak(allele, unit, value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>allele</code></dt><dd><p>Either <code>1</code> or <code>2</code>, indicating which allele information should be set. Allele 1 is the only one used for repeat instability metrics calculations.</p>
</dd>
<dt><code>unit</code></dt><dd><p>Either &quot;size&quot; or &quot;repeats&quot; to indicate if the value you're providing is bp size or repeat length.</p>
</dd>
<dt><code>value</code></dt><dd><p>Numeric vector (length one) of the size/repeat length to set.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-fragments_repeats-get_index_peak"></a>



<h4>Method <code>get_index_peak()</code></h4>

<p>This returns a list with the index peak information for this object.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_repeats$get_index_peak()</pre></div>


<hr>
<a id="method-fragments_repeats-set_index_peak"></a>



<h4>Method <code>set_index_peak()</code></h4>

<p>This sets the index repeat length. It searches through the repeat table and finds the closest peak to the value that's provided.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_repeats$set_index_peak(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>Numeric vector (length one) of the repeat length to set as index peak.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-fragments_repeats-plot_fragments"></a>



<h4>Method <code>plot_fragments()</code></h4>

<p>This plots the peak/repeat table as a histogram
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_repeats$plot_fragments(ylim = NULL, xlim = NULL, plot_title = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ylim</code></dt><dd><p>numeric vector length two specifying the y axis limits</p>
</dd>
<dt><code>xlim</code></dt><dd><p>numeric vector length two specifying the x axis limits</p>
</dd>
<dt><code>plot_title</code></dt><dd><p>A character string for setting the plot title. Defaults to the unique id of the object</p>
</dd>
</dl>

</div>


<hr>
<a id="method-fragments_repeats-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_repeats$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='fragments_trace'>fragments_trace object</h2><span id='topic+fragments_trace'></span>

<h3>Description</h3>

<p>An R6 Class representing a fragments_trace object.
</p>


<h3>Details</h3>

<p>The idea behind this class is to store data for processing of the continuous trace-level information from an fsa file towards peak level data.
</p>
<p>It also contains methods for plotting the ladder and traces
</p>


<h3>Super class</h3>

<p><code><a href="#topic+fragments">trace::fragments</a></code> -&gt; <code>fragments_trace</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>unique_id</code></dt><dd><p>unique id of the sample usually the file name</p>
</dd>
<dt><code>fsa</code></dt><dd><p>The whole fsa file, output from seqinr::read.abif()</p>
</dd>
<dt><code>raw_ladder</code></dt><dd><p>The raw data from the ladder channel</p>
</dd>
<dt><code>raw_data</code></dt><dd><p>The raw data from the sample channel</p>
</dd>
<dt><code>scan</code></dt><dd><p>The scan number</p>
</dd>
<dt><code>off_scale_scans</code></dt><dd><p>vector indicating which scales were too big and off scale. Note can be in any channel</p>
</dd>
<dt><code>ladder_df</code></dt><dd><p>A dataframe of the identified ladder from <code>find_ladders()</code>. Scan is the scan number of peak and size is the associated bp size.</p>
</dd>
<dt><code>trace_bp_df</code></dt><dd><p>A dataframe of bp size for every scan from <code>find_ladders()</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-fragments_trace-new"><code>fragments_trace$new()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments_trace-plot_ladder"><code>fragments_trace$plot_ladder()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments_trace-plot_data_channels"><code>fragments_trace$plot_data_channels()</code></a>
</p>
</li>
<li> <p><a href="#method-fragments_trace-clone"><code>fragments_trace$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="trace" data-topic="fragments" data-id="plot_trace"><a href='../../trace/html/fragments.html#method-fragments-plot_trace'><code>trace::fragments$plot_trace()</code></a></span></li>
<li><span class="pkg-link" data-pkg="trace" data-topic="fragments" data-id="print"><a href='../../trace/html/fragments.html#method-fragments-print'><code>trace::fragments$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-fragments_trace-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new fragments_trace.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_trace$new(unique_id, fsa_file)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>unique_id</code></dt><dd><p>usually the file name</p>
</dd>
<dt><code>fsa_file</code></dt><dd><p>output from seqinr::read.abif()</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>fragments_trace</code> object.
</p>


<hr>
<a id="method-fragments_trace-plot_ladder"></a>



<h4>Method <code>plot_ladder()</code></h4>

<p>plot the ladder data
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_trace$plot_ladder(xlim = NULL, ylim = NULL, plot_title = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>xlim</code></dt><dd><p>numeric vector length two specifying the x axis limits</p>
</dd>
<dt><code>ylim</code></dt><dd><p>numeric vector length two specifying the y axis limits</p>
</dd>
<dt><code>plot_title</code></dt><dd><p>A character string for setting the plot title. Defaults to the unique id of the object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A base R plot
</p>


<hr>
<a id="method-fragments_trace-plot_data_channels"></a>



<h4>Method <code>plot_data_channels()</code></h4>

<p>plot the raw data channels in the fsa file. It identifies every channel that has &quot;DATA&quot; in its name.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_trace$plot_data_channels()</pre></div>



<h5>Returns</h5>

<p>A base R plot
</p>


<hr>
<a id="method-fragments_trace-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>fragments_trace$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='generate_trace_template'>Generate a Quarto file that has the instability pipeline preset</h2><span id='topic+generate_trace_template'></span>

<h3>Description</h3>

<p>Generate a Quarto file that has the instability pipeline preset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_trace_template(
  file_name = NULL,
  correction = "batch",
  samples_grouped = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_trace_template_+3A_file_name">file_name</code></td>
<td>
<p>Name of file to create</p>
</td></tr>
<tr><td><code id="generate_trace_template_+3A_correction">correction</code></td>
<td>
<p>select either &quot;none&quot;, &quot;batch&quot; or &quot;repeat&quot; to indicate if the functionality for correcting repeat size using size standards across batches be included in the pipeline. See <code><a href="#topic+add_metadata">add_metadata()</a></code> &amp; <code><a href="#topic+call_repeats">call_repeats()</a></code> for more info.</p>
</td></tr>
<tr><td><code id="generate_trace_template_+3A_samples_grouped">samples_grouped</code></td>
<td>
<p>Indicates if the functionality for grouping samples for metrics calculations should be included in the pipeline. See <code><a href="#topic+add_metadata">add_metadata()</a></code> &amp; <code><a href="#topic+assign_index_peaks">assign_index_peaks()</a></code> for more info.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Quarto template file for repeat instability analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
   generate_trace_template("test")
}


</code></pre>

<hr>
<h2 id='metadata'>metadata</h2><span id='topic+metadata'></span>

<h3>Description</h3>

<p>This is a dataframe containing the metadata information for the example data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metadata
</code></pre>


<h3>Format</h3>



<h4><code>metadata</code></h4>

<p>A genemapper output dataframe
</p>



<h3>Source</h3>

<p><a href="https://doi.org/10.1038/s41467-024-47485-0">doi:10.1038/s41467-024-47485-0</a>
</p>

<hr>
<h2 id='peak_table_to_fragments'>Convert Peak Table to Fragments_repeats class</h2><span id='topic+peak_table_to_fragments'></span>

<h3>Description</h3>

<p>This function converts a peak table data frame into a list of fragments_repeats objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peak_table_to_fragments(
  df,
  data_format = NULL,
  peak_size_col = NULL,
  peak_signal_col = NULL,
  unique_id = NULL,
  dye_col = NULL,
  dye_channel = NULL,
  allele_col = NULL,
  min_size_bp = 200,
  max_size_bp = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peak_table_to_fragments_+3A_df">df</code></td>
<td>
<p>A data frame containing the peak data.</p>
</td></tr>
<tr><td><code id="peak_table_to_fragments_+3A_data_format">data_format</code></td>
<td>
<p>The format that the data frame is in (for example, a genemapper peak table). Choose between: genemapper5, generic.</p>
</td></tr>
<tr><td><code id="peak_table_to_fragments_+3A_peak_size_col">peak_size_col</code></td>
<td>
<p>A character string specifying column name giving the peak size.</p>
</td></tr>
<tr><td><code id="peak_table_to_fragments_+3A_peak_signal_col">peak_signal_col</code></td>
<td>
<p>A character string specifying column name giving the peak signal.</p>
</td></tr>
<tr><td><code id="peak_table_to_fragments_+3A_unique_id">unique_id</code></td>
<td>
<p>A character string specifying column name giving the unique sample id (often the file name).</p>
</td></tr>
<tr><td><code id="peak_table_to_fragments_+3A_dye_col">dye_col</code></td>
<td>
<p>Genemapper specific. A character string specifying column name indicating the dye channel.</p>
</td></tr>
<tr><td><code id="peak_table_to_fragments_+3A_dye_channel">dye_channel</code></td>
<td>
<p>Genemapper specific. A character string indicating the channel to extract data from. For example, 6-FAM is often &quot;B&quot;.</p>
</td></tr>
<tr><td><code id="peak_table_to_fragments_+3A_allele_col">allele_col</code></td>
<td>
<p>Genemapper specific. A character string specifying column name indicating the called alleles. This is often used when the peaks have been called in genemapper.</p>
</td></tr>
<tr><td><code id="peak_table_to_fragments_+3A_min_size_bp">min_size_bp</code></td>
<td>
<p>Numeric value indicating the minimum size of the peak table to import.</p>
</td></tr>
<tr><td><code id="peak_table_to_fragments_+3A_max_size_bp">max_size_bp</code></td>
<td>
<p>Numeric value indicating the maximum size of the peak table to import.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a peak table data frame (eg. Genemapper output) and converts it into a list of fragment objects.
The function supports different data formats and allows specifying column names for various attributes.
</p>


<h3>Value</h3>

<p>A list of fragments_repeats objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repeat_table_to_repeats">repeat_table_to_repeats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gm_raw &lt;- trace::example_data

test_fragments &lt;- peak_table_to_fragments(
  gm_raw,
  data_format = "genemapper5",
  dye_channel = "B",
  min_size_bp = 400
)

</code></pre>

<hr>
<h2 id='plot_batch_correction_samples'>Plot correction samples</h2><span id='topic+plot_batch_correction_samples'></span>

<h3>Description</h3>

<p>Plot the overlapping traces of the batch control samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_batch_correction_samples(fragments_list, selected_sample, xlim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_batch_correction_samples_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_repeats objects containing fragment data. must have trace information.</p>
</td></tr>
<tr><td><code id="plot_batch_correction_samples_+3A_selected_sample">selected_sample</code></td>
<td>
<p>A character vector of batch_sample_id for a subset of samples to plot. Or alternatively supply a number to select batch sample by position in alphabetical order.</p>
</td></tr>
<tr><td><code id="plot_batch_correction_samples_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot. A numeric vector of length two.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot of the raw signal by bp size or repeats for the batch correction samples.
</p>
<p>When plotting the traces before repeat correction, we do not expect the samples to be closely overlapping due to run-to-run variation. After repeat correction, the traces should be basically overlapping.
</p>
<p>These plots are made using base R plotting. Sometimes these fail to render in the viewing panes of IDEs (eg you get the error 'Error in <code>plot.new()</code>: figure margins too large)'. If this happens, try saving the plot as a pdf using traditional approaches (see grDevices::pdf).
</p>


<h3>Value</h3>

<p>plot of batch corrected samples
</p>


<h3>See Also</h3>

<p><code><a href="#topic+call_repeats">call_repeats()</a></code> for more info on batch correction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fsa_list &lt;- lapply(cell_line_fsa_list[16:19], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

fragments_list &lt;- find_fragments(fsa_list, min_bp_size = 300)

test_alleles &lt;- find_alleles(
  fragments_list 
)

add_metadata(
  fragments_list,
  metadata
)


call_repeats(
  fragments_list = fragments_list,
  correction = "batch"
)

# traces of bp size shows traces at different sizes
plot_batch_correction_samples(
  fragments_list,
  selected_sample = "S-21-212", xlim = c(100, 120)
)


</code></pre>

<hr>
<h2 id='plot_data_channels'>plot_data_channels</h2><span id='topic+plot_data_channels'></span>

<h3>Description</h3>

<p>Plot the raw data from the fsa file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_data_channels(fragments_list, sample_subset = NULL, n_facet_col = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_data_channels_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_trace objects.</p>
</td></tr>
<tr><td><code id="plot_data_channels_+3A_sample_subset">sample_subset</code></td>
<td>
<p>A character vector of unique ids for a subset of samples to plot</p>
</td></tr>
<tr><td><code id="plot_data_channels_+3A_n_facet_col">n_facet_col</code></td>
<td>
<p>A numeric value indicating the number of columns for faceting in the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot of the raw data channels in the fsa file.
</p>
<p>These plots are made using base R plotting. Sometimes these fail to render in the viewing panes of IDEs (eg you get the error 'Error in <code>plot.new()</code>: figure margins too large)'. If this happens, try saving the plot as a pdf using traditional approaches (see grDevices::pdf). To get it to render in the IDE pane, trying matching <code>n_facet_col</code> to the number of samples you're attempting to plot, or using <code>sample_subset</code> to limit it to a single sample.
</p>


<h3>Value</h3>

<p>a plot of the raw data channels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot_data_channels(cell_line_fsa_list[1])

</code></pre>

<hr>
<h2 id='plot_fragments'>Plot Peak Data</h2><span id='topic+plot_fragments'></span>

<h3>Description</h3>

<p>Plots peak data from a list of fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_fragments(
  fragments_list,
  n_facet_col = 1,
  sample_subset = NULL,
  xlim = NULL,
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_fragments_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_repeats objects containing fragment data.</p>
</td></tr>
<tr><td><code id="plot_fragments_+3A_n_facet_col">n_facet_col</code></td>
<td>
<p>A numeric value indicating the number of columns for faceting in the plot.</p>
</td></tr>
<tr><td><code id="plot_fragments_+3A_sample_subset">sample_subset</code></td>
<td>
<p>A character vector of unique ids for a subset of samples to plot</p>
</td></tr>
<tr><td><code id="plot_fragments_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot. A numeric vector of length two.</p>
</td></tr>
<tr><td><code id="plot_fragments_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. A numeric vector of length two.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object displaying the peak data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_raw &lt;- trace::example_data

fragments_list &lt;- peak_table_to_fragments(gm_raw,
  data_format = "genemapper5",
  dye_channel = "B",
  min_size_bp = 300
)

find_alleles(
  fragments_list
)

plot_fragments(fragments_list[1])
</code></pre>

<hr>
<h2 id='plot_ladders'>Plot ladder</h2><span id='topic+plot_ladders'></span>

<h3>Description</h3>

<p>Plot the ladder signal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ladders(
  fragments_trace_list,
  n_facet_col = 1,
  sample_subset = NULL,
  xlim = NULL,
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ladders_+3A_fragments_trace_list">fragments_trace_list</code></td>
<td>
<p>A list of fragments_trace objects containing fragment data.</p>
</td></tr>
<tr><td><code id="plot_ladders_+3A_n_facet_col">n_facet_col</code></td>
<td>
<p>A numeric value indicating the number of columns for faceting in the plot.</p>
</td></tr>
<tr><td><code id="plot_ladders_+3A_sample_subset">sample_subset</code></td>
<td>
<p>A character vector of unique ids for a subset of samples to plot</p>
</td></tr>
<tr><td><code id="plot_ladders_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot. A numeric vector of length two.</p>
</td></tr>
<tr><td><code id="plot_ladders_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. A numeric vector of length two.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot of ladders
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fsa_list &lt;- lapply(cell_line_fsa_list[1], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

# Manually inspect the ladders
plot_ladders(fsa_list[1])

</code></pre>

<hr>
<h2 id='plot_repeat_correction_model'>Plot Repeat Correction Model</h2><span id='topic+plot_repeat_correction_model'></span>

<h3>Description</h3>

<p>Plots the results of the repeat correction model for a list of fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_repeat_correction_model(
  fragments_list,
  batch_run_id_subset = NULL,
  n_facet_col = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_repeat_correction_model_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_repeats class objects obtained from the <code><a href="#topic+call_repeats">call_repeats()</a></code> function when the <code>correction = "repeat"</code> parameter is used.</p>
</td></tr>
<tr><td><code id="plot_repeat_correction_model_+3A_batch_run_id_subset">batch_run_id_subset</code></td>
<td>
<p>A character vector for a subset of batch_sample_id to plot. Or alternatively supply a number to select batch sample by position in alphabetical order.</p>
</td></tr>
<tr><td><code id="plot_repeat_correction_model_+3A_n_facet_col">n_facet_col</code></td>
<td>
<p>A numeric value indicating the number of columns for faceting in the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes plots for the model used to correct samples for each <code>batch_run_id</code>. The repeat correction algorithm assigns the user supplied repeat length to the modal peak of the sample, then pulls out a set of robust neighboring peaks to help get enough data to build an accurate linear model for the relationship between base-pair size and repeat length. So on this plot, each dot is an individual peak, with the colour indicating each sample, with the y-axis is the repeat length called from the user-supplied value in the metadata and the value assigned to each peak, with the x-axis showing the corresponding base-pair size.
</p>


<h3>Value</h3>

<p>A base R graphic object displaying the repeat correction model results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fsa_list &lt;- lapply(cell_line_fsa_list[16:19], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

fragments_list &lt;- find_fragments(fsa_list, min_bp_size = 300)

test_alleles &lt;- find_alleles(
  fragments_list 
)

add_metadata(
  fragments_list,
  metadata
)


call_repeats(
  fragments_list = fragments_list,
  correction = "repeat"
)

# traces of bp size shows traces at different sizes
plot_repeat_correction_model(
  fragments_list,
  batch_run_id_subset = "20230414"
)


</code></pre>

<hr>
<h2 id='plot_traces'>Plot sample traces</h2><span id='topic+plot_traces'></span>

<h3>Description</h3>

<p>Plot the raw trace data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_traces(
  fragments_list,
  show_peaks = TRUE,
  n_facet_col = 1,
  sample_subset = NULL,
  xlim = NULL,
  ylim = NULL,
  x_axis = NULL,
  signal_color_threshold = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_traces_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_repeats or fragments_trace objects containing fragment data.</p>
</td></tr>
<tr><td><code id="plot_traces_+3A_show_peaks">show_peaks</code></td>
<td>
<p>If peak data are available, TRUE will plot the peaks on top of the trace as dots.</p>
</td></tr>
<tr><td><code id="plot_traces_+3A_n_facet_col">n_facet_col</code></td>
<td>
<p>A numeric value indicating the number of columns for faceting in the plot.</p>
</td></tr>
<tr><td><code id="plot_traces_+3A_sample_subset">sample_subset</code></td>
<td>
<p>A character vector of unique ids for a subset of samples to plot</p>
</td></tr>
<tr><td><code id="plot_traces_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot. A numeric vector of length two.</p>
</td></tr>
<tr><td><code id="plot_traces_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. A numeric vector of length two.</p>
</td></tr>
<tr><td><code id="plot_traces_+3A_x_axis">x_axis</code></td>
<td>
<p>A character indicating what should be plotted on the x-axis, chose between <code>size</code> or <code>repeats</code>. If neither is selected, an assumption is made based on if repeats have been called.</p>
</td></tr>
<tr><td><code id="plot_traces_+3A_signal_color_threshold">signal_color_threshold</code></td>
<td>
<p>Threshold relative to tallest peak to color the dots (blue above, purple below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot of the raw signal by bp size. Red vertical line indicates the scan was
flagged as off-scale. This is in any channel, so use your best judgment to determine
if it's from the sample or ladder channel.
</p>
<p>If peaks are called, green is the tallest peak, blue is peaks above the signal threshold (default 5%), purple is below the signal threshold. If <code>force_whole_repeat_units</code> is used within <code><a href="#topic+call_repeats">call_repeats()</a></code>, the called repeat will be connected to the peak in the trace with a horizontal dashed line.
</p>
<p>The index peak will be plotted as a vertical dashed line when it has been set using <code>assign_index_peaks()</code>.
</p>


<h3>Value</h3>

<p>plot traces from fragments object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fsa_list &lt;- lapply(cell_line_fsa_list[1], function(x) x$clone())

find_ladders(fsa_list, show_progress_bar = FALSE)

fragments_list &lt;- find_fragments(fsa_list,
  min_bp_size = 300
)

find_alleles(
  fragments_list
)

# Simple conversion from bp size to repeat size
call_repeats(
  fragments_list
)

plot_traces(fragments_list, xlim = c(105, 150))

</code></pre>

<hr>
<h2 id='read_fsa'>Read fsa file</h2><span id='topic+read_fsa'></span>

<h3>Description</h3>

<p>Read fsa file into memory and create fragments_trace object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_fsa(files)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_fsa_+3A_files">files</code></td>
<td>
<p>a chr vector of fsa file names. For example, return all the fsa files in a directory with 'list.files(&quot;example_directory/&quot;, full.names = TRUE, pattern = &quot;.fsa&quot;)'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>read_fsa is just a wrapper around <code><a href="seqinr.html#topic+read.abif">seqinr::read.abif()</a></code> that reads the fsa file into memory and stores it inside a fragments_trace object. That enables you to use the next function <code><a href="#topic+find_ladders">find_ladders()</a></code>.
</p>


<h3>Value</h3>

<p>A list of fragments_trace objects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_ladders">find_ladders()</a></code>, <code><a href="#topic+plot_data_channels">plot_data_channels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fsa_file &lt;- read_fsa(system.file("abif/2_FAC321_0000205983_B02_004.fsa", package = "seqinr"))
plot_data_channels(fsa_file)

</code></pre>

<hr>
<h2 id='remove_fragments'>Remove Samples from List</h2><span id='topic+remove_fragments'></span>

<h3>Description</h3>

<p>A convenient function to remove specific samples from a list of fragments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_fragments(fragments_list, samples_to_remove)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_fragments_+3A_fragments_list">fragments_list</code></td>
<td>
<p>A list of fragments_repeats objects containing fragment data.</p>
</td></tr>
<tr><td><code id="remove_fragments_+3A_samples_to_remove">samples_to_remove</code></td>
<td>
<p>A character vector containing the unique IDs of the samples to be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified list of fragments with the specified samples removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_raw &lt;- trace::example_data
metadata &lt;- trace::metadata

test_fragments &lt;- peak_table_to_fragments(
  gm_raw,
  data_format = "genemapper5",
  dye_channel = "B",
  min_size_bp = 300
)

all_fragment_names &lt;- names(test_fragments)

# pull out unique ids of samples to remove
samples_to_remove &lt;- all_fragment_names[c(1, 5, 10)]

samples_removed &lt;- remove_fragments(test_fragments, samples_to_remove)

</code></pre>

<hr>
<h2 id='repeat_table_to_repeats'>Convert Repeat Table to Repeats Fragments</h2><span id='topic+repeat_table_to_repeats'></span>

<h3>Description</h3>

<p>This function converts a repeat table data frame into a list of fragments_repeats. class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeat_table_to_repeats(df, unique_id, repeat_col, frequency_col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repeat_table_to_repeats_+3A_df">df</code></td>
<td>
<p>A data frame containing the repeat data.</p>
</td></tr>
<tr><td><code id="repeat_table_to_repeats_+3A_unique_id">unique_id</code></td>
<td>
<p>A character string indicating the column name for unique identifiers.</p>
</td></tr>
<tr><td><code id="repeat_table_to_repeats_+3A_repeat_col">repeat_col</code></td>
<td>
<p>A character string indicating the column name for the repeats.</p>
</td></tr>
<tr><td><code id="repeat_table_to_repeats_+3A_frequency_col">frequency_col</code></td>
<td>
<p>A character string indicating the column name for the repeat frequencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a repeat table data frame and converts it into a list of repeats fragments.
The function allows specifying column names for repeats, frequencies, and unique identifiers.
</p>


<h3>Value</h3>

<p>A list of fragments_repeats objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repeat_table &lt;- trace::example_data_repeat_table
test_fragments &lt;- repeat_table_to_repeats(
  repeat_table,
  repeat_col = "repeats",
  frequency_col = "height",
  unique_id = "unique_id"
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
