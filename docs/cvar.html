<!DOCTYPE html><html lang="en"><head><title>Help for package cvar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cvar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cvar-package'><p>Compute Conditional Value-at-Risk and Value-at-Risk</p></a></li>
<li><a href='#ES'><p>Compute expected shortfall (ES) of distributions</p></a></li>
<li><a href='#GarchModel'><p>Specify a GARCH model</p></a></li>
<li><a href='#predict.garch1c1'><p>Prediction for GARCH(1,1) time series</p></a></li>
<li><a href='#sim_garch1c1'><p>Simulate GARCH(1,1) time series</p></a></li>
<li><a href='#VaR'><p>Compute Value-at-Risk (VaR)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compute Expected Shortfall and Value at Risk for Continuous
Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Compute expected shortfall (ES) and Value at Risk (VaR) from a
    quantile function, distribution function, random number generator or
    probability density function.  ES is also known as Conditional Value at
    Risk (CVaR). Virtually any continuous distribution can be specified.
    The functions are vectorized over the arguments. The computations are
    done directly from the definitions, see e.g. Acerbi and Tasche (2002)
    &lt;<a href="https://doi.org/10.1111%2F1468-0300.00091">doi:10.1111/1468-0300.00091</a>&gt;. Some support for GARCH models is provided,
    as well.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://geobosh.github.io/cvar/">https://geobosh.github.io/cvar/</a> (doc),
<a href="https://github.com/GeoBosh/cvar">https://github.com/GeoBosh/cvar</a> (devel)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeoBosh/cvar/issues">https://github.com/GeoBosh/cvar/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>gbutils, Rdpack (&ge; 0.8)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>VaR.R cvar-package.R garch.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, fGarch, PerformanceAnalytics</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-03 09:30:19 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Georgi N. Boshnakov [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-03 10:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='cvar-package'>Compute Conditional Value-at-Risk and Value-at-Risk</h2><span id='topic+cvar-package'></span><span id='topic+cvar'></span>

<h3>Description</h3>

<p>Compute expected shortfall (ES) and Value at Risk (VaR)
from a quantile function, distribution function, random number
generator or probability density function.  ES is also known as
Conditional Value at Risk (CVaR). Virtually any continuous
distribution can be specified.  The functions are vectorised over
the arguments. Some support for GARCH models is provided, as well.
</p>


<h3>Details</h3>

<p>There is a huge number of functions for computations with
distributions in core <span class="rlang"><b>R</b></span> and in contributed packages. Pdf's,
cdf's, quantile functions and random number generators are
covered comprehensively. The coverage of expected shortfall is
more patchy but a large collection of distributions, including
functions for expected shortfall, is provided by
Nadarajah et al. (2013).
Peterson and Carl (2018) and
Dutang et al. (2008) provide packages
covering comprehensively various aspects of risk measurement,
including some functions for expected shortfall.
</p>
<p>Package <span class="pkg">cvar</span> is a small package with, essentially, two main
functions &mdash; <code>ES</code> for computing the expected shortfall
and <code>VaR</code> for Value at Risk.  The user specifies the
distribution by supplying one of the functions that define a
continuous distribution&mdash;currently this can be a quantile
function (qf), cumulative distribution function (cdf) or
probability density function (pdf). Virtually any continuous
distribution can be specified.
</p>
<p>The functions are vectorised over the parameters of the
distributions, making bulk computations more convenient, for
example for forecasting or model evaluation.
</p>
<p>The name of this package, &quot;cvar&quot;, comes from <em>Conditional
Value at Risk</em> (CVaR), which is an alternative term for
expected shortfall.
</p>
<p>We chose to use the standard names <code>ES</code> and <code>VaR</code>,
despite the possibility for name clashes with same named
functions in other packages, rather than invent possibly
difficult to remember alternatives. Just call the functions as
<code>cvar::ES</code> and <code>cvar::VaR</code> if necessary.
</p>
<p>Locations-scale transformations can be specified separately
from the other distribution parameters. This is useful when
such parameters are not provided directly by the distribution
at hand. The use of these parameters often leads to more
efficient computations and better numerical accuracy even if
the distribution has its own parameters for this purpose. Some
of the examples for <code>VaR</code> and <code>ES</code> illustrate this
for the Gaussian distribution.
</p>
<p>Since VaR is a quantile, functions computing it for a given
distribution are convenience functions. <code>VaR</code> exported by
<span class="pkg">cvar</span> could be attractive in certain workflows because of
its vectorised distribution parameters, the location-scale
transformation, and the possibility to compute it from cdf's
when quantile functions are not available.
</p>
<p>Some support for GARCH models is provided, as well. It is
currently under development, see <code><a href="#topic+predict.garch1c1">predict.garch1c1</a></code>
for current functionality.
</p>
<p>In practice, we may need to compute VaR associated with data. The distribution comes
from fitting a model. In the simplest case, we fit a distribution to the data,
assuming that the sample is i.i.d. For example, a normal distribution <code class="reqn">N(\mu,
    \sigma^2)</code> can be fitted using the sample mean and sample variance as estimates of the
unknown parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code>, see section &lsquo;Examples&rsquo;. For other
common distributions there are specialised functions to fit their parameters and if
not, general optimisation routines can be used. More soffisticated models may be used,
even time series models such as GARCH and mixture autoregressive models.
</p>


<h3>Author(s)</h3>

<p>Georgi N. Boshnakov
</p>


<h3>References</h3>

<p>Christophe Dutang, Vincent Goulet, Mathieu Pigeon (2008).
&ldquo;actuar: An R Package for Actuarial Science.&rdquo;
<em>Journal of Statistical Software</em>, <b>25</b>(7), 38.
doi: <a href="https://doi.org/10.18637/jss.v025.i07">10.18637/jss.v025.i07</a>.<br /><br /> Saralees Nadarajah, Stephen Chan, Emmanuel Afuecheta (2013).
<em>VaRES: Computes value at risk and expected shortfall for over 100 parametric distributions</em>.
R package version 1.0, <a href="https://CRAN.R-project.org/package=VaRES">https://CRAN.R-project.org/package=VaRES</a>.<br /><br /> Brian
G. Peterson, Peter Carl (2018).
<em>PerformanceAnalytics: Econometric Tools for Performance and Risk Analysis</em>.
R package version 1.5.2, <a href="https://CRAN.R-project.org/package=PerformanceAnalytics">https://CRAN.R-project.org/package=PerformanceAnalytics</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ES">ES</a></code>,
<code><a href="#topic+VaR">VaR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the examples for ES(), VaR(), predict.garch1c1()

</code></pre>

<hr>
<h2 id='ES'>Compute expected shortfall (ES) of distributions</h2><span id='topic+ES'></span><span id='topic+ES.default'></span><span id='topic+ES.numeric'></span>

<h3>Description</h3>

<p>Compute the expected shortfall for a distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ES(dist, p_loss = 0.05, ...)

## Default S3 method:
ES(
  dist,
  p_loss = 0.05,
  dist.type = "qf",
  qf,
  ...,
  intercept = 0,
  slope = 1,
  control = list(),
  x
)

## S3 method for class 'numeric'
ES(
  dist,
  p_loss = 0.05,
  dist.type = "qf",
  qf,
  ...,
  intercept = 0,
  slope = 1,
  control = list(),
  x
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ES_+3A_dist">dist</code></td>
<td>
<p>specifies the distribution whose ES is computed, usually a function or a name
of a function computing quantiles, cdf, pdf, or a random number generator, see
Details.</p>
</td></tr>
<tr><td><code id="ES_+3A_p_loss">p_loss</code></td>
<td>
<p>level, default is 0.05.</p>
</td></tr>
<tr><td><code id="ES_+3A_...">...</code></td>
<td>
<p>passed on to <code>dist</code>.</p>
</td></tr>
<tr><td><code id="ES_+3A_dist.type">dist.type</code></td>
<td>
<p>a character string specifying what is computed by <code>dist</code>, such as
&quot;qf&quot; or &quot;cdf&quot;.</p>
</td></tr>
<tr><td><code id="ES_+3A_qf">qf</code></td>
<td>
<p>quantile function, only used if <code>dist.type = "pdf"</code>.</p>
</td></tr>
<tr><td><code id="ES_+3A_intercept">intercept</code>, <code id="ES_+3A_slope">slope</code></td>
<td>
<p>compute ES for the linear transformation <code>intercept +
slope*X</code>, where <code>X</code> has distribution specified by <code>dist</code>, see Details.</p>
</td></tr>
<tr><td><code id="ES_+3A_control">control</code></td>
<td>
<p>additional control parameters for the numerical integration routine.</p>
</td></tr>
<tr><td><code id="ES_+3A_x">x</code></td>
<td>
<p>deprecated and will soon be removed. <code>x</code> was renamed to <code>p_loss</code>,
please use the latter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ES</code> computes the expected shortfall for distributions specified by the
arguments. <code>dist</code> is typically a function (or the name of one). What <code>dist</code>
computes is determined by <code>dist.type</code>, whose default setting is <code>"qf"</code> (the
quantile function). Other possible settings of <code>dist.type</code> include <code>"cdf"</code>
and <code>"pdf"</code>.  Additional arguments for <code>dist</code> can be given with the
<code>"..."</code> arguments.
</p>
<p>Argument <code>dist</code> can also be a numeric vector. In that case the ES is computed,
effectively, for the empirical cumulative distribution function (ecdf) of the
vector. The ecdf is not created explicitly and the <code><a href="stats.html#topic+quantile">quantile</a></code>
function is used instead for the computation of VaR. Arguments in <code>"..."</code> are
passed eventually to <code>quantile()</code> and can be used, for example, to select a
non-defult method for the computation of quantiles.
</p>
<p>Except for the exceptions discussed below, a function computing VaR for the specified
distribution is constructed and the expected shortfall is computed by numerically
integrating it. The numerical integration can be fine-tuned with argument
<code>control</code>, which should be a named list, see <code><a href="stats.html#topic+integrate">integrate</a></code> for the
available options.
</p>
<p>If <code>dist.type</code> is <code>"pdf"</code>, VaR is not computed, Instead, the partial
expectation of the lower tail is computed by numerical integration of <code>x *
    pdf(x)</code>.  Currently the quantile function is required anyway, via argument <code>qf</code>,
to compute the upper limit of the integral. So, this case is mainly for testing and
comparison purposes.
</p>
<p>A bunch of expected shortfalls is computed if argument <code>x</code> or any of the
arguments in <code>"..."</code> are of length greater than one. They are recycled to equal
length, if necessary, using the normal <span class="rlang"><b>R</b></span> recycling rules.
</p>
<p><code>intercept</code> and <code>slope</code> can be used to compute the expected shortfall for
the location-scale transformation <code>Y = intercept + slope * X</code>, where the
distribution of <code>X</code> is as specified by the other parameters and <code>Y</code> is the
variable of interest. The expected shortfall of <code>X</code> is calculated and then
transformed to that of <code>Y</code>. Note that the distribution of <code>X</code> doesn't need
to be standardised, although it typically will.
</p>
<p>The <code>intercept</code> and the <code>slope</code> can be vectors. Using them may be
particularly useful for cheap calculations in, for example, forecasting, where the
predictive distributions are often from the same family, but with different location
and scale parameters. Conceptually, the described treatment of <code>intercept</code> and
<code>slope</code> is equivalent to recycling them along with the other arguments, but more
efficiently.
</p>
<p>The names, <code>intercept</code> and <code>slope</code>, for the location and scale parameters
were chosen for their expressiveness and to minimise the possibility for a clash with
parameters of <code>dist</code> (e.g., the Gamma distribution has parameter <code>scale</code>).
</p>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VaR">VaR</a></code> for VaR,
</p>
<p><code><a href="#topic+predict.garch1c1">predict</a></code> for examples with fitted models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ES(qnorm)

## Gaussian
ES(qnorm, dist.type = "qf")
ES(pnorm, dist.type = "cdf")

## t-dist
ES(qt, dist.type = "qf", df = 4)
ES(pt, dist.type = "cdf", df = 4)

ES(pnorm, 0.95, dist.type = "cdf")
ES(qnorm, 0.95, dist.type = "qf")
## - VaRES::esnormal(0.95, 0, 1)
## - PerformanceAnalytics::ETL(p=0.05, method = "gaussian", mu = 0,
##                             sigma = 1, weights = 1)             # same

cvar::ES(pnorm, dist.type = "cdf")
cvar::ES(qnorm, dist.type = "qf")
cvar::ES(pnorm, 0.05, dist.type = "cdf")
cvar::ES(qnorm, 0.05, dist.type = "qf")

## this uses "pdf"
cvar::ES(dnorm, 0.05, dist.type = "pdf", qf = qnorm)


## this gives warning (it does more than simply computing ES):
## PerformanceAnalytics::ETL(p=0.95, method = "gaussian", mu = 0, sigma = 1, weights = 1)

## run this if VaRRES is present
## Not run: 
x &lt;- seq(0.01, 0.99, length = 100)
y &lt;- sapply(x, function(p) cvar::ES(qnorm, p, dist.type = "qf"))
yS &lt;- sapply(x, function(p) - VaRES::esnormal(p))
plot(x, y)
lines(x, yS, col = "blue")

## End(Not run)

</code></pre>

<hr>
<h2 id='GarchModel'>Specify a GARCH model</h2><span id='topic+GarchModel'></span>

<h3>Description</h3>

<p>Specify a GARCH model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GarchModel(model = list(), ..., model.class = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GarchModel_+3A_model">model</code></td>
<td>
<p>a GARCH model or a list.</p>
</td></tr>
<tr><td><code id="GarchModel_+3A_...">...</code></td>
<td>
<p>named arguments specifying the GARCH model.</p>
</td></tr>
<tr><td><code id="GarchModel_+3A_model.class">model.class</code></td>
<td>
<p>a class for the result. By default <code>GarchModel()</code>
decides the class of the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>model</code> can be the result of a previous call to <code>GarchModel</code>.
Arguments in <code>"..."</code> overwrite current components of <code>model</code>.
</p>
<p><code>GarchModel</code> guarantees that code using it will continue to work
transparently for the user even if the internal represedtation of GARCH
models in this package is changed or additional functionality is added.
</p>


<h3>Value</h3>

<p>an object from suitable GARCH-type class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## GARCH(1,1) with Gaussian innovations
mo1a &lt;- GarchModel(omega = 1, alpha = 0.3, beta = 0.5)
mo1b &lt;- GarchModel(omega = 1, alpha = 0.3, beta = 0.5, cond.dist = "norm")

## equivalently, the parameters can be given as a list
p1 &lt;- list(omega = 1, alpha = 0.3, beta = 0.5)
mo1a_alt &lt;- GarchModel(p1)
mo1b_alt &lt;- GarchModel(p1, cond.dist = "norm")
stopifnot(identical(mo1a, mo1a_alt), identical(mo1b, mo1b_alt))

## additional arguments modify values already in 'model'
mo_alt &lt;- GarchModel(p1, beta = 0.4)

## set also initial values
mo2 &lt;- GarchModel(omega = 1, alpha = 0.3, beta = 0.5, esp0 = - 1.5, h0 = 4.96)

##  GARCH(1,1) with standardised-t_5
mot &lt;- GarchModel(omega = 1, alpha = 0.3, beta = 0.5, cond.dist = list("std", nu = 5))

</code></pre>

<hr>
<h2 id='predict.garch1c1'>Prediction for GARCH(1,1) time series</h2><span id='topic+predict.garch1c1'></span>

<h3>Description</h3>

<p>Predict GARCH(1,1) time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'garch1c1'
predict(object, n.ahead = 1, Nsim = 1000, eps, sigmasq, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.garch1c1_+3A_object">object</code></td>
<td>
<p>an object from class <code>"garch1c1"</code>.</p>
</td></tr>
<tr><td><code id="predict.garch1c1_+3A_n.ahead">n.ahead</code></td>
<td>
<p>maximum horizon (lead time) for prediction.</p>
</td></tr>
<tr><td><code id="predict.garch1c1_+3A_nsim">Nsim</code></td>
<td>
<p>number of Monte Carlo simulations for simulation based quantities.</p>
</td></tr>
<tr><td><code id="predict.garch1c1_+3A_eps">eps</code></td>
<td>
<p>the time series to predict, only the last value is used.</p>
</td></tr>
<tr><td><code id="predict.garch1c1_+3A_sigmasq">sigmasq</code></td>
<td>
<p>the (squared) volatilities, only the last value is used.</p>
</td></tr>
<tr><td><code id="predict.garch1c1_+3A_seed">seed</code></td>
<td>
<p>an integer, seed for the random number generator.</p>
</td></tr>
<tr><td><code id="predict.garch1c1_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plug-in prediction intervals and predictive distributions are obtained by
inserting the predicted volatility in the conditional densities. For
predictions more than one lag ahead these are not the real predictive
distributions but the prediction intervals are usually adequate.
</p>
<p>For simulation prediction intervals we generate a (large) number of
continuations of the given time series. Prediction intervals can be based on
sample quantiles. The generated samples are stored in the returned object and
can be used for further exploration of the predictive
distributions. <code>dist_sim$eps</code> contains the simulated future values of
the time series and <code>dist_sim$h</code> the corresponding (squared)
volatilities.  Both are matrices whose <code>i</code>-th rows contain the predicted
quantities for horizon <code>i</code>.
</p>
<p>The random seed at the start of the simulations is saved in the returned
object.  A speficific seed can be requested with argument <code>seed</code>. In
that case the simulations are done with the specified seed and the old state
of the random number generator is restored before the function returns.
This setup is similar to <code><a href="#topic+sim_garch1c1">sim_garch1c1</a></code>.
</p>


<h3>Value</h3>

<p>an object from S3 class <code>"predict_garch1c1"</code> containing
the following components:
</p>
<table role = "presentation">
<tr><td><code>eps</code></td>
<td>
<p>point predictions (conditional expectations) of the time series (equal
to zero for pure GARCH).</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>point predictions (conditional expectations)of the squared volatilities.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call.</p>
</td></tr>
<tr><td><code>pi_plugin</code></td>
<td>
<p>Prediction intervals for the time series, based on plug-in
distributions, see Details.</p>
</td></tr>
<tr><td><code>pi_sim</code></td>
<td>
<p>Simulation based prediction intervals for the time series, see Details.</p>
</td></tr>
<tr><td><code>dist_sim</code></td>
<td>
<p>simulation samples from the predictive distributions of the time
series and the volatilties. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is under development and may be changed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- options(digits = 4)

## set up a model and simulate a time series
mo &lt;- GarchModel(omega = 0.4, alpha = 0.3, beta = 0.5)
a1 &lt;- sim_garch1c1(mo, n = 1000, n.start = 100, seed = 20220305)

## predictions for T+1,...,T+5 (T = time of last value)
## Nsim is small to reduce the load on CRAN, usually Nsim is larger.
a.pred &lt;- predict(mo, n.ahead = 5, Nsim = 1000, eps = a1$eps,
  sigmasq = a1$h, seed = 1234)

## preditions for the time series
a.pred$eps

## PI's for eps - plug-in and simulated
a.pred$pi_plugin
a.pred$pi_sim

## a DIY calculation of PI's using the simulated sample paths
t(apply(a.pred$dist_sim$eps, 1, function(x) quantile(x, c(0.025, 0.975))))

## further investigate the predictive distributions
t(apply(a.pred$dist_sim$eps, 1, function(x) summary(x)))

## compare predictive densities for horizons 2 and 5:
h2 &lt;- a.pred$dist_sim$eps[2, ]
h5 &lt;- a.pred$dist_sim$eps[5, ]
main &lt;- "Predictive densities: horizons 2 (blue) and 5 (black)"
plot(density(h5), main = main)
lines(density(h2), col = "blue")

## predictions of sigma_t^2
a.pred$h

## plug-in predictions of sigma_t
sqrt(a.pred$h)

## simulation predictive densities (PD's) of sigma_t for horizons 2 and 5:
h2 &lt;- sqrt(a.pred$dist_sim$h[2, ])
h5 &lt;- sqrt(a.pred$dist_sim$h[5, ])
main &lt;- "PD's of sigma_t for horizons 2 (blue) and 5 (black)"
plot(density(h2), col = "blue", main = main)
lines(density(h5))

## VaR and ES for different horizons
cbind(h = 1:5,
      VaR = apply(a.pred$dist_sim$eps, 1, function(x) VaR(x, c(0.05))),
      ES = apply(a.pred$dist_sim$eps, 1, function(x) ES(x, c(0.05))) )

## fit a GARCH(1,1) model to exchange rate data and predict
gmo1 &lt;- fGarch::garchFit(formula = ~garch(1, 1), data = fGarch::dem2gbp,
  include.mean = FALSE, cond.dist = "norm", trace = FALSE)
mocoef &lt;- gmo1@fit$par
mofitted &lt;- GarchModel(omega = mocoef["omega"], alpha = mocoef["alpha1"],
  beta = mocoef["beta1"])
gmo1.pred &lt;- predict(mofitted, n.ahead = 5, Nsim = 1000, eps = gmo1@data,
  sigmasq = gmo1@h.t, seed = 1234)
gmo1.pred$pi_plugin
gmo1.pred$pi_sim

op &lt;- options(op) # restore options(digits)

</code></pre>

<hr>
<h2 id='sim_garch1c1'>Simulate GARCH(1,1) time series</h2><span id='topic+sim_garch1c1'></span>

<h3>Description</h3>

<p>Simulate GARCH(1,1) time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_garch1c1(model, n, n.start = 0, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_garch1c1_+3A_model">model</code></td>
<td>
<p>a GARCH(1,1) model, an object obtained from <code>GarchModel</code>.</p>
</td></tr>
<tr><td><code id="sim_garch1c1_+3A_n">n</code></td>
<td>
<p>the length of the generated time series.</p>
</td></tr>
<tr><td><code id="sim_garch1c1_+3A_n.start">n.start</code></td>
<td>
<p>number of warm-up values, which are then dropped.</p>
</td></tr>
<tr><td><code id="sim_garch1c1_+3A_seed">seed</code></td>
<td>
<p>an integer to use for setting the random number generator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulated time series is in component <code>eps</code> of the returned value.
For exploration of algorithms and eestimation procedures, the volatilities
and the standardised innovations are also returned.
</p>
<p>The random seed at the start of the simulations is saved in the returned
object.  A speficific seed can be requested with argument <code>seed</code>. In
that case the simulations are done with the specified seed and the old state
of the random number generator is restored before the function returns.
</p>


<h3>Value</h3>

<p>a list with components:
</p>
<table role = "presentation">
<tr><td><code>eps</code></td>
<td>
<p>the time series,</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>the (squared) volatilities,</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>the standardised innovations,</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the GARCH(1,1) model,</p>
</td></tr>
<tr><td><code>.sim</code></td>
<td>
<p>a list containing the parameters of the simulation,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is under development and may be changed.
</p>

<hr>
<h2 id='VaR'>Compute Value-at-Risk (VaR)</h2><span id='topic+VaR'></span><span id='topic+VaR_qf'></span><span id='topic+VaR_cdf'></span><span id='topic+VaR.default'></span><span id='topic+VaR.numeric'></span>

<h3>Description</h3>

<p><code>VaR</code> computes the Value-at-Risk of the distribution specified by the
arguments. The meaning of the parameters is the same as in <code><a href="#topic+ES">ES</a></code>, including
the recycling rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VaR(dist, p_loss = 0.05, ...)

VaR_qf(
  dist,
  p_loss = 0.05,
  ...,
  intercept = 0,
  slope = 1,
  tol = .Machine$double.eps^0.5,
  x
)

VaR_cdf(
  dist,
  p_loss = 0.05,
  ...,
  intercept = 0,
  slope = 1,
  tol = .Machine$double.eps^0.5,
  x
)

## Default S3 method:
VaR(
  dist,
  p_loss = 0.05,
  dist.type = "qf",
  ...,
  intercept = 0,
  slope = 1,
  tol = .Machine$double.eps^0.5,
  x
)

## S3 method for class 'numeric'
VaR(dist, p_loss = 0.05, ..., intercept = 0, slope = 1, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VaR_+3A_dist">dist</code></td>
<td>
<p>specifies the distribution whose ES is computed, usually a function or a name
of a function computing quantiles, cdf, pdf, or a random number generator, see
Details.</p>
</td></tr>
<tr><td><code id="VaR_+3A_p_loss">p_loss</code></td>
<td>
<p>level, default is 0.05.</p>
</td></tr>
<tr><td><code id="VaR_+3A_...">...</code></td>
<td>
<p>passed on to <code>dist</code>.</p>
</td></tr>
<tr><td><code id="VaR_+3A_intercept">intercept</code>, <code id="VaR_+3A_slope">slope</code></td>
<td>
<p>compute VaR for the linear transformation <code>intercept +
slope*X</code>, where <code>X</code> has distribution specified by <code>dist</code>, see Details.</p>
</td></tr>
<tr><td><code id="VaR_+3A_tol">tol</code></td>
<td>
<p>tollerance</p>
</td></tr>
<tr><td><code id="VaR_+3A_x">x</code></td>
<td>
<p>deprecated and will soon be removed. <code>x</code> was renamed to <code>p_loss</code>,
please use the latter.</p>
</td></tr>
<tr><td><code id="VaR_+3A_dist.type">dist.type</code></td>
<td>
<p>a character string specifying what is computed by <code>dist</code>, such as
&quot;qf&quot; or &quot;cdf&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>VaR</code> is S3 generic. The meaning of the parameters for its default method is the
same as in <code><a href="#topic+ES">ES</a></code>, including the recycling rules.
</p>
<p><code>VaR_qf</code> and <code>VaR_cdf</code> are streamlined, non-generic, variants for the common
case when the <code>"..."</code> parameters are scalar. The parameters <code>x</code>,
<code>intercept</code>, and <code>slope</code> can be vectors, as for <code>VaR</code>.
</p>
<p>Argument <code>dist</code> can also be a numeric vector. In that case the ES is computed,
effectively, for the empirical cumulative distribution function (ecdf) of the
vector. The ecdf is not created explicitly and the <code><a href="stats.html#topic+quantile">quantile</a></code>
function is used instead for the computation of VaR. Arguments in <code>"..."</code> are
passed eventually to <code>quantile()</code> and can be used, for example, to select a
non-defult method for the computation of quantiles.
</p>
<p>In practice, we may need to compute VaR associated with data. The distribution comes
from fitting a model. In the simplest case, we fit a distribution to the data,
assuming that the sample is i.i.d. For example, a normal distribution <code class="reqn">N(\mu,
    \sigma^2)</code> can be fitted using the sample mean and sample variance as estimates of the
unknown parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma^2</code>, see section &lsquo;Examples&rsquo;. For
other common distributions there are specialised functions to fit their parameters and
if not, general optimisation routines can be used. More soffisticated models may be
used, even time series models such as GARCH and mixture autoregressive models.
</p>


<h3>Note</h3>

<p>We use the traditional definition of VaR as the negated lower quantile. For example,
if <code class="reqn">X</code> are returns on an asset, VAR<code class="reqn">{}_\alpha</code> = <code class="reqn">-q_\alpha</code>,
where <code class="reqn">q_\alpha</code> is the lower <code class="reqn">\alpha</code> quantile of <code class="reqn">X</code>.
Equivalently, VAR<code class="reqn">{}_\alpha</code> is equal to the lower <code class="reqn">1-\alpha</code>
quantile of <code class="reqn">-X</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ES">ES</a></code> for ES,
</p>
<p><code><a href="#topic+predict.garch1c1">predict</a></code> for examples with fitted models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cvar::VaR(qnorm, c(0.01, 0.05), dist.type = "qf")

## the following examples use these values, obtained by fitting a normal distribution to
## some data:
muA &lt;- 0.006408553
sigma2A &lt;- 0.0004018977

## with quantile function, giving the parameters directly in the call:
res1 &lt;- cvar::VaR(qnorm, 0.05, mean = muA, sd = sqrt(sigma2A))
res2 &lt;- cvar::VaR(qnorm, 0.05, intercept = muA, slope = sqrt(sigma2A))
abs((res2 - res1)) # 0, intercept/slope equivalent to mean/sd

## with quantile function, which already knows the parameters:
my_qnorm &lt;- function(p) qnorm(p, mean = muA, sd = sqrt(sigma2A))
res1_alt &lt;- cvar::VaR(my_qnorm, 0.05)
abs((res1_alt - res1))

## with cdf the precision depends on solving an equation
res1a &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf", mean = muA, sd = sqrt(sigma2A))
res2a &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf", intercept = muA, slope = sqrt(sigma2A))
abs((res1a - res2)) # 3.287939e-09
abs((res2a - res2)) # 5.331195e-11, intercept/slope better numerically

## as above, but increase the precision, this is probably excessive
res1b &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                   mean = muA, sd = sqrt(sigma2A), tol = .Machine$double.eps^0.75)
res2b &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                   intercept = muA, slope = sqrt(sigma2A), tol = .Machine$double.eps^0.75)
abs((res1b - res2)) # 6.938894e-18 # both within machine precision
abs((res2b - res2)) # 1.040834e-16

## relative precision is also good
abs((res1b - res2)/res2) # 2.6119e-16 # both within machine precision
abs((res2b - res2)/res2) # 3.91785e-15


## an extended example with vector args, if "PerformanceAnalytics" is present
if (requireNamespace("PerformanceAnalytics", quietly = TRUE)) withAutoprint({
    data(edhec, package = "PerformanceAnalytics")
    mu &lt;- apply(edhec, 2, mean)
    sigma2 &lt;- apply(edhec, 2, var)
    musigma2 &lt;- cbind(mu, sigma2)

    ## compute in 2 ways with cvar::VaR
    vAz1 &lt;- cvar::VaR(qnorm, 0.05, mean = mu, sd = sqrt(sigma2))
    vAz2 &lt;- cvar::VaR(qnorm, 0.05, intercept = mu, slope = sqrt(sigma2))

    vAz1a &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                       mean = mu, sd = sqrt(sigma2))
    vAz2a &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                       intercept = mu, slope = sqrt(sigma2))

    vAz1b &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                   mean = mu, sd = sqrt(sigma2),
                   tol = .Machine$double.eps^0.75)
    vAz2b &lt;- cvar::VaR(pnorm, 0.05, dist.type = "cdf",
                   intercept = mu, slope = sqrt(sigma2),
                   tol = .Machine$double.eps^0.75)

    ## analogous calc. with PerformanceAnalytics::VaR
    vPA &lt;- apply(musigma2, 1, function(x)
        PerformanceAnalytics::VaR(p = .95, method = "gaussian", invert = FALSE,
                                  mu = x[1], sigma = x[2], weights = 1))
    ## the results are numerically the same
    max(abs((vPA - vAz1))) # 5.551115e-17
    max(abs((vPA - vAz2))) #   ""

    max(abs((vPA - vAz1a))) # 3.287941e-09
    max(abs((vPA - vAz2a))) #  1.465251e-10, intercept/slope better

    max(abs((vPA - vAz1b))) # 4.374869e-13
    max(abs((vPA - vAz2b))) # 3.330669e-16
})

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
