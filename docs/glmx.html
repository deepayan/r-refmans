<!DOCTYPE html><html><head><title>Help for package glmx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {glmx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AbortionAmbivalence'><p>American Ambivalence towards Abortion Policy</p></a></li>
<li><a href='#BeetleMortality'><p>Bliss (1935) Beetle Mortality Data</p></a></li>
<li><a href='#glmx'><p>Generalized Linear Models with Extra Parameters</p></a></li>
<li><a href='#glmx.control'><p>Control Parameters for GLMs with Extra Parameters</p></a></li>
<li><a href='#hetglm'><p>Heteroscedastic Binary Response GLMs</p></a></li>
<li><a href='#hetglm.control'><p>Control Parameters for Heteroscedastic Binary Response GLMs</p></a></li>
<li><a href='#MexicanLabor'><p>Mexican Women's Labor-Force Participation</p></a></li>
<li><a href='#plinks'><p>Parametric Links for Binomial Generalized Linear Models</p></a></li>
<li><a href='#pregibon'><p>Pregibon Distribution</p></a></li>
<li><a href='#WECO'><p>Productivity and Quit Behavior of Western Electric Workers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Linear Models Extended</td>
</tr>
<tr>
<td>Description:</td>
<td>Extended techniques for generalized linear models (GLMs), especially for binary responses,
             including parametric links and heteroscedastic latent variables.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MASS, Formula, lmtest, sandwich</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AER, gld, numDeriv, pscl</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-26 23:24:09 UTC; zeileis</td>
</tr>
<tr>
<td>Author:</td>
<td>Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Roger Koenker <a href="https://orcid.org/0000-0001-8436-6306"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Philipp Doebler <a href="https://orcid.org/0000-0002-2946-8526"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-27 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AbortionAmbivalence'>American Ambivalence towards Abortion Policy</h2><span id='topic+AbortionAmbivalence'></span>

<h3>Description</h3>

<p>Data about attitudes towards abortion policy in the US. 
Cross-section data from the US General Social Survey 1982 with
oversample of African American respondents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("AbortionAmbivalence")</code></pre>


<h3>Format</h3>

<p>A data frame containing 1860 observations on 20 variables.
</p>

<dl>
<dt>health</dt><dd><p>factor. Answer to the question: Please tell me whether
or not you think it should be possible for a pregnant woman to obtain
a legal abortion if the woman's own health is seriously endangered by
the pregnancy?</p>
</dd>
<dt>rape</dt><dd><p>factor. Answer to the question: Please tell me whether
or not you think it should be possible for a pregnant woman to obtain
a legal abortion if she became pregnant as a result of rape?</p>
</dd>
<dt>defect</dt><dd><p>factor. Answer to the question: Please tell me whether
or not you think it should be possible for a pregnant woman to obtain
a legal abortion if there is a strong chance of serious defect in the baby?</p>
</dd>
<dt>poor</dt><dd><p>factor. Answer to the question: Please tell me whether
or not you think it should be possible for a pregnant woman to obtain
a legal abortion if the family has a very low income and cannot afford any
more children?</p>
</dd>
<dt>nomore</dt><dd><p>factor. Answer to the question: Please tell me whether
or not you think it should be possible for a pregnant woman to obtain
a legal abortion if she is married and does not want any more children?</p>
</dd>
<dt>single</dt><dd><p>factor. Answer to the question: Please tell me whether
or not you think it should be possible for a pregnant woman to obtain
a legal abortion if she is not married and does not want to marry the man?</p>
</dd>
<dt>any</dt><dd><p>factor. Answer to the question: Please tell me whether
or not you think it should be possible for a pregnant woman to obtain
a legal abortion if the woman wants it for reason?</p>
</dd>
<dt>ethnicity</dt><dd><p>factor indicating ethnicity.
Is the individual African-American (<code>"afam"</code>) or not (<code>"other"</code>)?</p>
</dd>
<dt>gender</dt><dd><p>factor indicating gender.</p>
</dd>
<dt>religion</dt><dd><p>factor indicating religious preference (<code>"catholic"</code> or
<code>"other"</code>).</p>
</dd>
<dt>religiousness</dt><dd><p>Religious intensity as coded by Alvarez and Brehm (1995).</p>
</dd>
<dt>religiousness2</dt><dd><p>Religious intensity in an alternative coding suggested by
Altman and McDonald (1995).</p>
</dd>
<dt>church</dt><dd><p>Numeric coding of frequency of attending church.</p>
</dd>
<dt>erameans</dt><dd><p>factor. Answer to the question: Do you understand what the
Equal Rights Amendment (ERA) means?</p>
</dd>
<dt>erasupport</dt><dd><p>Intensity of support for ERA.</p>
</dd>
<dt>pros</dt><dd><p>Number of arguments in favor of abortion named by the subject.</p>
</dd>
<dt>cons</dt><dd><p>Number of arguments against abortion named by the subject.</p>
</dd>
<dt>importance</dt><dd><p>Numeric coding of subjective importance of abortion issue.</p>
</dd>
<dt>information</dt><dd><p>Numeric coding of self-assessment of information on abortion issue
available to the subject.</p>
</dd>
<dt>firmness</dt><dd><p>Numeric coding of subjective firmness of opinion on abortion.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were prepared and analyzed by Alvarez and Brehm (1995). A detailed
discussion of the variables is provided in their Appendix A and the model
is developed in their Section 3.
</p>
<p>The data were reanalyzed by Altman and McDonald (2003) with focus on numerical
accuracy and by Keele and Park (2006) with focus on interpretability.
</p>


<h3>Source</h3>

<p>Online supplements to Altman and McDonald (2003).
</p>
<p><a href="https://doi.org/10.1093/pan/mpg016">doi:10.1093/pan/mpg016</a>
</p>


<h3>References</h3>

<p>Altman M, McDonald MP (2003). &ldquo;Replication with Attention to Numerical Accuracy.&rdquo;
<em>Political Analysis</em>, <b>11</b>, 302&ndash;307.
</p>
<p>Alvarez RM, Brehm J (1995). &ldquo;American Ambivalence towards Abortion Policy: Development
of a Heteroskedastic Probit Model of Competing Values.&rdquo; <em>American Journal of Political
Science</em>, <b>39</b>(4), 1055&ndash;1082.
</p>
<p>Keele LJ, Park DK (2006). <em>Ambivalent about Ambivalence: A Re-Examination of Heteroskedastic Probit Models.</em>
Unpublished manuscript.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hetglm">hetglm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data("AbortionAmbivalence")

## first model for mother's health
ab_health &lt;- hetglm(
  health ~ ethnicity + gender + religion + religiousness + church + erameans + erasupport |
  pros * cons + importance + information + firmness, data = AbortionAmbivalence)
summary(ab_health)

## corresponding model with analytical gradients but numerical Hessian
ab_health2 &lt;- update(ab_health, method = "BFGS", hessian = TRUE)
summary(ab_health2)

## Alvarez and Brehm (1995), Table 1, p. 1069
## (see also Altman and McDonald, 2003, Supplement, Tables 4-10)
tab1 &lt;- sapply(names(AbortionAmbivalence)[1:7], function(x) {
  f &lt;- as.formula(paste(x,
    "~ ethnicity + gender + religion + religiousness + church + erameans + erasupport",
    "| pros * cons + importance + information + firmness"))
  f0 &lt;- as.formula(paste(x, "~ 1"))
  m &lt;- hetglm(f, data = AbortionAmbivalence)
  m0 &lt;- hetglm(f0, data = model.frame(m))
  c(Percent_yes = as.vector(100 * prop.table(table(AbortionAmbivalence[[x]]))["yes"]),
    coef(m)[c(1:10, 14, 11:13)],
    Heteroscedasticity = as.vector(summary(m)$lrtest[1]),
    N = nobs(m),
    Goodness_of_fit = 2 * as.vector(logLik(m) - logLik(m0))
  )
})
round(tab1, digits = 2)


if(require("AER")) {
## compare Wald tests with different types of standard errors
coeftest(ab_health)
coeftest(ab_health2)
coeftest(ab_health,  vcov = sandwich)
coeftest(ab_health2, vcov = sandwich)
coeftest(ab_health,  vcov = vcovOPG)
coeftest(ab_health2, vcov = vcovOPG)

ab_health_tstat &lt;- cbind(
  "A-Info"     = coeftest(ab_health)[,3],
  "N-Info"     = coeftest(ab_health2)[,3],
  "A-Sandwich" = coeftest(ab_health,  vcov = sandwich)[,3],
  "N-Sandwich" = coeftest(ab_health2, vcov = sandwich)[,3],
  "A-OPG"      = coeftest(ab_health,  vcov = vcovOPG)[,3],
  "N-OPG"      = coeftest(ab_health2, vcov = vcovOPG)[,3]
)
round(ab_health_tstat, digits = 3)
}
</code></pre>

<hr>
<h2 id='BeetleMortality'>Bliss (1935) Beetle Mortality Data</h2><span id='topic+BeetleMortality'></span>

<h3>Description</h3>

<p>Mortality of adult flour beetle after five hours' exposure to gaseous carbon disulphide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BeetleMortality")</code></pre>


<h3>Format</h3>

<p>A data frame containing 8 observations on 3 variables.
</p>

<dl>
<dt>dose</dt><dd><p>numeric. <code class="reqn">\log_{10}</code> dose.</p>
</dd>
<dt>died</dt><dd><p>integer. Number killed.</p>
</dd>
<dt>n</dt><dd><p>integer. Number exposed.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data originates from Bliss (1935) and has been reanalyzed frequently.
</p>


<h3>Source</h3>

<p>Bliss CI (1935). &ldquo;The Calculation of the Dosage-Mortality Curve.&rdquo;
<em>Annals of Applied Biology</em>, <b>22</b>, 134&ndash;167.
</p>


<h3>References</h3>

<p>Aranda-Ordaz F (1981). &ldquo;On Two Families of Transformations to Additivity for Binary Response Data.&rdquo;
<em>Biometrika</em>, <b>68</b>, 357&ndash;363.
</p>
<p>Hauck W (1990). &ldquo;Choice of Scale and Asymmetric Logistic Models.&rdquo;
<em>Biometrical Journal</em>, <b>32</b>, 79&ndash;86 
</p>
<p>Prentice RL (1976). &ldquo;A Generalization of the Probit and Logit Methods for Dose Response Curves.&rdquo;
<em>Biometrics</em>, <b>38</b>, 761&ndash;768. 
</p>
<p>Pregibon D (1980). &ldquo;Goodness of Link Tests for Generalized Linear Models.&rdquo;
<em>Journal of the Royal Statistical Society C</em>, <b>29</b>, 15&ndash;23. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
data("BeetleMortality", package = "glmx")

## various standard binary response models
m &lt;- lapply(c("logit", "probit", "cloglog"), function(type)
  glm(cbind(died, n - died) ~ dose, data = BeetleMortality, family = binomial(link = type)))

## visualization
plot(I(died/n) ~ dose, data = BeetleMortality)
lines(fitted(m[[1]]) ~ dose, data = BeetleMortality, col = 2)
lines(fitted(m[[2]]) ~ dose, data = BeetleMortality, col = 3)
lines(fitted(m[[3]]) ~ dose, data = BeetleMortality, col = 4)
</code></pre>

<hr>
<h2 id='glmx'>Generalized Linear Models with Extra Parameters</h2><span id='topic+glmx'></span><span id='topic+glmx.fit'></span><span id='topic+coef.glmx'></span><span id='topic+formula.glmx'></span><span id='topic+logLik.glmx'></span><span id='topic+nobs.glmx'></span><span id='topic+print.glmx'></span><span id='topic+summary.glmx'></span><span id='topic+vcov.glmx'></span><span id='topic+predict.glmx'></span>

<h3>Description</h3>

<p>Estimation of generalized linear models with extra parameters,
e.g., parametric links, or families with additional parameters
(such as negative binomial).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmx(formula, data, subset, na.action, weights, offset,
  family = negative.binomial, xlink = "log", control = glmx.control(...),
  model = TRUE, y = TRUE, x = FALSE, ...)

glmx.fit(x, y, weights = NULL, offset = NULL,
  family = negative.binomial, xlink = "log", control = glmx.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmx_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model.</p>
</td></tr>
<tr><td><code id="glmx_+3A_data">data</code>, <code id="glmx_+3A_subset">subset</code>, <code id="glmx_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="glmx_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of case weights.</p>
</td></tr>
<tr><td><code id="glmx_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector(s) with an a priori known component to be
included in the linear predictor.</p>
</td></tr>
<tr><td><code id="glmx_+3A_family">family</code></td>
<td>
<p>function that returns a <code>"family"</code> object, i.e.,
<code>family(x)</code> needs to be a <code>"family"</code> object when
<code>x</code> is the numeric vector of extra parameters (by default assumed
to be 1-dimensional).</p>
</td></tr>
<tr><td><code id="glmx_+3A_xlink">xlink</code></td>
<td>
<p>link object or a character that can be passed to <code><a href="stats.html#topic+make.link">make.link</a></code>.
It should link the extra parameters to real parameters.</p>
</td></tr>
<tr><td><code id="glmx_+3A_control">control</code></td>
<td>
<p>a list of control arguments as returned by <code><a href="#topic+glmx.control">glmx.control</a></code>.</p>
</td></tr>
<tr><td><code id="glmx_+3A_model">model</code>, <code id="glmx_+3A_y">y</code>, <code id="glmx_+3A_x">x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.
For <code>glmx.fit</code>, <code>x</code> should be a numeric regressor matrix
and <code>y</code> should be the response vector.</p>
</td></tr>
<tr><td><code id="glmx_+3A_...">...</code></td>
<td>
<p>control arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>glmx</code> is a convenience interface that estimates generalized
linear models (GLMs) with extra parameters. Examples would be binary response models
with parametric link functions or count regression using a negative binomial family
(which has one additional parameter).
</p>
<p>Hence, <code>glmx</code> needs a <code>family</code> argument which is a family-generating function
depending on one numeric argument for the extra parameters. Then, either profile-likelihood
methods can be used for optimizing the extra parameters or all parameters can be
optimized jointly.
</p>
<p>If the generated <code>family</code> contains a list element <code>loglik.extra</code> for the
derivative of the log-likelihood with respect to the extra parameters (i.e., score/gradient
contributions), then this is used in the optimization process. This should be a
<code>function(y, mu, extra)</code> depending on the observed response <code>y</code>, the estimated
mean <code>mu</code>, and the <code>extra</code> parameters.
</p>


<h3>Value</h3>

<p><code>glmx</code> returns an object of class <code>"glmx"</code>, i.e., a list with components as follows.
<code>glmx.fit</code> returns an unclassed list with components up to <code>converged</code>.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"glm"</code> and <code>"extra"</code>
containing the coefficients from the respective models,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of deviance residuals,</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>list of <code>optim</code> outputs for maximizing the <code>"profile"</code>
and <code>"full"</code> log-likelihood, respectively,</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights used (if any),</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the list of offset vectors used (if any),</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights,</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>number of estimated parameters,</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>estimate of the dispersion parameter (if any),</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix of all parameters in the model,</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>a list with elements <code>"glm"</code> and <code>"extra"</code> where the former
contains the <code>"family"</code> object at the optimal extra parameters and
the latter the family-generating function,</p>
</td></tr>
<tr><td><code>xlink</code></td>
<td>
<p>the link object for the extra parameters,</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>control options used,</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical indicating successful convergence of <code>optim</code>,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call,</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula,</p>
</td></tr>  
<tr><td><code>terms</code></td>
<td>
<p>the terms object for the model,</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>the levels of the categorical regressors,</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>the contrasts corresponding to <code>levels</code>,</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector (if <code>y = TRUE</code>),</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the model matrix (if <code>x = TRUE</code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+glmx.control">glmx.control</a></code>, <code><a href="#topic+hetglm">hetglm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## artificial data from geometric regression
set.seed(1)
d &lt;- data.frame(x = runif(200, -1, 1))
d$y &lt;- rnbinom(200, mu = exp(0 + 3 * d$x), size = 1)

### negative binomial regression ###

## negative binomial regression via glmx
if(require("MASS")) {
m_nb1 &lt;- glmx(y ~ x, data = d,
  family = negative.binomial, xlink = "log", xstart = 0)
summary(m_nb1)

## negative binomial regression via MASS::glm.nb
m_nb2 &lt;- glm.nb(y ~ x, data = d)
summary(m_nb2)

## comparison
if(require("lmtest")) {
logLik(m_nb1)
logLik(m_nb2)
coeftest(m_nb1)
coeftest(m_nb2)
exp(coef(m_nb1, model = "extra"))
m_nb2$theta
exp(coef(m_nb1, model = "extra")) * sqrt(vcov(m_nb1, model = "extra"))
m_nb2$SE.theta
}}

## if the score (or gradient) contribution of the extra parameters
## is supplied, then estimation can be speeded up:
negbin &lt;- function(theta) {
  fam &lt;- negative.binomial(theta)
  fam$loglik.extra &lt;- function(y, mu, theta) digamma(y + theta) - digamma(theta) +
    log(theta) + 1 - log(mu + theta) - (y + theta)/(mu + theta)
  fam
}
m_nb3 &lt;- glmx(y ~ x, data = d,
  family = negbin, xlink = "log", xstart = 0, profile = FALSE)
all.equal(coef(m_nb1), coef(m_nb3), tolerance = 1e-7)


### censored negative binomial hurdle regression (0 vs. &gt; 0) ###

## negative binomial zero hurdle part via glmx
nbbin &lt;- function(theta) binomial(link = nblogit(theta))
m_hnb1 &lt;- glmx(factor(y &gt; 0) ~ x, data = d,
  family = nbbin, xlink = "log", xstart = 0)
summary(m_hnb1)

## negative binomial hurdle regression via pscl::hurdle
## (see only zero hurdle part)
if(require("pscl")) {
m_hnb2 &lt;- hurdle(y ~ x, data = d, dist = "negbin", zero.dist = "negbin")
summary(m_hnb2)
}
</code></pre>

<hr>
<h2 id='glmx.control'>Control Parameters for GLMs with Extra Parameters</h2><span id='topic+glmx.control'></span>

<h3>Description</h3>

<p>Various parameters that control fitting of generalized linear models
with extra parameters using <code><a href="#topic+glmx">glmx</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmx.control(profile = TRUE, nuisance = FALSE,
  start = NULL, xstart = NULL, hessian = TRUE, method = "BFGS", 
  epsilon = 1e-8, maxit = c(500, 25), trace = FALSE,
  reltol = .Machine$double.eps^(1/1.2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmx.control_+3A_profile">profile</code></td>
<td>
<p>logical. Should the extra parameters be optimized via
profile likelihood (or via the full likelihood of all parameters)?</p>
</td></tr>
<tr><td><code id="glmx.control_+3A_nuisance">nuisance</code></td>
<td>
<p>logical. Should the extra parameters be treated as
nuisance parameters (i.e., suppressed in subsequent output)?</p>
</td></tr>
<tr><td><code id="glmx.control_+3A_start">start</code></td>
<td>
<p>an optional vector with starting values for the GLM coefficients.</p>
</td></tr>
<tr><td><code id="glmx.control_+3A_xstart">xstart</code></td>
<td>
<p>an optional vector with starting values for the extra parameter(s).
Must be supplied if there is more than one extra parameter.</p>
</td></tr>
<tr><td><code id="glmx.control_+3A_hessian">hessian</code></td>
<td>
<p>logical or character. Should the hessian be computed
to estimate the covariance matrix? If character, <code>hessian</code> can
be either <code>"none"</code>, <code>"optim"</code> or <code>"numDeriv"</code>. The
default is the hessian from <code><a href="stats.html#topic+optim">optim</a></code> but alternatively
<code><a href="numDeriv.html#topic+hessian">hessian</a></code> from the <span class="pkg">numDeriv</span> package can be used.</p>
</td></tr>
<tr><td><code id="glmx.control_+3A_method">method</code></td>
<td>
<p>characters string specifying the <code>method</code> argument
passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="glmx.control_+3A_epsilon">epsilon</code></td>
<td>
<p>numeric convergance tolerance passed to <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="glmx.control_+3A_maxit">maxit</code></td>
<td>
<p>integer specifying the <code>maxit</code> argument (maximal number
of iterations) passed to <code><a href="stats.html#topic+optim">optim</a></code> and <code><a href="stats.html#topic+glm.control">glm.control</a></code>.
Can also be a vector of length 2.</p>
</td></tr>
<tr><td><code id="glmx.control_+3A_trace">trace</code></td>
<td>
<p>logical or integer controlling whether tracing information on  
the progress of the optimization should be produced (passed to
<code><a href="stats.html#topic+optim">optim</a></code>, and <code><a href="stats.html#topic+glm.control">glm.control</a></code>).
Can also be a vector of length 2.</p>
</td></tr>
<tr><td><code id="glmx.control_+3A_reltol">reltol</code>, <code id="glmx.control_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parameters in <code><a href="#topic+glmx">glmx</a></code> are estimated by maximum likelihood
using <code><a href="stats.html#topic+optim">optim</a></code> with control options set in <code><a href="#topic+glmx.control">glmx.control</a></code>.
Either the parameters can be found by only optimizing over the extra parameters
(and then using <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> to estimate the GLM coefficients),
or alternatively all parameters can be optimized simultaneously.
Covariances are derived numerically using the Hessian matrix returned by
<code><a href="stats.html#topic+optim">optim</a></code>.
</p>


<h3>Value</h3>

<p>A list with the arguments specified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+glmx">glmx</a></code></p>

<hr>
<h2 id='hetglm'>Heteroscedastic Binary Response GLMs</h2><span id='topic+hetglm'></span><span id='topic+hetglm.fit'></span><span id='topic+print.hetglm'></span><span id='topic+summary.hetglm'></span><span id='topic+print.summary.hetglm'></span><span id='topic+predict.hetglm'></span><span id='topic+coef.hetglm'></span><span id='topic+vcov.hetglm'></span><span id='topic+bread.hetglm'></span><span id='topic+estfun.hetglm'></span><span id='topic+coeftest.hetglm'></span><span id='topic+logLik.hetglm'></span><span id='topic+terms.hetglm'></span><span id='topic+model.frame.hetglm'></span><span id='topic+model.matrix.hetglm'></span><span id='topic+residuals.hetglm'></span><span id='topic+update.hetglm'></span>

<h3>Description</h3>

<p>Fit heteroscedastic binary response models via maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hetglm(formula, data, subset, na.action, weights, offset,
  family = binomial(link = "probit"),
  link.scale = c("log", "sqrt", "identity"),
  control = hetglm.control(...),
  model = TRUE, y = TRUE, x = FALSE, ...)

hetglm.fit(x, y, z = NULL, weights = NULL, offset = NULL,
  family = binomial(), link.scale = "log", control = hetglm.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hetglm_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model (of type <code>y ~ x</code>
or <code>y ~ x | z</code>; for details see below).</p>
</td></tr>
<tr><td><code id="hetglm_+3A_data">data</code>, <code id="hetglm_+3A_subset">subset</code>, <code id="hetglm_+3A_na.action">na.action</code></td>
<td>
<p>arguments controlling formula processing
via <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="hetglm_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of case weights.</p>
</td></tr>
<tr><td><code id="hetglm_+3A_offset">offset</code></td>
<td>
<p>optional numeric vector(s) with an a priori known component to be
included in the linear predictor(s).</p>
</td></tr>
<tr><td><code id="hetglm_+3A_family">family</code></td>
<td>
<p>family object (including the link function of the mean model).</p>
</td></tr>
<tr><td><code id="hetglm_+3A_link.scale">link.scale</code></td>
<td>
<p>character specification of the link function in
the latent scale model.</p>
</td></tr>
<tr><td><code id="hetglm_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via
<code><a href="#topic+hetglm.control">hetglm.control</a></code>.</p>
</td></tr>
<tr><td><code id="hetglm_+3A_model">model</code>, <code id="hetglm_+3A_y">y</code>, <code id="hetglm_+3A_x">x</code></td>
<td>
<p>logicals. If <code>TRUE</code> the corresponding components
of the fit (model frame, response, model matrix) are returned.
For <code>hetglm.fit</code>, <code>x</code> should be a numeric regressor matrix
and <code>y</code> should be the numeric response vector (with values in (0,1)).</p>
</td></tr>
<tr><td><code id="hetglm_+3A_z">z</code></td>
<td>
<p>numeric matrix. Regressor matrix for the precision model, defaulting
to an intercept only.</p>
</td></tr>
<tr><td><code id="hetglm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+hetglm.control">hetglm.control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of standard extractor functions for fitted model objects is available for
objects of class <code>"hetglm"</code>, including methods to the generic functions
<code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="stats.html#topic+coef">coef</a></code>, 
<code><a href="stats.html#topic+vcov">vcov</a></code>, <code><a href="stats.html#topic+logLik">logLik</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, 
<code><a href="stats.html#topic+predict">predict</a></code>, <code><a href="stats.html#topic+terms">terms</a></code>, <code><a href="stats.html#topic+update">update</a></code>,
<code><a href="stats.html#topic+model.frame">model.frame</a></code>, <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>,
<code><a href="sandwich.html#topic+estfun">estfun</a></code> and <code><a href="sandwich.html#topic+bread">bread</a></code> (from the <span class="pkg">sandwich</span> package), and
<code><a href="lmtest.html#topic+coeftest">coeftest</a></code> (from the <span class="pkg">lmtest</span> package).  
</p>


<h3>Value</h3>

<p><code>hetglm</code> returns an object of class <code>"hetglm"</code>, i.e., a list with components as follows.
<code>hetglm.fit</code> returns an unclassed list with components up to <code>converged</code>.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"scale"</code>
containing the coefficients from the respective models,</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a vector of raw residuals (observed - fitted),</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a vector of fitted means,</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>output from the <code>optim</code> call for maximizing the log-likelihood,</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method argument passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the control arguments passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>the starting values for the parameters passed to the <code>optim</code> call,</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights used (if any),</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the list of offset vectors used (if any),</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations,</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations with non-zero weights,</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>residual degrees of freedom in the homoscedastic null model,</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>residual degrees of freedom in the fitted model,</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the fitted model,</p>
</td></tr>
<tr><td><code>loglik.null</code></td>
<td>
<p>log-likelihood of the homoscedastic null model,</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>estimate of the dispersion parameter (if any),</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>covariance matrix of all parameters in the model,</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family object used,</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"scale"</code>
containing the link objects for the respective models,</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical indicating successful convergence of <code>optim</code>,</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call,</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the original formula,</p>
</td></tr>  
<tr><td><code>terms</code></td>
<td>
<p>a list with elements <code>"mean"</code>, <code>"scale"</code> and
<code>"full"</code> containing the terms objects for the respective models,</p>
</td></tr>
<tr><td><code>levels</code></td>
<td>
<p>a list with elements <code>"mean"</code>, <code>"scale"</code> and
<code>"full"</code> containing the levels of the categorical regressors,</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"scale"</code>
containing the contrasts corresponding to <code>levels</code> from the
respective models,</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the full model frame (if <code>model = TRUE</code>),</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response vector (if <code>y = TRUE</code>),</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a list with elements <code>"mean"</code> and <code>"scale"</code>
containing the model matrices from the respective models
(if <code>x = TRUE</code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="Formula.html#topic+Formula">Formula</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate artifical binary data from a latent
## heteroscedastic normally distributed variable
set.seed(48)
n &lt;- 200
x &lt;- rnorm(n)
ystar &lt;- 1 + x +  rnorm(n, sd = exp(x))
y  &lt;- factor(ystar &gt; 0) 

## visualization
par(mfrow = c(1, 2))
plot(ystar ~ x, main = "latent")
abline(h = 0, lty = 2)
plot(y ~ x, main = "observed")

## model fitting of homoscedastic model (m0a/m0b)
## and heteroscedastic model (m)
m0a &lt;- glm(y ~ x, family = binomial(link = "probit"))
m0b &lt;- hetglm(y ~ x | 1)
m &lt;- hetglm(y ~ x)

## coefficient estimates
cbind(heteroscedastic = coef(m),
  homoscedastic = c(coef(m0a), 0))

## summary of correct heteroscedastic model
summary(m)



## Generate artificial binary data with a single binary regressor
## driving the heteroscedasticity in a model with two regressors
set.seed(48)
n &lt;- 200
x &lt;- rnorm(n)
z &lt;- rnorm(n)
a &lt;- factor(sample(1:2, n, replace = TRUE))
ystar &lt;- 1 + c(0, 1)[a] + x + z + rnorm(n, sd = c(1, 2)[a])
y  &lt;- factor(ystar &gt; 0) 

## fit "true" heteroscedastic model
m1 &lt;- hetglm(y ~ a + x + z | a)

## fit interaction model
m2 &lt;- hetglm(y ~ a/(x + z) | 1)

## although not obvious at first sight, the two models are
## nested. m1 is a restricted version of m2 where the following
## holds: a1:x/a2:x == a1:z/a2:z
if(require("lmtest")) lrtest(m1, m2)

## both ratios are == 2 in the data generating process
c(x = coef(m2)[3]/coef(m2)[4], z = coef(m2)[5]/coef(m2)[6])



if(require("AER")) {

## Labor force participation example from Greene
## (5th edition: Table 21.3, p. 682)
## (6th edition: Table 23.4, p. 790)

## data (including transformations)
data("PSID1976", package = "AER")
PSID1976$kids &lt;- with(PSID1976, factor((youngkids + oldkids) &gt; 0,
  levels = c(FALSE, TRUE), labels = c("no", "yes")))
PSID1976$fincome &lt;- PSID1976$fincome/10000

## Standard probit model via glm()
lfp0a &lt;- glm(participation ~ age + I(age^2) + fincome + education + kids,
  data = PSID1976, family = binomial(link = "probit"))

## Standard probit model via hetglm() with constant scale
lfp0b &lt;- hetglm(participation ~ age + I(age^2) + fincome + education + kids | 1,
  data = PSID1976)

## Probit model with varying scale
lfp1 &lt;- hetglm(participation ~ age + I(age^2) + fincome + education + kids | kids + fincome,
  data = PSID1976)

## Likelihood ratio and Wald test
lrtest(lfp0b, lfp1)
waldtest(lfp0b, lfp1)

## confusion matrices
table(true = PSID1976$participation,
  predicted = fitted(lfp0b) &lt;= 0.5)
table(true = PSID1976$participation,
  predicted = fitted(lfp1) &lt;= 0.5)



## Adapted (and somewhat artificial) example to illustrate that
## certain models with heteroscedastic scale can equivalently
## be interpreted as homoscedastic scale models with interaction
## effects.

## probit model with main effects and heteroscedastic scale in two groups
m &lt;- hetglm(participation ~ kids + fincome | kids, data = PSID1976)

## probit model with interaction effects and homoscedastic scale
p &lt;- glm(participation ~ kids * fincome, data = PSID1976,
   family = binomial(link = "probit"))

## both likelihoods are equivalent
logLik(m)
logLik(p)

## intercept/slope for the kids=="no" group
coef(m)[c(1, 3)]
coef(p)[c(1, 3)]

## intercept/slope for the kids=="yes" group
c(sum(coef(m)[1:2]), coef(m)[3]) / exp(coef(m)[4])
coef(p)[c(1, 3)] + coef(p)[c(2, 4)]

## Wald tests for the heteroscedasticity effect in m and the 
## interaction effect in p are very similar
coeftest(m)[4,]
coeftest(p)[4,]

## corresponding likelihood ratio tests are equivalent
## (due to the invariance of the MLE)
m0 &lt;- hetglm(participation ~ kids + fincome | 1, data = PSID1976)
p0 &lt;- glm(participation ~ kids + fincome, data = PSID1976,
  family = binomial(link = "probit"))
lrtest(m0, m)
lrtest(p0, p)

}
</code></pre>

<hr>
<h2 id='hetglm.control'>Control Parameters for Heteroscedastic Binary Response GLMs</h2><span id='topic+hetglm.control'></span>

<h3>Description</h3>

<p>Various parameters that control fitting of heteroscedastic binary response models
using <code><a href="#topic+hetglm">hetglm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hetglm.control(method = "nlminb", maxit = 1000,
  hessian = FALSE, trace = FALSE, start = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hetglm.control_+3A_method">method</code></td>
<td>
<p>characters string specifying either that <code><a href="stats.html#topic+nlminb">nlminb</a></code>
is used for optimization or the <code>method</code> argument passed to
<code><a href="stats.html#topic+optim">optim</a></code> (typically, <code>"BFGS"</code> or <code>"L-BFGS-B"</code>).</p>
</td></tr>
<tr><td><code id="hetglm.control_+3A_maxit">maxit</code></td>
<td>
<p>integer specifying the maximal number of iterations in the optimization.</p>
</td></tr>
<tr><td><code id="hetglm.control_+3A_hessian">hessian</code></td>
<td>
<p>logical. Should the numerical Hessian matrix from the <code>optim</code> output
be used for estimation of the covariance matrix? The default (and only option for
<code>nlminb</code>) is to use the analytical expected information rather than the numerical Hessian.</p>
</td></tr>
<tr><td><code id="hetglm.control_+3A_trace">trace</code></td>
<td>
<p>logical or integer controlling whether tracing information on  
the progress of the optimization should be produced?</p>
</td></tr>
<tr><td><code id="hetglm.control_+3A_start">start</code></td>
<td>
<p>an optional vector with starting values for all parameters.</p>
</td></tr>
<tr><td><code id="hetglm.control_+3A_...">...</code></td>
<td>
<p>arguments passed to the optimizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All parameters in <code><a href="#topic+hetglm">hetglm</a></code> are estimated by maximum likelihood
using either <code><a href="stats.html#topic+nlminb">nlminb</a></code> (default) or <code><a href="stats.html#topic+optim">optim</a></code>
with analytical gradients and (by default) analytical expected information.
Further control options can be set in <code><a href="#topic+hetglm.control">hetglm.control</a></code>, most of which
are simply passed on to the corresponding optimizer.
</p>
<p>Starting values can be supplied via <code>start</code> or estimated by
<code><a href="stats.html#topic+glm">glm.fit</a></code>, using the homoscedastic model.
Covariances are derived analytically by default. Alternatively, the numerical
Hessian matrix returned by <code>optim</code> can be employed, in case this is used
for the optimization itself.
</p>


<h3>Value</h3>

<p>A list with the processed specified arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hetglm">hetglm</a></code></p>

<hr>
<h2 id='MexicanLabor'>Mexican Women's Labor-Force Participation</h2><span id='topic+MexicanLabor'></span>

<h3>Description</h3>

<p>Data from the National Survey of Household Income and Expenditures for 1977,
Secretaria de Programacion y Presupuesto, Mexico.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("MexicanLabor")</code></pre>


<h3>Format</h3>

<p>A data frame containing 16 observations on 6 variables.
</p>

<dl>
<dt>total</dt><dd><p>integer. Number of women older than 12 years.</p>
</dd>
<dt>laborforce</dt><dd><p>integer. Number of women in labor force.</p>
</dd>
<dt>locality</dt><dd><p>factor with levels <code>"rural"</code>/<code>"urban"</code>.</p>
</dd>
<dt>age</dt><dd><p>factor with levels <code>"&lt;= 24"</code> and <code>"&gt; 24"</code> (in years).</p>
</dd>
<dt>income</dt><dd><p>factor with levels <code>"low"</code>/<code>"high"</code>
(household income less or more than $2626.8).</p>
</dd>
<dt>schooling</dt><dd><p>factor with levels <code>"primary"</code> (primary school or less)
and <code>"further"</code> (more than primary school).</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data were first analyzed by Guerrero and Johnson (1982) as an example of a
highly asymmetric data set, i.e., the observed proportions are rather low.
</p>


<h3>Source</h3>

<p>Guerrero V, Johnson R (1982). &ldquo;Use of the Box-Cox Transformation with Binary Response Models.&rdquo;
<em>Biometrika</em>, <b>69</b>, 309&ndash;314.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## data
data("MexicanLabor", package = "glmx")

## visualizations
plot(I(laborforce/total) ~ interaction(income, age), data = MexicanLabor)
plot(I(laborforce/total) ~ interaction(schooling, locality), data = MexicanLabor)

## simple logit model
m &lt;- glm(cbind(laborforce, total - laborforce) ~ ., data = MexicanLabor, family = binomial)
m
</code></pre>

<hr>
<h2 id='plinks'>Parametric Links for Binomial Generalized Linear Models</h2><span id='topic+plinks'></span><span id='topic+talpha'></span><span id='topic+ao1'></span><span id='topic+ao2'></span><span id='topic+gj'></span><span id='topic+angular'></span><span id='topic+foldexp'></span><span id='topic+rocke'></span><span id='topic+nblogit'></span><span id='topic+gosset'></span><span id='topic+pregibon'></span><span id='topic+loglog'></span>

<h3>Description</h3>

<p>Various symmetric and asymmetric parametric links for use as
link function for binomial generalized linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  gj(phi, verbose = FALSE)
  foldexp(phi, verbose = FALSE)
  ao1(phi, verbose = FALSE)
  ao2(phi, verbose = FALSE)
  talpha(alpha, verbose = FALSE, splineinv = TRUE,
    eps = 2 * .Machine$double.eps, maxit = 100)
  rocke(shape1, shape2, verbose = FALSE)

  gosset(nu, verbose = FALSE)
  pregibon(a, b)
  nblogit(theta)

  angular(verbose = FALSE)
  loglog()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plinks_+3A_phi">phi</code>, <code id="plinks_+3A_a">a</code>, <code id="plinks_+3A_b">b</code></td>
<td>
<p>numeric.</p>
</td></tr>
<tr><td><code id="plinks_+3A_alpha">alpha</code></td>
<td>
<p>numeric. Parameter in <code class="reqn">[0,2]</code>.</p>
</td></tr>
<tr><td><code id="plinks_+3A_shape1">shape1</code>, <code id="plinks_+3A_shape2">shape2</code>, <code id="plinks_+3A_nu">nu</code>, <code id="plinks_+3A_theta">theta</code></td>
<td>
<p>numeric. Non-negative parameter.</p>
</td></tr>
<tr><td><code id="plinks_+3A_splineinv">splineinv</code></td>
<td>
<p>logical. Should a (quick and dirty) spline function be used
for computing the inverse link function? Alternatively, a more precise but somewhat
slower Newton algorithm is used.</p>
</td></tr>
<tr><td><code id="plinks_+3A_eps">eps</code></td>
<td>
<p>numeric. Desired convergence tolerance for Newton algorithm.</p>
</td></tr>
<tr><td><code id="plinks_+3A_maxit">maxit</code></td>
<td>
<p>integer. Maximal number of steps for Newton algorithm.</p>
</td></tr>
<tr><td><code id="plinks_+3A_verbose">verbose</code></td>
<td>
<p>logical. Should warnings about numerical issues be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Symmetric and asymmetric families parametric link functions are available.
Many families contain the logit for some value(s) of their parameter(s). 
</p>
<p>The symmetric Aranda-Ordaz (1981) transformation
</p>
<p style="text-align: center;"><code class="reqn">y = \frac{2}{\phi}\frac{x^\phi-(1-x)^\phi}{x^\phi+(1-x)^\phi}</code>
</p>

<p>and the asymmetric Aranda-Ordaz (1981) transformation
</p>
<p style="text-align: center;"><code class="reqn">y = \log([(1-x)^{-\phi}-1]/\phi)</code>
</p>

<p>both contain the logit for <code class="reqn">\phi = 0</code> and
<code class="reqn">\phi = 1</code> respectively, where the latter also includes the
complementary log-log for <code class="reqn">\phi = 0</code>.
</p>
<p>The Pregibon (1980) two parameter family is the link given by
</p>
<p style="text-align: center;"><code class="reqn">y = \frac{x^{a-b}-1}{a-b}-\frac{(1-x)^{a+b}-1}{a+b}.</code>
</p>

<p>For <code class="reqn">a = b = 0</code> it is the logit. For <code class="reqn">b = 0</code> it is symmetric and
<code class="reqn">b</code> controls the skewness; the heavyness of the tails is controlled by
<code class="reqn">a</code>. The implementation uses the generalized lambda distribution
<code><a href="base.html#topic+gl">gl</a></code>.
</p>
<p>The Guerrero-Johnson (1982) family
</p>
<p style="text-align: center;"><code class="reqn">y = \frac{1}{\phi}\left(\left[\frac{x}{1-x}\right]^\phi-1\right)</code>
</p>

<p>is symmetric and contains the logit for <code class="reqn">\phi = 0</code>.
</p>
<p>The Rocke (1993) family of links is, modulo a linear transformation, the
cumulative density function of the Beta distribution. If both parameters are
set to <code class="reqn">0</code> the logit link is obtained. If both parameters equal
<code class="reqn">0.5</code> the Rocke link is, modulo a linear transformation, identical to the
angular transformation. Also for <code>shape1</code> = <code>shape2</code> <code class="reqn">= 1</code>, the
identity link is obtained. Note that the family can be used as a one and a two
parameter family.
</p>
<p>The folded exponential family (Piepho, 2003) is symmetric and given by
</p>
<p style="text-align: center;"><code class="reqn">y = \left\{\begin{array}{ll}
    \frac{\exp(\phi x)-\exp(\phi(1-x))}{2\phi}   &amp;(\phi \neq 0) \\
    x- \frac{1}{2}                 &amp;(\phi = 0)  
    \end{array}\right.</code>
</p>
  
<p>The <code class="reqn">t_\alpha</code> family (Doebler, Holling &amp; Boehning, 2011) given by
</p>
<p style="text-align: center;"><code class="reqn">y = \alpha\log(x)-(2-\alpha)\log(1-x)</code>
</p>

<p>is asymmetric and contains the logit for <code class="reqn">\phi = 1</code>.
</p>
<p>The Gosset family of links is given by the inverse of the cumulative
distribution function of the t-distribution. The degrees of freedom <code class="reqn">\nu</code>
control the heavyness of the tails and is restricted to values <code class="reqn">&gt;0</code>. For
<code class="reqn">\nu = 1</code> the Cauchy link is obtained and for <code class="reqn">\nu \to \infty</code> the link
converges to the probit. The implementation builds on <code><a href="stats.html#topic+qf">qf</a></code> and is
reliable for <code class="reqn">\nu \geq 0.2</code>. Liu (2004) reports that the Gosset link
approximates the logit well for <code class="reqn">\nu = 7</code>.
</p>
<p>Also the (parameterless) angular (arcsine) transformation
<code class="reqn">y = \arcsin(\sqrt{x})</code> is available as a link
function.
</p>


<h3>Value</h3>

<p>An object of the class <code>link-glm</code>, see the documentation of <code><a href="stats.html#topic+make.link">make.link</a></code>.
</p>


<h3>References</h3>

<p>Aranda-Ordaz F (1981). &ldquo;On Two Families of Transformations to Additivity for Binary Response Data.&rdquo;
<em>Biometrika</em>, <b>68</b>, 357&ndash;363.
</p>
<p>Doebler P, Holling H, Boehning D (2012). &ldquo;A Mixed Model Approach to Meta-Analysis of Diagnostic Studies with Binary Test Outcome.&rdquo; 
<em>Psychological Methods</em>, <b>17</b>(3), 418&ndash;436.
</p>
<p>Guerrero V, Johnson R (1982). &ldquo;Use of the Box-Cox Transformation with Binary Response Models.&rdquo;
<em>Biometrika</em>, <b>69</b>, 309&ndash;314.
</p>
<p>Koenker R (2006). &ldquo;Parametric Links for Binary Response.&rdquo;
<em>R News</em>, <b>6</b>(4), 32&ndash;34.
</p>
<p>Koenker R, Yoon J (2009). &ldquo;Parametric Links for Binary Choice Models: A Fisherian-Bayesian Colloquy.&rdquo;
<em>Journal of Econometrics</em>, <b>152</b>, 120&ndash;130.
</p>
<p>Liu C (2004). &ldquo;Robit Regression: A Simple Robust Alternative to Logistic and Probit Regression.&rdquo;
In Gelman A, Meng X-L (Eds.),
<em>Applied Bayesian Modeling and Causal Inference from Incomplete-Data Perspectives</em>, Chapter 21,
pp. 227&ndash;238. John Wiley &amp; Sons.
</p>
<p>Piepho H (2003). The Folded Exponential Transformation for Proportions.
<em>Journal of the Royal Statistical Society D</em>, <b>52</b>, 575&ndash;589.
</p>
<p>Pregibon D (1980). &ldquo;Goodness of Link Tests for Generalized Linear Models.&rdquo;
<em>Journal of the Royal Statistical Society C</em>, <b>29</b>, 15&ndash;23. 
</p>
<p>Rocke DM (1993). &ldquo;On the Beta Transformation Family.&rdquo;
<em>Technometrics</em>, <b>35</b>, 73&ndash;81.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+make.link">make.link</a></code>, <code><a href="stats.html#topic+family">family</a></code>, <code><a href="#topic+glmx">glmx</a></code>, <code><a href="#topic+WECO">WECO</a></code></p>

<hr>
<h2 id='pregibon'>Pregibon Distribution</h2><span id='topic+dpregibon'></span><span id='topic+ppregibon'></span><span id='topic+qpregibon'></span><span id='topic+rpregibon'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the Pregibon distribution with parameters
<code>a</code> and <code>b</code>. It is a special case of the generalized
Tukey lambda distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpregibon(x, a = 0, b = 0, log = FALSE, tol = 1e-12)
ppregibon(q, a = 0, b = 0, lower.tail = TRUE, log.p = FALSE, tol = 1e-12)
qpregibon(p, a = 0, b = 0, lower.tail = TRUE, log.p = FALSE)
rpregibon(n, a = 0, b = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pregibon_+3A_x">x</code>, <code id="pregibon_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="pregibon_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="pregibon_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="pregibon_+3A_a">a</code>, <code id="pregibon_+3A_b">b</code></td>
<td>
<p>distribution parameters.</p>
</td></tr>
<tr><td><code id="pregibon_+3A_log">log</code>, <code id="pregibon_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="pregibon_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="pregibon_+3A_tol">tol</code></td>
<td>
<p>numeric tolerance for computation of the distribution function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution is a special case of the generalized Tukey lambda distribution
and is used by Pregibon (1980) for goodness-of-link testing. See Koenker (2006)
and Koenker and Yoon (2009) for more details.
</p>
<p>The implementation is based on the corresponding functions for the
<a href="gld.html#topic+GeneralisedLambdaDistribution">GeneralisedLambdaDistribution</a> in the <span class="pkg">gld</span> package (King 2013).
</p>
<p>The corresponding link generator is available in the function <code><a href="#topic+pregibon">pregibon</a></code>.
</p>


<h3>Value</h3>

<p><code>dpregibon</code> gives the probability density function,
<code>ppregibon</code> gives the cumulative distribution function,
<code>qpregibon</code> gives the quantile function, and
<code>rpregibon</code> generates random deviates.
</p>


<h3>References</h3>

<p>King R, Dean B, Klinke S (2016). &ldquo;Estimation and Use of the Generalised (Tukey) Lambda Distribution.&rdquo;
R package version 2.4.1. <a href="https://CRAN.R-project.org/package=gld">https://CRAN.R-project.org/package=gld</a>
</p>
<p>Koenker R (2006). &ldquo;Parametric Links for Binary Response.&rdquo;
<em>R News</em>, <b>6</b>(4), 32&ndash;34.
</p>
<p>Koenker R, Yoon J (2009). &ldquo;Parametric Links for Binary Choice Models: A Fisherian-Bayesian Colloquy.&rdquo;
<em>Journal of Econometrics</em>, <b>152</b>, 120&ndash;130.
</p>
<p>Pregibon D (1980). &ldquo;Goodness of Link Tests for Generalized Linear Models.&rdquo;
<em>Journal of the Royal Statistical Society C</em>, <b>29</b>, 15&ndash;23. 
</p>


<h3>See Also</h3>

<p><a href="gld.html#topic+GeneralisedLambdaDistribution">GeneralisedLambdaDistribution</a>, <code><a href="#topic+pregibon">pregibon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Koenker &amp; Yoon (2009), Figure 2
par(mfrow = c(3, 3))
pregiboncurve &lt;- function(a, b, from, to, n = 301) {
  dp &lt;- function(x) dpregibon(x, a = a, b = b)
  curve(dp, from = from, to = to, n = n,
    xlab = "", ylab = "",
    main = paste("a = ", a, ", b = ", b, sep = ""))
}
pregiboncurve(-0.25, -0.25,  -5, 65)
pregiboncurve(-0.25,  0,    -18, 18)
pregiboncurve(-0.25,  0.25, -65,  5)
pregiboncurve( 0,    -0.25,  -4, 22)
pregiboncurve( 0,     0,     -8,  8)
pregiboncurve( 0,     0.25, -22,  4)
pregiboncurve( 0.25, -0.25,  -2.4,9)
pregiboncurve( 0.25,  0,     -4,  4)
pregiboncurve( 0.25,  0.25,  -9,  2.4)
par(mfrow = c(1, 1))
</code></pre>

<hr>
<h2 id='WECO'>Productivity and Quit Behavior of Western Electric Workers</h2><span id='topic+WECO'></span>

<h3>Description</h3>

<p>Partially artificial data about quit behavior of Western Electric workers.
(Western Electric was the manufacturing arm of the AT&amp;T corporation during
its glory days as a monopolist in the U.S. telephone industry.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("WECO")</code></pre>


<h3>Format</h3>

<p>A data frame containing 683 observations on 7 variables.
</p>

<dl>
<dt>output</dt><dd><p>productivity in first six months.</p>
</dd>
<dt>sex</dt><dd><p>factor indicating gender.</p>
</dd>
<dt>dex</dt><dd><p>score on a preemployment dexterity exam.</p>
</dd>
<dt>lex</dt><dd><p>years of education.</p>
</dd>
<dt>kwit</dt><dd><p>factor indicating whether the worker quit in the first six months.</p>
</dd>
<dt>tenure</dt><dd><p>duration of employment (see details).</p>
</dd>
<dt>censored</dt><dd><p>logical. Is the duration censored?</p>
</dd>
</dl>



<h3>Details</h3>

<p>The explanatory variables in this example are taken from the study of Klein et
al. (1991), but the response variable was altered long ago to improve the
didactic impact of the model as a class exercise. To this end, quit dates for
each individual were generated according to a log Weibull proportional hazard
model.
</p>


<h3>Source</h3>

<p>Online supplements to Koenker (2006) and Koenker and Yoon (2009).
</p>
<p><a href="http://www.econ.uiuc.edu/~roger/research/links/links.html">http://www.econ.uiuc.edu/~roger/research/links/links.html</a>
</p>


<h3>References</h3>

<p>Klein R, Spady R, Weiss A (1991). &ldquo;Factors Affecting the Output and Quit Propensities of Production Workers.&rdquo;
<em>The Review of Economic Studies</em>, <b>58</b>(5), 929&ndash;953.
</p>
<p>Koenker R (2006). &ldquo;Parametric Links for Binary Response.&rdquo;
<em>R News</em>, <b>6</b>(4), 32&ndash;34.
</p>
<p>Koenker R, Yoon J (2009). &ldquo;Parametric Links for Binary Choice Models: A Fisherian-Bayesian Colloquy.&rdquo;
<em>Journal of Econometrics</em>, <b>152</b>, 120&ndash;130.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plinks">plinks</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## WECO data
data("WECO", package = "glmx")
f &lt;- kwit ~ sex + dex + poly(lex, 2, raw = TRUE)
## (raw = FALSE would be numerically more stable)

## Gosset model
gossbin &lt;- function(nu) binomial(link = gosset(nu))
m1 &lt;- glmx(f, data = WECO,
  family = gossbin, xstart = 0, xlink = "log")

## Pregibon model
pregibin &lt;- function(shape) binomial(link = pregibon(shape[1], shape[2]))
m2 &lt;- glmx(f, data = WECO,
  family = pregibin, xstart = c(0, 0), xlink = "identity")

## Probit/logit/cauchit models
m3 &lt;- lapply(c("probit", "logit", "cauchit"), function(nam)
  glm(f, data = WECO, family = binomial(link = nam)))

## Probit/cauchit vs. Gosset
if(require("lmtest")) {
lrtest(m3[[1]], m1)
lrtest(m3[[3]], m1)

## Logit vs. Pregibon
lrtest(m3[[2]], m2)
}

## Table 1
tab1 &lt;- sapply(c(m3, list(m1)), function(obj)
  c(head(coef(obj), 5), AIC(obj)))
colnames(tab1) &lt;- c("Probit", "Logit", "Cauchit", "Gosset")
rownames(tab1)[4:6] &lt;- c("lex", "lex^2", "AIC")
tab1 &lt;- round(t(tab1), digits = 3)
tab1

## Figure 4
plot(fitted(m3[[1]]), fitted(m1),
  xlim = c(0, 1), ylim = c(0, 1),
  xlab = "Estimated Probit Probabilities",
  ylab = "Estimated Gosset Probabilities")
abline(0, 1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
