<!DOCTYPE html><html lang="en"><head><title>Help for package ecostate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ecostate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abm3pc_sys'><p>Adams-Bashford-Moulton for system of equations</p></a></li>
<li><a href='#add_equilibrium'><p>Compute equilibrium values</p></a></li>
<li><a href='#compute_nll'><p>Compute negative log-likelihood for EcoState model</p></a></li>
<li><a href='#compute_tracer'><p>Calculate tracers, e.g., trophic level</p></a></li>
<li><a href='#dBdt'><p>Dynamics from EcoSim</p></a></li>
<li><a href='#ddirmult'><p>Dirichlet-multinomial</p></a></li>
<li><a href='#eastern_bering_sea'><p>eastern Bering Sea ecosystem data</p></a></li>
<li><a href='#ecostate'><p>fit EcoState model</p></a></li>
<li><a href='#ecostate_control'><p>Detailed control for ecostate structure</p></a></li>
<li><a href='#ginv'><p>Penrose-Moore pseudoinverse</p></a></li>
<li><a href='#logLik.ecostate'><p>Marginal log-likelihood</p></a></li>
<li><a href='#ode23'><p>Non-stiff (and stiff) ODE solvers</p></a></li>
<li><a href='#plot_foodweb'><p>Plot foodweb</p></a></li>
<li><a href='#print_ecopars'><p>Print EcoSim parameters</p></a></li>
<li><a href='#print.ecostate'><p>Print fitted ecostate object</p></a></li>
<li><a href='#rk4sys'><p>Classical Runge-Kutta for system of equations</p></a></li>
<li><a href='#stanza_settings'><p>Detailed control for stanza structure</p></a></li>
<li><a href='#whitehouse_2021'><p>Full rpath inputs for eastern Bering Sea</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>State-Space Mass-Balance Model for Marine Ecosystems</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James T. Thorson &lt;James.Thorson@noaa.gov&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
	Fits a state-space mass-balance model for marine ecosystems,
	which implements dynamics derived from 
	'Ecopath with Ecosim' <a href="https://ecopath.org/">https://ecopath.org/</a>
	while fitting to time-series of fishery catch, biomass indices,
	age-composition samples, and weight-at-age data. Package 
	'ecostate' fits biological parameters (e.g., equilibrium mass)
	and measurement parameters (e.g., catchability coefficients)
	jointly with residual variation in process errors, and can include
	Bayesian priors for parameters.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), RTMB (&ge; 1.5.0),</td>
</tr>
<tr>
<td>Imports:</td>
<td>TMB, MASS, checkmate, ggplot2, ggnetwork, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://james-thorson-noaa.github.io/ecostate/">https://james-thorson-noaa.github.io/ecostate/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/James-Thorson-NOAA/ecostate/issues">https://github.com/James-Thorson-NOAA/ecostate/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-22 15:10:37 UTC; James.Thorson</td>
</tr>
<tr>
<td>Author:</td>
<td>James T. Thorson <a href="https://orcid.org/0000-0001-7415-1010"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-25 11:50:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='abm3pc_sys'>Adams-Bashford-Moulton for system of equations</h2><span id='topic+abm3pc_sys'></span>

<h3>Description</h3>

<p>Third-order Adams-Bashford-Moulton predictor-corrector method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abm3pc_sys(f, a, b, y0, n, Pars, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abm3pc_sys_+3A_f">f</code></td>
<td>
<p>function in the differential equation <code class="reqn">y' = f(x, y)</code>;
defined as a function <code class="reqn">R \times R^m \rightarrow R^m</code>, where <code class="reqn">m</code> is the number of equations.</p>
</td></tr>
<tr><td><code id="abm3pc_sys_+3A_a">a</code></td>
<td>
<p>starting time for the interval to integrate</p>
</td></tr>
<tr><td><code id="abm3pc_sys_+3A_b">b</code></td>
<td>
<p>ending time for the interval to integrate.</p>
</td></tr>
<tr><td><code id="abm3pc_sys_+3A_y0">y0</code></td>
<td>
<p>starting values at time <code>a</code></p>
</td></tr>
<tr><td><code id="abm3pc_sys_+3A_n">n</code></td>
<td>
<p>number of steps</p>
</td></tr>
<tr><td><code id="abm3pc_sys_+3A_pars">Pars</code></td>
<td>
<p>named list of parameters passed to f</p>
</td></tr>
<tr><td><code id="abm3pc_sys_+3A_...">...</code></td>
<td>
<p>additional inputs to function <code>f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combined Adams-Bashford and Adams-Moulton (or: multi-step) method of third order
with corrections according to the predictor-corrector approach.
Copied from pracma under GPL-3, with small modifications to work with RTMB
</p>


<h3>Value</h3>

<p>List with components x for grid points between a and b and y an
n-by-m matrix with solutions for variables in columns, i.e.
each row contains one time stamp.
</p>

<hr>
<h2 id='add_equilibrium'>Compute equilibrium values</h2><span id='topic+add_equilibrium'></span>

<h3>Description</h3>

<p>Compute equilibrium values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_equilibrium(ecoparams, scale_solver, noB_i, type_i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_equilibrium_+3A_ecoparams">ecoparams</code></td>
<td>
<p>list of parameters</p>
</td></tr>
<tr><td><code id="add_equilibrium_+3A_scale_solver">scale_solver</code></td>
<td>
<p>Whether to solve for ecotrophic efficiency EE given biomass B
(<code>scale_solver="simple"</code>) or solve for a combination of EE and B values</p>
</td></tr>
<tr><td><code id="add_equilibrium_+3A_nob_i">noB_i</code></td>
<td>
<p>Boolean vector indicating which taxa have no B value</p>
</td></tr>
<tr><td><code id="add_equilibrium_+3A_type_i">type_i</code></td>
<td>
<p>character vector indicating whether a taxon is &quot;hetero&quot;, &quot;auto&quot;, or
&quot;detritus&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Replaces NA values in ecotrophic efficiency and/or biomass with equilibrium
solution, and then calculates equilibrium consumption, natural mortality,
and other rates.
</p>


<h3>Value</h3>

<p>the list of parameters with missing values in <code>ecoparams$B_i</code> and/or
<code>ecoparams$EE_i</code> filled in, as well as additional values <code>Qe_ij</code>,
<code>m0_i</code>, and <code>GE_i</code>
</p>

<hr>
<h2 id='compute_nll'>Compute negative log-likelihood for EcoState model</h2><span id='topic+compute_nll'></span>

<h3>Description</h3>

<p>Compute negative log-likelihood for EcoState model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_nll(
  p,
  taxa,
  years,
  noB_i,
  type_i,
  n_species,
  project_vars,
  DC_ij,
  Bobs_ti,
  Cobs_ti,
  Nobs_ta_g2,
  Wobs_ta_g2,
  log_prior,
  fit_eps,
  fit_nu,
  stanza_data,
  settings,
  control
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_nll_+3A_p">p</code></td>
<td>
<p>list of parameters</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_taxa">taxa</code></td>
<td>
<p>Character vector of taxa included in model.</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_years">years</code></td>
<td>
<p>Integer-vector of years included in model</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_nob_i">noB_i</code></td>
<td>
<p>Boolean vector indicating which taxa have no B value</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_type_i">type_i</code></td>
<td>
<p>character vector indicating whether a taxon is &quot;hetero&quot;, &quot;auto&quot;, or
&quot;detritus&quot;</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_n_species">n_species</code></td>
<td>
<p>number of species</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_project_vars">project_vars</code></td>
<td>
<p>function to integrate differential equation</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_dc_ij">DC_ij</code></td>
<td>
<p>Diet projections matrix</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_bobs_ti">Bobs_ti</code></td>
<td>
<p>formatted matrix of biomass data</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_cobs_ti">Cobs_ti</code></td>
<td>
<p>formatted matrix of catch data</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_nobs_ta_g2">Nobs_ta_g2</code></td>
<td>
<p>formatted list of age-comp data</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_wobs_ta_g2">Wobs_ta_g2</code></td>
<td>
<p>formatted list of weight-at-age data</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_log_prior">log_prior</code></td>
<td>
<p>A user-provided function that takes as input the list of
parameters <code>out$obj$env$parList()</code> where <code>out</code> is the output from
<code>ecostate()</code>, and returns a numeric vector
where the sum is the log-prior probability.  For example
<code>log_prior = function(p) dnorm( p$logq_i[1], mean=0, sd=0.1, log=TRUE)</code>
specifies a lognormal prior probability for the catchability coefficient
for the first <code>taxa</code> with logmean of zero and logsd of 0.1</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_fit_eps">fit_eps</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which the
model should estimate annual process errors in dB/dt</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_fit_nu">fit_nu</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which the
model should estimate annual process errors in consumption <code>Q_ij</code></p>
</td></tr>
<tr><td><code id="compute_nll_+3A_stanza_data">stanza_data</code></td>
<td>
<p>output from <code>make_stanza_data</code></p>
</td></tr>
<tr><td><code id="compute_nll_+3A_settings">settings</code></td>
<td>
<p>Output from <code><a href="#topic+stanza_settings">stanza_settings()</a></code>, used to define age-structured
dynamics (called stanza-groups).</p>
</td></tr>
<tr><td><code id="compute_nll_+3A_control">control</code></td>
<td>
<p>output from <a href="#topic+ecostate_control">ecostate_control</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list of parameters, calculates the joint negative log-likelihood,
where the Laplace approximation is then used to marginalize across random
effects to calculate the log-marginal likelihood of fixed effects. The joint
likelihood includes the fit to fishery catches, biomass indices,
age-composition data, weight-at-age data, priors, and the distribution for
random effects.
</p>


<h3>Value</h3>

<p>The joint negative log-likelihood including contribution of priors
and fit to data.
</p>

<hr>
<h2 id='compute_tracer'>Calculate tracers, e.g., trophic level</h2><span id='topic+compute_tracer'></span>

<h3>Description</h3>

<p>Calculate how a tracer propagates through consumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_tracer(
  Q_ij,
  inverse_method = c("Penrose_moore", "Standard"),
  type_i,
  tracer_i = rep(1, nrow(Q_ij))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_tracer_+3A_q_ij">Q_ij</code></td>
<td>
<p>Consumption of each prey i by predator j in units biomass.</p>
</td></tr>
<tr><td><code id="compute_tracer_+3A_inverse_method">inverse_method</code></td>
<td>
<p>whether to use pseudoinverse or standard inverse</p>
</td></tr>
<tr><td><code id="compute_tracer_+3A_type_i">type_i</code></td>
<td>
<p>character vector indicating whether a taxon is &quot;hetero&quot;, &quot;auto&quot;, or
&quot;detritus&quot;</p>
</td></tr>
<tr><td><code id="compute_tracer_+3A_tracer_i">tracer_i</code></td>
<td>
<p>an indicator matrix specifying the traver value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trophic level <code class="reqn">y_i</code> for each predator <code class="reqn">i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{y = l Q^* + 1} </code>
</p>

<p>where <code class="reqn">\mathbf{Q*}</code> is the proportion consumption for each predator (column)
of different prey (rows).  We identify primary producers as any taxa with no
consumption (a column of 0s), and assign them as the first trophic level.
</p>
<p>More generically, a tracer might be used to track movement of biomass through
consumption.  For example, if we have a tracer <code class="reqn">x_i</code> that is 1 for the
base of the pelagic food chain, and 0 otherwise, then we can calculate
the proportion of pelagic vs. nonpelagic biomass for each taxon:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{y = l Q^* + x} </code>
</p>

<p>This then allows us to separate alternative components of the foodweb.
</p>


<h3>Value</h3>

<p>The vector </p>
<p style="text-align: center;"><code class="reqn">\mathbf{y_i}</code>
</p>
<p> resulting from tracer </p>
<p style="text-align: center;"><code class="reqn">\mathbf{x_i}</code>
</p>


<hr>
<h2 id='dBdt'>Dynamics from EcoSim</h2><span id='topic+dBdt'></span>

<h3>Description</h3>

<p>Compute system of differential equations representing EcoState dynamics
derived from EcoSim.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dBdt(
  Time,
  State,
  Pars,
  type_i,
  n_species,
  F_type = "integrated",
  what = "dBdt"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dBdt_+3A_time">Time</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="dBdt_+3A_state">State</code></td>
<td>
<p>vector of state variables to integrate</p>
</td></tr>
<tr><td><code id="dBdt_+3A_pars">Pars</code></td>
<td>
<p>list of parameters governing the ODE</p>
</td></tr>
<tr><td><code id="dBdt_+3A_type_i">type_i</code></td>
<td>
<p>type for each taxon</p>
</td></tr>
<tr><td><code id="dBdt_+3A_n_species">n_species</code></td>
<td>
<p>number of species</p>
</td></tr>
<tr><td><code id="dBdt_+3A_f_type">F_type</code></td>
<td>
<p>whether to integrate catches along with biomass (<code>"integrated"</code>)
or calculate catches from the Baranov catch equation applied to average
biomass (<code>"averaged"</code>)</p>
</td></tr>
<tr><td><code id="dBdt_+3A_what">what</code></td>
<td>
<p>what output to produce</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has syntax designed to match <code>pracma</code> solvers.
</p>


<h3>Value</h3>

<p>An object (list) of ranges. Elements include:
</p>

<dl>
<dt>G_i</dt><dd><p>Biomass growth per time</p>
</dd>
<dt>g_i</dt><dd><p>Biomass growth per time per biomass</p>
</dd>
<dt>M2_i</dt><dd><p>Consumptive mortality per time</p>
</dd>
<dt>m2_i</dt><dd><p>Consumptive mortality per time per biomass</p>
</dd>
<dt>M_i</dt><dd><p>Natural mortality per time</p>
</dd>
<dt>m_i</dt><dd><p>Natural mortality per time per biomass (i.e., m2_i + m0_i)</p>
</dd>
<dt>Q_ij</dt><dd><p>Consumption per time for prey (rows) by predator (columns)</p>
</dd>
</dl>


<hr>
<h2 id='ddirmult'>Dirichlet-multinomial</h2><span id='topic+ddirmult'></span>

<h3>Description</h3>

<p>Allows data-weighting as parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirmult(x, prob, ln_theta, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ddirmult_+3A_x">x</code></td>
<td>
<p>numeric vector of observations across categories</p>
</td></tr>
<tr><td><code id="ddirmult_+3A_prob">prob</code></td>
<td>
<p>numeric vector of category probabilities</p>
</td></tr>
<tr><td><code id="ddirmult_+3A_ln_theta">ln_theta</code></td>
<td>
<p>logit-ratio of effective and input sample size</p>
</td></tr>
<tr><td><code id="ddirmult_+3A_log">log</code></td>
<td>
<p>whether to return the log-probability or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood resulting from the Dirichlet-multinomial distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RTMB)
prob = rep(0.1,10)
x = rmultinom( n=1, prob=prob, size=20 )[,1]
f = function( ln_theta ) ddirmult(x, prob, ln_theta)
f( 0 )
F = MakeTape(f, 0)
F$jacfun()(0)

</code></pre>

<hr>
<h2 id='eastern_bering_sea'>eastern Bering Sea ecosystem data</h2><span id='topic+eastern_bering_sea'></span>

<h3>Description</h3>

<p>Data used to demonstrate a Model of Intermediate Complexity (MICE)
for the eastern Bering Sea.
<code>data(eastern_bering_sea)</code> loads a list that includes four components:
</p>

<ul>
<li> <p><code>Survey</code> is a long-form data-frame with three columns, providing the Year,
Mass (in relative units for most taxa, and million metric tons for Pollock,
Cod, Arrowtooth, and NFS), and Taxon for each year with available data
</p>
</li>
<li> <p><code>Catch</code> is a long-form data-frame with three columns, providing the Year,
Mass (in million metric tons), and Taxon for each year with available data
</p>
</li>
<li> <p><code>P_over_B</code> is a numeric vector with the unitless ratio of biomass production to
population biomass for each taxon
</p>
</li>
<li> <p><code>Q_over_B</code> is a numeric vector with the unitless ratio of biomass consumption to
population biomass for each taxon
</p>
</li>
<li> <p><code>Diet_proportions</code> is a numeric matrix where each column lists the
proportion of biomass consumed that is provided by each prey (row)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(eastern_bering_sea)
</code></pre>


<h3>Details</h3>

<p>The data compiled come from a variety of sources:
</p>

<ul>
<li><p> Northern fur seal (NFS) survey is an absolute index, corrected for proportion
of time spent in the eastern Bering Sea.  NFS QB is developed from a bioenergetic
model and also corrected for seasonal residency. Both are provided by
Elizabeth McHuron. It is post-processed in a variety of ways, and not
to be treated as an index of abundance for NFS for other uses.
</p>
</li>
<li><p> Pollock, cod, and arrowtooth surveys are from a bottom trawl survey, and
cod and arrowtooth are treated as an absolute index.
</p>
</li>
<li><p> Copepod and other zooplankton are from an oblique tow bongo net survey,
with data provided by Dave Kimmel.  It is then post-processed to account
for spatially and seaonally imbalanced data.
</p>
</li>
<li><p> Other P_over_B, Q_over_B and Diet_proportions values
are derived from Rpath models, provided by Andy Whitehouse.
</p>
</li>
<li><p> Primary producers is an annual index of relative biomass, developed from monthly
satellite measurements and provided by Jens Nielsen.
See Thorson et al. (In review) for more details regarding data standardization
and sources
</p>
</li></ul>


<hr>
<h2 id='ecostate'>fit EcoState model</h2><span id='topic+ecostate'></span>

<h3>Description</h3>

<p>Estimate parameters for an EcoState model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecostate(
  taxa,
  years,
  catch = data.frame(Year = numeric(0), Mass = numeric(0), Taxon = numeric(0)),
  biomass = data.frame(Year = numeric(0), Mass = numeric(0), Taxon = numeric(0)),
  agecomp = list(),
  weight = list(),
  PB,
  QB,
  B,
  DC,
  EE,
  X,
  type,
  U,
  fit_B = vector(),
  fit_Q = vector(),
  fit_B0 = vector(),
  fit_EE = vector(),
  fit_PB = vector(),
  fit_QB = vector(),
  fit_eps = vector(),
  fit_nu = vector(),
  log_prior = function(p) 0,
  settings = stanza_settings(taxa = taxa),
  control = ecostate_control()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ecostate_+3A_taxa">taxa</code></td>
<td>
<p>Character vector of taxa included in model.</p>
</td></tr>
<tr><td><code id="ecostate_+3A_years">years</code></td>
<td>
<p>Integer-vector of years included in model</p>
</td></tr>
<tr><td><code id="ecostate_+3A_catch">catch</code></td>
<td>
<p>long-form data frame with columns <code>Mass</code>, <code>Year</code>
and  <code>Taxon</code></p>
</td></tr>
<tr><td><code id="ecostate_+3A_biomass">biomass</code></td>
<td>
<p>long-form data frame with columns <code>Mass</code>, <code>Year</code>
and  <code>Taxon</code>, where <code>Mass</code> is assumed to have the same units
as <code>catch</code></p>
</td></tr>
<tr><td><code id="ecostate_+3A_agecomp">agecomp</code></td>
<td>
<p>a named list, with names corresponding to <code>stanza_groups</code>,
where each list-element is a matrix with rownames for <code>years</code>
and colnames for integer ages, where NA excludes the entry from inclusion
and the model computes the likelihood across included ages in a given year,
and the rowsum is the input-sample size for a given year</p>
</td></tr>
<tr><td><code id="ecostate_+3A_weight">weight</code></td>
<td>
<p>a named list, with names corresponding to <code>stanza_groups</code>,
where each list-element is a matrix with rownames for <code>years</code>
and colnames for integer ages, where NA excludes the entry from inclusion
and the model computes the lognormal likelihood for weight-at-age
in each specified age-year combination</p>
</td></tr>
<tr><td><code id="ecostate_+3A_pb">PB</code></td>
<td>
<p>numeric-vector with names matching <code>taxa</code>, providing the
ratio of production to biomass for each taxon</p>
</td></tr>
<tr><td><code id="ecostate_+3A_qb">QB</code></td>
<td>
<p>numeric-vector with names matching <code>taxa</code>, providing the
ratio of consumption to biomass for each taxon</p>
</td></tr>
<tr><td><code id="ecostate_+3A_b">B</code></td>
<td>
<p>numeric-vector with names matching <code>taxa</code>, providing the
starting (or fixed) value for equilibrium biomass for each taxon</p>
</td></tr>
<tr><td><code id="ecostate_+3A_dc">DC</code></td>
<td>
<p>numeric-matrix with rownames and colnames matching <code>taxa</code>,
where each column provides the diet proportion for a given predator</p>
</td></tr>
<tr><td><code id="ecostate_+3A_ee">EE</code></td>
<td>
<p>numeric-vector with names matching <code>taxa</code>, providing the
proportion of proportion of production that is subsequently
modeled (termed ecotrophic efficiency)</p>
</td></tr>
<tr><td><code id="ecostate_+3A_x">X</code></td>
<td>
<p>numeric-matrix with rownames and colnames matching <code>taxa</code>,
where each element gives the vulnerability parameter for a given
interaction.</p>
</td></tr>
<tr><td><code id="ecostate_+3A_type">type</code></td>
<td>
<p>character-vector with names matching <code>taxa</code> and
elements <code>c("auto","hetero","detritus")</code>,
indicating whether each taxon is a primary producer, consumer/predator, or
detritus, respectively.</p>
</td></tr>
<tr><td><code id="ecostate_+3A_u">U</code></td>
<td>
<p>numeric-vector with names matching <code>taxa</code>, providing the
proportion of consumption that is unassimilated and therefore
exported to detritus</p>
</td></tr>
<tr><td><code id="ecostate_+3A_fit_b">fit_B</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which equilibrium
biomass is estimated as a fixed effect</p>
</td></tr>
<tr><td><code id="ecostate_+3A_fit_q">fit_Q</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which the catchability
coefficient is estimated as a fixed effect</p>
</td></tr>
<tr><td><code id="ecostate_+3A_fit_b0">fit_B0</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which the ratio of initial
to equilibrium biomass is estimated as a fixed effect</p>
</td></tr>
<tr><td><code id="ecostate_+3A_fit_ee">fit_EE</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which ecotrophic
efficiency is estimated.</p>
</td></tr>
<tr><td><code id="ecostate_+3A_fit_pb">fit_PB</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which equilibrium
production per biomass is estimated.  Note that it is likely
a good idea to include a prior for any species for which this is estimated.</p>
</td></tr>
<tr><td><code id="ecostate_+3A_fit_qb">fit_QB</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which equilibrium
consumption per biomass is estimated.  Note that it is likely
a good idea to include a prior for any species for which this is estimated.</p>
</td></tr>
<tr><td><code id="ecostate_+3A_fit_eps">fit_eps</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which the
model should estimate annual process errors in dB/dt</p>
</td></tr>
<tr><td><code id="ecostate_+3A_fit_nu">fit_nu</code></td>
<td>
<p>Character-vector listing <code>taxa</code> for which the
model should estimate annual process errors in consumption <code>Q_ij</code></p>
</td></tr>
<tr><td><code id="ecostate_+3A_log_prior">log_prior</code></td>
<td>
<p>A user-provided function that takes as input the list of
parameters <code>out$obj$env$parList()</code> where <code>out</code> is the output from
<code>ecostate()</code>, and returns a numeric vector
where the sum is the log-prior probability.  For example
<code>log_prior = function(p) dnorm( p$logq_i[1], mean=0, sd=0.1, log=TRUE)</code>
specifies a lognormal prior probability for the catchability coefficient
for the first <code>taxa</code> with logmean of zero and logsd of 0.1</p>
</td></tr>
<tr><td><code id="ecostate_+3A_settings">settings</code></td>
<td>
<p>Output from <code><a href="#topic+stanza_settings">stanza_settings()</a></code>, used to define age-structured
dynamics (called stanza-groups).</p>
</td></tr>
<tr><td><code id="ecostate_+3A_control">control</code></td>
<td>
<p>Output from <code><a href="#topic+ecostate_control">ecostate_control()</a></code>, used to define user
settings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All <code>taxa</code> must be included in <code>QB</code>, <code>PB</code>, <code>B</code>, and <code>DC</code>,
but additional taxa can be in <code>QB</code>, <code>PB</code>, <code>B</code>, and <code>DC</code> that
are not in <code>taxa</code>.  So <code>taxa</code> can be used to redefine the set of modeled
species without changing other inputs
</p>


<h3>Value</h3>

<p>An object (list) of S3-class <code>ecostate</code>. Elements include:
</p>

<dl>
<dt>obj</dt><dd><p>RTMB object from <code><a href="RTMB.html#topic+MakeADFun">MakeADFun</a></code></p>
</dd>
<dt>tmb_inputs</dt><dd><p>The list of inputs passed to <code><a href="RTMB.html#topic+MakeADFun">MakeADFun</a></code></p>
</dd>
<dt>opt</dt><dd><p>The output from <code><a href="stats.html#topic+nlminb">nlminb</a></code></p>
</dd>
<dt>sdrep</dt><dd><p>The output from <code><a href="RTMB.html#topic+sdreport">sdreport</a></code></p>
</dd>
<dt>interal</dt><dd><p>Objects useful for package function, i.e., all arguments
passed during the call</p>
</dd>
<dt>rep</dt><dd><p>report file, including matrix <code>B_ti</code> for biomass in each year
<code>t</code> and taxon <code>i</code>, <code>g_ti</code> for growth rate per biomass,
and see <code>dBdt</code> for other quantities reported by year</p>
</dd>
<dt>derived</dt><dd><p>derived quantity estimates and standard errors, for <code>rep</code>
objects as requested</p>
</dd>
<dt>call</dt><dd><p>function call record</p>
</dd>
<dt>run_time</dt><dd><p>Total runtime</p>
</dd>
</dl>

<p>This S3 class then has functions <code>summary</code>, <code>print</code>, and
<code>logLik</code>
</p>


<h3>References</h3>

<p><strong>Introducing the state-space mass-balance model:</strong>
</p>
<p>Thorson, J.  Kristensen, K., Aydin, K., Gaichas, S., Kimmel, D.G.,
McHuron, E.A., Nielsen, J.N., Townsend, H., Whitehouse, G.A (In press).
The benefits of hierarchical ecosystem models: demonstration
using a new state-space mass-balance model EcoState. Fish and Fisheries.
</p>

<hr>
<h2 id='ecostate_control'>Detailed control for ecostate structure</h2><span id='topic+ecostate_control'></span>

<h3>Description</h3>

<p>Define a list of control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecostate_control(
  nlminb_loops = 1,
  newton_loops = 0,
  eval.max = 1000,
  iter.max = 1000,
  getsd = TRUE,
  silent = getOption("ecostate.silent", TRUE),
  trace = getOption("ecostate.trace", 0),
  verbose = getOption("ecostate.verbose", FALSE),
  profile = c("logF_ti", "log_winf_z", "s50_z", "srate_z"),
  random = c("epsilon_ti", "alpha_ti", "nu_ti", "phi_tg2"),
  tmb_par = NULL,
  map = NULL,
  getJointPrecision = FALSE,
  integration_method = c("ABM", "RK4", "ode23", "rk4", "lsoda"),
  process_error = c("epsilon", "alpha"),
  n_steps = 10,
  F_type = c("integrated", "averaged"),
  derived_quantities = c("h_g2", "B_ti", "B0_i"),
  scale_solver = c("joint", "simple"),
  inverse_method = c("Standard", "Penrose_moore"),
  tmbad.sparse_hessian_compress = 1,
  start_tau = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ecostate_control_+3A_nlminb_loops">nlminb_loops</code></td>
<td>
<p>Integer number of times to call <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_newton_loops">newton_loops</code></td>
<td>
<p>Integer number of Newton steps to do after running
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_eval.max">eval.max</code></td>
<td>
<p>Maximum number of evaluations of the objective function
allowed. Passed to <code>control</code> in <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed. Passed to <code>control</code> in
<code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_getsd">getsd</code></td>
<td>
<p>Boolean indicating whether to call <code><a href="TMB.html#topic+sdreport">TMB::sdreport()</a></code></p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_silent">silent</code></td>
<td>
<p>Disable terminal output for inner optimizer?</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_trace">trace</code></td>
<td>
<p>Parameter values are printed every <code>trace</code> iteration
for the outer optimizer. Passed to
<code>control</code> in <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>.</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_verbose">verbose</code></td>
<td>
<p>Output additional messages about model steps during fitting?</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_profile">profile</code></td>
<td>
<p>parameters that are profiled across,
passed to <code><a href="RTMB.html#topic+MakeADFun">MakeADFun</a></code></p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_random">random</code></td>
<td>
<p>parameters that are treated as random effects,
passed to <code><a href="RTMB.html#topic+MakeADFun">MakeADFun</a></code></p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_tmb_par">tmb_par</code></td>
<td>
<p>list of parameters for starting values, with shape identical
to <code>tinyVAST(...)$internal$parlist</code></p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_map">map</code></td>
<td>
<p>list of mapping values, passed to <a href="RTMB.html#topic+TMB-interface">RTMB::MakeADFun</a></p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_getjointprecision">getJointPrecision</code></td>
<td>
<p>whether to get the joint precision matrix.  Passed
to <code><a href="TMB.html#topic+sdreport">sdreport</a></code>.</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_integration_method">integration_method</code></td>
<td>
<p>What numerical integration method to use. <code>"ABM"</code>
uses a native-R versions of Adam-Bashford, <code>"RK4"</code> uses a native-R
version of Runge-Kutta-4, and <code>"ode23"</code> uses a native-R
version of adaptive Runge-Kutta-23,
where all are adapted from <code>pracma</code> functions.
<code>"rk4"</code> and <code>lsoda</code> use those methods
from <code>deSolve::ode</code> as implemented by <code>RTMBode::ode</code></p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_process_error">process_error</code></td>
<td>
<p>Whether to include process error as a continuous rate
(i.e., an &quot;innovation&quot; parameterization, <code>process_error="epsilon"</code>)
or as a discrete difference between expected
and predicted biomass (i.e., a &quot;state-space&quot; parameterization),
<code>process_error="alpha"</code>The
former is more interpretable, whereas the latter is much more computationally
efficient.</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_n_steps">n_steps</code></td>
<td>
<p>number of steps used in the ODE solver for biomass dynamics</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_f_type">F_type</code></td>
<td>
<p>whether to integrate catches along with biomass (<code>"integrated"</code>)
or calculate catches from the Baranov catch equation applied to average
biomass (<code>"averaged"</code>)</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_derived_quantities">derived_quantities</code></td>
<td>
<p>character-vector listing objects to ADREPORT</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_scale_solver">scale_solver</code></td>
<td>
<p>Whether to solve for ecotrophic efficiency EE given biomass B
(<code>scale_solver="simple"</code>) or solve for a combination of EE and B values</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_inverse_method">inverse_method</code></td>
<td>
<p>whether to use pseudoinverse or standard inverse</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_tmbad.sparse_hessian_compress">tmbad.sparse_hessian_compress</code></td>
<td>
<p>passed to <code><a href="TMB.html#topic+config">TMB::config()</a></code>, and enabling
an experimental feature to save memory when first computing the inner
Hessian matrix.  Using <code>tmbad.sparse_hessian_compress=1</code> seems
to have no effect on the MLE (although users should probably confirm this),
and hugely reduces memory use in both small
and large models. Using <code>tmbad.sparse_hessian_compress=1</code> seems
to hugely speed up the model-fitting with a large model but results in a small
decrease in speed for model-fitting with a small model.</p>
</td></tr>
<tr><td><code id="ecostate_control_+3A_start_tau">start_tau</code></td>
<td>
<p>Starting value for the standard deviation of process errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class &quot;ecostate_control&quot; that specifies detailed model settings,
allowing user specification while also specifying default values
</p>

<hr>
<h2 id='ginv'>Penrose-Moore pseudoinverse</h2><span id='topic+ginv'></span>

<h3>Description</h3>

<p>Extend <code>MASS:ginv</code> to work with RTMB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ginv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ginv_+3A_x">x</code></td>
<td>
<p>Matrix used to compute pseudoinverse</p>
</td></tr>
</table>

<hr>
<h2 id='logLik.ecostate'>Marginal log-likelihood</h2><span id='topic+logLik.ecostate'></span>

<h3>Description</h3>

<p>Extract the (marginal) log-likelihood of a ecostate model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ecostate'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.ecostate_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+ecostate">ecostate</a></code></p>
</td></tr>
<tr><td><code id="logLik.ecostate_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>logLik</code> with attributes
</p>
<table role = "presentation">
<tr><td><code>val</code></td>
<td>
<p>log-likelihood</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>number of parameters</p>
</td></tr>
</table>
<p>Returns an object of class logLik. This has attributes
&quot;df&quot; (degrees of freedom) giving the number of (estimated) fixed effects
in the model, abd &quot;val&quot; (value) giving the marginal log-likelihood.
This class then allows <code>AIC</code> to work as expected.
</p>

<hr>
<h2 id='ode23'>Non-stiff (and stiff) ODE solvers</h2><span id='topic+ode23'></span>

<h3>Description</h3>

<p>Runge-Kutta (2, 3)-method with variable step size, resp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ode23(f, a, b, y0, n, Pars, rtol = 0.001, atol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ode23_+3A_f">f</code></td>
<td>
<p>function in the differential equation <code class="reqn">y' = f(x, y)</code>;
defined as a function <code class="reqn">R \times R^m \rightarrow R^m</code>, where <code class="reqn">m</code> is the number of equations.</p>
</td></tr>
<tr><td><code id="ode23_+3A_a">a</code></td>
<td>
<p>starting time for the interval to integrate</p>
</td></tr>
<tr><td><code id="ode23_+3A_b">b</code></td>
<td>
<p>ending time for the interval to integrate.</p>
</td></tr>
<tr><td><code id="ode23_+3A_y0">y0</code></td>
<td>
<p>starting values at time <code>a</code></p>
</td></tr>
<tr><td><code id="ode23_+3A_n">n</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="ode23_+3A_pars">Pars</code></td>
<td>
<p>named list of parameters passed to f</p>
</td></tr>
<tr><td><code id="ode23_+3A_rtol">rtol</code></td>
<td>
<p>relative tolerance.</p>
</td></tr>
<tr><td><code id="ode23_+3A_atol">atol</code></td>
<td>
<p>absolute tolerance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Copied from pracma under GPL-3, with small modifications to work with RTMB.
This can be used to simulate dynamics, but not during estimation
</p>


<h3>Value</h3>

<p>List with components t for time points between a and b and y an
n-by-m matrix with solutions for variables in columns, i.e.
each row contains one time stamp.
</p>

<hr>
<h2 id='plot_foodweb'>Plot foodweb</h2><span id='topic+plot_foodweb'></span>

<h3>Description</h3>

<p>Plot consumption as a directed graph including all taxa (vertices)
and biomass consumed (arrows).  Taxa are located using tracers,
where by default the y-axis is trophic level.  #'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_foodweb(
  Q_ij,
  type_i,
  xtracer_i,
  ytracer_i = rep(1, nrow(Q_ij)),
  B_i = rep(1, nrow(Q_ij)),
  taxa_labels = letters[1:nrow(Q_ij)],
  xloc,
  yloc
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_foodweb_+3A_q_ij">Q_ij</code></td>
<td>
<p>Consumption of each prey i by predator j in units biomass.</p>
</td></tr>
<tr><td><code id="plot_foodweb_+3A_type_i">type_i</code></td>
<td>
<p>character vector indicating whether a taxon is &quot;hetero&quot;, &quot;auto&quot;, or
&quot;detritus&quot;</p>
</td></tr>
<tr><td><code id="plot_foodweb_+3A_xtracer_i">xtracer_i</code></td>
<td>
<p>tracer to use when computing x-axis values</p>
</td></tr>
<tr><td><code id="plot_foodweb_+3A_ytracer_i">ytracer_i</code></td>
<td>
<p>tracer to use when computing y-axis values</p>
</td></tr>
<tr><td><code id="plot_foodweb_+3A_b_i">B_i</code></td>
<td>
<p>biomass to use when weighting taxa in plot</p>
</td></tr>
<tr><td><code id="plot_foodweb_+3A_taxa_labels">taxa_labels</code></td>
<td>
<p>character vector of labels to use for each taxon</p>
</td></tr>
<tr><td><code id="plot_foodweb_+3A_xloc">xloc</code></td>
<td>
<p>x-axis location (overrides calculation using <code>xtracer_i</code>)</p>
</td></tr>
<tr><td><code id="plot_foodweb_+3A_yloc">yloc</code></td>
<td>
<p>y-axis location (overrides calculation using <code>ytracer_i</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trophic level <code class="reqn">l_i</code> for each predator <code class="reqn">i</code> is defined as:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{l - 1 = l Q^*} </code>
</p>

<p>where <code class="reqn">\mathbf{Q*}</code> is the proportion consumption for each predator (column)
of different prey (rows).  We identify primary producers as any taxa with no
consumption (a column of 0s), and assign them as the first trophic level.
</p>


<h3>Value</h3>

<p>invisibly return <code>ggplot</code> object for foodweb
</p>

<hr>
<h2 id='print_ecopars'>Print EcoSim parameters</h2><span id='topic+print_ecopars'></span>

<h3>Description</h3>

<p>Prints parameters defining EcoSim dynamics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_ecopars(x, silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_ecopars_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+ecostate">ecostate</a></code></p>
</td></tr>
<tr><td><code id="print_ecopars_+3A_silent">silent</code></td>
<td>
<p>whether to print to terminal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns table printed
</p>

<hr>
<h2 id='print.ecostate'>Print fitted ecostate object</h2><span id='topic+print.ecostate'></span>

<h3>Description</h3>

<p>Prints output from fitted ecostate model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ecostate'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.ecostate_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+ecostate">ecostate</a></code></p>
</td></tr>
<tr><td><code id="print.ecostate_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to provide clean terminal output when calling fitted
object in terminal.
</p>

<hr>
<h2 id='rk4sys'>Classical Runge-Kutta for system of equations</h2><span id='topic+rk4sys'></span>

<h3>Description</h3>

<p>Classical Runge-Kutta of order 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rk4sys(f, a, b, y0, n, Pars, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rk4sys_+3A_f">f</code></td>
<td>
<p>function in the differential equation <code class="reqn">y' = f(x, y)</code>;
defined as a function <code class="reqn">R \times R^m \rightarrow R^m</code>, where <code class="reqn">m</code> is the number of equations.</p>
</td></tr>
<tr><td><code id="rk4sys_+3A_a">a</code></td>
<td>
<p>starting time for the interval to integrate</p>
</td></tr>
<tr><td><code id="rk4sys_+3A_b">b</code></td>
<td>
<p>ending time for the interval to integrate.</p>
</td></tr>
<tr><td><code id="rk4sys_+3A_y0">y0</code></td>
<td>
<p>starting values at time <code>a</code></p>
</td></tr>
<tr><td><code id="rk4sys_+3A_n">n</code></td>
<td>
<p>the number of steps from a to b.</p>
</td></tr>
<tr><td><code id="rk4sys_+3A_pars">Pars</code></td>
<td>
<p>named list of parameters passed to f</p>
</td></tr>
<tr><td><code id="rk4sys_+3A_...">...</code></td>
<td>
<p>additional inputs to function <code>f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Classical Runge-Kutta of order 4 for (systems of) ordinary differential
equations with fixed step size.
Copied from pracma under GPL-3, with small modifications to work with RTMB
</p>


<h3>Value</h3>

<p>List with components x for grid points between a and b and y an
n-by-m matrix with solutions for variables in columns, i.e.
each row contains one time stamp.
</p>

<hr>
<h2 id='stanza_settings'>Detailed control for stanza structure</h2><span id='topic+stanza_settings'></span>

<h3>Description</h3>

<p>Define a list of control parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanza_settings(
  taxa,
  stanza_groups,
  K,
  d,
  Wmat,
  Amax,
  SpawnX,
  Leading,
  fit_K = c(),
  fit_d = c(),
  fit_phi = vector(),
  Amat = NULL,
  Wmatslope,
  STEPS_PER_YEAR = 1,
  comp_weight = c("multinom", "dir", "dirmult")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stanza_settings_+3A_taxa">taxa</code></td>
<td>
<p>Character vector of taxa included in model.</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_stanza_groups">stanza_groups</code></td>
<td>
<p>character-vector with names corresponding to <code>taxa</code>
and elements specifying the multi-stanza group (i.e., age-structured
population) for a given taxa</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_k">K</code></td>
<td>
<p>numeric-vector with names matching <code>unique(stanza_groups)</code>, providing the
von Bertalanffy growth coefficient for length</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_d">d</code></td>
<td>
<p>numeric-vector with names matching <code>unique(stanza_groups)</code>, providing the
von Bertalanffy allometric consumption-at-weight (default is 2/3)</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_wmat">Wmat</code></td>
<td>
<p>numeric-vector with names matching <code>unique(stanza_groups)</code>, providing the
weight-at-maturity relative to asymptotic weight</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_amax">Amax</code></td>
<td>
<p>numeric-vector with names matching <code>names(stanza_groups)</code>,
providing the maximum age  (in units years) for a given taxon
(and the oldest taxon for a given stanza_group is treated as a plus-group)</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_spawnx">SpawnX</code></td>
<td>
<p>numeric-vector with names matching <code>unique(stanza_groups)</code>, providing the
larval vulnerability (density dependence) parameter</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_leading">Leading</code></td>
<td>
<p>Boolean vector with names matching <code>names(stanza_groups)</code>,
with <code>TRUE</code> for the taxon for which scale (B or EE) is specified
or estimated, where this is then calculated determinstically
for other taxa for a given stanza_group</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_fit_k">fit_K</code></td>
<td>
<p>Character-vector listing <code>stanza_groups</code> for which
K is estimated</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_fit_d">fit_d</code></td>
<td>
<p>Character-vector listing <code>stanza_groups</code> for which
d is estimated (note that this currently does not work)</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_fit_phi">fit_phi</code></td>
<td>
<p>Character-vector listing <code>stanza_groups</code> for which the
model should estimate annual recruitment deviations, representing
nonconsumptive variation in larval survival (e.g., oceanographic advection)</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_amat">Amat</code></td>
<td>
<p>numeric-vector with names matching <code>unique(stanza_groups)</code>,
providing the integer age-at-maturity (in units years)</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_wmatslope">Wmatslope</code></td>
<td>
<p>numeric-vector with names matching <code>unique(stanza_groups)</code>,
providing the slope at 0.5 maturity for a logistic maturity-at-weight
ogive</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_steps_per_year">STEPS_PER_YEAR</code></td>
<td>
<p>integer number of Euler steps per year for calculating
integrating individual weight-at-age</p>
</td></tr>
<tr><td><code id="stanza_settings_+3A_comp_weight">comp_weight</code></td>
<td>
<p>method used for weighting age-composition data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class &quot;stanza_settings&quot; that specifies detailed model settings
related to age-structured dynamics (e.g., stanzas),
allowing user specification while also specifying default values
</p>

<hr>
<h2 id='whitehouse_2021'>Full rpath inputs for eastern Bering Sea</h2><span id='topic+whitehouse_2021'></span>

<h3>Description</h3>

<p>All Rpath inputs from Whitehouse et al. 2021
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(whitehouse_2021)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
