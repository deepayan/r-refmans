<!DOCTYPE html><html><head><title>Help for package FIESTAutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FIESTAutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.update_refs'><p>Updates reference tables</p></a></li>
<li><a href='#check.numeric'><p>Check Functions</p></a></li>
<li><a href='#datExportData'><p>Spatial - Exports a data frame object.</p></a></li>
<li><a href='#DBtestPostgreSQL'><p>Database - Test a PostgreSQL database.</p></a></li>
<li><a href='#DBtestSQLite'><p>Database - Checks access to a SQLite database.</p></a></li>
<li><a href='#DBvars.default'><p>General Utility Functions</p></a></li>
<li><a href='#eval_options'><p>List of population tables.</p></a></li>
<li><a href='#GBest.pbar'><p>Estimation Functions</p></a></li>
<li><a href='#GDT_NAMES'><p>Reference tables - gdal data types.</p></a></li>
<li><a href='#getDefaultNodata'><p>Raster Functions</p></a></li>
<li><a href='#kindcd3old'><p>Reference table - List of RMRS plots that have fallen out of inventory</p>
because they were not found or they were in the wrong place.</a></li>
<li><a href='#multest_options'><p>Multest output options.</p></a></li>
<li><a href='#pcheck.logical'><p>Parameter Check Functions</p></a></li>
<li><a href='#Rcpp_CmbTable-class'><p>Class <code>"Rcpp_CmbTable"</code></p></a></li>
<li><a href='#Rcpp_RunningStats-class'><p>Class <code>"Rcpp_RunningStats"</code></p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#ref_codes'><p>Reference tables - Code definitions.</p></a></li>
<li><a href='#ref_codes_archive'><p>Reference tables - Code definitions (Archive).</p></a></li>
<li><a href='#ref_cond'><p>Reference table - Metadata for cond default variables output from</p>
DBgetPlots()</a></li>
<li><a href='#ref_conversion'><p>Reference table - for conversion factors.</p></a></li>
<li><a href='#ref_diacl2in'><p>Reference table - diameter 2-inch class codes (DIA).</p></a></li>
<li><a href='#ref_domain'><p>Reference table - for generating tables.</p></a></li>
<li><a href='#ref_estvar'><p>Reference table - for generating estimates</p></a></li>
<li><a href='#ref_evaltyp'><p>Reference table - for generating tables.</p></a></li>
<li><a href='#ref_plt'><p>Reference table - Metadata for plt default variables output from</p>
DBgetPlots()</a></li>
<li><a href='#ref_popType'><p>Reference table - popType codes.</p></a></li>
<li><a href='#ref_shp'><p>Reference table - Metadata for shp_* default variables output from</p>
DBgetPlots()</a></li>
<li><a href='#ref_species'><p>Reference table - Code definitions.</p></a></li>
<li><a href='#ref_statecd'><p>Reference table - state codes (STATECD).</p></a></li>
<li><a href='#ref_titles'><p>Reference table - Variable titles.</p></a></li>
<li><a href='#ref_tree'><p>Reference table - Metadata for tree default variables output from</p>
DBgetPlots()</a></li>
<li><a href='#ref_units'><p>Reference table - for variable units.</p></a></li>
<li><a href='#savedata_options'><p>Data saving options.</p></a></li>
<li><a href='#spatial_desc'><p>Spatial Data Functions</p></a></li>
<li><a href='#spMakeSpatial_options'><p>Make SpatialPoints options</p></a></li>
<li><a href='#strata_options'><p>Strata options.</p></a></li>
<li><a href='#stunitco'><p>SpatialPolygonsDataFrame with FIA state, unit, county codes and names</p></a></li>
<li><a href='#table_options'><p>Table aesthetics and output options.</p></a></li>
<li><a href='#title_options'><p>Title output options.</p></a></li>
<li><a href='#unit_options'><p>Unit options.</p></a></li>
<li><a href='#write2_desc'><p>Data Writing Functions</p></a></li>
<li><a href='#xy_options'><p>List of population tables.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utility Functions for Forest Inventory Estimation and Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-15</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for data wrangling, spatial data analysis,
    statistical modeling (including direct, model-assisted, photo-based, and
    small area tools), and USDA Forest Service data base tools. These tools are
    aimed to help Foresters, Analysts, and Scientists extract and perform
    analyses on USDA Forest Service data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, DBI, gdalraster, graphics, hbsae, JoSAE, mase,
methods, nlme, Rcpp, RColorBrewer, RPostgres, RSQLite, sae, sf,
sqldf, stats, terra, units, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>See file COPYRIGHTS for details.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/USDAForestService/FIESTAutils">https://github.com/USDAForestService/FIESTAutils</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USDAForestService/FIESTAutils/issues">https://github.com/USDAForestService/FIESTAutils/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-15 19:41:27 UTC; grayson</td>
</tr>
<tr>
<td>Author:</td>
<td>Tracey Frescino [aut],
  Chris Toney [aut],
  Grayson White [aut, cre],
  Joshua Yamamoto [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Grayson White &lt;graysonwhite13@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-16 03:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='.update_refs'>Updates reference tables</h2><span id='topic+.update_refs'></span>

<h3>Description</h3>

<p>Updates reference tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.update_refs(write = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".update_refs_+3A_write">write</code></td>
<td>
<p>Logical. Should the internal reference tables be overwritten?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Called for side effects.
</p>


<h3>Author(s)</h3>

<p>Josh Yamamoto
</p>

<hr>
<h2 id='check.numeric'>Check Functions</h2><span id='topic+check.numeric'></span><span id='topic+check.logic'></span><span id='topic+check.matchclass'></span><span id='topic+check.matchval'></span><span id='topic+checks_desc'></span><span id='topic+checkfilenm'></span><span id='topic+checknm'></span><span id='topic+check.namedlist'></span>

<h3>Description</h3>

<p>Check functions for objects of class numeric, logical statements,
class matching, value matching, file names, names, and named lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.numeric(x)

check.logic(
  x,
  statement,
  filternm = NULL,
  stopifnull = FALSE,
  stopifinvalid = TRUE,
  removeinvalid = FALSE,
  syntax = "R",
  returnvar = FALSE,
  returnpart = FALSE
)

check.matchclass(
  tab1,
  tab2,
  matchcol,
  var2 = NULL,
  tab1txt = NULL,
  tab2txt = NULL
)

check.matchval(
  tab1,
  tab2,
  var1,
  var2 = NULL,
  tab1txt = NULL,
  tab2txt = NULL,
  gui = FALSE,
  stopifmiss = FALSE,
  subsetrows = FALSE
)

checkfilenm(fn, outfolder = NULL, ext = NULL, stopifnull = FALSE)

checknm(nm, nmlst, ignore.case = TRUE)

check.namedlist(xlst, checknms = NULL, modetype = "numeric")
</code></pre>


<h3>Details</h3>

<p>These functions are used to check if a vector is numeric with check.numeric,
to check a logical statement with check.logic, to check if two objects' 
classes match, to check it two object's values match, to check file names,
to check names, and finally, to check named lists.
</p>


<h3>Value</h3>

<p>The object who was checked, with necessary changes made for the object to
pass the check (i.e. character vector to numeric vector).
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='datExportData'>Spatial - Exports a data frame object.</h2><span id='topic+datExportData'></span>

<h3>Description</h3>

<p>Exports a data frame object to a specified output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datExportData(
  dfobj,
  create_dsn = FALSE,
  index.unique = NULL,
  index = NULL,
  savedata_opts = savedata_options(),
  dbconn = NULL,
  dbconnopen = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datExportData_+3A_dfobj">dfobj</code></td>
<td>
<p>Data.frame class R object. Data frame object to export.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_create_dsn">create_dsn</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_index.unique">index.unique</code></td>
<td>
<p>String. Name of variable(s) in dfobj to make unique
index.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_index">index</code></td>
<td>
<p>String. Name of variable(s) in dfobj to make (non-unique)
index.
dbconnopen Logical. If TRUE, keep database connection open.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_savedata_opts">savedata_opts</code></td>
<td>
<p>List. See help(savedata_options()) for a list
of options.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_dbconn">dbconn</code></td>
<td>
<p>Open database connection.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_dbconnopen">dbconnopen</code></td>
<td>
<p>Logical. If TRUE, keep database connection open.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for sf::st_write function.
</p>


<h3>Value</h3>

<p>An sf spatial object is written to the out_dsn.
</p>


<h3>Note</h3>

<p>If out_fmt='shp':<br /> The ESRI shapefile driver truncates variable
names to 10 characters or less.  Variable names are changed before export
using an internal function (trunc10shp). Name changes are output to the
outfolder, 'outshpnm'_newnames.csv.
</p>
<p>If sf object has more than 1 record, it cannot be exported to a shapefile.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='DBtestPostgreSQL'>Database - Test a PostgreSQL database.</h2><span id='topic+DBtestPostgreSQL'></span>

<h3>Description</h3>

<p>Checks a PostgreSQL database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBtestPostgreSQL(
  dbname = NULL,
  host = NULL,
  port = NULL,
  user = NULL,
  password = NULL,
  dbconnopen = FALSE,
  showlist = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBtestPostgreSQL_+3A_dbname">dbname</code></td>
<td>
<p>String. Name of the database on the host.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_host">host</code></td>
<td>
<p>String. Host name.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_port">port</code></td>
<td>
<p>String. Port number.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_user">user</code></td>
<td>
<p>String. User name.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_password">password</code></td>
<td>
<p>String. Password.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_dbconnopen">dbconnopen</code></td>
<td>
<p>Logical. If TRUE, the database connection is returned and not closed.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_showlist">showlist</code></td>
<td>
<p>Logical. If TRUE, prints list of tables in database.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_...">...</code></td>
<td>
<p>Additional authentication arguments passed to DBI::dbConnect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object that inherits from DBIConnection via the DBI package if
dbconnopen = TRUE, or NULL otherwise. 
For more information, see 'help(DBI::dbConnect)'.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='DBtestSQLite'>Database - Checks access to a SQLite database.</h2><span id='topic+DBtestSQLite'></span>

<h3>Description</h3>

<p>Checks a SQLite database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBtestSQLite(
  SQLitefn = NULL,
  gpkg = FALSE,
  dbconnopen = FALSE,
  outfolder = NULL,
  showlist = TRUE,
  returnpath = TRUE,
  createnew = TRUE,
  stopifnull = FALSE,
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBtestSQLite_+3A_sqlitefn">SQLitefn</code></td>
<td>
<p>String. Name of SQLite database (*.sqlite).</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_gpkg">gpkg</code></td>
<td>
<p>Logical. If TRUE, Sqlite geopackage database.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_dbconnopen">dbconnopen</code></td>
<td>
<p>Logical. If TRUE, the dbconn connection is not closed.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_outfolder">outfolder</code></td>
<td>
<p>String. Optional. Name of output folder. If NULL, export to
working directory.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_showlist">showlist</code></td>
<td>
<p>Logical. If TRUE, shows list of tables in database.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_returnpath">returnpath</code></td>
<td>
<p>Logical. If TRUE, returns full path to SQLite file name.
If FALSE, returns SQLitefn.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_createnew">createnew</code></td>
<td>
<p>If TRUE, creates new SQLite database.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_stopifnull">stopifnull</code></td>
<td>
<p>Logical. If TRUE, stops if SQLite database doesn't exist.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. If TRUE, overwrites data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string containing the path to the SQLite database of
interest.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='DBvars.default'>General Utility Functions</h2><span id='topic+DBvars.default'></span><span id='topic+DBgetfn'></span><span id='topic+getspconddat'></span><span id='topic+getpfromqry'></span><span id='topic+getpwithqry'></span><span id='topic+getEvalid.ppsa'></span><span id='topic+getPlotCur'></span><span id='topic+gui_filterdf'></span><span id='topic+DBgetbyids'></span><span id='topic+DBcreateSQLite'></span><span id='topic+changeclass'></span><span id='topic+customEvalchk'></span><span id='topic+checkidx'></span><span id='topic+createidx'></span><span id='topic+dbclassify'></span><span id='topic+dbclass'></span><span id='topic+getwithqry'></span><span id='topic+Ratio2Size'></span><span id='topic+addCI'></span><span id='topic+change10char'></span><span id='topic+RtoSQL'></span><span id='topic+getext'></span><span id='topic+getoutfn'></span><span id='topic+addcommas'></span><span id='topic+pastevars'></span><span id='topic+stopQ'></span><span id='topic+removecols'></span><span id='topic+DT_NAto0'></span><span id='topic+changeNULL'></span><span id='topic+getdups'></span><span id='topic+getlistparam'></span><span id='topic+getnm'></span><span id='topic+capfirst'></span><span id='topic+nbrdecimals'></span><span id='topic+nbrdigits'></span><span id='topic+getfilter'></span><span id='topic+filter2qry'></span><span id='topic+wraptitle'></span><span id='topic+xtabf'></span><span id='topic+recodelut'></span><span id='topic+findnm'></span><span id='topic+chkdbtab'></span><span id='topic+int64tochar'></span><span id='topic+messagedf'></span><span id='topic+getSPGRPCD'></span><span id='topic+addFORTYPGRPCD'></span><span id='topic+date2char'></span><span id='topic+checklevels'></span><span id='topic+strat.pivot'></span><span id='topic+makedummy'></span><span id='topic+preds.standardize'></span><span id='topic+gregEN.select'></span><span id='topic+preds.select'></span><span id='topic+fileexistsnm'></span><span id='topic+getRefcodes'></span><span id='topic+getRefobject'></span><span id='topic+getadjfactorDWM'></span><span id='topic+getadjfactorGB'></span><span id='topic+getadjfactorP2VEG'></span><span id='topic+getadjfactorPLOT'></span><span id='topic+getadjfactorVOL'></span><span id='topic+getfunnm'></span><span id='topic+getlt10char'></span><span id='topic+getrhat'></span><span id='topic+groupEstunit'></span><span id='topic+groupStrata'></span><span id='topic+groupUnits'></span><span id='topic+internal_desc'></span><span id='topic+getjoinqry'></span><span id='topic+classqry'></span><span id='topic+classifyqry'></span><span id='topic+save1tab'></span><span id='topic+save2tabs'></span><span id='topic+strat.collapse'></span><span id='topic+subpsamp'></span><span id='topic+subpsampP2VEG'></span><span id='topic+allin1f'></span><span id='topic+crosstabx'></span><span id='topic+add0unit'></span><span id='topic+addrowgrp'></span><span id='topic+crossxtab'></span><span id='topic+getdomain'></span><span id='topic+getestvar'></span><span id='topic+crossxbyunit'></span><span id='topic+ptdata2sf'></span><span id='topic+sf2ptdata'></span><span id='topic+layerIntersection'></span><span id='topic+layerUnion'></span><span id='topic+tabulateIntersections'></span><span id='topic+selectByIntersects'></span><span id='topic+layerFromRasterExtent'></span><span id='topic+wtcalc'></span><span id='topic+wtcalc.unit'></span>

<h3>Description</h3>

<p>These functions provide a wide-range of general utility for a variety of
data types. They were developed by the FIESTA development team and solve 
many general and specific problems for data analysis in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBvars.default(
  istree = FALSE,
  isseed = FALSE,
  isveg = FALSE,
  isgrm = FALSE,
  isdwm = FALSE,
  issubp = FALSE,
  regionVars = FALSE,
  plotgeom = FALSE,
  regionVarsRS = "RMRS"
)

DBgetfn(
  tab,
  invtype,
  outfn.pre,
  stabbrlst = NULL,
  evalid = NULL,
  qry = FALSE,
  othertxt = NULL,
  outfn.date = FALSE,
  addslash = FALSE,
  ext = "csv",
  outfolder = NULL,
  overwrite = FALSE
)

getspconddat(
  cond = NULL,
  ACTUALcond = NULL,
  cuniqueid = "PLT_CN",
  condid1 = FALSE,
  ACI = FALSE
)

getpfromqry(
  dsn = NULL,
  evalid = NULL,
  plotCur = TRUE,
  pjoinid,
  varCur = "MEASYEAR",
  Endyr = NULL,
  invyrs = NULL,
  allyrs = FALSE,
  SCHEMA. = NULL,
  subcycle99 = NULL,
  designcd1 = FALSE,
  intensity1 = NULL,
  popSURVEY = FALSE,
  chk = FALSE,
  Type = "VOL",
  syntax = "sql",
  plotnm = "plot",
  ppsanm = "pop_plot_stratum_assgn",
  ppsaid = "PLT_CN",
  surveynm = "survey",
  plotobj = NULL,
  dbconn = NULL,
  dbconnopen = TRUE
)

getpwithqry(
  dsn = NULL,
  evalid = NULL,
  states = NULL,
  pjoinid,
  plotCur = FALSE,
  varCur = "MEASYEAR",
  Endyr = NULL,
  invyrs = NULL,
  measyears = NULL,
  allyrs = FALSE,
  SCHEMA. = NULL,
  invtype = "ANNUAL",
  subcycle99 = FALSE,
  designcd1 = FALSE,
  intensity = NULL,
  popSURVEY = FALSE,
  chk = FALSE,
  Type = "VOL",
  syntax = "sql",
  plotnm = "plot",
  ppsanm = "pop_plot_stratum_assgn",
  ppsaid = "PLT_CN",
  surveynm = "survey",
  PLOTdf = NULL,
  pltflds = NULL,
  POP_PLOT_STRATUM_ASSGNdf = NULL,
  ppsaflds = NULL,
  pvars = NULL,
  dbconn = NULL,
  dbconnopen = TRUE,
  withqry2 = FALSE
)

getEvalid.ppsa(
  ppsa,
  states = NULL,
  evalAll = FALSE,
  evalCur = FALSE,
  evalEndyr = NULL,
  evalType = "VOL"
)

getPlotCur(
  pltx,
  Endyr = NULL,
  varCur = "MEASYEAR",
  Endyr.filter = NULL,
  designcd1 = TRUE
)

gui_filterdf(df, byname = TRUE)

DBgetbyids(dbconn, ids, layernm, layerid = "PLT_CN")

DBcreateSQLite(
  SQLitefn = NULL,
  gpkg = FALSE,
  dbconnopen = FALSE,
  outfolder = NULL,
  outfn.pre = NULL,
  outfn.date = FALSE,
  overwrite = FALSE,
  returnpath = TRUE,
  stopifnull = FALSE
)

changeclass(tab, noIDate = TRUE)

customEvalchk(
  states,
  measCur = TRUE,
  measEndyr = NULL,
  measEndyr.filter = NULL,
  allyrs = FALSE,
  invyrs = NULL,
  measyrs = NULL,
  invyrtab = NULL,
  gui = FALSE
)

checkidx(
  dbconn,
  tbl = NULL,
  index_cols = NULL,
  datsource = "sqlite",
  schema = "FS_FIADB",
  dbconnopen = TRUE
)

createidx(dbconn, tbl, index_cols, unique = FALSE, dbconnopen = TRUE)

dbclassify(
  dbconn,
  tabnm,
  classcol,
  cutbreaks,
  cutlabels,
  classnm = NULL,
  overwrite = TRUE,
  NAto0 = FALSE,
  dbconnopen = TRUE,
  quiet = FALSE
)

dbclass(
  dbconn,
  tabnm,
  classcol,
  classvals,
  classlabels,
  classnm = NULL,
  overwrite = TRUE,
  NAto0 = FALSE,
  dbconnopen = TRUE,
  quiet = FALSE
)

getwithqry(
  dsn = NULL,
  evalid = NULL,
  states = NULL,
  pjoinid,
  plotCur = FALSE,
  varCur = "MEASYEAR",
  Endyr = NULL,
  invyrs = NULL,
  measyears = NULL,
  allyrs = FALSE,
  SCHEMA. = NULL,
  invtype = "ANNUAL",
  subcycle99 = FALSE,
  designcd1 = FALSE,
  intensity1 = FALSE,
  popSURVEY = FALSE,
  chk = FALSE,
  Type = "VOL",
  syntax = "sql",
  plotnm = "plot",
  ppsanm = "pop_plot_stratum_assgn",
  ppsaid = "PLT_CN",
  surveynm = "survey",
  PLOTdf = NULL,
  pltflds = NULL,
  POP_PLOT_STRATUM_ASSGNdf = NULL,
  ppsaflds = NULL,
  pvars = NULL,
  dbconn = NULL,
  dbconnopen = TRUE,
  withqry2 = FALSE
)

Ratio2Size(
  yn,
  y2n = NULL,
  yd,
  y2d = NULL,
  ysum,
  dsum,
  uniqueid,
  esttype,
  ratiotype,
  stratalut,
  RHGlut,
  unitvar,
  strvar,
  domain
)

addCI(x, estnm, senm = NULL, conf.level = c(99, 95, 68), gainloss = FALSE)

change10char(xnms)

RtoSQL(filter, x = NULL)

getext(x)

getoutfn(
  outfn,
  outfolder = NULL,
  outfn.pre = NULL,
  outfn.date = FALSE,
  overwrite = FALSE,
  ext = NULL,
  baseonly = FALSE,
  noext = FALSE,
  outfn.default = "outfile",
  add = TRUE,
  append = FALSE,
  gui = FALSE
)

addcommas(vars, ALIAS = NULL, sepchar = ",", quotes = FALSE, paren = FALSE)

pastevars(vars1, vars2, sep = ",")

stopQ()

removecols(x, vars)

DT_NAto0(DT, cols, changeto = 0)

changeNULL(x, xvar, changeto = NULL)

getdups(cx, cuniqueid = "PLT_CN", varnm, fun)

getlistparam(lst)

getnm(xvar, group = FALSE)

capfirst(x, allwords = FALSE)

nbrdecimals(x)

nbrdigits(x)

getfilter(att, val, syntax = "R", quote = FALSE)

filter2qry(filt, layernm)

wraptitle(x, len = 10)

xtabf(x, y, levels)

recodelut(lut, minvar = "min", maxvar = "max", classvar = "class")

findnm(x, xvect, returnNULL = FALSE)

chkdbtab(dbtablst, tab, stopifnull = FALSE)

int64tochar(df)

messagedf(df)

getSPGRPCD(states)

addFORTYPGRPCD(cond)

date2char(df, col, formatstr = "%Y-%m-%d")

getfilter(att, val, syntax = "R", quote = FALSE)

checklevels(x, uniquex, xvar, keepNA = TRUE)

getext(x)

filter2qry(filt, layernm)

recodelut(lut, minvar = "min", maxvar = "max", classvar = "class")

strat.pivot(x, strvar, unitvars, strwtvar = "Prop", strat.levels = NULL)

makedummy(dat, auxlut, predfac)

preds.standardize(plt, aux, prednames)

gregEN.select(
  y,
  x_sample,
  x_pop,
  N,
  alpha = 0.5,
  returncoef = FALSE,
  cvfolds = 10
)

preds.select(y, plt, auxlut, prednames, cvfolds = 10)

fileexistsnm(outfolder, basenm, ext)

getRefcodes(xvar)

getRefobject(xvar)

getadjfactorDWM(
  adj = "samp",
  condx,
  cuniqueid = "PLT_CN",
  condid = "CONDID",
  unitlut = NULL,
  unitvars = NULL,
  strvars = NULL,
  unitarea = NULL,
  areavar = NULL,
  areawt = "SUBP_CONDPROP_UNADJ",
  dwmpropvars = NULL
)

getadjfactorGB(
  condx = NULL,
  treex = NULL,
  seedx = NULL,
  vcondsppx = NULL,
  vcondstrx = NULL,
  cond_dwm_calcx = NULL,
  tuniqueid = "PLT_CN",
  cuniqueid = "PLT_CN",
  vuniqueid = "PLT_CN",
  duniqueid = "PLT_CN",
  condid = "CONDID",
  unitlut = NULL,
  unitvars = NULL,
  strvars = NULL,
  unitarea = NULL,
  areavar = NULL,
  areawt = "CONDPROP_UNADJ",
  cvars2keep = NULL,
  tpropvars = list(SUBP = "SUBPPROP_UNADJ", MICR = "MICRPROP_UNADJ", MACR =
    "MACRPROP_UNADJ")
)

getadjfactorP2VEG(
  adj = "samp",
  condx,
  vcondsppx = NULL,
  vcondstrx = NULL,
  cuniqueid = "PLT_CN",
  vuniqueid = "PLT_CN",
  condid = "CONDID",
  unitlut = NULL,
  unitvars = NULL,
  strvars = NULL,
  unitarea = NULL,
  areavar = NULL,
  areawt = "SUBP_CONDPROP_UNADJ",
  cvars2keep = NULL
)

getadjfactorPLOT(
  condx = NULL,
  treex = NULL,
  seedx = NULL,
  cuniqueid = "PLT_CN",
  tuniqueid = "PLT_CN",
  condid = "CONDID",
  checkNA = TRUE,
  areawt = "CONDPROP_UNADJ",
  tpropvars = list(SUBP = "SUBPPROP_UNADJ", MICR = "MICRPROP_UNADJ", MACR =
    "MACRPROP_UNADJ")
)

getadjfactorVOL(
  adj = adj,
  condx = NULL,
  treex = NULL,
  seedx = NULL,
  tuniqueid = "PLT_CN",
  cuniqueid = "PLT_CN",
  condid = "CONDID",
  unitlut = NULL,
  unitvars = NULL,
  strvars = NULL,
  unitarea = NULL,
  areavar = NULL,
  areawt = "CONDPROP_UNADJ",
  cvars2keep = NULL,
  cpropvars = list(SUBP = "SUBPPROP_UNADJ", MACR = "MACRPROP_UNADJ"),
  tpropvars = list(SUBP = "SUBPPROP_UNADJ", MACR = "MACRPROP_UNADJ", MICR =
    "MICRPROP_UNADJ"),
  keepadjvars = FALSE,
  adjvars = NULL
)

getfunnm(x)

getlt10char(dbname)

getrhat(x)

groupEstunit(x, minplotnum)

groupStrata(x, minplotnum, nvar = "n.strata")

groupUnits(
  tabest,
  domain,
  esttype = "AREA",
  estncol = "estn",
  estncol.var = "estn.var",
  estdcol = "estd",
  estdcol.var = "estd.var",
  covarcol = "covar",
  grpfun = sum,
  domvar2 = NULL,
  rowgrpnm = NULL,
  unitvar = NULL,
  areavar = NULL,
  phototype = "PCT",
  photoratio = FALSE,
  keepvars = NULL
)

getjoinqry(joinid1, joinid2, alias1 = "p.", alias2 = "plta.")

classqry(classcol, fromval, toval, classnm = NULL, NAto0 = TRUE)

classifyqry(
  classcol,
  cutbreaks,
  cutlabels = NULL,
  classnm = NULL,
  NAto0 = FALSE
)

save1tab(
  tab,
  tab.title = NULL,
  outfolder,
  allin1 = TRUE,
  coltitlerow = TRUE,
  coltitle = NULL,
  addtitle = TRUE,
  rowtotal = TRUE,
  rnames = NULL,
  outfn = NULL,
  addformat = TRUE,
  charvars = NULL,
  outfn.date = TRUE,
  overwrite = FALSE,
  cols2format = NULL
)

save2tabs(
  tab1,
  tab2,
  tab1.title,
  tab2.title,
  outfolder,
  coltitlerow = TRUE,
  coltitle = NULL,
  addtitle = TRUE,
  rowtotal = TRUE,
  rnames = NULL,
  outfn.estpse = NULL,
  outfn.date = TRUE,
  overwrite = FALSE
)

strat.collapse(
  stratacnt,
  pltstratx,
  minplotnum.unit = 10,
  minplotnum.strat = 2,
  unitarea,
  areavar,
  unitvar,
  unitvar2 = NULL,
  strvar,
  getwt = FALSE,
  stratcombine = TRUE,
  unitcombine = FALSE,
  vars2combine = NULL,
  ...
)

subpsamp(
  cond,
  subp_cond,
  subplot,
  data_dsn = NULL,
  subpuniqueid = "PLT_CN",
  subpid = "SUBP",
  ACI = FALSE,
  whereqry = NULL
)

subpsampP2VEG(
  plt,
  cond,
  subp_cond,
  subplot,
  data_dsn = NULL,
  subpuniqueid = "PLT_CN",
  subpid = "SUBP",
  ACI = FALSE,
  whereqry = NULL
)

allin1f(
  x,
  y,
  char.width = NULL,
  estnull = "--",
  psenull = "--",
  estround = NULL,
  pseround = NULL
)

crosstabx(
  x,
  xvar,
  estnm,
  psenm,
  allin1 = FALSE,
  char.width = NULL,
  estround = NULL,
  pseround = NULL,
  estnull = "--",
  psenull = "--"
)

add0unit(
  x,
  xvar,
  uniquex,
  unitvar = NULL,
  xvar.add0 = FALSE,
  xvar2 = NULL,
  uniquex2 = NULL,
  xvar2.add0 = FALSE
)

addrowgrp(x, uniquerow, rowvar, rowgrpnm, title.rnames = NULL)

crossxtab(
  group.est,
  rowvar.est = NULL,
  colvar.est = NULL,
  total.est = NULL,
  rowvar,
  colvar,
  estnm,
  psenm,
  estround = NULL,
  pseround = NULL,
  gtotal = TRUE,
  allin1 = FALSE,
  rowgrp = FALSE,
  rowgrpnm = NULL,
  title.rnames = NULL,
  estnull = 0,
  psenull = "--",
  char.width = NULL
)

getdomain()

getestvar()

crossxbyunit(
  unit = NULL,
  unit_grpest = NULL,
  unit_rowest = NULL,
  unit_colest = NULL,
  unit_totest = NULL,
  unitvar,
  rowvar,
  colvar,
  estnm,
  psenm,
  allin1,
  char.width,
  estnull,
  psenull,
  estround = NULL,
  pseround = NULL,
  rowgrp = NULL,
  rowgrpnm = NULL,
  title.rnames = NULL,
  numunits,
  savedata,
  addtitle,
  returntitle,
  outfn.estpse,
  title.estpse,
  title.est,
  title.pse,
  title.ref,
  outfolder,
  outfn.date,
  overwrite,
  esttype,
  phototype,
  rnames = NULL,
  title.colvar = NULL,
  title.unitvar = NULL
)

ptdata2sf(
  ptdata,
  crs,
  coords = c(2, 3),
  asSpatial = FALSE,
  stringsAsFactors = FALSE
)

sf2ptdata(ptlayer, id_fld = 1, stringsAsFactors = FALSE)

layerIntersection(
  layer1,
  layer2,
  asSpatial = FALSE,
  dropLowerDimGeom = TRUE,
  stringsAsFactors = FALSE
)

layerUnion(
  layer1,
  layer2,
  asSpatial = FALSE,
  dropLowerDimGeom = TRUE,
  sfColName = "geometry",
  stringsAsFactors = FALSE
)

tabulateIntersections(
  layer1,
  layer1fld,
  layer2,
  layer2fld = NULL,
  stringsAsFactors = FALSE,
  withUnits = FALSE
)

selectByIntersects(
  layer1,
  layer2,
  overlapThreshold = 0,
  thresholdAsPct = TRUE,
  asSpatial = FALSE,
  stringsAsFactors = FALSE
)

layerFromRasterExtent(rasterfile, asSpatial = FALSE)

wtcalc(wtLUT, strvar, acrevar)

wtcalc.unit(wtLUT, strvar, unit, unitvar, acrevar)
</code></pre>


<h3>Details</h3>

<p>These functions provide a wide-range of general utility for a variety of
data types.
</p>


<h3>Value</h3>

<p>Object for internal use by other functions in FIESTAutils or other packages
used for USDA Forest Service data analysis.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino, Chris Toney, Grayson W. White
</p>

<hr>
<h2 id='eval_options'>List of population tables.</h2><span id='topic+eval_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for data 
evaluation (FIA or custom) extraction to be supplied to *DB functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_options(
  Cur = FALSE,
  Endyr = NULL,
  Endyr.filter = NULL,
  All = FALSE,
  Type = "VOL",
  evalid = NULL,
  invyrs = NULL,
  measyrs = NULL,
  varCur = "INVYR",
  evalType = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_options_+3A_cur">Cur</code></td>
<td>
<p>Logical. If eval='FIA': extract plots with most current 
evaluation. If eval='custom': extract the most current sampled plots 
in the database.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_endyr">Endyr</code></td>
<td>
<p>Integer (YYYY). If eval='FIA', defines end year for
extracting one or more FIA evaluation. If eval='custom', defines 
end year for extracting the most current sampled plots until.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_endyr.filter">Endyr.filter</code></td>
<td>
<p>Filter. If endyr != NULL, a filter to identify
when to use measEndyr, such as areas or plots identified as being 
disturbed in a particular year. In this example, plots sampled after
the disturbance will be excluded.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_all">All</code></td>
<td>
<p>Logical. If eval='FIA': includes all evaluations in 
database (annual inventory only). If eval='custom': includes all years 
in database (annual inventory only).</p>
</td></tr>
<tr><td><code id="eval_options_+3A_type">Type</code></td>
<td>
<p>String vector. Evaluation types ('ALL','CURR','VOL','P2VEG',
DWM','INV','CHNG','GRM','REGEN'). If eval='FIA', Type is equivalent to
plots for FIA Evaluations where 'ALL' includes nonsampled plots; 'CURR' 
and 'VOL' include plots used for area or tree estimates, respectively; 
Type = 'GRM' includes plots used for growth, removals, mortality; and 
Type = 'CHNG' includes plots used for change estimates (See FIA database 
manual for regioin availability and/or differences 
(https://www.fia.fs.usda.gov/library/database-documentation/index.php) 
If eval='custom', the associated tables are extracted for each Type. 
Multiple Types are accepted.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_evalid">evalid</code></td>
<td>
<p>Integer. Only eval='FIA': extract data for a specific 
evaluation period. See notes for more information about FIA Evaluations.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_invyrs">invyrs</code></td>
<td>
<p>Integer vector. eval='custom': defines specific
inventory years of data (e.g., 2010:2015). See FIA manual for 
definition of INVYR.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_measyrs">measyrs</code></td>
<td>
<p>Integer vector. eval='custom': defines specific
measurement years of data (e.g., 2010:2015).</p>
</td></tr>
<tr><td><code id="eval_options_+3A_varcur">varCur</code></td>
<td>
<p>String. Name of variable to use for most current plot
('MEASYEAR', 'INVYR').</p>
</td></tr>
<tr><td><code id="eval_options_+3A_evaltype">evalType</code></td>
<td>
<p>Deprecated. Use Type instead.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eval_options(invyrs = 2015:2018)
</code></pre>

<hr>
<h2 id='GBest.pbar'>Estimation Functions</h2><span id='topic+GBest.pbar'></span><span id='topic+MAest.ht'></span><span id='topic+MAest.ps'></span><span id='topic+MAest.greg'></span><span id='topic+MAest.ratio'></span><span id='topic+MAest.gregEN'></span><span id='topic+MAest.gregRatio'></span><span id='topic+MAest'></span><span id='topic+MAest.dom'></span><span id='topic+MAest.unit'></span><span id='topic+PBest.pbar'></span><span id='topic+PBest.pbarRatio'></span><span id='topic+SAest.unit'></span><span id='topic+SAest.area'></span><span id='topic+SAest'></span><span id='topic+SAest.dom'></span><span id='topic+SAest.large'></span><span id='topic+estimation_desc'></span>

<h3>Description</h3>

<p>These functions carry out direct, model-assisted, and small area estimation
through three different modules: &quot;Green Book&quot;, &quot;Model-Assisted&quot;, and
&quot;Small Area&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBest.pbar(
  sumyn = "CONDPROP_ADJ",
  ysum,
  sumyd = NULL,
  esttype = "AREA",
  ratiotype = "PERACRE",
  stratalut,
  uniqueid,
  unitvar,
  strvar = NULL,
  domain
)

MAest.ht(y, N, FIA = TRUE, getweights = FALSE, var_method = "LinHTSRS")

MAest.ps(
  y,
  N,
  x_sample,
  x_pop,
  FIA = TRUE,
  save4testing = FALSE,
  getweights = FALSE,
  var_method = "SRSunconditional"
)

MAest.greg(
  y,
  N,
  x_sample,
  x_pop,
  FIA = TRUE,
  save4testing = TRUE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = "LinHTSRS"
)

MAest.ratio(
  y,
  N,
  x_sample,
  x_pop,
  FIA = TRUE,
  save4testing = TRUE,
  var_method = "LinHTSRS"
)

MAest.gregEN(
  y,
  N,
  x_sample,
  x_pop,
  FIA = TRUE,
  model = "linear",
  save4testing = TRUE,
  getweights = FALSE,
  var_method = "LinHTSRS"
)

MAest.gregRatio(
  yn,
  yd,
  N,
  area,
  x_sample,
  x_pop,
  FIA = TRUE,
  save4testing = FALSE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = "LinHTSRS"
)

MAest(
  yn = "CONDPROP_ADJ",
  dat.dom,
  cuniqueid,
  unitlut = NULL,
  pltassgn,
  esttype = "ACRES",
  MAmethod,
  strvar = NULL,
  prednames = NULL,
  yd = NULL,
  ratiotype = "PERACRE",
  N,
  area,
  FIA = TRUE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = ifelse(MAmethod %in% c("PS"), "SRSunconditional", "LinHTSRS")
)

MAest.dom(
  dom,
  dat,
  cuniqueid,
  unitlut,
  pltassgn,
  esttype,
  MAmethod,
  strvar = NULL,
  prednames = NULL,
  domain,
  N,
  area = NULL,
  response = NULL,
  response_d = NULL,
  FIA = TRUE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = ifelse(MAmethod %in% c("PS"), "SRSunconditional", "LinHTSRS")
)

MAest.unit(
  unit,
  dat,
  cuniqueid,
  unitlut,
  unitvar,
  esttype,
  MAmethod = "HT",
  strvar = NULL,
  prednames = NULL,
  domain,
  response,
  response_d = NULL,
  npixels,
  unitarea = NULL,
  FIA = TRUE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = ifelse(MAmethod %in% c("PS"), "SRSunconditional", "LinHTSRS")
)

PBest.pbar(
  dom.prop,
  uniqueid,
  domain,
  strtype = "post",
  stratalut,
  strunitvars,
  unitvars,
  strvar
)

PBest.pbarRatio(
  dom.prop.n,
  dom.prop.d,
  uniqueid,
  domain,
  attribute,
  strtype = "post",
  stratalut,
  strunitvars,
  unitvars,
  strvar
)

SAest.unit(
  fmla.dom.unit,
  pltdat.dom,
  dunitlut.dom,
  yn,
  SApackage,
  dunitvar,
  predselect.unit,
  prior = NULL
)

SAest.area(
  fmla.dom.area,
  pltdat.area,
  dunitlut.area,
  cuniqueid,
  dunitvar = "DOMAIN",
  predselect.area,
  yn,
  SApackage,
  prior = NULL
)

SAest(
  yn = "CONDPROP_ADJ",
  dat.dom,
  cuniqueid,
  pltassgn,
  dunitlut,
  prednames = NULL,
  dunitvar = "DOMAIN",
  SAmethod = "unit",
  SApackage = "JoSAE",
  yd = NULL,
  ratiotype = "PERACRE",
  largebnd.val = NULL,
  showsteps = FALSE,
  savesteps = FALSE,
  stepfolder = NULL,
  prior = NULL,
  modelselect = TRUE,
  multest = TRUE,
  save4testing = FALSE
)

SAest.dom(
  dom,
  dat,
  cuniqueid,
  dunitlut,
  pltassgn,
  dunitvar = "DOMAIN",
  SApackage,
  SAmethod,
  prednames = NULL,
  domain,
  response = NULL,
  largebnd.val = NULL,
  showsteps = FALSE,
  savesteps = FALSE,
  stepfolder = NULL,
  prior = NULL,
  modelselect = TRUE,
  multest = TRUE
)

SAest.large(
  largebnd.val,
  dat,
  cuniqueid,
  largebnd.unique,
  dunitlut,
  dunitvar = "DOMAIN",
  SApackage = "JoSAE",
  SAmethod = "unit",
  domain,
  response,
  prednames = NULL,
  showsteps = FALSE,
  savesteps = FALSE,
  stepfolder = NULL,
  prior = NULL,
  modelselect = TRUE,
  multest = TRUE
)
</code></pre>


<h3>Details</h3>

<p>These functions can carry out estimation with data from a variety of domains, 
but are designed for USFS FIA data.
</p>


<h3>Value</h3>

<p>List object containing estimates produced. If GB or PB estimation, output is
directly from FIESTAutils, while outputs for MA or SA will be list objects
from packages such as 'mase', 'sae', 'hbsae', or 'JoSAE'.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino, Grayson W. White
</p>

<hr>
<h2 id='GDT_NAMES'>Reference tables - gdal data types.</h2><span id='topic+GDT_NAMES'></span>

<h3>Description</h3>

<p>Table with gdal data type names.
</p>


<h3>Format</h3>

<p>A vector of 12 data type values.
</p>


<h3>Source</h3>

<p>gdal values.
</p>

<hr>
<h2 id='getDefaultNodata'>Raster Functions</h2><span id='topic+getDefaultNodata'></span><span id='topic+getOffset'></span><span id='topic+getGDALformat'></span><span id='topic+basename.NoExt'></span><span id='topic+Mode'></span><span id='topic+Modes'></span><span id='topic+northness'></span><span id='topic+eastness'></span><span id='topic+roughness'></span><span id='topic+TRI'></span><span id='topic+TPI'></span><span id='topic+getPixelValue'></span><span id='topic+.getPixelValue'></span><span id='topic+extractPtsFromRaster'></span><span id='topic+extractPtsFromRasterList'></span><span id='topic+rasterInfo'></span><span id='topic+reprojectRaster'></span><span id='topic+rasterFromVectorExtent'></span><span id='topic+rasterizePolygons'></span><span id='topic+clipRaster'></span><span id='topic+recodeRaster'></span><span id='topic+pixelCount'></span><span id='topic+focalRaster'></span><span id='topic+zonalStats'></span><span id='topic+zonalMean'></span><span id='topic+zonalFreq'></span><span id='topic+zonalMajority'></span><span id='topic+zonalMinority'></span><span id='topic+zonalVariety'></span><span id='topic+raster_desc'></span><span id='topic+getrastlst'></span><span id='topic+areacalc.pixel'></span><span id='topic+aspect_transform'></span><span id='topic+checkrast.longlat'></span><span id='topic+getrastlst.rgdal'></span>

<h3>Description</h3>

<p>These functions allow for analysis of raster data. Many are written in C++ to
be extremely efficient and fast. Some are wrappers around these C++ functions
for easier use and integration into other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDefaultNodata(GDT_name)

getOffset(coord, origin, gt_pixel_size)

getGDALformat(file)

basename.NoExt(filepath)

Mode(x, na.rm = FALSE)

Modes(x, na.rm = FALSE)

northness(asp_deg)

eastness(asp_deg)

roughness(x, na.rm = FALSE, asInt = TRUE)

TRI(x, na.rm = FALSE, asInt = TRUE)

TPI(x, na.rm = FALSE, asInt = TRUE)

getPixelValue(
  pt,
  ds,
  ri = NULL,
  band = 1,
  interpolate = FALSE,
  windowsize = 1,
  statistic = NULL,
  na.rm = TRUE
)

.getPixelValue(pt, rasterfile, ds, ...)

extractPtsFromRaster(
  ptdata,
  rasterfile,
  band = NULL,
  var.name = NULL,
  interpolate = FALSE,
  windowsize = 1,
  statistic = NULL,
  na.rm = TRUE,
  ncores = 1
)

extractPtsFromRasterList(
  ptdata,
  rasterfiles,
  bands = NULL,
  var.names = NULL,
  interpolate = FALSE,
  windowsizes = NULL,
  statistics = NULL,
  na.rm = TRUE,
  ncores = 1
)

rasterInfo(srcfile)

reprojectRaster(
  srcfile,
  dstfile,
  t_srs,
  overwrite = TRUE,
  s_srs = NULL,
  of = NULL,
  ot = NULL,
  te = NULL,
  tr = NULL,
  r = NULL,
  dstnodata = NULL,
  co = NULL,
  addOptions = NULL
)

rasterFromVectorExtent(
  src,
  dstfile,
  res,
  fmt = NULL,
  nbands = 1,
  dtName = "Int16",
  options = NULL,
  init = NULL,
  dstnodata = init
)

rasterizePolygons(dsn, layer, burn_value, rasterfile, src = NULL)

clipRaster(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  srcfile,
  src_band = NULL,
  dstfile,
  fmt = NULL,
  options = NULL,
  init = NULL,
  dstnodata = NULL,
  maskByPolygons = TRUE
)

recodeRaster(srcfile, dstfile, lut, srcband = 1, ...)

pixelCount(rasterfile, band = 1)

focalRaster(
  srcfile,
  dstfile,
  w,
  fun = sum,
  na.rm = FALSE,
  ...,
  fmt = NULL,
  dtName = NULL,
  options = NULL,
  nodata_value = NULL,
  setRasterNodataValue = FALSE,
  srcband = NULL
)

zonalStats(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  pixelfun = NULL,
  na.rm = TRUE,
  ignoreValue = NULL
)

zonalMean(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  pixelfun = NULL,
  na.rm = TRUE,
  ...
)

zonalFreq(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  aggfun = NULL,
  lut = NULL,
  na.rm = FALSE,
  ignoreValue = NULL
)

zonalMajority(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  ...
)

zonalMinority(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  ...
)

zonalVariety(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  ...
)

getrastlst(
  rastnmlst,
  rastfolder = NULL,
  stopifLonLat = FALSE,
  stopifnull = FALSE,
  gui = FALSE,
  quiet = FALSE
)

areacalc.pixel(rastfn, unit = "ACRES", rast.NODATA = NULL, na.rm = TRUE)

aspect_transform(df, asp)

checkrast.longlat(rastfn, dstfile = NULL, nolonglat = TRUE, crs.default = NULL)

getrastlst.rgdal(
  rastnmlst,
  rastfolder = NULL,
  stopifLonLat = FALSE,
  stopifnull = FALSE,
  gui = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Details</h3>

<p>These functions carry out raster data analysis.
</p>


<h3>Value</h3>

<p>Spatial data object from 'sf'. Used for spatial data analyses.
</p>


<h3>Author(s)</h3>

<p>Chris Toney, Tracey S. Frescino
</p>

<hr>
<h2 id='kindcd3old'>Reference table - List of RMRS plots that have fallen out of inventory
because they were not found or they were in the wrong place.</h2><span id='topic+kindcd3old'></span>

<h3>Description</h3>

<p>Table with variable codes (VALUE) and descriptions (MEANING).
</p>


<h3>Format</h3>

<p>A dataframe
</p>


<h3>Source</h3>

<p>FIA query.
SELECT bp.STATECD, bp.COUNTYCD, bp.PLOT_FIADB NEW_PLOT, bp.START_DATE NEW_START_DATE,
bp_old.COUNTYCD OLD_COUNTYCD, bp_old.PLOT_FIADB OLD_PLOT, 
bp_old.END_DATE OLD_END_DATE, p.CN
FROM fs_nims_rmrs.NIMS_BASE_PLOT bp
JOIN fs_nims_rmrs.NIMS_BASE_PLOT bp_old on (bp.PREV_NBP_CN=bp_old.CN)
JOIN fs_nims_rmrs.NIMS_PLOT_RMRS_VW p on(p.NBP_CN=bp_old.CN)
WHERE p.KINDCD = 1
ORDER BY bp.STATECD, bp.COUNTYCD, bp_old.PLOT_FIADB&quot;
</p>

<hr>
<h2 id='multest_options'>Multest output options.</h2><span id='topic+multest_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for outputting
multest with custom aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multest_options(
  multest_fmt = "csv",
  multest_outfolder = NULL,
  multest_dsn = NULL,
  multest_layer = NULL,
  multest.append = FALSE,
  multest.AOIonly = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multest_options_+3A_multest_fmt">multest_fmt</code></td>
<td>
<p>String. Format for multest output tables ('csv',
'sqlite', 'gpkg').</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest_outfolder">multest_outfolder</code></td>
<td>
<p>String. Outfolder for multest. If NULL, same as
outfolder.</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest_dsn">multest_dsn</code></td>
<td>
<p>String. Name of database if multest_fmt = c('sqlite',
'gpkg').</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest_layer">multest_layer</code></td>
<td>
<p>String. Name of database layer if multest_fmt =
c('sqlite', 'gpkg').</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest.append">multest.append</code></td>
<td>
<p>Logical. If TRUE, appends multest dataframe to output.</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest.aoionly">multest.AOIonly</code></td>
<td>
<p>Logical. If TRUE, appends multest dataframe (AOI=1)
to output.</p>
</td></tr>
<tr><td><code id="multest_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for outputting
multest.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
multest_options(multest.append = TRUE)

</code></pre>

<hr>
<h2 id='pcheck.logical'>Parameter Check Functions</h2><span id='topic+pcheck.logical'></span><span id='topic+pcheck.unique'></span><span id='topic+pcheck.varchar'></span><span id='topic+pcheck.dsn'></span><span id='topic+pcheck.table'></span><span id='topic+pcheck.outfolder'></span><span id='topic+pcheck.states'></span><span id='topic+pcheck.object'></span><span id='topic+pcheck.output'></span><span id='topic+pcheck.colors'></span><span id='topic+pcheck.areaunits'></span><span id='topic+pcheck.spatial'></span><span id='topic+pcheck.params'></span><span id='topic+pcheck_desc'></span><span id='topic+popTabchk'></span>

<h3>Description</h3>

<p>These functions are used to check parameter inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcheck.logical(
  var2check,
  varnm = NULL,
  title = NULL,
  first = "YES",
  gui = FALSE,
  stopifnull = FALSE
)

pcheck.unique(
  tab,
  uniqueid,
  gui = FALSE,
  tabnm = NULL,
  warn = NULL,
  stopifnull = FALSE,
  stopifinvalid = TRUE,
  multiple = FALSE,
  ...
)

pcheck.varchar(
  var2check,
  varnm = NULL,
  checklst,
  gui = FALSE,
  caption = NULL,
  warn = NULL,
  stopifnull = FALSE,
  stopifinvalid = TRUE,
  multiple = FALSE,
  ...
)

pcheck.dsn(dsn, dbconnopen = TRUE)

pcheck.table(
  tab = NULL,
  conn = NULL,
  tab_dsn = NULL,
  tabnm = NULL,
  tabqry = NULL,
  caption = NULL,
  returnsf = TRUE,
  factors = FALSE,
  returnDT = TRUE,
  warn = NULL,
  stopifnull = FALSE,
  stopifinvalid = FALSE,
  nullcheck = FALSE,
  obj = FALSE,
  checkonly = FALSE,
  gui = FALSE
)

pcheck.outfolder(outfolder, default = getwd(), gui = FALSE)

pcheck.states(
  states,
  statereturn = "MEANING",
  gui = FALSE,
  RS = NULL,
  stopifnull = FALSE,
  ...
)

pcheck.object(
  obj = NULL,
  objnm = NULL,
  warn = NULL,
  caption = NULL,
  stopifnull = FALSE,
  gui = FALSE,
  list.items = NULL
)

pcheck.output(
  out_fmt = "csv",
  out_dsn = NULL,
  outfolder = NULL,
  outfn.pre = NULL,
  outfn.date = FALSE,
  overwrite_dsn = FALSE,
  overwrite_layer = TRUE,
  add_layer = TRUE,
  append_layer = FALSE,
  createSQLite = TRUE,
  out_conn = NULL,
  dbconnopen = FALSE,
  gui = FALSE
)

pcheck.colors(colorlst, n)

pcheck.areaunits(unitarea, areavar, areaunits, metric = FALSE)

pcheck.spatial(
  layer = NULL,
  dsn = NULL,
  sql = NA,
  fmt = NULL,
  tabnm = NULL,
  caption = NULL,
  stopifnull = FALSE,
  gui = FALSE,
  polyfix = FALSE,
  dropgeom = FALSE,
  stopifnoCRS = TRUE,
  checkonly = FALSE
)

pcheck.params(
  input.params,
  strata_opts = NULL,
  unit_opts = NULL,
  table_opts = NULL,
  title_opts = NULL,
  savedata_opts = NULL,
  multest_opts = NULL,
  spMakeSpatial_opts = NULL,
  eval_opts = NULL,
  xy_opts = NULL
)

popTabchk(tabnames, tabtext, tabs, tabIDs, dbtablst, dbconn, datindb = FALSE)
</code></pre>


<h3>Details</h3>

<p>These functions are used to check parameter inputs.
</p>


<h3>Value</h3>

<p>List of parameter objects checked by the function. While the 'pcheck.*()'
functions do return a value, they are primarily used for their side effects
when checking input function parameters.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='Rcpp_CmbTable-class'>Class <code>"Rcpp_CmbTable"</code></h2><span id='topic+Rcpp_CmbTable-class'></span>

<h3>Description</h3>

<p>C++ program to combine raster files.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="Rcpp.html#topic+C+2B+2BObject-class">C++Object</a>"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Toney
</p>

<hr>
<h2 id='Rcpp_RunningStats-class'>Class <code>"Rcpp_RunningStats"</code></h2><span id='topic+Rcpp_RunningStats-class'></span>

<h3>Description</h3>

<p>C++ program to calculate mean and variance on a data stream.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="Rcpp.html#topic+C+2B+2BObject-class">C++Object</a>"</code>, directly.
</p>
<p>All reference classes extend and inherit methods from
<code>"<a href="methods.html#topic+envRefClass-class">envRefClass</a>"</code>.
</p>


<h3>Author(s)</h3>

<p>Chris Toney
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+rasterFromRaster'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>gdalraster</dt><dd><p><code><a href="gdalraster.html#topic+rasterFromRaster">rasterFromRaster</a></code></p>
</dd>
</dl>

<hr>
<h2 id='ref_codes'>Reference tables - Code definitions.</h2><span id='topic+ref_codes'></span>

<h3>Description</h3>

<p>Table with variable codes (VALUE) and descriptions (MEANING).
</p>


<h3>Format</h3>

<p>A dataframe with 7 columns, VARIABLE, VALUE, MEANING, COLORHEX,
GROUP, GROUPNM, GROUPHEX.
</p>


<h3>Source</h3>

<p>FIA look-up tables.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_codes_archive'>Reference tables - Code definitions (Archive).</h2><span id='topic+ref_codes_archive'></span>

<h3>Description</h3>

<p>Table with variable codes (VALUE) and descriptions (MEANING).
</p>


<h3>Format</h3>

<p>A dataframe with 7 columns, VARIABLE, VALUE, MEANING, COLORHEX,
GROUP, GROUPNM, GROUPHEX.
</p>


<h3>Source</h3>

<p>FIA look-up tables.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_cond'>Reference table - Metadata for cond default variables output from
DBgetPlots()</h2><span id='topic+ref_cond'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions
</p>


<h3>Format</h3>

<p>A data frame with 61 rows and 3 columns VARIABLE - Variable in cond
data frame DESCRIPTION - Description of variable in cond data frame TABLE -
Table in database where variable originates or if derived
</p>


<h3>Source</h3>

<p>FIA look-up table
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_conversion'>Reference table - for conversion factors.</h2><span id='topic+ref_conversion'></span>

<h3>Description</h3>

<p>Table with conversion factors from English to metric units.
</p>


<h3>Format</h3>

<p>A dataframe with 6 columns: TYPE, ENGLISH, ENGLISH_ABBR, METRIC, METRIC_ABBR, CONVERSION.
</p>


<h3>Source</h3>

<p>Conversion table.
</p>

<hr>
<h2 id='ref_diacl2in'>Reference table - diameter 2-inch class codes (DIA).</h2><span id='topic+ref_diacl2in'></span>

<h3>Description</h3>

<p>Table with min (MIN), max (MAX), and 2-inch class diameter codes (MEANING).
</p>


<h3>Format</h3>

<p>A dataframe with 3 columns, MIN, MAX, and MEANING.
</p>


<h3>Source</h3>

<p>Imported from comma-delimited file.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_domain'>Reference table - for generating tables.</h2><span id='topic+ref_domain'></span>

<h3>Description</h3>

<p>Table with row/column domain (VARNM) and their pretty names for table output
(TABLENM).
</p>


<h3>Format</h3>

<p>A dataframe with 2 columns, VARNM and TABLENM.
</p>


<h3>Source</h3>

<p>FIA look-up table.
</p>

<hr>
<h2 id='ref_estvar'>Reference table - for generating estimates</h2><span id='topic+ref_estvar'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions
</p>


<h3>Format</h3>

<p>A data frame to use a reference for estimation 
variables and filters.
</p>

<hr>
<h2 id='ref_evaltyp'>Reference table - for generating tables.</h2><span id='topic+ref_evaltyp'></span>

<h3>Description</h3>

<p>Table with row/column domain (VARNM) and their pretty names for table output
(TABLENM).
</p>


<h3>Format</h3>

<p>A dataframe with 3 columns, EVAL_TYP_CD, EVAL_TYP, DESCRIPTION.
</p>


<h3>Source</h3>

<p>FIA look-up table.
</p>

<hr>
<h2 id='ref_plt'>Reference table - Metadata for plt default variables output from
DBgetPlots()</h2><span id='topic+ref_plt'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions.
</p>


<h3>Format</h3>

<p>A data frame with 43 rows and 3 columns VARIABLE - Variable in plt
data frame DESCRIPTION - Description of variable in plt data frame TABLE -
Table in database where variable originates or if derived
</p>


<h3>Source</h3>

<p>FIA look-up table
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_popType'>Reference table - popType codes.</h2><span id='topic+ref_popType'></span>

<h3>Description</h3>

<p>Table with population type (popType) and associated evaluation code (EVAL_TYP_CD).
</p>


<h3>Format</h3>

<p>A dataframe with 2 columns, VARNM and TITLE.
</p>


<h3>Source</h3>

<p>Comma-delimited file.
</p>

<hr>
<h2 id='ref_shp'>Reference table - Metadata for shp_* default variables output from
DBgetPlots()</h2><span id='topic+ref_shp'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions
</p>


<h3>Format</h3>

<p>A dataframe with 63 rows and 4 columns VARIABLE - Variable in plt
data frame DESCRIPTION - Description of variable in plt data frame TABLE -
Table in database where variable originates or if derived SHPEXPORT - Name
of variable for exported shapefile (&lt;= 10 characters)
</p>


<h3>Source</h3>

<p>FIA look-up table
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_species'>Reference table - Code definitions.</h2><span id='topic+ref_species'></span>

<h3>Description</h3>

<p>Table with species information downloaded from datamart FIADB_REFERENCES, 
subset from REF_SPECIES TABLE.
</p>


<h3>Format</h3>

<p>A dataframe with 14 columns: SPCD, COMMON_NAME, GENUS, SPECIES, 
SPECIES_SYMBOL, E_SPGRCD, W_SPGRPCD, C_SPGRPCD, P_SPGRPCD, 
MAJOR_SPGRPCD, JENKINS_TOTAL_B1, JENKINS_TOTAL_B2, 
DRYWT_TO_GREENWT_CONERSION, SCIENTIFIC_NAME (GENUS + SPECIES).
</p>


<h3>Source</h3>

<p>Imported from comma-delimited file.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_statecd'>Reference table - state codes (STATECD).</h2><span id='topic+ref_statecd'></span>

<h3>Description</h3>

<p>Table with state codes (VALUE), name (MEANING), abbreviation (ABBR), and
UNIT.
</p>


<h3>Format</h3>

<p>A dataframe with 4 columns, VALUE, MEANING, ABBR, UNIT.
</p>


<h3>Source</h3>

<p>Imported from comma-delimited file.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_titles'>Reference table - Variable titles.</h2><span id='topic+ref_titles'></span>

<h3>Description</h3>

<p>Table with variable name (VARNM) and associated title (TITLE).
</p>


<h3>Format</h3>

<p>A dataframe with 2 columns, VARNM and TITLE.
</p>


<h3>Source</h3>

<p>Comma-delimited file.
</p>

<hr>
<h2 id='ref_tree'>Reference table - Metadata for tree default variables output from
DBgetPlots()</h2><span id='topic+ref_tree'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions
</p>


<h3>Format</h3>

<p>A data frame with 72 rows and 3 columns VARIABLE - Variable in tree
data frame DESCRIPTION - Description of variable in tree data frame TABLE -
Table in database where variable originates
</p>


<h3>Source</h3>

<p>FIA look-up table
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_units'>Reference table - for variable units.</h2><span id='topic+ref_units'></span>

<h3>Description</h3>

<p>Table with units for TREE variables. The WOODLAND column was added
to identify which variables include woodland species.The kg2tons
column was added to identify which variables are commonly converted
from kilograms to tons in estimation process.
</p>


<h3>Format</h3>

<p>A dataframe with 4 columns: VARIABLE, UNITS, METRICUNITS, 
WOODLAND, kg2tons.
</p>


<h3>Source</h3>

<p>Units table.
</p>

<hr>
<h2 id='savedata_options'>Data saving options.</h2><span id='topic+savedata_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for saving data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>savedata_options(
  outfolder = NULL,
  out_fmt = "csv",
  outsp_fmt = "shp",
  outobj_fmt = "rds",
  out_dsn = NULL,
  out_layer = "outdat",
  outfn.pre = NULL,
  outfn.date = FALSE,
  addtitle = TRUE,
  raw_fmt = "csv",
  raw_dsn = NULL,
  overwrite_dsn = FALSE,
  overwrite_layer = TRUE,
  append_layer = FALSE,
  add_layer = TRUE,
  layer.pre = NULL,
  outconn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="savedata_options_+3A_outfolder">outfolder</code></td>
<td>
<p>String. The outfolder to write files to. If NULL, files are
written to working directory, or if gui=TRUE, a window to browse.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_out_fmt">out_fmt</code></td>
<td>
<p>String. Format for output tables ('csv', 'sqlite', 'gpkg', 'gdb').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outsp_fmt">outsp_fmt</code></td>
<td>
<p>String. Format for output spatial ('shp', sqlite', 'gpkg', 'gdb').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outobj_fmt">outobj_fmt</code></td>
<td>
<p>String. Format for output spatial ('rda', 'rds', 'llo').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_out_dsn">out_dsn</code></td>
<td>
<p>String. Data source name for output. If extension is
not included, out_fmt is used. Use full path if outfolder=NULL.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_out_layer">out_layer</code></td>
<td>
<p>outlayer.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outfn.pre">outfn.pre</code></td>
<td>
<p>String. If savedata=TRUE, prefix for output files. If
rawdata=TRUE, prefix for rawdata files (if raw_fmt = 'csv') or raw_dsn (if
raw_fmt != 'csv').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outfn.date">outfn.date</code></td>
<td>
<p>Logical. If TRUE, add current date to out_dsn.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_addtitle">addtitle</code></td>
<td>
<p>Logical. If TRUE and savedata=TRUE, adds title to outfile.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_raw_fmt">raw_fmt</code></td>
<td>
<p>String. Format for output rawdata tables ('sqlite',
'gpkg', 'csv', 'gdb').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_raw_dsn">raw_dsn</code></td>
<td>
<p>String. Data source name for rawdata output. If extension is
not included, out_fmt is used. Use full path if outfolder=NULL.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_overwrite_dsn">overwrite_dsn</code></td>
<td>
<p>Logical. If TRUE, overwrites raw_dsn, if exists.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_overwrite_layer">overwrite_layer</code></td>
<td>
<p>Logical. If TRUE, overwrites the output. If
rawdata=TRUE, overwrites out_layer in rawdata folder (if raw_fmt = 'csv') or
out_layers in raw_dsn (if raw_fmt != 'csv').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_append_layer">append_layer</code></td>
<td>
<p>Logical. If TRUE, and appends data to existing *.csv
files (if *_fmt = 'csv') or *_dsn layers (if *_fmt != 'csv&quot;.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_add_layer">add_layer</code></td>
<td>
<p>Logical. If TRUE, adds layer to an existing out_dsn 
(if out_fmt != c('csv','shp')).</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_layer.pre">layer.pre</code></td>
<td>
<p>Layer prefix.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outconn">outconn</code></td>
<td>
<p>Open database connection to save to.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for saving data.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
savedata_options(outfolder = "path", overwrite_dsn = FALSE)

</code></pre>

<hr>
<h2 id='spatial_desc'>Spatial Data Functions</h2><span id='topic+spatial_desc'></span><span id='topic+polyfix.sf'></span><span id='topic+build.prj4str'></span><span id='topic+trunc10shp'></span><span id='topic+merge_extents'></span><span id='topic+check.extents'></span><span id='topic+getprjatt'></span><span id='topic+areacalc.poly'></span><span id='topic+checksf.longlat'></span><span id='topic+crsCompare'></span><span id='topic+sf_dissolve'></span><span id='topic+closest_poly'></span><span id='topic+getIntersect'></span><span id='topic+clip.othertables'></span><span id='topic+check.area'></span>

<h3>Description</h3>

<p>These functions allow for analysis and manipulation of spatial data. Tasks
include but are not limited to analyzing polygons, comparing projections,
and checking data compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyfix.sf(x)

build.prj4str(
  prj,
  datum = NULL,
  ellps = NULL,
  zone = NULL,
  zoneS = FALSE,
  aea.param = "USGS",
  gui = FALSE
)

trunc10shp(x)

merge_extents(layer1, layer2)

check.extents(
  bbox1,
  bbox2,
  showext = FALSE,
  layer1nm = NULL,
  layer2nm = NULL,
  stopifnotin = FALSE,
  quiet = FALSE
)

getprjatt(prj4str, prjatt, stopifnull = FALSE)

areacalc.poly(
  polyv,
  polyv_dsn = NULL,
  areaprj = "aea",
  zone = NULL,
  unit = "ACRES",
  areavar = NULL
)

checksf.longlat(x, nolonglat = TRUE, crs.default = NULL)

crsCompare(
  x,
  ycrs = NULL,
  x.crs = NULL,
  nolonglat = FALSE,
  checkonly = FALSE,
  crs.default = NULL
)

sf_dissolve(sflayer, col = NULL, areacalc = TRUE)

closest_poly(x.centroid, ypoly, ypoly.att = NULL, nbr = NULL, returnsf = TRUE)

getIntersect(layer1, layer2, layer1.unique, layer2fld, overlapThreshold = 0)

clip.othertables(
  inids,
  othertabnms,
  othertabs = NULL,
  uniqueid = "PLT_CN",
  savedata = FALSE,
  outfn.pre = NULL,
  outfolder = NULL,
  out_fmt = "csv",
  out_dsn = NULL,
  outfn.date = FALSE,
  overwrite_layer = FALSE,
  gui = FALSE
)

check.area(bnd, bnd_dsn, bnd.att = NULL, areaunits = "acres", min.area = 6000)
</code></pre>


<h3>Details</h3>

<p>These functions carry out spatial data analysis.
</p>


<h3>Value</h3>

<p>Spatial data object from 'sf'. Used for spatial data analyses.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='spMakeSpatial_options'>Make SpatialPoints options</h2><span id='topic+spMakeSpatial_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for making
SpatialPoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spMakeSpatial_options(
  xvar = NULL,
  yvar = NULL,
  xy.crs = 4269,
  prj = NULL,
  datum = NULL,
  zone = NULL,
  zoneS = FALSE,
  aea.param = "USGS",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spMakeSpatial_options_+3A_xvar">xvar</code></td>
<td>
<p>String. Name of variable in xyplt defining x coordinate.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_yvar">yvar</code></td>
<td>
<p>String. Name of variable in xyplt defining y coordinate.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_xy.crs">xy.crs</code></td>
<td>
<p>PROJ.4 String or CRS object or Integer EPSG code defining
Coordinate Reference System. (e.g., EPSG:4269-Geodetic coordinate system for
North America, NAD83).</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_prj">prj</code></td>
<td>
<p>String. Projection, or coordinate system of the X/Y coordinates
(&quot;longlat&quot;, &quot;utm&quot;, &quot;aea&quot;). If other, include PROJ.4 string in prj4str.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_datum">datum</code></td>
<td>
<p>String. Datum of projection (&quot;WGS84&quot;, &quot;NAD83&quot;, &quot;NAD27&quot;).</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_zone">zone</code></td>
<td>
<p>Integer. If prj=&quot;utm&quot;, the UTM zone.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_zones">zoneS</code></td>
<td>
<p>Logical. If prj=&quot;utm&quot;, if the UTM zone is in the Southern
hemisphere.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_aea.param">aea.param</code></td>
<td>
<p>String. If prj=&quot;aea&quot;, the associated lat/lon parameters
(USGS: &quot; +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0&quot;).  If
other, include PROJ.4 string in prj4str.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spMakeSpatial_options()

</code></pre>

<hr>
<h2 id='strata_options'>Strata options.</h2><span id='topic+strata_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata_options(
  getwt = FALSE,
  getwtvar = "P1POINTCNT",
  strwtvar = "strwt",
  stratcombine = TRUE,
  minplotnum.strat = 2,
  pivot = FALSE,
  nonresp = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata_options_+3A_getwt">getwt</code></td>
<td>
<p>Logical. If TRUE, calculates strata weights from stratatlut
getwtvar.  If FALSE, strwtvar variable must be in stratalut.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_getwtvar">getwtvar</code></td>
<td>
<p>String. If getwt=TRUE, name of variable in stratalut to
calculate weights (Default = 'P1POINTCNT').</p>
</td></tr>
<tr><td><code id="strata_options_+3A_strwtvar">strwtvar</code></td>
<td>
<p>String. If getwt=FALSE, name of variable in stratalut with
calculated weights (Default = 'strwt').</p>
</td></tr>
<tr><td><code id="strata_options_+3A_stratcombine">stratcombine</code></td>
<td>
<p>Logical. If TRUE, and strata=TRUE, automatically combines
strata categories if less than minplotnum.strat plots in any one stratum. 
See notes for more info.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_minplotnum.strat">minplotnum.strat</code></td>
<td>
<p>Integer. Minimum number of plots for a stratum
within an estimation unit.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_pivot">pivot</code></td>
<td>
<p>Logical. If TRUE, pivot stratalut.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_nonresp">nonresp</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
strata_options(getwt = FALSE)

</code></pre>

<hr>
<h2 id='stunitco'>SpatialPolygonsDataFrame with FIA state, unit, county codes and names</h2><span id='topic+stunitco'></span>

<h3>Description</h3>

<p>Polygon feature class with state and county boundaries defined by Census
Bureau, including Federal Information Processing Standards (FIPS) codes. The
FIA Survey Unit code and name attributes (UNITCD, UNITNM) were appended to
dataset, with joining columns of STATECD and COUNTYCD.
</p>


<h3>Format</h3>

<p>A SpatialPolygonsDataFrame with 3233 features and 8 attributes RS -
FIA Research Station name RSCD - FIA Research Station code STATECD - FIPS
state code STATENM - FIPS state name STATEAB - FIPS state abbreviation
UNITCD - FIA survey unit code UNITNM - FIA survey unit name COUNTYCD - FIPS
county code COUNTYNM - FIPS county name
</p>


<h3>Details</h3>

<p>Derived from cb_2018_us_county_5m.  STATEFP was converted to numeric and
named STATECD COUNTYFP was converted to numeric and named COUNTYCD Lookup
table for FIA Research Station (REF_RESEARCH_STATION) was downloaded from
FIA DataMart on 20191105 (FIADB_1.6.1.00) and joined by STATECD. A lookup
table for UNITCD was created from plot data using unique STATECD, COUNTYCD,
UNITCD and joined to table.
</p>
<p>Converted to simple feature<br /> Transformed CRS from longlat(EPSG:4269) to
Albers (EPSG:5070)<br /> Saved to R object, with compression='xz'
</p>


<h3>Source</h3>

<p>Downloaded from the United States Census Bureau on 2019 November 3,
format Esri Shapefile
(https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html)
Projection: Geographic (GCS_North_American_1983) EPSG: 4269
</p>

<hr>
<h2 id='table_options'>Table aesthetics and output options.</h2><span id='topic+table_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for outputting
tables with custom aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_options(
  row.FIAname = FALSE,
  col.FIAname = FALSE,
  row.orderby = NULL,
  col.orderby = NULL,
  row.add0 = FALSE,
  col.add0 = FALSE,
  rowlut = NULL,
  collut = NULL,
  row.classify = NULL,
  col.classify = NULL,
  rawonly = FALSE,
  raw.keep0 = FALSE,
  rowgrp = FALSE,
  rowgrpnm = NULL,
  rowgrpord = NULL,
  totals = TRUE,
  allin1 = FALSE,
  metric = FALSE,
  estround = 1,
  pseround = 2,
  estnull = "--",
  psenull = "--",
  divideby = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_options_+3A_row.fianame">row.FIAname</code></td>
<td>
<p>Logical. If TRUE, retrieves default FIA reference names
for rowvar located in ref_codes data frame. Names are only available
for certain variables (Check sort(unique(ref_codes$VARIABLE)) for
available names.  If row.FIAname = TRUE and rowvar is in ref_codes,
the rowvar name is used for the output table, and the rowvar code is used to
sort.</p>
</td></tr>
<tr><td><code id="table_options_+3A_col.fianame">col.FIAname</code></td>
<td>
<p>Logical. If TRUE, retrieves default FIA reference names
for colvar located in ref_codes data frame. Names are only available
for certain variables. Check: sort(unique(ref_codes$VARIABLE)) for
available names.  If col.FIAname = TRUE and rowvar is in ref_codes,
the colvar name is used for the output table, and the colvar code is used to
sort.</p>
</td></tr>
<tr><td><code id="table_options_+3A_row.orderby">row.orderby</code></td>
<td>
<p>String. Optional. Name of variable to sort table rows.
Both the rowvar and row.orderby variables must be included in the same input
data.frame.  if NULL, and row.FIAname=FALSE or rowvar is not in
ref_codes, the rows are ordered by rowvar.</p>
</td></tr>
<tr><td><code id="table_options_+3A_col.orderby">col.orderby</code></td>
<td>
<p>String. Optional. Name of variable to sort table columns.
Both the colvar and col.orderby variables must be included in the same input
data.frame.  if NULL, and col.FIAname=FALSE or colvar is not in
ref_codes, the columns are ordered by colvar.</p>
</td></tr>
<tr><td><code id="table_options_+3A_row.add0">row.add0</code></td>
<td>
<p>Logical. If TRUE, include rows with 0 values to the output
table.</p>
</td></tr>
<tr><td><code id="table_options_+3A_col.add0">col.add0</code></td>
<td>
<p>Logical. If TRUE, include columns with 0 values to the
output table.</p>
</td></tr>
<tr><td><code id="table_options_+3A_rowlut">rowlut</code></td>
<td>
<p>Data frame. A lookup table with variable codes and code names
to include as rows of output table (See notes for more information and
format).</p>
</td></tr>
<tr><td><code id="table_options_+3A_collut">collut</code></td>
<td>
<p>Data frame. A lookup table with variable codes and code names
to include as columns of output table (See notes for more information and
format).</p>
</td></tr>
<tr><td><code id="table_options_+3A_row.classify">row.classify</code></td>
<td>
<p>Data frame (if categorical) or Vector (if continuous). 
If clasifying categories, input a dataframe with two columns ('FROM' and 'TO').
If classifying continuous values, input a vector of class breaks for row</p>
</td></tr>
<tr><td><code id="table_options_+3A_col.classify">col.classify</code></td>
<td>
<p>Data frame (if categorical) or Vector (if continuous). 
If clasifying categories, input a dataframe with two columns ('FROM' and 'TO').
If classifying continuous values, input a vector of class breaks for column</p>
</td></tr>
<tr><td><code id="table_options_+3A_rawonly">rawonly</code></td>
<td>
<p>Logical. If TRUE, only rawdata are output. If dataset
includes many estimation units, and only raw data tables are desired, it is
more efficient to output raw data only.</p>
</td></tr>
<tr><td><code id="table_options_+3A_raw.keep0">raw.keep0</code></td>
<td>
<p>Logical. If TRUE, keep 0 values in raw data tables.</p>
</td></tr>
<tr><td><code id="table_options_+3A_rowgrp">rowgrp</code></td>
<td>
<p>Logical. If TRUE, appends row groups to first column of table.
Only available if group category exists in ref_codes table or defined in
rowgrpnm (e.g., FORTYPGRPCD, OWNGRPCD).</p>
</td></tr>
<tr><td><code id="table_options_+3A_rowgrpnm">rowgrpnm</code></td>
<td>
<p>String. Name of variable for grouping rowvar. Variable must
be included in same input table as rowvar.</p>
</td></tr>
<tr><td><code id="table_options_+3A_rowgrpord">rowgrpord</code></td>
<td>
<p>String. Name of variable to sort row group variable.
Variable must be included in same input table as rowgrpnm.</p>
</td></tr>
<tr><td><code id="table_options_+3A_totals">totals</code></td>
<td>
<p>Logical. If TRUE, returns total estimate (mean * AREAUSED).</p>
</td></tr>
<tr><td><code id="table_options_+3A_allin1">allin1</code></td>
<td>
<p>Logical. If TRUE, both estimates and percent sample error are
output in one table as: estimates (percent sample error).</p>
</td></tr>
<tr><td><code id="table_options_+3A_metric">metric</code></td>
<td>
<p>Logical. If TRUE, output if returned in metric units.</p>
</td></tr>
<tr><td><code id="table_options_+3A_estround">estround</code></td>
<td>
<p>Integer. Number of decimal places for estimates.</p>
</td></tr>
<tr><td><code id="table_options_+3A_pseround">pseround</code></td>
<td>
<p>Integer. Number of decimal places for percent sampling
error.</p>
</td></tr>
<tr><td><code id="table_options_+3A_estnull">estnull</code></td>
<td>
<p>Number or character. The number or symbol to use to indicate
'not sampled' for estimate.</p>
</td></tr>
<tr><td><code id="table_options_+3A_psenull">psenull</code></td>
<td>
<p>Number or character. The number or symbol to use to indicate
'not sampled' for percent standard error.</p>
</td></tr>
<tr><td><code id="table_options_+3A_divideby">divideby</code></td>
<td>
<p>String. Conversion number for output ('hundred', 'thousand',
'million').</p>
</td></tr>
<tr><td><code id="table_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for outputting
tables with custom aesthetics.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
table_options(row.FIAname = TRUE, col.FIAname = TRUE)

</code></pre>

<hr>
<h2 id='title_options'>Title output options.</h2><span id='topic+title_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for outputting
title with custom aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>title_options(
  title.main = NULL,
  title.ref = NULL,
  title.rowvar = NULL,
  title.colvar = NULL,
  title.unitvar = NULL,
  title.estvar = NULL,
  title.estvarn = NULL,
  title.filter = NULL,
  title.units = "acres",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="title_options_+3A_title.main">title.main</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
the complete title used for table. If title.main=NULL, the title.*
parameters are used to generate title string. Note: if title.ref is not
NULL, it is added to title.main.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.ref">title.ref</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
the ending text of the table title (e.g., Nevada, 2004-2005). If NULL, = &quot;&quot;.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.rowvar">title.rowvar</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
pretty name for the row domain variable. If NULL, = rowvar.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.colvar">title.colvar</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
pretty name for the column domain variable. If NULL, = colvar.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.unitvar">title.unitvar</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or
returntitle=TRUE: pretty name for the estimation unit variable. If NULL, =
unitvar.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.estvar">title.estvar</code></td>
<td>
<p>String. TITLE: if savedata=TRUE and/or returntitle=TRUE:
pretty name for the estimate variable. If NULL, title.estvar = estvar.name.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.estvarn">title.estvarn</code></td>
<td>
<p>String. TITLE: if savedata=TRUE and/or returntitle=TRUE:
pretty name for the estimate variable. If NULL, title.estvar = estvar.name.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.filter">title.filter</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
pretty name for filter(s). If title.filter=NULL, a default is generated from
cfilter.  If title.filter=&quot;&quot;, no title.filter is used.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.units">title.units</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="title_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for outputting
titles with custom aesthetics.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
title_options(title.main = "My fancy title", title.estvar = "Estimate title")

</code></pre>

<hr>
<h2 id='unit_options'>Unit options.</h2><span id='topic+unit_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_options(
  unitvar2 = NULL,
  areaunits = "acres",
  minplotnum.unit = 10,
  unit.action = "keep",
  npixelvar = "npixels",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit_options_+3A_unitvar2">unitvar2</code></td>
<td>
<p>String. Name of a second level estimation unit variable in
unitarea and cond or pltassgn with assignment for each plot (e.g.,
'STATECD').</p>
</td></tr>
<tr><td><code id="unit_options_+3A_areaunits">areaunits</code></td>
<td>
<p>String. Units of areavar in unitarea ('acres', 'hectares').</p>
</td></tr>
<tr><td><code id="unit_options_+3A_minplotnum.unit">minplotnum.unit</code></td>
<td>
<p>Integer. Minimum number of plots for estimation unit.</p>
</td></tr>
<tr><td><code id="unit_options_+3A_unit.action">unit.action</code></td>
<td>
<p>String. What to do if number of plots in an estimation
unit is less than minplotnum.unit ('keep', 'remove' 'combine'). If
unit.action='keep', estimation units with less that minplotnum.unit will
be kept in output tables; if unit.action='remove', the estimation units 
with less that minplotnum.unit will be removed from the output tables; and
if unit.action='combine', combines estimation unit to the following estimation
unit, ordered in stratalut or unitzonal.</p>
</td></tr>
<tr><td><code id="unit_options_+3A_npixelvar">npixelvar</code></td>
<td>
<p>String. Name of variable in unitlut defining number of
pixels by estimation unit.</p>
</td></tr>
<tr><td><code id="unit_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
unit_options()

</code></pre>

<hr>
<h2 id='write2_desc'>Data Writing Functions</h2><span id='topic+write2_desc'></span><span id='topic+write2csv'></span><span id='topic+write2sqlite'></span>

<h3>Description</h3>

<p>These functions allow for data to be written to different formats. Currently,
supported formats are &quot;csv&quot; and &quot;sqlite&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write2csv(
  layer,
  outfile = NULL,
  outfolder = NULL,
  outfilenm = NULL,
  outfn.pre = NULL,
  outfn.date = FALSE,
  overwrite = FALSE,
  tabtitle = NULL,
  appendfile = FALSE,
  closefn = TRUE,
  outtxt = NULL,
  gui = FALSE
)

write2sqlite(
  layer,
  SQLitefn = NULL,
  out_name = NULL,
  gpkg = FALSE,
  outfolder = NULL,
  overwrite = FALSE,
  append_layer = FALSE,
  createnew = FALSE,
  dbconn = NULL,
  dbconnopen = FALSE,
  index.unique = NULL,
  index = NULL
)
</code></pre>


<h3>Details</h3>

<p>These functions allow for data to be written to different formats.
</p>


<h3>Value</h3>

<p>No return value, writes data to either a &quot;csv&quot; or &quot;sqlite&quot; file.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='xy_options'>List of population tables.</h2><span id='topic+xy_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for data 
xyuation (FIA or custom) extraction to be supplied to *DB functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy_options(
  xy.uniqueid = "CN",
  xvar = "LON",
  yvar = "LAT",
  xy.crs = 4269,
  xyjoinid = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xy_options_+3A_xy.uniqueid">xy.uniqueid</code></td>
<td>
<p>String. Unique identifier of xy.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_xvar">xvar</code></td>
<td>
<p>String. Name of variable in xy defining x coordinate.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_yvar">yvar</code></td>
<td>
<p>String. Name of variable in xy defining y coordinate.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_xy.crs">xy.crs</code></td>
<td>
<p>PROJ.4 String or CRS object or Integer EPSG code defining
Coordinate Reference System.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_xyjoinid">xyjoinid</code></td>
<td>
<p>String. Name of variable in xy to join to plot data. 
If NULL, xyjoinid = xy.uniqueid.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy_options(xvar="LON", yvar="LAT")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
