<!DOCTYPE html><html lang="en"><head><title>Help for package FIESTAutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FIESTAutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.update_refs'><p>Updates reference tables</p></a></li>
<li><a href='#check.numeric'><p>Check Functions</p></a></li>
<li><a href='#database_options'><p>Database options.</p></a></li>
<li><a href='#datExportData'><p>Spatial - Exports a data frame object.</p></a></li>
<li><a href='#datSum_options'><p>Options for summarizing tree data.</p></a></li>
<li><a href='#DBtestPostgreSQL'><p>Database - Test a PostgreSQL database.</p></a></li>
<li><a href='#DBtestSQLite'><p>Database - Checks access to a SQLite database.</p></a></li>
<li><a href='#DBvars.default'><p>General Utility Functions</p></a></li>
<li><a href='#eval_options'><p>List of population tables.</p></a></li>
<li><a href='#GBest.pbar'><p>Estimation Functions</p></a></li>
<li><a href='#GDT_NAMES'><p>Reference tables - gdal data types.</p></a></li>
<li><a href='#getDefaultNodata'><p>Raster Functions</p></a></li>
<li><a href='#kindcd3old'><p>Reference table - List of RMRS plots that have fallen out of inventory</p>
because they were not found or they were in the wrong place.</a></li>
<li><a href='#multest_options'><p>Multest output options.</p></a></li>
<li><a href='#pcheck.logical'><p>Parameter Check Functions</p></a></li>
<li><a href='#popFilters'><p>Population data filters.</p></a></li>
<li><a href='#popTableIDs'><p>List of population table unique IDs.</p></a></li>
<li><a href='#popTables'><p>List of population tables.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#ref_codes'><p>Reference tables - Code definitions.</p></a></li>
<li><a href='#ref_codes_archive'><p>Reference tables - Code definitions (Archive).</p></a></li>
<li><a href='#ref_cond'><p>Reference table - Metadata for cond default variables output from</p>
DBgetPlots()</a></li>
<li><a href='#ref_conversion'><p>Reference table - for conversion factors.</p></a></li>
<li><a href='#ref_diacl2in'><p>Reference table - diameter 2-inch class codes (DIA).</p></a></li>
<li><a href='#ref_domain'><p>Reference table - for generating tables.</p></a></li>
<li><a href='#ref_estimators'><p>Reference table - FIESTA estimators.</p></a></li>
<li><a href='#ref_estvar'><p>Reference table - for generating estimates</p></a></li>
<li><a href='#ref_evaltyp'><p>Reference table - for generating tables.</p></a></li>
<li><a href='#ref_plt'><p>Reference table - Metadata for plt default variables output from</p>
DBgetPlots()</a></li>
<li><a href='#ref_popType'><p>Reference table - popType codes.</p></a></li>
<li><a href='#ref_shp'><p>Reference table - Metadata for shp_* default variables output from</p>
DBgetPlots()</a></li>
<li><a href='#ref_species'><p>Reference table - Code definitions.</p></a></li>
<li><a href='#ref_statecd'><p>Reference table - state codes (STATECD).</p></a></li>
<li><a href='#ref_titles'><p>Reference table - Variable titles.</p></a></li>
<li><a href='#ref_tree'><p>Reference table - Metadata for tree default variables output from</p>
DBgetPlots()</a></li>
<li><a href='#ref_units'><p>Reference table - for variable units.</p></a></li>
<li><a href='#savedata_options'><p>Data saving options.</p></a></li>
<li><a href='#spatial_desc'><p>Spatial Data Functions</p></a></li>
<li><a href='#spMakeSpatial_options'><p>Make SpatialPoints options</p></a></li>
<li><a href='#strata_options'><p>Strata options.</p></a></li>
<li><a href='#stunitco'><p>SpatialPolygonsDataFrame with FIA state, unit, county codes and names</p></a></li>
<li><a href='#table_options'><p>Table aesthetics and output options.</p></a></li>
<li><a href='#tableIDs'><p>List of FIADB table unique IDs.</p></a></li>
<li><a href='#title_options'><p>Title output options.</p></a></li>
<li><a href='#unit_options'><p>Unit options.</p></a></li>
<li><a href='#write2_desc'><p>Data Writing Functions</p></a></li>
<li><a href='#xy_options'><p>List of population tables.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utility Functions for Forest Inventory Estimation and Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-28</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools for data wrangling, spatial data analysis,
    statistical modeling (including direct, model-assisted, photo-based, and
    small area tools), and USDA Forest Service data base tools. These tools are
    aimed to help Foresters, Analysts, and Scientists extract and perform
    analyses on USDA Forest Service data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, DBI, gdalraster, graphics, hbsae, JoSAE, mase,
methods, nlme, Rcpp, RColorBrewer, RPostgres, RSQLite, sae, sf,
sqldf, stats, terra, units, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>See file COPYRIGHTS for details.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/USDAForestService/FIESTAutils">https://github.com/USDAForestService/FIESTAutils</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/USDAForestService/FIESTAutils/issues">https://github.com/USDAForestService/FIESTAutils/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-29 04:22:16 UTC; graysonwhite</td>
</tr>
<tr>
<td>Author:</td>
<td>Tracey Frescino [aut],
  Chris Toney [aut],
  Grayson White [aut, cre],
  Joshua Yamamoto [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Grayson White &lt;graysonwhite13@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-29 05:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='.update_refs'>Updates reference tables</h2><span id='topic+.update_refs'></span>

<h3>Description</h3>

<p>Updates reference tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.update_refs(write = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".update_refs_+3A_write">write</code></td>
<td>
<p>Logical. Should the internal reference tables be overwritten?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Called for side effects.
</p>


<h3>Author(s)</h3>

<p>Josh Yamamoto
</p>

<hr>
<h2 id='check.numeric'>Check Functions</h2><span id='topic+check.numeric'></span><span id='topic+check.logic.vars'></span><span id='topic+check.logic'></span><span id='topic+check.matchclass'></span><span id='topic+check.matchval'></span><span id='topic+check.unique'></span><span id='topic+checks_desc'></span><span id='topic+checkfilenm'></span><span id='topic+checknm'></span><span id='topic+check.namedlist'></span>

<h3>Description</h3>

<p>Check functions for objects of class numeric, logical statements,
class matching, value matching, file names, names, and named lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.numeric(x)

check.logic.vars(varlst, statement, ignore.case = FALSE, returnVars = FALSE)

check.logic(
  x,
  statement,
  filternm = NULL,
  stopifnull = FALSE,
  stopifinvalid = TRUE,
  removeinvalid = FALSE,
  syntax = "R",
  returnvar = FALSE,
  returnpart = FALSE
)

check.matchclass(
  tab1,
  tab2,
  matchcol,
  var2 = NULL,
  tab1txt = NULL,
  tab2txt = NULL
)

check.matchval(
  tab1,
  tab2,
  var1,
  var2 = NULL,
  tab1txt = NULL,
  tab2txt = NULL,
  gui = FALSE,
  stopifmiss = FALSE,
  subsetrows = FALSE
)

check.unique(x, xvar, uniquex, NAname = "Other", addfactors = TRUE)

checkfilenm(fn, outfolder = NULL, ext = NULL, stopifnull = FALSE)

checknm(nm, nmlst, ignore.case = TRUE)

check.namedlist(xlst, checknms = NULL, modetype = "numeric")
</code></pre>


<h3>Details</h3>

<p>These functions are used to check if a vector is numeric with check.numeric,
to check a logical statement with check.logic, to check if two objects' 
classes match, to check it two object's values match, to check file names,
to check names, and finally, to check named lists.
</p>


<h3>Value</h3>

<p>The object who was checked, with necessary changes made for the object to
pass the check (i.e. character vector to numeric vector).
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='database_options'>Database options.</h2><span id='topic+database_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for database access.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>database_options(
  dbname = NULL,
  host = NULL,
  port = NULL,
  user = NULL,
  password = NULL,
  schema = NULL,
  dbconnopen = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="database_options_+3A_dbname">dbname</code></td>
<td>
<p>String. Name of database.</p>
</td></tr>
<tr><td><code id="database_options_+3A_host">host</code></td>
<td>
<p>String. Name of database host.</p>
</td></tr>
<tr><td><code id="database_options_+3A_port">port</code></td>
<td>
<p>String. Database port.</p>
</td></tr>
<tr><td><code id="database_options_+3A_user">user</code></td>
<td>
<p>String. User name for database access.</p>
</td></tr>
<tr><td><code id="database_options_+3A_password">password</code></td>
<td>
<p>String. Password for database access.</p>
</td></tr>
<tr><td><code id="database_options_+3A_schema">schema</code></td>
<td>
<p>String. Name of schema in database.</p>
</td></tr>
<tr><td><code id="database_options_+3A_dbconnopen">dbconnopen</code></td>
<td>
<p>Logical. If TRUE, keep database connection open.</p>
</td></tr>
<tr><td><code id="database_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for saving data.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
savedata_options(outfolder = "path", overwrite_dsn = FALSE)

</code></pre>

<hr>
<h2 id='datExportData'>Spatial - Exports a data frame object.</h2><span id='topic+datExportData'></span>

<h3>Description</h3>

<p>Exports a data frame object to a specified output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datExportData(
  dfobj,
  create_dsn = FALSE,
  index.unique = NULL,
  index = NULL,
  lowernames = FALSE,
  savedata_opts = savedata_options(),
  dbconn = NULL,
  dbconnopen = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="datExportData_+3A_dfobj">dfobj</code></td>
<td>
<p>Data.frame class R object. Data frame object to export.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_create_dsn">create_dsn</code></td>
<td>
<p>Boolean.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_index.unique">index.unique</code></td>
<td>
<p>String. Name of variable(s) in dfobj to make unique
index.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_index">index</code></td>
<td>
<p>String. Name of variable(s) in dfobj to make (non-unique)
index.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_lowernames">lowernames</code></td>
<td>
<p>Logical. If TRUE, convert column names to lowercase 
before writing to output.
dbconnopen Logical. If TRUE, keep database connection open.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_savedata_opts">savedata_opts</code></td>
<td>
<p>List. See help(savedata_options()) for a list
of options.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_dbconn">dbconn</code></td>
<td>
<p>Open database connection.</p>
</td></tr>
<tr><td><code id="datExportData_+3A_dbconnopen">dbconnopen</code></td>
<td>
<p>Logical. If TRUE, keep database connection open.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wrapper for sf::st_write function.
</p>


<h3>Value</h3>

<p>An sf spatial object is written to the out_dsn.
</p>


<h3>Note</h3>

<p>If out_fmt='shp':<br /> The ESRI shapefile driver truncates variable
names to 10 characters or less.  Variable names are changed before export
using an internal function (trunc10shp). Name changes are output to the
outfolder, 'outshpnm'_newnames.csv.
</p>
<p>If sf object has more than 1 record, it cannot be exported to a shapefile.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='datSum_options'>Options for summarizing tree data.</h2><span id='topic+datSum_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for 
summarizing tree data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datSum_options(
  lbs2tons = TRUE,
  metric = FALSE,
  tround = 5,
  TPA = TRUE,
  adjTPA = 1,
  ACI = FALSE,
  adjtree = FALSE,
  adjvar = "tadjfac",
  NAto0 = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="datSum_options_+3A_lbs2tons">lbs2tons</code></td>
<td>
<p>Logical. If TRUE, converts biomass or carbon variables from
pounds to tons (1 pound = 0.0005 short tons). If metric=TRUE, converts to  
metric tons, else short tons.</p>
</td></tr>
<tr><td><code id="datSum_options_+3A_metric">metric</code></td>
<td>
<p>Logical. If TRUE, converts response to metric units based on
ref_conversion, if any variable in tsumvarlst is in
FIESTAutils::ref_estvar.  Note: if TPA, TPA is converted to trees per hectare
(TPH: (1/ tpavar * 0.4046860)).</p>
</td></tr>
<tr><td><code id="datSum_options_+3A_tround">tround</code></td>
<td>
<p>Number. The number of digits to round to. If NULL, default=5.</p>
</td></tr>
<tr><td><code id="datSum_options_+3A_tpa">TPA</code></td>
<td>
<p>Logical. If TRUE, tsumvarlst variable(s) are multiplied by the
respective trees-per-acre variable (see details) to get per-acre
measurements.</p>
</td></tr>
<tr><td><code id="datSum_options_+3A_adjtpa">adjTPA</code></td>
<td>
<p>Numeric. A tree-per-acre adjustment. Use for DESIGNCD=1
(annual inventory), if using less than 4 subplots. If using only 1 subplot
for estimate, adjTPA=4. The default is 1.</p>
</td></tr>
<tr><td><code id="datSum_options_+3A_aci">ACI</code></td>
<td>
<p>Logical. If TRUE, if ACI (All Condition Inventory) plots exist,
any trees on these plots will be included in summary. If FALSE, you must
include condition table.</p>
</td></tr>
<tr><td><code id="datSum_options_+3A_adjtree">adjtree</code></td>
<td>
<p>Logical. If TRUE, trees are individually adjusted by
adjustment factors.  Adjustment factors must be included in tree table (see
adjvar).</p>
</td></tr>
<tr><td><code id="datSum_options_+3A_adjvar">adjvar</code></td>
<td>
<p>String. If adjtree=TRUE, the name of the variable to use for
multiplying by adjustment (e.g., tadjfac).</p>
</td></tr>
<tr><td><code id="datSum_options_+3A_nato0">NAto0</code></td>
<td>
<p>Logical. If TRUE, change NA values to 0</p>
</td></tr>
<tr><td><code id="datSum_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for 
summarizing tree data.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
datSum_options(lbs2tons = TRUE, metric = TRUE)

</code></pre>

<hr>
<h2 id='DBtestPostgreSQL'>Database - Test a PostgreSQL database.</h2><span id='topic+DBtestPostgreSQL'></span>

<h3>Description</h3>

<p>Checks a PostgreSQL database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBtestPostgreSQL(
  dbname = NULL,
  host = NULL,
  port = NULL,
  user = NULL,
  password = NULL,
  dbconnopen = FALSE,
  showlist = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DBtestPostgreSQL_+3A_dbname">dbname</code></td>
<td>
<p>String. Name of the database on the host.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_host">host</code></td>
<td>
<p>String. Host name.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_port">port</code></td>
<td>
<p>String. Port number.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_user">user</code></td>
<td>
<p>String. User name.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_password">password</code></td>
<td>
<p>String. Password.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_dbconnopen">dbconnopen</code></td>
<td>
<p>Logical. If TRUE, the database connection is returned and not closed.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_showlist">showlist</code></td>
<td>
<p>Logical. If TRUE, prints list of tables in database.</p>
</td></tr>
<tr><td><code id="DBtestPostgreSQL_+3A_...">...</code></td>
<td>
<p>Additional authentication arguments passed to DBI::dbConnect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object that inherits from DBIConnection via the DBI package if
dbconnopen = TRUE, or NULL otherwise. 
For more information, see 'help(DBI::dbConnect)'.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='DBtestSQLite'>Database - Checks access to a SQLite database.</h2><span id='topic+DBtestSQLite'></span>

<h3>Description</h3>

<p>Checks a SQLite database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBtestSQLite(
  SQLitefn = NULL,
  gpkg = FALSE,
  dbconnopen = FALSE,
  outfolder = NULL,
  showlist = TRUE,
  returnpath = TRUE,
  createnew = TRUE,
  stopifnull = FALSE,
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DBtestSQLite_+3A_sqlitefn">SQLitefn</code></td>
<td>
<p>String. Name of SQLite database (*.sqlite).</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_gpkg">gpkg</code></td>
<td>
<p>Logical. If TRUE, Sqlite geopackage database.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_dbconnopen">dbconnopen</code></td>
<td>
<p>Logical. If TRUE, the dbconn connection is not closed.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_outfolder">outfolder</code></td>
<td>
<p>String. Optional. Name of output folder. If NULL, export to
working directory.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_showlist">showlist</code></td>
<td>
<p>Logical. If TRUE, shows list of tables in database.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_returnpath">returnpath</code></td>
<td>
<p>Logical. If TRUE, returns full path to SQLite file name.
If FALSE, returns SQLitefn.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_createnew">createnew</code></td>
<td>
<p>If TRUE, creates new SQLite database.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_stopifnull">stopifnull</code></td>
<td>
<p>Logical. If TRUE, stops if SQLite database doesn't exist.</p>
</td></tr>
<tr><td><code id="DBtestSQLite_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. If TRUE, overwrites data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string containing the path to the SQLite database of
interest.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='DBvars.default'>General Utility Functions</h2><span id='topic+DBvars.default'></span><span id='topic+DBgetfn'></span><span id='topic+getspconddat'></span><span id='topic+getpfromqry'></span><span id='topic+getpwithqry'></span><span id='topic+getEvalid.ppsa'></span><span id='topic+getPlotCur'></span><span id='topic+gui_filterdf'></span><span id='topic+DBgetbyids'></span><span id='topic+DBcreateSQLite'></span><span id='topic+changeclass'></span><span id='topic+customEvalchk'></span><span id='topic+checkidx'></span><span id='topic+createidx'></span><span id='topic+dbclassify'></span><span id='topic+dbclass'></span><span id='topic+getwithqry'></span><span id='topic+Ratio2Size'></span><span id='topic+addCI'></span><span id='topic+change10char'></span><span id='topic+check.pltcnt'></span><span id='topic+RtoSQL'></span><span id='topic+getext'></span><span id='topic+getoutfn'></span><span id='topic+addcommas'></span><span id='topic+pastevars'></span><span id='topic+stopQ'></span><span id='topic+removecols'></span><span id='topic+DT_NAto0'></span><span id='topic+changeNULL'></span><span id='topic+getdups'></span><span id='topic+getlistparam'></span><span id='topic+getnm'></span><span id='topic+capfirst'></span><span id='topic+nbrdecimals'></span><span id='topic+nbrdigits'></span><span id='topic+getfilter'></span><span id='topic+filter2qry'></span><span id='topic+wraptitle'></span><span id='topic+xtabf'></span><span id='topic+recodelut'></span><span id='topic+findnm'></span><span id='topic+chkdbtab'></span><span id='topic+int64tochar'></span><span id='topic+messagedf'></span><span id='topic+getSPGRPCD'></span><span id='topic+addFORTYPGRPCD'></span><span id='topic+date2char'></span><span id='topic+checklevels'></span><span id='topic+strat.pivot'></span><span id='topic+makedummy'></span><span id='topic+preds.standardize'></span><span id='topic+gregEN.select'></span><span id='topic+preds.select'></span><span id='topic+fileexistsnm'></span><span id='topic+getEvalid'></span><span id='topic+getRefcodes'></span><span id='topic+getRefobject'></span><span id='topic+getadjfactorDWM'></span><span id='topic+getadjfactorGB'></span><span id='topic+getadjfactorP2VEG'></span><span id='topic+getadjfactorPLOT'></span><span id='topic+getadjfactorVOL'></span><span id='topic+getfunnm'></span><span id='topic+getlt10char'></span><span id='topic+getpse'></span><span id='topic+getrhat'></span><span id='topic+groupClasses'></span><span id='topic+groupEstunit'></span><span id='topic+groupStrata'></span><span id='topic+groupUnits'></span><span id='topic+internal_desc'></span><span id='topic+getjoinqry'></span><span id='topic+classqry'></span><span id='topic+classifyqry'></span><span id='topic+getcombineqry'></span><span id='topic+save1tab'></span><span id='topic+save2tabs'></span><span id='topic+strat.collapse'></span><span id='topic+subpsamp'></span><span id='topic+subpsampP2VEG'></span><span id='topic+allin1f'></span><span id='topic+crosstabx'></span><span id='topic+add0unit'></span><span id='topic+addrowgrp'></span><span id='topic+crossxtab'></span><span id='topic+getdomain'></span><span id='topic+getestvar'></span><span id='topic+crossxbyunit'></span><span id='topic+ptdata2sf'></span><span id='topic+sf2ptdata'></span><span id='topic+layerIntersection'></span><span id='topic+layerUnion'></span><span id='topic+tabulateIntersections'></span><span id='topic+selectByIntersects'></span><span id='topic+layerFromRasterExtent'></span><span id='topic+wtcalc'></span><span id='topic+wtcalc.unit'></span>

<h3>Description</h3>

<p>These functions provide a wide-range of general utility for a variety of
data types. They were developed by the FIESTA development team and solve 
many general and specific problems for data analysis in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBvars.default(
  istree = FALSE,
  isseed = FALSE,
  isveg = FALSE,
  isgrm = FALSE,
  isdwm = FALSE,
  issubp = FALSE,
  regionVars = FALSE,
  plotgeom = FALSE,
  regionVarsRS = "RMRS",
  iscwd = FALSE
)

DBgetfn(
  tab,
  invtype,
  outfn.pre,
  stabbrlst = NULL,
  evalid = NULL,
  qry = FALSE,
  othertxt = NULL,
  outfn.date = FALSE,
  addslash = FALSE,
  ext = "csv",
  outfolder = NULL,
  overwrite = FALSE
)

getspconddat(
  cond = NULL,
  ACTUALcond = NULL,
  cuniqueid = "PLT_CN",
  condid1 = FALSE,
  ACI = FALSE
)

getpfromqry(
  dsn = NULL,
  evalid = NULL,
  plotCur = TRUE,
  pjoinid,
  varCur = "MEASYEAR",
  Endyr = NULL,
  invyrs = NULL,
  allyrs = FALSE,
  SCHEMA. = NULL,
  subcycle99 = NULL,
  designcd1 = FALSE,
  intensity1 = NULL,
  popSURVEY = FALSE,
  chk = FALSE,
  Type = "VOL",
  syntax = "sql",
  plotnm = "plot",
  ppsanm = "pop_plot_stratum_assgn",
  ppsaid = "PLT_CN",
  surveynm = "survey",
  plotobj = NULL,
  dbconn = NULL,
  dbconnopen = TRUE
)

getpwithqry(
  dsn = NULL,
  evalid = NULL,
  states = NULL,
  pjoinid,
  plotCur = FALSE,
  varCur = "MEASYEAR",
  Endyr = NULL,
  invyrs = NULL,
  measyears = NULL,
  allyrs = FALSE,
  SCHEMA. = NULL,
  invtype = "ANNUAL",
  subcycle99 = FALSE,
  designcd1 = FALSE,
  intensity = NULL,
  popSURVEY = FALSE,
  chk = FALSE,
  Type = "VOL",
  syntax = "sql",
  plotnm = "plot",
  ppsanm = "pop_plot_stratum_assgn",
  ppsaid = "PLT_CN",
  surveynm = "survey",
  PLOTdf = NULL,
  pltflds = NULL,
  POP_PLOT_STRATUM_ASSGNdf = NULL,
  ppsaflds = NULL,
  pvars = NULL,
  dbconn = NULL,
  dbconnopen = TRUE,
  withqry2 = FALSE
)

getEvalid.ppsa(
  ppsa,
  states = NULL,
  evalAll = FALSE,
  evalCur = FALSE,
  evalEndyr = NULL,
  evalType = "VOL"
)

getPlotCur(
  pltx,
  Endyr = NULL,
  varCur = "MEASYEAR",
  Endyr.filter = NULL,
  designcd1 = TRUE
)

gui_filterdf(df, byname = TRUE)

DBgetbyids(dbconn, ids, layernm, layerid = "PLT_CN")

DBcreateSQLite(
  SQLitefn = NULL,
  gpkg = FALSE,
  dbconnopen = FALSE,
  outfolder = NULL,
  outfn.pre = NULL,
  outfn.date = FALSE,
  overwrite = FALSE,
  returnpath = TRUE,
  stopifnull = FALSE
)

changeclass(tab, noIDate = TRUE)

customEvalchk(
  states,
  measCur = TRUE,
  measEndyr = NULL,
  measEndyr.filter = NULL,
  allyrs = FALSE,
  invyrs = NULL,
  measyrs = NULL,
  invyrtab = NULL,
  gui = FALSE
)

checkidx(
  dbconn,
  tbl = NULL,
  index_cols = NULL,
  datsource = "sqlite",
  schema = "FS_FIADB",
  dbconnopen = TRUE
)

createidx(
  dbconn,
  schema = NULL,
  tbl,
  index_cols,
  unique = FALSE,
  dbconnopen = TRUE
)

dbclassify(
  dbconn,
  tabnm,
  classcol,
  cutbreaks,
  cutlabels,
  classnm = NULL,
  overwrite = TRUE,
  NAto0 = FALSE,
  dbconnopen = TRUE,
  quiet = FALSE
)

dbclass(
  dbconn,
  tabnm,
  classcol,
  classvals,
  classlabels,
  classnm = NULL,
  overwrite = TRUE,
  NAto0 = FALSE,
  dbconnopen = TRUE,
  quiet = FALSE
)

getwithqry(
  dsn = NULL,
  evalid = NULL,
  states = NULL,
  pjoinid,
  plotCur = FALSE,
  varCur = "MEASYEAR",
  Endyr = NULL,
  invyrs = NULL,
  measyears = NULL,
  allyrs = FALSE,
  SCHEMA. = NULL,
  invtype = "ANNUAL",
  subcycle99 = FALSE,
  designcd1 = FALSE,
  intensity1 = FALSE,
  popSURVEY = FALSE,
  chk = FALSE,
  Type = "VOL",
  syntax = "sql",
  plotnm = "plot",
  ppsanm = "pop_plot_stratum_assgn",
  ppsaid = "PLT_CN",
  surveynm = "survey",
  PLOTdf = NULL,
  pltflds = NULL,
  POP_PLOT_STRATUM_ASSGNdf = NULL,
  ppsaflds = NULL,
  pvars = NULL,
  dbconn = NULL,
  dbconnopen = TRUE,
  withqry2 = FALSE
)

Ratio2Size(
  yn,
  y2n = NULL,
  yd,
  y2d = NULL,
  ysum,
  dsum,
  uniqueid,
  esttype,
  ratiotype,
  stratalut,
  RHGlut,
  unitvar,
  strvar,
  domain
)

addCI(x, estnm, senm = NULL, conf.level = c(99, 95, 68), gainloss = FALSE)

change10char(xnms)

check.pltcnt(
  pltx,
  puniqueid = NULL,
  unitlut,
  unitvars = NULL,
  strvars = NULL,
  savedata = FALSE,
  outfolder = NULL,
  outfn = NULL,
  overwrite = FALSE,
  outfn.date = TRUE,
  outfn.pre = NULL,
  minplotnum.unit = 10,
  minplotnum.strat = 2,
  gui = FALSE,
  stopiferror = FALSE,
  showwarnings = TRUE
)

RtoSQL(filter, x = NULL)

getext(x)

getoutfn(
  outfn,
  outfolder = NULL,
  outfn.pre = NULL,
  outfn.date = FALSE,
  overwrite = FALSE,
  ext = NULL,
  baseonly = FALSE,
  noext = FALSE,
  outfn.default = "outfile",
  add = TRUE,
  append = FALSE,
  gui = FALSE
)

addcommas(vars, ALIAS = NULL, sepchar = ",", quotes = FALSE, paren = FALSE)

pastevars(vars1, vars2, sep = ",")

stopQ()

removecols(x, vars)

DT_NAto0(DT, cols, changeto = 0)

changeNULL(x, xvar, changeto = NULL)

getdups(cx, cuniqueid = "PLT_CN", varnm, fun)

getlistparam(lst)

getnm(xvar, group = FALSE)

capfirst(x, allwords = FALSE)

nbrdecimals(x)

nbrdigits(x)

getfilter(att, val, syntax = "R", quote = FALSE, like = FALSE)

filter2qry(filt, layernm)

wraptitle(x, len = 10)

xtabf(x, y, levels)

recodelut(lut, minvar = "min", maxvar = "max", classvar = "class")

findnm(x, xvect, returnNULL = FALSE)

chkdbtab(dbtablst, tab, stopifnull = FALSE)

int64tochar(df)

messagedf(df)

getSPGRPCD(states)

addFORTYPGRPCD(cond)

date2char(df, col, formatstr = "%Y-%m-%d")

checklevels(x, uniquex, xvar, keepNA = TRUE)

getext(x)

filter2qry(filt, layernm)

recodelut(lut, minvar = "min", maxvar = "max", classvar = "class")

strat.pivot(x, strvar, unitvars, strwtvar = "Prop", strat.levels = NULL)

makedummy(dat, auxlut, predfac)

preds.standardize(plt, aux, prednames)

gregEN.select(
  y,
  x_sample,
  x_pop,
  N,
  alpha = 0.5,
  returncoef = FALSE,
  cvfolds = 10
)

preds.select(y, plt, auxlut, prednames, cvfolds = 10)

fileexistsnm(outfolder, basenm, ext)

getEvalid(
  states = NULL,
  RS = NULL,
  evalCur = TRUE,
  evalEndyr = NULL,
  evalid = NULL,
  evalAll = FALSE,
  evalType = "VOL",
  dbconn = NULL,
  schema = NULL,
  dbconnopen = FALSE
)

getRefcodes(xvar)

getRefobject(xvar)

getadjfactorDWM(
  adj = "samp",
  condx,
  cuniqueid = "PLT_CN",
  condid = "CONDID",
  unitlut = NULL,
  unitvars = NULL,
  strvars = NULL,
  unitarea = NULL,
  areavar = NULL,
  areawt = "SUBP_CONDPROP_UNADJ",
  dwmpropvars = NULL
)

getadjfactorGB(
  condx = NULL,
  treex = NULL,
  seedx = NULL,
  vcondsppx = NULL,
  vcondstrx = NULL,
  cond_dwm_calcx = NULL,
  tuniqueid = "PLT_CN",
  cuniqueid = "PLT_CN",
  vuniqueid = "PLT_CN",
  duniqueid = "PLT_CN",
  condid = "CONDID",
  unitlut = NULL,
  unitvars = NULL,
  strvars = NULL,
  unitarea = NULL,
  areavar = NULL,
  areawt = "CONDPROP_UNADJ",
  cvars2keep = NULL,
  tpropvars = list(SUBP = "SUBPPROP_UNADJ", MICR = "MICRPROP_UNADJ", MACR =
    "MACRPROP_UNADJ")
)

getadjfactorP2VEG(
  adj = "samp",
  condx,
  vcondsppx = NULL,
  vcondstrx = NULL,
  cuniqueid = "PLT_CN",
  vuniqueid = "PLT_CN",
  condid = "CONDID",
  unitlut = NULL,
  unitvars = NULL,
  strvars = NULL,
  unitarea = NULL,
  areavar = NULL,
  areawt = "SUBP_CONDPROP_UNADJ",
  cvars2keep = NULL
)

getadjfactorPLOT(
  condx = NULL,
  treex = NULL,
  seedx = NULL,
  cuniqueid = "PLT_CN",
  tuniqueid = "PLT_CN",
  condid = "CONDID",
  checkNA = TRUE,
  areawt = "CONDPROP_UNADJ",
  tpropvars = list(SUBP = "SUBPPROP_UNADJ", MICR = "MICRPROP_UNADJ", MACR =
    "MACRPROP_UNADJ")
)

getadjfactorVOL(
  adj = adj,
  condx = NULL,
  treex = NULL,
  seedx = NULL,
  tuniqueid = "PLT_CN",
  cuniqueid = "PLT_CN",
  condid = "CONDID",
  unitlut = NULL,
  unitvars = NULL,
  strvars = NULL,
  unitarea = NULL,
  areavar = NULL,
  areawt = "CONDPROP_UNADJ",
  cvars2keep = NULL,
  cpropvars = list(SUBP = "SUBPPROP_UNADJ", MACR = "MACRPROP_UNADJ"),
  tpropvars = list(SUBP = "SUBPPROP_UNADJ", MACR = "MACRPROP_UNADJ", MICR =
    "MICRPROP_UNADJ"),
  keepadjvars = FALSE,
  adjvars = NULL
)

getfunnm(x)

getlt10char(dbname)

getpse(
  xdat,
  esttype = "AREA",
  areavar = NULL,
  nhatcol = "nhat",
  nhatcol.var = "nhat.var",
  dhatcol = "dhat",
  dhatcol.var = "dhat.var"
)

getrhat(x)

groupClasses(x, minplotnum, nvar, xvar, sumvar = "n.strata", xvarlevels = NULL)

groupEstunit(x, minplotnum)

groupStrata(
  x,
  minplotnum,
  nvar = "n.strata",
  strvar = NULL,
  stratalevels = NULL
)

groupUnits(
  tabest,
  domain,
  esttype = "AREA",
  estncol = "estn",
  estncol.var = "estn.var",
  estdcol = "estd",
  estdcol.var = "estd.var",
  covarcol = "covar",
  grpfun = sum,
  domvar2 = NULL,
  rowgrpnm = NULL,
  unitvar = NULL,
  areavar = NULL,
  phototype = "PCT",
  photoratio = FALSE,
  keepvars = NULL
)

getjoinqry(joinid1, joinid2 = NULL, alias1 = "p.", alias2 = "plta.")

classqry(
  classcol,
  fromval,
  toval,
  classnm = NULL,
  class. = NULL,
  prefixnm = NULL,
  fill = NULL
)

classifyqry(
  classcol,
  cutbreaks,
  cutlabels = NULL,
  classnm = NULL,
  class. = NULL,
  prefixnm = NULL,
  fill = NULL
)

getcombineqry(lut, unitvars, classcols, fromcols, tocols, tab. = "")

save1tab(
  tab,
  tab.title = NULL,
  outfolder,
  allin1 = TRUE,
  coltitlerow = TRUE,
  coltitle = NULL,
  addtitle = TRUE,
  rowtotal = TRUE,
  rnames = NULL,
  outfn = NULL,
  addformat = TRUE,
  charvars = NULL,
  outfn.date = TRUE,
  overwrite = FALSE,
  cols2format = NULL
)

save2tabs(
  tab1,
  tab2,
  tab1.title,
  tab2.title,
  outfolder,
  coltitlerow = TRUE,
  coltitle = NULL,
  addtitle = TRUE,
  rowtotal = TRUE,
  rnames = NULL,
  outfn.estpse = NULL,
  outfn.date = TRUE,
  overwrite = FALSE
)

strat.collapse(
  stratacnt,
  pltstratx,
  minplotnum.unit = 10,
  minplotnum.strat = 2,
  unitarea,
  areavar,
  unitvar,
  unitvar2 = NULL,
  strvar,
  getwt = FALSE,
  stratcombine = TRUE,
  unitcombine = FALSE,
  stratalevels = NULL,
  vars2combine = NULL,
  UNITCD = NULL,
  ...
)

subpsamp(
  cond,
  subp_cond,
  subplot,
  data_dsn = NULL,
  subpuniqueid = "PLT_CN",
  subpid = "SUBP",
  ACI = FALSE,
  whereqry = NULL
)

subpsampP2VEG(
  plt,
  cond,
  subp_cond,
  subplot,
  data_dsn = NULL,
  subpuniqueid = "PLT_CN",
  subpid = "SUBP",
  ACI = FALSE,
  whereqry = NULL
)

allin1f(
  x,
  y,
  char.width = NULL,
  estnull = "--",
  psenull = "--",
  estround = NULL,
  pseround = NULL
)

crosstabx(
  x,
  xvar,
  estnm,
  psenm,
  allin1 = FALSE,
  char.width = NULL,
  estround = NULL,
  pseround = NULL,
  estnull = "--",
  psenull = "--"
)

add0unit(
  x,
  xvar,
  uniquex,
  unitvar = NULL,
  xvar.add0 = FALSE,
  xvar2 = NULL,
  uniquex2 = NULL,
  xvar2.add0 = FALSE
)

addrowgrp(x, uniquerow, rowvar, rowgrpnm, title.rnames = NULL)

crossxtab(
  group.est,
  rowvar.est = NULL,
  colvar.est = NULL,
  total.est = NULL,
  rowvar,
  colvar,
  estnm,
  psenm,
  estround = NULL,
  pseround = NULL,
  gtotal = TRUE,
  allin1 = FALSE,
  rowgrp = FALSE,
  rowgrpnm = NULL,
  title.rnames = NULL,
  estnull = 0,
  psenull = "--",
  char.width = NULL
)

getdomain()

getestvar()

crossxbyunit(
  unit = NULL,
  unit_grpest = NULL,
  unit_rowest = NULL,
  unit_colest = NULL,
  unit_totest = NULL,
  unitvar,
  rowvar,
  colvar,
  estnm,
  psenm,
  allin1,
  char.width,
  estnull,
  psenull,
  estround = NULL,
  pseround = NULL,
  rowgrp = NULL,
  rowgrpnm = NULL,
  title.rnames = NULL,
  numunits,
  savedata,
  addtitle,
  returntitle,
  outfn.estpse,
  title.estpse,
  title.est,
  title.pse,
  title.ref,
  outfolder,
  outfn.date,
  overwrite,
  esttype,
  phototype,
  rnames = NULL,
  title.colvar = NULL,
  title.unitvar = NULL
)

ptdata2sf(
  ptdata,
  crs,
  coords = c(2, 3),
  asSpatial = FALSE,
  stringsAsFactors = FALSE
)

sf2ptdata(ptlayer, id_fld = 1, stringsAsFactors = FALSE)

layerIntersection(
  layer1,
  layer2,
  asSpatial = FALSE,
  dropLowerDimGeom = TRUE,
  stringsAsFactors = FALSE
)

layerUnion(
  layer1,
  layer2,
  asSpatial = FALSE,
  dropLowerDimGeom = TRUE,
  sfColName = "geometry",
  stringsAsFactors = FALSE
)

tabulateIntersections(
  layer1,
  layer1fld,
  layer2,
  layer2fld = NULL,
  stringsAsFactors = FALSE,
  withUnits = FALSE
)

selectByIntersects(
  layer1,
  layer2,
  overlapThreshold = 0,
  thresholdAsPct = TRUE,
  asSpatial = FALSE,
  stringsAsFactors = FALSE
)

layerFromRasterExtent(rasterfile, asSpatial = FALSE)

wtcalc(wtLUT, strvar, acrevar)

wtcalc.unit(wtLUT, strvar, unit, unitvar, acrevar)
</code></pre>


<h3>Details</h3>

<p>These functions provide a wide-range of general utility for a variety of
data types.
</p>


<h3>Value</h3>

<p>Object for internal use by other functions in FIESTAutils or other packages
used for USDA Forest Service data analysis.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino, Chris Toney, Grayson W. White
</p>

<hr>
<h2 id='eval_options'>List of population tables.</h2><span id='topic+eval_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for data 
evaluation (FIA or custom) extraction to be supplied to *DB functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_options(
  Cur = FALSE,
  Endyr = NULL,
  Endyr.filter = NULL,
  All = FALSE,
  Type = "VOL",
  evalid = NULL,
  invyrs = NULL,
  measyrs = NULL,
  varCur = "INVYR",
  evalType = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_options_+3A_cur">Cur</code></td>
<td>
<p>Logical. If eval='FIA': extract plots with most current 
evaluation. If eval='custom': extract the most current sampled plots 
in the database.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_endyr">Endyr</code></td>
<td>
<p>Integer (YYYY). If eval='FIA', defines end year for
extracting one or more FIA evaluation. If eval='custom', defines 
end year for extracting the most current sampled plots until.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_endyr.filter">Endyr.filter</code></td>
<td>
<p>Filter. If endyr != NULL, a filter to identify
when to use measEndyr, such as areas or plots identified as being 
disturbed in a particular year. In this example, plots sampled after
the disturbance will be excluded.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_all">All</code></td>
<td>
<p>Logical. If eval='FIA': includes all evaluations in 
database (annual inventory only). If eval='custom': includes all years 
in database (annual inventory only).</p>
</td></tr>
<tr><td><code id="eval_options_+3A_type">Type</code></td>
<td>
<p>String vector. Evaluation types ('ALL','CURR','VOL','P2VEG',
DWM','INV','CHNG','GRM','REGEN'). If eval='FIA', Type is equivalent to
plots for FIA Evaluations where 'ALL' includes nonsampled plots; 'CURR' 
and 'VOL' include plots used for area or tree estimates, respectively; 
Type = 'GRM' includes plots used for growth, removals, mortality; and 
Type = 'CHNG' includes plots used for change estimates (See FIA database 
manual for regioin availability and/or differences 
(https://www.fia.fs.usda.gov/library/database-documentation/index.php) 
If eval='custom', the associated tables are extracted for each Type. 
Multiple Types are accepted.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_evalid">evalid</code></td>
<td>
<p>Integer. Only eval='FIA': extract data for a specific 
evaluation period. See notes for more information about FIA Evaluations.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_invyrs">invyrs</code></td>
<td>
<p>Integer vector. eval='custom': defines specific
inventory years of data (e.g., 2010:2015). See FIA manual for 
definition of INVYR.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_measyrs">measyrs</code></td>
<td>
<p>Integer vector. eval='custom': defines specific
measurement years of data (e.g., 2010:2015).</p>
</td></tr>
<tr><td><code id="eval_options_+3A_varcur">varCur</code></td>
<td>
<p>String. Name of variable to use for most current plot
('MEASYEAR', 'INVYR').</p>
</td></tr>
<tr><td><code id="eval_options_+3A_evaltype">evalType</code></td>
<td>
<p>Deprecated. Use Type instead.</p>
</td></tr>
<tr><td><code id="eval_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eval_options(invyrs = 2015:2018)
</code></pre>

<hr>
<h2 id='GBest.pbar'>Estimation Functions</h2><span id='topic+GBest.pbar'></span><span id='topic+MAest.ht'></span><span id='topic+MAest.ps'></span><span id='topic+MAest.greg'></span><span id='topic+MAest.ratio'></span><span id='topic+MAest.gregEN'></span><span id='topic+MAest.gregRatio'></span><span id='topic+MAest'></span><span id='topic+MAest.dom'></span><span id='topic+MAest.unit'></span><span id='topic+PBest.pbar'></span><span id='topic+PBest.pbarRatio'></span><span id='topic+SAest.unit'></span><span id='topic+SAest.area'></span><span id='topic+SAest'></span><span id='topic+SAest.dom'></span><span id='topic+SAest.large'></span><span id='topic+estimation_desc'></span>

<h3>Description</h3>

<p>These functions carry out direct, model-assisted, and small area estimation
through three different modules: &quot;Green Book&quot;, &quot;Model-Assisted&quot;, and
&quot;Small Area&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBest.pbar(
  sumyn = "CONDPROP_ADJ",
  ysum,
  sumyd = NULL,
  esttype = "AREA",
  ratiotype = "PERACRE",
  stratalut,
  uniqueid,
  unitvar,
  strvar = NULL,
  domain
)

MAest.ht(y, N, FIA = TRUE, getweights = FALSE, var_method = "LinHTSRS")

MAest.ps(
  y,
  N,
  x_sample,
  x_pop,
  FIA = TRUE,
  save4testing = FALSE,
  getweights = FALSE,
  var_method = "SRSunconditional"
)

MAest.greg(
  y,
  N,
  x_sample,
  x_pop,
  FIA = TRUE,
  save4testing = TRUE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = "LinHTSRS"
)

MAest.ratio(
  y,
  N,
  x_sample,
  x_pop,
  FIA = TRUE,
  save4testing = TRUE,
  var_method = "LinHTSRS"
)

MAest.gregEN(
  y,
  N,
  x_sample,
  x_pop,
  FIA = TRUE,
  model = "linear",
  save4testing = TRUE,
  getweights = FALSE,
  var_method = "LinHTSRS"
)

MAest.gregRatio(
  yn,
  yd,
  N,
  area,
  x_sample,
  x_pop,
  FIA = TRUE,
  save4testing = FALSE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = "LinHTSRS"
)

MAest(
  yn = "CONDPROP_ADJ",
  dat.dom,
  cuniqueid,
  unitlut = NULL,
  pltassgn,
  esttype = "ACRES",
  MAmethod,
  strvar = NULL,
  prednames = NULL,
  yd = NULL,
  ratiotype = "PERACRE",
  N,
  area,
  FIA = TRUE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = ifelse(MAmethod %in% c("PS"), "SRSunconditional", "LinHTSRS")
)

MAest.dom(
  dom,
  dat,
  cuniqueid,
  unitlut,
  pltassgn,
  esttype,
  MAmethod,
  strvar = NULL,
  prednames = NULL,
  domain,
  N,
  area = NULL,
  response = NULL,
  response_d = NULL,
  FIA = TRUE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = ifelse(MAmethod %in% c("PS"), "SRSunconditional", "LinHTSRS")
)

MAest.unit(
  unit,
  dat,
  cuniqueid,
  unitlut,
  unitvar,
  esttype,
  MAmethod = "HT",
  strvar = NULL,
  prednames = NULL,
  domain,
  response,
  response_d = NULL,
  npixels,
  unitarea = NULL,
  FIA = TRUE,
  modelselect = FALSE,
  getweights = FALSE,
  var_method = ifelse(MAmethod %in% c("PS"), "SRSunconditional", "LinHTSRS")
)

PBest.pbar(
  dom.prop,
  uniqueid,
  domain,
  strtype = "post",
  stratalut,
  strunitvars,
  unitvars,
  strvar
)

PBest.pbarRatio(
  dom.prop.n,
  dom.prop.d,
  uniqueid,
  domain,
  attribute,
  strtype = "post",
  stratalut,
  strunitvars,
  unitvars,
  strvar
)

SAest.unit(
  fmla.dom.unit,
  pltdat.dom,
  dunitlut.dom,
  yn,
  SApackage,
  dunitvar,
  predselect.unit,
  prior = NULL
)

SAest.area(
  fmla.dom.area,
  pltdat.area,
  dunitlut.area,
  cuniqueid,
  dunitvar = "DOMAIN",
  predselect.area,
  yn,
  SApackage,
  prior = NULL
)

SAest(
  yn = "CONDPROP_ADJ",
  dat.dom,
  cuniqueid,
  pltassgn,
  dunitlut,
  prednames = NULL,
  dunitvar = "DOMAIN",
  SAmethod = "unit",
  SApackage = "JoSAE",
  yd = NULL,
  ratiotype = "PERACRE",
  largebnd.val = NULL,
  showsteps = FALSE,
  savesteps = FALSE,
  stepfolder = NULL,
  prior = NULL,
  modelselect = TRUE,
  multest = TRUE,
  multest_estimators = NULL,
  bayes = FALSE,
  bayes_opts = NULL,
  save4testing = FALSE
)

SAest.dom(
  dom,
  dat,
  cuniqueid,
  dunitlut,
  pltassgn,
  dunitvar = "DOMAIN",
  SApackage,
  SAmethod,
  prednames = NULL,
  domain,
  response = NULL,
  largebnd.val = NULL,
  showsteps = FALSE,
  savesteps = FALSE,
  stepfolder = NULL,
  prior = NULL,
  modelselect = TRUE,
  multest = TRUE,
  multest_estimators = NULL,
  bayes = FALSE,
  bayes_opts = NULL,
  save4testing = FALSE
)

SAest.large(
  largebnd.val,
  dat,
  cuniqueid,
  largebnd.unique,
  dunitlut,
  dunitvar = "DOMAIN",
  SApackage = "JoSAE",
  SAmethod = "unit",
  domain,
  response,
  prednames = NULL,
  showsteps = FALSE,
  savesteps = FALSE,
  stepfolder = NULL,
  prior = NULL,
  modelselect = TRUE,
  multest = TRUE,
  multest_estimators = "all",
  bayes = FALSE,
  bayes_opts = NULL,
  vars2keep = NULL,
  save4testing = FALSE
)
</code></pre>


<h3>Details</h3>

<p>These functions can carry out estimation with data from a variety of domains, 
but are designed for USFS FIA data.
</p>


<h3>Value</h3>

<p>List object containing estimates produced. If GB or PB estimation, output is
directly from FIESTAutils, while outputs for MA or SA will be list objects
from packages such as 'mase', 'sae', 'hbsae', or 'JoSAE'.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino, Grayson W. White
</p>

<hr>
<h2 id='GDT_NAMES'>Reference tables - gdal data types.</h2><span id='topic+GDT_NAMES'></span>

<h3>Description</h3>

<p>Table with gdal data type names.
</p>


<h3>Format</h3>

<p>A vector of 12 data type values.
</p>


<h3>Source</h3>

<p>gdal values.
</p>

<hr>
<h2 id='getDefaultNodata'>Raster Functions</h2><span id='topic+getDefaultNodata'></span><span id='topic+getOffset'></span><span id='topic+getGDALformat'></span><span id='topic+basename.NoExt'></span><span id='topic+Mode'></span><span id='topic+Modes'></span><span id='topic+northness'></span><span id='topic+eastness'></span><span id='topic+roughness'></span><span id='topic+TRI'></span><span id='topic+TPI'></span><span id='topic+getPixelValue'></span><span id='topic+.getPixelValue'></span><span id='topic+extractPtsFromRaster'></span><span id='topic+extractPtsFromRasterList'></span><span id='topic+rasterInfo'></span><span id='topic+reprojectRaster'></span><span id='topic+rasterFromVectorExtent'></span><span id='topic+rasterizePolygons'></span><span id='topic+clipRaster'></span><span id='topic+recodeRaster'></span><span id='topic+pixelCount'></span><span id='topic+focalRaster'></span><span id='topic+zonalStats'></span><span id='topic+zonalMean'></span><span id='topic+zonalFreq'></span><span id='topic+zonalMajority'></span><span id='topic+zonalMinority'></span><span id='topic+zonalVariety'></span><span id='topic+zonalBayes'></span><span id='topic+raster_desc'></span><span id='topic+getrastlst'></span><span id='topic+areacalc.pixel'></span><span id='topic+aspect_transform'></span><span id='topic+checkrast.longlat'></span><span id='topic+getrastlst.rgdal'></span>

<h3>Description</h3>

<p>These functions allow for analysis of raster data. Many are written in C++ to
be extremely efficient and fast. Some are wrappers around these C++ functions
for easier use and integration into other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDefaultNodata(GDT_name)

getOffset(coord, origin, gt_pixel_size)

getGDALformat(file)

basename.NoExt(filepath)

Mode(x, na.rm = FALSE)

Modes(x, na.rm = FALSE)

northness(asp_deg)

eastness(asp_deg)

roughness(x, na.rm = FALSE, asInt = TRUE)

TRI(x, na.rm = FALSE, asInt = TRUE)

TPI(x, na.rm = FALSE, asInt = TRUE)

getPixelValue(
  pt,
  ds,
  ri = NULL,
  band = 1,
  interpolate = FALSE,
  windowsize = 1,
  statistic = NULL,
  na.rm = TRUE
)

.getPixelValue(pt, rasterfile, ds, ...)

extractPtsFromRaster(
  ptdata,
  rasterfile,
  band = NULL,
  var.name = NULL,
  interpolate = FALSE,
  windowsize = 1,
  statistic = NULL,
  na.rm = TRUE,
  ncores = 1
)

extractPtsFromRasterList(
  ptdata,
  rasterfiles,
  bands = NULL,
  var.names = NULL,
  interpolate = FALSE,
  windowsizes = NULL,
  statistics = NULL,
  na.rm = TRUE,
  ncores = 1
)

rasterInfo(srcfile)

reprojectRaster(
  srcfile,
  dstfile,
  t_srs,
  overwrite = TRUE,
  s_srs = NULL,
  of = NULL,
  ot = NULL,
  te = NULL,
  tr = NULL,
  r = NULL,
  dstnodata = NULL,
  co = NULL,
  addOptions = NULL
)

rasterFromVectorExtent(
  src,
  dstfile,
  res,
  fmt = NULL,
  nbands = 1,
  dtName = "Int16",
  options = NULL,
  init = NULL,
  dstnodata = init
)

rasterizePolygons(dsn, layer, burn_value, rasterfile, src = NULL)

clipRaster(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  srcfile,
  src_band = NULL,
  dstfile,
  fmt = NULL,
  options = NULL,
  init = NULL,
  dstnodata = NULL,
  maskByPolygons = TRUE
)

recodeRaster(srcfile, dstfile, lut, srcband = 1, ...)

pixelCount(rasterfile, band = 1)

focalRaster(
  srcfile,
  dstfile,
  w,
  fun = sum,
  na.rm = FALSE,
  ...,
  fmt = NULL,
  dtName = NULL,
  options = NULL,
  nodata_value = NULL,
  setRasterNodataValue = FALSE,
  srcband = NULL
)

zonalStats(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  pixelfun = NULL,
  na.rm = TRUE,
  ignoreValue = NULL,
  show_progress = FALSE
)

zonalMean(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  pixelfun = NULL,
  na.rm = TRUE,
  ...
)

zonalFreq(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  aggfun = NULL,
  lut = NULL,
  na.rm = FALSE,
  ignoreValue = NULL,
  show_progress = FALSE
)

zonalMajority(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  ...
)

zonalMinority(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  ...
)

zonalVariety(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  attribute,
  rasterfile,
  band = 1,
  lut = NULL,
  ...
)

zonalBayes(
  dsn = NULL,
  layer = NULL,
  src = NULL,
  zoneidfld,
  helperidfld = NULL,
  rasterfiles,
  prednames,
  predfun,
  xy = FALSE,
  nMCMC = 100
)

getrastlst(
  rastnmlst,
  rastfolder = NULL,
  stopifLonLat = FALSE,
  stopifnull = FALSE,
  stopifinvalid = FALSE,
  gui = FALSE,
  quiet = FALSE
)

areacalc.pixel(rastfn, unit = "ACRES", rast.NODATA = NULL, na.rm = TRUE)

aspect_transform(df, asp)

checkrast.longlat(rastfn, dstfile = NULL, nolonglat = TRUE, crs.default = NULL)

getrastlst.rgdal(
  rastnmlst,
  rastfolder = NULL,
  stopifLonLat = FALSE,
  stopifnull = FALSE,
  stopifinvalid = FALSE,
  gui = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Details</h3>

<p>These functions carry out raster data analysis.
</p>


<h3>Value</h3>

<p>Spatial data object from 'sf'. Used for spatial data analyses.
</p>


<h3>Author(s)</h3>

<p>Chris Toney, Tracey S. Frescino
</p>

<hr>
<h2 id='kindcd3old'>Reference table - List of RMRS plots that have fallen out of inventory
because they were not found or they were in the wrong place.</h2><span id='topic+kindcd3old'></span>

<h3>Description</h3>

<p>Table with variable codes (VALUE) and descriptions (MEANING).
</p>


<h3>Format</h3>

<p>A dataframe
</p>


<h3>Source</h3>

<p>FIA query.
SELECT bp.STATECD, bp.COUNTYCD, bp.PLOT_FIADB NEW_PLOT, bp.START_DATE NEW_START_DATE,
bp_old.COUNTYCD OLD_COUNTYCD, bp_old.PLOT_FIADB OLD_PLOT, 
bp_old.END_DATE OLD_END_DATE, p.CN
FROM fs_nims_rmrs.NIMS_BASE_PLOT bp
JOIN fs_nims_rmrs.NIMS_BASE_PLOT bp_old on (bp.PREV_NBP_CN=bp_old.CN)
JOIN fs_nims_rmrs.NIMS_PLOT_RMRS_VW p on(p.NBP_CN=bp_old.CN)
WHERE p.KINDCD = 1
ORDER BY bp.STATECD, bp.COUNTYCD, bp_old.PLOT_FIADB&quot;
</p>

<hr>
<h2 id='multest_options'>Multest output options.</h2><span id='topic+multest_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for outputting
multest with custom aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multest_options(
  multest_estimators = "all",
  multest_fmt = "csv",
  multest_outfolder = NULL,
  multest_dsn = NULL,
  multest_layer = NULL,
  multest.append = FALSE,
  multest.AOIonly = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multest_options_+3A_multest_estimators">multest_estimators</code></td>
<td>
<p>String vector. If multest = TRUE, vector of estimators 
to include in multest output ('JU.GREG','JU.EBLUP','JFH','hbsaeU','hbsaeA'). 
See ref_estimators for descriptions. Use multest_estimators = 'all' to output
all estimators.</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest_fmt">multest_fmt</code></td>
<td>
<p>String. Format for multest output tables ('csv',
'sqlite', 'gpkg').</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest_outfolder">multest_outfolder</code></td>
<td>
<p>String. Outfolder for multest. If NULL, same as
outfolder.</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest_dsn">multest_dsn</code></td>
<td>
<p>String. Name of database if multest_fmt = c('sqlite',
'gpkg').</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest_layer">multest_layer</code></td>
<td>
<p>String. Name of database layer if multest_fmt =
c('sqlite', 'gpkg').</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest.append">multest.append</code></td>
<td>
<p>Logical. If TRUE, appends multest dataframe to output.</p>
</td></tr>
<tr><td><code id="multest_options_+3A_multest.aoionly">multest.AOIonly</code></td>
<td>
<p>Logical. If TRUE, appends multest dataframe (AOI=1)
to output.</p>
</td></tr>
<tr><td><code id="multest_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for outputting
multest.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
multest_options(multest.append = TRUE)

</code></pre>

<hr>
<h2 id='pcheck.logical'>Parameter Check Functions</h2><span id='topic+pcheck.logical'></span><span id='topic+pcheck.unique'></span><span id='topic+pcheck.varchar'></span><span id='topic+pcheck.dsn'></span><span id='topic+pcheck.table'></span><span id='topic+pcheck.outfolder'></span><span id='topic+pcheck.states'></span><span id='topic+pcheck.object'></span><span id='topic+pcheck.output'></span><span id='topic+pcheck.colors'></span><span id='topic+pcheck.areaunits'></span><span id='topic+pcheck.spatial'></span><span id='topic+pcheck.params'></span><span id='topic+pcheck.opts'></span><span id='topic+pcheck_desc'></span><span id='topic+popTabchk'></span>

<h3>Description</h3>

<p>These functions are used to check parameter inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcheck.logical(
  var2check,
  varnm = NULL,
  title = NULL,
  first = "YES",
  gui = FALSE,
  stopifnull = FALSE
)

pcheck.unique(
  tab,
  uniqueid,
  gui = FALSE,
  tabnm = NULL,
  warn = NULL,
  stopifnull = FALSE,
  stopifinvalid = TRUE,
  multiple = FALSE,
  ...
)

pcheck.varchar(
  var2check,
  varnm = NULL,
  checklst,
  gui = FALSE,
  caption = NULL,
  warn = NULL,
  stopifnull = FALSE,
  stopifinvalid = TRUE,
  multiple = FALSE,
  ...
)

pcheck.dsn(dsn, dbconnopen = TRUE)

pcheck.table(
  tab = NULL,
  conn = NULL,
  tab_dsn = NULL,
  tabnm = NULL,
  tabqry = NULL,
  caption = NULL,
  returnsf = TRUE,
  factors = FALSE,
  returnDT = TRUE,
  warn = NULL,
  stopifnull = FALSE,
  stopifinvalid = FALSE,
  nullcheck = FALSE,
  obj = FALSE,
  checkonly = FALSE,
  gui = FALSE
)

pcheck.outfolder(outfolder, default = getwd(), gui = FALSE)

pcheck.states(
  states,
  statereturn = "MEANING",
  gui = FALSE,
  RS = NULL,
  stopifnull = FALSE,
  ...
)

pcheck.object(
  obj = NULL,
  objnm = NULL,
  warn = NULL,
  caption = NULL,
  stopifnull = FALSE,
  gui = FALSE,
  list.items = NULL
)

pcheck.output(
  out_fmt = "csv",
  outsp_fmt = "shp",
  out_dsn = NULL,
  outfolder = NULL,
  outfn.pre = NULL,
  outfn.date = FALSE,
  overwrite_dsn = FALSE,
  overwrite_layer = TRUE,
  add_layer = TRUE,
  append_layer = FALSE,
  createSQLite = FALSE,
  out_conn = NULL,
  outconn = NULL,
  dbconnopen = FALSE,
  gui = FALSE,
  savedata_opts = NULL
)

pcheck.colors(colorlst, n)

pcheck.areaunits(unitarea, areavar, areaunits, metric = FALSE)

pcheck.spatial(
  layer = NULL,
  dsn = NULL,
  sql = NA,
  fmt = NULL,
  tabnm = NULL,
  caption = NULL,
  stopifnull = FALSE,
  gui = FALSE,
  polyfix = FALSE,
  dropgeom = FALSE,
  stopifnoCRS = TRUE,
  checkonly = FALSE
)

pcheck.params(
  input.params,
  strata_opts = NULL,
  unit_opts = NULL,
  table_opts = NULL,
  title_opts = NULL,
  savedata_opts = NULL,
  multest_opts = NULL,
  spMakeSpatial_opts = NULL,
  eval_opts = NULL,
  xy_opts = NULL,
  database_opts = NULL,
  datSum_opts = NULL
)

pcheck.opts(optionlst)

popTabchk(tabnames, tabtext, tabs, tabIDs, dbtablst, dbconn, datindb = FALSE)
</code></pre>


<h3>Details</h3>

<p>These functions are used to check parameter inputs.
</p>


<h3>Value</h3>

<p>List of parameter objects checked by the function. While the 'pcheck.*()'
functions do return a value, they are primarily used for their side effects
when checking input function parameters.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='popFilters'>Population data filters.</h2><span id='topic+popFilters'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for population
data filters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popFilters(
  evalid = NULL,
  states = NULL,
  evalCur = FALSE,
  evalEndyr = NULL,
  measCur = FALSE,
  measEndyr = NULL,
  invyrs = NULL,
  measyrs = NULL,
  intensity = NULL,
  ACI = FALSE,
  AOIonly = FALSE,
  pfilter = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popFilters_+3A_evalid">evalid</code></td>
<td>
<p>Numeric. FIA Evaluation identifier for subsetting plots for
population.</p>
</td></tr>
<tr><td><code id="popFilters_+3A_states">states</code></td>
<td>
<p>String or numeric vector. Name (e.g., 'Arizona','New Mexico')
or code (e.g., 4, 35) of state(s) for evalid. If all states in one or more
FIA Research Station is desired, set states=NULL and use RS argument to
define RS.</p>
</td></tr>
<tr><td><code id="popFilters_+3A_evalcur">evalCur</code></td>
<td>
<p>Logical. If TRUE, the most current FIA Evaluation is extracted
for state(s).</p>
</td></tr>
<tr><td><code id="popFilters_+3A_evalendyr">evalEndyr</code></td>
<td>
<p>Number. The end year of the FIA Evaluation of interest.
Selects only sampled plots and conditions for the evaluation period. If
more than one state, create a named list object with evalEndyr labeled for
each state (e.g., list(Utah=2014, Colorado=2013).</p>
</td></tr>
<tr><td><code id="popFilters_+3A_meascur">measCur</code></td>
<td>
<p>Logical. If TRUE, the most current sampled plots available
for state(s).</p>
</td></tr>
<tr><td><code id="popFilters_+3A_measendyr">measEndyr</code></td>
<td>
<p>Number. The most current sampled plots measured before or
during end given..</p>
</td></tr>
<tr><td><code id="popFilters_+3A_invyrs">invyrs</code></td>
<td>
<p>Integer vector. Inventory year(s) (e.g., c(2000, 2001, 2002)).</p>
</td></tr>
<tr><td><code id="popFilters_+3A_measyrs">measyrs</code></td>
<td>
<p>Integer vector. Measurement year(s) (e.g., c(2000, 2001, 2002)).</p>
</td></tr>
<tr><td><code id="popFilters_+3A_intensity">intensity</code></td>
<td>
<p>Integer code. Code(s) indicating intensity to use for
population.</p>
</td></tr>
<tr><td><code id="popFilters_+3A_aci">ACI</code></td>
<td>
<p>Logical. If TRUE, including All Condition Inventory (ACI) plots.</p>
</td></tr>
<tr><td><code id="popFilters_+3A_aoionly">AOIonly</code></td>
<td>
<p>Logical. If TRUE, and there is an AOI (1/0) attribute in the
population data, only AOI=1 are used for estimation.</p>
</td></tr>
<tr><td><code id="popFilters_+3A_pfilter">pfilter</code></td>
<td>
<p>String. Logical filter for plot or pltassgn.</p>
</td></tr>
<tr><td><code id="popFilters_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for population
data filters.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>

<hr>
<h2 id='popTableIDs'>List of population table unique IDs.</h2><span id='topic+popTableIDs'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for data 
table unique IDs to be supplied to *pop functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popTableIDs(
  cond = "PLT_CN",
  plt = "CN",
  tree = "PLT_CN",
  seed = "PLT_CN",
  seedling = "PLT_CN",
  vsubpspp = "PLT_CN",
  p2veg_subplot_spp = "PLT_CN",
  vsubpstr = "PLT_CN",
  p2veg_subp_structure = "PLT_CN",
  invsubp = "PLT_CN",
  invasive_subplot_spp = "PLT_CN",
  subplot = "PLT_CN",
  subp_cond = "PLT_CN",
  dwm = "PLT_CN",
  cond_dwm_calc = "PLT_CN",
  sccm = "PLT_CN",
  subp_cond_chng_mtrx = "PLT_CN",
  grm = "PLT_CN",
  tree_grm_component = "PLT_CN",
  begin = "PLT_CN",
  tree_grm_begin = "PLT_CN",
  midpt = "PLT_CN",
  tree_grm_midpt = "PLT_CN",
  plot = "CN",
  pltu = "CN",
  plotu = "CN",
  condu = "PLT_CN",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popTableIDs_+3A_cond">cond</code></td>
<td>
<p>String. Unique identifier of plot in cond.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_plt">plt</code></td>
<td>
<p>String. Unique identifier of plot in plt.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_tree">tree</code></td>
<td>
<p>String. Unique identifier of plot in tree and seed.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_seed">seed</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_seedling">seedling</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_vsubpspp">vsubpspp</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_p2veg_subplot_spp">p2veg_subplot_spp</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_vsubpstr">vsubpstr</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_p2veg_subp_structure">p2veg_subp_structure</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_invsubp">invsubp</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_invasive_subplot_spp">invasive_subplot_spp</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_subplot">subplot</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_subp_cond">subp_cond</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_dwm">dwm</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_cond_dwm_calc">cond_dwm_calc</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_sccm">sccm</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_subp_cond_chng_mtrx">subp_cond_chng_mtrx</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_grm">grm</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_tree_grm_component">tree_grm_component</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_begin">begin</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_tree_grm_begin">tree_grm_begin</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_midpt">midpt</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_tree_grm_midpt">tree_grm_midpt</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_plot">plot</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_pltu">pltu</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_plotu">plotu</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_condu">condu</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="popTableIDs_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied unique identifier of a plot in population tables.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>

<hr>
<h2 id='popTables'>List of population tables.</h2><span id='topic+popTables'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for data 
tables to be supplied to *pop functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popTables(
  cond = "COND",
  plt = "PLOT",
  tree = "TREE",
  seed = "SEEDLING",
  seedling = "SEEDLING",
  vsubpspp = "P2VEG_SUBPLOT_SPP",
  p2veg_subplot_spp = "P2VEG_SUBPLOT_SPP",
  vsubpstr = "P2VEG_SUBP_STRUCTURE",
  p2veg_subp_structure = "P2VEG_SUBP_STRUCTURE",
  invsubp = "INVASIVE_SUBPLOT_SPP",
  invasive_subplot_spp = "INVASIVE_SUBPLOT_SPP",
  subplot = "SUBPLOT",
  subp_cond = "SUBP_COND",
  dwm = "COND_DWM_CALC",
  cond_dwm_calc = "COND_DWM_CALC",
  sccm = "SUBP_COND_CHNG_MTRX",
  subp_cond_chng_mtrx = "SUBP_COND_CHNG_MTRX",
  grm = "TREE_GRM_COMPONENT",
  tree_grm_component = "TREE_GRM_COMPONENT",
  begin = "TREE_GRM_BEGIN",
  tree_grm_begin = "TREE_GRM_BEGIN",
  midpt = "TREE_GRM_MIDPT",
  tree_grm_midpt = "TREE_GRM_MIDPT",
  plot = "plot",
  pltu = "pltu",
  plotu = "plotu",
  condu = "condu",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="popTables_+3A_cond">cond</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Condition-level data with one record for each condition, including or
excluding nonsampled conditions. Plot variables and strata/estimation unit
variable(s) may be included if plt and pltassgn=NULL. See details for
necessary variables to include.</p>
</td></tr>
<tr><td><code id="popTables_+3A_plt">plt</code></td>
<td>
<p>DF/DT, Optional. R object, sf R object, comma-delimited
file(*.csv), layer or spatial layer in dsn, or shapefile(*.shp).  Plot-level
data with one record for each plot, including or excluding nonsampled
conditions. If nonsampled plots are included, PLOT_STATUS_CD variable must
be in table or a filter defined in plt.nonsamp.filter.</p>
</td></tr>
<tr><td><code id="popTables_+3A_tree">tree</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Tree-level data with one record for each tree. Tree data are aggregated to
condition-level. See details for necessary variables to include.</p>
</td></tr>
<tr><td><code id="popTables_+3A_seed">seed</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Seedling data with one record for each seedling count.</p>
</td></tr>
<tr><td><code id="popTables_+3A_seedling">seedling</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Seedling data with one record for each seedling count.</p>
</td></tr>
<tr><td><code id="popTables_+3A_vsubpspp">vsubpspp</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in
dsn.  Vegetation species-level data with one record for each species
(P2VEG_SUBPLOT_SPP).</p>
</td></tr>
<tr><td><code id="popTables_+3A_p2veg_subplot_spp">p2veg_subplot_spp</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or 
layer in dsn. Vegetation species-level data with one record for each species
(P2VEG_SUBPLOT_SPP).</p>
</td></tr>
<tr><td><code id="popTables_+3A_vsubpstr">vsubpstr</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in
dsn. Vegetation species-structure data with one record for each species
(P2VEG_SUBP_STRUCTURE).</p>
</td></tr>
<tr><td><code id="popTables_+3A_p2veg_subp_structure">p2veg_subp_structure</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), 
or layer in dsn. Vegetation species-structure data with one record for each 
species (P2VEG_SUBP_STRUCTURE).</p>
</td></tr>
<tr><td><code id="popTables_+3A_invsubp">invsubp</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in
dsn. Invasive species data with one record for each species
(INVASIVE_SUBPLOT_SPP).</p>
</td></tr>
<tr><td><code id="popTables_+3A_invasive_subplot_spp">invasive_subplot_spp</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), 
or layer in dsn. Invasive species data with one record for each species
(INVASIVE_SUBPLOT_SPP).</p>
</td></tr>
<tr><td><code id="popTables_+3A_subplot">subplot</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in
dsn. Subplot-level data with one record for each species (SUBPLOT).</p>
</td></tr>
<tr><td><code id="popTables_+3A_subp_cond">subp_cond</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in
dsn. Subplot condition-level data with one record for each species
(SUBP_COND).</p>
</td></tr>
<tr><td><code id="popTables_+3A_dwm">dwm</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer 
in dsn. Calculated down woody material (COND_DWM_CALC).</p>
</td></tr>
<tr><td><code id="popTables_+3A_cond_dwm_calc">cond_dwm_calc</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer 
in dsn. Calculated down woody material (COND_DWM_CALC).</p>
</td></tr>
<tr><td><code id="popTables_+3A_sccm">sccm</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Subplot-level data (SUBP_COND_CHNG_MTRX).</p>
</td></tr>
<tr><td><code id="popTables_+3A_subp_cond_chng_mtrx">subp_cond_chng_mtrx</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), 
or layer in dsn. Subplot-level data (SUBP_COND_CHNG_MTRX).</p>
</td></tr>
<tr><td><code id="popTables_+3A_grm">grm</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Tree-level growth, removal, and mortality data (TREE_GRM_COMPONENT).</p>
</td></tr>
<tr><td><code id="popTables_+3A_tree_grm_component">tree_grm_component</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), 
or layer in dsn. Tree-level growth, removal, and mortality data (TREE_GRM_COMPONENT).</p>
</td></tr>
<tr><td><code id="popTables_+3A_begin">begin</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Tree-level growth, removal, and mortality data (TREE_GRM_BEGIN).</p>
</td></tr>
<tr><td><code id="popTables_+3A_tree_grm_begin">tree_grm_begin</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Tree-level growth, removal, and mortality data (TREE_GRM_BEGIN).</p>
</td></tr>
<tr><td><code id="popTables_+3A_midpt">midpt</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Tree-level growth, removal, and mortality data (TREE_GRM_MIDPT).</p>
</td></tr>
<tr><td><code id="popTables_+3A_tree_grm_midpt">tree_grm_midpt</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Tree-level growth, removal, and mortality data (TREE_GRM_MIDPT).</p>
</td></tr>
<tr><td><code id="popTables_+3A_plot">plot</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Plot data unioned with remeasured plot data.</p>
</td></tr>
<tr><td><code id="popTables_+3A_pltu">pltu</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Plot data unioned with remeasured plot data.</p>
</td></tr>
<tr><td><code id="popTables_+3A_plotu">plotu</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Plot data unioned with remeasured plot data.</p>
</td></tr>
<tr><td><code id="popTables_+3A_condu">condu</code></td>
<td>
<p>DF/DT, R object, comma-delimited file(*.csv), or layer in dsn.
Cond data unioned with remeasured cond data.</p>
</td></tr>
<tr><td><code id="popTables_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+rasterFromRaster'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>gdalraster</dt><dd><p><code><a href="gdalraster.html#topic+rasterFromRaster">rasterFromRaster</a></code></p>
</dd>
</dl>

<hr>
<h2 id='ref_codes'>Reference tables - Code definitions.</h2><span id='topic+ref_codes'></span>

<h3>Description</h3>

<p>Table with variable codes (VALUE) and descriptions (MEANING).
</p>


<h3>Format</h3>

<p>A dataframe with 7 columns, VARIABLE, VALUE, MEANING, COLORHEX,
GROUP, GROUPNM, GROUPHEX.
</p>


<h3>Source</h3>

<p>FIA look-up tables.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_codes_archive'>Reference tables - Code definitions (Archive).</h2><span id='topic+ref_codes_archive'></span>

<h3>Description</h3>

<p>Table with variable codes (VALUE) and descriptions (MEANING).
</p>


<h3>Format</h3>

<p>A dataframe with 7 columns, VARIABLE, VALUE, MEANING, COLORHEX,
GROUP, GROUPNM, GROUPHEX.
</p>


<h3>Source</h3>

<p>FIA look-up tables.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_cond'>Reference table - Metadata for cond default variables output from
DBgetPlots()</h2><span id='topic+ref_cond'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions
</p>


<h3>Format</h3>

<p>A data frame with 61 rows and 3 columns VARIABLE - Variable in cond
data frame DESCRIPTION - Description of variable in cond data frame TABLE -
Table in database where variable originates or if derived
</p>


<h3>Source</h3>

<p>FIA look-up table
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_conversion'>Reference table - for conversion factors.</h2><span id='topic+ref_conversion'></span>

<h3>Description</h3>

<p>Table with conversion factors from English to metric units.
</p>


<h3>Format</h3>

<p>A dataframe with 6 columns: TYPE, ENGLISH, ENGLISH_ABBR, METRIC, METRIC_ABBR, CONVERSION.
</p>


<h3>Source</h3>

<p>Conversion table.
</p>

<hr>
<h2 id='ref_diacl2in'>Reference table - diameter 2-inch class codes (DIA).</h2><span id='topic+ref_diacl2in'></span>

<h3>Description</h3>

<p>Table with min (MIN), max (MAX), and 2-inch class diameter codes (MEANING).
</p>


<h3>Format</h3>

<p>A dataframe with 3 columns, MIN, MAX, and MEANING.
</p>


<h3>Source</h3>

<p>Imported from comma-delimited file.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_domain'>Reference table - for generating tables.</h2><span id='topic+ref_domain'></span>

<h3>Description</h3>

<p>Table with row/column domain (VARNM) and their pretty names for table output
(TABLENM).
</p>


<h3>Format</h3>

<p>A dataframe with 2 columns, VARNM and TABLENM.
</p>


<h3>Source</h3>

<p>FIA look-up table.
</p>

<hr>
<h2 id='ref_estimators'>Reference table - FIESTA estimators.</h2><span id='topic+ref_estimators'></span>

<h3>Description</h3>

<p>Table with list of estimators currently in FIESTA.
</p>


<h3>Format</h3>

<p>A dataframe with 7 columns: ESTIMATOR, SHORTNAME, PACKAGE, OUTNAME, ESTIMATOR_TYPE, ESTIMATOR_DATA, DESCRIPTION, CITATION
</p>


<h3>Source</h3>

<p>Comma-delimited file.
</p>

<hr>
<h2 id='ref_estvar'>Reference table - for generating estimates</h2><span id='topic+ref_estvar'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions
</p>


<h3>Format</h3>

<p>A data frame to use a reference for estimation 
variables and filters.
</p>

<hr>
<h2 id='ref_evaltyp'>Reference table - for generating tables.</h2><span id='topic+ref_evaltyp'></span>

<h3>Description</h3>

<p>Table with row/column domain (VARNM) and their pretty names for table output
(TABLENM).
</p>


<h3>Format</h3>

<p>A dataframe with 3 columns, EVAL_TYP_CD, EVAL_TYP, DESCRIPTION.
</p>


<h3>Source</h3>

<p>FIA look-up table.
</p>

<hr>
<h2 id='ref_plt'>Reference table - Metadata for plt default variables output from
DBgetPlots()</h2><span id='topic+ref_plt'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions.
</p>


<h3>Format</h3>

<p>A data frame with 43 rows and 3 columns VARIABLE - Variable in plt
data frame DESCRIPTION - Description of variable in plt data frame TABLE -
Table in database where variable originates or if derived
</p>


<h3>Source</h3>

<p>FIA look-up table
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_popType'>Reference table - popType codes.</h2><span id='topic+ref_popType'></span>

<h3>Description</h3>

<p>Table with population type (popType) and associated evaluation code (EVAL_TYP_CD).
</p>


<h3>Format</h3>

<p>A dataframe with 2 columns, VARNM and TITLE.
</p>


<h3>Source</h3>

<p>Comma-delimited file.
</p>

<hr>
<h2 id='ref_shp'>Reference table - Metadata for shp_* default variables output from
DBgetPlots()</h2><span id='topic+ref_shp'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions
</p>


<h3>Format</h3>

<p>A dataframe with 63 rows and 4 columns VARIABLE - Variable in plt
data frame DESCRIPTION - Description of variable in plt data frame TABLE -
Table in database where variable originates or if derived SHPEXPORT - Name
of variable for exported shapefile (&lt;= 10 characters)
</p>


<h3>Source</h3>

<p>FIA look-up table
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_species'>Reference table - Code definitions.</h2><span id='topic+ref_species'></span>

<h3>Description</h3>

<p>Table with species information downloaded from datamart FIADB_REFERENCES, 
subset from REF_SPECIES TABLE.
</p>


<h3>Format</h3>

<p>A dataframe with 14 columns: SPCD, COMMON_NAME, GENUS, SPECIES, 
SPECIES_SYMBOL, E_SPGRCD, W_SPGRPCD, C_SPGRPCD, P_SPGRPCD, 
MAJOR_SPGRPCD, JENKINS_TOTAL_B1, JENKINS_TOTAL_B2, 
DRYWT_TO_GREENWT_CONERSION, SCIENTIFIC_NAME (GENUS + SPECIES).
</p>


<h3>Source</h3>

<p>Imported from comma-delimited file.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_statecd'>Reference table - state codes (STATECD).</h2><span id='topic+ref_statecd'></span>

<h3>Description</h3>

<p>Table with state codes (VALUE), name (MEANING), abbreviation (ABBR), and
UNIT.
</p>


<h3>Format</h3>

<p>A dataframe with 4 columns, VALUE, MEANING, ABBR, UNIT.
</p>


<h3>Source</h3>

<p>Imported from comma-delimited file.
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_titles'>Reference table - Variable titles.</h2><span id='topic+ref_titles'></span>

<h3>Description</h3>

<p>Table with variable name (VARNM) and associated title (TITLE).
</p>


<h3>Format</h3>

<p>A dataframe with 2 columns, VARNM and TITLE.
</p>


<h3>Source</h3>

<p>Comma-delimited file.
</p>

<hr>
<h2 id='ref_tree'>Reference table - Metadata for tree default variables output from
DBgetPlots()</h2><span id='topic+ref_tree'></span>

<h3>Description</h3>

<p>Data frame with variable names and descriptions
</p>


<h3>Format</h3>

<p>A data frame with 72 rows and 3 columns VARIABLE - Variable in tree
data frame DESCRIPTION - Description of variable in tree data frame TABLE -
Table in database where variable originates
</p>


<h3>Source</h3>

<p>FIA look-up table
</p>


<h3>References</h3>

<p>O'Connell, B.M.; LaPoint, E.B.; Turner, J.A.; Ridley, T.; Boyer,
D.; Wilson, A.M.; Waddell, K.L.; Christensen, G.; Conkling, B.L. 2012. The
Forest Inventory and Analysis Database: Database Description and Users
Manual Version 5.1.2 for Phase 2. U.S. Department of Agriculture.
(http://fia.fs.fed.us/library/database-documentation/current/ver5-2012/FIADB_user
manual_5-1-2_p2_07_2012.pdf)
</p>

<hr>
<h2 id='ref_units'>Reference table - for variable units.</h2><span id='topic+ref_units'></span>

<h3>Description</h3>

<p>Table with units for TREE variables. The WOODLAND column was added
to identify which variables include woodland species.The kg2tons
column was added to identify which variables are commonly converted
from kilograms to tons in estimation process.
</p>


<h3>Format</h3>

<p>A dataframe with 4 columns: VARIABLE, UNITS, METRICUNITS, 
WOODLAND, kg2tons.
</p>


<h3>Source</h3>

<p>Units table.
</p>

<hr>
<h2 id='savedata_options'>Data saving options.</h2><span id='topic+savedata_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for saving data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>savedata_options(
  outfolder = NULL,
  out_fmt = "csv",
  outsp_fmt = "shp",
  outobj_fmt = "rds",
  out_dsn = NULL,
  out_layer = "outdat",
  outfn.pre = NULL,
  outfn.date = FALSE,
  addtitle = TRUE,
  raw_fmt = "csv",
  raw_dsn = NULL,
  overwrite_dsn = FALSE,
  overwrite_layer = TRUE,
  append_layer = FALSE,
  add_layer = TRUE,
  layer.pre = NULL,
  outconn = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="savedata_options_+3A_outfolder">outfolder</code></td>
<td>
<p>String. The outfolder to write files to. If NULL, files are
written to working directory, or if gui=TRUE, a window to browse.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_out_fmt">out_fmt</code></td>
<td>
<p>String. Format for output tables ('csv', 'sqlite', 'gpkg', 'gdb').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outsp_fmt">outsp_fmt</code></td>
<td>
<p>String. Format for output spatial ('shp', sqlite', 'gpkg', 'gdb').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outobj_fmt">outobj_fmt</code></td>
<td>
<p>String. Format for output spatial ('rda', 'rds', 'llo').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_out_dsn">out_dsn</code></td>
<td>
<p>String. Data source name for output. If extension is
not included, out_fmt is used. Use full path if outfolder=NULL.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_out_layer">out_layer</code></td>
<td>
<p>outlayer.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outfn.pre">outfn.pre</code></td>
<td>
<p>String. If savedata=TRUE, prefix for output files. If
rawdata=TRUE, prefix for rawdata files (if raw_fmt = 'csv') or raw_dsn (if
raw_fmt != 'csv').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outfn.date">outfn.date</code></td>
<td>
<p>Logical. If TRUE, add current date to out_dsn.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_addtitle">addtitle</code></td>
<td>
<p>Logical. If TRUE and savedata=TRUE, adds title to outfile.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_raw_fmt">raw_fmt</code></td>
<td>
<p>String. Format for output rawdata tables ('sqlite',
'gpkg', 'csv', 'gdb').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_raw_dsn">raw_dsn</code></td>
<td>
<p>String. Data source name for rawdata output. If extension is
not included, out_fmt is used. Use full path if outfolder=NULL.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_overwrite_dsn">overwrite_dsn</code></td>
<td>
<p>Logical. If TRUE, overwrites raw_dsn, if exists.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_overwrite_layer">overwrite_layer</code></td>
<td>
<p>Logical. If TRUE, overwrites the output. If
rawdata=TRUE, overwrites out_layer in rawdata folder (if raw_fmt = 'csv') or
out_layers in raw_dsn (if raw_fmt != 'csv').</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_append_layer">append_layer</code></td>
<td>
<p>Logical. If TRUE, and appends data to existing *.csv
files (if *_fmt = 'csv') or *_dsn layers (if *_fmt != 'csv&quot;.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_add_layer">add_layer</code></td>
<td>
<p>Logical. If TRUE, adds layer to an existing out_dsn 
(if out_fmt != c('csv','shp')).</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_layer.pre">layer.pre</code></td>
<td>
<p>Layer prefix.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_outconn">outconn</code></td>
<td>
<p>Open database connection to save to.</p>
</td></tr>
<tr><td><code id="savedata_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for saving data.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
savedata_options(outfolder = "path", overwrite_dsn = FALSE)

</code></pre>

<hr>
<h2 id='spatial_desc'>Spatial Data Functions</h2><span id='topic+spatial_desc'></span><span id='topic+polyfix.sf'></span><span id='topic+build.prj4str'></span><span id='topic+trunc10shp'></span><span id='topic+merge_extents'></span><span id='topic+check.extents'></span><span id='topic+getprjatt'></span><span id='topic+areacalc.poly'></span><span id='topic+checksf.longlat'></span><span id='topic+crsCompare'></span><span id='topic+sf_dissolve'></span><span id='topic+closest_poly'></span><span id='topic+getIntersect'></span><span id='topic+clip.othertables'></span><span id='topic+check.area'></span>

<h3>Description</h3>

<p>These functions allow for analysis and manipulation of spatial data. Tasks
include but are not limited to analyzing polygons, comparing projections,
and checking data compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyfix.sf(x, nolonglat = TRUE)

build.prj4str(
  prj,
  datum = NULL,
  ellps = NULL,
  zone = NULL,
  zoneS = FALSE,
  aea.param = "USGS",
  gui = FALSE
)

trunc10shp(x)

merge_extents(layer1, layer2)

check.extents(
  bbox1,
  bbox2,
  showext = FALSE,
  layer1nm = NULL,
  layer2nm = NULL,
  stopifnotin = FALSE,
  quiet = FALSE
)

getprjatt(prj4str, prjatt, stopifnull = FALSE)

areacalc.poly(
  polyv,
  polyv_dsn = NULL,
  areaprj = "aea",
  zone = NULL,
  unit = "ACRES",
  areavar = NULL
)

checksf.longlat(x, nolonglat = TRUE, crs.default = NULL)

crsCompare(
  x,
  ycrs = NULL,
  x.crs = NULL,
  nolonglat = FALSE,
  checkonly = FALSE,
  crs.default = NULL
)

sf_dissolve(sflayer, col = NULL, areacalc = TRUE)

closest_poly(x.centroid, ypoly, ypoly.att = NULL, nbr = NULL, returnsf = TRUE)

getIntersect(layer1, layer2, layer1.unique, layer2fld, overlapThreshold = 0)

clip.othertables(
  inids,
  othertabnms,
  othertabs = NULL,
  uniqueid = "PLT_CN",
  savedata = FALSE,
  outfn.pre = NULL,
  outfolder = NULL,
  out_fmt = "csv",
  out_dsn = NULL,
  outfn.date = FALSE,
  overwrite_layer = FALSE,
  gui = FALSE
)

check.area(bnd, bnd_dsn, bnd.att = NULL, areaunits = "acres", min.area = 6000)
</code></pre>


<h3>Details</h3>

<p>These functions carry out spatial data analysis.
</p>


<h3>Value</h3>

<p>Spatial data object from 'sf'. Used for spatial data analyses.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='spMakeSpatial_options'>Make SpatialPoints options</h2><span id='topic+spMakeSpatial_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for making
SpatialPoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spMakeSpatial_options(
  xvar = NULL,
  yvar = NULL,
  xy.crs = 4269,
  prj = NULL,
  datum = NULL,
  zone = NULL,
  zoneS = FALSE,
  aea.param = "USGS",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spMakeSpatial_options_+3A_xvar">xvar</code></td>
<td>
<p>String. Name of variable in xyplt defining x coordinate.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_yvar">yvar</code></td>
<td>
<p>String. Name of variable in xyplt defining y coordinate.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_xy.crs">xy.crs</code></td>
<td>
<p>PROJ.4 String or CRS object or Integer EPSG code defining
Coordinate Reference System. (e.g., EPSG:4269-Geodetic coordinate system for
North America, NAD83).</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_prj">prj</code></td>
<td>
<p>String. Projection, or coordinate system of the X/Y coordinates
(&quot;longlat&quot;, &quot;utm&quot;, &quot;aea&quot;). If other, include PROJ.4 string in prj4str.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_datum">datum</code></td>
<td>
<p>String. Datum of projection (&quot;WGS84&quot;, &quot;NAD83&quot;, &quot;NAD27&quot;).</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_zone">zone</code></td>
<td>
<p>Integer. If prj=&quot;utm&quot;, the UTM zone.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_zones">zoneS</code></td>
<td>
<p>Logical. If prj=&quot;utm&quot;, if the UTM zone is in the Southern
hemisphere.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_aea.param">aea.param</code></td>
<td>
<p>String. If prj=&quot;aea&quot;, the associated lat/lon parameters
(USGS: &quot; +lat_1=29.5 +lat_2=45.5 +lat_0=23 +lon_0=-96 +x_0=0 +y_0=0&quot;).  If
other, include PROJ.4 string in prj4str.</p>
</td></tr>
<tr><td><code id="spMakeSpatial_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
spMakeSpatial_options()

</code></pre>

<hr>
<h2 id='strata_options'>Strata options.</h2><span id='topic+strata_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata_options(
  getwt = FALSE,
  getwtvar = "P1POINTCNT",
  strwtvar = "strwt",
  stratcombine = TRUE,
  minplotnum.strat = 2,
  pivot = FALSE,
  nonresp = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strata_options_+3A_getwt">getwt</code></td>
<td>
<p>Logical. If TRUE, calculates strata weights from stratatlut
getwtvar.  If FALSE, strwtvar variable must be in stratalut.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_getwtvar">getwtvar</code></td>
<td>
<p>String. If getwt=TRUE, name of variable in stratalut to
calculate weights (Default = 'P1POINTCNT').</p>
</td></tr>
<tr><td><code id="strata_options_+3A_strwtvar">strwtvar</code></td>
<td>
<p>String. If getwt=FALSE, name of variable in stratalut with
calculated weights (Default = 'strwt').</p>
</td></tr>
<tr><td><code id="strata_options_+3A_stratcombine">stratcombine</code></td>
<td>
<p>Logical. If TRUE, and strata=TRUE, automatically combines
strata categories if less than minplotnum.strat plots in any one stratum. 
See notes for more info.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_minplotnum.strat">minplotnum.strat</code></td>
<td>
<p>Integer. Minimum number of plots for a stratum
within an estimation unit.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_pivot">pivot</code></td>
<td>
<p>Logical. If TRUE, pivot stratalut.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_nonresp">nonresp</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="strata_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
strata_options(getwt = FALSE)

</code></pre>

<hr>
<h2 id='stunitco'>SpatialPolygonsDataFrame with FIA state, unit, county codes and names</h2><span id='topic+stunitco'></span>

<h3>Description</h3>

<p>Polygon feature class with state and county boundaries defined by Census
Bureau, including Federal Information Processing Standards (FIPS) codes. The
FIA Survey Unit code and name attributes (UNITCD, UNITNM) were appended to
dataset, with joining columns of STATECD and COUNTYCD.
</p>


<h3>Format</h3>

<p>A SpatialPolygonsDataFrame with 3233 features and 8 attributes RS -
FIA Research Station name RSCD - FIA Research Station code STATECD - FIPS
state code STATENM - FIPS state name STATEAB - FIPS state abbreviation
UNITCD - FIA survey unit code UNITNM - FIA survey unit name COUNTYCD - FIPS
county code COUNTYNM - FIPS county name
</p>


<h3>Details</h3>

<p>Derived from cb_2018_us_county_5m.  STATEFP was converted to numeric and
named STATECD COUNTYFP was converted to numeric and named COUNTYCD Lookup
table for FIA Research Station (REF_RESEARCH_STATION) was downloaded from
FIA DataMart on 20191105 (FIADB_1.6.1.00) and joined by STATECD. A lookup
table for UNITCD was created from plot data using unique STATECD, COUNTYCD,
UNITCD and joined to table.
</p>
<p>Converted to simple feature<br /> Transformed CRS from longlat(EPSG:4269) to
Albers (EPSG:5070)<br /> Saved to R object, with compression='xz'
</p>


<h3>Source</h3>

<p>Downloaded from the United States Census Bureau on 2019 November 3,
format Esri Shapefile
(https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.html)
Projection: Geographic (GCS_North_American_1983) EPSG: 4269
</p>

<hr>
<h2 id='table_options'>Table aesthetics and output options.</h2><span id='topic+table_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for outputting
tables with custom aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_options(
  row.FIAname = FALSE,
  col.FIAname = FALSE,
  row.orderby = NULL,
  col.orderby = NULL,
  row.add0 = FALSE,
  col.add0 = FALSE,
  rowlut = NULL,
  collut = NULL,
  row.classify = NULL,
  col.classify = NULL,
  rawonly = FALSE,
  raw.keep0 = FALSE,
  rowgrp = FALSE,
  rowgrpnm = NULL,
  rowgrpord = NULL,
  totals = TRUE,
  allin1 = FALSE,
  metric = FALSE,
  estround = 1,
  pseround = 2,
  estnull = "--",
  psenull = "--",
  row.NAname = "Other",
  col.NAname = row.NAname,
  divideby = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table_options_+3A_row.fianame">row.FIAname</code></td>
<td>
<p>Logical. If TRUE, retrieves default FIA reference names
for rowvar located in ref_codes data frame. Names are only available
for certain variables (Check sort(unique(ref_codes$VARIABLE)) for
available names.  If row.FIAname = TRUE and rowvar is in ref_codes,
the rowvar name is used for the output table, and the rowvar code is used to
sort.</p>
</td></tr>
<tr><td><code id="table_options_+3A_col.fianame">col.FIAname</code></td>
<td>
<p>Logical. If TRUE, retrieves default FIA reference names
for colvar located in ref_codes data frame. Names are only available
for certain variables. Check: sort(unique(ref_codes$VARIABLE)) for
available names.  If col.FIAname = TRUE and rowvar is in ref_codes,
the colvar name is used for the output table, and the colvar code is used to
sort.</p>
</td></tr>
<tr><td><code id="table_options_+3A_row.orderby">row.orderby</code></td>
<td>
<p>String. Optional. Name of variable to sort table rows.
Both the rowvar and row.orderby variables must be included in the same input
data.frame.  if NULL, and row.FIAname=FALSE or rowvar is not in
ref_codes, the rows are ordered by rowvar.</p>
</td></tr>
<tr><td><code id="table_options_+3A_col.orderby">col.orderby</code></td>
<td>
<p>String. Optional. Name of variable to sort table columns.
Both the colvar and col.orderby variables must be included in the same input
data.frame.  if NULL, and col.FIAname=FALSE or colvar is not in
ref_codes, the columns are ordered by colvar.</p>
</td></tr>
<tr><td><code id="table_options_+3A_row.add0">row.add0</code></td>
<td>
<p>Logical. If TRUE, include rows with 0 values to the output
table.</p>
</td></tr>
<tr><td><code id="table_options_+3A_col.add0">col.add0</code></td>
<td>
<p>Logical. If TRUE, include columns with 0 values to the
output table.</p>
</td></tr>
<tr><td><code id="table_options_+3A_rowlut">rowlut</code></td>
<td>
<p>Data frame. A lookup table with variable codes and code names
to include as rows of output table (See notes for more information and
format).</p>
</td></tr>
<tr><td><code id="table_options_+3A_collut">collut</code></td>
<td>
<p>Data frame. A lookup table with variable codes and code names
to include as columns of output table (See notes for more information and
format).</p>
</td></tr>
<tr><td><code id="table_options_+3A_row.classify">row.classify</code></td>
<td>
<p>Data frame (if categorical) or Vector (if continuous). 
If clasifying categories, input a dataframe with two columns ('FROM' and 'TO').
If classifying continuous values, input a vector of class breaks for row</p>
</td></tr>
<tr><td><code id="table_options_+3A_col.classify">col.classify</code></td>
<td>
<p>Data frame (if categorical) or Vector (if continuous). 
If clasifying categories, input a dataframe with two columns ('FROM' and 'TO').
If classifying continuous values, input a vector of class breaks for column</p>
</td></tr>
<tr><td><code id="table_options_+3A_rawonly">rawonly</code></td>
<td>
<p>Logical. If TRUE, only rawdata are output. If dataset
includes many estimation units, and only raw data tables are desired, it is
more efficient to output raw data only.</p>
</td></tr>
<tr><td><code id="table_options_+3A_raw.keep0">raw.keep0</code></td>
<td>
<p>Logical. If TRUE, keep 0 values in raw data tables.</p>
</td></tr>
<tr><td><code id="table_options_+3A_rowgrp">rowgrp</code></td>
<td>
<p>Logical. If TRUE, appends row groups to first column of table.
Only available if group category exists in ref_codes table or defined in
rowgrpnm (e.g., FORTYPGRPCD, OWNGRPCD).</p>
</td></tr>
<tr><td><code id="table_options_+3A_rowgrpnm">rowgrpnm</code></td>
<td>
<p>String. Name of variable for grouping rowvar. Variable must
be included in same input table as rowvar.</p>
</td></tr>
<tr><td><code id="table_options_+3A_rowgrpord">rowgrpord</code></td>
<td>
<p>String. Name of variable to sort row group variable.
Variable must be included in same input table as rowgrpnm.</p>
</td></tr>
<tr><td><code id="table_options_+3A_totals">totals</code></td>
<td>
<p>Logical. If TRUE, returns total estimate (mean * AREAUSED).</p>
</td></tr>
<tr><td><code id="table_options_+3A_allin1">allin1</code></td>
<td>
<p>Logical. If TRUE, both estimates and percent sample error are
output in one table as: estimates (percent sample error).</p>
</td></tr>
<tr><td><code id="table_options_+3A_metric">metric</code></td>
<td>
<p>Logical. If TRUE, output if returned in metric units.</p>
</td></tr>
<tr><td><code id="table_options_+3A_estround">estround</code></td>
<td>
<p>Integer. Number of decimal places for estimates.</p>
</td></tr>
<tr><td><code id="table_options_+3A_pseround">pseround</code></td>
<td>
<p>Integer. Number of decimal places for percent sampling
error.</p>
</td></tr>
<tr><td><code id="table_options_+3A_estnull">estnull</code></td>
<td>
<p>Number or character. The number or symbol to use to indicate
'not sampled' for estimate.</p>
</td></tr>
<tr><td><code id="table_options_+3A_psenull">psenull</code></td>
<td>
<p>Number or character. The number or symbol to use to indicate
'not sampled' for percent standard error.</p>
</td></tr>
<tr><td><code id="table_options_+3A_row.naname">row.NAname</code></td>
<td>
<p>String. The name to use for NA values for rows.</p>
</td></tr>
<tr><td><code id="table_options_+3A_col.naname">col.NAname</code></td>
<td>
<p>String. String. The name to use for NA values for columns.</p>
</td></tr>
<tr><td><code id="table_options_+3A_divideby">divideby</code></td>
<td>
<p>String. Conversion number for output ('hundred', 'thousand',
'million').</p>
</td></tr>
<tr><td><code id="table_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for outputting
tables with custom aesthetics.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
table_options(row.FIAname = TRUE, col.FIAname = TRUE)

</code></pre>

<hr>
<h2 id='tableIDs'>List of FIADB table unique IDs.</h2><span id='topic+tableIDs'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for data 
table unique IDs to be supplied to *pop functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tableIDs(
  cond = "PLT_CN",
  plt = "CN",
  tree = "PLT_CN",
  seedling = "PLT_CN",
  subplot = "PLT_CN",
  subp_cond = "PLT_CN",
  condid = "CONDID",
  subpid = "SUBP",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tableIDs_+3A_cond">cond</code></td>
<td>
<p>String. Unique identifier of plot in cond.</p>
</td></tr>
<tr><td><code id="tableIDs_+3A_plt">plt</code></td>
<td>
<p>String. Unique identifier of plot in plt.</p>
</td></tr>
<tr><td><code id="tableIDs_+3A_tree">tree</code></td>
<td>
<p>String. Unique identifier of plot in tree.</p>
</td></tr>
<tr><td><code id="tableIDs_+3A_seedling">seedling</code></td>
<td>
<p>String. Unique identifier of plot in seedling.</p>
</td></tr>
<tr><td><code id="tableIDs_+3A_subplot">subplot</code></td>
<td>
<p>String. Unique identifier of plot in subplot.</p>
</td></tr>
<tr><td><code id="tableIDs_+3A_subp_cond">subp_cond</code></td>
<td>
<p>String. Unique identifier of plot in subp_cond.</p>
</td></tr>
<tr><td><code id="tableIDs_+3A_condid">condid</code></td>
<td>
<p>String. Unique identifier of a condition in cond.</p>
</td></tr>
<tr><td><code id="tableIDs_+3A_subpid">subpid</code></td>
<td>
<p>String. Unique identifier of a subplot in subplot and subp_cond.</p>
</td></tr>
<tr><td><code id="tableIDs_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied unique identifier of a plot in tables.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='title_options'>Title output options.</h2><span id='topic+title_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for outputting
title with custom aesthetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>title_options(
  title.main = NULL,
  title.ref = NULL,
  title.rowvar = NULL,
  title.colvar = NULL,
  title.unitvar = NULL,
  title.estvar = NULL,
  title.estvarn = NULL,
  title.filter = NULL,
  title.units = "acres",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="title_options_+3A_title.main">title.main</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
the complete title used for table. If title.main=NULL, the title.*
parameters are used to generate title string. Note: if title.ref is not
NULL, it is added to title.main.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.ref">title.ref</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
the ending text of the table title (e.g., Nevada, 2004-2005). If NULL, = &quot;&quot;.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.rowvar">title.rowvar</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
pretty name for the row domain variable. If NULL, = rowvar.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.colvar">title.colvar</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
pretty name for the column domain variable. If NULL, = colvar.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.unitvar">title.unitvar</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or
returntitle=TRUE: pretty name for the estimation unit variable. If NULL, =
unitvar.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.estvar">title.estvar</code></td>
<td>
<p>String. TITLE: if savedata=TRUE and/or returntitle=TRUE:
pretty name for the estimate variable. If NULL, title.estvar = estvar.name.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.estvarn">title.estvarn</code></td>
<td>
<p>String. TITLE: if savedata=TRUE and/or returntitle=TRUE:
pretty name for the estimate variable. If NULL, title.estvar = estvar.name.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.filter">title.filter</code></td>
<td>
<p>String. TITLE, if savedata=TRUE and/or returntitle=TRUE:
pretty name for filter(s). If title.filter=NULL, a default is generated from
cfilter.  If title.filter=&quot;&quot;, no title.filter is used.</p>
</td></tr>
<tr><td><code id="title_options_+3A_title.units">title.units</code></td>
<td>
<p>String.</p>
</td></tr>
<tr><td><code id="title_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for outputting
titles with custom aesthetics.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
title_options(title.main = "My fancy title", title.estvar = "Estimate title")

</code></pre>

<hr>
<h2 id='unit_options'>Unit options.</h2><span id='topic+unit_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_options(
  unitvar2 = NULL,
  areaunits = "acres",
  minplotnum.unit = 10,
  unit.action = "keep",
  npixelvar = "npixels",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unit_options_+3A_unitvar2">unitvar2</code></td>
<td>
<p>String. Name of a second level estimation unit variable in
unitarea and cond or pltassgn with assignment for each plot (e.g.,
'STATECD').</p>
</td></tr>
<tr><td><code id="unit_options_+3A_areaunits">areaunits</code></td>
<td>
<p>String. Units of areavar in unitarea ('acres', 'hectares').</p>
</td></tr>
<tr><td><code id="unit_options_+3A_minplotnum.unit">minplotnum.unit</code></td>
<td>
<p>Integer. Minimum number of plots for estimation unit.</p>
</td></tr>
<tr><td><code id="unit_options_+3A_unit.action">unit.action</code></td>
<td>
<p>String. What to do if number of plots in an estimation
unit is less than minplotnum.unit ('keep', 'remove' 'combine'). If
unit.action='keep', estimation units with less that minplotnum.unit will
be kept in output tables; if unit.action='remove', the estimation units 
with less that minplotnum.unit will be removed from the output tables; and
if unit.action='combine', combines estimation unit to the following estimation
unit, ordered in stratalut or unitzonal.</p>
</td></tr>
<tr><td><code id="unit_options_+3A_npixelvar">npixelvar</code></td>
<td>
<p>String. Name of variable in unitlut defining number of
pixels by estimation unit.</p>
</td></tr>
<tr><td><code id="unit_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Grayson W. White
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
unit_options()

</code></pre>

<hr>
<h2 id='write2_desc'>Data Writing Functions</h2><span id='topic+write2_desc'></span><span id='topic+write2csv'></span><span id='topic+write2postgresql'></span><span id='topic+write2sqlite'></span>

<h3>Description</h3>

<p>These functions allow for data to be written to different formats. Currently,
supported formats are &quot;csv&quot; and &quot;sqlite&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write2csv(
  layer,
  lowernames = FALSE,
  outfile = NULL,
  outfolder = NULL,
  outfilenm = NULL,
  outfn.pre = NULL,
  outfn.date = FALSE,
  overwrite = FALSE,
  tabtitle = NULL,
  appendfile = FALSE,
  closefn = TRUE,
  outtxt = NULL,
  gui = FALSE
)

write2postgresql(
  layer,
  dbconn,
  out_name = NULL,
  lowernames = TRUE,
  schema = NULL,
  append_layer = FALSE,
  overwrite = FALSE,
  index.unique = NULL,
  index = NULL,
  index_type = "btree"
)

write2sqlite(
  layer,
  SQLitefn = NULL,
  out_name = NULL,
  lowernames = FALSE,
  gpkg = FALSE,
  outfolder = NULL,
  overwrite = FALSE,
  append_layer = FALSE,
  createnew = FALSE,
  dbconn = NULL,
  dbconnopen = FALSE,
  index.unique = NULL,
  index = NULL
)
</code></pre>


<h3>Details</h3>

<p>These functions allow for data to be written to different formats.
</p>


<h3>Value</h3>

<p>No return value, writes data to either a &quot;csv&quot; or &quot;sqlite&quot; file.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>

<hr>
<h2 id='xy_options'>List of population tables.</h2><span id='topic+xy_options'></span>

<h3>Description</h3>

<p>Returns a list of user-supplied parameters and parameter values for data 
xyuation (FIA or custom) extraction to be supplied to *DB functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy_options(
  xy.uniqueid = "CN",
  xvar = "LON",
  yvar = "LAT",
  xy.crs = 4269,
  xyjoinid = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xy_options_+3A_xy.uniqueid">xy.uniqueid</code></td>
<td>
<p>String. Unique identifier of xy.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_xvar">xvar</code></td>
<td>
<p>String. Name of variable in xy defining x coordinate.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_yvar">yvar</code></td>
<td>
<p>String. Name of variable in xy defining y coordinate.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_xy.crs">xy.crs</code></td>
<td>
<p>PROJ.4 String or CRS object or Integer EPSG code defining
Coordinate Reference System.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_xyjoinid">xyjoinid</code></td>
<td>
<p>String. Name of variable in xy to join to plot data. 
If NULL, xyjoinid = xy.uniqueid.</p>
</td></tr>
<tr><td><code id="xy_options_+3A_...">...</code></td>
<td>
<p>For extendibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no parameters, an empty list is returned.
</p>


<h3>Value</h3>

<p>A list of user-supplied parameters and parameter values for strata.
</p>


<h3>Author(s)</h3>

<p>Tracey S. Frescino
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xy_options(xvar="LON", yvar="LAT")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
