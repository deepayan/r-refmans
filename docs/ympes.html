<!DOCTYPE html><html lang="en"><head><title>Help for package ympes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ympes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ympes-package'><p>ympes: Collection of Helper Functions</p></a></li>
<li><a href='#assertions'><p>Argument assertions (Experimental)</p></a></li>
<li><a href='#cc'><p>Quote names</p></a></li>
<li><a href='#fstrcapture'><p>Capture string tokens into a data frame</p></a></li>
<li><a href='#greprows'><p>Pattern matching on data frame rows</p></a></li>
<li><a href='#new_name'><p>Generate column names for a data frame</p></a></li>
<li><a href='#plot_palette'><p>Plot a colour palette</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Collection of Helper Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of lightweight helper functions (imps) both
  for interactive use and for inclusion within other packages. These include
  functions for minimal input assertions, visualising colour palettes,
  quoting user input, searching rows of a data frame and capturing string
  tokens.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, litedown, clipr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://timtaylor.github.io/ympes/">https://timtaylor.github.io/ympes/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TimTaylor/ympes/issues">https://github.com/TimTaylor/ympes/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, utils</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>litedown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-05 12:21:04 UTC; tim</td>
</tr>
<tr>
<td>Author:</td>
<td>Tim Taylor <a href="https://orcid.org/0000-0002-8587-7113"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  R Core Team [cph] (fstrcapture uses code from strcapture),
  Toby Hocking [cph] (fstrcapture uses code from nc::capture_first_vec)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Taylor &lt;tim.taylor@hiddenelephants.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-05 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ympes-package'>ympes: Collection of Helper Functions</h2><span id='topic+ympes'></span><span id='topic+ympes-package'></span>

<h3>Description</h3>

<p>Provides a collection of lightweight helper functions (imps) both for interactive use and for inclusion within other packages. These include functions for minimal input assertions, visualising colour palettes, quoting user input, searching rows of a data frame and capturing string tokens.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tim Taylor <a href="mailto:tim.taylor@hiddenelephants.co.uk">tim.taylor@hiddenelephants.co.uk</a> (<a href="https://orcid.org/0000-0002-8587-7113">ORCID</a>) [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> R Core Team (fstrcapture uses code from strcapture) [copyright holder]
</p>
</li>
<li><p> Toby Hocking (fstrcapture uses code from nc::capture_first_vec) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://timtaylor.github.io/ympes/">https://timtaylor.github.io/ympes/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/TimTaylor/ympes/issues">https://github.com/TimTaylor/ympes/issues</a>
</p>
</li></ul>


<hr>
<h2 id='assertions'>Argument assertions (Experimental)</h2><span id='topic+assertions'></span><span id='topic+assert_integer'></span><span id='topic+assert_int'></span><span id='topic+assert_integer_not_na'></span><span id='topic+assert_int_not_na'></span><span id='topic+assert_double'></span><span id='topic+assert_dbl'></span><span id='topic+assert_double_not_na'></span><span id='topic+assert_dbl_not_na'></span><span id='topic+assert_numeric'></span><span id='topic+assert_num'></span><span id='topic+assert_numeric_not_na'></span><span id='topic+assert_num_not_na'></span><span id='topic+assert_logical'></span><span id='topic+assert_lgl'></span><span id='topic+assert_logical_not_na'></span><span id='topic+assert_lgl_not_na'></span><span id='topic+assert_character'></span><span id='topic+assert_chr'></span><span id='topic+assert_character_not_na'></span><span id='topic+assert_chr_not_na'></span><span id='topic+assert_data_frame'></span><span id='topic+assert_list'></span><span id='topic+assert_whole'></span><span id='topic+assert_integerish'></span><span id='topic+assert_scalar_integer'></span><span id='topic+assert_scalar_int'></span><span id='topic+assert_scalar_integer_not_na'></span><span id='topic+assert_scalar_int_not_na'></span><span id='topic+assert_scalar_double'></span><span id='topic+assert_scalar_dbl'></span><span id='topic+assert_scalar_double_not_na'></span><span id='topic+assert_scalar_dbl_not_na'></span><span id='topic+assert_scalar_numeric'></span><span id='topic+assert_scalar_num'></span><span id='topic+assert_scalar_numeric_not_na'></span><span id='topic+assert_scalar_num_not_na'></span><span id='topic+assert_scalar_logical'></span><span id='topic+assert_scalar_lgl'></span><span id='topic+assert_scalar_logical_not_na'></span><span id='topic+assert_scalar_lgl_not_na'></span><span id='topic+assert_scalar_whole'></span><span id='topic+assert_scalar_integerish'></span><span id='topic+assert_bool'></span><span id='topic+assert_boolean'></span><span id='topic+assert_scalar_character'></span><span id='topic+assert_scalar_chr'></span><span id='topic+assert_string'></span><span id='topic+assert_scalar_character_not_na'></span><span id='topic+assert_scalar_chr_not_na'></span><span id='topic+assert_string_not_na'></span><span id='topic+assert_non_negative_or_na'></span><span id='topic+assert_non_positive_or_na'></span><span id='topic+assert_non_negative'></span><span id='topic+assert_non_positive'></span><span id='topic+assert_positive'></span><span id='topic+assert_negative'></span><span id='topic+assert_positive_or_na'></span><span id='topic+assert_negative_or_na'></span><span id='topic+assert_between'></span>

<h3>Description</h3>

<p>Assertions for function arguments. Motivated by <code><a href="vctrs.html#topic+vec_assert">vctrs::vec_assert()</a></code> but
with lower overhead at a cost of less informative error messages. Designed to
make it easy to identify the top level calling function whether used within a
user facing function or internally. They are somewhat experimental in nature
and should be treated accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_integer(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_int(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_integer_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_int_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_double(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_dbl(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_double_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_dbl_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_numeric(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_num(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_dbl_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_numeric_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_num_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_logical(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_lgl(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_logical_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_lgl_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_character(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_chr(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_character_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_chr_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_data_frame(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_list(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_whole(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_integerish(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_integer(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_int(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_integer_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_int_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_double(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_dbl(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_double_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_dbl_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_numeric(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_num(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_numeric_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_num_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_logical(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_lgl(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_logical_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_lgl_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_whole(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_integerish(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_bool(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_boolean(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_character(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_chr(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_string(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_character_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_scalar_chr_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_string_not_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_non_negative_or_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_non_positive_or_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_non_negative(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_non_positive(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_positive(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_negative(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_positive_or_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_negative_or_na(
  x,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)

assert_between(
  x,
  lower = -Inf,
  upper = Inf,
  left_inclusive = TRUE,
  right_inclusive = TRUE,
  .arg = deparse(substitute(x)),
  .call = sys.call(-1L),
  .subclass = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assertions_+3A_x">x</code></td>
<td>
<p>Argument to check.</p>
</td></tr>
<tr><td><code id="assertions_+3A_.arg">.arg</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code>
</p>
<p>Name of argument being checked (used in error message).</p>
</td></tr>
<tr><td><code id="assertions_+3A_.call">.call</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[call]&#8288;</code>
</p>
<p>Call to use in error message.</p>
</td></tr>
<tr><td><code id="assertions_+3A_.subclass">.subclass</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code>
</p>
<p>The (optional) subclass of the returned error condition.</p>
</td></tr>
<tr><td><code id="assertions_+3A_lower">lower</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>The lower bound to compare against.</p>
</td></tr>
<tr><td><code id="assertions_+3A_upper">upper</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code>
</p>
<p>The upper bound to compare against.</p>
</td></tr>
<tr><td><code id="assertions_+3A_left_inclusive">left_inclusive</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Should the left (lower) bound be compared inclusively (<code>&lt;=</code>) or exclusive (<code>&lt;</code>).</p>
</td></tr>
<tr><td><code id="assertions_+3A_right_inclusive">right_inclusive</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Should the right (upper) bound be compared inclusively (<code>&gt;=</code>) or exclusive (<code>&gt;</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the assertion succeeds then the input is returned invisibly.
</p>
<p>Otherwise an error of class &quot;ympes-error&quot; (with optional subclass if supplied
when calling the assertion).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use in a user facing function
fun &lt;- function(i, d, l, chr, b) {
    assert_scalar_int(i)
    TRUE
}
fun(i=1L)
try(fun(i="cat"))

# Use in an internal function
internal_fun &lt;- function(a) {
    assert_string(
        a,
        .arg = deparse(substitute(x)),
        .call = sys.call(-1L),
        .subclass = "example_error"
    )
    TRUE
}
external_fun &lt;- function(b) {
    internal_fun(a=b)
}
external_fun(b="cat")
try(external_fun(b = letters))
tryCatch(external_fun(b = letters), error = class)

</code></pre>

<hr>
<h2 id='cc'>Quote names</h2><span id='topic+cc'></span>

<h3>Description</h3>

<p><code>cc()</code> quotes comma separated names whilst trimming outer whitespace. It is
intended for interactive use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc(..., .clip = getOption("imp.clipboard", FALSE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_+3A_...">...</code></td>
<td>
<p>Either unquoted names (separated by commas) that you wish to quote or a
length one character vector you wish to split by whitespace.
</p>
<p>Empty arguments (e.g. third item in <code style="white-space: pre;">&#8288;one,two,,four&#8288;</code>) will be returned as <code>""</code>.
</p>
<p>Character vectors not of length one are returned as is.</p>
</td></tr>
<tr><td><code id="cc_+3A_.clip">.clip</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Should the code to generate the constructed character vector be copied to
your system clipboard.
</p>
<p>Defaults to <code>FALSE</code> unless the option &quot;imp.clipboard&quot; is set to TRUE.
</p>
<p>Note that copying to clipboard requires the availability of package
<a href="https://cran.r-project.org/package=clipr">clipr</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of the quoted input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cc(dale, audrey, laura, hawk)
cc("dale audrey laura hawk")

</code></pre>

<hr>
<h2 id='fstrcapture'>Capture string tokens into a data frame</h2><span id='topic+fstrcapture'></span><span id='topic+gstrcapture'></span>

<h3>Description</h3>

<p><code><a href="#topic+fstrcapture">fstrcapture()</a></code> is a more efficient alternative for <code><a href="utils.html#topic+strcapture">strcapture()</a></code> when
using Perl-compatible regular expressions. It is underpinned by the
<code><a href="base.html#topic+regexpr">regexpr()</a></code> function. Whilst <code><a href="#topic+fstrcapture">fstrcapture()</a></code> only returns the first
occurrence of the captures in a string, <code><a href="#topic+gstrcapture">gstrcapture()</a></code>, built upon
<code><a href="base.html#topic+gregexpr">gregexpr()</a></code>, will return all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fstrcapture(x, pattern, proto)

gstrcapture(x, pattern, proto)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fstrcapture_+3A_x">x</code></td>
<td>

<p>A character vector in which to capture the tokens.
</p>
</td></tr>
<tr><td><code id="fstrcapture_+3A_pattern">pattern</code></td>
<td>

<p>The regular expression with the capture expressions.
</p>
</td></tr>
<tr><td><code id="fstrcapture_+3A_proto">proto</code></td>
<td>

<p>A <code>data.frame</code> or S4 object that behaves like one. See details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tabular data structure of the same type as proto, so typically a data.frame,
containing a column for each capture expression. The column types are
inherited from proto, as are the names unless the captures themselves are
named (in which case these are prioritised). Cases in x that do not match
the pattern have NA in every column. For <code><a href="#topic+gstrcapture">gstrcapture()</a></code> there is an
additional column, <code>string_id</code>, which links the output to the relevant
element of the input vector.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+strcapture">strcapture()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# from regexpr example -------------------------------------------------

# if named capture then pass names on irrespective of proto
notables &lt;- c("  Ben Franklin and Jefferson Davis", "\tMillard Fillmore")
pattern &lt;- "(?&lt;first&gt;[[:upper:]][[:lower:]]+) (?&lt;last&gt;[[:upper:]][[:lower:]]+)"
proto &lt;- data.frame(a="", b="")
fstrcapture(notables, pattern, proto)
gstrcapture(notables, pattern, proto)

# from strcapture example ----------------------------------------------
# if unnamed capture then proto names used
x &lt;- "chr1:1-1000"
pattern &lt;- "(.*?):([[:digit:]]+)-([[:digit:]]+)"
proto &lt;- data.frame(chr=character(), start=integer(), end=integer())
fstrcapture(x, pattern, proto)

# if no proto supplied then all captures treated as character
str(fstrcapture(x, pattern))
str(fstrcapture(x, pattern, proto))

</code></pre>

<hr>
<h2 id='greprows'>Pattern matching on data frame rows</h2><span id='topic+greprows'></span><span id='topic+greplrows'></span><span id='topic+grepvrows'></span>

<h3>Description</h3>

<p><code>greprows()</code> searches for pattern matches within a data frames columns and
returns the related rows or row indices.
</p>
<p><code>grepvrows()</code> is identical to <code>greprows()</code> except with the default
<code>value = TRUE</code>.
</p>
<p><code>greplrows()</code> returns a logical vector (match or not for each row of dat).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greprows(
  dat,
  pattern,
  cols = NULL,
  value = FALSE,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  invert = FALSE
)

greplrows(
  dat,
  pattern,
  cols = NULL,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  invert = FALSE
)

grepvrows(
  dat,
  pattern,
  cols = NULL,
  value = TRUE,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="greprows_+3A_dat">dat</code></td>
<td>
<p>Data frame</p>
</td></tr>
<tr><td><code id="greprows_+3A_pattern">pattern</code></td>
<td>
<p>character string containing a <a href="base.html#topic+regular+20expression">regular expression</a>
(or character string for <code>fixed = TRUE</code>) to be matched
in the given character vector.  Coerced by
<code><a href="base.html#topic+as.character">as.character</a></code> to a character string if possible.  If a
character vector of length 2 or more is supplied, the first element
is used with a warning.  Missing values are allowed except for
<code>regexpr</code>, <code>gregexpr</code> and <code>regexec</code>.</p>
</td></tr>
<tr><td><code id="greprows_+3A_cols">cols</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code>
</p>
<p>Character vector of columns to search.
</p>
<p>If <code>NULL</code> (default) all character and factor columns will be searched.</p>
</td></tr>
<tr><td><code id="greprows_+3A_value">value</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code>
</p>
<p>Should a data frame of rows be returned.
</p>
<p>If <code>FALSE</code> (defauly) row indices will be returned instead of the rows
themselves.</p>
</td></tr>
<tr><td><code id="greprows_+3A_ignore.case">ignore.case</code></td>
<td>
<p>if <code>FALSE</code>, the pattern matching is <em>case
sensitive</em> and if <code>TRUE</code>, case is ignored during matching.</p>
</td></tr>
<tr><td><code id="greprows_+3A_perl">perl</code></td>
<td>
<p>logical.  Should Perl-compatible regexps be used?</p>
</td></tr>
<tr><td><code id="greprows_+3A_fixed">fixed</code></td>
<td>
<p>logical.  If <code>TRUE</code>, <code>pattern</code> is a string to be
matched as is.  Overrides all conflicting arguments.</p>
</td></tr>
<tr><td><code id="greprows_+3A_invert">invert</code></td>
<td>
<p>logical.  If <code>TRUE</code> return indices or values for
elements that do <em>not</em> match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of the corresponding rows or, if <code>value = FALSE</code>, the
corresponding row numbers.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat &lt;- data.frame(
    first = letters,
    second = factor(rev(LETTERS)),
    third = "Q"
)
greprows(dat, "A|b")
greprows(dat, "A|b", ignore.case = TRUE)
greprows(dat, "c", value = FALSE)

</code></pre>

<hr>
<h2 id='new_name'>Generate column names for a data frame</h2><span id='topic+new_name'></span>

<h3>Description</h3>

<p><code>new_name()</code> generates unique names for additional data frame variables
ensuring they are not already present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_name(x, n = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_name_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="new_name_+3A_n">n</code></td>
<td>
<p>Number of unique names to generate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of unique names not already found in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
new_name(mtcars)
new_name(mtcars, 2)

</code></pre>

<hr>
<h2 id='plot_palette'>Plot a colour palette</h2><span id='topic+plot_palette'></span>

<h3>Description</h3>

<p><code>plot_palette()</code> plots a palette from a vector of colour values (name or hex).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_palette(values, label = TRUE, square = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_palette_+3A_values">values</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code>
</p>
<p>Vector of named or hex colours.</p>
</td></tr>
<tr><td><code id="plot_palette_+3A_label">label</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Do you want to label the plot or not?
</p>
<p>If <code>values</code> is a named vector the names are used for labels, otherwise,
the values.</p>
</td></tr>
<tr><td><code id="plot_palette_+3A_square">square</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[bool]&#8288;</code>
</p>
<p>Display palette as square?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot_palette(c("#5FE756", "red", "black"))
plot_palette(c("#5FE756", "red", "black"), square = TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
