<!DOCTYPE html><html><head><title>Help for package eegkit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eegkit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eegkit-package'>
<p>Toolkit for Electroencephalography Data</p></a></li>
<li><a href='#eegcap'>
<p>Draws EEG Cap with Selected Electrodes</p></a></li>
<li><a href='#eegcap2d'>
<p>Draws 2D EEG Cap</p></a></li>
<li><a href='#eegcapdense'>
<p>Draws Dense EEG Cap with Selected Electrodes</p></a></li>
<li><a href='#eegcoord'>
<p>EEG Cap Coordinates</p></a></li>
<li><a href='#eegdense'>
<p>Dense EEG Cap Coordinates</p></a></li>
<li><a href='#eegfft'>
<p>Fast Fourier Transform of EEG Data</p></a></li>
<li><a href='#eegfilter'>
<p>Filters EEG Data</p></a></li>
<li><a href='#eeghead'>
<p>Dummy Head for 3d EEG Plots</p></a></li>
<li><a href='#eegica'>
<p>Independent Component Analysis of EEG Data</p></a></li>
<li><a href='#eegkit-internal'><p>Internal Functions for eegkit Package</p></a></li>
<li><a href='#eegmesh'>
<p>EEG Cap for Dense Coordinates</p></a></li>
<li><a href='#eegpsd'>
<p>Plots Power Spectral Density of EEG Data</p></a></li>
<li><a href='#eegresample'>
<p>Change Sampling Rate of EEG Data</p></a></li>
<li><a href='#eegsim'>
<p>Simulate Event-Related Potential EEG Data</p></a></li>
<li><a href='#eegsmooth'>
<p>Spatial and/or Temporal Smoothing of EEG Data</p></a></li>
<li><a href='#eegspace'>
<p>Plots Multi-Channel EEG Spatial Map</p></a></li>
<li><a href='#eegtime'>
<p>Plots Single-Channel EEG Time Course</p></a></li>
<li><a href='#eegtimemc'>
<p>Plots Multi-Channel EEG Time Course</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Toolkit for Electroencephalography Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-11-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), eegkitdata, bigsplines, ica, rgl, signal</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis and visualization tools for electroencephalography (EEG) data. Includes functions for (i) plotting EEG data, (ii) filtering EEG data, (iii) smoothing EEG data; (iv) frequency domain (Fourier) analysis of EEG data, (v) Independent Component Analysis of EEG data, and (vi) simulating event-related potential EEG data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-06 06:15:20 UTC; Nate</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-11-06 07:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='eegkit-package'>
Toolkit for Electroencephalography Data
</h2><span id='topic+eegkit-package'></span><span id='topic+eegkit'></span>

<h3>Description</h3>

<p>Analysis and visualization tools for electroencephalography (EEG) data. Includes functions for (i) plotting EEG data, (ii) filtering EEG data, (iii) smoothing EEG data; (iv) frequency domain (Fourier) analysis of EEG data, (v) Independent Component Analysis of EEG data, and (vi) simulating event-related potential EEG data.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> eegkit</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Toolkit for Electroencephalography Data</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-11-06</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Nathaniel E. Helwig &lt;helwig@umn.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Nathaniel E. Helwig &lt;helwig@umn.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> eegkitdata, bigsplines, ica, rgl, signal</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Analysis and visualization tools for electroencephalography (EEG) data. Includes functions for (i) plotting EEG data, (ii) filtering EEG data, (iii) smoothing EEG data; (iv) frequency domain (Fourier) analysis of EEG data, (v) Independent Component Analysis of EEG data, and (vi) simulating event-related potential EEG data.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
eegcap                  Draws EEG Cap with Selected Electrodes
eegcap2d                Draws 2D EEG Cap
eegcapdense             Draws Dense EEG Cap with Selected Electrodes
eegcoord                EEG Cap Coordinates
eegdense                Dense EEG Cap Coordinates
eegfft                  Fast Fourier Transform of EEG Data
eegfilter               Filters EEG Data
eeghead                 Dummy Head for 3d EEG Plots
eegica                  Independent Component Analysis of EEG Data
eegkit-package          Toolkit for Electroencephalography Data
eegmesh                 EEG Cap for Dense Coordinates
eegpsd                  Plots Power Spectral Density of EEG Data
eegresample             Change Sampling Rate of EEG Data
eegsim                  Simulate Event-Related Potential EEG Data
eegsmooth               Spatial and/or Temporal Smoothing of EEG Data
eegspace                Plots Multi-Channel EEG Spatial Map
eegtime                 Plots Single-Channel EEG Time Course
eegtimemc               Plots Multi-Channel EEG Time Course
</pre>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>
<p>Maintainer: Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Adler, D., Murdoch, D., and others (2014). <em>rgl: 3D visualization device system
(OpenGL)</em>. http://CRAN.R-project.org/package=rgl
</p>
<p>Bache, K. &amp; Lichman, M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.
</p>
<p>Begleiter, H. <em>Neurodynamics Laboratory</em>. State University of New York Health Center at Brooklyn. http://www.downstate.edu/hbnl/
</p>
<p>Bell, A.J. &amp; Sejnowski, T.J. (1995). An information-maximization approach to blind separation and blind deconvolution. <em>Neural Computation, 7</em>, 1129-1159.
</p>
<p>Cardoso, J.F., &amp; Souloumiac, A. (1993). Blind beamforming for non-Gaussian signals. <em>IEE Proceedings-F, 140</em>, 362-370.
</p>
<p>Cardoso, J.F., &amp; Souloumiac, A. (1996). Jacobi angles for simultaneous diagonalization. <em>SIAM Journal on Matrix Analysis and Applications, 17</em>, 161-164.
</p>
<p>Cooley, James W., and Tukey, John W. (1965) An algorithm for the machine calculation of complex Fourier series, <em>Math. Comput. 19</em>(90), 297-301.
</p>
<p>Harrell, F., Dupont, C., and Others. <em>Hmisc: Harrell Miscellaneous</em>. http://CRAN.R-project.org/package=Hmisc
</p>
<p>Helwig, N. E. (2013). <em>Fast and stable smoothing spline analysis of variance models for large samples with applications to electroencephalography data analysis</em>. Unpublished doctoral dissertation. University of Illinois at Urbana-Champaign.
</p>
<p>Helwig, N.E. (2018). <em>bigsplines: Smoothing Splines for Large Samples</em>. http://CRAN.R-project.org/package=bigsplines
</p>
<p>Helwig, N.E. (2018). <em>ica: Independent Component Analysis</em>. http://CRAN.R-project.org/package=ica
</p>
<p>Helwig, N. E., Hong, S., Hsiao-Wecksler E. T., &amp; Polk, J. D. (2011). Methods to temporally align gait cycle data. Journal of Biomechanics, 44(3), 561-566.
</p>
<p>Helwig, N.E. &amp; Hong, S. (2013). A critique of Tensor Probabilistic Independent Component Analysis: Implications and recommendations for multi-subject fMRI data analysis. <em>Journal of Neuroscience Methods, 213</em>, 263-273.
</p>
<p>Helwig, N. E. &amp; Ma, P. (2015). Fast and stable multiple smoothing parameter selection in smoothing spline analysis of variance models with large samples. <em>Journal of Computational and Graphical Statistics, 24</em>(3), 715-732.
</p>
<p>Helwig, N. E. &amp; Ma, P. (2016). Smoothing spline ANOVA for super large samples: Scalable computation via rounding parameters. <em>Statistics and Its Interface, 9</em>(4), 433-444.
</p>
<p>Ingber, L. (1997). Statistical mechanics of neocortical interactions: Canonical momenta indicatros of electroencephalography. <em>Physical Review E, 55</em>, 4578-4593.
</p>
<p>Ingber, L. (1998). Statistical mechanics of neocortical interactions: Training and testing canonical momenta indicators of EEG. <em>Mathematical Computer Modelling, 27</em>, 33-64.
</p>
<p>Oostenveld, R., and Praamstra, P. (2001). The Five percent electrode system for high-resolution EEG and ERP measurements. <em>Clinical Neurophysiology, 112</em>, 713-719.
</p>
<p>Schlager, S. &amp; authors of VCGLIB. (2014). Rvcg: Manipulations of triangular meshes (smoothing, quadric edge collapse decimation, im- and export of various mesh file-formats, cleaning, etc.) based on the VCGLIB API. R packge version 0.7.1. http://CRAN.R-project.org/package=Rvcg.
</p>
<p>Singleton, R. C. (1979) Mixed Radix Fast Fourier Transforms, in Programs for Digital Signal Processing, IEEE Digital Signal Processing Committee eds. IEEE Press.
</p>


<h3>See Also</h3>

<p><code><a href="eegkitdata.html#topic+eegkitdata-package">eegkitdata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See eegcap, eegcapdense, eegfft, eegica, eegresample, 
#     eegsim, eegsmooth, eegspace, eegtime, and eegtimemc
</code></pre>

<hr>
<h2 id='eegcap'>
Draws EEG Cap with Selected Electrodes
</h2><span id='topic+eegcap'></span>

<h3>Description</h3>

<p>Creates two- or three-dimensional plot of electroencephalography (EEG) cap with user-input electrodes. Three-dimensional plots are created using the <code><a href="#topic+eegcoord">eegcoord</a></code> data and the <code><a href="rgl.html#topic+plot3d">plot3d</a></code> function (from <code>rgl</code> package). Currently supports 84 scalp electrodes, and plots according to the international 10-10 system. Includes customization options (e.g., each electrode can have a unique plotting color, size, label color, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegcap(electrodes = "10-10", type = c("2d", "3d"),
       plotlabels = TRUE, plotaxes = FALSE, main = "",
       xyzlab = NULL, cex.point = NULL, col.point = NULL,
       col.border = NULL, cex.label = NULL, col.label = NULL, 
       nose = TRUE, ears = TRUE, head = TRUE, 
       col.head = "AntiqueWhite", index = FALSE, 
       plt = c(0.03,0.97,0.03,0.97), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegcap_+3A_electrodes">electrodes</code></td>
<td>

<p>Character vector with electrodes to plot. Each element of <code>electrodes</code> must match one of the 89 reference electrodes (see Notes). Mismatches are ignored (not plotted). Input is NOT case sensitive. Default plots all available electrodes (full 10-10 system).
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_type">type</code></td>
<td>

<p>Type of plot to create: <code>type="3d"</code> produces three-dimensional plot, whereas <code>type="2d"</code> produces two-dimensional projection plot (bird's eye view).
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_plotlabels">plotlabels</code></td>
<td>

<p>If <code>TRUE</code>, the electrode labels are plotted.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_plotaxes">plotaxes</code></td>
<td>

<p>If <code>TRUE</code>, the axes are plotted.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_main">main</code></td>
<td>

<p>Title to use for plot. Default is no title
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_xyzlab">xyzlab</code></td>
<td>

<p>Axis labels to use for plot. If <code>type="2d"</code>, then <code>xyzlab</code> should be two-element character vector giving x and y axis labels. If <code>type="3d"</code>, then <code>xyzlab</code> should be three-element character vector giving x, y, and z axis labels.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_cex.point">cex.point</code></td>
<td>

<p>Size of electrode points. Can have a unique size for each electrode.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_col.point">col.point</code></td>
<td>

<p>Color of electrode points. Can have a unique color for each electrode.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_col.border">col.border</code></td>
<td>

<p>Color of electrode point borders. Can have a unique color for each electrode.  
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_cex.label">cex.label</code></td>
<td>

<p>Size of electrode labels. Can have a unique size for each electrode label. Input is ignored if <code>plotlabels=FALSE</code> is used.  
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_col.label">col.label</code></td>
<td>

<p>Color of electrode labels. Can have a unique color for each electrode label. Input is ignored if <code>plotlabels=FALSE</code> is used.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_nose">nose</code></td>
<td>

<p>If <code>TRUE</code>, triangle is plotted to represent the subject's nose. Ignored if <code>type="3d"</code>.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_ears">ears</code></td>
<td>

<p>If <code>TRUE</code>, ovals are plotted to represent the subject's ears. Ignored if <code>type="3d"</code>.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_head">head</code></td>
<td>

<p>If <code>TRUE</code>, head is plotted. Ignored if <code>type="2d"</code>.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_col.head">col.head</code></td>
<td>

<p>Color for dummy head in 3d plot. Ignored if <code>type="2d"</code>.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_index">index</code></td>
<td>

<p>Logical indicating if the cap row indices should be returned (see Note).
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_plt">plt</code></td>
<td>

<p>A vector of the form c(x1, x2, y1, y2) giving the coordinates of the plot region as fractions of the current figure region. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="eegcap_+3A_...">...</code></td>
<td>

<p>Optional inputs for <code>plot</code> or <code>plot3d</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces plot of EEG cap and possibly returns cap row indices.
</p>


<h3>Note</h3>

<p>Currently supports 84 scalp electrodes (plus ears and nose):
A1   A2   AF1  AF2  AF3  AF4  AF5  AF6  AF7  AF8  AFZ  C1   C2   C3   C4   
C5   C6   CP1  CP2  CP3  CP4  CP5  CP6  CPZ  CZ   F1   F2   F3   F4   F5   
F6   F7   F8   F9   F10  FC1  FC2  FC3  FC4  FC5  FC6  FCZ  FP1  FP2  FPZ  
FT7  FT8  FT9  FT10 FZ   I1   I2   IZ   NZ   O1   O2   OZ   P1   P2   P3   
P4   P5   P6   P7   P8   P9   P10  PO1  PO2  PO3  PO4  PO5  PO6  PO7  PO8  
PO9  PO10 POZ  PZ   T7   T8   T9   T10  TP7  TP8  TP9  TP10
</p>
<p>See <code><a href="#topic+eegcoord">eegcoord</a></code> for the coordinates used to create plot. Setting <code>index=TRUE</code> returns the row indices of <code><a href="#topic+eegcoord">eegcoord</a></code> that were used to plot the cap.
</p>
<p>To save three-dimensional plots, use the <code><a href="rgl.html#topic+rgl.postscript">rgl.postscript</a></code> function (from <code>rgl</code> package).
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Adler, D., Murdoch, D., and others (2014). <em>rgl: 3D visualization device system
(OpenGL)</em>. http://CRAN.R-project.org/package=rgl
</p>
<p>Oostenveld, R., and Praamstra, P. (2001). The Five percent electrode system for high-resolution EEG and ERP measurements. <em>Clinical Neurophysiology, 112</em>, 713-719. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1   ##########

# plot 10-10 system (default):

# plot full cap 2d (default options)
eegcap()

# plot full cap 2d (different color for ears and nose)
data(eegcoord)
mycols &lt;- rep("white",87)
enames &lt;- rownames(eegcoord)
mycols[enames=="A1"] &lt;- "green"
mycols[enames=="A2"] &lt;- "light blue"
mycols[enames=="NZ"] &lt;- "pink"
eegcap(col.point = mycols)



##########   EXAMPLE 2   ##########

# plot 10-20 system:

# plot 2d cap with labels
eegcap("10-20")

# plot 2d cap without labels
eegcap("10-20", plotlabels = FALSE)



##########   EXAMPLE 3   ##########

# plot custom subset of electrodes
myelectrodes &lt;- c("FP1","FP2","FPZ","F7","F3","FZ",
                  "F4","F8","T7","C3","CZ","C4","T8",
                  "P7","P3","PZ","P4","P8","O1","O2")
eegcap(myelectrodes)

</code></pre>

<hr>
<h2 id='eegcap2d'>
Draws 2D EEG Cap
</h2><span id='topic+eegcap2d'></span>

<h3>Description</h3>

<p>Creates two-dimensional plot of electroencephalography (EEG) cap with user-input electrodes. Currently supports 84 scalp electrodes, and plots according to the international 10-10 system. Includes customization options (e.g., each electrode can have a unique plotting color, size, label color, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegcap2d(electrodes = "10-10", axes = FALSE, asp = 1, 
         cex.point = 2.75, col.point = "green", pch.point = 19,
         cex.border = 2.75, col.border = "black", pch.border = 21,
         cex.label = 0.5, col.label = "black", 
         head = TRUE, nose = TRUE, ears = TRUE, 
         main = "", xlab = "", ylab = "", 
         xlim = c(-13.7, 13.7), ylim = c(-13.7, 13.7), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegcap2d_+3A_electrodes">electrodes</code></td>
<td>

<p>Character vector with electrodes to plot. Each element of <code>electrodes</code> must match one of the 89 reference electrodes (see Details). Mismatches are ignored (not plotted). Input is NOT case sensitive. Default plots all available electrodes (full 10-10 system).
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_axes">axes</code></td>
<td>

<p>If <code>FALSE</code> (default), no axes are plotted.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_asp">asp</code></td>
<td>

<p>Aspect ratio for plot (defaults to 1).
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_cex.point">cex.point</code></td>
<td>

<p>Character EXpansion value for electrodes. Set to a negative value to suppress the electrode plotting.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_col.point">col.point</code></td>
<td>

<p>Color for electrodes. Ignored if <code>cex.point &lt; 0</code>.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_pch.point">pch.point</code></td>
<td>

<p>Plotting character for electrodes. Ignored if <code>cex.point &lt; 0</code>.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_cex.border">cex.border</code></td>
<td>

<p>Character EXpansion value for electrode borders. Set to a negative value to suppress the electrode border plotting.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_col.border">col.border</code></td>
<td>

<p>Color for electrode borders. Ignored if <code>cex.border &lt; 0</code>.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_pch.border">pch.border</code></td>
<td>

<p>Plotting character for electrode borders. Ignored if <code>cex.border &lt; 0</code>.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_cex.label">cex.label</code></td>
<td>

<p>Character EXpansion value for electrode labels. Set to a negative value to suppress the electrode label plotting.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_col.label">col.label</code></td>
<td>

<p>Color for electrode labels. Ignored if <code>cex.label &lt; 0</code>.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_head">head</code></td>
<td>

<p>If <code>TRUE</code>, a circle is plotted to represent the subject's head.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_nose">nose</code></td>
<td>

<p>If <code>TRUE</code>, a triangle is plotted to represent the subject's nose.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_ears">ears</code></td>
<td>

<p>If <code>TRUE</code>, two ovals are plotted to represent the subject's ears.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_main">main</code></td>
<td>

<p>Title to use for plot. Default is no title.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_xlab">xlab</code>, <code id="eegcap2d_+3A_ylab">ylab</code></td>
<td>

<p>x-axis and y-axis labels for the plot. Default is no axis labels.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_xlim">xlim</code>, <code id="eegcap2d_+3A_ylim">ylim</code></td>
<td>

<p>x-axis and y-axis limits for the plot.
</p>
</td></tr>
<tr><td><code id="eegcap2d_+3A_...">...</code></td>
<td>

<p>Optional inputs for <code>plot</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently supports 84 scalp electrodes (plus ears and nose):
A1   A2   AF1  AF2  AF3  AF4  AF5  AF6  AF7  AF8  AFZ  C1   C2   C3   C4   
C5   C6   CP1  CP2  CP3  CP4  CP5  CP6  CPZ  CZ   F1   F2   F3   F4   F5   
F6   F7   F8   F9   F10  FC1  FC2  FC3  FC4  FC5  FC6  FCZ  FP1  FP2  FPZ  
FT7  FT8  FT9  FT10 FZ   I1   I2   IZ   NZ   O1   O2   OZ   P1   P2   P3   
P4   P5   P6   P7   P8   P9   P10  PO1  PO2  PO3  PO4  PO5  PO6  PO7  PO8  
PO9  PO10 POZ  PZ   T7   T8   T9   T10  TP7  TP8  TP9  TP10
</p>
<p>See <code><a href="#topic+eegcoord">eegcoord</a></code> for the coordinates used to create plot.
</p>


<h3>Value</h3>

<p>Produces plot of EEG cap.
</p>


<h3>Note</h3>

<p>Unlike the <code><a href="#topic+eegcap">eegcap</a></code> function, this function does not use <code>par$plt</code> for the figure positioning. 
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Oostenveld, R., and Praamstra, P. (2001). The Five percent electrode system for high-resolution EEG and ERP measurements. <em>Clinical Neurophysiology, 112</em>, 713-719. 
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+eegcap">eegcap</a></code> for a similar implementation, which also supports 3d EEG cap plotting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##########   EXAMPLE 1   ##########

# plot 10-10 system (default):

# plot full cap (default options)
eegcap2d()

# plot full cap (different color for ears and nose)
data(eegcoord)
mycols &lt;- rep(NA, 87)
enames &lt;- rownames(eegcoord)
mycols[enames=="A1"] &lt;- "green"
mycols[enames=="A2"] &lt;- "light blue"
mycols[enames=="NZ"] &lt;- "pink"
eegcap2d(col.point = mycols)



##########   EXAMPLE 2   ##########

# plot 10-20 system:

# plot cap with labels
eegcap2d("10-20")

# plot cap without labels
eegcap2d("10-20", cex.label = -1)



##########   EXAMPLE 3   ##########

# plot custom subset of electrodes
myelectrodes &lt;- c("FP1","FP2","FPZ","F7","F3","FZ",
                  "F4","F8","T7","C3","CZ","C4","T8",
                  "P7","P3","PZ","P4","P8","O1","O2")
eegcap2d(myelectrodes)

</code></pre>

<hr>
<h2 id='eegcapdense'>
Draws Dense EEG Cap with Selected Electrodes
</h2><span id='topic+eegcapdense'></span>

<h3>Description</h3>

<p>Creates two- or three-dimensional plot of dense electroencephalography (EEG) cap that spans user-input electrodes. Three-dimensional plots are created using the <code><a href="#topic+eegdense">eegdense</a></code> data and the <code><a href="rgl.html#topic+plot3d">plot3d</a></code> function (from <code>rgl</code> package). Currently supports 933 scalp electrodes. Includes customization options (e.g., each electrode can have a unique plotting color, size, label color, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegcapdense(electrodes = "10-10", type = c("2d", "3d"),
            plotlabels = TRUE, plotaxes = FALSE, main = "",
            xyzlab = NULL, cex.point = NULL, col.point = NULL,
            cex.label = NULL, col.label = NULL, nose = TRUE,
            ears = TRUE, head = TRUE, col.head = "AntiqueWhite",
            index = FALSE, zconst = 0.5, plt = c(0.03,0.97,0.03,0.97), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegcapdense_+3A_electrodes">electrodes</code></td>
<td>

<p>Character vector with electrodes to plot. Each element of <code>electrodes</code> must match one of the 89 reference electrodes (see Notes). Mismatches are ignored (not plotted). Input is NOT case sensitive. Default plots all available electrodes (full 10-10 system).
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_type">type</code></td>
<td>

<p>Type of plot to create: <code>type="3d"</code> produces three-dimensional plot, whereas <code>type="2d"</code> produces two-dimensional projection plot (bird's eye view).
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_plotlabels">plotlabels</code></td>
<td>

<p>If <code>TRUE</code>, the electrode labels are plotted.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_plotaxes">plotaxes</code></td>
<td>

<p>If <code>TRUE</code>, the axes are plotted.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_main">main</code></td>
<td>

<p>Title to use for plot. Default is no title
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_xyzlab">xyzlab</code></td>
<td>

<p>Axis labels to use for plot. If <code>type="2d"</code>, then <code>xyzlab</code> should be two-element character vector giving x and y axis labels. If <code>type="3d"</code>, then <code>xyzlab</code> should be three-element character vector giving x, y, and z axis labels.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_cex.point">cex.point</code></td>
<td>

<p>Size of electrode points. Can have a unique size for each electrode.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_col.point">col.point</code></td>
<td>

<p>Color of electrode points. Can have a unique color for each electrode.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_cex.label">cex.label</code></td>
<td>

<p>Size of electrode labels. Can have a unique size for each electrode label. Input is ignored if <code>plotlabels=FALSE</code> is used.  
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_col.label">col.label</code></td>
<td>

<p>Color of electrode labels. Can have a unique color for each electrode label. Input is ignored if <code>plotlabels=FALSE</code> is used.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_nose">nose</code></td>
<td>

<p>If <code>TRUE</code>, triangle is plotted to represent the subject's nose. Ignored if <code>type="3d"</code>.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_ears">ears</code></td>
<td>

<p>If <code>TRUE</code>, ovals are plotted to represent the subject's ears. Ignored if <code>type="3d"</code>.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_head">head</code></td>
<td>

<p>If <code>TRUE</code>, head is plotted. Ignored if <code>type="2d"</code>.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_col.head">col.head</code></td>
<td>

<p>Color for dummy head in 3d plot. Ignored if <code>type="2d"</code>.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_index">index</code></td>
<td>

<p>Logical indicating if the cap row indices should be returned (see Note).
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_zconst">zconst</code></td>
<td>

<p>Scalar controlling which row indices should be returned (see Note).
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_plt">plt</code></td>
<td>

<p>A vector of the form c(x1, x2, y1, y2) giving the coordinates of the plot region as fractions of the current figure region. See <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="eegcapdense_+3A_...">...</code></td>
<td>

<p>Optional inputs for <code>plot</code> or <code>plot3d</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces plot of EEG cap and possibly returns cap row indices.
</p>


<h3>Note</h3>

<p>Currently supports 84 scalp electrodes (plus ears and nose):
A1   A2   AF1  AF2  AF3  AF4  AF5  AF6  AF7  AF8  AFZ  C1   C2   C3   C4   
C5   C6   CP1  CP2  CP3  CP4  CP5  CP6  CPZ  CZ   F1   F2   F3   F4   F5   
F6   F7   F8   F9   F10  FC1  FC2  FC3  FC4  FC5  FC6  FCZ  FP1  FP2  FPZ  
FT7  FT8  FT9  FT10 FZ   I1   I2   IZ   NZ   O1   O2   OZ   P1   P2   P3   
P4   P5   P6   P7   P8   P9   P10  PO1  PO2  PO3  PO4  PO5  PO6  PO7  PO8  
PO9  PO10 POZ  PZ   T7   T8   T9   T10  TP7  TP8  TP9  TP10
</p>
<p>See <code><a href="#topic+eegdense">eegdense</a></code> for the coordinates used to create plot. Setting <code>index=TRUE</code> returns the row indices of <code><a href="#topic+eegdense">eegdense</a></code> that were used to plot the cap. Only returns row indices with z-coordinates &gt;= (zmin-zconst), where zmin is minimum z-coordinate of input electrodes.
</p>
<p>To save three-dimensional plots, use the <code><a href="rgl.html#topic+rgl.postscript">rgl.postscript</a></code> function (from <code>rgl</code> package).
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Adler, D., Murdoch, D., and others (2014). <em>rgl: 3D visualization device system
(OpenGL)</em>. http://CRAN.R-project.org/package=rgl
</p>
<p>Oostenveld, R., and Praamstra, P. (2001). The Five percent electrode system for high-resolution EEG and ERP measurements. <em>Clinical Neurophysiology, 112</em>, 713-719. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1   ##########

# plot 10-10 system (default):
eegcapdense()



##########   EXAMPLE 2   ##########

# plot 10-20 system:
eegcapdense("10-20", plotlabels = FALSE)



##########   EXAMPLE 3   ##########

# plot custom subset of electrodes
myelectrodes &lt;- c("FP1","FP2","FPZ","F7","F3","FZ",
                  "F4","F8","T7","C3","CZ","C4","T8",
                  "P7","P3","PZ","P4","P8","O1","O2")
eegcapdense(myelectrodes)

</code></pre>

<hr>
<h2 id='eegcoord'>
EEG Cap Coordinates
</h2><span id='topic+eegcoord'></span>

<h3>Description</h3>

<p>Three-dimensional electroencephalography (EEG) electrode coordinates (measured in cm), and corresponding projection onto two-dimensional xy plane. Contains 84 scalp electrodes, as well as nose and ears.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eegcoord)
</code></pre>


<h3>Format</h3>

<p>A data frame with 87 observations and the following 5 variables:
</p>
  
<dl>
<dt>x</dt><dd>
<p>x-coordinate of 3d cap (numeric).
</p>
</dd>
<dt>y</dt><dd>
<p>y-coordinate of 3d cap (numeric).
</p>
</dd>
<dt>z</dt><dd>
<p>z-coordinate of 3d cap (numeric).
</p>
</dd>
<dt>xproj</dt><dd>
<p>Projected x-coordinate of 2d cap (numeric).
</p>
</dd>
<dt>yproj</dt><dd>
<p>Projected y-coordinate of 2d cap (numeric).
</p>
</dd>
</dl>

<p>Electrode channel name labels can be obtained using <code>rownames(eegcoord)</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Source</h3>

<p>Created by Nathaniel E. Helwig (2014) using:
</p>
<p>Adler, D., Murdoch, D., and others (2014). <em>rgl: 3D visualization device system
(OpenGL)</em>. http://CRAN.R-project.org/package=rgl
</p>
<p>Oostenveld, R., and Praamstra, P. (2001). The Five percent electrode system for high-resolution EEG and ERP measurements. <em>Clinical Neurophysiology, 112</em>, 713-719.
</p>
<p>Schlager, S. &amp; authors of VCGLIB. (2014). Rvcg: Manipulations of triangular meshes (smoothing, quadric edge collapse decimation, im- and export of various mesh file-formats, cleaning, etc.) based on the VCGLIB API. R packge version 0.7.1. http://CRAN.R-project.org/package=Rvcg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

data(eegcoord)
enames &lt;- rownames(eegcoord)
# plot3d(eegcoord[,1],eegcoord[,2],eegcoord[,3],size=10,col="green")
# text3d(eegcoord[,1],eegcoord[,2],eegcoord[,3],texts=enames,col="blue")
plot(eegcoord[,4],eegcoord[,5],cex=2,col="green",pch=19)
text(eegcoord[,4],eegcoord[,5],labels=enames,col="blue")

</code></pre>

<hr>
<h2 id='eegdense'>
Dense EEG Cap Coordinates
</h2><span id='topic+eegdense'></span>

<h3>Description</h3>

<p>Dense (hypothetical) three-dimensional electroencephalography (EEG) electrode coordinates, and corresponding projection onto two-dimensional plane. Dense cap spans the 84 scalp electrodes defined in <code><a href="#topic+eegcoord">eegcoord</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eegdense)
</code></pre>


<h3>Format</h3>

<p>A data frame with 977 observations and the following 5 variables:
</p>

<dl>
<dt>x</dt><dd>
<p>x-coordinate of 3d cap (numeric).
</p>
</dd>
<dt>y</dt><dd>
<p>y-coordinate of 3d cap (numeric).
</p>
</dd>
<dt>z</dt><dd>
<p>z-coordinate of 3d cap (numeric).
</p>
</dd>
<dt>xproj</dt><dd>
<p>Projected x-coordinate of 2d cap (numeric).
</p>
</dd>
<dt>yproj</dt><dd>
<p>Projected y-coordinate of 2d cap (numeric).
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Source</h3>

<p>Created by Nathaniel E. Helwig (2014) using:
</p>
<p>Adler, D., Murdoch, D., and others (2014). <em>rgl: 3D visualization device system
(OpenGL)</em>. http://CRAN.R-project.org/package=rgl
</p>
<p>Oostenveld, R., and Praamstra, P. (2001). The Five percent electrode system for high-resolution EEG and ERP measurements. <em>Clinical Neurophysiology, 112</em>, 713-719.
</p>
<p>Schlager, S. &amp; authors of VCGLIB. (2014). Rvcg: Manipulations of triangular meshes (smoothing, quadric edge collapse decimation, im- and export of various mesh file-formats, cleaning, etc.) based on the VCGLIB API. R packge version 0.7.1. http://CRAN.R-project.org/package=Rvcg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

data(eegdense)
# plot3d(eegdense[,1],eegdense[,2],eegdense[,3],size=10,col="green")
plot(eegdense[,4],eegdense[,5],cex=1,col="green",pch=19)

</code></pre>

<hr>
<h2 id='eegfft'>
Fast Fourier Transform of EEG Data
</h2><span id='topic+eegfft'></span>

<h3>Description</h3>

<p>Finds the strength (amplitude) and phase shift of the input signal(s) at a particular range of frequencies via a Discrete Fast Fourier Transform (FFT). Can input single or multi-channel data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegfft(x, Fs, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegfft_+3A_x">x</code></td>
<td>

<p>Vector or matrix (time by channel) of EEG data with <code>n</code> time points.
</p>
</td></tr>
<tr><td><code id="eegfft_+3A_fs">Fs</code></td>
<td>

<p>Sampling rate of <code>x</code> in Hz such that <code>n = s * Fs</code> where <code>s</code> is the number of seconds of input data (some positive integer).
</p>
</td></tr>
<tr><td><code id="eegfft_+3A_lower">lower</code></td>
<td>

<p>Lower band in Hz. Smallest frequency to keep (defaults to <code>0</code>).
</p>
</td></tr>
<tr><td><code id="eegfft_+3A_upper">upper</code></td>
<td>

<p>Upper band in Hz. Largest frequency to keep (defaults to <code>Fs/2 - Fs/n</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="stats.html#topic+fft">fft</a></code> function (or <code><a href="stats.html#topic+mvfft">mvfft</a></code> function) is used to implement the FFT (or multivatiate FFT). Given the FFT, the <em>strength</em> of the signal is the modulus (<code><a href="base.html#topic+Mod">Mod</a></code>), and the <em>phase.shift</em> is the angle (<code><a href="base.html#topic+Arg">Arg</a></code>).
</p>


<h3>Value</h3>

<p>If <code>x</code> is a vector, returns a data frame with variables:
</p>
<table>
<tr><td><code>frequency</code></td>
<td>
<p>vector of frequencies</p>
</td></tr>
<tr><td><code>strength</code></td>
<td>
<p>strength (amplitude) of signal at each frequency</p>
</td></tr>
<tr><td><code>phase.shift</code></td>
<td>
<p>phase shift of signal at each frequency</p>
</td></tr>
</table>
<p>If <code>x</code> is a matrix with <code>J</code> channels, returns a list with elements:
</p>
<table>
<tr><td><code>frequency</code></td>
<td>
<p>vector of frequencies of length <code>F</code></p>
</td></tr>
<tr><td><code>strength</code></td>
<td>
<p><code>F</code> by <code>J</code> matrix: strength (amplitude) of signal at each frequency and channel</p>
</td></tr>
<tr><td><code>phase.shift</code></td>
<td>
<p><code>F</code> by <code>J</code> matrix: phase shift of signal at each frequency and channel</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The strength of the signal has the same unit as the input (typically microvolts), and the phase shift is measured in radians (range -<code class="reqn">pi</code> to <code class="reqn">pi</code>).
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Cooley, James W., and Tukey, John W. (1965) An algorithm for the machine calculation of complex Fourier series, Math. Comput. 19(90), 297-301.
</p>
<p>Singleton, R. C. (1979) Mixed Radix Fast Fourier Transforms, in Programs for Digital Signal Processing, IEEE Digital Signal Processing Committee eds. IEEE Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##########   EXAMPLE   ##########

### Data Generation ###

# parameters for signal
Fs &lt;- 1000                             # 1000 Hz signal
s &lt;- 3                                 # 3 seconds of data
t &lt;- seq(0, s - 1/Fs, by = 1/Fs)       # time sequence
n &lt;- length(t)                         # number of data points
freqs &lt;- c(1, 5, 10, 20)               # frequencies
amp &lt;- c(2, 1.5, 3, 1.75)              # strengths (amplitudes)
phs &lt;- c(0, pi/6, pi/4, pi/2)          # phase shifts

# create data generating signals
mu &lt;- rep(0, n)
for(j in 1:length(freqs)){
  mu &lt;- mu + amp[j] * sin(2*pi*t*freqs[j] + phs[j])
}
set.seed(1)                           # set random seed
e &lt;- rnorm(n)                         # Gaussian error
y &lt;- mu + e                           # data = mean + error


### FFT of Noise-Free Data ###

# fft of noise-free data
ef &lt;- eegfft(mu, Fs = Fs, upper = 40)
head(ef)
ef[ef$strength &gt; 0.25,]

# plot frequency strength
par(mfrow = c(1,2))
plot(x = ef$frequency, y = ef$strength, t = "b",
     xlab = "Frequency (Hz)", 
     ylab = expression("Strength (" * mu * "V)"),
     main = "FFT of Noise-Free Data")

# compare to data generating parameters
cbind(amp, ef$strength[ef$strength &gt; 0.25])
cbind(phs - pi/2, ef$phase[ef$strength &gt; 0.25])


### FFT of Noisy Data ###

# fft of noisy data
ef &lt;- eegfft(y, Fs = Fs, upper = 40)
head(ef)
ef[ef$strength &gt; 0.25,]

# plot frequency strength
plot(x = ef$frequency, y = ef$strength, t = "b",
     xlab = "Frequency (Hz)", 
     ylab = expression("Strength (" * mu * "V)"),
     main = "FFT of Noisy Data")

# compare to data generating parameters
cbind(amp, ef$strength[ef$strength &gt; 0.25])
cbind(phs - pi/2, ef$phase[ef$strength &gt; 0.25])

</code></pre>

<hr>
<h2 id='eegfilter'>
Filters EEG Data
</h2><span id='topic+eegfilter'></span>

<h3>Description</h3>

<p>Low-pass, high-pass, or band-pass filter EEG data using either a Butterworth filter (default) or a finite impulse response (FIR) filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegfilter(x, Fs, lower, upper, method = "butter",
          order = 3L, forwardreverse = TRUE, 
          scale = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegfilter_+3A_x">x</code></td>
<td>

<p>Vector or matrix (time by channel) of EEG data with <code>n</code> time points.
</p>
</td></tr>
<tr><td><code id="eegfilter_+3A_fs">Fs</code></td>
<td>

<p>Sampling rate of <code>x</code> in Hz.
</p>
</td></tr>
<tr><td><code id="eegfilter_+3A_lower">lower</code></td>
<td>

<p>Lower band in Hz. Smallest frequency to keep.
</p>
</td></tr>
<tr><td><code id="eegfilter_+3A_upper">upper</code></td>
<td>

<p>Upper band in Hz. Largest frequency to keep.
</p>
</td></tr>
<tr><td><code id="eegfilter_+3A_method">method</code></td>
<td>

<p>Filtering method. Either <code>"butter"</code> for a Butterworth filter or <code>"fir1"</code> for a FIR filter.
</p>
</td></tr>
<tr><td><code id="eegfilter_+3A_order">order</code></td>
<td>

<p>Order of the filter. See corresponding argument of <code><a href="signal.html#topic+butter">butter</a></code> or <code><a href="signal.html#topic+fir1">fir1</a></code>.
</p>
</td></tr>
<tr><td><code id="eegfilter_+3A_forwardreverse">forwardreverse</code></td>
<td>

<p>If <code>TRUE</code> (default), the data are forward and reverse filtered via <code><a href="signal.html#topic+filtfilt">filtfilt</a></code>. Otherwise the data are (forward) filtered via <code><a href="stats.html#topic+filter">filter</a></code>.
</p>
</td></tr>
<tr><td><code id="eegfilter_+3A_scale">scale</code></td>
<td>

<p>If <code>FALSE</code> (default), the filter is not normalized. Otherwise the magnitude of the center of the first passband is normalized to 1.
</p>
</td></tr>
<tr><td><code id="eegfilter_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code>, the filter is plotted via <code><a href="signal.html#topic+freqz_plot">freqz_plot</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a low-pass filter, only enter the <code>upper</code> frequency to keep. For a high-pass filter, only enter the <code>lower</code> frequency to keep. For a band-pass filter, enter both the <code>lower</code> and <code>upper</code> frequency bounds.
</p>


<h3>Value</h3>

<p>Filtered version of input data.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Butterworth_filter
</p>
<p>http://en.wikipedia.org/wiki/Fir_filter
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+filter">filter</a></code>, <code><a href="signal.html#topic+filtfilt">filtfilt</a></code>, <code><a href="signal.html#topic+butter">butter</a></code>, <code><a href="signal.html#topic+fir1">fir1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##########   EXAMPLE   ##########

# create data generating signals
n &lt;- 1000                             # 1000 Hz signal
s &lt;- 2                                # 2 seconds of data
t &lt;- seq(0, s, length.out = s * n)    # time vector
s1 &lt;- sin(2*pi*t)                     # 1 Hz sinusoid
s5 &lt;- sin(2*pi*t*5)                   # 5 Hz sinusoid
s10 &lt;- sin(2*pi*t*10)                 # 10 Hz sinusoid
s20 &lt;- sin(2*pi*t*20)                 # 20 Hz sinusoid

# create data
set.seed(1)                           # set random seed
e &lt;- rnorm(s * n, sd = 0.25)          # Gaussian error
mu &lt;- s1 + s5 + s10 + s20             # 1 + 5 + 10 + 20 Hz mean
y &lt;- mu + e                           # data = mean + error

# 4-th order Butterworth filter (2 to 15 Hz band-pass)
yf.but &lt;- eegfilter(y, Fs = n, lower = 2, upper = 15, method = "butter", order = 4)

# 350-th order FIR filter (2 to 15 Hz band-pass)
yf.fir &lt;- eegfilter(y, Fs = n, lower = 2, upper = 15, method = "fir1", order = 350)

# check quality of results
yftrue &lt;- s5 + s10                    # true (filtered) mean signal
mean((yf.but - yftrue)^2)             # mse between yf.but and yftrue
mean((yf.fir - yftrue)^2)             # mse between yf.fir and yftrue

# plot true and estimated filtered signals
plot(t, yftrue, type = "l", lty = 1, lwd = 2, ylim = c(-3, 3))
lines(t, yf.but, col = "blue", lty = 2, lwd = 2)
lines(t, yf.fir, col = "red", lty = 3, lwd = 2)
legend("topright", legend = c("Truth", "Butterworth", "FIR"), 
       lty = 1:3, lwd = 2, col = c("black", "blue", "red"), bty = "n")

# power spectral density before and after filtering (dB)
par(mfrow=c(1,3), mar = c(5, 4.5, 4, 2) + 0.1)
eegpsd(y, Fs = n, upper = 50, t = "b",
       main = "Before Filtering", lwd = 2)
rect(2, -63, 15, 1, col = rgb(0.5,0.5,0.5,1/4))
legend("topright", legend = "2-15 Hz Filter", 
       fill = rgb(0.5,0.5,0.5,1/4), bty = "n")
eegpsd(yf.but, Fs = n, upper = 50, t = "b",
       main = "After Butterworth Filter", lwd = 2)
eegpsd(yf.fir, Fs = n, upper = 50, t = "b",
       main = "After FIR Filter", lwd = 2)
       
# power spectral density before and after filtering (mv^2)
par(mfrow=c(1,3), mar = c(5, 4.5, 4, 2) + 0.1)
eegpsd(y, Fs = n, upper = 50, unit = "mV^2", t = "b",
       main = "Before Filtering", lwd = 2)
rect(2, 0, 15, 1.05, col = rgb(0.5,0.5,0.5,1/4))
legend("topright", legend = "2-15 Hz Filter", 
       fill = rgb(0.5,0.5,0.5,1/4), bty = "n")
eegpsd(yf.but, Fs = n, upper = 50, unit = "mV^2", t = "b",
       main = "After Butterworth Filter", lwd = 2)
eegpsd(yf.fir, Fs = n, upper = 50, unit = "mV^2", t = "b",
       main = "After FIR Filter", lwd = 2)

</code></pre>

<hr>
<h2 id='eeghead'>
Dummy Head for 3d EEG Plots
</h2><span id='topic+eeghead'></span>

<h3>Description</h3>

<p>Contains mesh3d object of dummy head, which is used in the plotting functions <code><a href="#topic+eegcap">eegcap</a></code> and <code><a href="#topic+eegspace">eegspace</a></code>. This is a transformed (translated, rotated, and rescaled) vesion of the <code>dummyhead</code> object from the <code>Rvcg</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eeghead)
</code></pre>


<h3>Format</h3>

<p>mesh3d object
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Source</h3>

<p>Created by Nathaniel E. Helwig (2014) using:
</p>
<p>Adler, D., Murdoch, D., and others (2014). <em>rgl: 3D visualization device system
(OpenGL)</em>. http://CRAN.R-project.org/package=rgl
</p>
<p>Schlager, S. &amp; authors of VCGLIB. (2014). Rvcg: Manipulations of triangular meshes (smoothing, quadric edge collapse decimation, im- and export of various mesh file-formats, cleaning, etc.) based on the VCGLIB API. R packge version 0.7.1. http://CRAN.R-project.org/package=Rvcg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

# data(eeghead)
# shade3d(eeghead)
# eeghead$material$color &lt;- rep("black",length(eeghead$material$color))
# wire3d(eeghead)

</code></pre>

<hr>
<h2 id='eegica'>
Independent Component Analysis of EEG Data
</h2><span id='topic+eegica'></span>

<h3>Description</h3>

<p>Computes temporal (default) or spatial ICA decomposition of EEG data. Can use Infomax (default), FastICA, or JADE algorithm. ICA computations are conducted via <code><a href="ica.html#topic+icaimax">icaimax</a></code>, <code><a href="ica.html#topic+icafast">icafast</a></code>, or <code><a href="ica.html#topic+icajade">icajade</a></code> from the <code>ica</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegica(X, nc, center = TRUE, maxit = 100, tol = 1e-6,
       Rmat = diag(nc), type = c("time", "space"),
       method = c("imax", "fast", "jade"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegica_+3A_x">X</code></td>
<td>

<p>Data matrix with <code>n</code> rows (channels) and <code>p</code> columns (time points).
</p>
</td></tr>
<tr><td><code id="eegica_+3A_nc">nc</code></td>
<td>

<p>Number of components to extract.
</p>
</td></tr>
<tr><td><code id="eegica_+3A_center">center</code></td>
<td>

<p>If <code>TRUE</code>, columns of <code>X</code> are mean-centered before ICA decomposition.
</p>
</td></tr>
<tr><td><code id="eegica_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of algorithm iterations to allow.
</p>
</td></tr>
<tr><td><code id="eegica_+3A_tol">tol</code></td>
<td>

<p>Convergence tolerance.
</p>
</td></tr>
<tr><td><code id="eegica_+3A_rmat">Rmat</code></td>
<td>

<p>Initial estimate of the <code>nc</code>-by-<code>nc</code> orthogonal rotation matrix.
</p>
</td></tr>
<tr><td><code id="eegica_+3A_type">type</code></td>
<td>

<p>Type of ICA decomposition: <code>type="time"</code> extracts temporally independent components, and <code>type="space"</code> extracts spatially independent components.
</p>
</td></tr>
<tr><td><code id="eegica_+3A_method">method</code></td>
<td>

<p>Method for ICA decomposition: <code>method="imax"</code> uses Infomax, <code>method="fast"</code> uses FastICA, and <code>method="jade"</code> uses JADE.
</p>
</td></tr>
<tr><td><code id="eegica_+3A_...">...</code></td>
<td>

<p>Additional inputs to <code><a href="ica.html#topic+icaimax">icaimax</a></code> or <code><a href="ica.html#topic+icafast">icafast</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>ICA Model</b>
The ICA model can be written as <code>X = tcrossprod(S, M) + E</code>, where columns of <code>S</code> contain the source signals, <code>M</code> is the mixing matrix, and columns of <code>E</code> contain the noise signals. Columns of <code>X</code> are assumed to have zero mean. The goal is to find the unmixing matrix <code>W</code> such that columns of <code>S = tcrossprod(X, W)</code> are independent as possible.
</p>
<p><b>Whitening</b>
Without loss of generality, we can write <code>M = P %*% R</code> where <code>P</code> is a tall matrix and <code>R</code> is an orthogonal rotation matrix. Letting <code>Q</code> denote the pseudoinverse of <code>P</code>, we can whiten the data using <code>Y = tcrossprod(X,Q)</code>. The goal is to find the orthongal rotation matrix <code>R</code> such that the source signal estimates <code>S = Y %*% R</code> are as independent as possible. Note that <code>W = crossprod(R,Q)</code>.
</p>
<p><b>Infomax</b>
The Infomax approach finds the orthogonal rotation matrix <code>R</code> that (approximately) maximizes the joint entropy of a nonlinear function of the estimated source signals. See Bell and Sejnowski (1995) and Helwig (in prep) for specifics of algorithms.
</p>
<p><b>FastICA</b>
The FastICA algorithm finds the orthogonal rotation matrix <code>R</code> that (approximately) maximizes the negentropy of the estimated source signals. Negentropy is approximated using </p>
<p style="text-align: center;"><code class="reqn">J(s) = [E\{G(s)\}-E\{G(z)\} ]^2</code>
</p>
<p> where <em>E</em> denotes the expectation, <em>G</em> is the contrast function, and <em>z</em> is a standard normal variable. See Hyvarinen (1999) for specifics of fixed-point algorithm.
</p>
<p><b>JADE</b>
The JADE approach finds the orthogonal rotation matrix <code>R</code> that (approximately) diagonalizes the cumulant array of the source signals. See Cardoso and Souloumiac (1993,1996) and Helwig and Hong (2013) for specifics of the JADE algorithm.
</p>


<h3>Value</h3>

<table>
<tr><td><code>S</code></td>
<td>
<p>Matrix of source signal estimates (<code>S=Y%*%R</code>).</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>Estimated mixing matrix.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>Estimated unmixing matrix (<code>W=crossprod(R,Q)</code>).</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Whitened data matrix.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>Whitening matrix.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>Orthogonal rotation matrix.</p>
</td></tr>
<tr><td><code>vafs</code></td>
<td>
<p>Variance-accounted-for by each component.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of algorithm iterations.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>ICA type (same as input).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>ICA method (same as input).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <code>type="time"</code>, the data matrix is transposed before calling ICA algorithm (i.e., <code>X = t(X)</code>), and the columns of the tranposed data matrix are centered.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Bell, A.J. &amp; Sejnowski, T.J. (1995). An information-maximization approach to blind separation and blind deconvolution. <em>Neural Computation, 7</em>, 1129-1159.
</p>
<p>Cardoso, J.F., &amp; Souloumiac, A. (1993). Blind beamforming for non-Gaussian signals. <em>IEE Proceedings-F, 140</em>, 362-370.
</p>
<p>Cardoso, J.F., &amp; Souloumiac, A. (1996). Jacobi angles for simultaneous diagonalization. <em>SIAM Journal on Matrix Analysis and Applications, 17</em>, 161-164.
</p>
<p>Helwig, N.E. (2018). <em>ica: Independent Component Analysis</em>. http://CRAN.R-project.org/package=ica
</p>
<p>Helwig, N.E. &amp; Hong, S. (2013). A critique of Tensor Probabilistic Independent Component Analysis: Implications and recommendations for multi-subject fMRI data analysis. <em>Journal of Neuroscience Methods, 213</em>, 263-273.
</p>
<p>Hyvarinen, A. (1999). Fast and robust fixed-point algorithms for independent component analysis. <em>IEEE Transactions on Neural Networks, 10</em>, 626-634.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

# get "c" subjects of "eegdata" data
data(eegdata)
idx &lt;- which(eegdata$group=="c")
eegdata &lt;- eegdata[idx,]

# get average data (across subjects)
eegmean &lt;- tapply(eegdata$voltage,list(eegdata$channel,eegdata$time),mean)

# remove ears and nose
acnames &lt;- rownames(eegmean)
idx &lt;- c(which(acnames=="X"),which(acnames=="Y"),which(acnames=="nd"))
eegmean &lt;- eegmean[-idx,]

# get spatial coordinates (for plotting)
data(eegcoord)
cidx &lt;- match(rownames(eegmean),rownames(eegcoord))

# temporal ICA with 4 components
icatime &lt;- eegica(eegmean,4)
icatime$vafs
# quartz()
# par(mfrow=c(4,2))
# tseq &lt;- (0:255)*1000/255
# for(j in 1:4){
#   par(mar=c(5.1,4.6,4.1,2.1))
#   sptitle &lt;- bquote("VAF:  "*.(round(icatime$vafs[j],4)))
#   eegtime(tseq,icatime$S[,j],main=bquote("Component  "*.(j)),cex.main=1.5)
#   eegspace(eegcoord[cidx,4:5],icatime$M[,j],main=sptitle)
# }

# spatial ICA with 4 components
icaspace &lt;- eegica(eegmean,4,type="space")
icaspace$vafs
# quartz()
# par(mfrow=c(4,2))
# tseq &lt;- (0:255)*1000/255
# for(j in 1:4){
#   par(mar=c(5.1,4.6,4.1,2.1))
#   sptitle &lt;- bquote("VAF:  "*.(round(icaspace$vafs[j],4)))
#   eegtime(tseq,icaspace$M[,j],main=bquote("Component  "*.(j)),cex.main=1.5)
#   eegspace(eegcoord[cidx,4:5],icaspace$S[,j],main=sptitle)
# }

</code></pre>

<hr>
<h2 id='eegkit-internal'>Internal Functions for eegkit Package</h2><span id='topic+colorbar3d'></span><span id='topic+trimhead'></span><span id='topic+voltcol'></span><span id='topic+p1t'></span><span id='topic+n1t'></span><span id='topic+p2t'></span><span id='topic+n2t'></span><span id='topic+p3t'></span><span id='topic+p1s'></span><span id='topic+n1s'></span><span id='topic+p2s'></span><span id='topic+n2s'></span><span id='topic+p3s'></span>

<h3>Description</h3>

<p>Internal functions for eegkit package.
</p>


<h3>Details</h3>

<p>These functions are not to be called by the user.
</p>

<hr>
<h2 id='eegmesh'>
EEG Cap for Dense Coordinates
</h2><span id='topic+eegmesh'></span>

<h3>Description</h3>

<p>Contains mesh3d object of <code><a href="#topic+eegdense">eegdense</a></code>, which is used in the plotting function <code><a href="#topic+eegspace">eegspace</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eegmesh)
</code></pre>


<h3>Format</h3>

<p>mesh3d object
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Source</h3>

<p>Created by Nathaniel E. Helwig (2014) using:
</p>
<p>Adler, D., Murdoch, D., and others (2014). <em>rgl: 3D visualization device system
(OpenGL)</em>. http://CRAN.R-project.org/package=rgl
</p>
<p>Oostenveld, R., and Praamstra, P. (2001). The Five percent electrode system for high-resolution EEG and ERP measurements. <em>Clinical Neurophysiology, 112</em>, 713-719.
</p>
<p>Schlager, S. &amp; authors of VCGLIB. (2014). Rvcg: Manipulations of triangular meshes (smoothing, quadric edge collapse decimation, im- and export of various mesh file-formats, cleaning, etc.) based on the VCGLIB API. R packge version 0.7.1. http://CRAN.R-project.org/package=Rvcg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

# data(eegmesh)
# wire3d(eegmesh)
# eegmesh$material$color &lt;- rep("red",length(eegmesh$material$color))
# shade3d(eegmesh)

</code></pre>

<hr>
<h2 id='eegpsd'>
Plots Power Spectral Density of EEG Data
</h2><span id='topic+eegpsd'></span>

<h3>Description</h3>

<p>Uses a fast discrete Fourier transform (<code><a href="#topic+eegfft">eegfft</a></code>) to estimate the power spectral density of EEG data, and plots the power esimate using the <code><a href="graphics.html#topic+plot">plot</a></code> (single channel) or <code><a href="bigsplines.html#topic+imagebar">imagebar</a></code> (multi-channel) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegpsd(x, Fs, lower, upper, units = "dB", 
       xlab = NULL, ylab = NULL, zlab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegpsd_+3A_x">x</code></td>
<td>

<p>Vector or matrix (time by channel) of EEG data with <code>n</code> time points.
</p>
</td></tr>
<tr><td><code id="eegpsd_+3A_fs">Fs</code></td>
<td>

<p>Sampling rate of <code>x</code> in Hz.
</p>
</td></tr>
<tr><td><code id="eegpsd_+3A_lower">lower</code></td>
<td>

<p>Lower band in Hz. Smallest frequency to keep.
</p>
</td></tr>
<tr><td><code id="eegpsd_+3A_upper">upper</code></td>
<td>

<p>Upper band in Hz. Largest frequency to keep.
</p>
</td></tr>
<tr><td><code id="eegpsd_+3A_units">units</code></td>
<td>

<p>Units for plot. Options include &quot;dB&quot; for decibals (default), &quot;mV&quot; for microvolts, and &quot;mV^2&quot; for squared microvolts. Note dB = 10*log10(mV^2).
</p>
</td></tr>
<tr><td><code id="eegpsd_+3A_xlab">xlab</code></td>
<td>

<p>x-axis label for the plot/image.
</p>
</td></tr>
<tr><td><code id="eegpsd_+3A_ylab">ylab</code></td>
<td>

<p>y-axis label for the plot/image.
</p>
</td></tr>
<tr><td><code id="eegpsd_+3A_zlab">zlab</code></td>
<td>

<p>z-axis label for the plot/image.
</p>
</td></tr>
<tr><td><code id="eegpsd_+3A_...">...</code></td>
<td>

<p>Optional inputs for the <code><a href="graphics.html#topic+plot">plot</a></code> or <code><a href="bigsplines.html#topic+imagebar">imagebar</a></code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a plot (single channel) or image (multi-channel).
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Cooley, James W., and Tukey, John W. (1965) An algorithm for the machine calculation of complex Fourier series, Math. Comput. 19(90), 297-301.
</p>
<p>Singleton, R. C. (1979) Mixed Radix Fast Fourier Transforms, in Programs for Digital Signal Processing, IEEE Digital Signal Processing Committee eds. IEEE Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##########   EXAMPLE   ##########

# create data generating signals
n &lt;- 1000                             # 1000 Hz signal
s &lt;- 2                                # 2 seconds of data
t &lt;- seq(0, s, length.out = s * n)    # time vector
s1 &lt;- sin(2*pi*t)                     # 1 Hz sinusoid
s5 &lt;- sin(2*pi*t*5)                   # 5 Hz sinusoid
s10 &lt;- sin(2*pi*t*10)                 # 10 Hz sinusoid
s20 &lt;- sin(2*pi*t*20)                 # 20 Hz sinusoid

# create data
set.seed(1)                           # set random seed
e &lt;- rnorm(s * n, sd = 0.25)          # Gaussian error
mu &lt;- s1 + s5 + s10 + s20             # 1 + 5 + 10 + 20 Hz mean
y &lt;- mu + e                           # data = mean + error

# plot psd (single channel)
eegpsd(y, Fs = n, upper = 30, t = "b")

# plot psd (multi-channel)
ym &lt;- cbind(s1, s5, s10, s20)
eegpsd(ym, Fs = n, upper = 30, units = "mV")

</code></pre>

<hr>
<h2 id='eegresample'>
Change Sampling Rate of EEG Data
</h2><span id='topic+eegresample'></span>

<h3>Description</h3>

<p>Turn a signal of length <code>N</code> into a signal of length <code>n</code> via linear interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegresample(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegresample_+3A_x">x</code></td>
<td>

<p>Vector or matrix (time by channel) of EEG data with <code>N</code> time points.
</p>
</td></tr>
<tr><td><code id="eegresample_+3A_n">n</code></td>
<td>

<p>Number of time points for the resampled data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are resampled using the &quot;Linear Length Normalization&quot; approach described in Helwig et al. (2011). Let <code class="reqn">\mathbf{x} = (x_1, \ldots, x_N)'</code> denote the input vector of length <code class="reqn">N</code>, and define a vector <code class="reqn">\mathbf{t} = (t_1, \ldots, t_n)</code> with entries </p>
<p style="text-align: center;"><code class="reqn">t_i = 1 + (i - 1) \delta</code>
</p>
<p> for <code class="reqn">i = 1, \ldots, n</code> where <code class="reqn">\delta = (N - 1) / (n - 1)</code>. The resampled vector is calculated as </p>
<p style="text-align: center;"><code class="reqn">y_i = x_{\lfloor t_i \rfloor} + (x_{\lceil t_i \rceil} - x_{\lfloor t_i \rfloor}) ( t_i - \lfloor t_i \rfloor)  </code>
</p>
<p> for <code class="reqn">i = 1, \ldots, n</code> where <code class="reqn">\lfloor \cdot \rfloor</code> and <code class="reqn">\lceil \cdot \rceil</code> denote the floor and ceiling functions.
</p>


<h3>Value</h3>

<p>Resampled version of input data with <code>n</code> time points.
</p>


<h3>Note</h3>

<p>Typical usage is to down-sample (i.e., decrease the sampling rate of) a signal: <code>n &lt; N</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E., Hong, S., Hsiao-Wecksler E. T., &amp; Polk, J. D. (2011). Methods to temporally align gait cycle data. Journal of Biomechanics, 44(3), 561-566.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##########   EXAMPLE 1   ##########

# create vector with N = 200 time points
N &lt;- 200
x &lt;- sin(4 * pi * seq(0, 1, length.out = N))

# down-sample (i.e., decrease sampling rate) to n = 100
y &lt;- eegresample(x, n = 100)
mean((y - sin(4 * pi * seq(0, 1, length.out = 100)))^2)

# up-sample (i.e., increase sampling rate) to n = 500
z &lt;- eegresample(x, n = 500)
mean((z - sin(4 * pi * seq(0, 1, length.out = 500)))^2)

# plot results
par(mfrow = c(1,3))
plot(x, main = "Original (N = 200)")
plot(y, main = "Down-sampled (n = 100)")
plot(z, main = "Up-sampled (n = 500)")


##########   EXAMPLE 2   ##########

# create matrix with N = 500 time points and 2 columns
N &lt;- 500
x &lt;- cbind(sin(2 * pi * seq(0, 1, length.out = N)),
           sin(4 * pi * seq(0, 1, length.out = N)))
           
# down-sample (i.e., decrease sampling rate) to n = 250
y &lt;- eegresample(x, n = 250)
ytrue &lt;- cbind(sin(2 * pi * seq(0, 1, length.out = 250)),
               sin(4 * pi * seq(0, 1, length.out = 250)))
mean((y - ytrue)^2)

# up-sample (i.e., increase sampling rate) to n = 1000
z &lt;- eegresample(x, n = 1000)
ztrue &lt;- cbind(sin(2 * pi * seq(0, 1, length.out = 1000)),
               sin(4 * pi * seq(0, 1, length.out = 1000)))
mean((z - ztrue)^2)

# plot results
par(mfrow = c(1,3))
plot(x[,1], main = "Original (N = 500)", cex = 0.5)
points(x[,2], pch = 2, col = "blue", cex = 0.5)
plot(y[,1], main = "Down-sampled (n = 250)", cex = 0.5)
points(y[,2], pch = 2, col = "blue", cex = 0.5)
plot(z[,1], main = "Up-sampled (n = 1000)", cex = 0.5)
points(z[,2], pch = 2, col = "blue", cex = 0.5)

</code></pre>

<hr>
<h2 id='eegsim'>
Simulate Event-Related Potential EEG Data
</h2><span id='topic+eegsim'></span>

<h3>Description</h3>

<p>Simulates event-related potential EEG data from hypothetical visual-stimulus ERP study. Data are simulated using a linear combination of five spatiotemporal component functions: P100, N100, P200, N200, and P300 components. User can control the coefficient (weight) given to each component, as well as the time shift (delay) of each component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegsim(channel, time, coefs = rep(1,5), tshift = rep(0,5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegsim_+3A_channel">channel</code></td>
<td>

<p>Character vector of length <code>n</code> giving EEG channel of simulated data.
</p>
</td></tr>
<tr><td><code id="eegsim_+3A_time">time</code></td>
<td>

<p>Numeric vector of length <code>n</code> giving time point of simulated data (should be in interval [0,1]).
</p>
</td></tr>
<tr><td><code id="eegsim_+3A_coefs">coefs</code></td>
<td>

<p>Numeric vector of length 5 giving the coefficients (weights) to use for P100, N100, P200, N200, and P300 components (respectively).
</p>
</td></tr>
<tr><td><code id="eegsim_+3A_tshift">tshift</code></td>
<td>

<p>Numeric vector of length 5 giving the time shifts (delays) to use for P100, N100, P200, N200, and P300 components (respectively).  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of simulated EEG data corresponding to the input channel(s), time point(s), coefficients, and time shifts.
</p>


<h3>Note</h3>

<p>Simulates data for 39 parietal and occipital electrodes:
CP1  CP2  CP3  CP4  CP5  CP6  CPZ  I1   I2   IZ   O1   O2   OZ   
P1   P2   P3   P4   P5   P6   P7   P8   P9   P10  PO1  PO2  PO3  
PO4  PO5  PO6  PO7  PO8  PO9  PO10 POZ  PZ   TP7  TP8  TP9  TP10
</p>
<p>Returns simulated value of 0 for other electrodes.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Created by Nathaniel E. Helwig (2014) using data from:
</p>
<p>Bache, K. &amp; Lichman, M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.
</p>
<p>Begleiter, H. <em>Neurodynamics Laboratory</em>. State University of New York Health Center at Brooklyn. http://www.downstate.edu/hbnl/
</p>
<p>Ingber, L. (1997). Statistical mechanics of neocortical interactions: Canonical momenta indicatros of electroencephalography. <em>Physical Review E, 55</em>, 4578-4593.
</p>
<p>Ingber, L. (1998). Statistical mechanics of neocortical interactions: Training and testing canonical momenta indicators of EEG. <em>Mathematical Computer Modelling, 27</em>, 33-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

### plot spatiotemporal component functions

# data(eegcoord)
# chnames &lt;- rownames(eegcoord)
# tseq &lt;- seq(0,1,length.out=200)

# quartz(width=18,height=6)
# layout(matrix(c(1,2,3,4,5,6,7,8,9,10,11,11), 2, 6, byrow = TRUE))

# eegspace(eegcoord[,4:5],p1s(chnames),cex.point=1,main=expression(psi[p1]),cex.main=2,vlim=c(-3,9))
# eegtime(tseq,p1t(tseq),ylim=c(-1,1),asp=1/2,main=expression(tau[p1]),cex.main=2,
#         xlab="Time After Stimulus (sec)")
# eegspace(eegcoord[,4:5],p2s(chnames),cex.point=1,main=expression(psi[p2]),cex.main=2,vlim=c(-3,9))
# eegtime(tseq,p2t(tseq),ylim=c(-1,1),asp=1/2,main=expression(tau[p2]),cex.main=2,
#         xlab="Time After Stimulus (sec)")
# eegspace(eegcoord[,4:5],p3s(chnames),cex.point=1,main=expression(psi[p3]),cex.main=2,vlim=c(-3,9))
# eegtime(tseq,p3t(tseq),ylim=c(-1,1),asp=1/2,main=expression(tau[p3]),cex.main=2,
#         xlab="Time After Stimulus (sec)")
# eegspace(eegcoord[,4:5],n1s(chnames),cex.point=1,main=expression(psi[n1]),cex.main=2,vlim=c(-3,9))
# eegtime(tseq,n1t(tseq),ylim=c(-1,1),asp=1/2,main=expression(tau[n1]),cex.main=2,
#         xlab="Time After Stimulus (sec)")
# eegspace(eegcoord[,4:5],n2s(chnames),cex.point=1,main=expression(psi[n2]),cex.main=2,vlim=c(-3,9))
# eegtime(tseq,n2t(tseq),ylim=c(-1,1),asp=1/2,main=expression(tau[n2]),cex.main=2,
#         xlab="Time After Stimulus (sec)")
# plot(seq(-10,10),seq(-10,10),type="n",axes=FALSE,xlab="",ylab="")
# text(0,8,labels=expression(omega[p1]*" = "*psi[p1]*tau[p1]),cex=2)
# text(0,4,labels=expression(omega[n1]*" = "*psi[n1]*tau[n1]),cex=2)
# text(0,0,labels=expression(omega[p2]*" = "*psi[p2]*tau[p2]),cex=2)
# text(0,-4,labels=expression(omega[n2]*" = "*psi[n2]*tau[n2]),cex=2)
# text(0,-8,labels=expression(omega[p3]*" = "*psi[p3]*tau[p3]),cex=2)



### plot simulated data at various time points

# quartz(width=15,height=3)
# tseq &lt;- c(50,150,250,350,450)/1000
# par(mfrow=c(1,5))
# for(j in 1:5){
#   eegspace(eegcoord[,4:5],eegsim(chnames,rep(tseq[j],87)),vlim=c(-6.8,5.5),
#            main=paste(tseq[j]*1000," ms"),cex.main=2)
# }

</code></pre>

<hr>
<h2 id='eegsmooth'>
Spatial and/or Temporal Smoothing of EEG Data
</h2><span id='topic+eegsmooth'></span>

<h3>Description</h3>

<p>Smooths single- or multi-channel electroencephalography (EEG) with respect to space and/or time. Uses the <code><a href="bigsplines.html#topic+bigspline">bigspline</a></code>, <code><a href="bigsplines.html#topic+bigtps">bigtps</a></code>, and <code><a href="bigsplines.html#topic+bigssa">bigssa</a></code> functions (from <code>bigsplines</code> package) for smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegsmooth(voltage, space = NULL, time = NULL, nknots = NULL,
          rparm = NULL, lambdas = NULL, skip.iter = TRUE,
          se.fit = FALSE, rseed = 1234)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegsmooth_+3A_voltage">voltage</code></td>
<td>

<p>Vector of recorded EEG voltage at each row in <code>space</code>.
</p>
</td></tr>
<tr><td><code id="eegsmooth_+3A_space">space</code></td>
<td>

<p>Matrix of electrode coordinates (in three-dimensions) at which EEG was recorded. If <code>space=NULL</code>, data are temporally smoothed only.
</p>
</td></tr>
<tr><td><code id="eegsmooth_+3A_time">time</code></td>
<td>

<p>Vector of time points at which EEG was recorded. If <code>time=NULL</code>, data are spatially smoothed only.
</p>
</td></tr>
<tr><td><code id="eegsmooth_+3A_nknots">nknots</code></td>
<td>

<p>Number of knots to sample for smoothing. Positive integer.
</p>
</td></tr>
<tr><td><code id="eegsmooth_+3A_rparm">rparm</code></td>
<td>

<p>Rounding parameter(s) to use for smoothing. See Notes and Examples.
</p>
</td></tr>
<tr><td><code id="eegsmooth_+3A_lambdas">lambdas</code></td>
<td>

<p>Smoothing parameter(s) to use for smoothing.
</p>
</td></tr>
<tr><td><code id="eegsmooth_+3A_skip.iter">skip.iter</code></td>
<td>

<p>If <code>FALSE</code>, iterative spatial-temporal smoothing is skipped. Ignored if <code>space=NULL</code> or <code>time=NULL</code>.
</p>
</td></tr>
<tr><td><code id="eegsmooth_+3A_se.fit">se.fit</code></td>
<td>

<p>If <code>TRUE</code>, standard errors of smoothed values are calculated.
</p>
</td></tr>
<tr><td><code id="eegsmooth_+3A_rseed">rseed</code></td>
<td>

<p>Random seed to use for knot selection. Set <code>rseed=NULL</code> to obtain different knots each time, or set <code>rseed</code> to any positive integer to use a different random seed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For temporal smoothing only: an object of class &quot;bigspline&quot; (see <code><a href="bigsplines.html#topic+bigspline">bigspline</a></code>).
</p>
<p>For spatial smoothing only: an object of class &quot;bigtps&quot; (see <code><a href="bigsplines.html#topic+bigtps">bigtps</a></code>).
</p>
<p>For spatial-temporal smoothing: an object of class &quot;bigssa&quot; (see <code><a href="bigsplines.html#topic+bigssa">bigssa</a></code>).
</p>


<h3>Note</h3>

<p>For temporal smoothing only (i.e., <code>space=NULL</code>), the input <code>rparm</code> should be a positive scalar less than 1. Larger values produce faster (but less accurate) approximations. Default is 0.01, which I recommend for temporal smoothing; <code>rparm=0.005</code> may be needed for particuarly rough signals, and <code>rparm=0.02</code> could work for smoother signals.
</p>
<p>For spatial smoothing only (i.e., <code>time=NULL</code>), the input <code>rparm</code> should be a positive scalar giving the rounding unit for the spatial coordinates. For example, <code>rparm=0.1</code> rounds each coordinate to the nearest 0.1 (same as <code>round(space,1)</code>).
</p>
<p>For spatial-temporal smoothing (i.e., both <code>space</code> and <code>time</code> are non-null), the input <code>rparm</code> should be a list of the form <code>rparm=list(space=0.1,time=0.01)</code>, where the 0.1 and 0.01 can be replaced by your desired rounding parameters.
</p>
<p>Setting <code>rparm=NA</code> will use the full data solution; this is more computationally expensive, and typically produces a solution very similar to using <code>rparm=0.01</code> (see references).
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2013). <em>Fast and stable smoothing spline analysis of variance models for large samples with applications to electroencephalography data analysis</em>. Unpublished doctoral dissertation. University of Illinois at Urbana-Champaign.
</p>
<p>Helwig, N.E. (2015). <em>bigsplines: Smoothing Splines for Large Samples</em>. http://CRAN.R-project.org/package=bigsplines
</p>
<p>Helwig, N. E. &amp; Ma, P. (2015). Fast and stable multiple smoothing parameter selection in smoothing spline analysis of variance models with large samples. <em>Journal of Computational and Graphical Statistics, 24</em>(3), 715-732.
</p>
<p>Helwig, N. E. &amp; Ma, P. (2016). Smoothing spline ANOVA for super large samples: Scalable computation via rounding parameters. <em>Statistics and Its Interface, 9</em>(4), 433-444.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1: Temporal    ##########

# get "PZ" electrode of "c" subjects in "eegdata" data
data(eegdata)
idx &lt;- which(eegdata$channel=="PZ" &amp; eegdata$group=="c")
eegdata &lt;- eegdata[idx,]

# temporal smoothing
eegmod &lt;- eegsmooth(eegdata$voltage,time=eegdata$time)

# define data for prediction
time &lt;- seq(min(eegdata$time),max(eegdata$time),length.out=100)
yhat &lt;- predict(eegmod,newdata=time,se.fit=TRUE)

# plot results using eegtime
eegtime(time*1000/255,yhat$fit,voltageSE=yhat$se.fit,ylim=c(-4,4),main="Pz")



##########   EXAMPLE 2: Spatial   ##########

# get time point 65 (approx 250 ms) of "c" subjects in "eegdata" data
data(eegdata)
idx &lt;- which(eegdata$time==65L &amp; eegdata$group=="c")
eegdata &lt;- eegdata[idx,]

# remove ears, nose, and reference (Cz)
idx &lt;- c(which(eegdata$channel=="X"),which(eegdata$channel=="Y"),
         which(eegdata$channel=="nd"),which(eegdata$channel=="Cz"))
eegdata &lt;- eegdata[-idx,]

# match to eeg coordinates
data(eegcoord)
cidx &lt;- match(eegdata$channel,rownames(eegcoord))

# spatial smoothing
eegmod &lt;- eegsmooth(eegdata$voltage,space=eegcoord[cidx,1:3])

# use dense cap for prediction
mycap &lt;- levels(factor(eegdata$channel))
ix &lt;- eegcapdense(mycap,type="2d",index=TRUE)
data(eegdense)
space &lt;- eegdense[ix,1:3]
yhat &lt;- predict(eegmod,newdata=space)

# plot results using eegspace
#eegspace(space,yhat)
eegspace(eegdense[ix,4:5],yhat)



##########   EXAMPLE 3: Spatial-Temporal (not run)   ##########

# # get "c" subjects of "eegdata" data
# data(eegdata)
# idx &lt;- which(eegdata$group=="c")
# eegdata &lt;- eegdata[idx,]

# # remove ears, nose, and reference (Cz)
# idx &lt;- c(which(eegdata$channel=="X"),which(eegdata$channel=="Y"),
#          which(eegdata$channel=="nd"),which(eegdata$channel=="Cz"))
# eegdata &lt;- eegdata[-idx,]

# # match to eeg coordinates
# data(eegcoord)
# cidx &lt;- match(eegdata$channel,rownames(eegcoord))

# # spatial-temporal smoothing
# eegmod &lt;- eegsmooth(eegdata$voltage,space=eegcoord[cidx,1:3],time=eegdata$time)

# # time main effect
# newdata &lt;- list(time=seq(min(eegdata$time),max(eegdata$time),length.out=100))
# yhat &lt;- predict(eegmod,newdata=newdata,se.fit=TRUE,include="time")
# eegtime(newdata$time,yhat$fit,voltageSE=yhat$se.fit,ylim=c(-2,4),main="Time Main Effect")

# # space main effect
# mycap &lt;- levels(factor(eegdata$channel))
# ix &lt;- eegcapdense(mycap,type="2d",index=TRUE)
# data(eegdense)
# newdata &lt;- list(space=eegdense[ix,1:3])
# yhat &lt;- predict(eegmod,newdata=newdata,include="space")
# eegspace(newdata$space,yhat)

# # interaction effect (spatial map at time point 65)
# newdata &lt;- list(space=eegdense[ix,1:3],time=rep(65,nrow(eegdense[ix,])))
# yhat &lt;- predict(eegmod,newdata=newdata,include="space:time")
# eegspace(newdata$space,yhat)

# # full prediction (spatial map at time point 65)
# newdata &lt;- list(space=eegdense[ix,1:3],time=rep(65,nrow(eegdense[ix,])))
# yhat &lt;- predict(eegmod,newdata=newdata)
# eegspace(newdata$space,yhat)

</code></pre>

<hr>
<h2 id='eegspace'>
Plots Multi-Channel EEG Spatial Map
</h2><span id='topic+eegspace'></span>

<h3>Description</h3>

<p>Creates plot of multi-channel electroencephalography (EEG) spatial map. User can control the plot type (2d or 3d), the colormap, color, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegspace(space, voltage, vlim = NULL, mycolors = NULL, ncolor = 25,
         colorbar = TRUE, nctick = 5, rtick = 1, cex.axis = 1,
         barloc = NULL, colorlab = NULL, colorlabline = 3, cex.lab = 1,
         plotaxes = FALSE, main = "", xyzlab = NULL, cex.point = 1,
         cex.main = 1, nose = TRUE, ears = TRUE, head = TRUE,
         col.head = "AntiqueWhite", mar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegspace_+3A_space">space</code></td>
<td>

<p>Matrix of input electrode coordinates (3d or 2d). 
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_voltage">voltage</code></td>
<td>

<p>Vector of recorded EEG voltage at each row in <code>space</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_vlim">vlim</code></td>
<td>

<p>Two-element vector giving the limits to use when mapping <code>voltage</code> to colors in <code>mycolors</code>. Default is <code>vlim=range(voltage)</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_mycolors">mycolors</code></td>
<td>

<p>Character vector of colors to use for color mapping (such that <code>length(mycolors)&lt;=ncolor</code>). Default: <code>mycolors=c("blueviolet","blue","cyan","green","yellow","orange","red")</code>. 
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_ncolor">ncolor</code></td>
<td>

<p>Number of colors to use in mapping (positive integer).
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_colorbar">colorbar</code></td>
<td>

<p>If <code>TRUE</code>, colorbar is plotted.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_nctick">nctick</code></td>
<td>

<p>Approximate number of ticks for colorbar. Ignored if <code>colorbar=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_rtick">rtick</code></td>
<td>

<p>Round tick labels to given decimal. Ignored if <code>colorbar=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_cex.axis">cex.axis</code></td>
<td>

<p>Cex of axis ticks for colorbar. Ignored if <code>colorbar=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_barloc">barloc</code></td>
<td>

<p>Character vector giving location of color bar. See Notes.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_colorlab">colorlab</code></td>
<td>

<p>Character vector giving label for color bar. Ignored if <code>colorbar=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_colorlabline">colorlabline</code></td>
<td>

<p>Line number for color bar label (for input to <code><a href="graphics.html#topic+mtext">mtext</a></code>).  
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_cex.lab">cex.lab</code></td>
<td>

<p>Cex of axis labels for colorbar. Ignored if <code>colorbar=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_plotaxes">plotaxes</code></td>
<td>

<p>If <code>TRUE</code>, axes labels are plotted. Ignored for 3d plots.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_main">main</code></td>
<td>

<p>Plot title. Default is no title.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_xyzlab">xyzlab</code></td>
<td>

<p>Axis labels to use for plot. If <code>type="2d"</code>, then <code>xyzlab</code> should be two-element character vector giving x and y axis labels. If <code>type="3d"</code>, then <code>xyzlab</code> should be three-element character vector giving x, y, and z axis labels.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_cex.point">cex.point</code></td>
<td>

<p>Cex for plotted electrodes.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_cex.main">cex.main</code></td>
<td>

<p>Cex for plot title. Ignored if <code>main=NULL</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_nose">nose</code></td>
<td>

<p>If <code>TRUE</code>, triangle is plotted to represent the subject's nose. Ignored if <code>ncol(space)==3</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_ears">ears</code></td>
<td>

<p>If <code>TRUE</code>, ovals are plotted to represent the subject's ears.  Ignored if <code>ncol(space)==3</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_head">head</code></td>
<td>

<p>If <code>TRUE</code>, head is plotted. Ignored if <code>type="2d"</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_col.head">col.head</code></td>
<td>

<p>Color for dummy head in 3d plot. Ignored if <code>type="2d"</code>.
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_mar">mar</code></td>
<td>

<p>Margins to use for plot (see <code>par</code>).
</p>
</td></tr>
<tr><td><code id="eegspace_+3A_...">...</code></td>
<td>

<p>Optional inputs for <code>plot</code> or <code>lines</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces plot of EEG spatial map with <code>NULL</code> return value.
</p>


<h3>Note</h3>

<p>For 3d plots, <code>barloc</code> can be one of four options: <code>"backright"</code>, <code>"backleft"</code>, <code>"frontright"</code>, or <code>"frontleft"</code>. For 2d plots, <code>barloc</code> can be either <code>"right"</code> or <code>"left"</code>.
</p>
<p>Currently supports spatial maps registered to the 84-channel cap produced by <code><a href="#topic+eegcap">eegcap</a></code> and <code><a href="#topic+eegcoord">eegcoord</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Bache, K. &amp; Lichman, M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.
</p>
<p>Begleiter, H. <em>Neurodynamics Laboratory</em>. State University of New York Health Center at Brooklyn. http://www.downstate.edu/hbnl/
</p>
<p>Ingber, L. (1997). Statistical mechanics of neocortical interactions: Canonical momenta indicatros of electroencephalography. <em>Physical Review E, 55</em>, 4578-4593.
</p>
<p>Ingber, L. (1998). Statistical mechanics of neocortical interactions: Training and testing canonical momenta indicators of EEG. <em>Mathematical Computer Modelling, 27</em>, 33-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

# get time point 65 (approx 250 ms) from "eegdata" data
data(eegdata)
idx &lt;- which(eegdata$time==65L)
eegdata &lt;- eegdata[idx,]

# get average spatial map
eegmean &lt;- tapply(eegdata$voltage,list(eegdata$channel,eegdata$group),mean)

# remove ears and nose
acnames &lt;- rownames(eegmean)
idx &lt;- c(which(acnames=="X"),which(acnames=="Y"),which(acnames=="nd"),which(acnames=="Cz"))
eegmean &lt;- eegmean[-idx,]

# match to eeg coordinates
data(eegcoord)
cidx &lt;- match(rownames(eegmean),rownames(eegcoord))

# # plot average control voltage in 3d
# open3d()
# eegspace(eegcoord[cidx,1:3],eegmean[,2])

# plot average control voltage in 2d
eegspace(eegcoord[cidx,4:5],eegmean[,2])

# # change 3d bar location and use play3d to rotate (not run)
# open3d()
# par3d(windowRect=c(0,0,600,600))
# eegspace(eegcoord[cidx,1:3],eegmean[,2],barloc="frontleft")
# play3d(spin3d(axis=c(0,0,1),rpm=5),duration=20)

# change 2d bar location
eegspace(eegcoord[cidx,4:5],eegmean[,2],barloc="left")

</code></pre>

<hr>
<h2 id='eegtime'>
Plots Single-Channel EEG Time Course
</h2><span id='topic+eegtime'></span>

<h3>Description</h3>

<p>Creates plot of single-channel electroencephalography (EEG) time course with optional confidence interval. User can control the plot orientation, line types, line colors, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegtime(time, voltage, flipvoltage = TRUE, vlty = 1, vlwd = 2,
        vcol = "blue", voltageSE = NULL, slty = NA, slwd = 1,
        scol = "cyan", salpha = 0.65, conflevel = 0.95,
        plotzero = TRUE, zlty = 1, zlwd = 0.5, zcol = "black",
        xlim = NULL, ylim = NULL, xlab = NULL, ylab = NULL,
        nxtick = 6, nytick = 6, xticks = NULL, yticks = NULL,
        add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegtime_+3A_time">time</code></td>
<td>

<p>Vector of time points at which EEG was recorded.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_voltage">voltage</code></td>
<td>

<p>Vector of recorded EEG voltage at each point in <code>time</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_flipvoltage">flipvoltage</code></td>
<td>

<p>If <code>TRUE</code>, negative voltages are plotted upwards.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_vlty">vlty</code></td>
<td>

<p>Line type for <code>voltage</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_vlwd">vlwd</code></td>
<td>

<p>Line width for <code>voltage</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_vcol">vcol</code></td>
<td>

<p>Line color for <code>voltage</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_voltagese">voltageSE</code></td>
<td>

<p>Vector of standard errors of EEG voltage at each point in <code>time</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_slty">slty</code></td>
<td>

<p>Line type for <code>voltageSE</code>. If <code>slty=NA</code> (default) shaded polygons are plotted.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_slwd">slwd</code></td>
<td>

<p>Line width for <code>voltageSE</code>. Ignored if <code>slty=NA</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_scol">scol</code></td>
<td>

<p>Polygon or line color for <code>voltageSE</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_salpha">salpha</code></td>
<td>

<p>Transparency value for <code>voltageSE</code> polygon (only used if <code>slty=NA</code>).
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_conflevel">conflevel</code></td>
<td>

<p>Confidence level to use for confidence intervals. Default forms 95% CI.   
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_plotzero">plotzero</code></td>
<td>

<p>If <code>TRUE</code>, horizontal reference line is plotted at 0 volts.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_zlty">zlty</code></td>
<td>

<p>Line type for reference line. Ignored if <code>plotzero=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_zlwd">zlwd</code></td>
<td>

<p>Line width for reference line. Ignored if <code>plotzero=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_zcol">zcol</code></td>
<td>

<p>Line color for reference line. Ignored if <code>plotzero=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_xlim">xlim</code></td>
<td>

<p>Plot limits for <code>time</code>.  
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_ylim">ylim</code></td>
<td>

<p>Plot limits for <code>voltage</code>. 
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_xlab">xlab</code></td>
<td>

<p>Plot label for <code>time</code>.  
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_ylab">ylab</code></td>
<td>

<p>Plot label for <code>voltage</code>. 
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_nxtick">nxtick</code></td>
<td>

<p>Approximate number of axis ticks for <code>time</code>.  
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_nytick">nytick</code></td>
<td>

<p>Approximate number of axis ticks <code>voltage</code>. 
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_xticks">xticks</code></td>
<td>

<p>x-axis ticks for <code>time</code> (overrides <code>nxtick</code>).  
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_yticks">yticks</code></td>
<td>

<p>y-axis ticks <code>voltage</code> (overrides <code>nytick</code>). 
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_add">add</code></td>
<td>

<p>If <code>TRUE</code>, lines are added to current plot; otherwise a new plot is created.  
</p>
</td></tr>
<tr><td><code id="eegtime_+3A_...">...</code></td>
<td>

<p>Optional inputs for <code>plot</code> or <code>lines</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces plot of EEG time course with <code>NULL</code> return value.
</p>


<h3>Note</h3>

<p>Confidence intervals are formed using the normal (Gaussian) distribution.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Bache, K. &amp; Lichman, M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.
</p>
<p>Begleiter, H. <em>Neurodynamics Laboratory</em>. State University of New York Health Center at Brooklyn. http://www.downstate.edu/hbnl/
</p>
<p>Ingber, L. (1997). Statistical mechanics of neocortical interactions: Canonical momenta indicatros of electroencephalography. <em>Physical Review E, 55</em>, 4578-4593.
</p>
<p>Ingber, L. (1998). Statistical mechanics of neocortical interactions: Training and testing canonical momenta indicators of EEG. <em>Mathematical Computer Modelling, 27</em>, 33-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

# get "PZ" electrode from "eegdata" data
data(eegdata)
idx &lt;- which(eegdata$channel=="PZ")
eegdata &lt;- eegdata[idx,]

# get average and standard error (note se=sd/sqrt(n))
eegmean &lt;- tapply(eegdata$voltage,list(eegdata$time,eegdata$group),mean)
eegse &lt;- tapply(eegdata$voltage,list(eegdata$time,eegdata$group),sd)/sqrt(50) 

# plot results with legend
tseq &lt;- seq(0,1000,length.out=256)
eegtime(tseq,eegmean[,2],voltageSE=eegse[,2],ylim=c(-10,6),main="Pz")
eegtime(tseq,eegmean[,1],vlty=2,vcol="red",voltageSE=eegse[,1],scol="pink",add=TRUE)
legend("bottomright",c("controls","alcoholics"),lty=c(1,2),
       lwd=c(2,2),col=c("blue","red"),bty="n")

</code></pre>

<hr>
<h2 id='eegtimemc'>
Plots Multi-Channel EEG Time Course
</h2><span id='topic+eegtimemc'></span>

<h3>Description</h3>

<p>Creates plot of multi-channel electroencephalography (EEG) time courses with subplots positioned according to electrode locations. User can control the plot orientation, line types, line colors, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eegtimemc(time, voltmat, channel, size = c(0.75,0.75),
          vadj = 0.5, hadj = 0.5, xlab = "", ylab = "",
          voltSE = NULL, vlty = 1, slty = NA, vlwd = 1,
          slwd = 1, vcol = "blue", scol = "cyan", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eegtimemc_+3A_time">time</code></td>
<td>

<p>Vector of time points at which EEG was recorded.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_voltmat">voltmat</code></td>
<td>

<p>Matrix of multi-channel EEG voltages (time by channel). 
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_channel">channel</code></td>
<td>

<p>Character vector giving name of channel for each column of <code>voltmat</code>. 
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_size">size</code></td>
<td>

<p>Relative size of each subplot.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_vadj">vadj</code></td>
<td>

<p>Vertical adjustment for each subplot.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_hadj">hadj</code></td>
<td>

<p>Horizontal adjustment for each subplot.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_xlab">xlab</code></td>
<td>

<p>X-axis label for each subplot.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_ylab">ylab</code></td>
<td>

<p>Y-axis label for each subplot.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_voltse">voltSE</code></td>
<td>

<p>Matrix of voltage standard errors (same size as <code>voltmat</code>).
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_vlty">vlty</code></td>
<td>

<p>Line type for <code>voltmat</code>.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_slty">slty</code></td>
<td>

<p>Line type for <code>voltSE</code>. If <code>slty=NA</code> (default) shaded polygons are plotted.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_vlwd">vlwd</code></td>
<td>

<p>Line width for <code>voltmat</code>.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_slwd">slwd</code></td>
<td>

<p>Line width for <code>voltSE</code>. Ignored if <code>slty=NA</code>.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_vcol">vcol</code></td>
<td>

<p>Line color for <code>voltmat</code>.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_scol">scol</code></td>
<td>

<p>Polygon or line color for <code>voltSE</code>.
</p>
</td></tr>
<tr><td><code id="eegtimemc_+3A_...">...</code></td>
<td>

<p>Optional inputs for <code>eegtime</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces plot of EEG time course with <code>NULL</code> return value.
</p>


<h3>Note</h3>

<p>Currently supports 84 scalp electrodes (plus ears and nose):
A1   A2   AF1  AF2  AF3  AF4  AF5  AF6  AF7  AF8  AFZ  C1   C2   C3   C4   
C5   C6   CP1  CP2  CP3  CP4  CP5  CP6  CPZ  CZ   F1   F2   F3   F4   F5   
F6   F7   F8   F9   F10  FC1  FC2  FC3  FC4  FC5  FC6  FCZ  FP1  FP2  FPZ  
FT7  FT8  FT9  FT10 FZ   I1   I2   IZ   NZ   O1   O2   OZ   P1   P2   P3   
P4   P5   P6   P7   P8   P9   P10  PO1  PO2  PO3  PO4  PO5  PO6  PO7  PO8  
PO9  PO10 POZ  PZ   T7   T8   T9   T10  TP7  TP8  TP9  TP10
</p>
<p>Subplots are created using <code>eegtime</code>, so input <code>...</code> can be any optional input for <code>eegtime</code>.
</p>
<p>Inspired by Frank Harrell's subplot function (in Hmisc package).
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Bache, K. &amp; Lichman, M. (2013). UCI Machine Learning Repository [http://archive.ics.uci.edu/ml]. Irvine, CA: University of California, School of Information and Computer Science.
</p>
<p>Begleiter, H. <em>Neurodynamics Laboratory</em>. State University of New York Health Center at Brooklyn. http://www.downstate.edu/hbnl/
</p>
<p>Harrell, F., Dupont, C., and Others. <em>Hmisc: Harrell Miscellaneous</em>. http://CRAN.R-project.org/package=Hmisc
</p>
<p>Ingber, L. (1997). Statistical mechanics of neocortical interactions: Canonical momenta indicatros of electroencephalography. <em>Physical Review E, 55</em>, 4578-4593.
</p>
<p>Ingber, L. (1998). Statistical mechanics of neocortical interactions: Training and testing canonical momenta indicators of EEG. <em>Mathematical Computer Modelling, 27</em>, 33-64.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

# # get control ("c") data from "eegdata" data
# data(eegdata)
# idx &lt;- which(eegdata$group=="c")
# eegdata &lt;- eegdata[idx,]

# # get average 
# eegmean &lt;- tapply(eegdata$voltage,list(eegdata$time,eegdata$channel),mean)
# eegse &lt;- tapply(eegdata$voltage,list(eegdata$time,eegdata$channel),sd)/sqrt(50)

# # plot time course for all electrodes
# dev.new(height=15,width=15, noRStudioGD = TRUE)
# tseq &lt;- seq(0,1000,length.out=256)
# eegtimemc(tseq,eegmean,colnames(eegmean),ylim=c(-11,14),voltSE=eegse)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
