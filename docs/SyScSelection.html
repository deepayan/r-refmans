<!DOCTYPE html><html><head><title>Help for package SyScSelection</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SyScSelection}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baseb_expansion'><p>Adds the next base-b element to an existing base-b sequence</p></a></li>
<li><a href='#calc_mesh_size'><p>Calculates the number of points in a mesh of fineness phi, covering a hypercube in d dimensions</p></a></li>
<li><a href='#center_at_origin'><p>Creates a new ellipsoid object equivalent to the given hyperellipsoid (hellipse), but centered at the origin.</p></a></li>
<li><a href='#fill_adj_2Dface'><p>Creates a phi x phi grid (i.e., the mesh on a single two-dimensional face of a larger hypercube) of d-dimensional points, where the regularity of the grid has been adjusted to avoid  clustering in the corners.</p></a></li>
<li><a href='#fill_adj_2Dface_beta'><p>Calculates the factor, beta in [0, 1], that interpolates the pth equidistant point between the two endpoints, z_one and z_phi, for and adjusted 2D mesh of fineness phi in d dimensions.</p></a></li>
<li><a href='#fill_corners'><p>Systematically fills a given mesh array (cmesh) with d-dimensional  points representing every corner of a d-dimensional hypercube. The function fills the successive dimensions of each point via depth-first recursion across all d dimensions.</p></a></li>
<li><a href='#get'><p>Get hyperellipsoid property from the specified object and return the value.</p>
Property names are:
center, shape, and size</a></li>
<li><a href='#hypercube_mesh'><p>Generates a Cartesian mesh of d-dimensional scenarios based on the given ellipsoid. This function does not assume that the ellipsoid is centered at the origin.</p></a></li>
<li><a href='#hyperellipsoid'><p>Hyperellipsoid class constructor</p></a></li>
<li><a href='#make_corners'><p>Fills a mesh (corn_mesh) with d-dimensional points representing all corners of a d-dimensional cube encompassing a d-dimensional unit spheroid.</p></a></li>
<li><a href='#make_edges'><p>Fills a mesh with d-dimensional points representing all non-corner edge points of a d-dimensional cube encompassing a  d-dimensional unit spheroid.</p></a></li>
<li><a href='#make_ellipsoid_from_vertices'><p>Constructs a new d-dimensional ellipsoid with the given &quot;positive vertices&quot;, and size parameter, c.  The constructed ellipsoid is centered at the origin.Note that the input vertices (i.e., the columns of V) must therefore be orthogonal vectors, themselves centered at the origin.The size parameter, c, may be needed because the points alone only determine the eigenvalues up to a positive constant. For vertices which fall on the constructed ellipsoid, choose as the size parameterc = 1.The new ellipsoid is centered at the origin.</p></a></li>
<li><a href='#make_faces'><p>Fills a mesh with d-dimensional points representing all non-edge face points of a d-dimensional cube encompassing a  d-dimensional unit spheroid.</p></a></li>
<li><a href='#new_baseb_expansion'><p>Creates a new base-b sequence of a designated length</p></a></li>
<li><a href='#rotate_to_coordaxes'><p>Rotates the ellipsoid (hellip) so its principal axes align with the coordinate axes.  Both ellipsoids are centered at the origin.  Note that there are (2^d)*d! valid ways to rotate the ellipsoid to the axes. This algorithm does not prescribe which solution will be provided.</p></a></li>
<li><a href='#sizeparam_normal_distn'><p>Calculates the size paramater for a d-dimensional hyperellipsoid conforming to a normal (i.e., Gaussian) distribution.</p></a></li>
<li><a href='#sizeparam_t_distn'><p>Calculates the size paramater for a d-dimensional hyperellipsoid conforming to a Student's t distribution.</p></a></li>
<li><a href='#spheroid_mesh'><p>Generates a Cartesian mesh of d-dimensional scenarios based on the given ellipsoid.  This function does not assume that the ellipsoid is centered at the origin.</p></a></li>
<li><a href='#stretch_to_unitspheroid'><p>Stretches the ellipsoid (hellip) to the unit spheroid of the same dimension.  Both the input ellipsoid and unit spheroid are centered at the origin.</p></a></li>
<li><a href='#transform_ellipsoid'><p>Applies the given linear transformation, tfm, to the given ellipsoid.  The ellipsoid (hellip) must be centered at the origin.</p></a></li>
<li><a href='#univariate_shocks'><p>Calculates 2d d-dimensional univariate shocks (up and down in each of the d dimensions) based on the given  ellipsoid. Univariate shocks are points on the surface of the ellipsoid that differ from the center of the  ellipsoid in only one dimension. Thus, for an ellipsoid centered at the origin, only one element of a d-dimensional shock will be non-zero.This function does not assume that the ellipsoid is centered at the origin.</p></a></li>
<li><a href='#vertices'><p>Finds the d d-dimensional positive vertices for the  given ellipsoid.  A &quot;positive&quot; vertex is one where a  principal axis for the ellipsoid intersects the surface  of the ellipsoid in the direction of the corresponding eigenvector.  (Recall that each of the eigenvectors of  the ellipsoid's shape matrix is collinear with one of the  principal axes.)  This function does not assume that the ellipsoid is centered at the origin.  Because the    direction of each unit eigenvector is arbitrary (i.e., multiplication by -1 still yields a unit eigenvector), a simple algorithm is used to pick a consistent orientation for the vertex points.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Systematic Scenario Selection for Stress Testing</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Merlin Kopfmann</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Merlin Kopfmann &lt;mghncd+cran@posteo.jp&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quasi-Monte-Carlo algorithm for systematic generation of shock scenarios from an arbitrary multivariate elliptical distribution. The algorithm selects a systematic mesh of arbitrary fineness that approximately evenly covers an isoprobability ellipsoid in d dimensions (Flood, Mark D. &amp; Korenko, George G. (2013) &lt;<a href="https://doi.org/10.1080%2F14697688.2014.926018">doi:10.1080/14697688.2014.926018</a>&gt;).
  This package is the 'R' analogy to the 'Matlab' code published by Flood &amp; Korenko in above-mentioned paper.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>pracma, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-26 12:45:08 UTC; merlin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-26 14:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='baseb_expansion'>Adds the next base-b element to an existing base-b sequence</h2><span id='topic+baseb_expansion'></span>

<h3>Description</h3>

<p>Adds the next base-b element to an existing base-b sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseb_expansion(ain, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baseb_expansion_+3A_ain">ain</code></td>
<td>
<p>Either a an array containing an existing base-b expansion, or a scalar integer indicating the length for a new base-b expansion</p>
</td></tr>
<tr><td><code id="baseb_expansion_+3A_b">b</code></td>
<td>
<p>Base for integer expansions used in the sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An expanded base-b expansion
</p>

<hr>
<h2 id='calc_mesh_size'>Calculates the number of points in a mesh of fineness phi, covering a hypercube in d dimensions</h2><span id='topic+calc_mesh_size'></span>

<h3>Description</h3>

<p>Calculates the number of points in a mesh of fineness phi, covering a hypercube in d dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_mesh_size(phi, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_mesh_size_+3A_phi">phi</code></td>
<td>
<p>The scalar fineness of the mesh</p>
</td></tr>
<tr><td><code id="calc_mesh_size_+3A_d">d</code></td>
<td>
<p>The number of dimensions for the unit spheroid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of: corner_pts - Count of points extreme (+/- 1) in all dim, edge_pts - Count of points extreme in all but one dimen, face_pts - Count of points extreme in all but two dimen, total_pts - Sum of:  corner_pts + edge_pts + face_pts
</p>

<hr>
<h2 id='center_at_origin'>Creates a new ellipsoid object equivalent to the given hyperellipsoid (hellipse), but centered at the origin.</h2><span id='topic+center_at_origin'></span>

<h3>Description</h3>

<p>Creates a new ellipsoid object equivalent to the given hyperellipsoid (hellipse), but centered at the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_at_origin(hellip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_at_origin_+3A_hellip">hellip</code></td>
<td>
<p>The original object, to be shifted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two: hellip2 - the re-centered hyperellipsoid and mu - the amount of the translation
</p>

<hr>
<h2 id='fill_adj_2Dface'>Creates a phi x phi grid (i.e., the mesh on a single two-dimensional face of a larger hypercube) of d-dimensional points, where the regularity of the grid has been adjusted to avoid  clustering in the corners.</h2><span id='topic+fill_adj_2Dface'></span>

<h3>Description</h3>

<p>Creates a phi x phi grid (i.e., the mesh on a single two-dimensional face of a larger hypercube) of d-dimensional points, where the regularity of the grid has been adjusted to avoid  clustering in the corners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_adj_2Dface(d, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_adj_2Dface_+3A_d">d</code></td>
<td>
<p>The number of dimensions for the unit spheroid</p>
</td></tr>
<tr><td><code id="fill_adj_2Dface_+3A_phi">phi</code></td>
<td>
<p>Fineness of the mesh along each dimension of the 2D face</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phi x phi x d array of points.  The points (each facemesh2D(i,j,:)) are identically equal to one in the first d-2 dimensions, so that the mesh varies only in the final two dimensions.
</p>

<hr>
<h2 id='fill_adj_2Dface_beta'>Calculates the factor, beta in [0, 1], that interpolates the pth equidistant point between the two endpoints, z_one and z_phi, for and adjusted 2D mesh of fineness phi in d dimensions.</h2><span id='topic+fill_adj_2Dface_beta'></span>

<h3>Description</h3>

<p>Calculates the factor, beta in [0, 1], that interpolates the pth equidistant point between the two endpoints, z_one and z_phi, for and adjusted 2D mesh of fineness phi in d dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_adj_2Dface_beta(p, phi, z_one, z_phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_adj_2Dface_beta_+3A_p">p</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="fill_adj_2Dface_beta_+3A_phi">phi</code></td>
<td>
<p>Fineness of the mesh along each dimension of the 2D face</p>
</td></tr>
<tr><td><code id="fill_adj_2Dface_beta_+3A_z_one">z_one</code></td>
<td>
<p>...</p>
</td></tr>
<tr><td><code id="fill_adj_2Dface_beta_+3A_z_phi">z_phi</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta
</p>

<hr>
<h2 id='fill_corners'>Systematically fills a given mesh array (cmesh) with d-dimensional  points representing every corner of a d-dimensional hypercube. The function fills the successive dimensions of each point via depth-first recursion across all d dimensions.</h2><span id='topic+fill_corners'></span>

<h3>Description</h3>

<p>Systematically fills a given mesh array (cmesh) with d-dimensional  points representing every corner of a d-dimensional hypercube. The function fills the successive dimensions of each point via depth-first recursion across all d dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_corners(cmesh, shock, shk_curs, dim_curs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_corners_+3A_cmesh">cmesh</code></td>
<td>
<p>The mesh to be filled with corner points</p>
</td></tr>
<tr><td><code id="fill_corners_+3A_shock">shock</code></td>
<td>
<p>The current shock vector being filled</p>
</td></tr>
<tr><td><code id="fill_corners_+3A_shk_curs">shk_curs</code></td>
<td>
<p>Index in cmesh of the shock currently being filled</p>
</td></tr>
<tr><td><code id="fill_corners_+3A_dim_curs">dim_curs</code></td>
<td>
<p>Index in the current shock of the dimension being filled</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:  cmesh - d x 2^d array of corner points being filled, shk_curs - last point in cmesh that was filled
</p>

<hr>
<h2 id='get'>Get hyperellipsoid property from the specified object and return the value.
Property names are:
center, shape, and size</h2><span id='topic+get'></span>

<h3>Description</h3>

<p>Get hyperellipsoid property from the specified object and return the value.
Property names are:
center, shape, and size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get(hellip, propName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_+3A_hellip">hellip</code></td>
<td>
<p>A valid hyperellipsoid object</p>
</td></tr>
<tr><td><code id="get_+3A_propname">propName</code></td>
<td>
<p>A string of the desired property</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the indicated property
</p>

<hr>
<h2 id='hypercube_mesh'>Generates a Cartesian mesh of d-dimensional scenarios based on the given ellipsoid. This function does not assume that the ellipsoid is centered at the origin.</h2><span id='topic+hypercube_mesh'></span>

<h3>Description</h3>

<p>Generates a Cartesian mesh of d-dimensional scenarios based on the given ellipsoid. This function does not assume that the ellipsoid is centered at the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hypercube_mesh(phi, hellip, normalize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hypercube_mesh_+3A_phi">phi</code></td>
<td>
<p>The scalar fineness of the mesh</p>
</td></tr>
<tr><td><code id="hypercube_mesh_+3A_hellip">hellip</code></td>
<td>
<p>The basis for the shocks; it must have measurable width in every dimension</p>
</td></tr>
<tr><td><code id="hypercube_mesh_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize points from the cube onto the sphere or not (TRUE/FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A d x N array, with each column a scenario
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hellip &lt;- hyperellipsoid()
hypercube_mesh(3,hellip,TRUE)
</code></pre>

<hr>
<h2 id='hyperellipsoid'>Hyperellipsoid class constructor</h2><span id='topic+hyperellipsoid'></span>

<h3>Description</h3>

<p>Hyperellipsoid class constructor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperellipsoid(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperellipsoid_+3A_...">...</code></td>
<td>
<p>mu - The vector for the center point,
sig - The matrix determining the shape; for elliptical probability distributions, sig will be the inverse dispersion matrix,
c - The scalar determining the size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new hyperellipsoid object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hyperellipsoid()
</code></pre>

<hr>
<h2 id='make_corners'>Fills a mesh (corn_mesh) with d-dimensional points representing all corners of a d-dimensional cube encompassing a d-dimensional unit spheroid.</h2><span id='topic+make_corners'></span>

<h3>Description</h3>

<p>Fills a mesh (corn_mesh) with d-dimensional points representing all corners of a d-dimensional cube encompassing a d-dimensional unit spheroid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_corners(d, normalize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_corners_+3A_d">d</code></td>
<td>
<p>The number of dimensions for the unit spheroid</p>
</td></tr>
<tr><td><code id="make_corners_+3A_normalize">normalize</code></td>
<td>
<p>Whether to scale the corner points onto the sphere or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A d x 2^d array of corner points
</p>

<hr>
<h2 id='make_edges'>Fills a mesh with d-dimensional points representing all non-corner edge points of a d-dimensional cube encompassing a  d-dimensional unit spheroid.</h2><span id='topic+make_edges'></span>

<h3>Description</h3>

<p>Fills a mesh with d-dimensional points representing all non-corner edge points of a d-dimensional cube encompassing a  d-dimensional unit spheroid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_edges(d, phi, normalize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_edges_+3A_d">d</code></td>
<td>
<p>The number of dimensions for the unit spheroid</p>
</td></tr>
<tr><td><code id="make_edges_+3A_phi">phi</code></td>
<td>
<p>Fineness of the mesh along the edge (i.e., the total number of points, &quot;including&quot; the corners)</p>
</td></tr>
<tr><td><code id="make_edges_+3A_normalize">normalize</code></td>
<td>
<p>Whether to scale the corner points onto the sphere or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A d x d*2^(d-1)*(phi-2) array of edge points
</p>

<hr>
<h2 id='make_ellipsoid_from_vertices'>Constructs a new d-dimensional ellipsoid with the given &quot;positive vertices&quot;, and size parameter, c.  The constructed ellipsoid is centered at the origin.Note that the input vertices (i.e., the columns of V) must therefore be orthogonal vectors, themselves centered at the origin.The size parameter, c, may be needed because the points alone only determine the eigenvalues up to a positive constant. For vertices which fall on the constructed ellipsoid, choose as the size parameterc = 1.The new ellipsoid is centered at the origin.</h2><span id='topic+make_ellipsoid_from_vertices'></span>

<h3>Description</h3>

<p>Constructs a new d-dimensional ellipsoid with the given &quot;positive vertices&quot;, and size parameter, c.  The constructed ellipsoid is centered at the origin.Note that the input vertices (i.e., the columns of V) must therefore be orthogonal vectors, themselves centered at the origin.The size parameter, c, may be needed because the points alone only determine the eigenvalues up to a positive constant. For vertices which fall on the constructed ellipsoid, choose as the size parameterc = 1.The new ellipsoid is centered at the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ellipsoid_from_vertices(V, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ellipsoid_from_vertices_+3A_v">V</code></td>
<td>
<p>A d x d array of positive vertices (in columns)</p>
</td></tr>
<tr><td><code id="make_ellipsoid_from_vertices_+3A_c">c</code></td>
<td>
<p>The size parameter of the new ellipsoid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new ellipsoid, centered at the origin, with the given vertices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hellip &lt;- hyperellipsoid()
V &lt;- vertices(hellip)
c &lt;- 4
make_ellipsoid_from_vertices(V,c)
</code></pre>

<hr>
<h2 id='make_faces'>Fills a mesh with d-dimensional points representing all non-edge face points of a d-dimensional cube encompassing a  d-dimensional unit spheroid.</h2><span id='topic+make_faces'></span>

<h3>Description</h3>

<p>Fills a mesh with d-dimensional points representing all non-edge face points of a d-dimensional cube encompassing a  d-dimensional unit spheroid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_faces(d, phi, normalize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_faces_+3A_d">d</code></td>
<td>
<p>The number of dimensions for the unit spheroid</p>
</td></tr>
<tr><td><code id="make_faces_+3A_phi">phi</code></td>
<td>
<p>Fineness of the mesh along each dimension of the 2D face</p>
</td></tr>
<tr><td><code id="make_faces_+3A_normalize">normalize</code></td>
<td>
<p>Whether to scale the corner points onto the sphere or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A d x d*(d-1)*2^(d-3)*(phi-2)^2 array of face points
</p>

<hr>
<h2 id='new_baseb_expansion'>Creates a new base-b sequence of a designated length</h2><span id='topic+new_baseb_expansion'></span>

<h3>Description</h3>

<p>Creates a new base-b sequence of a designated length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_baseb_expansion(k, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_baseb_expansion_+3A_k">k</code></td>
<td>
<p>The integer to expand</p>
</td></tr>
<tr><td><code id="new_baseb_expansion_+3A_b">b</code></td>
<td>
<p>Base for integer expansions used in the sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The expansion of the integer k
</p>

<hr>
<h2 id='rotate_to_coordaxes'>Rotates the ellipsoid (hellip) so its principal axes align with the coordinate axes.  Both ellipsoids are centered at the origin.  Note that there are (2^d)*d! valid ways to rotate the ellipsoid to the axes. This algorithm does not prescribe which solution will be provided.</h2><span id='topic+rotate_to_coordaxes'></span>

<h3>Description</h3>

<p>Rotates the ellipsoid (hellip) so its principal axes align with the coordinate axes.  Both ellipsoids are centered at the origin.  Note that there are (2^d)*d! valid ways to rotate the ellipsoid to the axes. This algorithm does not prescribe which solution will be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate_to_coordaxes(hellip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_to_coordaxes_+3A_hellip">hellip</code></td>
<td>
<p>The shape to be rotated, must be centered at the origin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of: hellip2 - A new hyperellipsoid, rotated to the coordinate axes and tfm - the transformation matrix that creates the rotation
</p>

<hr>
<h2 id='sizeparam_normal_distn'>Calculates the size paramater for a d-dimensional hyperellipsoid conforming to a normal (i.e., Gaussian) distribution.</h2><span id='topic+sizeparam_normal_distn'></span>

<h3>Description</h3>

<p>Calculates the size paramater for a d-dimensional hyperellipsoid conforming to a normal (i.e., Gaussian) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeparam_normal_distn(prob, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sizeparam_normal_distn_+3A_prob">prob</code></td>
<td>
<p>The target probability threshold</p>
</td></tr>
<tr><td><code id="sizeparam_normal_distn_+3A_d">d</code></td>
<td>
<p>Number of dimensions in the multivariate distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The appropriate (scalar) size parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sizeparam_normal_distn(0.95, 6)
</code></pre>

<hr>
<h2 id='sizeparam_t_distn'>Calculates the size paramater for a d-dimensional hyperellipsoid conforming to a Student's t distribution.</h2><span id='topic+sizeparam_t_distn'></span>

<h3>Description</h3>

<p>Calculates the size paramater for a d-dimensional hyperellipsoid conforming to a Student's t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeparam_t_distn(prob, d, nu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sizeparam_t_distn_+3A_prob">prob</code></td>
<td>
<p>The target probability threshold</p>
</td></tr>
<tr><td><code id="sizeparam_t_distn_+3A_d">d</code></td>
<td>
<p>Number of dimensions in the multivariate distribution</p>
</td></tr>
<tr><td><code id="sizeparam_t_distn_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom parameter for the t distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The appropriate (scalar) size parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sizeparam_t_distn(0.95, 6, 5)
</code></pre>

<hr>
<h2 id='spheroid_mesh'>Generates a Cartesian mesh of d-dimensional scenarios based on the given ellipsoid.  This function does not assume that the ellipsoid is centered at the origin.</h2><span id='topic+spheroid_mesh'></span>

<h3>Description</h3>

<p>Generates a Cartesian mesh of d-dimensional scenarios based on the given ellipsoid.  This function does not assume that the ellipsoid is centered at the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spheroid_mesh(d, phi, normalize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spheroid_mesh_+3A_d">d</code></td>
<td>
<p>The number of dimensions for the unit spheroid</p>
</td></tr>
<tr><td><code id="spheroid_mesh_+3A_phi">phi</code></td>
<td>
<p>The scalar fineness of the mesh</p>
</td></tr>
<tr><td><code id="spheroid_mesh_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize points from the cube onto the sphere or not (TRUE/FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A d x N array with each column a scenario
</p>

<hr>
<h2 id='stretch_to_unitspheroid'>Stretches the ellipsoid (hellip) to the unit spheroid of the same dimension.  Both the input ellipsoid and unit spheroid are centered at the origin.</h2><span id='topic+stretch_to_unitspheroid'></span>

<h3>Description</h3>

<p>Stretches the ellipsoid (hellip) to the unit spheroid of the same dimension.  Both the input ellipsoid and unit spheroid are centered at the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stretch_to_unitspheroid(hellip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stretch_to_unitspheroid_+3A_hellip">hellip</code></td>
<td>
<p>The original shape to be stretched</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of: hellip1 - a new unit spheroid, mapped from the ellipsoid and tfm - transformation matrix that creates the stretching
</p>

<hr>
<h2 id='transform_ellipsoid'>Applies the given linear transformation, tfm, to the given ellipsoid.  The ellipsoid (hellip) must be centered at the origin.</h2><span id='topic+transform_ellipsoid'></span>

<h3>Description</h3>

<p>Applies the given linear transformation, tfm, to the given ellipsoid.  The ellipsoid (hellip) must be centered at the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_ellipsoid(hellip, tfm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_ellipsoid_+3A_hellip">hellip</code></td>
<td>
<p>The original shape to be transformed</p>
</td></tr>
<tr><td><code id="transform_ellipsoid_+3A_tfm">tfm</code></td>
<td>
<p>A d x d linear transformation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transformed ellipsoid, centered at the origin
</p>

<hr>
<h2 id='univariate_shocks'>Calculates 2d d-dimensional univariate shocks (up and down in each of the d dimensions) based on the given  ellipsoid. Univariate shocks are points on the surface of the ellipsoid that differ from the center of the  ellipsoid in only one dimension. Thus, for an ellipsoid centered at the origin, only one element of a d-dimensional shock will be non-zero.This function does not assume that the ellipsoid is centered at the origin.</h2><span id='topic+univariate_shocks'></span>

<h3>Description</h3>

<p>Calculates 2d d-dimensional univariate shocks (up and down in each of the d dimensions) based on the given  ellipsoid. Univariate shocks are points on the surface of the ellipsoid that differ from the center of the  ellipsoid in only one dimension. Thus, for an ellipsoid centered at the origin, only one element of a d-dimensional shock will be non-zero.This function does not assume that the ellipsoid is centered at the origin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>univariate_shocks(hellip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="univariate_shocks_+3A_hellip">hellip</code></td>
<td>
<p>the basis for the shocks; it must have measurable width in every dimension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A d x 2d array, [dx2d], with each column a shock; the first d columns are positive univariate shocks, and final d columns are matching negative univariate shocks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hellip &lt;- hyperellipsoid()
univariate_shocks(hellip)
</code></pre>

<hr>
<h2 id='vertices'>Finds the d d-dimensional positive vertices for the  given ellipsoid.  A &quot;positive&quot; vertex is one where a  principal axis for the ellipsoid intersects the surface  of the ellipsoid in the direction of the corresponding eigenvector.  (Recall that each of the eigenvectors of  the ellipsoid's shape matrix is collinear with one of the  principal axes.)  This function does not assume that the ellipsoid is centered at the origin.  Because the    direction of each unit eigenvector is arbitrary (i.e., multiplication by -1 still yields a unit eigenvector), a simple algorithm is used to pick a consistent orientation for the vertex points.</h2><span id='topic+vertices'></span>

<h3>Description</h3>

<p>Finds the d d-dimensional positive vertices for the  given ellipsoid.  A &quot;positive&quot; vertex is one where a  principal axis for the ellipsoid intersects the surface  of the ellipsoid in the direction of the corresponding eigenvector.  (Recall that each of the eigenvectors of  the ellipsoid's shape matrix is collinear with one of the  principal axes.)  This function does not assume that the ellipsoid is centered at the origin.  Because the    direction of each unit eigenvector is arbitrary (i.e., multiplication by -1 still yields a unit eigenvector), a simple algorithm is used to pick a consistent orientation for the vertex points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertices(hellip)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertices_+3A_hellip">hellip</code></td>
<td>
<p>defines the polar vertices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A d x d array with each column a positive vertex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hellip &lt;- hyperellipsoid()
vertices(hellip)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
