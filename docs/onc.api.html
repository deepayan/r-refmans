<!DOCTYPE html><html><head><title>Help for package onc.api</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {onc.api}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.appendList'><p>Helper that appends a list item to a list of lists</p></a></li>
<li><a href='#.countFilesInProduct'><p>Given a runId, polls the &quot;download&quot; method to count the number of files available</p>
Uses HTTP HEAD to avoid downloading the files</a></li>
<li><a href='#.discoveryRequest'><p>Discovery Request</p>
encapsulates a request to a discovery service</a></li>
<li><a href='#.doRequest'><p>Generic request wrapper for making simple web service requests</p>
Will return parsed results, even if they are an error description sent by the API
Will stop() if the request fails into an error different from 400</a></li>
<li><a href='#.downloadDataProduct'><p>Public wrapper that lets a user download data products manually with a runId</p>
Can optionally return just the download links</a></li>
<li><a href='#.downloadProductFiles'><p>Download all data product files for provided run id</p></a></li>
<li><a href='#.estimatePollPeriod'><p>Sets a poll period adequate to the estimated processing time</p>
Longer processing times require longer poll periods to avoid going over maxRetries</a></li>
<li><a href='#.filterByExtension'><p>Filter file list results to only those where the filename ends with the extension</p>
If extension is empty no change will be made</a></li>
<li><a href='#.filters2url'><p>Returns a string URL for a base url and a named list of parameters</p></a></li>
<li><a href='#.formatDuration'><p>Returns a formatted time duration string representation of a duration in seconds</p></a></li>
<li><a href='#.formatResult'><p>Aggregates individual download results obtained in .orderDataProduct()</p>
into a list of formatted results to return, and a named list with
general stats of the operation</a></li>
<li><a href='#.formatSize'><p>Returns a formatted file size string representation</p></a></li>
<li><a href='#.formatUtc'><p>Format date as ISO8601 UTC</p></a></li>
<li><a href='#.getDataProducts'><p>Request a list of data products that matches the filters provided</p></a></li>
<li><a href='#.getDeployments'><p>Request a list of deployments that matches the filters provided</p></a></li>
<li><a href='#.getDeviceCategories'><p>Request a list of device categories that matches the filters provided</p></a></li>
<li><a href='#.getDevices'><p>Request a list of devices that matches the filters provided</p></a></li>
<li><a href='#.getDirectAllPages'><p>Generic method to download and concatenate all pages of data</p>
Keeps downloading all scalar or raw data pages until finished
Automatically translates sensorCategoryCodes to a string if a list is provided</a></li>
<li><a href='#.getDirectByDevice'><p>Obtains scalar data from a device, as described by the filters</p></a></li>
<li><a href='#.getDirectByLocation'><p>Obtains scalar data from a location, from the source described by the filters</p></a></li>
<li><a href='#.getDirectFiles'><p>Downloads all archive files that match the filters</p>
Internally will use geListByDevice or getListByLocation and getFile all files</a></li>
<li><a href='#.getDirectRawByDevice'><p>Obtains raw data from a device, as described by the filters</p></a></li>
<li><a href='#.getDirectRawByLocation'><p>Obtains raw data from a location, from the source described by the filters</p></a></li>
<li><a href='#.getDownloadUrl'><p>Given a filename, returns an archivefile absolute download URL</p></a></li>
<li><a href='#.getFile'><p>Download the archive file with filename</p></a></li>
<li><a href='#.getList'><p>A generic wrapper for getListByLocation() and getListByDevice()</p></a></li>
<li><a href='#.getListByDevice'><p>Get a list of files available in Oceans 2.0 Archiving System for a given</p>
device code. The list of filenames can be filtered by time range.
filtered by others optional parameters.</a></li>
<li><a href='#.getListByLocation'><p>Get a list of files for a given location code and device category code, and</p>
filtered by others optional parameters.</a></li>
<li><a href='#.getLocationHierarchy'><p>Request a hierarchical tree list of locations that matches the filters provided</p></a></li>
<li><a href='#.getLocations'><p>Request a list of locations that matches the filters provided</p></a></li>
<li><a href='#.getProperties'><p>Request a list of properties that matches the filters provided</p></a></li>
<li><a href='#.infoForProductFiles'><p>Returns a list of information lists for each file available for download</p>
Returned rows will have the same structure as those returned by DataProductFile$getInfo()</a></li>
<li><a href='#.lastItem'><p>R helper: Returns the last element of a list</p></a></li>
<li><a href='#.log'><p>Prints message to console only when showInfo is true</p></a></li>
<li><a href='#.orderDataProduct'><p>Request, run and download a data product as described by the filters</p></a></li>
<li><a href='#.prepareDirectory'><p>Creates directory if it does not exist</p>
Supports directory paths with or without filenames</a></li>
<li><a href='#.prettyPrint'><p>Pretty prints a complex hierarchy of lists</p></a></li>
<li><a href='#.print'><p>Helper for printing a JSON named list to the console</p>
Can alternatively print the output to a text file at filePath</a></li>
<li><a href='#.printErrorMessage'><p>Print Error Response Message</p></a></li>
<li><a href='#.printProductOrderStats'><p>Prints a formatted representation of the total time and size downloaded</p>
after the product order finishes</a></li>
<li><a href='#.printProductRequest'><p>Prints the response after a data product request</p>
The request response format might differ depending on the product origin
as it can be &quot;assembled&quot; on the fly, or reused from existing products</a></li>
<li><a href='#.requestDataProduct'><p>Request a data product generation described by the filters</p></a></li>
<li><a href='#.respFailed'><p>Response has failed</p></a></li>
<li><a href='#.runDataProduct'><p>Run a data product generation request</p></a></li>
<li><a href='#.sanitizeBooleans'><p>For all rows in data, enforce that fields expected to have bool values</p>
are logical values (fixes API issues with booleans returned as strings)</a></li>
<li><a href='#.saveAsFile'><p>Saves the file downloaded in the response object, in the outPath, with filename</p></a></li>
<li><a href='#.serviceUrl'><p>Returns the absolute url for a given ONC API service</p></a></li>
<li><a href='#DataProductFile-class'><p>DataProductFile class</p></a></li>
<li><a href='#MultiPage-class'><p>MultiPage</p></a></li>
<li><a href='#Onc-class'><p>Onc Class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Oceans 2.0 API Client Library</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows users to discover and retrieve Ocean Networks Canada's oceanographic data in raw, text, image, audio, video or any other format available. Provides a class that wraps web service calls and business logic so that users can download data with a single line of code.</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wiki.oceannetworks.ca/display/O2A/Oceans+2.0+API+Home">https://wiki.oceannetworks.ca/display/O2A/Oceans+2.0+API+Home</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>anytime, httr, methods, humanize, lubridate, stringi, tictoc,
crayon, utils, testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-20 15:34:53 UTC; blm</td>
</tr>
<tr>
<td>Author:</td>
<td>Dany Cabrera [aut],
  Allan Rempel [ctb],
  Ryan Ross [ctb],
  Bennit Mueller [ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bennit Mueller &lt;data@oceannetworks.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-21 09:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='.appendList'>Helper that appends a list item to a list of lists</h2><span id='topic+.appendList'></span>

<h3>Description</h3>

<p>Helper that appends a list item to a list of lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.appendList(li = list(), item = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".appendList_+3A_li">li</code></td>
<td>
<p>The container list</p>
</td></tr>
<tr><td><code id=".appendList_+3A_item">item</code></td>
<td>
<p>The list to append to li as a new element</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified list
</p>

<hr>
<h2 id='.countFilesInProduct'>Given a runId, polls the &quot;download&quot; method to count the number of files available
Uses HTTP HEAD to avoid downloading the files</h2><span id='topic+.countFilesInProduct'></span>

<h3>Description</h3>

<p>Given a runId, polls the &quot;download&quot; method to count the number of files available
Uses HTTP HEAD to avoid downloading the files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.countFilesInProduct(self, runId = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".countFilesInProduct_+3A_self">self</code></td>
<td>
<p>Caling object</p>
</td></tr>
<tr><td><code id=".countFilesInProduct_+3A_runid">runId</code></td>
<td>
<p>Run id returned by .runDataProduct()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) Number of files available for download
</p>

<hr>
<h2 id='.discoveryRequest'>Discovery Request
encapsulates a request to a discovery service</h2><span id='topic+.discoveryRequest'></span>

<h3>Description</h3>

<p>Discovery Request
encapsulates a request to a discovery service
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.discoveryRequest(self, filters = list(), service = "", method = "get")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".discoveryRequest_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".discoveryRequest_+3A_filters">filters</code></td>
<td>
<p>Named list of filters</p>
</td></tr>
<tr><td><code id=".discoveryRequest_+3A_service">service</code></td>
<td>
<p>One of &quot;locations&quot;, &quot;deployments&quot;, &quot;deviceCategories&quot;, &quot;devices&quot;,
&quot;properties&quot;, &quot;dataProducts&quot;</p>
</td></tr>
<tr><td><code id=".discoveryRequest_+3A_method">method</code></td>
<td>
<p>One of &quot;get&quot;, &quot;getTree&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) Parsed response obtained
</p>

<hr>
<h2 id='.doRequest'>Generic request wrapper for making simple web service requests
Will return parsed results, even if they are an error description sent by the API
Will stop() if the request fails into an error different from 400</h2><span id='topic+.doRequest'></span>

<h3>Description</h3>

<p>Generic request wrapper for making simple web service requests
Will return parsed results, even if they are an error description sent by the API
Will stop() if the request fails into an error different from 400
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.doRequest(
  self,
  url = "",
  filters = list(),
  getInfo = FALSE,
  rawResponse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".doRequest_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".doRequest_+3A_url">url</code></td>
<td>
<p>Full URL to make the request, without GET parameters</p>
</td></tr>
<tr><td><code id=".doRequest_+3A_filters">filters</code></td>
<td>
<p>GET parameters</p>
</td></tr>
<tr><td><code id=".doRequest_+3A_getinfo">getInfo</code></td>
<td>
<p>When TRUE, will return a list with (&quot;response&quot;, &quot;duration&quot;, &quot;status&quot;), where
&quot;duration&quot; is the time the request took and &quot;status&quot; is the HTTP response status</p>
</td></tr>
<tr><td><code id=".doRequest_+3A_rawresponse">rawResponse</code></td>
<td>
<p>When TRUE, the response returned is the unparsed object returned
by httr::GET, otherwise a parsed named list is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) The parsed response
</p>

<hr>
<h2 id='.downloadDataProduct'>Public wrapper that lets a user download data products manually with a runId
Can optionally return just the download links</h2><span id='topic+.downloadDataProduct'></span>

<h3>Description</h3>

<p>Public wrapper that lets a user download data products manually with a runId
Can optionally return just the download links
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.downloadDataProduct(
  self,
  runId = 0,
  maxRetries = 0,
  downloadResultsOnly = FALSE,
  includeMetadataFile = TRUE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".downloadDataProduct_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".downloadDataProduct_+3A_runid">runId</code></td>
<td>
<p>(numeric) Run ID as provided by runDataProduct()</p>
</td></tr>
<tr><td><code id=".downloadDataProduct_+3A_maxretries">maxRetries</code></td>
<td>
<p>(numeric) Maximum number of API requests allowed, 0 for no limit</p>
</td></tr>
<tr><td><code id=".downloadDataProduct_+3A_downloadresultsonly">downloadResultsOnly</code></td>
<td>
<p>(logical) When TRUE, files are not downloaded
By default (FALSE) generated files are downloaded</p>
</td></tr>
<tr><td><code id=".downloadDataProduct_+3A_includemetadatafile">includeMetadataFile</code></td>
<td>
<p>(logical) When TRUE, a metadata file is downloaded,
otherwise it is skipped</p>
</td></tr>
<tr><td><code id=".downloadDataProduct_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) When TRUE downloaded files will overwrite any file
with the same filename, otherwise they will be skipped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) A list of results (one named list for each file) with
information on the operation outcome
</p>

<hr>
<h2 id='.downloadProductFiles'>Download all data product files for provided run id</h2><span id='topic+.downloadProductFiles'></span>

<h3>Description</h3>

<p>Download all data product files for provided run id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.downloadProductFiles(
  self,
  runId = 0,
  getMetadata = TRUE,
  maxRetries = 0,
  overwrite = TRUE,
  fileCount = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".downloadProductFiles_+3A_self">self</code></td>
<td>
<p>Caling object</p>
</td></tr>
<tr><td><code id=".downloadProductFiles_+3A_runid">runId</code></td>
<td>
<p>Run id returned by .runDataProduct()</p>
</td></tr>
<tr><td><code id=".downloadProductFiles_+3A_getmetadata">getMetadata</code></td>
<td>
<p>When TRUE, the metadata file will be downloaded</p>
</td></tr>
<tr><td><code id=".downloadProductFiles_+3A_maxretries">maxRetries</code></td>
<td>
<p>(numeric) Maximum number of API requests allowed, 0 for no limit</p>
</td></tr>
<tr><td><code id=".downloadProductFiles_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) When TRUE downloaded files will overwrite any file
with the same filename, otherwise they will be skipped</p>
</td></tr>
<tr><td><code id=".downloadProductFiles_+3A_filecount">fileCount</code></td>
<td>
<p>The number of files to download, or 0 if unknown</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of named lists, with the results for each file
</p>

<hr>
<h2 id='.estimatePollPeriod'>Sets a poll period adequate to the estimated processing time
Longer processing times require longer poll periods to avoid going over maxRetries</h2><span id='topic+.estimatePollPeriod'></span>

<h3>Description</h3>

<p>Sets a poll period adequate to the estimated processing time
Longer processing times require longer poll periods to avoid going over maxRetries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.estimatePollPeriod(self, response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".estimatePollPeriod_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".estimatePollPeriod_+3A_response">response</code></td>
<td>
<p>Response obtained in .requestDataProduct() for the DP request</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) suggested time between server polls (seconds)
</p>

<hr>
<h2 id='.filterByExtension'>Filter file list results to only those where the filename ends with the extension
If extension is empty no change will be made</h2><span id='topic+.filterByExtension'></span>

<h3>Description</h3>

<p>Filter file list results to only those where the filename ends with the extension
If extension is empty no change will be made
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.filterByExtension(self, results = list(), extension = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".filterByExtension_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".filterByExtension_+3A_results">results</code></td>
<td>
<p>Results as otained by getListByLocation() or getListByDevice()</p>
</td></tr>
<tr><td><code id=".filterByExtension_+3A_extension">extension</code></td>
<td>
<p>(character) Extension to search for (i.e. &quot;txt&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Filtered list
</p>

<hr>
<h2 id='.filters2url'>Returns a string URL for a base url and a named list of parameters</h2><span id='topic+.filters2url'></span>

<h3>Description</h3>

<p>Returns a string URL for a base url and a named list of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.filters2url(url, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".filters2url_+3A_url">url</code></td>
<td>
<p>Base url string</p>
</td></tr>
<tr><td><code id=".filters2url_+3A_params">params</code></td>
<td>
<p>Named list of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Full URL
</p>

<hr>
<h2 id='.formatDuration'>Returns a formatted time duration string representation of a duration in seconds</h2><span id='topic+.formatDuration'></span>

<h3>Description</h3>

<p>Returns a formatted time duration string representation of a duration in seconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.formatDuration(secs = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".formatDuration_+3A_secs">secs</code></td>
<td>
<p>(double) Number of seconds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(character) A readable string for this time duration
</p>

<hr>
<h2 id='.formatResult'>Aggregates individual download results obtained in .orderDataProduct()
into a list of formatted results to return, and a named list with
general stats of the operation</h2><span id='topic+.formatResult'></span>

<h3>Description</h3>

<p>Aggregates individual download results obtained in .orderDataProduct()
into a list of formatted results to return, and a named list with
general stats of the operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.formatResult(self, fileList = list(), runInfo = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".formatResult_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".formatResult_+3A_filelist">fileList</code></td>
<td>
<p>List of individual download results</p>
</td></tr>
<tr><td><code id=".formatResult_+3A_runinfo">runInfo</code></td>
<td>
<p>As returned by .runDataProduct()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with &quot;downloadResults&quot; (list of download results) and
&quot;stats&quot; (general stats for the full operation)
</p>

<hr>
<h2 id='.formatSize'>Returns a formatted file size string representation</h2><span id='topic+.formatSize'></span>

<h3>Description</h3>

<p>Returns a formatted file size string representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.formatSize(size = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".formatSize_+3A_size">size</code></td>
<td>
<p>(float) Size in bytes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(character) a readable string for this file size
</p>

<hr>
<h2 id='.formatUtc'>Format date as ISO8601 UTC</h2><span id='topic+.formatUtc'></span>

<h3>Description</h3>

<p>Helper that returns an ISO8601 string for the provided date string
Most date formats are supported, as explained in: https://github.com/eddelbuettel/anytime
A value of &quot;now&quot; returns the current UTC date &amp; time
Depends on the local system clock
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.formatUtc(self, dateString = "now")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".formatUtc_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".formatUtc_+3A_datestring">dateString</code></td>
<td>
<p>A string that describes a date. Can also be &quot;now&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(character) Date string
</p>

<hr>
<h2 id='.getDataProducts'>Request a list of data products that matches the filters provided</h2><span id='topic+.getDataProducts'></span>

<h3>Description</h3>

<p>Request a list of data products that matches the filters provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDataProducts(self, filters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDataProducts_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDataProducts_+3A_filters">filters</code></td>
<td>
<p>(named list) search filters</p>
</td></tr>
</table>


<h3>Value</h3>

<pre>   (named list) A list of data products found, or an error description if any
</pre>

<hr>
<h2 id='.getDeployments'>Request a list of deployments that matches the filters provided</h2><span id='topic+.getDeployments'></span>

<h3>Description</h3>

<p>Request a list of deployments that matches the filters provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDeployments(self, filters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDeployments_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDeployments_+3A_filters">filters</code></td>
<td>
<p>(named list) search filters</p>
</td></tr>
</table>


<h3>Value</h3>

<pre>   (named list) A list of deployments found, or an error description if any
</pre>

<hr>
<h2 id='.getDeviceCategories'>Request a list of device categories that matches the filters provided</h2><span id='topic+.getDeviceCategories'></span>

<h3>Description</h3>

<p>Request a list of device categories that matches the filters provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDeviceCategories(self, filters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDeviceCategories_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDeviceCategories_+3A_filters">filters</code></td>
<td>
<p>(named list) search filters</p>
</td></tr>
</table>


<h3>Value</h3>

<pre>   (named list) A list of device categories found, or an error description if any
</pre>

<hr>
<h2 id='.getDevices'>Request a list of devices that matches the filters provided</h2><span id='topic+.getDevices'></span>

<h3>Description</h3>

<p>Request a list of devices that matches the filters provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDevices(self, filters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDevices_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDevices_+3A_filters">filters</code></td>
<td>
<p>(named list) search filters</p>
</td></tr>
</table>


<h3>Value</h3>

<pre>   (named list) A list of devices found, or an error description if any
</pre>

<hr>
<h2 id='.getDirectAllPages'>Generic method to download and concatenate all pages of data
Keeps downloading all scalar or raw data pages until finished
Automatically translates sensorCategoryCodes to a string if a list is provided</h2><span id='topic+.getDirectAllPages'></span>

<h3>Description</h3>

<p>Generic method to download and concatenate all pages of data
Keeps downloading all scalar or raw data pages until finished
Automatically translates sensorCategoryCodes to a string if a list is provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDirectAllPages(
  self,
  filters = list(),
  service = "",
  method = "",
  allPages = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDirectAllPages_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDirectAllPages_+3A_filters">filters</code></td>
<td>
<p>(named list) Filters that describe the data origin</p>
</td></tr>
<tr><td><code id=".getDirectAllPages_+3A_service">service</code></td>
<td>
<p>One of: &quot;scalardata&quot;, &quot;rawdata&quot;</p>
</td></tr>
<tr><td><code id=".getDirectAllPages_+3A_method">method</code></td>
<td>
<p>One of: &quot;getByDevice&quot;, &quot;getByLocation&quot;</p>
</td></tr>
<tr><td><code id=".getDirectAllPages_+3A_allpages">allPages</code></td>
<td>
<p>When TRUE, if the data requested is too large to fit a single
API resquest, keep downloading data pages until we gather all data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single response in the expected format, with all data pages concatenated
</p>

<hr>
<h2 id='.getDirectByDevice'>Obtains scalar data from a device, as described by the filters</h2><span id='topic+.getDirectByDevice'></span>

<h3>Description</h3>

<p>Obtains scalar data from a device, as described by the filters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDirectByDevice(self, filters = list(), allPages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDirectByDevice_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDirectByDevice_+3A_filters">filters</code></td>
<td>
<p>(named list) Filters that describe the data origin</p>
</td></tr>
<tr><td><code id=".getDirectByDevice_+3A_allpages">allPages</code></td>
<td>
<p>When TRUE, if the data requested is too large to fit a single
API resquest, keep downloading data pages until we gather all data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) Scalar data obtained for all sensors found
</p>

<hr>
<h2 id='.getDirectByLocation'>Obtains scalar data from a location, from the source described by the filters</h2><span id='topic+.getDirectByLocation'></span>

<h3>Description</h3>

<p>Obtains scalar data from a location, from the source described by the filters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDirectByLocation(self, filters = list(), allPages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDirectByLocation_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDirectByLocation_+3A_filters">filters</code></td>
<td>
<p>(named list) Filters that describe the data origin</p>
</td></tr>
<tr><td><code id=".getDirectByLocation_+3A_allpages">allPages</code></td>
<td>
<p>When TRUE, if the data requested is too large to fit a single
API resquest, keep downloading data pages until we gather all data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) Scalar data obtained for all sensors found
</p>

<hr>
<h2 id='.getDirectFiles'>Downloads all archive files that match the filters
Internally will use geListByDevice or getListByLocation and getFile all files</h2><span id='topic+.getDirectFiles'></span>

<h3>Description</h3>

<p>Downloads all archive files that match the filters
Internally will use geListByDevice or getListByLocation and getFile all files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDirectFiles(self, filters = list(), overwrite = FALSE, allPages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDirectFiles_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDirectFiles_+3A_filters">filters</code></td>
<td>
<p>(named list) describe the data origin</p>
</td></tr>
<tr><td><code id=".getDirectFiles_+3A_overwrite">overwrite</code></td>
<td>
<p>When TRUE, downloaded files will overwrite any file with the
same filename, otherwise file will be skipped</p>
</td></tr>
<tr><td><code id=".getDirectFiles_+3A_allpages">allPages</code></td>
<td>
<p>When TRUE, if the data is too long to fit a single request,
multiple pages will be requested until all data is obatined</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) Information on the results of the operation, with &quot;downloadResults&quot;
for each file downloaded and general &quot;stats&quot;
</p>

<hr>
<h2 id='.getDirectRawByDevice'>Obtains raw data from a device, as described by the filters</h2><span id='topic+.getDirectRawByDevice'></span>

<h3>Description</h3>

<p>Obtains raw data from a device, as described by the filters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDirectRawByDevice(self, filters = list(), allPages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDirectRawByDevice_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDirectRawByDevice_+3A_filters">filters</code></td>
<td>
<p>(named list) Filters that describe the data origin</p>
</td></tr>
<tr><td><code id=".getDirectRawByDevice_+3A_allpages">allPages</code></td>
<td>
<p>When TRUE, if the data requested is too large to fit a single
API resquest, keep downloading data pages until we gather all data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) Raw data obtained for all sensors found
</p>

<hr>
<h2 id='.getDirectRawByLocation'>Obtains raw data from a location, from the source described by the filters</h2><span id='topic+.getDirectRawByLocation'></span>

<h3>Description</h3>

<p>Obtains raw data from a location, from the source described by the filters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDirectRawByLocation(self, filters = list(), allPages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDirectRawByLocation_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDirectRawByLocation_+3A_filters">filters</code></td>
<td>
<p>(named list) Filters that describe the data origin</p>
</td></tr>
<tr><td><code id=".getDirectRawByLocation_+3A_allpages">allPages</code></td>
<td>
<p>When TRUE, if the data requested is too large to fit a single
API resquest, keep downloading data pages until we gather all data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) Raw data obtained for all sensors found
</p>

<hr>
<h2 id='.getDownloadUrl'>Given a filename, returns an archivefile absolute download URL</h2><span id='topic+.getDownloadUrl'></span>

<h3>Description</h3>

<p>Given a filename, returns an archivefile absolute download URL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getDownloadUrl(self, filename = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getDownloadUrl_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getDownloadUrl_+3A_filename">filename</code></td>
<td>
<p>(character) archive file name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(character) download URL
</p>

<hr>
<h2 id='.getFile'>Download the archive file with filename</h2><span id='topic+.getFile'></span>

<h3>Description</h3>

<p>Download the archive file with filename
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getFile(self, filename = "", overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getFile_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getFile_+3A_filename">filename</code></td>
<td>
<p>Archive file filename</p>
</td></tr>
<tr><td><code id=".getFile_+3A_overwrite">overwrite</code></td>
<td>
<p>When TRUE, downloaded files will overwrite any file with the
same filename, otherwise file will be skipped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) Information on the download result
</p>

<hr>
<h2 id='.getList'>A generic wrapper for getListByLocation() and getListByDevice()</h2><span id='topic+.getList'></span>

<h3>Description</h3>

<p>A generic wrapper for getListByLocation() and getListByDevice()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getList(self, filters = list(), by = "location", allPages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getList_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getList_+3A_filters">filters</code></td>
<td>
<p>(named list) describe the data origin</p>
</td></tr>
<tr><td><code id=".getList_+3A_by">by</code></td>
<td>
<p>One of: &quot;location&quot;, &quot;device&quot;</p>
</td></tr>
<tr><td><code id=".getList_+3A_allpages">allPages</code></td>
<td>
<p>When TRUE, if the data is too long to fit a single request,
multiple pages will be requested until all data is obatined</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) Information on the list of files obtained
</p>

<hr>
<h2 id='.getListByDevice'>Get a list of files available in Oceans 2.0 Archiving System for a given
device code. The list of filenames can be filtered by time range.
filtered by others optional parameters.</h2><span id='topic+.getListByDevice'></span>

<h3>Description</h3>

<p>Get a list of files available in Oceans 2.0 Archiving System for a given
device code. The list of filenames can be filtered by time range.
filtered by others optional parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getListByDevice(self, filters = list(), allPages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getListByDevice_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getListByDevice_+3A_filters">filters</code></td>
<td>
<p>(named list) describe the data origin</p>
</td></tr>
<tr><td><code id=".getListByDevice_+3A_allpages">allPages</code></td>
<td>
<p>When TRUE, if the data is too long to fit a single request,
multiple pages will be requested until all data is obatined</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) file list obtained
</p>

<hr>
<h2 id='.getListByLocation'>Get a list of files for a given location code and device category code, and
filtered by others optional parameters.</h2><span id='topic+.getListByLocation'></span>

<h3>Description</h3>

<p>Get a list of files for a given location code and device category code, and
filtered by others optional parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getListByLocation(self, filters = list(), allPages = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getListByLocation_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getListByLocation_+3A_filters">filters</code></td>
<td>
<p>(named list) describe the data origin</p>
</td></tr>
<tr><td><code id=".getListByLocation_+3A_allpages">allPages</code></td>
<td>
<p>When TRUE, if the data is too long to fit a single request,
multiple pages will be requested until all data is obatined</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) file list obtained
</p>

<hr>
<h2 id='.getLocationHierarchy'>Request a hierarchical tree list of locations that matches the filters provided</h2><span id='topic+.getLocationHierarchy'></span>

<h3>Description</h3>

<p>Request a hierarchical tree list of locations that matches the filters provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getLocationHierarchy(self, filters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getLocationHierarchy_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getLocationHierarchy_+3A_filters">filters</code></td>
<td>
<p>(named list) search filters</p>
</td></tr>
</table>


<h3>Value</h3>

<pre>   (named list) A list of locations found, or an error description if any
           Locations include lists of children locations recursively
</pre>

<hr>
<h2 id='.getLocations'>Request a list of locations that matches the filters provided</h2><span id='topic+.getLocations'></span>

<h3>Description</h3>

<p>Request a list of locations that matches the filters provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getLocations(self, filters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getLocations_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getLocations_+3A_filters">filters</code></td>
<td>
<p>(named list) search filters</p>
</td></tr>
</table>


<h3>Value</h3>

<pre>   (named list) A list of locations found, or an error description if any
</pre>

<hr>
<h2 id='.getProperties'>Request a list of properties that matches the filters provided</h2><span id='topic+.getProperties'></span>

<h3>Description</h3>

<p>Request a list of properties that matches the filters provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getProperties(self, filters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getProperties_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".getProperties_+3A_filters">filters</code></td>
<td>
<p>(named list) search filters</p>
</td></tr>
</table>


<h3>Value</h3>

<pre>   (named list) A list of properties found, or an error description if any
</pre>

<hr>
<h2 id='.infoForProductFiles'>Returns a list of information lists for each file available for download
Returned rows will have the same structure as those returned by DataProductFile$getInfo()</h2><span id='topic+.infoForProductFiles'></span>

<h3>Description</h3>

<p>Returns a list of information lists for each file available for download
Returned rows will have the same structure as those returned by DataProductFile$getInfo()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.infoForProductFiles(self, dpRunId = 0, fileCount = 0, getMetadata = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".infoForProductFiles_+3A_self">self</code></td>
<td>
<p>Caling object</p>
</td></tr>
<tr><td><code id=".infoForProductFiles_+3A_dprunid">dpRunId</code></td>
<td>
<p>Run id returned by .runDataProduct()</p>
</td></tr>
<tr><td><code id=".infoForProductFiles_+3A_filecount">fileCount</code></td>
<td>
<p>The number of files to download, or 0 if unknown</p>
</td></tr>
<tr><td><code id=".infoForProductFiles_+3A_getmetadata">getMetadata</code></td>
<td>
<p>When TRUE, the metadata file will be included</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of named lists, with the results for each file
</p>

<hr>
<h2 id='.lastItem'>R helper: Returns the last element of a list</h2><span id='topic+.lastItem'></span>

<h3>Description</h3>

<p>R helper: Returns the last element of a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.lastItem(collection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".lastItem_+3A_collection">collection</code></td>
<td>
<p>The list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The last element of the list
</p>

<hr>
<h2 id='.log'>Prints message to console only when showInfo is true</h2><span id='topic+.log'></span>

<h3>Description</h3>

<p>Prints message to console only when showInfo is true
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.log(self, msg = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".log_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".log_+3A_msg">msg</code></td>
<td>
<p>(character) The message to print</p>
</td></tr>
</table>

<hr>
<h2 id='.orderDataProduct'>Request, run and download a data product as described by the filters</h2><span id='topic+.orderDataProduct'></span>

<h3>Description</h3>

<p>Request, run and download a data product as described by the filters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.orderDataProduct(
  self,
  filters = list(),
  maxRetries = 0,
  downloadResultsOnly = FALSE,
  metadata = TRUE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".orderDataProduct_+3A_self">self</code></td>
<td>
<p>Caling object</p>
</td></tr>
<tr><td><code id=".orderDataProduct_+3A_filters">filters</code></td>
<td>
<p>(named list) Filters that describe this data product</p>
</td></tr>
<tr><td><code id=".orderDataProduct_+3A_maxretries">maxRetries</code></td>
<td>
<p>(numeric) Total maximum number of request calls allowed, 0 for no limit</p>
</td></tr>
<tr><td><code id=".orderDataProduct_+3A_downloadresultsonly">downloadResultsOnly</code></td>
<td>
<p>(logical) When TRUE, files are not downloaded
By default (FALSE) generated files are downloaded</p>
</td></tr>
<tr><td><code id=".orderDataProduct_+3A_metadata">metadata</code></td>
<td>
<p>(logical) When TRUE, a metadata file is downloaded,
otherwise it is skipped</p>
</td></tr>
<tr><td><code id=".orderDataProduct_+3A_overwrite">overwrite</code></td>
<td>
<p>(logical) When TRUE downloaded files will overwrite any file
with the same filename, otherwise they will be skipped</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) A list of results (one named list for each file) with
information on the operation outcome
</p>

<hr>
<h2 id='.prepareDirectory'>Creates directory if it does not exist
Supports directory paths with or without filenames</h2><span id='topic+.prepareDirectory'></span>

<h3>Description</h3>

<p>Creates directory if it does not exist
Supports directory paths with or without filenames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prepareDirectory(filepath = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".prepareDirectory_+3A_filepath">filepath</code></td>
<td>
<p>(character) Directory path</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(logical) TRUE if the directory was created or already exists
</p>

<hr>
<h2 id='.prettyPrint'>Pretty prints a complex hierarchy of lists</h2><span id='topic+.prettyPrint'></span>

<h3>Description</h3>

<p>Pretty prints a complex hierarchy of lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prettyPrint(item, name = "", level = 0, comma = FALSE, file = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".prettyPrint_+3A_item">item</code></td>
<td>
<p>Hierarchy item (can be a list or an atomic element)</p>
</td></tr>
<tr><td><code id=".prettyPrint_+3A_name">name</code></td>
<td>
<p>(character) Item name if its an element in a named list</p>
</td></tr>
<tr><td><code id=".prettyPrint_+3A_level">level</code></td>
<td>
<p>(numeric)   Depth level in the hierarchy, starting at 0</p>
</td></tr>
<tr><td><code id=".prettyPrint_+3A_comma">comma</code></td>
<td>
<p>(logical)   If TRUE, a comma is printed after this element</p>
</td></tr>
<tr><td><code id=".prettyPrint_+3A_file">file</code></td>
<td>
<p>A file connection to an open file if we should print to it,
or &quot;&quot; (no file, print to console)</p>
</td></tr>
</table>

<hr>
<h2 id='.print'>Helper for printing a JSON named list to the console
Can alternatively print the output to a text file at filePath</h2><span id='topic+.print'></span>

<h3>Description</h3>

<p>Helper for printing a JSON named list to the console
Can alternatively print the output to a text file at filePath
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.print(self, obj, filePath = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".print_+3A_self">self</code></td>
<td>
<p>self</p>
</td></tr>
<tr><td><code id=".print_+3A_obj">obj</code></td>
<td>
<p>named list to print (usually the result of another function)</p>
</td></tr>
<tr><td><code id=".print_+3A_filepath">filePath</code></td>
<td>
<p>(string) if present, creates the file and writes the output in it</p>
</td></tr>
</table>

<hr>
<h2 id='.printErrorMessage'>Print Error Response Message</h2><span id='topic+.printErrorMessage'></span>

<h3>Description</h3>

<p>Prints the information from a API error response to the console
as a formatted error message
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.printErrorMessage(response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".printErrorMessage_+3A_response">response</code></td>
<td>
<p>Parsed response returned by httr::GET</p>
</td></tr>
</table>

<hr>
<h2 id='.printProductOrderStats'>Prints a formatted representation of the total time and size downloaded
after the product order finishes</h2><span id='topic+.printProductOrderStats'></span>

<h3>Description</h3>

<p>Prints a formatted representation of the total time and size downloaded
after the product order finishes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.printProductOrderStats(self, fileList = list(), runInfo = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".printProductOrderStats_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".printProductOrderStats_+3A_filelist">fileList</code></td>
<td>
<p>(list) As returned by .downloadProductFiles()</p>
</td></tr>
<tr><td><code id=".printProductOrderStats_+3A_runinfo">runInfo</code></td>
<td>
<p>(list) As returned by .runDataProduct()</p>
</td></tr>
</table>

<hr>
<h2 id='.printProductRequest'>Prints the response after a data product request
The request response format might differ depending on the product origin
as it can be &quot;assembled&quot; on the fly, or reused from existing products</h2><span id='topic+.printProductRequest'></span>

<h3>Description</h3>

<p>Prints the response after a data product request
The request response format might differ depending on the product origin
as it can be &quot;assembled&quot; on the fly, or reused from existing products
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.printProductRequest(self, response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".printProductRequest_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".printProductRequest_+3A_response">response</code></td>
<td>
<p>Parsed httr response</p>
</td></tr>
</table>

<hr>
<h2 id='.requestDataProduct'>Request a data product generation described by the filters</h2><span id='topic+.requestDataProduct'></span>

<h3>Description</h3>

<p>Request a data product generation described by the filters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.requestDataProduct(self, filters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".requestDataProduct_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".requestDataProduct_+3A_filters">filters</code></td>
<td>
<p>(named list) Filters that describe this data product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Parsed httr response
</p>

<hr>
<h2 id='.respFailed'>Response has failed</h2><span id='topic+.respFailed'></span>

<h3>Description</h3>

<p>Returns TRUE if the response is a 401 JSON error description provided by the API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.respFailed(response)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".respFailed_+3A_response">response</code></td>
<td>
<p>(named list) Parsed httr response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(logical)
</p>

<hr>
<h2 id='.runDataProduct'>Run a data product generation request</h2><span id='topic+.runDataProduct'></span>

<h3>Description</h3>

<p>Run a data product generation request
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.runDataProduct(self, dpRequestId = 0, waitComplete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".runDataProduct_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".runDataProduct_+3A_dprequestid">dpRequestId</code></td>
<td>
<p>(numeric) Request id obtained by requestDataProduct()</p>
</td></tr>
<tr><td><code id=".runDataProduct_+3A_waitcomplete">waitComplete</code></td>
<td>
<p>(logical) When true, will keep polling the server until
the data product is ready to download</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(named list) information of the run process, or error object
</p>

<hr>
<h2 id='.sanitizeBooleans'>For all rows in data, enforce that fields expected to have bool values
are logical values (fixes API issues with booleans returned as strings)</h2><span id='topic+.sanitizeBooleans'></span>

<h3>Description</h3>

<p>For all rows in data, enforce that fields expected to have bool values
are logical values (fixes API issues with booleans returned as strings)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sanitizeBooleans(self, data = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sanitizeBooleans_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".sanitizeBooleans_+3A_data">data</code></td>
<td>
<p>(list) Parsed response</p>
</td></tr>
</table>


<h3>Value</h3>

<pre>(list) The modified data
</pre>

<hr>
<h2 id='.saveAsFile'>Saves the file downloaded in the response object, in the outPath, with filename</h2><span id='topic+.saveAsFile'></span>

<h3>Description</h3>

<p>Saves the file downloaded in the response object, in the outPath, with filename
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.saveAsFile(response, filePath = "", fileName = "", overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".saveAsFile_+3A_response">response</code></td>
<td>
<p>An http raw response as returned by httr::GET</p>
</td></tr>
<tr><td><code id=".saveAsFile_+3A_filepath">filePath</code></td>
<td>
<p>Path where the file will be saved</p>
</td></tr>
<tr><td><code id=".saveAsFile_+3A_filename">fileName</code></td>
<td>
<p>Name of the file to save</p>
</td></tr>
<tr><td><code id=".saveAsFile_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE will overwrite files with the same name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) Result code from 0: done, -1: error, -2: fileExists
</p>

<hr>
<h2 id='.serviceUrl'>Returns the absolute url for a given ONC API service</h2><span id='topic+.serviceUrl'></span>

<h3>Description</h3>

<p>Returns the absolute url for a given ONC API service
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.serviceUrl(self, service = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".serviceUrl_+3A_self">self</code></td>
<td>
<p>Calling object</p>
</td></tr>
<tr><td><code id=".serviceUrl_+3A_service">service</code></td>
<td>
<p>One of ONC's API services</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(character) Service's URL
</p>

<hr>
<h2 id='DataProductFile-class'>DataProductFile class</h2><span id='topic+DataProductFile-class'></span><span id='topic+DataProductFile'></span>

<h3>Description</h3>

<p>Encapsulates the download of a single data product file, and the handling
of the server polling and error codes.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="DataProductFile-class_+3A_dprunid">dpRunId</code></td>
<td>
<p>Run Id of a data product request that was run</p>
</td></tr>
<tr><td><code id="DataProductFile-class_+3A_index">index</code></td>
<td>
<p>Index of this object's file</p>
</td></tr>
<tr><td><code id="DataProductFile-class_+3A_baseurl">baseUrl</code></td>
<td>
<p>From the Onc class</p>
</td></tr>
<tr><td><code id="DataProductFile-class_+3A_token">token</code></td>
<td>
<p>From the Onc class
Downloads this data product file
</p>
<p>Can poll, wait and retry if the file is not ready to download</p>
</td></tr>
<tr><td><code id="DataProductFile-class_+3A_overwrite">overwrite</code></td>
<td>
<p>When TRUE, existing files will be overwritten, otherwise they are skipped</p>
</td></tr>
<tr><td><code id="DataProductFile-class_+3A_timeout">timeout</code>, <code id="DataProductFile-class_+3A_pollperiod">pollPeriod</code>, <code id="DataProductFile-class_+3A_outpath">outPath</code>, <code id="DataProductFile-class_+3A_maxretries">maxRetries</code></td>
<td>
<p>Same as in the Onc class</p>
</td></tr>
<tr><td><code id="DataProductFile-class_+3A_response">response</code></td>
<td>
<p>The successful (200) httr response obtained from a download request</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(integer) the final response's HTTP status code
Return the file name from the response
</p>
<p>(string) The filename as obtained from the headers
Return information on this download's outcome
</p>
<p>(list) A named list with information on the download result
Sets this object's status to 200 (complete)
Used by onc_delivery methods
</p>


<h3>Fields</h3>


<dl>
<dt><code>.filters</code></dt><dd><p>The list of filters to pass to the download API method</p>
</dd>
<dt><code>.retries</code></dt><dd><p>Total count of HTTP requests made by this object</p>
</dd>
<dt><code>.status</code></dt><dd><p>Last request's HTTP status code</p>
</dd>
<dt><code>.downloaded</code></dt><dd><p>TRUE if the file was downloaded from the API</p>
</dd>
<dt><code>.baseUrl</code></dt><dd><p>Same as in the Onc class</p>
</dd>
<dt><code>.downloadUrl</code></dt><dd><p>URL that downloads this file</p>
</dd>
<dt><code>.fileName</code></dt><dd><p>Filename of the file if downloaded &amp; saved</p>
</dd>
<dt><code>.fileSize</code></dt><dd><p>Size in bytes of the file if downloaded &amp; saved</p>
</dd>
<dt><code>.runningTime</code></dt><dd><p>Total time spent running (sec)</p>
</dd>
<dt><code>.downloadingTime</code></dt><dd><p>Total time spend downloading (sec)
Class initializer</p>
</dd>
</dl>

<hr>
<h2 id='MultiPage-class'>MultiPage</h2><span id='topic+MultiPage-class'></span><span id='topic+MultiPage'></span>

<h3>Description</h3>

<p>API multiple page helper. Handles the download of data in multiple pages
Used by real-time and archivefile services
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiPage-class_+3A_extension+3A">extension:</code></td>
<td>
<p>Only provide for archivefiles filtering by filename extension</p>
</td></tr>
<tr><td><code id="MultiPage-class_+3A_nextresponse">nextResponse</code></td>
<td>
<p>(named list) Response with the next data page to add</p>
</td></tr>
<tr><td><code id="MultiPage-class_+3A_responsetime+3A">responseTime:</code></td>
<td>
<p>(double)     Request duration in seconds</p>
</td></tr>
<tr><td><code id="MultiPage-class_+3A_response">response</code></td>
<td>
<p>(named list) Response with the first page</p>
</td></tr>
<tr><td><code id="MultiPage-class_+3A_service">service</code></td>
<td>
<p>(character)  One of: &quot;scalardata&quot;, &quot;rawdata&quot;, &quot;archivefiles&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>: Response with concatenated data for all pages obtained
Do a page request
</p>
<p>Wraps the _doRequest method
Performs additional processing of the response for certain services
</p>
<p>(list) A named list with: &quot;response&quot; (httr response) and &quot;duration&quot; (secs)
Concatenate data
</p>
<p>Concatenates the data results from nextResponse into response
Compatible with the row structure of scalardata, rowdata and archivefiles
</p>
<p>(named list) Modified original response
Estimate pages
</p>
<p>Estimates the number of pages this request will require to download,
from the first page's response and its duration
</p>
<p>(int) Estimated number of pages
Response Time Span
</p>
<p>Determines the timespan covered by the data in the response
</p>
<pre>    (int)        page duration in seconds
</pre>


<h3>Fields</h3>


<dl>
<dt><code>showInfo</code></dt><dd><p>As provided by the Onc class</p>
</dd>
<dt><code>timeout</code></dt><dd><p>As provided by the Onc class
Class initializer
Get all pages
</p>
<p>Obtains all data pages for a query with the filters
Multiple pages will be downloaded in sequence until completed
Each new page gets concatenated to the previous one (limited to RAM)</p>
</dd>
</dl>

<hr>
<h2 id='Onc-class'>Onc Class</h2><span id='topic+Onc-class'></span><span id='topic+Onc'></span>

<h3>Description</h3>

<p>Provides convenient &amp; easy access to Ocean Networks Canada's data.
For detailed information and usage examples, visit our
<a href="https://wiki.oceannetworks.ca/display/O2A/Oceans+2.0+API+Home">official Documentation</a>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="Onc-class_+3A_token">token</code></td>
<td>
<p>User token</p>
</td></tr>
<tr><td><code id="Onc-class_+3A_production">production</code></td>
<td>
<p>whether the ONC Production server URL is used for service requests</p>
</td></tr>
<tr><td><code id="Onc-class_+3A_showinfo">showInfo</code></td>
<td>
<p>Whether verbose debug messages are displayed</p>
</td></tr>
<tr><td><code id="Onc-class_+3A_outpath">outPath</code></td>
<td>
<p>Output path for downloaded files</p>
</td></tr>
<tr><td><code id="Onc-class_+3A_timeout">timeout</code></td>
<td>
<p>Number of seconds before a request to the API is canceled</p>
</td></tr>
</table>


<h3>Fields</h3>


<dl>
<dt><code>token</code></dt><dd><p>character. User token</p>
</dd>
<dt><code>showInfo</code></dt><dd><p>logical. Print verbose debug comments</p>
</dd>
<dt><code>timeout</code></dt><dd><p>numeric. Number of seconds before a request to the API is canceled</p>
</dd>
<dt><code>baseUrl</code></dt><dd><p>character. Base URL for API requests</p>
</dd>
<dt><code>outPath</code></dt><dd><p>character. Output path for downloaded files
</p>
<p>Class initializer</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>downloadDataProduct(
  runId = 0,
  maxRetries = 0,
  downloadResultsOnly = FALSE,
  includeMetadataFile = TRUE,
  overwrite = FALSE
)</code></dt><dd><p>Manually download a data product after it was requested and run</p>
</dd>
<dt><code>formatUtc(dateString = "now")</code></dt><dd><p>Formats the provided date string to meet ISO8601</p>
</dd>
<dt><code>getDataProducts(filters = list())</code></dt><dd><p>Returns a filtered list of data products</p>
</dd>
<dt><code>getDeployments(filters = list())</code></dt><dd><p>Returns a filtered list of deployments</p>
</dd>
<dt><code>getDeviceCategories(filters = list())</code></dt><dd><p>Returns a filtered list of device categories</p>
</dd>
<dt><code>getDevices(filters = list())</code></dt><dd><p>Returns a filtered list of devices</p>
</dd>
<dt><code>getDirectByDevice(filters = list(), allPages = FALSE)</code></dt><dd><p>Obtain scalar data readings from a device</p>
</dd>
<dt><code>getDirectByLocation(filters = list(), allPages = FALSE)</code></dt><dd><p>Obtain scalar data readings from a device category in a location</p>
</dd>
<dt><code>getDirectFiles(filters = list(), overwrite = FALSE, allPages = FALSE)</code></dt><dd><p>Download a list of archived files that match the filters provided</p>
</dd>
<dt><code>getDirectRawByDevice(filters = list(), allPages = FALSE)</code></dt><dd><p>Obtain raw data readings from a device</p>
</dd>
<dt><code>getDirectRawByLocation(filters = list(), allPages = FALSE)</code></dt><dd><p>Obtain raw data readings from a device category in a location</p>
</dd>
<dt><code>getFile(filename = "", overwrite = FALSE)</code></dt><dd><p>Download a file with the given filename</p>
</dd>
<dt><code>getListByDevice(filters = list(), allPages = FALSE)</code></dt><dd><p>Get a list of archived files for a device</p>
</dd>
<dt><code>getListByLocation(filters = list(), allPages = FALSE)</code></dt><dd><p>Get a list of archived files for a device category in a location</p>
</dd>
<dt><code>getLocationHierarchy(filters = list())</code></dt><dd><p>Returns a filtered locations tree</p>
</dd>
<dt><code>getLocations(filters = list())</code></dt><dd><p>Returns a filtered list of locations</p>
</dd>
<dt><code>getProperties(filters = list())</code></dt><dd><p>Returns a filtered list of properties</p>
</dd>
<dt><code>orderDataProduct(
  filters = list(),
  maxRetries = 0,
  downloadResultsOnly = FALSE,
  includeMetadataFile = TRUE,
  overwrite = FALSE
)</code></dt><dd><p>Request, run and download a data product</p>
</dd>
<dt><code>print(data, filename = "")</code></dt><dd><p>Prints a named list in a format easier to read</p>
</dd>
<dt><code>requestDataProduct(filters = list())</code></dt><dd><p>Manually Request a data product</p>
</dd>
<dt><code>runDataProduct(dpRequestId = 0, waitComplete = FALSE)</code></dt><dd><p>Manually run a data product request</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
