<!DOCTYPE html><html lang="en"><head><title>Help for package rcDEA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rcDEA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conditional_BOD'><p>Conditional BOD function</p></a></li>
<li><a href='#conditional_DEA'><p>Conditional DEA function</p></a></li>
<li><a href='#graph1_m_BOD'><p>Graph to select m</p></a></li>
<li><a href='#graph1_m_DEA'><p>Graph to select m</p></a></li>
<li><a href='#graph2_m_BOD'><p>Graph to select m</p></a></li>
<li><a href='#graph2_m_DEA'><p>Graph to select m</p></a></li>
<li><a href='#robust_BOD'><p>Robust BOD function</p></a></li>
<li><a href='#robust_DEA'><p>Robust Data Envelopment Analysis (DEA)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Robust and Conditional Data Envelopment Analysis (DEA)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anna Mergoni &lt;anna.mergoni@kuleuven.be&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>With this package we provide an easy method to compute robust and conditional Data Envelopment Analysis (DEA), 
             Free Disposal Hull (FDH) and Benefit of the Doubt (BOD) scores. 
             The robust approach is based on the work of Cazals, Florens and Simar (2002) &lt;<a href="https://doi.org/10.1016%2FS0304-4076%2801%2900080-X">doi:10.1016/S0304-4076(01)00080-X</a>&gt;. 
             The conditional approach is based on Daraio and Simar (2007) &lt;<a href="https://doi.org/10.1007%2Fs11123-007-0049-3">doi:10.1007/s11123-007-0049-3</a>&gt;.
             Besides we provide graphs to help with the choice of m. 
             We relay on the 'Benchmarking' package to compute the efficiency scores and on the 'np' package to compute non parametric estimation of similarity among units.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>np , Benchmarking</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-12 09:08:00 UTC; Anna</td>
</tr>
<tr>
<td>Author:</td>
<td>Anna Mergoni <a href="https://orcid.org/0000-0002-9128-5341"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-14 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='conditional_BOD'>Conditional BOD function</h2><span id='topic+conditional_BOD'></span>

<h3>Description</h3>

<p>This function allows to compute Robust and Conditional BOD scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_BOD(
  output,
  exogenous = FALSE,
  m,
  B,
  alpha = FALSE,
  RTS = "CRS",
  ORIENTATION = "in",
  similarity = FALSE,
  inclusion = FALSE,
  print = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_BOD_+3A_output">output</code></td>
<td>
<p>matrix (or vector) of indicators along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="conditional_BOD_+3A_exogenous">exogenous</code></td>
<td>
<p>matrix (or vector) of exogenous variables involved in the conditional analysis. The similarity among the units is determined according to the exogeneous variable(s) using the function npudensbw and npudens (from the package np) with epanechnikov kernel.</p>
</td></tr>
<tr><td><code id="conditional_BOD_+3A_m">m</code></td>
<td>
<p>number of unit to be included in the reference set</p>
</td></tr>
<tr><td><code id="conditional_BOD_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="conditional_BOD_+3A_alpha">alpha</code></td>
<td>
<p>This allow to choose the size of the Confidence Intervals computed. By defaulta alpha = FALSE. In this case no confidence interval are computed</p>
</td></tr>
<tr><td><code id="conditional_BOD_+3A_rts">RTS</code></td>
<td>
<p>Default = &quot;CRS&quot;. For more details see the dea function in the package Benchmarking. Text string or a number defining the underlying DEA technology / returns to scale assumption.
0    fdh    Free disposability hull, no convexity assumption
1    vrs    Variable returns to scale, convexity and free disposability
2    drs    Decreasing returns to scale, convexity, down-scaling and free disposability
3    crs    Constant returns to scale, convexity and free disposability
4    irs    Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability
5    irs2    Increasing returns to scale (up-scaling, but not down-scaling), additivity, and free disposability
6    add    Additivity (scaling up and down, but only with integers), and free disposability; also known af replicability and free disposability, the free disposability and replicability hull (frh) &ndash; no convexity assumption
7    fdh+    A combination of free disposability and restricted or local constant return to scale
10    vrs+    As vrs, but with restrictions on the individual lambdas via param</p>
</td></tr>
<tr><td><code id="conditional_BOD_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Default = &quot;in&quot;. For more details see the dea function in the package Benchmarking. Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with DIRECT, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="conditional_BOD_+3A_similarity">similarity</code></td>
<td>
<p>matrix of similarities. In alternative to provide the exogenous variables, the matrix of similarities can be directly provided. This allow to customize the estimation of the similarities.</p>
</td></tr>
<tr><td><code id="conditional_BOD_+3A_inclusion">inclusion</code></td>
<td>
<p>If inclusion = TRUE the unit under analysis is included in the reference set. So, no super efficient scores are allowed. By default inclusion = FALSE.</p>
</td></tr>
<tr><td><code id="conditional_BOD_+3A_print">print</code></td>
<td>
<p>If print = TRUE the number of the unit under evaluation is printed. In case of large sample the function could require some time, so it could be useful to control how many units have already been evaluated and which one still have to be evaluated. By default print = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the parameter alpha is specified, the function returns a data frame with three numeric columns.
The first column is the vector representing the conditional BOD scores (eff);
the second column is the vector representing the lower bound of the condifence interval (ci_low);
the third column is the vector representing the upper bound of the confidence interval (Ci_up).
If alpha is not specified, the functions returns only the first column of the data frame (eff).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example with a very small sample to decrease computational time
          y1 &lt;-runif(50, 50, 75)
          y2 &lt;-runif(50, 30, 75)
          y &lt;- cbind(y1, y2)
          z &lt;- ifelse(rnorm(50, 0, 1)&gt;0, 1, 0)

          #Conditional BOD
          c_BOD &lt;- conditional_BOD(output = y, exogenous = z,
                                   m = 30, B = 50)
          summary(c_BOD$eff)

 #Example with bigger sample
          y1 &lt;-runif(100, 50, 75)
          y2 &lt;-runif(100, 30, 75)
          y &lt;- cbind(y1, y2)
          z &lt;- ifelse(rnorm(100, 0, 1)&gt;0, 1, 0)

          #Conditional BOD
          c_BOD &lt;- conditional_BOD(output = y, exogenous = z,
                                   similarity = FALSE,
                                   m = 30, B = 50)
          summary(c_BOD$eff)

</code></pre>

<hr>
<h2 id='conditional_DEA'>Conditional DEA function</h2><span id='topic+conditional_DEA'></span>

<h3>Description</h3>

<p>This function allows to compute Robust and Conditional DEA scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_DEA(
  input,
  output,
  exogenous = FALSE,
  alpha = FALSE,
  m,
  B,
  RTS = "crs",
  ORIENTATION = "in",
  similarity = FALSE,
  inclusion = FALSE,
  print = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_DEA_+3A_input">input</code></td>
<td>
<p>matrix (or vector) of inputs along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_output">output</code></td>
<td>
<p>matrix (or vector) of outputs along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_exogenous">exogenous</code></td>
<td>
<p>matrix (or vector) of exogenous variables involved in the conditional analysis. The similarity among the units is determined according to the exogeneous variable(s) using the function npudensbw and npudens (from the package np) with epanechnikov kernel.</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_alpha">alpha</code></td>
<td>
<p>This allow to choose the size of the Confidence Intervals computed. By defaulta alpha = FALSE. In this case no confidence interval are computed</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_m">m</code></td>
<td>
<p>number of unit to be included in the reference set</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_rts">RTS</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Text string or a number defining the underlying DEA technology / returns to scale assumption.
0    fdh    Free disposability hull, no convexity assumption
1    vrs    Variable returns to scale, convexity and free disposability
2    drs    Decreasing returns to scale, convexity, down-scaling and free disposability
3    crs    Constant returns to scale, convexity and free disposability
4    irs    Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability
5    irs2    Increasing returns to scale (up-scaling, but not down-scaling), additivity, and free disposability
6    add    Additivity (scaling up and down, but only with integers), and free disposability; also known af replicability and free disposability, the free disposability and replicability hull (frh) &ndash; no convexity assumption
7    fdh+    A combination of free disposability and restricted or local constant return to scale
10    vrs+    As vrs, but with restrictions on the individual lambdas via param</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_orientation">ORIENTATION</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with DIRECT, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_similarity">similarity</code></td>
<td>
<p>matrix of similarities. In alternative to provide the exogenous variables, the matrix of similarities can be directly provided. This allow to customize the estimation of the similarities.</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_inclusion">inclusion</code></td>
<td>
<p>If inclusion = TRUE the unit under analysis is included in the reference set. So, no super efficient scores are allowed. By default inclusion = FALSE.</p>
</td></tr>
<tr><td><code id="conditional_DEA_+3A_print">print</code></td>
<td>
<p>If print = TRUE the number of the unit under evaluation is printed. In case of large sample the function could require some time, so it could be useful to control how many units have already been evaluated and which one still have to be evaluated. By default print = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the parameter alpha is specified, the function returns a data frame with three numeric columns.
The first column is the vector representing the conditional DEA scores (eff);
the second column is the vector representing the lower bound of the condifence interval (ci_low);
the third column is the vector representing the upper bound of the confidence interval (Ci_up).
If alpha is not specified, the functions returns only the first column of the data frame (eff).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example with a very small sample to decrease computational time.
          x1 &lt;-runif(50, 50, 75)
          x2 &lt;-runif(50, 30, 75)
          x &lt;- cbind(x1, x2)
          e &lt;- rnorm(50, 0, 36)
          a1 &lt;- 0.4
          a2 &lt;- 0.6
          y &lt;- a1*x1 + a2*x2 + e
          z &lt;- ifelse(rnorm(50, 0, 1)&gt;0, 1, 0)

          #Conditional DEA
          c_DEA &lt;- conditional_DEA(input = x, output = y, exogenous = z,
                                   m = 30, B = 50,
                                   RTS = "crs", ORIENTATION = "in")
          summary(c_DEA$eff)

          #Example with bigger sample
          x1 &lt;-runif(100, 50, 75)
          x2 &lt;-runif(100, 30, 75)
          x &lt;- cbind(x1, x2)
          a1 &lt;- 0.4
          a2 &lt;- 0.6
          y &lt;- a1*x1 + a2*x2
          z &lt;- ifelse(rnorm(100, 0, 1)&gt;0, 1, 0)

          #Conditional DEA
          c_DEA &lt;- conditional_DEA(input = x, output = y, exogenous = z,
                                   m = 30, B = 50,
                                   RTS = "crs", ORIENTATION = "in")
          summary(c_DEA$eff)

</code></pre>

<hr>
<h2 id='graph1_m_BOD'>Graph to select m</h2><span id='topic+graph1_m_BOD'></span>

<h3>Description</h3>

<p>This function allows to draw a graph that relates the number of super efficient units and the choice of m
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph1_m_BOD(
  output,
  mseries,
  B,
  RTS = "crs",
  ORIENTATION = "in",
  check = c(1),
  col = c("black"),
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph1_m_BOD_+3A_output">output</code></td>
<td>
<p>matrix (or vector) of indicators along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="graph1_m_BOD_+3A_mseries">mseries</code></td>
<td>
<p>vector containing the different values of f that needed to be tested.</p>
</td></tr>
<tr><td><code id="graph1_m_BOD_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="graph1_m_BOD_+3A_rts">RTS</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Text string or a number defining the underlying DEA technology / returns to scale assumption.
0    fdh    Free disposability hull, no convexity assumption
1    vrs    Variable returns to scale, convexity and free disposability
2    drs    Decreasing returns to scale, convexity, down-scaling and free disposability
3    crs    Constant returns to scale, convexity and free disposability
4    irs    Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability
5    irs2    Increasing returns to scale (up-scaling, but not down-scaling), additivity, and free disposability
6    add    Additivity (scaling up and down, but only with integers), and free disposability; also known af replicability and free disposability, the free disposability and replicability hull (frh) &ndash; no convexity assumption
7    fdh+    A combination of free disposability and restricted or local constant return to scale
10    vrs+    As vrs, but with restrictions on the individual lambdas via param</p>
</td></tr>
<tr><td><code id="graph1_m_BOD_+3A_orientation">ORIENTATION</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with DIRECT, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="graph1_m_BOD_+3A_check">check</code></td>
<td>
<p>vector containing the values of the thresholds to be considered to define the superefficient units</p>
</td></tr>
<tr><td><code id="graph1_m_BOD_+3A_col">col</code></td>
<td>
<p>vector containing the colors. the vector col must contain the same number of element of the vector check.</p>
</td></tr>
<tr><td><code id="graph1_m_BOD_+3A_print">print</code></td>
<td>
<p>If print = TRUE the number of the unit under evaluation is printed. In case of large sample the function could require some time, so it could be useful to control how many units have already been evaluated and which one still have to be evaluated. By default print = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return a plot, representing the percentage of super-efficient units for the different values of m.
A unit is defined as super-efficient if it gets a value higher than a certain treshold (normally 1) in the robust analysis.
Each line of the plot represent different values of the tresholds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #Example with a very small sample to decrease computational time.
 y1 &lt;-runif(20, 50, 75)
 y2 &lt;-runif(20, 30, 75)
 y &lt;- cbind(y1, y2)

 check &lt;- c(1, 1.05, 1.5)
 colors &lt;- c("black", "red", "blue")

 graph1_m_BOD(output = y, mseries = c(5, 10, 15),
              B = 50, RTS = "crs", ORIENTATION = "in",
              check = check, col = colors)

  #An example with a larger sample size.
  x1 &lt;-runif(100, 50, 75)
  x2 &lt;-runif(100, 30, 75)
  x &lt;- cbind(x1, x2)
  y &lt;- cbind(x+runif(100, -10, 0), rnorm(100, 15, 4))

 graph1_m_BOD(output = y,
        mseries = c(20, 30, 40, 50, 60, 70, 80),
        B = 50,
        RTS = "crs", ORIENTATION = "in",
        check = c(1, 1.05, 1.2, 1.5),
        col = c("black", "red", "blue", "green")) 

</code></pre>

<hr>
<h2 id='graph1_m_DEA'>Graph to select m</h2><span id='topic+graph1_m_DEA'></span>

<h3>Description</h3>

<p>This function allows to draw a graph that relates the number of super efficient units and the choice of m
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph1_m_DEA(
  input,
  output,
  mseries,
  B,
  RTS = "crs",
  ORIENTATION = "in",
  check = c(1),
  col = c("black"),
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph1_m_DEA_+3A_input">input</code></td>
<td>
<p>matrix (or vector) of inputs along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="graph1_m_DEA_+3A_output">output</code></td>
<td>
<p>matrix (or vector) of outputs along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="graph1_m_DEA_+3A_mseries">mseries</code></td>
<td>
<p>vector containing the different values of f that needed to be tested.</p>
</td></tr>
<tr><td><code id="graph1_m_DEA_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="graph1_m_DEA_+3A_rts">RTS</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Text string or a number defining the underlying DEA technology / returns to scale assumption.
0    fdh    Free disposability hull, no convexity assumption
1    vrs    Variable returns to scale, convexity and free disposability
2    drs    Decreasing returns to scale, convexity, down-scaling and free disposability
3    crs    Constant returns to scale, convexity and free disposability
4    irs    Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability
5    irs2    Increasing returns to scale (up-scaling, but not down-scaling), additivity, and free disposability
6    add    Additivity (scaling up and down, but only with integers), and free disposability; also known af replicability and free disposability, the free disposability and replicability hull (frh) &ndash; no convexity assumption
7    fdh+    A combination of free disposability and restricted or local constant return to scale
10    vrs+    As vrs, but with restrictions on the individual lambdas via param</p>
</td></tr>
<tr><td><code id="graph1_m_DEA_+3A_orientation">ORIENTATION</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with DIRECT, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="graph1_m_DEA_+3A_check">check</code></td>
<td>
<p>vector containing the values of the thresholds to be considered to define the superefficient units</p>
</td></tr>
<tr><td><code id="graph1_m_DEA_+3A_col">col</code></td>
<td>
<p>vector containing the colors. the vector col must contain the same number of element of the vector check.</p>
</td></tr>
<tr><td><code id="graph1_m_DEA_+3A_print">print</code></td>
<td>
<p>If print = TRUE the number of the unit under evaluation is printed. In case of large sample the function could require some time, so it could be useful to control how many units have already been evaluated and which one still have to be evaluated. By default print = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return a plot, representing the percentage of super-efficient units for the different values of m.
A unit is defined as super-efficient if it gets a value higher than a certain treshold (normally 1) in the robust analysis.
Each line of the plot represent different values of the tresholds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #Example with a very small sample to decrease computational time.
 x1 &lt;-runif(20, 50, 75)
 x2 &lt;-runif(20, 30, 75)
 x &lt;- cbind(x1, x2)
 e &lt;- rnorm(20, 0, 36)
 a1 &lt;- 0.4
 a2 &lt;- 0.6
 y &lt;- a1*x1 + a2*x2 + e

 check &lt;- c(1, 1.05, 1.5)
 colors &lt;- c("black", "red", "blue")

 graph1_m_DEA(input = x, output = y, mseries = c(5, 10, 15, 20),
              B = 50, RTS = "crs", ORIENTATION = "in",
              check = check, col = colors)



 #An example with a larger sample size.
 x1 &lt;-runif(100, 50, 75)
 x2 &lt;-runif(100, 30, 75)
 x &lt;- cbind(x1, x2)
 y &lt;- cbind(x+runif(100, -10, 0), rnorm(100, 15, 4))

 check &lt;- c(1, 1.05, 1.2, 1.5)
 colors &lt;- c("black", "red", "blue", "green")

 graph1_m_DEA(input = x, output = y, mseries = c(20, 30, 40, 50, 60, 70, 80),
              B = 50, RTS = "crs", ORIENTATION = "in",
              check = check,
              col = colors) 

</code></pre>

<hr>
<h2 id='graph2_m_BOD'>Graph to select m</h2><span id='topic+graph2_m_BOD'></span>

<h3>Description</h3>

<p>This function allows to draw a graph that relates the average efficiency score and the choice of m
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph2_m_BOD(output, mseries, B, RTS = "crs", ORIENTATION = "in", print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph2_m_BOD_+3A_output">output</code></td>
<td>
<p>matrix (or vector) of indicators along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="graph2_m_BOD_+3A_mseries">mseries</code></td>
<td>
<p>vector containing the different values of m that needed to be tested.</p>
</td></tr>
<tr><td><code id="graph2_m_BOD_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="graph2_m_BOD_+3A_rts">RTS</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Text string or a number defining the underlying DEA technology / returns to scale assumption.
0    fdh    Free disposability hull, no convexity assumption
1    vrs    Variable returns to scale, convexity and free disposability
2    drs    Decreasing returns to scale, convexity, down-scaling and free disposability
3    crs    Constant returns to scale, convexity and free disposability
4    irs    Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability
5    irs2    Increasing returns to scale (up-scaling, but not down-scaling), additivity, and free disposability
6    add    Additivity (scaling up and down, but only with integers), and free disposability; also known af replicability and free disposability, the free disposability and replicability hull (frh) &ndash; no convexity assumption
7    fdh+    A combination of free disposability and restricted or local constant return to scale
10    vrs+    As vrs, but with restrictions on the individual lambdas via param</p>
</td></tr>
<tr><td><code id="graph2_m_BOD_+3A_orientation">ORIENTATION</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with DIRECT, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="graph2_m_BOD_+3A_print">print</code></td>
<td>
<p>If print = TRUE the number of the unit under evaluation is printed. In case of large sample the function could require some time, so it could be useful to control how many units have already been evaluated and which one still have to be evaluated. By default print = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return a plot representing the average score from the robust analysis for the different values of m chosen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #Example with a very small sample to decrease computational time.
 y1 &lt;-runif(20, 50, 75)
 y2 &lt;-runif(20, 30, 75)
 y &lt;- cbind(y1, y2)

 graph2_m_BOD(output = y, mseries = c(5, 10, 15), B = 50,
              RTS = "crs", ORIENTATION = "in")



 #An example with a larger sample size.
 y1 &lt;-runif(100, 50, 75)
 y2 &lt;-runif(100, 30, 75)
 y &lt;- cbind(y1, y2)

 graph2_m_BOD(output = y,
              mseries = c(20, 30, 40, 50, 60, 70, 80),
              B = 50, RTS = "crs", ORIENTATION = "in")

</code></pre>

<hr>
<h2 id='graph2_m_DEA'>Graph to select m</h2><span id='topic+graph2_m_DEA'></span>

<h3>Description</h3>

<p>This function allows to draw a graph that relates the average efficiency score and the choice of m
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph2_m_DEA(
  input,
  output,
  mseries,
  B,
  RTS = "crs",
  ORIENTATION = "in",
  print = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph2_m_DEA_+3A_input">input</code></td>
<td>
<p>matrix (or vector) of inputs along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="graph2_m_DEA_+3A_output">output</code></td>
<td>
<p>matrix (or vector) of outputs along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="graph2_m_DEA_+3A_mseries">mseries</code></td>
<td>
<p>vector containing the different values of m that needed to be tested.</p>
</td></tr>
<tr><td><code id="graph2_m_DEA_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="graph2_m_DEA_+3A_rts">RTS</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Text string or a number defining the underlying DEA technology / returns to scale assumption.
0    fdh    Free disposability hull, no convexity assumption
1    vrs    Variable returns to scale, convexity and free disposability
2    drs    Decreasing returns to scale, convexity, down-scaling and free disposability
3    crs    Constant returns to scale, convexity and free disposability
4    irs    Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability
5    irs2    Increasing returns to scale (up-scaling, but not down-scaling), additivity, and free disposability
6    add    Additivity (scaling up and down, but only with integers), and free disposability; also known af replicability and free disposability, the free disposability and replicability hull (frh) &ndash; no convexity assumption
7    fdh+    A combination of free disposability and restricted or local constant return to scale
10    vrs+    As vrs, but with restrictions on the individual lambdas via param</p>
</td></tr>
<tr><td><code id="graph2_m_DEA_+3A_orientation">ORIENTATION</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with DIRECT, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="graph2_m_DEA_+3A_print">print</code></td>
<td>
<p>If print = TRUE, the number of the unit under evaluation is printed. In case of large sample the function could require some time, so it could be useful to control how many units have already been evaluated and which one still have to be evaluated. By default print = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function return a plot representing the average score from the robust analysis for the different values of m chosen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #Example with a very small sample to decrease computational time.
 x1 &lt;-runif(20, 50, 75)
 x2 &lt;-runif(20, 30, 75)
 x &lt;- cbind(x1, x2)
 e &lt;- rnorm(20, 0, 36)
 a1 &lt;- 0.4
 a2 &lt;- 0.6
 y &lt;- a1*x1 + a2*x2 + e

 graph2_m_DEA(input = x, output = y,  mseries = c(5, 10, 15, 20),
              B = 50, RTS = "crs", ORIENTATION = "in")


 #An example with a larger sample size.
 x1 &lt;-runif(100, 50, 75)
 x2 &lt;-runif(100, 30, 75)
 x &lt;- cbind(x1, x2)
 y &lt;- cbind(x+runif(100, -10, 0), rnorm(100, 15, 4))

 graph2_m_DEA(input = x, output = y,
              mseries = c(20, 30, 40, 50, 60, 70, 80), B = 50,
              RTS = "crs", ORIENTATION = "in") 

</code></pre>

<hr>
<h2 id='robust_BOD'>Robust BOD function</h2><span id='topic+robust_BOD'></span>

<h3>Description</h3>

<p>This function allows to compute Robust  BOD scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_BOD(
  output,
  m,
  B,
  alpha = FALSE,
  RTS = "CRS",
  ORIENTATION = "in",
  inclusion = FALSE,
  print = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_BOD_+3A_output">output</code></td>
<td>
<p>matrix (or vector) of indicators along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="robust_BOD_+3A_m">m</code></td>
<td>
<p>number of unit to be included in the reference set</p>
</td></tr>
<tr><td><code id="robust_BOD_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="robust_BOD_+3A_alpha">alpha</code></td>
<td>
<p>This allow to choose the size of the Confidence Intervals computed. By defaulta alpha = FALSE. In this case no confidence interval are computed</p>
</td></tr>
<tr><td><code id="robust_BOD_+3A_rts">RTS</code></td>
<td>
<p>Default = &quot;CRS&quot;. For more details see the dea function in the package Benchmarking. Text string or a number defining the underlying DEA technology / returns to scale assumption.
0    fdh    Free disposability hull, no convexity assumption
1    vrs    Variable returns to scale, convexity and free disposability
2    drs    Decreasing returns to scale, convexity, down-scaling and free disposability
3    crs    Constant returns to scale, convexity and free disposability
4    irs    Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability
5    irs2    Increasing returns to scale (up-scaling, but not down-scaling), additivity, and free disposability
6    add    Additivity (scaling up and down, but only with integers), and free disposability; also known af replicability and free disposability, the free disposability and replicability hull (frh) &ndash; no convexity assumption
7    fdh+    A combination of free disposability and restricted or local constant return to scale
10    vrs+    As vrs, but with restrictions on the individual lambdas via param</p>
</td></tr>
<tr><td><code id="robust_BOD_+3A_orientation">ORIENTATION</code></td>
<td>
<p>Default = &quot;in&quot;. For more details see the dea function in the package Benchmarking. Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with DIRECT, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="robust_BOD_+3A_inclusion">inclusion</code></td>
<td>
<p>If inclusion = TRUE the unit under analysis is included in the reference set. So, no super efficient scores are allowed. By default inclusion = FALSE.</p>
</td></tr>
<tr><td><code id="robust_BOD_+3A_print">print</code></td>
<td>
<p>If print = TRUE the number of the unit under evaluation is printed. In case of large sample the function could require some time, so it could be useful to control how many units have already been evaluated and which one still have to be evaluated. By default print = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the parameter alpha is specified, the function returns a data frame with three numeric columns.
The first column is the vector representing the robust BOD scores (eff);
the second column is the vector representing the lower bound of the condifence interval (ci_low);
the third column is the vector representing the upper bound of the confidence interval (Ci_up).
If alpha is not specified, the functions returns only the first column of the data frame (eff).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example with a very small sample to decrease computational time.
          y1 &lt;-runif(50, 50, 75)
          y2 &lt;-runif(50, 30, 75)
          y &lt;- cbind(y1, y2)

          #Robust BOD
          r_BOD &lt;- robust_BOD(output = y, m = 30, B = 50,
                              RTS = "crs", ORIENTATION = "in", print = TRUE)
          summary(r_BOD$eff)

          ## Not run: #Example with random data x and y
          y1 &lt;-runif(100, 50, 75)
          y2 &lt;-runif(100, 30, 75)
          y &lt;- cbind(y1, y2)

          #Robust BOD
          r_BOD &lt;- robust_BOD(output = y, m = 30, B = 50,
                              RTS = "crs", ORIENTATION = "in", print = TRUE)
          summary(r_BOD$eff)
## End(Not run)

</code></pre>

<hr>
<h2 id='robust_DEA'>Robust Data Envelopment Analysis (DEA)</h2><span id='topic+robust_DEA'></span>

<h3>Description</h3>

<p>This function allows to compute Robust  DEA scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_DEA(
  input,
  output,
  m,
  B,
  RTS = "crs",
  ORIENTATION = "in",
  alpha = FALSE,
  inclusion = FALSE,
  print = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_DEA_+3A_input">input</code></td>
<td>
<p>matrix (or vector) of inputs along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="robust_DEA_+3A_output">output</code></td>
<td>
<p>matrix (or vector) of outputs along which the units are evaluated.</p>
</td></tr>
<tr><td><code id="robust_DEA_+3A_m">m</code></td>
<td>
<p>number of unit to be included in the reference set</p>
</td></tr>
<tr><td><code id="robust_DEA_+3A_b">B</code></td>
<td>
<p>number of bootstrap replicates</p>
</td></tr>
<tr><td><code id="robust_DEA_+3A_rts">RTS</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Text string or a number defining the underlying DEA technology / returns to scale assumption.
0    fdh    Free disposability hull, no convexity assumption
1    vrs    Variable returns to scale, convexity and free disposability
2    drs    Decreasing returns to scale, convexity, down-scaling and free disposability
3    crs    Constant returns to scale, convexity and free disposability
4    irs    Increasing returns to scale, (up-scaling, but not down-scaling), convexity and free disposability
5    irs2    Increasing returns to scale (up-scaling, but not down-scaling), additivity, and free disposability
6    add    Additivity (scaling up and down, but only with integers), and free disposability; also known af replicability and free disposability, the free disposability and replicability hull (frh) &ndash; no convexity assumption
7    fdh+    A combination of free disposability and restricted or local constant return to scale
10    vrs+    As vrs, but with restrictions on the individual lambdas via param</p>
</td></tr>
<tr><td><code id="robust_DEA_+3A_orientation">ORIENTATION</code></td>
<td>
<p>For more details see the dea function in the package Benchmarking. Input efficiency &quot;in&quot; (1), output efficiency &quot;out&quot; (2), and graph efficiency &quot;graph&quot; (3). For use with DIRECT, an additional option is &quot;in-out&quot; (0).</p>
</td></tr>
<tr><td><code id="robust_DEA_+3A_alpha">alpha</code></td>
<td>
<p>This allow to choose the size of the Confidence Intervals computed. By defaulta alpha = FALSE. In this case no confidence interval are computed</p>
</td></tr>
<tr><td><code id="robust_DEA_+3A_inclusion">inclusion</code></td>
<td>
<p>If inclusion = TRUE the unit under analysis is included in the reference set. So, no super efficient scores are allowed. By default inclusion = FALSE.</p>
</td></tr>
<tr><td><code id="robust_DEA_+3A_print">print</code></td>
<td>
<p>If print = TRUE the number of the unit under evaluation is printed. In case of large sample the function could require some time, so it could be useful to control how many units have already been evaluated and which one still have to be evaluated. By default print = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the parameter alpha is specified, the function returns a data frame with three numeric columns.
The first column is the vector representing the robust DEA scores (eff);
the second column is the vector representing the lower bound of the condifence interval (ci_low);
the third column is the vector representing the upper bound of the confidence interval (Ci_up).
If alpha is not specified, the functions returns only the first column of the data frame (eff).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example with a very small sample to decrease computational time.
          x1 &lt;-runif(50, 50, 75)
          x2 &lt;-runif(50, 30, 75)
          x &lt;- cbind(x1, x2)
          e &lt;- rnorm(50, 0, 36)
          a1 &lt;- 0.4
          a2 &lt;- 0.6
          y &lt;- a1*x1 + a2*x2 + e

          #Robust DEA
          r_DEA &lt;- robust_DEA(input = x, output = y, m = 20, B = 50,
          RTS = "crs", ORIENTATION = "in", print = TRUE)
          summary(r_DEA$eff)

 #Example with random data x and y
          x1 &lt;-runif(100, 50, 75)
          x2 &lt;-runif(100, 30, 75)
          x &lt;- cbind(x1, x2)
          y &lt;- cbind(x+runif(100, -10, 0), rnorm(100, 15, 4))

          #Robust DEA
          r_DEA &lt;- robust_DEA(input = x, output = y, m = 30, B = 40,
          RTS = "crs", ORIENTATION = "in", print = TRUE)
          summary(r_DEA$eff) 

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
