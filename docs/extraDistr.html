<!DOCTYPE html><html><head><title>Help for package extraDistr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {extraDistr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#extraDistr-package'><p>extraDistr: Additional Univariate and Multivariate Distributions</p></a></li>
<li><a href='#Bernoulli'><p>Bernoulli distribution</p></a></li>
<li><a href='#BetaBinom'><p>Beta-binomial distribution</p></a></li>
<li><a href='#BetaNegBinom'><p>Beta-negative binomial distribution</p></a></li>
<li><a href='#BetaPrime'><p>Beta prime distribution</p></a></li>
<li><a href='#Bhattacharjee'><p>Bhattacharjee distribution</p></a></li>
<li><a href='#BirnbaumSaunders'><p>Birnbaum-Saunders (fatigue life) distribution</p></a></li>
<li><a href='#BivNormal'><p>Bivariate normal distribution</p></a></li>
<li><a href='#BivPoiss'><p>Bivariate Poisson distribution</p></a></li>
<li><a href='#Categorical'><p>Categorical distribution</p></a></li>
<li><a href='#Dirichlet'><p>Dirichlet distribution</p></a></li>
<li><a href='#DirMnom'><p>Dirichlet-multinomial (multivariate Polya) distribution</p></a></li>
<li><a href='#DiscreteGamma'><p>Discrete gamma distribution</p></a></li>
<li><a href='#DiscreteLaplace'><p>Discrete Laplace distribution</p></a></li>
<li><a href='#DiscreteNormal'><p>Discrete normal distribution</p></a></li>
<li><a href='#DiscreteUniform'><p>Discrete uniform distribution</p></a></li>
<li><a href='#DiscreteWeibull'><p>Discrete Weibull distribution (type I)</p></a></li>
<li><a href='#Frechet'><p>Frechet distribution</p></a></li>
<li><a href='#GammaPoiss'><p>Gamma-Poisson distribution</p></a></li>
<li><a href='#GEV'><p>Generalized extreme value distribution</p></a></li>
<li><a href='#Gompertz'><p>Gompertz distribution</p></a></li>
<li><a href='#GPD'><p>Generalized Pareto distribution</p></a></li>
<li><a href='#Gumbel'><p>Gumbel distribution</p></a></li>
<li><a href='#HalfCauchy'><p>Half-Cauchy distribution</p></a></li>
<li><a href='#HalfNormal'><p>Half-normal distribution</p></a></li>
<li><a href='#HalfT'><p>Half-t distribution</p></a></li>
<li><a href='#Huber'><p>&quot;Huber density&quot; distribution</p></a></li>
<li><a href='#InvChiSq'><p>Inverse chi-squared and scaled chi-squared distributions</p></a></li>
<li><a href='#InvGamma'><p>Inverse-gamma distribution</p></a></li>
<li><a href='#Kumaraswamy'><p>Kumaraswamy distribution</p></a></li>
<li><a href='#Laplace'><p>Laplace distribution</p></a></li>
<li><a href='#LocationScaleT'><p>Location-scale version of the t-distribution</p></a></li>
<li><a href='#LogSeries'><p>Logarithmic series distribution</p></a></li>
<li><a href='#Lomax'><p>Lomax distribution</p></a></li>
<li><a href='#MultiHypergeometric'><p>Multivariate hypergeometric distribution</p></a></li>
<li><a href='#Multinomial'><p>Multinomial distribution</p></a></li>
<li><a href='#NegHyper'><p>Negative hypergeometric distribution</p></a></li>
<li><a href='#NormalMix'><p>Mixture of normal distributions</p></a></li>
<li><a href='#NSBeta'><p>Non-standard beta distribution</p></a></li>
<li><a href='#Pareto'><p>Pareto distribution</p></a></li>
<li><a href='#PoissonMix'><p>Mixture of Poisson distributions</p></a></li>
<li><a href='#PowerDist'><p>Power distribution</p></a></li>
<li><a href='#PropBeta'><p>Beta distribution of proportions</p></a></li>
<li><a href='#Rademacher'><p>Random generation from Rademacher distribution</p></a></li>
<li><a href='#Rayleigh'><p>Rayleigh distribution</p></a></li>
<li><a href='#ShiftGomp'><p>Shifted Gompertz distribution</p></a></li>
<li><a href='#Skellam'><p>Skellam distribution</p></a></li>
<li><a href='#Slash'><p>Slash distribution</p></a></li>
<li><a href='#Triangular'><p>Triangular distribution</p></a></li>
<li><a href='#TruncBinom'><p>Truncated binomial distribution</p></a></li>
<li><a href='#TruncNormal'><p>Truncated normal distribution</p></a></li>
<li><a href='#TruncPoisson'><p>Truncated Poisson distribution</p></a></li>
<li><a href='#TukeyLambda'><p>Tukey lambda distribution</p></a></li>
<li><a href='#Wald'><p>Wald (inverse Gaussian) distribution</p></a></li>
<li><a href='#ZIB'><p>Zero-inflated binomial distribution</p></a></li>
<li><a href='#ZINB'><p>Zero-inflated negative binomial distribution</p></a></li>
<li><a href='#ZIP'><p>Zero-inflated Poisson distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Additional Univariate and Multivariate Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.10.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Tymoteusz Wolodzko</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tymoteusz Wolodzko &lt;twolodzko+extraDistr@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Density, distribution function, quantile function
    and random generation for a number of univariate
    and multivariate distributions. This package implements the
    following distributions: Bernoulli, beta-binomial, beta-negative
    binomial, beta prime, Bhattacharjee, Birnbaum-Saunders,
    bivariate normal, bivariate Poisson, categorical, Dirichlet,
    Dirichlet-multinomial, discrete gamma, discrete Laplace,
    discrete normal, discrete uniform, discrete Weibull, Frechet,
    gamma-Poisson, generalized extreme value, Gompertz,
    generalized Pareto, Gumbel, half-Cauchy, half-normal, half-t,
    Huber density, inverse chi-squared, inverse-gamma, Kumaraswamy,
    Laplace, location-scale t, logarithmic, Lomax, multivariate
    hypergeometric, multinomial, negative hypergeometric,
    non-standard beta, normal mixture, Poisson mixture, Pareto,
    power, reparametrized beta, Rayleigh, shifted Gompertz, Skellam,
    slash, triangular, truncated binomial, truncated normal,
    truncated Poisson, Tukey lambda, Wald, zero-inflated binomial,
    zero-inflated negative binomial, zero-inflated Poisson.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/twolodzko/extraDistr">https://github.com/twolodzko/extraDistr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/twolodzko/extraDistr/issues">https://github.com/twolodzko/extraDistr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, LaplacesDemon, VGAM, evd, skellam, triangle, actuar</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 08:49:53 UTC; tymek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 09:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='extraDistr-package'>extraDistr: Additional Univariate and Multivariate Distributions</h2><span id='topic+extraDistr'></span><span id='topic+extraDistr-package'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for a number of univariate and multivariate distributions. This package implements the following distributions: Bernoulli, beta-binomial, beta-negative binomial, beta prime, Bhattacharjee, Birnbaum-Saunders, bivariate normal, bivariate Poisson, categorical, Dirichlet, Dirichlet-multinomial, discrete gamma, discrete Laplace, discrete normal, discrete uniform, discrete Weibull, Frechet, gamma-Poisson, generalized extreme value, Gompertz, generalized Pareto, Gumbel, half-Cauchy, half-normal, half-t, Huber density, inverse chi-squared, inverse-gamma, Kumaraswamy, Laplace, location-scale t, logarithmic, Lomax, multivariate hypergeometric, multinomial, negative hypergeometric, non-standard beta, normal mixture, Poisson mixture, Pareto, power, reparametrized beta, Rayleigh, shifted Gompertz, Skellam, slash, triangular, truncated binomial, truncated normal, truncated Poisson, Tukey lambda, Wald, zero-inflated binomial, zero-inflated negative binomial, zero-inflated Poisson.
</p>
<p>Density, distribution function, quantile function and random
generation for a number of univariate and multivariate distributions.
</p>


<h3>Details</h3>

<p>This package follows naming convention that is consistent with base R,
where density (or probability mass) functions, distribution functions,
quantile functions and random generation functions names are followed by
<code>d</code>*, <code>p</code>*, <code>q</code>*, and <code>r</code>* prefixes.
</p>
<p>Behaviour of the functions is consistent with base R, where for
not valid parameters values <code>NaN</code>'s are returned, while
for values beyond function support <code>0</code>'s are returned
(e.g. for non-integers in discrete distributions, or for
negative values in functions with non-negative support).
</p>
<p>All the functions vectorized and coded in C++ using <span class="pkg">Rcpp</span>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/twolodzko/extraDistr">https://github.com/twolodzko/extraDistr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/twolodzko/extraDistr/issues">https://github.com/twolodzko/extraDistr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Bernoulli'>Bernoulli distribution</h2><span id='topic+Bernoulli'></span><span id='topic+dbern'></span><span id='topic+pbern'></span><span id='topic+qbern'></span><span id='topic+rbern'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function, quantile function and random generation
for the Bernoulli distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbern(x, prob = 0.5, log = FALSE)

pbern(q, prob = 0.5, lower.tail = TRUE, log.p = FALSE)

qbern(p, prob = 0.5, lower.tail = TRUE, log.p = FALSE)

rbern(n, prob = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bernoulli_+3A_x">x</code>, <code id="Bernoulli_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_prob">prob</code></td>
<td>
<p>probability of success; (<code>0 &lt; prob &lt; 1</code>).</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_log">log</code>, <code id="Bernoulli_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Bernoulli_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Binomial">Binomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
prop.table(table(rbern(1e5, 0.5)))

</code></pre>

<hr>
<h2 id='BetaBinom'>Beta-binomial distribution</h2><span id='topic+BetaBinom'></span><span id='topic+dbbinom'></span><span id='topic+pbbinom'></span><span id='topic+rbbinom'></span>

<h3>Description</h3>

<p>Probability mass function and random generation
for the beta-binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbbinom(x, size, alpha = 1, beta = 1, log = FALSE)

pbbinom(q, size, alpha = 1, beta = 1, lower.tail = TRUE, log.p = FALSE)

rbbinom(n, size, alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BetaBinom_+3A_x">x</code>, <code id="BetaBinom_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="BetaBinom_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="BetaBinom_+3A_alpha">alpha</code>, <code id="BetaBinom_+3A_beta">beta</code></td>
<td>
<p>non-negative parameters of the beta distribution.</p>
</td></tr>
<tr><td><code id="BetaBinom_+3A_log">log</code>, <code id="BetaBinom_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BetaBinom_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="BetaBinom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">p \sim \mathrm{Beta}(\alpha, \beta)</code> and
<code class="reqn">X \sim \mathrm{Binomial}(n, p)</code>, then 
<code class="reqn">X \sim \mathrm{BetaBinomial}(n, \alpha, \beta)</code>.
</p>
<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = {n \choose x} \frac{\mathrm{B}(x+\alpha, n-x+\beta)}{\mathrm{B}(\alpha, \beta)}
</code>
</p>

<p>Cumulative distribution function is calculated using recursive algorithm that employs the fact that
<code class="reqn">\Gamma(x) = (x - 1)!</code>, and
<code class="reqn">
\mathrm{B}(x, y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
</code>, and that
<code class="reqn">
{n \choose k} = \prod_{i=1}^k \frac{n+1-i}{i}
</code>. This enables re-writing probability mass function as
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \left( \prod_{i=1}^x \frac{n+1-i}{i} \right) \frac{\frac{(\alpha+x-1)!\,(\beta+n-x-1)!}{(\alpha+\beta+n-1)!}}{\mathrm{B}(\alpha,\beta)}
</code>
</p>

<p>what makes recursive updating from <code class="reqn">x</code> to <code class="reqn">x+1</code> easy using the properties of factorials
</p>
<p style="text-align: center;"><code class="reqn">
f(x+1) = \left( \prod_{i=1}^x \frac{n+1-i}{i} \right) \frac{n+1-x+1}{x+1} \frac{\frac{(\alpha+x-1)! \,(\alpha+x)\,(\beta+n-x-1)! \, (\beta+n-x)^{-1}}{(\alpha+\beta+n-1)!\,(\alpha+\beta+n)}}{\mathrm{B}(\alpha,\beta)}
</code>
</p>

<p>and let's us efficiently calculate cumulative distribution function as a sum of probability mass functions
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \sum_{k=0}^x f(k)</code>
</p>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code>, <code><a href="stats.html#topic+Binomial">Binomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rbbinom(1e5, 1000, 5, 13)
xx &lt;- 0:1000
hist(x, 100, freq = FALSE)
lines(xx-0.5, dbbinom(xx, 1000, 5, 13), col = "red")
hist(pbbinom(x, 1000, 5, 13))
xx &lt;- seq(0, 1000, by = 0.1)
plot(ecdf(x))
lines(xx, pbbinom(xx, 1000, 5, 13), col = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='BetaNegBinom'>Beta-negative binomial distribution</h2><span id='topic+BetaNegBinom'></span><span id='topic+dbnbinom'></span><span id='topic+pbnbinom'></span><span id='topic+rbnbinom'></span>

<h3>Description</h3>

<p>Probability mass function and random generation
for the beta-negative binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbnbinom(x, size, alpha = 1, beta = 1, log = FALSE)

pbnbinom(q, size, alpha = 1, beta = 1, lower.tail = TRUE, log.p = FALSE)

rbnbinom(n, size, alpha = 1, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BetaNegBinom_+3A_x">x</code>, <code id="BetaNegBinom_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="BetaNegBinom_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more). Must be strictly positive, need not be integer.</p>
</td></tr>
<tr><td><code id="BetaNegBinom_+3A_alpha">alpha</code>, <code id="BetaNegBinom_+3A_beta">beta</code></td>
<td>
<p>non-negative parameters of the beta distribution.</p>
</td></tr>
<tr><td><code id="BetaNegBinom_+3A_log">log</code>, <code id="BetaNegBinom_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BetaNegBinom_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="BetaNegBinom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">p \sim \mathrm{Beta}(\alpha, \beta)</code> and
<code class="reqn">X \sim \mathrm{NegBinomial}(r, p)</code>, then 
<code class="reqn">X \sim \mathrm{BetaNegBinomial}(r, \alpha, \beta)</code>.
</p>
<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\Gamma(r+x)}{x! \,\Gamma(r)}
       \frac{\mathrm{B}(\alpha+r, \beta+x)}{\mathrm{B}(\alpha, \beta)}
</code>
</p>

<p>Cumulative distribution function is calculated using recursive algorithm that employs the fact that
<code class="reqn">\Gamma(x) = (x - 1)!</code> and
<code class="reqn">
\mathrm{B}(x, y) = \frac{\Gamma(x)\Gamma(y)}{\Gamma(x+y)}
</code>. This enables re-writing probability mass function as
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{(r+x-1)!}{x! \, \Gamma(r)} \frac{\frac{(\alpha+r-1)!\,(\beta+x-1)!}{(\alpha+\beta+r+x-1)!}}{\mathrm{B}(\alpha,\beta)}
</code>
</p>

<p>what makes recursive updating from <code class="reqn">x</code> to <code class="reqn">x+1</code> easy using the properties of factorials
</p>
<p style="text-align: center;"><code class="reqn">
f(x+1) = \frac{(r+x-1)!\,(r+x)}{x!\,(x+1) \, \Gamma(r)} \frac{\frac{(\alpha+r-1)!\,(\beta+x-1)!\,(\beta+x)}{(\alpha+\beta+r+x-1)!\,(\alpha+\beta+r+x)}}{\mathrm{B}(\alpha,\beta)}
</code>
</p>

<p>and let's us efficiently calculate cumulative distribution function as a sum of probability mass functions
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \sum_{k=0}^x f(k)</code>
</p>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code>, <code><a href="stats.html#topic+NegBinomial">NegBinomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rbnbinom(1e5, 1000, 5, 13)
xx &lt;- 0:1e5
hist(x, 100, freq = FALSE)
lines(xx-0.5, dbnbinom(xx, 1000, 5, 13), col = "red")
hist(pbnbinom(x, 1000, 5, 13))
xx &lt;- seq(0, 1e5, by = 0.1)
plot(ecdf(x))
lines(xx, pbnbinom(xx, 1000, 5, 13), col = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='BetaPrime'>Beta prime distribution</h2><span id='topic+BetaPrime'></span><span id='topic+dbetapr'></span><span id='topic+pbetapr'></span><span id='topic+qbetapr'></span><span id='topic+rbetapr'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the beta prime distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbetapr(x, shape1, shape2, scale = 1, log = FALSE)

pbetapr(q, shape1, shape2, scale = 1, lower.tail = TRUE, log.p = FALSE)

qbetapr(p, shape1, shape2, scale = 1, lower.tail = TRUE, log.p = FALSE)

rbetapr(n, shape1, shape2, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BetaPrime_+3A_x">x</code>, <code id="BetaPrime_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="BetaPrime_+3A_shape1">shape1</code>, <code id="BetaPrime_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters.</p>
</td></tr>
<tr><td><code id="BetaPrime_+3A_scale">scale</code></td>
<td>
<p>positive valued scale parameter.</p>
</td></tr>
<tr><td><code id="BetaPrime_+3A_log">log</code>, <code id="BetaPrime_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BetaPrime_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="BetaPrime_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="BetaPrime_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">X \sim \mathrm{Beta}(\alpha, \beta)</code>, then
<code class="reqn">\frac{X}{1-X} \sim \mathrm{BetaPrime}(\alpha, \beta)</code>.
</p>
<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{(x/\sigma)^{\alpha-1} (1+x/\sigma)^{-\alpha -\beta}}{\mathrm{B}(\alpha,\beta)\sigma}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = I_{\frac{x/\sigma}{1+x/\sigma}}(\alpha, \beta)
</code>
</p>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rbetapr(1e5, 5, 3, 2)
hist(x, 350, freq = FALSE, xlim = c(0, 100))
curve(dbetapr(x, 5, 3, 2), 0, 100, col = "red", add = TRUE, n = 500)
hist(pbetapr(x, 5, 3, 2))
plot(ecdf(x), xlim = c(0, 100))
curve(pbetapr(x, 5, 3, 2), 0, 100, col = "red", add = TRUE, n = 500)

</code></pre>

<hr>
<h2 id='Bhattacharjee'>Bhattacharjee distribution</h2><span id='topic+Bhattacharjee'></span><span id='topic+dbhatt'></span><span id='topic+pbhatt'></span><span id='topic+rbhatt'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation for the Bhattacharjee
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbhatt(x, mu = 0, sigma = 1, a = sigma, log = FALSE)

pbhatt(q, mu = 0, sigma = 1, a = sigma, lower.tail = TRUE, log.p = FALSE)

rbhatt(n, mu = 0, sigma = 1, a = sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bhattacharjee_+3A_x">x</code>, <code id="Bhattacharjee_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Bhattacharjee_+3A_mu">mu</code>, <code id="Bhattacharjee_+3A_sigma">sigma</code>, <code id="Bhattacharjee_+3A_a">a</code></td>
<td>
<p>location, scale and shape parameters.
Scale and shape must be positive.</p>
</td></tr>
<tr><td><code id="Bhattacharjee_+3A_log">log</code>, <code id="Bhattacharjee_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Bhattacharjee_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Bhattacharjee_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">Z \sim \mathrm{Normal}(0, 1)</code> and
<code class="reqn">U \sim \mathrm{Uniform}(0, 1)</code>, then
<code class="reqn">Z+U</code> follows Bhattacharjee distribution.
</p>
<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(z) = \frac{1}{2a} \left[\Phi\left(\frac{x-\mu+a}{\sigma}\right) - \Phi\left(\frac{x-\mu-a}{\sigma}\right)\right]
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(z) = \frac{\sigma}{2a} \left[(x-\mu)\Phi\left(\frac{x-\mu+a}{\sigma}\right) -
                               (x-\mu)\Phi\left(\frac{x-\mu-a}{\sigma}\right) +
                               \phi\left(\frac{x-\mu+a}{\sigma}\right) -
                               \phi\left(\frac{x-\mu-a}{\sigma}\right)\right]
</code>
</p>



<h3>References</h3>

<p>Bhattacharjee, G.P., Pandit, S.N.N., and Mohan, R. (1963).
Dimensional chains involving rectangular and normal error-distributions.
Technometrics, 5, 404-406.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rbhatt(1e5, 5, 3, 5)
hist(x, 100, freq = FALSE)
curve(dbhatt(x, 5, 3, 5), -20, 20, col = "red", add = TRUE)
hist(pbhatt(x, 5, 3, 5))
plot(ecdf(x))
curve(pbhatt(x, 5, 3, 5), -20, 20, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='BirnbaumSaunders'>Birnbaum-Saunders (fatigue life) distribution</h2><span id='topic+BirnbaumSaunders'></span><span id='topic+dfatigue'></span><span id='topic+pfatigue'></span><span id='topic+qfatigue'></span><span id='topic+rfatigue'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Birnbaum-Saunders (fatigue life) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfatigue(x, alpha, beta = 1, mu = 0, log = FALSE)

pfatigue(q, alpha, beta = 1, mu = 0, lower.tail = TRUE, log.p = FALSE)

qfatigue(p, alpha, beta = 1, mu = 0, lower.tail = TRUE, log.p = FALSE)

rfatigue(n, alpha, beta = 1, mu = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BirnbaumSaunders_+3A_x">x</code>, <code id="BirnbaumSaunders_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="BirnbaumSaunders_+3A_alpha">alpha</code>, <code id="BirnbaumSaunders_+3A_beta">beta</code>, <code id="BirnbaumSaunders_+3A_mu">mu</code></td>
<td>
<p>shape, scale and location parameters.
Scale and shape must be positive.</p>
</td></tr>
<tr><td><code id="BirnbaumSaunders_+3A_log">log</code>, <code id="BirnbaumSaunders_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BirnbaumSaunders_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="BirnbaumSaunders_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="BirnbaumSaunders_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \left (\frac{\sqrt{\frac{x-\mu} {\beta}} + \sqrt{\frac{\beta} 
{x-\mu}}} {2\alpha (x-\mu)} \right) 
\phi \left( \frac{1}{\alpha}\left( \sqrt{\frac{x-\mu}{\beta}} -
\sqrt{\frac{\beta}{x-\mu}} \right) \right)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \Phi \left(\frac{1}{\alpha}\left( \sqrt{\frac{x-\mu}{\beta}} -
\sqrt{\frac{\beta}{x-\mu}} \right) \right)
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \left[\frac{\alpha}{2} \Phi^{-1}(p) +
\sqrt{\left(\frac{\alpha}{2} \Phi^{-1}(p)\right)^{2} + 1}\right]^{2} \beta + \mu
</code>
</p>



<h3>References</h3>

<p>Birnbaum, Z. W. and Saunders, S. C. (1969).
A new family of life distributions.
Journal of Applied Probability, 6(2), 637-652.
</p>
<p>Desmond, A. (1985) Stochastic models of failure in random environments.
Canadian Journal of Statistics, 13, 171-183.
</p>
<p>Vilca-Labra, F., and Leiva-Sanchez, V. (2006).
A new fatigue life model based on the family of skew-elliptical distributions.
Communications in Statistics-Theory and Methods, 35(2), 229-244.
</p>
<p>Leiva, V., Sanhueza, A., Sen, P. K., and Paula, G. A. (2008).
Random number generators for the generalized Birnbaum-Saunders distribution.
Journal of Statistical Computation and Simulation, 78(11), 1105-1118.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rfatigue(1e5, .5, 2, 5)
hist(x, 100, freq = FALSE)
curve(dfatigue(x, .5, 2, 5), 2, 20, col = "red", add = TRUE)
hist(pfatigue(x, .5, 2, 5))
plot(ecdf(x))
curve(pfatigue(x, .5, 2, 5), 2, 20, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='BivNormal'>Bivariate normal distribution</h2><span id='topic+BivNormal'></span><span id='topic+dbvnorm'></span><span id='topic+rbvnorm'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation
for the bivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbvnorm(
  x,
  y = NULL,
  mean1 = 0,
  mean2 = mean1,
  sd1 = 1,
  sd2 = sd1,
  cor = 0,
  log = FALSE
)

rbvnorm(n, mean1 = 0, mean2 = mean1, sd1 = 1, sd2 = sd1, cor = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BivNormal_+3A_x">x</code>, <code id="BivNormal_+3A_y">y</code></td>
<td>
<p>vectors of quantiles; alternatively x may be a two-column
matrix (or data.frame) and y may be omitted.</p>
</td></tr>
<tr><td><code id="BivNormal_+3A_mean1">mean1</code>, <code id="BivNormal_+3A_mean2">mean2</code></td>
<td>
<p>vectors of means.</p>
</td></tr>
<tr><td><code id="BivNormal_+3A_sd1">sd1</code>, <code id="BivNormal_+3A_sd2">sd2</code></td>
<td>
<p>vectors of standard deviations.</p>
</td></tr>
<tr><td><code id="BivNormal_+3A_cor">cor</code></td>
<td>
<p>vector of correlations (<code>-1 &lt; cor &lt; 1</code>).</p>
</td></tr>
<tr><td><code id="BivNormal_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BivNormal_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{1}{2\pi\sqrt{1-\rho^2}\sigma_1\sigma_2}
       \exp\left\{-\frac{1}{2(1-\rho^2)} \left[\left(\frac{x_1 - \mu_1}{\sigma_1}\right)^2 -
       2\rho \left(\frac{x_1 - \mu_1}{\sigma_1}\right) \left(\frac{x_2 - \mu_2}{\sigma_2}\right) +
       \left(\frac{x_2 - \mu_2}{\sigma_2}\right)^2\right]\right\}
</code>
</p>



<h3>References</h3>

<p>Krishnamoorthy, K. (2006). Handbook of Statistical Distributions
with Applications. Chapman &amp; Hall/CRC
</p>
<p>Mukhopadhyay, N. (2000). Probability and statistical inference.
Chapman &amp; Hall/CRC
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">Normal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- x &lt;- seq(-4, 4, by = 0.25)
z &lt;- outer(x, y, function(x, y) dbvnorm(x, y, cor = -0.75))
persp(x, y, z)

y &lt;- x &lt;- seq(-4, 4, by = 0.25)
z &lt;- outer(x, y, function(x, y) dbvnorm(x, y, cor = -0.25))
persp(x, y, z)

</code></pre>

<hr>
<h2 id='BivPoiss'>Bivariate Poisson distribution</h2><span id='topic+BivPoiss'></span><span id='topic+dbvpois'></span><span id='topic+rbvpois'></span>

<h3>Description</h3>

<p>Probability mass function and random generation for the bivariate Poisson distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbvpois(x, y = NULL, a, b, c, log = FALSE)

rbvpois(n, a, b, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BivPoiss_+3A_x">x</code>, <code id="BivPoiss_+3A_y">y</code></td>
<td>
<p>vectors of quantiles; alternatively x may be a two-column
matrix (or data.frame) and y may be omitted.</p>
</td></tr>
<tr><td><code id="BivPoiss_+3A_a">a</code>, <code id="BivPoiss_+3A_b">b</code>, <code id="BivPoiss_+3A_c">c</code></td>
<td>
<p>positive valued parameters.</p>
</td></tr>
<tr><td><code id="BivPoiss_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="BivPoiss_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \exp \{-(a+b+c)\} \frac{a^x}{x!} \frac{b^y}{y!} \sum_{k=0}^{\min(x,y)}
{x \choose k} {y \choose k} k! \left( \frac{c}{ab} \right)^k
</code>
</p>



<h3>References</h3>

<p>Karlis, D. and Ntzoufras, I. (2003). Analysis of sports data by using bivariate Poisson models.
Journal of the Royal Statistical Society: Series D (The Statistician), 52(3), 381-393.
</p>
<p>Kocherlakota, S. and Kocherlakota, K. (1992) Bivariate Discrete Distributions.
New York: Dekker.
</p>
<p>Johnson, N., Kotz, S. and Balakrishnan, N. (1997). Discrete Multivariate Distributions.
New York: Wiley.
</p>
<p>Holgate, P. (1964). Estimation for the bivariate Poisson distribution.
Biometrika, 51(1-2), 241-287.
</p>
<p>Kawamura, K. (1984). Direct calculation of maximum likelihood estimator for the bivariate
Poisson distribution. Kodai mathematical journal, 7(2), 211-221.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Poisson">Poisson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rbvpois(5000, 7, 8, 5)
image(prop.table(table(x[,1], x[,2])))
colMeans(x)

</code></pre>

<hr>
<h2 id='Categorical'>Categorical distribution</h2><span id='topic+Categorical'></span><span id='topic+dcat'></span><span id='topic+pcat'></span><span id='topic+qcat'></span><span id='topic+rcat'></span><span id='topic+rcatlp'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function, quantile function and random generation
for the categorical distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcat(x, prob, log = FALSE)

pcat(q, prob, lower.tail = TRUE, log.p = FALSE)

qcat(p, prob, lower.tail = TRUE, log.p = FALSE, labels)

rcat(n, prob, labels)

rcatlp(n, log_prob, labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Categorical_+3A_x">x</code>, <code id="Categorical_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Categorical_+3A_prob">prob</code>, <code id="Categorical_+3A_log_prob">log_prob</code></td>
<td>
<p>vector of length <code class="reqn">m</code>, or <code class="reqn">m</code>-column matrix
of non-negative weights (or their logarithms in <code>log_prob</code>).</p>
</td></tr>
<tr><td><code id="Categorical_+3A_log">log</code>, <code id="Categorical_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Categorical_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Categorical_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Categorical_+3A_labels">labels</code></td>
<td>
<p>if provided, labeled <code>factor</code> vector is returned.
Number of labels needs to be the same as
number of categories (number of columns in prob).</p>
</td></tr>
<tr><td><code id="Categorical_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
\Pr(X = k) = \frac{w_k}{\sum_{j=1}^m w_j}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
\Pr(X \le k) = \frac{\sum_{i=1}^k w_i}{\sum_{j=1}^m w_j}
</code>
</p>

<p>It is possible to sample from categorical distribution parametrized
by vector of unnormalized log-probabilities
<code class="reqn">\alpha_1,\dots,\alpha_m</code>
without leaving the log space by employing the Gumbel-max trick (Maddison, Tarlow and Minka, 2014).
If <code class="reqn">g_1,\dots,g_m</code> are samples from Gumbel distribution with
cumulative distribution function <code class="reqn">F(g) = \exp(-\exp(-g))</code>,
then <code class="reqn">k = \mathrm{arg\,max}_i \{g_i + \alpha_i\}</code>
is a draw from categorical distribution parametrized by
vector of probabilities <code class="reqn">p_1,\dots,p_m</code>, such that
<code class="reqn">p_i = \exp(\alpha_i) / [\sum_{j=1}^m \exp(\alpha_j)]</code>.
This is implemented in <code>rcatlp</code> function parametrized by vector of
log-probabilities <code>log_prob</code>.
</p>


<h3>References</h3>

<p>Maddison, C. J., Tarlow, D., &amp; Minka, T. (2014). A* sampling.
[In:] Advances in Neural Information Processing Systems (pp. 3086-3094).
<a href="https://arxiv.org/abs/1411.0030">https://arxiv.org/abs/1411.0030</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating 10 random draws from categorical distribution
# with k=3 categories occuring with equal probabilities
# parametrized using a vector

rcat(10, c(1/3, 1/3, 1/3))

# or with k=5 categories parametrized using a matrix of probabilities
# (generated from Dirichlet distribution)

p &lt;- rdirichlet(10, c(1, 1, 1, 1, 1))
rcat(10, p)

x &lt;- rcat(1e5, c(0.2, 0.4, 0.3, 0.1))
plot(prop.table(table(x)), type = "h")
lines(0:5, dcat(0:5, c(0.2, 0.4, 0.3, 0.1)), col = "red")

p &lt;- rdirichlet(1, rep(1, 20))
x &lt;- rcat(1e5, matrix(rep(p, 2), nrow = 2, byrow = TRUE))
xx &lt;- 0:21
plot(prop.table(table(x)))
lines(xx, dcat(xx, p), col = "red")

xx &lt;- seq(0, 21, by = 0.01)
plot(ecdf(x))
lines(xx, pcat(xx, p), col = "red", lwd = 2)

pp &lt;- seq(0, 1, by = 0.001)
plot(ecdf(x))
lines(qcat(pp, p), pp, col = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='Dirichlet'>Dirichlet distribution</h2><span id='topic+Dirichlet'></span><span id='topic+ddirichlet'></span><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Density function, cumulative distribution function and random generation
for the Dirichlet distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirichlet(x, alpha, log = FALSE)

rdirichlet(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dirichlet_+3A_x">x</code></td>
<td>
<p><code class="reqn">k</code>-column matrix of quantiles.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">k</code>-values vector or <code class="reqn">k</code>-column matrix;
concentration parameter. Must be positive.</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Dirichlet_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\Gamma(\sum_k \alpha_k)}{\prod_k \Gamma(\alpha_k)} \prod_k x_k^{k-1}
</code>
</p>



<h3>References</h3>

<p>Devroye, L. (1986). Non-Uniform Random Variate Generation. Springer-Verlag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating 10 random draws from Dirichlet distribution
# parametrized using a vector

rdirichlet(10, c(1, 1, 1, 1))

# or parametrized using a matrix where each row
# is a vector of parameters

alpha &lt;- matrix(c(1, 1, 1, 1:3, 7:9), ncol = 3, byrow = TRUE)
rdirichlet(10, alpha)

</code></pre>

<hr>
<h2 id='DirMnom'>Dirichlet-multinomial (multivariate Polya) distribution</h2><span id='topic+DirMnom'></span><span id='topic+ddirmnom'></span><span id='topic+rdirmnom'></span>

<h3>Description</h3>

<p>Density function, cumulative distribution function and random generation
for the Dirichlet-multinomial (multivariate Polya) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddirmnom(x, size, alpha, log = FALSE)

rdirmnom(n, size, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DirMnom_+3A_x">x</code></td>
<td>
<p><code class="reqn">k</code>-column matrix of quantiles.</p>
</td></tr>
<tr><td><code id="DirMnom_+3A_size">size</code></td>
<td>
<p>numeric vector; number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="DirMnom_+3A_alpha">alpha</code></td>
<td>
<p><code class="reqn">k</code>-values vector or <code class="reqn">k</code>-column matrix;
concentration parameter. Must be positive.</p>
</td></tr>
<tr><td><code id="DirMnom_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="DirMnom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">(p_1,\dots,p_k) \sim \mathrm{Dirichlet}(\alpha_1,\dots,\alpha_k)</code> and
<code class="reqn">(x_1,\dots,x_k) \sim \mathrm{Multinomial}(n, p_1,\dots,p_k)</code>, then 
<code class="reqn">(x_1,\dots,x_k) \sim \mathrm{DirichletMultinomial(n, \alpha_1,\dots,\alpha_k)}</code>.
</p>
<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\left(n!\right)\Gamma\left(\sum \alpha_k\right)}{\Gamma\left(n+\sum \alpha_k\right)}\prod_{k=1}^K\frac{\Gamma(x_{k}+\alpha_{k})}{\left(x_{k}!\right)\Gamma(\alpha_{k})}
</code>
</p>



<h3>References</h3>

<p>Gentle, J.E. (2006). Random number generation and Monte Carlo methods. Springer.
</p>
<p>Kvam, P. and Day, D. (2001) The multivariate Polya distribution in combat modeling.
Naval Research Logistics, 48, 1-17.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Dirichlet">Dirichlet</a></code>, <code><a href="#topic+Multinomial">Multinomial</a></code>
</p>

<hr>
<h2 id='DiscreteGamma'>Discrete gamma distribution</h2><span id='topic+DiscreteGamma'></span><span id='topic+ddgamma'></span><span id='topic+pdgamma'></span><span id='topic+rdgamma'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function and random generation
for discrete gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE)

pdgamma(q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)

rdgamma(n, shape, rate = 1, scale = 1/rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscreteGamma_+3A_x">x</code>, <code id="DiscreteGamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="DiscreteGamma_+3A_shape">shape</code>, <code id="DiscreteGamma_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters. Must be positive, scale strictly.</p>
</td></tr>
<tr><td><code id="DiscreteGamma_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="DiscreteGamma_+3A_log">log</code>, <code id="DiscreteGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="DiscreteGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="DiscreteGamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability mass function of discrete gamma distribution <code class="reqn">f_Y(y)</code>
is defined by discretization of continuous gamma distribution
<code class="reqn">f_Y(y) = S_X(y) - S_X(y+1)</code>
where <code class="reqn">S_X</code> is a survival function of continuous gamma distribution.
</p>


<h3>References</h3>

<p>Chakraborty, S. and Chakravarty, D. (2012).
Discrete Gamma distributions: Properties and parameter estimations.
Communications in Statistics-Theory and Methods, 41(18), 3301-3324.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+GammaDist">GammaDist</a></code>, <code><a href="#topic+DiscreteNormal">DiscreteNormal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rdgamma(1e5, 9, 1)
xx &lt;- 0:50
plot(prop.table(table(x)))
lines(xx, ddgamma(xx, 9, 1), col = "red")
hist(pdgamma(x, 9, 1))
plot(ecdf(x))
xx &lt;- seq(0, 50, 0.1)
lines(xx, pdgamma(xx, 9, 1), col = "red", lwd = 2, type = "s")

</code></pre>

<hr>
<h2 id='DiscreteLaplace'>Discrete Laplace distribution</h2><span id='topic+DiscreteLaplace'></span><span id='topic+ddlaplace'></span><span id='topic+pdlaplace'></span><span id='topic+rdlaplace'></span>

<h3>Description</h3>

<p>Probability mass, distribution function and random generation
for the discrete Laplace distribution parametrized by location and scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddlaplace(x, location, scale, log = FALSE)

pdlaplace(q, location, scale, lower.tail = TRUE, log.p = FALSE)

rdlaplace(n, location, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscreteLaplace_+3A_x">x</code>, <code id="DiscreteLaplace_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="DiscreteLaplace_+3A_location">location</code></td>
<td>
<p>location parameter.</p>
</td></tr>
<tr><td><code id="DiscreteLaplace_+3A_scale">scale</code></td>
<td>
<p>scale parameter; <code>0 &lt; scale &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="DiscreteLaplace_+3A_log">log</code>, <code id="DiscreteLaplace_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="DiscreteLaplace_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="DiscreteLaplace_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">U \sim \mathrm{Geometric}(1-p)</code> and
<code class="reqn">V \sim \mathrm{Geometric}(1-p)</code>,
then <code class="reqn">U-V \sim \mathrm{DiscreteLaplace}(p)</code>,
where geometric distribution is related to discrete Laplace distribution
in similar way as exponential distribution is related to Laplace distribution.
</p>
<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{1-p}{1+p} p^{|x-\mu|}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \left\{\begin{array}{ll}
\frac{p^{-|x-\mu|}}{1+p} &amp; x &lt; 0 \\
1 - \frac{p^{|x-\mu|+1}}{1+p} &amp; x \ge 0
\end{array}\right.
</code>
</p>



<h3>References</h3>

<p>Inusah, S., &amp; Kozubowski, T.J. (2006). A discrete analogue of the Laplace distribution.
Journal of statistical planning and inference, 136(3), 1090-1102.
</p>
<p>Kotz, S., Kozubowski, T., &amp; Podgorski, K. (2012).
The Laplace distribution and generalizations: a revisit with applications
to communications, economics, engineering, and finance.
Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- 0.45
x &lt;- rdlaplace(1e5, 0, p)
xx &lt;- seq(-200, 200, by = 1)
plot(prop.table(table(x)))
lines(xx, ddlaplace(xx, 0, p), col = "red")
hist(pdlaplace(x, 0, p))
plot(ecdf(x))
lines(xx, pdlaplace(xx, 0, p), col = "red", type = "s")

</code></pre>

<hr>
<h2 id='DiscreteNormal'>Discrete normal distribution</h2><span id='topic+DiscreteNormal'></span><span id='topic+ddnorm'></span><span id='topic+pdnorm'></span><span id='topic+rdnorm'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function and random generation
for discrete normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddnorm(x, mean = 0, sd = 1, log = FALSE)

pdnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)

rdnorm(n, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscreteNormal_+3A_x">x</code>, <code id="DiscreteNormal_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="DiscreteNormal_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="DiscreteNormal_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="DiscreteNormal_+3A_log">log</code>, <code id="DiscreteNormal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="DiscreteNormal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="DiscreteNormal_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \Phi\left(\frac{x-\mu+1}{\sigma}\right) - \Phi\left(\frac{x-\mu}{\sigma}\right)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \Phi\left(\frac{\lfloor x \rfloor + 1 - \mu}{\sigma}\right)
</code>
</p>



<h3>References</h3>

<p>Roy, D. (2003). The discrete normal distribution.
Communications in Statistics-Theory and Methods, 32, 1871-1883.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">Normal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rdnorm(1e5, 0, 3)
xx &lt;- -15:15
plot(prop.table(table(x)))
lines(xx, ddnorm(xx, 0, 3), col = "red")
hist(pdnorm(x, 0, 3))
plot(ecdf(x))
xx &lt;- seq(-15, 15, 0.1)
lines(xx, pdnorm(xx, 0, 3), col = "red", lwd = 2, type = "s")

</code></pre>

<hr>
<h2 id='DiscreteUniform'>Discrete uniform distribution</h2><span id='topic+DiscreteUniform'></span><span id='topic+ddunif'></span><span id='topic+pdunif'></span><span id='topic+qdunif'></span><span id='topic+rdunif'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function, quantile function and random generation
for the discrete uniform distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddunif(x, min, max, log = FALSE)

pdunif(q, min, max, lower.tail = TRUE, log.p = FALSE)

qdunif(p, min, max, lower.tail = TRUE, log.p = FALSE)

rdunif(n, min, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscreteUniform_+3A_x">x</code>, <code id="DiscreteUniform_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="DiscreteUniform_+3A_min">min</code>, <code id="DiscreteUniform_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution. Must be finite.</p>
</td></tr>
<tr><td><code id="DiscreteUniform_+3A_log">log</code>, <code id="DiscreteUniform_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="DiscreteUniform_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="DiscreteUniform_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="DiscreteUniform_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>min == max</code>, then discrete uniform distribution is a degenerate distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rdunif(1e5, 1, 10) 
xx &lt;- -1:11
plot(prop.table(table(x)), type = "h")
lines(xx, ddunif(xx, 1, 10), col = "red")
hist(pdunif(x, 1, 10))
xx &lt;- seq(-1, 11, by = 0.01)
plot(ecdf(x))
lines(xx, pdunif(xx, 1, 10), col = "red")

</code></pre>

<hr>
<h2 id='DiscreteWeibull'>Discrete Weibull distribution (type I)</h2><span id='topic+DiscreteWeibull'></span><span id='topic+ddweibull'></span><span id='topic+pdweibull'></span><span id='topic+qdweibull'></span><span id='topic+rdweibull'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the discrete Weibull (type I) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddweibull(x, shape1, shape2, log = FALSE)

pdweibull(q, shape1, shape2, lower.tail = TRUE, log.p = FALSE)

qdweibull(p, shape1, shape2, lower.tail = TRUE, log.p = FALSE)

rdweibull(n, shape1, shape2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DiscreteWeibull_+3A_x">x</code>, <code id="DiscreteWeibull_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="DiscreteWeibull_+3A_shape1">shape1</code>, <code id="DiscreteWeibull_+3A_shape2">shape2</code></td>
<td>
<p>parameters (named q, <code class="reqn">\beta</code>). Values of <code>shape2</code>
need to be positive and <code>0 &lt; shape1 &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="DiscreteWeibull_+3A_log">log</code>, <code id="DiscreteWeibull_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="DiscreteWeibull_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="DiscreteWeibull_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="DiscreteWeibull_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = q^{x^\beta} - q^{(x+1)^\beta}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = 1-q^{(x+1)^\beta}
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \left \lceil{\left(\frac{\log(1-p)}{\log(q)}\right)^{1/\beta} - 1}\right \rceil
</code>
</p>



<h3>References</h3>

<p>Nakagawa, T. and Osaki, S. (1975). The Discrete Weibull Distribution.
IEEE Transactions on Reliability, R-24, 300-301.
</p>
<p>Kulasekera, K.B. (1994).
Approximate MLE's of the parameters of a discrete Weibull distribution
with type I censored data.
Microelectronics Reliability, 34(7), 1185-1188.
</p>
<p>Khan, M.A., Khalique, A. and Abouammoh, A.M. (1989).
On estimating parameters in a discrete Weibull distribution.
IEEE Transactions on Reliability, 38(3), 348-350.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Weibull">Weibull</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rdweibull(1e5, 0.32, 1)
xx &lt;- seq(-2, 100, by = 1)
plot(prop.table(table(x)), type = "h")
lines(xx, ddweibull(xx, .32, 1), col = "red")

# Notice: distribution of F(X) is far from uniform:
hist(pdweibull(x, .32, 1), 50)

plot(ecdf(x))
lines(xx, pdweibull(xx, .32, 1), col = "red", lwd = 2, type = "s")

</code></pre>

<hr>
<h2 id='Frechet'>Frechet distribution</h2><span id='topic+Frechet'></span><span id='topic+dfrechet'></span><span id='topic+pfrechet'></span><span id='topic+qfrechet'></span><span id='topic+rfrechet'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Frechet distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfrechet(x, lambda = 1, mu = 0, sigma = 1, log = FALSE)

pfrechet(q, lambda = 1, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qfrechet(p, lambda = 1, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rfrechet(n, lambda = 1, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Frechet_+3A_x">x</code>, <code id="Frechet_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_lambda">lambda</code>, <code id="Frechet_+3A_sigma">sigma</code>, <code id="Frechet_+3A_mu">mu</code></td>
<td>
<p>shape, scale, and location parameters.
Scale and shape must be positive.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_log">log</code>, <code id="Frechet_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Frechet_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\lambda}{\sigma} \left(\frac{x-\mu}{\sigma}\right)^{-1-\lambda} \exp\left(-\left(\frac{x-\mu}{\sigma}\right)^{-\lambda}\right)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \exp\left(-\left(\frac{x-\mu}{\sigma}\right)^{-\lambda}\right)
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \mu + \sigma -\log(p)^{-1/\lambda}
</code>
</p>



<h3>References</h3>

<p>Bury, K. (1999). Statistical Distributions in Engineering.
Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rfrechet(1e5, 5, 2, 1.5)
xx &lt;- seq(0, 1000, by = 0.1)
hist(x, 200, freq = FALSE)
lines(xx, dfrechet(xx, 5, 2, 1.5), col = "red") 
hist(pfrechet(x, 5, 2, 1.5))
plot(ecdf(x))
lines(xx, pfrechet(xx, 5, 2, 1.5), col = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='GammaPoiss'>Gamma-Poisson distribution</h2><span id='topic+GammaPoiss'></span><span id='topic+dgpois'></span><span id='topic+pgpois'></span><span id='topic+rgpois'></span>

<h3>Description</h3>

<p>Probability mass function and random generation
for the gamma-Poisson distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgpois(x, shape, rate, scale = 1/rate, log = FALSE)

pgpois(q, shape, rate, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)

rgpois(n, shape, rate, scale = 1/rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GammaPoiss_+3A_x">x</code>, <code id="GammaPoiss_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GammaPoiss_+3A_shape">shape</code>, <code id="GammaPoiss_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters. Must be positive,
scale strictly.</p>
</td></tr>
<tr><td><code id="GammaPoiss_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="GammaPoiss_+3A_log">log</code>, <code id="GammaPoiss_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="GammaPoiss_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="GammaPoiss_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gamma-Poisson distribution arises as a continuous mixture of
Poisson distributions, where the mixing distribution
of the Poisson rate <code class="reqn">\lambda</code> is a gamma distribution.
When <code class="reqn">X \sim \mathrm{Poisson}(\lambda)</code>
and <code class="reqn">\lambda \sim \mathrm{Gamma}(\alpha, \beta)</code>, then <code class="reqn">X \sim \mathrm{GammaPoisson}(\alpha, \beta)</code>.
</p>
<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\Gamma(\alpha+x)}{x! \, \Gamma(\alpha)} \left(\frac{\beta}{1+\beta}\right)^x \left(1-\frac{\beta}{1+\beta}\right)^\alpha
</code>
</p>

<p>Cumulative distribution function is calculated using recursive algorithm that employs the fact that
<code class="reqn">\Gamma(x) = (x - 1)!</code>. This enables re-writing probability mass function as
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{(\alpha+x-1)!}{x! \, \Gamma(\alpha)} \left( \frac{\beta}{1+\beta} \right)^x \left( 1- \frac{\beta}{1+\beta} \right)^\alpha
</code>
</p>

<p>what makes recursive updating from <code class="reqn">x</code> to <code class="reqn">x+1</code> easy using the properties of factorials
</p>
<p style="text-align: center;"><code class="reqn">
f(x+1) = \frac{(\alpha+x-1)! \, (\alpha+x)}{x! \,(x+1) \, \Gamma(\alpha)} \left( \frac{\beta}{1+\beta} \right)^x \left( \frac{\beta}{1+\beta} \right) \left( 1- \frac{\beta}{1+\beta} \right)^\alpha
</code>
</p>

<p>and let's us efficiently calculate cumulative distribution function as a sum of probability mass functions
</p>
<p style="text-align: center;"><code class="reqn">F(x) = \sum_{k=0}^x f(k)</code>
</p>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+Gamma">Gamma</a></code>, <code><a href="stats.html#topic+Poisson">Poisson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rgpois(1e5, 7, 0.002)
xx &lt;- seq(0, 12000, by = 1)
hist(x, 100, freq = FALSE)
lines(xx, dgpois(xx, 7, 0.002), col = "red")
hist(pgpois(x, 7, 0.002))
xx &lt;- seq(0, 12000, by = 0.1)
plot(ecdf(x))
lines(xx, pgpois(xx, 7, 0.002), col = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='GEV'>Generalized extreme value distribution</h2><span id='topic+GEV'></span><span id='topic+dgev'></span><span id='topic+pgev'></span><span id='topic+qgev'></span><span id='topic+rgev'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the generalized extreme value distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgev(x, mu = 0, sigma = 1, xi = 0, log = FALSE)

pgev(q, mu = 0, sigma = 1, xi = 0, lower.tail = TRUE, log.p = FALSE)

qgev(p, mu = 0, sigma = 1, xi = 0, lower.tail = TRUE, log.p = FALSE)

rgev(n, mu = 0, sigma = 1, xi = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEV_+3A_x">x</code>, <code id="GEV_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GEV_+3A_mu">mu</code>, <code id="GEV_+3A_sigma">sigma</code>, <code id="GEV_+3A_xi">xi</code></td>
<td>
<p>location, scale, and shape parameters. Scale must be positive.</p>
</td></tr>
<tr><td><code id="GEV_+3A_log">log</code>, <code id="GEV_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="GEV_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="GEV_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="GEV_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = \left\{\begin{array}{ll}
\frac{1}{\sigma} \left(1+\xi \frac{x-\mu}{\sigma}\right)^{-1/\xi-1} \exp\left(-\left(1+\xi \frac{x-\mu}{\sigma}\right)^{-1/\xi}\right) &amp; \xi \neq 0 \\
\frac{1}{\sigma} \exp\left(- \frac{x-\mu}{\sigma}\right) \exp\left(-\exp\left(- \frac{x-\mu}{\sigma}\right)\right)                       &amp; \xi = 0
\end{array}\right.
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn"> F(x) = \left\{\begin{array}{ll}
\exp\left(-\left(1+\xi \frac{x-\mu}{\sigma}\right)^{1/\xi}\right) &amp; \xi \neq 0 \\
\exp\left(-\exp\left(- \frac{x-\mu}{\sigma}\right)\right)          &amp; \xi = 0
\end{array}\right.
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn"> F^{-1}(p) = \left\{\begin{array}{ll}
\mu - \frac{\sigma}{\xi} (1 - (-\log(p))^\xi)  &amp; \xi \neq 0 \\
\mu - \sigma \log(-\log(p))                    &amp; \xi = 0
\end{array}\right.
</code>
</p>



<h3>References</h3>

<p>Coles, S. (2001). An Introduction to Statistical Modeling of Extreme Values.
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
curve(dgev(x, xi = -1/2), -4, 4, col = "green", ylab = "")
curve(dgev(x, xi = 0), -4, 4, col = "red", add = TRUE)
curve(dgev(x, xi = 1/2), -4, 4, col = "blue", add = TRUE)
legend("topleft", col = c("green", "red", "blue"), lty = 1,
       legend = expression(xi == -1/2, xi == 0, xi == 1/2), bty = "n")

x &lt;- rgev(1e5, 5, 2, .5)
hist(x, 1000, freq = FALSE, xlim = c(0, 50))
curve(dgev(x, 5, 2, .5), 0, 50, col = "red", add = TRUE, n = 5000)
hist(pgev(x, 5, 2, .5))
plot(ecdf(x), xlim = c(0, 50))
curve(pgev(x, 5, 2, .5), 0, 50, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='Gompertz'>Gompertz distribution</h2><span id='topic+Gompertz'></span><span id='topic+dgompertz'></span><span id='topic+pgompertz'></span><span id='topic+qgompertz'></span><span id='topic+rgompertz'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Gompertz distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgompertz(x, a = 1, b = 1, log = FALSE)

pgompertz(q, a = 1, b = 1, lower.tail = TRUE, log.p = FALSE)

qgompertz(p, a = 1, b = 1, lower.tail = TRUE, log.p = FALSE)

rgompertz(n, a = 1, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gompertz_+3A_x">x</code>, <code id="Gompertz_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_a">a</code>, <code id="Gompertz_+3A_b">b</code></td>
<td>
<p>positive valued scale and location parameters.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_log">log</code>, <code id="Gompertz_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Gompertz_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = a \exp\left(bx - \frac{a}{b} (\exp(bx)-1)\right)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = 1-\exp\left(-\frac{a}{b} (\exp(bx)-1)\right)
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \frac{1}{b} \log\left(1-\frac{b}{a}\log(1-p)\right)
</code>
</p>



<h3>References</h3>

<p>Lenart, A. (2012). The Gompertz distribution and Maximum Likelihood Estimation
of its parameters - a revision. MPIDR WORKING PAPER WP 2012-008.
<a href="https://www.demogr.mpg.de/papers/working/wp-2012-008.pdf">https://www.demogr.mpg.de/papers/working/wp-2012-008.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rgompertz(1e5, 5, 2)
hist(x, 100, freq = FALSE)
curve(dgompertz(x, 5, 2), 0, 1, col = "red", add = TRUE)
hist(pgompertz(x, 5, 2))
plot(ecdf(x))
curve(pgompertz(x, 5, 2), 0, 1, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='GPD'>Generalized Pareto distribution</h2><span id='topic+GPD'></span><span id='topic+dgpd'></span><span id='topic+pgpd'></span><span id='topic+qgpd'></span><span id='topic+rgpd'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the generalized Pareto distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgpd(x, mu = 0, sigma = 1, xi = 0, log = FALSE)

pgpd(q, mu = 0, sigma = 1, xi = 0, lower.tail = TRUE, log.p = FALSE)

qgpd(p, mu = 0, sigma = 1, xi = 0, lower.tail = TRUE, log.p = FALSE)

rgpd(n, mu = 0, sigma = 1, xi = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPD_+3A_x">x</code>, <code id="GPD_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="GPD_+3A_mu">mu</code>, <code id="GPD_+3A_sigma">sigma</code>, <code id="GPD_+3A_xi">xi</code></td>
<td>
<p>location, scale, and shape parameters. Scale must be positive.</p>
</td></tr>
<tr><td><code id="GPD_+3A_log">log</code>, <code id="GPD_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="GPD_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="GPD_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="GPD_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn"> f(x) = \left\{\begin{array}{ll}
\frac{1}{\sigma} \left(1+\xi \frac{x-\mu}{\sigma}\right)^{-(\xi+1)/\xi} &amp; \xi \neq 0 \\
\frac{1}{\sigma} \exp\left(-\frac{x-\mu}{\sigma}\right)                 &amp; \xi = 0
\end{array}\right.
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn"> F(x) = \left\{\begin{array}{ll}
1-\left(1+\xi \frac{x-\mu}{\sigma}\right)^{-1/\xi} &amp; \xi \neq 0 \\
1-\exp\left(-\frac{x-\mu}{\sigma}\right)           &amp; \xi = 0
\end{array}\right.
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn"> F^{-1}(x) = \left\{\begin{array}{ll}
\mu + \sigma \frac{(1-p)^{-\xi}-1}{\xi} &amp; \xi \neq 0 \\
\mu - \sigma \log(1-p)                  &amp; \xi = 0
\end{array}\right.
</code>
</p>



<h3>References</h3>

<p>Coles, S. (2001). An Introduction to Statistical Modeling of Extreme Values.
Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rgpd(1e5, 5, 2, .1)
hist(x, 100, freq = FALSE, xlim = c(0, 50))
curve(dgpd(x, 5, 2, .1), 0, 50, col = "red", add = TRUE, n = 5000)
hist(pgpd(x, 5, 2, .1))
plot(ecdf(x))
curve(pgpd(x, 5, 2, .1), 0, 50, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='Gumbel'>Gumbel distribution</h2><span id='topic+Gumbel'></span><span id='topic+dgumbel'></span><span id='topic+pgumbel'></span><span id='topic+qgumbel'></span><span id='topic+rgumbel'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Gumbel distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgumbel(x, mu = 0, sigma = 1, log = FALSE)

pgumbel(q, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qgumbel(p, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rgumbel(n, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gumbel_+3A_x">x</code>, <code id="Gumbel_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_mu">mu</code>, <code id="Gumbel_+3A_sigma">sigma</code></td>
<td>
<p>location and scale parameters. Scale must be positive.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_log">log</code>, <code id="Gumbel_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{1}{\sigma} \exp\left(-\left(\frac{x-\mu}{\sigma} + \exp\left(-\frac{x-\mu}{\sigma}\right)\right)\right)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \exp\left(-\exp\left(-\frac{x-\mu}{\sigma}\right)\right)
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \mu - \sigma \log(-\log(p))
</code>
</p>



<h3>References</h3>

<p>Bury, K. (1999). Statistical Distributions in Engineering.
Cambridge University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rgumbel(1e5, 5, 2)
hist(x, 100, freq = FALSE)
curve(dgumbel(x, 5, 2), 0, 25, col = "red", add = TRUE)
hist(pgumbel(x, 5, 2))
plot(ecdf(x))
curve(pgumbel(x, 5, 2), 0, 25, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='HalfCauchy'>Half-Cauchy distribution</h2><span id='topic+HalfCauchy'></span><span id='topic+dhcauchy'></span><span id='topic+phcauchy'></span><span id='topic+qhcauchy'></span><span id='topic+rhcauchy'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the half-Cauchy distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhcauchy(x, sigma = 1, log = FALSE)

phcauchy(q, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qhcauchy(p, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rhcauchy(n, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HalfCauchy_+3A_x">x</code>, <code id="HalfCauchy_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="HalfCauchy_+3A_sigma">sigma</code></td>
<td>
<p>positive valued scale parameter.</p>
</td></tr>
<tr><td><code id="HalfCauchy_+3A_log">log</code>, <code id="HalfCauchy_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="HalfCauchy_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="HalfCauchy_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="HalfCauchy_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">X</code> follows Cauchy centered at 0 and parametrized by scale <code class="reqn">\sigma</code>,
then <code class="reqn">|X|</code> follows half-Cauchy distribution parametrized by
scale <code class="reqn">\sigma</code>. Half-Cauchy distribution is a special case of half-t
distribution with <code class="reqn">\nu=1</code> degrees of freedom.
</p>


<h3>References</h3>

<p>Gelman, A. (2006). Prior distributions for variance parameters in hierarchical
models (comment on article by Browne and Draper).
Bayesian analysis, 1(3), 515-534.
</p>
<p>Jacob, E. and Jayakumar, K. (2012).
On Half-Cauchy Distribution and Process.
International Journal of Statistika and Mathematika, 3(2), 77-81.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HalfT">HalfT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rhcauchy(1e5, 2)
hist(x, 2e5, freq = FALSE, xlim = c(0, 100))
curve(dhcauchy(x, 2), 0, 100, col = "red", add = TRUE)
hist(phcauchy(x, 2))
plot(ecdf(x), xlim = c(0, 100))
curve(phcauchy(x, 2), col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='HalfNormal'>Half-normal distribution</h2><span id='topic+HalfNormal'></span><span id='topic+dhnorm'></span><span id='topic+phnorm'></span><span id='topic+qhnorm'></span><span id='topic+rhnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the half-normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhnorm(x, sigma = 1, log = FALSE)

phnorm(q, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qhnorm(p, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rhnorm(n, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HalfNormal_+3A_x">x</code>, <code id="HalfNormal_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="HalfNormal_+3A_sigma">sigma</code></td>
<td>
<p>positive valued scale parameter.</p>
</td></tr>
<tr><td><code id="HalfNormal_+3A_log">log</code>, <code id="HalfNormal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="HalfNormal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="HalfNormal_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="HalfNormal_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">X</code> follows normal distribution centered at 0 and parametrized
by scale <code class="reqn">\sigma</code>, then <code class="reqn">|X|</code> follows half-normal distribution
parametrized by scale <code class="reqn">\sigma</code>. Half-t distribution with <code class="reqn">\nu=\infty</code>
degrees of freedom converges to half-normal distribution.
</p>


<h3>References</h3>

<p>Gelman, A. (2006). Prior distributions for variance parameters in hierarchical
models (comment on article by Browne and Draper).
Bayesian analysis, 1(3), 515-534.
</p>
<p>Jacob, E. and Jayakumar, K. (2012).
On Half-Cauchy Distribution and Process.
International Journal of Statistika and Mathematika, 3(2), 77-81.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HalfT">HalfT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rhnorm(1e5, 2)
hist(x, 100, freq = FALSE)
curve(dhnorm(x, 2), 0, 8, col = "red", add = TRUE)
hist(phnorm(x, 2))
plot(ecdf(x))
curve(phnorm(x, 2), 0, 8, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='HalfT'>Half-t distribution</h2><span id='topic+HalfT'></span><span id='topic+dht'></span><span id='topic+pht'></span><span id='topic+qht'></span><span id='topic+rht'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the half-t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dht(x, nu, sigma = 1, log = FALSE)

pht(q, nu, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qht(p, nu, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rht(n, nu, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HalfT_+3A_x">x</code>, <code id="HalfT_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="HalfT_+3A_nu">nu</code>, <code id="HalfT_+3A_sigma">sigma</code></td>
<td>
<p>positive valued degrees of freedom and scale parameters.</p>
</td></tr>
<tr><td><code id="HalfT_+3A_log">log</code>, <code id="HalfT_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="HalfT_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="HalfT_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="HalfT_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">X</code> follows t distribution parametrized by degrees of freedom <code class="reqn">\nu</code>
and scale <code class="reqn">\sigma</code>, then <code class="reqn">|X|</code> follows half-t distribution parametrized
by degrees of freedom <code class="reqn">\nu</code> and scale <code class="reqn">\sigma</code>.
</p>


<h3>References</h3>

<p>Gelman, A. (2006). Prior distributions for variance parameters in hierarchical
models (comment on article by Browne and Draper).
Bayesian analysis, 1(3), 515-534.
</p>
<p>Jacob, E. and Jayakumar, K. (2012).
On Half-Cauchy Distribution and Process.
International Journal of Statistika and Mathematika, 3(2), 77-81.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HalfNormal">HalfNormal</a></code>, <code><a href="#topic+HalfCauchy">HalfCauchy</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rht(1e5, 2, 2)
hist(x, 500, freq = FALSE, xlim = c(0, 100))
curve(dht(x, 2, 2), 0, 100, col = "red", add = TRUE)
hist(pht(x, 2, 2))
plot(ecdf(x), xlim = c(0, 100))
curve(pht(x, 2, 2), 0, 100, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='Huber'>&quot;Huber density&quot; distribution</h2><span id='topic+Huber'></span><span id='topic+dhuber'></span><span id='topic+phuber'></span><span id='topic+qhuber'></span><span id='topic+rhuber'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the &quot;Huber density&quot; distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dhuber(x, mu = 0, sigma = 1, epsilon = 1.345, log = FALSE)

phuber(q, mu = 0, sigma = 1, epsilon = 1.345, lower.tail = TRUE, log.p = FALSE)

qhuber(p, mu = 0, sigma = 1, epsilon = 1.345, lower.tail = TRUE, log.p = FALSE)

rhuber(n, mu = 0, sigma = 1, epsilon = 1.345)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Huber_+3A_x">x</code>, <code id="Huber_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Huber_+3A_mu">mu</code>, <code id="Huber_+3A_sigma">sigma</code>, <code id="Huber_+3A_epsilon">epsilon</code></td>
<td>
<p>location, and scale, and shape parameters.
Scale and shape must be positive.</p>
</td></tr>
<tr><td><code id="Huber_+3A_log">log</code>, <code id="Huber_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Huber_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Huber_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Huber_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Huber density is connected to Huber loss and can be defined as:
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{1}{2 \sqrt{2\pi} \left( \Phi(k) + \phi(k)/k - \frac{1}{2} \right)} e^{-\rho_k(x)}
</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">
\rho_k(x) =
\left\{\begin{array}{ll}
\frac{1}{2} x^2       &amp; |x|\le k \\
k|x|- \frac{1}{2} k^2 &amp; |x|&gt;k
\end{array}\right.
</code>
</p>



<h3>References</h3>

<p>Huber, P.J. (1964). Robust Estimation of a Location Parameter.
Annals of Statistics, 53(1), 73-101.
</p>
<p>Huber, P.J. (1981). Robust Statistics. Wiley.
</p>
<p>Schumann, D. (2009). Robust Variable Selection. ProQuest.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rhuber(1e5, 5, 2, 3)
hist(x, 100, freq = FALSE)
curve(dhuber(x, 5, 2, 3), -20, 20, col = "red", add = TRUE, n = 5000)
hist(phuber(x, 5, 2, 3))
plot(ecdf(x))
curve(phuber(x, 5, 2, 3), -20, 20, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='InvChiSq'>Inverse chi-squared and scaled chi-squared distributions</h2><span id='topic+InvChiSq'></span><span id='topic+dinvchisq'></span><span id='topic+pinvchisq'></span><span id='topic+qinvchisq'></span><span id='topic+rinvchisq'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation
for the inverse chi-squared distribution and scaled chi-squared distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvchisq(x, nu, tau, log = FALSE)

pinvchisq(q, nu, tau, lower.tail = TRUE, log.p = FALSE)

qinvchisq(p, nu, tau, lower.tail = TRUE, log.p = FALSE)

rinvchisq(n, nu, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvChiSq_+3A_x">x</code>, <code id="InvChiSq_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InvChiSq_+3A_nu">nu</code></td>
<td>
<p>positive valued shape parameter.</p>
</td></tr>
<tr><td><code id="InvChiSq_+3A_tau">tau</code></td>
<td>
<p>positive valued scaling parameter; if provided it
returns values for scaled chi-squared distributions.</p>
</td></tr>
<tr><td><code id="InvChiSq_+3A_log">log</code>, <code id="InvChiSq_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="InvChiSq_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InvChiSq_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InvChiSq_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">X</code> follows <code class="reqn">\chi^2 (\nu)</code> distribution, then <code class="reqn">1/X</code> follows inverse
chi-squared distribution parametrized by <code class="reqn">\nu</code>. Inverse chi-squared distribution
is a special case of inverse gamma distribution with parameters
<code class="reqn">\alpha=\frac{\nu}{2}</code> and <code class="reqn">\beta=\frac{1}{2}</code>;
or <code class="reqn">\alpha=\frac{\nu}{2}</code> and
<code class="reqn">\beta=\frac{\nu\tau^2}{2}</code> for scaled inverse
chi-squared distribution.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Chisquare">Chisquare</a></code>, <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rinvchisq(1e5, 20)
hist(x, 100, freq = FALSE)
curve(dinvchisq(x, 20), 0, 1, n = 501, col = "red", add = TRUE)
hist(pinvchisq(x, 20))
plot(ecdf(x))
curve(pinvchisq(x, 20), 0, 1, n = 501, col = "red", lwd = 2, add = TRUE)

# scaled

x &lt;- rinvchisq(1e5, 10, 5)
hist(x, 100, freq = FALSE)
curve(dinvchisq(x, 10, 5), 0, 150, n = 501, col = "red", add = TRUE)
hist(pinvchisq(x, 10, 5))
plot(ecdf(x))
curve(pinvchisq(x, 10, 5), 0, 150, n = 501, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='InvGamma'>Inverse-gamma distribution</h2><span id='topic+InvGamma'></span><span id='topic+dinvgamma'></span><span id='topic+pinvgamma'></span><span id='topic+qinvgamma'></span><span id='topic+rinvgamma'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation
for the inverse-gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dinvgamma(x, alpha, beta = 1, log = FALSE)

pinvgamma(q, alpha, beta = 1, lower.tail = TRUE, log.p = FALSE)

qinvgamma(p, alpha, beta = 1, lower.tail = TRUE, log.p = FALSE)

rinvgamma(n, alpha, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InvGamma_+3A_x">x</code>, <code id="InvGamma_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="InvGamma_+3A_alpha">alpha</code>, <code id="InvGamma_+3A_beta">beta</code></td>
<td>
<p>positive valued shape and scale parameters.</p>
</td></tr>
<tr><td><code id="InvGamma_+3A_log">log</code>, <code id="InvGamma_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="InvGamma_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="InvGamma_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="InvGamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\beta^\alpha x^{-\alpha-1} \exp(-\frac{\beta}{x})}{\Gamma(\alpha)}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \frac{\gamma(\alpha, \frac{\beta}{x})}{\Gamma(\alpha)}
</code>
</p>



<h3>References</h3>

<p>Witkovsky, V. (2001). Computing the distribution of a linear
combination of inverted gamma variables. Kybernetika 37(1), 79-90.
</p>
<p>Leemis, L.M. and McQueston, L.T. (2008). Univariate Distribution
Relationships. American Statistician 62(1): 45-53.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+GammaDist">GammaDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rinvgamma(1e5, 20, 3)
hist(x, 100, freq = FALSE)
curve(dinvgamma(x, 20, 3), 0, 1, col = "red", add = TRUE, n = 5000)
hist(pinvgamma(x, 20, 3))
plot(ecdf(x))
curve(pinvgamma(x, 20, 3), 0, 1, col = "red", lwd = 2, add = TRUE, n = 5000) 

</code></pre>

<hr>
<h2 id='Kumaraswamy'>Kumaraswamy distribution</h2><span id='topic+Kumaraswamy'></span><span id='topic+dkumar'></span><span id='topic+pkumar'></span><span id='topic+qkumar'></span><span id='topic+rkumar'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Kumaraswamy distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dkumar(x, a = 1, b = 1, log = FALSE)

pkumar(q, a = 1, b = 1, lower.tail = TRUE, log.p = FALSE)

qkumar(p, a = 1, b = 1, lower.tail = TRUE, log.p = FALSE)

rkumar(n, a = 1, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kumaraswamy_+3A_x">x</code>, <code id="Kumaraswamy_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Kumaraswamy_+3A_a">a</code>, <code id="Kumaraswamy_+3A_b">b</code></td>
<td>
<p>positive valued parameters.</p>
</td></tr>
<tr><td><code id="Kumaraswamy_+3A_log">log</code>, <code id="Kumaraswamy_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Kumaraswamy_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Kumaraswamy_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Kumaraswamy_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = abx^{a-1} (1-x^a)^{b-1}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = 1-(1-x^a)^b
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = 1-(1-p^{1/b})^{1/a}
</code>
</p>



<h3>References</h3>

<p>Jones, M. C. (2009). Kumaraswamy's distribution: A beta-type distribution with
some tractability advantages. Statistical Methodology, 6, 70-81.
</p>
<p>Cordeiro, G.M. and de Castro, M. (2009). A new family of generalized distributions.
Journal of Statistical Computation &amp; Simulation, 1-17.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rkumar(1e5, 5, 16)
hist(x, 100, freq = FALSE)
curve(dkumar(x, 5, 16), 0, 1, col = "red", add = TRUE)
hist(pkumar(x, 5, 16))
plot(ecdf(x))
curve(pkumar(x, 5, 16), 0, 1, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='Laplace'>Laplace distribution</h2><span id='topic+Laplace'></span><span id='topic+dlaplace'></span><span id='topic+plaplace'></span><span id='topic+qlaplace'></span><span id='topic+rlaplace'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Laplace distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlaplace(x, mu = 0, sigma = 1, log = FALSE)

plaplace(q, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qlaplace(p, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rlaplace(n, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Laplace_+3A_x">x</code>, <code id="Laplace_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_mu">mu</code>, <code id="Laplace_+3A_sigma">sigma</code></td>
<td>
<p>location and scale parameters. Scale must be positive.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_log">log</code>, <code id="Laplace_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Laplace_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Laplace_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{1}{2\sigma} \exp\left(-\left|\frac{x-\mu}{\sigma}\right|\right)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn"> F(x) = \left\{\begin{array}{ll}
\frac{1}{2} \exp\left(\frac{x-\mu}{\sigma}\right)     &amp; x &lt; \mu \\
1 - \frac{1}{2} \exp\left(\frac{x-\mu}{\sigma}\right) &amp; x \geq \mu
\end{array}\right.
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn"> F^{-1}(p) = \left\{\begin{array}{ll}
\mu + \sigma \log(2p)     &amp; p &lt; 0.5 \\
\mu - \sigma \log(2(1-p)) &amp; p \geq 0.5
\end{array}\right.
</code>
</p>



<h3>References</h3>

<p>Krishnamoorthy, K. (2006). Handbook of Statistical Distributions
with Applications. Chapman &amp; Hall/CRC
</p>
<p>Forbes, C., Evans, M. Hastings, N., &amp; Peacock, B. (2011).
Statistical Distributions. John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rlaplace(1e5, 5, 16)
hist(x, 100, freq = FALSE)
curve(dlaplace(x, 5, 16), -200, 200, n = 500, col = "red", add = TRUE)
hist(plaplace(x, 5, 16))
plot(ecdf(x))
curve(plaplace(x, 5, 16), -200, 200, n = 500, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='LocationScaleT'>Location-scale version of the t-distribution</h2><span id='topic+LocationScaleT'></span><span id='topic+dlst'></span><span id='topic+plst'></span><span id='topic+qlst'></span><span id='topic+rlst'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function and random generation
for location-scale version of the t-distribution. Location-scale version
of the t-distribution besides degrees of freedom <code class="reqn">\nu</code>, is parametrized
using additional parameters <code class="reqn">\mu</code> for location and <code class="reqn">\sigma</code> for
scale (<code class="reqn">\mu = 0</code> and <code class="reqn">\sigma = 1</code> for standard t-distribution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlst(x, df, mu = 0, sigma = 1, log = FALSE)

plst(q, df, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qlst(p, df, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rlst(n, df, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocationScaleT_+3A_x">x</code>, <code id="LocationScaleT_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="LocationScaleT_+3A_df">df</code></td>
<td>
<p>degrees of freedom (&gt; 0, maybe non-integer). <code>df = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="LocationScaleT_+3A_mu">mu</code></td>
<td>
<p>vector of locations</p>
</td></tr>
<tr><td><code id="LocationScaleT_+3A_sigma">sigma</code></td>
<td>
<p>vector of positive valued scale parameters.</p>
</td></tr>
<tr><td><code id="LocationScaleT_+3A_log">log</code>, <code id="LocationScaleT_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="LocationScaleT_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="LocationScaleT_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="LocationScaleT_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+TDist">TDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rlst(1e5, 1000, 5, 13)
hist(x, 100, freq = FALSE)
curve(dlst(x, 1000, 5, 13), -60, 60, col = "red", add = TRUE)
hist(plst(x, 1000, 5, 13))
plot(ecdf(x))
curve(plst(x, 1000, 5, 13), -60, 60, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='LogSeries'>Logarithmic series distribution</h2><span id='topic+LogSeries'></span><span id='topic+dlgser'></span><span id='topic+plgser'></span><span id='topic+qlgser'></span><span id='topic+rlgser'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the logarithmic series distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlgser(x, theta, log = FALSE)

plgser(q, theta, lower.tail = TRUE, log.p = FALSE)

qlgser(p, theta, lower.tail = TRUE, log.p = FALSE)

rlgser(n, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LogSeries_+3A_x">x</code>, <code id="LogSeries_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="LogSeries_+3A_theta">theta</code></td>
<td>
<p>vector; concentration parameter; (<code>0 &lt; theta &lt; 1</code>).</p>
</td></tr>
<tr><td><code id="LogSeries_+3A_log">log</code>, <code id="LogSeries_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="LogSeries_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="LogSeries_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="LogSeries_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{-1}{\log(1-\theta)} \frac{\theta^x}{x}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \frac{-1}{\log(1-\theta)} \sum_{k=1}^x \frac{\theta^x}{x}
</code>
</p>

<p>Quantile function and random generation are computed using
algorithm described in Krishnamoorthy (2006).
</p>


<h3>References</h3>

<p>Krishnamoorthy, K. (2006). Handbook of Statistical Distributions
with Applications. Chapman &amp; Hall/CRC
</p>
<p>Forbes, C., Evans, M. Hastings, N., &amp; Peacock, B. (2011).
Statistical Distributions. John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rlgser(1e5, 0.66)
xx &lt;- seq(0, 100, by = 1)
plot(prop.table(table(x)), type = "h")
lines(xx, dlgser(xx, 0.66), col = "red")

# Notice: distribution of F(X) is far from uniform:
hist(plgser(x, 0.66), 50)

xx &lt;- seq(0, 100, by = 0.01)
plot(ecdf(x))
lines(xx, plgser(xx, 0.66), col = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='Lomax'>Lomax distribution</h2><span id='topic+Lomax'></span><span id='topic+dlomax'></span><span id='topic+plomax'></span><span id='topic+qlomax'></span><span id='topic+rlomax'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Lomax distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlomax(x, lambda, kappa, log = FALSE)

plomax(q, lambda, kappa, lower.tail = TRUE, log.p = FALSE)

qlomax(p, lambda, kappa, lower.tail = TRUE, log.p = FALSE)

rlomax(n, lambda, kappa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lomax_+3A_x">x</code>, <code id="Lomax_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Lomax_+3A_lambda">lambda</code>, <code id="Lomax_+3A_kappa">kappa</code></td>
<td>
<p>positive valued parameters.</p>
</td></tr>
<tr><td><code id="Lomax_+3A_log">log</code>, <code id="Lomax_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Lomax_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Lomax_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Lomax_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\lambda \kappa}{(1+\lambda x)^{\kappa+1}}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = 1-(1+\lambda x)^{-\kappa}
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \frac{(1-p)^{-1/\kappa} -1}{\lambda}
</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rlomax(1e5, 5, 16)
hist(x, 100, freq = FALSE)
curve(dlomax(x, 5, 16), 0, 1, col = "red", add = TRUE, n = 5000)
hist(plomax(x, 5, 16))
plot(ecdf(x))
curve(plomax(x, 5, 16), 0, 1, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='MultiHypergeometric'>Multivariate hypergeometric distribution</h2><span id='topic+MultiHypergeometric'></span><span id='topic+dmvhyper'></span><span id='topic+rmvhyper'></span>

<h3>Description</h3>

<p>Probability mass function and random generation
for the multivariate hypergeometric distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvhyper(x, n, k, log = FALSE)

rmvhyper(nn, n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiHypergeometric_+3A_x">x</code></td>
<td>
<p><code class="reqn">m</code>-column matrix of quantiles.</p>
</td></tr>
<tr><td><code id="MultiHypergeometric_+3A_n">n</code></td>
<td>
<p><code class="reqn">m</code>-length vector or <code class="reqn">m</code>-column matrix
of numbers of balls in <code class="reqn">m</code> colors.</p>
</td></tr>
<tr><td><code id="MultiHypergeometric_+3A_k">k</code></td>
<td>
<p>the number of balls drawn from the urn.</p>
</td></tr>
<tr><td><code id="MultiHypergeometric_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="MultiHypergeometric_+3A_nn">nn</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\prod_{i=1}^m {n_i \choose x_i}}{{N \choose k}}
</code>
</p>

<p>The multivariate hypergeometric distribution is generalization of
hypergeometric distribution. It is used for sampling <em>without</em> replacement
<code class="reqn">k</code> out of <code class="reqn">N</code> marbles in <code class="reqn">m</code> colors, where each of the colors appears
<code class="reqn">n_i</code> times. Where <code class="reqn">k=\sum_{i=1}^m x_i</code>,
<code class="reqn">N=\sum_{i=1}^m n_i</code> and <code class="reqn">k \le N</code>.
</p>


<h3>References</h3>

<p>Gentle, J.E. (2006). Random number generation and Monte Carlo methods. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Hypergeometric">Hypergeometric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating 10 random draws from multivariate hypergeometric
# distribution parametrized using a vector

rmvhyper(10, c(10, 12, 5, 8, 11), 33)

</code></pre>

<hr>
<h2 id='Multinomial'>Multinomial distribution</h2><span id='topic+Multinomial'></span><span id='topic+dmnom'></span><span id='topic+rmnom'></span>

<h3>Description</h3>

<p>Probability mass function and random generation
for the multinomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmnom(x, size, prob, log = FALSE)

rmnom(n, size, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Multinomial_+3A_x">x</code></td>
<td>
<p><code class="reqn">k</code>-column matrix of quantiles.</p>
</td></tr>
<tr><td><code id="Multinomial_+3A_size">size</code></td>
<td>
<p>numeric vector; number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="Multinomial_+3A_prob">prob</code></td>
<td>
<p><code class="reqn">k</code>-column numeric matrix; probability of success on each trial.</p>
</td></tr>
<tr><td><code id="Multinomial_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Multinomial_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{n!}{\prod_{i=1}^k x_i} \prod_{i=1}^k p_i^{x_i}
</code>
</p>



<h3>References</h3>

<p>Gentle, J.E. (2006). Random number generation and Monte Carlo methods. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Binomial">Binomial</a></code>, <code><a href="stats.html#topic+Multinomial">Multinomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating 10 random draws from multinomial distribution
# parametrized using a vector

(x &lt;- rmnom(10, 3, c(1/3, 1/3, 1/3)))

# Results are consistent with dmultinom() from stats:

all.equal(dmultinom(x[1,], 3, c(1/3, 1/3, 1/3)),
          dmnom(x[1, , drop = FALSE], 3, c(1/3, 1/3, 1/3)))

</code></pre>

<hr>
<h2 id='NegHyper'>Negative hypergeometric distribution</h2><span id='topic+NegHyper'></span><span id='topic+dnhyper'></span><span id='topic+pnhyper'></span><span id='topic+qnhyper'></span><span id='topic+rnhyper'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function, quantile function and random generation
for the negative hypergeometric distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnhyper(x, n, m, r, log = FALSE)

pnhyper(q, n, m, r, lower.tail = TRUE, log.p = FALSE)

qnhyper(p, n, m, r, lower.tail = TRUE, log.p = FALSE)

rnhyper(nn, n, m, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NegHyper_+3A_x">x</code>, <code id="NegHyper_+3A_q">q</code></td>
<td>
<p>vector of quantiles representing the number of balls drawn without
replacement from an urn which contains both black and white balls.</p>
</td></tr>
<tr><td><code id="NegHyper_+3A_n">n</code></td>
<td>
<p>the number of black balls in the urn.</p>
</td></tr>
<tr><td><code id="NegHyper_+3A_m">m</code></td>
<td>
<p>the number of white balls in the urn.</p>
</td></tr>
<tr><td><code id="NegHyper_+3A_r">r</code></td>
<td>
<p>the number of white balls that needs to be drawn for the sampling
to be stopped.</p>
</td></tr>
<tr><td><code id="NegHyper_+3A_log">log</code>, <code id="NegHyper_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="NegHyper_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="NegHyper_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="NegHyper_+3A_nn">nn</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Negative hypergeometric distribution describes number of balls <code class="reqn">x</code> observed
until drawing without replacement to obtain <code class="reqn">r</code> white balls
from the urn containing <code class="reqn">m</code> white balls and <code class="reqn">n</code> black balls,
and is defined as
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{{x-1 \choose r-1}{m+n-x \choose m-r}}{{m+n \choose n}}
</code>
</p>

<p>The algorithm used for calculating probability mass function,
cumulative distribution function and quantile function is based
on Fortran program NHYPERG created by Berry and Mielke (1996, 1998).
Random generation is done by inverse transform sampling.
</p>


<h3>References</h3>

<p>Berry, K. J., &amp; Mielke, P. W. (1998).
The negative hypergeometric probability distribution:
Sampling without replacement from a finite population.
Perceptual and motor skills, 86(1), 207-210.
<a href="https://journals.sagepub.com/doi/10.2466/pms.1998.86.1.207">https://journals.sagepub.com/doi/10.2466/pms.1998.86.1.207</a>
</p>
<p>Berry, K. J., &amp; Mielke, P. W. (1996).
Exact confidence limits for population proportions based on the negative
hypergeometric probability distribution.
Perceptual and motor skills, 83(3 suppl), 1216-1218.
<a href="https://journals.sagepub.com/doi/10.2466/pms.1996.83.3f.1216">https://journals.sagepub.com/doi/10.2466/pms.1996.83.3f.1216</a>
</p>
<p>Schuster, E. F., &amp; Sype, W. R. (1987).
On the negative hypergeometric distribution.
International Journal of Mathematical Education in Science and Technology, 18(3), 453-459.
</p>
<p>Chae, K. C. (1993).
Presenting the negative hypergeometric distribution to the introductory statistics courses.
International Journal of Mathematical Education in Science and Technology, 24(4), 523-526.
</p>
<p>Jones, S.N. (2013). A Gaming Application of the Negative Hypergeometric Distribution.
UNLV Theses, Dissertations, Professional Papers, and Capstones. Paper 1846.
<a href="https://digitalscholarship.unlv.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=2847&amp;context=thesesdissertations">https://digitalscholarship.unlv.edu/cgi/viewcontent.cgi?referer=&amp;httpsredir=1&amp;article=2847&amp;context=thesesdissertations</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Hypergeometric">Hypergeometric</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnhyper(1e5, 60, 35, 15)
xx &lt;- 15:95
plot(prop.table(table(x)))
lines(xx, dnhyper(xx, 60, 35, 15), col = "red")
hist(pnhyper(x, 60, 35, 15))

xx &lt;- seq(0, 100, by = 0.01)
plot(ecdf(x))
lines(xx, pnhyper(xx, 60, 35, 15), col = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='NormalMix'>Mixture of normal distributions</h2><span id='topic+NormalMix'></span><span id='topic+dmixnorm'></span><span id='topic+pmixnorm'></span><span id='topic+rmixnorm'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation
for the mixture of normal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixnorm(x, mean, sd, alpha, log = FALSE)

pmixnorm(q, mean, sd, alpha, lower.tail = TRUE, log.p = FALSE)

rmixnorm(n, mean, sd, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NormalMix_+3A_x">x</code>, <code id="NormalMix_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="NormalMix_+3A_mean">mean</code></td>
<td>
<p>matrix (or vector) of means.</p>
</td></tr>
<tr><td><code id="NormalMix_+3A_sd">sd</code></td>
<td>
<p>matrix (or vector) of standard deviations.</p>
</td></tr>
<tr><td><code id="NormalMix_+3A_alpha">alpha</code></td>
<td>
<p>matrix (or vector) of mixing proportions;
mixing proportions need to sum up to 1.</p>
</td></tr>
<tr><td><code id="NormalMix_+3A_log">log</code>, <code id="NormalMix_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="NormalMix_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="NormalMix_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="NormalMix_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \alpha_1 f_1(x; \mu_1, \sigma_1) + \dots + \alpha_k f_k(x; \mu_k, \sigma_k)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \alpha_1 F_1(x; \mu_1, \sigma_1) + \dots + \alpha_k F_k(x; \mu_k, \sigma_k)
</code>
</p>

<p>where <code class="reqn">\sum_i \alpha_i = 1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rmixnorm(1e5, c(0.5, 3, 6), c(3, 1, 1), c(1/3, 1/3, 1/3))
hist(x, 100, freq = FALSE)
curve(dmixnorm(x, c(0.5, 3, 6), c(3, 1, 1), c(1/3, 1/3, 1/3)),
      -20, 20, n = 500, col = "red", add = TRUE)
hist(pmixnorm(x, c(0.5, 3, 6), c(3, 1, 1), c(1/3, 1/3, 1/3)))
plot(ecdf(x))
curve(pmixnorm(x, c(0.5, 3, 6), c(3, 1, 1), c(1/3, 1/3, 1/3)),
      -20, 20, n = 500, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='NSBeta'>Non-standard beta distribution</h2><span id='topic+NSBeta'></span><span id='topic+dnsbeta'></span><span id='topic+dgbeta'></span><span id='topic+pnsbeta'></span><span id='topic+qnsbeta'></span><span id='topic+rnsbeta'></span>

<h3>Description</h3>

<p>Non-standard form of beta distribution with lower and upper bounds
denoted as <code>min</code> and <code>max</code>. By default <code>min=0</code>
and <code>max=1</code> what leads to standard beta distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnsbeta(x, shape1, shape2, min = 0, max = 1, log = FALSE)

pnsbeta(q, shape1, shape2, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)

qnsbeta(p, shape1, shape2, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)

rnsbeta(n, shape1, shape2, min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NSBeta_+3A_x">x</code>, <code id="NSBeta_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="NSBeta_+3A_shape1">shape1</code>, <code id="NSBeta_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="NSBeta_+3A_min">min</code>, <code id="NSBeta_+3A_max">max</code></td>
<td>
<p>lower and upper bounds.</p>
</td></tr>
<tr><td><code id="NSBeta_+3A_log">log</code>, <code id="NSBeta_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="NSBeta_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \leq x]</code>,
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="NSBeta_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="NSBeta_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Beta">Beta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rnsbeta(1e5, 5, 13, -4, 8)
hist(x, 100, freq = FALSE)
curve(dnsbeta(x, 5, 13, -4, 8), -4, 6, col = "red", add = TRUE) 
hist(pnsbeta(x, 5, 13, -4, 8))
plot(ecdf(x))
curve(pnsbeta(x, 5, 13, -4, 8), -4, 6, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='Pareto'>Pareto distribution</h2><span id='topic+Pareto'></span><span id='topic+dpareto'></span><span id='topic+ppareto'></span><span id='topic+qpareto'></span><span id='topic+rpareto'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Pareto distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpareto(x, a = 1, b = 1, log = FALSE)

ppareto(q, a = 1, b = 1, lower.tail = TRUE, log.p = FALSE)

qpareto(p, a = 1, b = 1, lower.tail = TRUE, log.p = FALSE)

rpareto(n, a = 1, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pareto_+3A_x">x</code>, <code id="Pareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_a">a</code>, <code id="Pareto_+3A_b">b</code></td>
<td>
<p>positive valued scale and location parameters.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_log">log</code>, <code id="Pareto_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Pareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Pareto_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{ab^a}{x^{a+1}}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = 1 - \left(\frac{b}{x}\right)^a
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \frac{b}{(1-p)^{1-a}}
</code>
</p>



<h3>References</h3>

<p>Krishnamoorthy, K. (2006). Handbook of Statistical Distributions
with Applications. Chapman &amp; Hall/CRC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rpareto(1e5, 5, 16)
hist(x, 100, freq = FALSE)
curve(dpareto(x, 5, 16), 0, 200, col = "red", add = TRUE)
hist(ppareto(x, 5, 16))
plot(ecdf(x))
curve(ppareto(x, 5, 16), 0, 200, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='PoissonMix'>Mixture of Poisson distributions</h2><span id='topic+PoissonMix'></span><span id='topic+dmixpois'></span><span id='topic+pmixpois'></span><span id='topic+rmixpois'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation
for the mixture of Poisson distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmixpois(x, lambda, alpha, log = FALSE)

pmixpois(q, lambda, alpha, lower.tail = TRUE, log.p = FALSE)

rmixpois(n, lambda, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PoissonMix_+3A_x">x</code>, <code id="PoissonMix_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="PoissonMix_+3A_lambda">lambda</code></td>
<td>
<p>matrix (or vector) of (non-negative) means.</p>
</td></tr>
<tr><td><code id="PoissonMix_+3A_alpha">alpha</code></td>
<td>
<p>matrix (or vector) of mixing proportions;
mixing proportions need to sum up to 1.</p>
</td></tr>
<tr><td><code id="PoissonMix_+3A_log">log</code>, <code id="PoissonMix_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="PoissonMix_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="PoissonMix_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="PoissonMix_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \alpha_1 f_1(x; \lambda_1) + \dots + \alpha_k f_k(x; \lambda_k)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \alpha_1 F_1(x; \lambda_1) + \dots + \alpha_k F_k(x; \lambda_k)
</code>
</p>

<p>where <code class="reqn">\sum_i \alpha_i = 1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rmixpois(1e5, c(5, 12, 19), c(1/3, 1/3, 1/3))
xx &lt;- seq(-1, 50)
plot(prop.table(table(x)))
lines(xx, dmixpois(xx, c(5, 12, 19), c(1/3, 1/3, 1/3)), col = "red")
hist(pmixpois(x, c(5, 12, 19), c(1/3, 1/3, 1/3)))

xx &lt;- seq(0, 50, by = 0.01)
plot(ecdf(x))
lines(xx, pmixpois(xx, c(5, 12, 19), c(1/3, 1/3, 1/3)), col = "red", lwd = 2)

</code></pre>

<hr>
<h2 id='PowerDist'>Power distribution</h2><span id='topic+PowerDist'></span><span id='topic+dpower'></span><span id='topic+ppower'></span><span id='topic+qpower'></span><span id='topic+rpower'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the power distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpower(x, alpha, beta, log = FALSE)

ppower(q, alpha, beta, lower.tail = TRUE, log.p = FALSE)

qpower(p, alpha, beta, lower.tail = TRUE, log.p = FALSE)

rpower(n, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PowerDist_+3A_x">x</code>, <code id="PowerDist_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="PowerDist_+3A_alpha">alpha</code>, <code id="PowerDist_+3A_beta">beta</code></td>
<td>
<p>parameters.</p>
</td></tr>
<tr><td><code id="PowerDist_+3A_log">log</code>, <code id="PowerDist_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="PowerDist_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="PowerDist_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="PowerDist_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\beta x^{\beta-1}}{\alpha^\beta}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \frac{x^\beta}{\alpha^\beta}
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \alpha p^{1/\beta}
</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rpower(1e5, 5, 16)
hist(x, 100, freq = FALSE)
curve(dpower(x, 5, 16), 2, 6, col = "red", add = TRUE, n = 5000)
hist(ppower(x, 5, 16))
plot(ecdf(x))
curve(ppower(x, 5, 16), 2, 6, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='PropBeta'>Beta distribution of proportions</h2><span id='topic+PropBeta'></span><span id='topic+dprop'></span><span id='topic+pprop'></span><span id='topic+qprop'></span><span id='topic+rprop'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function and random generation
for the reparametrized beta distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprop(x, size, mean, prior = 0, log = FALSE)

pprop(q, size, mean, prior = 0, lower.tail = TRUE, log.p = FALSE)

qprop(p, size, mean, prior = 0, lower.tail = TRUE, log.p = FALSE)

rprop(n, size, mean, prior = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PropBeta_+3A_x">x</code>, <code id="PropBeta_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="PropBeta_+3A_size">size</code></td>
<td>
<p>non-negative real number; precision or number of binomial trials.</p>
</td></tr>
<tr><td><code id="PropBeta_+3A_mean">mean</code></td>
<td>
<p>mean proportion or probability of success on each trial;
<code>0 &lt; mean &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="PropBeta_+3A_prior">prior</code></td>
<td>
<p>(see below) with <code>prior = 0</code> (default)
the distribution corresponds to re-parametrized beta
distribution used in beta regression. This parameter needs
to be non-negative.</p>
</td></tr>
<tr><td><code id="PropBeta_+3A_log">log</code>, <code id="PropBeta_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="PropBeta_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="PropBeta_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="PropBeta_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beta can be understood as a distribution of <code class="reqn">x = k/\phi</code> proportions in
<code class="reqn">\phi</code> trials where the average proportion is denoted as <code class="reqn">\mu</code>,
so it's parameters become <code class="reqn">\alpha = \phi\mu</code> and
<code class="reqn">\beta = \phi(1-\mu)</code> and it's density function becomes
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{x^{\phi\mu+\pi-1} (1-x)^{\phi(1-\mu)+\pi-1}}{\mathrm{B}(\phi\mu+\pi, \phi(1-\mu)+\pi)}
</code>
</p>

<p>where <code class="reqn">\pi</code> is a <em>prior</em> parameter, so the distribution is a
<em>posterior</em> distribution after observing <code class="reqn">\phi\mu</code> successes and
<code class="reqn">\phi(1-\mu)</code> failures in <code class="reqn">\phi</code> trials with binomial likelihood
and symmetric <code class="reqn">\mathrm{Beta}(\pi, \pi)</code> prior for
probability of success. Parameter value <code class="reqn">\pi = 1</code> corresponds to
uniform prior; <code class="reqn">\pi = 1/2</code> corresponds to Jeffreys prior; <code class="reqn">\pi = 0</code>
corresponds to &quot;uninformative&quot; Haldane prior, this is also the re-parametrized
distribution used in beta regression. With <code class="reqn">\pi = 0</code> the distribution
can be understood as a continuous analog to binomial distribution dealing
with proportions rather then counts. Alternatively <code class="reqn">\phi</code> may be
understood as precision parameter (as in beta regression).
</p>
<p>Notice that in pre-1.8.4 versions of this package, <code>prior</code> was not settable
and by default fixed to one, instead of zero. To obtain the same results as in
the previous versions, use <code>prior = 1</code> in each of the functions.
</p>


<h3>References</h3>

<p>Ferrari, S., &amp; Cribari-Neto, F. (2004). Beta regression for modelling rates and proportions.
Journal of Applied Statistics, 31(7), 799-815.
</p>
<p>Smithson, M., &amp; Verkuilen, J. (2006). A better lemon squeezer? Maximum-likelihood regression
with beta-distributed dependent variables.
Psychological Methods, 11(1), 54-71.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+beta">beta</a></code>, <code><a href="stats.html#topic+binomial">binomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rprop(1e5, 100, 0.33)
hist(x, 100, freq = FALSE)
curve(dprop(x, 100, 0.33), 0, 1, col = "red", add = TRUE)
hist(pprop(x, 100, 0.33))
plot(ecdf(x))
curve(pprop(x, 100, 0.33), 0, 1, col = "red", lwd = 2, add = TRUE)

n &lt;- 500
p &lt;- 0.23
k &lt;- rbinom(1e5, n, p)
hist(k/n, freq = FALSE, 100)
curve(dprop(x, n, p), 0, 1, col = "red", add = TRUE, n = 500)
                       
</code></pre>

<hr>
<h2 id='Rademacher'>Random generation from Rademacher distribution</h2><span id='topic+Rademacher'></span><span id='topic+rsign'></span>

<h3>Description</h3>

<p>Random generation for the Rademacher distribution (values -1 and +1
with equal probability).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsign(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rademacher_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>

<hr>
<h2 id='Rayleigh'>Rayleigh distribution</h2><span id='topic+Rayleigh'></span><span id='topic+drayleigh'></span><span id='topic+prayleigh'></span><span id='topic+qrayleigh'></span><span id='topic+rrayleigh'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the Rayleigh distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drayleigh(x, sigma = 1, log = FALSE)

prayleigh(q, sigma = 1, lower.tail = TRUE, log.p = FALSE)

qrayleigh(p, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rrayleigh(n, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rayleigh_+3A_x">x</code>, <code id="Rayleigh_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Rayleigh_+3A_sigma">sigma</code></td>
<td>
<p>positive valued parameter.</p>
</td></tr>
<tr><td><code id="Rayleigh_+3A_log">log</code>, <code id="Rayleigh_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Rayleigh_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Rayleigh_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Rayleigh_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{x}{\sigma^2} \exp\left(-\frac{x^2}{2\sigma^2}\right)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = 1 - \exp\left(-\frac{x^2}{2\sigma^2}\right)
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \sqrt{-2\sigma^2 \log(1-p)}
</code>
</p>



<h3>References</h3>

<p>Krishnamoorthy, K. (2006). Handbook of Statistical Distributions
with Applications. Chapman &amp; Hall/CRC.
</p>
<p>Forbes, C., Evans, M. Hastings, N., &amp; Peacock, B. (2011).
Statistical Distributions. John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rrayleigh(1e5, 13)
hist(x, 100, freq = FALSE)
curve(drayleigh(x, 13), 0, 60, col = "red", add = TRUE)
hist(prayleigh(x, 13)) 
plot(ecdf(x))
curve(prayleigh(x, 13), 0, 60, col = "red", lwd = 2, add = TRUE) 

</code></pre>

<hr>
<h2 id='ShiftGomp'>Shifted Gompertz distribution</h2><span id='topic+ShiftGomp'></span><span id='topic+dsgomp'></span><span id='topic+psgomp'></span><span id='topic+rsgomp'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation
for the shifted Gompertz distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsgomp(x, b, eta, log = FALSE)

psgomp(q, b, eta, lower.tail = TRUE, log.p = FALSE)

rsgomp(n, b, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShiftGomp_+3A_x">x</code>, <code id="ShiftGomp_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ShiftGomp_+3A_b">b</code>, <code id="ShiftGomp_+3A_eta">eta</code></td>
<td>
<p>positive valued scale and shape parameters;
both need to be positive.</p>
</td></tr>
<tr><td><code id="ShiftGomp_+3A_log">log</code>, <code id="ShiftGomp_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ShiftGomp_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="ShiftGomp_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">X</code> follows exponential distribution parametrized by scale <code class="reqn">b</code> and
<code class="reqn">Y</code> follows reparametrized Gumbel distribution with cumulative distribution function
<code class="reqn">F(x) = \exp(-\eta  e^{-bx})</code> parametrized by 
scale <code class="reqn">b</code> and shape <code class="reqn">\eta</code>, then <code class="reqn">\max(X,Y)</code> follows shifted
Gompertz distribution parametrized by scale <code class="reqn">b&gt;0</code> and shape <code class="reqn">\eta&gt;0</code>.
The above relation is used by <code>rsgomp</code> function for random generation from
shifted Gompertz distribution.
</p>
<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = b e^{-bx} \exp(-\eta e^{-bx}) \left[1 + \eta(1 - e^{-bx})\right]
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = (1-e^{-bx}) \exp(-\eta e^{-bx})
</code>
</p>



<h3>References</h3>

<p>Bemmaor, A.C. (1994).
Modeling the Diffusion of New Durable Goods: Word-of-Mouth Effect Versus Consumer Heterogeneity.
[In:] G. Laurent, G.L. Lilien &amp; B. Pras. Research Traditions in Marketing.
Boston: Kluwer Academic Publishers. pp. 201-223.
</p>
<p>Jimenez, T.F. and Jodra, P. (2009).
A Note on the Moments and Computer Generation of the Shifted Gompertz Distribution.
Communications in Statistics - Theory and Methods, 38(1), 78-89.
</p>
<p>Jimenez T.F. (2014).
Estimation of the Parameters of the Shifted Gompertz Distribution,
Using Least Squares, Maximum Likelihood and Moments Methods.
Journal of Computational and Applied Mathematics, 255(1), 867-877.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rsgomp(1e5, 0.4, 1)
hist(x, 50, freq = FALSE)
curve(dsgomp(x, 0.4, 1), 0, 30, col = "red", add = TRUE)
hist(psgomp(x, 0.4, 1))
plot(ecdf(x))
curve(psgomp(x, 0.4, 1), 0, 30, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='Skellam'>Skellam distribution</h2><span id='topic+Skellam'></span><span id='topic+dskellam'></span><span id='topic+rskellam'></span>

<h3>Description</h3>

<p>Probability mass function and random generation
for the Skellam distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dskellam(x, mu1, mu2, log = FALSE)

rskellam(n, mu1, mu2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Skellam_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Skellam_+3A_mu1">mu1</code>, <code id="Skellam_+3A_mu2">mu2</code></td>
<td>
<p>positive valued parameters.</p>
</td></tr>
<tr><td><code id="Skellam_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Skellam_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">X</code> and <code class="reqn">Y</code> follow Poisson distributions with means
<code class="reqn">\mu_1</code> and <code class="reqn">\mu_2</code>, than <code class="reqn">X-Y</code> follows
Skellam distribution parametrized by <code class="reqn">\mu_1</code> and <code class="reqn">\mu_2</code>.
</p>
<p>Probability mass function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = e^{-(\mu_1\!+\!\mu_2)} \left(\frac{\mu_1}{\mu_2}\right)^{k/2}\!\!I_{k}(2\sqrt{\mu_1\mu_2})
</code>
</p>



<h3>References</h3>

<p>Karlis, D., &amp; Ntzoufras, I. (2006). Bayesian analysis of the differences of count data.
Statistics in medicine, 25(11), 1885-1905.
</p>
<p>Skellam, J.G. (1946). The frequency distribution of the difference between
two Poisson variates belonging to different populations.
Journal of the Royal Statistical Society, series A, 109(3), 26.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rskellam(1e5, 5, 13)
xx &lt;- -40:40
plot(prop.table(table(x)), type = "h")
lines(xx, dskellam(xx, 5, 13), col = "red")

</code></pre>

<hr>
<h2 id='Slash'>Slash distribution</h2><span id='topic+Slash'></span><span id='topic+dslash'></span><span id='topic+pslash'></span><span id='topic+rslash'></span>

<h3>Description</h3>

<p>Probability mass function, distribution function and random generation
for slash distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dslash(x, mu = 0, sigma = 1, log = FALSE)

pslash(q, mu = 0, sigma = 1, lower.tail = TRUE, log.p = FALSE)

rslash(n, mu = 0, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Slash_+3A_x">x</code>, <code id="Slash_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Slash_+3A_mu">mu</code></td>
<td>
<p>vector of locations</p>
</td></tr>
<tr><td><code id="Slash_+3A_sigma">sigma</code></td>
<td>
<p>vector of positive valued scale parameters.</p>
</td></tr>
<tr><td><code id="Slash_+3A_log">log</code>, <code id="Slash_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Slash_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Slash_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">Z \sim \mathrm{Normal}(0, 1)</code> and <code class="reqn">U \sim \mathrm{Uniform}(0, 1)</code>,
then <code class="reqn">Z/U</code> follows slash distribution.
</p>
<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \left\{\begin{array}{ll}
\frac{\phi(0) - \phi(x)}{x^2} &amp; x \ne 0 \\
\frac{1}{2\sqrt{2\pi}} &amp; x = 0
\end{array}\right.
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \left\{\begin{array}{ll}
\Phi(x) - \frac{\phi(0)-\phi(x)}{x} &amp; x \neq 0 \\
\frac{1}{2} &amp; x = 0
\end{array}\right.
</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rslash(1e5, 5, 3)
hist(x, 1e5, freq = FALSE, xlim = c(-100, 100))
curve(dslash(x, 5, 3), -100, 100, col = "red", n = 500, add = TRUE)
hist(pslash(x, 5, 3))
plot(ecdf(x), xlim = c(-100, 100))
curve(pslash(x, 5, 3), -100, 100, col = "red", lwd = 2, n = 500, add = TRUE)

</code></pre>

<hr>
<h2 id='Triangular'>Triangular distribution</h2><span id='topic+Triangular'></span><span id='topic+dtriang'></span><span id='topic+ptriang'></span><span id='topic+qtriang'></span><span id='topic+rtriang'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the triangular distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtriang(x, a = -1, b = 1, c = (a + b)/2, log = FALSE)

ptriang(q, a = -1, b = 1, c = (a + b)/2, lower.tail = TRUE, log.p = FALSE)

qtriang(p, a = -1, b = 1, c = (a + b)/2, lower.tail = TRUE, log.p = FALSE)

rtriang(n, a = -1, b = 1, c = (a + b)/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Triangular_+3A_x">x</code>, <code id="Triangular_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_a">a</code>, <code id="Triangular_+3A_b">b</code>, <code id="Triangular_+3A_c">c</code></td>
<td>
<p>minimum, maximum and mode of the distribution.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_log">log</code>, <code id="Triangular_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Triangular_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \left\{\begin{array}{ll}
\frac{2(x-a)}{(b-a)(c-a)} &amp; x &lt; c \\
\frac{2}{b-a}             &amp; x = c \\
\frac{2(b-x)}{(b-a)(b-c)} &amp; x &gt; c
\end{array}\right.
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \left\{\begin{array}{ll}
\frac{(x-a)^2}{(b-a)(c-a)}     &amp; x \leq c \\
1 - \frac{(b-x)^2}{(b-a)(b-c)} &amp; x &gt; c
\end{array}\right.
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \left\{\begin{array}{ll}
a + \sqrt{p \times (b-a)(c-a)} &amp; p \leq \frac{c-a}{b-a} \\
b - \sqrt{(1-p)(b-a)(b-c)}     &amp; p &gt; \frac{c-a}{b-a}
\end{array}\right.
</code>
</p>

<p>For random generation MINMAX method described by
Stein and Keblis (2009) is used.
</p>


<h3>References</h3>

<p>Forbes, C., Evans, M. Hastings, N., &amp; Peacock, B. (2011).
Statistical Distributions. John Wiley &amp; Sons.
</p>
<p>Stein, W. E., &amp; Keblis, M. F. (2009).
A new method to simulate the triangular distribution.
Mathematical and computer modelling, 49(5), 1143-1147.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rtriang(1e5, 5, 7, 6)
hist(x, 100, freq = FALSE)
curve(dtriang(x, 5, 7, 6), 3, 10, n = 500, col = "red", add = TRUE)
hist(ptriang(x, 5, 7, 6))
plot(ecdf(x))
curve(ptriang(x, 5, 7, 6), 3, 10, n = 500, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='TruncBinom'>Truncated binomial distribution</h2><span id='topic+TruncBinom'></span><span id='topic+dtbinom'></span><span id='topic+ptbinom'></span><span id='topic+qtbinom'></span><span id='topic+rtbinom'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the truncated binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtbinom(x, size, prob, a = -Inf, b = Inf, log = FALSE)

ptbinom(q, size, prob, a = -Inf, b = Inf, lower.tail = TRUE, log.p = FALSE)

qtbinom(p, size, prob, a = -Inf, b = Inf, lower.tail = TRUE, log.p = FALSE)

rtbinom(n, size, prob, a = -Inf, b = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TruncBinom_+3A_x">x</code>, <code id="TruncBinom_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="TruncBinom_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="TruncBinom_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial.</p>
</td></tr>
<tr><td><code id="TruncBinom_+3A_a">a</code>, <code id="TruncBinom_+3A_b">b</code></td>
<td>
<p>lower and upper truncation points (<code>a &lt; x &lt;= b</code>).</p>
</td></tr>
<tr><td><code id="TruncBinom_+3A_log">log</code>, <code id="TruncBinom_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="TruncBinom_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="TruncBinom_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="TruncBinom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rtbinom(1e5, 100, 0.83, 76, 86)
xx &lt;- seq(0, 100)
plot(prop.table(table(x)))
lines(xx, dtbinom(xx, 100, 0.83, 76, 86), col = "red")
hist(ptbinom(x, 100, 0.83, 76, 86))

xx &lt;- seq(0, 100, by = 0.01)
plot(ecdf(x))
lines(xx, ptbinom(xx, 100, 0.83, 76, 86), col = "red", lwd = 2)
uu &lt;- seq(0, 1, by = 0.001)
lines(qtbinom(uu, 100, 0.83, 76, 86), uu, col = "blue", lty = 2)

</code></pre>

<hr>
<h2 id='TruncNormal'>Truncated normal distribution</h2><span id='topic+TruncNormal'></span><span id='topic+dtnorm'></span><span id='topic+ptnorm'></span><span id='topic+qtnorm'></span><span id='topic+rtnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the truncated normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtnorm(x, mean = 0, sd = 1, a = -Inf, b = Inf, log = FALSE)

ptnorm(
  q,
  mean = 0,
  sd = 1,
  a = -Inf,
  b = Inf,
  lower.tail = TRUE,
  log.p = FALSE
)

qtnorm(
  p,
  mean = 0,
  sd = 1,
  a = -Inf,
  b = Inf,
  lower.tail = TRUE,
  log.p = FALSE
)

rtnorm(n, mean = 0, sd = 1, a = -Inf, b = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TruncNormal_+3A_x">x</code>, <code id="TruncNormal_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="TruncNormal_+3A_mean">mean</code>, <code id="TruncNormal_+3A_sd">sd</code></td>
<td>
<p>location and scale parameters. Scale must be positive.</p>
</td></tr>
<tr><td><code id="TruncNormal_+3A_a">a</code>, <code id="TruncNormal_+3A_b">b</code></td>
<td>
<p>lower and upper truncation points (<code>a &lt; x &lt;= b</code>,
with <code>a = -Inf</code> and <code>b = Inf</code> by default).</p>
</td></tr>
<tr><td><code id="TruncNormal_+3A_log">log</code>, <code id="TruncNormal_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="TruncNormal_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="TruncNormal_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="TruncNormal_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \frac{\phi(\frac{x-\mu}{\sigma})}
            {\Phi(\frac{b-\mu}{\sigma}) - \Phi(\frac{a-\mu}{\sigma})}
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \frac{\Phi(\frac{x-\mu}{\sigma}) - \Phi(\frac{a-\mu}{\sigma})}
            {\Phi(\frac{b-\mu}{\sigma}) - \Phi(\frac{a-\mu}{\sigma})}
</code>
</p>

<p>Quantile function
</p>
<p style="text-align: center;"><code class="reqn">
F^{-1}(p) = \Phi^{-1}\left(\Phi\left(\frac{a-\mu}{\sigma}\right) + p \times
                     \left[\Phi\left(\frac{b-\mu}{\sigma}\right) -
                     \Phi\left(\frac{a-\mu}{\sigma}\right)\right]\right)
</code>
</p>

<p>For random generation algorithm described by Robert (1995) is used.
</p>


<h3>References</h3>

<p>Robert, C.P. (1995). Simulation of truncated normal variables.
Statistics and Computing 5(2): 121-125. <a href="https://arxiv.org/abs/0907.4010">https://arxiv.org/abs/0907.4010</a>
</p>
<p>Burkardt, J. (17 October 2014). The Truncated Normal Distribution. Florida State University.
<a href="https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf">https://people.sc.fsu.edu/~jburkardt/presentations/truncated_normal.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rtnorm(1e5, 5, 3, b = 7)
hist(x, 100, freq = FALSE)
curve(dtnorm(x, 5, 3, b = 7), -8, 8, col = "red", add = TRUE)
hist(ptnorm(x, 5, 3, b = 7))
plot(ecdf(x))
curve(ptnorm(x, 5, 3, b = 7), -8, 8, col = "red", lwd = 2, add = TRUE)

R &lt;- 1e5
partmp &lt;- par(mfrow = c(2,4), mar = c(2,2,2,2))

hist(rtnorm(R), freq= FALSE, main = "", xlab = "", ylab = "")
curve(dtnorm(x), -5, 5, col = "red", add = TRUE)

hist(rtnorm(R, a = 0), freq= FALSE, main = "", xlab = "", ylab = "")
curve(dtnorm(x, a = 0), -1, 5, col = "red", add = TRUE)

hist(rtnorm(R, b = 0), freq= FALSE, main = "", xlab = "", ylab = "")
curve(dtnorm(x, b = 0), -5, 5, col = "red", add = TRUE)

hist(rtnorm(R, a = 0, b = 1), freq= FALSE, main = "", xlab = "", ylab = "")
curve(dtnorm(x, a = 0, b = 1), -1, 2, col = "red", add = TRUE)

hist(rtnorm(R, a = -1, b = 0), freq= FALSE, main = "", xlab = "", ylab = "")
curve(dtnorm(x, a = -1, b = 0), -2, 2, col = "red", add = TRUE)

hist(rtnorm(R, mean = -6, a = 0), freq= FALSE, main = "", xlab = "", ylab = "")
curve(dtnorm(x, mean = -6, a = 0), -2, 1, col = "red", add = TRUE)

hist(rtnorm(R, mean = 8, b = 0), freq= FALSE, main = "", xlab = "", ylab = "")
curve(dtnorm(x, mean = 8, b = 0), -2, 1, col = "red", add = TRUE)

hist(rtnorm(R, a = 3, b = 5), freq= FALSE, main = "", xlab = "", ylab = "")
curve(dtnorm(x, a = 3, b = 5), 2, 5, col = "red", add = TRUE)

par(partmp)

</code></pre>

<hr>
<h2 id='TruncPoisson'>Truncated Poisson distribution</h2><span id='topic+TruncPoisson'></span><span id='topic+dtpois'></span><span id='topic+ptpois'></span><span id='topic+qtpois'></span><span id='topic+rtpois'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for the truncated Poisson distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtpois(x, lambda, a = -Inf, b = Inf, log = FALSE)

ptpois(q, lambda, a = -Inf, b = Inf, lower.tail = TRUE, log.p = FALSE)

qtpois(p, lambda, a = -Inf, b = Inf, lower.tail = TRUE, log.p = FALSE)

rtpois(n, lambda, a = -Inf, b = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TruncPoisson_+3A_x">x</code>, <code id="TruncPoisson_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="TruncPoisson_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) means.</p>
</td></tr>
<tr><td><code id="TruncPoisson_+3A_a">a</code>, <code id="TruncPoisson_+3A_b">b</code></td>
<td>
<p>lower and upper truncation points (<code>a &lt; x &lt;= b</code>).</p>
</td></tr>
<tr><td><code id="TruncPoisson_+3A_log">log</code>, <code id="TruncPoisson_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="TruncPoisson_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="TruncPoisson_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="TruncPoisson_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Plackett, R.L. (1953). The truncated Poisson distribution.
Biometrics, 9(4), 485-488.
</p>
<p>Singh, J. (1978). A characterization of positive Poisson distribution and
its statistical application.
SIAM Journal on Applied Mathematics, 34(3), 545-548.
</p>
<p>Dalgaard, P. (May 1, 2005). [R] simulate zero-truncated Poisson distribution.
R-help mailing list.
<a href="https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html">https://stat.ethz.ch/pipermail/r-help/2005-May/070680.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rtpois(1e5, 14, 16)
xx &lt;- seq(-1, 50)
plot(prop.table(table(x)))
lines(xx, dtpois(xx, 14, 16), col = "red")
hist(ptpois(x, 14, 16))

xx &lt;- seq(0, 50, by = 0.01)
plot(ecdf(x))
lines(xx, ptpois(xx, 14, 16), col = "red", lwd = 2)

uu &lt;- seq(0, 1, by = 0.001)
lines(qtpois(uu, 14, 16), uu, col = "blue", lty = 2)

# Zero-truncated Poisson

x &lt;- rtpois(1e5, 5, 0)
xx &lt;- seq(-1, 50)
plot(prop.table(table(x)))
lines(xx, dtpois(xx, 5, 0), col = "red")
hist(ptpois(x, 5, 0))

xx &lt;- seq(0, 50, by = 0.01)
plot(ecdf(x))
lines(xx, ptpois(xx, 5, 0), col = "red", lwd = 2)
lines(qtpois(uu, 5, 0), uu, col = "blue", lty = 2)

</code></pre>

<hr>
<h2 id='TukeyLambda'>Tukey lambda distribution</h2><span id='topic+TukeyLambda'></span><span id='topic+qtlambda'></span><span id='topic+rtlambda'></span>

<h3>Description</h3>

<p>Quantile function, and random generation for the Tukey lambda
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtlambda(p, lambda, lower.tail = TRUE, log.p = FALSE)

rtlambda(n, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TukeyLambda_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="TukeyLambda_+3A_lambda">lambda</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="TukeyLambda_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="TukeyLambda_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="TukeyLambda_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tukey lambda distribution is a continuous probability distribution defined in terms
of its quantile function. It is typically used to identify other distributions.
</p>
<p>Quantile function:
</p>
<p style="text-align: center;"><code class="reqn">F^{-1}(p) = \left\{\begin{array}{ll}
\frac{1}{\lambda} [p^\lambda - (1-p)^\lambda] &amp; \lambda \ne 0 \\
\log(\frac{p}{1-p}) &amp; \lambda = 0
\end{array}\right.
</code>
</p>



<h3>References</h3>

<p>Joiner, B.L., &amp; Rosenblatt, J.R. (1971).
Some properties of the range in samples from Tukey's symmetric lambda distributions.
Journal of the American Statistical Association, 66(334), 394-399.
</p>
<p>Hastings Jr, C., Mosteller, F., Tukey, J.W., &amp; Winsor, C.P. (1947).
Low moments for small samples: a comparative study of order statistics.
The Annals of Mathematical Statistics, 413-426.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pp = seq(0, 1, by = 0.001)
partmp &lt;- par(mfrow = c(2,3))
plot(qtlambda(pp, -1), pp, type = "l", main = "lambda = -1 (Cauchy)")
plot(qtlambda(pp, 0), pp, type = "l", main = "lambda = 0 (logistic)")
plot(qtlambda(pp, 0.14), pp, type = "l", main = "lambda = 0.14 (normal)")
plot(qtlambda(pp, 0.5), pp, type = "l", main = "lambda = 0.5 (concave)")
plot(qtlambda(pp, 1), pp, type = "l", main = "lambda = 1 (uniform)")
plot(qtlambda(pp, 2), pp, type = "l", main = "lambda = 2 (uniform)")

hist(rtlambda(1e5, -1), freq = FALSE, main = "lambda = -1 (Cauchy)")
hist(rtlambda(1e5, 0), freq = FALSE, main = "lambda = 0 (logistic)")
hist(rtlambda(1e5, 0.14), freq = FALSE, main = "lambda = 0.14 (normal)")
hist(rtlambda(1e5, 0.5), freq = FALSE, main = "lambda = 0.5 (concave)")
hist(rtlambda(1e5, 1), freq = FALSE, main = "lambda = 1 (uniform)")
hist(rtlambda(1e5, 2), freq = FALSE, main = "lambda = 2 (uniform)")
par(partmp)

</code></pre>

<hr>
<h2 id='Wald'>Wald (inverse Gaussian) distribution</h2><span id='topic+Wald'></span><span id='topic+dwald'></span><span id='topic+pwald'></span><span id='topic+rwald'></span>

<h3>Description</h3>

<p>Density, distribution function and random generation
for the Wald distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwald(x, mu, lambda, log = FALSE)

pwald(q, mu, lambda, lower.tail = TRUE, log.p = FALSE)

rwald(n, mu, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wald_+3A_x">x</code>, <code id="Wald_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Wald_+3A_mu">mu</code>, <code id="Wald_+3A_lambda">lambda</code></td>
<td>
<p>location and shape parameters. Scale must be positive.</p>
</td></tr>
<tr><td><code id="Wald_+3A_log">log</code>, <code id="Wald_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Wald_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="Wald_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Wald_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \sqrt{\frac{\lambda}{2\pi x^3}} \exp\left( \frac{-\lambda(x-\mu)^2}{2\mu^2 x} \right)
</code>
</p>

<p>Cumulative distribution function
</p>
<p style="text-align: center;"><code class="reqn">
F(x) = \Phi\left(\sqrt{\frac{\lambda}{x}} \left(\frac{x}{\mu}-1 \right) \right) +
\exp\left(\frac{2\lambda}{\mu} \right) \Phi\left(\sqrt{\frac{\lambda}{x}}
\left(\frac{x}{\mu}+1 \right) \right)
</code>
</p>

<p>Random generation is done using the algorithm described by Michael, Schucany and Haas (1976).
</p>


<h3>References</h3>

<p>Michael, J.R., Schucany, W.R., and Haas, R.W. (1976).
Generating Random Variates Using Transformations with Multiple Roots.
The American Statistician, 30(2): 88-90.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rwald(1e5, 5, 16)
hist(x, 100, freq = FALSE)
curve(dwald(x, 5, 16), 0, 50, col = "red", add = TRUE)
hist(pwald(x, 5, 16))
plot(ecdf(x))
curve(pwald(x, 5, 16), 0, 50, col = "red", lwd = 2, add = TRUE)

</code></pre>

<hr>
<h2 id='ZIB'>Zero-inflated binomial distribution</h2><span id='topic+ZIB'></span><span id='topic+dzib'></span><span id='topic+pzib'></span><span id='topic+qzib'></span><span id='topic+rzib'></span>

<h3>Description</h3>

<p>Probability mass function and random generation
for the zero-inflated binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzib(x, size, prob, pi, log = FALSE)

pzib(q, size, prob, pi, lower.tail = TRUE, log.p = FALSE)

qzib(p, size, prob, pi, lower.tail = TRUE, log.p = FALSE)

rzib(n, size, prob, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZIB_+3A_x">x</code>, <code id="ZIB_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZIB_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="ZIB_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZIB_+3A_pi">pi</code></td>
<td>
<p>probability of extra zeros.</p>
</td></tr>
<tr><td><code id="ZIB_+3A_log">log</code>, <code id="ZIB_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ZIB_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="ZIB_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZIB_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \left\{\begin{array}{ll}
\pi + (1 - \pi) (1-p)^n &amp; x = 0 \\
(1 - \pi) {n \choose x} p^x (1-p)^{n-x} &amp; x &gt; 0 \\
\end{array}\right.
</code>
</p>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+Binomial">Binomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rzib(1e5, 10, 0.6, 0.33)
xx &lt;- -2:20
plot(prop.table(table(x)), type = "h")
lines(xx, dzib(xx, 10, 0.6, 0.33), col = "red")

xx &lt;- seq(0, 20, by = 0.01)
plot(ecdf(x))
lines(xx, pzib(xx, 10, 0.6, 0.33), col = "red")

</code></pre>

<hr>
<h2 id='ZINB'>Zero-inflated negative binomial distribution</h2><span id='topic+ZINB'></span><span id='topic+dzinb'></span><span id='topic+pzinb'></span><span id='topic+qzinb'></span><span id='topic+rzinb'></span>

<h3>Description</h3>

<p>Probability mass function and random generation
for the zero-inflated negative binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzinb(x, size, prob, pi, log = FALSE)

pzinb(q, size, prob, pi, lower.tail = TRUE, log.p = FALSE)

qzinb(p, size, prob, pi, lower.tail = TRUE, log.p = FALSE)

rzinb(n, size, prob, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZINB_+3A_x">x</code>, <code id="ZINB_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZINB_+3A_size">size</code></td>
<td>
<p>target for number of successful trials, or dispersion
parameter (the shape parameter of the gamma mixing
distribution). Must be strictly positive, need not be
integer.</p>
</td></tr>
<tr><td><code id="ZINB_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="ZINB_+3A_pi">pi</code></td>
<td>
<p>probability of extra zeros.</p>
</td></tr>
<tr><td><code id="ZINB_+3A_log">log</code>, <code id="ZINB_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ZINB_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="ZINB_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZINB_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \left\{\begin{array}{ll}
\pi + (1 - \pi) p^r &amp; x = 0 \\
(1 - \pi) {x+r-1 \choose x} p^r (1-p)^x &amp; x &gt; 0 \\
\end{array}\right.
</code>
</p>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+NegBinomial">NegBinomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rzinb(1e5, 100, 0.6, 0.33)
xx &lt;- -2:200
plot(prop.table(table(x)), type = "h")
lines(xx, dzinb(xx, 100, 0.6, 0.33), col = "red")

xx &lt;- seq(0, 200, by = 0.01)
plot(ecdf(x))
lines(xx, pzinb(xx, 100, 0.6, 0.33), col = "red")

</code></pre>

<hr>
<h2 id='ZIP'>Zero-inflated Poisson distribution</h2><span id='topic+ZIP'></span><span id='topic+dzip'></span><span id='topic+pzip'></span><span id='topic+qzip'></span><span id='topic+rzip'></span>

<h3>Description</h3>

<p>Probability mass function and random generation
for the zero-inflated Poisson distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dzip(x, lambda, pi, log = FALSE)

pzip(q, lambda, pi, lower.tail = TRUE, log.p = FALSE)

qzip(p, lambda, pi, lower.tail = TRUE, log.p = FALSE)

rzip(n, lambda, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ZIP_+3A_x">x</code>, <code id="ZIP_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="ZIP_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) means.</p>
</td></tr>
<tr><td><code id="ZIP_+3A_pi">pi</code></td>
<td>
<p>probability of extra zeros.</p>
</td></tr>
<tr><td><code id="ZIP_+3A_log">log</code>, <code id="ZIP_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="ZIP_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>
otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="ZIP_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="ZIP_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>,
the length is taken to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probability density function
</p>
<p style="text-align: center;"><code class="reqn">
f(x) = \left\{\begin{array}{ll}
\pi + (1 - \pi) e^{-\lambda} &amp; x = 0 \\
(1 - \pi) \frac{\lambda^{x} e^{-\lambda}} {x!} &amp; x &gt; 0 \\
\end{array}\right.
</code>
</p>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+Poisson">Poisson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rzip(1e5, 6, 0.33)
xx &lt;- -2:20
plot(prop.table(table(x)), type = "h")
lines(xx, dzip(xx, 6, 0.33), col = "red")

xx &lt;- seq(0, 20, by = 0.01)
plot(ecdf(x))
lines(xx, pzip(xx, 6, 0.33), col = "red")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
