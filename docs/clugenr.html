<!DOCTYPE html><html><head><title>Help for package clugenr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clugenr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clugenr-package'><p>clugenr: Multidimensional Cluster Generation Using Support Lines</p></a></li>
<li><a href='#angle_btw'><p>Angle between two \(n\)-dimensional vectors.</p></a></li>
<li><a href='#angle_deltas'><p>Get angles between average cluster direction and cluster-supporting lines</p></a></li>
<li><a href='#clucenters'><p>Determine cluster centers using the uniform distribution</p></a></li>
<li><a href='#clugen'><p>Generate multidimensional clusters</p></a></li>
<li><a href='#clumerge'><p>Merges the fields (specified in <code>fields</code>) of two or more data sets</p></a></li>
<li><a href='#clupoints_n'><p>Create points from their projections on a cluster-supporting line</p></a></li>
<li><a href='#clupoints_n_1'><p>Create points from their projections on a cluster-supporting line</p></a></li>
<li><a href='#clupoints_n_1_template'><p>Create points from their projections on a cluster-supporting line</p></a></li>
<li><a href='#clusizes'><p>Determine cluster sizes, i.e., the number of points in each cluster</p></a></li>
<li><a href='#fix_empty'><p>Certify that, given enough points, no clusters are left empty</p></a></li>
<li><a href='#fix_num_points'><p>Certify that array values add up to a specific total</p></a></li>
<li><a href='#gdim'><p>Returns the actual dimensions of the input</p></a></li>
<li><a href='#llengths'><p>Determine length of cluster-supporting lines</p></a></li>
<li><a href='#points_on_line'><p>Determine coordinates of points on a line</p></a></li>
<li><a href='#rand_ortho_vector'><p>Get a random unit vector orthogonal to <code>u</code>.</p></a></li>
<li><a href='#rand_unit_vector'><p>Get a random unit vector with <code>num_dims</code> components.</p></a></li>
<li><a href='#rand_vector_at_angle'><p>Get a random unit vector at a given angle with another vector.</p></a></li>
<li><a href='#tprom'><p>Generality of types, by increasing order</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multidimensional Cluster Generation Using Support Lines</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the clugen algorithm for generating
    multidimensional clusters with arbitrary distributions. Each cluster is
    supported by a line segment, the position, orientation and length of which
    guide where the respective points are placed. This package is described in
    Fachada &amp; de Andrade (2023) &lt;<a href="https://doi.org/10.1016%2Fj.knosys.2023.110836">doi:10.1016/j.knosys.2023.110836</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>crul, devtools, ggplot2, knitr, lintr, patchwork, prettydoc,
rgl, rmarkdown, roxygen2, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://clugen.github.io/clugenr/">https://clugen.github.io/clugenr/</a>,
<a href="https://github.com/clugen/clugenr">https://github.com/clugen/clugenr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/clugen/clugenr/issues">https://github.com/clugen/clugenr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 11:56:39 UTC; nuno</td>
</tr>
<tr>
<td>Author:</td>
<td>Nuno Fachada <a href="https://orcid.org/0000-0002-8487-5837"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nuno Fachada &lt;faken@fakenmc.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-11 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clugenr-package'>clugenr: Multidimensional Cluster Generation Using Support Lines</h2><span id='topic+clugenr'></span><span id='topic+clugenr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>An implementation of the clugen algorithm for generating multidimensional clusters with arbitrary distributions. Each cluster is supported by a line segment, the position, orientation and length of which guide where the respective points are placed. This package is described in Fachada &amp; de Andrade (2023) <a href="https://doi.org/10.1016/j.knosys.2023.110836">doi:10.1016/j.knosys.2023.110836</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nuno Fachada <a href="mailto:faken@fakenmc.com">faken@fakenmc.com</a> (<a href="https://orcid.org/0000-0002-8487-5837">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://clugen.github.io/clugenr/">https://clugen.github.io/clugenr/</a>
</p>
</li>
<li> <p><a href="https://github.com/clugen/clugenr">https://github.com/clugen/clugenr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/clugen/clugenr/issues">https://github.com/clugen/clugenr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='angle_btw'>Angle between two \(n\)-dimensional vectors.</h2><span id='topic+angle_btw'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Typically, the angle between two vectors <code>v1</code> and <code>v2</code> can be obtained with:
</p>
<div class="sourceCode R"><pre>acos((v1 %*% v2) / (norm(v1, "2") * norm(v2, "2")))
</pre></div>
<p>However, this approach is numerically unstable. The version provided here is
numerically stable and based on the <a href="https://github.com/JeffreySarnoff/AngleBetweenVectors.jl">Angle Between Vectors</a>
Julia package by Jeffrey Sarnoff (MIT license), implementing an algorithm
provided by Prof. W. Kahan in
<a href="https://people.eecs.berkeley.edu/~wkahan/MathH110/Cross.pdf">these notes</a>
(see page 15).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle_btw(v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle_btw_+3A_v1">v1</code></td>
<td>
<p>First vector.</p>
</td></tr>
<tr><td><code id="angle_btw_+3A_v2">v2</code></td>
<td>
<p>Second vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Angle between <code>v1</code> and <code>v2</code> in radians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>angle_btw(c(1.0, 1.0, 1.0, 1.0), c(1.0, 0.0, 0.0, 0.0)) * 180 / pi
</code></pre>

<hr>
<h2 id='angle_deltas'>Get angles between average cluster direction and cluster-supporting lines</h2><span id='topic+angle_deltas'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Determine the angles between the average cluster direction and the
cluster-supporting lines. These angles are obtained from a wrapped normal
distribution (\(\mu=0\), \(\sigma=\) <code>angle_disp</code> ) with
support in the interval \(\left[-\pi/2,\pi/2\right]\).
Note this is different from the standard wrapped normal distribution, the
support of which is given by the interval
\(\left[-\pi,\pi\right]\).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle_deltas(num_clusters, angle_disp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle_deltas_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="angle_deltas_+3A_angle_disp">angle_disp</code></td>
<td>
<p>Angle dispersion, in radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Angles between the average cluster direction and the
cluster-supporting lines, given in radians in the interval
\(\left[-\pi/2,\pi/2\right]\)
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
arad &lt;- angle_deltas(4, pi / 8) # Angle dispersion of 22.5 degrees
arad                            # What angles deltas did we get?
arad * 180 / pi                 #  Show angle deltas in degrees
</code></pre>

<hr>
<h2 id='clucenters'>Determine cluster centers using the uniform distribution</h2><span id='topic+clucenters'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Determine cluster centers using the uniform distribution, taking into account
the number of clusters (<code>num_clusters</code>) and the average cluster separation
(<code>clu_sep</code>).
</p>
<p>More specifically, let \(c=\)<code>num_clusters</code>,
\(\mathbf{s}=\)<code>clu_sep</code>, \(\mathbf{o}=\)<code>clu_offset</code>,
\(n=\)<code>length(clu_sep)</code> (i.e., number of dimensions). Cluster centers
are obtained according to the following equation:
</p>
\[\mathbf{C}=c\mathbf{U}\cdot\operatorname{diag}(\mathbf{s}) +
\mathbf{1}\,\mathbf{o}^T\]
<p>where \(\mathbf{C}\) is the \(c \times n\) matrix of
cluster centers, \(\mathbf{U}\) is an \(c \times n\) matrix
of random values drawn from the uniform distribution between -0.5 and 0.5,
and \(\mathbf{1}\) is an \(c \times 1\) vector with all
entries equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clucenters(num_clusters, clu_sep, clu_offset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clucenters_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="clucenters_+3A_clu_sep">clu_sep</code></td>
<td>
<p>Average cluster separation (\(n \times 1\) vector).</p>
</td></tr>
<tr><td><code id="clucenters_+3A_clu_offset">clu_offset</code></td>
<td>
<p>Cluster offsets (\(n \times 1\) vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A \(c \times n\) matrix containing the cluster centers.
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(321)
clucenters(3, c(30, 10), c(-50,50))
</code></pre>

<hr>
<h2 id='clugen'>Generate multidimensional clusters</h2><span id='topic+clugen'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>This is the main function of <strong>clugenr</strong>, and possibly the only function most
users will need.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clugen(
  num_dims,
  num_clusters,
  num_points,
  direction,
  angle_disp,
  cluster_sep,
  llength,
  llength_disp,
  lateral_disp,
  allow_empty = FALSE,
  cluster_offset = NA,
  proj_dist_fn = "norm",
  point_dist_fn = "n-1",
  clusizes_fn = clusizes,
  clucenters_fn = clucenters,
  llengths_fn = llengths,
  angle_deltas_fn = angle_deltas,
  seed = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clugen_+3A_num_dims">num_dims</code></td>
<td>
<p>Number of dimensions.</p>
</td></tr>
<tr><td><code id="clugen_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Number of clusters to generate.</p>
</td></tr>
<tr><td><code id="clugen_+3A_num_points">num_points</code></td>
<td>
<p>Total number of points to generate.</p>
</td></tr>
<tr><td><code id="clugen_+3A_direction">direction</code></td>
<td>
<p>Average direction of the cluster-supporting lines. Can be
a vector of length <code>num_dims</code> (same direction for all clusters) or a
matrix of size <code>num_clusters</code> x <code>num_dims</code> (one direction per cluster).</p>
</td></tr>
<tr><td><code id="clugen_+3A_angle_disp">angle_disp</code></td>
<td>
<p>Angle dispersion of cluster-supporting lines (radians).</p>
</td></tr>
<tr><td><code id="clugen_+3A_cluster_sep">cluster_sep</code></td>
<td>
<p>Average cluster separation in each dimension (vector of
length <code>num_dims</code>).</p>
</td></tr>
<tr><td><code id="clugen_+3A_llength">llength</code></td>
<td>
<p>Average length of cluster-supporting lines.</p>
</td></tr>
<tr><td><code id="clugen_+3A_llength_disp">llength_disp</code></td>
<td>
<p>Length dispersion of cluster-supporting lines.</p>
</td></tr>
<tr><td><code id="clugen_+3A_lateral_disp">lateral_disp</code></td>
<td>
<p>Cluster lateral dispersion, i.e., dispersion of points
from their projection on the cluster-supporting line.</p>
</td></tr>
<tr><td><code id="clugen_+3A_allow_empty">allow_empty</code></td>
<td>
<p>Allow empty clusters? <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="clugen_+3A_cluster_offset">cluster_offset</code></td>
<td>
<p>Offset to add to all cluster centers (vector of length
<code>num_dims</code>). By default there will be no offset.</p>
</td></tr>
<tr><td><code id="clugen_+3A_proj_dist_fn">proj_dist_fn</code></td>
<td>
<p>Distribution of point projections along
cluster-supporting lines, with three possible values:
</p>

<ul>
<li> <p><code>"norm"</code> (default): Distribute point projections along lines using a normal
distribution (\(\mu=\) <em>line_center</em>,
\(\sigma=\) <code>llength/6</code> ).
</p>
</li>
<li> <p><code>"unif"</code>: Distribute points uniformly along the line.
</p>
</li>
<li><p> User-defined function, which accepts two parameters, line length (<code>double</code>)
and number of points (<code>integer</code>), and returns a vector containing the
distance of each point projection to the center of the line. For example,
the <code>"norm"</code> option roughly corresponds to
<code>function(l, n) stats::rnorm(n, sd = l / 6)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="clugen_+3A_point_dist_fn">point_dist_fn</code></td>
<td>
<p>Controls how the final points are created from their
projections on the cluster-supporting lines, with three possible values:
</p>

<ul>
<li> <p><code>"n-1"</code> (default): Final points are placed on a hyperplane orthogonal to
the cluster-supporting line, centered at each point's projection, using the
normal distribution (\(\mu=0\),
\(\sigma=\) <code>lateral_disp</code> ). This is done by the <a href="#topic+clupoints_n_1">clupoints_n_1</a>
function.
</p>
</li>
<li> <p><code>"n"</code>: Final points are placed around their projection on the
cluster-supporting line using the normal distribution (\(\mu=0\),
\(\sigma=\) <code>lateral_disp</code> ). This is done by the <a href="#topic+clupoints_n">clupoints_n</a>
function.
</p>
</li>
<li><p> User-defined function: The user can specify a custom point placement
strategy by passing a function with the same signature as <a href="#topic+clupoints_n_1">clupoints_n_1</a>
and <a href="#topic+clupoints_n">clupoints_n</a>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="clugen_+3A_clusizes_fn">clusizes_fn</code></td>
<td>
<p>Distribution of cluster sizes. By default, cluster sizes
are determined by the <a href="#topic+clusizes">clusizes</a> function, which uses the normal distribution
(\(\mu=\) <code>num_points</code>/<code>num_clusters</code>, \(\sigma=\mu/3\)),
and assures that the final cluster sizes add up to <code>num_points</code>. This
parameter allows the user to specify a custom function for this purpose,
which must follow <a href="#topic+clusizes">clusizes</a> signature. Note that custom functions are not
required to strictly obey the <code>num_points</code> parameter. Alternatively, the user
can specify a vector of cluster sizes directly.</p>
</td></tr>
<tr><td><code id="clugen_+3A_clucenters_fn">clucenters_fn</code></td>
<td>
<p>Distribution of cluster centers. By default, cluster
centers are determined by the <a href="#topic+clucenters">clucenters</a> function, which uses the uniform
distribution, and takes into account the <code>num_clusters</code> and <code>cluster_sep</code>
parameters for generating well-distributed cluster centers. This parameter
allows the user to specify a custom function for this purpose, which must
follow <a href="#topic+clucenters">clucenters</a> signature. Alternatively, the user can specify a matrix
of size <code>num_clusters</code> x <code>num_dims</code> with the exact cluster centers.</p>
</td></tr>
<tr><td><code id="clugen_+3A_llengths_fn">llengths_fn</code></td>
<td>
<p>Distribution of line lengths. By default, the lengths of
cluster-supporting lines are determined by the <a href="#topic+llengths">llengths</a> function, which
uses the folded normal distribution (\(\mu=\) <code>llength</code>,
\(\sigma=\) <code>llength_disp</code> ). This parameter allows the user to
specify a custom function for this purpose, which must follow <a href="#topic+llengths">llengths</a>
signature. Alternatively, the user can specify a vector of line lengths
directly.</p>
</td></tr>
<tr><td><code id="clugen_+3A_angle_deltas_fn">angle_deltas_fn</code></td>
<td>
<p>Distribution of line angle differences with respect to
<code>direction</code>. By default, the angles between the main <code>direction</code> of each
cluster and the final directions of their cluster-supporting lines are
determined by the <a href="#topic+angle_deltas">angle_deltas</a> function, which uses the wrapped normal
distribution (\(\mu=0\), \(\sigma=\) <code>angle_disp</code> ) with
support in the interval \(\left[-\pi/2,\pi/2\right]\). This
parameter allows the user to specify a custom function for this purpose,
which must follow <a href="#topic+angle_deltas">angle_deltas</a> signature. Alternatively, the user can
specify a vector of angle deltas directly.</p>
</td></tr>
<tr><td><code id="clugen_+3A_seed">seed</code></td>
<td>
<p>An integer used to initialize the PRNG, allowing for reproducible
results. If specified, <code>seed</code> is simply passed to <a href="base.html#topic+set.seed">set.seed</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a custom function was given in the <code>clusizes_fn</code> parameter, it is
possible that <code>num_points</code> may have a different value than what was
specified in the <code>num_points</code> parameter.
</p>
<p>The terms &quot;average&quot; and &quot;dispersion&quot; refer to measures of central
tendency and statistical dispersion, respectively. Their exact meaning
depends on the optional arguments.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<ul>
<li> <p><code>points</code>: A <code>num_points</code> x <code>num_dims</code> matrix with the generated points for
all clusters.
</p>
</li>
<li> <p><code>clusters</code>: A <code>num_points</code> factor vector indicating which cluster
each point in <code>points</code> belongs to.
</p>
</li>
<li> <p><code>projections</code>: A <code>num_points</code> x <code>num_dims</code> matrix with the point
projections on the cluster-supporting lines.
</p>
</li>
<li> <p><code>sizes</code>: A <code>num_clusters</code> x 1 vector with the number of points in
each cluster.
</p>
</li>
<li> <p><code>centers</code>: A <code>num_clusters</code> x <code>num_dims</code> matrix with the
coordinates of the cluster centers.
</p>
</li>
<li> <p><code>directions</code>: A <code>num_clusters</code> x <code>num_dims</code> matrix with the final
direction of each cluster-supporting line.
</p>
</li>
<li> <p><code>angles</code>: A <code>num_clusters</code> x 1 vector with the angles between the
cluster-supporting lines and the main direction.
</p>
</li>
<li> <p><code>lengths</code>: A <code>num_clusters</code> x 1 vector with the lengths of the
cluster-supporting lines.
</p>
</li></ul>



<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2D example
x &lt;- clugen(2, 5, 1000, c(1, 3), 0.5, c(10, 10), 8, 1.5, 2)
graphics::plot(x$points, col = x$clusters, xlab = "x", ylab = "y", asp = 1)
# 3D example
x &lt;- clugen(3, 5, 1000, c(2, 3, 4), 0.5, c(15, 13, 14), 7, 1, 2)
</code></pre>

<hr>
<h2 id='clumerge'>Merges the fields (specified in <code>fields</code>) of two or more data sets</h2><span id='topic+clumerge'></span>

<h3>Description</h3>

<p>Merges the fields (specified in <code>fields</code>) of two or more data sets (passed as
lists). The fields to be merged need to have the same number of columns. The
corresponding merged field will contain the rows of the fields to be merged,
and will have a common &quot;supertype&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clumerge(..., fields = c("points", "clusters"), clusters_field = "clusters")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clumerge_+3A_...">...</code></td>
<td>
<p>One or more cluster data sets (in the form of lists) whose
<code>fields</code> are to be merged.</p>
</td></tr>
<tr><td><code id="clumerge_+3A_fields">fields</code></td>
<td>
<p>Fields to be merged, which must exist in the data sets given in
<code>...</code>.</p>
</td></tr>
<tr><td><code id="clumerge_+3A_clusters_field">clusters_field</code></td>
<td>
<p>Field containing the integer cluster labels. If
specified, cluster assignments in individual datasets will be updated in the
merged dataset so that clusters are considered separate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>clusters_field</code> parameter specifies a field containing integers that
identify the cluster to which the respective points belongs to. If
<code>clusters_field</code> is specified (by default it's specified as <code>"clusters"</code>),
cluster assignments in individual datasets will be updated in the merged
dataset so that clusters are considered separate. This parameter can be set
to <code>NA</code>, in which case no field will be considered as a special cluster
assignments field.
</p>
<p>This function can be used to merge data sets generated with the <a href="#topic+clugen">clugen</a>
function, by default merging the <code>points</code> and <code>clusters</code> fields in those data
sets. It also works with arbitrary data by specifying alternative fields in
the <code>fields</code> parameter. It can be used, for example, to merge third-party
data with <a href="#topic+clugen">clugen</a>-generated data.
</p>


<h3>Value</h3>

<p>A list whose fields consist of the merged fields in the original
data sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- clugen(2, 5, 100, c(1, 3), 0.5, c(10, 10), 8, 1.5, 2)
b &lt;- clugen(2, 3, 250, c(-1, 3), 0.5, c(13, 14), 7, 1, 2)
ab &lt;- clumerge(a, b)
</code></pre>

<hr>
<h2 id='clupoints_n'>Create points from their projections on a cluster-supporting line</h2><span id='topic+clupoints_n'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Each point is placed around its projection using the normal distribution
(\(\mu=0\), \(\sigma=\) <code>lat_disp</code> ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clupoints_n(projs, lat_disp, line_len, clu_dir, clu_ctr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clupoints_n_+3A_projs">projs</code></td>
<td>
<p>Point projections on the cluster-supporting line
(\(p \times n\) matrix).</p>
</td></tr>
<tr><td><code id="clupoints_n_+3A_lat_disp">lat_disp</code></td>
<td>
<p>Standard deviation for the normal distribution, i.e., cluster
lateral dispersion.</p>
</td></tr>
<tr><td><code id="clupoints_n_+3A_line_len">line_len</code></td>
<td>
<p>Length of cluster-supporting line (ignored).</p>
</td></tr>
<tr><td><code id="clupoints_n_+3A_clu_dir">clu_dir</code></td>
<td>
<p>Direction of the cluster-supporting line.</p>
</td></tr>
<tr><td><code id="clupoints_n_+3A_clu_ctr">clu_ctr</code></td>
<td>
<p>Center position of the cluster-supporting line (ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function's main intended use is by the main <a href="#topic+clugen">clugen</a> function,
generating the final points when the <code>point_dist_fn</code> parameter is set to
<code>"n"</code>.
</p>


<h3>Value</h3>

<p>Generated points (\(p \times n\) matrix).
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
ctr &lt;- c(0, 0)
dir &lt;- c(1, 0)
pdist &lt;- c(-0.5, -0.2, 0.1, 0.3)
proj &lt;- points_on_line(ctr, dir, pdist)
clupoints_n(proj, 0.01, NA, dir, NA)
</code></pre>

<hr>
<h2 id='clupoints_n_1'>Create points from their projections on a cluster-supporting line</h2><span id='topic+clupoints_n_1'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Each point is placed on a hyperplane orthogonal to that line and centered at
the point's projection, using the normal distribution (\(\mu=0\),
\(\sigma=\) <code>lat_disp</code> ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clupoints_n_1(projs, lat_disp, line_len, clu_dir, clu_ctr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clupoints_n_1_+3A_projs">projs</code></td>
<td>
<p>Point projections on the cluster-supporting line
(\(p \times n\) matrix).</p>
</td></tr>
<tr><td><code id="clupoints_n_1_+3A_lat_disp">lat_disp</code></td>
<td>
<p>Standard deviation for the normal distribution, i.e., cluster
lateral dispersion.</p>
</td></tr>
<tr><td><code id="clupoints_n_1_+3A_line_len">line_len</code></td>
<td>
<p>Length of cluster-supporting line (ignored).</p>
</td></tr>
<tr><td><code id="clupoints_n_1_+3A_clu_dir">clu_dir</code></td>
<td>
<p>Direction of the cluster-supporting line.</p>
</td></tr>
<tr><td><code id="clupoints_n_1_+3A_clu_ctr">clu_ctr</code></td>
<td>
<p>Center position of the cluster-supporting line (ignored).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function's main intended use is by the main <a href="#topic+clugen">clugen</a> function,
generating the final points when the <code>point_dist_fn</code> parameter is set to
<code>"n-1"</code>.
</p>


<h3>Value</h3>

<p>Generated points (\(p \times n\) matrix).
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
ctr &lt;- c(0, 0)
dir &lt;- c(1, 0)
pdist &lt;- c(-0.5, -0.2, 0.1, 0.3)
proj &lt;- points_on_line(ctr, dir, pdist)
clupoints_n_1(proj, 0.1, NA, dir, NA)
</code></pre>

<hr>
<h2 id='clupoints_n_1_template'>Create points from their projections on a cluster-supporting line</h2><span id='topic+clupoints_n_1_template'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Generate points from their \(n\)-dimensional projections on a
cluster-supporting line, placing each point on a hyperplane orthogonal to
that line and centered at the point's projection. The function specified in
<code>dist_fn</code> is used to perform the actual placement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clupoints_n_1_template(projs, lat_disp, clu_dir, dist_fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clupoints_n_1_template_+3A_projs">projs</code></td>
<td>
<p>Point projections on the cluster-supporting line
(\(p \times n\) matrix).</p>
</td></tr>
<tr><td><code id="clupoints_n_1_template_+3A_lat_disp">lat_disp</code></td>
<td>
<p>Dispersion of points from their projection.</p>
</td></tr>
<tr><td><code id="clupoints_n_1_template_+3A_clu_dir">clu_dir</code></td>
<td>
<p>Direction of the cluster-supporting line (unit vector).</p>
</td></tr>
<tr><td><code id="clupoints_n_1_template_+3A_dist_fn">dist_fn</code></td>
<td>
<p>Function to place points on a second line, orthogonal to the
first.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by <a href="#topic+clupoints_n_1">clupoints_n_1</a> and may be useful for
constructing user-defined final point placement strategies for the
<code>point_dist_fn</code> parameter of the main <a href="#topic+clugen">clugen</a> function.
</p>


<h3>Value</h3>

<p>Generated points (\(p \times n\) matrix).
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
ctr &lt;- c(0, 0)
dir &lt;- c(1, 0)
pdist &lt;- c(-0.5, -0.2, 0.1, 0.3)
proj &lt;- points_on_line(ctr, dir, pdist)
clupoints_n_1_template(proj, 0, dir, function(p, l) stats::runif(p))
</code></pre>

<hr>
<h2 id='clusizes'>Determine cluster sizes, i.e., the number of points in each cluster</h2><span id='topic+clusizes'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Cluster sizes are determined using the normal distribution
(\(\mu=\) <code>num_points</code> \(/\) <code>num_clusters</code>,
\(\sigma=\mu/3\)), and then assuring that the final cluster sizes
add up to <code>num_points</code> via the <a href="#topic+fix_num_points">fix_num_points</a> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusizes(num_clusters, num_points, allow_empty)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusizes_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="clusizes_+3A_num_points">num_points</code></td>
<td>
<p>Total number of points.</p>
</td></tr>
<tr><td><code id="clusizes_+3A_allow_empty">allow_empty</code></td>
<td>
<p>Allow empty clusters?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of points in each cluster (vector of length <code>num_clusters</code>).
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
sizes &lt;- clusizes(4, 1000, TRUE)
sizes
sum(sizes)
</code></pre>

<hr>
<h2 id='fix_empty'>Certify that, given enough points, no clusters are left empty</h2><span id='topic+fix_empty'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Certifies that, given enough points, no clusters are left empty. This is done
by removing a point from the largest cluster and adding it to an empty
cluster while there are empty clusters. If the total number of points is
smaller than the number of clusters (or if the <code>allow_empty</code> parameter is set
to <code>TRUE</code>), this function does nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_empty(clu_num_points, allow_empty = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_empty_+3A_clu_num_points">clu_num_points</code></td>
<td>
<p>Number of points in each cluster (vector of size
\(c\)), where \(c\) is the number of clusters.</p>
</td></tr>
<tr><td><code id="fix_empty_+3A_allow_empty">allow_empty</code></td>
<td>
<p>Allow empty clusters?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by <a href="#topic+clusizes">clusizes</a> and might be useful for custom
cluster sizing implementations given as the <code>clusizes_fn</code> parameter of the
main <a href="#topic+clugen">clugen</a> function.
</p>


<h3>Value</h3>

<p>Number of points in each cluster, after being fixed by this function
(vector of size \(c\)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clusters &lt;- c(3, 4, 5, 0, 0)    # A vector with some empty elements
clusters &lt;- fix_empty(clusters) # Apply this function
clusters                        # Check that there's no more empty elements
</code></pre>

<hr>
<h2 id='fix_num_points'>Certify that array values add up to a specific total</h2><span id='topic+fix_num_points'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Certifies that the values in the <code>clu_num_points</code> array, i.e. the number of
points in each cluster, add up to <code>num_points</code>. If this is not the case, the
<code>clu_num_points</code> array is modified in-place, incrementing the value
corresponding to the smallest cluster while
<code>sum(clu_num_points) &lt; num_points</code>, or decrementing the value corresponding
to the largest cluster while <code>sum(clu_num_points) &gt; num_points</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_num_points(clu_num_points, num_points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_num_points_+3A_clu_num_points">clu_num_points</code></td>
<td>
<p>Number of points in each cluster (vector of size
\(c\)), where \(c\) is the number of clusters.</p>
</td></tr>
<tr><td><code id="fix_num_points_+3A_num_points">num_points</code></td>
<td>
<p>The expected total number of points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by <a href="#topic+clusizes">clusizes</a> and might be useful for
custom cluster sizing implementations given as the <code>clusizes_fn</code> parameter of
the main <a href="#topic+clugen">clugen</a> function.
</p>


<h3>Value</h3>

<p>Number of points in each cluster, after being fixed by this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clusters &lt;- c(1, 6, 3)                   # 10 total points
clusters &lt;- fix_num_points(clusters, 12) # But we want 12 total points
clusters                                 # Check that we now have 12 points
</code></pre>

<hr>
<h2 id='gdim'>Returns the actual dimensions of the input</h2><span id='topic+gdim'></span>

<h3>Description</h3>

<p>Gets the dimensions of the input <code>a</code>, returning <code>c(length(a), 1)</code> if
<code>dim(a) == NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdim(a)
</code></pre>

<hr>
<h2 id='llengths'>Determine length of cluster-supporting lines</h2><span id='topic+llengths'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Line lengths are determined using the folded normal distribution
(\(\mu=\) <code>llength</code>, \(\sigma=\) <code>llength_disp</code> ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llengths(num_clusters, llength, llength_disp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llengths_+3A_num_clusters">num_clusters</code></td>
<td>
<p>Number of clusters.</p>
</td></tr>
<tr><td><code id="llengths_+3A_llength">llength</code></td>
<td>
<p>Average line length.</p>
</td></tr>
<tr><td><code id="llengths_+3A_llength_disp">llength_disp</code></td>
<td>
<p>Line length dispersion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lengths of cluster-supporting lines (vector of size <code>num_clusters</code>).
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
llengths(4, 20, 3.5)
</code></pre>

<hr>
<h2 id='points_on_line'>Determine coordinates of points on a line</h2><span id='topic+points_on_line'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Determine coordinates of points on a line with <code>center</code> and <code>direction</code>,
based on the distances from the center given in <code>dist_center</code>.
</p>
<p>This works by using the vector formulation of the line equation assuming
<code>direction</code> is a \(n\)-dimensional unit vector. In other words,
considering \(\mathbf{d}=\) <code>as.matrix(direction)</code> (\(n \times
1\) vector), \(\mathbf{c}=\) <code>as.matrix(center)</code> (\(n
\times 1\) vector), and \(\mathbf{w}=\)
<code>as.matrix(dist_center)</code> (\(p \times 1\) vector), the coordinates
of points on the line are given by:
</p>
\[\mathbf{P}=\mathbf{1}\,\mathbf{c}^T + \mathbf{w}\mathbf{d}^T\]
<p>where \(\mathbf{P}\) is the \(p \times n\) matrix of point
coordinates on the line, and \(\mathbf{1}\) is a \(p \times 1\) vector with all entries equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>points_on_line(center, direction, dist_center)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="points_on_line_+3A_center">center</code></td>
<td>
<p>Center of the line (\(n\)-component vector).</p>
</td></tr>
<tr><td><code id="points_on_line_+3A_direction">direction</code></td>
<td>
<p>Line direction (\(n\)-component unit vector).</p>
</td></tr>
<tr><td><code id="points_on_line_+3A_dist_center">dist_center</code></td>
<td>
<p>Distance of each point to the center of the line
(\(n\)-component vector, where \(n\) is the number of points).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coordinates of points on the specified line
(\(p \times n\) matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points_on_line(c(5, 5), c(1, 0), seq(-4, 4, length.out=5)) # 2D, 5 points

points_on_line(c(-2, 0, 0, 2), c(0, 0, -1, 0), c(10, -10)) # 4D, 2 points
</code></pre>

<hr>
<h2 id='rand_ortho_vector'>Get a random unit vector orthogonal to <code>u</code>.</h2><span id='topic+rand_ortho_vector'></span>

<h3>Description</h3>

<p>Get a random unit vector orthogonal to <code>u</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_ortho_vector(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_ortho_vector_+3A_u">u</code></td>
<td>
<p>A unit vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random unit vector orthogonal to <code>u</code>.
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- stats::runif(3)      # Get a random 3D vector
r &lt;- r / norm(r, "2")     # Normalize it
o &lt;- rand_ortho_vector(r) # Get a random unit vector orthogonal to r
r %*% o            # Check that r and o are orthogonal (result should be ~0)
</code></pre>

<hr>
<h2 id='rand_unit_vector'>Get a random unit vector with <code>num_dims</code> components.</h2><span id='topic+rand_unit_vector'></span>

<h3>Description</h3>

<p>Get a random unit vector with <code>num_dims</code> components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_unit_vector(num_dims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_unit_vector_+3A_num_dims">num_dims</code></td>
<td>
<p>Number of components in vector (i.e. vector size).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random unit vector with <code>num_dims</code> components.
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rand_unit_vector(4)
norm(r, "2")
</code></pre>

<hr>
<h2 id='rand_vector_at_angle'>Get a random unit vector at a given angle with another vector.</h2><span id='topic+rand_vector_at_angle'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Get a random unit vector which is at <code>angle</code> radians of vector <code>u</code>.
Note that <code>u</code> is expected to be a unit vector itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand_vector_at_angle(u, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_vector_at_angle_+3A_u">u</code></td>
<td>
<p>Unit vector with \(n\) components.</p>
</td></tr>
<tr><td><code id="rand_vector_at_angle_+3A_angle">angle</code></td>
<td>
<p>Angle in radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Random unit vector with \(n\) components which is at <code>angle</code>
radians with vector <code>u</code>.
</p>


<h3>Note</h3>

<p>This function is stochastic. For reproducibility set a PRNG seed with
<a href="base.html#topic+set.seed">set.seed</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- c(1.0, 0, 0.5, -0.5)            # Define a 4D vector
u &lt;- u / norm(u, "2")                # Normalize the vector
v &lt;- rand_vector_at_angle(u, pi / 4) # Get a vector at 45 degrees
arad &lt;- acos((u %*% v) / norm(u,"2") * norm(v, "2")) # Get angle in radians
arad * 180 / pi # Convert to degrees, should be close to 45 degrees
</code></pre>

<hr>
<h2 id='tprom'>Generality of types, by increasing order</h2><span id='topic+tprom'></span>

<h3>Description</h3>

<p>Generality of types, by increasing order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tprom
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
