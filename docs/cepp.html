<!DOCTYPE html><html><head><title>Help for package cepp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cepp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cepp-package'>
<p>Context Driven Exploratory Projection Pursuit</p></a></li>
<li><a href='#bases'><p>Create random bases</p></a></li>
<li><a href='#caller'><p>Function to optimize the projection index</p></a></li>
<li><a href='#Colon'><p>Gene expression data from Alon et al. (1999)</p></a></li>
<li><a href='#CvM'><p>Projection Pursuit Indices based on the bivariate empirical distribution function.</p></a></li>
<li><a href='#evaluator'><p>Function to evaluate spatial quantiles</p></a></li>
<li><a href='#geodesic'><p>Functions for geodesic search</p></a></li>
<li><a href='#Olive oil measurements'><p>Olive oil samples from Italy</p></a></li>
<li><a href='#pp'><p>Creates the projection pursuit function.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Context Driven Exploratory Projection Pursuit</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-01-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohit Dayal</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mohit Dayal &lt;mohitdayal2000@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and Data to support Context Driven Exploratory Projection Pursuit.</td>
</tr>
<tr>
<td>Imports:</td>
<td>randtoolbox</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), trust</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-01-29 21:59:43 UTC; mohit</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-01-30 00:19:38</td>
</tr>
</table>
<hr>
<h2 id='cepp-package'>
Context Driven Exploratory Projection Pursuit
</h2><span id='topic+cepp-package'></span><span id='topic+cepp'></span>

<h3>Description</h3>

<p>Functions and Data to support Context Driven Exploratory Projection Pursuit.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> cepp</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Context Driven Exploratory Projection Pursuit</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-01-16</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Mohit Dayal</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Mohit Dayal &lt;mohitdayal2000@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Functions and Data to support Context Driven Exploratory Projection Pursuit.</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> randtoolbox</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> trust</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Mohit Dayal
</p>
<p>Maintainer: Mohit Dayal &lt;mohitdayal2000@gmail.com&gt;
</p>

<hr>
<h2 id='bases'>Create random bases</h2><span id='topic+basis_nearby'></span><span id='topic+basis_random'></span>

<h3>Description</h3>

<p>Generate bases.</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis_random(n, d = 2)
basis_nearby(alpha = 0.75, method = 'geodesic', d = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bases_+3A_n">n</code></td>
<td>
<p>The number of rows.</p>
</td></tr>
<tr><td><code id="bases_+3A_d">d</code></td>
<td>
<p>The number of columns.</p>
</td></tr>
<tr><td><code id="bases_+3A_alpha">alpha</code></td>
<td>
<p>How &quot;far&quot; away should the new matrix be generated?</p>
</td></tr>
<tr><td><code id="bases_+3A_method">method</code></td>
<td>
<p>How should be new matrix be found? One of <code>linear</code> or <code>geodesic</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>basis_random</code> returns a new orthonormal matrix of specified dimensions.
</p>
<p><code>basis_nearby</code> generates a function. Calling this function with a
matrix, hybridizes it with a new (randomly generated via
<code>basis_random</code>) orthonormal matrix, and returns it. 
</p>


<h3>Value</h3>

<p>For <code>basis_random</code>, a random orthonormal matrix of specified
dimensions.
</p>
<p>For <code>basis_nearby</code>, a function that can be used to generate new
matrices &quot;near&quot; the current matrix.</p>


<h3>Author(s)</h3>

<p>Both functions were originally taken from the <code>tourr</code>
package. The <code>basis_nearby</code> function was modified so the
parameters <code>alpha</code> and <code>method</code> can be set more conveniently
during optimization.</p>

<hr>
<h2 id='caller'>Function to optimize the projection index</h2><span id='topic+caller'></span>

<h3>Description</h3>

<p>This function provides an alternative way to optimize the projection
index, by moving along a geodesic path.</p>


<h3>Usage</h3>

<pre><code class='language-R'>caller(start, index, n, bases)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caller_+3A_start">start</code></td>
<td>
<p>The Starting Projection for the optimization.</p>
</td></tr>
<tr><td><code id="caller_+3A_index">index</code></td>
<td>
<p>The Projection Index function. Typically generated by a
call to the <code>pp</code> function.</p>
</td></tr>
<tr><td><code id="caller_+3A_n">n</code></td>
<td>
<p>The number of new bases to try at every stage of the
optimization. Needs to be an array of the same length as
<code>bases</code>. Typically, you either pass a constant vector, or you
use a vector with ascending entries, so that you can try more matrices
as the optimization proceeds.</p>
</td></tr>
<tr><td><code id="caller_+3A_bases">bases</code></td>
<td>
<p>The number of new bases desired. Actual number generated
may be lesser if optimization stalls.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an alternative way to optimize the projection
index. It moves the index along geodesic paths between randomly
generated nearby matrices, in hopes of uncovering peaks of the index
function. By experience, one can say that it can often reveal structure
missed by Simulated Annealing optimization.
</p>


<h3>Value</h3>

<p>A list of basis matrices, of length <code>bases</code> or shorter (if
the optimization stalls).</p>


<h3>Author(s)</h3>

<p>Mohit Dayal
</p>


<h3>See Also</h3>

<p>Colon</p>

<hr>
<h2 id='Colon'>Gene expression data from Alon et al. (1999)</h2><span id='topic+Colon'></span>

<h3>Description</h3>

<p>Gene expression data (2000 genes for 62 samples) from the
microarray experiments of Colon tissue samples of Alon et al. (1999). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Colon)
</code></pre>


<h3>Details</h3>

<p> This data set contains 62 samples 
with 2000 genes: 40 tumor tissues, coded 2 and 22 normal tissues, coded 1.  
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>a (62 x 2000) matrix giving the expression levels of 2000 
genes for the 62 Colon tissue samples. Each row corresponds to a patient, each column to a
gene.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>a numeric vector of length 62 giving the type of tissue sample (tumor or normal).</p>
</td></tr> 
<tr><td><code>gene.names</code></td>
<td>
<p>a vector containing the names of the 2000 genes for the gene
expression matrix <code>X</code>.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>The data are described in Alon et al. (1999) and can be freely
downloaded from 
<a href="http://microarray.princeton.edu/oncology/affydata/index.html">http://microarray.princeton.edu/oncology/affydata/index.html</a>.</p>


<h3>References</h3>

<p>Alon, U. and Barkai, N. and Notterman, D.A. and Gish, K. and Ybarra, S. and Mack, D. and Levine, A.J. (1999).
Broad patterns of gene expression revealed by clustering analysis of tumor and normal colon tissues probed by oligonucleotide arrays,
Proc. Natl. Acad. Sci. USA, 96(12), 6745&ndash;6750.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># how many samples and how many genes ?
data(Colon)
dim(Colon$X)
norm &lt;- Colon$X[Colon$Y == 1,]
tumor &lt;- Colon$X[Colon$Y == 2,]
gene1 &lt;- pp(r=2,n=50,oth=tumor,data=norm,k=2)
F1  &lt;- basis_random(2000)
gene1(F1)
t1  &lt;- caller(start=F1, index=gene1, n=rep(3,5), bases=5)
</code></pre>

<hr>
<h2 id='CvM'>Projection Pursuit Indices based on the bivariate empirical distribution function.</h2><span id='topic+ecdf.indices'></span><span id='topic+KS'></span><span id='topic+D1'></span><span id='topic+D2'></span>

<h3>Description</h3>

<p>This function can be used to compute the projection pursuit
indices described in Perisic and Posse (2005).</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecdf.indices(A, sphered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CvM_+3A_a">A</code></td>
<td>
<p>The projected data.</p>
</td></tr>
<tr><td><code id="CvM_+3A_sphered">sphered</code></td>
<td>
<p>Whether the data has already been sphered or not. If
set to FALSE (default), the function will sphere the data before
computing the indices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The two-dimensional empirical distribution function is defined as,
</p>
<p style="text-align: center;"><code class="reqn">F_n(x, y) = \frac{1}{n} \#\{(x_j, y_j): x_j \leq x \mbox{ and }
    y_j \leq y\}</code>
</p>

<p>The indices described in Perisic and Posse (2005) use this function to
construct the following four indices.
</p>
<p>Cramer-von-Mises:   </p>
<p style="text-align: center;"><code class="reqn">\sum_i (F_n(x_i, y_i) -
    \Phi(x_i)\Phi(y_i))^2</code>
</p>

<p>Kolmogorov-Smirnov: </p>
<p style="text-align: center;"><code class="reqn">\max_i |F_n(x_i, y_i) - \Phi(x_i)\Phi(y_i)|</code>
</p>

<p>D2:                 </p>
<p style="text-align: center;"><code class="reqn">\sum_i (F_n(x_i, y_i) - F_n(y_i, x_i))^2</code>
</p>

<p>D-infinity:         </p>
<p style="text-align: center;"><code class="reqn">\max_i |F_n(x_i, y_i) - F_n(y_i, x_i)|</code>
</p>

<p>where <code class="reqn">\Phi(.)</code> is the cumulative distribution function of the
standard normal distribution.
</p>
<p>When using any of these indices, the original authors recommended
rotating the data projection several times to obtain rotational
invariance. In simulations, the indices performed well even without
rotations.
</p>


<h3>Value</h3>

<p>A named numeric vector with the values of the following indices : the
Cramer-von-Mises index, the Kolmogorov-Smirnov index, the D2 Symmetry
index, and the D-infinity Symmetry index.
</p>


<h3>Author(s)</h3>

<p>Mohit Dayal</p>


<h3>References</h3>

<p>Perisic, Igor, and Christian Posse. &quot;Projection pursuit indices based on the empirical distribution function.&quot; Journal of Computational and Graphical Statistics 14.3 (2005).</p>

<hr>
<h2 id='evaluator'>Function to evaluate spatial quantiles</h2><span id='topic+evaluator'></span>

<h3>Description</h3>

<p>This provides an objective function whose minimization yields the spatial quantiles.</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluator(n, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluator_+3A_n">n</code></td>
<td>
<p>The number of rows in the data</p>
</td></tr>
<tr><td><code id="evaluator_+3A_p">p</code></td>
<td>
<p>The number of columns in the data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns another function suitable for passing to an optimizer like <code>nlm</code> or <code>trust</code>.
</p>


<h3>Value</h3>

<p>A function that should be passed to an optimizer.</p>


<h3>Author(s)</h3>

<p>Mohit Dayal
</p>


<h3>References</h3>

<p>P. Chaudhuri. &quot;On a geometric notion of quantiles for multivariate data.&quot; Journal of the American Statistical Association,
91(434):862-872, 1996.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(500)
dim(x) &lt;- c(250,2)
ev &lt;- evaluator(250,2)
##The Spatial Median
trust(ev, parinit=c(median(x[1,]), median(x[2,])), u=c(0,0),
      rinit=0.5, rmax=2e5, samp = x)
##Quantile for vector (0.2,0.3)
trust(ev, parinit=c(median(x[1,]), median(x[2,])), u=c(0.2,0.3),
      rinit=0.5, rmax=2e5, samp = x)
</code></pre>

<hr>
<h2 id='geodesic'>Functions for geodesic search</h2><span id='topic+search_geodesic'></span>

<h3>Description</h3>

<p>This function provides an alternative way to optimize the
projection index, by moving along a geodesic path.</p>


<h3>Usage</h3>

<pre><code class='language-R'>search_geodesic(current, alpha = 1, index, max.tries = 5, n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geodesic_+3A_current">current</code></td>
<td>
<p>The starting projection.</p>
</td></tr>
<tr><td><code id="geodesic_+3A_alpha">alpha</code></td>
<td>
<p>Maximum distance to travel (currently ignored).</p>
</td></tr>
<tr><td><code id="geodesic_+3A_index">index</code></td>
<td>
<p>The projection index.</p>
</td></tr>
<tr><td><code id="geodesic_+3A_max.tries">max.tries</code></td>
<td>
<p>Maximum number of failed attempts before giving up.</p>
</td></tr>
<tr><td><code id="geodesic_+3A_n">n</code></td>
<td>
<p>Number of random steps to take to find best direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>search_geodesic</code> finds only one basis at a time. The <code>caller</code> is a wrapper function that calls <code>search_geodesic</code> <code>bases</code> number of times.</p>


<h3>Value</h3>

<p>Returns the basis found.</p>


<h3>Author(s)</h3>

<p>The function has been copied as is from the <code>tourr</code> package.
</p>

<hr>
<h2 id='Olive+20oil+20measurements'>Olive oil samples from Italy</h2><span id='topic+olive'></span>

<h3>Description</h3>

<p>This data is from a paper by Forina, Armanino, Lanteri, Tiscornia (1983) Classification of Olive Oils from their Fatty Acid Composition, in Martens and Russwurm (ed) Food Research and Data Anlysis. We thank Prof. Michele Forina, University of Genova, Italy for making this dataset available.
</p>

<ul>
<li><p> region Three super-classes of Italy: North, South and the island of Sardinia
</p>
</li>
<li><p> area Nine collection areas: three from North, four from South and 2 from Sardinia
</p>
</li>
<li><p> palmitic, palmitoleic, stearic, oleic, linoleic, linolenic, arachidic, eicosenoic fatty acids percent x 100
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(olive)</code></pre>


<h3>Format</h3>

<p>A 572 x 10 numeric array</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(olive)
head(olive)
##Permutation
OlivesT &lt;- as.matrix(olive[, -c(1:2)])
OlivesF &lt;- OlivesT
#You should set.seed here so as to "fix" the benchmark
OlivesF[, 'palmitic']	&lt;- OlivesF[sample(572,572), 'palmitic']
OlivesF[, 'palmitoleic'] &lt;- OlivesF[sample(572,572), 'palmitoleic']
OlivesF[, 'stearic'] 	&lt;- OlivesF[sample(572,572), 'stearic']
OlivesF[, 'oleic'] 	&lt;- OlivesF[sample(572,572), 'oleic']
OlivesF[, 'linoleic'] 	&lt;- OlivesF[sample(572,572), 'linoleic']
OlivesF[, 'linolenic']	&lt;- OlivesF[sample(572,572), 'linolenic']
OlivesF[, 'arachidic']	&lt;- OlivesF[sample(572,572), 'arachidic']
OlivesF[, 'eicosenoic']	&lt;- OlivesF[sample(572,572), 'eicosenoic']
##
oil1 &lt;- pp(r=2, n=50, oth=OlivesF, data=OlivesT, k=2)
##In practice try at least &gt;10 starting values
F1   &lt;- basis_random(8)
##Increase iterations to &gt;2000 for useful results
o1 &lt;- optim(par=F1, fn=oil1, gr=basis_nearby(), method='SANN',
            control=list(fnscale=-1, maxit=50, trace=6))
</code></pre>

<hr>
<h2 id='pp'>Creates the projection pursuit function.</h2><span id='topic+pp'></span>

<h3>Description</h3>

<p>These functions encapsulate everything, that is, the data, the benchmark and the index parameters, needed to compute the projection index.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp(r = 0.8, n, data, oth, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_+3A_r">r</code></td>
<td>
<p> The radius multiplier. Values between 0.5 and 3 seem to work well.</p>
</td></tr>
<tr><td><code id="pp_+3A_n">n</code></td>
<td>
<p>Number of Monte-Carlo Evaluations to approximate the integral. Values as low as 25 can be used.</p>
</td></tr>
<tr><td><code id="pp_+3A_data">data</code></td>
<td>
<p>The data for which structure needs to be found.</p>
</td></tr>
<tr><td><code id="pp_+3A_oth">oth</code></td>
<td>
<p>The benchmark dataset.</p>
</td></tr>
<tr><td><code id="pp_+3A_k">k</code></td>
<td>
<p>The target dimension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pp</code> is for projection pursuit.
</p>


<h3>Value</h3>

<p>The actual index function, which takes a single matrix argument, and returns the index value for that projection.
</p>


<h3>Author(s)</h3>

<p>Mohit Dayal</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Exploring structure in the RANDU data
##Or using the MINSTD generator
randu &lt;- as.matrix(randu)

randtoolbox::setSeed(570)
w &lt;- randtoolbox::congruRand(1200)
dim(w) &lt;- c(3, 400)
w &lt;- t(w)

m &lt;- 'geodesic'
a &lt;- 0.50

ranif1 &lt;- pp(r=1, n=50, data=randu, oth=w, k=2)

set.seed(50)
F1 &lt;- basis_random(3)
o1 &lt;- optim(par=F1, fn=ranif1, gr=basis_nearby(), method='SANN',
            control=list(fnscale=-1, maxit=100, trace=1))
plot(randu %*% o1$par)

##How accurate are the values?
ranif1hi &lt;- pp(r=1, n=500, data=randu, oth=w, k=2)
ranif1hi(o1$par)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
