<!DOCTYPE html><html lang="en-US"><head><title>Help for package mco</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mco}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#functions'><p>MCO test problems</p></a></li>
<li><a href='#generationalDistance'><p>Quality measures for MCO solutions</p></a></li>
<li><a href='#normalizeFront'><p>Normalize a pareto front</p></a></li>
<li><a href='#nsga2'><p>NSGA II MOEA</p></a></li>
<li><a href='#paretoFront'><p>Pareto Front and pareto set getters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.17</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Criteria Optimization Algorithms and Related Functions</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of function to solve multiple criteria optimization problems 
  using genetic algorithms (NSGA-II). Also included is a collection of test functions.</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>scatterplot3d, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/olafmersmann/mco">https://github.com/olafmersmann/mco</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-19 21:04:15 UTC; olafm</td>
</tr>
<tr>
<td>Author:</td>
<td>Olaf Mersmann [aut, cre],
  Heike Trautmann [ctb],
  Detlef Steuer [ctb],
  Bernd Bischl [ctb],
  Kalyanmoy Deb [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Olaf Mersmann &lt;olafm@p-value.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-19 22:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='functions'>MCO test problems</h2><span id='topic+belegundu'></span><span id='topic+belegundu.constr'></span><span id='topic+binh1'></span><span id='topic+binh2'></span><span id='topic+binh2.constr'></span><span id='topic+binh3'></span><span id='topic+deb3'></span><span id='topic+fonseca1'></span><span id='topic+fonseca2'></span><span id='topic+gianna'></span><span id='topic+hanne1'></span><span id='topic+hanne1.constr'></span><span id='topic+hanne2'></span><span id='topic+hanne2.constr'></span><span id='topic+hanne3'></span><span id='topic+hanne3.constr'></span><span id='topic+hanne4'></span><span id='topic+hanne4.constr'></span><span id='topic+hanne5'></span><span id='topic+hanne5.constr'></span><span id='topic+jimenez'></span><span id='topic+jimenez.constr'></span><span id='topic+vnt'></span><span id='topic+zdt1'></span><span id='topic+zdt2'></span><span id='topic+zdt3'></span>

<h3>Description</h3>

<p>Collection of functions implementing various MCO test problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>belegundu(x)
belegundu.constr(x)
binh1(x)
binh2(x)
binh2.constr(x)
binh3(x)
deb3(x)
fonseca1(x)
fonseca2(x)
gianna(x)
hanne1(x)
hanne1.constr(x)
hanne2(x)
hanne2.constr(x)
hanne3(x)
hanne3.constr(x)
hanne4(x)
hanne4.constr(x)
hanne5(x)
hanne5.constr(x)
jimenez(x)
jimenez.constr(x)
vnt(x)
zdt1(x)
zdt2(x)
zdt3(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="functions_+3A_x">x</code></td>
<td>
<p>Input vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function value.
</p>


<h3>Author(s)</h3>

<p>Heike Trautmann <a href="mailto:trautmann@statistik.tu-dortmund.de">trautmann@statistik.tu-dortmund.de</a>,
Detlef Steuer <a href="mailto:steuer@hsu-hamburg.de">steuer@hsu-hamburg.de</a> and
Olaf Mersmann <a href="mailto:olafm@statistik.tu-dortmund.de">olafm@statistik.tu-dortmund.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
nsga2(belegundu, 2, 2,
      constraints=belegundu.constr, cdim=2,
      lower.bounds=c(0, 0), upper.bounds=c(5, 3))

nsga2(binh1, 2, 2,
      lower.bounds=c(-5, -5), upper.bounds=c(10, 10))
nsga2(binh2, 2, 2,
      lower.bounds=c(0, 0), upper.bounds=c(5, 3),
      constraints=binh2.constr, cdim=2)

nsga2(binh3, 2, 3,
      lower.bounds=c(10e-6, 10e-6), upper.bounds=c(10e6, 10e6))

nsga2(deb3, 2, 2,
      lower.bounds=c(0, 0), upper.bounds=c(1, 1),
      generations=500)

nsga2(fonseca1, 2, 2,
      lower.bounds=c(-100, -100), upper.bounds=c(100, 100))

nsga2(fonseca2, 2, 2,
      lower.bounds=c(-4, -4), upper.bounds=c(4, 4))

nsga2(gianna, 1, 2,
      lower.bounds=5, upper.bounds=10)

nsga2(hanne1, 2, 2,
      lower.bounds=c(0, 0), upper.bounds=c(10, 10),
      constraints=hanne1.constr, cdim=1)

nsga2(hanne2, 2, 2,
      lower.bounds=c(0, 0), upper.bounds=c(10, 10),
      constraints=hanne2.constr, cdim=1)

nsga2(hanne3, 2, 2,
      lower.bounds=c(0, 0), upper.bounds=c(10, 10),
      constraints=hanne3.constr, cdim=1)

nsga2(hanne4, 2, 2,
      lower.bounds=c(0, 0), upper.bounds=c(10, 10),
      constraints=hanne4.constr, cdim=1)

nsga2(hanne5, 2, 2,
      lower.bounds=c(0, 0), upper.bounds=c(10, 10),
      constraints=hanne5.constr, cdim=1)

nsga2(jimenez, 2, 2,
      lower.bounds=c(0, 0), upper.bounds=c(100, 100),
      constraints=jimenez.constr, cdim=4)

nsga2(vnt, 2, 3,
      lower.bounds=rep(-3, 2), upper.bounds=rep(3, 2))

nsga2(zdt1, 30, 2,
      lower.bounds=rep(0, 30), upper.bounds=rep(1, 30))

nsga2(zdt2, 30, 2,
      lower.bounds=rep(0, 30), upper.bounds=rep(1, 30))

nsga2(zdt3, 30, 2,
      lower.bounds=rep(0, 30), upper.bounds=rep(1, 30))

## End(Not run)
</code></pre>

<hr>
<h2 id='generationalDistance'>Quality measures for MCO solutions</h2><span id='topic+generationalDistance'></span><span id='topic+generalizedSpread'></span><span id='topic+dominatedHypervolume'></span><span id='topic+epsilonIndicator'></span>

<h3>Description</h3>

<p>Functions to evaluate the quality of the estimated pareto front.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generationalDistance(x, o)
generalizedSpread(x, o)
epsilonIndicator(x, o)
dominatedHypervolume(x, ref)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generationalDistance_+3A_x">x</code></td>
<td>
<p>Estimated pareto front or an object which has a paretoFront method</p>
</td></tr>
<tr><td><code id="generationalDistance_+3A_o">o</code></td>
<td>
<p>True pareto front or an object which has a paretoFront
method</p>
</td></tr>
<tr><td><code id="generationalDistance_+3A_ref">ref</code></td>
<td>
<p>Reference point (may be omitted).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Instead of the pareto front, one can also pass an object for which a
paretoFront method exists to both methods.
</p>
<p>For <code>dominatedHypervolume</code>, if no reference point is given, the
maximum in each dimension is used as the reference point.
</p>


<h3>Value</h3>

<p>The respective quality measure.
</p>


<h3>Note</h3>

<p>This code uses version 1.3 of the hypervolume code available from
<a href="https://lopez-ibanez.eu/hypervolume">https://lopez-ibanez.eu/hypervolume</a>. For a description
of the algorithm see
</p>
<p>Carlos M. Fonseca, Luis Paquete, and Manuel Lopez-Ibanez.
<em>An improved dimension-sweep algorithm for the hypervolume indicator</em>.
In IEEE Congress on Evolutionary Computation, pages 1157-1163,
Vancouver, Canada, July 2006.
</p>


<h3>Author(s)</h3>

<p>Heike Trautmann <a href="mailto:trautmann@statistik.uni-dortmund.de">trautmann@statistik.uni-dortmund.de</a>,
Detlef Steuer <a href="mailto:steuer@hsu-hamburg.de">steuer@hsu-hamburg.de</a> and
Olaf Mersmann <a href="mailto:olafm@statistik.uni-dortmund.de">olafm@statistik.uni-dortmund.de</a>
</p>


<h3>References</h3>

<p>Carlos M. Fonseca, Luis Paquete, and Manuel Lopez-Ibanez.
<em>An improved dimension-sweep algorithm for the hypervolume indicator</em>.
In IEEE Congress on Evolutionary Computation, pages 1157-1163,
Vancouver, Canada, July 2006.
</p>
<p>Nicola Beume, Carlos M. Fonseca, Manuel Lopez-Ibanez, Luis Paquete,
and J. Vahrenhold. <em>On the complexity of computing the
hypervolume indicator</em>. IEEE Transactions on Evolutionary Computation,
13(5):1075-1082, 2009.
</p>
<p>Zitzler, E., Thiele, L., Laumanns, M., Fonseca, C., and Grunert da
Fonseca, V (2003): <em>Performance Assessment of Multiobjective
Optimizers: An Analysis and Review</em>. IEEE Transactions on Evolutionary
Computation, 7(2), 117-132.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Estimate true front:
## Not run: 
tf &lt;- nsga2(fonseca2, 2, 2,
            lower.bounds=c(-4, -4), upper.bounds=c(4, 4),
            popsize=1000, generations=100)
res &lt;- nsga2(fonseca2, 2, 2,
             lower.bounds=c(-4, -4), upper.bounds=c(4, 4),
             popsize=16, generations=c(2, 4, 6, 8, 10, 20, 50))
n &lt;- length(res)
sapply(1:n, function(i) dominatedHypervolume(res[[i]], c(1, 1)))
sapply(1:n, function(i) generationalDistance(res[[i]], tf))
sapply(1:n, function(i) generalizedSpread(res[[i]], tf))
sapply(1:n, function(i) epsilonIndicator(res[[i]], tf))

## End(Not run)
</code></pre>

<hr>
<h2 id='normalizeFront'>Normalize a pareto front</h2><span id='topic+normalizeFront'></span>

<h3>Description</h3>

<p>Rescales a pareto front to be in the unit hypercube</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeFront(front, minval, maxval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalizeFront_+3A_front">front</code></td>
<td>
<p>Matrix containing the pareto front</p>
</td></tr>
<tr><td><code id="normalizeFront_+3A_minval">minval</code></td>
<td>
<p>Vector containing the minimum value of each
objective. May be omitted.</p>
</td></tr>
<tr><td><code id="normalizeFront_+3A_maxval">maxval</code></td>
<td>
<p>Vector containing the maximum value of each
objective. May be omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix containing the rescaled pareto front.
</p>


<h3>Author(s)</h3>

<p>Heike Trautmann <a href="mailto:trautmann@statistik.uni-dortmund.de">trautmann@statistik.uni-dortmund.de</a>,
Detlef Steuer <a href="mailto:steuer@hsu-hamburg.de">steuer@hsu-hamburg.de</a> and
Olaf Mersmann <a href="mailto:olafm@statistik.uni-dortmund.de">olafm@statistik.uni-dortmund.de</a>
</p>

<hr>
<h2 id='nsga2'>NSGA II MOEA</h2><span id='topic+nsga2'></span>

<h3>Description</h3>

<p>The NSGA-II algorithm minimizes a multidimensional function to approximate its Pareto front and Pareto set.
It does this by successive sampling of the search space, each such sample is called a <em>population</em>. 
The number of samples taken is governed by the <code>generations</code> parameter, the size of the sample by the <code>popsize</code> parameter.
Each population is obtained by creating so called offspring search points from the best individuals in the previous population. 
The best individuals are calculated by non-dominated sorting breaking ties using the crowding distance.
The total number of function evaluations used is 
</p>
<p style="text-align: center;"><code class="reqn">n_eval = popsize * (generations + 1)</code>
</p>

<p>when <code>generations</code> is a single number and
</p>
<p style="text-align: center;"><code class="reqn">n_eval = popsize * (max(generations) + 1)</code>
</p>

<p>when <code>generations</code> is a vector of numbers. 
Note the additional generation of evaluations in the above equation. 
These stem from the initial population which must be evaluated before the algorithm can start evolving new individuals.
</p>
<p>While the algorithm supports unbounded minimization, it will throw a warning and best results are obtained when a sensible upper and lower bound are given. 
No attempt is made to find such a sensible region of interest, instead if any element of the upper or lower bound is infinite, it is replace with a very large number (currently +/-4.49423283715579e+307).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nsga2(fn, idim, odim, ...,
        constraints = NULL, cdim = 0,
        lower.bounds = rep(-Inf, idim), upper.bounds = rep(Inf, idim),
        popsize = 100, generations = 100,
        cprob = 0.7, cdist = 5,
        mprob = 0.2, mdist = 10,
        vectorized=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsga2_+3A_fn">fn</code></td>
<td>
<p>Function to be minimized</p>
</td></tr>
<tr><td><code id="nsga2_+3A_idim">idim</code></td>
<td>
<p>Input dimension</p>
</td></tr>
<tr><td><code id="nsga2_+3A_odim">odim</code></td>
<td>
<p>Output dimension</p>
</td></tr>
<tr><td><code id="nsga2_+3A_...">...</code></td>
<td>
<p>Arguments passed through to 'fn'</p>
</td></tr>
<tr><td><code id="nsga2_+3A_constraints">constraints</code></td>
<td>
<p>Constraint function</p>
</td></tr>
<tr><td><code id="nsga2_+3A_cdim">cdim</code></td>
<td>
<p>Constraint dimension</p>
</td></tr>
<tr><td><code id="nsga2_+3A_lower.bounds">lower.bounds</code></td>
<td>
<p>Lower bound of parameters</p>
</td></tr>
<tr><td><code id="nsga2_+3A_upper.bounds">upper.bounds</code></td>
<td>
<p>Upper bound of parameters</p>
</td></tr>
<tr><td><code id="nsga2_+3A_popsize">popsize</code></td>
<td>
<p>Size of population</p>
</td></tr>
<tr><td><code id="nsga2_+3A_generations">generations</code></td>
<td>
<p>Number of generations to breed. If a vector, then
the result will contain the population at each given generation.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_cprob">cprob</code></td>
<td>
<p>Crossover probability</p>
</td></tr>
<tr><td><code id="nsga2_+3A_cdist">cdist</code></td>
<td>
<p>Crossover distribution index</p>
</td></tr>
<tr><td><code id="nsga2_+3A_mprob">mprob</code></td>
<td>
<p>Mutation probability</p>
</td></tr>
<tr><td><code id="nsga2_+3A_mdist">mdist</code></td>
<td>
<p>Mutation distribution index</p>
</td></tr>
<tr><td><code id="nsga2_+3A_vectorized">vectorized</code></td>
<td>
<p>If <code>TRUE</code>, the objective and constraint
functions must be vectorized, i.e. accept a matrix instead of a
vector and return a matrix instead of a vector. The matrix is
structured such that one individual parameter combination is
contained in each row (the matrix has shape <code>popsize * idim</code>)
and each objective is stored in a row of the returned matrix (the
returned matrix must have shape <code>odim * popsize</code>).
</p>
<p>A vectorized of a function <code>fn</code> should behave like
<code>apply(x, 1, f</code> for a population stored in the matrix <code>x</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If generation is an integer, a list describing the final population
with components <code>par</code>, <code>value</code> and <code>pareto.optimal</code>. If
generations is a vector, a list is returned. The i-th element of the
list contains the population after generations[i] generations, this is
not necessarily the set of new individuals that were evaluated in this 
generation. Some of the new individuals might have been eliminated in
the selection phase.  
</p>


<h3>Author(s)</h3>

<p>Heike Trautmann <a href="mailto:trautmann@statistik.uni-dortmund.de">trautmann@statistik.uni-dortmund.de</a>,
Detlef Steuer <a href="mailto:steuer@hsu-hamburg.de">steuer@hsu-hamburg.de</a> and
Olaf Mersmann <a href="mailto:olafm@statistik.uni-dortmund.de">olafm@statistik.uni-dortmund.de</a>
</p>


<h3>References</h3>

<p>Deb, K., Pratap, A., and Agarwal, S..
A Fast and Elitist Multiobjective Genetic Algorithm: NSGA-II.
<em>IEEE Transactions on Evolutionary Computation</em>, <b>6 (8)</b>
(2002), 182-197.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zdt1">zdt1</a></code> for more examples and a list of
multiobjective test functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Binh 1 problem:
binh1 &lt;- function(x) {
  y &lt;- numeric(2)
  y[1] &lt;- crossprod(x, x)
  y[2] &lt;- crossprod(x - 5, x - 5)
  return (y)
}
r1 &lt;- nsga2(binh1, 2, 2,
           generations=150, popsize=100,
           cprob=0.7, cdist=20,
           mprob=0.2, mdist=20,
           lower.bounds=rep(-5, 2),
           upper.bounds=rep(10, 2))
plot(r1)

## VNT problem:
vnt &lt;- function(x) {  
  y &lt;- numeric(3)
  xn &lt;- crossprod(x, x)
  y[1] &lt;- xn/2 + sin(xn);
  y[2] &lt;- (crossprod(c(3, -2), x) + 4)^2/8 + (crossprod(c(1, -1), x) + 1)^2/27 + 15
  y[3] &lt;- 1/(xn + 1) - 1.1*exp(-xn)
  return (y)
}

r2 &lt;- nsga2(vnt, 2, 3,
           generations=150, popsize=100,
           lower.bounds=rep(-3, 2),
           upper.bounds=rep(3, 2))
plot(r2)

## Example using constraints:
## minimize     f(x) = (x[1]^2, x[2]^2)
## subject to   g(x) = (sum(x) - 5) &gt;= 0
f &lt;- function(x) { x^2 }
g &lt;- function(x) { sum(x) - 5 }
res &lt;- nsga2(f, 2, 2, generations=500,
             lower.bounds=c(0, 0), upper.bounds=c(10, 10),
             constraints=g, cdim=1)
opar &lt;-par(mfrow=c(1,2))
plot(res, xlab="y1", ylab="y2", main="Objective space")
plot(res$par, xlab="x1", ylab="x2", main="Parameter space")
par(opar)
</code></pre>

<hr>
<h2 id='paretoFront'>Pareto Front and pareto set getters</h2><span id='topic+paretoFront'></span><span id='topic+paretoSet'></span><span id='topic+paretoFilter'></span>

<h3>Description</h3>

<p>Extract the pareto front or pareto set from an mco result object.
</p>
<p>Filter an mco result and extract the pareto-optimal solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paretoFront(x, ...)
paretoSet(x, ...)
paretoFilter(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paretoFront_+3A_x">x</code></td>
<td>
<p>matrix or mco result object</p>
</td></tr>
<tr><td><code id="paretoFront_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the pareto front or pareto set.
</p>
<p><code>paretoFilter</code> returns those values in <code>x</code> which are not
dominated by any other solution.
</p>


<h3>Author(s)</h3>

<p>Heike Trautmann <a href="mailto:trautmann@statistik.uni-dortmund.de">trautmann@statistik.uni-dortmund.de</a>,
Detlef Steuer <a href="mailto:steuer@hsu-hamburg.de">steuer@hsu-hamburg.de</a> and
Olaf Mersmann <a href="mailto:olafm@statistik.uni-dortmund.de">olafm@statistik.uni-dortmund.de</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
