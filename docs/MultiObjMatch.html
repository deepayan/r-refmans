<!DOCTYPE html><html><head><title>Help for package MultiObjMatch</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MultiObjMatch}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addBalance'><p>Add fine balance edges</p></a></li>
<li><a href='#addExclusion'><p>Add exclusion edges</p></a></li>
<li><a href='#balanceCosts'><p>Create a skeleton representation of the balance edge costs</p></a></li>
<li><a href='#build.dist.struct'><p>An internal helper function that generates the data abstraction for the edge</p>
weights of the main network structure.</a></li>
<li><a href='#build.dist.struct_user'><p>An internal helper function that generates the data abstraction for the edge</p>
weights of the main network structure using the distance matrix passed by the
user.</a></li>
<li><a href='#callrelax'><p>Call relax on the network</p></a></li>
<li><a href='#combine_dist'><p>An internal helper function that combines two distance object</p></a></li>
<li><a href='#compareMatching'><p>Generate covariate balance in different matches</p></a></li>
<li><a href='#compareTables'><p>Summarize covariate balance table</p></a></li>
<li><a href='#convert_index'><p>An internal helper function that translates the matching index in the sorted</p>
data frame to the original dataframe's row index</a></li>
<li><a href='#convert_names'><p>Internal helper function that converts axis name to internal variable name</p></a></li>
<li><a href='#costSkeleton'><p>Create cost skeleton</p></a></li>
<li><a href='#data_precheck'><p>Data precheck: Handle missing data(mean imputation) and remove redundant</p>
columns; it also adds an NA column for indicating whether it's missing</a></li>
<li><a href='#descr.stats_general'><p>Generate summary statistics for matches</p></a></li>
<li><a href='#distanceFunctionHelper'><p>Helper function that change input distance matrix</p></a></li>
<li><a href='#distBalMatch'><p>Optimal tradeoffs among distance, exclusion and marginal imbalance</p></a></li>
<li><a href='#dummy'><p>This is a modified version of the function &quot;dummy&quot; from the R package</p>
dummies. Original code Copyright (c) 2011 Decision
Patterns.</a></li>
<li><a href='#edgelist2ISM'><p>Change the edgelist to the infinity sparse matrix</p></a></li>
<li><a href='#excludeCosts'><p>Create a skeleton representation of the exclusion edge costs</p></a></li>
<li><a href='#extractEdges'><p>Extract edges from the network</p></a></li>
<li><a href='#extractSupply'><p>Extract the supply nodes from the net</p></a></li>
<li><a href='#flattenSkeleton'><p>Turns a skeleton representation of edge costs in a network</p></a></li>
<li><a href='#generate_rhos'><p>Generate rho pairs</p></a></li>
<li><a href='#generateBalanceTable'><p>Generate balance table</p></a></li>
<li><a href='#generatePairdistanceBalanceGraph'><p>Total variation imbalance vs. marginal imbalance</p></a></li>
<li><a href='#generatePairdistanceGraph'><p>Distance vs. exclusion</p></a></li>
<li><a href='#generateRhoObj'><p>Penalty and objective values summary</p></a></li>
<li><a href='#generateTVGraph'><p>Marginal imbalance vs. exclusion</p></a></li>
<li><a href='#get_five_index'><p>An internal helper function that gives the index of matching with a wide</p>
range of number of treated units left unmatched</a></li>
<li><a href='#getExactOn'><p>Generate a factor for exact matching.</p></a></li>
<li><a href='#getPropensityScore'><p>Fit propensity scores using logistic regression.</p></a></li>
<li><a href='#getUnmatched'><p>Get unmatched percentage</p></a></li>
<li><a href='#makeInfinitySparseMatrix'><p>Internal helper to build infinity sparse matrix</p></a></li>
<li><a href='#makeSparse'><p>Helper function to mask edges</p></a></li>
<li><a href='#matched_index'><p>An internal helper function that translate the matching index in the sorted</p>
data frame to the original dataframe's row index</a></li>
<li><a href='#matchedData'><p>Get matched dataframe</p></a></li>
<li><a href='#matrix2cost'><p>change the distance matrix to cost</p></a></li>
<li><a href='#matrix2edgelist'><p>Helper function to convert matrix to list</p></a></li>
<li><a href='#meldMask'><p>Helper function to combine two sparse distances</p></a></li>
<li><a href='#netFlowMatch'><p>Create network flow structure</p></a></li>
<li><a href='#obj.to.match'><p>An internal helper function that transforms the output from the RELAX</p>
algorithm to a data structure that is more interpretable for the output of
the main matching function</a></li>
<li><a href='#pairCosts'><p>Create a skeleton representation of the edge costs</p></a></li>
<li><a href='#rho_proposition'><p>Generate penalty coefficient pairs</p></a></li>
<li><a href='#solveP'><p>Solve the network flow problem - basic version</p></a></li>
<li><a href='#solveP1'><p>Solve the network flow problem - twoDistMatch</p></a></li>
<li><a href='#twoDistMatch'><p>Optimal tradeoffs among two distances and exclusion</p></a></li>
<li><a href='#visualize'><p>Visualize tradeoffs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multi-Objective Matching Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Matching algorithm based on network-flow structure. 
  Users are able to modify the emphasis on three different 
  optimization goals: two different distance measures and 
  the number of treated units left unmatched. The method is proposed by Pimentel
  and Kelz (2019) &lt;<a href="https://doi.org/10.1080%2F01621459.2020.1720693">doi:10.1080/01621459.2020.1720693</a>&gt;.
  The 'rrelaxiv' package, which provides an alternative solver for
	the underlying network flow problems, carries an
	academic license and is not available on CRAN, but
	may be downloaded from Github at 
	<a href="https://github.com/josherrickson/rrelaxiv/">https://github.com/josherrickson/rrelaxiv/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>cobalt, dplyr, optmatch, matchMulti, fields, plyr, RCurl,
gtools, rcbalance, MASS, stats, methods, utils, rlemon</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), rrelaxiv</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://errickson.net/rrelaxiv/">https://errickson.net/rrelaxiv/</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-22 23:03:25 UTC; hanshichao</td>
</tr>
<tr>
<td>Author:</td>
<td>Shichao Han [cre, aut],
  Samuel D. Pimentel [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shichao Han &lt;schan21@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-23 08:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='addBalance'>Add fine balance edges</h2><span id='topic+addBalance'></span>

<h3>Description</h3>

<p>Add fine balance edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addBalance(net, treatedVals, controlVals, replaceExisting = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addBalance_+3A_net">net</code></td>
<td>
<p>the network object created for the network flow problem</p>
</td></tr>
<tr><td><code id="addBalance_+3A_treatedvals">treatedVals</code></td>
<td>
<p>the balance value for treated nodes</p>
</td></tr>
<tr><td><code id="addBalance_+3A_controlvals">controlVals</code></td>
<td>
<p>the balance value for control nodes</p>
</td></tr>
<tr><td><code id="addBalance_+3A_replaceexisting">replaceExisting</code></td>
<td>
<p>(optional) whether or not to replace the existing net;
TRUE by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the network structure with balance edges added
</p>

<hr>
<h2 id='addExclusion'>Add exclusion edges</h2><span id='topic+addExclusion'></span>

<h3>Description</h3>

<p>Add exclusion edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addExclusion(net, remove = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addExclusion_+3A_net">net</code></td>
<td>
<p>the input network structure</p>
</td></tr>
<tr><td><code id="addExclusion_+3A_remove">remove</code></td>
<td>
<p>(optional) whether to exclude edges; FALSE by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the network structure with exclusion edges added to allow for trdeoff
for the exclusion cost
</p>

<hr>
<h2 id='balanceCosts'>Create a skeleton representation of the balance edge costs</h2><span id='topic+balanceCosts'></span>

<h3>Description</h3>

<p>Create a skeleton representation of the balance edge costs
associated with pairings for a given distance and network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanceCosts(net, balance.penalty = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanceCosts_+3A_net">net</code></td>
<td>
<p>the network structure</p>
</td></tr>
<tr><td><code id="balanceCosts_+3A_balance.penalty">balance.penalty</code></td>
<td>
<p>(optional) the numeric value for balance; 1 by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the skeleton with balance edge cost
</p>

<hr>
<h2 id='build.dist.struct'>An internal helper function that generates the data abstraction for the edge
weights of the main network structure.</h2><span id='topic+build.dist.struct'></span>

<h3>Description</h3>

<p>An internal helper function that generates the data abstraction for the edge
weights of the main network structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.dist.struct(
  z,
  X,
  distMat,
  exact = NULL,
  dist.type = "Mahalanobis",
  calip.option = "propensity",
  calip.cov = NULL,
  caliper = 0.2,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.dist.struct_+3A_z">z</code></td>
<td>
<p>a vector of treatment and control indicators, 1 for treatment and 0
for control.</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_x">X</code></td>
<td>
<p>a data frame or a numeric or logical matrix containing covariate
information for treated and control units. Its row count must be equal to
the length of z.</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_distmat">distMat</code></td>
<td>
<p>a matrix of pair-wise distance specified by the user</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_exact">exact</code></td>
<td>
<p>an optional vector of the same length as z. If this argument is
specified, treated units will only be allowed to match to control units
that have equal values in the corresponding indices of the exact vector.
For example, to match patients within hospitals only, one could set exact
equal to a vector of hospital IDs for each patient.</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_dist.type">dist.type</code></td>
<td>
<p>one of ('propensity','user','none'). If ’propensity’ is
specified (the default option), the function estimates a propensity score
via logistic regression of z on X and imposes a propensity score caliper.
If ’user’ is specified, the user must provide a vector of values on which a
caliper will be enforced using the calip.cov argument. If ’none’ is
specified no caliper is used.</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_calip.option">calip.option</code></td>
<td>
<p>a character indicating the type of caliper used</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_calip.cov">calip.cov</code></td>
<td>
<p>see calip.option.</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_caliper">caliper</code></td>
<td>
<p>a numeric value that gives the size of the caliper when the
user specifies the calip.option argument as ’propensity’ or ’calip.cov’.</p>
</td></tr>
<tr><td><code id="build.dist.struct_+3A_verbose">verbose</code></td>
<td>
<p>a boolean value whether to print(cat) debug information.
Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance structure used for constructing the main network flow
problem
</p>

<hr>
<h2 id='build.dist.struct_user'>An internal helper function that generates the data abstraction for the edge
weights of the main network structure using the distance matrix passed by the
user.</h2><span id='topic+build.dist.struct_user'></span>

<h3>Description</h3>

<p>An internal helper function that generates the data abstraction for the edge
weights of the main network structure using the distance matrix passed by the
user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.dist.struct_user(z, distMat, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.dist.struct_user_+3A_z">z</code></td>
<td>
<p>a vector indicating whether each unit is in treatment or control
group</p>
</td></tr>
<tr><td><code id="build.dist.struct_user_+3A_distmat">distMat</code></td>
<td>
<p>a matrix of pair-wise distance</p>
</td></tr>
<tr><td><code id="build.dist.struct_user_+3A_verbose">verbose</code></td>
<td>
<p>a boolean value whether to print(cat) debug information.
Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance structure used for constructing the main network flow
problem
</p>

<hr>
<h2 id='callrelax'>Call relax on the network</h2><span id='topic+callrelax'></span>

<h3>Description</h3>

<p>this function is copied from the rcbalance package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callrelax(net, solver = "rlemon")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callrelax_+3A_net">net</code></td>
<td>
<p>the network structure</p>
</td></tr>
<tr><td><code id="callrelax_+3A_solver">solver</code></td>
<td>
<p>(optional) the solver; by default, &quot;rlemon&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of the result from the call to relax solver
</p>

<hr>
<h2 id='combine_dist'>An internal helper function that combines two distance object</h2><span id='topic+combine_dist'></span>

<h3>Description</h3>

<p>An internal helper function that combines two distance object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_dist(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_dist_+3A_a">a</code></td>
<td>
<p>a distance structure object</p>
</td></tr>
<tr><td><code id="combine_dist_+3A_b">b</code></td>
<td>
<p>a distance structure object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new distance structure object whose edge weights are the sum of the
corresponding edge weigths in a and b
</p>

<hr>
<h2 id='compareMatching'>Generate covariate balance in different matches</h2><span id='topic+compareMatching'></span>

<h3>Description</h3>

<p>This is a wrapper function for use in evaluating covariate
balance across different matches. The function calls <code>compareTables</code> on the
output from the function <code>generateBalanceTable</code>. It only works for 'Basic'
version of matching (using <code>distBalMatch</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareMatching(
  matchingResult,
  covList = NULL,
  display.all = TRUE,
  stat = "mean.diff"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareMatching_+3A_matchingresult">matchingResult</code></td>
<td>
<p>an object returned by the main matching function
distBalMatch</p>
</td></tr>
<tr><td><code id="compareMatching_+3A_covlist">covList</code></td>
<td>
<p>(optional) factor of names of covariates that we want to
evaluate covariate balance on; default is NULL. When set to NULL, the
program will compare the covariates that have been used to construct a
propensity model.</p>
</td></tr>
<tr><td><code id="compareMatching_+3A_display.all">display.all</code></td>
<td>
<p>(optional) boolean value of whether to display all the
matches; default is TRUE, where matches at each quantile is displayed</p>
</td></tr>
<tr><td><code id="compareMatching_+3A_stat">stat</code></td>
<td>
<p>(optional) character of the name of the statistic used for
measuring covariate balance; default is &quot;mean.diff&quot;. This argument is the
same as used in &quot;cobalt&quot; package, see: <a href="cobalt.html#topic+bal.tab">bal.tab</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe that shows covariate balance in different matches
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate matches 
data("lalonde", package="cobalt")
psCols &lt;- c("age", "educ", "married", "nodegree")
treatVal &lt;- "treat"
responseVal &lt;- "re78"
pairDistVal &lt;- c("age", "married", "educ", "nodegree")
exactVal &lt;- c("educ")
myBalVal &lt;- c("race")
r1s &lt;- c( 0.1, 0.3, 0.5, 0.7, 0.9,1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7)
r2s &lt;- c(0.01)
matchResult &lt;- distBalMatch(df=lalonde, treatCol=treatVal, myBalCol=myBalVal,
rhoExclude =r1s, rhoBalance=r2s,
distList=pairDistVal, exactlist=exactVal,
propensityCols = psCols,ignore = c(responseVal), maxUnMatched = 0.1,
caliperOption=NULL, toleranceOption=1e-1, maxIter=0, rho.max.f = 10)

## Generate table for comparing matches
compareMatching(matchResult, display.all = TRUE)
</code></pre>

<hr>
<h2 id='compareTables'>Summarize covariate balance table</h2><span id='topic+compareTables'></span>

<h3>Description</h3>

<p>This function would take the result of <code>generateBalanceTable</code>
function and combine the results in a single table. It only works for 'Basic'
version of the matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareTables(balanceTable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareTables_+3A_balancetable">balanceTable</code></td>
<td>
<p>a named list, which is the result from the function
<code>generateBalanceTable</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with combined information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate matches 
data("lalonde", package="cobalt")
psCols &lt;- c("age", "educ", "married", "nodegree")
treatVal &lt;- "treat"
responseVal &lt;- "re78"
pairDistVal &lt;- c("age", "married", "educ", "nodegree")
exactVal &lt;- c("educ")
myBalVal &lt;- c("race")
r1s &lt;- c( 0.1, 0.3, 0.5, 0.7, 0.9,1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7)
r2s &lt;- c(0.01)
matchResult &lt;- distBalMatch(df=lalonde, treatCol=treatVal, myBalCol=myBalVal,
rhoExclude =r1s, rhoBalance=r2s,
distList=pairDistVal, exactlist=exactVal,
propensityCols = psCols,ignore = c(responseVal), maxUnMatched = 0.1,
caliperOption=NULL, toleranceOption=1e-1, maxIter=0, rho.max.f = 10)

## Generate summary table for comparing matches 
compareTables(generateBalanceTable(matchResult))
</code></pre>

<hr>
<h2 id='convert_index'>An internal helper function that translates the matching index in the sorted
data frame to the original dataframe's row index</h2><span id='topic+convert_index'></span>

<h3>Description</h3>

<p>An internal helper function that translates the matching index in the sorted
data frame to the original dataframe's row index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_index(matchingResult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_index_+3A_matchingresult">matchingResult</code></td>
<td>
<p>an object returned by the main matching function
distBalMatch</p>
</td></tr>
</table>

<hr>
<h2 id='convert_names'>Internal helper function that converts axis name to internal variable name</h2><span id='topic+convert_names'></span>

<h3>Description</h3>

<p>Internal helper function that converts axis name to internal variable name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_names(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_names_+3A_x">x</code></td>
<td>
<p>the user input character for x-axis value</p>
</td></tr>
<tr><td><code id="convert_names_+3A_y">y</code></td>
<td>
<p>the user input character for y-axis value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with variable names for visualization for internal use
</p>

<hr>
<h2 id='costSkeleton'>Create cost skeleton</h2><span id='topic+costSkeleton'></span>

<h3>Description</h3>

<p>Create a more user-friendly data structure to represent the edge
costs in a network.  Internally the network object used by the optmiization
routine represents all the edge costs in a single vector. The &quot;skeleton&quot;
structure decomposes this vector into a list of components, each
corresponding to a different role in the network: &quot;pairings&quot; are edges
between treated and control, exclusion&quot; are direct links between treated
units and a sink that allows them to be excluded, &quot;balance&quot; refers to edges
that count marginal balance between groups, and &quot;sink&quot; indicates edges that
connect control nodes to the sink. Skeletons are created so these various
features can be combined (or switched on and off) easily into objective
functions, and the interface to the main tradeoff function expects to see
each function represented in skeleton format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>costSkeleton(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costSkeleton_+3A_net">net</code></td>
<td>
<p>the network structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the skeleton
</p>

<hr>
<h2 id='data_precheck'>Data precheck: Handle missing data(mean imputation) and remove redundant
columns; it also adds an NA column for indicating whether it's missing</h2><span id='topic+data_precheck'></span>

<h3>Description</h3>

<p>Data precheck: Handle missing data(mean imputation) and remove redundant
columns; it also adds an NA column for indicating whether it's missing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_precheck(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_precheck_+3A_x">X</code></td>
<td>
<p>a dataframe that the user initially inputs for matching - dataframe
with covariates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with modified data if necessary
</p>

<hr>
<h2 id='descr.stats_general'>Generate summary statistics for matches</h2><span id='topic+descr.stats_general'></span>

<h3>Description</h3>

<p>Generate summary statistics for matches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descr.stats_general(matches, df, treatCol, b.vars, pair.vars, extra = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="descr.stats_general_+3A_matches">matches</code></td>
<td>
<p>One matching result from the main matching function</p>
</td></tr>
<tr><td><code id="descr.stats_general_+3A_df">df</code></td>
<td>
<p>the original data frame used for matching</p>
</td></tr>
<tr><td><code id="descr.stats_general_+3A_treatcol">treatCol</code></td>
<td>
<p>the character of the column name for treatment vector</p>
</td></tr>
<tr><td><code id="descr.stats_general_+3A_b.vars">b.vars</code></td>
<td>
<p>the vector of column names of covariates used for measuring
balance</p>
</td></tr>
<tr><td><code id="descr.stats_general_+3A_pair.vars">pair.vars</code></td>
<td>
<p>the vector of column names used for measuring pairwise
distance</p>
</td></tr>
<tr><td><code id="descr.stats_general_+3A_extra">extra</code></td>
<td>
<p>the list of summary statistic; it must be the types that can be
taken by cobalt</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of summary statistic
</p>

<hr>
<h2 id='distanceFunctionHelper'>Helper function that change input distance matrix</h2><span id='topic+distanceFunctionHelper'></span>

<h3>Description</h3>

<p>Helper function that change input distance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceFunctionHelper(z, distMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distanceFunctionHelper_+3A_z">z</code></td>
<td>
<p>the treatment vector</p>
</td></tr>
<tr><td><code id="distanceFunctionHelper_+3A_distmat">distMat</code></td>
<td>
<p>the user input distance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance matrix where (i,j) element is the distance between unit i
and j in the same order as z
</p>

<hr>
<h2 id='distBalMatch'>Optimal tradeoffs among distance, exclusion and marginal imbalance</h2><span id='topic+distBalMatch'></span>

<h3>Description</h3>

<p>Explores tradeoffs among three important objective functions in
an optimal matching problem:the sum of covariate distances within matched
pairs, the number of treated units included in the match, and the marginal
imbalance on pre-specified covariates (in total variation distance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distBalMatch(
  df,
  treatCol,
  myBalCol,
  rhoExclude = c(1),
  rhoBalance = c(1, 2, 3),
  distMatrix = NULL,
  distList = NULL,
  exactlist = NULL,
  propensityCols = NULL,
  pScores = NULL,
  ignore = NULL,
  maxUnMatched = 0.25,
  caliperOption = NULL,
  toleranceOption = 0.01,
  maxIter = 0,
  rho.max.f = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distBalMatch_+3A_df">df</code></td>
<td>
<p>data frame that contain columns indicating treatment, outcome and
covariates.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_treatcol">treatCol</code></td>
<td>
<p>character of name of the column indicating treatment
assignment.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_mybalcol">myBalCol</code></td>
<td>
<p>character of column name of the variable on which to evaluate
marginal balance.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_rhoexclude">rhoExclude</code></td>
<td>
<p>(optional) numeric vector of values of exclusion penalty.
Default value is c(1).</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_rhobalance">rhoBalance</code></td>
<td>
<p>(optional) factor of values of marginal balance penalty.
Default value is c(1,2,3).</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_distmatrix">distMatrix</code></td>
<td>
<p>(optional) a matrix that specifies the pair-wise distances
between any two objects.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_distlist">distList</code></td>
<td>
<p>(optional) character vector of variable names used for
calculating within-pair distance.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_exactlist">exactlist</code></td>
<td>
<p>(optional) character vector, variable names that we want
exact matching on; NULL by default.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_propensitycols">propensityCols</code></td>
<td>
<p>(optional) character vector, variable names on which to
fit a propensity score (to supply a caliper).</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_pscores">pScores</code></td>
<td>
<p>(optional) character, giving the variable name for the fitted
propensity score.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_ignore">ignore</code></td>
<td>
<p>(optional) character vector of variable names that should be
ignored when constructing the internal matching. NULL by default.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_maxunmatched">maxUnMatched</code></td>
<td>
<p>(optional) numeric, the maximum proportion of unmatched
units that can be accepted; default is 0.25.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_caliperoption">caliperOption</code></td>
<td>
<p>(optional) numeric, the propensity score caliper value
in standard deviations of the estimated propensity scores; default is NULL,
which is no caliper.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_toleranceoption">toleranceOption</code></td>
<td>
<p>(optional) numeric, tolerance of close match distance;
default is 1e-2.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_maxiter">maxIter</code></td>
<td>
<p>(optional) integer,  maximum number of iterations to use in
searching for penalty combintions that improve the matching; default is 0.</p>
</td></tr>
<tr><td><code id="distBalMatch_+3A_rho.max.f">rho.max.f</code></td>
<td>
<p>(optional) numeric, the scaling factor used in proposal for
rhos; default is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matched designs generated by this function are Pareto optimal for
the three objective functions.  The degree of relative emphasis among the
three objectives in any specific solution is controlled by the penalties,
denoted by Greek letter rho. Larger values of <code>rhoExclude</code> corresponds to
increased emphasis on retaining treated units (all else being equal), while
larger values of <code>rhoBalance</code> corresponds to increased emphasis on marginal
balance. Additional details:
</p>

<ul>
<li><p> Users may either specify their own distance
matrix via the <code>distMatrix</code> argument or ask the function to create a
Mahalanobis distance matrix internally on a set of covariates specified by
the <code>distList</code> argument; if neither argument is specified an error will
result.  User-specified distance matrices should have row count equal to
the number of treated units and column count equal to the number of
controls.
</p>
</li>
<li><p> If the <code>caliperOption</code> argument is specified, a propensity
score caliper will be imposed, forbidding matches between units more than a
fixed distance apart on the propensity score.  The caliper will be based
either on a user-fit propensity score, identified in the input dataframe by
argument <code>pScores</code>, or by an internally-fit propensity score based on
logistic regression against the variables named in <code>psoreCols</code>.  If
<code>caliperOption</code> is non-NULL and neither of the other arguments is specified
an error will result.
</p>
</li>
<li> <p><code>toleranceOption</code> controls the precision at which
the objective functions is evaluated. When matching problems are especially
large or complex it may be necessary to increase toleranceOption in order
to prevent integer overflows in the underlying network flow solver;
generally this will be suggested in appropariate warning messages.
</p>
</li>
<li><p> While
by default tradeoffs are only assessed at penalty combinations provided by
the user, the user may ask for the algorithm to search over additional
penalty values in order to identify additional Pareto optimal solutions.
<code>rho.max.f</code> is a multiplier applied to initial penalty values to discover
new solutions, and setting it larger leads to wider exploration; similarly,
<code>maxIter</code> controls how long the exploration routine runs, with larger
values leading to more exploration.
</p>
</li></ul>



<h3>Value</h3>

<p>a named list whose elements are: * &quot;rhoList&quot;: list of penalty
combinations for each match * &quot;matchList&quot;: list of matches indexed by
number
</p>

<ul>
<li><p> &quot;treatmentCol&quot;: character of treatment variable
</p>
</li>
<li><p> &quot;covs&quot;:
character vector of names of the variables used for calculating within-pair
distance
</p>
</li>
<li><p> &quot;exactCovs&quot;: character vector of names of variables that we want
exact or close match on * &quot;idMapping&quot;: numeric vector of row indices for
each observation in the sorted data frame for internal use
</p>
</li>
<li><p> &quot;stats&quot;: data
frame of important statistics (total variation distance) for variable on
which marginal balance is measured
</p>
</li>
<li><p> &quot;b.var&quot;: character, name of variable
on which marginal balance is measured * &quot;dataTable&quot;: data frame sorted by
treatment value
</p>
</li>
<li><p> &quot;t&quot;: a treatment vector
</p>
</li>
<li><p> &quot;df&quot;: the original dataframe
input by the user
</p>
</li>
<li><p> &quot;pair_cost1&quot;: list of pair-wise distance sum using the
first distance measure
</p>
</li>
<li><p> &quot;pair_cost2&quot;: list of pair-wise distance sum using
the second distance measure (left NULL since only one distance measure is
used here).
</p>
</li>
<li><p> &quot;version&quot;: (for internal use) the version of the matching
function called; &quot;Basic&quot; indicates the matching comes from distBalMatch and
&quot;Advanced&quot; from twoDistMatch.
</p>
</li>
<li><p> &quot;fPair&quot;: a vector of values for the first
objective function; it corresponds to the pair-wise distance sum according
to the first distance measure.
</p>
</li>
<li><p> &quot;fExclude&quot;: a vector of values for the
second objective function; it corresponds to the number of treated units
being unmatched.
</p>
</li>
<li><p> &quot;fMarginal&quot;: a vector of values for the third objective
function; it corresponds to the marginal balanced distance for the
specified variable(s).
</p>
</li></ul>



<h3>See Also</h3>

<p>Other main matching function: 
<code><a href="#topic+twoDistMatch">twoDistMatch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde", package="cobalt")
psCols &lt;- c("age", "educ", "married", "nodegree", "race")
treatVal &lt;- "treat"
responseVal &lt;- "re78"  
pairDistVal &lt;- c("age", "married", "educ", "nodegree", "race")
myBalVal &lt;- c("race")
r1s &lt;- c(0.01,1,2,4,4.4,5.2,5.4,5.6,5.8,6)
r2s &lt;- c(0.001)
matchResult &lt;- distBalMatch(df=lalonde, treatCol= treatVal, 
myBalCol = myBalVal, rhoExclude=r1s, rhoBalance=r2s, distList = pairDistVal, 
propensityCols = psCols, maxIter=0)
</code></pre>

<hr>
<h2 id='dummy'>This is a modified version of the function &quot;dummy&quot; from the R package
dummies. Original code Copyright (c) 2011 Decision
Patterns.</h2><span id='topic+dummy'></span>

<h3>Description</h3>

<p>Change is made to the &quot;model.matrix&quot; function so that the output could be
used for the current package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy(
  x,
  data = NULL,
  sep = "",
  drop = TRUE,
  fun = as.integer,
  verbose = FALSE,
  name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_+3A_x">x</code></td>
<td>
<p>a data.frame, matrix or single variable or variable name</p>
</td></tr>
<tr><td><code id="dummy_+3A_data">data</code></td>
<td>
<p>(optional) if provided, x is the name of a column on the data</p>
</td></tr>
<tr><td><code id="dummy_+3A_sep">sep</code></td>
<td>
<p>(optional) the separator used between variable name and the value</p>
</td></tr>
<tr><td><code id="dummy_+3A_drop">drop</code></td>
<td>
<p>(optional) whether to drop unused levels</p>
</td></tr>
<tr><td><code id="dummy_+3A_fun">fun</code></td>
<td>
<p>(optional) function to coerce the value in the final matrix; 'as,integer' by default</p>
</td></tr>
<tr><td><code id="dummy_+3A_verbose">verbose</code></td>
<td>
<p>(optional) whether to print the number of variables; FALSE by default</p>
</td></tr>
<tr><td><code id="dummy_+3A_name">name</code></td>
<td>
<p>(optional) the column name to be selected for converting; NULL by default</p>
</td></tr>
</table>

<hr>
<h2 id='edgelist2ISM'>Change the edgelist to the infinity sparse matrix</h2><span id='topic+edgelist2ISM'></span>

<h3>Description</h3>

<p>Change the edgelist to the infinity sparse matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgelist2ISM(elist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgelist2ISM_+3A_elist">elist</code></td>
<td>
<p>the vector of the edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the infinity sparse matrix object
</p>

<hr>
<h2 id='excludeCosts'>Create a skeleton representation of the exclusion edge costs</h2><span id='topic+excludeCosts'></span>

<h3>Description</h3>

<p>Create a skeleton representation of the exclusion edge costs
associated with pairings for a given distance and network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excludeCosts(net, exclude.penalty = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excludeCosts_+3A_net">net</code></td>
<td>
<p>the network structure</p>
</td></tr>
<tr><td><code id="excludeCosts_+3A_exclude.penalty">exclude.penalty</code></td>
<td>
<p>(optional) numeric penalty for excluding a treated
unit; 1 by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the skeleton with exclusion edge cost
</p>

<hr>
<h2 id='extractEdges'>Extract edges from the network</h2><span id='topic+extractEdges'></span>

<h3>Description</h3>

<p>Extract edges from the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractEdges(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractEdges_+3A_net">net</code></td>
<td>
<p>the network representation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of edges
</p>

<hr>
<h2 id='extractSupply'>Extract the supply nodes from the net</h2><span id='topic+extractSupply'></span>

<h3>Description</h3>

<p>Extract the supply nodes from the net
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractSupply(net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractSupply_+3A_net">net</code></td>
<td>
<p>the network representation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector of the supply nodes
</p>

<hr>
<h2 id='flattenSkeleton'>Turns a skeleton representation of edge costs in a network</h2><span id='topic+flattenSkeleton'></span>

<h3>Description</h3>

<p>Turns a skeleton representation of edge costs in a network back
into the vector representation expected by the optimization routine. See
comment on the costSkeleton function for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flattenSkeleton(skeleton)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flattenSkeleton_+3A_skeleton">skeleton</code></td>
<td>
<p>the skeleton structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector representation expected by the optimization routine.
</p>

<hr>
<h2 id='generate_rhos'>Generate rho pairs</h2><span id='topic+generate_rhos'></span>

<h3>Description</h3>

<p>An internal helper function that generates the set of rho value
pairs used for matching. This function is used when exploring the Pareto
optimality of the solutions to the multi-objective optimization in matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_rhos(rho1.list, rho2.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_rhos_+3A_rho1.list">rho1.list</code></td>
<td>
<p>a vector of rho 1 values</p>
</td></tr>
<tr><td><code id="generate_rhos_+3A_rho2.list">rho2.list</code></td>
<td>
<p>a vector of rho 2 values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of (rho1, rho2) pairs
</p>

<hr>
<h2 id='generateBalanceTable'>Generate balance table</h2><span id='topic+generateBalanceTable'></span>

<h3>Description</h3>

<p>The helper function can generate tabular analytics that quantify
covariate imbalance after matching. It only works for the 'Basic' version of
matching (produced by <code>distBalMatch</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateBalanceTable(
  matchingResult,
  covList = NULL,
  display.all = TRUE,
  statList = c("mean.diffs")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateBalanceTable_+3A_matchingresult">matchingResult</code></td>
<td>
<p>an object returned by the main matching function
distBalMatch</p>
</td></tr>
<tr><td><code id="generateBalanceTable_+3A_covlist">covList</code></td>
<td>
<p>(optional) a vector of names of covariates used for evaluating
covariate imbalance; NULL by default.</p>
</td></tr>
<tr><td><code id="generateBalanceTable_+3A_display.all">display.all</code></td>
<td>
<p>(optional) a boolean value indicating whether or not to
show the data for all possible matches; TRUE by default</p>
</td></tr>
<tr><td><code id="generateBalanceTable_+3A_statlist">statList</code></td>
<td>
<p>(optional) a vector of statistics that are calculated for
evaluating the covariate imbalance between treated and control group. The
types that are supported can be found here: <a href="cobalt.html#topic+bal.tab">bal.tab</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result can be either directly used by indexing into the list, or
post-processing by the function <code>compareTables</code> that summarizes the
covariate balance information in a tidier table. Users can specify the
arguments as follows: * <code>covList</code>: if it is set of NULL, all the covariates
are included for the covariate balance table; otherwise, only the specified
covariates will be included in the tabular result. * <code>display.all</code>: by
default, the summary statistics for each match are included when the
argument is set to TRUE. If the user only wants to see the summary
statistics for matches with varying performance on three different
objective values, the function would only display the matches with number
of treated units being excluded at different quantiles. User can switch to
the brief version by setting the parameter to FALSE. * <code>statList</code> is the
list of statistics used for measuring balance. The argument is the same as
<code>stats</code> argument in <a href="cobalt.html#topic+bal.tab">bal.tab</a>, which is the function that is
used for calculating the statistics. By default, only standardized
difference in means is calculated.
</p>


<h3>Value</h3>

<p>a named list object containing covariate balance table and statistics
for numer of units being matched for each match; the names are the
character of index for each match in the <code>matchResult</code>.
</p>


<h3>See Also</h3>

<p>Other numerical analysis helper functions: 
<code><a href="#topic+generateRhoObj">generateRhoObj</a>()</code>,
<code><a href="#topic+getUnmatched">getUnmatched</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate matches
data("lalonde", package="cobalt")
psCols &lt;- c("age", "educ", "married", "nodegree")
treatVal &lt;- "treat"
responseVal &lt;- "re78"
pairDistVal &lt;- c("age", "married", "educ", "nodegree")
exactVal &lt;- c("educ")
myBalVal &lt;- c("race")
r1s &lt;- c( 0.1, 0.3, 0.5, 0.7, 0.9,1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7)
r2s &lt;- c(0.01)
matchResult &lt;- distBalMatch(df=lalonde, treatCol=treatVal, myBalCol=myBalVal,
rhoExclude =r1s, rhoBalance=r2s,
distList=pairDistVal, exactlist=exactVal,
propensityCols = psCols,ignore = c(responseVal), maxUnMatched = 0.1,
caliperOption=NULL, toleranceOption=1e-1, maxIter=0, rho.max.f = 10)

## Generate summary table for balance 
balanceTables &lt;- generateBalanceTable(matchResult)
balanceTableMatch10 &lt;- balanceTables$'10'
</code></pre>

<hr>
<h2 id='generatePairdistanceBalanceGraph'>Total variation imbalance vs. marginal imbalance</h2><span id='topic+generatePairdistanceBalanceGraph'></span>

<h3>Description</h3>

<p>Plotting function that generate sum of pairwise distance vs.
total variation imbalance on specified balance variable. This function only
works for 'Basic' version of matching (conducted using <code>distBalMatch</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePairdistanceBalanceGraph(matchingResult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatePairdistanceBalanceGraph_+3A_matchingresult">matchingResult</code></td>
<td>
<p>an object returned by the main matching function
distBalMatch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for visualization of match result
</p>


<h3>See Also</h3>

<p>Other Graphical helper functions for analysis: 
<code><a href="#topic+generatePairdistanceGraph">generatePairdistanceGraph</a>()</code>,
<code><a href="#topic+generateTVGraph">generateTVGraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate matches 
data("lalonde", package="cobalt")
psCols &lt;- c("age", "educ", "married", "nodegree")
treatVal &lt;- "treat"
responseVal &lt;- "re78"
pairDistVal &lt;- c("age", "married", "educ", "nodegree")
exactVal &lt;- c("educ")
myBalVal &lt;- c("race")
r1s &lt;- c( 0.1, 0.3, 0.5, 0.7, 0.9,1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7)
r2s &lt;- c(0.01)
matchResult &lt;- distBalMatch(df=lalonde, treatCol=treatVal, myBalCol=myBalVal,
rhoExclude =r1s, rhoBalance=r2s,
distList=pairDistVal, exactlist=exactVal,
propensityCols = psCols,ignore = c(responseVal), maxUnMatched = 0.1,
caliperOption=NULL, toleranceOption=1e-1, maxIter=0, rho.max.f = 10)

## Visualize the tradeoff between the pair-wise distance sum and 
## total variation distance 
generatePairdistanceBalanceGraph(matchResult)
</code></pre>

<hr>
<h2 id='generatePairdistanceGraph'>Distance vs. exclusion</h2><span id='topic+generatePairdistanceGraph'></span>

<h3>Description</h3>

<p>Plotting function that generate sum of pair-wise distance vs.
number of unmatched treated units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePairdistanceGraph(matchingResult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatePairdistanceGraph_+3A_matchingresult">matchingResult</code></td>
<td>
<p>an object returned by the main matching function
distBalMatch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for visualization of match result
</p>


<h3>See Also</h3>

<p>Other Graphical helper functions for analysis: 
<code><a href="#topic+generatePairdistanceBalanceGraph">generatePairdistanceBalanceGraph</a>()</code>,
<code><a href="#topic+generateTVGraph">generateTVGraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate matches 
data("lalonde", package="cobalt")
psCols &lt;- c("age", "educ", "married", "nodegree")
treatVal &lt;- "treat"
responseVal &lt;- "re78"
pairDistVal &lt;- c("age", "married", "educ", "nodegree")
exactVal &lt;- c("educ")
myBalVal &lt;- c("race")
r1s &lt;- c( 0.1, 0.3, 0.5, 0.7, 0.9,1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7)
r2s &lt;- c(0.01)
matchResult &lt;- distBalMatch(df=lalonde, treatCol=treatVal, myBalCol=myBalVal,
rhoExclude =r1s, rhoBalance=r2s,
distList=pairDistVal, exactlist=exactVal,
propensityCols = psCols,ignore = c(responseVal), maxUnMatched = 0.1,
caliperOption=NULL, toleranceOption=1e-1, maxIter=0, rho.max.f = 10)

## Generate visualization of tradeoff between pari-wise distance sum and 
## number of treated units left unmatched
generatePairdistanceGraph(matchResult)
</code></pre>

<hr>
<h2 id='generateRhoObj'>Penalty and objective values summary</h2><span id='topic+generateRhoObj'></span>

<h3>Description</h3>

<p>Helper function to generate a dataframe with matching number,
penalty (rho) values, and objective function values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateRhoObj(matchingResult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateRhoObj_+3A_matchingresult">matchingResult</code></td>
<td>
<p>matchingResult object that contains information for all
matches.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe that contains objective function values and rho values
corresponding coefficients before each objective function.
</p>


<h3>See Also</h3>

<p>Other numerical analysis helper functions: 
<code><a href="#topic+generateBalanceTable">generateBalanceTable</a>()</code>,
<code><a href="#topic+getUnmatched">getUnmatched</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate matches
x1 = rnorm(100, 0, 0.5)
x2 = rnorm(100, 0, 0.1)
x3 = rnorm(100, 0, 1)
x4 = rnorm(100, x1, 0.1)
r1ss &lt;- seq(0.1,50, 10)
r2ss &lt;- seq(0.1,50, 10)
x = cbind(x1, x2, x3,x4)
z = sample(c(rep(1, 50), rep(0, 50)))
e1 = rnorm(100, 0, 1.5)
e0 = rnorm(100, 0, 1.5)
y1impute = x1^2 + 0.6*x2^2 + 1 + e1
y0impute = x1^2 + 0.6*x2^2 + e0
treat = (z==1)
y = ifelse(treat, y1impute, y0impute)
names(x) &lt;- c("x1", "x2", "x3", "x4")
df &lt;- data.frame(cbind(z, y, x))
df$x5 &lt;- 1
names(x) &lt;- c("x1", "x2", "x3", "x4")
df &lt;- data.frame(cbind(z, y, x))
df$x5 &lt;- 1
d1 &lt;- as.matrix(dist(df["x1"]))
d2 &lt;- as.matrix(dist(df["x2"]))
idx &lt;- 1:length(z)
treatedUnits &lt;- idx[z==1]
controlUnits &lt;- idx[z==0]
d1 &lt;- as.matrix(d1[treatedUnits, controlUnits])
d2 &lt;- as.matrix(d2[treatedUnits, controlUnits])
matchResult1 &lt;- twoDistMatch(df, "z", "y", dMat1=d1, dType1= "User", dMat2=d2,
dType2="User", myBalCol=c("x5"), rhoExclude=r1ss, rhoDistance=r2ss,
propensityCols = c("x1")) 

## Generate tabular summary 
generateRhoObj(matchResult1)
</code></pre>

<hr>
<h2 id='generateTVGraph'>Marginal imbalance vs. exclusion</h2><span id='topic+generateTVGraph'></span>

<h3>Description</h3>

<p>Plotting function that visualizes the tradeoff between the total
variation imbalance on a specified variable and the number of unmatched
treated units. This function only works for the 'Basic' version of matching
(conducted using <code>distBalMatch</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateTVGraph(matchingResult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateTVGraph_+3A_matchingresult">matchingResult</code></td>
<td>
<p>an object returned by the main matching function
distBalMatch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for visualization of match result
</p>


<h3>See Also</h3>

<p>Other Graphical helper functions for analysis: 
<code><a href="#topic+generatePairdistanceBalanceGraph">generatePairdistanceBalanceGraph</a>()</code>,
<code><a href="#topic+generatePairdistanceGraph">generatePairdistanceGraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate matches 
data("lalonde", package="cobalt")
psCols &lt;- c("age", "educ", "married", "nodegree")
treatVal &lt;- "treat"
responseVal &lt;- "re78"
pairDistVal &lt;- c("age", "married", "educ", "nodegree")
exactVal &lt;- c("educ")
myBalVal &lt;- c("race")
r1s &lt;- c( 0.1, 0.3, 0.5, 0.7, 0.9,1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7)
r2s &lt;- c(0.01)
matchResult &lt;- distBalMatch(df=lalonde, treatCol=treatVal, myBalCol=myBalVal,
rhoExclude =r1s, rhoBalance=r2s,
distList=pairDistVal, exactlist=exactVal,
propensityCols = psCols,ignore = c(responseVal), maxUnMatched = 0.1,
caliperOption=NULL, toleranceOption=1e-1, maxIter=0, rho.max.f = 10)

## Generate visualization of tradeoff between total variation distance and 
## number of treated units left unmatched
generateTVGraph(matchResult)
</code></pre>

<hr>
<h2 id='get_five_index'>An internal helper function that gives the index of matching with a wide
range of number of treated units left unmatched</h2><span id='topic+get_five_index'></span>

<h3>Description</h3>

<p>An internal helper function that gives the index of matching with a wide
range of number of treated units left unmatched
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_five_index(matchingResult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_five_index_+3A_matchingresult">matchingResult</code></td>
<td>
<p>an object returned by the main matching function
distBalMatch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of five matching indices with the number of treated units
excluded at 0th, 25th, 50th, 75th and 100th percentiles respectively.
</p>

<hr>
<h2 id='getExactOn'>Generate a factor for exact matching.</h2><span id='topic+getExactOn'></span>

<h3>Description</h3>

<p>Generate a factor for exact matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExactOn(dat, exactList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getExactOn_+3A_dat">dat</code></td>
<td>
<p>dataframe containing all the variables in exactList</p>
</td></tr>
<tr><td><code id="getExactOn_+3A_exactlist">exactList</code></td>
<td>
<p>factor of names of the variables on which we want exact or
close matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>factor on which to match exactly, with labels given by concatenating
labels for input variables.
</p>

<hr>
<h2 id='getPropensityScore'>Fit propensity scores using logistic regression.</h2><span id='topic+getPropensityScore'></span>

<h3>Description</h3>

<p>Fit propensity scores using logistic regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPropensityScore(df, covs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPropensityScore_+3A_df">df</code></td>
<td>
<p>dataframe that contains a column named &quot;treat&quot;, the treatment
vector, and columns of covariates specified.</p>
</td></tr>
<tr><td><code id="getPropensityScore_+3A_covs">covs</code></td>
<td>
<p>factor of column names of covariates used for fitting a
propensity score model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of estimated propensity scores (on the probability scale).
</p>

<hr>
<h2 id='getUnmatched'>Get unmatched percentage</h2><span id='topic+getUnmatched'></span>

<h3>Description</h3>

<p>A function that generate the percentage of unmatched units for
each match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getUnmatched(matchingResult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getUnmatched_+3A_matchingresult">matchingResult</code></td>
<td>
<p>matchingResult object that contains information for all
matches</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with three columns, one containing the matching index, one
containing the number of matched units, and one conatining the percentage
of matched units (out of original treated group size).
</p>


<h3>See Also</h3>

<p>Other numerical analysis helper functions: 
<code><a href="#topic+generateBalanceTable">generateBalanceTable</a>()</code>,
<code><a href="#topic+generateRhoObj">generateRhoObj</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getUnmatched(matchResult)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeInfinitySparseMatrix'>Internal helper to build infinity sparse matrix</h2><span id='topic+makeInfinitySparseMatrix'></span>

<h3>Description</h3>

<p>Formats the data and make a call to
<a href="optmatch.html#topic+InfinitySparseMatrix-class">InfinitySparseMatrix-class</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeInfinitySparseMatrix(
  data,
  cols,
  rows,
  colnames = NULL,
  rownames = NULL,
  dimension = NULL,
  call = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeInfinitySparseMatrix_+3A_data">data</code></td>
<td>
<p>the input numeric vector of cost</p>
</td></tr>
<tr><td><code id="makeInfinitySparseMatrix_+3A_cols">cols</code></td>
<td>
<p>the input numeric vector corresponding to control units</p>
</td></tr>
<tr><td><code id="makeInfinitySparseMatrix_+3A_rows">rows</code></td>
<td>
<p>the input numeric vector corresponding to treated units</p>
</td></tr>
<tr><td><code id="makeInfinitySparseMatrix_+3A_colnames">colnames</code></td>
<td>
<p>(optional) vector containing names for all control units</p>
</td></tr>
<tr><td><code id="makeInfinitySparseMatrix_+3A_rownames">rownames</code></td>
<td>
<p>(optional) vector containing names for all treated units</p>
</td></tr>
<tr><td><code id="makeInfinitySparseMatrix_+3A_dimension">dimension</code></td>
<td>
<p>(optional) vector of number of treated and control units</p>
</td></tr>
<tr><td><code id="makeInfinitySparseMatrix_+3A_call">call</code></td>
<td>
<p>(optional) funtion call used to create the InfinitySparseMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an InfinitySparseMatrix object
</p>

<hr>
<h2 id='makeSparse'>Helper function to mask edges</h2><span id='topic+makeSparse'></span>

<h3>Description</h3>

<p>Remove some of the treatment-control edges from a network flow
representation of a match (forbidding those pairings)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSparse(net, mask, replaceMask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeSparse_+3A_net">net</code></td>
<td>
<p>the network object</p>
</td></tr>
<tr><td><code id="makeSparse_+3A_mask">mask</code></td>
<td>
<p>a matrix indicating whether to exclude the corresponding edge</p>
</td></tr>
<tr><td><code id="makeSparse_+3A_replacemask">replaceMask</code></td>
<td>
<p>(optional) whether to mask</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the masked network structure object
</p>

<hr>
<h2 id='matched_index'>An internal helper function that translate the matching index in the sorted
data frame to the original dataframe's row index</h2><span id='topic+matched_index'></span>

<h3>Description</h3>

<p>An internal helper function that translate the matching index in the sorted
data frame to the original dataframe's row index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matched_index(matchingResult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matched_index_+3A_matchingresult">matchingResult</code></td>
<td>
<p>an object returned by the main matching function
distBalMatch</p>
</td></tr>
</table>

<hr>
<h2 id='matchedData'>Get matched dataframe</h2><span id='topic+matchedData'></span>

<h3>Description</h3>

<p>A function that returns the dataframe that contains only matched
pairs from the original data frame with specified match index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchedData(matchingResult, match_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchedData_+3A_matchingresult">matchingResult</code></td>
<td>
<p>an object returned by the main matching function
distBalMatch</p>
</td></tr>
<tr><td><code id="matchedData_+3A_match_num">match_num</code></td>
<td>
<p>Integer index of match that the user want to extract paired
observations from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe that contains only matched pair data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate Matches
x1 = rnorm(100, 0, 0.5)
x2 = rnorm(100, 0, 0.1)
x3 = rnorm(100, 0, 1)
x4 = rnorm(100, x1, 0.1)
r1ss &lt;- seq(0.1,50, 10)
r2ss &lt;- seq(0.1,50, 10)
x = cbind(x1, x2, x3,x4)
z = sample(c(rep(1, 50), rep(0, 50)))
e1 = rnorm(100, 0, 1.5)
e0 = rnorm(100, 0, 1.5)
y1impute = x1^2 + 0.6*x2^2 + 1 + e1
y0impute = x1^2 + 0.6*x2^2 + e0
treat = (z==1)
y = ifelse(treat, y1impute, y0impute)
names(x) &lt;- c("x1", "x2", "x3", "x4")
df &lt;- data.frame(cbind(z, y, x))
df$x5 &lt;- 1
names(x) &lt;- c("x1", "x2", "x3", "x4")
df &lt;- data.frame(cbind(z, y, x))
df$x5 &lt;- 1
d1 &lt;- as.matrix(dist(df["x1"]))
d2 &lt;- as.matrix(dist(df["x2"]))
idx &lt;- 1:length(z)
treatedUnits &lt;- idx[z==1]
controlUnits &lt;- idx[z==0]
d1 &lt;- as.matrix(d1[treatedUnits, controlUnits])
d2 &lt;- as.matrix(d2[treatedUnits, controlUnits])
matchResult1 &lt;- twoDistMatch(df, "z", "y", dMat1=d1, dType1= "User", dMat2=d2,
dType2="User", myBalCol=c("x5"), rhoExclude=r1ss, rhoDistance=r2ss,
propensityCols = c("x1")) 
matchedData(matchResult1, 1)
</code></pre>

<hr>
<h2 id='matrix2cost'>change the distance matrix to cost</h2><span id='topic+matrix2cost'></span>

<h3>Description</h3>

<p>change the distance matrix to cost
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2cost(net, distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix2cost_+3A_net">net</code></td>
<td>
<p>the network structure</p>
</td></tr>
<tr><td><code id="matrix2cost_+3A_distance">distance</code></td>
<td>
<p>distance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the vector of cost
</p>

<hr>
<h2 id='matrix2edgelist'>Helper function to convert matrix to list</h2><span id='topic+matrix2edgelist'></span>

<h3>Description</h3>

<p>Convert between a matrix representation of distances between
treated and control units and a list of vectors (default format for
build.dist.struct function in rcbalance package)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2edgelist(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix2edgelist_+3A_mat">mat</code></td>
<td>
<p>matrix representation of distances between treated and control
units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of vector representation of distances
</p>

<hr>
<h2 id='meldMask'>Helper function to combine two sparse distances</h2><span id='topic+meldMask'></span>

<h3>Description</h3>

<p>Combine two sparse distances,
allowing only pairings allowed by both
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meldMask(mask1, mask2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meldMask_+3A_mask1">mask1</code></td>
<td>
<p>matrix of the first mask</p>
</td></tr>
<tr><td><code id="meldMask_+3A_mask2">mask2</code></td>
<td>
<p>matrix of the second mask</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined mask structure
</p>

<hr>
<h2 id='netFlowMatch'>Create network flow structure</h2><span id='topic+netFlowMatch'></span>

<h3>Description</h3>

<p>Create network flow structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netFlowMatch(z, IDs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netFlowMatch_+3A_z">z</code></td>
<td>
<p>a vector of treatment vectors</p>
</td></tr>
<tr><td><code id="netFlowMatch_+3A_ids">IDs</code></td>
<td>
<p>(optional) the name of the units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a networks structure
</p>

<hr>
<h2 id='obj.to.match'>An internal helper function that transforms the output from the RELAX
algorithm to a data structure that is more interpretable for the output of
the main matching function</h2><span id='topic+obj.to.match'></span>

<h3>Description</h3>

<p>An internal helper function that transforms the output from the RELAX
algorithm to a data structure that is more interpretable for the output of
the main matching function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj.to.match(out.elem, already.done = NULL, prev.obj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj.to.match_+3A_out.elem">out.elem</code></td>
<td>
<p>a named list whose elements are: (1) the net structure (2)
the edge weights of pair-wise distance (3) the edge weights of marginal
balance (4) the list of rho value pairs (5) the named list of solutions
from the RELAX algorithm</p>
</td></tr>
<tr><td><code id="obj.to.match_+3A_already.done">already.done</code></td>
<td>
<p>a factor indicating the index of matches already been
transformed</p>
</td></tr>
<tr><td><code id="obj.to.match_+3A_prev.obj">prev.obj</code></td>
<td>
<p>an object of previously transformed matches</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with elements containing matching information useful for
the main matching function
</p>

<hr>
<h2 id='pairCosts'>Create a skeleton representation of the edge costs</h2><span id='topic+pairCosts'></span>

<h3>Description</h3>

<p>Create a skeleton representation of the edge costs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairCosts(dist.struct, net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairCosts_+3A_dist.struct">dist.struct</code></td>
<td>
<p>the distance structure</p>
</td></tr>
<tr><td><code id="pairCosts_+3A_net">net</code></td>
<td>
<p>the net structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the skeleton representation of the given distance pairs and the net
</p>

<hr>
<h2 id='rho_proposition'>Generate penalty coefficient pairs</h2><span id='topic+rho_proposition'></span>

<h3>Description</h3>

<p>An internal helper function used for automatically generating
the set of rho values used for grid search in exploring the Pareto optimal
set of solutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho_proposition(
  paircosts.list,
  rho.max.factor = 10,
  rho1old,
  rho2old,
  rho.min = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rho_proposition_+3A_paircosts.list">paircosts.list</code></td>
<td>
<p>a vector of pair-wise distance.</p>
</td></tr>
<tr><td><code id="rho_proposition_+3A_rho.max.factor">rho.max.factor</code></td>
<td>
<p>a numeric value indicating the maximal rho values.</p>
</td></tr>
<tr><td><code id="rho_proposition_+3A_rho1old">rho1old</code></td>
<td>
<p>a vector of numeric values of rho1 used before.</p>
</td></tr>
<tr><td><code id="rho_proposition_+3A_rho2old">rho2old</code></td>
<td>
<p>a vector of numeric values of rho2 used before.</p>
</td></tr>
<tr><td><code id="rho_proposition_+3A_rho.min">rho.min</code></td>
<td>
<p>smallest rho value to consider.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of pairs of rho values for future search.
</p>

<hr>
<h2 id='solveP'>Solve the network flow problem - basic version</h2><span id='topic+solveP'></span>

<h3>Description</h3>

<p>Solve the network flow problem - basic version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveP(net, f1.list, f2.list, rho, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveP_+3A_net">net</code></td>
<td>
<p>the network representation</p>
</td></tr>
<tr><td><code id="solveP_+3A_f1.list">f1.list</code></td>
<td>
<p>the list of the first objective functions values for each node</p>
</td></tr>
<tr><td><code id="solveP_+3A_f2.list">f2.list</code></td>
<td>
<p>the list of the second objective functions values for each
node</p>
</td></tr>
<tr><td><code id="solveP_+3A_rho">rho</code></td>
<td>
<p>the penalty coefficient</p>
</td></tr>
<tr><td><code id="solveP_+3A_tol">tol</code></td>
<td>
<p>the tolerance value for precision</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the solution represented in a named list
</p>

<hr>
<h2 id='solveP1'>Solve the network flow problem - twoDistMatch</h2><span id='topic+solveP1'></span>

<h3>Description</h3>

<p>Solve the network flow problem - twoDistMatch
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solveP1(net, f1.list, f2.list, f3.list, rho1, rho2 = 0, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="solveP1_+3A_net">net</code></td>
<td>
<p>the network representation</p>
</td></tr>
<tr><td><code id="solveP1_+3A_f1.list">f1.list</code></td>
<td>
<p>the list of the first objective functions values for
each node</p>
</td></tr>
<tr><td><code id="solveP1_+3A_f2.list">f2.list</code></td>
<td>
<p>the list of the second objective functions values for
each node</p>
</td></tr>
<tr><td><code id="solveP1_+3A_f3.list">f3.list</code></td>
<td>
<p>the list of the third objective functions values for
each node</p>
</td></tr>
<tr><td><code id="solveP1_+3A_rho1">rho1</code></td>
<td>
<p>the penalty coefficient for the second objective</p>
</td></tr>
<tr><td><code id="solveP1_+3A_rho2">rho2</code></td>
<td>
<p>the penalty coefficient for the third objective</p>
</td></tr>
<tr><td><code id="solveP1_+3A_tol">tol</code></td>
<td>
<p>the tolerance value for precision</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the solution represented in a named list
</p>

<hr>
<h2 id='twoDistMatch'>Optimal tradeoffs among two distances and exclusion</h2><span id='topic+twoDistMatch'></span>

<h3>Description</h3>

<p>Explores tradeoffs among three objective functions in
multivariate matching: sums of two different user-specified  covariate
distances within matched pairs, and the number of treated units included in
the match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoDistMatch(
  dType1 = "user",
  dType2 = "user",
  dMat1 = NULL,
  df = NULL,
  dMat2 = NULL,
  treatCol = NULL,
  distList1 = NULL,
  distList2 = NULL,
  rhoExclude = c(1),
  rhoDistance = c(1, 2, 3),
  myBalCol = NULL,
  exactlist = NULL,
  propensityCols = NULL,
  pScores = NULL,
  ignore = NULL,
  maxUnMatched = 0.25,
  caliperOption = NULL,
  toleranceOption = 0.01,
  maxIter = 0,
  rho.max.f = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoDistMatch_+3A_dtype1">dType1</code></td>
<td>
<p>One of (&quot;Euclidean&quot;, &quot;Mahalanobis&quot;, &quot;user&quot;) indicating the type
of distance that are used for the first distance objective functions. NULL
by default.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_dtype2">dType2</code></td>
<td>
<p>One of (&quot;Euclidean&quot;, &quot;Mahalanobis&quot;, &quot;user&quot;)  charactor
indicating the type of distance that are used for the second distance
objective functions. NULL by default.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_dmat1">dMat1</code></td>
<td>
<p>(optional) matrix object that represents the distance matrix
using the first distance measure; <code>dType</code> must be passed in as &quot;user&quot; if
dMat is non-empty</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_df">df</code></td>
<td>
<p>(optional) data frame that contain columns indicating treatment,
outcome and covariates</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_dmat2">dMat2</code></td>
<td>
<p>(optional) matrix object that represents the distance matrix
using the second distance measure; <code>dType1</code> must be passed in as &quot;user&quot; if
dMat is non-empty</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_treatcol">treatCol</code></td>
<td>
<p>(optional) character, name of the column indicating treatment
assignment.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_distlist1">distList1</code></td>
<td>
<p>(optional) character vector names of the variables used for
calculating covariate distance using first distance measure specified by
dType</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_distlist2">distList2</code></td>
<td>
<p>(optional) character vector, names of the variables used for
calculating covariate distance using second distance measure specified by
dType1</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_rhoexclude">rhoExclude</code></td>
<td>
<p>(optional) numeric vector, penalty values associated with
the distance specified by <code>dMat</code> or <code>dType</code>. Default value is c(1).</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_rhodistance">rhoDistance</code></td>
<td>
<p>(optional) numeric vector, penalty values associated with
the distance specified by <code>dMat1</code> or <code>dType1</code>. Default value is c(1,2,3).</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_mybalcol">myBalCol</code></td>
<td>
<p>(optional) character, column name of the variable on which to
evaluate balance.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_exactlist">exactlist</code></td>
<td>
<p>(optional) character vector, names of the variables on which
to match exactly; NULL by default.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_propensitycols">propensityCols</code></td>
<td>
<p>character vector, names of columns on which to fit a
propensity score model.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_pscores">pScores</code></td>
<td>
<p>(optional) character, name of the column containing fitted
propensity scores; default is NULL.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_ignore">ignore</code></td>
<td>
<p>(optional) character vector of variable names that should be
ignored when constructing the internal matching. NULL by default.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_maxunmatched">maxUnMatched</code></td>
<td>
<p>(optional) numeric, maximum proportion of unmatched units
that can be accepted; default is 0.25.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_caliperoption">caliperOption</code></td>
<td>
<p>(optional) numeric, the propensity score caliper value
in standard deviations of the estimated propensity scores; default is NULL,
which is no caliper.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_toleranceoption">toleranceOption</code></td>
<td>
<p>(optional) numeric, tolerance of close match distance;
default is 1e-2.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_maxiter">maxIter</code></td>
<td>
<p>(optional) integer,  maximum number of iterations to use in
searching for penalty combintions that improve the matching; default is 0.</p>
</td></tr>
<tr><td><code id="twoDistMatch_+3A_rho.max.f">rho.max.f</code></td>
<td>
<p>(optional) numeric, the scaling factor used in proposal for
rhos; default is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matched designs generated by this function are Pareto optimal for
the three objective functions.  The degree of relative emphasis among the
three objectives in any specific solution is controlled by the penalties,
denoted by Greek letter rho. Larger values for the penalties associated with
the two distances correspond to increased emphasis close matching on these
distances, at the possible cost of excluding more treated units. Additional
details:
</p>

<ul>
<li><p> Users may either specify their own distance matrices (specifying
the <code>user</code> option in <code>dType1</code> and/or <code>dType2</code> and supplying arguments to
<code>dMat1</code> and/or <code>dMat2</code> respectively) or ask the function to create
Mahalanobis or Euclidean distances on sets of covariates specified by the
<code>distList1</code> and <code>distList2</code> arguments. If <code>dType1</code> or <code>dType2</code> is not
specified, if one of these is set to <code>user</code> and the corresponding <code>dMat1</code>
argument is not provided, or if one is NOT set to <code>user</code> and the
corresponding <code>distList1</code> argument is not provided, an error will result.
</p>
</li>
<li><p> User-specified distance matrices passed to <code>dMat1</code> or <code>dMat2</code> should have row
count equal to the number of treated units and column count equal to the
number of controls.
</p>
</li>
<li><p> If the <code>caliperOption</code> argument is specified, a
propensity score caliper will be imposed, forbidding matches between units
more than a fixed distance apart on the propensity score.  The caliper will
be based either on a user-fit propensity score, identified in the input
dataframe by argument <code>pScores</code>, or by an internally-fit propensity score
based on logistic regression against the variables named in <code>psoreCols</code>.  If
<code>caliperOption</code> is non-NULL and neither of the other arguments is specified
an error will result.
</p>
</li>
<li> <p><code>toleranceOption</code> controls the precision at which the
objective functions is evaluated. When matching problems are especially large
or complex it may be necessary to increase toleranceOption in order to
prevent integer overflows in the underlying network flow solver; generally
this will be suggested in appropariate warning messages.
</p>
</li>
<li><p> While by default
tradeoffs are only assessed at penalty combinations provided by the user, the
user may ask for the algorithm to search over additional penalty values in
order to identify additional Pareto optimal solutions. <code>rho.max.f</code> is a
multiplier applied to initial penalty values to discover new solutions, and
setting it larger leads to wider exploration; similarly, <code>maxIter</code> controls
how long the exploration routine runs, with larger values leading to more
exploration.
</p>
</li></ul>



<h3>Value</h3>

<p>a named list whose elements are:
</p>

<ul>
<li><p> &quot;rhoList&quot;: list of penalty
combinations for each match
</p>
</li>
<li><p> &quot;matchList&quot;: list of matches indexed by
number
</p>
</li>
<li><p> &quot;treatmentCol&quot;: character of treatment variable
</p>
</li>
<li><p> &quot;covs&quot;:character vector of names of the variables used for calculating within-pair
distance
</p>
</li>
<li><p> &quot;exactCovs&quot;: character vector of names of variables that we want
exact or close match on
</p>
</li>
<li><p> &quot;idMapping&quot;: numeric vector of row indices for
each observation in the sorted data frame for internal use
</p>
</li>
<li><p> &quot;stats&quot;: data
frame of important statistics (total variation distance) for variable on
which marginal balance is measured
</p>
</li>
<li><p> &quot;b.var&quot;: character, name of variable
on which marginal balance is measured (left NULL since no balance
constraint is imposed here).
</p>
</li>
<li><p> &quot;dataTable&quot;: data frame sorted by treatment
value
</p>
</li>
<li><p> &quot;t&quot;: a treatment vector
</p>
</li>
<li><p> &quot;df&quot;: the original dataframe input by the
user
</p>
</li>
<li><p> &quot;pair_cost1&quot;: list of pair-wise distance sum using the first
distance measure
</p>
</li>
<li><p> &quot;pair_cost2&quot;: list of pair-wise distance sum using the
second distance measure
</p>
</li>
<li><p> &quot;version&quot;: (for internal use) the version of the
matching function called; &quot;Basic&quot; indicates the matching comes from
distBalMatch and &quot;Advanced&quot; from twoDistMatch.
</p>
</li>
<li><p> &quot;fDist1&quot;: a vector of
values for the first objective function; it corresponds to the pair-wise
distance sum according to the first distance measure.
</p>
</li>
<li><p> &quot;fExclude&quot;: a
vector of values for the second objective function; it corresponds to the
number of treated units being unmatched.
</p>
</li>
<li><p> &quot;fDist2&quot;: a vector of values for
the third objective function; it corresponds to the pair-wise distance sum
corresponds to the
</p>
</li></ul>



<h3>See Also</h3>

<p>Other main matching function: 
<code><a href="#topic+distBalMatch">distBalMatch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 = rnorm(100, 0, 0.5)
x2 = rnorm(100, 0, 0.1)
x3 = rnorm(100, 0, 1)
x4 = rnorm(100, x1, 0.1)
r1ss &lt;- seq(0.1,50, 10)
r2ss &lt;- seq(0.1,50, 10)
x = cbind(x1, x2, x3,x4)
z = sample(c(rep(1, 50), rep(0, 50)))
e1 = rnorm(100, 0, 1.5)
e0 = rnorm(100, 0, 1.5)
y1impute = x1^2 + 0.6*x2^2 + 1 + e1
y0impute = x1^2 + 0.6*x2^2 + e0
treat = (z==1)
y = ifelse(treat, y1impute, y0impute)
names(x) &lt;- c("x1", "x2", "x3", "x4")
df &lt;- data.frame(cbind(z, y, x))
df$x5 &lt;- 1
names(x) &lt;- c("x1", "x2", "x3", "x4")
df &lt;- data.frame(cbind(z, y, x))
df$x5 &lt;- 1
d1 &lt;- as.matrix(dist(df["x1"]))
d2 &lt;- as.matrix(dist(df["x2"]))
idx &lt;- 1:length(z)
treatedUnits &lt;- idx[z==1]
controlUnits &lt;- idx[z==0]
d1 &lt;- as.matrix(d1[treatedUnits, controlUnits])
d2 &lt;- as.matrix(d2[treatedUnits, controlUnits])
matchResult1 &lt;- twoDistMatch(df, "z", "y", dMat1=d1, dType1= "User", dMat2=d2,
dType2="User", myBalCol=c("x5"), rhoExclude=r1ss, rhoDistance=r2ss,
propensityCols = c("x1")) 
</code></pre>

<hr>
<h2 id='visualize'>Visualize tradeoffs</h2><span id='topic+visualize'></span>

<h3>Description</h3>

<p>Main visualization functions for showing the tradeoffs between
two of the three objective functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualize(
  matchingResult,
  x_axis = "dist1",
  y_axis = "dist2",
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  display_all = FALSE,
  cond = NULL,
  xlim = NULL,
  ylim = NULL,
  display_index = TRUE,
  average_cost = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualize_+3A_matchingresult">matchingResult</code></td>
<td>
<p>the matching result returned by either distBalMatch or
twoDistMatch.</p>
</td></tr>
<tr><td><code id="visualize_+3A_x_axis">x_axis</code></td>
<td>
<p>character, naming the objective function shown on x-axis; one
of (&quot;pair&quot;, &quot;marginal&quot;, &quot;dist1&quot;, &quot;dist2&quot;, &quot;exclude&quot;), &quot;dist1&quot; by default.</p>
</td></tr>
<tr><td><code id="visualize_+3A_y_axis">y_axis</code></td>
<td>
<p>character, naming the objective function shown on y-axis; one
of (&quot;pair&quot;, &quot;marginal&quot;, &quot;dist1&quot;, &quot;dist2&quot;, &quot;exclude&quot;), &quot;dist2&quot; by default.</p>
</td></tr>
<tr><td><code id="visualize_+3A_xlab">xlab</code></td>
<td>
<p>(optional) the axis label for x-axis; NULL by default.</p>
</td></tr>
<tr><td><code id="visualize_+3A_ylab">ylab</code></td>
<td>
<p>(optional) the axis label for y-axis; NULL by default.</p>
</td></tr>
<tr><td><code id="visualize_+3A_main">main</code></td>
<td>
<p>(optional) the title of the graph; NULL by default.</p>
</td></tr>
<tr><td><code id="visualize_+3A_display_all">display_all</code></td>
<td>
<p>(optional) whether to show all the labels for match index;
FALSE by default, which indicates the visualization function only labels
matches at quantiles of number of treated units being excluded.</p>
</td></tr>
<tr><td><code id="visualize_+3A_cond">cond</code></td>
<td>
<p>(optional) NULL by default, which denotes all the matches are
shown; otherwise, takes a list of boolean values indicating whether to
include each match</p>
</td></tr>
<tr><td><code id="visualize_+3A_xlim">xlim</code></td>
<td>
<p>(optional) NULL by default; function automatically takes the max
of the first objective function values being plotted on x-axis;
if specified otherwise, pass in the numeric vector
c(lower_bound, upper_bound)</p>
</td></tr>
<tr><td><code id="visualize_+3A_ylim">ylim</code></td>
<td>
<p>(optional) NULL by default; function automatically takes the max
of the first objective function values being plotted on y-axis;
if specified otherwise, pass in the numeric vector
c(lower_bound, upper_bound)</p>
</td></tr>
<tr><td><code id="visualize_+3A_display_index">display_index</code></td>
<td>
<p>(optional) TRUE by default; whether to display match
index</p>
</td></tr>
<tr><td><code id="visualize_+3A_average_cost">average_cost</code></td>
<td>
<p>(optional) FALSE by default; whether to show mean cost</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the plotting function will show the tradeoff between
the first distance objective function and the marginal balance (if
distBalMatch) is used; or simply the second distance objective function, if
twoDistMatch is used.
</p>


<h3>Value</h3>

<p>No return value, called for visualization of match result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate matches
data("lalonde", package="cobalt")
psCols &lt;- c("age", "educ", "married", "nodegree", "race")
treatVal &lt;- "treat"
responseVal &lt;- "re78"  
pairDistVal &lt;- c("age", "married", "educ", "nodegree", "race")
myBalVal &lt;- c("race")
r1s &lt;- c(0.01,1,2,4,4.4,5.2,5.4,5.6,5.8,6)
r2s &lt;- c(0.001)
matchResult &lt;- distBalMatch(df=lalonde, treatCol= treatVal, 
myBalCol = myBalVal, rhoExclude=r1s, rhoBalance=r2s, distList = pairDistVal, 
propensityCols = psCols, maxIter=0)
## Visualization
visualize(matchResult, "marginal", "exclude")
visualize(matchResult, "pair", "exclude")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
