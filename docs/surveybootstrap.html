<!DOCTYPE html><html><head><title>Help for package surveybootstrap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {surveybootstrap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootstrap.estimates'><p>bootstrap.estimates</p></a></li>
<li><a href='#chain.data'><p>Get a dataset from a chain</p></a></li>
<li><a href='#chain.size'><p>Get the size of a chain</p></a></li>
<li><a href='#chain.vals'><p>Get all of the values of the given variable</p>
found among members of a chain</a></li>
<li><a href='#estimate.degree.distns'><p>Estimate degree distributions by trait</p></a></li>
<li><a href='#estimate.mixing'><p>Construct a mixing model from GoC/RDS data</p></a></li>
<li><a href='#get.fn'><p>Grab a function based on its name</p></a></li>
<li><a href='#get.var'><p>Get a variable from a dataframe or vector</p></a></li>
<li><a href='#get.weights'><p>Get the weights column from a dataframe</p></a></li>
<li><a href='#is.child.ct'><p>Determine whether or not one id is a parent of another</p></a></li>
<li><a href='#make.chain'><p>Build an RDS seed's chain from the dataset</p></a></li>
<li><a href='#max.depth'><p>Get the height (maximum depth) of a chain</p></a></li>
<li><a href='#mc.sim'><p>Run a markov model</p></a></li>
<li><a href='#MU284'><p>The MU284 Population dataset</p></a></li>
<li><a href='#MU284.boot.res.summ'><p>Benchmarks for unit tests</p></a></li>
<li><a href='#MU284.complex.surveys'><p>Simulated sample surveys drawn from the MU284 Population using a complex design</p></a></li>
<li><a href='#MU284.estimator.fn'><p>MU284.estimator.fn</p></a></li>
<li><a href='#MU284.estimator.summary.fn'><p>MU284.estimator.summary.fn</p></a></li>
<li><a href='#MU284.surveys'><p>Simulated sample surveys drawn from the MU284 Population</p></a></li>
<li><a href='#parse_design'><p>Parse a formula that describes the design of a survey</p></a></li>
<li><a href='#rds.boot.draw.chain'><p>Draw RDS bootstrap resamples for one chain</p></a></li>
<li><a href='#rds.chain.boot.draws'><p>Draw RDS bootstrap resamples</p></a></li>
<li><a href='#rds.mc.boot.draws'><p>Draw RDS bootstrap resamples using the</p>
algorithm in Salganik 2006 (see Details below)</a></li>
<li><a href='#rescaled.bootstrap.sample'><p>rescaled.bootstrap.sample</p></a></li>
<li><a href='#rescaled.bootstrap.sample.pureR'><p>rescaled.bootstrap.sample.pureR</p></a></li>
<li><a href='#rescaled.bootstrap.weights'><p>rescaled.bootstrap.weights</p></a></li>
<li><a href='#srs.bootstrap.sample'><p>srs.bootstrap.sample</p></a></li>
<li><a href='#surveybootstrap'><p>Survey bootstrap variance estimators</p></a></li>
<li><a href='#traits.to.string'><p>Take a set of traits and turn into a string</p></a></li>
<li><a href='#unparse.trait'><p>Unparse a collapsed trait string</p></a></li>
<li><a href='#vcat'><p>Only prints things out in verbose mode</p></a></li>
<li><a href='#weighted.mean'><p>Compute the weighted mean</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bootstrap with Survey Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements different kinds of bootstraps
    to estimate sampling variation from survey data with 
    complex designs. Includes the rescaled bootstrap
    described in Rust and Rao (1996) &lt;<a href="https://doi.org/10.1177%2F096228029600500305">doi:10.1177/096228029600500305</a>&gt; and
    Rao and Wu (1988) &lt;<a href="https://doi.org/10.1080%2F01621459.1988.10478591">doi:10.1080/01621459.1988.10478591</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stringr, dplyr, plyr, purrr, functional</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-09 05:42:24 UTC; dennis</td>
</tr>
<tr>
<td>Author:</td>
<td>Dennis M. Feehan [aut, cre],
  Matthew J. Salganik [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dennis M. Feehan &lt;feehan@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-09 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bootstrap.estimates'>bootstrap.estimates</h2><span id='topic+bootstrap.estimates'></span>

<h3>Description</h3>

<p>Use a given bootstrap method to estimate sampling uncertainty from a given
estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap.estimates(
  survey.data,
  survey.design,
  bootstrap.fn,
  estimator.fn,
  num.reps,
  weights = NULL,
  ...,
  summary.fn = NULL,
  verbose = TRUE,
  parallel = FALSE,
  paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap.estimates_+3A_survey.data">survey.data</code></td>
<td>
<p>The dataset to use</p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_survey.design">survey.design</code></td>
<td>
<p>A formula describing the design of the survey
(see Details below)</p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_bootstrap.fn">bootstrap.fn</code></td>
<td>
<p>Name of the method to be used to take
bootstrap resamples</p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_estimator.fn">estimator.fn</code></td>
<td>
<p>The name of a function which, given a dataset like
<code>survey.data</code> and arguments in <code>...</code>,
will produce an estimate of interest</p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_num.reps">num.reps</code></td>
<td>
<p>The number of bootstrap replication samples to draw</p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_weights">weights</code></td>
<td>
<p>Weights to use in estimation (or <code>NULL</code>, if none)</p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_...">...</code></td>
<td>
<p>additional arguments which will be passed on to <code>estimator.fn</code></p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_summary.fn">summary.fn</code></td>
<td>
<p>(Optional) Name of a function which, given the set of estimates
produced by <code>estimator.fn</code>, summarizes them. If not specified, all of
the estimates are returned in a list.</p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, produce lots of feedback about what is going on</p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, use the <code>plyr</code> library's <code>.parallel</code> argument to
produce bootstrap resamples and estimates in parallel</p>
</td></tr>
<tr><td><code id="bootstrap.estimates_+3A_paropts">paropts</code></td>
<td>
<p>If not <code>NULL</code>, additional arguments to pass along to the
parallelization routine</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula describing the survey design should have the form
<code>~ psu_v1 + psu_v2 + ... + strata(strata_v1 + strata_v2 + ...)</code>,
where <code style="white-space: pre;">&#8288;psu_v1, ...&#8288;</code> are the variables identifying primary sampling units (PSUs)
and <code style="white-space: pre;">&#8288;strata_v1, ...&#8288;</code> identifies the strata
</p>


<h3>Value</h3>

<p>If <code>summary.fn</code> is not specified, then return the list of estimates
produced by <code>estimator.fn</code>; if <code>summary.fn</code> is specified, then return
its output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example using a simple random sample

survey &lt;- MU284.surveys[[1]]

estimator &lt;- function(survey.data, weights) {
  plyr::summarise(survey.data,
                  T82.hat = sum(S82 * weights))
}

ex.mu284 &lt;- bootstrap.estimates(
   survey.design = ~1,
   num.reps = 10,
   estimator.fn = estimator,
   weights='sample_weight',
   bootstrap.fn = 'srs.bootstrap.sample',
   survey.data=survey)

## Not run: 
idu.est &lt;- bootstrap.estimates(
  ## this describes the sampling design of the
  ## survey; here, the PSUs are given by the
  ## variable cluster, and the strata are given
  ## by the variable region
  survey.design = ~ cluster + strata(region),
  ## the number of bootstrap resamples to obtain
  num.reps=1000,
  ## this is the name of the function
  ## we want to use to produce an estimate
  ## from each bootstrapped dataset
  estimator.fn="our.estimator",
  ## these are the sampling weights
  weights="indweight",
  ## this is the name of the type of bootstrap
  ## we wish to use
  bootstrap.fn="rescaled.bootstrap.sample",
  ## our dataset
  survey.data=example.survey,
  ## other parameters we need to pass
  ## to the estimator function
  d.hat.vals=d.hat,
  total.popn.size=tot.pop.size,
  y.vals="clients",
  missing="complete.obs")


## End(Not run)
</code></pre>

<hr>
<h2 id='chain.data'>Get a dataset from a chain</h2><span id='topic+chain.data'></span>

<h3>Description</h3>

<p>Take the data for each member of the given chain
and assemble it together in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain.data(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain.data_+3A_chain">chain</code></td>
<td>
<p>The chain to build a dataset from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataset comprised of all of the chain's
members' data put together. The order of the rows
in the dataset is not specified.
</p>

<hr>
<h2 id='chain.size'>Get the size of a chain</h2><span id='topic+chain.size'></span>

<h3>Description</h3>

<p>Count the total number of respondents in the chain
and return it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain.size(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain.size_+3A_chain">chain</code></td>
<td>
<p>The chain object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of respondents involved in
the chain
</p>

<hr>
<h2 id='chain.vals'>Get all of the values of the given variable
found among members of a chain</h2><span id='topic+chain.vals'></span>

<h3>Description</h3>

<p>Get all of the values of the given variable
found among members of a chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain.vals(chain, qoi.var = "uid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain.vals_+3A_chain">chain</code></td>
<td>
<p>The chain to get values from</p>
</td></tr>
<tr><td><code id="chain.vals_+3A_qoi.var">qoi.var</code></td>
<td>
<p>The name of the variable to
get from each member of the chain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with all of the values of <code>qoi.var</code>
found in this chain. (Currently, the order of the values
in the vector is not guaranteed.)
</p>

<hr>
<h2 id='estimate.degree.distns'>Estimate degree distributions by trait</h2><span id='topic+estimate.degree.distns'></span>

<h3>Description</h3>

<p>Break down RDS degree distributions by trait,
and return an object which has the degrees
for each trait as well as functions to draw
degrees from each trait.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.degree.distns(survey.data, d.hat.vals, traits, keep.vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.degree.distns_+3A_survey.data">survey.data</code></td>
<td>
<p>The respondent info</p>
</td></tr>
<tr><td><code id="estimate.degree.distns_+3A_d.hat.vals">d.hat.vals</code></td>
<td>
<p>The variable that contains
the degrees for each respondent</p>
</td></tr>
<tr><td><code id="estimate.degree.distns_+3A_traits">traits</code></td>
<td>
<p>A vector of the names of the columns
of <code>survey.data</code> which refer to the traits</p>
</td></tr>
<tr><td><code id="estimate.degree.distns_+3A_keep.vars">keep.vars</code></td>
<td>
<p>Additional vars to return along with degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of the items returned as a result is a function,
<code>draw.degrees.fn</code>, which takes one argument,
<code>traits</code>. This is a vector of traits and,
for each entry in this vector, <code>draw.degress.fn</code>
returns a draw from the empirical distribution of
degrees among respondents with that trait. So,
<code style="white-space: pre;">&#8288;draw.degrees.fn(c("0.0", "0.1", "0.1")&#8288;</code> would
return a degree drawn uniformly at random from among
the observed degrees of respondents with trait &quot;0.0&quot;
and then two degrees from respondents with trait &quot;0.1&quot;
</p>


<h3>Value</h3>

<p>An object with
</p>

<ul>
<li> <p><code>distns</code> a list with one entry per trait value; each
</p>
</li>
<li> <p><code>draw.degrees.fn</code> a function which gets called with one
</p>
</li>
<li> <p><code>keep.vars</code> the name of the other vars that are kept (if any)
</p>
</li></ul>


<hr>
<h2 id='estimate.mixing'>Construct a mixing model from GoC/RDS data</h2><span id='topic+estimate.mixing'></span>

<h3>Description</h3>

<p>Given a dataset with the respondents and a dataset
on the parents (in many cases the same individuals),
and a set of relevant traits,
estimate mixing parameters and return a markov model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.mixing(survey.data, parent.data, traits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.mixing_+3A_survey.data">survey.data</code></td>
<td>
<p>The respondent info</p>
</td></tr>
<tr><td><code id="estimate.mixing_+3A_parent.data">parent.data</code></td>
<td>
<p>The parent info</p>
</td></tr>
<tr><td><code id="estimate.mixing_+3A_traits">traits</code></td>
<td>
<p>The names of the traits to build the model on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries:
</p>

<ul>
<li> <p><code>mixing.df</code> the data used to estimate the mixing function
</p>
</li>
<li> <p><code>choose.next.state.fn</code> a function which can be passed
a vector of states and will return a draw of a subsequent state
for each entry in the vector
</p>
</li>
<li> <p><code>mixing.df</code> a dataframe (long-form) representation of
the transition counts used to estimate the transition probabilities
</p>
</li>
<li> <p><code>states</code> a list with an entry for each state. within
each state's entry are
</p>

<ul>
<li> <p><code>trans.probs</code> a vector of estimated transition probabilities
</p>
</li>
<li> <p><code>trans.fn</code> a function which, when called, randomly chooses a
next state with probabilities given by the transition probs.
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='get.fn'>Grab a function based on its name</h2><span id='topic+get.fn'></span>

<h3>Description</h3>

<p>Helper to grab a function that is passed in as an argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.fn(fn, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.fn_+3A_fn">fn</code></td>
<td>
<p>The function to search for</p>
</td></tr>
<tr><td><code id="get.fn_+3A_env">env</code></td>
<td>
<p>The environment to start searching in</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is based on Hadley Wickham's response to an SO
post:
<a href="https://stackoverflow.com/questions/14183766/match-fun-provide-error-with-functions-defined-inside-functions">https://stackoverflow.com/questions/14183766/match-fun-provide-error-with-functions-defined-inside-functions</a>
with some minor modifications
</p>


<h3>Value</h3>

<p><code>fn</code>, if <code>fn</code> is already a function; otherwise, the first function found
in env or one of its parents whose name is <code>fn</code>
</p>

<hr>
<h2 id='get.var'>Get a variable from a dataframe or vector</h2><span id='topic+get.var'></span>

<h3>Description</h3>

<p>This function was written because a few of the estimator functions
need to use weights, and there are several cases to handle:
the user could pass in a column name, a vector of weights, or
nothing (in which case, the weights should default to 1 for each
row in the dataset). For the special case of getting weights, look
at the curried function <code><a href="#topic+get.weights">get.weights()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.var(survey.data, var, default = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.var_+3A_survey.data">survey.data</code></td>
<td>
<p>The survey dataset</p>
</td></tr>
<tr><td><code id="get.var_+3A_var">var</code></td>
<td>
<p>Either <code>NULL</code>, a column name, or a vector of values</p>
</td></tr>
<tr><td><code id="get.var_+3A_default">default</code></td>
<td>
<p>The default value to fill in if the variable
is not found</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values whose length is the same as the
number of rows in <code>survey.data</code>; if <code>var</code> is <code>NULL</code>, this has
the default values
</p>

<hr>
<h2 id='get.weights'>Get the weights column from a dataframe</h2><span id='topic+get.weights'></span>

<h3>Description</h3>

<p>This is the same as <code><a href="#topic+get.var">get.var()</a></code> with the default value set to 1
instead of <code>NA</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.weights(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.weights_+3A_...">...</code></td>
<td>
<p>(this is a function curried from <code><a href="#topic+get.var">get.var()</a></code>)</p>
</td></tr>
</table>

<hr>
<h2 id='is.child.ct'>Determine whether or not one id is a parent of another</h2><span id='topic+is.child.ct'></span>

<h3>Description</h3>

<p>This function allows us to determine which ids are
directly descended from which other ones. It is the only part
of the code that relies on the ID format used by the
Curitiba study (see Details); by modifying this function,
it should be possible to adapt this code to another study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.child.ct(id, seed.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.child.ct_+3A_id">id</code></td>
<td>
<p>the id of the potential child</p>
</td></tr>
<tr><td><code id="is.child.ct_+3A_seed.id">seed.id</code></td>
<td>
<p>the id of the potential parent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See:
</p>

<ul>
<li><p> Salganik, M. J., Fazito, D., Bertoni, N., Abdo, A. H., Mello, M. B., &amp;
Bastos, F. I. (2011). Assessing network scale-up estimates for groups
most at risk of HIV/AIDS: evidence from a multiple-method study of heavy
drug users in Curitiba, Brazil. <em>American journal of epidemiology</em>,
174(10), 1190-1196.
</p>
</li></ul>



<h3>Value</h3>

<p>TRUE if <code>id</code> is the direct descendant of <code>seed.id</code>
and FALSE otherwise
</p>

<hr>
<h2 id='make.chain'>Build an RDS seed's chain from the dataset</h2><span id='topic+make.chain'></span>

<h3>Description</h3>

<p>Note that this assumes that the chain is a tree (no loops)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.chain(seed.id, survey.data, is.child.fn = is.child.ct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.chain_+3A_seed.id">seed.id</code></td>
<td>
<p>The id of the seed whose chain we
wish to build from the dataset</p>
</td></tr>
<tr><td><code id="make.chain_+3A_survey.data">survey.data</code></td>
<td>
<p>The dataset</p>
</td></tr>
<tr><td><code id="make.chain_+3A_is.child.fn">is.child.fn</code></td>
<td>
<p>A function which takes two ids as arguments;
it is expected to return <code>TRUE</code> if the second argument is the parent of the
first, and <code>FALSE</code> otherwise. it defaults to <code><a href="#topic+is.child.ct">is.child.ct()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>info
</p>

<hr>
<h2 id='max.depth'>Get the height (maximum depth) of a chain</h2><span id='topic+max.depth'></span>

<h3>Description</h3>

<p>Get the height (maximum depth) of a chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'depth'
max(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max.depth_+3A_chain">chain</code></td>
<td>
<p>The chain object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The maximum depth of the chain
</p>

<hr>
<h2 id='mc.sim'>Run a markov model</h2><span id='topic+mc.sim'></span>

<h3>Description</h3>

<p>Run a given markov model for n time steps, starting
at a specified state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc.sim(mm, start, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.sim_+3A_mm">mm</code></td>
<td>
<p>The markov model object returned by <code><a href="#topic+estimate.mixing">estimate.mixing()</a></code></p>
</td></tr>
<tr><td><code id="mc.sim_+3A_start">start</code></td>
<td>
<p>The name of the state to start in</p>
</td></tr>
<tr><td><code id="mc.sim_+3A_n">n</code></td>
<td>
<p>The number of time-steps to run through</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses the markov model produced by <code><a href="#topic+estimate.mixing">estimate.mixing()</a></code>
</p>


<h3>Value</h3>

<p>A vector with the state visited at each time step. the first entry
has the starting state
</p>

<hr>
<h2 id='MU284'>The MU284 Population dataset</h2><span id='topic+MU284'></span>

<h3>Description</h3>

<p>A dataset containing information about Sweden's 284 municipalities. This
dataset comes from Model-Assisted Survey Sampling by
Sarndal, Swensson, and Wretman (2003, ISBN:0387406204). The columns are:
</p>


<h3>Format</h3>

<p>A data frame with 284 rows and 11 columns:
</p>

<dl>
<dt>LABEL</dt><dd><p>ID</p>
</dd>
<dt>P85</dt><dd><p>Population in 1985</p>
</dd>
<dt>P75</dt><dd><p>Population in 1975</p>
</dd>
<dt>RMT85</dt><dd><p>Municipal tax revenue in 1985</p>
</dd>
<dt>CS82</dt><dd><p>Number of Conservative seats in municipal council</p>
</dd>
<dt>SS82</dt><dd><p>Number of Social-Democratic seats in municipal council</p>
</dd>
<dt>S82</dt><dd><p>Total number of seats in municipal council</p>
</dd>
<dt>ME84</dt><dd><p>Number of municipal employees</p>
</dd>
<dt>REV84</dt><dd><p>Real estate values according to 1984 assessment</p>
</dd>
<dt>REG</dt><dd><p>Geographic location indicator</p>
</dd>
<dt>CL</dt><dd><p>Cluster indicator (neighboring municipalities are clustered together)</p>
</dd>
</dl>



<h3>Source</h3>

<p>'Model Assisted Survey Sampling' by Sarndal, Swensson, and Wretman (2003, ISBN:0387406204)
</p>

<hr>
<h2 id='MU284.boot.res.summ'>Benchmarks for unit tests</h2><span id='topic+MU284.boot.res.summ'></span>

<h3>Description</h3>

<p>Benchmark results to use in unit tests; these are based on
<a href="#topic+MU284.complex.surveys">MU284.complex.surveys</a>.
</p>


<h3>Format</h3>

<p>A list with 10 data frames, each with 15 rows and 11 columns:
</p>

<dl>
<dt>mean.TS82.hat, ..., sd.R.RMT85.P85.hat</dt><dd><p>summaries for each estimand</p>
</dd>
</dl>


<hr>
<h2 id='MU284.complex.surveys'>Simulated sample surveys drawn from the MU284 Population using a complex design</h2><span id='topic+MU284.complex.surveys'></span>

<h3>Description</h3>

<p>A list with 10 sample surveys with sample size 15 drawn from the <a href="#topic+MU284">MU284</a>
dataset using a complex sampling design.
</p>


<h3>Format</h3>

<p>A list with 10 data frames, each with 15 rows and 11 columns:
</p>

<dl>
<dt>LABEL, ..., CL</dt><dd><p>Same as MU284 dataset</p>
</dd>
<dt>sample_weight</dt><dd><p>The sampling weight for the row</p>
</dd>
</dl>



<h3>Details</h3>

<p>The sampling design comes from Ex. 4.3.2 (pg 142-3) of
'Model Assisted Survey Sampling' by Sarndal, Swensson, and Wretman
(2003, ISBN:0387406204).
</p>
<p>The design is a two-stage sample:
</p>

<ul>
<li><p> stage I: the primary sampling units (PSUs) are the standard clusters from
<a href="#topic+MU284">MU284</a>; we take a simple random sample without replacement of <code>n_I = 5</code>
out of <code>N_I = 50</code> of these
</p>
</li>
<li><p> stage II: within each sampled PSU, we take a simple random sample without
replacement of <code>n_i = 3</code> out of <code>N_i</code> municipalities
</p>
</li></ul>


<hr>
<h2 id='MU284.estimator.fn'>MU284.estimator.fn</h2><span id='topic+MU284.estimator.fn'></span>

<h3>Description</h3>

<p>Produce estimates from a simulated sample survey of the <a href="#topic+MU284">MU284</a> population.
Used in package tests and examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MU284.estimator.fn(survey.data, weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MU284.estimator.fn_+3A_survey.data">survey.data</code></td>
<td>
<p>the survey dataset</p>
</td></tr>
<tr><td><code id="MU284.estimator.fn_+3A_weights">weights</code></td>
<td>
<p>a vector with the survey weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with one row and two columns:
</p>

<ul>
<li> <p><code>TS82.hat</code> - the estimated total of <code>S82</code>
</p>
</li>
<li> <p><code>R.RMT85.P85.hat</code> - the estimated ratio of <code>RMT85</code> / <code>P85</code>
</p>
</li></ul>


<hr>
<h2 id='MU284.estimator.summary.fn'>MU284.estimator.summary.fn</h2><span id='topic+MU284.estimator.summary.fn'></span>

<h3>Description</h3>

<p>Summarize results from <code><a href="#topic+MU284.estimator.fn">MU284.estimator.fn()</a></code> applied to many surveys.
(This is a dummy function, used for tests)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MU284.estimator.summary.fn(res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MU284.estimator.summary.fn_+3A_res">res</code></td>
<td>
<p>a dataframe whose rows are the results of calling <code><a href="#topic+MU284.estimator.fn">MU284.estimator.fn()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same dataframe
</p>

<hr>
<h2 id='MU284.surveys'>Simulated sample surveys drawn from the MU284 Population</h2><span id='topic+MU284.surveys'></span>

<h3>Description</h3>

<p>A list with 10 sample surveys with sample size 15 drawn from the <a href="#topic+MU284">MU284</a>
dataset using simple random sampling with replacment.
</p>


<h3>Format</h3>

<p>A list with 10 data frames, each with 15 rows and 11 columns:
</p>

<dl>
<dt>LABEL, ..., CL</dt><dd><p>Same as MU284 dataset</p>
</dd>
<dt>sample_weight</dt><dd><p>The sampling weight for the row</p>
</dd>
</dl>


<hr>
<h2 id='parse_design'>Parse a formula that describes the design of a survey</h2><span id='topic+parse_design'></span>

<h3>Description</h3>

<p>Parse a formula of the form
<code>~ psu_v1 + psu_v2 + ... + strata(strata_v1 + strata_v2 + ...)</code>
into a PSU formula and a strata formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_design(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_design_+3A_formula">formula</code></td>
<td>
<p>a formula describing the sample design (see Description of <code><a href="#topic+bootstrap.estimates">bootstrap.estimates()</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with entries <code>psu.formula</code> and <code>strata.formula</code>
</p>

<hr>
<h2 id='rds.boot.draw.chain'>Draw RDS bootstrap resamples for one chain</h2><span id='topic+rds.boot.draw.chain'></span>

<h3>Description</h3>

<p>This function uses the algorithm described in the
supporting online material for Weir et al 2012
(see Details) to take bootstrap resamples
of one chain from an RDS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rds.boot.draw.chain(chain, mm, dd, parent.trait, idvar = "uid")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rds.boot.draw.chain_+3A_chain">chain</code></td>
<td>
<p>The chain to draw resamples for</p>
</td></tr>
<tr><td><code id="rds.boot.draw.chain_+3A_mm">mm</code></td>
<td>
<p>The mixing model to use</p>
</td></tr>
<tr><td><code id="rds.boot.draw.chain_+3A_dd">dd</code></td>
<td>
<p>The degree distns to use</p>
</td></tr>
<tr><td><code id="rds.boot.draw.chain_+3A_parent.trait">parent.trait</code></td>
<td>
<p>A vector whose length is the number
of bootstrap reps we want</p>
</td></tr>
<tr><td><code id="rds.boot.draw.chain_+3A_idvar">idvar</code></td>
<td>
<p>The name of the variable used to label the
columns of the output (presumably some id identifying the
row in the original dataset they come from)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See
</p>

<ul>
<li><p> Weir, Sharon S., et al. &quot;A comparison of respondent-driven and venue-based sampling of female sex workers in Liuzhou, China.&quot;
<em>Sexually transmitted infections</em> 88.Suppl 2 (2012): i95-i101.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of dataframes with one entry for each respondent in the chain.
each dataframe has one row for each bootstrap replicate. so if we take 10
bootstrap resamples of a chain of length 50, there will be 50 entries in
the list that is returned. each entry will be a dataframe with 10 rows.
</p>

<hr>
<h2 id='rds.chain.boot.draws'>Draw RDS bootstrap resamples</h2><span id='topic+rds.chain.boot.draws'></span>

<h3>Description</h3>

<p>Draw bootstrap resamples for an RDS dataset, using
the algorithm described in the supporting online
material of Weir et al 2012 (see <code><a href="#topic+rds.boot.draw.chain">rds.boot.draw.chain()</a></code> ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rds.chain.boot.draws(chains, mm, dd, num.reps, keep.vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rds.chain.boot.draws_+3A_chains">chains</code></td>
<td>
<p>A list whose entries are the chains
we want to resample</p>
</td></tr>
<tr><td><code id="rds.chain.boot.draws_+3A_mm">mm</code></td>
<td>
<p>The mixing model</p>
</td></tr>
<tr><td><code id="rds.chain.boot.draws_+3A_dd">dd</code></td>
<td>
<p>The degree distributions</p>
</td></tr>
<tr><td><code id="rds.chain.boot.draws_+3A_num.reps">num.reps</code></td>
<td>
<p>The number of bootstrap resamples we want</p>
</td></tr>
<tr><td><code id="rds.chain.boot.draws_+3A_keep.vars">keep.vars</code></td>
<td>
<p>If not <code>NULL</code>, then the names of variables
from the original dataset we want appended to each bootstrap
resampled dataset (default is <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length <code>num.reps</code>; each entry in
the list has one bootstrap-resampled dataset
</p>

<hr>
<h2 id='rds.mc.boot.draws'>Draw RDS bootstrap resamples using the
algorithm in Salganik 2006 (see Details below)</h2><span id='topic+rds.mc.boot.draws'></span>

<h3>Description</h3>

<p>This algorithm picks a respondent from the survey
to be a seed uniformly at random. it then generates
a bootstrap draw by simulating the markov process
forward for n steps, where n is the size of the draw
required.
</p>
<p>If you wish the bootstrap dataset to end up with
variables from the original dataset other than the
traits and degree, then you must specify this when
you construct <code>dd</code> using the
'<code>estimate.degree.distns</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rds.mc.boot.draws(chains, mm, dd, num.reps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rds.mc.boot.draws_+3A_chains">chains</code></td>
<td>
<p>A list with the chains constructed from the survey
using <code>make.chain</code></p>
</td></tr>
<tr><td><code id="rds.mc.boot.draws_+3A_mm">mm</code></td>
<td>
<p>The mixing model</p>
</td></tr>
<tr><td><code id="rds.mc.boot.draws_+3A_dd">dd</code></td>
<td>
<p>The degree distributions</p>
</td></tr>
<tr><td><code id="rds.mc.boot.draws_+3A_num.reps">num.reps</code></td>
<td>
<p>The number of bootstrap resamples we want</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See:
</p>

<ul>
<li><p> Salganik, Matthew J. &quot;Variance estimation, design effects, and sample
size calculations for respondent-driven sampling.&quot;
<em>Journal of Urban Health</em> 83.1 (2006): 98-112.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of length <code>num.reps</code>; each entry in
the list has one bootstrap-resampled dataset
</p>

<hr>
<h2 id='rescaled.bootstrap.sample'>rescaled.bootstrap.sample</h2><span id='topic+rescaled.bootstrap.sample'></span>

<h3>Description</h3>

<p>Given a survey dataset and a description of the survey
design (ie, which combination of variables determines primary sampling
units, and which combination of variables determines strata), take
a bunch of bootstrap samples for the rescaled bootstrap estimator
(see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaled.bootstrap.sample(
  survey.data,
  survey.design,
  parallel = FALSE,
  paropts = NULL,
  num.reps = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaled.bootstrap.sample_+3A_survey.data">survey.data</code></td>
<td>
<p>The dataset to use</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.sample_+3A_survey.design">survey.design</code></td>
<td>
<p>A formula describing the design of the survey (see Details)</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.sample_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, use parallelization (via <code>plyr</code>)</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.sample_+3A_paropts">paropts</code></td>
<td>
<p>An optional list of arguments passed on to <code>plyr</code> to control
details of parallelization</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.sample_+3A_num.reps">num.reps</code></td>
<td>
<p>The number of bootstrap replication samples to draw</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>survey.design</code> is a formula of the form
</p>
<p><code>weight ~ psu_vars + strata(strata_vars)</code>
</p>
<p>where:
</p>

<ul>
<li> <p><code>weight</code> is the variable with the survey weights
</p>
</li>
<li> <p><code>psu_vars</code> has the form <code>psu_v1 + psu_v2 + ...</code>, where primary
sampling units (PSUs) are determined by <code>psu_v1</code>, etc
</p>
</li>
<li> <p><code>strata_vars</code> has the form <code>strata_v1 + strata_v2 + ...</code>, which
determine strata
</p>
</li></ul>

<p>Note that we assume that the formula uniquely specifies PSUs.
This will always be true if the PSUs were selected without replacement.
If they were selected with replacement, then it will be necessary
to make each realization of a given PSU in the sample a unique id.
The code below assumes that all observations within
each PSU (as identified by the design formula) are from the same draw
of the PSU.
</p>
<p>The rescaled bootstrap technique works by adjusting the
estimation weights based on the number of times each
row is included in the resamples. If a row is never selected,
it is still included in the returned results, but its weight
will be set to 0. It is therefore important to use estimators
that make use of the estimation weights on the resampled
datasets.
</p>
<p>We always take m_i = n_i - 1, according to the advice presented
in Rao and Wu (1988) and Rust and Rao (1996).
</p>
<p>(This is a C++ version; a previous version, written in pure R,
is called <code><a href="#topic+rescaled.bootstrap.sample.pureR">rescaled.bootstrap.sample.pureR()</a></code> )
</p>
<p>References:
</p>

<ul>
<li><p> Rust, Keith F., and J. N. K. Rao. &quot;Variance estimation for complex surveys
using replication techniques.&quot; <em>Statistical methods in medical research</em>
5.3 (1996): 283-310.
</p>
</li>
<li><p> Rao, Jon NK, and C. F. J. Wu. &quot;Resampling inference with complex survey
data.&quot; <em>Journal of the American Statistical Association</em>
83.401 (1988): 231-241.
</p>
</li></ul>



<h3>Value</h3>

<p>A list with <code>num.reps</code> entries. Each entry is a dataset which
has at least the variables <code>index</code> (the row index of the original
dataset that was resampled) and <code>weight.scale</code>
(the factor by which to multiply the sampling weights
in the original dataset).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
survey &lt;- MU284.complex.surveys[[1]]
boot_surveys &lt;- rescaled.bootstrap.sample(survey.data = survey,
                                          survey.design = ~ CL,
                                          num.reps = 2)

</code></pre>

<hr>
<h2 id='rescaled.bootstrap.sample.pureR'>rescaled.bootstrap.sample.pureR</h2><span id='topic+rescaled.bootstrap.sample.pureR'></span>

<h3>Description</h3>

<p>(this is the pure R version; it has been supplanted by
<code>rescaled.bootstrap.sample</code>, which is partially written in C++)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaled.bootstrap.sample.pureR(
  survey.data,
  survey.design,
  parallel = FALSE,
  paropts = NULL,
  num.reps = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaled.bootstrap.sample.pureR_+3A_survey.data">survey.data</code></td>
<td>
<p>the dataset to use</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.sample.pureR_+3A_survey.design">survey.design</code></td>
<td>
<p>a formula describing the design of the survey (see below - TODO)</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.sample.pureR_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, use parallelization (via <code>plyr</code>)</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.sample.pureR_+3A_paropts">paropts</code></td>
<td>
<p>an optional list of arguments passed on to <code>plyr</code> to control
details of parallelization</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.sample.pureR_+3A_num.reps">num.reps</code></td>
<td>
<p>the number of bootstrap replication samples to draw</p>
</td></tr>
</table>


<h3>Details</h3>

<p>given a survey dataset and a description of the survey
design (ie, which combination of vars determines primary sampling
units, and which combination of vars determines strata), take
a bunch of bootstrap samples for the rescaled bootstrap estimator
(see, eg, Rust and Rao 1996).
</p>
<p>Note that we assume that the formula uniquely specifies PSUs.
This will always be true if the PSUs were selected without replacement.
If they were selected with replacement, then it will be necessary
to make each realization of a given PSU in the sample a unique id.
Bottom line: the code below assumes that all observations within
each PSU (as identified by the design formula) are from the same draw
of the PSU.
</p>
<p>The rescaled bootstrap technique works by adjusting the
estimation weights based on the number of times each
row is included in the resamples. If a row is never selected,
it is still included in the returned results, but its weight
will be set to 0. It is therefore important to use estimators
that make use of the estimation weights on the resampled
datasets.
</p>
<p>We always take m_i = n_i - 1, according to the advice presented
in Rao and Wu (1988) and Rust and Rao (1996).
</p>
<p><code>survey.design</code> is a formula of the form<br />
weight ~ psu_vars + strata(strata_vars),
where weight is the variable with the survey weights and psu
is the variable denoting the primary sampling unit
</p>


<h3>Value</h3>

<p>a list with <code>num.reps</code> entries. each entry is a dataset which
has at least the variables <code>index</code> (the row index of the original
dataset that was resampled) and <code>weight.scale</code>
(the factor by which to multiply the sampling weights
in the original dataset).
</p>

<hr>
<h2 id='rescaled.bootstrap.weights'>rescaled.bootstrap.weights</h2><span id='topic+rescaled.bootstrap.weights'></span>

<h3>Description</h3>

<p>This function creates a dataset with rescaled bootstrap weights;
it can be a helpful alternative to <code>bootstrap.estimates</code> in some situations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaled.bootstrap.weights(
  survey.data,
  survey.design,
  num.reps,
  weights = NULL,
  idvar,
  verbose = TRUE,
  parallel = FALSE,
  paropts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaled.bootstrap.weights_+3A_survey.data">survey.data</code></td>
<td>
<p>The dataset to use</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.weights_+3A_survey.design">survey.design</code></td>
<td>
<p>A formula describing the design of the survey
(see Details in <code><a href="#topic+bootstrap.estimates">bootstrap.estimates()</a></code> help page)</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.weights_+3A_num.reps">num.reps</code></td>
<td>
<p>the number of bootstrap replication samples to draw</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.weights_+3A_weights">weights</code></td>
<td>
<p>weights to use in estimation (or NULL, if none)</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.weights_+3A_idvar">idvar</code></td>
<td>
<p>the name of the column in <code>survey.data</code> that has the respondent id</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.weights_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, produce lots of feedback about what is going on</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.weights_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, use the plyr library's .parallel argument to
produce bootstrap resamples and estimates in parallel</p>
</td></tr>
<tr><td><code id="rescaled.bootstrap.weights_+3A_paropts">paropts</code></td>
<td>
<p>if not NULL, additional arguments to pass along to the
parallelization routine</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula describing the survey design should have the form
<code>~ psu_v1 + psu_v2 + ... + strata(strata_v1 + strata_v2 + ...)</code>,
where <code style="white-space: pre;">&#8288;psu_v1, ...&#8288;</code> are the variables identifying primary sampling units (PSUs)
and <code style="white-space: pre;">&#8288;strata_v1, ...&#8288;</code> identify the strata
</p>


<h3>Value</h3>

<p>if no summary.fn is specified, then return the list of estimates
produced by estimator.fn; if summary.fn is specified, then return
its output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
survey &lt;- MU284.complex.surveys[[1]]
rescaled.bootstrap.weights(survey.data = survey,
                          survey.design = ~ CL,
                          weights='sample_weight',
                          idvar='LABEL',
                          num.reps = 2)


## Not run: 
bootweights &lt;- rescaled.bootstrap.weights(
                                         # formula describing survey design:
                                         # psu and strata
                                         survey.design = ~ psu +
                                                           stratum(stratum_analysis),
                                         num.reps=10000,
                                         # column with respondent ids
                                         idvar='caseid',
                                         # column with sampling weight
                                         weights='wwgt',
                                         # survey dataset
                                         survey.data=mw.ego)


## End(Not run)
</code></pre>

<hr>
<h2 id='srs.bootstrap.sample'>srs.bootstrap.sample</h2><span id='topic+srs.bootstrap.sample'></span>

<h3>Description</h3>

<p>Given a survey dataset and a description of the survey
design (ie, which combination of vars determines primary sampling
units, and which combination of vars determines strata), take
a bunch of bootstrap samples under a simple random sampling
(with repetition) scheme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srs.bootstrap.sample(
  survey.data,
  num.reps = 1,
  parallel = FALSE,
  paropts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srs.bootstrap.sample_+3A_survey.data">survey.data</code></td>
<td>
<p>The dataset to use</p>
</td></tr>
<tr><td><code id="srs.bootstrap.sample_+3A_num.reps">num.reps</code></td>
<td>
<p>The number of bootstrap replication samples to draw</p>
</td></tr>
<tr><td><code id="srs.bootstrap.sample_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, use parallelization (via <code>plyr</code>)</p>
</td></tr>
<tr><td><code id="srs.bootstrap.sample_+3A_paropts">paropts</code></td>
<td>
<p>An optional list of arguments passed on to <code>plyr</code> to control
details of parallelization</p>
</td></tr>
<tr><td><code id="srs.bootstrap.sample_+3A_...">...</code></td>
<td>
<p>Ignored, but useful because it allows params like <code>survey.design</code>
which are used in other bootstrap designs, to be passed in without error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with <code>num.reps</code> entries. Each entry is a dataset which has
at least the variables <code>index</code> (the row index of the original dataset that
was resampled) and <code>weight.scale</code> (the factor by which to multiply the
sampling weights in the original dataset).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
survey &lt;- MU284.surveys[[1]]
boot_surveys &lt;- srs.bootstrap.sample(survey, num.reps = 2)

</code></pre>

<hr>
<h2 id='surveybootstrap'>Survey bootstrap variance estimators</h2><span id='topic+surveybootstrap'></span><span id='topic+package-surveybootstrap'></span>

<h3>Description</h3>

<p><code>surveybootstrap</code> has methods for analyzing data that were collected
using network reporting techniques. It includes estimators appropriate for
the simple bootstrap and the rescaled bootstrap.
</p>

<hr>
<h2 id='traits.to.string'>Take a set of traits and turn into a string</h2><span id='topic+traits.to.string'></span>

<h3>Description</h3>

<p>This is a helper function that is useful when we wish
to make several traits into one variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traits.to.string(data, traits, na.action = "drop", sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traits.to.string_+3A_data">data</code></td>
<td>
<p>The respondent info</p>
</td></tr>
<tr><td><code id="traits.to.string_+3A_traits">traits</code></td>
<td>
<p>The names of the traits to build the model on</p>
</td></tr>
<tr><td><code id="traits.to.string_+3A_na.action">na.action</code></td>
<td>
<p>Defaults to 'drop' (meaning all rows of data
with any missingness on the traits are dropped). Anything else
means <code>NA</code>s are treated like any other value.</p>
</td></tr>
<tr><td><code id="traits.to.string_+3A_sep">sep</code></td>
<td>
<p>The separator character used to combine values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose entries are
</p>

<ul>
<li> <p><code>used.idx</code>, which indicates which rows from the original dataset were used
(may not be all of them if there is missingness); and
</p>
</li>
<li> <p><code>traits</code>, which has the string version of the traits
</p>
</li></ul>


<hr>
<h2 id='unparse.trait'>Unparse a collapsed trait string</h2><span id='topic+unparse.trait'></span>

<h3>Description</h3>

<p>For a few of the RDS-related functions, it is useful
to combine several traits into one variable as a string;
for example, &quot;male&quot; and &quot;young&quot; might become
&quot;male.young&quot;. this function takes a string with
combined traits and explodes it back into
several variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unparse.trait(trait.string, names, sep = "\\.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unparse.trait_+3A_trait.string">trait.string</code></td>
<td>
<p>A vector whose values are collapsed
traits</p>
</td></tr>
<tr><td><code id="unparse.trait_+3A_names">names</code></td>
<td>
<p>A vector with the names of each trait (in order)</p>
</td></tr>
<tr><td><code id="unparse.trait_+3A_sep">sep</code></td>
<td>
<p>The character used to separate the traits in their
collapsed string representation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe whose rows correspond to the entries in
<code>trait.string</code>, with one column per trait
</p>

<hr>
<h2 id='vcat'>Only prints things out in verbose mode</h2><span id='topic+vcat'></span>

<h3>Description</h3>

<p>Only prints things out in verbose mode
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcat(verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcat_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, print things out; otherwise, do nothing</p>
</td></tr>
<tr><td><code id="vcat_+3A_...">...</code></td>
<td>
<p>Arguments to pass to cat if verbose is <code>TRUE</code></p>
</td></tr>
</table>

<hr>
<h2 id='weighted.mean'>Compute the weighted mean</h2><span id='topic+weighted.mean'></span>

<h3>Description</h3>

<p>Given a vector of values and a vector of weights, compute the
weighted mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.mean(x, w, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.mean_+3A_x">x</code></td>
<td>
<p>The vector of values</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_w">w</code></td>
<td>
<p>The vector of weights</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code>, only consider elements of <code>x</code> that are not missing
(and their corresponding entries in <code>w</code>). Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The weighted mean
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
