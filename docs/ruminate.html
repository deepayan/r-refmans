<!DOCTYPE html><html lang="en"><head><title>Help for package ruminate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ruminate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ruminate'><p>ruminate: Shiny app and module to facilitate pharamacometrics analysis</p></a></li>
<li><a href='#apply_route_map'><p>Applies Route Mapping to Dataset</p></a></li>
<li><a href='#CTS_add_covariate'><p>Add Covariate to Elemetnt</p></a></li>
<li><a href='#CTS_add_rule'><p>Add Rule to Element</p></a></li>
<li><a href='#CTS_append_report'><p>Append Report Elements</p></a></li>
<li><a href='#CTS_change_source_model'><p>Change the Source Model</p></a></li>
<li><a href='#CTS_del_current_element'><p>Deletes Current cohort</p></a></li>
<li><a href='#CTS_fetch_code'><p>Fetch Module Code</p></a></li>
<li><a href='#CTS_fetch_current_element'><p>Fetches Current cohort</p></a></li>
<li><a href='#CTS_fetch_ds'><p>Fetch Clinical Trial Simulator Module Datasets</p></a></li>
<li><a href='#CTS_fetch_sc_meta'><p>Fetches Simulation Parameter Meta Information</p></a></li>
<li><a href='#CTS_fetch_state'><p>Fetch Clinical Trial Simulator State</p></a></li>
<li><a href='#CTS_init_element_model'><p>Initializes Cohort When Model Changes</p></a></li>
<li><a href='#CTS_init_state'><p>Initialize CTS Module State</p></a></li>
<li><a href='#CTS_mk_preload'><p>Make List of Current CTS State</p></a></li>
<li><a href='#CTS_new_element'><p>New Clinical Trial Simulation Cohort</p></a></li>
<li><a href='#CTS_plot_element'><p>Plots the Specified Element</p></a></li>
<li><a href='#CTS_preload'><p>Preload Data for CTS Module</p></a></li>
<li><a href='#CTS_Server'><p>Clinical Trial Simulator State Server</p></a></li>
<li><a href='#CTS_set_current_element'><p>Sets the Value for the  Current cohort</p></a></li>
<li><a href='#CTS_sim_isgood'><p>Checks Simulation in Element for Goodness</p></a></li>
<li><a href='#CTS_simulate_element'><p>Simulates the Specified Element</p></a></li>
<li><a href='#CTS_test_mksession'><p>Populate Session Data for Module Testing</p></a></li>
<li><a href='#CTS_update_checksum'><p>Updates CTS Module Checksum</p></a></li>
<li><a href='#dose_records_builder'><p>Builds Dose Records Dataframe</p></a></li>
<li><a href='#fetch_rxinfo'><p>Fetches Information from an rxode2 Object</p></a></li>
<li><a href='#fetch_rxtc'><p>Extracts Timecourse and Merges Covariates</p></a></li>
<li><a href='#MB_append_report'><p>Append Report Elements</p></a></li>
<li><a href='#MB_build_code'><p>Build Code to Generate Model</p></a></li>
<li><a href='#MB_del_current_element'><p>Deletes Current model</p></a></li>
<li><a href='#MB_fetch_appends'><p>Fetches List of Available Models</p></a></li>
<li><a href='#MB_fetch_catalog'><p>Fetches List of Available Models</p></a></li>
<li><a href='#MB_fetch_code'><p>Fetch Module Code</p></a></li>
<li><a href='#MB_fetch_component'><p>Fetch Selected Current Model Component</p></a></li>
<li><a href='#MB_fetch_current_element'><p>Fetches Current model</p></a></li>
<li><a href='#MB_fetch_mdl'><p>Fetch Model Builder Module Models</p></a></li>
<li><a href='#MB_fetch_state'><p>Fetch Model Builder State</p></a></li>
<li><a href='#MB_init_state'><p>Initialize MB Module State</p></a></li>
<li><a href='#MB_mk_preload'><p>Make List of Current MB State</p></a></li>
<li><a href='#MB_new_element'><p>New Model Building Model</p></a></li>
<li><a href='#MB_preload'><p>Preload Data for MB Module</p></a></li>
<li><a href='#MB_Server'><p>Model Builder State Server</p></a></li>
<li><a href='#MB_set_current_element'><p>Sets the Value for the  Current model</p></a></li>
<li><a href='#MB_test_catalog'><p>Tests the Model Catalog</p></a></li>
<li><a href='#MB_test_mksession'><p>Populate Session Data for Module Testing</p></a></li>
<li><a href='#MB_update_checksum'><p>Update MB Module Checksum</p></a></li>
<li><a href='#MB_update_model'><p>Updates Current Element with rxode2 Model</p></a></li>
<li><a href='#mk_figure_ind_obs'><p>Creates Figures of Individual Observations from PKNCA Result</p></a></li>
<li><a href='#mk_rx_obj'><p>Makes an rxode2 Object</p></a></li>
<li><a href='#mk_subjects'><p>Fetches Information from an rxode2 Object</p></a></li>
<li><a href='#mk_table_ind_obs'><p>Creates Tables of Individual Observations from PKNCA Result</p></a></li>
<li><a href='#mk_table_nca_params'><p>Create Tabular Output from PKNCA Results</p></a></li>
<li><a href='#NCA_add_int'><p>Adds Analysis Interval to Current Analysis</p></a></li>
<li><a href='#NCA_append_report'><p>Append Report Elements</p></a></li>
<li><a href='#nca_builder'><p>Builds NCA Code from ui Elements</p></a></li>
<li><a href='#NCA_fetch_ana_ds'><p>Fetch Analysis Dataset</p></a></li>
<li><a href='#NCA_fetch_ana_pknca'><p>Fetch PKNCA Results Object</p></a></li>
<li><a href='#NCA_fetch_code'><p>Fetch Module Code</p></a></li>
<li><a href='#NCA_fetch_current_ana'><p>Fetches Current Analysis</p></a></li>
<li><a href='#NCA_fetch_current_obj'><p>Fetches the Current Analysis Object</p></a></li>
<li><a href='#NCA_fetch_data_format'><p>Fetches Details About Data Requirements</p></a></li>
<li><a href='#NCA_fetch_ds'><p>Fetch Module Datasets</p></a></li>
<li><a href='#NCA_fetch_np_meta'><p>Fetches NCA Parameter Meta Information</p></a></li>
<li><a href='#NCA_fetch_PKNCA_meta'><p>Fetches PKNCA Metadata</p></a></li>
<li><a href='#NCA_fetch_state'><p>Fetch ruminate State</p></a></li>
<li><a href='#NCA_find_col'><p>Determines Default Column Name</p></a></li>
<li><a href='#NCA_init_state'><p>Initialize NCA Module State</p></a></li>
<li><a href='#NCA_load_scenario'><p>Loads Pre-Defined Scenario</p></a></li>
<li><a href='#NCA_mk_preload'><p>Make List of Current NCA State</p></a></li>
<li><a href='#NCA_mkactive_ana'><p>Fetch PKNCA Results Object</p></a></li>
<li><a href='#NCA_new_ana'><p>Initialize New Analysis</p></a></li>
<li><a href='#NCA_preload'><p>Preload Data for NCA Module</p></a></li>
<li><a href='#NCA_process_current_ana'><p>Processes Current Analysis to be Run</p></a></li>
<li><a href='#NCA_Server'><p>Fetch Non-Compartmental Analysis State</p></a></li>
<li><a href='#NCA_set_current_ana'><p>Sets Current Analysis</p></a></li>
<li><a href='#NCA_test_mksession'><p>Populate Session Data for Module Testing</p></a></li>
<li><a href='#plot_sr_ev'><p>Plots        Timecourse of Rules Simulations</p></a></li>
<li><a href='#plot_sr_tc'><p>Plots        Timecourse of Rules Simulations</p></a></li>
<li><a href='#ruminate_check'><p>Checks <code>ruminate</code> Dependencies</p></a></li>
<li><a href='#run_nca_components'><p>Runs NCA for the Current Analysis</p></a></li>
<li><a href='#rx2other'><p>Converts an rxode2 Object Into Specified Model Format</p></a></li>
<li><a href='#simulate_rules'><p>Rule-Based simulates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Pharmacometrics Data Transformation and Analysis Tool</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Exploration of pharmacometrics data involves both general tools (transformation and plotting) and specific techniques (non-compartmental analysis). This kind of exploration is generally accomplished by utilizing different packages. The purpose of 'ruminate' is to create a 'shiny' interface to make these tools more broadly available while creating reproducible results.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/john-harrold/ruminate/issues">https://github.com/john-harrold/ruminate/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ruminate.ubiquity.tools/">https://ruminate.ubiquity.tools/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, dplyr, DT, flextable, formods (&ge; 0.2.0), ggplot2,
onbrand (&ge; 1.0.3), PKNCA (&ge; 0.10.2), plotly, rhandsontable,
rlang, shiny, shinyAce, shinyWidgets, stats, stringr, tidyr,
utils, yaml, zip</td>
</tr>
<tr>
<td>Suggests:</td>
<td>babelmixr2, cli, clipr, gridExtra, knitr, nlmixr2lib(&ge;
0.3.0), nonmem2rx, nlmixr2(&ge; 3.0.0), prompter, rmarkdown,
readxl, rxode2 (&ge; 3.0.0), shinybusy, shinydashboard, testthat
(&ge; 3.0.0), ubiquity</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 14:59:10 UTC; jmh</td>
</tr>
<tr>
<td>Author:</td>
<td>John Harrold <a href="https://orcid.org/0000-0003-2052-4373"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Harrold &lt;john.m.harrold@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-10 15:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ruminate'>ruminate: Shiny app and module to facilitate pharamacometrics analysis</h2><span id='topic+ruminate-package'></span><span id='topic+ruminate'></span>

<h3>Description</h3>

<p>This is done by creating a Shiny interface to different tools for data
transformation (<code>dplyr</code> and <code>tidyr</code>), plotting (<code>ggplot2</code>), and
noncompartmental analysis (<code>PKNCA</code>). These results can be reported in Excel,
Word or PowerPoint. The state of the app can be saved and loaded at a later
date. When saved, a script is generated to reproduce the different actions in
the Shiny interface.
</p>
<p>Runs the pharmacometrics ruminate app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruminate(
  host = "127.0.0.1",
  port = 3838,
  server_opts = list(shiny.maxRequestSize = 30 * 1024^2),
  devmode = FALSE,
  mksession = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ruminate_+3A_host">host</code></td>
<td>
<p>Hostname of the server (&quot;127.0.0.1&quot;)</p>
</td></tr>
<tr><td><code id="ruminate_+3A_port">port</code></td>
<td>
<p>Port number for the app (3838)</p>
</td></tr>
<tr><td><code id="ruminate_+3A_server_opts">server_opts</code></td>
<td>
<p>List of options (names) and their vlues (value) e.g.
<code>list(shiny.maxRequestSize = 30 * 1024^2)</code>.</p>
</td></tr>
<tr><td><code id="ruminate_+3A_devmode">devmode</code></td>
<td>
<p>Boolean value, when TRUE will run ruminate with development
modules.</p>
</td></tr>
<tr><td><code id="ruminate_+3A_mksession">mksession</code></td>
<td>
<p>Boolean value, when TRUE will load test session data
for app testing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned, this function just runs the built-in ruminate
app.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Harrold <a href="mailto:john.m.harrold@gmail.com">john.m.harrold@gmail.com</a> (<a href="https://orcid.org/0000-0003-2052-4373">ORCID</a>)
</p>


<h3>See Also</h3>

<p><a href="https://ruminate.ubiquity.tools/">https://ruminate.ubiquity.tools/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
ruminate()
}
</code></pre>

<hr>
<h2 id='apply_route_map'>Applies Route Mapping to Dataset</h2><span id='topic+apply_route_map'></span>

<h3>Description</h3>

<p>Used to convert nonstandard dose route values (i.e. &quot;IV&quot;) to
standard values (&quot;intravascular&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_route_map(route_map = list(), route_col = NULL, DS = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_route_map_+3A_route_map">route_map</code></td>
<td>
<p>List with names corresponding to the route replacement and
a vector of regular expressions to match.</p>
</td></tr>
<tr><td><code id="apply_route_map_+3A_route_col">route_col</code></td>
<td>
<p>Column name with the route data.</p>
</td></tr>
<tr><td><code id="apply_route_map_+3A_ds">DS</code></td>
<td>
<p>Dataframe containing the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataset with the route mapping applied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(system.file(package="readxl") !=""){
library(readxl)
#loading a dataset
data_file =  system.file(package="formods","test_data","TEST_DATA.xlsx")
myDS = readxl::read_excel(path=data_file, sheet="DATA")

 route_map = list(
   intravascular = c("^(?i)iv$"),
   extravascular = c("^(?i)sc$", "^(?i)oral")
 )

utils::head(myDS[["ROUTE"]])

myDS = apply_route_map(route_map = route_map,
                       route_col = "ROUTE",
                       DS        = myDS)

utils::head(myDS[["ROUTE"]])
}
</code></pre>

<hr>
<h2 id='CTS_add_covariate'>Add Covariate to Elemetnt</h2><span id='topic+CTS_add_covariate'></span>

<h3>Description</h3>

<p>Takes the ui elements in the module state and processes the covariate elements for addition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_add_covariate(state, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_add_covariate_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
<tr><td><code id="CTS_add_covariate_+3A_element">element</code></td>
<td>
<p>Element list from <code>CTS_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This depends on the following UI values in the state
</p>

<ul>
<li> <p><code>state[["CTS"]][["ui"]][["covariate_value"]]</code>
</p>
</li>
<li> <p><code>state[["CTS"]][["ui"]][["covariate_type_selected"]]</code>
</p>
</li>
<li> <p><code>state[["CTS"]][["ui"]][["selected_covariate"]]</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Element with the results of adding the covariate. The <code>cares</code> list
element can be used to determine the exit status of the function.
</p>

<ul>
<li><p>COV_IS_GOOD  If TRUE if the covariate was good and added, and FALSE if
there were any issues.
</p>
</li>
<li><p>msgs     Vector of messages.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_add_rule'>Add Rule to Element</h2><span id='topic+CTS_add_rule'></span>

<h3>Description</h3>

<p>Takes the ui elements in the state and element and attempts to add a rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_add_rule(state, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_add_rule_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
<tr><td><code id="CTS_add_rule_+3A_element">element</code></td>
<td>
<p>Element list from <code>CTS_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This depends on the following UI values in the state and element
</p>

<ul>
<li>  <p><code>state[["CTS"]][["ui"]][["rule_name"]]</code>
</p>
</li>
<li>  <p><code>state[["CTS"]][["ui"]][["rule_condition"]]</code>
</p>
</li>
<li>  <p><code>state[["CTS"]][["ui"]][["rule_type"]]</code>
</p>

<ul>
<li><p>  For rule type &quot;dose&quot;
</p>

<ul>
<li>  <p><code>state[["CTS"]][["ui"]][["action_dosing_state"]]</code>
</p>
</li>
<li>  <p><code>state[["CTS"]][["ui"]][["action_dosing_values"]]</code>
</p>
</li>
<li>  <p><code>state[["CTS"]][["ui"]][["action_dosing_times"]]</code>
</p>
</li>
<li>  <p><code>state[["CTS"]][["ui"]][["action_dosing_durations"]]</code>
</p>
</li></ul>

</li></ul>


<ul>
<li><p>  For rule type &quot;set state&quot;
</p>

<ul>
<li>  <p><code>state[["CTS"]][["ui"]][["action_set_state_state"]]</code>
</p>
</li>
<li>  <p><code>state[["CTS"]][["ui"]][["action_set_state_values"]]</code>
</p>
</li></ul>

</li></ul>


<ul>
<li><p>  For rule type &quot;manual code&quot;
</p>

<ul>
<li>  <p><code>state[["CTS"]][["ui"]][["action_manual_code"]]</code>
</p>
</li></ul>

</li></ul>

</li></ul>



<h3>Value</h3>

<p>Element with the results of adding the rule. The <code>rares</code> list
element can be used to determine the exit status of the function.
</p>

<ul>
<li><p>RULE_IS_GOOD  If true it indicates that the pieces of the rule from
the UI check out.
</p>
</li>
<li><p>RULE_UPDATED  If RULE_IS_GOOD and RULE_UPDATED is true then a
previous rule definition was overwritten. If RULE_IS_GOOD is TRUE and
RULE_UPDATED is FALSE then a new rule was added.
</p>
</li>
<li><p>notify_text  Text for notify message
</p>
</li>
<li><p>notify_id    Notification ID
</p>
</li>
<li><p>notify_type  Notification type
</p>
</li>
<li><p>msgs         Vector of messages.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_append_report'>Append Report Elements</h2><span id='topic+CTS_append_report'></span>

<h3>Description</h3>

<p>Appends report elements to a formods report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_append_report(state, rpt, rpttype, gen_code_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_append_report_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
<tr><td><code id="CTS_append_report_+3A_rpt">rpt</code></td>
<td>
<p>Report with the current content of the report which will be appended to in
this function. For details on the structure see the documentation for
<code><a href="onbrand.html#topic+template_details">onbrand::template_details()</a></code></p>
</td></tr>
<tr><td><code id="CTS_append_report_+3A_rpttype">rpttype</code></td>
<td>
<p>Type of report to generate (supported &quot;xlsx&quot;, &quot;pptx&quot;, &quot;docx&quot;).</p>
</td></tr>
<tr><td><code id="CTS_append_report_+3A_gen_code_only">gen_code_only</code></td>
<td>
<p>Boolean value indicating that only code should be
generated (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>hasrptele: Boolean indicator if the module has any reportable elements.
</p>
</li>
<li><p>code:      Code to generate reporting elements.
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li>
<li><p>rpt:       Report with any additions passed back to the user.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="formods.html#topic+FM_generate_report">formods::FM_generate_report()</a></code> and
<code><a href="onbrand.html#topic+template_details">onbrand::template_details()</a></code>
</p>

<hr>
<h2 id='CTS_change_source_model'>Change the Source Model</h2><span id='topic+CTS_change_source_model'></span>

<h3>Description</h3>

<p>Takes the ui elements in the state and element and processes any changes to the source model and updates the element accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_change_source_model(state, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_change_source_model_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
<tr><td><code id="CTS_change_source_model_+3A_element">element</code></td>
<td>
<p>Element list from <code>CTS_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This depends on the following UI values in the state.
</p>

<ul>
<li>  <p><code>state[["CTS"]][["ui"]][["source_model"]]</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Element with the necessary changes to the source model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_del_current_element'>Deletes Current cohort</h2><span id='topic+CTS_del_current_element'></span>

<h3>Description</h3>

<p>Takes a CTS state and deletes the current cohort.
If that is the last element, then a new default will be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_del_current_element(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_del_current_element_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>CTS state object with the current cohort deleted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_fetch_code'>Fetch Module Code</h2><span id='topic+CTS_fetch_code'></span>

<h3>Description</h3>

<p>Fetches the code to generate results seen in the app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_fetch_code(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_fetch_code_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object vector with the lines of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_fetch_current_element'>Fetches Current cohort</h2><span id='topic+CTS_fetch_current_element'></span>

<h3>Description</h3>

<p>Takes a CTS state and returns the current active
cohort
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_fetch_current_element(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_fetch_current_element_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the details of the active data view. The structure
of this list is the same as the structure of <code>state$CTS$elements</code> in the output of
<code>CTS_fetch_state()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_fetch_ds'>Fetch Clinical Trial Simulator Module Datasets</h2><span id='topic+CTS_fetch_ds'></span>

<h3>Description</h3>

<p>Fetches the datasets produced by the module. For each cohort
this will be the simulation timecourse and the event table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_fetch_ds(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_fetch_ds_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object vector with the lines of code
</p>
<p>list containing the following elements
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>hasds:     Boolean indicator if the module has any datasets
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li>
<li><p>ds:        List with datasets. Each list element has the name of
the R-object for that dataset. Each element has the following structure:
</p>

<ul>
<li><p>label: Text label for the dataset
</p>
</li>
<li><p>MOD_TYPE: Short name for the type of module.
</p>
</li>
<li><p>id: module ID
</p>
</li>
<li><p>DS: Dataframe containing the actual dataset.
</p>
</li>
<li><p>DSMETA: Metadata describing DS
</p>
</li>
<li><p>code: Complete code to build dataset.
</p>
</li>
<li><p>checksum: Module checksum.
</p>
</li>
<li><p>DSchecksum: Dataset checksum.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_fetch_sc_meta'>Fetches Simulation Parameter Meta Information</h2><span id='topic+CTS_fetch_sc_meta'></span>

<h3>Description</h3>

<p>This provides meta information about simulatino options. This
includes option names, text descriptions, ui_names used, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_fetch_sc_meta(
  MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_fetch_sc_meta_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following elements:
</p>

<ul>
<li><p>config List from the YAML-&gt;MC-&gt;sim_config.
</p>
</li>
<li><p>summary: Dataframe with elements of config in tabular format.
</p>
</li>
<li><p>ui_config Vector of  all the ui_ids for configuration options.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>CTS_fetch_sc_meta()
</code></pre>

<hr>
<h2 id='CTS_fetch_state'>Fetch Clinical Trial Simulator State</h2><span id='topic+CTS_fetch_state'></span>

<h3>Description</h3>

<p>Merges default app options with the changes made in the UI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_fetch_state(
  id,
  id_ASM,
  id_MB,
  input,
  session,
  FM_yaml_file,
  MOD_yaml_file,
  react_state
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_fetch_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID</p>
</td></tr>
<tr><td><code id="CTS_fetch_state_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state management module used to save and load app states</p>
</td></tr>
<tr><td><code id="CTS_fetch_state_+3A_id_mb">id_MB</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the MB modules</p>
</td></tr>
<tr><td><code id="CTS_fetch_state_+3A_input">input</code></td>
<td>
<p>Shiny input variable</p>
</td></tr>
<tr><td><code id="CTS_fetch_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="CTS_fetch_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="CTS_fetch_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="CTS_fetch_state_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the current state of the app including default
values from the yaml file as well as any changes made by the user. The list
has the following structure:
</p>

<ul>
<li><p>yaml: Full contents of the supplied yaml file.
</p>
</li>
<li><p>MC: Module components of the yaml file.
</p>
</li>
<li><p>CTS:
</p>

<ul>
<li><p>isgood: Boolean object indicating if the file was successfully loaded.
</p>
</li>
<li><p>checksum: This is an MD5 sum of the contents element and can be
used to detect changes in the state.
</p>
</li></ul>

</li>
<li><p>MOD_TYPE: Character data containing the type of module <code>"CTS"</code>
</p>
</li>
<li><p>id: Character data containing the module id module in the session variable.
</p>
</li>
<li><p>FM_yaml_file: App configuration file with FM as main section.
</p>
</li>
<li><p>MOD_yaml_file:  Module configuration file with MC as main section.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = MB_test_mksession()
session = sess_res$session
input   = sess_res$input

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

# Creating an empty state object
state = CTS_fetch_state(id              = "CTS",
                       id_ASM          = "ASM",
                       id_MB           = "MB",
                       input           = input,
                       session         = session,
                       FM_yaml_file    = FM_yaml_file,
                       MOD_yaml_file   = MOD_yaml_file,
                       react_state     = NULL)
</code></pre>

<hr>
<h2 id='CTS_init_element_model'>Initializes Cohort When Model Changes</h2><span id='topic+CTS_init_element_model'></span>

<h3>Description</h3>

<p>When a source model changes this will update information about
that model like the default dvcols and selection information about the
dvcols
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_init_element_model(state, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_init_element_model_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
<tr><td><code id="CTS_init_element_model_+3A_element">element</code></td>
<td>
<p>Element list from <code>CTS_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>CTS state object with the current cohort ui elements initialized
based on the current model selected
</p>

<hr>
<h2 id='CTS_init_state'>Initialize CTS Module State</h2><span id='topic+CTS_init_state'></span>

<h3>Description</h3>

<p>Creates a list of the initialized module state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_init_state(FM_yaml_file, MOD_yaml_file, id, id_MB, session)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_init_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section</p>
</td></tr>
<tr><td><code id="CTS_init_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section</p>
</td></tr>
<tr><td><code id="CTS_init_state_+3A_id">id</code></td>
<td>
<p>ID string for the module</p>
</td></tr>
<tr><td><code id="CTS_init_state_+3A_id_mb">id_MB</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the MB modules</p>
</td></tr>
<tr><td><code id="CTS_init_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing an empty CTS state
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = MB_test_mksession()
session = sess_res$session
input   = sess_res$input

state = CTS_init_state(
   FM_yaml_file  = system.file(package = "formods",
                               "templates",
                               "formods.yaml"),
   MOD_yaml_file = system.file(package = "ruminate",
                               "templates",
                               "CTS.yaml"),
   id              = "CTS",
   id_MB           = "MB",
   session         = session)

state
</code></pre>

<hr>
<h2 id='CTS_mk_preload'>Make List of Current CTS State</h2><span id='topic+CTS_mk_preload'></span>

<h3>Description</h3>

<p>Reads in the app state from yaml files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_mk_preload(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_mk_preload_+3A_state">state</code></td>
<td>
<p>CTS state object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood:       Boolean indicating the exit status of the function.
</p>
</li>
<li><p>msgs:         Messages to be passed back to the user.
</p>
</li>
<li><p>yaml_list:    Lists with preload components.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
sess_res = CTS_test_mksession()
state = sess_res$state
res = CTS_mk_preload(state)

</code></pre>

<hr>
<h2 id='CTS_new_element'>New Clinical Trial Simulation Cohort</h2><span id='topic+CTS_new_element'></span>

<h3>Description</h3>

<p>Appends a new empty cohort to the CTS state object
and makes this new cohort the active cohort.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_new_element(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_new_element_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>CTS state object containing a new cohort and that
cohort is set as the current active cohort. See the help for
<code>CTS_fetch_state()</code> for ===ELEMENT== format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_plot_element'>Plots the Specified Element</h2><span id='topic+CTS_plot_element'></span>

<h3>Description</h3>

<p>Takes a CTS state and element and simulates the current set of
rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_plot_element(state, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_plot_element_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
<tr><td><code id="CTS_plot_element_+3A_element">element</code></td>
<td>
<p>Element list from <code>CTS_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation element with plot results stored in the '<code>"plotres"</code> element.
</p>

<ul>
<li><p>isgood   Boolean value indicating the state of the figure generation code.
</p>
</li>
<li><p>msgs     Any messages to be passed to the user.
</p>
</li>
<li><p>capture  Captured figure generation output from <code>plot_sr_tc()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_preload'>Preload Data for CTS Module</h2><span id='topic+CTS_preload'></span>

<h3>Description</h3>

<p>Populates the supplied session variable with information from
list of sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_preload(
  session,
  src_list,
  yaml_res,
  mod_ID = NULL,
  react_state = list(),
  quickload = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_preload_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
<tr><td><code id="CTS_preload_+3A_src_list">src_list</code></td>
<td>
<p>List of preload data (all read together with module IDs at the top level)</p>
</td></tr>
<tr><td><code id="CTS_preload_+3A_yaml_res">yaml_res</code></td>
<td>
<p>List data from module yaml config</p>
</td></tr>
<tr><td><code id="CTS_preload_+3A_mod_id">mod_ID</code></td>
<td>
<p>Module ID of the module being loaded.</p>
</td></tr>
<tr><td><code id="CTS_preload_+3A_react_state">react_state</code></td>
<td>
<p>Reactive shiny object (in app) or a list (outside of app) used to trigger reactions.</p>
</td></tr>
<tr><td><code id="CTS_preload_+3A_quickload">quickload</code></td>
<td>
<p>Logical <code>TRUE</code> to load reduced analysis <code>FALSE</code> to load the full analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood:      Boolean indicating the exit status of the function.
</p>
</li>
<li><p>msgs:        Messages to be passed back to the user.
</p>
</li>
<li><p>session:     Session object
</p>
</li>
<li><p>input:       The value of the shiny input at the end of the session initialization.
</p>
</li>
<li><p>state:       App state.
</p>
</li>
<li><p>react_state: The <code>react_state</code> components.
</p>
</li></ul>


<hr>
<h2 id='CTS_Server'>Clinical Trial Simulator State Server</h2><span id='topic+CTS_Server'></span>

<h3>Description</h3>

<p>Server function for the Clinical Trial Simulator  Shiny Module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_Server(
  id,
  id_ASM = "ASM",
  id_MB = "MB",
  FM_yaml_file = system.file(package = "formods", "templates", "formods.yaml"),
  MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml"),
  deployed = FALSE,
  react_state = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_Server_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="CTS_Server_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state managment module used to save and load app states</p>
</td></tr>
<tr><td><code id="CTS_Server_+3A_id_mb">id_MB</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the MB modules</p>
</td></tr>
<tr><td><code id="CTS_Server_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="CTS_Server_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="CTS_Server_+3A_deployed">deployed</code></td>
<td>
<p>Boolean variable indicating whether the app is deployed or not.</p>
</td></tr>
<tr><td><code id="CTS_Server_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>UD Server object
</p>

<hr>
<h2 id='CTS_set_current_element'>Sets the Value for the  Current cohort</h2><span id='topic+CTS_set_current_element'></span>

<h3>Description</h3>

<p>Takes a CTS state and returns the current active
cohort
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_set_current_element(state, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_set_current_element_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
<tr><td><code id="CTS_set_current_element_+3A_element">element</code></td>
<td>
<p>Element list from <code>CTS_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>CTS state object with the current cohort set using the
supplied value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_sim_isgood'>Checks Simulation in Element for Goodness</h2><span id='topic+CTS_sim_isgood'></span>

<h3>Description</h3>

<p>Takes the supplied element and determines if the underlying
simulation is in a good state or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_sim_isgood(state, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_sim_isgood_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
<tr><td><code id="CTS_sim_isgood_+3A_element">element</code></td>
<td>
<p>Element list from <code>CTS_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following elements:
</p>

<ul>
<li><p>isgood: Boolean object indicating if the file was successfully loaded.
</p>
</li>
<li><p>msgs: Text description of failure.
</p>
</li></ul>


<hr>
<h2 id='CTS_simulate_element'>Simulates the Specified Element</h2><span id='topic+CTS_simulate_element'></span>

<h3>Description</h3>

<p>Takes a CTS state and element and simulates the current set of
rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_simulate_element(state, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_simulate_element_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
<tr><td><code id="CTS_simulate_element_+3A_element">element</code></td>
<td>
<p>Element list from <code>CTS_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation element with simulation results stored in the
<code>"simres"</code> element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='CTS_test_mksession'>Populate Session Data for Module Testing</h2><span id='topic+CTS_test_mksession'></span>

<h3>Description</h3>

<p>Populates the supplied session variable for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_test_mksession(session = list(), full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_test_mksession_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
<tr><td><code id="CTS_test_mksession_+3A_full">full</code></td>
<td>
<p>Boolean indicating if the full test session should be created
(<code>TRUE</code>) or a minimal test session should be created (<code>FALSE</code>,
default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The CTS portion of the <code>all_sess_res</code> returned from <code><a href="formods.html#topic+FM_app_preload">FM_app_preload</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="formods.html#topic+FM_app_preload">FM_app_preload</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
session = shiny::MockShinySession$new()
sess_res = CTS_test_mksession(session=session)

</code></pre>

<hr>
<h2 id='CTS_update_checksum'>Updates CTS Module Checksum</h2><span id='topic+CTS_update_checksum'></span>

<h3>Description</h3>

<p>Takes a CTS state and updates the checksum used to trigger
downstream updates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CTS_update_checksum(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CTS_update_checksum_+3A_state">state</code></td>
<td>
<p>CTS state from <code>CTS_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>CTS state object with the checksum updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html
# None of this will work if rxode2 isn't installed:

library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){

# This will populate the session variable with the model building (MB) module
sess_res = MB_test_mksession()
session = sess_res[["session"]]

id     = "CTS"
id_ASM = "ASM"
id_MB  = "MB"
input  = list()

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "CTS.yaml")

state = CTS_fetch_state(id              = id,
                        id_ASM          = id_ASM,
                        id_MB           = id_MB,
                        input           = input,
                        session         = session,
                        FM_yaml_file    = FM_yaml_file,
                        MOD_yaml_file   = MOD_yaml_file,
                        react_state     = NULL)


# Fetch a list of the current element
current_ele = CTS_fetch_current_element(state)

# You can modify the element
current_ele[["element_name"]] = "A more descriptive name"

# Defining the source model
state[["CTS"]][["ui"]][["source_model"]] = "MB_obj_1_rx"
current_ele = CTS_change_source_model(state, current_ele)

# Single visit
current_ele[["ui"]][["visit_times"]]                 = "0"
current_ele[["ui"]][["cts_config_nsteps"]]           = "5"

# Creating a dosing rule
state[["CTS"]][["ui"]][["rule_condition"]]           = "time == 0"
state[["CTS"]][["ui"]][["rule_type"]]                = "dose"
state[["CTS"]][["ui"]][["action_dosing_state"]]      = "central"
state[["CTS"]][["ui"]][["action_dosing_values"]]     = "c(1)"
state[["CTS"]][["ui"]][["action_dosing_times"]]      = "c(0)"
state[["CTS"]][["ui"]][["action_dosing_durations"]]  = "c(0)"
state[["CTS"]][["ui"]][["rule_name"]]                = "Single_Dose"

# Adding the rule:
current_ele = CTS_add_rule(state, current_ele)

# Appending the plotting details as well
current_ele[["ui"]][["fpage"]]             = "1"
current_ele[["ui"]][["dvcols"]]            = "Cc"

# Reducing the number of subjects and steps to speed things up on CRAN
current_ele[["ui"]][["nsub"]]              = "2"
current_ele[["ui"]][["cts_config_nsteps"]] = "5"

# Putting the element back in the state forcing code generation
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# Now we pull out the current element, and simulate it
current_ele = CTS_fetch_current_element(state)
#current_ele = CTS_simulate_element(state, current_ele)

# Next we plot the element
current_ele = CTS_plot_element(state, current_ele)

# Now we save those results back into the state:
state = CTS_set_current_element(
  state   = state,
  element = current_ele)

# This will extract the code for the current module
code = CTS_fetch_code(state)
code

# This will update the checksum of the module state
state = CTS_update_checksum(state)


# Access the datasets generated from simulations
ds = CTS_fetch_ds(state)

# CTS_add_covariate
state[["CTS"]][["ui"]][["covariate_value"]]            = "70, .1"
state[["CTS"]][["ui"]][["covariate_type_selected"]]    = "cont_lognormal"
state[["CTS"]][["ui"]][["selected_covariate"]]         = "WT"
current_ele = CTS_add_covariate(state, current_ele)

# Creates a new empty element
state = CTS_new_element(state)

# Delete the current element
state = CTS_del_current_element(state)
}

</code></pre>

<hr>
<h2 id='dose_records_builder'>Builds Dose Records Dataframe</h2><span id='topic+dose_records_builder'></span>

<h3>Description</h3>

<p>Takes information about columns in dataset and constructs the
dosing records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_records_builder(
  NCA_DS = NULL,
  dose_from = NULL,
  col_id = NULL,
  col_time = NULL,
  col_ntime = NULL,
  col_route = NULL,
  col_dose = NULL,
  col_cycle = NULL,
  col_dur = NULL,
  col_evid = NULL,
  col_analyte = NULL,
  col_group = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dose_records_builder_+3A_nca_ds">NCA_DS</code></td>
<td>
<p>Dataset containing dosing records.</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_dose_from">dose_from</code></td>
<td>
<p>Method of dose extraction either &quot;cols&quot; or &quot;rows&quot;.</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_id">col_id</code></td>
<td>
<p>Name of column with subject ID.</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_time">col_time</code></td>
<td>
<p>Name of column with time since first dose.</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_ntime">col_ntime</code></td>
<td>
<p>Name of column with time since the last dose (required with <code>dose_from="cols"</code>).</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_route">col_route</code></td>
<td>
<p>Name of column with route information.</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_dose">col_dose</code></td>
<td>
<p>Name of column with last dose given.</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_cycle">col_cycle</code></td>
<td>
<p>Name of column with dose cycle (required with <code>dose_from="cols"</code>).</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_dur">col_dur</code></td>
<td>
<p>Name of column with dose duration.</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_evid">col_evid</code></td>
<td>
<p>Name of column with event ID (required with <code>dose_from="rows"</code>).</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_analyte">col_analyte</code></td>
<td>
<p>Name of column with analyte (optional).</p>
</td></tr>
<tr><td><code id="dose_records_builder_+3A_col_group">col_group</code></td>
<td>
<p>Names of columns with grouping information (optionl).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood:           Return status of the function.
</p>
</li>
<li><p>msgs:             Messages to be passed back to the user.
</p>
</li>
<li><p>dose_rec:
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if(system.file(package="readxl") !=""){
library(dplyr)
library(readxl)
library(stringr)

# Example data file:
data_file =  system.file(package="formods","test_data","TEST_DATA.xlsx")

# Dataset formatted to extract dosing from columns
DS_cols = readxl::read_excel(path=data_file, sheet="DATA")        |&gt;
 dplyr::filter(EVID == 0)                                |&gt;
 dplyr::filter(DOSE %in% c(3))                           |&gt;
 dplyr::filter(str_detect(string=Cohort, "^MD"))         |&gt;
 dplyr::filter(CMT == "C_ng_ml")

drb_res = dose_records_builder(
 NCA_DS     = DS_cols,
 dose_from  = "cols",
 col_id     = "ID",
 col_time   = "TIME_DY",
 col_ntime  = "NTIME_DY",
 col_route  = "ROUTE",
 col_cycle  = "DOSE_NUM",
 col_dose   = "DOSE",
 col_group  = "Cohort")

utils::head(drb_res$dose_rec)

# Dataset formatted to extract dosing from rows (records)
DS_rows = readxl::read_excel(path=data_file, sheet="DATA")        |&gt;
 dplyr::filter(DOSE %in% c(3))                                   |&gt;
 dplyr::filter(str_detect(string=Cohort, "^MD"))                 |&gt;
 dplyr::filter(CMT %in% c("Ac", "C_ng_ml"))

drb_res = dose_records_builder(
 NCA_DS     = DS_rows,
 dose_from  = "rows",
 col_id     = "ID",
 col_time   = "TIME_DY",
 col_ntime  = "NTIME_DY",
 col_route  = "ROUTE",
 col_dose   = "AMT",
 col_evid   = "EVID",
 col_group  = "Cohort")

utils::head(drb_res$dose_rec)
}
</code></pre>

<hr>
<h2 id='fetch_rxinfo'>Fetches Information from an rxode2 Object</h2><span id='topic+fetch_rxinfo'></span>

<h3>Description</h3>

<p>This will provide information like parameter names, covriates,
etc from an rxode2 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_rxinfo(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_rxinfo_+3A_object">object</code></td>
<td>
<p>rxode2 model object  An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following elements.
</p>

<ul>
<li><p>isgood: Boolean variable indicating if the model is good.
</p>
</li>
<li><p>msgs: Any messages from parsing the model.
</p>
</li>
<li><p>elements: List with names of simulation elements:
</p>

<ul>
<li><p>covariates: Names of the covariates in the system.
</p>
</li>
<li><p>parameters: Names of the parameters (subject level) in the system.
</p>
</li>
<li><p>iiv: Names of the iiv parameters in the system.
</p>
</li>
<li><p>states: Names of the states/compartments in the system.
</p>
</li></ul>

</li>
<li><p>txt_info: Summary information in text format.
</p>
</li>
<li><p>list_info: Summary information in list format used with onbrand
reporting.
</p>
</li>
<li><p>ht_info: Summary information in HTML formot.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
library(ggplot2)

# For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html

# None of this will work if rxode2 isn't installed:
if(is_installed("rxode2")){
library(rxode2)
set.seed(8675309)
rxSetSeed(8675309)

my_model = function ()
{
    description &lt;- "One compartment PK model with linear clearance using differential equations"
    ini({
        lka &lt;- 0.45
        label("Absorption rate (Ka)")
        lcl &lt;- 1
        label("Clearance (CL)")
        lvc &lt;- 3.45
        label("Central volume of distribution (V)")
        propSd &lt;- c(0, 0.5)
        label("Proportional residual error (fraction)")
        etalcl ~ 0.1
    })
    model({
        ka &lt;- exp(lka)
        cl &lt;- exp(lcl + etalcl)
        vc &lt;- exp(lvc)
        kel &lt;- cl/vc
        d/dt(depot) &lt;- -ka * depot
        d/dt(central) &lt;- ka * depot - kel * central
        Cc &lt;- central/vc
        Cc ~ prop(propSd)
    })
}

# This creates an rxode2 object
object  = rxode(my_model)

# If you want details about the parameters, states, etc
# in the model you can use this:
rxdetails = fetch_rxinfo(object)

rxdetails$elements

# Next we will create subjects. To do that we need to
# specify information about covariates:
nsub = 2
covs = list(
  WT         = list(type     = "continuous",
                    sampling = "log-normal",
                    values   = c(70, .15))
)

subs = mk_subjects(object = object,
                   nsub   = nsub,
                   covs   = covs)

head(subs$subjects)

rules = list(
  dose = list(
    condition = "TRUE",
    action    = list(
      type  = "dose",
      state     = "central",
      values    = "c(1)",
      times     = "c(0)",
      durations = "c(0)")
    )
)

# We evaulate the rules for dosing at time 0
eval_times =  0

# Stop 2 months after the last dose
output_times = seq(0, 56, 1)

# This runs the rule-based simulations
simres =
  simulate_rules(
    object        = object,
    subjects      = subs[["subjects"]],
    eval_times    = eval_times,
    output_times  = output_times,
    rules         = rules)

# First subject data:
sub_1 = simres$simall[simres$simall$id == 1, ]

# First subjects events
evall = as.data.frame(simres$evall)
ev_sub_1 = evall[evall$id ==1, ]

# All of the simulation data
simall = simres$simall
simall$id = as.factor(simall$id)

# Timecourse
psim =
  plot_sr_tc(
    sro    = simres,
    dvcols = "Cc")
psim$fig

# Events
pev =
  plot_sr_ev(
    sro    = simres,
    ylog   = FALSE)
pev$fig

}

</code></pre>

<hr>
<h2 id='fetch_rxtc'>Extracts Timecourse and Merges Covariates</h2><span id='topic+fetch_rxtc'></span>

<h3>Description</h3>

<p>Takes the output of <code>rxSolve()</code> and merges in any missing
covariates that are present in params but not in sim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_rxtc(rx_details, sim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fetch_rxtc_+3A_rx_details">rx_details</code></td>
<td>
<p>Output of <code>fetch_rxinfo()</code></p>
</td></tr>
<tr><td><code id="fetch_rxtc_+3A_sim">sim</code></td>
<td>
<p>output of <code>rxSolve()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe of the simulated time course.
</p>

<hr>
<h2 id='MB_append_report'>Append Report Elements</h2><span id='topic+MB_append_report'></span>

<h3>Description</h3>

<p>Appends report elements to a formods report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_append_report(state, rpt, rpttype, gen_code_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_append_report_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
<tr><td><code id="MB_append_report_+3A_rpt">rpt</code></td>
<td>
<p>Report with the current content of the report which will be appended to in
this function. For details on the structure see the documentation for
<code><a href="formods.html#topic+FM_generate_report">formods::FM_generate_report()</a></code></p>
</td></tr>
<tr><td><code id="MB_append_report_+3A_rpttype">rpttype</code></td>
<td>
<p>Type of report to generate (supported &quot;xlsx&quot;, &quot;pptx&quot;, &quot;docx&quot;).</p>
</td></tr>
<tr><td><code id="MB_append_report_+3A_gen_code_only">gen_code_only</code></td>
<td>
<p>Boolean value indicating that only code should be
generated (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>hasrptele: Boolean indicator if the module has any reportable elements.
</p>
</li>
<li><p>code:      Code to generate reporting elements.
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li>
<li><p>rpt:       Report with any additions passed back to the user.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="formods.html#topic+FM_generate_report">formods::FM_generate_report()</a></code>
</p>

<hr>
<h2 id='MB_build_code'>Build Code to Generate Model</h2><span id='topic+MB_build_code'></span>

<h3>Description</h3>

<p>Takes the function definition from an rxode object, a function
object name and an rxode object name and creates the code to build those
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_build_code(
  state,
  session,
  fcn_def,
  time_scale,
  fcn_obj_name,
  rx_obj_name,
  ts_obj_name
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_build_code_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
<tr><td><code id="MB_build_code_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="MB_build_code_+3A_fcn_def">fcn_def</code></td>
<td>
<p>Character string containing the function definition for the
model</p>
</td></tr>
<tr><td><code id="MB_build_code_+3A_time_scale">time_scale</code></td>
<td>
<p>Short name for the model timescale (see names of state$MC$formatting$time_scales$choices).</p>
</td></tr>
<tr><td><code id="MB_build_code_+3A_fcn_obj_name">fcn_obj_name</code></td>
<td>
<p>Object name of the function to create.</p>
</td></tr>
<tr><td><code id="MB_build_code_+3A_rx_obj_name">rx_obj_name</code></td>
<td>
<p>Object name of the rxode2 object to create.</p>
</td></tr>
<tr><td><code id="MB_build_code_+3A_ts_obj_name">ts_obj_name</code></td>
<td>
<p>Object name of the tiemscale object to create.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following elements
</p>

<ul>
<li><p>model_code Block of code to create the model in the context of a
larger script.
</p>
</li>
<li><p>model_code_sa Same as the <code>model_code</code> element but meant to
stand alone.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_del_current_element'>Deletes Current model</h2><span id='topic+MB_del_current_element'></span>

<h3>Description</h3>

<p>Takes a MB state and deletes the current model.
If that is the last element, then a new default will be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_del_current_element(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_del_current_element_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>MB state object with the current model deleted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_fetch_appends'>Fetches List of Available Models</h2><span id='topic+MB_fetch_appends'></span>

<h3>Description</h3>

<p>Creates a catalog of the models available in the system file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_fetch_appends(state, current_ele)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_fetch_appends_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
<tr><td><code id="MB_fetch_appends_+3A_current_ele">current_ele</code></td>
<td>
<p>MB model element from <code>MB_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following attributes:
</p>

<ul>
<li><p>isgood: Boolean variable indicating success or failure.
</p>
</li>
<li><p>msgs: Messages to be passed back to the user.
</p>
</li>
<li><p>hasappends: Boolean variable indicating if appendable models were found.
</p>
</li>
<li><p>select_plain: Flat list with the models (ungrouped).
</p>
</li>
<li><p>choicesOpt List witht he subtext filled out.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_fetch_catalog'>Fetches List of Available Models</h2><span id='topic+MB_fetch_catalog'></span>

<h3>Description</h3>

<p>Creates a catalog of the models available in the system file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_fetch_catalog(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_fetch_catalog_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following attributes:
</p>

<ul>
<li><p>summary: Dataframe with a summary of the models in the catlog
</p>
</li>
<li><p>sources: Same information a that found in the summary table but in
list form.
</p>
</li>
<li><p>select_group: List with the models grouped by source.
</p>
</li>
<li><p>select_plain: Flat list with the models (ungrouped).
</p>
</li>
<li><p>select_subtext: Subtext for pulldown menus.
</p>
</li>
<li><p>msgs: Messages to be passed back to the user.
</p>
</li>
<li><p>hasmdl: Boolean value indicating if any models were found.
</p>
</li>
<li><p>isgood: Boolean variable indicating success or failure.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_fetch_code'>Fetch Module Code</h2><span id='topic+MB_fetch_code'></span>

<h3>Description</h3>

<p>Fetches the code to generate results seen in the app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_fetch_code(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_fetch_code_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object vector with the lines of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_fetch_component'>Fetch Selected Current Model Component</h2><span id='topic+MB_fetch_component'></span>

<h3>Description</h3>

<p>Fetches the selected component of the provided model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_fetch_component(state, current_ele, component_id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_fetch_component_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
<tr><td><code id="MB_fetch_component_+3A_current_ele">current_ele</code></td>
<td>
<p>MB model element from <code>MB_fetch_current_element()</code></p>
</td></tr>
<tr><td><code id="MB_fetch_component_+3A_component_id">component_id</code></td>
<td>
<p>The numeric component id to select (default <code>NULL</code>)
will return the selected ID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the current component with the following attributes
</p>

<ul>
<li><p>isgood: Boolean object indicating success.
</p>
</li>
<li><p>rx_obj: rxode2 object for the model.
</p>
</li>
<li><p>ts_obj: timescale object for the model.
</p>
</li>
<li><p>fcn_def: Just the model function definition.
</p>
</li>
<li><p>note: Note field from the components_table
</p>
</li>
<li><p>model_code: Code to generate model.
</p>
</li>
<li><p>model_code_sa: Stand-alone code to generate model with
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_fetch_current_element'>Fetches Current model</h2><span id='topic+MB_fetch_current_element'></span>

<h3>Description</h3>

<p>Takes a MB state and returns the current active
model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_fetch_current_element(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_fetch_current_element_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the details of the active data view. The structure
of this list is the same as the structure of <code>state$MB$elements</code> in the output of
<code>MB_fetch_state()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_fetch_mdl'>Fetch Model Builder Module Models</h2><span id='topic+MB_fetch_mdl'></span>

<h3>Description</h3>

<p>Fetches the models contained in the module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_fetch_mdl(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_fetch_mdl_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood:      Return status of the function.
</p>
</li>
<li><p>hasmdl:      Boolean indicator if the module has any models
</p>
</li>
<li><p>msgs:        Messages to be passed back to the user.
</p>
</li>
<li><p>mdl:         List with models. Each list element has the name of
the R-object for that dataset. Each element has the following structure:
</p>

<ul>
<li><p>label:       Text label for the model (e.g. one-compartment model).
</p>
</li>
<li><p>MOD_TYPE:    Type of module.
</p>
</li>
<li><p>id:          Module ID.
</p>
</li>
<li><p>rx_obj:      The rxode2 object.
</p>
</li>
<li><p>rx_obj_name: The rxode2 object name that holds the model.
</p>
</li>
<li><p>ts_obj       List with elements system and details
</p>
</li>
<li><p>ts_obj_name: The object name that holds the model time scale information.
</p>
</li>
<li><p>fcn_def:     Text to define the model
</p>
</li>
<li><p>MDLMETA:     Notes about the model.
</p>
</li>
<li><p>code:        Code to generate the model.
</p>
</li>
<li><p>checksum:    Module checksum.
</p>
</li>
<li><p>MDLchecksum: Model checksum.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a module state:
sess_res = MB_test_mksession()
state = sess_res$state

mdls = MB_fetch_mdl(state)

names(mdls)
</code></pre>

<hr>
<h2 id='MB_fetch_state'>Fetch Model Builder State</h2><span id='topic+MB_fetch_state'></span>

<h3>Description</h3>

<p>Merges default app options with the changes made in the UI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_fetch_state(
  id,
  id_ASM,
  input,
  session,
  FM_yaml_file,
  MOD_yaml_file,
  react_state
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_fetch_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID</p>
</td></tr>
<tr><td><code id="MB_fetch_state_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state management module used to save and load app states</p>
</td></tr>
<tr><td><code id="MB_fetch_state_+3A_input">input</code></td>
<td>
<p>Shiny input variable</p>
</td></tr>
<tr><td><code id="MB_fetch_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="MB_fetch_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="MB_fetch_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="MB_fetch_state_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the current state of the app including default
values from the yaml file as well as any changes made by the user. The list
has the following structure:
</p>

<ul>
<li><p>yaml: Full contents of the supplied yaml file.
</p>
</li>
<li><p>MC: Module components of the yaml file.
</p>
</li>
<li><p>MB:
</p>

<ul>
<li><p>isgood: Boolean object indicating if the file was successfully loaded.
</p>
</li>
<li><p>checksum: This is an MD5 sum of the contents element and can be
used to detect changes in the state.
</p>
</li></ul>

</li>
<li><p>MOD_TYPE: Character data containing the type of module <code>"MB"</code>
</p>
</li>
<li><p>id: Character data containing the module id module in the session variable.
</p>
</li>
<li><p>FM_yaml_file: App configuration file with FM as main section.
</p>
</li>
<li><p>MOD_yaml_file:  Module configuration file with MC as main section.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = MB_test_mksession()
session = sess_res$session
input   = sess_res$input

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")

# Creating an empty state object
state = MB_fetch_state(id              = "MB",
                       id_ASM          = "ASM",
                       input           = input,
                       session         = session,
                       FM_yaml_file    = FM_yaml_file,
                       MOD_yaml_file   = MOD_yaml_file,
                       react_state     = NULL)
</code></pre>

<hr>
<h2 id='MB_init_state'>Initialize MB Module State</h2><span id='topic+MB_init_state'></span>

<h3>Description</h3>

<p>Creates a list of the initialized module state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_init_state(FM_yaml_file, MOD_yaml_file, id, session)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_init_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="MB_init_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="MB_init_state_+3A_id">id</code></td>
<td>
<p>ID string for the module.</p>
</td></tr>
<tr><td><code id="MB_init_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing an empty MB state
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = MB_test_mksession()
session = sess_res$session
input   = sess_res$input

state = MB_init_state(
   FM_yaml_file  = system.file(package = "formods",
                               "templates",
                               "formods.yaml"),
   MOD_yaml_file = system.file(package = "ruminate",
                               "templates",
                               "MB.yaml"),
   id              = "MB",
   session         = session)

state
</code></pre>

<hr>
<h2 id='MB_mk_preload'>Make List of Current MB State</h2><span id='topic+MB_mk_preload'></span>

<h3>Description</h3>

<p>Reads in the app state from yaml files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_mk_preload(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_mk_preload_+3A_state">state</code></td>
<td>
<p>MB state object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood:       Boolean indicating the exit status of the function.
</p>
</li>
<li><p>msgs:         Messages to be passed back to the user.
</p>
</li>
<li><p>yaml_list:    Lists with preload components.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>sess_res = MB_test_mksession()
state = sess_res$state
res = MB_mk_preload(state)
</code></pre>

<hr>
<h2 id='MB_new_element'>New Model Building Model</h2><span id='topic+MB_new_element'></span>

<h3>Description</h3>

<p>Appends a new empty model to the MB state object
and makes this new model the active model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_new_element(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_new_element_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>MB state object containing a new model and that
model is set as the current active model. See the help for
<code>MB_fetch_state()</code> for model format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_preload'>Preload Data for MB Module</h2><span id='topic+MB_preload'></span>

<h3>Description</h3>

<p>Populates the supplied session variable with information from
list of sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_preload(
  session,
  src_list,
  yaml_res,
  mod_ID = NULL,
  react_state = list(),
  quickload = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_preload_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
<tr><td><code id="MB_preload_+3A_src_list">src_list</code></td>
<td>
<p>List of preload data (all read together with module IDs at the top level)</p>
</td></tr>
<tr><td><code id="MB_preload_+3A_yaml_res">yaml_res</code></td>
<td>
<p>List data from module yaml config</p>
</td></tr>
<tr><td><code id="MB_preload_+3A_mod_id">mod_ID</code></td>
<td>
<p>Module ID of the module being loaded.</p>
</td></tr>
<tr><td><code id="MB_preload_+3A_react_state">react_state</code></td>
<td>
<p>Reactive shiny object (in app) or a list (outside of app) used to trigger reactions.</p>
</td></tr>
<tr><td><code id="MB_preload_+3A_quickload">quickload</code></td>
<td>
<p>Logical <code>TRUE</code> to load reduced analysis <code>FALSE</code> to load the full analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood:      Boolean indicating the exit status of the function.
</p>
</li>
<li><p>msgs:        Messages to be passed back to the user.
</p>
</li>
<li><p>session:     Session object
</p>
</li>
<li><p>input:       The value of the shiny input at the end of the session initialization.
</p>
</li>
<li><p>state:       App state.
</p>
</li>
<li><p>react_state: The <code>react_state</code> components.
</p>
</li></ul>


<hr>
<h2 id='MB_Server'>Model Builder State Server</h2><span id='topic+MB_Server'></span>

<h3>Description</h3>

<p>Server function for the Model Builder  Shiny Module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_Server(
  id,
  id_ASM = "ASM",
  FM_yaml_file = system.file(package = "formods", "templates", "formods.yaml"),
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml"),
  deployed = FALSE,
  react_state = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_Server_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="MB_Server_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state managment module used to save and load app states</p>
</td></tr>
<tr><td><code id="MB_Server_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="MB_Server_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="MB_Server_+3A_deployed">deployed</code></td>
<td>
<p>Boolean variable indicating whether the app is deployed or not.</p>
</td></tr>
<tr><td><code id="MB_Server_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MB Server object
</p>

<hr>
<h2 id='MB_set_current_element'>Sets the Value for the  Current model</h2><span id='topic+MB_set_current_element'></span>

<h3>Description</h3>

<p>Takes a MB state and returns the current active
model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_set_current_element(state, element)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_set_current_element_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
<tr><td><code id="MB_set_current_element_+3A_element">element</code></td>
<td>
<p>Element list from <code>MB_fetch_current_element()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>MB state object with the current model set using the
supplied value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_test_catalog'>Tests the Model Catalog</h2><span id='topic+MB_test_catalog'></span>

<h3>Description</h3>

<p>Reads in models in the catalog and attempts to build them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_test_catalog(state, as_cran = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_test_catalog_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
<tr><td><code id="MB_test_catalog_+3A_as_cran">as_cran</code></td>
<td>
<p>Boolean to indicate if you're running this on CRAN</p>
</td></tr>
<tr><td><code id="MB_test_catalog_+3A_verbose">verbose</code></td>
<td>
<p>Boolean to indicate if messages should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following attributes:
</p>

<ul>
<li><p>isgood: Boolean varaible indicating if all the models in the catalog
passed the test.
</p>
</li>
<li><p>msgs: Messages indicating if the test was successful or not.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='MB_test_mksession'>Populate Session Data for Module Testing</h2><span id='topic+MB_test_mksession'></span>

<h3>Description</h3>

<p>Populates the supplied session variable for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_test_mksession(session = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_test_mksession_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The MB portion of the <code>all_sess_res</code> returned from
<code><a href="formods.html#topic+FM_app_preload">FM_app_preload</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="formods.html#topic+FM_app_preload">FM_app_preload</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>session = shiny::MockShinySession$new()
sess_res = MB_test_mksession(session=session)
</code></pre>

<hr>
<h2 id='MB_update_checksum'>Update MB Module Checksum</h2><span id='topic+MB_update_checksum'></span>

<h3>Description</h3>

<p>Takes a MB state and updates the checksum used to trigger
downstream updates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_update_checksum(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_update_checksum_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>MB state object with the checksum updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = MB_test_mksession()
session = sess_res$session
input   = sess_res$input

# We also need a state variable
state = sess_res$state

state = MB_update_checksum(state)
</code></pre>

<hr>
<h2 id='MB_update_model'>Updates Current Element with rxode2 Model</h2><span id='topic+MB_update_model'></span>

<h3>Description</h3>

<p>Takes an rxode2 object and updates the model components of the
current element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MB_update_model(state, session, current_ele, rx_obj, note, reset = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MB_update_model_+3A_state">state</code></td>
<td>
<p>MB state from <code>MB_fetch_state()</code></p>
</td></tr>
<tr><td><code id="MB_update_model_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="MB_update_model_+3A_current_ele">current_ele</code></td>
<td>
<p>MB model element from <code>MB_fetch_current_element()</code></p>
</td></tr>
<tr><td><code id="MB_update_model_+3A_rx_obj">rx_obj</code></td>
<td>
<p>rxode2 model from <code>rxode2::rxode2()</code></p>
</td></tr>
<tr><td><code id="MB_update_model_+3A_note">note</code></td>
<td>
<p>text indicating what this update does (e.g. &quot;added parameter&quot;)</p>
</td></tr>
<tr><td><code id="MB_update_model_+3A_reset">reset</code></td>
<td>
<p>boolean indicating that the element needs to be reset (i.e. if
you change the base model) default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>current_element with model attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(ruminate)
# This will get the full session:
library(formods)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
  sess_res = MB_test_mksession()
  # This is just for CRAN
  #sess_res = MB_test_mksession(session=list())
  session = sess_res$session
  input   = sess_res$input
  
  # Configuration files
  FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
  MOD_yaml_file = system.file(package = "ruminate", "templates", "MB.yaml")
  
  # Creating an empty state object
  state = MB_fetch_state(id              = "MB",
                         input           = input,
                         session         = session,
                         FM_yaml_file    = FM_yaml_file,
                         MOD_yaml_file   = MOD_yaml_file,
                         react_state     = NULL)
  
  # This will provide a list of the available models
  models = MB_fetch_catalog(state)
  # This is a summary of the tables in the model:
  models$summary
  
  # This will test the models in the catalog, set as_cran
  # to FALSE to test all the models.
  mtres = MB_test_catalog(state, as_cran=TRUE)
  mtres$isgood
  
  
  # Creates a new empty element
  state = MB_new_element(state)
  
  # Delete the current element
  state = MB_del_current_element(state)
  
  # Fetch a list of the current element
  element = MB_fetch_current_element(state)
  
  # This will attach a model to it:
  # Pulling the first model from the catalog
  fcn_def  = models[["summary"]][1, ][["Model"]]
  fcn_obj  = models[["summary"]][1, ][["Object"]]
  mdl_type = models[["summary"]][1, ][["Type"]]
  fcn_desc = models[["summary"]][1, ][["Description"]]
  
  # This will build the rxode2 object from the model
  mk_rx_res = mk_rx_obj(
    type  = mdl_type,
    model = list(fcn_def = fcn_def,
                 fcn_obj = fcn_obj))
  
  # This will attach the model to the current element
  element = MB_update_model(
    state       = state,
    session     = session,
    current_ele = element,
    rx_obj      = mk_rx_res[["capture"]][["rx_obj"]],
    note        = fcn_desc,
    reset       = TRUE)
  
  # You can now place element back in the state
  state = MB_set_current_element(state, element)
  
  # This will fetch the current component
  component = MB_fetch_component(state, element)
  
  
  fares = MB_fetch_appends(state, element) 
  
  # You can use the component to build the code to generate the model:
  gen_code =
    MB_build_code(state        = state, session = session,
                fcn_def        = component[["fcn_def"]],
                time_scale     = element[["ui"]][["time_scale"]],
                fcn_obj_name   = "my_fcn_obj",
                rx_obj_name    = "my_obj_name",
                ts_obj_name    = "my_ts_name")
  
  # Model code to be included in a larger script
  message(paste0(gen_code$model_code, collapse="\n"))
  
  # Stand-alone model code
  message(paste0(gen_code$model_code_sa, collapse="\n"))
  
  # This will fetch the code to regenerate all of the components of this module
  message(MB_fetch_code(state))
}
</code></pre>

<hr>
<h2 id='mk_figure_ind_obs'>Creates Figures of Individual Observations from PKNCA Result</h2><span id='topic+mk_figure_ind_obs'></span>

<h3>Description</h3>

<p>Takes the output of PKNCA and creates <code>ggplot</code> figures faceted
by subject id highlighting of certain NCA aspects (e.g. points used for half-life)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_figure_ind_obs(
  nca_res,
  OBS_LAB = "Concentration ===CONCUNITS===",
  TIME_LAB = "Time ===TIMEUNITS===",
  OBS_STRING = "Observation",
  BLQ_STRING = "BLQ",
  NA_STRING = "Missing",
  log_scale = TRUE,
  scales = "fixed",
  nfrows = 4,
  nfcols = 3
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_figure_ind_obs_+3A_nca_res">nca_res</code></td>
<td>
<p>Output of PKNCA.</p>
</td></tr>
<tr><td><code id="mk_figure_ind_obs_+3A_obs_lab">OBS_LAB</code></td>
<td>
<p>Label of the observation axis with optional ===CONCUNITS=== placeholder for units.</p>
</td></tr>
<tr><td><code id="mk_figure_ind_obs_+3A_time_lab">TIME_LAB</code></td>
<td>
<p>Label of the time axis with optional ===TIMEUNITS=== placeholder for units.</p>
</td></tr>
<tr><td><code id="mk_figure_ind_obs_+3A_obs_string">OBS_STRING</code></td>
<td>
<p>Label for observation data.</p>
</td></tr>
<tr><td><code id="mk_figure_ind_obs_+3A_blq_string">BLQ_STRING</code></td>
<td>
<p>Label for BLQ data.</p>
</td></tr>
<tr><td><code id="mk_figure_ind_obs_+3A_na_string">NA_STRING</code></td>
<td>
<p>Label for missing data.</p>
</td></tr>
<tr><td><code id="mk_figure_ind_obs_+3A_log_scale">log_scale</code></td>
<td>
<p>Boolean variable to control y-scale (<code>TRUE</code>: Log 10, <code>FALSE</code>: linear).</p>
</td></tr>
<tr><td><code id="mk_figure_ind_obs_+3A_scales">scales</code></td>
<td>
<p>String to determine the scales used when faceting. Can be either <code>"fixed"</code>, <code>"free"</code>, <code>"free_x"</code>, or <code>"free_y"</code>.</p>
</td></tr>
<tr><td><code id="mk_figure_ind_obs_+3A_nfrows">nfrows</code></td>
<td>
<p>Number of facet rows per page.</p>
</td></tr>
<tr><td><code id="mk_figure_ind_obs_+3A_nfcols">nfcols</code></td>
<td>
<p>Number of facet cols per page.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the element <code>figures</code> which is a list of figure
pages (<code>"Figure 1"</code>, <code>"Figure 2"</code>, etc.). Each of these is
a also a list containing two elements:
</p>

<ul>
<li><p>gg:    A ggplot object for that page.
</p>
</li>
<li><p>notes: Placeholder for future notes, but NULL now.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a state variable to be define
sess_res = NCA_test_mksession()

state = sess_res$state

# Pulls out the active analysis
current_ana = NCA_fetch_current_ana(state)

# This is the raw PKNCA output
pknca_res = NCA_fetch_ana_pknca(state, current_ana)

# Building the figure
mk_res = mk_figure_ind_obs(nca_res = pknca_res)
mk_res$figures$Figure_1$gg
</code></pre>

<hr>
<h2 id='mk_rx_obj'>Makes an rxode2 Object</h2><span id='topic+mk_rx_obj'></span>

<h3>Description</h3>

<p>Creates an rxode2 object from a model (either rxode2 function
or a NONMEM file)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_rx_obj(type, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_rx_obj_+3A_type">type</code></td>
<td>
<p>Type of supplied model can be &quot;rxode2&quot;, &quot;NONMEM&quot;</p>
</td></tr>
<tr><td><code id="mk_rx_obj_+3A_model">model</code></td>
<td>
<p>List containing the relevant information about the model. This
will depend on the model types.
</p>

<ul>
<li><p>rxode2: The supplied model is in the rxode2 format.
</p>

<ul>
<li><p>fcn_def: Character string containing function definition.
</p>
</li>
<li><p>fcn_obj: Name of the funciton object created in <code>fcn_def</code>.
</p>
</li></ul>

</li>
<li><p>NONMEM: The supplied model is in NONMEM format (either a control
</p>

<ul>
<li><p>model_file: Character string containing the NONMEM model file.
</p>
</li></ul>

</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Results of <code>FM_tc()</code> when running the model. This will include
a field <code>isgood</code> which is a boolean variable indicating success or
failure. See the documentation for <code>FM_tc()</code> for the format returned
when evaluation results in a failure and how to address those. When
successful the <code>capture</code> field will contain the following:
</p>

<ul>
<li><p>fcn_obj: The function name.
</p>
</li>
<li><p>rx_obj: The built rxode2 object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fcn_def = ' my_func = function ()
   {
       description &lt;- "One compartment PK model with linear clearance"
       ini({
           lka &lt;- 0.45
           label("Absorption rate (Ka)")
           lcl &lt;- 1
           label("Clearance (CL)")
           lvc &lt;- 3.45
           label("Central volume of distribution (V)")
           propSd &lt;- c(0, 0.5)
           label("Proportional residual error (fraction)")
       })
       model({
           ka &lt;- exp(lka)
           cl &lt;- exp(lcl)
           vc &lt;- exp(lvc)
           cp &lt;- linCmt()
           cp ~ prop(propSd)
       })

   }'
fcn_obj = "my_func"
model = list(fcn_def = fcn_def,
             fcn_obj = fcn_obj)


rx_res = mk_rx_obj("rxode2", model)

# function object
rx_res[["capture"]][["fcn_obj"]]

# rxode2 object
rx_res[["capture"]][["rx_obj"]]
</code></pre>

<hr>
<h2 id='mk_subjects'>Fetches Information from an rxode2 Object</h2><span id='topic+mk_subjects'></span>

<h3>Description</h3>

<p>This will provide information like parameter names, covriates,
etc from an rxode2 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_subjects(object, nsub = 10, covs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_subjects_+3A_object">object</code></td>
<td>
<p>rxode2 model object  An ID string that corresponds with the ID used to call the modules UI elements.</p>
</td></tr>
<tr><td><code id="mk_subjects_+3A_nsub">nsub</code></td>
<td>
<p>Number of subjects to generate. If set to 1 it will return the
typical values (IIV set to zero).</p>
</td></tr>
<tr><td><code id="mk_subjects_+3A_covs">covs</code></td>
<td>
<p>List describing how covariates should be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See below.
</p>
<p>The underlying simulations are run using <code>rxode2</code>, and as such we need
an <code>rxode2</code> system object. From that we can either simulate subjects or
load them from a file. Next we need to define a set of rules. These will
be a set of conditions and actions. At each evaluation time point the
conditions are evaluated. When a condition is met the actions associated
with that condition are executed. For example, if during a visit (an
evaluation time point) the trough PK is below a certain level
(condition) we may want to increase the dosing regimen for the next
dosing cycle (action).
</p>


<h4>Creating subjects</h4>

<p>Subjects are expected in a data frame with the following column headers:
</p>

<ul>
<li> <p><code>id</code> Individual subject id
</p>
</li>
<li><p> Names of parameters and iiv as specified in the <code>ini</code> section of the
<code>rxode2</code> function specification
</p>
</li>
<li><p> Names of covariates used in the model.
</p>
</li></ul>

<p><code>mk_subjects()</code>  Creates subjects for simulation by sampling based on
between-subject variability and generating covariate information based
on user specifications.
</p>


<h5>Covariates</h5>

<p>The <code>covs</code> input is a list with the following structure:
</p>

<ul>
<li><p> type: Can be either fixed, discrete, or continuous.
</p>
</li>
<li><p> sampling: This field is only needed for a continuous covariate 
type and can be either random, normal or log-normal.
</p>
</li>
<li><p> values: This field depends on the type and optional sampling above.
</p>

<ul>
<li><p> fixed: A single value.
</p>
</li>
<li><p> discrete: A vector of possible discrete elements.
</p>
</li>
<li><p> continuous, random: Two values the first is the lower bound and the
second is the upper bound.
</p>
</li>
<li><p> continuous, normal: Two values the first is the mean and the second
is the variance.
</p>
</li>
<li><p> continuous, log-normal: Two values the first is the mean and the
second is the variance.
</p>
</li></ul>

</li></ul>

<p>This examples shows the <code>SEX_ID</code> randomly sampled from the values
specified, <code>SUBTYPE_ID</code> fixed at a value, and <code>WT</code> sampled from a
log-normal distribution.
</p>
<div class="sourceCode r"><pre>covs = list(
  SEX_ID     = list(type     = "discrete", 
                    values   = c(0,1)),
  SUBTYPE_ID = list(type     = "fixed",
                    values   = c(0)),
  WT         = list(type     = "continuous",
                    sampling = "log-normal",
                    values   = c(70, .15))
)
</pre></div>




<h4>Rule-based simulations</h4>

<p><code>simulate_rules()</code>  This will run simulations based on the rule
definitions below.
</p>


<h5>Rules</h5>

<p>Rules are a named list where the list name can be a short descriptive
label used to remember what the rule does. These names will be returned
as columns in the simulated data frame.
</p>

<ul>
<li> <p><code>condition</code>: Character string that evaluates to either <code>TRUE</code> or
<code>FALSE</code>. When true the <code>action</code> portion will be triggered. For a list
of objects available see the Rule-evaluation environment below.
</p>
</li>
<li> <p><code>fail_flag</code>: Flag set in the <code>rule_id</code> column when the condition is
not met (set to <code>"false"</code> if not specified).
</p>
</li>
<li> <p><code>true_flag</code>: Flag set in the <code>rule_id</code> column when the condition is
met (set to <code>"true"</code> if not specified).
</p>
</li>
<li> <p><code>action</code>: This is what the rule will trigger can be any of the
following:
</p>

<ul>
<li> <p><code>type</code>: This defines the action type and can be either <code>"dose"</code>,
<code>"set state"</code>, or <code>"manual"</code>.
</p>
</li></ul>

</li></ul>

<p>Based on the <code>type</code> the <code>action</code> field will expect different elements.
</p>
<p>Dosing:
</p>

<ul>
<li> <p><code>action</code>
</p>

<ul>
<li> <p><code>type</code>: <code>"dose"</code>
</p>
</li>
<li> <p><code>values</code>: Character string that evaluates as a numeric vector dosing
amounts (e.g.<code>"c(3,  3,  3,  3)"</code>)
</p>
</li>
<li> <p><code>times</code>: Character string that evaluates as a numeric vector of
times (e.g.<code>"c(0, 14, 28, 42)"</code>)
</p>
</li>
<li> <p><code>durations</code>: Character string that evaluates as a numeric vector of
durations (e.g.<code>"c(0, 0, 0, 0)"</code>, zero for bolus dosing)
</p>
</li></ul>

</li></ul>

<p>Changing a state value:
</p>

<ul>
<li> <p><code>action</code>
</p>

<ul>
<li> <p><code>type</code>: <code>"set state"</code>
</p>
</li>
<li> <p><code>state</code>: Character string with the name of the state to set (<code>"Ac"</code>)
</p>
</li>
<li> <p><code>value</code>: Character string that evaluates as a numeric value for
state (e.g.<code>"Ac/2"</code> would set the state to half the value of Ac at
the evaluation point)
</p>
</li></ul>

</li></ul>

<p>Manual modification of the simulation:
</p>

<ul>
<li> <p><code>action</code>
</p>

<ul>
<li> <p><code>type</code>: <code>"manual"</code>
</p>
</li>
<li> <p><code>code</code>: Character string of code to evaluate.
</p>
</li></ul>

</li></ul>




<h5>Rule-evaluation environment</h5>

<p>Beyond simple simulations it will be necessary to execute actions based
on the current or previous state of the system. For this reason, when a
<code>condition</code> or elements of the action (e.g., the <code>values</code>, <code>times</code> and
<code>durations</code> of a dose action type) are being evaluated, the following
objects will be available at each evaluation point:
</p>

<ul>
<li><p> outputs: The value of each model output.
</p>
</li>
<li><p> states: The value of each named state or compartment.
</p>
</li>
<li><p> covariates: The value of each named covariate.
</p>
</li>
<li><p> subject-level parameters: The value of each named parameter.
</p>
</li>
<li><p> rule value: The last value the rule evaluated as.
</p>
</li>
<li> <p><code>id</code>: Current subject id.
</p>
</li>
<li> <p><code>time</code>: Current evaluation time.
</p>
</li>
<li> <p><code>SI_SUB_HISTORY</code>: A data frame of the simulation history of the
current subject up to the current evaluation point.
</p>
</li>
<li> <p><code>SI_subjects</code>: The subjects data frame.
</p>
</li>
<li> <p><code>SI_eval_times</code>: Vector of the evaluation times.
</p>
</li>
<li> <p><code>SI_interval_ev</code>: The events table in its current state for the given
simulation interval.
</p>
</li>
<li> <p><code>SI_ev_history</code>: This is the history of the event table containing all
the events leading up to the current interval.
</p>
</li>
<li> <p><code>SI_ud_history</code>: This is a free form object the user can define or
alter within the manualaction type (ud-user defined, history).
</p>
</li></ul>



<h6>The following functions will be available:</h6>


<ul>
<li> <p><code>SI_fpd</code>: This function will fetch the previous dose (fpd) for the
given id and state. For example for the current <code>id</code> and the state
<code>Ac</code> you would do the following:
</p>
</li></ul>

<div class="sourceCode r"><pre>SI_fpd(id=id, state="Ac")
</pre></div>




<h5>Time scales</h5>

<p>You can include columns in your output for different time scales if you
wish. You need to create a list in the format below. One element should
be <code>system</code> with a short name for the system time scale. The next should
be <code>details</code> which is a list containing short names for each time scale
you want to include. Each of these is a list with a verbose name for the
time scale (<code>verb</code>) and a numerical conversion indicating how that time
scale relates to the others. Here we define weeks and days on the basis
of seconds.
</p>
<div class="sourceCode r"><pre>time_scales = list(system="days", 
                details= list(
                  weeks = list(verb="Weeks",    conv=1/(60*60*24*7)),
                  days  = list(verb="Days",     conv=1/(60*60*24))))
</pre></div>




<h3>Value</h3>

<p>List with the following elements.
</p>

<ul>
<li><p>isgood:     Return status of the function.
</p>
</li>
<li><p>msgs:       Error or warning messages if any issues were encountered.
</p>
</li>
<li><p>subjects:   Data frame of parameters and covariates for the subjects generated.
</p>
</li>
<li><p>iCov:       Data frame of the covariates.
</p>
</li>
<li><p>params:     Data frame of the parameters.
</p>
</li></ul>



<h3>See Also</h3>

<p><code>vignette("clinical_trial_simulation", package = "ruminate")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
library(ggplot2)

# For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html

# None of this will work if rxode2 isn't installed:
if(is_installed("rxode2")){
library(rxode2)
set.seed(8675309)
rxSetSeed(8675309)

my_model = function ()
{
    description &lt;- "One compartment PK model with linear clearance using differential equations"
    ini({
        lka &lt;- 0.45
        label("Absorption rate (Ka)")
        lcl &lt;- 1
        label("Clearance (CL)")
        lvc &lt;- 3.45
        label("Central volume of distribution (V)")
        propSd &lt;- c(0, 0.5)
        label("Proportional residual error (fraction)")
        etalcl ~ 0.1
    })
    model({
        ka &lt;- exp(lka)
        cl &lt;- exp(lcl + etalcl)
        vc &lt;- exp(lvc)
        kel &lt;- cl/vc
        d/dt(depot) &lt;- -ka * depot
        d/dt(central) &lt;- ka * depot - kel * central
        Cc &lt;- central/vc
        Cc ~ prop(propSd)
    })
}

# This creates an rxode2 object
object  = rxode(my_model)

# If you want details about the parameters, states, etc
# in the model you can use this:
rxdetails = fetch_rxinfo(object)

rxdetails$elements

# Next we will create subjects. To do that we need to
# specify information about covariates:
nsub = 2
covs = list(
  WT         = list(type     = "continuous",
                    sampling = "log-normal",
                    values   = c(70, .15))
)

subs = mk_subjects(object = object,
                   nsub   = nsub,
                   covs   = covs)

head(subs$subjects)

rules = list(
  dose = list(
    condition = "TRUE",
    action    = list(
      type  = "dose",
      state     = "central",
      values    = "c(1)",
      times     = "c(0)",
      durations = "c(0)")
    )
)

# We evaulate the rules for dosing at time 0
eval_times =  0

# Stop 2 months after the last dose
output_times = seq(0, 56, 1)

# This runs the rule-based simulations
simres =
  simulate_rules(
    object        = object,
    subjects      = subs[["subjects"]],
    eval_times    = eval_times,
    output_times  = output_times,
    rules         = rules)

# First subject data:
sub_1 = simres$simall[simres$simall$id == 1, ]

# First subjects events
evall = as.data.frame(simres$evall)
ev_sub_1 = evall[evall$id ==1, ]

# All of the simulation data
simall = simres$simall
simall$id = as.factor(simall$id)

# Timecourse
psim =
  plot_sr_tc(
    sro    = simres,
    dvcols = "Cc")
psim$fig

# Events
pev =
  plot_sr_ev(
    sro    = simres,
    ylog   = FALSE)
pev$fig

}

</code></pre>

<hr>
<h2 id='mk_table_ind_obs'>Creates Tables of Individual Observations from PKNCA Result</h2><span id='topic+mk_table_ind_obs'></span>

<h3>Description</h3>

<p>Takes the output of PKNCA and creates a tabular view of the
individual observation data. This can be spread out of over several tables
(pages) if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_table_ind_obs(
  nca_res,
  obnd = NULL,
  not_sampled = "NS",
  blq = "BLQ",
  digits = 3,
  text_format = "text",
  max_height = 7,
  max_width = 6.5,
  max_row = NULL,
  max_col = 9,
  notes_detect = NULL,
  rows_by = "time"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_table_ind_obs_+3A_nca_res">nca_res</code></td>
<td>
<p>Output of PKNCA.</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_obnd">obnd</code></td>
<td>
<p>onbrand reporting object.</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_not_sampled">not_sampled</code></td>
<td>
<p>Character string to use for missing data when pivoting.</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_blq">blq</code></td>
<td>
<p>Character string to use to indicate data below the level of quantification (value of 0 in the dataset).</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_digits">digits</code></td>
<td>
<p>Number of significant figures to report (set to <code>NULL</code> to disable rounding)</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_text_format">text_format</code></td>
<td>
<p>Either <code>"md"</code> for markdown or <code>"text"</code> (default) for plain text.</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_max_height">max_height</code></td>
<td>
<p>Maximum height of the final table in inches (A value of <code>NULL</code> will use 100 inches).</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width of the final table in inches (A value of <code>NULL</code> will use 100 inches).</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_max_row">max_row</code></td>
<td>
<p>Maximum number of rows to have on a page. Spillover will hang over the side of the page..</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_max_col">max_col</code></td>
<td>
<p>Maximum number of columns to have on a page. Spillover will be wrapped to multiple pages.</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_notes_detect">notes_detect</code></td>
<td>
<p>Vector of strings to detect in output tables (example <code>c("NC", "BLQ")</code>).</p>
</td></tr>
<tr><td><code id="mk_table_ind_obs_+3A_rows_by">rows_by</code></td>
<td>
<p>Can be either &quot;time&quot; or &quot;id&quot;. If it is &quot;time&quot;, there will be a
column for time and separate column for each subject ID. If rows_by is set
to &quot;id&quot; there will be a column for ID and a column for each individual time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the following elements
</p>

<ul>
<li><p>isgood:      Boolean indicating the exit status of the function.
</p>
</li>
<li><p>one_table:   Dataframe of the entire table with the first lines containing the header.
</p>
</li>
<li><p>one_body:    Dataframe of the entire table (data only).
</p>
</li>
<li><p>one_header:  Dataframe of the entire header (row and body, no data).
</p>
</li>
<li><p>tables:      Named list of tables. Each list element is of the output
</p>
</li>
<li><p>msgs:        Vector of text messages describing any errors that were found.
format from <code><a href="onbrand.html#topic+build_span">build_span</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a state variable to be define
sess_res = NCA_test_mksession()

state = sess_res$state

# Pulls out the active analysis
current_ana = NCA_fetch_current_ana(state)

# This is the raw PKNCA output
pknca_res = NCA_fetch_ana_pknca(state, current_ana)

# Building the figure
mk_res = mk_table_ind_obs(nca_res = pknca_res)
mk_res$tables[["Table 1"]]$ft
</code></pre>

<hr>
<h2 id='mk_table_nca_params'>Create Tabular Output from PKNCA Results</h2><span id='topic+mk_table_nca_params'></span>

<h3>Description</h3>

<p>Create paginated tables from PKNCA to use in reports and Shiny
apps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_table_nca_params(
  nca_res,
  type = "individual",
  grouping = "interval",
  not_calc = "NC",
  obnd = NULL,
  nps = NULL,
  mult_str = "*",
  infinity = "inf",
  digits = NULL,
  text_format = "text",
  notes_detect = NULL,
  max_height = 7,
  max_width = 6.5,
  max_row = NULL,
  max_col = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mk_table_nca_params_+3A_nca_res">nca_res</code></td>
<td>
<p>Output of PKNCA.</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_type">type</code></td>
<td>
<p>Type of table to generate. Can be either <code>"individual"</code> or <code>"summary"]</code>.</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_grouping">grouping</code></td>
<td>
<p>How to group columns in tables. Can be either <code>"interval"</code> or <code>"parameter"]</code>.</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_not_calc">not_calc</code></td>
<td>
<p>Text string to replace NA values with to indicated values were not calculated.</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_obnd">obnd</code></td>
<td>
<p>onbrand reporting object.</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_nps">nps</code></td>
<td>
<p>NCA parameter summary table with the following columns.
</p>

<ul>
<li><p>parameter:      PKNCA Paramter name.
</p>
</li>
<li><p>text:           Name used in text output.
</p>
</li>
<li><p>md:             Name used markdown output.
</p>
</li>
<li><p>latex:          Name used in latex output.
</p>
</li>
<li><p>description:    Verbose textual description of the parameter.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_mult_str">mult_str</code></td>
<td>
<p>Text string to replace * values in units.</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_infinity">infinity</code></td>
<td>
<p>Text string to replace infinity in time intervals in column headers.</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_digits">digits</code></td>
<td>
<p>Number of significant figures to report (set to <code>NULL</code> to disable rounding)</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_text_format">text_format</code></td>
<td>
<p>Either <code>"md"</code> for markdown or <code>"text"</code> (default) for plain text.</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_notes_detect">notes_detect</code></td>
<td>
<p>Vector of strings to detect in output tables (example <code>c("NC", "BLQ")</code>).</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_max_height">max_height</code></td>
<td>
<p>Maximum height of the final table in inches (A value of <code>NULL</code> will use 100 inches).</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_max_width">max_width</code></td>
<td>
<p>Maximum width of the final table in inches (A value of <code>NULL</code> will use 100 inches).</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_max_row">max_row</code></td>
<td>
<p>Maximum number of rows to have on a page. Spillover will hang over the side of the page..</p>
</td></tr>
<tr><td><code id="mk_table_nca_params_+3A_max_col">max_col</code></td>
<td>
<p>Maximum number of columns to have on a page. Spillover will be wrapped to multiple pages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>raw_nca:     Raw PKNCA output.
</p>
</li>
<li><p>isgood:      Boolean indicating the exit status of the function.
</p>
</li>
<li><p>one_table:   Dataframe of the entire table with the first lines containing the header.
</p>
</li>
<li><p>one_body:    Dataframe of the entire table (data only).
</p>
</li>
<li><p>one_header:  Dataframe of the entire header (row and body, no data).
</p>
</li>
<li><p>tables:      Named list of tables. Each list element is of the output
</p>
</li>
<li><p>msgs:        Vector of text messages describing any errors that were found.
format from <code><a href="onbrand.html#topic+build_span">build_span</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a state variable to be define
sess_res = NCA_test_mksession()

state = sess_res$state

# Pulls out the active analysis
current_ana = NCA_fetch_current_ana(state)

# This is the raw PKNCA output
pknca_res = NCA_fetch_ana_pknca(state, current_ana)

# Parameter reporting details from the ruminate configuration
nps  = state[["NCA"]][["nca_parameters"]][["summary"]]

# Building the figure
mk_res = mk_table_nca_params(nca_res = pknca_res, nps=nps, digits=3)
mk_res$tables[["Table 1"]]$ft
</code></pre>

<hr>
<h2 id='NCA_add_int'>Adds Analysis Interval to Current Analysis</h2><span id='topic+NCA_add_int'></span>

<h3>Description</h3>

<p>Takes the start time, stop time, and NCA parameters and adds
them to the intervals table of the current analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_add_int(state, interval_start, interval_stop, nca_parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_add_int_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
<tr><td><code id="NCA_add_int_+3A_interval_start">interval_start</code></td>
<td>
<p>Interval start time (numeric).</p>
</td></tr>
<tr><td><code id="NCA_add_int_+3A_interval_stop">interval_stop</code></td>
<td>
<p>Interval stop time (numeric).</p>
</td></tr>
<tr><td><code id="NCA_add_int_+3A_nca_parameters">nca_parameters</code></td>
<td>
<p>list of NCA parameters in the interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p>State with interval added to the current analysis.
</p>

<hr>
<h2 id='NCA_append_report'>Append Report Elements</h2><span id='topic+NCA_append_report'></span>

<h3>Description</h3>

<p>Takes an NCA state object and appends any reportable elements
for the specified report type. On NCA analyses that are in a &quot;good&quot; state
will be reported. Those not in a good state will be ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_append_report(state, rpt, rpttype, gen_code_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_append_report_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
<tr><td><code id="NCA_append_report_+3A_rpt">rpt</code></td>
<td>
<p>Report with the current content of the report which will be appended to in
this function. For details on the structure see the documentation for
<code><a href="formods.html#topic+FM_generate_report">formods::FM_generate_report()</a></code></p>
</td></tr>
<tr><td><code id="NCA_append_report_+3A_rpttype">rpttype</code></td>
<td>
<p>Type of report to generate (supported &quot;xlsx&quot;, &quot;pptx&quot;, &quot;docx&quot;).</p>
</td></tr>
<tr><td><code id="NCA_append_report_+3A_gen_code_only">gen_code_only</code></td>
<td>
<p>Boolean value indicating that only code should be
generated (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>hasrptele: Boolean indicator if the module has any reportable elements.
</p>
</li>
<li><p>code:      Code to create report elements.
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li>
<li><p>rpt:       Report with any additions passed back to the user.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="formods.html#topic+FM_generate_report">formods::FM_generate_report()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a state object to use below
sess_res = NCA_test_mksession()
state = sess_res$state

# here we need an empty report object for tabular data
rpt = list(summary = list(), sheets=list())

# Now we append the report indicating we want
# Excel output:
rpt_res = NCA_append_report(state,
  rpt           = rpt,
  rpttype       = "xlsx",
  gen_code_only = TRUE)

# Shows if report elements are present
rpt_res$hasrptele

# Code chunk to generate report element
cat(paste(rpt_res$code, collapse="\n"))
</code></pre>

<hr>
<h2 id='nca_builder'>Builds NCA Code from ui Elements</h2><span id='topic+nca_builder'></span>

<h3>Description</h3>

<p>Takes the current analysis in the state object and creates the
code to run the analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nca_builder(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nca_builder_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>NCA state with the NCA for the current analysis built.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a module variables to be defined
sess_res = NCA_test_mksession()

state = sess_res$state

state = nca_builder(state)
</code></pre>

<hr>
<h2 id='NCA_fetch_ana_ds'>Fetch Analysis Dataset</h2><span id='topic+NCA_fetch_ana_ds'></span>

<h3>Description</h3>

<p>Fetches the dataset used for the specified analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_ana_ds(state, current_ana)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_fetch_ana_ds_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
<tr><td><code id="NCA_fetch_ana_ds_+3A_current_ana">current_ana</code></td>
<td>
<p>Current value in the analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataset from the <code>ds</code> field of FM_fetch_ds()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_fetch_ana_pknca'>Fetch PKNCA Results Object</h2><span id='topic+NCA_fetch_ana_pknca'></span>

<h3>Description</h3>

<p>Fetches the PKNCA output for a specified analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_ana_pknca(state, current_ana)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_fetch_ana_pknca_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
<tr><td><code id="NCA_fetch_ana_pknca_+3A_current_ana">current_ana</code></td>
<td>
<p>Current value in the analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataset from the <code>ds</code> field of FM_fetch_ds()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_fetch_code'>Fetch Module Code</h2><span id='topic+NCA_fetch_code'></span>

<h3>Description</h3>

<p>Fetches the code to generate results seen in the app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_code(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_fetch_code_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object vector with the lines of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_fetch_current_ana'>Fetches Current Analysis</h2><span id='topic+NCA_fetch_current_ana'></span>

<h3>Description</h3>

<p>Takes an NCA state and returns the current active analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_current_ana(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_fetch_current_ana_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the details of the current analysis. The structure
of this list is the same as the structure of <code>state$NCA$anas</code> in the output of
<code>NCA_fetch_state()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_fetch_current_obj'>Fetches the Current Analysis Object</h2><span id='topic+NCA_fetch_current_obj'></span>

<h3>Description</h3>

<p>Takes the current state and object type and returns the
currently selected object. For example if you have specified figure, it will
look at the output figure selected and the figure number of that figure and
return the ggplot object for that.
by subject id highlighting of certain NCA aspects (e.g. points used for half-life)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_current_obj(state, obj_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_fetch_current_obj_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
<tr><td><code id="NCA_fetch_current_obj_+3A_obj_type">obj_type</code></td>
<td>
<p>Type of object to return (either &quot;table&quot; or &quot;figure&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with a format that depends on the obj_type.
For figures:
</p>

<ul>
<li><p>ggplot:   ggplot object of the figure.
</p>
</li>
<li><p>isgood:   Return status of the function.
</p>
</li>
<li><p>msgs:     Messages to be passed back to the user.
</p>
</li></ul>

<p>For tables:
</p>

<ul>
<li><p>df:       Dataframe of the current table.
</p>
</li>
<li><p>ft:       Flextable object of the current table.
</p>
</li>
<li><p>notes:    Any table notes to be included.
</p>
</li>
<li><p>isgood:   Return status of the function.
</p>
</li>
<li><p>msgs:     Messages to be passed back to the user.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a state object to use below
sess_res = NCA_test_mksession()
state = sess_res$state

# Current active table:
res = NCA_fetch_current_obj(state, "table")
res$ft

# Current active figure:
res = NCA_fetch_current_obj(state, "figure")
res$ggplot
</code></pre>

<hr>
<h2 id='NCA_fetch_data_format'>Fetches Details About Data Requirements</h2><span id='topic+NCA_fetch_data_format'></span>

<h3>Description</h3>

<p>Use this to get information about data formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_data_format(
  MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_fetch_data_format_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with details about the data formats
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NCA_fetch_data_format()
</code></pre>

<hr>
<h2 id='NCA_fetch_ds'>Fetch Module Datasets</h2><span id='topic+NCA_fetch_ds'></span>

<h3>Description</h3>

<p>Fetches the datasets contained in the module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_ds(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_fetch_ds_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>hasds:     Boolean indicator if the module has any datasets
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li>
<li><p>ds:        List with datasets. Each list element has the name of
the R-object for that dataset. Each element has the following structure:
</p>

<ul>
<li><p>label: Text label for the dataset
</p>
</li>
<li><p>MOD_TYPE: Short name for the type of module.
</p>
</li>
<li><p>id: module ID
</p>
</li>
<li><p>DS: Dataframe containing the actual dataset.
</p>
</li>
<li><p>DSMETA: Metadata describing DS
</p>
</li>
<li><p>code: Complete code to build dataset.
</p>
</li>
<li><p>checksum: Module checksum.
</p>
</li>
<li><p>DSchecksum: Dataset checksum.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a state object to use below
sess_res = NCA_test_mksession()
state = sess_res$state

myDs = NCA_fetch_ds(state)
</code></pre>

<hr>
<h2 id='NCA_fetch_np_meta'>Fetches NCA Parameter Meta Information</h2><span id='topic+NCA_fetch_np_meta'></span>

<h3>Description</h3>

<p>This provides meta information about NCA parameters. This
includes parameter names, text descriptions, formatting (md and LaTeX).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_np_meta(
  MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_fetch_np_meta_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following elements:
</p>

<ul>
<li><p>choices: List parameter choices grouped by values specified in the module configuration file.
</p>
</li>
<li><p>summary: Data frame with meta data about the NCA parameters with
the following columns:
</p>

<ul>
<li><p>parameter:   Name of parameter in PKNCA.
</p>
</li>
<li><p>text:        Name of parameter in plain text.
</p>
</li>
<li><p>md:          Parameter name formatted in Markdown.
</p>
</li>
<li><p>latex:       Parameter name formatted using LaTeX.
</p>
</li>
<li><p>description: Verbose description in plain text for the parameter.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>NCA_fetch_np_meta()
</code></pre>

<hr>
<h2 id='NCA_fetch_PKNCA_meta'>Fetches PKNCA Metadata</h2><span id='topic+NCA_fetch_PKNCA_meta'></span>

<h3>Description</h3>

<p>Compiles Metadata from PKNCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_PKNCA_meta()
</code></pre>


<h3>Value</h3>

<p>Dataframe containing PKCNA metadata for NCA parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PKNCA_meta = NCA_fetch_PKNCA_meta()
utils::head(PKNCA_meta)
</code></pre>

<hr>
<h2 id='NCA_fetch_state'>Fetch ruminate State</h2><span id='topic+NCA_fetch_state'></span>

<h3>Description</h3>

<p>Merges default app options with the changes made in the UI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_fetch_state(
  id,
  input,
  session,
  FM_yaml_file,
  MOD_yaml_file,
  id_ASM,
  id_UD,
  id_DW,
  react_state
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_fetch_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID</p>
</td></tr>
<tr><td><code id="NCA_fetch_state_+3A_input">input</code></td>
<td>
<p>Shiny input variable</p>
</td></tr>
<tr><td><code id="NCA_fetch_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="NCA_fetch_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="NCA_fetch_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="NCA_fetch_state_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state management module used to save and load app states</p>
</td></tr>
<tr><td><code id="NCA_fetch_state_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to save and load app states</p>
</td></tr>
<tr><td><code id="NCA_fetch_state_+3A_id_dw">id_DW</code></td>
<td>
<p>ID string for the data wrangling module used to save and load app states</p>
</td></tr>
<tr><td><code id="NCA_fetch_state_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the current state of the app including default
values from the yaml file as well as any changes made by the user. The list
has the following structure:
</p>

<ul>
<li><p>yaml: Full contents of the supplied yaml file.
</p>
</li>
<li><p>MC: Module components of the yaml file.
</p>
</li>
<li><p>NCA:
</p>

<ul>
<li><p>ana_cntr:       Analysis counter.
</p>
</li>
<li><p>anas:                    List of analyses: Each analysis has the following  structure:
</p>

<ul>
<li><p>ana_dsview:       Dataset view/ID (name from DSV) selected as a data source for this analysis.
</p>
</li>
<li><p>ana_scenario:     Analysis scenario selected in the UI
</p>
</li>
<li><p>checksum:         checksum of the analysis (used to detect changes in the analysis).
</p>
</li>
<li><p>code:             Code to generate analysis from start to finish or error messages if code generation/analysis failed.
</p>
</li>
<li><p>code_components:  List containing the different components from code
</p>
</li>
<li><p>col_conc:         Column from ana_dsview containing the concentration data.
</p>
</li>
<li><p>col_dose:         Column from ana_dsview containing the dose amount.
</p>
</li>
<li><p>col_dur:          Column from ana_dsview containing the infusion duration or N/A if unused.
</p>
</li>
<li><p>col_group:        Columns from ana_dsview containing other grouping variables.
</p>
</li>
<li><p>col_id:           Column from ana_dsview containing the subject IDs.
</p>
</li>
<li><p>col_ntime:        Column from ana_dsview containing the nominal time values
</p>
</li>
<li><p>col_route:        Column from ana_dsview containing the dosing route.
</p>
</li>
<li><p>col_time:         Column from ana_dsview containing the time values.
</p>
</li>
<li><p>id:               Character id (<code>ana_idx</code>).
</p>
</li>
<li><p>idx:              Numeric id (<code>1</code>).
</p>
</li>
<li><p>include_units:    Boolean variable indicating in units should included in the analysis.
</p>
</li>
<li><p>interval_range:   Vector with the first element representing he beginning of the interval
and the second element containing the end of the interval.
</p>
</li>
<li><p>intervals:        List of the intervals to include.
</p>
</li>
<li><p>isgood:           Current status of the analysis.
</p>
</li>
<li><p>key:              Analysis key acts as a title/caption (user editable)
</p>
</li>
<li><p>msgs:             Messages generated when checking configuration and analysis options.
</p>
</li>
<li><p>nca_config:       List of NCA configuration options for this analysis.
</p>
</li>
<li><p>nca_object_name:  Prefix for NCA objects associated with this analyis.
</p>
</li>
<li><p>nca_parameters:   NCA parameters selected for calculation in the UI.
</p>
</li>
<li><p>notes:            Analysis notes  (user editable)
</p>
</li>
<li><p>objs:             List of names and values for objects created with generated code.
</p>
</li>
<li><p>sampling:         Sampling method either &quot;sparse&quot; or &quot;serial&quot;
</p>
</li>
<li><p>units_amt:        Amount units.
</p>
</li>
<li><p>units_conc:       Concentration units.
</p>
</li>
<li><p>units_dose:       Dosing units.
</p>
</li>
<li><p>units_time:       Time units.
</p>
</li></ul>

</li>
<li><p>current_ana:           Currently selected analysis (list name element from anas).
</p>
</li>
<li><p>DSV:                   Available data source views (see <code><a href="formods.html#topic+FM_fetch_ds">FM_fetch_ds</a></code>)
</p>
</li>
<li><p>checksum:              This is an MD5 sum of the module (checksum of the analysis checksums).
</p>
</li>
<li><p>nca_config:            List of PKNCA configuration options for this analysis.
</p>
</li>
<li><p>nca_parameters:        List with two elements
</p>

<ul>
<li><p>choices:          List consisting of &quot;Common Parameters&quot; and
&quot;Other&quot; (used for grouping in the UI).
Each of these is a list of text parameter
names with a value of the PKNCA parameter
name.
</p>
</li>
<li><p>summary:          Summary table with the following columns:
</p>

<ul>
<li><p>parameter:      PKNCA Paramter name.
</p>
</li>
<li><p>text:           Name used in text output.
</p>
</li>
<li><p>md:             Name used markdown output.
</p>
</li>
<li><p>latex:          Name used in latex output.
</p>
</li>
<li><p>description:    Verbose textual description of the parameter.
</p>
</li></ul>

</li></ul>

</li>
<li><p>ui:                    Current value of form elements in the UI.
</p>
</li>
<li><p>ui_ana_map:            Map between UI element names and analysis in the object you get from <code><a href="#topic+NCA_fetch_current_ana">NCA_fetch_current_ana</a></code>
</p>
</li>
<li><p>ui_ids:                Vector of UI elements for the module.
</p>
</li>
<li><p>ui_hold:               List of hold elements to disable updates before a full ui referesh is complete.
</p>
</li></ul>

</li>
<li><p>MOD_TYPE: Character data containing the type of module <code>"NCA"</code>
</p>
</li>
<li><p>id: Character data containing the module id module in the session variable.
</p>
</li>
<li><p>FM_yaml_file: App configuration file with FM as main section.
</p>
</li>
<li><p>MOD_yaml_file:  Module configuration file with MC as main section.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_find_col'>Determines Default Column Name</h2><span id='topic+NCA_find_col'></span>

<h3>Description</h3>

<p>Based on the current analysis, value from the UI, an optional
list of patterns to search, and column names from a dataset this function
tries to find a default value for a column in the analysis (e.g. subject id,
dose, concentration, etc).
</p>
<p>Generally the following is done:
</p>

<ul>
<li><p> If curr_ui has a non-NULL, non-&quot;&quot; value it is compared to dscols. If it
is found there that value is returned.
</p>
</li>
<li><p> If not then the patterns are considered. If the patterns from the YAML
file are not NULL they are compared sequentially to the columns names.
The first match found is returned.
</p>
</li>
<li><p> If nothing is found then the first value of dscols is returned.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>NCA_find_col(
  curr_ana = NULL,
  curr_ui = NULL,
  patterns = NULL,
  dscols,
  null_ok = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_find_col_+3A_curr_ana">curr_ana</code></td>
<td>
<p>Current value in the analysis</p>
</td></tr>
<tr><td><code id="NCA_find_col_+3A_curr_ui">curr_ui</code></td>
<td>
<p>Current value in UI</p>
</td></tr>
<tr><td><code id="NCA_find_col_+3A_patterns">patterns</code></td>
<td>
<p>List of regular expression patterns to consider.</p>
</td></tr>
<tr><td><code id="NCA_find_col_+3A_dscols">dscols</code></td>
<td>
<p>Columns from the dataset.</p>
</td></tr>
<tr><td><code id="NCA_find_col_+3A_null_ok">null_ok</code></td>
<td>
<p>Logical value indicating if a null result (nothing found) is
OK (default: <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Name of column found based on the rules above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_init_state'>Initialize NCA Module State</h2><span id='topic+NCA_init_state'></span>

<h3>Description</h3>

<p>Creates a list of the initialized module state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_init_state(FM_yaml_file, MOD_yaml_file, id, id_UD, id_DW, session)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_init_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="NCA_init_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="NCA_init_state_+3A_id">id</code></td>
<td>
<p>ID string for the module.</p>
</td></tr>
<tr><td><code id="NCA_init_state_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to handle uploads or the name of the list element in react_state where the data set is stored.</p>
</td></tr>
<tr><td><code id="NCA_init_state_+3A_id_dw">id_DW</code></td>
<td>
<p>ID string for the data wrangling module to process any uploaded data</p>
</td></tr>
<tr><td><code id="NCA_init_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing an empty NCA state
</p>

<hr>
<h2 id='NCA_load_scenario'>Loads Pre-Defined Scenario</h2><span id='topic+NCA_load_scenario'></span>

<h3>Description</h3>

<p>Loads a pre-defined analysis scneario from the NCA YAML config
file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_load_scenario(state, ana_scenario)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_load_scenario_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
<tr><td><code id="NCA_load_scenario_+3A_ana_scenario">ana_scenario</code></td>
<td>
<p>Short name of the analysis scenario to load from the config file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NCA state object with the scenario loaded and relevant notifications
set.
</p>

<hr>
<h2 id='NCA_mk_preload'>Make List of Current NCA State</h2><span id='topic+NCA_mk_preload'></span>

<h3>Description</h3>

<p>Reads in the app state from yaml files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_mk_preload(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_mk_preload_+3A_state">state</code></td>
<td>
<p>NCA state object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood:       Boolean indicating the exit status of the function.
</p>
</li>
<li><p>msgs:         Messages to be passed back to the user.
</p>
</li>
<li><p>yaml_list:    Lists with preload components.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>sess_res = NCA_test_mksession()
state = sess_res$state
res = NCA_mk_preload(state)
</code></pre>

<hr>
<h2 id='NCA_mkactive_ana'>Fetch PKNCA Results Object</h2><span id='topic+NCA_mkactive_ana'></span>

<h3>Description</h3>

<p>Fetches the PKNCA output for a specified analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_mkactive_ana(state, ana_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_mkactive_ana_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
<tr><td><code id="NCA_mkactive_ana_+3A_ana_id">ana_id</code></td>
<td>
<p>Analysis ID to make active.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>State with the analysis ID made active.
JMH add to example script below
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_new_ana'>Initialize New Analysis</h2><span id='topic+NCA_new_ana'></span>

<h3>Description</h3>

<p>Creates a new NCA analysis in an NCA module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_new_ana(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_new_ana_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>NCA state object containing a new empty analysis and that analysis
is set as the current active analyisis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_preload'>Preload Data for NCA Module</h2><span id='topic+NCA_preload'></span>

<h3>Description</h3>

<p>Populates the supplied session variable with information from
list of sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_preload(
  session,
  src_list,
  yaml_res,
  mod_ID = NULL,
  react_state = list(),
  quickload = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_preload_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
<tr><td><code id="NCA_preload_+3A_src_list">src_list</code></td>
<td>
<p>List of preload data (all read together with module IDs at the top level)</p>
</td></tr>
<tr><td><code id="NCA_preload_+3A_yaml_res">yaml_res</code></td>
<td>
<p>List data from module yaml config</p>
</td></tr>
<tr><td><code id="NCA_preload_+3A_mod_id">mod_ID</code></td>
<td>
<p>Module ID of the module being loaded.</p>
</td></tr>
<tr><td><code id="NCA_preload_+3A_react_state">react_state</code></td>
<td>
<p>Reactive shiny object (in app) or a list (outside of app) used to trigger reactions.</p>
</td></tr>
<tr><td><code id="NCA_preload_+3A_quickload">quickload</code></td>
<td>
<p>Logical <code>TRUE</code> to load reduced analysis <code>FALSE</code> to load the full analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood:      Boolean indicating the exit status of the function.
</p>
</li>
<li><p>msgs:        Messages to be passed back to the user.
</p>
</li>
<li><p>session:     Session object
</p>
</li>
<li><p>input:       The value of the shiny input at the end of the session initialization.
</p>
</li>
<li><p>state:       App state.
</p>
</li>
<li><p>react_state: The <code>react_state</code> components.
</p>
</li></ul>


<hr>
<h2 id='NCA_process_current_ana'>Processes Current Analysis to be Run</h2><span id='topic+NCA_process_current_ana'></span>

<h3>Description</h3>

<p>Takes the current analysis and checks different aspects to for
any issues to make sure it's good to go.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_process_current_ana(state)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_process_current_ana_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Current analysis list with isgood and msgs set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_Server'>Fetch Non-Compartmental Analysis State</h2><span id='topic+NCA_Server'></span>

<h3>Description</h3>

<p>Merges default app options with the changes made in the UI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_Server(
  id,
  FM_yaml_file = system.file(package = "formods", "templates", "formods.yaml"),
  MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml"),
  id_ASM = "ASM",
  id_UD = "UD",
  id_DW = "DW",
  deployed = FALSE,
  react_state = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_Server_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="NCA_Server_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="NCA_Server_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="NCA_Server_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state management module used to save and load app states</p>
</td></tr>
<tr><td><code id="NCA_Server_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to save and load app states</p>
</td></tr>
<tr><td><code id="NCA_Server_+3A_id_dw">id_DW</code></td>
<td>
<p>ID string for the data wrangling module used to save and load app states</p>
</td></tr>
<tr><td><code id="NCA_Server_+3A_deployed">deployed</code></td>
<td>
<p>Boolean variable indicating whether the app is deployed or not.</p>
</td></tr>
<tr><td><code id="NCA_Server_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the current state of the app including default
values from the yaml file as well as any changes made by the user. The list
has the following structure:
</p>

<ul>
<li><p>yaml: Full contents of the supplied yaml file.
</p>
</li>
<li><p>MC: Module components of the yaml file.
</p>
</li>
<li><p>NCA:
</p>

<ul>
<li><p>isgood: Boolean object indicating if the file was successfully loaded.
</p>
</li>
<li><p>checksum: This is an MD5 sum of the contents element and can be
used to detect changes in the state.
</p>
</li></ul>

</li>
<li><p>MOD_TYPE: Character data containing the type of module <code>"NCA"</code>
</p>
</li>
<li><p>id: Character data containing the module id module in the session variable.
</p>
</li>
<li><p>FM_yaml_file: App configuration file with FM as main section.
</p>
</li>
<li><p>MOD_yaml_file:  Module configuration file with MC as main section.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# original file: inst/templates/ruminate.R
library(formods)
library(ruminate)

# These are suggested packages
library(shinydashboard)
#library(ggpubr)
#library(plotly)
#library(shinybusy)
library(prompter)
#library(utils)

tags$style("@import url(https://use.fontawesome.com/releases/v6.4.0/css/all.css);")

# You can copy these locally and customize them for your own needs. Simply
# change the assignment to the local copy you've modified.
formods.yaml  = system.file(package="formods",  "templates",  "formods.yaml")
ASM.yaml      = system.file(package="formods",  "templates",  "ASM.yaml")
UD.yaml       = system.file(package="formods",  "templates",  "UD.yaml")
DW.yaml       = system.file(package="formods",  "templates",  "DW.yaml")
FG.yaml       = system.file(package="formods",  "templates",  "FG.yaml")
NCA.yaml      = system.file(package="ruminate", "templates",  "NCA.yaml")


# Name of  file to indicate we need to load testing data
ftmptest = file.path(tempdir(), "ruminate.test")


# Making sure that the deployed object is created
if(!exists("deployed")){
  deployed = FALSE
}

# If the DEPLOYED file marker existrs we set deployed to TRUE
if(file.exists("DEPLOYED")){
  deployed = TRUE
}

# # Making sure that the run_dev object is created
# if(file.exists(file.path(tempdir(), "RUMINTE_DEVELOPMENT"))){
#   run_dev  = TRUE
# }else{
#   run_dev  = FALSE
# }

# If the SETUP.R file exists we source it
if(file.exists("SETUP.R")){
  source("SETUP.R")
}



CSS &lt;- "
.wrapfig {
  float: right;
  shape-margin: 20px;
  margin-right: 20px;
  margin-bottom: 20px;
}
"

#https://fontawesome.com/icons?from=io
logo_url =
  "https://raw.githubusercontent.com/john-harrold/ruminate/main/man/figures/logo.png"
data_url =
  "https://github.com/john-harrold/formods/raw/master/inst/test_data/TEST_DATA.xlsx"
run_url  =
  "https://runruminate.ubiquity.tools/"
use_url  =
  "https://useruminate.ubiquity.tools/"
main_url =
  "https://ruminate.ubiquity.tools/"
issue_url =
  "https://github.com/john-harrold/ruminate/issues"

intro_text = tags$p(
"Ruminate is a shiny module for pharmacometric data processing,
visualization, and analysis. It consists of separate shiny modules that
provide interfaces into common R packages and provides the underlying code.
This is done to facilitate usage of those packages and to provide reproducible
analyses." ,
tags$li( "To find out more visit  ",
        tags$a("ruminate.ubiquity.tools", href=main_url),""),
tags$li( "To give it a try you can download a test dataset ",
        tags$a("here", href=data_url),""),
tags$li( "Go to  ",
        tags$a("useruminate.ubiquity.tools", href=use_url)," for a video
        demonstrating how to use ruminate"),
tags$li( "If you run into any problems, have questions, or want a feature please
        visit the ",
        tags$a("issues", href=issue_url)," page")
)


ui &lt;- shinydashboard::dashboardPage(
  skin="black",
  shinydashboard::dashboardHeader(title="ruminate"),
  shinydashboard::dashboardSidebar(
     shinydashboard::sidebarMenu(
       shinydashboard::menuItem("Load/Save",
                                tabName="loadsave",
                                icon=icon("arrow-down-up-across-line")) ,
       shinydashboard::menuItem("Transform Data", tabName="wrangle", icon=icon("shuffle")),
       shinydashboard::menuItem("Visualize",      tabName="plot",    icon=icon("chart-line")),
       shinydashboard::menuItem("NCA",            tabName="nca",     icon=icon("chart-area")),
       shinydashboard::menuItem("App Info",       tabName="sysinfo", icon=icon("book-medical"))
     )
  ),
  shinydashboard::dashboardBody(
  tags$head(
    tags$style(HTML(CSS))
  ),
    shinydashboard::tabItems(
       shinydashboard::tabItem(tabName="nca",
               shinydashboard::box(title="Non-Compartmental Analysis", width=12,
               fluidRow( prompter::use_prompt(),
               column(width=12,
               htmlOutput(NS("NCA",  "NCA_ui_compact")))))
               ),
       shinydashboard::tabItem(tabName="loadsave",
         #     shinydashboard::box(title=NULL, width=12,
               shinydashboard::tabBox(
                 width = 12,
                 title = NULL,
                 shiny::tabPanel(id="load_data",
                          title=tagList(shiny::icon("file-arrow-up"),
                                        "Load Data"),
                   fluidRow(
                     column(width=6,
                       div(style="display:inline-block;width:100%",
                       htmlOutput(NS("UD", "ui_ud_load_data"))),
                       htmlOutput(NS("UD", "ui_ud_clean")),
                       htmlOutput(NS("UD", "ui_ud_select_sheets")),
                       htmlOutput(NS("UD", "ui_ud_workflows")),
                       htmlOutput(NS("UD", "ui_ud_text_load_result"))),
                     column(width=6,
                         tags$p(
                             tags$img(
                             class = "wrapfig",
                             src   = logo_url,
                             width = 150,
                             alt = "formods logo" ),
                         intro_text
                         ))
                   ),
                 fluidRow(
                   column(width=12,
                          div(style="display:inline-block;vertical-align:top",
                                    htmlOutput(NS("UD", "ui_ud_data_preview")))
                          ))
                 ),
                 shiny::tabPanel(id="save_state",
                          title=tagList(shiny::icon("arrow-down-up-across-line"),
                                        "Save or Load Analysis"),
                 fluidRow(
                   column(width=5,
                          div(style="display:inline-block;vertical-align:top",
                   htmlOutput(NS("ASM", "ui_asm_compact"))
                   ))
                   )
                 )
               )
         #     ),
               ),
       shinydashboard::tabItem(tabName="wrangle",
               shinydashboard::box(title="Transform and Create Views of Your Data", width=12,
               fluidRow(
               column(width=12,
               htmlOutput(NS("DW",  "DW_ui_compact")))))
               ),
       shinydashboard::tabItem(tabName="plot",
               shinydashboard::box(title="Visualize Data", width=12,
               htmlOutput(NS("FG",  "FG_ui_compact")))),
       shinydashboard::tabItem(tabName="sysinfo",
         #     box(title="System Details", width=12,
               shinydashboard::tabBox(
                 width = 12,
                 title = NULL,
                 shiny::tabPanel(id="sys_packages",
                          title=tagList(shiny::icon("box-open"),
                                        "Installed Packages"),
                 htmlOutput(NS("ASM", "ui_asm_sys_packages"))
                 ),
                 shiny::tabPanel(id="sys_modules",
                          title=tagList(shiny::icon("cubes"),
                                        "Loaded Modules"),
                 htmlOutput(NS("ASM", "ui_asm_sys_modules"))
                 ),
                 shiny::tabPanel(id="sys_log",
                          title=tagList(shiny::icon("clipboard-list"),
                                        "Log"),
                 verbatimTextOutput(NS("ASM", "ui_asm_sys_log"))
                 ),
                 shiny::tabPanel(id="sys_options",
                          title=tagList(shiny::icon("sliders"),
                                        "R Options"),
                 htmlOutput(NS("ASM", "ui_asm_sys_options"))
                 )
         #       )
               ))
      )
    )
  )

# Main app server
server &lt;- function(input, output, session) {

  # Empty reactive object to track and react to
  # changes in the module state outside of the module
  react_FM = reactiveValues()

  # Module IDs and the order they are needed for code generation
  mod_ids = c("UD", "DW", "FG", "NCA", "MB")

  # If the ftmptest file is present we load test data
  if(file.exists(ftmptest)){
    sources = c(system.file(package="formods",  "preload", "ASM_preload.yaml"),
                system.file(package="formods",  "preload", "UD_preload.yaml"),
                system.file(package="formods",  "preload", "FG_preload.yaml"),
                system.file(package="formods",  "preload", "DW_preload.yaml"),
                system.file(package="ruminate", "preload", "NCA_preload.yaml"))

    res = FM_app_preload(session=session, sources=sources)
  # Otherwise we look for a preload file and load that if it exists
  } else if(file.exists("preload.yaml")){
    shinybusy::show_modal_spinner(text="Preloading analysis, be patient", session=session)
    res = FM_app_preload(session=session, sources="preload.yaml")
    shinybusy::remove_modal_spinner(session = session)
  }

  # Module servers
  formods::ASM_Server( id="ASM",
                       deployed      = deployed,
                       react_state   = react_FM,
                       FM_yaml_file  = formods.yaml,
                       MOD_yaml_file = ASM.yaml,
                       mod_ids       = mod_ids)
  formods::UD_Server(  id ="UD", id_ASM = "ASM",
                       deployed         = deployed,
                       react_state      = react_FM,
                       MOD_yaml_file    = UD.yaml,
                       FM_yaml_file     = formods.yaml)
  formods::DW_Server(  id="DW",       id_ASM = "ASM",
                       id_UD = "UD",
                       deployed         = deployed,
                       react_state      = react_FM,
                       MOD_yaml_file    = DW.yaml,
                       FM_yaml_file     = formods.yaml)
  formods::FG_Server(  id="FG",     id_ASM = "ASM",
                       id_UD = "UD", id_DW = "DW",
                       deployed         = deployed,
                       react_state      = react_FM,
                       MOD_yaml_file    = FG.yaml,
                       FM_yaml_file     = formods.yaml)
  ruminate::NCA_Server(id    ="NCA", id_ASM = "ASM",
                       id_UD = "UD", id_DW  = "DW",
                       deployed         = deployed,
                       react_state      = react_FM,
                       MOD_yaml_file    = NCA.yaml,
                       FM_yaml_file     = formods.yaml)

}

shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='NCA_set_current_ana'>Sets Current Analysis</h2><span id='topic+NCA_set_current_ana'></span>

<h3>Description</h3>

<p>Takes an NCA state and an analysis list and sets that figure list
as the value for the active figure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_set_current_ana(state, ana)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_set_current_ana_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
<tr><td><code id="NCA_set_current_ana_+3A_ana">ana</code></td>
<td>
<p>Analysis list from <code>NCA_fetch_current_ana</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>State with the current analysis updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ruminate)
# Module IDs                                                                   
id     = "NCA"                                                                 
id_UD  = "UD"                                                                  
id_DW  = "DW"                                                                  
id_ASM = "ASM"  
# We need session and input variables to be define                             
 sess_res = NCA_test_mksession()
                                                                               
# Extracting the session and input variables                                   
session      = sess_res$session                                                
input        = sess_res$input                                                  
react_state  = list()                                                          
                                                                               
# We also need configuration files                                             
FM_yaml_file  = system.file(package = "formods",  "templates", "formods.yaml") 
MOD_yaml_file = system.file(package = "ruminate", "templates", "NCA.yaml")     
                                                                               
# Getting the current module state                                             
state = NCA_fetch_state(id             = id,                                   
                       input           = input,                                
                       session         = session,                              
                       FM_yaml_file    = FM_yaml_file,                         
                       MOD_yaml_file   = MOD_yaml_file,                        
                       id_ASM          = id_ASM,                               
                       id_UD           = id_UD,                                
                       id_DW           = id_DW,                                
                       react_state     = react_state)                          
                                                                               
# Pulls out the active analysis                                                
current_ana = NCA_fetch_current_ana(state)

# This will get the dataset associated with this analysis
ds = NCA_fetch_ana_ds(state, current_ana)

# After making changes you can update those in the state
state = NCA_set_current_ana(state, current_ana)

# You can use this to check the current analysis
current_ana = NCA_process_current_ana(state)

# This will pull out the code for the module
fc_res = NCA_fetch_code(state)

# This will use patterns defined for the site to detect
# columns. In this example we are detecting the id column:
id_col = NCA_find_col(
  patterns = state[["MC"]][["detect_col"]][["id"]],
  dscols   = names(ds$DS))

# This creates a new analysis
state = NCA_new_ana(state)
</code></pre>

<hr>
<h2 id='NCA_test_mksession'>Populate Session Data for Module Testing</h2><span id='topic+NCA_test_mksession'></span>

<h3>Description</h3>

<p>Populates the supplied session variable for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NCA_test_mksession(session = list(), full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NCA_test_mksession_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
<tr><td><code id="NCA_test_mksession_+3A_full">full</code></td>
<td>
<p>Boolean indicating if the full test session should be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The NCA portion of the <code>all_sess_res</code> returned from <code><a href="formods.html#topic+FM_app_preload">FM_app_preload</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="formods.html#topic+FM_app_preload">FM_app_preload</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>session = shiny::MockShinySession$new()
sess_res = NCA_test_mksession(session=session)
</code></pre>

<hr>
<h2 id='plot_sr_ev'>Plots        Timecourse of Rules Simulations</h2><span id='topic+plot_sr_ev'></span>

<h3>Description</h3>

<div class="sourceCode"><pre>   Plots the timecourse of `simulate_rules()` output.
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sr_ev(
  sro = NULL,
  fpage = 1,
  fcol = "id",
  xcol = "time",
  error_msgs = NULL,
  ylog = TRUE,
  ylab_str = "Amount",
  xlab_str = "Time",
  post_proc = "fig  = fig + ggplot2::theme_light()",
  evplot = c(1, 4),
  fncol = 4,
  fnrow = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_sr_ev_+3A_sro">sro</code></td>
<td>
<p>Output of 'simulate_rules()'.</p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_fpage">fpage</code></td>
<td>
<p>If facets are selected and multiple pages are generated then
this indcates       the page to return.</p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_fcol">fcol</code></td>
<td>
<p>Name of column to facet by or <code>NULL</code> to disable faceting (<code>"id"</code>).</p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_xcol">xcol</code></td>
<td>
<p>Name of column to take x-data from (<code>"time"</code>).</p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_error_msgs">error_msgs</code></td>
<td>
<p>Named list with error messages to overwrite (<code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_ylog">ylog</code></td>
<td>
<p>Boolean to enable log10 scaling of the y-axis (<code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_ylab_str">ylab_str</code></td>
<td>
<p>Label for the y-axis (<code>"Output"</code></p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_xlab_str">xlab_str</code></td>
<td>
<p>Label for the x-axis (<code>"Output"</code></p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_post_proc">post_proc</code></td>
<td>
<p>Character object with post processing post-processing code for the figure object named <code>fig</code> internall  (<code>"fig = fig + theme_light()"</code>)</p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_evplot">evplot</code></td>
<td>
<p>Evids to plot can be 1 or 4</p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_fncol">fncol</code></td>
<td>
<p>Number of columns in faceted output.</p>
</td></tr>
<tr><td><code id="plot_sr_ev_+3A_fnrow">fnrow</code></td>
<td>
<p>Number of rows in faceted output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed examples see <code>vignette("clinical_trial_simulation", package = "ruminate")</code>.
</p>


<h3>Value</h3>

<p>List with the followin1g elements:
</p>

<ul>
<li><p>isgood:       Return status of the function.
</p>
</li>
<li><p>msgs:         Error or warning messages if any issues were encountered.
</p>
</li>
<li><p>npages:       Total number of pages using the current configuration.
</p>
</li>
<li><p>error_msgs:   List of error messages used.
</p>
</li>
<li><p>dsp:          Intermediate dataset generated from <code>sro</code> to plot in ggplot.
</p>
</li>
<li><p>fig:          Figure generated.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
library(ggplot2)

# For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html

# None of this will work if rxode2 isn't installed:
if(is_installed("rxode2")){
library(rxode2)
set.seed(8675309)
rxSetSeed(8675309)

my_model = function ()
{
    description &lt;- "One compartment PK model with linear clearance using differential equations"
    ini({
        lka &lt;- 0.45
        label("Absorption rate (Ka)")
        lcl &lt;- 1
        label("Clearance (CL)")
        lvc &lt;- 3.45
        label("Central volume of distribution (V)")
        propSd &lt;- c(0, 0.5)
        label("Proportional residual error (fraction)")
        etalcl ~ 0.1
    })
    model({
        ka &lt;- exp(lka)
        cl &lt;- exp(lcl + etalcl)
        vc &lt;- exp(lvc)
        kel &lt;- cl/vc
        d/dt(depot) &lt;- -ka * depot
        d/dt(central) &lt;- ka * depot - kel * central
        Cc &lt;- central/vc
        Cc ~ prop(propSd)
    })
}

# This creates an rxode2 object
object  = rxode(my_model)

# If you want details about the parameters, states, etc
# in the model you can use this:
rxdetails = fetch_rxinfo(object)

rxdetails$elements

# Next we will create subjects. To do that we need to
# specify information about covariates:
nsub = 2
covs = list(
  WT         = list(type     = "continuous",
                    sampling = "log-normal",
                    values   = c(70, .15))
)

subs = mk_subjects(object = object,
                   nsub   = nsub,
                   covs   = covs)

head(subs$subjects)

rules = list(
  dose = list(
    condition = "TRUE",
    action    = list(
      type  = "dose",
      state     = "central",
      values    = "c(1)",
      times     = "c(0)",
      durations = "c(0)")
    )
)

# We evaulate the rules for dosing at time 0
eval_times =  0

# Stop 2 months after the last dose
output_times = seq(0, 56, 1)

# This runs the rule-based simulations
simres =
  simulate_rules(
    object        = object,
    subjects      = subs[["subjects"]],
    eval_times    = eval_times,
    output_times  = output_times,
    rules         = rules)

# First subject data:
sub_1 = simres$simall[simres$simall$id == 1, ]

# First subjects events
evall = as.data.frame(simres$evall)
ev_sub_1 = evall[evall$id ==1, ]

# All of the simulation data
simall = simres$simall
simall$id = as.factor(simall$id)

# Timecourse
psim =
  plot_sr_tc(
    sro    = simres,
    dvcols = "Cc")
psim$fig

# Events
pev =
  plot_sr_ev(
    sro    = simres,
    ylog   = FALSE)
pev$fig

}

</code></pre>

<hr>
<h2 id='plot_sr_tc'>Plots        Timecourse of Rules Simulations</h2><span id='topic+plot_sr_tc'></span>

<h3>Description</h3>

<div class="sourceCode"><pre>   Plots the timecourse of `simulate_rules()` output.
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sr_tc(
  sro = NULL,
  dvcols = NULL,
  fpage = 1,
  fcol = "id",
  xcol = "time",
  error_msgs = NULL,
  ylog = TRUE,
  ylab_str = "Output",
  xlab_str = "Time",
  post_proc = "fig  = fig + ggplot2::theme_light()",
  fncol = 4,
  fnrow = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_sr_tc_+3A_sro">sro</code></td>
<td>
<p>Output of 'simulate_rules()'.</p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_dvcols">dvcols</code></td>
<td>
<p>Character vector of dependent variables.</p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_fpage">fpage</code></td>
<td>
<p>If facets are selected and multiple pages are generated then
this indcates       the page to return.</p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_fcol">fcol</code></td>
<td>
<p>Name of column to facet by or <code>NULL</code> to disable faceting (<code>"id"</code>).</p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_xcol">xcol</code></td>
<td>
<p>Name of column to take x-data from (<code>"time"</code>).</p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_error_msgs">error_msgs</code></td>
<td>
<p>Named list with error messages to overwrite (<code>NULL</code></p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_ylog">ylog</code></td>
<td>
<p>Boolean to enable log10 scaling of the y-axis (<code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_ylab_str">ylab_str</code></td>
<td>
<p>Label for the y-axis (<code>"Output"</code></p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_xlab_str">xlab_str</code></td>
<td>
<p>Label for the x-axis (<code>"Output"</code></p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_post_proc">post_proc</code></td>
<td>
<p>Character object with post processing post-processing code for the figure object named <code>fig</code> internall  (<code>"fig = fig + theme_light()"</code>)</p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_fncol">fncol</code></td>
<td>
<p>Number of columns in faceted output.</p>
</td></tr>
<tr><td><code id="plot_sr_tc_+3A_fnrow">fnrow</code></td>
<td>
<p>Number of rows in faceted output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed examples see <code>vignette("clinical_trial_simulation", package = "ruminate")</code>.
</p>


<h3>Value</h3>

<p>List with the followin1g elements:
</p>

<ul>
<li><p>isgood:       Return status of the function.
</p>
</li>
<li><p>msgs:         Error or warning messages if any issues were encountered.
</p>
</li>
<li><p>npages:       Total number of pages using the current configuration.
</p>
</li>
<li><p>error_msgs:   List of error messages used.
</p>
</li>
<li><p>dsp:          Intermediate dataset generated from <code>sro</code> to plot in ggplot.
</p>
</li>
<li><p>fig:          Figure generated.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
library(ggplot2)

# For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html

# None of this will work if rxode2 isn't installed:
if(is_installed("rxode2")){
library(rxode2)
set.seed(8675309)
rxSetSeed(8675309)

my_model = function ()
{
    description &lt;- "One compartment PK model with linear clearance using differential equations"
    ini({
        lka &lt;- 0.45
        label("Absorption rate (Ka)")
        lcl &lt;- 1
        label("Clearance (CL)")
        lvc &lt;- 3.45
        label("Central volume of distribution (V)")
        propSd &lt;- c(0, 0.5)
        label("Proportional residual error (fraction)")
        etalcl ~ 0.1
    })
    model({
        ka &lt;- exp(lka)
        cl &lt;- exp(lcl + etalcl)
        vc &lt;- exp(lvc)
        kel &lt;- cl/vc
        d/dt(depot) &lt;- -ka * depot
        d/dt(central) &lt;- ka * depot - kel * central
        Cc &lt;- central/vc
        Cc ~ prop(propSd)
    })
}

# This creates an rxode2 object
object  = rxode(my_model)

# If you want details about the parameters, states, etc
# in the model you can use this:
rxdetails = fetch_rxinfo(object)

rxdetails$elements

# Next we will create subjects. To do that we need to
# specify information about covariates:
nsub = 2
covs = list(
  WT         = list(type     = "continuous",
                    sampling = "log-normal",
                    values   = c(70, .15))
)

subs = mk_subjects(object = object,
                   nsub   = nsub,
                   covs   = covs)

head(subs$subjects)

rules = list(
  dose = list(
    condition = "TRUE",
    action    = list(
      type  = "dose",
      state     = "central",
      values    = "c(1)",
      times     = "c(0)",
      durations = "c(0)")
    )
)

# We evaulate the rules for dosing at time 0
eval_times =  0

# Stop 2 months after the last dose
output_times = seq(0, 56, 1)

# This runs the rule-based simulations
simres =
  simulate_rules(
    object        = object,
    subjects      = subs[["subjects"]],
    eval_times    = eval_times,
    output_times  = output_times,
    rules         = rules)

# First subject data:
sub_1 = simres$simall[simres$simall$id == 1, ]

# First subjects events
evall = as.data.frame(simres$evall)
ev_sub_1 = evall[evall$id ==1, ]

# All of the simulation data
simall = simres$simall
simall$id = as.factor(simall$id)

# Timecourse
psim =
  plot_sr_tc(
    sro    = simres,
    dvcols = "Cc")
psim$fig

# Events
pev =
  plot_sr_ev(
    sro    = simres,
    ylog   = FALSE)
pev$fig

}

</code></pre>

<hr>
<h2 id='ruminate_check'>Checks <code>ruminate</code> Dependencies</h2><span id='topic+ruminate_check'></span>

<h3>Description</h3>

<p>Looks at the suggested dependencies and checks to make sure
they are installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruminate_check(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ruminate_check_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if messages should be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following elements:
</p>

<ul>
<li><p>all_found:    Boolean indicating if all packages were found
</p>
</li>
<li><p>found_pkgs:   Character vector of found packages
</p>
</li>
<li><p>missing_pkgs: Character vector of missing packages
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fcres =ruminate_check()
</code></pre>

<hr>
<h2 id='run_nca_components'>Runs NCA for the Current Analysis</h2><span id='topic+run_nca_components'></span>

<h3>Description</h3>

<p>Takes the current state and runs the current analysis in that
state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_nca_components(
  state,
  components = c("nca", "fg_ind_obs", "tb_ind_obs", "tb_ind_params"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_nca_components_+3A_state">state</code></td>
<td>
<p>NCA state from <code>NCA_fetch_state()</code></p>
</td></tr>
<tr><td><code id="run_nca_components_+3A_components">components</code></td>
<td>
<p>List of components to run. By default it will run all of
the following. If you just need to regenerate a figure based on the current
nca results you can just specify that component. These are the valid</p>
</td></tr>
<tr><td><code id="run_nca_components_+3A_verbose">verbose</code></td>
<td>
<p>Logical to enable or disable messaging
components:
</p>

<ul>
<li><p>nca:               Run NCA analysis
</p>
</li>
<li><p>fg_ind_obs:        Build the figure(s) with the indiviudal observations.
</p>
</li>
<li><p>tb_ind_obs:        Build the table(s) with the indiviudal observations.
</p>
</li>
<li><p>tb_ind_params:     Build the table(s) with the indiviudal parameters.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following components:
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>msgs:      Error messages if any issues were encountered.
</p>
</li>
<li><p>nca_res:   PKNCA results if run was successful.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a state object to use below
sess_res = NCA_test_mksession()
state = sess_res$state

state = run_nca_components(state, components="tb_ind_params")
</code></pre>

<hr>
<h2 id='rx2other'>Converts an rxode2 Object Into Specified Model Format</h2><span id='topic+rx2other'></span>

<h3>Description</h3>

<p>If you have an rxode2 or nlmixr2 model object you can use this
function to translate that object into other formats. See output_type below
for the allowed formats.
</p>
<p>In order to do this you need at least one between-subject variability term
and one endpoint. If these are missing then dummy values will be added. The
dummy values for between-subject variablitiy are IIV will be
<code>POP_RUMINATE</code>, <code>TV_RUMINATE</code>, and <code>ETA.RUMINATE</code>. The dummy
terms for endpoints are <code>OUT_RUMINATE</code> and <code>add.OUT_RUMINATE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rx2other(
  object,
  out_type = "nonmem",
  dataset = NULL,
  export_name = "my_model",
  export_path = tempfile(pattern = "dir")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rx2other_+3A_object">object</code></td>
<td>
<p>rxode2 model object</p>
</td></tr>
<tr><td><code id="rx2other_+3A_out_type">out_type</code></td>
<td>
<p>Output type (either &quot;nonmem&quot;, &quot;monolix&quot;)</p>
</td></tr>
<tr><td><code id="rx2other_+3A_dataset">dataset</code></td>
<td>
<p>Optional dataset</p>
</td></tr>
<tr><td><code id="rx2other_+3A_export_name">export_name</code></td>
<td>
<p>Basename for models used</p>
</td></tr>
<tr><td><code id="rx2other_+3A_export_path">export_path</code></td>
<td>
<p>Location to place output files (default <code>tempdir()</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Known issues: If you have specified bioavailability in the model, it will
fail on the Monolix conversion.
</p>


<h3>Value</h3>

<p>List with the following elements:
</p>

<ul>
<li><p>isgood:     Return status of the function.
</p>
</li>
<li><p>msgs:       Error or warning messages if any issues were encountered.
</p>
</li>
<li><p>files:      If succesful this will contain a list with an entry for
each file generated to support the requested format.
the current file format. For example if &quot;nonmem&quot; was
selected this will include elements for &quot;ctl&quot; and
&quot;csv&quot;. Each of these are lists with the following
format:
</p>

<ul>
<li><p>fn:       Exported file name
</p>
</li>
<li><p>fn_full:  Exported file name with the full path.
</p>
</li>
<li><p>contents: Contents of the file.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(ruminate)
if( Sys.getenv("ruminate_rxfamily_found") == "TRUE"){
 # First create an rxode2 model:
 library(rxode2)
 one.compartment &lt;- function() {
   rxode2::ini({
     tka &lt;- log(1.57); label("Ka")
     tcl &lt;- log(2.72); label("Cl")
     tv &lt;- log(31.5); label("V")
     eta.ka ~ 0.6
     eta.cl ~ 0.3
     eta.v ~ 0.1
     add.sd &lt;- 0.7
   })
   # and a model block with the error specification and model specification
   rxode2::model({
     ka &lt;- exp(tka + eta.ka)
     cl &lt;- exp(tcl + eta.cl)
     v &lt;- exp(tv + eta.v)
     d/dt(depot) &lt;- -ka * depot
     d/dt(center) &lt;- ka * depot - cl / v * center
     cp &lt;- center / v
     cp ~ add(add.sd)
   })
 }

 nmout = rx2other(one.compartment, out_type="nonmem")

}
</code></pre>

<hr>
<h2 id='simulate_rules'>Rule-Based simulates</h2><span id='topic+simulate_rules'></span>

<h3>Description</h3>

<p>Simulate an rxode2 model based on rules evaluated at specified
time-points. For example if you want to titrate dosing based on individual
plasma levels you could create a rule that changes dosing at specified time
points based on the last observation of the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_rules(
  object,
  subjects,
  eval_times,
  output_times,
  time_scales = NULL,
  rules,
  rx_options = list(),
  preamble = "",
  pbm = "Evaluation times",
  smooth_sampling = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_rules_+3A_object">object</code></td>
<td>
<p>rxode2 model object  An ID string that corresponds with the ID
used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="simulate_rules_+3A_subjects">subjects</code></td>
<td>
<p>Dataframe of subject level information.</p>
</td></tr>
<tr><td><code id="simulate_rules_+3A_eval_times">eval_times</code></td>
<td>
<p>Vector of simulation times to evaulate the rules (units are
time units of the system).</p>
</td></tr>
<tr><td><code id="simulate_rules_+3A_output_times">output_times</code></td>
<td>
<p>Specific output times to include. Other times will be
included as well to ensure proper evaluation of the rules.</p>
</td></tr>
<tr><td><code id="simulate_rules_+3A_time_scales">time_scales</code></td>
<td>
<p>Optional list with timescale information to include in the output.</p>
</td></tr>
<tr><td><code id="simulate_rules_+3A_rules">rules</code></td>
<td>
<p>List of rules, see below for a description of the format.</p>
</td></tr>
<tr><td><code id="simulate_rules_+3A_rx_options">rx_options</code></td>
<td>
<p>List of options to pass through to <code>rxSolve()</code>.</p>
</td></tr>
<tr><td><code id="simulate_rules_+3A_preamble">preamble</code></td>
<td>
<p>Character string of user-defined code to execute in
rule-evaluation environment (e.g. you can put user-defined functions here).</p>
</td></tr>
<tr><td><code id="simulate_rules_+3A_pbm">pbm</code></td>
<td>
<p>Progress bar message, set to NULL to disable.</p>
</td></tr>
<tr><td><code id="simulate_rules_+3A_smooth_sampling">smooth_sampling</code></td>
<td>
<p>Boolean when TRUE will insert sampling just before
dosing to make sampling smooth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed examples see <code>vignette("clinical_trial_simulation", package = "ruminate")</code>
</p>
<p>The underlying simulations are run using <code>rxode2</code>, and as such we need
an <code>rxode2</code> system object. From that we can either simulate subjects or
load them from a file. Next we need to define a set of rules. These will
be a set of conditions and actions. At each evaluation time point the
conditions are evaluated. When a condition is met the actions associated
with that condition are executed. For example, if during a visit (an
evaluation time point) the trough PK is below a certain level
(condition) we may want to increase the dosing regimen for the next
dosing cycle (action).
</p>


<h4>Creating subjects</h4>

<p>Subjects are expected in a data frame with the following column headers:
</p>

<ul>
<li> <p><code>id</code> Individual subject id
</p>
</li>
<li><p> Names of parameters and iiv as specified in the <code>ini</code> section of the
<code>rxode2</code> function specification
</p>
</li>
<li><p> Names of covariates used in the model.
</p>
</li></ul>

<p><code>mk_subjects()</code>  Creates subjects for simulation by sampling based on
between-subject variability and generating covariate information based
on user specifications.
</p>


<h5>Covariates</h5>

<p>The <code>covs</code> input is a list with the following structure:
</p>

<ul>
<li><p> type: Can be either fixed, discrete, or continuous.
</p>
</li>
<li><p> sampling: This field is only needed for a continuous covariate 
type and can be either random, normal or log-normal.
</p>
</li>
<li><p> values: This field depends on the type and optional sampling above.
</p>

<ul>
<li><p> fixed: A single value.
</p>
</li>
<li><p> discrete: A vector of possible discrete elements.
</p>
</li>
<li><p> continuous, random: Two values the first is the lower bound and the
second is the upper bound.
</p>
</li>
<li><p> continuous, normal: Two values the first is the mean and the second
is the variance.
</p>
</li>
<li><p> continuous, log-normal: Two values the first is the mean and the
second is the variance.
</p>
</li></ul>

</li></ul>

<p>This examples shows the <code>SEX_ID</code> randomly sampled from the values
specified, <code>SUBTYPE_ID</code> fixed at a value, and <code>WT</code> sampled from a
log-normal distribution.
</p>
<div class="sourceCode r"><pre>covs = list(
  SEX_ID     = list(type     = "discrete", 
                    values   = c(0,1)),
  SUBTYPE_ID = list(type     = "fixed",
                    values   = c(0)),
  WT         = list(type     = "continuous",
                    sampling = "log-normal",
                    values   = c(70, .15))
)
</pre></div>




<h4>Rule-based simulations</h4>

<p><code>simulate_rules()</code>  This will run simulations based on the rule
definitions below.
</p>


<h5>Rules</h5>

<p>Rules are a named list where the list name can be a short descriptive
label used to remember what the rule does. These names will be returned
as columns in the simulated data frame.
</p>

<ul>
<li> <p><code>condition</code>: Character string that evaluates to either <code>TRUE</code> or
<code>FALSE</code>. When true the <code>action</code> portion will be triggered. For a list
of objects available see the Rule-evaluation environment below.
</p>
</li>
<li> <p><code>fail_flag</code>: Flag set in the <code>rule_id</code> column when the condition is
not met (set to <code>"false"</code> if not specified).
</p>
</li>
<li> <p><code>true_flag</code>: Flag set in the <code>rule_id</code> column when the condition is
met (set to <code>"true"</code> if not specified).
</p>
</li>
<li> <p><code>action</code>: This is what the rule will trigger can be any of the
following:
</p>

<ul>
<li> <p><code>type</code>: This defines the action type and can be either <code>"dose"</code>,
<code>"set state"</code>, or <code>"manual"</code>.
</p>
</li></ul>

</li></ul>

<p>Based on the <code>type</code> the <code>action</code> field will expect different elements.
</p>
<p>Dosing:
</p>

<ul>
<li> <p><code>action</code>
</p>

<ul>
<li> <p><code>type</code>: <code>"dose"</code>
</p>
</li>
<li> <p><code>values</code>: Character string that evaluates as a numeric vector dosing
amounts (e.g.<code>"c(3,  3,  3,  3)"</code>)
</p>
</li>
<li> <p><code>times</code>: Character string that evaluates as a numeric vector of
times (e.g.<code>"c(0, 14, 28, 42)"</code>)
</p>
</li>
<li> <p><code>durations</code>: Character string that evaluates as a numeric vector of
durations (e.g.<code>"c(0, 0, 0, 0)"</code>, zero for bolus dosing)
</p>
</li></ul>

</li></ul>

<p>Changing a state value:
</p>

<ul>
<li> <p><code>action</code>
</p>

<ul>
<li> <p><code>type</code>: <code>"set state"</code>
</p>
</li>
<li> <p><code>state</code>: Character string with the name of the state to set (<code>"Ac"</code>)
</p>
</li>
<li> <p><code>value</code>: Character string that evaluates as a numeric value for
state (e.g.<code>"Ac/2"</code> would set the state to half the value of Ac at
the evaluation point)
</p>
</li></ul>

</li></ul>

<p>Manual modification of the simulation:
</p>

<ul>
<li> <p><code>action</code>
</p>

<ul>
<li> <p><code>type</code>: <code>"manual"</code>
</p>
</li>
<li> <p><code>code</code>: Character string of code to evaluate.
</p>
</li></ul>

</li></ul>




<h5>Rule-evaluation environment</h5>

<p>Beyond simple simulations it will be necessary to execute actions based
on the current or previous state of the system. For this reason, when a
<code>condition</code> or elements of the action (e.g., the <code>values</code>, <code>times</code> and
<code>durations</code> of a dose action type) are being evaluated, the following
objects will be available at each evaluation point:
</p>

<ul>
<li><p> outputs: The value of each model output.
</p>
</li>
<li><p> states: The value of each named state or compartment.
</p>
</li>
<li><p> covariates: The value of each named covariate.
</p>
</li>
<li><p> subject-level parameters: The value of each named parameter.
</p>
</li>
<li><p> rule value: The last value the rule evaluated as.
</p>
</li>
<li> <p><code>id</code>: Current subject id.
</p>
</li>
<li> <p><code>time</code>: Current evaluation time.
</p>
</li>
<li> <p><code>SI_SUB_HISTORY</code>: A data frame of the simulation history of the
current subject up to the current evaluation point.
</p>
</li>
<li> <p><code>SI_subjects</code>: The subjects data frame.
</p>
</li>
<li> <p><code>SI_eval_times</code>: Vector of the evaluation times.
</p>
</li>
<li> <p><code>SI_interval_ev</code>: The events table in its current state for the given
simulation interval.
</p>
</li>
<li> <p><code>SI_ev_history</code>: This is the history of the event table containing all
the events leading up to the current interval.
</p>
</li>
<li> <p><code>SI_ud_history</code>: This is a free form object the user can define or
alter within the manualaction type (ud-user defined, history).
</p>
</li></ul>



<h6>The following functions will be available:</h6>


<ul>
<li> <p><code>SI_fpd</code>: This function will fetch the previous dose (fpd) for the
given id and state. For example for the current <code>id</code> and the state
<code>Ac</code> you would do the following:
</p>
</li></ul>

<div class="sourceCode r"><pre>SI_fpd(id=id, state="Ac")
</pre></div>




<h5>Time scales</h5>

<p>You can include columns in your output for different time scales if you
wish. You need to create a list in the format below. One element should
be <code>system</code> with a short name for the system time scale. The next should
be <code>details</code> which is a list containing short names for each time scale
you want to include. Each of these is a list with a verbose name for the
time scale (<code>verb</code>) and a numerical conversion indicating how that time
scale relates to the others. Here we define weeks and days on the basis
of seconds.
</p>
<div class="sourceCode r"><pre>time_scales = list(system="days", 
                details= list(
                  weeks = list(verb="Weeks",    conv=1/(60*60*24*7)),
                  days  = list(verb="Days",     conv=1/(60*60*24))))
</pre></div>




<h3>Value</h3>

<p>List with the following elements:
</p>

<ul>
<li><p>isgood:     Return status of the function.
</p>
</li>
<li><p>msgs:       Error or warning messages if any issues were encountered.
</p>
</li>
<li><p>simall:     Simulation results.
</p>
</li>
<li><p>ev_history: The event table for the entire simulation history.
</p>
</li>
<li><p>eval_times: Evaluation time points at the system time scale
</p>
</li>
<li><p>eval_times_df: Data frame of the evaluation time points with a
column for the system time scale and then columns for named time scales.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
library(ggplot2)

# For more information see the Clinical Trial Simulation vignette:
# https://ruminate.ubiquity.tools/articles/clinical_trial_simulation.html

# None of this will work if rxode2 isn't installed:
if(is_installed("rxode2")){
library(rxode2)
set.seed(8675309)
rxSetSeed(8675309)

my_model = function ()
{
    description &lt;- "One compartment PK model with linear clearance using differential equations"
    ini({
        lka &lt;- 0.45
        label("Absorption rate (Ka)")
        lcl &lt;- 1
        label("Clearance (CL)")
        lvc &lt;- 3.45
        label("Central volume of distribution (V)")
        propSd &lt;- c(0, 0.5)
        label("Proportional residual error (fraction)")
        etalcl ~ 0.1
    })
    model({
        ka &lt;- exp(lka)
        cl &lt;- exp(lcl + etalcl)
        vc &lt;- exp(lvc)
        kel &lt;- cl/vc
        d/dt(depot) &lt;- -ka * depot
        d/dt(central) &lt;- ka * depot - kel * central
        Cc &lt;- central/vc
        Cc ~ prop(propSd)
    })
}

# This creates an rxode2 object
object  = rxode(my_model)

# If you want details about the parameters, states, etc
# in the model you can use this:
rxdetails = fetch_rxinfo(object)

rxdetails$elements

# Next we will create subjects. To do that we need to
# specify information about covariates:
nsub = 2
covs = list(
  WT         = list(type     = "continuous",
                    sampling = "log-normal",
                    values   = c(70, .15))
)

subs = mk_subjects(object = object,
                   nsub   = nsub,
                   covs   = covs)

head(subs$subjects)

rules = list(
  dose = list(
    condition = "TRUE",
    action    = list(
      type  = "dose",
      state     = "central",
      values    = "c(1)",
      times     = "c(0)",
      durations = "c(0)")
    )
)

# We evaulate the rules for dosing at time 0
eval_times =  0

# Stop 2 months after the last dose
output_times = seq(0, 56, 1)

# This runs the rule-based simulations
simres =
  simulate_rules(
    object        = object,
    subjects      = subs[["subjects"]],
    eval_times    = eval_times,
    output_times  = output_times,
    rules         = rules)

# First subject data:
sub_1 = simres$simall[simres$simall$id == 1, ]

# First subjects events
evall = as.data.frame(simres$evall)
ev_sub_1 = evall[evall$id ==1, ]

# All of the simulation data
simall = simres$simall
simall$id = as.factor(simall$id)

# Timecourse
psim =
  plot_sr_tc(
    sro    = simres,
    dvcols = "Cc")
psim$fig

# Events
pev =
  plot_sr_ev(
    sro    = simres,
    ylog   = FALSE)
pev$fig

}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
