<!DOCTYPE html><html><head><title>Help for package brglm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {brglm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brglm'><p>Bias reduction in Binomial-response GLMs</p></a></li>
<li><a href='#brglm.control'><p>Auxiliary for Controlling BRGLM Fitting</p></a></li>
<li><a href='#confint.brglm'><p>Computes confidence intervals of parameters for bias-reduced estimation</p></a></li>
<li><a href='#gethats'><p>Calculates the Leverages for a GLM through a C Routine</p></a></li>
<li><a href='#glm.control1'><p>Auxiliary for Controlling BRGLM Fitting</p></a></li>
<li><a href='#lizards'><p>Habitat Preferences of Lizards</p></a></li>
<li><a href='#modifications'><p>Additive Modifications to the Binomial Responses and Totals for</p>
Use within &lsquo;brglm.fit&rsquo;</a></li>
<li><a href='#plot.profile.brglm'><p>Plot methods for 'profile.brglm' objects</p></a></li>
<li><a href='#profile.brglm'><p>Calculate profiles for objects of class 'brglm'.</p></a></li>
<li><a href='#profileObjectives-brglm'><p>Objectives to be profiled</p></a></li>
<li><a href='#separation.detection'><p>Separation Identification.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bias Reduction in Binomial-Response Generalized Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ikosmidis/brglm">https://github.com/ikosmidis/brglm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ikosmidis/brglm/issues">https://github.com/ikosmidis/brglm/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Fit generalized linear models with binomial responses using either an adjusted-score approach to bias reduction or maximum penalized likelihood where penalization is by Jeffreys invariant prior. These procedures return estimates with improved frequentist properties (bias, mean squared error) that are always finite even in cases where the maximum likelihood estimates are infinite (data separation). Fitting takes place by fitting generalized linear models on iteratively updated pseudo-data. The interface is essentially the same as 'glm'.  More flexibility is provided by the fact that custom pseudo-data representations can be specified and used for model fitting. Functions are provided for the construction of confidence intervals for the reduced-bias estimates.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.6.0), profileModel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-22 10:44:03 UTC; yiannis</td>
</tr>
<tr>
<td>Author:</td>
<td>Ioannis Kosmidis <a href="https://orcid.org/0000-0003-1556-0302"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ioannis Kosmidis &lt;ioannis.kosmidis@warwick.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-22 11:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='brglm'>Bias reduction in Binomial-response GLMs</h2><span id='topic+brglm'></span><span id='topic+brglm.fit'></span><span id='topic+print.brglm'></span><span id='topic+summary.brglm'></span><span id='topic+print.summary.brglm'></span>

<h3>Description</h3>

<p>Fits binomial-response GLMs using the bias-reduction method developed in
Firth (1993) for the removal of the leading (<code class="reqn">\mathop{\rm
O}(n^{-1})</code>) term from the asymptotic expansion of the bias
of the maximum likelihood estimator. Fitting is performed using
pseudo-data representations, as described in Kosmidis (2007, Chapter 5). For
estimation in binomial-response GLMs, the bias-reduction method is an
improvement over traditional maximum likelihood because:
</p>

<ul>
<li><p> the bias-reduced estimator is second-order unbiased and has smaller
variance than the maximum likelihood estimator and
</p>
</li>
<li><p> the resulting estimates and their corresponding standard errors
are <b>always</b> finite while the maximum likelihood estimates
can be infinite (in situations where complete or quasi separation
occurs); see Kosmidis &amp; Firth (2021) for the proof of finiteness in
logistic regression models.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>brglm(formula, family = binomial, data, weights, subset, na.action,
      start = NULL, etastart, mustart, offset,
      control.glm = glm.control1(...), model = TRUE, method = "brglm.fit",
      pl = FALSE, x = FALSE, y = TRUE, contrasts = NULL,
      control.brglm = brglm.control(...), ...)

brglm.fit(x, y, weights = rep(1, nobs), start = NULL, etastart = NULL,
          mustart = NULL, offset = rep(0, nobs), family = binomial(),
          control = glm.control(), control.brglm = brglm.control(),
          intercept = TRUE, pl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brglm_+3A_formula">formula</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_family">family</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>. <code>brglm</code> currently
supports only the <code>"binomial"</code> family with links
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>, <code>"cauchit"</code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_data">data</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_weights">weights</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_subset">subset</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_na.action">na.action</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_start">start</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_etastart">etastart</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_mustart">mustart</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_offset">offset</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_control.glm">control.glm</code></td>
<td>
<p><code>control.glm</code> replaces the <code>control</code>
argument in <code><a href="stats.html#topic+glm">glm</a></code> but essentially does the same job. It
is a list  of parameters to control <code><a href="stats.html#topic+glm.fit">glm.fit</a></code>. See the
documentation of  <code>glm.control1</code> for details.</p>
</td></tr>
<tr><td><code id="brglm_+3A_control">control</code></td>
<td>
<p>same as in <code><a href="stats.html#topic+glm">glm</a></code>. Only available to
<code>brglm.fit</code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_intercept">intercept</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_model">model</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_method">method</code></td>
<td>
<p>the method to be used for fitting the model. The default
method is <code>"brglm.fit"</code>, which uses either the modified-scores
approach to  estimation or maximum penalized likelihood (see
the  <code>pl</code> argument below).  The standard
<code><a href="stats.html#topic+glm">glm</a></code> methods <code>"glm.fit"</code> for maximum likelihood and
<code>"model.frame"</code> for returning the model frame without any
fitting, are also accepted.</p>
</td></tr>
<tr><td><code id="brglm_+3A_pl">pl</code></td>
<td>
<p>a logical value indicating whether the
model should be fitted using maximum penalized likelihood, where the
penalization is done using Jeffreys invariant prior, or using the
bias-reducing modified scores. It is only used when
<code>method = "brglm.fit"</code>. The default value is <code>FALSE</code> (see also the
Details section).</p>
</td></tr>
<tr><td><code id="brglm_+3A_x">x</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_y">y</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_contrasts">contrasts</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="brglm_+3A_control.brglm">control.brglm</code></td>
<td>
<p>a list of parameters for controlling the fitting
process when <code>method = "brglm.fit"</code>. See documentation of
<code><a href="#topic+brglm.control">brglm.control</a></code> for details.</p>
</td></tr>
<tr><td><code id="brglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>brglm.fit</code> is the workhorse function for fitting the model using
either the bias-reduction method or maximum penalized likelihood. If
<code>method = "glm.fit"</code>, usual maximum likelihood is used via
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.
</p>
<p>The main iteration of <code>brglm.fit</code> consists of the following
steps:
</p>

<ol>
<li><p>  Calculate the diagonal components of the hat matrix (see
<code><a href="#topic+gethats">gethats</a></code> and <code><a href="stats.html#topic+hatvalues">hatvalues</a></code>).
</p>
</li>
<li><p> Obtain the pseudo-data representation at the current value of the
parameters (see <code><a href="#topic+modifications">modifications</a></code> for more information).
</p>
</li>
<li><p> Fit a local GLM, using <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> on the pseudo data.
</p>
</li>
<li><p> Adjust the quadratic weights to agree with the original
binomial totals.
</p>
</li></ol>

<p>Iteration is repeated until either the iteration limit has been reached
or the sum of the absolute values of the modified scores is less than
some specified positive constant (see the <code>br.maxit</code> and
<code>br.epsilon</code> arguments in <code><a href="#topic+brglm.control">brglm.control</a></code>).
</p>
<p>The default value (<code>FALSE</code>) of <code>pl</code>, when <code>method = "brglm.fit"</code>,
results in estimates that are free of any <code class="reqn">\mathop{\rm
O}(n^{-1})</code> terms in the asymptotic expansion of their bias. When
<code>pl = TRUE</code> bias-reduction is again achieved but generally not at
such order of magnitude. In the case of logistic regression the value of
<code>pl</code> is irrelevant since maximum penalized likelihood and the
modified-scores approach coincide for natural exponential families (see
Firth, 1993).
</p>
<p>For other language related details see the details section in
<code><a href="stats.html#topic+glm">glm</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+brglm">brglm</a></code> returns an object of class <code>"brglm"</code>. A
<code>"brglm"</code> object inherits first from <code>"glm"</code> and then from
<code>"lm"</code> and is a list containing the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>qr</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code> (see Details).</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>ModifiedScores</code></td>
<td>
<p>the vector of the modified scores for the
parameters at the final iteration. If <code>pl = TRUE</code> they are the
derivatives of the penalized likelihood at the final iteration.</p>
</td></tr>
<tr><td><code>FisherInfo</code></td>
<td>
<p>the Fisher information matrix evaluated at the
resulting estimates. Only available when <code>method = "brglm.fit"</code>.</p>
</td></tr>
<tr><td><code>hats</code></td>
<td>
<p>the diagonal elements of the hat matrix. Only available
when <code>method = "brglm.fit"</code></p>
</td></tr>
<tr><td><code>nIter</code></td>
<td>
<p>the number of iterations that were required until
convergence. Only available when <code>method = "brglm.fit"</code>.</p>
</td></tr>
<tr><td><code>cur.model</code></td>
<td>
<p>a list with components <code>ar</code> and <code>at</code> which
contains the values of the additive modifications to the responses
(<code>y</code>) and to the binomial totals (<code>prior.weights</code>) at
the resulting estimates (see <code><a href="#topic+modifications">modifications</a></code> for more
information). Only available  when <code>method = "brglm.fit"</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>control.glm</code></td>
<td>
<p>as <code>control</code> in the result of
<code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>control.brglm</code></td>
<td>
<p>the <code>control.brglm</code> argument that was passed to
<code>brglm</code>. Only available when <code>method = "brglm.fit"</code>.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the method used for fitting the model.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code>pl</code></td>
<td>
<p>logical having the same value with the <code>pl</code>
argument passed to <code>brglm</code>. Only available when <code>method =
      "brglm.fit"</code>.</p>
</td></tr>
</table>


<h3>Warnings</h3>

<p>1. It is not advised to use methods associated with model comparison
(<code><a href="stats.html#topic+add1">add1</a></code>, <code><a href="stats.html#topic+drop1">drop1</a></code>,
<code><a href="stats.html#topic+anova">anova</a></code>, etc.) on objects of class
<code>"brglm"</code>. Model comparison when estimation is performed using
the modified scores or the penalized likelihood is an on-going
research topic and will be implemented as soon as it is concluded.
</p>
<p>2. The use of Akaike's information criterion (AIC) for model selection
when <code>method = "brglm.fit"</code> is asymptotically valid, because
the log-likelihood derivatives dominate the modification (in terms
of asymptotic order). 
</p>


<h3>Note</h3>

<p>1. Supported methods for objects of class <code>"brglm"</code> are:
</p>

<ul>
<li><p><code><a href="base.html#topic+print">print</a></code>through <code>print.brglm</code>.
</p>
</li>
<li><p><code><a href="base.html#topic+summary">summary</a></code>through <code>summary.brglm</code>.
</p>
</li>
<li><p><code><a href="stats.html#topic+coefficients">coefficients</a></code>inherited from the
<code>"glm"</code> class.
</p>
</li>
<li><p><code><a href="stats.html#topic+vcov">vcov</a></code>inherited from the<code>"glm"</code>
class.
</p>
</li>
<li><p><code><a href="stats.html#topic+predict">predict</a></code>inherited from the<code>"glm"</code>
class.
</p>
</li>
<li><p><code><a href="stats.html#topic+residuals">residuals</a></code>inherited from the<code>"glm"</code>
class.
</p>
</li>
<li><p>and other methods that apply to objects of class
<code>"glm"</code>
</p>
</li></ul>

<p>2. A similar implementation of the bias-reduction method could be done
for every GLM, following Kosmidis (2007) (see also Kosmidis and Firth,
2009). The full set of families and links will be available in a
future version. However, bias-reduction is not generally beneficial
as it is in the binomial family and it could cause inflation of the
variance (see Firth,  1993).
</p>
<p>3. Basically, the differences between maximum likelihood, maximum
penalized likelihood and the modified scores approach are more
apparent in small sample sizes, in sparse data sets and in cases
where complete or quasi-complete separation occurs. Asymptotically
(as <code class="reqn">n</code> goes to infinity), the three different approaches are
equivalent to first order.
</p>
<p>4. When an offset is not present in the model, the modified-scores based
estimates are usually smaller in magnitude than the corresponding
maximum likelihood estimates, shrinking towards the origin of the
scale imposed by the link function. Thus, the corresponding
estimated asymptotic standard errors are also smaller.
</p>
<p>The same is true for the maximum penalized likelihood estimates when
for example, the logit (where the maximum penalized likelihood and
modified-scores approaches coincide) or the probit links are
used. However, generally the maximum penalized likelihood estimates do
not shrink towards the origin. In terms of mean-value
parameterization, in the case of maximum penalized likelihood the
fitted probabilities would shrink towards the point where the Jeffreys
prior is maximized or equivalently where the  quadratic weights are
simultaneously maximized (see Kosmidis, 2007).
</p>
<p>5. Implementations of the bias-reduction method for logistic
regressions can also be found in the <span class="pkg">logistf</span> package. In
addition to the obvious advantage of <code>brglm</code> in the range of
link functions that can be used (<code>"logit"</code>, <code>"probit"</code>,
<code>"cloglog"</code> and <code>"cauchit"</code>), <code>brglm</code> is also more
efficient computationally. Furthermore, for any user-specified link
function (see the Example section of <code><a href="stats.html#topic+family">family</a></code>), the
user can specify the corresponding pseudo-data representation to be
used within <code>brglm</code> (see <code><a href="#topic+modifications">modifications</a></code> for
details).  </p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>References</h3>

<p>Kosmidis I. and Firth D. (2021). Jeffreys-prior penalty, finiteness
and shrinkage in binomial-response generalized linear
models. <em>Biometrika</em>, <b>108</b>, 71&ndash;82.
</p>
<p>Bull, S. B., Lewinger, J. B. and Lee, S. S. F. (2007). Confidence
intervals for multinomial logistic regression in sparse
data. <em>Statistics in Medicine</em> <b>26</b>, 903&ndash;918.
</p>
<p>Firth, D. (1992) Bias reduction, the Jeffreys prior and GLIM. In
<em>Advances in GLIM and statistical modelling: Proceedings of the
GLIM 92 conference, Munich</em>, Eds. L.~Fahrmeir, B.~Francis,
R.~Gilchrist and G.Tutz, pp. 91&ndash;100. New York: Springer.
</p>
<p>Firth, D. (1992) Generalized linear models and Jeffreys priors: An
iterative generalized least-squares approach. In <em>Computational
Statistics I</em>, Eds. Y. Dodge and J. Whittaker. Heidelberg: Physica-Verlag.
</p>
<p>Firth, D. (1993). Bias reduction of maximum likelihood
estimates. <em>Biometrika</em> <b>80</b>, 27&ndash;38.
</p>
<p>Heinze, G. and Schemper, M. (2002). A solution to the problem of
separation in logistic regression. <em>Statistics in Medicine</em>
<b>21</b>, 2409&ndash;2419.
</p>
<p>Kosmidis, I. (2007). Bias reduction in exponential family nonlinear
models. <em>PhD Thesis</em>, Department of Statistics, University of
Warwick.
</p>
<p>Kosmidis, I. and Firth, D. (2009). Bias reduction in exponential
family nonlinear models. <em>Biometrika</em>
<b>96</b>, 793&ndash;804.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+glm.fit">glm.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Begin Example
data(lizards)
# Fit the GLM using maximum likelihood
lizards.glm &lt;- brglm(cbind(grahami, opalinus) ~ height + diameter +
                  light + time, family = binomial(logit), data=lizards,
                  method = "glm.fit")
# Now the bias-reduced fit:
lizards.brglm &lt;- brglm(cbind(grahami, opalinus) ~ height + diameter +
                  light + time, family = binomial(logit), data=lizards,
                  method = "brglm.fit")
lizards.glm
lizards.brglm
# Other links
update(lizards.brglm, family = binomial(probit))
update(lizards.brglm, family = binomial(cloglog))
update(lizards.brglm, family = binomial(cauchit))
# Using penalized maximum likelihood
update(lizards.brglm, family = binomial(probit), pl = TRUE)
update(lizards.brglm, family = binomial(cloglog), pl = TRUE)
update(lizards.brglm, family = binomial(cauchit), pl = TRUE)
</code></pre>

<hr>
<h2 id='brglm.control'>Auxiliary for Controlling BRGLM Fitting</h2><span id='topic+brglm.control'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for <code><a href="#topic+brglm">brglm</a></code>
fitting. Typically only used when calling <code>brglm</code> or <code>brglm.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brglm.control(br.epsilon = 1e-08, br.maxit = 100, br.trace=FALSE,
              br.consts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brglm.control_+3A_br.epsilon">br.epsilon</code></td>
<td>
<p>positive convergence tolerance for the iteration
described in <code><a href="#topic+brglm.fit">brglm.fit</a></code>.</p>
</td></tr>
<tr><td><code id="brglm.control_+3A_br.maxit">br.maxit</code></td>
<td>
<p>integer giving the maximum number of iterations for
the iteration in <code><a href="#topic+brglm.fit">brglm.fit</a></code>.</p>
</td></tr>
<tr><td><code id="brglm.control_+3A_br.trace">br.trace</code></td>
<td>
<p>logical indicating if output should be prooduced for
each iteration.</p>
</td></tr>
<tr><td><code id="brglm.control_+3A_br.consts">br.consts</code></td>
<td>
<p>a (small) positive constant or a vector of
such.</p>
</td></tr>
<tr><td><code id="brglm.control_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>br.trace=TRUE</code> then for each iteration the iteration number
and the current value of the modified scores is
<code><a href="base.html#topic+cat">cat</a></code>'ed. If <code>br.consts</code> is specified then <code>br.consts</code>
is added to the original binomial counts and <code>2*br.consts</code>. Then
the model is fitted to the adjusted data to provide starting values
for the iteration in <code><a href="#topic+brglm.fit">brglm.fit</a></code>. If <code>br.consts = NULL</code>
(default) then <code><a href="#topic+brglm.fit">brglm.fit</a></code> adjusts the responses and totals by
&quot;number of parameters&quot;/&quot;number of observations&quot; and twice that, respectively.
</p>


<h3>Value</h3>

<p>A list with the arguments as components.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>References</h3>

<p>Kosmidis I. and Firth D. (2021). Jeffreys-prior penalty, finiteness
and shrinkage in binomial-response generalized linear
models. <em>Biometrika</em>, <b>108</b>, 71&ndash;82. 
</p>
<p>Kosmidis, I. (2007). Bias reduction in exponential family nonlinear
models. <em>PhD Thesis</em>, Department of Statistics, University of
Warwick.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brglm.fit">brglm.fit</a></code>, the fitting procedure used by
<code><a href="#topic+brglm">brglm</a></code>.
</p>

<hr>
<h2 id='confint.brglm'>Computes confidence intervals of parameters for bias-reduced estimation</h2><span id='topic+confint.brglm'></span><span id='topic+confint.profile.brglm'></span>

<h3>Description</h3>

<p>Computes confidence intervals for one or more parameters when
estimation is performed using <code><a href="#topic+brglm">brglm</a></code>. The resulting confidence
intervals are based on manipulation of the profiles of the deviance,
the penalized deviance and the modified score statistic (see
<code><a href="#topic+profileObjectives">profileObjectives</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brglm'
confint(object, parm = 1:length(coef(object)), level = 0.95,
        verbose = TRUE, endpoint.tolerance = 0.001,
        max.zoom = 100, zero.bound = 1e-08, stepsize = 0.5,
        stdn = 5, gridsize = 10, scale = FALSE, method = "smooth",
        ci.method = "union", n.interpolations = 100, ...)

## S3 method for class 'profile.brglm'
confint(object, parm, level = 0.95, method = "smooth",
        ci.method = "union", endpoint.tolerance = 0.001,
        max.zoom = 100, n.interpolations = 100, verbose = TRUE,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.brglm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"brglm"</code> or <code>"profile.brglm"</code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_parm">parm</code></td>
<td>
<p>either a numeric vector of indices or a character vector
of names, specifying the parameters for which confidence intervals
are to be estimated. The default is all parameters in the fitted
model. When <code>object</code> is of class <code>"profile.brglm"</code>,
<code>parm</code> is not used and confidence intervals are returned for
all the parameters for which profiling took place.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_level">level</code></td>
<td>
<p>the confidence level required. The default is 0.95. When
<code>object</code> is of class <code>"profile.brglm"</code>, <code>level</code> is not
used and the level attribute of <code>object</code> is used instead.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_verbose">verbose</code></td>
<td>
<p>logical. If <code>TRUE</code> (default) progress indicators
are printed during the progress of calculating the confidence
intervals.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_endpoint.tolerance">endpoint.tolerance</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+confintModel">confintModel</a></code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_max.zoom">max.zoom</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+confintModel">confintModel</a></code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_zero.bound">zero.bound</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+confintModel">confintModel</a></code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_stepsize">stepsize</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+confintModel">confintModel</a></code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_stdn">stdn</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+confintModel">confintModel</a></code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_gridsize">gridsize</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+confintModel">confintModel</a></code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_scale">scale</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+confintModel">confintModel</a></code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_method">method</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+confintModel">confintModel</a></code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_ci.method">ci.method</code></td>
<td>
<p>The method to be used for the construction of
confidence intervals. It can take values <code>"union"</code> (default) and
<code>"mean"</code> (see Details).</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_n.interpolations">n.interpolations</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+confintModel">confintModel</a></code>.</p>
</td></tr>
<tr><td><code id="confint.brglm_+3A_...">...</code></td>
<td>
<p>further arguments to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of logistic regression Heinze &amp; Schemper (2002) and Bull
et. al. (2007) suggest the use of confidence intervals based on the
profiles of the penalized likelihood, when estimation is performed
using maximum penalized likelihood.
</p>
<p>Kosmidis (2007) illustrated that because of the shape of the penalized
likelihood, confidence intervals based on the penalized likelihood
could exhibit low or even zero coverage for hypothesis testing on
large parameter values and also misbehave illustrating severe
oscillation (see Brown et. al., 2001); see, also Kosmidis &amp; Firth
(2021) for discussion on the schrinkage implied by bias reduction and
what that entails for inference. Kosmidis (2007) suggested an
alternative confidence interval that is based on the union of the
confidence intervals resulted by profiling the ordinary deviance for
the maximum likelihood fit and by profiling the penalized deviance for
the maximum penalized fit.  Such confidence intervals, despite of
being slightly conservative, illustrate less oscillation and avoid the
loss of coverage. Another possibility is to use the mean of the
corresponding endpoints instead of &ldquo;union&rdquo;. Yet unpublished
simulation studies suggest that such confidence intervals are not as
conservative as the &ldquo;union&rdquo; based intervals but illustrate more
oscillation, which however is not as severe as in the case of the
penalized likelihood based ones.
</p>
<p>The properties of the &ldquo;union&rdquo; and &ldquo;mean&rdquo; confidence
intervals extend  to all the links that are supported by
<code><a href="#topic+brglm">brglm</a></code>, when  estimation is performed using maximum
penalized likelihood.
</p>
<p>In the case of estimation using modified scores and for models other
than logistic, where there is not an objective that is maximized, the
profiles of the penalized likelihood for the construction of the
&ldquo;union&rdquo; and &ldquo;mean&rdquo; confidence intervals can be replaced
by the profiles of modified score statistic (see
<code><a href="#topic+profileObjectives">profileObjectives</a></code>).
</p>
<p>The <code>confint</code> method for <code>brglm</code> and <code>profile.brglm</code>
objects implements the &ldquo;union&rdquo; and &ldquo;mean&rdquo; confidence
intervals. The method is chosen through the <code>ci.method</code> argument.
</p>


<h3>Value</h3>

<p>A matrix with columns the endpoints of the confidence intervals for
the specified (or profiled) parameters.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>References</h3>

<p>Kosmidis I. and Firth D. (2021). Jeffreys-prior penalty, finiteness
and shrinkage in binomial-response generalized linear
models. <em>Biometrika</em>, <b>108</b>, 71&ndash;82. 
</p>
<p>Brown, L. D., Cai, T. T. and DasGupta, A. (2001).
Interval estimation for a binomial proportion (with discussion).
<em>Statistical Science</em> <b>16</b>, 101&ndash;117.
</p>
<p>Bull, S. B., Lewinger, J. B. and Lee, S. S. F. (2007). Confidence
intervals for multinomial logistic regression in sparse data.
<em>Statistics in Medicine</em> <b>26</b>, 903&ndash;918.
</p>
<p>Heinze, G. and Schemper, M. (2002). A solution to the problem of
separation in logistic regression.
<em>Statistics in Medicine</em> <b>21</b>, 2409&ndash;2419.
</p>
<p>Kosmidis, I. (2007). Bias reduction in exponential family nonlinear
models. <em>PhD Thesis</em>, Department of Statistics, University of
Warwick.
</p>


<h3>See Also</h3>

<p><code><a href="profileModel.html#topic+confintModel">confintModel</a></code>, <code><a href="profileModel.html#topic+profileModel">profileModel</a></code>,
<code><a href="#topic+profile.brglm">profile.brglm</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Begin Example 1
## Not run: 
library(MASS)
data(bacteria)
contrasts(bacteria$trt) &lt;- structure(contr.sdif(3),
          dimnames = list(NULL, c("drug", "encourage")))
# fixed effects analyses
m.glm.logit &lt;- brglm(y ~ trt * week, family = binomial,
                     data = bacteria, method = "glm.fit")
m.brglm.logit &lt;- brglm(y ~ trt * week, family = binomial,
                       data = bacteria, method = "brglm.fit")
p.glm.logit &lt;- profile(m.glm.logit)
p.brglm.logit &lt;- profile(m.brglm.logit)
#
plot(p.glm.logit)
plot(p.brglm.logit)
# confidence intervals for the glm fit based on the profiles of the
# ordinary deviance
confint(p.glm.logit)
# confidence intervals for the brglm fit
confint(p.brglm.logit, ci.method = "union")
confint(p.brglm.logit, ci.method = "mean")
# A cloglog link
m.brglm.cloglog &lt;- update(m.brglm.logit, family = binomial(cloglog))
p.brglm.cloglog &lt;- profile(m.brglm.cloglog)
plot(p.brglm.cloglog)
confint(m.brglm.cloglog, ci.method = "union")
confint(m.brglm.cloglog, ci.method = "mean")
## End example

## End(Not run)
## Not run: 
## Begin Example 2
y &lt;- c(1, 1, 0, 0)
totals &lt;- c(2, 2, 2, 2)
x1 &lt;- c(1, 0, 1, 0)
x2 &lt;- c(1, 1, 0, 0)
m1 &lt;- brglm(y/totals ~ x1 + x2, weights = totals,
            family = binomial(cloglog))
p.m1 &lt;- profile(m1)
confint(p.m1, method="zoom")

## End(Not run)
</code></pre>

<hr>
<h2 id='gethats'>Calculates the Leverages for a GLM through a C Routine</h2><span id='topic+gethats'></span>

<h3>Description</h3>

<p>Calculates the leverages of a GLM through a C routine.  It is intended to
be used only within <code><a href="#topic+brglm.fit">brglm.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gethats(nobs, nvars, x.t, XWXinv, ww)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gethats_+3A_nobs">nobs</code></td>
<td>
<p>The number of observations, i.e. <code>dim(X)[1]</code>.</p>
</td></tr>
<tr><td><code id="gethats_+3A_nvars">nvars</code></td>
<td>
<p>The number of parameters, i.e. <code>dim(X)[1]</code>, where
<code>X</code> is the model matrix, excluding the columns that correspond to
aliased parameters.</p>
</td></tr>
<tr><td><code id="gethats_+3A_x.t">x.t</code></td>
<td>
<p><code>t(X)</code>.</p>
</td></tr>
<tr><td><code id="gethats_+3A_xwxinv">XWXinv</code></td>
<td>
<p>The inverse of the Fisher information.</p>
</td></tr>
<tr><td><code id="gethats_+3A_ww">ww</code></td>
<td>
<p>The &lsquo;working&rsquo; weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the diagonal elements of the hat matrix.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hatvalues">hatvalues</a></code>, <code><a href="#topic+brglm.fit">brglm.fit</a></code></p>

<hr>
<h2 id='glm.control1'>Auxiliary for Controlling BRGLM Fitting</h2><span id='topic+glm.control1'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for <code><a href="#topic+brglm">brglm</a></code>
fitting. Typically only used when calling <code>brglm</code> or
<code>brglm.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm.control1(epsilon = 1e-08, maxit = 25, trace = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.control1_+3A_epsilon">epsilon</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="glm.control1_+3A_maxit">maxit</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="glm.control1_+3A_trace">trace</code></td>
<td>
<p>as in <code><a href="stats.html#topic+glm.control">glm.control</a></code>.</p>
</td></tr>
<tr><td><code id="glm.control1_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The only difference with <code><a href="stats.html#topic+glm.control">glm.control</a></code> is that
<code>glm.control1</code> supports further arguments to be passed from other
methods. However, this additional arguments have no effect on the
resulting list.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>

<hr>
<h2 id='lizards'>Habitat Preferences of Lizards</h2><span id='topic+lizards'></span>

<h3>Description</h3>

<p>The <code>lizards</code> data frame has 23 rows and 6 columns.
Variables <code>grahami</code> and <code>opalinus</code> are counts
of two lizard species at two different perch heights, two
different perch diameters, in sun and in shade, at three
times of day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lizards)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt><code>grahami</code></dt><dd><p>count of grahami lizards</p>
</dd>
<dt><code>opalinus</code></dt><dd><p>count of opalinus lizards</p>
</dd>
<dt><code>height</code></dt><dd><p>a factor with levels <code>"&lt;5ft"</code>, <code>"&gt;=5ft"</code></p>
</dd>
<dt><code>diameter</code></dt><dd><p>a factor with levels <code>"&lt;=2in"</code>, <code>"&gt;2in"</code></p>
</dd>
<dt><code>light</code></dt><dd><p>a factor with levels <code>"sunny"</code>, <code>"shady"</code></p>
</dd>
<dt><code>time</code></dt><dd><p>a factor with levels <code>"early"</code>, <code>"midday"</code>,
<code>"late"</code></p>
</dd>
</dl>



<h3>Source</h3>

  
<p>McCullagh, P. and Nelder, J. A. (1989) <em>Generalized Linear
Models</em> (2nd Edition).  London: Chapman and Hall.
</p>
<p>Originally from
</p>
<p>Schoener, T. W. (1970)  Nonsynchronous spatial overlap of lizards in
patchy habitats.  <em>Ecology</em> <b>51</b>, 408&ndash;418.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lizards)
glm(cbind(grahami, opalinus) ~ height + diameter + light + time,
    family = binomial, data=lizards)
brglm(cbind(grahami, opalinus) ~ height + diameter + light + time,
    family = binomial, data=lizards)
</code></pre>

<hr>
<h2 id='modifications'>Additive Modifications to the Binomial Responses and Totals for
Use within &lsquo;brglm.fit&rsquo;</h2><span id='topic+modifications'></span><span id='topic+checkModifications'></span>

<h3>Description</h3>

<p>Get, test and set the functions that calculate the additive
modifications to the responses and totals in binomial-response GLMs,
for the application of bias-reduction either via modified scores or
via maximum penalized likelihood  (where penalization is by Jeffreys
invariant prior).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifications(family, pl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modifications_+3A_family">family</code></td>
<td>
<p>a family object of the form <code>binomial(link = "link")</code>, where
<code>"link"</code> can be one of <code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>
and <code>"cauchit"</code>. The usual ways of giving the family name are
supported (see <code><a href="stats.html#topic+family">family</a></code>).</p>
</td></tr>
<tr><td><code id="modifications_+3A_pl">pl</code></td>
<td>
<p>logical determining whether the function returned corresponds
to modifications for the penalized maximum likelihood approach or for
the modified-scores approach to bias-reduction. Default value is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returned from <code>modifications</code> accepts the argument <code>p</code>
which are the binomial probabilities and returns a list with
components <code>ar</code> and <code>at</code>, which are the link-dependent parts
of the additive modifications to the actual responses and totals,
respectively.
</p>
<p>Since the resulting function is used in <code><a href="#topic+brglm.fit">brglm.fit</a></code>, for
efficiency reasons no check is made for <code>p &gt;= 0 | p &lt;= 1</code>, for
<code>length(at) == length(p)</code> and for <code>length(ap) == length(p)</code>.
</p>


<h3>Construction of custom pseudo-data representations</h3>

<p> If
<code class="reqn">y^*</code> are the pseudo-responses (pseudo-counts) and
<code class="reqn">m^*</code> are the pseudo-totals then we call the pair <code class="reqn">(y^*,
  m^*)</code> a pseudo-data representation. Both the modified-scores
approach and the maximum penalized likelihood have a common property:
</p>
<p>there exists <code class="reqn">(y^*, m^*)</code> such that if we replace the actual data
<code class="reqn">(y, m)</code> with <code class="reqn">(y^*, m^*)</code> in the expression for the
ordinary scores (first derivatives of the likelihood) of a
binomial-response GLM, then we end-up either with the modified-scores
or with the derivatives of the penalized likelihood (see Kosmidis,
2007, Chapter 5).
</p>
<p>Let <code class="reqn">\mu</code> be the mean of the binomial response <code class="reqn">y</code>
(i.e. <code class="reqn">\mu=mp</code>, where <code class="reqn">p</code> is the binomial probability
corresponding to the count <code class="reqn">y</code>). Also, let <code class="reqn">d</code> and <code class="reqn">d'</code>
denote the first and the second derivatives, respectively, of
<code class="reqn">\mu</code> with respect to the linear predictor <code class="reqn">\eta</code> of the
model. All the above are viewed as functions of <code class="reqn">p</code>. The
pseudo-data representations have the generic form
</p>

<table>
<tr>
 <td style="text-align: left;">
    pseudo-response : </td><td style="text-align: left;"> <code class="reqn">y^*=y + h a_r(p)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    pseudo-totals : </td><td style="text-align: left;"> <code class="reqn">m^*=m + h a_t(p)</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>where <code class="reqn">h</code> is the leverage corresponding to <code class="reqn">y</code>. The general
expressions for <code class="reqn">a_r(p)</code> (&quot;r&quot; for &quot;response&quot;) and <code class="reqn">a_t(p)</code>
(&quot;t&quot; for &quot;totals&quot;) are:
</p>
<p><em>modified-scores approach</em>
</p>

<table>
<tr>
 <td style="text-align: left;">
   <code class="reqn">a_r(p) = d'(p)/(2w(p))</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code class="reqn">a_t(p) = 0</code>, </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p><em>maximum penalized likelihood approach</em>
</p>

<table>
<tr>
 <td style="text-align: left;">
   <code class="reqn">a_r(p) = d'(p)/w(p) + p - 0.5</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code class="reqn">a_t(p) = 0</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>For supplying <code class="reqn">(y^*, m^*)</code> in <code><a href="stats.html#topic+glm.fit">glm.fit</a></code> (as is
done by <code><a href="#topic+brglm.fit">brglm.fit</a></code>), an essential requirement for the
pseudo-data representation is that it should mimic the behaviour of the
original responses and totals, i.e. <code class="reqn">0 \le y^* \le m^*</code>. Since <code class="reqn">h \in [0, 1]</code>, the requirement translates to
<code class="reqn">0 \le a_r(p) \le  a_t(p)</code> for every <code class="reqn">p \in (0, 1)</code>. However,
the above definitions of <code class="reqn">a_r(p)</code> and <code class="reqn">a_t(p)</code> do not
necessarily respect this requirement.
</p>
<p>On the other hand, the pair <code class="reqn">(a_r(p), a_t(p))</code> is not unique in
the sense that for a given link function and once the link-specific
structure of the pair has been extrapolated, there is a class of
equivalent pairs that can be resulted following only the following two
rules:
</p>

<ul>
<li><p> add and subtract the same quantity from either <code class="reqn">a_r(p)</code>
or <code class="reqn">a_t(p)</code>.
</p>
</li>
<li><p> if a quantity is to be moved from <code class="reqn">a_r(p)</code> to <code class="reqn">a_t(p)</code> it
first has to be divided by <code class="reqn">-p</code>.
</p>
</li></ul>

<p>For example, in the case of penalized maximum likelihood, the pairs
<code class="reqn">(d'(p)/w(p) + p - 0.5 , 0)</code> and <code class="reqn">(d'(p)/w(p) + p , 0.5/p)</code> are
equivalent, in the sense that if the corresponding pseudo-data
representations are substituted in the ordinary scores both return the
same expression.
</p>
<p>So, in order to construct a pseudo-data representation that
corresponds to a user-specified link function and has the property
<code class="reqn">0 \le a_r(p) \le  a_t(p)</code> for every <code class="reqn">p \in (0, 1)</code>, one merely
has to pursue a simple algebraic calculation on the initial pair
<code class="reqn">(a_r(p), a_t(p))</code> using only the two aforementioned rules until
an appropriate pair is resulted. There is always a pair!
</p>
<p>Once the pair has been found the following steps should be followed.
</p>

<ol>
<li><p> For a user-specified link function the user has to write a
modification function with name &quot;br.custom.family&quot; or
&quot;pml.custom.family&quot; for <code>pl=FALSE</code> or <code>pl=TRUE</code>,
respectively. The function should take as argument the
probabilities <code>p</code> and return a list  of two vectors with
same length as <code>p</code> and  with names
<code>c("ar", "at")</code>. The result corresponds to the pair
<code class="reqn">(a_r(p), a_t(p))</code>.
</p>
</li>
<li><p> Check if the custom-made modifications function is
appropriate. This can be done via the function
<code><a href="#topic+checkModifications">checkModifications</a></code> which has arguments
<code>fun</code> (the function to be tested) and <code>Length</code> with
default value <code>Length=100</code>. <code>Length</code> is to be used
when the user-specified link function takes as argument a
vector of values (e.g. the <code>logexp</code> link in
<code>?family</code>). Then the value of <code>Length</code> should be the
length of that vector.
</p>
</li>
<li><p> Put the function in the search patch so that
<code>modifications</code> can find it.
</p>
</li>
<li> <p><code><a href="#topic+brglm">brglm</a></code> can now be used with the custom family as
<code><a href="stats.html#topic+glm">glm</a></code> would be used.
</p>
</li></ol>



<h3>Note</h3>

<p>The user could also deviate from modified-scores and maximum penalized
likelihood and experiment with implemented (or not) links, e.g. <code>probit</code>,
constructing his own pseudo-data representations of the aforementioned
general form. This could be done by changing the link name, e.g. by
</p>
<p><code>probitt &lt;-  make.link(probit) ;
    probitt$name &lt;- "probitt"</code>
</p>
<p>and then setting a custom <code>br.custom.family</code> that does
not necessarily depend on the <code>probit</code> link. Then, <code>brglm</code>
could be used with <code>pl=FALSE</code>.
</p>
<p>A further generalization would be to completely remove the hat value
<code class="reqn">h</code> in the generic expression of the pseudo-data representation
and have general additive modifications that depend on <code class="reqn">p</code>. To do
this divide both <code>ar</code> and <code>at</code> by
<code>pmax(get("hats",parent.frame()),.Machine\$double.eps)</code> within the
custom modification function (see also Examples).
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>References</h3>

<p>Kosmidis I. and Firth D. (2021). Jeffreys-prior penalty, finiteness
and shrinkage in binomial-response generalized linear
models. <em>Biometrika</em>, <b>108</b>, 71&ndash;82. 
</p>
<p>Kosmidis, I. (2007). Bias reduction in exponential family nonlinear
models. <em>PhD Thesis</em>, Department of Statistics, University of
Warwick.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+brglm">brglm</a></code>, <code><a href="#topic+brglm.fit">brglm.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Begin Example 1
## logistic exposure model, following the Example in ?family. See,
## Shaffer, T.  2004. Auk 121(2): 526-540.
# Definition of the link function
logexp &lt;- function(days = 1) {
  linkfun &lt;- function(mu) qlogis(mu^(1/days))
  linkinv &lt;- function(eta) plogis(eta)^days
  mu.eta &lt;- function(eta) days * plogis(eta)^(days-1) *
        binomial()$mu.eta(eta)
  valideta &lt;- function(eta) TRUE
  link &lt;- paste("logexp(", days, ")", sep="")
  structure(list(linkfun = linkfun, linkinv = linkinv,
    mu.eta = mu.eta, valideta = valideta, name = link),
    class = "link-glm")
}
# Here d(p) = days * p * ( 1 - p^(1/days) )
#      d'(p) = (days - (days+1) * p^(1/days)) * d(p)
#      w(p) = days^2 * p * (1-p^(1/days))^2 / (1-p)
# Initial modifications, as given from the general expressions above:
br.custom.family &lt;- function(p) {
  etas &lt;- binomial(logexp(.days))$linkfun(p)
  # the link function argument `.days' will be detected by lexical
  # scoping. So, make sure that the link-function inputted arguments
  # have unusual names, like `.days' and that
  # the link function enters `brglm' as
  # `family=binomial(logexp(.days))'.
  list(ar = 0.5*(1-p)-0.5*(1-p)*exp(etas)/.days,
       at = 0*p/p) # so that to fix the length of at
}
.days &lt;-3
# `.days' could be a vector as well but then it should have the same
# length as the number of observations (`length(.days)' should be
# equal to `length(p)'). In this case, `checkModifications' should
# have argument `Length=length(.days)'.
#
# Check:
## Not run: checkModifications(br.custom.family)
# OOOPS error message... the condition is not satisfied
#
# After some trivial algebra using the two allowed operations, we
# get new modifications:
br.custom.family &lt;- function(p) {
  etas &lt;- binomial(logexp(.days))$linkfun(p)
  list(ar=0.5*p/p, # so that to fix the length of ar
       at=0.5+exp(etas)*(1-p)/(2*p*.days))
}
# Check:
checkModifications(br.custom.family)
# It is OK.
# Now,
modifications(binomial(logexp(.days)))
# works.
# Notice that for `.days &lt;- 1', `logexp(.days)' is the `logit' link
# model and `a_r=0.5', `a_t=1'.
# In action:
library(MASS)
example(birthwt)
m.glm &lt;- glm(formula = low ~ ., family = binomial, data = bwt)
.days &lt;- bwt$age
m.glm.logexp &lt;- update(m.glm,family=binomial(logexp(.days)))
m.brglm.logexp &lt;- brglm(formula = low ~ ., family =
binomial(logexp(.days)), data = bwt)
# The fit for the `logexp' link via maximum likelihood
m.glm.logexp
# and the fit for the `logexp' link via modified scores
m.brglm.logexp
## End Example
## Begin Example 2
## Another possible use of brglm.fit:
## Deviating from bias reducing modified-scores:
## Add 1/2 to the response of a probit model.
y &lt;- c(1,2,3,4)
totals &lt;- c(5,5,5,5)
x1 &lt;- c(1,0,1,0)
x2 &lt;- c(1,1,0,0)
my.probit &lt;- make.link("probit")
my.probit$name &lt;- "my.probit"
br.custom.family &lt;- function(p) {
   h &lt;- pmax(get("hats",parent.frame()),.Machine$double.eps)
   list(ar=0.5/h,at=1/h)
}
m1 &lt;- brglm(y/totals~x1+x2,weights=totals,family=binomial(my.probit))
m2 &lt;- glm((y+0.5)/(totals+1)~x1+x2,weights=totals+1,family=binomial(probit))
# m1 and m2 should be the same.
# End example
# Begin example 3: Maximum penalized likelihood for logistic regression, 
# with the penalty being a powerof the Jeffreys prior (`.const` below)
# Setup a custom logit link
mylogit &lt;- make.link("logit")
mylogit$name &lt;- "mylogit"
## Set-up the custom family
br.custom.family &lt;- function(p) {
     list(ar = .const * p/p, at = 2 * .const * p/p)
}
data("lizards")
## The reduced-bias fit is
.const &lt;- 1/2
brglm(cbind(grahami, opalinus) ~ height + diameter +
          light + time, family = binomial(mylogit), data=lizards)
## which is the same as what brglm does by default for logistic regression
brglm(cbind(grahami, opalinus) ~ height + diameter +
          light + time, family = binomial(logit), data=lizards)
## Stronger penalization (e.g. 5/2) can be achieved by 
.const &lt;- 5/2
brglm(cbind(grahami, opalinus) ~ height + diameter +
          light + time, family = binomial(mylogit), data=lizards)
# End example 
</code></pre>

<hr>
<h2 id='plot.profile.brglm'>Plot methods for 'profile.brglm' objects</h2><span id='topic+plot.profile.brglm'></span><span id='topic+pairs.profile.brglm'></span>

<h3>Description</h3>

<p><code>plot.profile.brglm</code> plots the objects of class
<code>"profileModel"</code> that  are contained in an object of class
<code>"profile.brglm"</code>. <code>pairs.profile.brglm</code> is a diagnostic tool
that plots pairwise profile traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile.brglm'
plot(x, signed = FALSE, interpolate = TRUE,
     n.interpolations = 100, print.grid.points = FALSE, ...)

## S3 method for class 'profile.brglm'
pairs(x, colours = 2:3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.profile.brglm_+3A_x">x</code></td>
<td>
<p>a <code>"profile.brglm"</code> object.</p>
</td></tr>
<tr><td><code id="plot.profile.brglm_+3A_signed">signed</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+plot.profileModel">plot.profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="plot.profile.brglm_+3A_interpolate">interpolate</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+plot.profileModel">plot.profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="plot.profile.brglm_+3A_n.interpolations">n.interpolations</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+plot.profileModel">plot.profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="plot.profile.brglm_+3A_print.grid.points">print.grid.points</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+plot.profileModel">plot.profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="plot.profile.brglm_+3A_colours">colours</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+plot.profileModel">plot.profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="plot.profile.brglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Details in <code><a href="profileModel.html#topic+plot.profileModel">plot.profileModel</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="profileModel.html#topic+plot.profileModel">plot.profileModel</a></code>, <code><a href="#topic+profile.brglm">profile.brglm</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in 'confint.brglm'.
</code></pre>

<hr>
<h2 id='profile.brglm'>Calculate profiles for objects of class 'brglm'.</h2><span id='topic+profile.brglm'></span><span id='topic+print.profile.brglm'></span>

<h3>Description</h3>

<p>Creates <code>"profile.brglm"</code> objects to be used for the calculation of
confidence intervals and for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brglm'
profile(fitted, gridsize = 10, stdn = 5,
        stepsize = 0.5, level = 0.95,
        which = 1:length(coef(fitted)), verbose = TRUE,
        zero.bound = 1e-08, scale = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile.brglm_+3A_fitted">fitted</code></td>
<td>
<p>an object of class <code>"brglm"</code>.</p>
</td></tr>
<tr><td><code id="profile.brglm_+3A_gridsize">gridsize</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="profile.brglm_+3A_stdn">stdn</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="profile.brglm_+3A_stepsize">stepsize</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="profile.brglm_+3A_level">level</code></td>
<td>
<p><code>qchisq(level,1)</code> indicates the range that the
profiles must cover.</p>
</td></tr>
<tr><td><code id="profile.brglm_+3A_which">which</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="profile.brglm_+3A_verbose">verbose</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="profile.brglm_+3A_zero.bound">zero.bound</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="profile.brglm_+3A_scale">scale</code></td>
<td>
<p>as in <code><a href="profileModel.html#topic+profileModel">profileModel</a></code>.</p>
</td></tr>
<tr><td><code id="profile.brglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>profile.brglm</code> calculates the profiles of the appropriate
objectives to be used for the construction of confidence intervals for
the bias-reduced estimates (see <code><a href="#topic+confint.brglm">confint.brglm</a></code> for the
objectives that are profiled).
</p>


<h3>Value</h3>

<p>An object of class <code>"profile.glm"</code> with attribute &ldquo;level&rdquo;
corresponding to the argument <code>level</code>. The object supports the
methods <code><a href="base.html#topic+print">print</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+pairs">pairs</a></code>
and <code><a href="stats.html#topic+confint">confint</a></code> and it  is a list of the components:
</p>
<table>
<tr><td><code>profilesML</code></td>
<td>
<p>a <code>"profileModel"</code> object containing
the profiles of the ordinary deviance for the maximum likelihood fit
corresponding to <code>fitted</code>.</p>
</td></tr>
<tr><td><code>profilesBR</code></td>
<td>
<p><code>NULL</code> if <code>method = "glm.fit"</code> in
<code><a href="#topic+brglm">brglm</a></code>. If <code>method = "brglm.fit"</code> and <code>pl =
  TRUE</code>, <code>profilesBR</code> is a <code>"profileModel"</code> object containing
the profiles of the penalized deviance for the parameters of
<code>fitted</code>. If <code>method = "brglm.fit"</code> and <code>pl = FALSE</code>
<code>profilesBR</code> is a <code>"profileModel"</code> object containing the
profiles of the modified score statistic (see
<code><a href="#topic+profileObjectives">profileObjectives</a></code>) for the parameters of <code>fitted</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Objects of class <code>"profile.brglm"</code> support the methods:
</p>

<ul>
<li><p><code>print</code>which prints the <code>"level"</code> attribute of the
object, as well as the supported methods.
</p>
</li>
<li><p><code>confint</code>see <code><a href="#topic+confint.brglm">confint.brglm</a></code>.
</p>
</li>
<li><p><code>plot</code>see <code><a href="#topic+plot.profile.brglm">plot.profile.brglm</a></code>.
</p>
</li>
<li><p><code>pairs</code>see <code><a href="#topic+plot.profile.brglm">plot.profile.brglm</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>See Also</h3>

<p><code><a href="profileModel.html#topic+profileModel">profileModel</a></code>, <code><a href="#topic+profile.brglm">profile.brglm</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example in 'confint.brglm'.
</code></pre>

<hr>
<h2 id='profileObjectives-brglm'>Objectives to be profiled</h2><span id='topic+profileObjectives'></span><span id='topic+penalizedDeviance'></span><span id='topic+modifiedScoreStatistic'></span>

<h3>Description</h3>

<p>Objectives that are used in <code><a href="#topic+profile.brglm">profile.brglm</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalizedDeviance(fm, X, dispersion = 1)

modifiedScoreStatistic(fm, X, dispersion = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profileObjectives-brglm_+3A_fm">fm</code></td>
<td>
<p>the <b>restricted</b> fit.</p>
</td></tr>
<tr><td><code id="profileObjectives-brglm_+3A_x">X</code></td>
<td>
<p>the model matrix of the fit on all parameters.</p>
</td></tr>
<tr><td><code id="profileObjectives-brglm_+3A_dispersion">dispersion</code></td>
<td>
<p>the dispersion parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These objectives follow the specifications for objectives in the
<span class="pkg">profileModel</span> package and are used from <code>profile.brglm</code>.
</p>
<p><code>penalizedDeviance</code> returns a deviance-like value corresponding
to a likelihood function penalized by Jeffreys invariant prior. It
has been used by Heinze &amp; Schemper (2002) and by Bull et. al. (2002)
for the construction of confidence intervals for the bias-reduced
estimates in logistic regression. The <code>X</code> argument is the
model  matrix of the full (<b>not</b> the restricted) fit.
</p>
<p><code>modifiedScoreStatistic</code> mimics <code><a href="profileModel.html#topic+RaoScoreStatistic">RaoScoreStatistic</a></code>
in <span class="pkg">profileModel</span>, but with the ordinary scores replaced with the
modified scores used for bias reduction. The argument <code>X</code> has
the same interpretation as for <code>penalizedDeviance</code>.
</p>


<h3>Value</h3>

<p>A scalar.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>References</h3>

<p>Kosmidis I. and Firth D. (2021). Jeffreys-prior penalty, finiteness
and shrinkage in binomial-response generalized linear
models. <em>Biometrika</em>, <b>108</b>, 71&ndash;82. 
</p>
<p>Bull, S. B., Lewinger, J. B. and Lee, S. S. F. (2007). Confidence
intervals for multinomial logistic regression in sparse data.
<em>Statistics in Medicine</em> <b>26</b>, 903&ndash;918.
</p>
<p>Heinze, G. and Schemper, M. (2002). A solution to the problem of
separation in logistic regression.
<em>Statistics in Medicine</em> <b>21</b>, 2409&ndash;2419.
</p>


<h3>See Also</h3>

<p><code><a href="profileModel.html#topic+profileModel">profileModel</a></code>, <code><a href="#topic+profile.brglm">profile.brglm</a></code>.</p>

<hr>
<h2 id='separation.detection'>Separation Identification.</h2><span id='topic+separation.detection'></span>

<h3>Description</h3>

<p>Provides a tool for identifying whether or not separation has occurred.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separation.detection(fit, nsteps = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separation.detection_+3A_fit">fit</code></td>
<td>
<p>the result of a <code><a href="stats.html#topic+glm">glm</a></code> call.</p>
</td></tr>
<tr><td><code id="separation.detection_+3A_nsteps">nsteps</code></td>
<td>
<p>Starting from <code>maxit = 1</code>, the GLM is refitted for
<code>maxit = 2</code>, <code>maxit = 3</code>, ..., <code>maxit = nsteps</code>. Default
value is 30.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Identifies separated cases for binomial-response GLMs, by refitting
the model. At each iteration the maximum number of allowed IWLS
iterations is fixed starting from 1 to <code>nsteps</code> (by setting
<code>control = glm.control(maxit = j)</code>, where <code>j</code> takes values  1,
..., nsteps in <code><a href="stats.html#topic+glm">glm</a></code>). For each value of <code>maxit</code>,
the estimated asymptotic standard errors are divided to the
corresponding ones resulted for
<code>control = glm.control(maxit = 1)</code>. Based on the results in Lesaffre
&amp; Albert (1989), if the sequence of ratios in any column of the
resulting matrix diverges, then separation occurs and the maximum
likelihood estimate for the corresponding parameter has value minus or
plus infinity.
</p>


<h3>Value</h3>

<p>A matrix of dimension <code>nsteps</code> by <code>length(coef(fit))</code>, that
contains the ratios of the estimated asymptotic standard errors.
</p>


<h3>Author(s)</h3>

<p>Ioannis Kosmidis, <a href="mailto:ioannis.kosmidis@warwick.ac.uk">ioannis.kosmidis@warwick.ac.uk</a></p>


<h3>References</h3>

<p>Kosmidis I. and Firth D. (2021). Jeffreys-prior penalty, finiteness
and shrinkage in binomial-response generalized linear
models. <em>Biometrika</em>, <b>108</b>, 71&ndash;82. 
</p>
<p>Lesaffre, E. and Albert, A. (1989). Partial separation in logistic
discrimination. <em>J. R. Statist. Soc. <b>B</b></em>, <b>51</b>,
109&ndash;116.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Begin Example
y &lt;- c(1,1,0,0)
totals &lt;- c(2,2,2,2)
x1 &lt;- c(1,0,1,0)
x2 &lt;- c(1,1,0,0)
m1 &lt;- glm(y/totals ~ x1 + x2, weights = totals, family = binomial())
# No warning from glm...
m1
# However estimates for (Intercept) and x2 are unusually large in
# absolute value... Investigate further:
#
separation.detection(m1,nsteps=30)
# Note that the values in the column for (Intercept) and x2 diverge,
# while for x1 converged. Hence, separation has occurred and the
# maximum lieklihood estimate for (Intercept) is minus infinity and
# for x2 is plus infinity. The signs for infinity are taken from the
# signs of (Intercept) and x1 in coef(m1).
## End Example
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
