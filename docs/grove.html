<!DOCTYPE html><html lang="en"><head><title>Help for package grove</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grove}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grove'><p>grove: A package for functional denoising and functional ANOVA</p></a></li>
<li><a href='#Denoise'><p>Bayesian wavelet denoising</p></a></li>
<li><a href='#DWT'><p>Discrete wavelet transform</p></a></li>
<li><a href='#FAnova'><p>Bayesian functional ANOVA</p></a></li>
<li><a href='#GenerateSyntheticAnova'><p>Generate synthetic functional ANOVA dataset</p></a></li>
<li><a href='#InvDWT'><p>Inverse discrete wavelet transform</p></a></li>
<li><a href='#PlotFun'><p>Function to plot the denoised signal</p></a></li>
<li><a href='#PlotStates'><p>Function to plot the hidden states</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wavelet Functional ANOVA Through Markov Groves</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Jacopo Soriano and Li Ma</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Li Ma &lt;li.ma@duke.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functional denoising and functional ANOVA through wavelet-domain 
  Markov groves. Fore more details see: Ma L. and Soriano J. (2018) 
  Efficient functional ANOVA through wavelet-domain Markov groves. 
  &lt;<a href="https://doi.org/10.48550/arXiv.1602.03990">doi:10.48550/arXiv.1602.03990</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 0.11.2), wavethresh</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 01:41:20 UTC; lm186</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-10 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='grove'>grove: A package for functional denoising and functional ANOVA</h2><span id='topic+grove'></span><span id='topic+grove-package'></span>

<h3>Description</h3>

<p>The grove package implements a wavelet-domain Bayesian hierarchical model for
functional analysis of variance.
</p>

<hr>
<h2 id='Denoise'>Bayesian wavelet denoising</h2><span id='topic+Denoise'></span>

<h3>Description</h3>

<p>This function carries out Bayesian wavelet denoising using the Normal
Inverse Gamma Markov Tree method of Ma and Soriano (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Denoise(W, alpha = 0.5, nu = 5, n.samples = 500,
  transition.mode = "Markov", method = "Nelder-Mead")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Denoise_+3A_w">W</code></td>
<td>
<p>An object of class <code>DWT</code>.</p>
</td></tr>
<tr><td><code id="Denoise_+3A_alpha">alpha</code></td>
<td>
<p>Hyperparameter controlling the global smoothness.</p>
</td></tr>
<tr><td><code id="Denoise_+3A_nu">nu</code></td>
<td>
<p>Hyperparameter controlling variance heterogeneity. If <code>Inf</code>,
then the variance is identical for all nodes.</p>
</td></tr>
<tr><td><code id="Denoise_+3A_n.samples">n.samples</code></td>
<td>
<p>Number of posterior draws.</p>
</td></tr>
<tr><td><code id="Denoise_+3A_transition.mode">transition.mode</code></td>
<td>
<p>Type of transition.
The two options are <code>Markov</code> or <code>Independent</code>.</p>
</td></tr>
<tr><td><code id="Denoise_+3A_method">method</code></td>
<td>
<p>Method used for find maxmimum of marginal likelihood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>grove</code>.
</p>


<h3>References</h3>

<p>Ma L. and Soriano J. (2016) Efficient functional ANOVA
through wavelet-domain Markov groves. arXiv:1602.03990v2 [stat.ME]
(<a href="https://arxiv.org/abs/1602.03990v2">https://arxiv.org/abs/1602.03990v2</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- wavethresh::DJ.EX(n = 512, noisy = TRUE, rsnr = 5)$doppler
W &lt;- DWT(data)
ans &lt;- Denoise(W)
</code></pre>

<hr>
<h2 id='DWT'>Discrete wavelet transform</h2><span id='topic+DWT'></span>

<h3>Description</h3>

<p>This function performs the discrete wavelet transform (DWT) according to
Mallat's pyramidal algorithm (Mallat, 1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DWT(data, filter.number = 10, family = "DaubLeAsymm")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DWT_+3A_data">data</code></td>
<td>
<p>A matrix of data, where each row is an observation.
The number of columns must be a power of two.</p>
</td></tr>
<tr><td><code id="DWT_+3A_filter.number">filter.number</code></td>
<td>
<p>The smoothness of the wavelet to use in the
decomposition.</p>
</td></tr>
<tr><td><code id="DWT_+3A_family">family</code></td>
<td>
<p>The family of wavelets. The two most common options
are <code>DaubExPhase</code> and <code>DaubLeAsymm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See function <code>wd</code> from package <code>wavethresh</code> for more details.
</p>


<h3>Value</h3>

<p>A <code>DWT</code> object. This object is a list with the following
components:
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- GenerateSyntheticAnova(st.dev = 5, n.replicates = 10)
W &lt;- DWT(data$noisy.Y)
</code></pre>

<hr>
<h2 id='FAnova'>Bayesian functional ANOVA</h2><span id='topic+FAnova'></span>

<h3>Description</h3>

<p>This function carries out Bayesian functional ANOVA using the
Normal Inverse Gamma Markov Grove method of Ma and Soriano (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FAnova(W, X, formula, nu = 5, is.kappa.fixed = FALSE, gamma.kappa = 0.3,
  eta.kappa = 0.1, n.samples = 500, transition.mode = "Markov",
  method = "Nelder-Mead")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FAnova_+3A_w">W</code></td>
<td>
<p>An object of class <code>DWT</code>.</p>
</td></tr>
<tr><td><code id="FAnova_+3A_x">X</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="FAnova_+3A_formula">formula</code></td>
<td>
<p>An object of class formula.</p>
</td></tr>
<tr><td><code id="FAnova_+3A_nu">nu</code></td>
<td>
<p>Hyperparameter controlling the heterogeneity in the noise variance.</p>
</td></tr>
<tr><td><code id="FAnova_+3A_is.kappa.fixed">is.kappa.fixed</code></td>
<td>
<p>If <code>TRUE</code>, gamma.kappa and eta.kappa are fixed.
If <code>FALSE</code> gamma_kappa and eta_kappa are determined using Empirical Bayes.</p>
</td></tr>
<tr><td><code id="FAnova_+3A_gamma.kappa">gamma.kappa</code></td>
<td>
<p>Hyperparameter for the MT transition matrix.</p>
</td></tr>
<tr><td><code id="FAnova_+3A_eta.kappa">eta.kappa</code></td>
<td>
<p>Hyperparameter for the MT transition matrix.</p>
</td></tr>
<tr><td><code id="FAnova_+3A_n.samples">n.samples</code></td>
<td>
<p>Number of posterior draws.</p>
</td></tr>
<tr><td><code id="FAnova_+3A_transition.mode">transition.mode</code></td>
<td>
<p>Type of transition. The two options are <code>Markov</code>
or <code>Independent</code>.</p>
</td></tr>
<tr><td><code id="FAnova_+3A_method">method</code></td>
<td>
<p>Method used for find maxmimum of marginal likelihood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>grove</code>.
</p>


<h3>References</h3>

<p>Ma L. and Soriano J. (2016) Efficient functional ANOVA
through wavelet-domain Markov groves. arXiv:1602.03990v2 [stat.ME]
(<a href="https://arxiv.org/abs/1602.03990v2">https://arxiv.org/abs/1602.03990v2</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- GenerateSyntheticAnova(st.dev = 5, n.replicates = 5)
W &lt;- DWT(data$noisy.Y)
X &lt;- data$X
ans &lt;- FAnova(W, X, ~ 1 + factorA + factorB)
denoised.data &lt;- InvDWT(ans, x = c(0, 0, 1, 0))
PlotFun(denoised.data)
## End(Not run)
</code></pre>

<hr>
<h2 id='GenerateSyntheticAnova'>Generate synthetic functional ANOVA dataset</h2><span id='topic+GenerateSyntheticAnova'></span>

<h3>Description</h3>

<p>This function generates a synthetic 3-factor functional ANOVA dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateSyntheticAnova(st.dev = 10, n.replicates = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateSyntheticAnova_+3A_st.dev">st.dev</code></td>
<td>
<p>The standard deviation of the error.</p>
</td></tr>
<tr><td><code id="GenerateSyntheticAnova_+3A_n.replicates">n.replicates</code></td>
<td>
<p>The number of replicates for each factor combination.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the data without noise, the data with noise, and the
design matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- GenerateSyntheticAnova(st.dev = 5, n.replicates = 10)
ix &lt;- 1
plot(data$clean.Y[ix, ], type = "l", col = "red", ylab = "")
lines(data$noisy.Y[ix, ], col = "blue")
</code></pre>

<hr>
<h2 id='InvDWT'>Inverse discrete wavelet transform</h2><span id='topic+InvDWT'></span>

<h3>Description</h3>

<p>This function performs the inverse discrete wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InvDWT(grove.obj, x = NULL, include.C = TRUE, sample.C = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InvDWT_+3A_grove.obj">grove.obj</code></td>
<td>
<p>An object of class <code>grove</code>.</p>
</td></tr>
<tr><td><code id="InvDWT_+3A_x">x</code></td>
<td>
<p>A vector of the values of a predictor.</p>
</td></tr>
<tr><td><code id="InvDWT_+3A_include.c">include.C</code></td>
<td>
<p>If <code>TRUE</code>, C is used for reconstructing
the function.</p>
</td></tr>
<tr><td><code id="InvDWT_+3A_sample.c">sample.C</code></td>
<td>
<p>If <code>TRUE</code>, draws from C are used for recontructing
the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with each row representing a draw from the reconstructed signal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- wavethresh::DJ.EX(n = 512, noisy = TRUE, rsnr = 5)$doppler
W &lt;- DWT(data)
ans &lt;- Denoise(W)
denoised.data &lt;- InvDWT(ans)
plot(data, type = "l")
lines(denoised.data[1, ], col = "red")
</code></pre>

<hr>
<h2 id='PlotFun'>Function to plot the denoised signal</h2><span id='topic+PlotFun'></span>

<h3>Description</h3>

<p>This function plots the credible bounds of the denoised signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotFun(data, p = c(0.025, 0.5, 0.975), band.type = "pointwise",
  main = "", col = "blue", type = "l", ylab = "", xlab = "",
  ylim = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotFun_+3A_data">data</code></td>
<td>
<p>Matrix of posterior samples.</p>
</td></tr>
<tr><td><code id="PlotFun_+3A_p">p</code></td>
<td>
<p>Vector with the lower, center and upper quantile.</p>
</td></tr>
<tr><td><code id="PlotFun_+3A_band.type">band.type</code></td>
<td>
<p>Type of credible intervals. The options are:
<code>pointwise</code>, <code>gloabl</code> or <code>global</code>.</p>
</td></tr>
<tr><td><code id="PlotFun_+3A_main">main</code></td>
<td>
<p>The main title of the plot.</p>
</td></tr>
<tr><td><code id="PlotFun_+3A_col">col</code></td>
<td>
<p>The color of the point estimate.</p>
</td></tr>
<tr><td><code id="PlotFun_+3A_type">type</code></td>
<td>
<p>The type of line of the point estimate.</p>
</td></tr>
<tr><td><code id="PlotFun_+3A_ylab">ylab</code></td>
<td>
<p>The label of the y-axis.</p>
</td></tr>
<tr><td><code id="PlotFun_+3A_xlab">xlab</code></td>
<td>
<p>The label of the x-axis.</p>
</td></tr>
<tr><td><code id="PlotFun_+3A_ylim">ylim</code></td>
<td>
<p>The range of the y-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- wavethresh::DJ.EX(n = 512, noisy = TRUE, rsnr = 5)$doppler
W &lt;- DWT(data)
ans &lt;- Denoise(W)
denoised.data &lt;- InvDWT(ans)
PlotFun(denoised.data)
PlotFun(denoised.data, band.type = "both")
</code></pre>

<hr>
<h2 id='PlotStates'>Function to plot the hidden states</h2><span id='topic+PlotStates'></span>

<h3>Description</h3>

<p>This function plots on a tree the state of each latent variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotStates(grove.obj, block = "Intercept", legend = FALSE, main = NULL,
  prior = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotStates_+3A_grove.obj">grove.obj</code></td>
<td>
<p>Output from function <code>FAnova</code>.</p>
</td></tr>
<tr><td><code id="PlotStates_+3A_block">block</code></td>
<td>
<p>Which block to plot.</p>
</td></tr>
<tr><td><code id="PlotStates_+3A_legend">legend</code></td>
<td>
<p>If <code>TRUE</code>, show legend.</p>
</td></tr>
<tr><td><code id="PlotStates_+3A_main">main</code></td>
<td>
<p>Main title.</p>
</td></tr>
<tr><td><code id="PlotStates_+3A_prior">prior</code></td>
<td>
<p>If <code>TRUE</code>, plot prior state probabilities. If <code>FALE</code>,
plot posterior state probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- GenerateSyntheticAnova(st.dev = 5, n.replicates = 5)
W &lt;- DWT(data$noisy.Y)
X &lt;- data$X
ans &lt;- FAnova(W, X, ~ 1 + factorA + factorB)
PlotStates(ans)
PlotStates(ans, block = "factorA")
PlotStates(ans, block = "factorB")
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
