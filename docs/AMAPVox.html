<!DOCTYPE html><html><head><title>Help for package AMAPVox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AMAPVox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AMAPVox'><p>AMAPVox package</p></a></li>
<li><a href='#butterfly'><p>Identify butterflies from a VoxelSpace object.</p></a></li>
<li><a href='#canopy'><p>Extract canopy from voxel space.</p></a></li>
<li><a href='#clear'><p>Clear voxel</p></a></li>
<li><a href='#computeG'><p>Foliage projection ratio G(theta).</p></a></li>
<li><a href='#crop'><p>Crop voxel space</p></a></li>
<li><a href='#Extract'><p>Extract or Replace Parts of a VoxelSpace Object</p></a></li>
<li><a href='#fillNA'><p>Fill missing values (NA) with averaged neighboring data</p></a></li>
<li><a href='#getLocalVersions'><p>List local AMAPVox versions.</p></a></li>
<li><a href='#getMaxCorner'><p>Gets the x, y, z coordinates of the voxel space top right corner.</p></a></li>
<li><a href='#getMinCorner'><p>Gets the x, y, z coordinates of the voxel space bottom left corner.</p></a></li>
<li><a href='#getParameter'><p>Gets a parameter from the VoxelSpace header.</p></a></li>
<li><a href='#getPosition'><p>Gets the x, y, z coordinates of a given voxel.</p></a></li>
<li><a href='#getRemoteVersions'><p>List remote AMAPVox versions.</p></a></li>
<li><a href='#getVoxelSize'><p>Gets the elemental size of a voxel (dx, dy, dz) in meter.</p></a></li>
<li><a href='#ground'><p>Extract ground from voxel space.</p></a></li>
<li><a href='#installVersion'><p>Install specific AMAPVox version on local computer.</p></a></li>
<li><a href='#merge.VoxelSpace'><p>Merge two voxel spaces</p></a></li>
<li><a href='#plantAreaDensity'><p>Plant Area Density (PAD)</p></a></li>
<li><a href='#plantAreaIndex'><p>Plant Area Index (PAI)</p></a></li>
<li><a href='#plot'><p>Plot an object of class VoxelSpace</p></a></li>
<li><a href='#plotG'><p>Plot G(theta) profiles for one or several leaf angle distribution functions</p></a></li>
<li><a href='#readVoxelSpace'><p>Read a voxel file</p></a></li>
<li><a href='#removeVersion'><p>Remove specific AMAPVox version from local computer.</p></a></li>
<li><a href='#run'><p>Run AMAPVox</p></a></li>
<li><a href='#tools'><p>Tools inherited from base R for VoxelSpace object.</p></a></li>
<li><a href='#toRaster'><p>Voxel layer to raster</p></a></li>
<li><a href='#VoxelSpace-class'><p>VoxelSpace</p></a></li>
<li><a href='#writeVoxelSpace'><p>Write a voxel file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>LiDAR Data Voxelisation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Read, manipulate and write voxel spaces. Voxel spaces are
    read from text-based output files of the 'AMAPVox' software. 'AMAPVox'
    is a LiDAR point cloud voxelisation software that aims at estimating
    leaf area through several theoretical/numerical approaches. See more
    in the article Vincent et al. (2017) &lt;<a href="https://doi.org/10.23708%2F1AJNMP">doi:10.23708/1AJNMP</a>&gt; and the
    technical note Vincent et al. (2021) &lt;<a href="https://doi.org/10.23708%2F1AJNMP">doi:10.23708/1AJNMP</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL version 2</a> | <a href="https://www.cecill.info/licences/Licence_CeCILL_V2.1-en.txt">CECILL-2.1</a> [expanded from: CeCILL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://amapvox.org">https://amapvox.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://forge.ird.fr/amap/amapvox/AMAPVox/-/issues">https://forge.ird.fr/amap/amapvox/AMAPVox/-/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl, data.table, dplyr, jsonlite, methods, rappdirs, stringr,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fields, ggplot2, graphics, grDevices, knitr, RANN, rgl,
RefManageR, rmarkdown, sf, terra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AMAPVox.R' 'Butterfly.R' 'Canopy.R' 'Classes.R' 'ComputeG.R'
'Crop.R' 'FillNA.R' 'Generics.R' 'Getters.R' 'Ground.R'
'Operators.R' 'PlantArea.R' 'PlotVoxelSpace.R'
'ReadVoxelSpace.R' 'VersionManager.R' 'Run.R' 'Utils-voxel.R'
'WriteVoxelSpace.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-15 15:58:49 UTC; pverley</td>
</tr>
<tr>
<td>Author:</td>
<td>Grégoire Vincent [aut],
  Julien Heurtebize [aut],
  Philippe Verley [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philippe Verley &lt;philippe.verley@ird.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-15 22:30:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='AMAPVox'>AMAPVox package</h2><span id='topic+AMAPVox-package'></span><span id='topic+AMAPVox'></span>

<h3>Description</h3>

<p>The package provides a a set of R functions for working with voxel spaces
(read, write, plot, etc.).
Voxel spaces are read from text-based output files of the
<a href="https://amapvox.org">AMAPVox software</a>.
</p>


<h3>References</h3>

 <ul>
<li><p> Research paper first describing
AMAPVox:<br /> Vincent, G., Antin, C., Laurans, M., Heurtebize, J., Durrieu,
S., Lavalley, C., &amp; Dauzat, J. (2017). Mapping plant area index of tropical
evergreen forest by airborne laser scanning. A cross-validation study using
LAI2200 optical sensor. Remote Sensing of Environment, 198, 254-266.
doi: <a href="https://doi.org/10.1016/j.rse.2017.05.034">10.1016/j.rse.2017.05.034</a>  </p>
</li>
<li><p> Up-to-date description of PAD/LAD
estimators implemented in AMAPVox:<br /> VINCENT, Gregoire; PIMONT, François;
VERLEY, Philippe, 2021, &quot;A note on PAD/LAD estimators implemented in
AMAPVox 1.7&quot;, doi: <a href="https://doi.org/10.23708/1AJNMP">10.23708/1AJNMP</a>, DataSuds, V1  </p>
</li></ul>



<h3>Contact</h3>

<p><a href="mailto:contact@amapvox.org">contact@amapvox.org</a>
</p>


<h3>Author(s)</h3>

<p>Philippe VERLEY <a href="mailto:philippe.verley@ird.fr">philippe.verley@ird.fr</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://amapvox.org">https://amapvox.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://forge.ird.fr/amap/amapvox/AMAPVox/-/issues">https://forge.ird.fr/amap/amapvox/AMAPVox/-/issues</a>
</p>
</li></ul>


<hr>
<h2 id='butterfly'>Identify butterflies from a VoxelSpace object.</h2><span id='topic+butterfly'></span>

<h3>Description</h3>

<p>Identify butterflies from a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.
</p>
<p>A butterfly refers to a non-empty isolated voxel. Non-empty means that there
is one or more hits recorded in the voxel. Isolated means that voxels in the
<a href="https://en.wikipedia.org/wiki/Moore_neighborhood">Moore neighborhood</a>
of rank 1 are empty (no hit).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>butterfly(vxsp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="butterfly_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of voxel index (i, j, k) identified as butterfly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clear">clear()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# identify butterflies
btf &lt;- butterfly(vxsp)
# clear butterflies
clear(vxsp, butterfly(vxsp))
</code></pre>

<hr>
<h2 id='canopy'>Extract canopy from voxel space.</h2><span id='topic+canopy'></span><span id='topic+belowCanopy'></span><span id='topic+aboveCanopy'></span><span id='topic+canopyHeight'></span>

<h3>Description</h3>

<p>Extract canopy from <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.
The canopy layer is the set of highest voxels with number of hits greater
than a user-defined threshold.
</p>


<h4>Minimum number of hits/echos</h4>

<p>Minimum number of hits is set by default to one, meaning that a single echo
in a voxel is enough to consider that there is some vegetation. Increasing
this threshold will tend to lower the canopy level or introduce some gaps (
i-j-cells with no vegetation). This <code>hit.min</code> filter is stronger than
<code><a href="#topic+butterfly">butterfly()</a></code> since is does not discriminate isolated voxels.
A reasonable value for <code>hit.min</code> cannot be suggested ad-hoc since it
strongly depends on sampling intensity. Removing butterflies prior to
extracting canopy is advisable.
</p>



<h4>Gaps</h4>

<p>For a VoxelSpace with fully defined ground level (see <code><a href="#topic+ground">ground()</a></code>),
missing canopy cells can be interpreted as gaps. Conversely if both ground
and canopy are missing for a i-j-cell, then it is inconclusive.
</p>



<h4>Above/below canopy</h4>

<p>Function <code>aboveCanopy</code> returns voxel index above canopy level (excluded).
Function <code>belowCanopy</code> returns voxel index below canopy level (included).
</p>



<h4>Canopy Height Model</h4>

<p>Function <code>canopyHeight</code> returns ground distance at canopy level, including
gaps.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>canopy(vxsp, hit.min = 1)

belowCanopy(vxsp, ...)

aboveCanopy(vxsp, ...)

canopyHeight(vxsp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canopy_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="canopy_+3A_hit.min">hit.min</code></td>
<td>
<p>a positive integer, minimum number of hit/echo in a voxel
to consider it contains vegetation.</p>
</td></tr>
<tr><td><code id="canopy_+3A_...">...</code></td>
<td>
<p>additional parameters which will be passed to <code>canopy</code> function.
So far only <code>hit.min</code> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="data.table.html#topic+data.table-class">data.table::data.table</a></code> object with voxel index either
below canopy, canopy level or above canopy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+butterfly">butterfly()</a></code>, <code><a href="#topic+ground">ground()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
cnp &lt;- canopy(vxsp)
acnp &lt;- aboveCanopy(vxsp)
bcnp &lt;- belowCanopy(vxsp)
# canopy layer included in below canopy subset
all(bcnp[cnp, on=list(i, j, k)] == cnp) # TRUE expected
vxsp@data[cnp, list(i, j, ground_distance), on=list(i, j, k)]

</code></pre>

<hr>
<h2 id='clear'>Clear voxel</h2><span id='topic+clear'></span><span id='topic+clear+2CVoxelSpace+2Cdata.table-method'></span><span id='topic+clear+2CVoxelSpace+2Cvector-method'></span><span id='topic+clear+2CVoxelSpace+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Clear a set of voxels. Clearing means that the state variables
of the selected voxels are altered as if they were <em>clear</em> of any vegetation.
Namely:
</p>

<ul>
<li><p> number of echo set to zero
</p>
</li>
<li><p> intercepted beam surface set to zero (if variable is outputted)
</p>
</li>
<li><p> plant area density set to zero (if variable is outputted)
</p>
</li>
<li><p> transmittance set to one (if variable is outputted)
</p>
</li>
<li><p> any attenuation variable set to zero
</p>
</li></ul>

<p>Other state variables such as sampling intensity, mean angle, entering beam
surface, etc. are unaltered. A cleared voxel is not the same as an unsampled
voxel (not &quot;crossed&quot; by any beam).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear(vxsp, vx)

## S4 method for signature 'VoxelSpace,data.table'
clear(vxsp, vx)

## S4 method for signature 'VoxelSpace,vector'
clear(vxsp, vx)

## S4 method for signature 'VoxelSpace,matrix'
clear(vxsp, vx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clear_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="clear_+3A_vx">vx</code></td>
<td>
<p>(i, j, k) voxel coordinates as a <code><a href="data.table.html#topic+data.table-class">data.table::data.table</a></code>
with i, j, k columns, a vector (i, j, k) or a matrix with i, j, k columns.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# clear 1st voxel
clear(vxsp, c(0, 0, 0)) # clear 1st voxel
# clear butterflies
clear(vxsp, butterfly(vxsp))
# clear voxels with less than two hits
clear(vxsp, vxsp@data[nbEchos &lt; 2])

</code></pre>

<hr>
<h2 id='computeG'>Foliage projection ratio G(theta).</h2><span id='topic+computeG'></span>

<h3>Description</h3>

<p>Compute the mean projection of unit leaf area on the plane
perpendicular to beam direction, namely, G(theta) parameter. Assumption of
symmetric distribution of leaf azimuth angle.
When estimating G for large amount of theta values, it is advised to enable
the lookup table for speeding up the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeG(
  theta,
  pdf = "spherical",
  chi,
  mu,
  nu,
  with.lut = length(theta) &gt; 100,
  lut.precision = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeG_+3A_theta">theta</code></td>
<td>
<p>a numeric vector, theta, the incident beam inclination, in radian,
ranging <code style="white-space: pre;">&#8288;[0, pi/2]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="computeG_+3A_pdf">pdf</code></td>
<td>
<p>the name of the probability density function of the leaf angle
distribution. One of &quot;uniform&quot;, &quot;spherical&quot;, &quot;planophile&quot;, &quot;erectophile&quot;,
&quot;plagiophile&quot;, &quot;extremophile&quot;, &quot;ellipsoidal&quot;, &quot;twoParamBeta&quot;. Refer to
section &quot;Leaf Angle Distribution functions&quot; for details.</p>
</td></tr>
<tr><td><code id="computeG_+3A_chi">chi</code></td>
<td>
<p>a float, parameter of the ellipsoidal leaf angle distribution.
The ratio the ratio horizontal axis over vertical axis. See section &quot;Leaf
Angle Ditribution functions&quot; for details.</p>
</td></tr>
<tr><td><code id="computeG_+3A_mu">mu</code></td>
<td>
<p>a float, parameter controlling the Beta distribution. See section
&quot;Leaf Angle Distribution functions&quot; for details.</p>
</td></tr>
<tr><td><code id="computeG_+3A_nu">nu</code></td>
<td>
<p>a float, parameter controlling the Beta distribution. See section
&quot;Leaf Angle Distribution functions&quot; for details.</p>
</td></tr>
<tr><td><code id="computeG_+3A_with.lut">with.lut</code></td>
<td>
<p>a Boolean, whether to estimate G with a lookup table (LUT).
By default the lookup table is automatically generated when length of theta
vector is greater than 100.</p>
</td></tr>
<tr><td><code id="computeG_+3A_lut.precision">lut.precision</code></td>
<td>
<p>a float, the increment of the theta sequence ranging
from 0 to pi/2 for computing the lookup table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Leaf Angle Distribution functions
</p>

<ul>
<li><p> de Wit’s leaf angle distribution functions:
</p>

<ul>
<li> <p><strong>uniform</strong>, proportion of leaf angle is the same at any angle
</p>
</li>
<li> <p><strong>spherical</strong>, relative frequency of leaf angle is the same as for
surface elements of a sphere
</p>
</li>
<li> <p><strong>planophile</strong>, horizontal leaves most frequent
</p>
</li>
<li> <p><strong>erectophile</strong>, vertical leaves most frequent
</p>
</li>
<li> <p><strong>plagiophile</strong>, oblique leaves most frequent
</p>
</li>
<li> <p><strong>extremophile</strong>, oblique leaves least frequent
</p>
</li></ul>

</li>
<li> <p><strong>ellipsoidal</strong> distribution function, generalization of the spherical
distribution over an ellipsoid. Relative frequency of leaf angle is the same
as for surface elements of an ellipsoid. Takes one parameter <code>chi</code> the ratio
horizontal axis over vertical axis. For <code>chi = 1</code> the distribution becomes
spherical. For <code>chi &lt; 1</code>, the ellipsoid is a prolate spheroid (like a
rugby ball). For <code>chi &gt; 1</code> the ellipsoid is an oblate spheroid (a sphere that
bulges at the equator and is somewhat squashed at the poles).
</p>
</li>
<li> <p><strong>two parameters Beta</strong> distribution. Most generic approach from Goal
and Strebel (1984) to represent large variety of leaf angle distribution. Takes
two parameters <code>mu</code> and <code>nu</code> that control the shape of the Beta
distribution.
</p>
</li></ul>



<h3>References</h3>

<p>Wang, W. M., Li, Z. L., &amp; Su, H. B. (2007).
Comparison of leaf angle distribution functions: effects on extinction
coefficient and fraction of sunlit foliage. Agricultural and Forest
Meteorology, 143(1), 106-122.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotG">plotG()</a></code> for plotting G(theta) profiles
</p>


<h3>Examples</h3>

<pre><code class='language-R'># G(theta) == 0.5 for spherical distribution
all(computeG(theta = runif(10, 0, pi/2)) == 0.5) # returns TRUE
# ellipsoidal distribution
computeG(theta = runif(10, 0, pi/2), pdf = "ellipsoidal", chi = 0.6)
</code></pre>

<hr>
<h2 id='crop'>Crop voxel space</h2><span id='topic+crop'></span>

<h3>Description</h3>

<p>Crop <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object based on voxel i, j,
k, index. If cropping index are missing, the function will automatically crop
the voxel space by discarding outermost unsampled slices of voxels. A <em>slice</em>
designates a layer with constant i (i-slice), j (j-slice) or k (k-slice).
<em>unsampled</em> means that no pulse went through.
</p>
<p>One may want to crop the voxel space on coordinates rather than grid index.
To do so the voxel space must be first converted to an <code><a href="sf.html#topic+sf">sf::sf</a></code>
object and use the <code><a href="sf.html#topic+st_crop">sf::st_crop()</a></code> function.
</p>
<div class="sourceCode"><pre>vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
vxsp@data[, c("x", "y"):=getPosition(vxsp)[, .(x, y)]]
library(sf)
vx.sf &lt;- sf::st_as_sf(vxsp@data, coords=c("x", "y"))
vx.sf &lt;- sf::st_crop(vx.sf, c(xmin = 4, ymin = 1, xmax = 5, ymax = 4))
sf::st_bbox(vx.sf)
vxsp@data &lt;- sf::st_drop_geometry(vx.sf)
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>crop(vxsp, imin = 0, imax = Inf, jmin = 0, jmax = Inf, kmin = 0, kmax = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="crop_+3A_imin">imin</code></td>
<td>
<p>minimum i index of cropped area (inclusive)</p>
</td></tr>
<tr><td><code id="crop_+3A_imax">imax</code></td>
<td>
<p>maximum i index of cropped area (inclusive)</p>
</td></tr>
<tr><td><code id="crop_+3A_jmin">jmin</code></td>
<td>
<p>minimum j index of cropped area (inclusive)</p>
</td></tr>
<tr><td><code id="crop_+3A_jmax">jmax</code></td>
<td>
<p>maximum j index of cropped area (inclusive)</p>
</td></tr>
<tr><td><code id="crop_+3A_kmin">kmin</code></td>
<td>
<p>minimum k index of cropped area (inclusive)</p>
</td></tr>
<tr><td><code id="crop_+3A_kmax">kmax</code></td>
<td>
<p>maximum k index of cropped area (inclusive)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cropped voxel space with updated i, j, k grid coordinates and
updated header (min and max corner).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
plot(crop(vxsp, imin = 1, imax = 5))
# introduce unsampled areas in voxel space
vxsp@data[i &lt; 3, nbSampling:= 0]
# automatic cropping
plot(crop(vxsp))

## End(Not run)

</code></pre>

<hr>
<h2 id='Extract'>Extract or Replace Parts of a VoxelSpace Object</h2><span id='topic+Extract'></span><span id='topic++24+2CVoxelSpace-method'></span><span id='topic++5B+5B+2CVoxelSpace+2CANY+2Cmissing-method'></span><span id='topic++24+3C-+2CVoxelSpace-method'></span><span id='topic++5B+5B+3C-+2CVoxelSpace+2CANY+2Cmissing-method'></span>

<h3>Description</h3>

<p>Operators acting on <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object. If user attempts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'VoxelSpace'
x$name

## S4 method for signature 'VoxelSpace,ANY,missing'
x[[i, j, ...]]

## S4 replacement method for signature 'VoxelSpace'
x$name &lt;- value

## S4 replacement method for signature 'VoxelSpace,ANY,missing'
x[[i, j]] &lt;- value

## S4 replacement method for signature 'VoxelSpace'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object</p>
</td></tr>
<tr><td><code id="Extract_+3A_name">name</code></td>
<td>
<p>A literal character string or a name (possibly backtick quoted).</p>
</td></tr>
<tr><td><code id="Extract_+3A_i">i</code></td>
<td>
<p>string, name of elements to extract.</p>
</td></tr>
<tr><td><code id="Extract_+3A_j">j</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="Extract_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="Extract_+3A_value">value</code></td>
<td>
<p>typically an array-like R object of a similar class as x.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))

# extract columns or header parameters
vxsp$nbSampling
vxsp[["i"]]
vxsp[["mincorner"]]

## Not run: 
# add new column
vxsp[["pad_capped"]] &lt;- ifelse(vxsp$PadBVTotal &gt; 0.5, 0.5, vxsp$PadBVTotal)
# update header parameter
vxsp[["max_pad"]] &lt;- 0.5

## End(Not run)

</code></pre>

<hr>
<h2 id='fillNA'>Fill missing values (NA) with averaged neighboring data</h2><span id='topic+fillNA'></span>

<h3>Description</h3>

<p>Fill missing values of a given variable in a VoxelSpace object
with averaged neighboring values.
</p>
<p>Neighboring values are selected among voxels within a user-defined radius
in meter and whose sampling rate (number of pulses that went through the
voxel) is above a user-defined threshold. Distance between voxels is the
euclidian distance between voxel centers. Fill-value may be capped by
user-defined minimal and maximal values.
</p>
<p>Default radius (if not defined by user) is set to largest dimension of voxel
size <code>max(getVoxelSize(vxsp))</code>. It guarantees that default neighborhood is
isotropic.
</p>
<p>In some cases, for instance poorly sampled area, neighboring values may all
be missing or discarded. A fallback value can be provided to &quot;force fill&quot;
suche voxels. An other option is to run again the function with larger
radius or lower sampling threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillNA(
  vxsp,
  variable.name,
  variable.min = -Inf,
  variable.max = Inf,
  variable.fallback,
  radius,
  pulse.min = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillNA_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="fillNA_+3A_variable.name">variable.name</code></td>
<td>
<p>a character, the name of a variable in the VoxelSpace</p>
</td></tr>
<tr><td><code id="fillNA_+3A_variable.min">variable.min</code></td>
<td>
<p>a numeric, minimal value for the fill values</p>
</td></tr>
<tr><td><code id="fillNA_+3A_variable.max">variable.max</code></td>
<td>
<p>a numeric, maximal value for the fill values</p>
</td></tr>
<tr><td><code id="fillNA_+3A_variable.fallback">variable.fallback</code></td>
<td>
<p>a numeric, optional fallback value in case no fill
value can be estimated from neighboring voxels.</p>
</td></tr>
<tr><td><code id="fillNA_+3A_radius">radius</code></td>
<td>
<p>a numeric, the radius in meter that defines the neighborhood of
a voxel. The function looks for the voxels whose center is inside a sphere
of radius <code>radius</code> centered at current voxel center. Default is set to
<code>max(getVoxelSize(vxsp))</code></p>
</td></tr>
<tr><td><code id="fillNA_+3A_pulse.min">pulse.min</code></td>
<td>
<p>a numeric, minimal sampling intensity (i.e. number of pulses
that went through a voxel) to include neighboring voxel in the estimation of
the averaged fill value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># read voxel space
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# Randomly add some NA in PAD variable
vx &lt;- vxsp@data
ind &lt;- sample(vx[PadBVTotal &gt; 0, which = TRUE], 3)
# print initial values
vx[ind, .(i, j, k, PadBVTotal)]
vx[ind, PadBVTotal := NA]
# fill NA in PAD variable
fillNA(vxsp, "PadBVTotal", variable.max = 5)
# print filled values
vx[ind, .(i, j, k, PadBVTotal)]

</code></pre>

<hr>
<h2 id='getLocalVersions'>List local AMAPVox versions.</h2><span id='topic+getLocalVersions'></span>

<h3>Description</h3>

<p>List AMAPVox versions already installed on your computer by
the package. AMAPVox versions are installed in the user-specific data
directory, as specified by <code><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLocalVersions()
</code></pre>


<h3>Value</h3>

<p>a <code>data.frame</code> with 2 variables: <code style="white-space: pre;">&#8288;$version&#8288;</code> that stores
the version number and <code style="white-space: pre;">&#8288;$path&#8288;</code> the local path of the AMAPVox
directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getRemoteVersions">getRemoteVersions()</a></code>, <code><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir()</a></code>
</p>

<hr>
<h2 id='getMaxCorner'>Gets the x, y, z coordinates of the voxel space top right corner.</h2><span id='topic+getMaxCorner'></span><span id='topic+getMaxCorner+2CVoxelSpace-method'></span>

<h3>Description</h3>

<p>Gets the x, y, z coordinates of the voxel space top right
corner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMaxCorner(vxsp)

## S4 method for signature 'VoxelSpace'
getMaxCorner(vxsp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMaxCorner_+3A_vxsp">vxsp</code></td>
<td>
<p>the <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x, y, z coordinates of the voxel space top right corner, as a
numerical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# retrieve 'max_corner' parameter
getMaxCorner(vxsp)
</code></pre>

<hr>
<h2 id='getMinCorner'>Gets the x, y, z coordinates of the voxel space bottom left corner.</h2><span id='topic+getMinCorner'></span><span id='topic+getMinCorner+2CVoxelSpace-method'></span>

<h3>Description</h3>

<p>Gets the x, y, z coordinates of the voxel space bottom left
corner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMinCorner(vxsp)

## S4 method for signature 'VoxelSpace'
getMinCorner(vxsp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMinCorner_+3A_vxsp">vxsp</code></td>
<td>
<p>the <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x, y, z coordinates of the voxel space bottom left corner, as a
numerical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# retrieve 'min_corner' parameter
getMinCorner(vxsp)
</code></pre>

<hr>
<h2 id='getParameter'>Gets a parameter from the VoxelSpace header.</h2><span id='topic+getParameter'></span><span id='topic+getParameter+2CVoxelSpace+2Ccharacter-method'></span><span id='topic+getParameter+2CVoxelSpace+2Cmissing-method'></span>

<h3>Description</h3>

<p>Gets a parameter from the VoxelSpace header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParameter(vxsp, what)

## S4 method for signature 'VoxelSpace,character'
getParameter(vxsp, what)

## S4 method for signature 'VoxelSpace,missing'
getParameter(vxsp, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParameter_+3A_vxsp">vxsp</code></td>
<td>
<p>the <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object</p>
</td></tr>
<tr><td><code id="getParameter_+3A_what">what</code></td>
<td>
<p>the name of the parameter. If missing returns all parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the parameter as a <code>character</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# show parameters name
names(getParameter(vxsp))
# retrieve 'mincorner' parameter
getParameter(vxsp, "mincorner")
# all parameters
getParameter(vxsp)
</code></pre>

<hr>
<h2 id='getPosition'>Gets the x, y, z coordinates of a given voxel.</h2><span id='topic+getPosition'></span><span id='topic+getPosition+2CVoxelSpace+2Cvector-method'></span><span id='topic+getPosition+2CVoxelSpace+2Cmatrix-method'></span><span id='topic+getPosition+2CVoxelSpace+2Cdata.table-method'></span><span id='topic+getPosition+2CVoxelSpace+2Cmissing-method'></span>

<h3>Description</h3>

<p>Gets the x, y, z coordinates of the voxel center. If the voxel
parameter is missing, it returns the positions of all the voxels in the
voxel space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPosition(vxsp, vx)

## S4 method for signature 'VoxelSpace,vector'
getPosition(vxsp, vx)

## S4 method for signature 'VoxelSpace,matrix'
getPosition(vxsp, vx)

## S4 method for signature 'VoxelSpace,data.table'
getPosition(vxsp, vx)

## S4 method for signature 'VoxelSpace,missing'
getPosition(vxsp, vx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPosition_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="getPosition_+3A_vx">vx</code></td>
<td>
<p>(i, j, k) voxel coordinates as a <code><a href="data.table.html#topic+data.table-class">data.table::data.table</a></code>
with i, j, k columns, a vector (i, j, k) or a matrix with i, j, k columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the x, y, z coordinates of the voxel center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))

# get position of voxel(i=0, j=0, k=0)
getPosition(vxsp, c(0, 0, 0))

# get position of voxels 1 to 10 in the data.table
getPosition(vxsp, vxsp@data[1:10,])

# get positions of every voxel
getPosition(vxsp)
</code></pre>

<hr>
<h2 id='getRemoteVersions'>List remote AMAPVox versions.</h2><span id='topic+getRemoteVersions'></span>

<h3>Description</h3>

<p>List AMAPVox versions available for download from AMAPVox Gitlab
package registry <a href="https://forge.ird.fr/amap/amapvox/-/packages">https://forge.ird.fr/amap/amapvox/-/packages</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRemoteVersions()
</code></pre>


<h3>Value</h3>

<p>a <code>data.frame</code> with 2 variables: <code style="white-space: pre;">&#8288;$version&#8288;</code> that stores
the version number and <code style="white-space: pre;">&#8288;$url&#8288;</code> the URL of the associated ZIP file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLocalVersions">getLocalVersions()</a></code>
</p>

<hr>
<h2 id='getVoxelSize'>Gets the elemental size of a voxel (dx, dy, dz) in meter.</h2><span id='topic+getVoxelSize'></span><span id='topic+getVoxelSize+2CVoxelSpace-method'></span>

<h3>Description</h3>

<p>Gets the elemental size of a voxel (dx, dy, dz) in meter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVoxelSize(vxsp)

## S4 method for signature 'VoxelSpace'
getVoxelSize(vxsp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVoxelSize_+3A_vxsp">vxsp</code></td>
<td>
<p>the <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the size of the voxel in meter, as a numerical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# retrieve voxel size
getVoxelSize(vxsp)
</code></pre>

<hr>
<h2 id='ground'>Extract ground from voxel space.</h2><span id='topic+ground'></span><span id='topic+belowGround'></span><span id='topic+aboveGround'></span><span id='topic+groundEnergy'></span><span id='topic+groundElevation'></span>

<h3>Description</h3>

<p>Extract ground layer from <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.
</p>


<h4>Ground layer</h4>

<p>The ground layer is the set of voxels that are just above ground level. The
bottom facet of the voxel must be above ground
<code>ground_distance(voxel_center) &gt;= dz/2</code> with dz the voxel size on z axis.
Ground layer may be missing (the function returns an empty data.table) or
incomplete (the function returns a data.table with
<code>nrow(ground(vxsp)) &lt; prod(dim(vxsp)[1:2])</code>) for some voxel space.
</p>



<h4>Above/below ground</h4>

<p>Function <code>aboveGround</code> returns voxel index above ground layer (included).
Function <code>belowGround</code> returns voxel index below ground layer (excluded).
</p>



<h4>Ground energy</h4>

<p>Function <code>groundEnergy</code> estimates fraction of light reaching the ground. It
is computed as the ratio of entering beam section on potential beam section
(beams that would have crossed a voxel if there were no vegetation in the
scene). It requires variables <em>bsEntering</em> and <em>bsPotential</em>.
</p>



<h4>Ground elevation</h4>

<p>Function <code>groundElevation</code> returns the elevation of the ground layer. It is
provided as a check function, to make sure that AMAPVox
<em>digital elevation model</em> is consistent with the one provided in input.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>ground(vxsp)

belowGround(vxsp)

aboveGround(vxsp)

groundEnergy(vxsp)

groundElevation(vxsp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ground_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="data.table.html#topic+data.table-class">data.table::data.table</a></code> object with voxel index either
below ground, ground level or above ground.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
gr &lt;- ground(vxsp)
ag &lt;- aboveGround(vxsp)
bg &lt;- belowGround(vxsp) # empty in test case
# ground layer included in above ground subset
all(ag[gr, on=list(i, j, k)] == gr) # TRUE expected
vxsp@data[ag, on=list(i, j, k)]

</code></pre>

<hr>
<h2 id='installVersion'>Install specific AMAPVox version on local computer.</h2><span id='topic+installVersion'></span>

<h3>Description</h3>

<p>Install specific AMAPVox version on your computer.
AMAPVox versions are installed in the user-specific data
directory, as specified by <code><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir()</a></code>.
You should not worry to call directly this function since
local installations are automatically handled by the version manager
when you launch AMAPVox GUI with <code><a href="#topic+gui">gui()</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installVersion(version, overwrite = FALSE, timeout = 300)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="installVersion_+3A_version">version</code></td>
<td>
<p>a valid and existing AMAPVox remote version number
(major.minor.build)</p>
</td></tr>
<tr><td><code id="installVersion_+3A_overwrite">overwrite</code></td>
<td>
<p>whether existing local installation should be re-installed.</p>
</td></tr>
<tr><td><code id="installVersion_+3A_timeout">timeout</code></td>
<td>
<p>maximum time in seconds before interrupting download.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the path of the AMAPVox installation directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getLocalVersions">getLocalVersions()</a></code>, <code><a href="#topic+getRemoteVersions">getRemoteVersions()</a></code>, <code><a href="#topic+removeVersion">removeVersion()</a></code>
</p>
<p><code><a href="rappdirs.html#topic+user_data_dir">rappdirs::user_data_dir()</a></code>
</p>
<p><code><a href="utils.html#topic+download.file">utils::download.file()</a></code>, <code><a href="utils.html#topic+unzip">utils::unzip()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# install latest version
installVersion(tail(getRemoteVersions()$version, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='merge.VoxelSpace'>Merge two voxel spaces</h2><span id='topic+merge.VoxelSpace'></span>

<h3>Description</h3>

<p>Merge of two <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.
Voxel spaces must have same sptial extension and resolution, and some
shared column names.
</p>


<h4>Merging modes</h4>

<p>Variables <code style="white-space: pre;">&#8288;i, j, k &amp; ground_distance&#8288;</code> are merged.
</p>
<p>Variables <code style="white-space: pre;">&#8288;nbEchos, nbSampling, lgTotal, bsEntering, bsIntercepted, bsPotential, weightedEffectiveFreepathLength &amp; weightedFreepathLength&#8288;</code>
are summed-up.
</p>
<p>Variables <code style="white-space: pre;">&#8288;sdLength, angleMean and distLaser&#8288;</code> are weighted means with
<code>nbSampling</code> (the number of pulses) as weights.
</p>
<p>Attenuation FPL variables (<code style="white-space: pre;">&#8288;attenuation_FPL_biasedMLE, attenuation_FPL_biasCorrection, attenuation_FPL_unbiasedMLE) &amp; lMeanTotal&#8288;</code>
are calculated analytically.
</p>
<p>Transmittance and attenuation variables (except the FPL attenuation
variables listed above) are weighted means with bsEntering as weights.
</p>
<p>Any other variables will not be merged. In particular PAD variables
are not merged and should be recalculated with
<code><a href="#topic+plantAreaDensity">plantAreaDensity()</a></code> on the merged voxel space.
</p>
<div class="sourceCode"><pre>vxsp &lt;- plantAreaDensity(merge(vxsp1, vxsp2))
</pre></div>



<h4>Merging multiple voxel spaces</h4>

<p>Merging several voxel spaces works as follow : vxsp1 and vxsp2 merged
into vxsp12. vxsp12 &amp; vxsp3 merged into vxsp123, etc. The process can be
synthesized with the <code><a href="base.html#topic+Reduce">Reduce()</a></code> function.
</p>
<div class="sourceCode"><pre>vxsp &lt;- Reduce(merge, list(vxsp1, vxsp2, vxsp3))
</pre></div>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VoxelSpace'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.VoxelSpace_+3A_x">x</code>, <code id="merge.VoxelSpace_+3A_y">y</code></td>
<td>
<p><code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> objects to be merged.</p>
</td></tr>
<tr><td><code id="merge.VoxelSpace_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A merged <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># merge same voxel space to confirm merging behavior
vxsp1 &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
vxsp2 &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
vxsp &lt;- merge(vxsp1, vxsp2)
all(vxsp$nbSampling == vxsp1$nbSampling + vxsp2$nbSampling)

# with PAD
vxsp &lt;- plantAreaDensity(merge(vxsp1, vxsp2), pulse.min = 1)
all((vxsp$pad_transmittance - vxsp1$PadBVTotal) &lt; 1e-7) # equal at float precision

</code></pre>

<hr>
<h2 id='plantAreaDensity'>Plant Area Density (PAD)</h2><span id='topic+plantAreaDensity'></span>

<h3>Description</h3>

<p>Computes Plant Area Density either from transmittance or
attenuation coefficient estimates.
Details of calculation and underlying assumptions can be found online at
doi: <a href="https://doi.org/10.23708/1AJNMP">10.23708/1AJNMP</a>.
PAD is defind as the plant area per unit volume
( PAD plant area / voxel volume = m^2 / m^3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plantAreaDensity(
  vxsp,
  vx,
  lad = "spherical",
  angle.name = "angleMean",
  variable.name = c("transmittance", "attenuation_FPL_unbiasedMLE",
    "attenuation_PPL_MLE"),
  pad.max = 5,
  pulse.min = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plantAreaDensity_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="plantAreaDensity_+3A_vx">vx</code></td>
<td>
<p>a subset of voxel index. A data.table with <code style="white-space: pre;">&#8288;i, j, k&#8288;</code> columns.
Missing parameter means whole voxel space.</p>
</td></tr>
<tr><td><code id="plantAreaDensity_+3A_lad">lad</code></td>
<td>
<p>the name of the probability density function of the leaf angle
distribution. One of <code>AMAPVox:::leafAngleDistribution</code>.</p>
</td></tr>
<tr><td><code id="plantAreaDensity_+3A_angle.name">angle.name</code></td>
<td>
<p>the name of the mean angle variable in the VoxelSpace
object.</p>
</td></tr>
<tr><td><code id="plantAreaDensity_+3A_variable.name">variable.name</code></td>
<td>
<p>the name of the transmittance/attenuation variables in
the VoxelSpace object. Transmittance variables are expected to start with
&quot;tra&quot; and attenuation variables with &quot;att&quot;.</p>
</td></tr>
<tr><td><code id="plantAreaDensity_+3A_pad.max">pad.max</code></td>
<td>
<p>a float, the maximal PAD value</p>
</td></tr>
<tr><td><code id="plantAreaDensity_+3A_pulse.min">pulse.min</code></td>
<td>
<p>an integer, the minimal number of pulses in a voxel for
computing the PAD. PAD set to NA otherwise.</p>
</td></tr>
<tr><td><code id="plantAreaDensity_+3A_...">...</code></td>
<td>
<p>additional parameters which will be passed to the leaf angle
distribution functions. Details in <code><a href="#topic+computeG">computeG()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A voxel space object with the requested PAD variables.
</p>


<h3>References</h3>

<p>VINCENT, Gregoire; PIMONT, François; VERLEY, Philippe, 2021,
&quot;A note on PAD/LAD estimators implemented in AMAPVox 1.7&quot;,
doi: <a href="https://doi.org/10.23708/1AJNMP">10.23708/1AJNMP</a>, DataSuds, V1
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeG">computeG()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# compute PAD
pad &lt;- plantAreaDensity(vxsp, variable.name = "attenuation_PPL_MLE")
# merge pad variables into voxel space
vxsp@data &lt;- merge(vxsp@data, pad, by = c("i", "j", "k"))
grep("^pad", names(vxsp), value = TRUE) # print PAD variables in vxsp
# PAD on a subset
pad.i2j3 &lt;- plantAreaDensity(vxsp, vxsp@data[i ==2 &amp; j==3, .(i, j, k)])
pad.i2j3[["ground_distance"]] &lt;- vxsp@data[i ==2 &amp; j==3]$ground_distance
## Not run: 
# plot vertical profile
library(ggplot2)
# meld data.table (wide-to-long reshaping)
pad &lt;- data.table::melt(pad.i2j3,
  id.vars = "ground_distance",
  measure.vars = c("pad_transmittance", "pad_attenuation_FPL_unbiasedMLE",
    "pad_attenuation_PPL_MLE"))
ggplot(data = pad, aes(x=value, y=ground_distance, color=variable)) +
  geom_path() + geom_point()

## End(Not run)
</code></pre>

<hr>
<h2 id='plantAreaIndex'>Plant Area Index (PAI)</h2><span id='topic+plantAreaIndex'></span>

<h3>Description</h3>

<p>Computes Plant Area Index (PAI) from Plant Area Density (PAD).
PAI is defined as the plant area per unit ground surface area (PAI = plant
area / ground area = m^2 / m^2).
</p>
<p>The function can estimate PAI on the whole voxel space or any region of
interest (parameter vx subset of voxels). It can compute PAI from several
perspectives : either an averaged PAI value, a two-dimensions (i, j) PAI
array or vertical profiles either above ground or below canopy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plantAreaIndex(
  vxsp,
  vx,
  type = c("av", "ag", "bc", "xy"),
  pattern.pad = "^pad_*"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plantAreaIndex_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="plantAreaIndex_+3A_vx">vx</code></td>
<td>
<p>a subset of voxel index. A data.table with <code style="white-space: pre;">&#8288;i, j, k&#8288;</code> columns.
Missing parameter means whole voxel space.</p>
</td></tr>
<tr><td><code id="plantAreaIndex_+3A_type">type</code></td>
<td>
<p>a character vector, the type of PAI profile.
</p>

<ul>
<li> <p><code>"av"</code> Averaged value on every voxel
</p>
</li>
<li> <p><code>"ag"</code> Above ground vertical profile
</p>
</li>
<li> <p><code>"bc"</code> Below canopy vertical profile
</p>
</li>
<li> <p><code>"xy"</code> Spatial profile
</p>
</li></ul>
</td></tr>
<tr><td><code id="plantAreaIndex_+3A_pattern.pad">pattern.pad</code></td>
<td>
<p>character string containing a
<a href="base.html#topic+regex">regular expression</a> to be matched in the voxel space
variable names, for selecting PAD variables. Typing the name of a specific
PAD variable works just fine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of PAI profiles for requested PAD variables and PAI
types.
</p>


<h4><code>av</code> Averaged PAI</h4>

<p>Returns a single value. Calculated as the sum of PAD values multiplied by
voxel volume and divided by ground surface with vegetation.
</p>



<h4><code>ag &amp; bc</code> Above ground and below canopy PAI vertical profile</h4>

<p>Returns a vertical profile of PAI values either from ground distance or
canopy depth. Calculated as the averaged PAD values per layer (a layer
being defined by either the distance to ground or canopy level) multiplied
by voxel size along z (equivalent to multiplying PAD by voxel volume and
dividing by voxel ground surface).
</p>



<h4><code>xy</code> Spatial PAI profile</h4>

<p>Returns a list a PAI values by i, j index. Calculated as the sum of PAD on
(i, j) column multiplied by voxel size along z (equivalent to multiplying
PAD by voxel volume and dividing by voxel ground surface).
</p>



<h3>See Also</h3>

<p><code><a href="#topic+plantAreaDensity">plantAreaDensity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
vxsp@data &lt;- merge(vxsp@data, plantAreaDensity(vxsp), by = c("i", "j", "k"))
## Not run: 
lai &lt;- plantAreaIndex(vxsp)
names(lai)
library(ggplot2)
ggplot(data = lai[["pad_transmittance.pai.ag" ]], aes(x=pai, y=ground_distance)) +
  geom_path() + geom_point()

## End(Not run)
# PAI on a subset
ni &lt;- round(dim(vxsp)[1]/2)
vx &lt;- vxsp@data[i &lt; ni, .(i, j, k)]
lai &lt;- plantAreaIndex(vxsp, vx)

</code></pre>

<hr>
<h2 id='plot'>Plot an object of class VoxelSpace</h2><span id='topic+plot'></span><span id='topic+plot+2CVoxelSpace+2Cmissing-method'></span><span id='topic+plot+2CVoxelSpace+2Cdata.table-method'></span>

<h3>Description</h3>

<p>plot a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(x, y, ...)

## S4 method for signature 'VoxelSpace,missing'
plot(
  x,
  y,
  variable.name = "nbSampling",
  palette = "viridis",
  bg.color = "lightgrey",
  width = 640,
  voxel.size = 5,
  unsampled.discard = TRUE,
  empty.discard = TRUE,
  ...
)

## S4 method for signature 'VoxelSpace,data.table'
plot(
  x,
  y,
  variable.name = "nbSampling",
  palette = "viridis",
  bg.color = "lightgrey",
  width = 640,
  voxel.size = 5,
  unsampled.discard = TRUE,
  empty.discard = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>the object of class VoxelSpace to plot</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>a subset of voxel index. A data.table with <code style="white-space: pre;">&#8288;i, j, k&#8288;</code> columns.
Missing parameter means whole voxel space.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>additional parameters which will be passed to <code><a href="rgl.html#topic+plot3d">rgl::plot3d()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_variable.name">variable.name</code></td>
<td>
<p>character, the name of the variable to plot</p>
</td></tr>
<tr><td><code id="plot_+3A_palette">palette</code></td>
<td>
<p>character, a valid palette name (one of hcl.pals())</p>
</td></tr>
<tr><td><code id="plot_+3A_bg.color">bg.color</code></td>
<td>
<p>character, a valid background color name (one of colors())</p>
</td></tr>
<tr><td><code id="plot_+3A_width">width</code></td>
<td>
<p>numeric, the width of the windows</p>
</td></tr>
<tr><td><code id="plot_+3A_voxel.size">voxel.size</code></td>
<td>
<p>numeric, the size of voxel in pixels</p>
</td></tr>
<tr><td><code id="plot_+3A_unsampled.discard">unsampled.discard</code></td>
<td>
<p>logical, whether to discard unsampled voxel</p>
</td></tr>
<tr><td><code id="plot_+3A_empty.discard">empty.discard</code></td>
<td>
<p>logical, whether to discard empty voxel (no hit)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot an object of class VoxelSpace in a 3d device. By default it plots the
sampling intensity but the user can choose any variable available in the
voxel file.
</p>


<h3>See Also</h3>

<p><code><a href="rgl.html#topic+plot3d">rgl::plot3d()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# plot sampling intensity by default
plot(vxsp)
# plot PAD
plot(vxsp, variable.name = "PadBVTotal", palette = "YlOrRd")
# plot a subset
plot(vxsp, vxsp@data[k &gt; 4, .(i, j, k)])

## End(Not run)
</code></pre>

<hr>
<h2 id='plotG'>Plot G(theta) profiles for one or several leaf angle distribution functions</h2><span id='topic+plotG'></span>

<h3>Description</h3>

<p>Plot G(theta) profiles for one or several leaf angle distribution
functions with <code style="white-space: pre;">&#8288;theta in [0, pi/2]&#8288;</code>. Requires ggplot2 package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotG(pdf = leafAngleDistribution, chi = 0.6, mu = 1.1, nu = 1.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotG_+3A_pdf">pdf</code></td>
<td>
<p>the name of the leaf angle distribution functions. One of
&quot;uniform&quot;, &quot;spherical&quot;, &quot;planophile&quot;, &quot;erectophile&quot;, &quot;plagiophile&quot;,
&quot;extremophile&quot;, &quot;ellipsoidal&quot;, &quot;twoParamBeta&quot;.</p>
</td></tr>
<tr><td><code id="plotG_+3A_chi">chi</code></td>
<td>
<p>a float, parameter of the ellipsoidal leaf angle distribution.
The ratio the ratio horizontal axis over vertical axis. See section &quot;Leaf
Angle Ditribution functions&quot; for details.</p>
</td></tr>
<tr><td><code id="plotG_+3A_mu">mu</code></td>
<td>
<p>a float, parameter controlling the Beta distribution. See section
&quot;Leaf Angle Distribution functions&quot; for details.</p>
</td></tr>
<tr><td><code id="plotG_+3A_nu">nu</code></td>
<td>
<p>a float, parameter controlling the Beta distribution. See section
&quot;Leaf Angle Distribution functions&quot; for details.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# plot G(theta) for planophile leaf angle distribution function
AMAPVox::plotG(pdf = "planophile")
# plot G(theta) for every distributions
AMAPVox::plotG()

## End(Not run)
</code></pre>

<hr>
<h2 id='readVoxelSpace'>Read a voxel file</h2><span id='topic+readVoxelSpace'></span>

<h3>Description</h3>

<p>read a voxel file and cast it into a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code>
object.
</p>
<p>Zipped voxel file is accepted. AMAPVox uses user cache directory to unzip
the file (<code><a href="rappdirs.html#topic+user_cache_dir">rappdirs::user_cache_dir()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readVoxelSpace(f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readVoxelSpace_+3A_f">f</code></td>
<td>
<p>The path of the voxel file.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+writeVoxelSpace">writeVoxelSpace()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
</code></pre>

<hr>
<h2 id='removeVersion'>Remove specific AMAPVox version from local computer.</h2><span id='topic+removeVersion'></span>

<h3>Description</h3>

<p>Uninstall specific AMAPVox version from your computer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeVersion(version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeVersion_+3A_version">version</code></td>
<td>
<p>a valid and existing AMAPVox local version number
(major.minor.build)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getLocalVersions">getLocalVersions()</a></code>, <code><a href="#topic+installVersion">installVersion()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# uninstall oldest version from your computer
removeVersion(head(getLocalVersions()$version, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='run'>Run AMAPVox</h2><span id='topic+run'></span><span id='topic+gui'></span>

<h3>Description</h3>

<p>Run AMAPVox either in batch mode or with Graphical User
Interface (GUI). The function embeds a version manager for installing
locally any version available remotely.
</p>
<p>AMAPVox versions equal or prior to 1.10 require Java 8 on your Operating
System. Refer to section <em>Java 8 64-Bit</em> for details.
</p>
<p><code>gui</code> function has been kept for background compatibility. It is an alias
of the <code>run</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run(
  version = "latest",
  xml,
  java = "java",
  jvm.options = "-Xms2048m",
  nt = 1,
  ntt = 1,
  stdout = ""
)

gui(version = "latest", java = "java", jvm.options = "-Xms2048m", stdout = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_+3A_version">version</code></td>
<td>
<p>either &quot;latest&quot; or a valid version number major.minor(.build)
if <code>version="latest"</code> the function looks for latest remote version. If
there is no internet connection it runs latest local version.</p>
</td></tr>
<tr><td><code id="run_+3A_xml">xml</code></td>
<td>
<p>path(s) to AMAPVox XML configuration files. If missing or <code>NULL</code>
AMAPVox launches the GUI.</p>
</td></tr>
<tr><td><code id="run_+3A_java">java</code></td>
<td>
<p>path to the java executable. Ignored for AMAPVox version &gt;= 2.0
since Java is embedded within AMAPVox binary. Default 'java' value assumes
that java is correctly defined on the $PATH variable.</p>
</td></tr>
<tr><td><code id="run_+3A_jvm.options">jvm.options</code></td>
<td>
<p>JVM (Java Virtual Machine) options. By default it
allocates 2Go of heap memory to AMAPVox.</p>
</td></tr>
<tr><td><code id="run_+3A_nt">nt</code></td>
<td>
<p>maximum number of threads for running tasks. <code>nt=1</code> means
sequential execution. <code>nt=0</code> means as many threads as available.</p>
</td></tr>
<tr><td><code id="run_+3A_ntt">ntt</code></td>
<td>
<p>maximum number of threads per task. <code>ntt=0</code> means as many threads
as available.</p>
</td></tr>
<tr><td><code id="run_+3A_stdout">stdout</code></td>
<td>
<p>where output from both stdout/stderr should be sent. Same as
stdout &amp; stderr options from function <code><a href="base.html#topic+system2">system2()</a></code>.</p>
</td></tr>
</table>


<h3>Java 8 64-Bit</h3>

<p>AMAPVox versions equal or prior to 1.10 rely on
Java/JavaFX 64-Bit. It must be installed on the Operating System before
running AMAPVox. In practice it requires either <a href="https://java.com/download/">Java 8 64-Bit Oracle</a> or <a href="https://aws.amazon.com/fr/corretto/">Java 8 64-Bit Corretto</a>. Mind that OpenJDK 8 will
not work for AMAPVox GUI since JavaFX is not included in this distribution.
Nonetheless for AMAPVox in batch mode, any version of Java 64-bit &gt;= 8
should work.
</p>
<p>You may check beforehand if java is installed on your system and which
version.
</p>
<div class="sourceCode"><pre>system2("java", args = "-version")
</pre></div>
<p>If AMAPVox::run keeps throwing errors after you have installed a suitable
Java 8 64-Bit, it means that Java 8 may not be properly detected by
your system. In such case you may have to check and set the <code>JAVA_HOME</code>
environment variable.
</p>
<div class="sourceCode"><pre>Sys.getenv("JAVA_HOME")
Sys.setenv(JAVA_HOME="path/to/java/8/bin")
system2("java", args = "-version")
</pre></div>
<p>As a last resort you may change the <code>java</code> parameter of this function and
set the full path to Java 8 binary.
</p>
<div class="sourceCode"><pre>AMAPVox::run("1.10.4", java = "/path/to/java/8/bin/java")
</pre></div>


<h3>See Also</h3>

<p><code><a href="#topic+getLocalVersions">getLocalVersions()</a></code>, <code><a href="#topic+getRemoteVersions">getRemoteVersions()</a></code>, <code><a href="#topic+installVersion">installVersion()</a></code> and
<code><a href="#topic+removeVersion">removeVersion()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# (install and) run latest AMAPVox version with GUI
AMAPVox::run()
# (install and) run version 2.0.0 with GUI
AMAPVox::run(version="2.0.0")
# run latest AMAPVox version with XML configuration
AMAPVox::run(xml="/path/to/cfg.xml")
# run multiple configurations
AMAPVox::run(xml=c("cfg1.xml", "cfg2.xml"), nt=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='tools'>Tools inherited from base R for VoxelSpace object.</h2><span id='topic+tools'></span><span id='topic+show+2CVoxelSpace-method'></span><span id='topic+print.VoxelSpace'></span><span id='topic+length.VoxelSpace'></span><span id='topic+dim.VoxelSpace'></span><span id='topic+is.VoxelSpace'></span><span id='topic+ncol+2CVoxelSpace-method'></span><span id='topic+nrow+2CVoxelSpace-method'></span><span id='topic+names.VoxelSpace'></span>

<h3>Description</h3>

<p>Tools inherited from base R for <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'VoxelSpace'
show(object)

## S3 method for class 'VoxelSpace'
print(x, ...)

## S3 method for class 'VoxelSpace'
length(x)

## S3 method for class 'VoxelSpace'
dim(x)

is.VoxelSpace(x)

## S4 method for signature 'VoxelSpace'
ncol(x)

## S4 method for signature 'VoxelSpace'
nrow(x)

## S3 method for class 'VoxelSpace'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tools_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="tools_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="tools_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print</code> function.</p>
</td></tr>
</table>


<h3>Note on <code>length.VoxelSpace</code></h3>

<p>AMAPVox allows to discard empty voxels in the voxel file. In such case
<code>length.VoxelSpace</code> will return the expected number of voxels as if
none were missing. As a  consequence the number of voxels stored in the
<code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object may be inferior to the returned
value, namely <code>nrow(x) &lt;= length(x)</code>
</p>

<hr>
<h2 id='toRaster'>Voxel layer to raster</h2><span id='topic+toRaster'></span>

<h3>Description</h3>

<p>Converts a voxel space (i, j) layer into a
<code><a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toRaster(vxsp, vx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toRaster_+3A_vxsp">vxsp</code></td>
<td>
<p>a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code> object.</p>
</td></tr>
<tr><td><code id="toRaster_+3A_vx">vx</code></td>
<td>
<p>a voxel space horizontal slice. A data.table with <code style="white-space: pre;">&#8288;i, j&#8288;</code> columns
and least one additional variable, the value of the raster layer. Every
column beside i and j will be converted into a raster layer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="terra.html#topic+SpatRaster-class">terra::SpatRaster</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
library(terra)

# CHM, DEM and PAI as raster
plot(toRaster(vxsp, merge(canopyHeight(vxsp), groundElevation(vxsp), all = T)))

# PAI
vxsp &lt;- plantAreaDensity(vxsp)
pai &lt;- plantAreaIndex(vxsp, type = "xy", pattern.pad = "pad_transmittance")
plot(toRaster(vxsp, pai))

# sampling intensity at 2 meters
plot(toRaster(vxsp, vxsp@data[ground_distance == 2.25, .(i, j, nbSampling)]))

## End(Not run)

</code></pre>

<hr>
<h2 id='VoxelSpace-class'>VoxelSpace</h2><span id='topic+VoxelSpace-class'></span>

<h3>Description</h3>

<p>Class that holds the state variables of every voxel of the voxel
space in a <code><a href="data.table.html#topic+data.table-class">data.table::data.table</a></code> object, plus metadata from the
voxel space header.
</p>


<h3>Value</h3>

<p>An object of class VoxelSpace.
</p>


<h3>Slots</h3>


<dl>
<dt><code>file</code></dt><dd><p>the path of the voxel file (.vox).</p>
</dd>
<dt><code>data</code></dt><dd><p>the voxels hold in a data.table.</p>
</dd>
<dt><code>header</code></dt><dd><p>a list of parameters associated to this voxel file.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+readVoxelSpace">readVoxelSpace()</a></code>
</p>

<hr>
<h2 id='writeVoxelSpace'>Write a voxel file</h2><span id='topic+writeVoxelSpace'></span>

<h3>Description</h3>

<p>write a voxel file out of a <code><a href="#topic+VoxelSpace-class">VoxelSpace</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeVoxelSpace(vxsp, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeVoxelSpace_+3A_vxsp">vxsp</code></td>
<td>
<p>the object of class VoxelSpace to write</p>
</td></tr>
<tr><td><code id="writeVoxelSpace_+3A_f">f</code></td>
<td>
<p>a character string naming a file.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+readVoxelSpace">readVoxelSpace()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load a voxel file
vxsp &lt;- readVoxelSpace(system.file("extdata", "tls_sample.vox", package = "AMAPVox"))
# set max PAD to 5
vxsp@data[, PadBVTotal:=sapply(PadBVTotal, min, 5)]
# write updated voxel file in temporary file
writeVoxelSpace(vxsp, tempfile("pattern"="amapvox_", fileext=".vox"))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
