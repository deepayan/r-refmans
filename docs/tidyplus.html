<!DOCTYPE html><html><head><title>Help for package tidyplus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyplus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidyplus-package'><p>tidyplus: Additional 'tidyverse' Functions</p></a></li>
<li><a href='#add_missing_column'><p>Add missing columns to a data frame</p></a></li>
<li><a href='#coalesce_data'><p>Coalesce Data</p></a></li>
<li><a href='#collapse_comments'><p>Collapse Comments</p></a></li>
<li><a href='#drop_na_all'><p>Drop rows containing all missing values</p></a></li>
<li><a href='#drop_uninformative_columns'><p>Drop uninformative columns from a data frame</p></a></li>
<li><a href='#if_else2'><p>Vectorised if else.</p></a></li>
<li><a href='#only'><p>Extract the only distinct value from a vector</p></a></li>
<li><a href='#replace_na_if'><p>Conditional replacement of NAs with specified values</p></a></li>
<li><a href='#str_crush'><p>Remove whitespace from a string</p></a></li>
<li><a href='#str_detect2'><p>Detect the presence/absence of a match</p></a></li>
<li><a href='#unite_str'><p>Unite multiple character columns into one</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Additional 'tidyverse' Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions such as str_crush(), add_missing_column(), 
  coalesce_data() and drop_na_all() that complement 'tidyverse' functionality
  or functions that provide alternative behaviors such as if_else2()
  and str_detect2().</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/poissonconsulting/tidyplus">https://github.com/poissonconsulting/tidyplus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/poissonconsulting/tidyplus/issues">https://github.com/poissonconsulting/tidyplus/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>chk, dplyr, rlang, stringi, stringr, tibble, tidyr,
tidyselect, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, readr, sf, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-16 19:41:48 UTC; joe</td>
</tr>
<tr>
<td>Author:</td>
<td>Joe Thorley <a href="https://orcid.org/0000-0002-7683-4592"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Poisson Consulting [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joe Thorley &lt;joe@poissonconsulting.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-16 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidyplus-package'>tidyplus: Additional 'tidyverse' Functions</h2><span id='topic+tidyplus'></span><span id='topic+tidyplus-package'></span>

<h3>Description</h3>

<p>Provides functions such as str_crush(), add_missing_column(), coalesce_data() and drop_na_all() that complement 'tidyverse' functionality or functions that provide alternative behaviors such as if_else2() and str_detect2().
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joe Thorley <a href="mailto:joe@poissonconsulting.ca">joe@poissonconsulting.ca</a> (<a href="https://orcid.org/0000-0002-7683-4592">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Poisson Consulting [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/poissonconsulting/tidyplus">https://github.com/poissonconsulting/tidyplus</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/poissonconsulting/tidyplus/issues">https://github.com/poissonconsulting/tidyplus/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_missing_column'>Add missing columns to a data frame</h2><span id='topic+add_missing_column'></span>

<h3>Description</h3>

<p>This is a convenient way to add one more columns (if not already present) to
an existing data frame. It is useful to ensure that all required columns
are present in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_missing_column(
  .data,
  ...,
  .before = NULL,
  .after = NULL,
  .name_repair = c("check_unique", "unique", "universal", "minimal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_missing_column_+3A_.data">.data</code></td>
<td>
<p>Data frame to append to.</p>
</td></tr>
<tr><td><code id="add_missing_column_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+dyn-dots">dynamic-dots</a></code>&gt;
Name-value pairs, passed on to <code><a href="tibble.html#topic+tibble">tibble()</a></code>. All values must have
the same size of <code>.data</code> or size 1.</p>
</td></tr>
<tr><td><code id="add_missing_column_+3A_.before">.before</code>, <code id="add_missing_column_+3A_.after">.after</code></td>
<td>
<p>One-based column index or column name where to add the
new columns, default: after last column.</p>
</td></tr>
<tr><td><code id="add_missing_column_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Treatment of problematic column names:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence,
</p>
</li>
<li> <p><code>"unique"</code>: Make sure names are unique and not empty,
</p>
</li>
<li> <p><code>"check_unique"</code>: (default value), no name repair, but check they are
<code>unique</code>,
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic
</p>
</li>
<li><p> a function: apply custom name repair (e.g., <code>.name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is wrapper on <code><a href="tibble.html#topic+add_column">tibble::add_column()</a></code> that doesn't error if the column
is already present.
</p>


<h3>Value</h3>

<p>The original data frame with missing columns added
if not already present.
</p>


<h3>See Also</h3>

<p><code><a href="tibble.html#topic+add_column">tibble::add_column()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tibble::tibble(x = 1:3, y = 3:1)

tibble::add_column(data, z = -1:1, w = 0)
add_missing_column(data, z = -1:1, .before = "y")

# add_column errors if already present
try(tibble::add_column(data, x = 4:6))

# add_missing_column silently ignores
add_missing_column(data, x = 4:6)
</code></pre>

<hr>
<h2 id='coalesce_data'>Coalesce Data</h2><span id='topic+coalesce_data'></span>

<h3>Description</h3>

<p>Coalesce values in multiple columns by finding the first non-missing
value at each position.
Coalesced columns are removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce_data(x, coalesce = list(), quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalesce_data_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="coalesce_data_+3A_coalesce">coalesce</code></td>
<td>
<p>A uniquely named list of character vectors where the names are the
new column names and the values are the names of the columns to coalesce.
If a single value is provided for a column it is treated as a regular expression.</p>
</td></tr>
<tr><td><code id="coalesce_data_+3A_quiet">quiet</code></td>
<td>
<p>A flag specifying whether to provide messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coalescence is performed in the order
specified in the coalesce argument such that a column produced by
coalescence can be further coalesced.
</p>


<h3>Value</h3>

<p>The original data frame with one or more columns coalesced into a
new column.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+coalesce">dplyr::coalesce()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(x = c(1, NA, NA), y = c(NA, 3, NA), z = c(7, 8, 9), a = c(4, 5, 6))
coalesce_data(data, list(b = c("x", "y")), quiet = TRUE)
coalesce_data(data, list(z = c("y", "x"), d = c("z", "a")))
</code></pre>

<hr>
<h2 id='collapse_comments'>Collapse Comments</h2><span id='topic+collapse_comments'></span>

<h3>Description</h3>

<p>Collapse comments coercing each element to a string (character scalar)
and then collapsing into a single string using the '. ' separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_comments(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_comments_+3A_...">...</code></td>
<td>
<p>objects to be collapsed into a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of the collapsed comments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unite_str">unite_str()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collapse_comments("Saw fish", character(0), "Nice. .", NA_character_)

data &lt;- data.frame(
  visit = c(1,1,2, 2), 
  fish = 1:4,
  comment = c("Sunny day.  ", "Skinny fish", "Lost boot", NA))

## Not run: 
data |&gt;
  dplyr::group_by(visit) |&gt;
  dplyr::summarise(comment = collapse_comments(comment)) |&gt;
  dplyr::ungroup()

## End(Not run)
</code></pre>

<hr>
<h2 id='drop_na_all'>Drop rows containing all missing values</h2><span id='topic+drop_na_all'></span>

<h3>Description</h3>

<p>This is a convenient way to drop uninformative rows from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_na_all(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_na_all_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="drop_na_all_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to inspect for
missing values. If empty, all columns are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data frame with rows for which all values are missing dropped.
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+drop_na">tidyr::drop_na</a></code> and <code><a href="#topic+drop_uninformative_columns">drop_uninformative_columns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tibble::tibble(
  a = c(NA, NA, NA), b = c(1, 1, NA), c = c(2, NA, NA))

drop_na_all(data)
drop_na_all(data, a, c)
</code></pre>

<hr>
<h2 id='drop_uninformative_columns'>Drop uninformative columns from a data frame</h2><span id='topic+drop_uninformative_columns'></span>

<h3>Description</h3>

<p>This is a convenient way to drop columns which all have one value (missing or not) or
if <code>na_distinct = FALSE</code> also drop columns which all have one value and/or missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_uninformative_columns(data, na_distinct = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_uninformative_columns_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="drop_uninformative_columns_+3A_na_distinct">na_distinct</code></td>
<td>
<p>A flag specifying whether to treat missing values
as distinct from other values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data frame with only informative columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tibble::tibble(
  a = c(1,1,1), x = c(NA, NA, NA), b = c(1, 1, NA), 
  z = c(1, 2, 2), e = c(1, 2, NA))

drop_uninformative_columns(data)
drop_uninformative_columns(data, na_distinct = FALSE)
</code></pre>

<hr>
<h2 id='if_else2'>Vectorised if else.</h2><span id='topic+if_else2'></span>

<h3>Description</h3>

<p>Vectorised if else that if true returns first possibility otherwise returns
second possibility (even if the condition is a missing value).
When searching character vectors an alternative solution is to use
<code><a href="#topic+str_detect2">str_detect2()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_else2(condition, true, false)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_else2_+3A_condition">condition</code></td>
<td>
<p>Logical vector</p>
</td></tr>
<tr><td><code id="if_else2_+3A_true">true</code>, <code id="if_else2_+3A_false">false</code></td>
<td>
<p>Values to use for <code>TRUE</code> and <code>FALSE</code> values of
<code>condition</code>. They must be either the same length as <code>condition</code>,
or length 1. They must also be the same type: <code>if_else()</code> checks that
they have the same type and same class. All other attributes are
taken from <code>true</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Where condition is <code>TRUE</code>, the matching value from <code>true</code>, where it's <code>FALSE</code> or <code>NA</code>, the matching value from <code>false</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+ifelse">ifelse()</a></code> and <code><a href="dplyr.html#topic+if_else">dplyr::if_else()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># consider the following data frame
data &lt;- tibble::tibble(
  x = c(TRUE, FALSE, NA), 
  y = c("x is false", NA, "hello"))
  
# with a single vector if_else2() behaves the same as the default call to if_else().
dplyr::mutate(data,
    y1 = dplyr::if_else(y != "x is false", "x is true", y),
    y2 = if_else2(y != "x is false", "x is true", y))

# however in the case of a second vector the use of 
# if_else2() does not introduce missing values
dplyr::mutate(data,
    x1 = dplyr::if_else(stringr::str_detect(y, "x is false"), FALSE, x),
    x2 = if_else2(stringr::str_detect(y, "x is false"), FALSE, x))
    
# in the case of regular expression matching an alternative is to use 
# str_detect2()
dplyr::mutate(data,
    x3 = dplyr::if_else(str_detect2(y, "x is false"), FALSE, x))
</code></pre>

<hr>
<h2 id='only'>Extract the only distinct value from a vector</h2><span id='topic+only'></span>

<h3>Description</h3>

<p>Extracts the only distinct value from an atomic vector
or throws an informative error if no values or multiple distinct values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>only(x, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="only_+3A_x">x</code></td>
<td>
<p>An atomic vector.</p>
</td></tr>
<tr><td><code id="only_+3A_na_rm">na_rm</code></td>
<td>
<p>A flag indicating whether to exclude missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>only()</code> is useful when summarizing a vector by group
while checking the assumption that it is constant within the group.
</p>


<h3>Value</h3>

<p>The only distinct value from a vector otherwise throws an error.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+nth">dplyr::first()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>only(c(1, 1))
only(c(NA, NA))
only(c(1, 1, NA), na_rm = TRUE)
try(only(character(0)))
try(only(c(1, NA)))
try(only(c(1, 2)))
</code></pre>

<hr>
<h2 id='replace_na_if'>Conditional replacement of NAs with specified values</h2><span id='topic+replace_na_if'></span>

<h3>Description</h3>

<p>Unlike <code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code>, it is only defined for vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_na_if(x, condition, true)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_na_if_+3A_x">x</code></td>
<td>
<p>Vector with missing values to modify.</p>
</td></tr>
<tr><td><code id="replace_na_if_+3A_condition">condition</code></td>
<td>
<p>Logical vector</p>
</td></tr>
<tr><td><code id="replace_na_if_+3A_true">true</code></td>
<td>
<p>The replacement values where condition is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>replace_na_if()</code> is a wrapper on <code>if_else2(is.na(x) &amp; condition, true, x)</code>
</p>


<h3>Value</h3>

<p>A modified version of x that replaces any missing values where condition is <code>TRUE</code>
with <code>true</code>.
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code> and <code><a href="#topic+if_else2">if_else2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tibble::tibble(
  x = c(TRUE, FALSE, NA), 
  y = c("x is false", NA, "x is false"))
  
dplyr::mutate(data,
    x1 = tidyr::replace_na(x, FALSE),
    x3 = if_else2(is.na(x) &amp; y == "x is false", FALSE, x),
    x4 = replace_na_if(x, y == "x is false", FALSE))
</code></pre>

<hr>
<h2 id='str_crush'>Remove whitespace from a string</h2><span id='topic+str_crush'></span>

<h3>Description</h3>

<p><code>str_crush()</code>, which removes all whitespace from a string,
is the logical extension to <code><a href="stringr.html#topic+str_trim">stringr::str_trim()</a></code> and <code><a href="stringr.html#topic+str_trim">stringr::str_squish()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_crush(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_crush_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>str_crush()</code> is considered <a href="https://github.com/tidyverse/stringr/pull/338">too specialized</a> to be part of stringr.
</p>


<h3>Value</h3>

<p>A character vector the same length as <code>string</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stringr.html#topic+str_trim">stringr::str_trim()</a></code> and <code><a href="stringr.html#topic+str_trim">stringr::str_squish()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str_crush("  String with trailing,  middle, and leading white space\t")
</code></pre>

<hr>
<h2 id='str_detect2'>Detect the presence/absence of a match</h2><span id='topic+str_detect2'></span>

<h3>Description</h3>

<p>Vectorised over <code>string</code> and <code>pattern</code>.
Actually equivalent to <code>grepl(pattern, x)</code> as returns FALSE
for <code>NA</code>s (unlike <code><a href="stringr.html#topic+str_detect">stringr::str_detect()</a></code>).
This behavior is useful when searching comments many of which are NA to
indicate no comments present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str_detect2(string, pattern, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str_detect2_+3A_string">string</code></td>
<td>
<p>Input vector. Either a character vector, or something
coercible to one.</p>
</td></tr>
<tr><td><code id="str_detect2_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to look for.
</p>
<p>The default interpretation is a regular expression, as described in
<code>vignette("regular-expressions")</code>. Use <code><a href="stringr.html#topic+regex">regex()</a></code> for finer control of the
matching behaviour.
</p>
<p>Match a fixed string (i.e. by comparing only bytes), using
<code><a href="stringr.html#topic+fixed">fixed()</a></code>. This is fast, but approximate. Generally,
for matching human text, you'll want <code><a href="stringr.html#topic+coll">coll()</a></code> which
respects character matching rules for the specified locale.
</p>
<p>Match character, word, line and sentence boundaries with
<code><a href="stringr.html#topic+boundary">boundary()</a></code>. An empty pattern, &quot;&quot;, is equivalent to
<code>boundary("character")</code>.</p>
</td></tr>
<tr><td><code id="str_detect2_+3A_negate">negate</code></td>
<td>
<p>If <code>TRUE</code>, return non-matching elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same length as <code>string</code>/<code>pattern</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grepl">grepl()</a></code> and <code><a href="stringr.html#topic+str_detect">stringr::str_detect()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("b", NA, "ab")
pattern &lt;- "^a"
grepl(pattern, x)
stringr::str_detect(x, pattern)
str_detect2(x, pattern)
</code></pre>

<hr>
<h2 id='unite_str'>Unite multiple character columns into one</h2><span id='topic+unite_str'></span>

<h3>Description</h3>

<p>Convenience function for combining character columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unite_str(data, col, ..., sep = ". ", remove = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unite_str_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="unite_str_+3A_col">col</code></td>
<td>
<p>The name of the new column, as a string or symbol.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote strings
and symbols). The name is captured from the expression with
<code><a href="rlang.html#topic+defusing-advanced">rlang::ensym()</a></code> (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).</p>
</td></tr>
<tr><td><code id="unite_str_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to unite</p>
</td></tr>
<tr><td><code id="unite_str_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="unite_str_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Blank values of &quot;&quot; are converted into missing values.
</p>


<h3>Value</h3>

<p>The original data frame with the one or more columns combined as
character vectors separated by a period.
</p>


<h3>See Also</h3>

<p><code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code> and <code><a href="#topic+collapse_comments">collapse_comments()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- tibble::tibble(x = c("good", "Saw fish.", "", NA), y = c("2021", NA, NA, NA))

# unite has poor handling of character vectors
tidyr::unite(data, "new", x, y, remove = FALSE)

unite_str(data, "new", x, y, remove = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
