<!DOCTYPE html><html lang="en"><head><title>Help for package CNLTreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CNLTreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CNLTreg-package'>
<p>Complex-Valued Wavelet Lifting for Signal Denoising</p></a></li>
<li><a href='#cnlt.reg'>
<p>Performs 'nondecimated' complex-valued wavelet lifting for signal denoising</p></a></li>
<li><a href='#denoisepermC'>
<p>Denoises a signal using the complex-valued lifting transform and multivariate soft thresholding</p></a></li>
<li><a href='#denoisepermCh'>
<p>Denoises a signal using the complex-valued lifting transform and multivariate soft thresholding and heteroscedastic variance computation</p></a></li>
<li><a href='#fwtnppermC'>
<p>Forward complex wavelet lifting transform</p></a></li>
<li><a href='#mthreshC'>
<p>Function to perform 'multiwavelet style' level-dependent soft</p>
thresholding for complex-valued wavelet coefficients</a></li>
<li><a href='#orthpredfilters'>
<p>Computes orthogonal filters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Complex-Valued Wavelet Lifting for Signal Denoising</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Nunes [aut, cre],
  Marina Knight [aut],
  Jean Hamilton [ctb],
  Piotr Fryzlewicz [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of recent complex-valued wavelet shrinkage procedures for smoothing irregularly sampled signals, see Hamilton et al (2018) &lt;<a href="https://doi.org/10.1080%2F00401706.2017.1281846">doi:10.1080/00401706.2017.1281846</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>adlift, miscTools, nlt</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-18 12:20:38 UTC; nunes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-18 12:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='CNLTreg-package'>
Complex-Valued Wavelet Lifting for Signal Denoising
</h2><span id='topic+CNLTreg-package'></span><span id='topic+CNLTreg'></span>

<h3>Description</h3>

<p>Implementations of recent complex-valued wavelet shrinkage procedures for smoothing irregularly sampled signals, see Hamilton et al (2018) &lt;doi:10.1080/00401706.2017.1281846&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CNLTreg</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Complex-Valued Wavelet Lifting for Signal Denoising</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-07-18</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Matt Nunes [aut, cre], Marina Knight [aut], Jean Hamilton [ctb], Piotr Fryzlewicz [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Matt","Nunes", role=c("aut","cre"),email="nunesrpackages@gmail.com"),person("Marina", "Knight", role="aut"), person("Jean", "Hamilton", role="ctb"), person("Piotr", "Fryzlewicz", role="ctb"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Implementations of recent complex-valued wavelet shrinkage procedures for smoothing irregularly sampled signals, see Hamilton et al (2018) &lt;doi:10.1080/00401706.2017.1281846&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> adlift, miscTools, nlt</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> MASS</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
CNLTreg-package         Complex-Valued Wavelet Lifting for Signal
                        Denoising
cnlt.reg                Performs 'nondecimated' complex-valued wavelet
                        lifting for signal denoising
denoisepermC            Denoises a signal using the complex-valued
                        lifting transform and multivariate soft
                        thresholding
denoisepermCh           Denoises a signal using the complex-valued
                        lifting transform and multivariate soft
                        thresholding and heteroscedastic variance
                        computation
fwtnppermC              Forward complex wavelet lifting transform
mthreshC                Function to perform 'multiwavelet style'
                        level-dependent soft thresholding for
                        complex-valued wavelet coefficients
orthpredfilters         Computes orthogonal filters
</pre>
<p>The main routines of the package are <code><a href="#topic+denoisepermC">denoisepermC</a></code> and <code><a href="#topic+cnlt.reg">cnlt.reg</a></code> which perform complex-valued lifting-based denoising, using a single or a multiple (chosen) number of lifting trajectories, respectively.  
</p>


<h3>Author(s)</h3>

<p>Matt Nunes [aut, cre], Marina Knight [aut], Jean Hamilton [ctb], Piotr Fryzlewicz [ctb]
</p>
<p>Maintainer: Matt Nunes &lt;nunesrpackages@gmail.com&gt;
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A, Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications. 
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br /><br />
For related literature on the lifting methodology adopted in the technique, see<br /><br />
Nunes, M. A., Knight, M. I and Nason, G. P. (2006) Adaptive lifting for nonparametric regression. 
<em>Stat. Comput.</em> <b>16</b> (2), 143&ndash;159.<br /><br />
Knight, M. I. and Nason, G. P. (2009) A 'nondecimated' wavelet transform. <em>Stat. Comput.</em> 
<b>19</b> (1), 1&ndash;16. 
</p>


<h3>See Also</h3>

<p><code><a href="adlift.html#topic+denoise">denoise</a></code>
<code><a href="nlt.html#topic+denoiseperm">denoiseperm</a></code>
<code><a href="nlt.html#topic+nlt">nlt</a></code>
</p>

<hr>
<h2 id='cnlt.reg'>
Performs 'nondecimated' complex-valued wavelet lifting for signal denoising
</h2><span id='topic+cnlt.reg'></span>

<h3>Description</h3>

<p>The transform-threshold-invert procedure for signal denoising is dependent on the trajectory (lifting order) used in the forward lifting transform.  This procedure uses trajectory bootstrapping and averaging of estimates to gain denoising performance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnlt.reg(x, f, P, returnall = FALSE, nkeep = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cnlt.reg_+3A_x">x</code></td>
<td>
<p>Vector of any length (not necessarily equally spaced) that gives the grid on which the signal is
observed.</p>
</td></tr>
<tr><td><code id="cnlt.reg_+3A_f">f</code></td>
<td>
<p>Vector of the same length as <code>x</code> that gives the signal values corresponding to the
<code>x</code>-locations. </p>
</td></tr>
<tr><td><code id="cnlt.reg_+3A_p">P</code></td>
<td>

<p>Number of trajectories to be used by the nondecimated lifting algorithm.
</p>
</td></tr>
<tr><td><code id="cnlt.reg_+3A_returnall">returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td></tr>
<tr><td><code id="cnlt.reg_+3A_nkeep">nkeep</code></td>
<td>

<p>Number of scaling points we want at the end of the transform. The usual choice is <code>nkeep</code>=2.
</p>
</td></tr>
<tr><td><code id="cnlt.reg_+3A_...">...</code></td>
<td>
<p>Any other arguments to be passed to <code><a href="#topic+denoisepermC">denoisepermC</a></code>, see the function documentation for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, this function applies the complex wavelet lifting
denoising procedure <code><a href="#topic+denoisepermC">denoisepermC</a></code> <span class="env">P</span> times, each with a different random lifting trajectory. 
This results in <span class="env">P</span> estimates of the (unknown) true
signal. The average of these estimators is the proposed estimator.
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>,
a list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>vec</code></td>
<td>
<p>A matrix of dimension <code>P x (n - nkeep)</code>, each row corresponding to a different lifting trajectory.</p>
</td></tr>
<tr><td><code>aveghat</code></td>
<td>
<p>Estimated signal after removing the noise.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Using a large number of trajectories for long datasets could take a long time!</p>


<h3>Author(s)</h3>

<p>Matt Nunes
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applicati$
<em>Technometrics</em>, bold60 (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br /><br />
For the real-valued equivalent procedure, see also<br />
Knight, M. I. and Nason, G. P. (2009) A 'nondecimated' wavelet transform. <em>Stat. Comput.</em>
<b>19</b> (1), 1&ndash;16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoisepermCh">denoisepermCh</a></code>,
<code><a href="#topic+fwtnppermC">fwtnppermC</a></code>,
<code><a href="#topic+mthreshC">mthreshC</a></code>,
<code><a href="nlt.html#topic+nlt">nlt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
    library(adlift)

    # construct an (irregular) observation grid
     x&lt;-runif(256) 
     
     #construct the true, normally unknown, signal
     g&lt;-make.signal2("blocks",x=x) 
     
     #generate noise with mean 0 and signal-to-noise ratio 5
     noise&lt;-rnorm(256,mean=0,sd=sqrt(var(g))/5)
     
     #generate a noisy version of g 
     f&lt;-g+noise 
     
     #decide on a number of random trajectories to be used (e.g. J=5 below), and apply
     # the nondecimated lifting transform to the noisy signal (x,f): 
## Not run: 
     est&lt;-cnlt.reg(x,f,P=50,LocalPred=AdaptPred,neighbours=1,returnall=FALSE) 

## End(Not run)
</code></pre>

<hr>
<h2 id='denoisepermC'>
Denoises a signal using the complex-valued lifting transform and multivariate soft thresholding
</h2><span id='topic+denoisepermC'></span>

<h3>Description</h3>

<p>Denoises an input signal contaminated by noise. First the signal is decomposed using the complex-valued lifting 
scheme (see <code><a href="#topic+fwtnppermC">fwtnppermC</a></code>) using an order of point removal. The resulting complex-valued wavelet
coefficients are then thresholded using a soft thresholding rule on the details' magnitude.  
The transform is inverted and an estimate of the noisy signal is obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoisepermC(x, f, returnall = FALSE, sdtype = "adlift", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denoisepermC_+3A_x">x</code></td>
<td>
<p>Vector of any length (not necessarily equally spaced) that gives the grid on which the signal is 
observed.</p>
</td></tr>
<tr><td><code id="denoisepermC_+3A_f">f</code></td>
<td>
<p>Vector of the same length as <code>x</code> that gives the signal values corresponding to the 
<code>x</code>-locations. </p>
</td></tr>
<tr><td><code id="denoisepermC_+3A_returnall">returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td></tr>
<tr><td><code id="denoisepermC_+3A_sdtype">sdtype</code></td>
<td>
<p>Options are either <code>"adlift"</code> or <code>"complex"</code>, indicating whether the noise variance is estimated with the average of the mean absolute deviations of both real and imaginary components of the finest wavelet coefficients, or just the real component, as in <code><a href="adlift.html#topic+denoise">denoise</a></code>.</p>
</td></tr>
<tr><td><code id="denoisepermC_+3A_verbose">verbose</code></td>
<td>
<p>Indicates whether useful messages should be printed to the console during the procedure.</p>
</td></tr>
<tr><td><code id="denoisepermC_+3A_...">...</code></td>
<td>
<p>Any other arguments to be passed to <code><a href="#topic+fwtnppermC">fwtnppermC</a></code>, see documentation for this function for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After the complex lifting transform is applied, the wavelet coeficients are divided into artificial levels. 
The details from the lifting scheme have different variances, and will therefore be normalized 
to have the same variance as the noise, by using the lifting matrix. Those normalized details falling into the finest artificial level will 
be used for estimating the standard deviation of the noise that contaminated the signal.  The variable <span class="env">sdtype</span> is used for this estimate, see Appendix B of Hamilton et al. (2018) for more details.  Using this 
estimate,  the normalized details can then be thresholded and un-normalized.  The transform is then inverted to give an estimate of the signal. 
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>, 
a list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>fhat</code></td>
<td>
<p>Estimated signal after removing the noise.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>This is the matrix associated to the modified lifting transform.</p>
</td></tr>
<tr><td><code>indsd</code></td>
<td>
<p>Vector giving the standard deviations of the detail and scaling coefficients.</p>
</td></tr>
<tr><td><code>al</code></td>
<td>
<p>List giving the split of points between the artificial levels.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Estimated standard deviation of the noise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes, Marina Knight
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoisepermCh">denoisepermCh</a></code>,
<code><a href="#topic+fwtnppermC">fwtnppermC</a></code>,
<code><a href="#topic+mthreshC">mthreshC</a></code>,
<code><a href="#topic+cnlt.reg">cnlt.reg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    library(adlift)

    # construct an (irregular) observation grid
     x&lt;-runif(256)

     #construct the true, normally unknown, signal
     g&lt;-make.signal2("blocks",x=x)

     #generate noise with mean 0 and signal-to-noise ratio 5
     noise&lt;-rnorm(256,mean=0,sd=sqrt(var(g))/5)

     #generate a noisy version of g
     f&lt;-g+noise

     # perform the complex-valued denoising procedure to the noisy signal (x,f):
     est&lt;-denoisepermC(x,f,LocalPred=AdaptPred,neigh=1,returnall=FALSE)

</code></pre>

<hr>
<h2 id='denoisepermCh'>
Denoises a signal using the complex-valued lifting transform and multivariate soft thresholding and heteroscedastic variance computation
</h2><span id='topic+denoisepermCh'></span>

<h3>Description</h3>

<p>Denoises an input signal contaminated by noise. First the signal is decomposed using the complex-valued lifting
scheme (see <code><a href="#topic+fwtnppermC">fwtnppermC</a></code>) using an order of point removal. A sliding window approach is then used
on these wavelet coefficients to estimate a local noise variance.
The resulting complex-valued wavelet
coefficients are then thresholded using a soft thresholding rule on the details' magnitude.
The transform is inverted and an estimate of the noisy signal is obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denoisepermCh(x, f, returnall = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denoisepermCh_+3A_x">x</code></td>
<td>
<p>Vector of any length (not necessarily equally spaced) that gives the grid on which the signal is
observed.</p>
</td></tr>
<tr><td><code id="denoisepermCh_+3A_f">f</code></td>
<td>
<p>Vector of the same length as <code>x</code> that gives the signal values corresponding to the
<code>x</code>-locations. </p>
</td></tr>
<tr><td><code id="denoisepermCh_+3A_returnall">returnall</code></td>
<td>
<p>Indicates whether the function returns useful variables or just the denoised datapoints.</p>
</td></tr>
<tr><td><code id="denoisepermCh_+3A_verbose">verbose</code></td>
<td>
<p>Indicates whether useful messages should be printed to the console during the procedure.</p>
</td></tr>
<tr><td><code id="denoisepermCh_+3A_...">...</code></td>
<td>
<p>Any other arguments to be passed to <code><a href="nlt.html#topic+fwtnpperm">fwtnpperm</a></code> and <code><a href="#topic+fwtnppermC">fwtnppermC</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After the complex lifting transform is applied, the wavelet coeficients are divided into artificial levels.
The details from the lifting scheme have different variances, and will therefore be normalized
to have the same variance as the noise, by using the lifting matrix.  A sliding window is used to compute a local 'heteroscedastic' noise variance by taking the MAD of those normalized details falling into the window, see Nunes et al. (2006) for more details.  
Given the noise estimates for each observation,  the normalized details can then be thresholded and un-normalized.  The transform is then inverted to
give an estimate of the signal.
</p>


<h3>Value</h3>

<p>If <span class="env">returnall=FALSE</span>, the estimate of the function after denoising.  If <span class="env">returnall=TRUE</span>,
a list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>fhat</code></td>
<td>
<p>Estimated signal after removing the noise.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>This is the matrix associated to the modified lifting transform.</p>
</td></tr>
<tr><td><code>al</code></td>
<td>
<p>List giving the split of points between the artificial levels.</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Estimated heteroscedastic standard deviation of the noise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes, Marina Knight
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A, Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications. 
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br /><br />
Nunes, M. A., Knight, M. I and Nason, G. P. (2006) Adaptive lifting for nonparametric regression.
<em>Stat. Comput.</em> <b>16</b> (2), 143&ndash;159.<br /><br />
Knight, M. I. and Nason, G. P. (2009) A 'nondecimated' wavelet transform. <em>Stat. Comput.</em>
<b>19</b> (1), 1&ndash;16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denoisepermC">denoisepermC</a></code>,
<code><a href="#topic+fwtnppermC">fwtnppermC</a></code>,
<code><a href="nlt.html#topic+fwtnpperm">fwtnpperm</a></code>,
<code><a href="adlift.html#topic+heterovar">heterovar</a></code>,
<code><a href="#topic+mthreshC">mthreshC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(MASS)	# where the motorcyle data lives

mcycleu&lt;-mcycle[which(duplicated(mcycle$times)=='FALSE'),]
time&lt;-mcycleu[,1]
accel&lt;-mcycleu[,2]

set.seed(200)
est1&lt;-denoisepermCh(time,accel)

</code></pre>

<hr>
<h2 id='fwtnppermC'>
Forward complex wavelet lifting transform
</h2><span id='topic+fwtnppermC'></span>

<h3>Description</h3>

<p>Performs the complex-valued lifting transform on a signal with grid <span class="env">x</span> and corresponding function 
values <span class="env">f</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fwtnppermC(x, f, LocalPred = LinearPred, neighbours = 1, 
intercept = TRUE, closest = FALSE, nkeep = 2, 
mod = sample(1:length(x), (length(x) - nkeep), FALSE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fwtnppermC_+3A_x">x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td></tr>
<tr><td><code id="fwtnppermC_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="fwtnppermC_+3A_localpred">LocalPred</code></td>
<td>
<p>The type of regression to be performed in the prediction lifting step. Possible options are <code>LinearPred</code>, <code>QuadPred</code>, <code>CubicPred</code>, <code>AdaptPred</code> and
<code>AdaptNeigh</code>.</p>
</td></tr>
<tr><td><code id="fwtnppermC_+3A_neighbours">neighbours</code></td>
<td>
<p>The number of neighbours over which the regression is performed at each step.
If <span class="env">closest</span> is <code>FALSE</code>, then this in fact denotes the number of neighbours on each side of the removed point.</p>
</td></tr>
<tr><td><code id="fwtnppermC_+3A_intercept">intercept</code></td>
<td>
<p>Indicates whether or not the regression prediction includes an intercept.</p>
</td></tr>
<tr><td><code id="fwtnppermC_+3A_closest">closest</code></td>
<td>
<p>Refers to the configuration of the chosen neighbours. If <span class="env">closest</span> is <code>FALSE</code>,
the neighbours will be chosen symmetrically around the removed point.
Otherwise, the closest neighbours (in distance) will be chosen.</p>
</td></tr>
<tr><td><code id="fwtnppermC_+3A_nkeep">nkeep</code></td>
<td>
<p>The number of scaling coefficients to be kept in the final representation of the initial signal.
This must be at least two. </p>
</td></tr>
<tr><td><code id="fwtnppermC_+3A_mod">mod</code></td>
<td>
<p>Vector of length (length(<code>x</code>)-<code>nkeep</code>). This gives
the trajectory for the lifting algorithm to follow, i.e. it gives
the order of point removal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">n</code> points on a line, <span class="env">x</span>, each with a corresponding envf value this function computes
the complex-valued lifting transform of the (<span class="env">x</span>,<span class="env">f</span>) data. This is similar in spirit to the 
real-valued lifting transform in <code><a href="nlt.html#topic+fwtnpperm">fwtnpperm</a></code>, except that the algorithm constructs *two* 
orthogonally linked prediction filters, as in Section 2.2 of Hamilton et al. (2018).  A summary of the 
procedure is as follows:
</p>
<p>Step One. Compute &quot;integrals&quot; associated to each point, representing the intervals that each gridpoint 
<code>x_i</code> spans. 
</p>
<p>Then for each point index in the lifting trajectory <span class="env">mod</span>, 
</p>
<p>Step Two(a). The neighbours of the removed point are identified using the specified neighbour configuration.
The value of <span class="env">f</span> at the removed point is predicted using the specified regression over the
neighbours, unless an adaptive procedure is chosen. In this case, the algorithm chooses the regression which
produces the minimal detail coefficient (in magnitude) from a range of regression types (see <code><a href="adlift.html#topic+AdaptPred">AdaptPred</a></code> or <code><a href="adlift.html#topic+AdaptNeigh">AdaptNeigh</a></code> for more information).  In either case, the regression
specifies a local filter of the function values over the neighbourhood, <code>L</code>.
</p>
<p>Step Two(b). A second filter, <code>M</code>, is then constructed orthogonal to <code>L</code>, such that it has unit norm, see Hamilton et al. (2018) for more details. 
</p>
<p>The differences between the removed point's <span class="env">f</span> value and the predictions using the two filters are computed, which constitute the real and imaginary parts of the complex-valued wavelet coefficient.  This coefficient is then stored
</p>
<p>Step Three. The integrals and the scaling function values (neighbouring <span class="env">coeffv</span> values) are updated according to the filter <code>L</code>. 
</p>
<p>The algorithm continues until all points in <span class="env">mod</span> are removed.  
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coeff</code></td>
<td>
<p>matrix of detail and scaling coefficients in the wavelet decomposition of the signal; first column: real component, second column: imaginary component.</p>
</td></tr>
<tr><td><code>lengthsremove</code></td>
<td>
<p>vector of interval lengths corresponding to the points removed during the transform
(in <span class="env">removelist</span>).</p>
</td></tr>
<tr><td><code>pointsin</code></td>
<td>
<p>indices into <span class="env">X</span> of the scaling coefficients in the wavelet decomposition. These are the
indices of the <span class="env">X</span> values which remain after all points in <span class="env">removelist</span> have been predicted and
removed. This has length <span class="env">nkeep</span>.</p>
</td></tr>
<tr><td><code>removelist</code></td>
<td>
<p>a vector of indices into <span class="env">X</span> of the lifted coefficients during the transform
(in the order of removal).</p>
</td></tr>
<tr><td><code>gamlist</code></td>
<td>
<p>a list of all the prediction weights used at each step of the transform; each list entry is a matrix of two rows, corresponding to the filters <code>L</code> and <code>M</code>.</p>
</td></tr>
<tr><td><code>alphalist</code></td>
<td>
<p>a list of the update coefficients used in the update step of the decomposition.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>The complex-valued lifting matrix associated to the transform.</p>
</td></tr>
<tr><td><code>reo</code></td>
<td>
<p>An index into the observations indicating a reordering to give <code>1:n</code>.  This is reported for convenience for other functions, and is not intended for use by the user.</p>
</td></tr>
<tr><td><code>coeffv</code></td>
<td>
<p>vector of complex-valued detail and scaling coefficients in the wavelet decomposition of the signal; contains the same information as <span class="env">coeff</span>.</p>
</td></tr>
<tr><td><code>Ialpha</code></td>
<td>
<p>Vector of &quot;irregularity degree&quot; measures corresponding to each lifting step of the transform.  Note that this is returned for convenience in other functions, and is not intended for use by the user.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes, Marina Knight</p>


<h3>References</h3>

<p>Hamilton, J., Knight, Nunes, M. A. and Fryzlewicz (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>69</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br /><br />
For related literature on the lifting methodology adopted in the technique, see<br /><br />
Nunes, M. A., Knight, M. I and Nason, G. P. (2006) Adaptive lifting for nonparametric regression.
<em>Stat. Comput.</em> <b>16</b> (2), 143&ndash;159.<br /><br />
Knight, M. I. and Nason, G. P. (2009) A 'nondecimated' wavelet transform. <em>Stat. Comput.</em>
<b>19</b> (1), 1&ndash;16.
</p>


<h3>See Also</h3>

<p><code><a href="adlift.html#topic+AdaptNeigh">AdaptNeigh</a></code>, <code><a href="adlift.html#topic+AdaptPred">AdaptPred</a></code>, <code><a href="adlift.html#topic+CubicPred">CubicPred</a></code>, 
<code><a href="#topic+denoisepermC">denoisepermC</a></code>, 
<code><a href="#topic+denoisepermCh">denoisepermCh</a></code>, 
<code><a href="adlift.html#topic+LinearPred">LinearPred</a></code>, 
<code><a href="#topic+orthpredfilters">orthpredfilters</a></code>, 
<code><a href="adlift.html#topic+QuadPred">QuadPred</a></code>     
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    library(adlift)

    # construct an (irregular) observation grid
     x&lt;-runif(256)

     #construct a signal
     f&lt;-make.signal2("blocks",x=x)

     fwd&lt;-fwtnppermC(x,f,LocalPred=AdaptPred,neigh=1,closest=FALSE)

     # have a look at the complex-valued coefficients and the removal trajectory:

     fwd$coeffv

     fwd$removelist	
</code></pre>

<hr>
<h2 id='mthreshC'>
Function to perform 'multiwavelet style' level-dependent soft
thresholding for complex-valued wavelet coefficients
</h2><span id='topic+mthreshC'></span>

<h3>Description</h3>

<p>This function uses chi^2 statistics similar to Barber and Nason
(2004) to threshold wavelet coefficients based on their magnitude
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mthreshC(coeffv, Sigma, rl, po, ali, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mthreshC_+3A_coeffv">coeffv</code></td>
<td>

<p>A matrix of complex-valued wavelet coefficients (columns are
real and imaginary parts of the coefficients respectively).
</p>
</td></tr>
<tr><td><code id="mthreshC_+3A_sigma">Sigma</code></td>
<td>

<p>An array of dimension <code>2 x 2 x n</code> describing the covariance
between real and imaginary parts of the wavelet coefficients.
In particular, <code>Sigma[,,i]</code> represents the covariance between
real and imaginary parts of the <code>i</code>th lifted wavelet
coefficient (see <span class="env">rl</span> argument).
</p>
</td></tr>
<tr><td><code id="mthreshC_+3A_rl">rl</code></td>
<td>

<p>The removelist (trajectory of lifted points) corresponding to
a forward lifting transform.
</p>
</td></tr>
<tr><td><code id="mthreshC_+3A_po">po</code></td>
<td>

<p>A vector of indices describing the unlifted scaling
coefficients in a forward lifting transform.
</p>
</td></tr>
<tr><td><code id="mthreshC_+3A_ali">ali</code></td>
<td>

<p>A list of indices of observations, each entry corresponding
to an 'artificial level' (finest to coarsest), see <code><a href="adlift.html#topic+artlev">artlev</a></code>
for more details.
</p>
</td></tr>
<tr><td><code id="mthreshC_+3A_verbose">verbose</code></td>
<td>

<p>Indicates whether helpful messages should be printed to the
console during the procedure.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure in Downie and Silverman (1998) or Barber and Nason (2004) makes
use of the magnitude of wavelet coefficients to threshold them.
In particular, the covariance between the components of the
wavelet coefficients (contained in <span class="env">Sigma</span> is taken into account
to compute a thresholding statistic, the distribution of which is
chi-squared_2 distributed, see <code><a href="wavethresh.html#topic+cthresh">cthresh</a></code> for more details.  These
statistics are then compared with level-dependent universal
thresholds computed by counting the numnber of coefficients in
specific artificial levels.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>chi</code></td>
<td>
<p>the vector of chi-squared statistics used in the thresholding procedure.</p>
</td></tr>
<tr><td><code>coeffvt</code></td>
<td>
<p>the matrix of thresholded coefficients, columns representing
the real and imaginary components respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes, Marina Knight
</p>


<h3>References</h3>

<p>Hamilton, J., Knight, M. I., Nunes, M. A. and Fryzlewicz (2018)
Complex-valued wavelet lifting and applications. <em>Technometrics</em>, <b>60</b> (1), 48-60,DOI 10.1080/00401706.2017.1281846.
Barber, S. and Nason, G. P. (2004) Real nonparametric regression
using complex wavelets. <em>J. Roy. Stat. Soc. B</em> <b>66</b> (4), 927&ndash;939.
Downie, T. R. and Silverman, B. W. (1998) The discrete multiple
wavelet tranform and thresholding methods. <em>IEEE Trans. Sig.
Proc.</em> <b>46</b> 2558&ndash;2561.
</p>


<h3>See Also</h3>

<p><code><a href="wavethresh.html#topic+cthresh">cthresh</a></code>,
<code><a href="#topic+denoisepermC">denoisepermC</a></code>,
<code><a href="#topic+denoisepermCh">denoisepermCh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(adlift)

set.seed(100)

# construct an (irregular) sampling structure:

x&lt;-sort(runif(200))

g&lt;-make.signal2("bumps",x=x)

# generate IID noise with a particular sd
noise&lt;-rnorm(200,0,sd=0.5)

f&lt;-g+noise

# perform forward complex lifting transform

out&lt;-fwtnppermC(x,f,LocalPred=LinearPred,neigh=1)

# have a look at some of the coefficients

out$coeffv[1:10]

# extract lifting matrix and induced lifting variances
W &lt;- out$W

Gpre&lt;-tcrossprod(W,Conj(W))

indsd&lt;-sqrt(diag(Gpre))

# now estimate noise sd using the first artificial level:

al&lt;-artlev(out$lengthsremove,out$removelist)

fine&lt;-(out$coeffv/indsd)[al[[1]]]

varest&lt;-mad(Re(fine))^2

# now compute coefficient covariance structure, see
# Hamilton et al. (2018), Appendix B

C = varest * tcrossprod(W)
    G = varest * Gpre
    P = Conj(G) - t(Conj(C)) 
    Sigma &lt;- array(0, dim = c(2, 2, length(out$coeffv)))
    Sigma[1, 1, ] &lt;- diag(Re(G + C)/2)
    Sigma[2, 2, ] &lt;- diag(Re(G - C)/2)
    Sigma[1, 2, ] &lt;- -diag(Im(G - C)/2)
    Sigma[2, 1, ] &lt;- diag(Im(G + C)/2)

# now threshold complex coefficients according to this structure:

coeff.thresh&lt;-mthreshC(out$coeffv,Sigma,out$removelist,out$pointsin,al)

# have a look at some of these coefficients

coeff.thresh$coeffv[1:10]

</code></pre>

<hr>
<h2 id='orthpredfilters'>
Computes orthogonal filters
</h2><span id='topic+orthpredfilters'></span>

<h3>Description</h3>

<p>Given a filter L, finds a second filter M, orthogonal to L and with unit norm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthpredfilters(filter = c(0.5, 1, 0.5))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthpredfilters_+3A_filter">filter</code></td>
<td>
<p>An initial filter L</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Hamilton et al. (2018), section 2.2.
</p>


<h3>Value</h3>

<p>A matrix with two rows, the first row corresponding to L, the second corresponding to the orthogonal filter M.
</p>


<h3>Warning</h3>

<p>At present only works with odd length filters</p>


<h3>Author(s)</h3>

<p>Marina Knight, Matt Nunes
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fwtnppermC">fwtnppermC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a vector representing a filter for one neighbour either side of a removed point
# (equally weighted):

L = c(0.5, 1, 0.5)

# now work out a unit-norm filter orthogonal to L

out &lt;- orthpredfilters(L)

# M should be the second row:

out[2,]

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
