<!DOCTYPE html><html><head><title>Help for package bispdep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bispdep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#connectivity.map'><p>Map of spatial connectivity</p></a></li>
<li><a href='#correlogram'><p> Computes Moran's or Geary's coefficients on distance classes</p></a></li>
<li><a href='#correlogram.bi'><p> Computes Bivariate Moran's or Geary's coefficients on distance classes</p></a></li>
<li><a href='#geary.bi'><p>Compute Bivariate Geary's Cxy</p></a></li>
<li><a href='#gearybi.test'><p>Bivariate Geary's Cxy test for spatial autocorrelation</p></a></li>
<li><a href='#getis.cluster'><p>Getis and Ord's Gi* Cluster and Significance Map</p></a></li>
<li><a href='#localmoran.bi'><p>BiLISA - Bivariate Local Indicators of Spatial Association Moran's Ixy statistic</p></a></li>
<li><a href='#moran.bi'><p>Compute Bivariate Moran's Ixy</p></a></li>
<li><a href='#moran.cluster'><p>Maps of LISA clusters and statistical significance associated with LISA</p></a></li>
<li><a href='#moranbi.cluster'><p>Maps of BiLISA clusters and statistical significance associated with BiLISA</p></a></li>
<li><a href='#moranbi.mc'><p>Permutation test for bivariate Moran's Ixy statistic</p></a></li>
<li><a href='#moranbi.plot'><p>Bivariate Moran scatterplot</p></a></li>
<li><a href='#moranbi.test'><p>Moran's Ixy test for bivariate spatial autocorrelation</p></a></li>
<li><a href='#moranbir.test'><p>Moran's Ixy test using Monte Carlo permutations for bivariate spatial autocorrelation</p></a></li>
<li><a href='#randomize_vector'><p>Generate a random sample from other vector</p></a></li>
<li><a href='#spcorrelogram.bi'><p>Bivariate spatial correlogram</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Tools for Bivariate Spatial Dependence Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Carlos Melo <a href="https://orcid.org/0000-0002-5598-1913"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0), methods, spData, sf</td>
</tr>
<tr>
<td>Imports:</td>
<td>spdep, spatialreg, stats, combinat, boot (&ge; 1.3-1), graphics,
grDevices, ggplot2, sp (&ge; 1.0), RColorBrewer</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carlos Melo &lt;cmelo@udistrital.edu.co&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions to test spatial autocorrelation between variables, including Moran I, Geary C and Getis G together with scatter plots, functions for mapping and identifying clusters and outliers, functions associated with the moments of the previous statistics that will allow testing whether there is bivariate spatial autocorrelation, and a function that allows identifying (visualizing neighbours) on the map, the neighbors of any region once the scheme of the spatial weights matrix has been established.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-26 13:38:10 UTC; ASUS</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-27 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='connectivity.map'>Map of spatial connectivity</h2><span id='topic+connectivity.map'></span>

<h3>Description</h3>

<p>Generates a map of spatial connectivity according to a predefined neighborhood scheme, around a region selected by the user by clicking on the screen.</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectivity.map(nb,polygons,var.label,obs,col,cex, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connectivity.map_+3A_nb">nb</code></td>
<td>
<p>an object of class <code>nb</code> with a list of integer vectors containing neighbour region number ids</p>
</td></tr>
<tr><td><code id="connectivity.map_+3A_polygons">polygons</code></td>
<td>
<p>the spatial dataset: sf or SpatialPolygonsDataFrame (spdep)</p>
</td></tr>
<tr><td><code id="connectivity.map_+3A_var.label">var.label</code></td>
<td>
<p>variable to label in the connectivity neighborhood</p>
</td></tr>
<tr><td><code id="connectivity.map_+3A_obs">obs</code></td>
<td>
<p>number of the observation around which neighborhood connectivity will be performed. by default is NULL, the user can press the (first) mouse button over the map region for which he wishes to identify his neighborhood.</p>
</td></tr>
<tr><td><code id="connectivity.map_+3A_col">col</code></td>
<td>
<p>color to assign in the regions of the defined neighborhood</p>
</td></tr>
<tr><td><code id="connectivity.map_+3A_cex">cex</code></td>
<td>
<p>text size on neighborhood labels</p>
</td></tr>
<tr><td><code id="connectivity.map_+3A_...">...</code></td>
<td>
<p>further specifications, see plot_sf and plot and details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>around a region selected by the user by clicking on the screen
A spatial connectivity map showing the neighbors according to the weighting scheme.
</p>


<h3>See Also</h3>

<p><code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>, <code><a href="spdep.html#topic+knn2nb">knn2nb</a></code>, <code><a href="spdep.html#topic+graph2nb">graph2nb</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
#Queen neighbours
col_nbq1 &lt;- poly2nb(columbus)             # queen, order 1
col.lags10 &lt;- nblag(col_nbq1, 10)         # queen, up to order 10
connectivity.map(col.lags10[[1]],columbus,"COLUMBUS_I",obs=25,col="green",cex=0.5)

sf_obj &lt;- st_centroid(st_geometry(columbus), of_largest_polygon)
sp_obj &lt;- as(sf_obj, "Spatial")
coords &lt;- st_coordinates(sf_obj)

col.k4 &lt;- knn2nb(knearneigh(coords,4))
connectivity.map(col.k4,columbus,"COLUMBUS_I",obs=25,col="green",cex=0.5)

suppressMessages(trinb &lt;- tri2nb(coords))
connectivity.map(trinb,columbus,"COLUMBUS_I",obs=25,col="green",cex=0.5)

gabrielnb=graph2nb(gabrielneigh(coords),sym=TRUE)
connectivity.map(gabrielnb,columbus,"COLUMBUS_I",obs=25,col="green",cex=0.5)
</code></pre>

<hr>
<h2 id='correlogram'> Computes Moran's or Geary's coefficients on distance classes </h2><span id='topic+correlogram'></span><span id='topic+plot.correlogram'></span><span id='topic+print.correlogram'></span>

<h3>Description</h3>

<p>Computes Moran's or Geary's coefficients on distance classes from a set of spatial coordinates and corresponding z values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlogram(coords, z, method="Moran", nbclass = NULL, zero.policy=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlogram_+3A_coords">coords</code></td>
<td>
<p>a two columns array, data.frame or matrix of spatial coordinates. Column 1 = X, Column 2 = Y. </p>
</td></tr>
<tr><td><code id="correlogram_+3A_z">z</code></td>
<td>
<p> a vector for the values at each location. Must have the same length as the row number of coords </p>
</td></tr>
<tr><td><code id="correlogram_+3A_method">method</code></td>
<td>
<p> the method used. Must be &quot;Moran&quot; (default) or &quot;Geary&quot; </p>
</td></tr>
<tr><td><code id="correlogram_+3A_nbclass">nbclass</code></td>
<td>
<p>number of bins. If NULL Sturges method is used to compute an optimal number</p>
</td></tr>
<tr><td><code id="correlogram_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="correlogram_+3A_...">...</code></td>
<td>
<p>further arguments to pass to e.g. <code><a href="spdep.html#topic+moran.test">moran.test</a></code> or <code><a href="spdep.html#topic+geary.test">geary.test</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the library spdep including <code><a href="spdep.html#topic+moran.test">moran.test</a></code> or <code><a href="spdep.html#topic+geary.test">geary.test</a></code>. Distances are euclidian and in the same unit as the spatial coordinates.  Moran's Ho: I values larger than 0 due to chance; Geary's Ho: C values lesser than 1 due to chance. Correlog has print and plot methods; statistically significant values (p&lt;0.05) are plotted in red.
</p>


<h3>Value</h3>

<p>An object of class &quot;correlog&quot;, a matrix including:
</p>
<table>
<tr><td><code>class</code></td>
<td>
<p>bin centers</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>the coefficient values</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>probability of Ho </p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of pairs</p>
</td></tr>
<tr><td><code>low.l</code></td>
<td>
<p>bin lower limit</p>
</td></tr>
<tr><td><code>up.l</code></td>
<td>
<p>bin upper limit</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Computing can take a long time for large data sets</p>


<h3>References</h3>

<p>see library spdep</p>


<h3>See Also</h3>

 <p><code><a href="spdep.html#topic+geary.test">geary.test</a></code>, <code><a href="spdep.html#topic+moran.test">moran.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(spdep)
data(oldcol)
attach(COL.OLD)
coords&lt;-cbind(X,Y)
corM &lt;- correlogram(coords,CRIME,zero.policy=TRUE)
corM
plot(corM)

corG &lt;- correlogram(coords,CRIME,method="Geary",zero.policy=TRUE)
corG
plot(corG)

</code></pre>

<hr>
<h2 id='correlogram.bi'> Computes Bivariate Moran's or Geary's coefficients on distance classes </h2><span id='topic+correlogram.bi'></span><span id='topic+plot.correlogrambi'></span><span id='topic+print.correlogrambi'></span>

<h3>Description</h3>

<p>Computes Bivariate Moran's or Geary's coefficients on distance classes from a set of spatial coordinates and values of the two corresponding variables varX and varY.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlogram.bi(coords, varX, varY, method="Moran", nbclass = NULL, zero.policy=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlogram.bi_+3A_coords">coords</code></td>
<td>
<p>a two columns array, data.frame or matrix of spatial coordinates. Column 1 = X, Column 2 = Y. </p>
</td></tr>
<tr><td><code id="correlogram.bi_+3A_varx">varX</code></td>
<td>
<p>a vector for the values of the variable <code>x</code> at each location. Must have the same length as the row number of coords</p>
</td></tr>
<tr><td><code id="correlogram.bi_+3A_vary">varY</code></td>
<td>
<p>a vector for the values of the variable <code>y</code> at each location. Must have the same length as the row number of coords </p>
</td></tr>
<tr><td><code id="correlogram.bi_+3A_method">method</code></td>
<td>
<p> the method used. Must be &quot;Moran&quot; (default) or &quot;Geary&quot; </p>
</td></tr>
<tr><td><code id="correlogram.bi_+3A_nbclass">nbclass</code></td>
<td>
<p>number of bins. If NULL Sturges method is used to compute an optimal number</p>
</td></tr>
<tr><td><code id="correlogram.bi_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="correlogram.bi_+3A_...">...</code></td>
<td>
<p>further arguments to pass to e.g. <code><a href="#topic+moranbi.test">moranbi.test</a></code> or <code><a href="#topic+gearybi.test">gearybi.test</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the library bispdep including <code><a href="#topic+moranbi.test">moranbi.test</a></code> or <code><a href="#topic+gearybi.test">gearybi.test</a></code>. Distances are euclidian and in the same unit as the spatial coordinates.  Moran's Ho: I values larger than 0 due to chance; Geary's Ho: C values lesser than 1 due to chance, correlogram.bi has print and plot methods; statistically significant values (p&lt;0.05) are plotted in red.
</p>


<h3>Value</h3>

<p>An object of class &quot;correlog.bi&quot;, a matrix including:
</p>
<table>
<tr><td><code>class</code></td>
<td>
<p>bin centers</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>the coefficient values</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>probability of Ho </p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of pairs</p>
</td></tr>
<tr><td><code>low.l</code></td>
<td>
<p>bin lower limit</p>
</td></tr>
<tr><td><code>up.l</code></td>
<td>
<p>bin upper limit</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>Computing can take a long time for large data sets</p>


<h3>References</h3>

<p> see library bispdep </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gearybi.test">gearybi.test</a></code>, <code><a href="#topic+moranbi.test">moranbi.test</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
library(sf)
data(oldcol)
attach(COL.OLD)
coords&lt;-cbind(X,Y)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
plot(st_geometry(columbus))

corbiM &lt;- correlogram.bi(coords,columbus$CRIME,columbus$INC, zero.policy=TRUE)
corbiM
plot(corbiM)

corbiG &lt;- correlogram.bi(coords,columbus$CRIME,columbus$INC,method="Geary",zero.policy=TRUE)
corbiG
plot(corbiG)
</code></pre>

<hr>
<h2 id='geary.bi'>Compute Bivariate Geary's Cxy</h2><span id='topic+geary.bi'></span>

<h3>Description</h3>

<p>A simple function to compute Bivariate Geary's Cxy;
</p>
<p style="text-align: center;"><code class="reqn">C_{xy} = \frac{(n-1)}{2\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}}
\frac{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}(x_i-y_j)^2}{\sum_{i=1}^{n}(x_i - \bar{x})^2}
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>geary.bi(varX, varY, listw, zero.policy=NULL, adjust.n = TRUE,
         alternative = "greater")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geary.bi_+3A_varx">varX</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw with the values of the variable <code>x</code></p>
</td></tr>
<tr><td><code id="geary.bi_+3A_vary">varY</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw with the values of the variable <code>y</code></p>
</td></tr>
<tr><td><code id="geary.bi_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="geary.bi_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="geary.bi_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="geary.bi_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater (default), less or two.sided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with
</p>
<table>
<tr><td><code>C</code></td>
<td>
<p>Bivariate Geary's C</p>
</td></tr>
<tr><td><code>Kx</code></td>
<td>
<p>sample kurtosis of <code>x</code></p>
</td></tr>
<tr><td><code>Ky</code></td>
<td>
<p>sample kurtosis of <code>y</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Wartenberg, Daniel. 2010. Multivariate Spatial Correlation: A Method for Exploratory Geographical Analysis. Geographical Analysis. 17. 263 - 283. 10.1111/j.1538-4632.1985.tb00849.x.</p>


<h3>See Also</h3>

<p><code><a href="#topic+gearybi.test">gearybi.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(oldcol)
col.W &lt;- nb2listw(COL.nb, style="W")
geary.bi(COL.OLD$CRIME, COL.OLD$INC, col.W, zero.policy = TRUE)
</code></pre>

<hr>
<h2 id='gearybi.test'>Bivariate Geary's Cxy test for spatial autocorrelation</h2><span id='topic+gearybi.test'></span>

<h3>Description</h3>

<p>Bivariate Geary's test for spatial autocorrelation using a spatial weights matrix in weights list form. The assumptions underlying the test are sensitive to the form of the graph of neighbour relationships and other factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gearybi.test(varX, varY, listw, randomisation=TRUE, zero.policy=NULL,
    alternative="greater", spChk=NULL, adjust.n=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gearybi.test_+3A_varx">varX</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw with the values of the variable X</p>
</td></tr>
<tr><td><code id="gearybi.test_+3A_vary">varY</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw with the values of the variable Y</p>
</td></tr>
<tr><td><code id="gearybi.test_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="gearybi.test_+3A_randomisation">randomisation</code></td>
<td>
<p>variance of I calculated under the assumption of randomisation, if FALSE normality</p>
</td></tr>
<tr><td><code id="gearybi.test_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="gearybi.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;less&quot; or &quot;two.sided&quot;.</p>
</td></tr>
<tr><td><code id="gearybi.test_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="gearybi.test_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the standard deviate of Geary's Cxy, in the order given in Cliff and Ord 1973, p. 21, which is (ECxy - Cxy) / sqrt(VCxy), that is with the sign reversed with respect to the more usual (Cxy - ECxy) / sqrt(VCxy); this means that the &ldquo;greater&rdquo; alternative for the Bivariate Geary Cxy test corresponds to the &ldquo;greater&rdquo; alternative for Bivariate Moran's Ixy test.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed BIvariate Geary's Cxy, its expectation and
variance under the method assumption.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the assumption used for calculating
the standard deviate.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The derivation of the test (Cliff and Ord, 1981, p. 18) assumes that the weights matrix is symmetric. For inherently non-symmetric matrices, such as k-nearest neighbour matrices, <code>listw2U()</code> can be used to make the matrix symmetric. In non-symmetric weights matrix cases, the variance of the test statistic may be negative (thanks to Franz Munoz I for a well documented bug report). Geary's C is affected by non-symmetric weights under normality much more than Moran's I. From 0.4-35, the sign of the standard deviate of C is changed to match Cliff and Ord (1973, p. 21).
</p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 21, Cliff, A. D., Ord, J. K. 1973 Spatial Autocorrelation, Pion, pp. 15-16, 21; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+geary.bi">geary.bi</a></code>, <code><a href="spdep.html#topic+listw2U">listw2U</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(oldcol)
gearybi.test(COL.OLD$CRIME,COL.OLD$INC,nb2listw(COL.nb,style="W"),zero.policy=TRUE)
gearybi.test(COL.OLD$CRIME,COL.OLD$INC,nb2listw(COL.nb,style="W"),zero.policy=TRUE,
             randomisation=FALSE)
colold.lags &lt;- nblag(COL.nb, 3)
gearybi.test(COL.OLD$CRIME,COL.OLD$INC,nb2listw(colold.lags[[2]],style="W"),
             zero.policy=TRUE)
gearybi.test(COL.OLD$CRIME,COL.OLD$INC,nb2listw(colold.lags[[3]],style="W"),
             zero.policy=TRUE,alternative="greater")
print(is.symmetric.nb(COL.nb))
coords.OLD &lt;- cbind(COL.OLD$X, COL.OLD$Y)
COL.k4.nb &lt;- knn2nb(knearneigh(coords.OLD, 4))
print(is.symmetric.nb(COL.k4.nb))
gearybi.test(COL.OLD$CRIME,COL.OLD$INC,nb2listw(COL.k4.nb,style="W"),zero.policy=TRUE)
gearybi.test(COL.OLD$CRIME,COL.OLD$INC,nb2listw(COL.k4.nb,style="W"),zero.policy=TRUE,
             randomisation=FALSE)
cat("Note non-symmetric weights matrix - use listw2U()\n")
gearybi.test(COL.OLD$CRIME,COL.OLD$INC,listw2U(nb2listw(COL.k4.nb,style="W")),
             zero.policy=TRUE)
gearybi.test(COL.OLD$CRIME,COL.OLD$INC,listw2U(nb2listw(COL.k4.nb,style="W")),
             zero.policy=TRUE,randomisation=FALSE)
</code></pre>

<hr>
<h2 id='getis.cluster'>Getis and Ord's Gi* Cluster and Significance Map</h2><span id='topic+getis.cluster'></span>

<h3>Description</h3>

<p>Create the Getis Gi* Cluster Map and the corresponding Significance Map.
Maps are done calculating the Local Gi* (localG - spdep) for each
spatial unit and testing its significance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getis.cluster(x, listw, zero.policy = NULL, polygons, significant = TRUE, pleg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getis.cluster_+3A_x">x</code></td>
<td>
<p>variable to create cluster and significance map</p>
</td></tr>
<tr><td><code id="getis.cluster_+3A_listw">listw</code></td>
<td>
<p>a neighbours list with spatial weights. From package spdep:
a listw object. Use poly2nb (class nb)
and nb2listw (class listw, nb) from package spdep. Can be any type of listw
object, for instance, rook contiguity (common edge) or queen contiguity (common
edge or common vertex)</p>
</td></tr>
<tr><td><code id="getis.cluster_+3A_zero.policy">zero.policy</code></td>
<td>
<p>by default = NULL, if FALSE stop with error for any empty
neighbour sets, if TRUE permit the weights list to be formed with zero-length
weights vectors. Parameter inherited from the spdep package.</p>
</td></tr>
<tr><td><code id="getis.cluster_+3A_polygons">polygons</code></td>
<td>
<p>SpatialPolygons, SpatialPolygonsDataFrame or sfc_POLYGON object</p>
</td></tr>
<tr><td><code id="getis.cluster_+3A_significant">significant</code></td>
<td>
<p>by default is TRUE, if FALSE the significant map is not created</p>
</td></tr>
<tr><td><code id="getis.cluster_+3A_pleg">pleg</code></td>
<td>
<p>the x and y co-ordinates to be used to position the legend. They can be specified by keyword or in any way which is accepted by <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code></p>
</td></tr>
<tr><td><code id="getis.cluster_+3A_...">...</code></td>
<td>
<p>other graphical parameters as in <code>par(..)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the function localG (spdep) create the Getis Gi* Cluster Map and the
corresponding Significance Map.
The significance map is done testing the null hypothesis (Ho) of zero spatial
autocorrelation for each spatial unit, then plotting a choropleth map with this
legend values: (Not Significant, p-value=0.05, p-value= 0.01, p-value=0.001,
p-value=0.0001, and Neighborless). Most significant clustered spatial units are
those with p-values smaller than 0.0001. Not significant
clustered spatial units are those with p-values grather than 0.05. Gi* Cluster Map
is done based on the significance map, but the choropleth legend is different (Not
- Significant, High-High, Low-Low, Low-High, High-Low, and Neighborless).
</p>


<h3>Value</h3>

<p>one or two maps
</p>


<h3>Links</h3>


<ol>
<li> <p><a href="https://pysal.org/esda/notebooks/spatialautocorrelation.html">Spatial Autocorrelation</a>
</p>
</li></ol>



<h3>See Also</h3>


<ul>
<li><p> Bivariate Moran's Ixy: <code><a href="#topic+moran.bi">moran.bi</a></code>
</p>
</li>
<li><p> Plot Bivariate Moran's Ixy: <code><a href="#topic+moranbi.plot">moranbi.plot</a></code>
</p>
</li>
<li><p> Bivariate Moran's Ixy Test: <code><a href="#topic+moranbi.test">moranbi.test</a></code>
</p>
</li>
<li><p> Bivariate Local Moran's Ixy and Test: <code><a href="#topic+localmoran.bi">localmoran.bi</a></code>
</p>
</li>
<li><p> Create object &quot;nb&quot;: <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>
</p>
</li>
<li><p> Create object &quot;listw&quot;/&quot;nb&quot;: <code><a href="spdep.html#topic+nb2listw">nb2listw</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col_nbq &lt;- poly2nb(columbus)
a.lw &lt;- nb2listw(col_nbq, style="W")
getis.cluster(columbus$CRIME, a.lw, zero.policy = FALSE, st_geometry(columbus),
              significant=TRUE, pleg = "topleft")

</code></pre>

<hr>
<h2 id='localmoran.bi'>BiLISA - Bivariate Local Indicators of Spatial Association Moran's Ixy statistic</h2><span id='topic+localmoran.bi'></span><span id='topic+localmoran_perm'></span>

<h3>Description</h3>

<p>The bivariate local spatial statistic Moran's I is calculated for each zone based on the spatial weights object used. The values returned include a Z-value, and may be used as a diagnostic tool. The statistic is:
</p>
<p style="text-align: center;"><code class="reqn">I(i)_{xy} = \frac{(x_i-\bar{x})}{{\sum_{k=1}^{n}(x_k-\bar{x})^2}/(n-1)}{\sum_{j=1}^{n}w_{ij}(y_j-\bar{y})}</code>
</p>
<p>, and its expectation and variance were given in Anselin (1995), but those from Sokal et al. (1998) are implemented here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localmoran.bi(varX,varY,listw,zero.policy=NULL,na.action=na.fail,conditional=TRUE,
              alternative="two.sided",mlvar=TRUE,spChk=NULL,adjust.x=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localmoran.bi_+3A_varx">varX</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw and <code>y</code>, with the values of the primary variable <code>x</code></p>
</td></tr>
<tr><td><code id="localmoran.bi_+3A_vary">varY</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw and <code>x</code>, with the values of the secundary variable <code>y</code></p>
</td></tr>
<tr><td><code id="localmoran.bi_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code> with spatial weights</p>
</td></tr>
<tr><td><code id="localmoran.bi_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA and stop with error for any empty neighbours sets.</p>
</td></tr>
<tr><td><code id="localmoran.bi_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. Similar meaning and values than parameter <code>na.action</code> of <code><a href="spdep.html#topic+localmoran">localmoran</a></code></p>
</td></tr>
<tr><td><code id="localmoran.bi_+3A_conditional">conditional</code></td>
<td>
<p>default TRUE: expectation and variance are calculated using the conditional randomization null (Sokal 1998 Eqs. A7 &amp; A8). Elaboration of these changes available in Sauer et al. (2021). If FALSE: expectation and variance are calculated using the total randomization null (Sokal 1998 Eqs. A3 &amp; A4).</p>
</td></tr>
<tr><td><code id="localmoran.bi_+3A_alternative">alternative</code></td>
<td>
<p>type of specifying the alternative hypothesis test, must be one of greater, less or two.sided (default).</p>
</td></tr>
<tr><td><code id="localmoran.bi_+3A_mlvar">mlvar</code></td>
<td>
<p>default TRUE: values of local Moran's I are reported using the variance of the variable of interest (sum of squared deviances over n), but can be reported as the sample variance, dividing by (n-1) instead; both are used in other implementations.</p>
</td></tr>
<tr><td><code id="localmoran.bi_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="localmoran.bi_+3A_adjust.x">adjust.x</code></td>
<td>
<p>default FALSE, if TRUE, x values of observations with no neighbours are omitted in the mean of x</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of local Moran's I are divided by the variance (or sample variance) of the variable of interest to accord with Table 1, p. 103, and formula (12), p. 99, in Anselin (1995), rather than his formula (7), p. 98. The variance of the local Moran statistic is taken from Sokal et al. (1998) p. 334, equations 4 &amp; 5 or equations 7 &amp; 8 located depending on user specification. By default, the implementation divides by n, not (n-1) in calculating the variance and higher moments. Conditional code contributed by Jeff Sauer and Levi Wolf.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Iyxi</code></td>
<td>
<p>local moran statistic</p>
</td></tr>
<tr><td><code>E.Iyxi</code></td>
<td>
<p>expectation of local moran statistic; for <code>localmoran_perm</code>the permutation sample means</p>
</td></tr>
<tr><td><code>Var.Iyxi</code></td>
<td>
<p>variance of local moran statistic; for <code>localmoran_perm</code>the permutation sample standard deviations</p>
</td></tr>
<tr><td><code>Z.Iyxi</code></td>
<td>
<p>standard deviate of local moran statistic; for <code>localmoran_perm</code> based on permutation sample means and standard deviations</p>
</td></tr>
<tr><td><code>Pr()</code></td>
<td>
<p>p-value of local moran statistic using <code>pnorm()</code>; for <code>localmoran_perm</code> using standard deviatse based on permutation sample means and standard deviations</p>
</td></tr>
<tr><td><code>Pr() Sim</code></td>
<td>
<p>For <code>localmoran_perm</code>, <code>rank()</code> and <code>punif()</code> of observed statistic rank for [0, 1] p-values using <code>alternative=</code></p>
</td></tr>
<tr><td><code>Pr(folded) Sim</code></td>
<td>
<p>the simulation folded [0, 0.5] range ranked p-value (based on <a href="https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213">https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213</a>)</p>
</td></tr>
<tr><td><code>Skewness</code></td>
<td>
<p>For <code>localmoran_perm</code>, the output of <code>e1071::skewness()</code> for the permutation samples underlying the standard deviates</p>
</td></tr>
<tr><td><code>Kurtosis</code></td>
<td>
<p>For <code>localmoran_perm</code>, the output of <code>e1071::kurtosis()</code> for the permutation samples underlying the standard deviates</p>
</td></tr>
</table>
<p>In addition, an attribute data frame <code>"quadr"</code> with mean and median quadrant columns, and a column splitting on the demeaned variable and lagged demeaned variable at zero.
</p>


<h3>Note</h3>

<p>Conditional permutations added for comparative purposes; permutations are over the whole data vector omitting the observation itself. For p-value adjustment, use <code>p.adjust()</code> or <code>p.adjustSP()</code> on the output vector.</p>


<h3>References</h3>

<p>Getis, A. and Ord, J. K. 1996 Local spatial
statistics: an overview. In P. Longley and M. Batty (eds) <em>Spatial
analysis: modelling in a GIS environment</em> (Cambridge: Geoinformation International), 261&ndash;277; Sokal, R. R, Oden, N. L. and Thomson, B. A. 1998. Local Spatial Autocorrelation in a Biological Model. Geographical Analysis, 30. 331&ndash;354;
Czaplewski, R.L., Reich, R.M. 1993. Expected value and variance of Moran's bivariate spatial autocorrelation statistic for a permutation test, Research paper RM-309, Fort Collins, CO U.S. Department of Agriculture, Forest Service, Rocky Mountain Forest and Range Experiment Station, p, 13.;
Anselin, Luc, Ibnu Syabri, and Oleg Smirnov. 2002. “Visualizing Multivariate Spatial Correlation with Dynamically Linked Windows.” In New Tools for Spatial Data Analysis: Proceedings of the Specialist Meeting, edited by Luc Anselin and Sergio Rey. University of California, Santa Barbara: Center for Spatially Integrated Social Science (CSISS)
</p>


<h3>See Also</h3>

<p><code><a href="spdep.html#topic+localG">localG</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
# load columbus data
data(columbus)
data(oldcol)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col_nbq &lt;- poly2nb(columbus)
a.lw &lt;- nb2listw(col_nbq, style="W")
localmoran.bi(columbus$CRIME, columbus$HOVAL, a.lw, zero.policy=TRUE,
              alternative="two.sided")
</code></pre>

<hr>
<h2 id='moran.bi'>Compute Bivariate Moran's Ixy</h2><span id='topic+moran.bi'></span>

<h3>Description</h3>

<p>A simple function to compute bivariate Moran's Ixy, called by <code>moranbi.test</code> and <code>moranbi.mc</code>;
</p>
<p style="text-align: center;"><code class="reqn">I = \frac{n}{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}}
\frac{\sum_{i=1}^{n}\sum_{j=1}^{n}w_{ij}(x_i-\bar{x})(y_j-\bar{y})}{\sum_{i=1}^{n}(x_i - \bar{x})^2}
</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>moran.bi(varX, varY, listw, zero.policy=NULL, adjust.n = TRUE, NAOK=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran.bi_+3A_varx">varX</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw with the values of the variable <code>x</code></p>
</td></tr>
<tr><td><code id="moran.bi_+3A_vary">varY</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw with the values of the variable <code>y</code></p>
</td></tr>
<tr><td><code id="moran.bi_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="moran.bi_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="moran.bi_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="moran.bi_+3A_naok">NAOK</code></td>
<td>
<p>if 'TRUE' then any 'NA' or 'NaN' or 'Inf' values in x are passed on to the foreign function.  If 'FALSE', the presence of 'NA' or 'NaN' or 'Inf' values is regarded as an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of
</p>
<table>
<tr><td><code>I</code></td>
<td>
<p>Bivariate Moran's I</p>
</td></tr>
<tr><td><code>Kx</code></td>
<td>
<p>sample kurtosis of the variable X</p>
</td></tr>
<tr><td><code>Ky</code></td>
<td>
<p>sample kurtosis of the variable Y</p>
</td></tr>
</table>


<h3>References</h3>

<p>Czaplewski, R.L., Reich, R.M. 1993. Expected value and variance of Moran's bivariate spatial autocorrelation statistic for a permutation test, Research paper RM-309, Fort Collins, CO U.S. Department of Agriculture, Forest Service, Rocky Mountain Forest and Range Experiment Station, p, 13.</p>


<h3>See Also</h3>

<p><code><a href="#topic+moranbi.test">moranbi.test</a></code>, <code><a href="#topic+moranbi.mc">moranbi.mc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(oldcol)
col.W &lt;- nb2listw(COL.nb, style="W")
crime &lt;- COL.OLD$CRIME
inc &lt;- COL.OLD$INC
str(moran.bi(crime, inc, col.W, zero.policy = TRUE, NAOK=FALSE))
set.seed(123)
is.na(crime) &lt;- sample(1:length(crime), 5)
is.na(inc) &lt;- sample(1:length(inc), 10)
str(moran.bi(crime, inc, col.W, zero.policy = TRUE, NAOK=TRUE))
</code></pre>

<hr>
<h2 id='moran.cluster'>Maps of LISA clusters and statistical significance associated with LISA</h2><span id='topic+moran.cluster'></span>

<h3>Description</h3>

<p>Using the <code>localmoran</code> function, create a Local Indicators of Spatial Association (LISA) cluster map and corresponding significance map. The maps are made by calculating the LISAs from <code>localmoran</code> for each of the spatial units and then the statistical significance is evaluated to determine the spatial clusters and outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moran.cluster(x, listw, zero.policy = NULL, polygons, conditional=TRUE,
                significant = TRUE, alternative = "two.sided", pleg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moran.cluster_+3A_x">x</code></td>
<td>
<p>variable to create cluster and significance map</p>
</td></tr>
<tr><td><code id="moran.cluster_+3A_listw">listw</code></td>
<td>
<p>a neighbours list with spatial weights. From package spdep:
a listw object. Use <code>poly2nb</code> (class <code>nb</code>)
and <code>nb2listw</code> (class <code>listw</code>, <code>nb</code>) from package spdep. Can be any type of listw
object, for instance, rook contiguity (common edge) or queen contiguity (common
edge or common vertex)</p>
</td></tr>
<tr><td><code id="moran.cluster_+3A_zero.policy">zero.policy</code></td>
<td>
<p>by default = NULL, if FALSE stop with error for any empty
neighbour sets, if TRUE permit the weights list to be formed with zero-length
weights vectors. Parameter inherited from the <code>spdep</code> package.</p>
</td></tr>
<tr><td><code id="moran.cluster_+3A_polygons">polygons</code></td>
<td>
<p>SpatialPolygons, SpatialPolygonsDataFrame or sfc_POLYGON object</p>
</td></tr>
<tr><td><code id="moran.cluster_+3A_conditional">conditional</code></td>
<td>
<p>default TRUE: expectation and variance are calculated using the conditional randomization null (Sokal 1998 Eqs. A7 &amp; A8). Elaboration of these changes available in Sauer et al. (2021). If FALSE: expectation and variance are calculated using the total randomization null (Sokal 1998 Eqs. A3 &amp; A4).</p>
</td></tr>
<tr><td><code id="moran.cluster_+3A_significant">significant</code></td>
<td>
<p>by default is TRUE, if FALSE the significant map is not created</p>
</td></tr>
<tr><td><code id="moran.cluster_+3A_alternative">alternative</code></td>
<td>
<p>by default is &quot;two.sided&quot;. Type of alternative hypothesis test.
Other values are &quot;less&quot; or &quot;greater&quot;.</p>
</td></tr>
<tr><td><code id="moran.cluster_+3A_pleg">pleg</code></td>
<td>
<p>the x and y co-ordinates to be used to position the legend. They can be specified by keyword or in any way which is accepted by <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code></p>
</td></tr>
<tr><td><code id="moran.cluster_+3A_...">...</code></td>
<td>
<p>other graphical parameters as in <code>par(..)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the function <code>localmoran</code> create the Local Indicators of Spatial
Association - LISA Cluster Map and the corresponding Significance Map.
The significance map is done testing the null hypothesis (Ho) of zero spatial
autocorrelation for each spatial unit and then plotting a choropleth map with this
legend values: (Not Significant, p-value=0.05, p-value= 0.01, p-value=0.001,
p-value=0.0001, and Neighborless). Maps can represent concentrations of similar (cluster)
or dissimilar values (spatial outliers). Most significant clustered spatial units are
those with p-values smaller than 0.0001. Not significant clustered spatial units are
those with p-values greater than 0.05. LISA Cluster Map is done based on the
significance map but the choropleth legend is different (Not - Significant, High-High, Low-Low,
Low-High, High-Low, and Neighborless).
</p>


<h3>Value</h3>

<p>two maps
</p>


<h3>Links</h3>


<ol>
<li> <p><a href="https://en.wikipedia.org/wiki/Indicators_of_spatial_association">Indicators of Spatial Association</a>
</p>
</li></ol>



<h3>See Also</h3>


<ul>
<li><p> Bivariate Moran's Ixy: <code><a href="#topic+moran.bi">moran.bi</a></code>
</p>
</li>
<li><p> Plot Bivariate Moran's Ixy: <code><a href="#topic+moranbi.plot">moranbi.plot</a></code>
</p>
</li>
<li><p> Bivariate Moran's Ixy Test: <code><a href="#topic+moranbi.test">moranbi.test</a></code>
</p>
</li>
<li><p> Create object &quot;nb&quot;: <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>
</p>
</li>
<li><p> Create object &quot;listw&quot;/&quot;nb&quot;: <code><a href="spdep.html#topic+nb2listw">nb2listw</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(columbus)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
plot(st_geometry(columbus))
col_nbq &lt;- poly2nb(columbus)
a.lw &lt;- nb2listw(col_nbq, style="W")
moran.cluster(columbus$CRIME, a.lw, zero.policy = FALSE, st_geometry(columbus),
              significant=TRUE,pleg = "topleft")
moran.cluster(columbus$CRIME, a.lw, zero.policy = FALSE, st_geometry(columbus),
              significant=TRUE,alternative="greater",pleg = "topleft")
</code></pre>

<hr>
<h2 id='moranbi.cluster'>Maps of BiLISA clusters and statistical significance associated with BiLISA</h2><span id='topic+moranbi.cluster'></span>

<h3>Description</h3>

<p>Using the <code>localmoran.bi</code> function, create a Bivariate Local Indicators of Spatial Association (BiLISA) cluster map and corresponding significance map. The maps are made by calculating the BiLISAs from <code>localmoran.bi</code> for each of the spatial units and then the statistical significance is evaluated to determine the spatial clusters and outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moranbi.cluster(varY, varX, listw, zero.policy = NULL, polygons, conditional=TRUE,
                significant = TRUE, alternative = "two.sided", pleg, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moranbi.cluster_+3A_vary">varY</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw and <code>x</code>, with the values of the secundary variable <code>y</code></p>
</td></tr>
<tr><td><code id="moranbi.cluster_+3A_varx">varX</code></td>
<td>
<p>a numeric vector the same length as the neighbours list in listw and <code>y</code>, with the values of the primary variable <code>x</code></p>
</td></tr>
<tr><td><code id="moranbi.cluster_+3A_listw">listw</code></td>
<td>
<p>a neighbours list with spatial weights. From package spdep:
a listw object. Use <code>poly2nb</code> (class <code>nb</code>)
and <code>nb2listw</code> (class <code>listw</code>, <code>nb</code>) from package spdep. Can be any type of listw
object, for instance, rook contiguity (common edge) or queen contiguity (common
edge or common vertex)</p>
</td></tr>
<tr><td><code id="moranbi.cluster_+3A_zero.policy">zero.policy</code></td>
<td>
<p>by default = NULL, if FALSE stop with error for any empty
neighbour sets, if TRUE permit the weights list to be formed with zero-length
weights vectors. Parameter inherited from the <code>spdep</code> package.</p>
</td></tr>
<tr><td><code id="moranbi.cluster_+3A_polygons">polygons</code></td>
<td>
<p>SpatialPolygons, SpatialPolygonsDataFrame or sfc_POLYGON object</p>
</td></tr>
<tr><td><code id="moranbi.cluster_+3A_conditional">conditional</code></td>
<td>
<p>default TRUE: expectation and variance are calculated using the conditional randomization null (Sokal 1998 Eqs. A7 &amp; A8). Elaboration of these changes available in Sauer et al. (2021). If FALSE: expectation and variance are calculated using the total randomization null (Sokal 1998 Eqs. A3 &amp; A4).</p>
</td></tr>
<tr><td><code id="moranbi.cluster_+3A_significant">significant</code></td>
<td>
<p>by default is TRUE, if FALSE the significant map is not created</p>
</td></tr>
<tr><td><code id="moranbi.cluster_+3A_alternative">alternative</code></td>
<td>
<p>by default is &quot;two.sided&quot;. Type of alternative hypothesis test.
Other values are &quot;less&quot; or &quot;greater&quot;.</p>
</td></tr>
<tr><td><code id="moranbi.cluster_+3A_pleg">pleg</code></td>
<td>
<p>the x and y co-ordinates to be used to position the legend. They can be specified by keyword or in any way which is accepted by <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code></p>
</td></tr>
<tr><td><code id="moranbi.cluster_+3A_...">...</code></td>
<td>
<p>other parameters similar to internal function <code><a href="spdep.html#topic+moran">moran</a></code> and other graphical parameters as in <code>par(..)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the function <code>localmoran.bi</code> create the Bivariate Local Indicators of Spatial
Association - BiLISA Cluster Map and the corresponding Significance Map.
The significance map is done testing the null hypothesis (Ho) of zero spatial
autocorrelation for each spatial unit and then plotting a choropleth map with this
legend values: (Not Significant, p-value=0.05, p-value= 0.01, p-value=0.001,
p-value=0.0001, and Neighborless). Maps can represent concentrations of similar (cluster)
or dissimilar values (spatial outliers). Most significant clustered spatial units are
those with p-values smaller than 0.0001. Not significant clustered spatial units are
those with p-values greater than 0.05. BiLISA Cluster Map is done based on the
significance map but the choropleth legend is different (Not - Significant, High-High, Low-Low, Low-High, High-Low, and Neighborless).
</p>


<h3>Value</h3>

<p>one or two maps
</p>


<h3>Links</h3>


<ol>
<li> <p><a href="https://en.wikipedia.org/wiki/Indicators_of_spatial_association">Indicators of Spatial Association</a>
</p>
</li></ol>



<h3>See Also</h3>


<ul>
<li><p> Bivariate Moran's Ixy: <code><a href="#topic+moran.bi">moran.bi</a></code>
</p>
</li>
<li><p> Plot Bivariate Moran's Ixy: <code><a href="#topic+moranbi.plot">moranbi.plot</a></code>
</p>
</li>
<li><p> Bivariate Moran's Ixy Test: <code><a href="#topic+moranbi.test">moranbi.test</a></code>
</p>
</li>
<li><p> Create object &quot;nb&quot;: <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>
</p>
</li>
<li><p> Create object &quot;listw&quot;/&quot;nb&quot;: <code><a href="spdep.html#topic+nb2listw">nb2listw</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(columbus)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
plot(st_geometry(columbus))
col_nbq &lt;- poly2nb(columbus)
a.lw &lt;- nb2listw(col_nbq, style="W")
moranbi.cluster(columbus$CRIME, columbus$HOVAL, a.lw, zero.policy = FALSE,
                conditional=TRUE, st_geometry(columbus), significant=TRUE,
                pleg = "topleft")
moranbi.cluster(columbus$CRIME, columbus$HOVAL, a.lw, zero.policy = FALSE,
                st_geometry(columbus), significant=TRUE, alternative="greater",
                pleg = "topleft")
</code></pre>

<hr>
<h2 id='moranbi.mc'>Permutation test for bivariate Moran's Ixy statistic</h2><span id='topic+moranbi.mc'></span>

<h3>Description</h3>

<p>A permutation test for bivariate Moran's Ixy statistic calculated by using nsim random permutations of <code>x</code> and <code>y</code> for the given spatial weighting scheme, to establish the rank of the observed statistic in relation to the nsim simulated values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moranbi.mc(varX, varY, listw, nsim, zero.policy=NULL, alternative="greater",
           na.action=na.fail, spChk=NULL, return_boot=FALSE, adjust.n=TRUE, parallel="no",
           ncpus = getOption("boot.ncpus", 1L), cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moranbi.mc_+3A_varx">varX</code></td>
<td>
<p>a numeric vector of the variable <code>x</code> the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_vary">varY</code></td>
<td>
<p>a numeric vector of the variable <code>y</code> the same length as the neighbours list in listw</p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_nsim">nsim</code></td>
<td>
<p>number of permutations</p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;greater&quot; (default), &quot;two.sided&quot;, or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_na.action">na.action</code></td>
<td>
<p>a function (default <code>na.fail</code>), can also be <code>na.omit</code> or <code>na.exclude</code> - in these cases the weights list will be subsetted to remove NAs in the data. It may be necessary to set zero.policy to TRUE because this subsetting may create no-neighbour observations. Note that only weights lists created without using the glist argument to <code>nb2listw</code> may be subsetted. <code>na.pass</code> is not permitted because it is meaningless in a permutation test.</p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_return_boot">return_boot</code></td>
<td>
<p>return an object of class <code>boot</code> from the equivalent permutation bootstrap rather than an object of class <code>htest</code></p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_parallel">parallel</code></td>
<td>
<p>The type of parallel operation to be used (if any). If missing, the default is &quot;no&quot;. for more details see <code><a href="boot.html#topic+boot">boot</a></code></p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_ncpus">ncpus</code></td>
<td>
<p>integer: number of processes to be used in parallel operation: number of available CPUs. By default it is set to 1 with getOption(&quot;boot.ncpus&quot;, 1L)</p>
</td></tr>
<tr><td><code id="moranbi.mc_+3A_cl">cl</code></td>
<td>
<p>An optional parallel or snow cluster for use if <code>parallel</code> = &quot;<code>snow</code>&quot;. If not supplied, a cluster on the local machine is created for the duration of the <code>boot</code> call (by default is NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> and <code>mc.sim</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the observed bivariate Moran's I.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the rank of the observed bivariate Moran's I.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the pseudo p-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the method used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data, and the number of simulations.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>nsim simulated values of statistic, final value is observed statistic</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 63-5.</p>


<h3>See Also</h3>

<p><code><a href="#topic+moran.bi">moran.bi</a></code>, <code><a href="#topic+moranbi.test">moranbi.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(oldcol)
colw &lt;- nb2listw(COL.nb, style="W")
nsim &lt;- 999
set.seed(123)
sim1 &lt;- moranbi.mc(COL.OLD$CRIME, COL.OLD$INC, listw=colw, nsim=nsim, zero.policy=TRUE)
sim1
mean(sim1$res[1:nsim])
var(sim1$res[1:nsim])
summary(sim1$res[1:nsim])


colold.lags &lt;- nblag(COL.nb, 3)
set.seed(1234)
sim2 &lt;- moranbi.mc(COL.OLD$CRIME, COL.OLD$INC, nb2listw(colold.lags[[2]],style="W"),
                   nsim=nsim, zero.policy=TRUE)
summary(sim2$res[1:nsim])
sim3 &lt;- moranbi.mc(COL.OLD$CRIME, COL.OLD$INC, nb2listw(colold.lags[[3]],style="W"),
                   nsim=nsim, zero.policy=TRUE)
summary(sim3$res[1:nsim])
sim4 &lt;- moranbi.mc(COL.OLD$CRIME, COL.OLD$INC, colw, nsim=nsim, zero.policy=TRUE,
                   return_boot=TRUE,parallel="multicore")
sim4

</code></pre>

<hr>
<h2 id='moranbi.plot'>Bivariate Moran scatterplot</h2><span id='topic+moranbi.plot'></span>

<h3>Description</h3>

<p>A plot of spatial data of the variable &quot;varY&quot; against the spatially lagged values of the variable &quot;varX&quot;, augmented by reporting the summary of influence measures for the linear relationship between the data of &quot;varY&quot; and the lag of &quot;varX&quot; &quot;. If policy zero is TRUE, such observations are also flagged if they occur.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moranbi.plot(varY, varX, listw, zero.policy=NULL, spChk=NULL, labels=NULL,
 xlab=NULL, ylab=NULL, quiet=NULL, plot=TRUE, return_df=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moranbi.plot_+3A_varx">varX</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw with the values of the variable <code>x</code></p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_vary">varY</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw with the values of the variable <code>y</code></p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_labels">labels</code></td>
<td>
<p>character labels for points with high influence measures, if set to FALSE, no labels are plotted for points with large influence</p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis</p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_ylab">ylab</code></td>
<td>
<p>label for x axis</p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_quiet">quiet</code></td>
<td>
<p>default NULL, use !verbose global option value; if TRUE, output of summary of influence object suppressed</p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_plot">plot</code></td>
<td>
<p>default is TRUE, to suppress the plotting use FALSE</p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_return_df">return_df</code></td>
<td>
<p>default TRUE, invisibly return a data.frame object; if FALSE invisibly return an influence measures object</p>
</td></tr>
<tr><td><code id="moranbi.plot_+3A_...">...</code></td>
<td>
<p>other graphical parameters as in <code>par(..)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data.frame object with coordinates and influence measures if <code>return_df</code> is TRUE, or an influence object from <code>influence.measures</code>.
</p>


<h3>References</h3>

<p>Matkan, A.A., Shahri, M. and Mirzaie, M., 2013, September. Bivariate Moran’s I and LISA to explore the crash risky locations in urban areas. In Proceedings of the Conference of Network-Association of European Researchers on Urbanisation in the South, Enschede, The Netherlands (pp. 12-14).</p>


<h3>See Also</h3>

<p><code><a href="#topic+localmoran.bi">localmoran.bi</a></code>, <code><a href="stats.html#topic+influence.measures">influence.measures</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
col_nbq &lt;- poly2nb(columbus)
a.lw &lt;- nb2listw(col_nbq, style="W")

# Editing axis labels
CRIME &lt;- as.vector(scale(columbus$CRIME))
INCOME &lt;- as.vector(scale(columbus$INC))
moranbi.plot(CRIME,INCOME,quiet =FALSE,zero.policy =FALSE,listw=a.lw)
# Without editing the label of the axes
moranbi.plot(as.vector(scale(columbus$CRIME)),as.vector(scale(columbus$INC)),
             quiet =FALSE,zero.policy =FALSE,listw=a.lw)

# Moran scatterplot
mp &lt;- moranbi.plot(CRIME,INCOME,quiet=FALSE,zero.policy=FALSE,listw=a.lw,
                   label=columbus$POLYID, plot = FALSE)

# Plot Moran Scatterplot in ggplot
if (require(ggplot2, quietly=TRUE)) {
# xname &lt;- attr(mp, "xname")
ggplot2::ggplot(mp, aes(x=varY, y=wx)) + geom_point(shape=1) +
  geom_smooth(formula=y ~ x, method="lm") +
  geom_hline(yintercept=mean(mp$wx), lty=2) +
  geom_vline(xintercept=mean(mp$varY), lty=2) + theme_minimal() +
  geom_point(data=mp[mp$is_inf,], aes(x=varY, y=wx), shape=9) +
  geom_text(data=mp[mp$is_inf,], aes(x=varY, y=wx, label=labels, vjust=1.5)) +
  # xlab(xname) + ylab(paste0("Spatially lagged ", xname))
  xlab("Crime") + ylab("Spatially Lagged Income")
}
</code></pre>

<hr>
<h2 id='moranbi.test'>Moran's Ixy test for bivariate spatial autocorrelation</h2><span id='topic+moranbi.test'></span>

<h3>Description</h3>

<p>Moran's Ixy test for bivariate spatial autocorrelation using a spatial weights matrix in weights list form. The assumptions underlying the test are sensitive to the form of the graph of neighbour relationships and other factors, and results may be checked against those of <code>moranbi.mc</code> permutations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moranbi.test(varX,varY,listw,randomisation=TRUE,zero.policy=NULL,
             alternative="greater",rank=FALSE,spChk=NULL,adjust.n=TRUE,
             drop.EI2=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moranbi.test_+3A_varx">varX</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw with the values of the variable <code>x</code></p>
</td></tr>
<tr><td><code id="moranbi.test_+3A_vary">varY</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw with the values of the variable <code>y</code></p>
</td></tr>
<tr><td><code id="moranbi.test_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="moranbi.test_+3A_randomisation">randomisation</code></td>
<td>
<p>variance of I calculated under the assumption of randomisation, if FALSE normality</p>
</td></tr>
<tr><td><code id="moranbi.test_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE assign NA</p>
</td></tr>
<tr><td><code id="moranbi.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code id="moranbi.test_+3A_rank">rank</code></td>
<td>
<p>logical value - default FALSE for continuous variables, if TRUE, uses the adaptation of Moran's I for ranks suggested by Cliff and Ord (1981, p. 46)</p>
</td></tr>
<tr><td><code id="moranbi.test_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="moranbi.test_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="moranbi.test_+3A_drop.ei2">drop.EI2</code></td>
<td>
<p>default FALSE, if TRUE, emulate CrimeStat &lt;= 4.02</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with class <code>htest</code> containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the standard deviate of Moran's Ixy.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the value of the observed Moran's Ixy, its expectation and variance under the method assumption.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string giving the assumption used for calculating the standard deviate.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Var(Ixy) is taken from Cliff and Ord (1969, p. 28), and
Goodchild's CATMOG 47 (1986),
see also Upton &amp; Fingleton (1985) p. 171; it agrees with SpaceStat,
see Tutorial workbook Chapter 22; VIxy is the second crude moment minus the
square of the first crude moment. The derivation of the test (Cliff and Ord, 1981, p. 18) assumes that the weights matrix is symmetric. For inherently non-symmetric matrices, such as k-nearest neighbour matrices, <code>listw2U()</code> can be used to make the matrix symmetric.
</p>


<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 21; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a></p>


<h3>See Also</h3>

<p><code><a href="spdep.html#topic+moran">moran</a></code>, <code><a href="spdep.html#topic+moran.mc">moran.mc</a></code>, <code><a href="spdep.html#topic+listw2U">listw2U</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(columbus)
data(oldcol)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
plot(st_geometry(columbus))
col_nbq &lt;- poly2nb(columbus)
set.seed(123)
BMCrime &lt;- moranbi.test(columbus$CRIME,columbus$INC,nb2listw(COL.nb, style="W"),
           zero.policy =TRUE, alternative = "two.sided")
BMCrime
moranbi.test(columbus$CRIME,columbus$INC,nb2listw(COL.nb,style="B"),
             zero.policy =TRUE,alternative = "two.sided",randomisation=FALSE)
colold.lags &lt;- nblag(col_nbq, 3)
moranbi.test(columbus$CRIME,columbus$INC,nb2listw(colold.lags[[2]],style="W"),
             zero.policy =TRUE, alternative = "two.sided",randomisation=FALSE)
print(is.symmetric.nb(COL.nb))

COL.k4.nb &lt;- knn2nb(knearneigh(coords, 4))
print(is.symmetric.nb(COL.k4.nb))
cat("Note: non-symmetric weights matrix, use listw2U()")
moranbi.test(columbus$CRIME,columbus$INC,listw2U(nb2listw(COL.k4.nb,style="W")),
             zero.policy =TRUE,adjust.n = TRUE)
moranbi.test(columbus$CRIME,columbus$INC,listw2U(nb2listw(COL.k4.nb,style="W")),
             zero.policy =TRUE, randomisation=FALSE)

ranksX &lt;- rank(columbus$CRIME)
ranksY &lt;- rank(columbus$INC)
names(ranksX) &lt;- rownames(columbus)
names(ranksY) &lt;- rownames(columbus)
moranbi.test(ranksX,ranksY,nb2listw(COL.k4.nb,style="W"),rank=TRUE,
             zero.policy=TRUE,alternative="two.sided")

crime &lt;- columbus$CRIME
income &lt;- columbus$INC
set.seed(123)
is.na(crime) &lt;- sample(1:length(crime), 5)
is.na(income) &lt;- sample(1:length(income), 4)
DF &lt;- data.frame(crime,income)
col.na &lt;- moranbi.test(DF$crime, DF$income, nb2listw(COL.nb, style="W"),
           zero.policy =TRUE)
col.na
</code></pre>

<hr>
<h2 id='moranbir.test'>Moran's Ixy test using Monte Carlo permutations for bivariate spatial autocorrelation</h2><span id='topic+moranbir.test'></span>

<h3>Description</h3>

<p>Moran's Ixy test for bivariate spatial autocorrelation using a spatial weights matrix in weights list form. Constructs a plot of the empirical density from the simulations (Monte Carlo permutations) and superimposes Moran's bivariate Ixy index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moranbir.test(varX,varY,listw,zero.policy=NULL,adjust.n=TRUE,N,graph=FALSE,
              alternative="greater", spChk=NULL, print.results=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moranbir.test_+3A_varx">varX</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw with the values of the variable <code>x</code></p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_vary">varY</code></td>
<td>
<p>a numeric vector of the same length as the neighbours list in listw with the values of the variable <code>y</code></p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_listw">listw</code></td>
<td>
<p>a <code>listw</code> object created for example by <code>nb2listw</code></p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_zero.policy">zero.policy</code></td>
<td>
<p>by default NULL, use global option value; if TRUE assign zero to the lagged value of zones without neighbours, if FALSE stop with error for any empty
neighbours sets and assign NA.</p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_adjust.n">adjust.n</code></td>
<td>
<p>default TRUE, if FALSE the number of observations is not adjusted for no-neighbour observations, if TRUE, the number of observations is adjusted</p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_n">N</code></td>
<td>
<p>set the number of spatial permutations for the calculation.</p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_graph">graph</code></td>
<td>
<p>by default = FALSE. Use TRUE to create test's graphic.</p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_print.results">print.results</code></td>
<td>
<p>by default = TRUE. Use FALSE to hide test results (table).
Results are: observed, expected and p-value.</p>
</td></tr>
<tr><td><code id="moranbir.test_+3A_...">...</code></td>
<td>
<p>other parameters similar to original</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compare the observed bivariate Moran's Ixy (moran.bi function) with the expected value empirical density. The expected value is -cor(x,y)/(n-1), where n is the number of rows/samples (number of polygons), and represents the null hyphothesis (Ho) of no spatial Autocorrelation (bivariate Moran's Ixy coefficient around zero). This expected value density is constructed with Monte Carlo simulations. Values significant below of -cor(x,y)/(n-1) represents negative spatial autocorrelation (generally negative values of observed bivariate Moran's Ixy), and values significant above of -cor(x,y)/(n-1) represents positive spatial autocorrelation (generally positive values of observed bivariate Moran's Ixy).
For hypothesis testing the sample values are compared with empirical density, and p-value is calculated. For significant values of p-value (reject Ho), the conclusion of the test could be: &quot;given the value of p-value, there is less than alpha (1%, or 5%, or 10%) likelihood that the pattern (clustered or dispersed) could be the result of random change&quot;.
</p>


<h3>Value</h3>

<p>A list with class <code>htest</code> containing the following components:
</p>
<table>
<tr><td><code>Observed</code></td>
<td>
<p>the value of the observed Moran's Ixy.</p>
</td></tr>
<tr><td><code>Expected</code></td>
<td>
<p>the expected value of Moran's Ixy.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>Values</code></td>
<td>
<p>corresponds to the N simulated values of Moran's Ixy coefficient for bivariate autocorrelation.</p>
</td></tr>
</table>


<h3>Links</h3>

<p>Adapted from:
</p>

<ol>
<li><p> Spatial Autocorrelation <a href="https://blogs.oregonstate.edu/geo599spatialstatistics/2016/06/08/spatial-autocorrelation-morans/">(Moran’s I) Test</a>
</p>
</li>
<li><p> Moran's I <a href="https://stats.oarc.ucla.edu/r/faq/how-can-i-calculate-morans-i-in-r/">Test</a>
</p>
</li></ol>



<h3>References</h3>

<p>Cliff, A. D., Ord, J. K. 1981 Spatial processes, Pion, p. 21; Bivand RS, Wong DWS 2018 Comparing implementations of global and local indicators of spatial association. TEST, 27(3), 716&ndash;748 <a href="https://doi.org/10.1007/s11749-018-0599-x">doi:10.1007/s11749-018-0599-x</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+moran.bi">moran.bi</a></code>, <code><a href="#topic+moranbi.mc">moranbi.mc</a></code>, <code><a href="spdep.html#topic+listw2U">listw2U</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(columbus)
data(oldcol)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
plot(st_geometry(columbus))
col_nbq &lt;- poly2nb(columbus)
a.lw &lt;- nb2listw(col_nbq, style="W")
set.seed(123)
RCrimeInc.Q &lt;- moranbir.test(columbus$CRIME,columbus$INC,a.lw,graph=TRUE,
                             zero.policy =TRUE,N=1000)
RCrimeInc.Q$Values


COL.k4.nb &lt;- knn2nb(knearneigh(coords, 4))
RCrimeInc.Knn &lt;- moranbir.test(columbus$CRIME, columbus$INC, listw2U(nb2listw(COL.k4.nb,
                               style="W")),graph=TRUE,zero.policy =TRUE,N=1000)
RCrimeInc.Knn

</code></pre>

<hr>
<h2 id='randomize_vector'>Generate a random sample from other vector</h2><span id='topic+randomize_vector'></span>

<h3>Description</h3>

<p>Use function 'sample' from base R library
to generate a random sample.
Function taken from Edzer Pebesma package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomize_vector(X, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomize_vector_+3A_x">X</code></td>
<td>
<p>vector to choose from</p>
</td></tr>
<tr><td><code id="randomize_vector_+3A_n">N</code></td>
<td>
<p>number of random elements to select from X</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
example(columbus)
#col_nbq &lt;- poly2nb(columbus)
#a.lw &lt;- nb2listw(col_nbq, style="W")
#set.seed(123)
DF &lt;- data.frame(1:length(columbus$CRIME),columbus$CRIME,columbus$INC)
X1&lt;-randomize_vector(DF$Obs,999)
</code></pre>

<hr>
<h2 id='spcorrelogram.bi'>Bivariate spatial correlogram</h2><span id='topic+spcorrelogram.bi'></span><span id='topic+plot.spcorbi'></span><span id='topic+print.spcorbi'></span>

<h3>Description</h3>

<p>Bivariate spatial correlograms for Moran's Ixy and the autocorrelation coefficient, with print and plot helper functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spcorrelogram.bi(neighbours, varX, varY, order = 1, method = "corr",
                 style = "W", randomisation = TRUE, zero.policy = NULL,
                 spChk=NULL, alternative = "greater", drop.EI2=FALSE)
## S3 method for class 'spcorbi'
plot(x, main, ylab, ylim, ...)
## S3 method for class 'spcorbi'
print(x, p.adj.method="none", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spcorrelogram.bi_+3A_neighbours">neighbours</code></td>
<td>
<p>an object of class <code>nb</code></p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_varx">varX</code></td>
<td>
<p>a numeric vector of the variable <code>x</code></p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_vary">varY</code></td>
<td>
<p>a numeric vector of the variable <code>y</code></p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_order">order</code></td>
<td>
<p>maximum lag order</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_method">method</code></td>
<td>
<p>&quot;corr&quot; for correlation, &quot;I&quot; for Moran's Ixy, &quot;C&quot; for Geary's Cxy</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_style">style</code></td>
<td>
<p><code>style</code> can take values W, B, C, and S</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_randomisation">randomisation</code></td>
<td>
<p>variance of I or C calculated under the assumption of randomisation, if FALSE normality</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_zero.policy">zero.policy</code></td>
<td>
<p>default NULL, use global option value; if FALSE stop with error for any empty neighbour sets,
if TRUE permit the weights list to be formed with zero-length weights vectors</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_spchk">spChk</code></td>
<td>
<p>should the data vector names be checked against the spatial objects for identity integrity, TRUE, or FALSE, default NULL to use <code>get.spChkOption()</code></p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of greater (default), less or two.sided.</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_drop.ei2">drop.EI2</code></td>
<td>
<p>default FALSE, if TRUE, emulate CrimeStat &lt;= 4.02</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_x">x</code></td>
<td>
<p>an object from <code>spcorrelogram.bi()</code> of class <code>spcorbi</code></p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_p.adj.method">p.adj.method</code></td>
<td>
<p>correction method as in <code>p.adjust</code></p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_main">main</code></td>
<td>
<p>an overall title for the plot</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot</p>
</td></tr>
<tr><td><code id="spcorrelogram.bi_+3A_...">...</code></td>
<td>
<p>further arguments passed through</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The print function also calculates the standard deviates of Bivariate Moran's Ixy or Geary's Cxy and a two-sided probability value, optionally using <code>p.adjust</code> to correct by the nymber of lags. The plot function plots a bar from the estimated value of Bivariate Moran's Ixy, or Geary's Cxy to +/- twice the square root of its variance (in previous releases only once, not twice). The table includes the count of included observations in brackets after the lag order. Care must be taken when interpreting the results, since increasing the order of the lag tends to include fewer observations.
</p>


<h3>Value</h3>

<p>returns a list of class <code>spcorbi</code>:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>for &quot;corr&quot; a vector of values; for &quot;I&quot;, a matrix of estimates of &quot;I&quot;, expectations, and variances</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>&quot;I&quot; or &quot;corr&quot;</p>
</td></tr>
<tr><td><code>cardnos</code></td>
<td>
<p>list of tables of neighbour cardinalities for the lag orders used</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>variable name</p>
</td></tr>
</table>


<h3>References</h3>

<p>Czaplewski, R.L., Reich, R.M. 1993. Expected value and variance of Moran's bivariate spatial autocorrelation statistic for a permutation test, Research paper RM-309, Fort Collins, CO U.S. Department of Agriculture, Forest Service, Rocky Mountain Forest and Range Experiment Station, p, 13.</p>


<h3>See Also</h3>

<p><code><a href="spdep.html#topic+nblag">nblag</a></code>, <code><a href="#topic+moran.bi">moran.bi</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spdep)
data(columbus)
data(oldcol)
columbus &lt;- st_read(system.file("shapes/columbus.shp", package="spData")[1], quiet=TRUE)
plot(st_geometry(columbus))
col_nbq &lt;- poly2nb(columbus)

Cspcb &lt;- spcorrelogram.bi(col_nbq,columbus$CRIME,columbus$INC,order=7,
                          method="corr",zero.policy=TRUE,alternative="two.sided")
print(Cspcb)
plot(Cspcb)

Ispcb &lt;- spcorrelogram.bi(col_nbq,columbus$CRIME,columbus$INC,order=7,
                          method="I",zero.policy=TRUE,alternative="two.sided")
print(Ispcb)
plot(Ispcb)

Cspcb &lt;- spcorrelogram.bi(col_nbq,columbus$CRIME,columbus$INC,order=7,
                          method="C",zero.policy=TRUE,alternative="two.sided")
print(Ispcb)
plot(Ispcb)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
