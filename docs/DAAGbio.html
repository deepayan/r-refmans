<!DOCTYPE html><html lang="en"><head><title>Help for package DAAGbio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DAAGbio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coralRG'><p>Spotted microarray red and green foreground and background values</p></a></li>
<li><a href='#coralTargets'><p>Targets file to accompany spotted expression array data</p></a></li>
<li><a href='#DEnma'><p>Spotted microarray M and A values; differentially expressed controls</p></a></li>
<li><a href='#imgplot'><p>Image plot of spotted expression array data</p></a></li>
<li><a href='#plantStressCounts'>
<p>Matrix holding mRNA counts</p></a></li>
<li><a href='#plotprintseq'><p>Sequence of movements of spotted microarray printhead</p></a></li>
<li><a href='#primateDNA'><p>Mitochondrial DNA sequence data from 14 primates</p></a></li>
<li><a href='#xplot'><p>Repeat specified plot across multiple columns of a matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.63-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Sets and Functions, for Demonstrations with Expression
Arrays and Gene Sequences</td>
</tr>
<tr>
<td>Author:</td>
<td>John Maindonald</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Maindonald &lt;jhmaindonald@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Data sets and functions, for the display of gene expression array (microarray) data, and for demonstrations with such data.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), limma (&ge; 2.9.15)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DAAG, locfit, knitr</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jhmaindonald/DAAGbio/">https://github.com/jhmaindonald/DAAGbio/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 08:57:32 UTC; johnm1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-20 23:02:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='coralRG'>Spotted microarray red and green foreground and background values</h2><span id='topic+coralRG'></span>

<h3>Description</h3>

<p>Unnormalised red and green values, and corresponding background values.
Further information is in the data frame <code>coralTargets</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coralRG)</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'RGList' [package &quot;limma&quot;]
Can be accessed as a list, with named elements
&quot;R&quot; ,&quot;G&quot; ,&quot;Rb&quot; ,&quot;Gb&quot; ,&quot;targets&quot;, &quot;source&quot; ,&quot;genes&quot; and &quot;printer&quot;
</p>


<h3>Source</h3>

<p>Lauretto Grasso and Eldon Ball, Molecular Genetics and Evolution Group,
Research School of Biological Sciences, Australian National University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coralRG)
</code></pre>

<hr>
<h2 id='coralTargets'>Targets file to accompany spotted expression array data</h2><span id='topic+coralTargets'></span>

<h3>Description</h3>

<p>Targets file, in the form expected by limma, to accompany the
expression array data in <code>coralRg</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coralTargets)</code></pre>


<h3>Format</h3>

<p>A data frame with 6 observations on the following 4 variables.
</p>

<dl>
<dt><code>SlideNumber</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>FileName</code></dt><dd><p>Names of files that hold spotted array data</p>
</dd>
<dt><code>Cy3</code></dt><dd><p>Treatment assigned to Cy3 (&quot;red&quot;)</p>
</dd>
<dt><code>Cy5</code></dt><dd><p>Treatment assigned to Cy5 (&quot;green&quot;)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(coralTargets)
## maybe str(coralTargets) ; plot(coralTargets) ...
</code></pre>

<hr>
<h2 id='DEnma'>Spotted microarray M and A values; differentially expressed controls</h2><span id='topic+DEnma'></span>

<h3>Description</h3>

<p>Values, derived from the data in <code>coralRG</code>, are the subset of the
M and A values, after normalisation within and between arrays, for the
differentially expressed controls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DEnma)</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'MAList' [package &quot;limma&quot;]
Can be accessed as a list, with named elements
&quot;targets&quot;, &quot;source&quot;,  &quot;genes&quot;,  &quot;printer&quot;, &quot;M&quot; and &quot;A&quot;
</p>


<h3>Source</h3>

<p>Centre for the Molecular Genomics of Genetic Development, ANU
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DEnma)
</code></pre>

<hr>
<h2 id='imgplot'>Image plot of spotted expression array data</h2><span id='topic+imgplot'></span>

<h3>Description</h3>

<p>Creates an image of graduated colors that represent the
values of a statistic for each spot on a spotted microarray.
By default, the only the 5
shown.  The initial version was based on <code>plot.spatial</code>
in the sma package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imgplot(z = DAAGbio::coralRG$R[, 1], layout = DAAGbio::coralRG$printer, crit1 = 0.05,
crit2 = crit1, key.side=2,
lohi.colors = c("#9E0142", "#D53E4F", "#F46D43", "#FDAE61", "#ABDDA4",
"#66C2A5", "#3288BD", "#5E4FA2"), nacolor = "#FFFF00",
boxplot.side = 1, split = "quantiles")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imgplot_+3A_z">z</code></td>
<td>
<p>values to be plotted</p>
</td></tr>
<tr><td><code id="imgplot_+3A_layout">layout</code></td>
<td>
<p>layout of spots, in the order (rows of grids, columns of
grids, rows of spots in a grid, columns in a grid)</p>
</td></tr>
<tr><td><code id="imgplot_+3A_crit1">crit1</code></td>
<td>
<p>Choose the lower threshold to include this proportion
at the high end</p>
</td></tr>
<tr><td><code id="imgplot_+3A_crit2">crit2</code></td>
<td>
<p>Choose the upper threshold to include this proportion
of values at the low end</p>
</td></tr>
<tr><td><code id="imgplot_+3A_key.side">key.side</code></td>
<td>
<p>Side on which the color key should appear</p>
</td></tr>
<tr><td><code id="imgplot_+3A_lohi.colors">lohi.colors</code></td>
<td>
<p>Graduated sequence of colors</p>
</td></tr>
<tr><td><code id="imgplot_+3A_nacolor">nacolor</code></td>
<td>
<p>Use this color for <code>NA</code>s</p>
</td></tr>
<tr><td><code id="imgplot_+3A_boxplot.side">boxplot.side</code></td>
<td>
<p>Show boxplot on this side of figure region</p>
</td></tr>
<tr><td><code id="imgplot_+3A_split">split</code></td>
<td>
<p>Specify <code>"intervals"</code> or <code>"quantiles"</code>,
as required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is created on the current graphics device
</p>


<h3>Author(s)</h3>

<p>J. H. Maindonald</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (z=DAAGbio::coralRG$R[,1], layout=cDAAGbio::oralRG$printer, crit1 = 0.05,
            crit2 = crit1, key.side=2,
            lohi.colors=c("#9E0142","#D53E4F","#F46D43","#FDAE61",
              "#ABDDA4","#66C2A5","#3288BD","#5E4FA2"),
            nacolor="#FFFF00", boxplot.side=1, split="quantiles")
{
  "block2matrix" &lt;-
    function(z, sr=3, sc=2, gr=2, gc=2){
      ## Assumes that values in the vector z are  in row major
      ## order within blocks of dimension sr x sc, with blocks
      ## in row major order within a gr x gc array of grids.
      ## Elements in the vector that is returned are in row
      ## major order wrt the sr*gr x sc*gc matrix of values on
      ## the slide. (It is given the dimensions of a matrix.)
      xy &lt;- array(z, dim=c(sc, sr, gc, gr))
      xy &lt;- aperm(xy, c(1,3,2,4))
      dim(xy) &lt;- c(sc*gc, gr*sr)
      xy}
  quantile.na &lt;- function (z, ...)
    {
      tmp &lt;- !(is.na(z) | is.infinite(z))
      quantile(z[tmp], ...)
    }
  length.na &lt;- function (z, ...)
    {
      tmp &lt;- !(is.na(z) | is.infinite(z))
      length(z[tmp], ...)
    }
    if(is.matrix(z))warning("z is a matrix, You probably want a column vector")
  bplot &lt;- function(z, boxplot.side=1){
    xrange &lt;- range(z,na.rm=TRUE)
    iqr &lt;- diff(quantile(xrange, c(.25,.75)))
    bwex &lt;- diff(xrange)/(3*iqr)
    xhi &lt;- max(z,na.rm=TRUE)
    xusr &lt;- par()$usr[c(1:2)]
    xpos=pretty(z[!is.na(z)], n=5)
    z &lt;- xusr[1]+(z-xrange[1])*diff(xusr)/diff(xrange)
    newpos &lt;- xusr[1]+(xpos-xrange[1])*diff(xusr)/diff(xrange)
    par(xpd=TRUE)
    atvert &lt;- switch(boxplot.side, par()$usr[3]-par()$cxy[2]*0.8,
                     "", par()$usr[4]+par()$cxy[2]*0.8, "")
    if(atvert!=""){
      boxplot(z, at=atvert, boxwex=bwex, add=TRUE, horizontal=TRUE, xaxt="n")
      axis(side=boxplot.side, line=1.5,
           at=newpos, labels=xpos, cex.axis=0.75, mgp=c(2, 0.5, 0))
    }
    par(xpd=FALSE)
  }
  if (crit1 &gt;= 1)
    crit1 &lt;- crit1/(length.na(z))
  if (crit2 &gt;= 1)
    crit2 &lt;- crit2/(length.na(z))
  tmpind &lt;- (z &gt; quantile.na(z, probs = 1 - crit2)) | (z &lt;
                                  quantile.na(z, probs = crit1))
  n &lt;- prod(unlist(layout))
  n.all &lt;- length(z)
  n.na &lt;- sum(is.na(z))
  nhalf &lt;- length(lohi.colors)%/%2
  n2 &lt;- 2*nhalf
  n.one &lt;- length(lohi.colors)
  plo &lt;- crit1*(0:nhalf)/nhalf
  phi &lt;- 1-crit2*(nhalf:0)/nhalf
  quiles1 &lt;- quantile.na(z, plo)
  quiles2 &lt;- quantile.na(z, phi)
  if(split=="intervals"){
    quiles1[2:nhalf] &lt;- quiles1[1]+(quiles1[nhalf+1]-quiles1[1])*
      (1:(nhalf-1))/nhalf
    quiles2[2:nhalf] &lt;- quiles2[1]-(quiles2[nhalf+1]-quiles2[1])*
      ((nhalf-1):1)/nhalf
    plo[-1] &lt;- sapply(quiles1[-1],
                      function(x, z)sum(z&lt;=x, na.rm=TRUE)/length.na(z), z=z)
    phi[-1] &lt;- sapply(quiles2[-1],
                      function(x, z)sum(z&lt;=x, na.rm=TRUE)/length.na(z), z=z)
  }

  if(crit1+crit2&lt;1){
    quiles &lt;- c(quiles1,quiles2)
    frac &lt;- c(plo, phi)
    colpal &lt;- c(lohi.colors[1:nhalf],"#FFFFFF",
                lohi.colors[(n.one-nhalf+1):(n.one)])
    midbreak &lt;- TRUE
  }
  else {colpal &lt;- lohi.colors
        midbreak &lt;- FALSE
        quiles &lt;- quantile.na(z, (0:n.one)/n.one)
        frac &lt;- c(plo, phi[-1])
      }
  dups &lt;- duplicated(quiles)
  if(any(dups)){
    cats &lt;- seq(along=quiles[-1])
    filledcats &lt;- cats[!dups]
    cutcats &lt;- as.integer(cut(z, quiles[!dups], include.lowest=TRUE))
    fullm &lt;- filledcats[cutcats]}
  else fullm &lt;- as.integer(cut(z, quiles, include.lowest=TRUE))
  n.one &lt;- length(colpal)
  nrects &lt;- length(quiles)
  if(any(is.na(z))){
    nacat &lt;- TRUE
    fullm[is.na(fullm)] &lt;- max(unique(fullm[!is.na(fullm)]))+1
    colpal &lt;- c(colpal, nacolor)
  }
  else nacat &lt;- FALSE
  if ((length(as.vector(z)) != n) &amp; (!is.null(names(z)))) {
    y &lt;- fullm[tmpind]
    fullm &lt;- rep(NA, n)
    fullm[as.integer(names(y))] &lt;- y
  }
  else fullm[!tmpind] &lt;- NA
  if ((length(as.vector(z)) != n) &amp; (is.null(names(z)))) {
    stop(paste("Error: Length of vector is different from total number\n",
               "of spots and vector has no row.name.\n"))
  }
#################################################################
  gc &lt;- layout$ngrid.c
  gr &lt;- layout$ngrid.r
  sc &lt;- layout$nspot.c
  sr &lt;- layout$nspot.r
  full &lt;- block2matrix(fullm, sr, sc, gr, gc)
  image(1:ncol(full), 1:nrow(full), t(full), axes = FALSE,
        xlab = "", ylab = "", col=colpal)
  box()
  abline(v = ((gr - 1):1) * (sr) + 0.5)
  abline(h = (1:(gc - 1)) * (sc) + 0.5)
#################################################################
  if(boxplot.side%in%c(1,3))bplot(z, boxplot.side=boxplot.side)
  if(key.side%in%c(2,4)){
    chw &lt;- par()$cxy[1]
    barwid &lt;- 0.75*chw
    if(key.side==2){
      x0 &lt;- par()$usr[1]-chw-barwid
      xcutpos &lt;- x0 - 0.4*chw
      xquilepos &lt;- x0+barwid+0.55*chw
      srt &lt;- 90
    }
    else {
      x0 &lt;- par()$usr[2]+chw
      xcutpos &lt;- x0 + barwid + 0.4*chw
      xquilepos &lt;- x0-0.4*chw
      srt &lt;- -90
    }
    yvals2 &lt;- seq(from=par()$usr[3], to=par()$usr[4],
                  length=n2+midbreak+2*nacat+1)[-(n2+midbreak+2*nacat+1)]
    eps2 &lt;- diff(yvals2[1:2])

    if(nacat){
      nlast &lt;- length(yvals2)
      nclast &lt;- length(colpal)
      rect(x0, yvals2[nlast], x0+barwid, yvals2[nlast]+eps2,
           col=colpal[nclast], xpd=TRUE)
      text(x0+0.5*barwid, yvals2[nlast]+0.5*eps2, "NA",
           xpd=TRUE, srt=srt)
      yvals2 &lt;- yvals2[-((nlast-1):nlast)]
      colpal &lt;- colpal[-nclast]
    }
    if(!midbreak){
      rect(x0, yvals2, x0+barwid, yvals2+eps2,
           col=colpal, xpd=TRUE)
      text(xcutpos, c(yvals2[1],yvals2+eps2),
           paste(signif(quiles,3)), srt=srt, xpd=TRUE, cex=0.8)
      text(xquilepos, yvals2[1], "(0%)", srt=srt, xpd=TRUE, cex=0.65)
      fracs &lt;- frac[-c(1, length(frac))]
      text(xquilepos, yvals2[-1],
           paste("(",round(fracs*100,2),")",sep=""),
           srt=srt, xpd=TRUE, cex=0.65)
      text(xquilepos, yvals2[length(yvals2)]+eps2, "(100%)", srt=srt,
           xpd=TRUE, cex=0.65)

    }
    else {rect(x0, yvals2[1:nhalf], x0+barwid, yvals2[1:nhalf]+eps2,
               col=colpal[1:nhalf], xpd=TRUE)
          rect(x0, yvals2[(nhalf+2):(2*nhalf+1)], x0+barwid,
               yvals2[(nhalf+2):(2*nhalf+1)]+eps2,
               col=colpal[(nhalf+2):(2*nhalf+1)], xpd=TRUE)
          text(xcutpos, yvals2[1:(nhalf+1)],
               paste(signif(quiles1,3)), srt=srt, xpd=TRUE, cex=0.8)
          text(xquilepos, yvals2[2:(nhalf+1)],
               paste("(",round(plo[-1]*100,2),")",sep=""), srt=srt,
               xpd=TRUE, cex=0.65)
          text(xquilepos, yvals2[1], "(0%)", srt=srt, xpd=TRUE, cex=0.65)
          text(xcutpos,
               c(yvals2[(nhalf+2):(2*nhalf+1)], yvals2[2*nhalf+1]+eps2),
               paste(signif(quiles2,3)), srt=srt, xpd=TRUE, cex=0.8)
          text(xquilepos, yvals2[(nhalf+2):(2*nhalf+1)],
               paste("(",round(phi[-length(phi)]*100,2),")",sep=""),
               srt=srt, xpd=TRUE, cex=0.65)
          text(xquilepos, yvals2[2*nhalf+1]+eps2, "(100%)", srt=srt,
               xpd=TRUE, cex=0.65)
        }
  }
  invisible()
  }
</code></pre>

<hr>
<h2 id='plantStressCounts'>
Matrix holding mRNA counts
</h2><span id='topic+plantStressCounts'></span>

<h3>Description</h3>

<p>Three treatments (3 samples each) were applied to Arabidopsis plants.
RNA-Seq technology was used to determine messenger RNA (mRNA) counts.
These were processed to remove counts for sequences that could not be 
identified as corresponding to a gene.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("plantStressCounts")</code></pre>


<h3>Format</h3>

<p>The matrix <code>plantStressCounts</code> has 28775 rows,
and 9 columns.  Rows have the nondescript names
&quot;Gene1&quot; &quot;Gene2&quot; &quot;Gene3&quot; &quot;Gene4&quot; ... .  Columns are
named &quot;CTL1&quot;, &quot;CTL2&quot;, &quot;CTL3&quot;, &quot;Light1&quot;, &quot;Light2&quot;, &quot;Light3&quot;, 
&quot;Drought1&quot;, &quot;Drought2&quot;, &quot;Drought3&quot;
</p>


<h3>Details</h3>

<p>The treatments were:
</p>

<dl>
<dt>Control</dt><dd><p>Plants were grown under normal light and
watering conditions</p>
</dd>
<dt>Light stress</dt><dd><p>One hour of continuous exposure to light
at ten times the level that the plants are normally grown under</p>
</dd>
<dt>Drought stress</dt><dd><p>Nine days without water, causing wilting
of the leaves</p>
</dd>
</dl>

<p>The interest is in how light and drought stress affect gene
expression to produce proteins.
</p>


<h3>Source</h3>

<p>Data are from Peter Crisp, obtained as part of his PhD work in the
ARC Centre of Excellence in Plant Energy Biology at Australian 
National University. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(plantStressCounts)
## maybe str(plantStressCounts) ; plot(plantStressCounts) ...
</code></pre>

<hr>
<h2 id='plotprintseq'>Sequence of movements of spotted microarray printhead</h2><span id='topic+plotprintseq'></span>

<h3>Description</h3>

<p>Shows the sequence of movements of a spotted microarray printhead,
when a slide is printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotprintseq(ngrid.r = 4, ngrid.c = 4, nspot.r = 16, nspot.c = 12,
gridorder = expand.grid(row = 1:ngrid.c, col = 1:ngrid.r),
spotorder = list(x = nspot.r:1, y = nspot.c:1), rowmajor = FALSE, eps =
1, delay1 = 100,
delay2 = 2000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotprintseq_+3A_ngrid.r">ngrid.r</code></td>
<td>
<p>Number of rows of grids</p>
</td></tr>
<tr><td><code id="plotprintseq_+3A_ngrid.c">ngrid.c</code></td>
<td>
<p>Number of columns of grids</p>
</td></tr>
<tr><td><code id="plotprintseq_+3A_nspot.r">nspot.r</code></td>
<td>
<p>Number of rows of spots in a grid</p>
</td></tr>
<tr><td><code id="plotprintseq_+3A_nspot.c">nspot.c</code></td>
<td>
<p>Number of columns of spots in a grid</p>
</td></tr>
<tr><td><code id="plotprintseq_+3A_gridorder">gridorder</code></td>
<td>
<p>A data frame whose rows specify grids, in order of printing</p>
</td></tr>
<tr><td><code id="plotprintseq_+3A_spotorder">spotorder</code></td>
<td>
<p>A list, specifying the order across rows and up or
down each column in a grid</p>
</td></tr>
<tr><td><code id="plotprintseq_+3A_rowmajor">rowmajor</code></td>
<td>
<p>Order of printing of spots within grids.</p>
</td></tr>
<tr><td><code id="plotprintseq_+3A_eps">eps</code></td>
<td>
<p>Distance between grids</p>
</td></tr>
<tr><td><code id="plotprintseq_+3A_delay1">delay1</code></td>
<td>
<p>Delay in shifting by one spot</p>
</td></tr>
<tr><td><code id="plotprintseq_+3A_delay2">delay2</code></td>
<td>
<p>Delay in shifting to new column or new row</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotprintseq()

## The function is currently defined as
function(ngrid.r=4, ngrid.c=4,
             nspot.r=16, nspot.c=12,
             gridorder=expand.grid(row=1:ngrid.c, col=1:ngrid.r),
             spotorder=list(x=nspot.r:1, y=nspot.c:1),
             rowmajor=FALSE, eps=1, delay1=100, delay2=2000){
        oldpar &lt;- par(mar=par()$mar-c(0,0,2.5,0))
        on.exit(par(oldpar))
        plotpoints &lt;- function(i, j, delay1=5000, delay2=10000){
            points(i+xy$x, j+xy$y, pch=15,
                   cex=0.5, col="cyan")
            x &lt;- 0
            for(k in 1:delay2)x &lt;- x+1
            points(i+xy$x, j+xy$y, pch=15,
                   cex=0.85, col="grey60")
            x &lt;- 0
            for(k in 1:delay1)x &lt;- x+1
        }

        xy &lt;- gridorder-1
        names(xy) &lt;- c("x","y")
        xy$x &lt;- xy$x*(nspot.c+eps)
        xy$y &lt;- xy$y*(nspot.r+eps)
        plot(c(1, ngrid.c*(nspot.c+eps)),
             c(1, ngrid.r*(nspot.r+eps)),
             type="n",xlab="",ylab="",axes=FALSE)
        mtext(side=1, line=1,
              paste("Grid layout:  #rows of Grids =", ngrid.r,
                      "   #columns of Grids =", ngrid.c))
        mtext(side=1, line=2.5,
              paste("In each grid:  #rows of Spots =", nspot.r,
                      "  #columns of Spots =", nspot.c))
        if (rowmajor)
        for(j in spotorder$x) for(i in spotorder$y)
        	plotpoints(i,j, delay1=delay1, delay2=delay2)
        	else
        	for(i in spotorder$y) for(j in spotorder$x)
        	plotpoints(i,j, delay1=delay1, delay2=delay2)
            }
</code></pre>

<hr>
<h2 id='primateDNA'>Mitochondrial DNA sequence data from 14 primates</h2><span id='topic+primateDNA'></span>

<h3>Description</h3>

<p>Bases at 232 mitochondrial locations (not continuous), for each of
14 primates.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(primateDNA)</code></pre>


<h3>Format</h3>

<p>A matrix of 14 rows (primate species) by 232 locations.
</p>


<h3>Source</h3>

<p>Data, originally from Masami Hasegawa, are from
<a href="http://evolution.genetics.washington.edu/book/primates.dna">http://evolution.genetics.washington.edu/book/primates.dna</a>
</p>


<h3>References</h3>

<p>Felsenstein, J. 2003. Inferring Phylogenies.  Sinauer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primateDNA)
## Not run: 
library(ape)
primates.dist &lt;- dist.dna(as.DNAbin(primateDNA), model = "K80") 
primates.cmd &lt;- cmdscale(primates.dist)
lefrt &lt;- primates.cmd[,1] &lt; apply(primates.cmd, 1, mean)
plot(primates.cmd)
text(primates.cmd, rownames(primates.cmd), pos=lefrt*2+2)

## End(Not run)
</code></pre>

<hr>
<h2 id='xplot'>Repeat specified plot across multiple columns of a matrix</h2><span id='topic+xplot'></span>

<h3>Description</h3>

<p>This is designed to repeat a plot, usually an image plot, across
multiple columns of a matrix of gene expression values. A boxplot
that shows the distribution of values appears below each panel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xplot(data = DAAGbio::coralRG$R, images = 1:6, layout = DAAGbio::coralRG$printer, mfrow =
c(3, 2),
FUN = imgplot, device = NULL, title = NULL, width = 7.5, height = 10,
paneltitles = c("1:R/G", "2:G/R", "3:R/G", "4:G/R", "5:R/G", "6:G/R"),
paneltitles.line = 0.5,
mar = c(3.6, 3.6, 1.6, 0.6), oma = c(0.6, 0.6, 1.6, 0.6), file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xplot_+3A_data">data</code></td>
<td>
<p>matrix of expression array values</p>
</td></tr>
<tr><td><code id="xplot_+3A_images">images</code></td>
<td>
<p>columns of matrix for which plots are required</p>
</td></tr>
<tr><td><code id="xplot_+3A_layout">layout</code></td>
<td>
<p>layout of spots, in the order (rows of grids, columns of
grids, rows of spots in a grid, columns in a grid)</p>
</td></tr>
<tr><td><code id="xplot_+3A_mfrow">mfrow</code></td>
<td>
<p>row by column layout of plots on a page</p>
</td></tr>
<tr><td><code id="xplot_+3A_fun">FUN</code></td>
<td>
<p><code>imgplot</code>, or <code>imageplot</code> from <code>limma</code></p>
</td></tr>
<tr><td><code id="xplot_+3A_device">device</code></td>
<td>
<p>If <code>NULL</code>, plot appears on the monitor.  Other
possibilities include <code>pdf</code>, <code>postscript</code>, <code>png</code>,
<code>jpeg</code> and <code>bitmap</code></p>
</td></tr>
<tr><td><code id="xplot_+3A_title">title</code></td>
<td>
<p>A title for the page of graphs</p>
</td></tr>
<tr><td><code id="xplot_+3A_width">width</code></td>
<td>
<p>width of plot (in)</p>
</td></tr>
<tr><td><code id="xplot_+3A_height">height</code></td>
<td>
<p>height of plot (in)</p>
</td></tr>
<tr><td><code id="xplot_+3A_paneltitles">paneltitles</code></td>
<td>
<p>character vector of titles for individual panels</p>
</td></tr>
<tr><td><code id="xplot_+3A_paneltitles.line">paneltitles.line</code></td>
<td>
<p>height (lines) at which panel title are to appear
above the upper margin of each panel</p>
</td></tr>
<tr><td><code id="xplot_+3A_mar">mar</code></td>
<td>
<p>Setting for <code>par$mar</code></p>
</td></tr>
<tr><td><code id="xplot_+3A_oma">oma</code></td>
<td>
<p>Setting for <code>par$mar</code></p>
</td></tr>
<tr><td><code id="xplot_+3A_file">file</code></td>
<td>
<p>Optional file name, if output is to a file</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. H. Maindonald</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xplot(data=coralRG$R, layout=coralRG$printer, FUN=imgplot)

## End(Not run)

## The function is currently defined as
function(data = DAAGbio::coralRG$R, images=1:6, layout = DAAGbio::coralRG$printer, mfrow=c(3,2),
           FUN = imgplot, device=NULL, title=NULL, width=7.5, height=10,
           paneltitles=c("1:R/G","2:G/R", "3:R/G","4:G/R", "5:R/G","6:G/R"),
           paneltitles.line=0.5,
           mar=c(3.6,3.6,1.6,0.6), oma=c(0.6,0.6,1.6,0.6), file=NULL){
    if(is.null(title)){title &lt;- as.character(substitute(data))
    title &lt;- paste(title[2], title[3], sep=":")
                    }
    if(is.null(file))file &lt;- title
    nch &lt;- nchar(title)
    if(!is.null(device)){devnam &lt;- deparse(substitute(device))
    ext &lt;- switch(devnam, ps="ps", pdf="pdf", png="png",
                  jpeg="jpg", bitmap="bmp")
      file &lt;- paste(title,".", ext, sep="")
      print(file)
      device(file=file, width=width, height=height)
    }
    oldpar &lt;- par(mfrow=mfrow, mgp=c(1,0.25,0), oma=oma, mar=mar)
    on.exit(par(oldpar))
    for(i in images){
      FUN(data[,i], layout=layout)
      mtext(side=3,line=paneltitles.line,paneltitles[i],adj=0)
    }
    mtext(side=3, line=0.25, title, outer=TRUE)
    if(!is.null(device))dev.off()
  }
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
