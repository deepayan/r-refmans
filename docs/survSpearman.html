<!DOCTYPE html><html><head><title>Help for package survSpearman</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {survSpearman}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CCASAnetData'><p>CCASAnetData</p></a></li>
<li><a href='#data123'><p>data123</p></a></li>
<li><a href='#fillUpDecimals'><p>Formats decimal part of numbers.</p></a></li>
<li><a href='#fillUpStr'><p>Adds characters to the head or tail of each element of the character vector.</p></a></li>
<li><a href='#plotMatrix'><p>Plots a color matrix.</p></a></li>
<li><a href='#plotVector'><p>Plots a set of rectangles that represent a numeric vector.</p></a></li>
<li><a href='#survDabrowska'><p>Computes marginal and joint survival probability estimates using Dabrowska's method.</p></a></li>
<li><a href='#survPMF'><p>Computes marginal and joint probability mass function from marginal and joint survival probabilities.</p></a></li>
<li><a href='#survPMFPlot'><p>Plots marginal and joint probability mass functions.</p></a></li>
<li><a href='#survRestricted'><p>Computes conditional marginal and joint survival probability in a restricted region.</p></a></li>
<li><a href='#survSpearman'><p>Computes Spearman's Correlation for Bivariate Survival Data.</p></a></li>
<li><a href='#visualBivarTimeToEvent'><p>Plots bivariate right-censored data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Nonparametric Spearman's Correlation for Survival Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Svetlana Eden &lt;svetlana.k.eden.1@vumc.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Nonparametric estimation of Spearman's rank correlation with bivariate survival (right-censored) data as described in Eden, S.K., Li, C., Shepherd B.E. (2021), Nonparametric Estimation of Spearman's Rank Correlation with Bivariate Survival Data, Biometrics (under revision). The package also provides functions that visualize bivariate survival data and bivariate probability mass function.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-26 15:39:56 UTC; svetlanaeden</td>
</tr>
<tr>
<td>Author:</td>
<td>Svetlana Eden [aut, cre],
  Chun Li [aut, anl],
  Bryan Shepherd [aut, anl]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-26 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CCASAnetData'>CCASAnetData</h2><span id='topic+CCASAnetData'></span>

<h3>Description</h3>

<p>Dataset with bivariate survival times to events and times to censoring. This de-identified dataset was made available with permission from the Caribbean, Central, and South America network for HIV Epidemiology (CCASAnet). The US National Institutes of Health partially funded the data collection (grants R01 AI093234 and U01 AI069923). The dataset includes 6691 HIV-positive adults (one record per patient) from Brazil, Chile, Honduras, Mexico, and Peru sites, anonymized for presentation. Each record contains time (in years) from antiretroviral therapy (ART) initiation to viral failure, viral failure event indicator, time (in years) from ART initiation to regimen change, and regimen change indicator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCASAnetData
</code></pre>


<h3>Format</h3>

<p>A data frame with 6691 rows and 5 variables:
</p>

<dl>
<dt>site</dt><dd><p>Anonymized study site.</p>
</dd>
<dt>timeToRegimenChange</dt><dd><p>Time (in years) from antiretroviral therapy initiation to regimen change.</p>
</dd>
<dt>regimenChange</dt><dd><p>Regimen change event indicator: 0 - no regimen change, 1 - regimen was changed.</p>
</dd>
<dt>timeToViralFailure</dt><dd><p>Time (in years) from antiretroviral therapy initiation to viral failure.</p>
</dd>
<dt>viralFailure</dt><dd><p>Viral failure event indicator: 0 - no viral failure, 1 - viral failure.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Caribbean, Central, and South America network for HIV Epidemiology, CCASAnet (grants R01 AI093234 and U01 AI069923).
</p>

<hr>
<h2 id='data123'>data123</h2><span id='topic+data123'></span>

<h3>Description</h3>

<p>Bivariate survival data simulated from Frank's copula family with parameter 4.426265, which is equivalent to Spearman's correlation of 0.6.
The marginal distributions of time to event and time to censoring are exponential with mean 1.
In the first 100 rows, the follow-up time is restricted to time 2, and the observations can also be independently censored before time 2.
In rows 101:200, the follow-up time is not restricted, but some observations are independently censored.
In rows 201:300, there is no censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data123
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows and 4 variables:
</p>

<dl>
<dt>X</dt><dd><p>Time to event X.</p>
</dd>
<dt>deltaX</dt><dd><p>Event indicator for event X (1 - event; 0 - censoring event).</p>
</dd>
<dt>Y</dt><dd><p>Time to event Y</p>
</dd>
<dt>deltaY</dt><dd><p>Event indicator for event Y (1 - event; 0 - censoring event).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated data.
</p>

<hr>
<h2 id='fillUpDecimals'>Formats decimal part of numbers.</h2><span id='topic+fillUpDecimals'></span>

<h3>Description</h3>

<p>The function adds zeros after the decimal point of each element of a numeric vector so that all elements have the same number of digits after the decimal point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillUpDecimals(numVec, howManyToFill, fill)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillUpDecimals_+3A_numvec">numVec</code></td>
<td>
<p>A vector of numbers in a numeric or character format.</p>
</td></tr>
<tr><td><code id="fillUpDecimals_+3A_howmanytofill">howManyToFill</code></td>
<td>
<p>The target number of digits after the decimal point. If <code>howManyToFill</code> is <code>NULL</code> (the default), then the function uses the maximum number of digits after the decimal point among the element of <code>numVec</code>.</p>
</td></tr>
<tr><td><code id="fillUpDecimals_+3A_fill">fill</code></td>
<td>
<p>What character to insert as a filler to reach the target number of digits (characters) after the decimal point. The default is <code>'0'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function adds zeros (or other characters) after the decimal point of each element of <code>numVec</code> so that all elements have the same number of decimal places after the decimal point. Lower and upper case letters are treated as digits (see the examples). <code>NA</code> values are returned unchanged. It is not recommended to include elements with characters other than digits and letters into <code>numVec</code> because the function will not work as described for these elements.
</p>


<h3>Value</h3>

<p>A character string with equal number of decimal places after the decimal point.
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fillUpDecimals(c("2", "3.4", "A", NA))
fillUpDecimals(c("2", "3.4", "A.5", NA), howManyToFill = 3)
fillUpDecimals(c("2", "3.4", "A", NA), fill = "X")
fillUpDecimals(c("2", "3.4", "A", NA), howManyToFill = -3)
fillUpDecimals(c("2", "3.4", "A.zx", NA), fill = "?")
### It is not recommended to include elements
### with characters other than digits and letters
### because the function will not work as described
### for these elements
fillUpDecimals(c("2", "3.4", "A.zx", NA, "#", "#a"), fill = "?")

</code></pre>

<hr>
<h2 id='fillUpStr'>Adds characters to the head or tail of each element of the character vector.</h2><span id='topic+fillUpStr'></span>

<h3>Description</h3>

<p>Adds characters to the head or tail of each element of the character vector to make all elements the same length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillUpStr(strVec, howManyToFill, where, fill)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillUpStr_+3A_strvec">strVec</code></td>
<td>
<p>A vector of character strings.</p>
</td></tr>
<tr><td><code id="fillUpStr_+3A_howmanytofill">howManyToFill</code></td>
<td>
<p>The target number of characters in each element of <code>strVec</code>. If <code>howManyToFill</code> is <code>NULL</code> or less than the number of characters in the longest element of <code>strVec</code>, then the number of characters in the longest element is used.</p>
</td></tr>
<tr><td><code id="fillUpStr_+3A_where">where</code></td>
<td>
<p>Where to place the characters: at the beginning of each element (<code>'head'</code>, the default) or at the end of each element (<code>'tail'</code>)</p>
</td></tr>
<tr><td><code id="fillUpStr_+3A_fill">fill</code></td>
<td>
<p>What character to add. The default is a blank space.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function adds characters to the head or tail of each element of the character vector, <code>strVec</code>, so that all elements have the same number of characters. <code>NA</code> values are returned unchanged. If <code>howManyToFill</code> is <code>NULL</code> or less than the number of characters in the longest element of <code>strVec</code>, then the number of characters in the longest element is used.
</p>


<h3>Value</h3>

<p>A character string with equal number of characters in each element.
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fillUpStr(c("A", "aaa", NA, "bb", "4.5"), where="tail", howManyToFill = 4, fill = "_")
fillUpStr(c("A", "aaa", NA, "bb", "4.5"), where="tail", howManyToFill = -3, fill = "_")
fillUpStr(c("A", "aaa", NA, "bb", "4.5"), where="head", howManyToFill = -3, fill = "*")

</code></pre>

<hr>
<h2 id='plotMatrix'>Plots a color matrix.</h2><span id='topic+plotMatrix'></span>

<h3>Description</h3>

<p>Plots a matrix of colors at a given point. Each element of the color matrix is plotted as a rectangle with user specified side lengths and border color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMatrix(colorMatr, borderCol, coordX, coordY, widthX, widthY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMatrix_+3A_colormatr">colorMatr</code></td>
<td>
<p>A matrix of colors in R format.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_bordercol">borderCol</code></td>
<td>
<p>The border color of plotted rectangles.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_coordx">coordX</code></td>
<td>
<p>X coordinate of the lower left corner of <code>colorMatr</code>.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_coordy">coordY</code></td>
<td>
<p>Y coordinate of the lower left corner of <code>colorMatr</code>.</p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_widthx">widthX</code></td>
<td>
<p>The vector of lengths of the rectangle sides parallel to the X-axis. The length of <code>widthX</code> can be either 1 (all rectangles have the same side length for X-axis) or the number of columns of <code>colorMatr</code></p>
</td></tr>
<tr><td><code id="plotMatrix_+3A_widthy">widthY</code></td>
<td>
<p>The vector of lengths of the rectangle sides parallel to the Y-axis. The length of <code>widthY</code> can be either 1 (all rectangles have the same side length for Y-axis) or the number of rows of <code>colorMatr</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>R</code>-function <code>plot()</code> has to be called first. The function plots a color matrix at a given coordinate. Each element of the color matrix is plotted as a rectangle with user specified border color and side lengths on X- and Y-axes. Element <code>colorMatr[nrow(colMatr), 1]</code> is displayed as the bottom left rectangle. Element <code>colorMatr[1, ncol(colMatr)]</code> is displayed as the top right rectangle.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Uneven rectangles
colorMatr = matrix(c("goldenrod1", "mediumpurple3", "palegreen3",
   "royalblue1", "orchid", "firebrick1"), nrow = 2, byrow = TRUE)
plot(c(1, 4), c(2, 4), type = "n", xlab = "", ylab = "")
plotMatrix(colorMatr, borderCol = "white", coordX = 1, coordY = 2,
   widthX = c(1/4, 1, 1/6), widthY = c(1, 1/2))
   
### Plotting the legend:
reshapeColMatr = matrix(t(colorMatr), ncol = 1, nrow = nrow(colorMatr)*ncol(colorMatr),
   byrow = TRUE)
plotMatrix(reshapeColMatr, borderCol = "white", coordX = 2.8, coordY = 2,
   widthX = c(1/4), widthY = c(1/4))
text(x = rep(3.03, nrow(reshapeColMatr)),
   y = 2.12+c(0,cumsum(rep(1/4, nrow(reshapeColMatr)-1))),
   labels = reshapeColMatr[nrow(reshapeColMatr):1], pos = 4, cex = 0.7)
   
### Same length and width rectangles on the black background
plot(c(1, 4), c(2, 4), type = "n", xlab = "", ylab = "")
polygon(x = c(0, 5, 5, 0, 0), y = c(0, 0, 5, 5, 0), col = "black")
plotMatrix(colorMatr, borderCol = "black", coordX = 1, coordY = 2, widthX = 1, widthY = 1)

</code></pre>

<hr>
<h2 id='plotVector'>Plots a set of rectangles that represent a numeric vector.</h2><span id='topic+plotVector'></span>

<h3>Description</h3>

<p>Plots a vector of numeric values as a set of rectangles with user specified height, width, color, and border color. The bases of the rectangles are aligned like in a histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVector(vectValues, width, coordX, coordY, rotationRadians, vectColor, bordColor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVector_+3A_vectvalues">vectValues</code></td>
<td>
<p>The heights of the rectangles. If <code>vectValues[i]</code>&gt;=0 then the base of rectangle <code>i</code> is plotted at <code>coordY</code> and the top is plotted at <code>coordY</code> + (<code>abs(vectValues[i])</code>).  If the <code>vectValues[i]</code>&lt;0 then the base of rectangle <code>i</code> is plotted at <code>coordY</code> and the bottom is plotted at <code>coordY</code> - <code>abs(vectValues[i])</code>.</p>
</td></tr>
<tr><td><code id="plotVector_+3A_width">width</code></td>
<td>
<p>The width (positive number) of the rectangles. It can be either one number or a vector of numbers with the same length as <code>vectValues</code>.</p>
</td></tr>
<tr><td><code id="plotVector_+3A_coordx">coordX</code></td>
<td>
<p>X coordinate of the left base corner of the first rectangle, <code>vectValues[1]</code>.</p>
</td></tr>
<tr><td><code id="plotVector_+3A_coordy">coordY</code></td>
<td>
<p>Y coordinate of the left base corner of the first rectangle, <code>vectValues[1]</code>.</p>
</td></tr>
<tr><td><code id="plotVector_+3A_rotationradians">rotationRadians</code></td>
<td>
<p>By how much (in radians) to rotate the aligned rectangles around <code>(coordX, coordY)</code>. The rotation is performed counter clock-wise.</p>
</td></tr>
<tr><td><code id="plotVector_+3A_vectcolor">vectColor</code></td>
<td>
<p>The colors of the rectangles in <code>R</code> color format. It can be either one value or a vector of values with the same length as <code>vectValues</code>.</p>
</td></tr>
<tr><td><code id="plotVector_+3A_bordcolor">bordColor</code></td>
<td>
<p>The color of the border of the rectangles. It can be either one value or a vector of values with the same length as <code>vectValues</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>R</code>-function <code>plot</code> has to be called first. The rectangles are aligned in the following manner. If <code>rotationRadians</code> is zero, then the base of all rectangles is at <code>coordY</code>. If <code>vectValues[i]&gt;=0</code> then the top of the rectangle is plotted at <code>coordY</code> + <code>abs(vectValues[i])</code>. If the <code>vectValues[i]</code>&lt;0 then the bottom of the rectangle is plotted at <code>coordY</code> - <code>abs(vectValues[i])</code>. If <code>rotationRadians</code> is not zero, then the aligned rectangles are rotated counter clock-wise around point (<code>coordX</code>,<code>coordY</code>).
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Histogram-like plot
plot(c(-1, 2), c(-1, 1), type = "n")
vectValues = c(0.057, 0.336, 0.260, 0.362, 0.209)
plotVector(vectValues, width = 0.2, coordX = 0, coordY = 0, rotationRadians = 0,
   vectColor = "gray", bordColor = "white")
   
### Rotated and flipped sequence of rectangles.
width = c(0.10, 0.20, 0.10, 0.80, 0.12)
vectColor = c("orange", "green", "orchid", "blue", "goldenrod1")
plot(c(-1, 2), c(-1, 2), type = "n")
plotVector(vectValues = vectValues, width, coordX = 0, coordY = 0,
   rotationRadians = pi/2, vectColor, bordColor = "white")
plotVector(vectValues = -vectValues, width, coordX = 0, coordY = 0,
   rotationRadians = 0, vectColor, bordColor = "white")
   
### Histogram-like plot with positive and negative values.
vectValues = c(0.057, -0.336, 0.260, -0.222, 0.209)
plot(c(-1, 1), c(-1, 1), type = "n")
vectColor = rep("goldenrod1", length(vectValues))
vectColor[vectValues&lt;0] = "royalblue1"
bordColor = rep("red", length(vectValues))
bordColor[vectValues&lt;0] = "darkblue"
plotVector(vectValues, width = 0.4, coordX = -1, coordY = 0, rotationRadians = 0,
    vectColor, bordColor = bordColor)

</code></pre>

<hr>
<h2 id='survDabrowska'>Computes marginal and joint survival probability estimates using Dabrowska's method.</h2><span id='topic+survDabrowska'></span>

<h3>Description</h3>

<p>The function computes marginal and joint survival probabilities for right-censored data using Dabrowska's (1988) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survDabrowska(X, Y, deltaX, deltaY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survDabrowska_+3A_x">X</code></td>
<td>
<p>Time to event or censoring for variable <code>X</code>. It indicates time to event if argument <code>deltaX</code> is <code>1</code> and time to censoring if argument <code>deltaX</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="survDabrowska_+3A_y">Y</code></td>
<td>
<p>Time to event or censoring for variable <code>Y</code>. It indicates time to event if argument <code>deltaY</code> is <code>1</code> and time to censoring if argument <code>deltaY</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code id="survDabrowska_+3A_deltax">deltaX</code></td>
<td>
<p>Event indicator for variable <code>X</code>. <code>deltaX</code> is <code>1</code> if the event is observed and <code>0</code> if it is censored.</p>
</td></tr>
<tr><td><code id="survDabrowska_+3A_deltay">deltaY</code></td>
<td>
<p>Event indicator for variable <code>Y</code>. <code>deltaY</code> is <code>1</code> if the event is observed and <code>0</code> if it is censored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a list with two values: Dabrowska's estimator of the marginal and joint survival probabilities, <code>DabrowskaEst</code>, and its corresponding marginal and joint cumulative distribution functions (CDFs), <code>DabrowskaCDF</code>, based on the bivariate survival data provided by the user.
</p>


<h3>Value</h3>

<p>A list of two elements: <code>DabrowskaEst</code> and <code>DabrowskaCDF</code>. <code>DabrowskaEst</code> is a matrix containing marginal and joint survival probabilities. The first column is the marginal survival probability corresponding to variable <code>X</code>. The first row is the marginal survival probability corresponding to variable <code>Y</code>. The rest of the matrix contains the joint survival probabilities. The row names of <code>DabrowskaEst</code> are ordered <code>X</code>-values. The column names of <code>DabrowskaEst</code> are ordered <code>Y</code>-values. Element <code>DabrowskaEst[1,1]</code> equals 1. Its row and column name is <code>'0'</code>. <code>DabrowskaCDF</code> is a matrix containing marginal and joint cumulative distribution functions (CDFs). The first row of <code>DabrowskaCDF</code> is the marginal CDF corresponding to variable <code>X</code>. The first column of <code>DabrowskaCDF</code> is the marginal CDF corresponding to variable <code>Y</code>. The row and column names of <code>DabrowskaCDF</code>  are the same as for <code>DabrowskaEst</code>.
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>References</h3>

<p>Dabrowska, D. M. (1988). Kaplan–Meier estimate on the plane. The Annals of Statistics 16, 1475–1489.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = c(0.5, 0.6, 0.6, 0.8)
Y = c(0.44, 0.77, 0.88, 0.99)
deltaX = c(1, 0, 1, 1)
deltaY = c(1, 1, 1, 1)
survDabrowska(X, Y, deltaX, deltaY)

</code></pre>

<hr>
<h2 id='survPMF'>Computes marginal and joint probability mass function from marginal and joint survival probabilities.</h2><span id='topic+survPMF'></span>

<h3>Description</h3>

<p>The function computes marginal and joint probability mass functions from marginal and joint survival probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survPMF(bivarSurf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survPMF_+3A_bivarsurf">bivarSurf</code></td>
<td>
<p>A matrix containing the marginal and joint survival probabilities. The first column is the marginal survival probability corresponding to variable <code>X</code>. The first row is the marginal survival probability corresponding to variable <code>Y</code>. The rest of the matrix contains the joint survival probabilities. The row names of <code>bivarSurf</code> are ordered <code>X</code> values. The column names of <code>bivarSurf</code> are ordered <code>Y</code> values. Element <code>bivarSurf[1,1]</code> equals 1. Its row and column name is <code>'0'</code> (see the documentation for the return value <code>DabrowskaEst</code> in function <code>survDabrowska</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a list of survival surfaces and their differentials. Element <code>Sdxdy</code> of this list is the marginal and joint probability mass function in the same format as argument <code>bivarSurf</code>. The rest of the returned list elements are matrices in the same format as <code>bivarSurf</code> except that they do not contain marginal values and row/column names.
</p>


<h3>Value</h3>

<p>The following list of survival surfaces and their differentials is returned. <code>Sdxdy</code> is the marginal and joint probability mass functions in the same format as argument <code>bivarSurf</code>; <code>Sxy</code> is the joint survival probability; <code>SxMyM</code> is <code>Sxy</code> at point <code>(x-, y-)</code>, where <code>x-</code> is the left limit of <code>x</code>; <code>Sx</code> is the marginal survival probability function for variable X; <code>Sy</code> is the marginal survival probability function for variable Y; <code>Sdx</code> is the marginal probability mass function for variable X; <code>Sdy</code> is the marginal probability mass function for variable Y; <code>SxM</code> is the marginal survival probability function for X at point <code>x-</code>; <code>SyM</code> is the marginal survival probability function for Y at point <code>y-</code>; <code>SxM_y</code> is the joint survival probability function at point <code>(x-, y)</code>; <code>Sx_yM</code> is the joint survival probability function at point <code>(x, y-)</code>; <code>Sdx_y</code> is <code>SxM_y - Sxy</code>; <code>Sx_dy</code> is <code>Sx_yM - Sxy</code>; <code>Sdx_yM</code> is <code>SxMyM - Sx_yM</code>; <code>SxM_dy</code> is <code>SxMyM - SxM_y</code>.
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = c(0.5, 0.6, 0.8)
Y = c(0.44, 0.77, 0.99)
deltaX = c(1, 0, 1)
deltaY = c(1, 1, 1)

bivarSurf = survDabrowska(X, Y, deltaX, deltaY)$DabrowskaEst
bivarSurf

bivarPMF = survPMF(bivarSurf)$Sdxdy
bivarPMF

</code></pre>

<hr>
<h2 id='survPMFPlot'>Plots marginal and joint probability mass functions.</h2><span id='topic+survPMFPlot'></span>

<h3>Description</h3>

<p>Plots marginal and joint probability mass functions for bivariate survival data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survPMFPlot(bivarSurf, gridWidthX, gridWidthY,
scaleGapX, scaleGapY, scaleHistX, scaleHistY,
XAxisLabel, YAxisLabel, lineXAxisLabel, lineYAxisLabel,
timeLabelScale, axisLabelScale,
labelSkipX, labelSkipY, roundX, roundY,
plotLabel, linePlotLabel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survPMFPlot_+3A_bivarsurf">bivarSurf</code></td>
<td>
<p>A matrix containing marginal and joint survival probabilities.  The first column is the marginal survival probability corresponding to variable <code>X</code>. The first row is the marginal survival probability corresponding to variable <code>Y</code>. The rest of the matrix contains the joint survival probabilities. The row names of <code>bivarSurf</code> are ordered <code>X</code> values. The column names of <code>bivarSurf</code> are ordered <code>Y</code> values. Element <code>bivarSurf[1,1]</code> equals 1. Its row and column name is <code>'0'</code> (see the documentation for the return value <code>DabrowskaEst</code> in function <code>survDabrowska</code>)</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_gridwidthx">gridWidthX</code></td>
<td>
<p>Grid size on <code>X</code>-axis.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_gridwidthy">gridWidthY</code></td>
<td>
<p>Grid size on <code>Y</code>-axis.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_scalegapx">scaleGapX</code></td>
<td>
<p>The proportion by which the gap between the marginal and joint histograms along the X-axis is increased (if &gt;1) or decreased (if &gt;0 and &lt;1).</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_scalegapy">scaleGapY</code></td>
<td>
<p>The proportion by which the gap between the marginal and joint histograms along the Y-axis is increased (if &gt;1) or decreased (if &gt;0 and &lt;1).</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_scalehistx">scaleHistX</code></td>
<td>
<p>The proportion by which to increase (if &gt;1) or decrease (if &gt;0 and &lt;1) the height of the marginal histogram along the X-axis.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_scalehisty">scaleHistY</code></td>
<td>
<p>The proportion by which to increase (if &gt;1) or decrease (if &gt;0 and &lt;1) the height of the marginal histogram along the Y-axis.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_xaxislabel">XAxisLabel</code></td>
<td>
<p><code>X</code>-axis label.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_yaxislabel">YAxisLabel</code></td>
<td>
<p><code>Y</code>-axis label.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_linexaxislabel">lineXAxisLabel</code></td>
<td>
<p>Line where to place the <code>X</code>-axis label (used by function <code>mtext</code>).</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_lineyaxislabel">lineYAxisLabel</code></td>
<td>
<p>Line where to place the <code>Y</code>-axis label (used by function <code>mtext</code>).</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_timelabelscale">timeLabelScale</code></td>
<td>
<p>The proportion by which the axis labels is increased (if &gt;1) or decreased (if &gt;0 and &lt;1).</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_axislabelscale">axisLabelScale</code></td>
<td>
<p>The proportion by which the time grid labels are increased (if &gt;1) or decreased (if &gt;0 and &lt;1).</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_labelskipx">labelSkipX</code></td>
<td>
<p>If the time grid looks too busy, not all <code>X</code>-label time grid labels have to be printed. For example, if <code>labelSkipX = 1</code> then every other label is printed starting from the first (time 0). If <code>labelSkipX = 2</code> then the 1st, 4rd, 7th, 10th, ... and so on, labels are printed. The default is <code>0</code>, which means that all time grid labels are printed.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_labelskipy">labelSkipY</code></td>
<td>
<p>If the time grid looks too busy, not all <code>Y</code>-label time grid labels have to be printed. For example, if <code>labelSkipY = 1</code> then every other label is printed starting from the first (time 0). If <code>labelSkipX = 2</code> then the 1st, 4rd, 7th, 10th, ... and so on, labels are printed. The default is <code>0</code>, which means that all time grid labels are printed.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_roundx">roundX</code></td>
<td>
<p>Number of decimal places in time grid labels for <code>X</code>-label.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_roundy">roundY</code></td>
<td>
<p>Number of decimal places in time grid labels for <code>Y</code>-label.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_plotlabel">plotLabel</code></td>
<td>
<p>Plot label.</p>
</td></tr>
<tr><td><code id="survPMFPlot_+3A_lineplotlabel">linePlotLabel</code></td>
<td>
<p>Line where to place the plot label (used by function <code>mtext</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots marginal and joint probability mass functions (PMFs) from marginal and joint survival probabilities. The probability mass gets aggregated into cells according to the user-specified arguments <code>gridWidthX</code> and <code>gridWidthY</code>. After this aggregation, the negative values (if any) are set to zero. Marginal probability mass functions are displayed as histograms. Joint probability mass function is displayed as a matrix with darker cells indicating larger probability mass aggregated in this cell. Zero mass is denoted with a very faint gray shade. Because the shading is relative, with greater range of probability mass more gray shades are observed. A future version of the function will allow users to choose their own shading/color function.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>References</h3>

<p>Eden, S.K., Li, C., Shepherd B.E. (2021). Non-parametric Estimation of Spearman's Rank Correlation with Bivariate Survival Data. Biometrics (under revision).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = c(0.5, 0.61, 0.6, 0.8, 0.78, 0.7, 0.9)
Y = c(0.44, 0.15, 0.77, 0.88, 0.22, 0.99, .33)
deltaX = c(1, 0, 1, 1, 0, 1, 0)
deltaY = c(1, 0, 1, 0, 1, 1, 1)

dabrSurf = survDabrowska(X, Y, deltaX, deltaY)$DabrowskaEst

grid = 0.1
survPMFPlot(bivarSurf = dabrSurf, gridWidthX = grid, gridWidthY = grid,
            scaleGapX = 1, scaleGapY = 1,
            XAxisLabel = "X", YAxisLabel = "Y", timeLabelScale = 1,
            axisLabelScale = 1,
            labelSkipX = 0, labelSkipY = 0, roundX = 2, roundY = 2,
            plotLabel = "Bivariate PMF")

</code></pre>

<hr>
<h2 id='survRestricted'>Computes conditional marginal and joint survival probability in a restricted region.</h2><span id='topic+survRestricted'></span>

<h3>Description</h3>

<p>The function computes marginal and joint survival probabilities conditionally on surviving in a restricted region. This region is defined by the user as <code>[0,tauX)x[0,tauY)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survRestricted(bivarSurf, tauX = Inf, tauY = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survRestricted_+3A_bivarsurf">bivarSurf</code></td>
<td>
<p>A matrix containing marginal and joint survival probabilities.  The first column is the marginal survival probability corresponding to variable <code>X</code>. The first row is the marginal survival probability corresponding to variable <code>Y</code>. The rest of the matrix contains the joint survival probabilities. The row names of <code>bivarSurf</code> are ordered <code>X</code> values. The column names of <code>bivarSurf</code> are ordered <code>Y</code> values. Element <code>bivarSurf[1,1]</code> equals 1. Its row and column name is <code>'0'</code> (see the documentation for the return value <code>DabrowskaEst</code> in function <code>survDabrowska</code>).</p>
</td></tr>
<tr><td><code id="survRestricted_+3A_taux">tauX</code></td>
<td>
<p>The <code>X</code> value that defines the restricted region for the <code>X</code> variable.</p>
</td></tr>
<tr><td><code id="survRestricted_+3A_tauy">tauY</code></td>
<td>
<p>The <code>Y</code> value that defines the restricted region for the <code>Y</code> variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method of Dabrowska can result in negative probability mass for some points, which may result in zero or negative probability of failure in the restricted region. This only happens when the sample size is small and censoring is heavy. If the probability of survival in the restricted region is zero or less, <code>NA</code> value is returned. Otherwise, the function returns a list of survival probabilities and their differentials conditionally on being in the restricted region defined by <code>tauX</code> and <code>tauY</code>. Element <code>Sxy</code> of this list is the conditional marginal and joint survival probabilities with row/column names in the same format as argument <code>bivarSurf</code>. The rest of the returned list elements are matrices in the same format as <code>bivarSurf</code> except that they do not contain marginal values and row/column names.
</p>


<h3>Value</h3>

<p>The function returns the following list of survival surfaces and their differentials: <code>Sxy</code> is the conditional marginal and joint survival probabilities in the same format as <code>bivarSurf</code>; <code>SxMyM</code> is <code>Sxy</code> at point <code>(x-, y-)</code>, where <code>x-</code> is the left limit of <code>x</code>; <code>Sx</code> is the conditional marginal survival probability function for variable X; <code>Sy</code> is the conditional marginal survival probability function for variable Y; <code>Sdx</code> is the conditional marginal probability mass function for variable X; <code>Sdy</code> is the conditional marginal probability mass function for variable Y; <code>SxM</code> is the conditional marginal survival probability function for X at point <code>x-</code>; <code>SyM</code> is the conditional marginal survival probability function for Y at point <code>y-</code>; <code>SxM_y</code> is the conditional joint survival probability function at point <code>(x-, y)</code>; <code>Sx_yM</code> is the conditional joint survival probability function at point <code>(x, y-)</code>; <code>Sdx_y</code> is <code>SxM_y - Sxy</code>; <code>Sx_dy</code> is <code>Sx_yM - Sxy</code>; <code>Sdx_yM</code> is <code>SxMyM - Sx_yM</code>; <code>SxM_dy</code> is <code>SxMyM - SxM_y</code>; <code>Sdxdy</code> is the conditional joint probability mass function.
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>References</h3>

<p>Eden, S.K., Li, C., Shepherd B.E. (2021). Non-parametric Estimation of Spearman's Rank Correlation with Bivariate Survival Data, Biometrics (under revision).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = c(0.5, 0.6, 0.8)
Y = c(0.44, 0.77, 0.99)
deltaX = c(1, 0, 1)
deltaY = c(1, 1, 1)
bivarSurf = survDabrowska(X, Y, deltaX, deltaY)$DabrowskaEst
bivarSurf

condSurf = survRestricted(bivarSurf, tauX = Inf, tauY = 0.88)$Sxy
condSurf

</code></pre>

<hr>
<h2 id='survSpearman'>Computes Spearman's Correlation for Bivariate Survival Data.</h2><span id='topic+survSpearman'></span>

<h3>Description</h3>

<p>Computes non-parametric estimates of Spearman's rank correlation for bivariate survival data. Two correlations are returned: a highest rank correlation that can be interpreted as Spearman's correlation after assigning a highest rank to observations beyond a specified region, and a restricted correlation that estimates Spearman's correlation within the specified region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survSpearman(X = NULL, Y = NULL, deltaX = NULL, deltaY = NULL, data = NULL,
tauX = Inf, tauY = Inf, bivarSurf = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survSpearman_+3A_x">X</code></td>
<td>
<p>Time to event or censoring for variable <code>X</code>. It indicates time to event if argument <code>deltaX</code>=1 and time to censoring if argument <code>deltaX</code>=0.</p>
</td></tr>
<tr><td><code id="survSpearman_+3A_y">Y</code></td>
<td>
<p>Time to event or censoring for variable <code>Y</code>. It indicates time to event if argument <code>deltaY</code>=1 and time to censoring if argument <code>deltaY</code>=0.</p>
</td></tr>
<tr><td><code id="survSpearman_+3A_deltax">deltaX</code></td>
<td>
<p>Event indicator for variable <code>X</code>. <code>deltaX=1</code> if the event is observed and <code>0</code> if it is censored.</p>
</td></tr>
<tr><td><code id="survSpearman_+3A_deltay">deltaY</code></td>
<td>
<p>Event indicator for variable <code>Y</code>. <code>deltaY=1</code> if the event is observed and <code>0</code> if it is censored.</p>
</td></tr>
<tr><td><code id="survSpearman_+3A_data">data</code></td>
<td>
<p>Data frame containing variables (arguments) <code>X</code>, <code>Y</code>, <code>deltaX</code>, and <code>deltaY</code>.</p>
</td></tr>
<tr><td><code id="survSpearman_+3A_taux">tauX</code></td>
<td>
<p>The <code>X</code> value that defines the restricted region for <code>X</code> variable.</p>
</td></tr>
<tr><td><code id="survSpearman_+3A_tauy">tauY</code></td>
<td>
<p>The <code>Y</code> value that defines the restricted region for <code>Y</code> variable.</p>
</td></tr>
<tr><td><code id="survSpearman_+3A_bivarsurf">bivarSurf</code></td>
<td>
<p>A matrix containing the marginal and joint survival probabilities. The first column is the marginal survival probability corresponding to variable <code>X</code>. The first row is the marginal survival probability corresponding to variable <code>Y</code>. The rest of the matrix contains the joint survival probabilities. The row names of <code>bivarSurf</code> are ordered <code>X</code>-values. The column names of <code>bivarSurf</code> are ordered <code>Y</code>-values. Element <code>bivarSurf[1,1]</code> equals 1. Its row and column name is <code>'0'</code> (see the documentation for the return value <code>DabrowskaEst</code> in function <code>survDabrowska</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the highest rank and restricted Spearman's correlations with bivariate survival data. The data can be supplied in three ways: 1) as vectors <code>X</code>, <code>Y</code>, <code>deltaX</code>, and <code>deltaY</code>; 2) as data frame <code>data</code> that contains the variables mentioned in 1); and 3) as matrix <code>bivarSurf</code> containing marginal and joint survival probabilities. If <code>bivarSurf</code> is not <code>NULL</code> then 1) and 2) are ignored. If <code>bivarSurf</code> is <code>NULL</code> and <code>data</code> is not then 2) is used. If <code>bivarSurf</code> and <code>data</code> are <code>NULL</code> then 1) is used. The highest rank correlation is the Spearman's correlation that can be interpreted as Spearman's rank correlation computed after assigning the highest rank to the events outside of <code>tauX</code> and <code>tauY</code>. The restricted Spearman's correlation is Spearman's correlation computed within the restricted region defined by <code>tauX</code> and <code>tauY</code>. Note that given <code>tauX</code> and <code>tauY</code> the survival probability is estimated using the values that are just above the latest observed event times within that region, what we call an effective restricted region. This means that if, for example, <code>tauX</code> is greater than the latest observed event time for <code>X</code> variable and <code>tauY</code> is greater than the latest observed event time for <code>Y</code> variable, then <code>tauX</code> and <code>tauY</code> do not affect the correlation values since the effective restricted region remains the same (as defined by the maximum observed event or censoring event times). The method of Dabrowska can result in negative probability mass for some points. This may result in zero or negative probability of failure in the restricted region, in which case the restricted Spearman's correlation cannot be computed and NA value is returned. This only happens when the sample size is small and censoring is heavy.
</p>


<h3>Value</h3>

<p>The function returns the following list of values. <code>'Restricted region set by user'</code> is a character vector of two user-specified restricted region values, <code>tauX</code> and <code>tauY</code>. <code>'Effective restricted region'</code> is character vector of two values that define the effective restricted region, the values that are just above the latest observed event times within the user-specified restricted region. <code>'Correlation'</code> is a numeric vector of two correlation values: the highest rank Spearman's correlation (<code>'HighestRank'</code>) and the restricted region Spearman's correlation (<code>'Restricted'</code>), where the restricted region is defined by the values in <code>'Effective restricted region'</code>.
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>References</h3>

<p>Dabrowska, D. M. (1988) Kaplan–Meier estimate on the plane. The Annals of Statistics 16, 1475–1489.
</p>
<p>Eden, S.K., Li, C., Shepherd B.E. (2021). Non-parametric Estimation of Spearman's Rank Correlation with Bivariate Survival Data. Biometrics (under revision).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Compute correlation from data
X &lt;- c(0.5, 0.6, 0.7, 0.8)
Y &lt;- c(0.44, 0.77, 0.88, 0.99)
deltaX &lt;- c(1, 0, 1, 1)
deltaY &lt;- c(1, 1, 1, 1)
survSpearman(X, Y, deltaX, deltaY)
survSpearman(X, Y, deltaX, deltaY, tauX = 100, tauY = 100)
survSpearman(X, Y, deltaX, deltaY, tauX = 100, tauY = 0.99)
survSpearman(X, Y, deltaX, deltaY, tauX = 0.8, tauY = 0.99)

### Compute correlation from survival surface
someSurf &lt;- survDabrowska(X, Y, deltaX, deltaY)$DabrowskaEst
survSpearman(tauY = 0.9, bivarSurf = someSurf)

</code></pre>

<hr>
<h2 id='visualBivarTimeToEvent'>Plots bivariate right-censored data.</h2><span id='topic+visualBivarTimeToEvent'></span>

<h3>Description</h3>

<p>Plots bivariate right-censored data distinguishing between uncensored, singly censored, and doubly censored observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualBivarTimeToEvent(X, Y, deltaX, deltaY, labelX, labelY,
   xlim = NULL, ylim = NULL, dotSize = 0.7,
   segLength=abs(mean(diff(c(X, Y)))), scaleLegendGap = 1,
   legendCex = 1, labCex = 1, axisCex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualBivarTimeToEvent_+3A_x">X</code></td>
<td>
<p>Time to event or censoring for variable <code>X</code>. It indicates time to event if argument <code>deltaX</code>=1 and time to censoring if argument <code>deltaX</code>=0.</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_y">Y</code></td>
<td>
<p>Time to event or censoring for variable <code>Y</code>. It indicates time to event if argument <code>deltaY</code>=1 and time to censoring if argument <code>deltaY</code>=0.</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_deltax">deltaX</code></td>
<td>
<p>Event indicator for variable <code>X</code>. <code>deltaX=1</code> if the event is observed and <code>0</code> if it is censored.</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_deltay">deltaY</code></td>
<td>
<p>Event indicator for variable <code>Y</code>. <code>deltaY=1</code> if the event is observed and <code>0</code> if it is censored.</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_labelx">labelX</code></td>
<td>
<p>Label for the X event.</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_labely">labelY</code></td>
<td>
<p>Label for the Y event.</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_xlim">xlim</code></td>
<td>
<p>The range for the X-axis (the same as parameter <code>xlim</code> in function <code>plot()</code>).</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_ylim">ylim</code></td>
<td>
<p>The range on the X-axis (the same as parameter <code>ylim</code> in function <code>plot()</code>).</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_dotsize">dotSize</code></td>
<td>
<p>The size of the points (the same as parameter <code>cex</code> in function <code>points()</code>).</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_seglength">segLength</code></td>
<td>
<p>The length of the segment representing censored observations.</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_scalelegendgap">scaleLegendGap</code></td>
<td>
<p>Increases (if &gt; 1) or decreases (if &lt; 1) the distance between the labels in the legend;</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_legendcex">legendCex</code></td>
<td>
<p>The size of the legend font (the same as parameter <code>cex</code> in function <code>text()</code>).</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_labcex">labCex</code></td>
<td>
<p>The size of <code>xlab</code> and <code>ylab</code> (the same as parameter <code>cex.lab</code> in function <code>plot()</code>).</p>
</td></tr>
<tr><td><code id="visualBivarTimeToEvent_+3A_axiscex">axisCex</code></td>
<td>
<p>The size of axis labels (the same as parameter <code>cex.axis</code> in function <code>plot()</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots bivariate right-censored data distinguishing between uncensored, singly censored,
and doubly censored observations. The singly and doubly censored observations are plotted
as diamonds and squares, respectively, with a short segment on the right,
which length is the same for X and Y.
The legend is always plotted in the left upper corner.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Svetlana K Eden, <a href="mailto:svetlanaeden@gmail.com">svetlanaeden@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = c(0.5, 0.61, 0.6, 0.8, 0.78, 0.7, 0.9)
Y = c(0.44, 0.15, 0.77, 0.88, 0.22, 0.99, .33)
deltaX = c(1, 0, 1, 1, 0, 1, 0)
deltaY = c(1, 0, 1, 0, 1, 1, 1)

visualBivarTimeToEvent(X, Y, deltaX, deltaY, xlim = c(0, 1), ylim = c(0, 1),
                       labelX = "X", labelY = "Y", segLength = 0.05)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
