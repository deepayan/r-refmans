<!DOCTYPE html><html><head><title>Help for package bayestestR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayestestR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.extract_priors_rstanarm'><p>Extract and Returns the priors formatted for rstanarm</p></a></li>
<li><a href='#.prior_new_location'><p>Set a new location for a prior</p></a></li>
<li><a href='#.select_nums'><p>select numerics columns</p></a></li>
<li><a href='#area_under_curve'><p>Area under the Curve (AUC)</p></a></li>
<li><a href='#as.data.frame.density'><p>Coerce to a Data Frame</p></a></li>
<li><a href='#as.numeric.map_estimate'><p>Convert to Numeric</p></a></li>
<li><a href='#bayesfactor'><p>Bayes Factors (BF)</p></a></li>
<li><a href='#bayesfactor_inclusion'><p>Inclusion Bayes Factors for testing predictors across Bayesian models</p></a></li>
<li><a href='#bayesfactor_models'><p>Bayes Factors (BF) for model comparison</p></a></li>
<li><a href='#bayesfactor_parameters'><p>Bayes Factors (BF) for a Single Parameter</p></a></li>
<li><a href='#bayesfactor_restricted'><p>Bayes Factors (BF) for Order Restricted Models</p></a></li>
<li><a href='#bayestestR-package'><p>bayestestR: Describing Effects and their Uncertainty, Existence and</p>
Significance within the Bayesian Framework</a></li>
<li><a href='#bci'><p>Bias Corrected and Accelerated Interval (BCa)</p></a></li>
<li><a href='#bic_to_bf'><p>Convert BIC indices to Bayes Factors via the BIC-approximation method.</p></a></li>
<li><a href='#check_prior'><p>Check if Prior is Informative</p></a></li>
<li><a href='#ci'><p>Confidence/Credible/Compatibility Interval (CI)</p></a></li>
<li><a href='#contr.equalprior'><p>Contrast Matrices for Equal Marginal Priors in Bayesian Estimation</p></a></li>
<li><a href='#convert_bayesian_as_frequentist'><p>Convert (refit) a Bayesian model to frequentist</p></a></li>
<li><a href='#cwi'><p>Curvewise Intervals (CWI)</p></a></li>
<li><a href='#density_at'><p>Density Probability at a Given Value</p></a></li>
<li><a href='#describe_posterior'><p>Describe Posterior Distributions</p></a></li>
<li><a href='#describe_prior'><p>Describe Priors</p></a></li>
<li><a href='#diagnostic_draws'><p>Diagnostic values for each iteration</p></a></li>
<li><a href='#diagnostic_posterior'><p>Posteriors Sampling Diagnostic</p></a></li>
<li><a href='#disgust'><p>Moral Disgust Judgment</p></a></li>
<li><a href='#distribution'><p>Empirical Distributions</p></a></li>
<li><a href='#effective_sample'><p>Effective Sample Size (ESS)</p></a></li>
<li><a href='#equivalence_test'><p>Test for Practical Equivalence</p></a></li>
<li><a href='#estimate_density'><p>Density Estimation</p></a></li>
<li><a href='#eti'><p>Equal-Tailed Interval (ETI)</p></a></li>
<li><a href='#hdi'><p>Highest Density Interval (HDI)</p></a></li>
<li><a href='#map_estimate'><p>Maximum A Posteriori probability estimate (MAP)</p></a></li>
<li><a href='#mcse'><p>Monte-Carlo Standard Error (MCSE)</p></a></li>
<li><a href='#mediation'><p>Summary of Bayesian multivariate-response mediation-models</p></a></li>
<li><a href='#model_to_priors'><p>Convert model's posteriors to priors (EXPERIMENTAL)</p></a></li>
<li><a href='#overlap'><p>Overlap Coefficient</p></a></li>
<li><a href='#p_direction'><p>Probability of Direction (pd)</p></a></li>
<li><a href='#p_map'><p>Bayesian p-value based on the density at the Maximum A Posteriori (MAP)</p></a></li>
<li><a href='#p_rope'><p>Probability of being in the ROPE</p></a></li>
<li><a href='#p_significance'><p>Practical Significance (ps)</p></a></li>
<li><a href='#p_to_bf'><p>Convert p-values to (pseudo) Bayes Factors</p></a></li>
<li><a href='#pd_to_p'><p>Convert between Probability of Direction (pd) and p-value.</p></a></li>
<li><a href='#point_estimate'><p>Point-estimates of posterior distributions</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reshape_iterations'><p>Reshape estimations with multiple iterations (draws) to long format</p></a></li>
<li><a href='#rope'><p>Region of Practical Equivalence (ROPE)</p></a></li>
<li><a href='#rope_range'><p>Find Default Equivalence (ROPE) Region Bounds</p></a></li>
<li><a href='#sensitivity_to_prior'><p>Sensitivity to Prior</p></a></li>
<li><a href='#sexit'><p>Sequential Effect eXistence and sIgnificance Testing (SEXIT)</p></a></li>
<li><a href='#sexit_thresholds'><p>Find Effect Size Thresholds</p></a></li>
<li><a href='#si'><p>Compute Support Intervals</p></a></li>
<li><a href='#simulate_correlation'><p>Data Simulation</p></a></li>
<li><a href='#simulate_prior'><p>Returns Priors of a Model as Empirical Distributions</p></a></li>
<li><a href='#simulate_simpson'><p>Simpson's paradox dataset simulation</p></a></li>
<li><a href='#spi'><p>Shortest Probability Interval (SPI)</p></a></li>
<li><a href='#unupdate'><p>Un-update Bayesian models to their prior-to-data state</p></a></li>
<li><a href='#weighted_posteriors'><p>Generate posterior distributions weighted across models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Understand and Describe Bayesian Models and Posterior
Distributions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.13.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominique Makowski &lt;dom.makowski@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utilities to describe posterior
    distributions and Bayesian models. It includes point-estimates such as
    Maximum A Posteriori (MAP), measures of dispersion (Highest Density
    Interval - HDI; Kruschke, 2015 &lt;<a href="https://doi.org/10.1016%2FC2012-0-00477-2">doi:10.1016/C2012-0-00477-2</a>&gt;) and
    indices used for null-hypothesis testing (such as ROPE percentage, pd
    and Bayes factors). References: Makowski et al. (2021) &lt;<a href="https://doi.org/10.21105%2Fjoss.01541">doi:10.21105/joss.01541</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>insight (&ge; 0.19.8), datawizard (&ge; 0.9.1), graphics, methods,
stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BayesFactor (&ge; 0.9.12-4.4), bayesQR, bayesplot, BH, blavaan,
bridgesampling, brms, curl, effectsize, emmeans, gamm4, ggdist,
ggplot2, glmmTMB, httr, KernSmooth, knitr, lavaan, lme4,
logspline (&ge; 2.1.21), MASS, mclust, mediation, modelbased,
parameters, patchwork, performance, quadprog, posterior,
RcppEigen, rmarkdown, rstan, rstanarm, see (&ge; 0.7.5),
testthat, tweedie</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://easystats.github.io/bayestestR/">https://easystats.github.io/bayestestR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/easystats/bayestestR/issues">https://github.com/easystats/bayestestR/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/rcmdcheck/ignore-inconsequential-notes:</td>
<td>true</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rstudio/bslib, r-lib/pkgdown,
easystats/easystatstemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-11 10:28:23 UTC; domma</td>
</tr>
<tr>
<td>Author:</td>
<td>Dominique Makowski
    <a href="https://orcid.org/0000-0001-5375-9967"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]
    (@Dom_Makowski),
  Daniel Lüdecke <a href="https://orcid.org/0000-0002-8895-3206"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (@strengejacke),
  Mattan S. Ben-Shachar
    <a href="https://orcid.org/0000-0002-4287-4801"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]
    (@mattansb),
  Indrajeet Patil <a href="https://orcid.org/0000-0003-1995-6531"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut] (@patilindrajeets),
  Michael D. Wilson <a href="https://orcid.org/0000-0003-4143-7308"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Brenton M. Wiernik
    <a href="https://orcid.org/0000-0001-9560-6336"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]
    (@bmwiernik),
  Paul-Christian Bürkner [rev],
  Tristan Mahr <a href="https://orcid.org/0000-0002-8890-5116"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Henrik Singmann <a href="https://orcid.org/0000-0002-4842-3657"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Quentin F. Gronau <a href="https://orcid.org/0000-0001-5510-6943"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Sam Crawley <a href="https://orcid.org/0000-0002-7847-0411"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-12 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.extract_priors_rstanarm'>Extract and Returns the priors formatted for rstanarm</h2><span id='topic+.extract_priors_rstanarm'></span>

<h3>Description</h3>

<p>Extract and Returns the priors formatted for rstanarm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extract_priors_rstanarm(model, ...)
</code></pre>

<hr>
<h2 id='.prior_new_location'>Set a new location for a prior</h2><span id='topic+.prior_new_location'></span>

<h3>Description</h3>

<p>Set a new location for a prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prior_new_location(prior, sign, magnitude = 10)
</code></pre>

<hr>
<h2 id='.select_nums'>select numerics columns</h2><span id='topic+.select_nums'></span>

<h3>Description</h3>

<p>select numerics columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.select_nums(x)
</code></pre>

<hr>
<h2 id='area_under_curve'>Area under the Curve (AUC)</h2><span id='topic+area_under_curve'></span><span id='topic+auc'></span>

<h3>Description</h3>

<p>Based on the DescTools <code>AUC</code> function. It can calculate the area under the
curve with a naive algorithm or a more elaborated spline approach. The curve
must be given by vectors of xy-coordinates. This function can handle unsorted
x values (by sorting x) and ties for the x values (by ignoring duplicates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>area_under_curve(x, y, method = c("trapezoid", "step", "spline"), ...)

auc(x, y, method = c("trapezoid", "step", "spline"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="area_under_curve_+3A_x">x</code></td>
<td>
<p>Vector of x values.</p>
</td></tr>
<tr><td><code id="area_under_curve_+3A_y">y</code></td>
<td>
<p>Vector of y values.</p>
</td></tr>
<tr><td><code id="area_under_curve_+3A_method">method</code></td>
<td>
<p>Method to compute the Area Under the Curve (AUC). Can be
<code>"trapezoid"</code> (default), <code>"step"</code> or <code>"spline"</code>. If &quot;trapezoid&quot;, the curve
is formed by connecting all points by a direct line (composite trapezoid
rule). If &quot;step&quot; is chosen then a stepwise connection of two points is
used. For calculating the area under a spline interpolation the splinefun
function is used in combination with integrate.</p>
</td></tr>
<tr><td><code id="area_under_curve_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>DescTools
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bayestestR)
posterior &lt;- distribution_normal(1000)

dens &lt;- estimate_density(posterior)
dens &lt;- dens[dens$x &gt; 0, ]
x &lt;- dens$x
y &lt;- dens$y

area_under_curve(x, y, method = "trapezoid")
area_under_curve(x, y, method = "step")
area_under_curve(x, y, method = "spline")
</code></pre>

<hr>
<h2 id='as.data.frame.density'>Coerce to a Data Frame</h2><span id='topic+as.data.frame.density'></span>

<h3>Description</h3>

<p>Coerce to a Data Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'density'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.density_+3A_x">x</code></td>
<td>
<p>any <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.density_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>

<hr>
<h2 id='as.numeric.map_estimate'>Convert to Numeric</h2><span id='topic+as.numeric.map_estimate'></span><span id='topic+as.numeric.p_direction'></span><span id='topic+as.numeric.p_map'></span><span id='topic+as.numeric.p_significance'></span>

<h3>Description</h3>

<p>Convert to Numeric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'map_estimate'
as.numeric(x, ...)

## S3 method for class 'p_direction'
as.numeric(x, ...)

## S3 method for class 'p_map'
as.numeric(x, ...)

## S3 method for class 'p_significance'
as.numeric(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.numeric.map_estimate_+3A_x">x</code></td>
<td>
<p>object to be coerced or tested.</p>
</td></tr>
<tr><td><code id="as.numeric.map_estimate_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='bayesfactor'>Bayes Factors (BF)</h2><span id='topic+bayesfactor'></span>

<h3>Description</h3>

<p>This function compte the Bayes factors (BFs) that are appropriate to the
input. For vectors or single models, it will compute <code><a href="#topic+bayesfactor_parameters">BFs for single parameters()</a></code>, or is <code>hypothesis</code> is specified,
<code><a href="#topic+bayesfactor_restricted">BFs for restricted models()</a></code>. For multiple models,
it will return the BF corresponding to <code><a href="#topic+bayesfactor_models">comparison between models()</a></code> and if a model comparison is passed, it will
compute the <code><a href="#topic+bayesfactor_inclusion">inclusion BF()</a></code>.
<br /><br />
For a complete overview of these functions, read the <a href="https://easystats.github.io/bayestestR/articles/bayes_factors.html">Bayes factor vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesfactor(
  ...,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  hypothesis = NULL,
  effects = c("fixed", "random", "all"),
  verbose = TRUE,
  denominator = 1,
  match_models = FALSE,
  prior_odds = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesfactor_+3A_...">...</code></td>
<td>
<p>A numeric vector, model object(s), or the output from
<code>bayesfactor_models</code>.</p>
</td></tr>
<tr><td><code id="bayesfactor_+3A_prior">prior</code></td>
<td>
<p>An object representing a prior distribution (see 'Details').</p>
</td></tr>
<tr><td><code id="bayesfactor_+3A_direction">direction</code></td>
<td>
<p>Test type (see 'Details'). One of <code>0</code>,
<code>"two-sided"</code> (default, two tailed), <code>-1</code>, <code>"left"</code> (left
tailed) or <code>1</code>, <code>"right"</code> (right tailed).</p>
</td></tr>
<tr><td><code id="bayesfactor_+3A_null">null</code></td>
<td>
<p>Value of the null, either a scalar (for point-null) or a range
(for a interval-null).</p>
</td></tr>
<tr><td><code id="bayesfactor_+3A_hypothesis">hypothesis</code></td>
<td>
<p>A character vector specifying the restrictions as logical conditions (see examples below).</p>
</td></tr>
<tr><td><code id="bayesfactor_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="bayesfactor_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="bayesfactor_+3A_denominator">denominator</code></td>
<td>
<p>Either an integer indicating which of the models to use as
the denominator, or a model to be used as a denominator. Ignored for
<code>BFBayesFactor</code>.</p>
</td></tr>
<tr><td><code id="bayesfactor_+3A_match_models">match_models</code></td>
<td>
<p>See details.</p>
</td></tr>
<tr><td><code id="bayesfactor_+3A_prior_odds">prior_odds</code></td>
<td>
<p>Optional vector of prior odds for the models. See
<code style="white-space: pre;">&#8288;BayesFactor::priorOdds&lt;-&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Some type of Bayes factor, depending on the input. See <code><a href="#topic+bayesfactor_parameters">bayesfactor_parameters()</a></code>, <code><a href="#topic+bayesfactor_models">bayesfactor_models()</a></code> or <code><a href="#topic+bayesfactor_inclusion">bayesfactor_inclusion()</a></code>
</p>


<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

prior &lt;- distribution_normal(1000, mean = 0, sd = 1)
posterior &lt;- distribution_normal(1000, mean = .5, sd = .3)

bayesfactor(posterior, prior = prior, verbose = FALSE)


# rstanarm models
# ---------------
model &lt;- suppressWarnings(rstanarm::stan_lmer(extra ~ group + (1 | ID), data = sleep))
bayesfactor(model, verbose = FALSE)

# Frequentist models
# ---------------
m0 &lt;- lm(extra ~ 1, data = sleep)
m1 &lt;- lm(extra ~ group, data = sleep)
m2 &lt;- lm(extra ~ group + ID, data = sleep)

comparison &lt;- bayesfactor(m0, m1, m2)
comparison

bayesfactor(comparison)


</code></pre>

<hr>
<h2 id='bayesfactor_inclusion'>Inclusion Bayes Factors for testing predictors across Bayesian models</h2><span id='topic+bayesfactor_inclusion'></span><span id='topic+bf_inclusion'></span>

<h3>Description</h3>

<p>The <code style="white-space: pre;">&#8288;bf_*&#8288;</code> function is an alias of the main function.
<br /> <br />
For more info, see <a href="https://easystats.github.io/bayestestR/articles/bayes_factors.html">the Bayes factors vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesfactor_inclusion(models, match_models = FALSE, prior_odds = NULL, ...)

bf_inclusion(models, match_models = FALSE, prior_odds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesfactor_inclusion_+3A_models">models</code></td>
<td>
<p>An object of class <code><a href="#topic+bayesfactor_models">bayesfactor_models()</a></code> or <code>BFBayesFactor</code>.</p>
</td></tr>
<tr><td><code id="bayesfactor_inclusion_+3A_match_models">match_models</code></td>
<td>
<p>See details.</p>
</td></tr>
<tr><td><code id="bayesfactor_inclusion_+3A_prior_odds">prior_odds</code></td>
<td>
<p>Optional vector of prior odds for the models. See
<code style="white-space: pre;">&#8288;BayesFactor::priorOdds&lt;-&#8288;</code>.</p>
</td></tr>
<tr><td><code id="bayesfactor_inclusion_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inclusion Bayes factors answer the question: Are the observed data
more probable under models with a particular effect, than they are under
models without that particular effect? In other words, on average - are
models with effect <code class="reqn">X</code> more likely to have produced the observed data
than models without effect <code class="reqn">X</code>?
</p>


<h4>Match Models</h4>

<p>If <code>match_models=FALSE</code> (default), Inclusion BFs are computed by comparing
all models with a term against all models without that term. If <code>TRUE</code>,
comparison is restricted to models that (1) do not include any interactions
with the term of interest; (2) for interaction terms, averaging is done only
across models that containe the main effect terms from which the interaction
term is comprised.
</p>



<h3>Value</h3>

<p>a data frame containing the prior and posterior probabilities, and
log(BF) for each effect (Use <code>as.numeric()</code> to extract the non-log Bayes
factors; see examples).
</p>


<h3>Interpreting Bayes Factors</h3>

<p>A Bayes factor greater than 1 can be interpreted as evidence against the
null, at which one convention is that a Bayes factor greater than 3 can be
considered as &quot;substantial&quot; evidence against the null (and vice versa, a
Bayes factor smaller than 1/3 indicates substantial evidence in favor of the
null-model) (<cite>Wetzels et al. 2011</cite>).
</p>


<h3>Note</h3>

<p>Random effects in the <code>lmer</code> style are converted to interaction terms:
i.e., <code>(X|G)</code> will become the terms <code>1:G</code> and <code>X:G</code>.
</p>


<h3>Author(s)</h3>

<p>Mattan S. Ben-Shachar
</p>


<h3>References</h3>


<ul>
<li><p> Hinne, M., Gronau, Q. F., van den Bergh, D., and Wagenmakers, E. (2019, March 25).
A conceptual introduction to Bayesian Model Averaging. <a href="https://doi.org/10.31234/osf.io/wgb64">doi:10.31234/osf.io/wgb64</a>
</p>
</li>
<li><p> Clyde, M. A., Ghosh, J., &amp; Littman, M. L. (2011). Bayesian adaptive sampling
for variable selection and model averaging. Journal of Computational and Graphical Statistics,
20(1), 80-101.
</p>
</li>
<li><p> Mathot, S. (2017). Bayes like a Baws: Interpreting Bayesian Repeated Measures in JASP.
<a href="https://www.cogsci.nl/blog/interpreting-bayesian-repeated-measures-in-jasp">Blog post</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+weighted_posteriors">weighted_posteriors()</a></code> for Bayesian parameter averaging.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

# Using bayesfactor_models:
# ------------------------------
mo0 &lt;- lm(Sepal.Length ~ 1, data = iris)
mo1 &lt;- lm(Sepal.Length ~ Species, data = iris)
mo2 &lt;- lm(Sepal.Length ~ Species + Petal.Length, data = iris)
mo3 &lt;- lm(Sepal.Length ~ Species * Petal.Length, data = iris)

BFmodels &lt;- bayesfactor_models(mo1, mo2, mo3, denominator = mo0)
(bf_inc &lt;- bayesfactor_inclusion(BFmodels))

as.numeric(bf_inc)


# BayesFactor
# -------------------------------
BF &lt;- BayesFactor::generalTestBF(len ~ supp * dose, ToothGrowth, progress = FALSE)
bayesfactor_inclusion(BF)

# compare only matched models:
bayesfactor_inclusion(BF, match_models = TRUE)


</code></pre>

<hr>
<h2 id='bayesfactor_models'>Bayes Factors (BF) for model comparison</h2><span id='topic+bayesfactor_models'></span><span id='topic+bf_models'></span><span id='topic+bayesfactor_models.default'></span><span id='topic+update.bayesfactor_models'></span><span id='topic+as.matrix.bayesfactor_models'></span>

<h3>Description</h3>

<p>This function computes or extracts Bayes factors from fitted models.
<br /> <br />
The <code style="white-space: pre;">&#8288;bf_*&#8288;</code> function is an alias of the main function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesfactor_models(..., denominator = 1, verbose = TRUE)

bf_models(..., denominator = 1, verbose = TRUE)

## Default S3 method:
bayesfactor_models(..., denominator = 1, verbose = TRUE)

## S3 method for class 'bayesfactor_models'
update(object, subset = NULL, reference = NULL, ...)

## S3 method for class 'bayesfactor_models'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesfactor_models_+3A_...">...</code></td>
<td>
<p>Fitted models (see details), all fit on the same data, or a single
<code>BFBayesFactor</code> object (see 'Details'). Ignored in <code>as.matrix()</code>,
<code>update()</code>. If the following named arguments are present, they are passed
to <code><a href="insight.html#topic+get_loglikelihood">insight::get_loglikelihood()</a></code> (see details):
</p>

<ul>
<li> <p><code>estimator</code> (defaults to <code>"ML"</code>)
</p>
</li>
<li> <p><code>check_response</code>  (defaults to <code>FALSE</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="bayesfactor_models_+3A_denominator">denominator</code></td>
<td>
<p>Either an integer indicating which of the models to use as
the denominator, or a model to be used as a denominator. Ignored for
<code>BFBayesFactor</code>.</p>
</td></tr>
<tr><td><code id="bayesfactor_models_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="bayesfactor_models_+3A_object">object</code>, <code id="bayesfactor_models_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+bayesfactor_models">bayesfactor_models()</a></code> object.</p>
</td></tr>
<tr><td><code id="bayesfactor_models_+3A_subset">subset</code></td>
<td>
<p>Vector of model indices to keep or remove.</p>
</td></tr>
<tr><td><code id="bayesfactor_models_+3A_reference">reference</code></td>
<td>
<p>Index of model to reference to, or <code>"top"</code> to
reference to the best model, or <code>"bottom"</code> to reference to the worst
model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the passed models are supported by <strong>insight</strong> the DV of all models will
be tested for equality (else this is assumed to be true), and the models'
terms will be extracted (allowing for follow-up analysis with <code>bayesfactor_inclusion</code>).
</p>

<ul>
<li><p> For <code>brmsfit</code> or <code>stanreg</code> models, Bayes factors are computed using the <a href="https://CRAN.R-project.org/package=bridgesampling"><span class="pkg">bridgesampling</span></a> package.
</p>

<ul>
<li> <p><code>brmsfit</code> models must have been fitted with <code>save_pars = save_pars(all = TRUE)</code>.
</p>
</li>
<li> <p><code>stanreg</code> models must have been fitted with a defined <code>diagnostic_file</code>.
</p>
</li></ul>

</li>
<li><p> For <code>BFBayesFactor</code>, <code>bayesfactor_models()</code> is mostly a wraparound <code>BayesFactor::extractBF()</code>.
</p>
</li>
<li><p> For all other model types, Bayes factors are computed using the BIC approximation.
Note that BICs are extracted from using <a href="insight.html#topic+get_loglikelihood">insight::get_loglikelihood</a>, see documentation
there for options for dealing with transformed responses and REML estimation.
</p>
</li></ul>

<p>In order to correctly and precisely estimate Bayes factors, a rule of thumb
are the 4 P's: <strong>P</strong>roper <strong>P</strong>riors and <strong>P</strong>lentiful
<strong>P</strong>osteriors. How many? The number of posterior samples needed for
testing is substantially larger than for estimation (the default of 4000
samples may not be enough in many cases). A conservative rule of thumb is to
obtain 10 times more samples than would be required for estimation
(<em>Gronau, Singmann, &amp; Wagenmakers, 2017</em>). If less than 40,000 samples
are detected, <code>bayesfactor_models()</code> gives a warning.
</p>
<p>See also <a href="https://easystats.github.io/bayestestR/articles/bayes_factors.html">the Bayes factors vignette</a>.
</p>


<h3>Value</h3>

<p>A data frame containing the models' formulas (reconstructed fixed and
random effects) and their <code>log(BF)</code>s  (Use <code>as.numeric()</code> to extract the
non-log Bayes factors; see examples), that prints nicely.
</p>


<h3>Interpreting Bayes Factors</h3>

<p>A Bayes factor greater than 1 can be interpreted as evidence against the
null, at which one convention is that a Bayes factor greater than 3 can be
considered as &quot;substantial&quot; evidence against the null (and vice versa, a
Bayes factor smaller than 1/3 indicates substantial evidence in favor of the
null-model) (<cite>Wetzels et al. 2011</cite>).
</p>


<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a>
implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>Author(s)</h3>

<p>Mattan S. Ben-Shachar
</p>


<h3>References</h3>


<ul>
<li><p> Gronau, Q. F., Singmann, H., &amp; Wagenmakers, E. J. (2017). Bridgesampling: An R package for estimating
normalizing constants. arXiv preprint arXiv:1710.08162.
</p>
</li>
<li><p> Kass, R. E., and Raftery, A. E. (1995). Bayes Factors. Journal of the American Statistical Association,
90(430), 773-795.
</p>
</li>
<li><p> Robert, C. P. (2016). The expected demise of the Bayes factor. Journal of Mathematical Psychology,
72, 33–37.
</p>
</li>
<li><p> Wagenmakers, E. J. (2007). A practical solution to the pervasive problems of p values.
Psychonomic bulletin &amp; review, 14(5), 779-804.
</p>
</li>
<li><p> Wetzels, R., Matzke, D., Lee, M. D., Rouder, J. N., Iverson, G. J., and Wagenmakers, E.-J. (2011).
Statistical Evidence in Experimental Psychology: An Empirical Comparison Using 855 t Tests.
Perspectives on Psychological Science, 6(3), 291–298. <a href="https://doi.org/10.1177/1745691611406923">doi:10.1177/1745691611406923</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# With lm objects:
# ----------------
lm1 &lt;- lm(mpg ~ 1, data = mtcars)
lm2 &lt;- lm(mpg ~ hp, data = mtcars)
lm3 &lt;- lm(mpg ~ hp + drat, data = mtcars)
lm4 &lt;- lm(mpg ~ hp * drat, data = mtcars)
(BFM &lt;- bayesfactor_models(lm1, lm2, lm3, lm4, denominator = 1))
# bayesfactor_models(lm2, lm3, lm4, denominator = lm1) # same result
# bayesfactor_models(lm1, lm2, lm3, lm4, denominator = lm1) # same result

update(BFM, reference = "bottom")
as.matrix(BFM)
as.numeric(BFM)

lm2b &lt;- lm(sqrt(mpg) ~ hp, data = mtcars)
# Set check_response = TRUE for transformed responses
bayesfactor_models(lm2b, denominator = lm2, check_response = TRUE)


# With lmerMod objects:
# ---------------------
lmer1 &lt;- lme4::lmer(Sepal.Length ~ Petal.Length + (1 | Species), data = iris)
lmer2 &lt;- lme4::lmer(Sepal.Length ~ Petal.Length + (Petal.Length | Species), data = iris)
lmer3 &lt;- lme4::lmer(
  Sepal.Length ~ Petal.Length + (Petal.Length | Species) + (1 | Petal.Width),
  data = iris
)
bayesfactor_models(lmer1, lmer2, lmer3,
  denominator = 1,
  estimator = "REML"
)

# rstanarm models
# ---------------------
# (note that a unique diagnostic_file MUST be specified in order to work)
stan_m0 &lt;- suppressWarnings(rstanarm::stan_glm(Sepal.Length ~ 1,
  data = iris,
  family = gaussian(),
  diagnostic_file = file.path(tempdir(), "df0.csv")
))
stan_m1 &lt;- suppressWarnings(rstanarm::stan_glm(Sepal.Length ~ Species,
  data = iris,
  family = gaussian(),
  diagnostic_file = file.path(tempdir(), "df1.csv")
))
stan_m2 &lt;- suppressWarnings(rstanarm::stan_glm(Sepal.Length ~ Species + Petal.Length,
  data = iris,
  family = gaussian(),
  diagnostic_file = file.path(tempdir(), "df2.csv")
))
bayesfactor_models(stan_m1, stan_m2, denominator = stan_m0, verbose = FALSE)


# brms models
# --------------------
# (note the save_pars MUST be set to save_pars(all = TRUE) in order to work)
brm1 &lt;- brms::brm(Sepal.Length ~ 1, data = iris, save_pars = save_pars(all = TRUE))
brm2 &lt;- brms::brm(Sepal.Length ~ Species, data = iris, save_pars = save_pars(all = TRUE))
brm3 &lt;- brms::brm(
  Sepal.Length ~ Species + Petal.Length,
  data = iris,
  save_pars = save_pars(all = TRUE)
)

bayesfactor_models(brm1, brm2, brm3, denominator = 1, verbose = FALSE)


# BayesFactor
# ---------------------------
data(puzzles)
BF &lt;- BayesFactor::anovaBF(RT ~ shape * color + ID,
  data = puzzles,
  whichRandom = "ID", progress = FALSE
)
BF
bayesfactor_models(BF) # basically the same


</code></pre>

<hr>
<h2 id='bayesfactor_parameters'>Bayes Factors (BF) for a Single Parameter</h2><span id='topic+bayesfactor_parameters'></span><span id='topic+bayesfactor_pointnull'></span><span id='topic+bayesfactor_rope'></span><span id='topic+bf_parameters'></span><span id='topic+bf_pointnull'></span><span id='topic+bf_rope'></span><span id='topic+bayesfactor_parameters.numeric'></span><span id='topic+bayesfactor_parameters.stanreg'></span><span id='topic+bayesfactor_parameters.brmsfit'></span><span id='topic+bayesfactor_parameters.blavaan'></span><span id='topic+bayesfactor_parameters.data.frame'></span>

<h3>Description</h3>

<p>This method computes Bayes factors against the null (either a point or an
interval), based on prior and posterior samples of a single parameter. This
Bayes factor indicates the degree by which the mass of the posterior
distribution has shifted further away from or closer to the null value(s)
(relative to the prior distribution), thus indicating if the null value has
become less or more likely given the observed data.
<br /> <br />
When the null is an interval, the Bayes factor is computed by comparing the
prior and posterior odds of the parameter falling within or outside the null
interval (Morey &amp; Rouder, 2011; Liao et al., 2020); When the null is a point,
a Savage-Dickey density ratio is computed, which is also an approximation of
a Bayes factor comparing the marginal likelihoods of the model against a
model in which the tested parameter has been restricted to the point null
(Wagenmakers et al., 2010; Heck, 2019).
<br /> <br />
Note that the <code>logspline</code> package is used for estimating densities and
probabilities, and must be installed for the function to work.
<br /> <br />
<code>bayesfactor_pointnull()</code> and <code>bayesfactor_rope()</code> are wrappers
around <code>bayesfactor_parameters</code> with different defaults for the null to
be tested against (a point and a range, respectively). Aliases of the main
functions are prefixed with <code style="white-space: pre;">&#8288;bf_*&#8288;</code>, like <code>bf_parameters()</code> or
<code>bf_pointnull()</code>.
<br /> <br />
<strong>For more info, in particular on specifying correct priors for factors
with more than 2 levels, see
<a href="https://easystats.github.io/bayestestR/articles/bayes_factors.html">the Bayes factors vignette</a>.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesfactor_parameters(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  verbose = TRUE,
  ...
)

bayesfactor_pointnull(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  verbose = TRUE,
  ...
)

bayesfactor_rope(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = rope_range(posterior, verbose = FALSE),
  verbose = TRUE,
  ...
)

bf_parameters(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  verbose = TRUE,
  ...
)

bf_pointnull(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  verbose = TRUE,
  ...
)

bf_rope(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = rope_range(posterior, verbose = FALSE),
  verbose = TRUE,
  ...
)

## S3 method for class 'numeric'
bayesfactor_parameters(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  verbose = TRUE,
  ...
)

## S3 method for class 'stanreg'
bayesfactor_parameters(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "location", "smooth_terms", "sigma", "zi",
    "zero_inflated", "all"),
  parameters = NULL,
  ...
)

## S3 method for class 'brmsfit'
bayesfactor_parameters(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "location", "smooth_terms", "sigma", "zi",
    "zero_inflated", "all"),
  parameters = NULL,
  ...
)

## S3 method for class 'blavaan'
bayesfactor_parameters(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  verbose = TRUE,
  ...
)

## S3 method for class 'data.frame'
bayesfactor_parameters(
  posterior,
  prior = NULL,
  direction = "two-sided",
  null = 0,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesfactor_parameters_+3A_posterior">posterior</code></td>
<td>
<p>A numerical vector, <code>stanreg</code> / <code>brmsfit</code> object,
<code>emmGrid</code> or a data frame - representing a posterior distribution(s)
from (see 'Details').</p>
</td></tr>
<tr><td><code id="bayesfactor_parameters_+3A_prior">prior</code></td>
<td>
<p>An object representing a prior distribution (see 'Details').</p>
</td></tr>
<tr><td><code id="bayesfactor_parameters_+3A_direction">direction</code></td>
<td>
<p>Test type (see 'Details'). One of <code>0</code>,
<code>"two-sided"</code> (default, two tailed), <code>-1</code>, <code>"left"</code> (left
tailed) or <code>1</code>, <code>"right"</code> (right tailed).</p>
</td></tr>
<tr><td><code id="bayesfactor_parameters_+3A_null">null</code></td>
<td>
<p>Value of the null, either a scalar (for point-null) or a range
(for a interval-null).</p>
</td></tr>
<tr><td><code id="bayesfactor_parameters_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="bayesfactor_parameters_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods. (Can be used to pass
arguments to internal <code><a href="logspline.html#topic+logspline">logspline::logspline()</a></code>.)</p>
</td></tr>
<tr><td><code id="bayesfactor_parameters_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="bayesfactor_parameters_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="bayesfactor_parameters_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is used to compute Bayes factors based on prior and posterior
distributions.
</p>


<h4>One-sided &amp; Dividing Tests (setting an order restriction)</h4>

<p>One sided tests (controlled by <code>direction</code>) are conducted by restricting
the prior and posterior of the non-null values (the &quot;alternative&quot;) to one
side of the null only (<cite>Morey &amp; Wagenmakers, 2014</cite>). For example, if we
have a prior hypothesis that the parameter should be positive, the
alternative will be restricted to the region to the right of the null (point
or interval). For example, for a Bayes factor comparing the &quot;null&quot; of <code>0-0.1</code>
to the alternative <code style="white-space: pre;">&#8288;&gt;0.1&#8288;</code>, we would set
<code>bayesfactor_parameters(null = c(0, 0.1), direction = "&gt;")</code>.
<br /><br />
It is also possible to compute a Bayes factor for <strong>dividing</strong>
hypotheses - that is, for a null and alternative that are complementary,
opposing one-sided hypotheses (<cite>Morey &amp; Wagenmakers, 2014</cite>). For
example, for a Bayes factor comparing the &quot;null&quot; of <code style="white-space: pre;">&#8288;&lt;0&#8288;</code> to the alternative
<code style="white-space: pre;">&#8288;&gt;0&#8288;</code>, we would set <code>bayesfactor_parameters(null = c(-Inf, 0))</code>.
</p>



<h3>Value</h3>

<p>A data frame containing the (log) Bayes factor representing evidence
<em>against</em> the null  (Use <code>as.numeric()</code> to extract the non-log Bayes
factors; see examples).
</p>


<h3>Setting the correct <code>prior</code></h3>

<p>For the computation of Bayes factors, the model priors must be proper priors
(at the very least they should be <em>not flat</em>, and it is preferable that
they be <em>informative</em>); As the priors for the alternative get wider, the
likelihood of the null value(s) increases, to the extreme that for completely
flat priors the null is infinitely more favorable than the alternative (this
is called <em>the Jeffreys-Lindley-Bartlett paradox</em>). Thus, you should
only ever try (or want) to compute a Bayes factor when you have an informed
prior.
<br /><br />
(Note that by default, <code>brms::brm()</code> uses flat priors for fixed-effects;
See example below.)
<br /><br />
It is important to provide the correct <code>prior</code> for meaningful results.
</p>

<ul>
<li><p> When <code>posterior</code> is a numerical vector, <code>prior</code> should also be a numerical vector.
</p>
</li>
<li><p> When <code>posterior</code> is a <code>data.frame</code>, <code>prior</code> should also be a <code>data.frame</code>, with matching column order.
</p>
</li>
<li><p> When <code>posterior</code> is a <code>stanreg</code>, <code>brmsfit</code> or other supported Bayesian model: </p>

<ul>
<li> <p><code>prior</code> can be set to <code>NULL</code>, in which case prior samples are drawn internally.
</p>
</li>
<li> <p><code>prior</code> can also be a model equivalent to <code>posterior</code> but with samples from
the priors <em>only</em>. See <code><a href="#topic+unupdate">unupdate()</a></code>.
</p>
</li>
<li> <p><strong>Note:</strong> When <code>posterior</code> is a <code>brmsfit_multiple</code> model, <code>prior</code> <strong>must</strong> be provided.
</p>
</li></ul>

</li>
<li><p> When <code>posterior</code> is an <code>emmGrid</code> / <code>emm_list</code> object: </p>

<ul>
<li> <p><code>prior</code> should also be an <code>emmGrid</code> / <code>emm_list</code> object equivalent to <code>posterior</code> but
created with a model of priors samples <em>only</em>. See <code><a href="#topic+unupdate">unupdate()</a></code>.
</p>
</li>
<li> <p><code>prior</code> can also be the original (posterior) <em>model</em>. If so, the function will try to
update the <code>emmGrid</code> / <code>emm_list</code> to use the <code><a href="#topic+unupdate">unupdate()</a></code>d prior-model.
(<em>This cannot be done for <code>brmsfit</code> models.</em>)
</p>
</li>
<li> <p><strong>Note</strong>: When the <code>emmGrid</code> has undergone any transformations (<code>"log"</code>, <code>"response"</code>, etc.),
or <code>regrid</code>ing, then <code>prior</code> must be an <code>emmGrid</code> object, as stated above.
</p>
</li></ul>

</li></ul>



<h3>Interpreting Bayes Factors</h3>

<p>A Bayes factor greater than 1 can be interpreted as evidence against the
null, at which one convention is that a Bayes factor greater than 3 can be
considered as &quot;substantial&quot; evidence against the null (and vice versa, a
Bayes factor smaller than 1/3 indicates substantial evidence in favor of the
null-model) (<cite>Wetzels et al. 2011</cite>).
</p>


<h3>Note</h3>

<p>There is also a
<a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a>
implemented in the
<a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>Author(s)</h3>

<p>Mattan S. Ben-Shachar
</p>


<h3>References</h3>


<ul>
<li><p> Wagenmakers, E. J., Lodewyckx, T., Kuriyal, H., and Grasman, R. (2010).
Bayesian hypothesis testing for psychologists: A tutorial on the
Savage-Dickey method. Cognitive psychology, 60(3), 158-189.
</p>
</li>
<li><p> Heck, D. W. (2019). A caveat on the Savage–Dickey density ratio: The
case of computing Bayes factors for regression parameters. British Journal of
Mathematical and Statistical Psychology, 72(2), 316-333.
</p>
</li>
<li><p> Morey, R. D., &amp; Wagenmakers, E. J. (2014). Simple relation between
Bayesian order-restricted and point-null hypothesis tests. Statistics &amp;
Probability Letters, 92, 121-124.
</p>
</li>
<li><p> Morey, R. D., &amp; Rouder, J. N. (2011). Bayes factor approaches for
testing interval null hypotheses. Psychological methods, 16(4), 406.
</p>
</li>
<li><p> Liao, J. G., Midya, V., &amp; Berg, A. (2020). Connecting and contrasting
the Bayes factor and a modified ROPE procedure for testing interval null
hypotheses. The American Statistician, 1-19.
</p>
</li>
<li><p> Wetzels, R., Matzke, D., Lee, M. D., Rouder, J. N., Iverson, G. J., and
Wagenmakers, E.-J. (2011). Statistical Evidence in Experimental Psychology:
An Empirical Comparison Using 855 t Tests. Perspectives on Psychological
Science, 6(3), 291–298. <a href="https://doi.org/10.1177/1745691611406923">doi:10.1177/1745691611406923</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)
prior &lt;- distribution_normal(1000, mean = 0, sd = 1)
posterior &lt;- distribution_normal(1000, mean = .5, sd = .3)
(BF_pars &lt;- bayesfactor_parameters(posterior, prior, verbose = FALSE))

as.numeric(BF_pars)



# rstanarm models
# ---------------
contrasts(sleep$group) &lt;- contr.equalprior_pairs # see vingette
stan_model &lt;- suppressWarnings(stan_lmer(
  extra ~ group + (1 | ID),
  data = sleep,
  refresh = 0
))
bayesfactor_parameters(stan_model, verbose = FALSE)
bayesfactor_parameters(stan_model, null = rope_range(stan_model))

# emmGrid objects
# ---------------
group_diff &lt;- pairs(emmeans(stan_model, ~group, data = sleep))
bayesfactor_parameters(group_diff, prior = stan_model, verbose = FALSE)

# Or
# group_diff_prior &lt;- pairs(emmeans(unupdate(stan_model), ~group))
# bayesfactor_parameters(group_diff, prior = group_diff_prior, verbose = FALSE)



# brms models
# -----------
## Not run: 
contrasts(sleep$group) &lt;- contr.equalprior_pairs # see vingette
my_custom_priors &lt;-
  set_prior("student_t(3, 0, 1)", class = "b") +
  set_prior("student_t(3, 0, 1)", class = "sd", group = "ID")

brms_model &lt;- suppressWarnings(brm(extra ~ group + (1 | ID),
  data = sleep,
  prior = my_custom_priors,
  refresh = 0
))
bayesfactor_parameters(brms_model, verbose = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='bayesfactor_restricted'>Bayes Factors (BF) for Order Restricted Models</h2><span id='topic+bayesfactor_restricted'></span><span id='topic+bf_restricted'></span><span id='topic+bayesfactor_restricted.stanreg'></span><span id='topic+bayesfactor_restricted.brmsfit'></span><span id='topic+bayesfactor_restricted.blavaan'></span><span id='topic+bayesfactor_restricted.emmGrid'></span><span id='topic+as.logical.bayesfactor_restricted'></span>

<h3>Description</h3>

<p>This method computes Bayes factors for comparing a model with an order restrictions on its parameters
with the fully unrestricted model. <em>Note that this method should only be used for confirmatory analyses</em>.
<br /> <br />
The <code style="white-space: pre;">&#8288;bf_*&#8288;</code> function is an alias of the main function.
<br /> <br />
<strong>For more info, in particular on specifying correct priors for factors with more than 2 levels,
see <a href="https://easystats.github.io/bayestestR/articles/bayes_factors.html">the Bayes factors vignette</a>.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bayesfactor_restricted(
  posterior,
  hypothesis,
  prior = NULL,
  verbose = TRUE,
  ...
)

bf_restricted(posterior, hypothesis, prior = NULL, verbose = TRUE, ...)

## S3 method for class 'stanreg'
bayesfactor_restricted(
  posterior,
  hypothesis,
  prior = NULL,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  ...
)

## S3 method for class 'brmsfit'
bayesfactor_restricted(
  posterior,
  hypothesis,
  prior = NULL,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  ...
)

## S3 method for class 'blavaan'
bayesfactor_restricted(
  posterior,
  hypothesis,
  prior = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'emmGrid'
bayesfactor_restricted(
  posterior,
  hypothesis,
  prior = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'bayesfactor_restricted'
as.logical(x, which = c("posterior", "prior"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesfactor_restricted_+3A_posterior">posterior</code></td>
<td>
<p>A <code>stanreg</code> / <code>brmsfit</code> object, <code>emmGrid</code> or a data frame - representing
a posterior distribution(s) from (see Details).</p>
</td></tr>
<tr><td><code id="bayesfactor_restricted_+3A_hypothesis">hypothesis</code></td>
<td>
<p>A character vector specifying the restrictions as logical conditions (see examples below).</p>
</td></tr>
<tr><td><code id="bayesfactor_restricted_+3A_prior">prior</code></td>
<td>
<p>An object representing a prior distribution (see Details).</p>
</td></tr>
<tr><td><code id="bayesfactor_restricted_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="bayesfactor_restricted_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="bayesfactor_restricted_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="bayesfactor_restricted_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="bayesfactor_restricted_+3A_x">x</code></td>
<td>
<p>An object of class <code>bayesfactor_restricted</code></p>
</td></tr>
<tr><td><code id="bayesfactor_restricted_+3A_which">which</code></td>
<td>
<p>Should the logical matrix be of the posterior or prior distribution(s)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is used to compute Bayes factors for order-restricted models vs un-restricted
models by setting an order restriction on the prior and posterior distributions
(<cite>Morey &amp; Wagenmakers, 2013</cite>).
<br /><br />
(Though it is possible to use <code>bayesfactor_restricted()</code> to test interval restrictions,
it is more suitable for testing order restrictions; see examples).
</p>


<h3>Value</h3>

<p>A data frame containing the (log) Bayes factor representing evidence
<em>against</em> the un-restricted model (Use <code>as.numeric()</code> to extract the
non-log Bayes factors; see examples). (A <code>bool_results</code> attribute contains
the results for each sample, indicating if they are included or not in the
hypothesized restriction.)
</p>


<h3>Setting the correct <code>prior</code></h3>

<p>For the computation of Bayes factors, the model priors must be proper priors
(at the very least they should be <em>not flat</em>, and it is preferable that
they be <em>informative</em>); As the priors for the alternative get wider, the
likelihood of the null value(s) increases, to the extreme that for completely
flat priors the null is infinitely more favorable than the alternative (this
is called <em>the Jeffreys-Lindley-Bartlett paradox</em>). Thus, you should
only ever try (or want) to compute a Bayes factor when you have an informed
prior.
<br /><br />
(Note that by default, <code>brms::brm()</code> uses flat priors for fixed-effects;
See example below.)
<br /><br />
It is important to provide the correct <code>prior</code> for meaningful results.
</p>

<ul>
<li><p> When <code>posterior</code> is a numerical vector, <code>prior</code> should also be a numerical vector.
</p>
</li>
<li><p> When <code>posterior</code> is a <code>data.frame</code>, <code>prior</code> should also be a <code>data.frame</code>, with matching column order.
</p>
</li>
<li><p> When <code>posterior</code> is a <code>stanreg</code>, <code>brmsfit</code> or other supported Bayesian model: </p>

<ul>
<li> <p><code>prior</code> can be set to <code>NULL</code>, in which case prior samples are drawn internally.
</p>
</li>
<li> <p><code>prior</code> can also be a model equivalent to <code>posterior</code> but with samples from
the priors <em>only</em>. See <code><a href="#topic+unupdate">unupdate()</a></code>.
</p>
</li>
<li> <p><strong>Note:</strong> When <code>posterior</code> is a <code>brmsfit_multiple</code> model, <code>prior</code> <strong>must</strong> be provided.
</p>
</li></ul>

</li>
<li><p> When <code>posterior</code> is an <code>emmGrid</code> / <code>emm_list</code> object: </p>

<ul>
<li> <p><code>prior</code> should also be an <code>emmGrid</code> / <code>emm_list</code> object equivalent to <code>posterior</code> but
created with a model of priors samples <em>only</em>. See <code><a href="#topic+unupdate">unupdate()</a></code>.
</p>
</li>
<li> <p><code>prior</code> can also be the original (posterior) <em>model</em>. If so, the function will try to
update the <code>emmGrid</code> / <code>emm_list</code> to use the <code><a href="#topic+unupdate">unupdate()</a></code>d prior-model.
(<em>This cannot be done for <code>brmsfit</code> models.</em>)
</p>
</li>
<li> <p><strong>Note</strong>: When the <code>emmGrid</code> has undergone any transformations (<code>"log"</code>, <code>"response"</code>, etc.),
or <code>regrid</code>ing, then <code>prior</code> must be an <code>emmGrid</code> object, as stated above.
</p>
</li></ul>

</li></ul>



<h3>Interpreting Bayes Factors</h3>

<p>A Bayes factor greater than 1 can be interpreted as evidence against the
null, at which one convention is that a Bayes factor greater than 3 can be
considered as &quot;substantial&quot; evidence against the null (and vice versa, a
Bayes factor smaller than 1/3 indicates substantial evidence in favor of the
null-model) (<cite>Wetzels et al. 2011</cite>).
</p>


<h3>References</h3>


<ul>
<li><p> Morey, R. D., &amp; Wagenmakers, E. J. (2014). Simple relation between Bayesian order-restricted and
point-null hypothesis tests. Statistics &amp; Probability Letters, 92, 121-124.
</p>
</li>
<li><p> Morey, R. D., &amp; Rouder, J. N. (2011). Bayes factor approaches for testing interval null hypotheses.
Psychological methods, 16(4), 406.
</p>
</li>
<li><p> Morey, R. D. (Jan, 2015). Multiple Comparisons with BayesFactor, Part 2 – order restrictions.
Retrieved from https://richarddmorey.org/category/order-restrictions/.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(444)
library(bayestestR)
prior &lt;- data.frame(
  A = rnorm(500),
  B = rnorm(500),
  C = rnorm(500)
)

posterior &lt;- data.frame(
  A = rnorm(500, .4, 0.7),
  B = rnorm(500, -.2, 0.4),
  C = rnorm(500, 0, 0.5)
)

hyps &lt;- c(
  "A &gt; B &amp; B &gt; C",
  "A &gt; B &amp; A &gt; C",
  "C &gt; A"
)


(b &lt;- bayesfactor_restricted(posterior, hypothesis = hyps, prior = prior))

bool &lt;- as.logical(b, which = "posterior")
head(bool)



see::plots(
  plot(estimate_density(posterior)),
  # distribution **conditional** on the restrictions
  plot(estimate_density(posterior[bool[, hyps[1]], ])) + ggplot2::ggtitle(hyps[1]),
  plot(estimate_density(posterior[bool[, hyps[2]], ])) + ggplot2::ggtitle(hyps[2]),
  plot(estimate_density(posterior[bool[, hyps[3]], ])) + ggplot2::ggtitle(hyps[3]),
  guides = "collect"
)



# rstanarm models
# ---------------
data("mtcars")

fit_stan &lt;- rstanarm::stan_glm(mpg ~ wt + cyl + am,
  data = mtcars, refresh = 0
)
hyps &lt;- c(
  "am &gt; 0 &amp; cyl &lt; 0",
  "cyl &lt; 0",
  "wt - cyl &gt; 0"
)

bayesfactor_restricted(fit_stan, hypothesis = hyps)




# emmGrid objects
# ---------------
# replicating http://bayesfactor.blogspot.com/2015/01/multiple-comparisons-with-bayesfactor-2.html
data("disgust")
contrasts(disgust$condition) &lt;- contr.equalprior_pairs # see vignette
fit_model &lt;- rstanarm::stan_glm(score ~ condition, data = disgust, family = gaussian())

em_condition &lt;- emmeans::emmeans(fit_model, ~condition, data = disgust)
hyps &lt;- c("lemon &lt; control &amp; control &lt; sulfur")

bayesfactor_restricted(em_condition, prior = fit_model, hypothesis = hyps)
# &gt; # Bayes Factor (Order-Restriction)
# &gt;
# &gt;                          Hypothesis P(Prior) P(Posterior)   BF
# &gt;  lemon &lt; control &amp; control &lt; sulfur     0.17         0.75 4.49
# &gt; ---
# &gt; Bayes factors for the restricted model vs. the un-restricted model.


</code></pre>

<hr>
<h2 id='bayestestR-package'>bayestestR: Describing Effects and their Uncertainty, Existence and
Significance within the Bayesian Framework</h2><span id='topic+bayestestR-package'></span><span id='topic+bayestestR'></span>

<h3>Description</h3>

<p>Existing R packages allow users to easily fit a large variety of models
and extract and visualize the posterior draws. However, most of these
packages only return a limited set of indices (e.g., point-estimates and
CIs). <strong>bayestestR</strong> provides a comprehensive and consistent set of
functions to analyze and describe posterior distributions generated by a
variety of models objects, including popular modeling packages such as
<strong>rstanarm</strong>, <strong>brms</strong> or <strong>BayesFactor</strong>.
</p>
<p>References:
</p>

<ul>
<li><p> Makowski et al. (2019) <a href="https://doi.org/10.21105/joss.01541">doi:10.21105/joss.01541</a>
</p>
</li>
<li><p> Makowski et al. (2019) <a href="https://doi.org/10.3389/fpsyg.2019.02767">doi:10.3389/fpsyg.2019.02767</a>
</p>
</li></ul>



<h3>Details</h3>

<p><code>bayestestR</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dominique Makowski <a href="mailto:dom.makowski@gmail.com">dom.makowski@gmail.com</a> (<a href="https://orcid.org/0000-0001-5375-9967">ORCID</a>) (@Dom_Makowski)
</p>
<p>Authors:
</p>

<ul>
<li><p> Daniel Lüdecke <a href="mailto:d.luedecke@uke.de">d.luedecke@uke.de</a> (<a href="https://orcid.org/0000-0002-8895-3206">ORCID</a>) (@strengejacke)
</p>
</li>
<li><p> Mattan S. Ben-Shachar <a href="mailto:matanshm@post.bgu.ac.il">matanshm@post.bgu.ac.il</a> (<a href="https://orcid.org/0000-0002-4287-4801">ORCID</a>) (@mattansb)
</p>
</li>
<li><p> Indrajeet Patil <a href="mailto:patilindrajeet.science@gmail.com">patilindrajeet.science@gmail.com</a> (<a href="https://orcid.org/0000-0003-1995-6531">ORCID</a>) (@patilindrajeets)
</p>
</li>
<li><p> Michael D. Wilson <a href="mailto:michael.d.wilson@curtin.edu.au">michael.d.wilson@curtin.edu.au</a> (<a href="https://orcid.org/0000-0003-4143-7308">ORCID</a>)
</p>
</li>
<li><p> Brenton M. Wiernik <a href="mailto:brenton@wiernik.org">brenton@wiernik.org</a> (<a href="https://orcid.org/0000-0001-9560-6336">ORCID</a>) (@bmwiernik)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Paul-Christian Bürkner <a href="mailto:paul.buerkner@gmail.com">paul.buerkner@gmail.com</a> [reviewer]
</p>
</li>
<li><p> Tristan Mahr <a href="mailto:tristan.mahr@wisc.edu">tristan.mahr@wisc.edu</a> (<a href="https://orcid.org/0000-0002-8890-5116">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Henrik Singmann <a href="mailto:singmann@gmail.com">singmann@gmail.com</a> (<a href="https://orcid.org/0000-0002-4842-3657">ORCID</a>) [contributor]
</p>
</li>
<li><p> Quentin F. Gronau (<a href="https://orcid.org/0000-0001-5510-6943">ORCID</a>) [contributor]
</p>
</li>
<li><p> Sam Crawley <a href="mailto:sam@crawley.nz">sam@crawley.nz</a> (<a href="https://orcid.org/0000-0002-7847-0411">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://easystats.github.io/bayestestR/">https://easystats.github.io/bayestestR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/easystats/bayestestR/issues">https://github.com/easystats/bayestestR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bci'>Bias Corrected and Accelerated Interval (BCa)</h2><span id='topic+bci'></span><span id='topic+bcai'></span><span id='topic+bci.numeric'></span><span id='topic+bci.data.frame'></span><span id='topic+bci.MCMCglmm'></span><span id='topic+bci.sim.merMod'></span><span id='topic+bci.sim'></span><span id='topic+bci.emmGrid'></span><span id='topic+bci.stanreg'></span><span id='topic+bci.brmsfit'></span><span id='topic+bci.BFBayesFactor'></span><span id='topic+bci.get_predicted'></span>

<h3>Description</h3>

<p>Compute the <strong>Bias Corrected and Accelerated Interval (BCa)</strong> of posterior
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bci(x, ...)

bcai(x, ...)

## S3 method for class 'numeric'
bci(x, ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'data.frame'
bci(x, ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'MCMCglmm'
bci(x, ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'sim.merMod'
bci(
  x,
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'sim'
bci(x, ci = 0.95, parameters = NULL, verbose = TRUE, ...)

## S3 method for class 'emmGrid'
bci(x, ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'stanreg'
bci(
  x,
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'brmsfit'
bci(
  x,
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'BFBayesFactor'
bci(x, ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'get_predicted'
bci(x, ci = 0.95, use_iterations = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bci_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution, or a data frame of such
vectors. Can also be a Bayesian model. <strong>bayestestR</strong> supports a wide range
of models (see, for example, <code>methods("hdi")</code>) and not all of those are
documented in the 'Usage' section, because methods for other classes mostly
resemble the arguments of the <code>.numeric</code> or <code>.data.frame</code>methods.</p>
</td></tr>
<tr><td><code id="bci_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="bci_+3A_ci">ci</code></td>
<td>
<p>Value or vector of probability of the (credible) interval - CI
(between 0 and 1) to be estimated. Default to <code>.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="bci_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="bci_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="bci_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="bci_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="bci_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike equal-tailed intervals (see <code>eti()</code>) that typically exclude <code style="white-space: pre;">&#8288;2.5%&#8288;</code>
from each tail of the distribution and always include the median, the HDI is
<em>not</em> equal-tailed and therefore always includes the mode(s) of posterior
distributions. While this can be useful to better represent the credibility
mass of a distribution, the HDI also has some limitations. See <code><a href="#topic+spi">spi()</a></code> for
details.
</p>
<p>The <a href="https://easystats.github.io/bayestestR/articles/credible_interval.html"><code style="white-space: pre;">&#8288;95%&#8288;</code> or <code style="white-space: pre;">&#8288;89%&#8288;</code> Credible Intervals (CI)</a>
are two reasonable ranges to characterize the uncertainty related to the
estimation (see <a href="https://easystats.github.io/bayestestR/articles/credible_interval.html">here</a>
for a discussion about the differences between these two values).
</p>
<p>The <code style="white-space: pre;">&#8288;89%&#8288;</code> intervals (<code>ci = 0.89</code>) are deemed to be more stable than, for
instance, <code style="white-space: pre;">&#8288;95%&#8288;</code> intervals (<em>Kruschke, 2014</em>). An effective sample size
of at least 10.000 is recommended if one wants to estimate <code style="white-space: pre;">&#8288;95%&#8288;</code> intervals
with high precision (<em>Kruschke, 2014, p. 183ff</em>). Unfortunately, the
default number of posterior samples for most Bayes packages (e.g., <code>rstanarm</code>
or <code>brms</code>) is only 4.000 (thus, you might want to increase it when fitting
your model). Moreover, 89 indicates the arbitrariness of interval limits -
its only remarkable property is being the highest prime number that does not
exceed the already unstable <code style="white-space: pre;">&#8288;95%&#8288;</code> threshold (<em>McElreath, 2015</em>).
</p>
<p>However, <code style="white-space: pre;">&#8288;95%&#8288;</code> has some <a href="https://easystats.github.io/blog/posts/bayestestr_95/">advantages too</a>. For instance, it
shares (in the case of a normal posterior distribution) an intuitive
relationship with the standard deviation and it conveys a more accurate image
of the (artificial) bounds of the distribution. Also, because it is wider, it
makes analyses more conservative (i.e., the probability of covering 0 is
larger for the <code style="white-space: pre;">&#8288;95%&#8288;</code> CI than for lower ranges such as <code style="white-space: pre;">&#8288;89%&#8288;</code>), which is a good
thing in the context of the reproducibility crisis.
</p>
<p>A <code style="white-space: pre;">&#8288;95%&#8288;</code> equal-tailed interval (ETI) has <code style="white-space: pre;">&#8288;2.5%&#8288;</code> of the distribution on either
side of its limits. It indicates the 2.5th percentile and the 97.5h
percentile. In symmetric distributions, the two methods of computing credible
intervals, the ETI and the <a href="#topic+hdi">HDI</a>, return similar results.
</p>
<p>This is not the case for skewed distributions. Indeed, it is possible that
parameter values in the ETI have lower credibility (are less probable) than
parameter values outside the ETI. This property seems undesirable as a summary
of the credible values in a distribution.
</p>
<p>On the other hand, the ETI range does change when transformations are applied
to the distribution (for instance, for a log odds scale to probabilities):
the lower and higher bounds of the transformed distribution will correspond
to the transformed lower and higher bounds of the original distribution.
On the contrary, applying transformations to the distribution will change
the resulting HDI.
</p>


<h3>Value</h3>

<p>A data frame with following columns:
</p>

<ul>
<li> <p><code>Parameter</code> The model parameter(s), if <code>x</code> is a model-object. If <code>x</code> is a
vector, this column is missing.
</p>
</li>
<li> <p><code>CI</code> The probability of the credible interval.
</p>
</li>
<li> <p><code>CI_low</code>, <code>CI_high</code> The lower and upper credible interval limits for the parameters.
</p>
</li></ul>



<h3>References</h3>

<p>DiCiccio, T. J. and B. Efron. (1996). Bootstrap Confidence Intervals.
Statistical Science. 11(3): 189–212. 10.1214/ss/1032280214
</p>


<h3>See Also</h3>

<p>Other ci: 
<code><a href="#topic+ci">ci</a>()</code>,
<code><a href="#topic+cwi">cwi</a>()</code>,
<code><a href="#topic+eti">eti</a>()</code>,
<code><a href="#topic+hdi">hdi</a>()</code>,
<code><a href="#topic+si">si</a>()</code>,
<code><a href="#topic+spi">spi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior &lt;- rnorm(1000)
bci(posterior)
bci(posterior, ci = c(0.80, 0.89, 0.95))
</code></pre>

<hr>
<h2 id='bic_to_bf'>Convert BIC indices to Bayes Factors via the BIC-approximation method.</h2><span id='topic+bic_to_bf'></span>

<h3>Description</h3>

<p>The difference between two Bayesian information criterion (BIC) indices of
two models can be used to approximate Bayes factors via:
<br />
</p>
<p style="text-align: center;"><code class="reqn">BF_{10} = e^{(BIC_0 - BIC_1)/2}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>bic_to_bf(bic, denominator, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bic_to_bf_+3A_bic">bic</code></td>
<td>
<p>A vector of BIC values.</p>
</td></tr>
<tr><td><code id="bic_to_bf_+3A_denominator">denominator</code></td>
<td>
<p>The BIC value to use as a denominator (to test against).</p>
</td></tr>
<tr><td><code id="bic_to_bf_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code>, return the <code>log(BF)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Bayes Factors corresponding to the BIC values against the denominator.
</p>


<h3>References</h3>

<p>Wagenmakers, E. J. (2007). A practical solution to the pervasive problems of
p values. Psychonomic bulletin &amp; review, 14(5), 779-804
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bic1 &lt;- BIC(lm(Sepal.Length ~ 1, data = iris))
bic2 &lt;- BIC(lm(Sepal.Length ~ Species, data = iris))
bic3 &lt;- BIC(lm(Sepal.Length ~ Species + Petal.Length, data = iris))
bic4 &lt;- BIC(lm(Sepal.Length ~ Species * Petal.Length, data = iris))

bic_to_bf(c(bic1, bic2, bic3, bic4), denominator = bic1)
</code></pre>

<hr>
<h2 id='check_prior'>Check if Prior is Informative</h2><span id='topic+check_prior'></span>

<h3>Description</h3>

<p>Performs a simple test to check whether the prior is informative to the
posterior. This idea, and the accompanying heuristics, were discussed in
<a href="https://statmodeling.stat.columbia.edu/2019/08/10/">this blogpost</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_prior(model, method = "gelman", simulate_priors = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_prior_+3A_model">model</code></td>
<td>
<p>A <code>stanreg</code>, <code>stanfit</code>, <code>brmsfit</code>, <code>blavaan</code>, or <code>MCMCglmm</code> object.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_method">method</code></td>
<td>
<p>Can be <code>"gelman"</code> or <code>"lakeland"</code>. For the
<code>"gelman"</code> method, if the SD of the posterior is more than 0.1 times
the SD of the prior, then the prior is considered as informative. For the
<code>"lakeland"</code> method, the prior is considered as informative if the
posterior falls within the <code style="white-space: pre;">&#8288;95%&#8288;</code> HDI of the prior.</p>
</td></tr>
<tr><td><code id="check_prior_+3A_simulate_priors">simulate_priors</code></td>
<td>
<p>Should prior distributions be simulated using
<code><a href="#topic+simulate_prior">simulate_prior()</a></code> (default; faster) or sampled via
<code><a href="#topic+unupdate">unupdate()</a></code> (slower, more accurate).</p>
</td></tr>
<tr><td><code id="check_prior_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: The parameter names and the quality
of the prior (which might be <code>"informative"</code>, <code>"uninformative"</code>)
or <code>"not determinable"</code> if the prior distribution could not be
determined).
</p>


<h3>References</h3>

<p>https://statmodeling.stat.columbia.edu/2019/08/10/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)
if (require("rstanarm")) {
  model &lt;- stan_glm(mpg ~ wt + am, data = mtcars, chains = 1, refresh = 0)
  check_prior(model, method = "gelman")
  check_prior(model, method = "lakeland")

  # An extreme example where both methods diverge:
  model &lt;- stan_glm(mpg ~ wt,
    data = mtcars[1:3, ],
    prior = normal(-3.3, 1, FALSE),
    prior_intercept = normal(0, 1000, FALSE),
    refresh = 0
  )
  check_prior(model, method = "gelman")
  check_prior(model, method = "lakeland")
  # can provide visual confirmation to the Lakeland method
  plot(si(model, verbose = FALSE))
}

</code></pre>

<hr>
<h2 id='ci'>Confidence/Credible/Compatibility Interval (CI)</h2><span id='topic+ci'></span><span id='topic+ci.numeric'></span><span id='topic+ci.data.frame'></span><span id='topic+ci.sim.merMod'></span><span id='topic+ci.sim'></span><span id='topic+ci.stanreg'></span><span id='topic+ci.brmsfit'></span><span id='topic+ci.BFBayesFactor'></span><span id='topic+ci.MCMCglmm'></span>

<h3>Description</h3>

<p>Compute Confidence/Credible/Compatibility Intervals (CI) or Support Intervals
(SI) for Bayesian and frequentist models. The Documentation is accessible
for:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(x, ...)

## S3 method for class 'numeric'
ci(x, ci = 0.95, method = "ETI", verbose = TRUE, BF = 1, ...)

## S3 method for class 'data.frame'
ci(x, ci = 0.95, method = "ETI", verbose = TRUE, BF = 1, ...)

## S3 method for class 'sim.merMod'
ci(
  x,
  ci = 0.95,
  method = "ETI",
  effects = c("fixed", "random", "all"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'sim'
ci(x, ci = 0.95, method = "ETI", parameters = NULL, verbose = TRUE, ...)

## S3 method for class 'stanreg'
ci(
  x,
  ci = 0.95,
  method = "ETI",
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  verbose = TRUE,
  BF = 1,
  ...
)

## S3 method for class 'brmsfit'
ci(
  x,
  ci = 0.95,
  method = "ETI",
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  verbose = TRUE,
  BF = 1,
  ...
)

## S3 method for class 'BFBayesFactor'
ci(x, ci = 0.95, method = "ETI", verbose = TRUE, BF = 1, ...)

## S3 method for class 'MCMCglmm'
ci(x, ci = 0.95, method = "ETI", verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_+3A_x">x</code></td>
<td>
<p>A <code>stanreg</code> or <code>brmsfit</code> model, or a vector representing a posterior
distribution.</p>
</td></tr>
<tr><td><code id="ci_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="ci_+3A_ci">ci</code></td>
<td>
<p>Value or vector of probability of the CI (between 0 and 1)
to be estimated. Default to <code>0.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="ci_+3A_method">method</code></td>
<td>
<p>Can be <a href="#topic+eti">&quot;ETI&quot;</a> (default), <a href="#topic+hdi">&quot;HDI&quot;</a>, <a href="#topic+bci">&quot;BCI&quot;</a>,
<a href="#topic+spi">&quot;SPI&quot;</a> or <a href="#topic+si">&quot;SI&quot;</a>.</p>
</td></tr>
<tr><td><code id="ci_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="ci_+3A_bf">BF</code></td>
<td>
<p>The amount of support required to be included in the support interval.</p>
</td></tr>
<tr><td><code id="ci_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="ci_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="ci_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><a href="https://easystats.github.io/bayestestR/articles/credible_interval.html">Bayesian models</a>
</p>
</li>
<li> <p><a href="https://easystats.github.io/parameters/reference/ci.default.html">Frequentist models</a>
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame with following columns:
</p>

<ul>
<li> <p><code>Parameter</code> The model parameter(s), if <code>x</code> is a model-object. If <code>x</code> is a
vector, this column is missing.
</p>
</li>
<li> <p><code>CI</code> The probability of the credible interval.
</p>
</li>
<li> <p><code>CI_low</code>, <code>CI_high</code> The lower and upper credible interval limits for the parameters.
</p>
</li></ul>



<h3>Note</h3>

<p>When it comes to interpretation, we recommend thinking of the CI in terms of
an &quot;uncertainty&quot; or &quot;compatibility&quot; interval, the latter being defined as
&quot;Given any value in the interval and the background assumptions,
the data should not seem very surprising&quot; (<em>Gelman &amp; Greenland 2019</em>).
</p>
<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>References</h3>

<p>Gelman A, Greenland S. Are confidence intervals better termed &quot;uncertainty
intervals&quot;? BMJ 2019;l5381. 10.1136/bmj.l5381
</p>


<h3>See Also</h3>

<p>Other ci: 
<code><a href="#topic+bci">bci</a>()</code>,
<code><a href="#topic+cwi">cwi</a>()</code>,
<code><a href="#topic+eti">eti</a>()</code>,
<code><a href="#topic+hdi">hdi</a>()</code>,
<code><a href="#topic+si">si</a>()</code>,
<code><a href="#topic+spi">spi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

posterior &lt;- rnorm(1000)
ci(posterior, method = "ETI")
ci(posterior, method = "HDI")

df &lt;- data.frame(replicate(4, rnorm(100)))
ci(df, method = "ETI", ci = c(0.80, 0.89, 0.95))
ci(df, method = "HDI", ci = c(0.80, 0.89, 0.95))

model &lt;- suppressWarnings(
  stan_glm(mpg ~ wt, data = mtcars, chains = 2, iter = 200, refresh = 0)
)
ci(model, method = "ETI", ci = c(0.80, 0.89))
ci(model, method = "HDI", ci = c(0.80, 0.89))


bf &lt;- ttestBF(x = rnorm(100, 1, 1))
ci(bf, method = "ETI")
ci(bf, method = "HDI")


model &lt;- emtrends(model, ~1, "wt", data = mtcars)
ci(model, method = "ETI")
ci(model, method = "HDI")

</code></pre>

<hr>
<h2 id='contr.equalprior'>Contrast Matrices for Equal Marginal Priors in Bayesian Estimation</h2><span id='topic+contr.equalprior'></span><span id='topic+contr.bayes'></span><span id='topic+contr.orthonorm'></span><span id='topic+contr.equalprior_pairs'></span><span id='topic+contr.equalprior_deviations'></span>

<h3>Description</h3>

<p>Build contrasts for factors with equal marginal priors on all levels. The 3
functions give the same orthogonal contrasts, but are scaled differently to
allow different prior specifications (see 'Details'). Implementation from
Singmann &amp; Gronau's <a href="https://github.com/bayesstuff/bfrms/"><code>bfrms</code></a>,
following the description in Rouder, Morey, Speckman, &amp; Province (2012, p.
363).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.equalprior(n, contrasts = TRUE, sparse = FALSE)

contr.equalprior_pairs(n, contrasts = TRUE, sparse = FALSE)

contr.equalprior_deviations(n, contrasts = TRUE, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.equalprior_+3A_n">n</code></td>
<td>
<p>a vector of levels for a factor, or the number of levels.</p>
</td></tr>
<tr><td><code id="contr.equalprior_+3A_contrasts">contrasts</code></td>
<td>
<p>a logical indicating whether contrasts should be
computed.</p>
</td></tr>
<tr><td><code id="contr.equalprior_+3A_sparse">sparse</code></td>
<td>
<p>logical indicating if the result should be sparse
(of class <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>), using
package <a href="https://CRAN.R-project.org/package=Matrix"><span class="pkg">Matrix</span></a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using <code><a href="stats.html#topic+contrast">stats::contr.treatment</a></code>, each dummy variable is the difference
between each level and the reference level. While this is useful if setting
different priors for each coefficient, it should not be used if one is trying
to set a general prior for differences between means, as it (as well as
<code><a href="stats.html#topic+contrast">stats::contr.sum</a></code> and others) results in unequal marginal priors on the
means the the difference between them.
</p>
<div class="sourceCode"><pre>library(brms)

data &lt;- data.frame(
  group = factor(rep(LETTERS[1:4], each = 3)),
  y = rnorm(12)
)

contrasts(data$group) # R's default contr.treatment
#&gt;   B C D
#&gt; A 0 0 0
#&gt; B 1 0 0
#&gt; C 0 1 0
#&gt; D 0 0 1

model_prior &lt;- brm(
  y ~ group, data = data,
  sample_prior = "only",
  # Set the same priors on the 3 dummy variable
  # (Using an arbitrary scale)
  prior = set_prior("normal(0, 10)", coef = c("groupB", "groupC", "groupD"))
)

est &lt;- emmeans::emmeans(model_prior, pairwise ~ group)

point_estimate(est, centr = "mean", disp = TRUE)
#&gt; Point Estimate
#&gt;
#&gt; Parameter |  Mean |    SD
#&gt; -------------------------
#&gt; A         | -0.01 |  6.35
#&gt; B         | -0.10 |  9.59
#&gt; C         |  0.11 |  9.55
#&gt; D         | -0.16 |  9.52
#&gt; A - B     |  0.10 |  9.94
#&gt; A - C     | -0.12 |  9.96
#&gt; A - D     |  0.15 |  9.87
#&gt; B - C     | -0.22 | 14.38
#&gt; B - D     |  0.05 | 14.14
#&gt; C - D     |  0.27 | 14.00
</pre></div>
<p>We can see that the priors for means aren't all the same (<code>A</code> having a more
narrow prior), and likewise for the pairwise differences (priors for
differences from <code>A</code> are more narrow).
</p>
<p>The solution is to use one of the methods provided here, which <em>do</em> result in
marginally equal priors on means differences between them. Though this will
obscure the interpretation of parameters, setting equal priors on means and
differences is important for they are useful for specifying equal priors on
all means in a factor and their differences correct estimation of Bayes
factors for contrasts and order restrictions of multi-level factors (where
<code>k&gt;2</code>). See info on specifying correct priors for factors with more than 2
levels in <a href="https://easystats.github.io/bayestestR/articles/bayes_factors.html">the Bayes factors vignette</a>.
</p>
<p><em><strong>NOTE:</strong></em> When setting priors on these dummy variables, always:
</p>

<ol>
<li><p> Use priors that are <strong>centered on 0</strong>! Other location/centered priors are meaningless!
</p>
</li>
<li><p> Use <strong>identically-scaled priors</strong> on all the dummy variables of a single factor!
</p>
</li></ol>

<p><code>contr.equalprior</code> returns the original orthogonal-normal contrasts as
described in Rouder, Morey, Speckman, &amp; Province (2012, p. 363). Setting
<code>contrasts = FALSE</code> returns the <code class="reqn">I_{n} - \frac{1}{n}</code> matrix.
</p>


<h4><code>contr.equalprior_pairs</code></h4>

<p>Useful for setting priors in terms of pairwise differences between means -
the scales of the priors defines the prior distribution of the pair-wise
differences between all pairwise differences (e.g., <code>A - B</code>, <code>B - C</code>, etc.).
</p>
<div class="sourceCode"><pre>contrasts(data$group) &lt;- contr.equalprior_pairs
contrasts(data$group)
#&gt;         [,1]       [,2]       [,3]
#&gt; A  0.0000000  0.6123724  0.0000000
#&gt; B -0.1893048 -0.2041241  0.5454329
#&gt; C -0.3777063 -0.2041241 -0.4366592
#&gt; D  0.5670111 -0.2041241 -0.1087736

model_prior &lt;- brm(
  y ~ group, data = data,
  sample_prior = "only",
  # Set the same priors on the 3 dummy variable
  # (Using an arbitrary scale)
  prior = set_prior("normal(0, 10)", coef = c("group1", "group2", "group3"))
)

est &lt;- emmeans(model_prior, pairwise ~ group)

point_estimate(est, centr = "mean", disp = TRUE)
#&gt; Point Estimate
#&gt;
#&gt; Parameter |  Mean |    SD
#&gt; -------------------------
#&gt; A         | -0.31 |  7.46
#&gt; B         | -0.24 |  7.47
#&gt; C         | -0.34 |  7.50
#&gt; D         | -0.30 |  7.25
#&gt; A - B     | -0.08 | 10.00
#&gt; A - C     |  0.03 | 10.03
#&gt; A - D     | -0.01 |  9.85
#&gt; B - C     |  0.10 | 10.28
#&gt; B - D     |  0.06 |  9.94
#&gt; C - D     | -0.04 | 10.18
</pre></div>
<p>All means have the same prior distribution, and the distribution of the
differences matches the prior we set of <code>"normal(0, 10)"</code>. Success!
</p>



<h4><code>contr.equalprior_deviations</code></h4>

<p>Useful for setting priors in terms of the deviations of each mean from the
grand mean - the scales of the priors defines the prior distribution of the
distance (above, below) the mean of one of the levels might have from the
overall mean. (See examples.)
</p>



<h3>Value</h3>

<p>A <code>matrix</code> with n rows and k columns, with k=n-1 if contrasts is
<code>TRUE</code> and k=n if contrasts is <code>FALSE</code>.
</p>


<h3>References</h3>

<p>Rouder, J. N., Morey, R. D., Speckman, P. L., &amp; Province, J. M. (2012).
Default Bayes factors for ANOVA designs. <em>Journal of Mathematical
Psychology</em>, 56(5), 356-374. https://doi.org/10.1016/j.jmp.2012.08.001
</p>


<h3>Examples</h3>

<pre><code class='language-R'>contr.equalprior(2) # Q_2 in Rouder et al. (2012, p. 363)

contr.equalprior(5) # equivalent to Q_5 in Rouder et al. (2012, p. 363)

## check decomposition
Q3 &lt;- contr.equalprior(3)
Q3 %*% t(Q3) ## 2/3 on diagonal and -1/3 on off-diagonal elements
</code></pre>

<hr>
<h2 id='convert_bayesian_as_frequentist'>Convert (refit) a Bayesian model to frequentist</h2><span id='topic+convert_bayesian_as_frequentist'></span><span id='topic+bayesian_as_frequentist'></span>

<h3>Description</h3>

<p>Refit Bayesian model as frequentist. Can be useful for comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_bayesian_as_frequentist(model, data = NULL, REML = TRUE)

bayesian_as_frequentist(model, data = NULL, REML = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_bayesian_as_frequentist_+3A_model">model</code></td>
<td>
<p>A Bayesian model.</p>
</td></tr>
<tr><td><code id="convert_bayesian_as_frequentist_+3A_data">data</code></td>
<td>
<p>Data used by the model. If <code>NULL</code>, will try to extract it
from the model.</p>
</td></tr>
<tr><td><code id="convert_bayesian_as_frequentist_+3A_reml">REML</code></td>
<td>
<p>For mixed effects, should models be estimated using
restricted maximum likelihood (REML) (<code>TRUE</code>, default) or maximum
likelihood (<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# Rstanarm ----------------------
# Simple regressions
model &lt;- rstanarm::stan_glm(Sepal.Length ~ Species,
  data = iris, chains = 2, refresh = 0
)
bayesian_as_frequentist(model)

model &lt;- rstanarm::stan_glm(vs ~ mpg,
  family = "binomial",
  data = mtcars, chains = 2, refresh = 0
)
bayesian_as_frequentist(model)

# Mixed models
model &lt;- rstanarm::stan_glmer(
  Sepal.Length ~ Petal.Length + (1 | Species),
  data = iris, chains = 2, refresh = 0
)
bayesian_as_frequentist(model)

model &lt;- rstanarm::stan_glmer(vs ~ mpg + (1 | cyl),
  family = "binomial",
  data = mtcars, chains = 2, refresh = 0
)
bayesian_as_frequentist(model)


</code></pre>

<hr>
<h2 id='cwi'>Curvewise Intervals (CWI)</h2><span id='topic+cwi'></span><span id='topic+cwi.data.frame'></span>

<h3>Description</h3>

<p>Compute the <strong>Curvewise interval (CWI)</strong> (also called the &quot;simultaneous interval&quot; or &quot;joint interval&quot;) of posterior distributions using <code>ggdist::curve_interval()</code>.
Whereas the more typical &quot;pointwise intervals&quot; contain xx% of the posterior for a single parameter,
joint/curvewise intervals contain xx% of the posterior distribution for <strong>all</strong> parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cwi(x, ...)

## S3 method for class 'data.frame'
cwi(x, ci = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cwi_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution, or a data frame of such
vectors. Can also be a Bayesian model. <strong>bayestestR</strong> supports a wide range
of models (see, for example, <code>methods("hdi")</code>) and not all of those are
documented in the 'Usage' section, because methods for other classes mostly
resemble the arguments of the <code>.numeric</code> or <code>.data.frame</code>methods.</p>
</td></tr>
<tr><td><code id="cwi_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="cwi_+3A_ci">ci</code></td>
<td>
<p>Value or vector of probability of the (credible) interval - CI
(between 0 and 1) to be estimated. Default to <code>.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applied model predictions, pointwise intervals contain xx% of the predicted response values <strong>conditional</strong> on specific predictor values.
In contrast, curvewise intervals contain xx% of the predicted response values across all predictor values.
Put another way, curvewise intervals contain xx% of the full <strong>prediction lines</strong> from the model.
</p>
<p>For more details, see the <a href="https://mjskay.github.io/ggdist/articles/lineribbon.html#curve-boxplots-aka-lineribbons-with-joint-intervals-or-curvewise-intervals-"><em>ggdist</em> documentation on curvewise intervals</a>.
</p>


<h3>Value</h3>

<p>A data frame with following columns:
</p>

<ul>
<li> <p><code>Parameter</code> The model parameter(s), if <code>x</code> is a model-object. If <code>x</code> is a
vector, this column is missing.
</p>
</li>
<li> <p><code>CI</code> The probability of the credible interval.
</p>
</li>
<li> <p><code>CI_low</code>, <code>CI_high</code> The lower and upper credible interval limits for the parameters.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other ci: 
<code><a href="#topic+bci">bci</a>()</code>,
<code><a href="#topic+ci">ci</a>()</code>,
<code><a href="#topic+eti">eti</a>()</code>,
<code><a href="#topic+hdi">hdi</a>()</code>,
<code><a href="#topic+si">si</a>()</code>,
<code><a href="#topic+spi">spi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

if (require("ggplot2") &amp;&amp; require("rstanarm") &amp;&amp; require("ggdist")) {
  # Generate data =============================================
  k &lt;- 11 # number of curves (iterations)
  n &lt;- 201 # number of rows
  data &lt;- data.frame(x = seq(-15, 15, length.out = n))

  # Simulate iterations as new columns
  for (i in 1:k) {
    data[paste0("iter_", i)] &lt;- dnorm(data$x, seq(-5, 5, length.out = k)[i], 3)
  }

  # Note: first, we need to transpose the data to have iters as rows
  iters &lt;- datawizard::data_transpose(data[paste0("iter_", 1:k)])

  # Compute Median
  data$Median &lt;- point_estimate(iters)[["Median"]]

  # Compute Credible Intervals ================================

  # Compute ETI (default type of CI)
  data[c("ETI_low", "ETI_high")] &lt;- eti(iters, ci = 0.5)[c("CI_low", "CI_high")]

  # Compute CWI
  # ggdist::curve_interval(reshape_iterations(data), iter_value .width = 0.5)

  # Visualization =============================================
  ggplot(data, aes(x = x, y = Median)) +
    geom_ribbon(aes(ymin = ETI_low, ymax = ETI_high), fill = "red", alpha = 0.3) +
    geom_line(linewidth = 1) +
    geom_line(
      data = reshape_iterations(data),
      aes(y = iter_value, group = iter_group),
      alpha = 0.3
    )
}

</code></pre>

<hr>
<h2 id='density_at'>Density Probability at a Given Value</h2><span id='topic+density_at'></span>

<h3>Description</h3>

<p>Compute the density value at a given point of a distribution (i.e.,
the value of the <code>y</code> axis of a value <code>x</code> of a distribution).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_at(posterior, x, precision = 2^10, method = "kernel", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_at_+3A_posterior">posterior</code></td>
<td>
<p>Vector representing a posterior distribution.</p>
</td></tr>
<tr><td><code id="density_at_+3A_x">x</code></td>
<td>
<p>The value of which to get the approximate probability.</p>
</td></tr>
<tr><td><code id="density_at_+3A_precision">precision</code></td>
<td>
<p>Number of points of density data. See the <code>n</code> parameter in <code>density</code>.</p>
</td></tr>
<tr><td><code id="density_at_+3A_method">method</code></td>
<td>
<p>Density estimation method. Can be <code>"kernel"</code> (default), <code>"logspline"</code>
or <code>"KernSmooth"</code>.</p>
</td></tr>
<tr><td><code id="density_at_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(bayestestR)
posterior &lt;- distribution_normal(n = 10)
density_at(posterior, 0)
density_at(posterior, c(0, 1))
</code></pre>

<hr>
<h2 id='describe_posterior'>Describe Posterior Distributions</h2><span id='topic+describe_posterior'></span><span id='topic+describe_posterior.numeric'></span><span id='topic+describe_posterior.stanreg'></span><span id='topic+describe_posterior.brmsfit'></span>

<h3>Description</h3>

<p>Compute indices relevant to describe and characterize the posterior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe_posterior(posterior, ...)

## S3 method for class 'numeric'
describe_posterior(
  posterior,
  centrality = "median",
  dispersion = FALSE,
  ci = 0.95,
  ci_method = "eti",
  test = c("p_direction", "rope"),
  rope_range = "default",
  rope_ci = 0.95,
  keep_iterations = FALSE,
  bf_prior = NULL,
  BF = 1,
  verbose = TRUE,
  ...
)

## S3 method for class 'stanreg'
describe_posterior(
  posterior,
  centrality = "median",
  dispersion = FALSE,
  ci = 0.95,
  ci_method = "eti",
  test = c("p_direction", "rope"),
  rope_range = "default",
  rope_ci = 0.95,
  keep_iterations = FALSE,
  bf_prior = NULL,
  diagnostic = c("ESS", "Rhat"),
  priors = FALSE,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  BF = 1,
  verbose = TRUE,
  ...
)

## S3 method for class 'brmsfit'
describe_posterior(
  posterior,
  centrality = "median",
  dispersion = FALSE,
  ci = 0.95,
  ci_method = "eti",
  test = c("p_direction", "rope"),
  rope_range = "default",
  rope_ci = 0.95,
  keep_iterations = FALSE,
  bf_prior = NULL,
  diagnostic = c("ESS", "Rhat"),
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all", "location",
    "distributional", "auxiliary"),
  parameters = NULL,
  BF = 1,
  priors = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_posterior_+3A_posterior">posterior</code></td>
<td>
<p>A vector, data frame or model of posterior draws.
<strong>bayestestR</strong> supports a wide range of models (see <code>methods("describe_posterior")</code>)
and not all of those are documented in the 'Usage' section, because methods
for other classes mostly resemble the arguments of the <code>.numeric</code> method.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_centrality">centrality</code></td>
<td>
<p>The point-estimates (centrality indices) to compute. Character
(vector) or list with one or more of these options: <code>"median"</code>, <code>"mean"</code>, <code>"MAP"</code>
(see <code><a href="#topic+map_estimate">map_estimate()</a></code>), <code>"trimmed"</code> (which is just <code>mean(x, trim = threshold)</code>),
<code>"mode"</code> or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_dispersion">dispersion</code></td>
<td>
<p>Logical, if <code>TRUE</code>, computes indices of dispersion related
to the estimate(s) (<code>SD</code> and <code>MAD</code> for <code>mean</code> and <code>median</code>, respectively).
Dispersion is not available for <code>"MAP"</code> or <code>"mode"</code> centrality indices.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_ci">ci</code></td>
<td>
<p>Value or vector of probability of the CI (between 0 and 1)
to be estimated. Default to <code>0.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_ci_method">ci_method</code></td>
<td>
<p>The type of index used for Credible Interval. Can be
<code>"ETI"</code> (default, see <code><a href="#topic+eti">eti()</a></code>), <code>"HDI"</code>
(see <code><a href="#topic+hdi">hdi()</a></code>), <code>"BCI"</code> (see
<code><a href="#topic+bci">bci()</a></code>), <code>"SPI"</code> (see <code><a href="#topic+spi">spi()</a></code>), or
<code>"SI"</code> (see <code><a href="#topic+si">si()</a></code>).</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_test">test</code></td>
<td>
<p>The indices of effect existence to compute. Character (vector) or
list with one or more of these options: <code>"p_direction"</code> (or <code>"pd"</code>),
<code>"rope"</code>, <code>"p_map"</code>, <code>"equivalence_test"</code> (or <code>"equitest"</code>),
<code>"bayesfactor"</code> (or <code>"bf"</code>) or <code>"all"</code> to compute all tests.
For each &quot;test&quot;, the corresponding <span class="pkg">bayestestR</span> function is called
(e.g. <code><a href="#topic+rope">rope()</a></code> or <code><a href="#topic+p_direction">p_direction()</a></code>) and its results
included in the summary output.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_rope_range">rope_range</code></td>
<td>
<p>ROPE's lower and higher bounds. Should be a list of two
values (e.g., <code>c(-0.1, 0.1)</code>) or <code>"default"</code>. If <code>"default"</code>,
the bounds are set to <code>x +- 0.1*SD(response)</code>.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_rope_ci">rope_ci</code></td>
<td>
<p>The Credible Interval (CI) probability, corresponding to the
proportion of HDI, to use for the percentage in ROPE.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_keep_iterations">keep_iterations</code></td>
<td>
<p>If <code>TRUE</code>, will keep all iterations (draws) of
bootstrapped or Bayesian models. They will be added as additional columns
named <code style="white-space: pre;">&#8288;iter_1, iter_2, ...&#8288;</code>. You can reshape them to a long format by
running <code><a href="#topic+reshape_iterations">reshape_iterations()</a></code>.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_bf_prior">bf_prior</code></td>
<td>
<p>Distribution representing a prior for the computation of
Bayes factors / SI. Used if the input is a posterior, otherwise (in the
case of models) ignored.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_bf">BF</code></td>
<td>
<p>The amount of support required to be included in the support interval.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_diagnostic">diagnostic</code></td>
<td>
<p>Diagnostic metrics to compute.  Character (vector) or list
with one or more of these options: <code>"ESS"</code>, <code>"Rhat"</code>, <code>"MCSE"</code> or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_priors">priors</code></td>
<td>
<p>Add the prior used for each parameter.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="describe_posterior_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One or more components of point estimates (like posterior mean or median),
intervals and tests can be omitted from the summary output by setting the
related argument to <code>NULL</code>. For example, <code>test = NULL</code> and <code>centrality = NULL</code> would only return the HDI (or CI).
</p>


<h3>References</h3>


<ul>
<li><p> Makowski, D., Ben-Shachar, M. S., Chen, S. H. A., and Lüdecke, D. (2019).
<em>Indices of Effect Existence and Significance in the Bayesian Framework</em>.
Frontiers in Psychology 2019;10:2767. <a href="https://doi.org/10.3389/fpsyg.2019.02767">doi:10.3389/fpsyg.2019.02767</a>
</p>
</li>
<li> <p><a href="https://easystats.github.io/bayestestR/articles/region_of_practical_equivalence.html">Region of Practical Equivalence (ROPE)</a>
</p>
</li>
<li> <p><a href="https://easystats.github.io/bayestestR/articles/bayes_factors.html">Bayes factors</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(bayestestR)

if (require("logspline")) {
  x &lt;- rnorm(1000)
  describe_posterior(x, verbose = FALSE)
  describe_posterior(x,
    centrality = "all",
    dispersion = TRUE,
    test = "all",
    verbose = FALSE
  )
  describe_posterior(x, ci = c(0.80, 0.90), verbose = FALSE)

  df &lt;- data.frame(replicate(4, rnorm(100)))
  describe_posterior(df, verbose = FALSE)
  describe_posterior(
    df,
    centrality = "all",
    dispersion = TRUE,
    test = "all",
    verbose = FALSE
  )
  describe_posterior(df, ci = c(0.80, 0.90), verbose = FALSE)

  df &lt;- data.frame(replicate(4, rnorm(20)))
  head(reshape_iterations(
    describe_posterior(df, keep_iterations = TRUE, verbose = FALSE)
  ))
}

# rstanarm models
# -----------------------------------------------
if (require("rstanarm") &amp;&amp; require("emmeans")) {
  model &lt;- suppressWarnings(
    stan_glm(mpg ~ wt + gear, data = mtcars, chains = 2, iter = 200, refresh = 0)
  )
  describe_posterior(model)
  describe_posterior(model, centrality = "all", dispersion = TRUE, test = "all")
  describe_posterior(model, ci = c(0.80, 0.90))

  # emmeans estimates
  # -----------------------------------------------
  describe_posterior(emtrends(model, ~1, "wt"))
}

# BayesFactor objects
# -----------------------------------------------
if (require("BayesFactor")) {
  bf &lt;- ttestBF(x = rnorm(100, 1, 1))
  describe_posterior(bf)
  describe_posterior(bf, centrality = "all", dispersion = TRUE, test = "all")
  describe_posterior(bf, ci = c(0.80, 0.90))
}

</code></pre>

<hr>
<h2 id='describe_prior'>Describe Priors</h2><span id='topic+describe_prior'></span><span id='topic+describe_prior.brmsfit'></span>

<h3>Description</h3>

<p>Returns a summary of the priors used in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe_prior(model, ...)

## S3 method for class 'brmsfit'
describe_prior(
  model,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all", "location",
    "distributional", "auxiliary"),
  parameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_prior_+3A_model">model</code></td>
<td>
<p>A Bayesian model.</p>
</td></tr>
<tr><td><code id="describe_prior_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="describe_prior_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="describe_prior_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="describe_prior_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

# rstanarm models
# -----------------------------------------------
if (require("rstanarm")) {
  model &lt;- rstanarm::stan_glm(mpg ~ wt + cyl, data = mtcars)
  describe_prior(model)
}

# brms models
# -----------------------------------------------
if (require("brms")) {
  model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
  describe_prior(model)
}

# BayesFactor objects
# -----------------------------------------------
if (require("BayesFactor")) {
  bf &lt;- ttestBF(x = rnorm(100, 1, 1))
  describe_prior(bf)
}

</code></pre>

<hr>
<h2 id='diagnostic_draws'>Diagnostic values for each iteration</h2><span id='topic+diagnostic_draws'></span>

<h3>Description</h3>

<p>Returns the accumulated log-posterior, the average Metropolis acceptance rate, divergent transitions, treedepth rather than terminated its evolution normally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic_draws(posterior, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic_draws_+3A_posterior">posterior</code></td>
<td>
<p>A <code>stanreg</code>, <code>stanfit</code>, <code>brmsfit</code>, or <code>blavaan</code> object.</p>
</td></tr>
<tr><td><code id="diagnostic_draws_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(333)

if (require("brms", quietly = TRUE)) {
  model &lt;- suppressWarnings(brm(mpg ~ wt * cyl * vs,
    data = mtcars,
    iter = 100, control = list(adapt_delta = 0.80),
    refresh = 0
  ))
  diagnostic_draws(model)
}


</code></pre>

<hr>
<h2 id='diagnostic_posterior'>Posteriors Sampling Diagnostic</h2><span id='topic+diagnostic_posterior'></span><span id='topic+diagnostic_posterior.default'></span><span id='topic+diagnostic_posterior.stanreg'></span><span id='topic+diagnostic_posterior.brmsfit'></span>

<h3>Description</h3>

<p>Extract diagnostic metrics (Effective Sample Size (<code>ESS</code>), <code>Rhat</code> and Monte
Carlo Standard Error <code>MCSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic_posterior(posterior, ...)

## Default S3 method:
diagnostic_posterior(posterior, diagnostic = c("ESS", "Rhat"), ...)

## S3 method for class 'stanreg'
diagnostic_posterior(
  posterior,
  diagnostic = "all",
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  ...
)

## S3 method for class 'brmsfit'
diagnostic_posterior(
  posterior,
  diagnostic = "all",
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic_posterior_+3A_posterior">posterior</code></td>
<td>
<p>A <code>stanreg</code>, <code>stanfit</code>, <code>brmsfit</code>, or <code>blavaan</code> object.</p>
</td></tr>
<tr><td><code id="diagnostic_posterior_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="diagnostic_posterior_+3A_diagnostic">diagnostic</code></td>
<td>
<p>Diagnostic metrics to compute.  Character (vector) or list
with one or more of these options: <code>"ESS"</code>, <code>"Rhat"</code>, <code>"MCSE"</code> or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="diagnostic_posterior_+3A_effects">effects</code></td>
<td>
<p>Should parameters for fixed effects, random effects
or both be returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="diagnostic_posterior_+3A_component">component</code></td>
<td>
<p>Should all predictor variables, predictor variables for the
conditional model, the zero-inflated part of the model, the dispersion
term or the instrumental variables be returned? Applies to models
with zero-inflated and/or dispersion formula, or to models with instrumental
variable (so called fixed-effects regressions). May be abbreviated. Note that the
<em>conditional</em> component is also called <em>count</em> or <em>mean</em>
component, depending on the model.</p>
</td></tr>
<tr><td><code id="diagnostic_posterior_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters that
should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Effective Sample (ESS)</strong> should be as large as possible, although for
most applications, an effective sample size greater than 1000 is sufficient
for stable estimates (<em>Bürkner, 2017</em>). The ESS corresponds to the number of
independent samples with the same estimation power as the N autocorrelated
samples. It is is a measure of &quot;how much independent information there is
in autocorrelated chains&quot; (<em>Kruschke 2015, p182-3</em>).
</p>
<p><strong>Rhat</strong> should be the closest to 1. It should not be larger than 1.1
(<em>Gelman and Rubin, 1992</em>) or 1.01 (<em>Vehtari et al., 2019</em>). The split
Rhat statistic quantifies the consistency of an ensemble of Markov chains.
</p>
<p><strong>Monte Carlo Standard Error (MCSE)</strong> is another measure of accuracy of the
chains. It is defined as standard deviation of the chains divided by their
effective sample size (the formula for <code>mcse()</code> is from Kruschke 2015, p.
187). The MCSE &quot;provides a quantitative suggestion of how big the estimation
noise is&quot;.
</p>


<h3>References</h3>


<ul>
<li><p> Gelman, A., &amp; Rubin, D. B. (1992). Inference from iterative simulation
using multiple sequences. Statistical science, 7(4), 457-472.
</p>
</li>
<li><p> Vehtari, A., Gelman, A., Simpson, D., Carpenter, B., and Bürkner, P. C.
(2019). Rank-normalization, folding, and localization: An improved Rhat
for assessing convergence of MCMC. arXiv preprint arXiv:1903.08008.
</p>
</li>
<li><p> Kruschke, J. (2014). Doing Bayesian data analysis: A tutorial with R,
JAGS, and Stan. Academic Press.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

# rstanarm models
# -----------------------------------------------
model &lt;- suppressWarnings(
  rstanarm::stan_glm(mpg ~ wt + gear, data = mtcars, chains = 2, iter = 200, refresh = 0)
)
diagnostic_posterior(model)

# brms models
# -----------------------------------------------
model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
diagnostic_posterior(model)


</code></pre>

<hr>
<h2 id='disgust'>Moral Disgust Judgment</h2><span id='topic+disgust'></span>

<h3>Description</h3>

<p>A sample (simulated) dataset, used in tests and some examples.
</p>


<h3>Format</h3>

<p>A data frame with 500 rows and 5 variables:
</p>

<dl>
<dt>score</dt><dd><p>Score on the questionnaire, which ranges from 0 to 50 with higher scores representing harsher moral judgment</p>
</dd>
<dt>condition</dt><dd><p>one of three conditions, differing by the odor present in the room: a pleasant scent associated with cleanliness (lemon), a disgusting scent (sulfur), and a control condition in which no unusual odor is present</p>
</dd>
</dl>

<div class="sourceCode r"><pre>data("disgust")
head(disgust, n = 5)
#&gt;   score condition
#&gt; 1    13   control
#&gt; 2    26   control
#&gt; 3    30   control
#&gt; 4    23   control
#&gt; 5    34   control
</pre></div>


<h3>Author(s)</h3>

<p>Richard D. Morey
</p>

<hr>
<h2 id='distribution'>Empirical Distributions</h2><span id='topic+distribution'></span><span id='topic+distribution_custom'></span><span id='topic+distribution_beta'></span><span id='topic+distribution_binomial'></span><span id='topic+distribution_binom'></span><span id='topic+distribution_cauchy'></span><span id='topic+distribution_chisquared'></span><span id='topic+distribution_chisq'></span><span id='topic+distribution_gamma'></span><span id='topic+distribution_mixture_normal'></span><span id='topic+distribution_normal'></span><span id='topic+distribution_gaussian'></span><span id='topic+distribution_nbinom'></span><span id='topic+distribution_poisson'></span><span id='topic+distribution_student'></span><span id='topic+distribution_t'></span><span id='topic+distribution_student_t'></span><span id='topic+distribution_tweedie'></span><span id='topic+distribution_uniform'></span><span id='topic+rnorm_perfect'></span>

<h3>Description</h3>

<p>Generate a sequence of n-quantiles, i.e., a sample of size <code>n</code> with a
near-perfect distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution(type = "normal", ...)

distribution_custom(n, type = "norm", ..., random = FALSE)

distribution_beta(n, shape1, shape2, ncp = 0, random = FALSE, ...)

distribution_binomial(n, size = 1, prob = 0.5, random = FALSE, ...)

distribution_binom(n, size = 1, prob = 0.5, random = FALSE, ...)

distribution_cauchy(n, location = 0, scale = 1, random = FALSE, ...)

distribution_chisquared(n, df, ncp = 0, random = FALSE, ...)

distribution_chisq(n, df, ncp = 0, random = FALSE, ...)

distribution_gamma(n, shape, scale = 1, random = FALSE, ...)

distribution_mixture_normal(n, mean = c(-3, 3), sd = 1, random = FALSE, ...)

distribution_normal(n, mean = 0, sd = 1, random = FALSE, ...)

distribution_gaussian(n, mean = 0, sd = 1, random = FALSE, ...)

distribution_nbinom(n, size, prob, mu, phi, random = FALSE, ...)

distribution_poisson(n, lambda = 1, random = FALSE, ...)

distribution_student(n, df, ncp, random = FALSE, ...)

distribution_t(n, df, ncp, random = FALSE, ...)

distribution_student_t(n, df, ncp, random = FALSE, ...)

distribution_tweedie(n, xi = NULL, mu, phi, power = NULL, random = FALSE, ...)

distribution_uniform(n, min = 0, max = 1, random = FALSE, ...)

rnorm_perfect(n, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution_+3A_type">type</code></td>
<td>
<p>Can be any of the names from base R's
<a href="stats.html#topic+Distributions">Distributions</a>, like <code>"cauchy"</code>, <code>"pois"</code> or
<code>"beta"</code>.</p>
</td></tr>
<tr><td><code id="distribution_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="distribution_+3A_n">n</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code id="distribution_+3A_random">random</code></td>
<td>
<p>Generate near-perfect or random (simple wrappers for the base R
<code style="white-space: pre;">&#8288;r*&#8288;</code> functions) distributions.</p>
</td></tr>
<tr><td><code id="distribution_+3A_shape1">shape1</code>, <code id="distribution_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="distribution_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter.</p>
</td></tr>
<tr><td><code id="distribution_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="distribution_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial.</p>
</td></tr>
<tr><td><code id="distribution_+3A_location">location</code>, <code id="distribution_+3A_scale">scale</code></td>
<td>
<p>location and scale parameters.</p>
</td></tr>
<tr><td><code id="distribution_+3A_df">df</code></td>
<td>
<p>degrees of freedom (non-negative, but can be non-integer).</p>
</td></tr>
<tr><td><code id="distribution_+3A_shape">shape</code></td>
<td>
<p>Shape parameter.</p>
</td></tr>
<tr><td><code id="distribution_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="distribution_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="distribution_+3A_mu">mu</code></td>
<td>
<p>the mean</p>
</td></tr>
<tr><td><code id="distribution_+3A_phi">phi</code></td>
<td>
<p>Corresponding to <code>glmmTMB</code>'s implementation of nbinom
distribution, where <code>size=mu/phi</code>.</p>
</td></tr>
<tr><td><code id="distribution_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) means.</p>
</td></tr>
<tr><td><code id="distribution_+3A_xi">xi</code></td>
<td>
<p>For tweedie distributions, the value of <code>xi</code> such that the variance
is <code>var(Y) = phi * mu^xi</code>.</p>
</td></tr>
<tr><td><code id="distribution_+3A_power">power</code></td>
<td>
<p>Alias for <code>xi</code>.</p>
</td></tr>
<tr><td><code id="distribution_+3A_min">min</code>, <code id="distribution_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution.  Must be finite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>random = FALSE</code>, these function return <code style="white-space: pre;">&#8288;q*(ppoints(n), ...)&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bayestestR)
x &lt;- distribution(n = 10)
plot(density(x))

x &lt;- distribution(type = "gamma", n = 100, shape = 2)
plot(density(x))
</code></pre>

<hr>
<h2 id='effective_sample'>Effective Sample Size (ESS)</h2><span id='topic+effective_sample'></span><span id='topic+effective_sample.brmsfit'></span><span id='topic+effective_sample.stanreg'></span>

<h3>Description</h3>

<p>This function returns the effective sample size (ESS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effective_sample(model, ...)

## S3 method for class 'brmsfit'
effective_sample(
  model,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  ...
)

## S3 method for class 'stanreg'
effective_sample(
  model,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effective_sample_+3A_model">model</code></td>
<td>
<p>A <code>stanreg</code>, <code>stanfit</code>, <code>brmsfit</code>, <code>blavaan</code>, or <code>MCMCglmm</code> object.</p>
</td></tr>
<tr><td><code id="effective_sample_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="effective_sample_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="effective_sample_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="effective_sample_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Effective Sample (ESS)</strong> should be as large as possible, altough for most applications, an effective sample size greater than 1,000 is sufficient for stable estimates (Bürkner, 2017). The ESS corresponds to the number of independent samples with the same estimation power as the N autocorrelated samples. It is is a measure of &ldquo;how much independent information there is in autocorrelated chains&rdquo; (<em>Kruschke 2015, p182-3</em>).
</p>


<h3>Value</h3>

<p>A data frame with two columns: Parameter name and effective sample size (ESS).
</p>


<h3>References</h3>


<ul>
<li><p> Kruschke, J. (2014). Doing Bayesian data analysis: A tutorial with R, JAGS, and Stan. Academic Press.
</p>
</li>
<li><p> Bürkner, P. C. (2017). brms: An R package for Bayesian multilevel models using Stan. Journal of Statistical Software, 80(1), 1-28
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

library(rstanarm)
model &lt;- suppressWarnings(
  stan_glm(mpg ~ wt + gear, data = mtcars, chains = 2, iter = 200, refresh = 0)
)
effective_sample(model)


</code></pre>

<hr>
<h2 id='equivalence_test'>Test for Practical Equivalence</h2><span id='topic+equivalence_test'></span><span id='topic+equivalence_test.default'></span><span id='topic+equivalence_test.data.frame'></span><span id='topic+equivalence_test.stanreg'></span><span id='topic+equivalence_test.brmsfit'></span>

<h3>Description</h3>

<p>Perform a <strong>Test for Practical Equivalence</strong> for Bayesian and frequentist models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalence_test(x, ...)

## Default S3 method:
equivalence_test(x, ...)

## S3 method for class 'data.frame'
equivalence_test(x, range = "default", ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'stanreg'
equivalence_test(
  x,
  range = "default",
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'brmsfit'
equivalence_test(
  x,
  range = "default",
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalence_test_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution. Can also be a
<code>stanreg</code> or <code>brmsfit</code> model.</p>
</td></tr>
<tr><td><code id="equivalence_test_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="equivalence_test_+3A_range">range</code></td>
<td>
<p>ROPE's lower and higher bounds. Should be <code>"default"</code> or
depending on the number of outcome variables a vector or a list. In
models with one response, <code>range</code> should be a vector of length two (e.g.,
<code>c(-0.1, 0.1)</code>). In multivariate models, <code>range</code> should be a list with a
numeric vectors for each response variable. Vector names should correspond
to the name of the response variables. If <code>"default"</code> and input is a vector,
the range is set to <code>c(-0.1, 0.1)</code>. If <code>"default"</code> and input is a Bayesian
model, <code><a href="#topic+rope_range">rope_range()</a></code> is used.</p>
</td></tr>
<tr><td><code id="equivalence_test_+3A_ci">ci</code></td>
<td>
<p>The Credible Interval (CI) probability, corresponding to the
proportion of HDI, to use for the percentage in ROPE.</p>
</td></tr>
<tr><td><code id="equivalence_test_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="equivalence_test_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="equivalence_test_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="equivalence_test_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Documentation is accessible for:
</p>

<ul>
<li> <p><a href="https://easystats.github.io/bayestestR/reference/equivalence_test.html">Bayesian models</a>
</p>
</li>
<li> <p><a href="https://easystats.github.io/parameters/reference/equivalence_test.lm.html">Frequentist models</a>
</p>
</li></ul>

<p>For Bayesian models, the <strong>Test for Practical Equivalence</strong> is based on the <em>&quot;HDI+ROPE decision rule&quot;</em> (<cite>Kruschke, 2014, 2018</cite>) to check whether parameter values should be accepted or rejected against an explicitly formulated &quot;null hypothesis&quot; (i.e., a ROPE). In other words, it checks the percentage of the <code style="white-space: pre;">&#8288;89%&#8288;</code> <a href="#topic+hdi">HDI</a> that is the null region (the ROPE). If this percentage is sufficiently low, the null hypothesis is rejected. If this percentage is sufficiently high, the null hypothesis is accepted.
</p>
<p>Using the <a href="#topic+rope">ROPE</a> and the <a href="#topic+hdi">HDI</a>, <cite>Kruschke (2018)</cite>
suggests using the percentage of the <code style="white-space: pre;">&#8288;95%&#8288;</code> (or <code style="white-space: pre;">&#8288;89%&#8288;</code>, considered more stable)
HDI that falls within the ROPE as a decision rule. If the HDI
is completely outside the ROPE, the &quot;null hypothesis&quot; for this parameter is
&quot;rejected&quot;. If the ROPE completely covers the HDI, i.e., all most credible
values of a parameter are inside the region of practical equivalence, the
null hypothesis is accepted. Else, it’s undecided whether to accept or
reject the null hypothesis. If the full ROPE is used (i.e., <code style="white-space: pre;">&#8288;100%&#8288;</code> of the
HDI), then the null hypothesis is rejected or accepted if the percentage
of the posterior within the ROPE is smaller than to <code style="white-space: pre;">&#8288;2.5%&#8288;</code> or greater than
<code style="white-space: pre;">&#8288;97.5%&#8288;</code>. Desirable results are low proportions inside the ROPE  (the closer
to zero the better).
<br /> <br />
Some attention is required for finding suitable values for the ROPE limits
(argument <code>range</code>). See 'Details' in <code><a href="#topic+rope_range">rope_range()</a></code>
for further information.
<br /> <br />
<strong>Multicollinearity: Non-independent covariates</strong>
<br /> <br />
When parameters show strong correlations, i.e. when covariates are not
independent, the joint parameter distributions may shift towards or
away from the ROPE. In such cases, the test for practical equivalence may
have inappropriate results. Collinearity invalidates ROPE and hypothesis
testing based on univariate marginals, as the probabilities are conditional
on independence. Most problematic are the results of the &quot;undecided&quot;
parameters, which may either move further towards &quot;rejection&quot; or away
from it (<cite>Kruschke 2014, 340f</cite>).
<br /> <br />
<code>equivalence_test()</code> performs a simple check for pairwise correlations
between parameters, but as there can be collinearity between more than two variables,
a first step to check the assumptions of this hypothesis testing is to look
at different pair plots. An even more sophisticated check is the projection
predictive variable selection (<cite>Piironen and Vehtari 2017</cite>).
</p>


<h3>Value</h3>

<p>A data frame with following columns:
</p>

<ul>
<li> <p><code>Parameter</code> The model parameter(s), if <code>x</code> is a model-object. If <code>x</code> is a vector, this column is missing.
</p>
</li>
<li> <p><code>CI</code> The probability of the HDI.
</p>
</li>
<li> <p><code>ROPE_low</code>, <code>ROPE_high</code> The limits of the ROPE. These values are identical for all parameters.
</p>
</li>
<li> <p><code>ROPE_Percentage</code> The proportion of the HDI that lies inside the ROPE.
</p>
</li>
<li> <p><code>ROPE_Equivalence</code> The &quot;test result&quot;, as character. Either &quot;rejected&quot;, &quot;accepted&quot; or &quot;undecided&quot;.
</p>
</li>
<li> <p><code>HDI_low</code> , <code>HDI_high</code> The lower and upper HDI limits for the parameters.
</p>
</li></ul>



<h3>Note</h3>

<p>There is a <code>print()</code>-method with a <code>digits</code>-argument to control
the amount of digits in the output, and there is a
<a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a>
to visualize the results from the equivalence-test (for models only).
</p>


<h3>References</h3>


<ul>
<li><p> Kruschke, J. K. (2018). Rejecting or accepting parameter values in Bayesian estimation. Advances in Methods and Practices in Psychological Science, 1(2), 270-280. <a href="https://doi.org/10.1177/2515245918771304">doi:10.1177/2515245918771304</a>
</p>
</li>
<li><p> Kruschke, J. K. (2014). Doing Bayesian data analysis: A tutorial with R, JAGS, and Stan. Academic Press
</p>
</li>
<li><p> Piironen, J., &amp; Vehtari, A. (2017). Comparison of Bayesian predictive methods for model selection. Statistics and Computing, 27(3), 711–735. <a href="https://doi.org/10.1007/s11222-016-9649-y">doi:10.1007/s11222-016-9649-y</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

equivalence_test(x = rnorm(1000, 0, 0.01), range = c(-0.1, 0.1))
equivalence_test(x = rnorm(1000, 0, 1), range = c(-0.1, 0.1))
equivalence_test(x = rnorm(1000, 1, 0.01), range = c(-0.1, 0.1))
equivalence_test(x = rnorm(1000, 1, 1), ci = c(.50, .99))

# print more digits
test &lt;- equivalence_test(x = rnorm(1000, 1, 1), ci = c(.50, .99))
print(test, digits = 4)

model &lt;- rstanarm::stan_glm(mpg ~ wt + cyl, data = mtcars)
equivalence_test(model)

# plot result
test &lt;- equivalence_test(model)
plot(test)

equivalence_test(emmeans::emtrends(model, ~1, "wt", data = mtcars))

model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
equivalence_test(model)

bf &lt;- BayesFactor::ttestBF(x = rnorm(100, 1, 1))
# equivalence_test(bf)


</code></pre>

<hr>
<h2 id='estimate_density'>Density Estimation</h2><span id='topic+estimate_density'></span><span id='topic+estimate_density.data.frame'></span>

<h3>Description</h3>

<p>This function is a wrapper over different methods of density estimation. By
default, it uses the base R <code>density</code> with by default uses a different smoothing
bandwidth (<code>"SJ"</code>) from the legacy default implemented the base R <code>density</code>
function (<code>"nrd0"</code>). However, Deng and Wickham suggest that <code>method = "KernSmooth"</code>
is the fastest and the most accurate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_density(x, ...)

## S3 method for class 'data.frame'
estimate_density(
  x,
  method = "kernel",
  precision = 2^10,
  extend = FALSE,
  extend_scale = 0.1,
  bw = "SJ",
  ci = NULL,
  select = NULL,
  at = NULL,
  group_by = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_density_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution, or a data frame of such
vectors. Can also be a Bayesian model. <strong>bayestestR</strong> supports a wide range
of models (see, for example, <code>methods("hdi")</code>) and not all of those are
documented in the 'Usage' section, because methods for other classes mostly
resemble the arguments of the <code>.numeric</code> or <code>.data.frame</code>methods.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_method">method</code></td>
<td>
<p>Density estimation method. Can be <code>"kernel"</code> (default), <code>"logspline"</code>
or <code>"KernSmooth"</code>.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_precision">precision</code></td>
<td>
<p>Number of points of density data. See the <code>n</code> parameter in <code>density</code>.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_extend">extend</code></td>
<td>
<p>Extend the range of the x axis by a factor of <code>extend_scale</code>.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_extend_scale">extend_scale</code></td>
<td>
<p>Ratio of range by which to extend the x axis. A value of <code>0.1</code>
means that the x axis will be extended by <code>1/10</code> of the range of the data.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_bw">bw</code></td>
<td>
<p>See the eponymous argument in <code>density</code>. Here, the default has been
changed for <code>"SJ"</code>, which is recommended.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_ci">ci</code></td>
<td>
<p>The confidence interval threshold. Only used when <code>method = "kernel"</code>.
This feature is experimental, use with caution.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_select">select</code></td>
<td>
<p>Character vector of column names. If NULL (the default), all
numeric variables will be selected. Other arguments from <code><a href="datawizard.html#topic+find_columns">datawizard::find_columns()</a></code>
(such as <code>exclude</code>) can also be used.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_at">at</code></td>
<td>
<p>Optional character vector. If not <code>NULL</code> and input is a data frame,
density estimation is performed for each group (subsets) indicated by <code>at</code>.
See examples.</p>
</td></tr>
<tr><td><code id="estimate_density_+3A_group_by">group_by</code></td>
<td>
<p>Deprecated in favour of <code>at</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>References</h3>

<p>Deng, H., &amp; Wickham, H. (2011). Density estimation in R. Electronic publication.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

set.seed(1)
x &lt;- rnorm(250, mean = 1)

# Basic usage
density_kernel &lt;- estimate_density(x) # default method is "kernel"

hist(x, prob = TRUE)
lines(density_kernel$x, density_kernel$y, col = "black", lwd = 2)
lines(density_kernel$x, density_kernel$CI_low, col = "gray", lty = 2)
lines(density_kernel$x, density_kernel$CI_high, col = "gray", lty = 2)
legend("topright",
  legend = c("Estimate", "95% CI"),
  col = c("black", "gray"), lwd = 2, lty = c(1, 2)
)

# Other Methods
density_logspline &lt;- estimate_density(x, method = "logspline")
density_KernSmooth &lt;- estimate_density(x, method = "KernSmooth")
density_mixture &lt;- estimate_density(x, method = "mixture")

hist(x, prob = TRUE)
lines(density_kernel$x, density_kernel$y, col = "black", lwd = 2)
lines(density_logspline$x, density_logspline$y, col = "red", lwd = 2)
lines(density_KernSmooth$x, density_KernSmooth$y, col = "blue", lwd = 2)
lines(density_mixture$x, density_mixture$y, col = "green", lwd = 2)

# Extension
density_extended &lt;- estimate_density(x, extend = TRUE)
density_default &lt;- estimate_density(x, extend = FALSE)

hist(x, prob = TRUE)
lines(density_extended$x, density_extended$y, col = "red", lwd = 3)
lines(density_default$x, density_default$y, col = "black", lwd = 3)

# Multiple columns
head(estimate_density(iris))
head(estimate_density(iris, select = "Sepal.Width"))

# Grouped data
head(estimate_density(iris, at = "Species"))
head(estimate_density(iris$Petal.Width, at = iris$Species))

# rstanarm models
# -----------------------------------------------
library(rstanarm)
model &lt;- suppressWarnings(
  stan_glm(mpg ~ wt + gear, data = mtcars, chains = 2, iter = 200, refresh = 0)
)
head(estimate_density(model))

library(emmeans)
head(estimate_density(emtrends(model, ~1, "wt", data = mtcars)))

# brms models
# -----------------------------------------------
library(brms)
model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
estimate_density(model)


</code></pre>

<hr>
<h2 id='eti'>Equal-Tailed Interval (ETI)</h2><span id='topic+eti'></span><span id='topic+eti.numeric'></span><span id='topic+eti.stanreg'></span><span id='topic+eti.brmsfit'></span><span id='topic+eti.get_predicted'></span>

<h3>Description</h3>

<p>Compute the <strong>Equal-Tailed Interval (ETI)</strong> of posterior distributions using
the quantiles method. The probability of being below this interval is equal
to the probability of being above it. The ETI can be used in the context of
uncertainty characterisation of posterior distributions as
<strong>Credible Interval (CI)</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eti(x, ...)

## S3 method for class 'numeric'
eti(x, ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'stanreg'
eti(
  x,
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'brmsfit'
eti(
  x,
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'get_predicted'
eti(x, ci = 0.95, use_iterations = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eti_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution, or a data frame of such
vectors. Can also be a Bayesian model. <strong>bayestestR</strong> supports a wide range
of models (see, for example, <code>methods("hdi")</code>) and not all of those are
documented in the 'Usage' section, because methods for other classes mostly
resemble the arguments of the <code>.numeric</code> or <code>.data.frame</code>methods.</p>
</td></tr>
<tr><td><code id="eti_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="eti_+3A_ci">ci</code></td>
<td>
<p>Value or vector of probability of the (credible) interval - CI
(between 0 and 1) to be estimated. Default to <code>.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="eti_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="eti_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="eti_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="eti_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="eti_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike equal-tailed intervals (see <code>eti()</code>) that typically exclude <code style="white-space: pre;">&#8288;2.5%&#8288;</code>
from each tail of the distribution and always include the median, the HDI is
<em>not</em> equal-tailed and therefore always includes the mode(s) of posterior
distributions. While this can be useful to better represent the credibility
mass of a distribution, the HDI also has some limitations. See <code><a href="#topic+spi">spi()</a></code> for
details.
</p>
<p>The <a href="https://easystats.github.io/bayestestR/articles/credible_interval.html"><code style="white-space: pre;">&#8288;95%&#8288;</code> or <code style="white-space: pre;">&#8288;89%&#8288;</code> Credible Intervals (CI)</a>
are two reasonable ranges to characterize the uncertainty related to the
estimation (see <a href="https://easystats.github.io/bayestestR/articles/credible_interval.html">here</a>
for a discussion about the differences between these two values).
</p>
<p>The <code style="white-space: pre;">&#8288;89%&#8288;</code> intervals (<code>ci = 0.89</code>) are deemed to be more stable than, for
instance, <code style="white-space: pre;">&#8288;95%&#8288;</code> intervals (<em>Kruschke, 2014</em>). An effective sample size
of at least 10.000 is recommended if one wants to estimate <code style="white-space: pre;">&#8288;95%&#8288;</code> intervals
with high precision (<em>Kruschke, 2014, p. 183ff</em>). Unfortunately, the
default number of posterior samples for most Bayes packages (e.g., <code>rstanarm</code>
or <code>brms</code>) is only 4.000 (thus, you might want to increase it when fitting
your model). Moreover, 89 indicates the arbitrariness of interval limits -
its only remarkable property is being the highest prime number that does not
exceed the already unstable <code style="white-space: pre;">&#8288;95%&#8288;</code> threshold (<em>McElreath, 2015</em>).
</p>
<p>However, <code style="white-space: pre;">&#8288;95%&#8288;</code> has some <a href="https://easystats.github.io/blog/posts/bayestestr_95/">advantages too</a>. For instance, it
shares (in the case of a normal posterior distribution) an intuitive
relationship with the standard deviation and it conveys a more accurate image
of the (artificial) bounds of the distribution. Also, because it is wider, it
makes analyses more conservative (i.e., the probability of covering 0 is
larger for the <code style="white-space: pre;">&#8288;95%&#8288;</code> CI than for lower ranges such as <code style="white-space: pre;">&#8288;89%&#8288;</code>), which is a good
thing in the context of the reproducibility crisis.
</p>
<p>A <code style="white-space: pre;">&#8288;95%&#8288;</code> equal-tailed interval (ETI) has <code style="white-space: pre;">&#8288;2.5%&#8288;</code> of the distribution on either
side of its limits. It indicates the 2.5th percentile and the 97.5h
percentile. In symmetric distributions, the two methods of computing credible
intervals, the ETI and the <a href="#topic+hdi">HDI</a>, return similar results.
</p>
<p>This is not the case for skewed distributions. Indeed, it is possible that
parameter values in the ETI have lower credibility (are less probable) than
parameter values outside the ETI. This property seems undesirable as a summary
of the credible values in a distribution.
</p>
<p>On the other hand, the ETI range does change when transformations are applied
to the distribution (for instance, for a log odds scale to probabilities):
the lower and higher bounds of the transformed distribution will correspond
to the transformed lower and higher bounds of the original distribution.
On the contrary, applying transformations to the distribution will change
the resulting HDI.
</p>


<h3>Value</h3>

<p>A data frame with following columns:
</p>

<ul>
<li> <p><code>Parameter</code> The model parameter(s), if <code>x</code> is a model-object. If <code>x</code> is a
vector, this column is missing.
</p>
</li>
<li> <p><code>CI</code> The probability of the credible interval.
</p>
</li>
<li> <p><code>CI_low</code>, <code>CI_high</code> The lower and upper credible interval limits for the parameters.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other ci: 
<code><a href="#topic+bci">bci</a>()</code>,
<code><a href="#topic+ci">ci</a>()</code>,
<code><a href="#topic+cwi">cwi</a>()</code>,
<code><a href="#topic+hdi">hdi</a>()</code>,
<code><a href="#topic+si">si</a>()</code>,
<code><a href="#topic+spi">spi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

posterior &lt;- rnorm(1000)
eti(posterior)
eti(posterior, ci = c(0.80, 0.89, 0.95))

df &lt;- data.frame(replicate(4, rnorm(100)))
eti(df)
eti(df, ci = c(0.80, 0.89, 0.95))

model &lt;- suppressWarnings(
  rstanarm::stan_glm(mpg ~ wt + gear, data = mtcars, chains = 2, iter = 200, refresh = 0)
)
eti(model)
eti(model, ci = c(0.80, 0.89, 0.95))

eti(emmeans::emtrends(model, ~1, "wt", data = mtcars))

model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
eti(model)
eti(model, ci = c(0.80, 0.89, 0.95))

bf &lt;- BayesFactor::ttestBF(x = rnorm(100, 1, 1))
eti(bf)
eti(bf, ci = c(0.80, 0.89, 0.95))


</code></pre>

<hr>
<h2 id='hdi'>Highest Density Interval (HDI)</h2><span id='topic+hdi'></span><span id='topic+hdi.numeric'></span><span id='topic+hdi.data.frame'></span><span id='topic+hdi.stanreg'></span><span id='topic+hdi.brmsfit'></span><span id='topic+hdi.get_predicted'></span>

<h3>Description</h3>

<p>Compute the <strong>Highest Density Interval (HDI)</strong> of posterior distributions.
All points within this interval have a higher probability density than points
outside the interval. The HDI can be used in the context of uncertainty
characterisation of posterior distributions as <strong>Credible Interval (CI)</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdi(x, ...)

## S3 method for class 'numeric'
hdi(x, ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'data.frame'
hdi(x, ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'stanreg'
hdi(
  x,
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'brmsfit'
hdi(
  x,
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'get_predicted'
hdi(x, ci = 0.95, use_iterations = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdi_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution, or a data frame of such
vectors. Can also be a Bayesian model. <strong>bayestestR</strong> supports a wide range
of models (see, for example, <code>methods("hdi")</code>) and not all of those are
documented in the 'Usage' section, because methods for other classes mostly
resemble the arguments of the <code>.numeric</code> or <code>.data.frame</code>methods.</p>
</td></tr>
<tr><td><code id="hdi_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="hdi_+3A_ci">ci</code></td>
<td>
<p>Value or vector of probability of the (credible) interval - CI
(between 0 and 1) to be estimated. Default to <code>.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="hdi_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="hdi_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="hdi_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="hdi_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="hdi_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike equal-tailed intervals (see <code>eti()</code>) that typically exclude <code style="white-space: pre;">&#8288;2.5%&#8288;</code>
from each tail of the distribution and always include the median, the HDI is
<em>not</em> equal-tailed and therefore always includes the mode(s) of posterior
distributions. While this can be useful to better represent the credibility
mass of a distribution, the HDI also has some limitations. See <code><a href="#topic+spi">spi()</a></code> for
details.
</p>
<p>The <a href="https://easystats.github.io/bayestestR/articles/credible_interval.html"><code style="white-space: pre;">&#8288;95%&#8288;</code> or <code style="white-space: pre;">&#8288;89%&#8288;</code> Credible Intervals (CI)</a>
are two reasonable ranges to characterize the uncertainty related to the
estimation (see <a href="https://easystats.github.io/bayestestR/articles/credible_interval.html">here</a>
for a discussion about the differences between these two values).
</p>
<p>The <code style="white-space: pre;">&#8288;89%&#8288;</code> intervals (<code>ci = 0.89</code>) are deemed to be more stable than, for
instance, <code style="white-space: pre;">&#8288;95%&#8288;</code> intervals (<em>Kruschke, 2014</em>). An effective sample size
of at least 10.000 is recommended if one wants to estimate <code style="white-space: pre;">&#8288;95%&#8288;</code> intervals
with high precision (<em>Kruschke, 2014, p. 183ff</em>). Unfortunately, the
default number of posterior samples for most Bayes packages (e.g., <code>rstanarm</code>
or <code>brms</code>) is only 4.000 (thus, you might want to increase it when fitting
your model). Moreover, 89 indicates the arbitrariness of interval limits -
its only remarkable property is being the highest prime number that does not
exceed the already unstable <code style="white-space: pre;">&#8288;95%&#8288;</code> threshold (<em>McElreath, 2015</em>).
</p>
<p>However, <code style="white-space: pre;">&#8288;95%&#8288;</code> has some <a href="https://easystats.github.io/blog/posts/bayestestr_95/">advantages too</a>. For instance, it
shares (in the case of a normal posterior distribution) an intuitive
relationship with the standard deviation and it conveys a more accurate image
of the (artificial) bounds of the distribution. Also, because it is wider, it
makes analyses more conservative (i.e., the probability of covering 0 is
larger for the <code style="white-space: pre;">&#8288;95%&#8288;</code> CI than for lower ranges such as <code style="white-space: pre;">&#8288;89%&#8288;</code>), which is a good
thing in the context of the reproducibility crisis.
</p>
<p>A <code style="white-space: pre;">&#8288;95%&#8288;</code> equal-tailed interval (ETI) has <code style="white-space: pre;">&#8288;2.5%&#8288;</code> of the distribution on either
side of its limits. It indicates the 2.5th percentile and the 97.5h
percentile. In symmetric distributions, the two methods of computing credible
intervals, the ETI and the <a href="#topic+hdi">HDI</a>, return similar results.
</p>
<p>This is not the case for skewed distributions. Indeed, it is possible that
parameter values in the ETI have lower credibility (are less probable) than
parameter values outside the ETI. This property seems undesirable as a summary
of the credible values in a distribution.
</p>
<p>On the other hand, the ETI range does change when transformations are applied
to the distribution (for instance, for a log odds scale to probabilities):
the lower and higher bounds of the transformed distribution will correspond
to the transformed lower and higher bounds of the original distribution.
On the contrary, applying transformations to the distribution will change
the resulting HDI.
</p>


<h3>Value</h3>

<p>A data frame with following columns:
</p>

<ul>
<li> <p><code>Parameter</code> The model parameter(s), if <code>x</code> is a model-object. If <code>x</code> is a
vector, this column is missing.
</p>
</li>
<li> <p><code>CI</code> The probability of the credible interval.
</p>
</li>
<li> <p><code>CI_low</code>, <code>CI_high</code> The lower and upper credible interval limits for the parameters.
</p>
</li></ul>



<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>Author(s)</h3>

<p>Credits go to <strong>ggdistribute</strong> and <a href="https://github.com/mikemeredith/HDInterval"><strong>HDInterval</strong></a>.
</p>


<h3>References</h3>


<ul>
<li><p> Kruschke, J. (2014). Doing Bayesian data analysis: A tutorial with R, JAGS,
and Stan. Academic Press.
</p>
</li>
<li><p> McElreath, R. (2015). Statistical rethinking: A Bayesian course with
examples in R and Stan. Chapman and Hall/CRC.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other interval functions, such as <code><a href="#topic+hdi">hdi()</a></code>, <code><a href="#topic+eti">eti()</a></code>, <code><a href="#topic+bci">bci()</a></code>, <code><a href="#topic+spi">spi()</a></code>, <code><a href="#topic+si">si()</a></code>, <code><a href="#topic+cwi">cwi()</a></code>.
</p>
<p>Other ci: 
<code><a href="#topic+bci">bci</a>()</code>,
<code><a href="#topic+ci">ci</a>()</code>,
<code><a href="#topic+cwi">cwi</a>()</code>,
<code><a href="#topic+eti">eti</a>()</code>,
<code><a href="#topic+si">si</a>()</code>,
<code><a href="#topic+spi">spi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

posterior &lt;- rnorm(1000)
hdi(posterior, ci = 0.89)
hdi(posterior, ci = c(0.80, 0.90, 0.95))

bayestestR::hdi(iris[1:4])
bayestestR::hdi(iris[1:4], ci = c(0.80, 0.90, 0.95))

model &lt;- suppressWarnings(
  rstanarm::stan_glm(mpg ~ wt + gear, data = mtcars, chains = 2, iter = 200, refresh = 0)
)
bayestestR::hdi(model)
bayestestR::hdi(model, ci = c(0.80, 0.90, 0.95))

bayestestR::hdi(emmeans::emtrends(model, ~1, "wt", data = mtcars))

model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
bayestestR::hdi(model)
bayestestR::hdi(model, ci = c(0.80, 0.90, 0.95))

bf &lt;- BayesFactor::ttestBF(x = rnorm(100, 1, 1))
bayestestR::hdi(bf)
bayestestR::hdi(bf, ci = c(0.80, 0.90, 0.95))


</code></pre>

<hr>
<h2 id='map_estimate'>Maximum A Posteriori probability estimate (MAP)</h2><span id='topic+map_estimate'></span><span id='topic+map_estimate.numeric'></span><span id='topic+map_estimate.stanreg'></span><span id='topic+map_estimate.brmsfit'></span><span id='topic+map_estimate.data.frame'></span><span id='topic+map_estimate.get_predicted'></span>

<h3>Description</h3>

<p>Find the <strong>Highest Maximum A Posteriori probability estimate (MAP)</strong> of a
posterior, i.e., the value associated with the highest probability density
(the &quot;peak&quot; of the posterior distribution). In other words, it is an estimation
of the <em>mode</em> for continuous parameters. Note that this function relies on
<code><a href="#topic+estimate_density">estimate_density()</a></code>, which by default uses a different smoothing bandwidth
(<code>"SJ"</code>) compared to the legacy default implemented the base R <code><a href="stats.html#topic+density">density()</a></code>
function (<code>"nrd0"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_estimate(x, ...)

## S3 method for class 'numeric'
map_estimate(x, precision = 2^10, method = "kernel", ...)

## S3 method for class 'stanreg'
map_estimate(
  x,
  precision = 2^10,
  method = "kernel",
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  ...
)

## S3 method for class 'brmsfit'
map_estimate(
  x,
  precision = 2^10,
  method = "kernel",
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  ...
)

## S3 method for class 'data.frame'
map_estimate(x, precision = 2^10, method = "kernel", ...)

## S3 method for class 'get_predicted'
map_estimate(
  x,
  precision = 2^10,
  method = "kernel",
  use_iterations = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_estimate_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution, or a data frame of such
vectors. Can also be a Bayesian model. <strong>bayestestR</strong> supports a wide range
of models (see, for example, <code>methods("hdi")</code>) and not all of those are
documented in the 'Usage' section, because methods for other classes mostly
resemble the arguments of the <code>.numeric</code> or <code>.data.frame</code>methods.</p>
</td></tr>
<tr><td><code id="map_estimate_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="map_estimate_+3A_precision">precision</code></td>
<td>
<p>Number of points of density data. See the <code>n</code> parameter in <code>density</code>.</p>
</td></tr>
<tr><td><code id="map_estimate_+3A_method">method</code></td>
<td>
<p>Density estimation method. Can be <code>"kernel"</code> (default), <code>"logspline"</code>
or <code>"KernSmooth"</code>.</p>
</td></tr>
<tr><td><code id="map_estimate_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="map_estimate_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="map_estimate_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="map_estimate_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
<tr><td><code id="map_estimate_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value if <code>x</code> is a vector. If <code>x</code> is a model-object,
returns a data frame with following columns:
</p>

<ul>
<li> <p><code>Parameter</code>: The model parameter(s), if <code>x</code> is a model-object. If <code>x</code> is a
vector, this column is missing.
</p>
</li>
<li> <p><code>MAP_Estimate</code>: The MAP estimate for the posterior or each model parameter.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

library(bayestestR)

posterior &lt;- rnorm(10000)
map_estimate(posterior)

plot(density(posterior))
abline(v = as.numeric(map_estimate(posterior)), col = "red")

model &lt;- rstanarm::stan_glm(mpg ~ wt + cyl, data = mtcars)
map_estimate(model)

model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
map_estimate(model)


</code></pre>

<hr>
<h2 id='mcse'>Monte-Carlo Standard Error (MCSE)</h2><span id='topic+mcse'></span><span id='topic+mcse.stanreg'></span>

<h3>Description</h3>

<p>This function returns the Monte Carlo Standard Error (MCSE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcse(model, ...)

## S3 method for class 'stanreg'
mcse(
  model,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcse_+3A_model">model</code></td>
<td>
<p>A <code>stanreg</code>, <code>stanfit</code>, <code>brmsfit</code>, <code>blavaan</code>, or <code>MCMCglmm</code> object.</p>
</td></tr>
<tr><td><code id="mcse_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="mcse_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="mcse_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="mcse_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Monte Carlo Standard Error (MCSE)</strong> is another measure of
accuracy of the chains. It is defined as standard deviation of the chains
divided by their effective sample size (the formula for <code>mcse()</code> is
from Kruschke 2015, p. 187). The MCSE &ldquo;provides a quantitative
suggestion of how big the estimation noise is&rdquo;.
</p>


<h3>References</h3>

<p>Kruschke, J. (2014). Doing Bayesian data analysis: A tutorial with R, JAGS, and Stan. Academic Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(bayestestR)

model &lt;- suppressWarnings(
  rstanarm::stan_glm(mpg ~ wt + am, data = mtcars, chains = 1, refresh = 0)
)
mcse(model)


</code></pre>

<hr>
<h2 id='mediation'>Summary of Bayesian multivariate-response mediation-models</h2><span id='topic+mediation'></span><span id='topic+mediation.brmsfit'></span><span id='topic+mediation.stanmvreg'></span>

<h3>Description</h3>

<p><code>mediation()</code> is a short summary for multivariate-response
mediation-models, i.e. this function computes average direct and average
causal mediation effects of multivariate response models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mediation(model, ...)

## S3 method for class 'brmsfit'
mediation(
  model,
  treatment,
  mediator,
  response = NULL,
  centrality = "median",
  ci = 0.95,
  method = "ETI",
  ...
)

## S3 method for class 'stanmvreg'
mediation(
  model,
  treatment,
  mediator,
  response = NULL,
  centrality = "median",
  ci = 0.95,
  method = "ETI",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mediation_+3A_model">model</code></td>
<td>
<p>A <code>brmsfit</code> or <code>stanmvreg</code> object.</p>
</td></tr>
<tr><td><code id="mediation_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="mediation_+3A_treatment">treatment</code></td>
<td>
<p>Character, name of the treatment variable (or direct effect)
in a (multivariate response) mediator-model. If missing, <code>mediation()</code>
tries to find the treatment variable automatically, however, this may fail.</p>
</td></tr>
<tr><td><code id="mediation_+3A_mediator">mediator</code></td>
<td>
<p>Character, name of the mediator variable in a (multivariate
response) mediator-model. If missing, <code>mediation()</code> tries to find the
treatment variable automatically, however, this may fail.</p>
</td></tr>
<tr><td><code id="mediation_+3A_response">response</code></td>
<td>
<p>A named character vector, indicating the names of the response
variables to be used for the mediation analysis. Usually can be <code>NULL</code>,
in which case these variables are retrieved automatically. If not <code>NULL</code>,
names should match the names of the model formulas,
<code>names(insight::find_response(model, combine = TRUE))</code>. This can be
useful if, for instance, the mediator variable used as predictor has a different
name from the mediator variable used as response. This might occur when the
mediator is transformed in one model, but used &quot;as is&quot; as response variable
in the other model. Example: The mediator <code>m</code> is used as response variable,
but the centered version <code>m_center</code> is used as mediator variable. The
second response variable (for the treatment model, with the mediator as
additional predictor), <code>y</code>, is not transformed. Then we could use
<code>response</code> like this: <code>mediation(model, response = c(m = "m_center", y = "y"))</code>.</p>
</td></tr>
<tr><td><code id="mediation_+3A_centrality">centrality</code></td>
<td>
<p>The point-estimates (centrality indices) to compute. Character
(vector) or list with one or more of these options: <code>"median"</code>, <code>"mean"</code>, <code>"MAP"</code>
(see <code><a href="#topic+map_estimate">map_estimate()</a></code>), <code>"trimmed"</code> (which is just <code>mean(x, trim = threshold)</code>),
<code>"mode"</code> or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="mediation_+3A_ci">ci</code></td>
<td>
<p>Value or vector of probability of the CI (between 0 and 1)
to be estimated. Default to <code>0.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="mediation_+3A_method">method</code></td>
<td>
<p>Can be <a href="#topic+eti">&quot;ETI&quot;</a> (default), <a href="#topic+hdi">&quot;HDI&quot;</a>, <a href="#topic+bci">&quot;BCI&quot;</a>,
<a href="#topic+spi">&quot;SPI&quot;</a> or <a href="#topic+si">&quot;SI&quot;</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mediation()</code> returns a data frame with information on the
<em>direct effect</em> (mean value of posterior samples from <code>treatment</code>
of the outcome model), <em>mediator effect</em> (mean value of posterior
samples from <code>mediator</code> of the outcome model), <em>indirect effect</em>
(mean value of the multiplication of the posterior samples from
<code>mediator</code> of the outcome model and the posterior samples from
<code>treatment</code> of the mediation model) and the total effect (mean
value of sums of posterior samples used for the direct and indirect
effect). The <em>proportion mediated</em> is the indirect effect divided
by the total effect.
</p>
<p>For all values, the <code style="white-space: pre;">&#8288;89%&#8288;</code> credible intervals are calculated by default.
Use <code>ci</code> to calculate a different interval.
</p>
<p>The arguments <code>treatment</code> and <code>mediator</code> do not necessarily
need to be specified. If missing, <code>mediation()</code> tries to find the
treatment and mediator variable automatically. If this does not work,
specify these variables.
</p>
<p>The direct effect is also called <em>average direct effect</em> (ADE),
the indirect effect is also called <em>average causal mediation effects</em>
(ACME). See also <em>Tingley et al. 2014</em> and <em>Imai et al. 2010</em>.
</p>


<h3>Value</h3>

<p>A data frame with direct, indirect, mediator and
total effect of a multivariate-response mediation-model, as well as the
proportion mediated. The effect sizes are median values of the posterior
samples (use <code>centrality</code> for other centrality indices).
</p>


<h3>Note</h3>

<p>There is an <code>as.data.frame()</code> method that returns the posterior
samples of the effects, which can be used for further processing in the
different <span class="pkg">bayestestR</span> package.
</p>


<h3>References</h3>


<ul>
<li><p> Imai, K., Keele, L. and Tingley, D. (2010) A General Approach to Causal
Mediation Analysis, Psychological Methods, Vol. 15, No. 4 (December), pp.
309-334.
</p>
</li>
<li><p> Tingley, D., Yamamoto, T., Hirose, K., Imai, K. and Keele, L. (2014).
mediation: R package for Causal Mediation Analysis, Journal of Statistical
Software, Vol. 59, No. 5, pp. 1-38.
</p>
</li></ul>



<h3>See Also</h3>

<p>The <span class="pkg">mediation</span> package for a causal mediation analysis in
the frequentist framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(mediation)
library(brms)
library(rstanarm)

# load sample data
data(jobs)
set.seed(123)

# linear models, for mediation analysis
b1 &lt;- lm(job_seek ~ treat + econ_hard + sex + age, data = jobs)
b2 &lt;- lm(depress2 ~ treat + job_seek + econ_hard + sex + age, data = jobs)
# mediation analysis, for comparison with Stan models
m1 &lt;- mediate(b1, b2, sims = 1000, treat = "treat", mediator = "job_seek")

# Fit Bayesian mediation model in brms
f1 &lt;- bf(job_seek ~ treat + econ_hard + sex + age)
f2 &lt;- bf(depress2 ~ treat + job_seek + econ_hard + sex + age)
m2 &lt;- brm(f1 + f2 + set_rescor(FALSE), data = jobs, refresh = 0)

# Fit Bayesian mediation model in rstanarm
m3 &lt;- suppressWarnings(stan_mvmer(
  list(
    job_seek ~ treat + econ_hard + sex + age + (1 | occp),
    depress2 ~ treat + job_seek + econ_hard + sex + age + (1 | occp)
  ),
  data = jobs,
  refresh = 0
))

summary(m1)
mediation(m2, centrality = "mean", ci = 0.95)
mediation(m3, centrality = "mean", ci = 0.95)


</code></pre>

<hr>
<h2 id='model_to_priors'>Convert model's posteriors to priors (EXPERIMENTAL)</h2><span id='topic+model_to_priors'></span>

<h3>Description</h3>

<p>Convert model's posteriors to (normal) priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_to_priors(model, scale_multiply = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_to_priors_+3A_model">model</code></td>
<td>
<p>A Bayesian model.</p>
</td></tr>
<tr><td><code id="model_to_priors_+3A_scale_multiply">scale_multiply</code></td>
<td>
<p>The SD of the posterior will be multiplied by this amount before being set as a prior to avoid overly narrow priors.</p>
</td></tr>
<tr><td><code id="model_to_priors_+3A_...">...</code></td>
<td>
<p>Other arguments for <code>insight::get_prior()</code> or <code><a href="#topic+describe_posterior">describe_posterior</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# brms models
# -----------------------------------------------
if (require("brms")) {
  formula &lt;- brms::brmsformula(mpg ~ wt + cyl, center = FALSE)

  model &lt;- brms::brm(formula, data = mtcars, refresh = 0)
  priors &lt;- model_to_priors(model)
  priors &lt;- brms::validate_prior(priors, formula, data = mtcars)
  priors

  model2 &lt;- brms::brm(formula, data = mtcars, prior = priors, refresh = 0)
}

</code></pre>

<hr>
<h2 id='overlap'>Overlap Coefficient</h2><span id='topic+overlap'></span>

<h3>Description</h3>

<p>A method to calculate the overlap coefficient between two empirical distributions (that can be used as a measure of similarity between two samples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap(
  x,
  y,
  method_density = "kernel",
  method_auc = "trapezoid",
  precision = 2^10,
  extend = TRUE,
  extend_scale = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_+3A_x">x</code></td>
<td>
<p>Vector of x values.</p>
</td></tr>
<tr><td><code id="overlap_+3A_y">y</code></td>
<td>
<p>Vector of x values.</p>
</td></tr>
<tr><td><code id="overlap_+3A_method_density">method_density</code></td>
<td>
<p>Density estimation method. See <code><a href="#topic+estimate_density">estimate_density()</a></code>.</p>
</td></tr>
<tr><td><code id="overlap_+3A_method_auc">method_auc</code></td>
<td>
<p>Area Under the Curve (AUC) estimation method. See <code><a href="#topic+area_under_curve">area_under_curve()</a></code>.</p>
</td></tr>
<tr><td><code id="overlap_+3A_precision">precision</code></td>
<td>
<p>Number of points of density data. See the <code>n</code> parameter in <code>density</code>.</p>
</td></tr>
<tr><td><code id="overlap_+3A_extend">extend</code></td>
<td>
<p>Extend the range of the x axis by a factor of <code>extend_scale</code>.</p>
</td></tr>
<tr><td><code id="overlap_+3A_extend_scale">extend_scale</code></td>
<td>
<p>Ratio of range by which to extend the x axis. A value of <code>0.1</code>
means that the x axis will be extended by <code>1/10</code> of the range of the data.</p>
</td></tr>
<tr><td><code id="overlap_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(bayestestR)

x &lt;- distribution_normal(1000, 2, 0.5)
y &lt;- distribution_normal(1000, 0, 1)

overlap(x, y)
plot(overlap(x, y))
</code></pre>

<hr>
<h2 id='p_direction'>Probability of Direction (pd)</h2><span id='topic+p_direction'></span><span id='topic+pd'></span><span id='topic+p_direction.numeric'></span><span id='topic+p_direction.data.frame'></span><span id='topic+p_direction.MCMCglmm'></span><span id='topic+p_direction.emmGrid'></span><span id='topic+p_direction.stanreg'></span><span id='topic+p_direction.brmsfit'></span><span id='topic+p_direction.BFBayesFactor'></span><span id='topic+p_direction.get_predicted'></span>

<h3>Description</h3>

<p>Compute the <strong>Probability of Direction</strong> (<em><strong>pd</strong></em>, also known as the Maximum
Probability of Effect - <em>MPE</em>). This can be interpreted as the probability
that a parameter (described by its posterior distribution) is strictly
positive or negative (whichever is the most probable). Although differently
expressed, this index is fairly similar (<em>i.e.</em>, is strongly correlated) to
the frequentist <strong>p-value</strong> (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_direction(x, ...)

pd(x, ...)

## S3 method for class 'numeric'
p_direction(x, method = "direct", null = 0, ...)

## S3 method for class 'data.frame'
p_direction(x, method = "direct", null = 0, ...)

## S3 method for class 'MCMCglmm'
p_direction(x, method = "direct", null = 0, ...)

## S3 method for class 'emmGrid'
p_direction(x, method = "direct", null = 0, ...)

## S3 method for class 'stanreg'
p_direction(
  x,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  method = "direct",
  null = 0,
  ...
)

## S3 method for class 'brmsfit'
p_direction(
  x,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  method = "direct",
  null = 0,
  ...
)

## S3 method for class 'BFBayesFactor'
p_direction(x, method = "direct", null = 0, ...)

## S3 method for class 'get_predicted'
p_direction(
  x,
  method = "direct",
  null = 0,
  use_iterations = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_direction_+3A_x">x</code></td>
<td>
<p>A vector representing a posterior distribution, a data frame of
posterior draws (samples be parameter). Can also be a Bayesian model.</p>
</td></tr>
<tr><td><code id="p_direction_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="p_direction_+3A_method">method</code></td>
<td>
<p>Can be <code>"direct"</code> or one of methods of <code><a href="#topic+estimate_density">estimate_density()</a></code>,
such as <code>"kernel"</code>, <code>"logspline"</code> or <code>"KernSmooth"</code>. See details.</p>
</td></tr>
<tr><td><code id="p_direction_+3A_null">null</code></td>
<td>
<p>The value considered as a &quot;null&quot; effect. Traditionally 0, but
could also be 1 in the case of ratios of change (OR, IRR, ...).</p>
</td></tr>
<tr><td><code id="p_direction_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="p_direction_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="p_direction_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="p_direction_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
<tr><td><code id="p_direction_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>What is the <em>pd</em>?</h4>

<p>The Probability of Direction (pd) is an index of effect existence, representing
the certainty with which an effect goes in a particular direction (i.e., is
positive or negative / has a sign), typically ranging from 0.5 to 1 (but see
next section for cases where it can range between 0 and 1). Beyond
its simplicity of interpretation, understanding and computation, this index
also presents other interesting properties:
</p>

<ul>
<li><p> Like other posterior-based indices, <em>pd</em> is solely based on the posterior
distributions and does not require any additional information from the data
or the model (e.g., such as priors, as in the case of Bayes factors).
</p>
</li>
<li><p> It is robust to the scale of both the response variable and the predictors.
</p>
</li>
<li><p> It is strongly correlated with the frequentist p-value, and can thus
be used to draw parallels and give some reference to readers non-familiar
with Bayesian statistics (Makowski et al., 2019).
</p>
</li></ul>




<h4>Relationship with the p-value</h4>

<p>In most cases, it seems that the <em>pd</em> has a direct correspondence with the
frequentist one-sided <em>p</em>-value through the formula (for two-sided <em>p</em>):
</p>
<p style="text-align: center;"><code class="reqn">p = 2 \times (1 - p_d)</code>
</p>

<p>Thus, a two-sided p-value of respectively <code>.1</code>, <code>.05</code>, <code>.01</code> and <code>.001</code> would
correspond approximately to a <em>pd</em> of <code style="white-space: pre;">&#8288;95%&#8288;</code>, <code style="white-space: pre;">&#8288;97.5%&#8288;</code>, <code style="white-space: pre;">&#8288;99.5%&#8288;</code> and <code style="white-space: pre;">&#8288;99.95%&#8288;</code>.
See <code><a href="#topic+pd_to_p">pd_to_p()</a></code> for details.
</p>



<h4>Possible Range of Values</h4>

<p>The largest value <em>pd</em> can take is 1 - the posterior is strictly directional.
However, the smallest value <em>pd</em> can take depends on the parameter space
represented by the posterior.
<br /><br />
<strong>For a continuous parameter space</strong>, exact values of 0 (or any point null
value) are not possible, and so 100% of the posterior has <em>some</em> sign, some
positive, some negative. Therefore, the smallest the <em>pd</em> can be is 0.5 -
with an equal posterior mass of positive and negative values. Values close to
0.5 <em>cannot</em> be used to support the null hypothesis (that the parameter does
<em>not</em> have a direction) is a similar why to how large p-values cannot be used
to support the null hypothesis (see <code><a href="#topic+pd_to_p">pd_to_p()</a></code>; Makowski et al., 2019).
<br /><br />
<strong>For a discrete parameter space or a parameter space that is a mixture
between discrete and continuous spaces</strong>, exact values of 0 (or any point
null value) <em>are</em> possible! Therefore, the smallest the <em>pd</em> can be is 0 -
with 100% of the posterior mass on 0. Thus values close to 0 can be used to
support the null hypothesis (see van den Bergh et al., 2021).
<br /><br />
Examples of posteriors representing discrete parameter space:
</p>

<ul>
<li><p> When a parameter can only take discrete values.
</p>
</li>
<li><p> When a mixture prior/posterior is used (such as the spike-and-slab prior;
see van den Bergh et al., 2021).
</p>
</li>
<li><p> When conducting Bayesian model averaging (e.g., <code><a href="#topic+weighted_posteriors">weighted_posteriors()</a></code> or
<code>brms::posterior_average</code>).
</p>
</li></ul>




<h4>Methods of computation</h4>

<p>The <em>pd</em> is defined as:
</p>
<p style="text-align: center;"><code class="reqn">p_d = max({Pr(\hat{\theta} &lt; \theta_{null}), Pr(\hat{\theta} &gt; \theta_{null})})</code>
</p>

<p><br /><br />
The most simple and direct way to compute the <em>pd</em> is to compute the
proportion of positive (or larger than <code>null</code>) posterior samples, the
proportion of negative (or smaller than <code>null</code>) posterior samples, and take
the larger of the two. This &quot;simple&quot; method is the most straightforward, but
its precision is directly tied to the number of posterior draws.
<br /><br />
The second approach relies on <a href="#topic+estimate_density">density estimation</a>: It starts by
estimating the continuous-smooth density function (for which many methods are
available), and then computing the <a href="#topic+area_under_curve">area under the curve</a>
(AUC) of the density curve on either side of <code>null</code> and taking the maximum
between them. Note the this approach assumes a continuous density function,
and so <strong>when the posterior represents a (partially) discrete parameter
space, only the direct method <em>must</em> be used</strong> (see above).
</p>



<h3>Value</h3>

<p>Values between 0.5 and 1 <em>or</em> between 0 and 1 (see above) corresponding to
the probability of direction (pd).
</p>


<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>References</h3>


<ul>
<li><p> Makowski, D., Ben-Shachar, M. S., Chen, S. A., &amp; Lüdecke, D. (2019).
Indices of effect existence and significance in the Bayesian framework.
Frontiers in psychology, 10, 2767. <a href="https://doi.org/10.3389/fpsyg.2019.02767">doi:10.3389/fpsyg.2019.02767</a>
</p>
</li>
<li><p> van den Bergh, D., Haaf, J. M., Ly, A., Rouder, J. N., &amp; Wagenmakers, E. J.
(2021). A cautionary note on estimating effect size. Advances in Methods
and Practices in Psychological Science, 4(1). <a href="https://doi.org/10.1177/2515245921992035">doi:10.1177/2515245921992035</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+pd_to_p">pd_to_p()</a></code> to convert between Probability of Direction (pd) and p-value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(bayestestR)

# Simulate a posterior distribution of mean 1 and SD 1
# ----------------------------------------------------
posterior &lt;- rnorm(1000, mean = 1, sd = 1)
p_direction(posterior)
p_direction(posterior, method = "kernel")

# Simulate a dataframe of posterior distributions
# -----------------------------------------------
df &lt;- data.frame(replicate(4, rnorm(100)))
p_direction(df)
p_direction(df, method = "kernel")

# rstanarm models
# -----------------------------------------------
if (require("rstanarm")) {
  model &lt;- rstanarm::stan_glm(mpg ~ wt + cyl,
    data = mtcars,
    chains = 2, refresh = 0
  )
  p_direction(model)
  p_direction(model, method = "kernel")
}

# emmeans
# -----------------------------------------------
if (require("emmeans")) {
  p_direction(emtrends(model, ~1, "wt", data = mtcars))
}

# brms models
# -----------------------------------------------
if (require("brms")) {
  model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
  p_direction(model)
  p_direction(model, method = "kernel")
}

# BayesFactor objects
# -----------------------------------------------
if (require("BayesFactor")) {
  bf &lt;- ttestBF(x = rnorm(100, 1, 1))
  p_direction(bf)
  p_direction(bf, method = "kernel")
}

</code></pre>

<hr>
<h2 id='p_map'>Bayesian p-value based on the density at the Maximum A Posteriori (MAP)</h2><span id='topic+p_map'></span><span id='topic+p_pointnull'></span><span id='topic+p_map.numeric'></span><span id='topic+p_map.get_predicted'></span><span id='topic+p_map.stanreg'></span><span id='topic+p_map.brmsfit'></span>

<h3>Description</h3>

<p>Compute a Bayesian equivalent of the <em>p</em>-value, related to the odds that a
parameter (described by its posterior distribution) has against the null
hypothesis (<em>h0</em>) using Mills' (2014, 2017) <em>Objective Bayesian Hypothesis
Testing</em> framework. It corresponds to the density value at the null (e.g., 0)
divided by the density at the Maximum A Posteriori (MAP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_map(x, ...)

p_pointnull(x, ...)

## S3 method for class 'numeric'
p_map(x, null = 0, precision = 2^10, method = "kernel", ...)

## S3 method for class 'get_predicted'
p_map(
  x,
  null = 0,
  precision = 2^10,
  method = "kernel",
  use_iterations = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'stanreg'
p_map(
  x,
  null = 0,
  precision = 2^10,
  method = "kernel",
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  ...
)

## S3 method for class 'brmsfit'
p_map(
  x,
  null = 0,
  precision = 2^10,
  method = "kernel",
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_map_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution, or a data frame of such
vectors. Can also be a Bayesian model. <strong>bayestestR</strong> supports a wide range
of models (see, for example, <code>methods("hdi")</code>) and not all of those are
documented in the 'Usage' section, because methods for other classes mostly
resemble the arguments of the <code>.numeric</code> or <code>.data.frame</code>methods.</p>
</td></tr>
<tr><td><code id="p_map_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="p_map_+3A_null">null</code></td>
<td>
<p>The value considered as a &quot;null&quot; effect. Traditionally 0, but
could also be 1 in the case of ratios of change (OR, IRR, ...).</p>
</td></tr>
<tr><td><code id="p_map_+3A_precision">precision</code></td>
<td>
<p>Number of points of density data. See the <code>n</code> parameter in <code>density</code>.</p>
</td></tr>
<tr><td><code id="p_map_+3A_method">method</code></td>
<td>
<p>Density estimation method. Can be <code>"kernel"</code> (default), <code>"logspline"</code>
or <code>"KernSmooth"</code>.</p>
</td></tr>
<tr><td><code id="p_map_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
<tr><td><code id="p_map_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="p_map_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="p_map_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="p_map_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this method is sensitive to the density estimation <code>method</code>
(see the section in the examples below).
</p>


<h4>Strengths and Limitations</h4>

<p><strong>Strengths:</strong> Straightforward computation. Objective property of the posterior
distribution.
</p>
<p><strong>Limitations:</strong> Limited information favoring the null hypothesis. Relates
on density approximation. Indirect relationship between mathematical
definition and interpretation. Only suitable for weak / very diffused priors.
</p>



<h3>References</h3>


<ul>
<li><p> Makowski D, Ben-Shachar MS, Chen SHA, Lüdecke D (2019) Indices of Effect Existence and Significance in the Bayesian Framework. Frontiers in Psychology 2019;10:2767. <a href="https://doi.org/10.3389/fpsyg.2019.02767">doi:10.3389/fpsyg.2019.02767</a>
</p>
</li>
<li><p> Mills, J. A. (2018). Objective Bayesian Precise Hypothesis Testing. University of Cincinnati.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="https://www.youtube.com/watch?v=Ip8Ci5KUVRc">Jeff Mill's talk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

p_map(rnorm(1000, 0, 1))
p_map(rnorm(1000, 10, 1))

model &lt;- suppressWarnings(
  rstanarm::stan_glm(mpg ~ wt + gear, data = mtcars, chains = 2, iter = 200, refresh = 0)
)
p_map(model)

p_map(suppressWarnings(
  emmeans::emtrends(model, ~1, "wt", data = mtcars)
))

model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
p_map(model)

bf &lt;- BayesFactor::ttestBF(x = rnorm(100, 1, 1))
p_map(bf)

# ---------------------------------------
# Robustness to density estimation method
set.seed(333)
data &lt;- data.frame()
for (iteration in 1:250) {
  x &lt;- rnorm(1000, 1, 1)
  result &lt;- data.frame(
    Kernel = as.numeric(p_map(x, method = "kernel")),
    KernSmooth = as.numeric(p_map(x, method = "KernSmooth")),
    logspline = as.numeric(p_map(x, method = "logspline"))
  )
  data &lt;- rbind(data, result)
}
data$KernSmooth &lt;- data$Kernel - data$KernSmooth
data$logspline &lt;- data$Kernel - data$logspline

summary(data$KernSmooth)
summary(data$logspline)
boxplot(data[c("KernSmooth", "logspline")])


</code></pre>

<hr>
<h2 id='p_rope'>Probability of being in the ROPE</h2><span id='topic+p_rope'></span><span id='topic+p_rope.numeric'></span><span id='topic+p_rope.stanreg'></span><span id='topic+p_rope.brmsfit'></span>

<h3>Description</h3>

<p>Compute the proportion of the whole posterior distribution that doesn't lie within a region of practical equivalence (ROPE). It is equivalent to running <code>rope(..., ci = 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_rope(x, ...)

## S3 method for class 'numeric'
p_rope(x, range = "default", verbose = TRUE, ...)

## S3 method for class 'stanreg'
p_rope(
  x,
  range = "default",
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  verbose = verbose,
  ...
)

## S3 method for class 'brmsfit'
p_rope(
  x,
  range = "default",
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  verbose = verbose,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_rope_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution. Can also be a
<code>stanreg</code> or <code>brmsfit</code> model.</p>
</td></tr>
<tr><td><code id="p_rope_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="p_rope_+3A_range">range</code></td>
<td>
<p>ROPE's lower and higher bounds. Should be <code>"default"</code> or
depending on the number of outcome variables a vector or a list. In
models with one response, <code>range</code> should be a vector of length two (e.g.,
<code>c(-0.1, 0.1)</code>). In multivariate models, <code>range</code> should be a list with a
numeric vectors for each response variable. Vector names should correspond
to the name of the response variables. If <code>"default"</code> and input is a vector,
the range is set to <code>c(-0.1, 0.1)</code>. If <code>"default"</code> and input is a Bayesian
model, <code><a href="#topic+rope_range">rope_range()</a></code> is used.</p>
</td></tr>
<tr><td><code id="p_rope_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="p_rope_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="p_rope_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="p_rope_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(bayestestR)

p_rope(x = rnorm(1000, 0, 0.01), range = c(-0.1, 0.1))
p_rope(x = mtcars, range = c(-0.1, 0.1))
</code></pre>

<hr>
<h2 id='p_significance'>Practical Significance (ps)</h2><span id='topic+p_significance'></span><span id='topic+p_significance.numeric'></span><span id='topic+p_significance.get_predicted'></span><span id='topic+p_significance.stanreg'></span><span id='topic+p_significance.brmsfit'></span>

<h3>Description</h3>

<p>Compute the probability of <strong>Practical Significance</strong> (<em><strong>ps</strong></em>), which can be conceptualized as a unidirectional equivalence test. It returns the probability that effect is above a given threshold corresponding to a negligible effect in the median's direction. Mathematically, it is defined as the proportion of the posterior distribution of the median sign above the threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_significance(x, ...)

## S3 method for class 'numeric'
p_significance(x, threshold = "default", ...)

## S3 method for class 'get_predicted'
p_significance(
  x,
  threshold = "default",
  use_iterations = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'stanreg'
p_significance(
  x,
  threshold = "default",
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'brmsfit'
p_significance(
  x,
  threshold = "default",
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_significance_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution. Can also be a
<code>stanreg</code> or <code>brmsfit</code> model.</p>
</td></tr>
<tr><td><code id="p_significance_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="p_significance_+3A_threshold">threshold</code></td>
<td>
<p>The threshold value that separates significant from negligible effect. If <code>"default"</code>, the range is set to <code>0.1</code> if input is a vector, and based on <code><a href="#topic+rope_range">rope_range()</a></code> if a Bayesian model is provided.</p>
</td></tr>
<tr><td><code id="p_significance_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
<tr><td><code id="p_significance_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="p_significance_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="p_significance_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="p_significance_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>p_significance()</code> returns the proportion of a probability
distribution (<code>x</code>) that is outside a certain range (the negligible
effect, or ROPE, see argument <code>threshold</code>). If there are values of the
distribution both below and above the ROPE, <code>p_significance()</code> returns
the higher probability of a value being outside the ROPE. Typically, this
value should be larger than 0.5 to indicate practical significance. However,
if the range of the negligible effect is rather large compared to the
range of the probability distribution <code>x</code>, <code>p_significance()</code>
will be less than 0.5, which indicates no clear practical significance.
</p>


<h3>Value</h3>

<p>Values between 0 and 1 corresponding to the probability of practical significance (ps).
</p>


<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

# Simulate a posterior distribution of mean 1 and SD 1
# ----------------------------------------------------
posterior &lt;- rnorm(1000, mean = 1, sd = 1)
p_significance(posterior)

# Simulate a dataframe of posterior distributions
# -----------------------------------------------
df &lt;- data.frame(replicate(4, rnorm(100)))
p_significance(df)

# rstanarm models
# -----------------------------------------------
model &lt;- rstanarm::stan_glm(mpg ~ wt + cyl,
  data = mtcars,
  chains = 2, refresh = 0
)
p_significance(model)


</code></pre>

<hr>
<h2 id='p_to_bf'>Convert p-values to (pseudo) Bayes Factors</h2><span id='topic+p_to_bf'></span><span id='topic+p_to_bf.numeric'></span><span id='topic+p_to_bf.default'></span>

<h3>Description</h3>

<p>Convert p-values to (pseudo) Bayes Factors. This transformation has been
suggested by Wagenmakers (2022), but is based on a vast amount of assumptions.
It might therefore be not reliable. Use at your own risks. For more accurate
approximate Bayes factors, use <code><a href="#topic+bic_to_bf">bic_to_bf()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_to_bf(x, ...)

## S3 method for class 'numeric'
p_to_bf(x, log = FALSE, n_obs = NULL, ...)

## Default S3 method:
p_to_bf(x, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_to_bf_+3A_x">x</code></td>
<td>
<p>A (frequentist) model object, or a (numeric) vector of p-values.</p>
</td></tr>
<tr><td><code id="p_to_bf_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed (not used for now).</p>
</td></tr>
<tr><td><code id="p_to_bf_+3A_log">log</code></td>
<td>
<p>Wether to return log Bayes Factors. <strong>Note:</strong> The <code>print()</code> method
always shows <code>BF</code> - the <code>"log_BF"</code> column is only accessible from the returned
data frame.</p>
</td></tr>
<tr><td><code id="p_to_bf_+3A_n_obs">n_obs</code></td>
<td>
<p>Number of observations. Either length 1, or same length as <code>p</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the p-values and pseudo-Bayes factors (against the null).
</p>


<h3>References</h3>


<ul>
<li><p> Wagenmakers, E.J. (2022). Approximate objective Bayes factors from p-values
and sample size: The 3p(sqrt(n)) rule. Preprint available on ArXiv:
https://psyarxiv.com/egydq
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bic_to_bf">bic_to_bf()</a></code> for more accurate approximate Bayes factors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
model &lt;- lm(Petal.Length ~ Sepal.Length + Species, data = iris)
p_to_bf(model)

# Examples that demonstrate comparison between
# BIC-approximated and pseudo BF
# --------------------------------------------
m0 &lt;- lm(mpg ~ 1, mtcars)
m1 &lt;- lm(mpg ~ am, mtcars)
m2 &lt;- lm(mpg ~ factor(cyl), mtcars)

# In this first example, BIC-approximated BF and
# pseudo-BF based on p-values are close...

# BIC-approximated BF, m1 against null model
bic_to_bf(BIC(m1), denominator = BIC(m0))

# pseudo-BF based on p-values - dropping intercept
p_to_bf(m1)[-1, ]

# The second example shows that results from pseudo-BF are less accurate
# and should be handled wit caution!
bic_to_bf(BIC(m2), denominator = BIC(m0))
p_to_bf(anova(m2), n_obs = nrow(mtcars))

</code></pre>

<hr>
<h2 id='pd_to_p'>Convert between Probability of Direction (pd) and p-value.</h2><span id='topic+pd_to_p'></span><span id='topic+p_to_pd'></span><span id='topic+convert_p_to_pd'></span><span id='topic+convert_pd_to_p'></span>

<h3>Description</h3>

<p>Enables a conversion between Probability of Direction (pd) and p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pd_to_p(pd, direction = "two-sided", verbose = TRUE, ...)

p_to_pd(p, direction = "two-sided", ...)

convert_p_to_pd(p, direction = "two-sided", ...)

convert_pd_to_p(pd, direction = "two-sided", verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pd_to_p_+3A_pd">pd</code></td>
<td>
<p>A Probability of Direction (pd) value (between 0 and 1).</p>
</td></tr>
<tr><td><code id="pd_to_p_+3A_direction">direction</code></td>
<td>
<p>What type of p-value is requested or provided. Can be
<code>"two-sided"</code> (default, two tailed) or <code>"one-sided"</code> (one tailed).</p>
</td></tr>
<tr><td><code id="pd_to_p_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="pd_to_p_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="pd_to_p_+3A_p">p</code></td>
<td>
<p>A p-value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conversion is done using the following equation (see Makowski et al., 2019):
<br /><br />
When <code>direction = "two-sided"</code> -
<br /><br />
</p>
<p style="text-align: center;"><code class="reqn">p = 2 \times (1 - p_d)</code>
</p>

<p>When <code>direction = "one-sided"</code> -
<br /><br />
</p>
<p style="text-align: center;"><code class="reqn">p = 1 - p_d</code>
</p>

<p><br /><br />
Note that this conversion is only valid when the lowest possible values of pd
is 0.5 - i.e., when the posterior represents continuous parameter space (see
<a href="#topic+p_direction">p_direction</a>). If any pd &lt; 0.5 are detected, they are converted to a p of 1,
and a warning is given.
</p>


<h3>References</h3>

<p>Makowski, D., Ben-Shachar, M. S., Chen, S. H. A., and Lüdecke, D. (2019).
<em>Indices of Effect Existence and Significance in the Bayesian Framework</em>.
Frontiers in Psychology 2019;10:2767. <a href="https://doi.org/10.3389/fpsyg.2019.02767">doi:10.3389/fpsyg.2019.02767</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pd_to_p(pd = 0.95)
pd_to_p(pd = 0.95, direction = "one-sided")

</code></pre>

<hr>
<h2 id='point_estimate'>Point-estimates of posterior distributions</h2><span id='topic+point_estimate'></span><span id='topic+point_estimate.numeric'></span><span id='topic+point_estimate.stanreg'></span><span id='topic+point_estimate.brmsfit'></span><span id='topic+point_estimate.BFBayesFactor'></span><span id='topic+point_estimate.get_predicted'></span>

<h3>Description</h3>

<p>Compute various point-estimates, such as the mean, the median or the MAP, to describe posterior distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_estimate(x, ...)

## S3 method for class 'numeric'
point_estimate(x, centrality = "all", dispersion = FALSE, threshold = 0.1, ...)

## S3 method for class 'stanreg'
point_estimate(
  x,
  centrality = "all",
  dispersion = FALSE,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  ...
)

## S3 method for class 'brmsfit'
point_estimate(
  x,
  centrality = "all",
  dispersion = FALSE,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  ...
)

## S3 method for class 'BFBayesFactor'
point_estimate(x, centrality = "all", dispersion = FALSE, ...)

## S3 method for class 'get_predicted'
point_estimate(
  x,
  centrality = "all",
  dispersion = FALSE,
  use_iterations = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point_estimate_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution, or a data frame of such
vectors. Can also be a Bayesian model. <strong>bayestestR</strong> supports a wide range
of models (see, for example, <code>methods("hdi")</code>) and not all of those are
documented in the 'Usage' section, because methods for other classes mostly
resemble the arguments of the <code>.numeric</code> or <code>.data.frame</code>methods.</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_centrality">centrality</code></td>
<td>
<p>The point-estimates (centrality indices) to compute. Character
(vector) or list with one or more of these options: <code>"median"</code>, <code>"mean"</code>, <code>"MAP"</code>
(see <code><a href="#topic+map_estimate">map_estimate()</a></code>), <code>"trimmed"</code> (which is just <code>mean(x, trim = threshold)</code>),
<code>"mode"</code> or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_dispersion">dispersion</code></td>
<td>
<p>Logical, if <code>TRUE</code>, computes indices of dispersion related
to the estimate(s) (<code>SD</code> and <code>MAD</code> for <code>mean</code> and <code>median</code>, respectively).
Dispersion is not available for <code>"MAP"</code> or <code>"mode"</code> centrality indices.</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_threshold">threshold</code></td>
<td>
<p>For <code>centrality = "trimmed"</code> (i.e. trimmed mean), indicates
the fraction (0 to 0.5) of observations to be trimmed from each end of the
vector before the mean is computed.</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>References</h3>

<p>Makowski, D., Ben-Shachar, M. S., Chen, S. H. A., and Lüdecke, D.
(2019). <em>Indices of Effect Existence and Significance in the Bayesian Framework</em>.
Frontiers in Psychology 2019;10:2767. <a href="https://doi.org/10.3389/fpsyg.2019.02767">doi:10.3389/fpsyg.2019.02767</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

point_estimate(rnorm(1000))
point_estimate(rnorm(1000), centrality = "all", dispersion = TRUE)
point_estimate(rnorm(1000), centrality = c("median", "MAP"))

df &lt;- data.frame(replicate(4, rnorm(100)))
point_estimate(df, centrality = "all", dispersion = TRUE)
point_estimate(df, centrality = c("median", "MAP"))

# rstanarm models
# -----------------------------------------------
model &lt;- rstanarm::stan_glm(mpg ~ wt + cyl, data = mtcars)
point_estimate(model, centrality = "all", dispersion = TRUE)
point_estimate(model, centrality = c("median", "MAP"))


# emmeans estimates
# -----------------------------------------------
point_estimate(
  emmeans::emtrends(model, ~1, "wt", data = mtcars),
  centrality = c("median", "MAP")
)

# brms models
# -----------------------------------------------
model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
point_estimate(model, centrality = "all", dispersion = TRUE)
point_estimate(model, centrality = c("median", "MAP"))

# BayesFactor objects
# -----------------------------------------------
bf &lt;- BayesFactor::ttestBF(x = rnorm(100, 1, 1))
point_estimate(bf, centrality = "all", dispersion = TRUE)
point_estimate(bf, centrality = c("median", "MAP"))


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+print_html'></span><span id='topic+print_md'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>insight</dt><dd><p><code><a href="insight.html#topic+display">print_html</a></code>, <code><a href="insight.html#topic+display">print_md</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reshape_iterations'>Reshape estimations with multiple iterations (draws) to long format</h2><span id='topic+reshape_iterations'></span><span id='topic+reshape_draws'></span>

<h3>Description</h3>

<p>Reshape a wide data.frame of iterations (such as posterior draws or
bootsrapped samples) as columns to long format. Instead of having all
iterations as columns (e.g., <code style="white-space: pre;">&#8288;iter_1, iter_2, ...&#8288;</code>), will return 3 columns
with the <code style="white-space: pre;">&#8288;\*_index&#8288;</code> (the previous index of the row), the <code style="white-space: pre;">&#8288;\*_group&#8288;</code> (the
iteration number) and the <code style="white-space: pre;">&#8288;\*_value&#8288;</code> (the value of said iteration).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_iterations(x, prefix = c("draw", "iter", "iteration", "sim"))

reshape_draws(x, prefix = c("draw", "iter", "iteration", "sim"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_iterations_+3A_x">x</code></td>
<td>
<p>A data.frame containing posterior draws obtained from
<code>estimate_response</code> or <code>estimate_link</code>.</p>
</td></tr>
<tr><td><code id="reshape_iterations_+3A_prefix">prefix</code></td>
<td>
<p>The prefix of the draws (for instance, <code>"iter_"</code> for columns
named as <code style="white-space: pre;">&#8288;iter_1, iter_2, iter_3&#8288;</code>). If more than one are provided, will
search for the first one that matches.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of reshaped draws in long format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("rstanarm")) {
  model &lt;- stan_glm(mpg ~ am, data = mtcars, refresh = 0)
  draws &lt;- insight::get_predicted(model)
  long_format &lt;- reshape_iterations(draws)
  head(long_format)
}

</code></pre>

<hr>
<h2 id='rope'>Region of Practical Equivalence (ROPE)</h2><span id='topic+rope'></span><span id='topic+rope.numeric'></span><span id='topic+rope.stanreg'></span><span id='topic+rope.brmsfit'></span>

<h3>Description</h3>

<p>Compute the proportion of the HDI (default to the <code style="white-space: pre;">&#8288;89%&#8288;</code> HDI) of a posterior
distribution that lies within a region of practical equivalence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rope(x, ...)

## S3 method for class 'numeric'
rope(x, range = "default", ci = 0.95, ci_method = "ETI", verbose = TRUE, ...)

## S3 method for class 'stanreg'
rope(
  x,
  range = "default",
  ci = 0.95,
  ci_method = "ETI",
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'brmsfit'
rope(
  x,
  range = "default",
  ci = 0.95,
  ci_method = "ETI",
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rope_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution. Can also be a
<code>stanreg</code> or <code>brmsfit</code> model.</p>
</td></tr>
<tr><td><code id="rope_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="rope_+3A_range">range</code></td>
<td>
<p>ROPE's lower and higher bounds. Should be <code>"default"</code> or
depending on the number of outcome variables a vector or a list. In
models with one response, <code>range</code> should be a vector of length two (e.g.,
<code>c(-0.1, 0.1)</code>). In multivariate models, <code>range</code> should be a list with a
numeric vectors for each response variable. Vector names should correspond
to the name of the response variables. If <code>"default"</code> and input is a vector,
the range is set to <code>c(-0.1, 0.1)</code>. If <code>"default"</code> and input is a Bayesian
model, <code><a href="#topic+rope_range">rope_range()</a></code> is used.</p>
</td></tr>
<tr><td><code id="rope_+3A_ci">ci</code></td>
<td>
<p>The Credible Interval (CI) probability, corresponding to the
proportion of HDI, to use for the percentage in ROPE.</p>
</td></tr>
<tr><td><code id="rope_+3A_ci_method">ci_method</code></td>
<td>
<p>The type of interval to use to quantify the percentage in
ROPE. Can be 'HDI' (default) or 'ETI'. See <code><a href="#topic+ci">ci()</a></code>.</p>
</td></tr>
<tr><td><code id="rope_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="rope_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="rope_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="rope_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
</table>


<h3>ROPE</h3>

<p>Statistically, the probability of a posterior distribution of being
different from 0 does not make much sense (the probability of a single value
null hypothesis in a continuous distribution is 0). Therefore, the idea
underlining ROPE is to let the user define an area around the null value
enclosing values that are <em>equivalent to the null</em> value for practical
purposes (<em>Kruschke 2010, 2011, 2014</em>).
</p>
<p>Kruschke (2018) suggests that such null value could be set, by default,
to the -0.1 to 0.1 range of a standardized parameter (negligible effect
size according to Cohen, 1988). This could be generalized: For instance,
for linear models, the ROPE could be set as <code style="white-space: pre;">&#8288;0 +/- .1 * sd(y)&#8288;</code>.
This ROPE range can be automatically computed for models using the
<a href="#topic+rope_range">rope_range</a> function.
</p>
<p>Kruschke (2010, 2011, 2014) suggests using the proportion of  the <code style="white-space: pre;">&#8288;95%&#8288;</code>
(or <code style="white-space: pre;">&#8288;89%&#8288;</code>, considered more stable) <a href="#topic+hdi">HDI</a> that falls within the
ROPE as an index for &quot;null-hypothesis&quot; testing (as understood under the
Bayesian framework, see <code><a href="#topic+equivalence_test">equivalence_test()</a></code>).
</p>


<h3>Sensitivity to parameter's scale</h3>

<p>It is important to consider the unit (i.e., the scale) of the predictors
when using an index based on the ROPE, as the correct interpretation of the
ROPE as representing a region of practical equivalence to zero is dependent
on the scale of the predictors. Indeed, the percentage in ROPE depend on
the unit of its parameter. In other words, as the ROPE represents a fixed
portion of the response's scale, its proximity with a coefficient depends
on the scale of the coefficient itself.
</p>


<h3>Multicollinearity - Non-independent covariates</h3>

<p>When parameters show strong correlations, i.e. when covariates are not
independent, the joint parameter distributions may shift towards or
away from the ROPE. Collinearity invalidates ROPE and hypothesis
testing based on univariate marginals, as the probabilities are conditional
on independence. Most problematic are parameters that only have partial
overlap with the ROPE region. In case of collinearity, the (joint) distributions
of these parameters may either get an increased or decreased ROPE, which
means that inferences based on <code>rope()</code> are inappropriate
(<em>Kruschke 2014, 340f</em>).
</p>
<p><code>rope()</code> performs a simple check for pairwise correlations between
parameters, but as there can be collinearity between more than two variables,
a first step to check the assumptions of this hypothesis testing is to look
at different pair plots. An even more sophisticated check is the projection
predictive variable selection (<em>Piironen and Vehtari 2017</em>).
</p>


<h3>Strengths and Limitations</h3>

<p><strong>Strengths:</strong> Provides information related to the practical relevance of
the effects.
</p>
<p><strong>Limitations:</strong> A ROPE range needs to be arbitrarily defined. Sensitive to
the scale (the unit) of the predictors. Not sensitive to highly significant
effects.
</p>


<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>References</h3>


<ul>
<li><p> Cohen, J. (1988). Statistical power analysis for the behavioural sciences.
</p>
</li>
<li><p> Kruschke, J. K. (2010). What to believe: Bayesian methods for data analysis.
Trends in cognitive sciences, 14(7), 293-300. <a href="https://doi.org/10.1016/j.tics.2010.05.001">doi:10.1016/j.tics.2010.05.001</a>.
</p>
</li>
<li><p> Kruschke, J. K. (2011). Bayesian assessment of null values via parameter
estimation and model comparison. Perspectives on Psychological Science,
6(3), 299-312. <a href="https://doi.org/10.1177/1745691611406925">doi:10.1177/1745691611406925</a>.
</p>
</li>
<li><p> Kruschke, J. K. (2014). Doing Bayesian data analysis: A tutorial with R,
JAGS, and Stan. Academic Press. <a href="https://doi.org/10.1177/2515245918771304">doi:10.1177/2515245918771304</a>.
</p>
</li>
<li><p> Kruschke, J. K. (2018). Rejecting or accepting parameter values in Bayesian
estimation. Advances in Methods and Practices in Psychological Science,
1(2), 270-280. <a href="https://doi.org/10.1177/2515245918771304">doi:10.1177/2515245918771304</a>.
</p>
</li>
<li><p> Makowski D, Ben-Shachar MS, Chen SHA, Lüdecke D (2019) Indices of Effect
Existence and Significance in the Bayesian Framework. Frontiers in
Psychology 2019;10:2767. <a href="https://doi.org/10.3389/fpsyg.2019.02767">doi:10.3389/fpsyg.2019.02767</a>
</p>
</li>
<li><p> Piironen, J., &amp; Vehtari, A. (2017). Comparison of Bayesian predictive
methods for model selection. Statistics and Computing, 27(3), 711–735.
<a href="https://doi.org/10.1007/s11222-016-9649-y">doi:10.1007/s11222-016-9649-y</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

rope(x = rnorm(1000, 0, 0.01), range = c(-0.1, 0.1))
rope(x = rnorm(1000, 0, 1), range = c(-0.1, 0.1))
rope(x = rnorm(1000, 1, 0.01), range = c(-0.1, 0.1))
rope(x = rnorm(1000, 1, 1), ci = c(0.90, 0.95))

library(rstanarm)
model &lt;- suppressWarnings(
  stan_glm(mpg ~ wt + gear, data = mtcars, chains = 2, iter = 200, refresh = 0)
)
rope(model)
rope(model, ci = c(0.90, 0.95))

library(emmeans)
rope(emtrends(model, ~1, "wt"), ci = c(0.90, 0.95))

library(brms)
model &lt;- brm(mpg ~ wt + cyl, data = mtcars)
rope(model)
rope(model, ci = c(0.90, 0.95))

library(brms)
model &lt;- brm(
  bf(mvbind(mpg, disp) ~ wt + cyl) + set_rescor(rescor = TRUE),
  data = mtcars
)
rope(model)
rope(model, ci = c(0.90, 0.95))

library(BayesFactor)
bf &lt;- ttestBF(x = rnorm(100, 1, 1))
rope(bf)
rope(bf, ci = c(0.90, 0.95))


</code></pre>

<hr>
<h2 id='rope_range'>Find Default Equivalence (ROPE) Region Bounds</h2><span id='topic+rope_range'></span><span id='topic+rope_range.default'></span>

<h3>Description</h3>

<p>This function attempts at automatically finding suitable &quot;default&quot;
values for the Region Of Practical Equivalence (ROPE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rope_range(x, ...)

## Default S3 method:
rope_range(x, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rope_range_+3A_x">x</code></td>
<td>
<p>A <code>stanreg</code>, <code>brmsfit</code> or <code>BFBayesFactor</code> object.</p>
</td></tr>
<tr><td><code id="rope_range_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="rope_range_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Kruschke (2018)</em> suggests that the region of practical equivalence
could be set, by default, to a range from <code>-0.1</code> to <code>0.1</code> of a standardized
parameter (negligible effect size according to <em>Cohen, 1988</em>).
</p>

<ul>
<li><p> For <strong>linear models (lm)</strong>, this can be generalised to
-0.1 * SD<sub>y</sub>, 0.1 * SD<sub>y</sub>.
</p>
</li>
<li><p> For <strong>logistic models</strong>, the parameters expressed in log odds ratio can be
converted to standardized difference through the formula
&pi;/&radic;(3), resulting in a
range of <code>-0.18</code> to <code>0.18</code>.
</p>
</li>
<li><p> For other models with <strong>binary outcome</strong>, it is strongly recommended to
manually specify the rope argument. Currently, the same default is applied
that for logistic models.
</p>
</li>
<li><p> For models from <strong>count data</strong>, the residual variance is used. This is a
rather experimental threshold and is probably often similar to <code style="white-space: pre;">&#8288;-0.1, 0.1&#8288;</code>,
but should be used with care!
</p>
</li>
<li><p> For <strong>t-tests</strong>, the standard deviation of the response is used, similarly
to linear models (see above).
</p>
</li>
<li><p> For <strong>correlations</strong>, <code style="white-space: pre;">&#8288;-0.05, 0.05&#8288;</code> is used, i.e., half the value of a
negligible correlation as suggested by Cohen's (1988) rules of thumb.
</p>
</li>
<li><p> For all other models, <code style="white-space: pre;">&#8288;-0.1, 0.1&#8288;</code> is used to determine the ROPE limits,
but it is strongly advised to specify it manually.
</p>
</li></ul>



<h3>References</h3>

<p>Kruschke, J. K. (2018). Rejecting or accepting parameter values
in Bayesian estimation. Advances in Methods and Practices in Psychological
Science, 1(2), 270-280. <a href="https://doi.org/10.1177/2515245918771304">doi:10.1177/2515245918771304</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

model &lt;- suppressWarnings(rstanarm::stan_glm(
  mpg ~ wt + gear,
  data = mtcars,
  chains = 2,
  iter = 200,
  refresh = 0
))
rope_range(model)

model &lt;- suppressWarnings(
  rstanarm::stan_glm(vs ~ mpg, data = mtcars, family = "binomial", refresh = 0)
)
rope_range(model)

model &lt;- brms::brm(mpg ~ wt + cyl, data = mtcars)
rope_range(model)

model &lt;- BayesFactor::ttestBF(mtcars[mtcars$vs == 1, "mpg"], mtcars[mtcars$vs == 0, "mpg"])
rope_range(model)

model &lt;- lmBF(mpg ~ vs, data = mtcars)
rope_range(model)


</code></pre>

<hr>
<h2 id='sensitivity_to_prior'>Sensitivity to Prior</h2><span id='topic+sensitivity_to_prior'></span><span id='topic+sensitivity_to_prior.stanreg'></span>

<h3>Description</h3>

<p>Computes the sensitivity to priors specification. This represents the
proportion of change in some indices when the model is fitted with an
antagonistic prior (a prior of same shape located on the opposite of the
effect).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity_to_prior(model, ...)

## S3 method for class 'stanreg'
sensitivity_to_prior(model, index = "Median", magnitude = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity_to_prior_+3A_model">model</code></td>
<td>
<p>A Bayesian model (<code>stanreg</code> or <code>brmsfit</code>).</p>
</td></tr>
<tr><td><code id="sensitivity_to_prior_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="sensitivity_to_prior_+3A_index">index</code></td>
<td>
<p>The indices from which to compute the sensitivity. Can be one or
multiple names of the columns returned by <code>describe_posterior</code>. The case is
important here (e.g., write 'Median' instead of 'median').</p>
</td></tr>
<tr><td><code id="sensitivity_to_prior_+3A_magnitude">magnitude</code></td>
<td>
<p>This represent the magnitude by which to shift the
antagonistic prior (to test the sensitivity). For instance, a magnitude of
10 (default) means that the mode wil be updated with a prior located at 10
standard deviations from its original location.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>DescTools
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(bayestestR)

# rstanarm models
# -----------------------------------------------
model &lt;- rstanarm::stan_glm(mpg ~ wt, data = mtcars)
sensitivity_to_prior(model)

model &lt;- rstanarm::stan_glm(mpg ~ wt + cyl, data = mtcars)
sensitivity_to_prior(model, index = c("Median", "MAP"))


</code></pre>

<hr>
<h2 id='sexit'>Sequential Effect eXistence and sIgnificance Testing (SEXIT)</h2><span id='topic+sexit'></span>

<h3>Description</h3>

<p>The SEXIT is a new framework to describe Bayesian effects, guiding which
indices to use. Accordingly, the <code>sexit()</code> function returns the minimal (and
optimal) required information to describe models' parameters under a Bayesian
framework. It includes the following indices:
</p>

<ul>
<li><p>Centrality: the median of the posterior distribution. In
probabilistic terms, there is <code style="white-space: pre;">&#8288;50%&#8288;</code> of probability that the effect is higher
and lower. See <code><a href="#topic+point_estimate">point_estimate()</a></code>.
</p>
</li>
<li><p>Uncertainty: the <code style="white-space: pre;">&#8288;95%&#8288;</code> Highest Density Interval (HDI). In
probabilistic terms, there is <code style="white-space: pre;">&#8288;95%&#8288;</code> of probability that the effect is
within this confidence interval. See <code><a href="#topic+ci">ci()</a></code>.
</p>
</li>
<li><p>Existence: The probability of direction allows to quantify the
certainty by which an effect is positive or negative. It is a critical
index to show that an effect of some manipulation is not harmful (for
instance in clinical studies) or to assess the direction of a link. See
<code><a href="#topic+p_direction">p_direction()</a></code>.
</p>
</li>
<li><p>Significance: Once existence is demonstrated with high certainty, we
can assess whether the effect is of sufficient size to be considered as
significant (i.e., not negligible). This is a useful index to determine
which effects are actually important and worthy of discussion in a given
process. See <code><a href="#topic+p_significance">p_significance()</a></code>.
</p>
</li>
<li><p>Size: Finally, this index gives an idea about the strength of an
effect. However, beware, as studies have shown that a big effect size can
be also suggestive of low statistical power (see details section).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sexit(x, significant = "default", large = "default", ci = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sexit_+3A_x">x</code></td>
<td>
<p>A vector representing a posterior distribution, a data frame of
posterior draws (samples be parameter). Can also be a Bayesian model.</p>
</td></tr>
<tr><td><code id="sexit_+3A_significant">significant</code>, <code id="sexit_+3A_large">large</code></td>
<td>
<p>The threshold values to use for significant and
large probabilities. If left to 'default', will be selected through
<code><a href="#topic+sexit_thresholds">sexit_thresholds()</a></code>. See the details section below.</p>
</td></tr>
<tr><td><code id="sexit_+3A_ci">ci</code></td>
<td>
<p>Value or vector of probability of the (credible) interval - CI
(between 0 and 1) to be estimated. Default to <code>.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="sexit_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Rationale</h4>

<p>The assessment of &quot;significance&quot; (in its broadest meaning) is a pervasive
issue in science, and its historical index, the p-value, has been strongly
criticized and deemed to have played an important role in the replicability
crisis. In reaction, more and more scientists have tuned to Bayesian methods,
offering an alternative set of tools to answer their questions. However, the
Bayesian framework offers a wide variety of possible indices related to
&quot;significance&quot;, and the debate has been raging about which index is the best,
and which one to report.
</p>
<p>This situation can lead to the mindless reporting of all possible indices
(with the hopes that with that the reader will be satisfied), but often
without having the writer understanding and interpreting them. It is indeed
complicated to juggle between many indices with complicated definitions and
subtle differences.
</p>
<p>SEXIT aims at offering a practical framework for Bayesian effects reporting,
in which the focus is put on intuitiveness, explicitness and usefulness of
the indices' interpretation. To that end, we suggest a system of description
of parameters that would be intuitive, easy to learn and apply,
mathematically accurate and useful for taking decision.
</p>
<p>Once the thresholds for significance (i.e., the ROPE) and the one for a
&quot;large&quot; effect are explicitly defined, the SEXIT framework does not make any
interpretation, i.e., it does not label the effects, but just sequentially
gives 3 probabilities (of direction, of significance and of being large,
respectively) as-is on top of the characteristics of the posterior (using the
median and HDI for centrality and uncertainty description). Thus, it provides
a lot of information about the posterior distribution (through the mass of
different 'sections' of the posterior) in a clear and meaningful way.
</p>



<h4>Threshold selection</h4>

<p>One of the most important thing about the SEXIT framework is that it relies
on two &quot;arbitrary&quot; thresholds (i.e., that have no absolute meaning). They
are the ones related to effect size (an inherently subjective notion),
namely the thresholds for significant and large effects. They are set, by
default, to <code>0.05</code> and <code>0.3</code> of the standard deviation of the outcome
variable (tiny and large effect sizes for correlations according to Funder
and Ozer, 2019). However, these defaults were chosen by lack of a better
option, and might not be adapted to your case. Thus, they are to be handled
with care, and the chosen thresholds should always be explicitly reported
and justified.
</p>

<ul>
<li><p> For <strong>linear models (lm)</strong>, this can be generalised to 0.05 * SD<sub>y</sub> and 0.3 * SD<sub>y</sub> for significant and large effects, respectively.
</p>
</li>
<li><p> For <strong>logistic models</strong>, the parameters expressed in log odds ratio can be converted to standardized difference through the formula &pi;/&radic;(3), resulting a threshold of <code>0.09</code> and <code>0.54</code>.
</p>
</li>
<li><p> For other models with <strong>binary outcome</strong>, it is strongly recommended to manually specify the rope argument. Currently, the same default is applied that for logistic models.
</p>
</li>
<li><p> For models from <strong>count data</strong>, the residual variance is used. This is a rather experimental threshold and is probably often similar to <code>0.05</code> and <code>0.3</code>, but should be used with care!
</p>
</li>
<li><p> For <strong>t-tests</strong>, the standard deviation of the response is used, similarly to linear models (see above).
</p>
</li>
<li><p> For <strong>correlations</strong>,<code>0.05</code> and <code>0.3</code> are used.
</p>
</li>
<li><p> For all other models, <code>0.05</code> and <code>0.3</code> are used, but it is strongly advised to specify it manually.
</p>
</li></ul>




<h4>Examples</h4>

<p>The three values for existence, significance and size provide a useful description of the posterior distribution of the effects. Some possible scenarios include:
</p>

<ul>
<li><p>The probability of existence is low, but the probability of being large is high: it suggests that the posterior is very wide (covering large territories on both side of 0). The statistical power might be too low, which should warrant any confident conclusion.
</p>
</li>
<li><p>The probability of existence and significance is high, but the probability of being large is very small: it suggests that the effect is, with high confidence, not large (the posterior is mostly contained between the significance and the large thresholds).
</p>
</li>
<li><p>The 3 indices are very low: this suggests that the effect is null with high confidence (the posterior is closely centred around 0).</p>
</li></ul>



<h3>Value</h3>

<p>A dataframe and text as attribute.
</p>


<h3>References</h3>


<ul>
<li><p>Makowski, D., Ben-Shachar, M. S., &amp; Lüdecke, D. (2019). bayestestR: Describing Effects and their Uncertainty, Existence and Significance within the Bayesian Framework. Journal of Open Source Software, 4(40), 1541. <a href="https://doi.org/10.21105/joss.01541">doi:10.21105/joss.01541</a>
</p>
</li>
<li><p>Makowski D, Ben-Shachar MS, Chen SHA, Lüdecke D (2019) Indices of Effect Existence and Significance in the Bayesian Framework. Frontiers in Psychology 2019;10:2767. <a href="https://doi.org/10.3389/fpsyg.2019.02767">doi:10.3389/fpsyg.2019.02767</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

s &lt;- sexit(rnorm(1000, -1, 1))
s
print(s, summary = TRUE)

s &lt;- sexit(iris)
s
print(s, summary = TRUE)

if (require("rstanarm")) {
  model &lt;- suppressWarnings(rstanarm::stan_glm(mpg ~ wt * cyl,
    data = mtcars,
    iter = 400, refresh = 0
  ))
  s &lt;- sexit(model)
  s
  print(s, summary = TRUE)
}

</code></pre>

<hr>
<h2 id='sexit_thresholds'>Find Effect Size Thresholds</h2><span id='topic+sexit_thresholds'></span>

<h3>Description</h3>

<p>This function attempts at automatically finding suitable default
values for a &quot;significant&quot; (i.e., non-negligible) and &quot;large&quot; effect. This is
to be used with care, and the chosen threshold should always be explicitly
reported and justified. See the detail section in <code><a href="#topic+sexit">sexit()</a></code> for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sexit_thresholds(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sexit_thresholds_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution. Can also be a
<code>stanreg</code> or <code>brmsfit</code> model.</p>
</td></tr>
<tr><td><code id="sexit_thresholds_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kruschke, J. K. (2018). Rejecting or accepting parameter values in Bayesian estimation. Advances in Methods and Practices in Psychological Science, 1(2), 270-280. <a href="https://doi.org/10.1177/2515245918771304">doi:10.1177/2515245918771304</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sexit_thresholds(rnorm(1000))

if (require("rstanarm")) {
  model &lt;- suppressWarnings(stan_glm(
    mpg ~ wt + gear,
    data = mtcars,
    chains = 2,
    iter = 200,
    refresh = 0
  ))
  sexit_thresholds(model)

  model &lt;- suppressWarnings(
    stan_glm(vs ~ mpg, data = mtcars, family = "binomial", refresh = 0)
  )
  sexit_thresholds(model)
}

if (require("brms")) {
  model &lt;- brm(mpg ~ wt + cyl, data = mtcars)
  sexit_thresholds(model)
}

if (require("BayesFactor")) {
  bf &lt;- ttestBF(x = rnorm(100, 1, 1))
  sexit_thresholds(bf)
}

</code></pre>

<hr>
<h2 id='si'>Compute Support Intervals</h2><span id='topic+si'></span><span id='topic+si.numeric'></span><span id='topic+si.stanreg'></span><span id='topic+si.brmsfit'></span><span id='topic+si.blavaan'></span><span id='topic+si.emmGrid'></span><span id='topic+si.get_predicted'></span><span id='topic+si.data.frame'></span>

<h3>Description</h3>

<p>A support interval contains only the values of the parameter that predict the observed data better
than average, by some degree <em>k</em>; these are values of the parameter that are associated with an
updating factor greater or equal than <em>k</em>. From the perspective of the Savage-Dickey Bayes factor, testing
against a point null hypothesis for any value within the support interval will yield a Bayes factor smaller
than <em>1/k</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>si(posterior, ...)

## S3 method for class 'numeric'
si(posterior, prior = NULL, BF = 1, verbose = TRUE, ...)

## S3 method for class 'stanreg'
si(
  posterior,
  prior = NULL,
  BF = 1,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("location", "conditional", "all", "smooth_terms", "sigma", "auxiliary",
    "distributional"),
  parameters = NULL,
  ...
)

## S3 method for class 'brmsfit'
si(
  posterior,
  prior = NULL,
  BF = 1,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("location", "conditional", "all", "smooth_terms", "sigma", "auxiliary",
    "distributional"),
  parameters = NULL,
  ...
)

## S3 method for class 'blavaan'
si(
  posterior,
  prior = NULL,
  BF = 1,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("location", "conditional", "all", "smooth_terms", "sigma", "auxiliary",
    "distributional"),
  parameters = NULL,
  ...
)

## S3 method for class 'emmGrid'
si(posterior, prior = NULL, BF = 1, verbose = TRUE, ...)

## S3 method for class 'get_predicted'
si(
  posterior,
  prior = NULL,
  BF = 1,
  use_iterations = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'data.frame'
si(posterior, prior = NULL, BF = 1, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="si_+3A_posterior">posterior</code></td>
<td>
<p>A numerical vector, <code>stanreg</code> / <code>brmsfit</code> object,
<code>emmGrid</code> or a data frame - representing a posterior distribution(s)
from (see 'Details').</p>
</td></tr>
<tr><td><code id="si_+3A_...">...</code></td>
<td>
<p>Arguments passed to and from other methods. (Can be used to pass
arguments to internal <code><a href="logspline.html#topic+logspline">logspline::logspline()</a></code>.)</p>
</td></tr>
<tr><td><code id="si_+3A_prior">prior</code></td>
<td>
<p>An object representing a prior distribution (see 'Details').</p>
</td></tr>
<tr><td><code id="si_+3A_bf">BF</code></td>
<td>
<p>The amount of support required to be included in the support interval.</p>
</td></tr>
<tr><td><code id="si_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="si_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="si_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="si_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="si_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>For more info, in particular on specifying correct priors for factors with more than 2 levels,
see <a href="https://easystats.github.io/bayestestR/articles/bayes_factors.html">the Bayes factors vignette</a>.</strong>
</p>
<p>This method is used to compute support intervals based on prior and posterior distributions.
For the computation of support intervals, the model priors must be proper priors (at the very least
they should be <em>not flat</em>, and it is preferable that they be <em>informative</em> - note
that by default, <code>brms::brm()</code> uses flat priors for fixed-effects; see example below).
</p>


<h3>Value</h3>

<p>A data frame containing the lower and upper bounds of the SI.
</p>
<p>Note that if the level of requested support is higher than observed in the data, the
interval will be <code style="white-space: pre;">&#8288;[NA,NA]&#8288;</code>.
</p>


<h3>Choosing a value of <code>BF</code></h3>

<p>The choice of <code>BF</code> (the level of support) depends on what we want our interval
to represent:
</p>

<ul>
<li><p> A <code>BF</code> = 1 contains values whose credibility is not decreased by observing the data.
</p>
</li>
<li><p> A <code>BF</code> &gt; 1 contains values who received more impressive support from the data.
</p>
</li>
<li><p> A <code>BF</code> &lt; 1 contains values whose credibility has <em>not</em> been impressively
decreased by observing the data. Testing against values outside this interval
will produce a Bayes factor larger than 1/<code>BF</code> in support of the alternative.
E.g., if an SI (BF = 1/3) excludes 0, the Bayes factor against the point-null
will be larger than 3.
</p>
</li></ul>



<h3>Setting the correct <code>prior</code></h3>

<p>For the computation of Bayes factors, the model priors must be proper priors
(at the very least they should be <em>not flat</em>, and it is preferable that
they be <em>informative</em>); As the priors for the alternative get wider, the
likelihood of the null value(s) increases, to the extreme that for completely
flat priors the null is infinitely more favorable than the alternative (this
is called <em>the Jeffreys-Lindley-Bartlett paradox</em>). Thus, you should
only ever try (or want) to compute a Bayes factor when you have an informed
prior.
<br /><br />
(Note that by default, <code>brms::brm()</code> uses flat priors for fixed-effects;
See example below.)
<br /><br />
It is important to provide the correct <code>prior</code> for meaningful results.
</p>

<ul>
<li><p> When <code>posterior</code> is a numerical vector, <code>prior</code> should also be a numerical vector.
</p>
</li>
<li><p> When <code>posterior</code> is a <code>data.frame</code>, <code>prior</code> should also be a <code>data.frame</code>, with matching column order.
</p>
</li>
<li><p> When <code>posterior</code> is a <code>stanreg</code>, <code>brmsfit</code> or other supported Bayesian model: </p>

<ul>
<li> <p><code>prior</code> can be set to <code>NULL</code>, in which case prior samples are drawn internally.
</p>
</li>
<li> <p><code>prior</code> can also be a model equivalent to <code>posterior</code> but with samples from
the priors <em>only</em>. See <code><a href="#topic+unupdate">unupdate()</a></code>.
</p>
</li>
<li> <p><strong>Note:</strong> When <code>posterior</code> is a <code>brmsfit_multiple</code> model, <code>prior</code> <strong>must</strong> be provided.
</p>
</li></ul>

</li>
<li><p> When <code>posterior</code> is an <code>emmGrid</code> / <code>emm_list</code> object: </p>

<ul>
<li> <p><code>prior</code> should also be an <code>emmGrid</code> / <code>emm_list</code> object equivalent to <code>posterior</code> but
created with a model of priors samples <em>only</em>. See <code><a href="#topic+unupdate">unupdate()</a></code>.
</p>
</li>
<li> <p><code>prior</code> can also be the original (posterior) <em>model</em>. If so, the function will try to
update the <code>emmGrid</code> / <code>emm_list</code> to use the <code><a href="#topic+unupdate">unupdate()</a></code>d prior-model.
(<em>This cannot be done for <code>brmsfit</code> models.</em>)
</p>
</li>
<li> <p><strong>Note</strong>: When the <code>emmGrid</code> has undergone any transformations (<code>"log"</code>, <code>"response"</code>, etc.),
or <code>regrid</code>ing, then <code>prior</code> must be an <code>emmGrid</code> object, as stated above.
</p>
</li></ul>

</li></ul>



<h3>Note</h3>

<p>There is also a <a href="https://easystats.github.io/see/articles/bayestestR.html"><code>plot()</code>-method</a> implemented in the <a href="https://easystats.github.io/see/"><span class="pkg">see</span>-package</a>.
</p>


<h3>References</h3>

<p>Wagenmakers, E., Gronau, Q. F., Dablander, F., &amp; Etz, A. (2018, November 22).
The Support Interval. <a href="https://doi.org/10.31234/osf.io/zwnxb">doi:10.31234/osf.io/zwnxb</a>
</p>


<h3>See Also</h3>

<p>Other ci: 
<code><a href="#topic+bci">bci</a>()</code>,
<code><a href="#topic+ci">ci</a>()</code>,
<code><a href="#topic+cwi">cwi</a>()</code>,
<code><a href="#topic+eti">eti</a>()</code>,
<code><a href="#topic+hdi">hdi</a>()</code>,
<code><a href="#topic+spi">spi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

prior &lt;- distribution_normal(1000, mean = 0, sd = 1)
posterior &lt;- distribution_normal(1000, mean = 0.5, sd = 0.3)

si(posterior, prior, verbose = FALSE)

# rstanarm models
# ---------------
library(rstanarm)
contrasts(sleep$group) &lt;- contr.equalprior_pairs # see vignette
stan_model &lt;- stan_lmer(extra ~ group + (1 | ID), data = sleep)
si(stan_model, verbose = FALSE)
si(stan_model, BF = 3, verbose = FALSE)

# emmGrid objects
# ---------------
library(emmeans)
group_diff &lt;- pairs(emmeans(stan_model, ~group))
si(group_diff, prior = stan_model, verbose = FALSE)

# brms models
# -----------
library(brms)
contrasts(sleep$group) &lt;- contr.equalprior_pairs # see vingette
my_custom_priors &lt;-
  set_prior("student_t(3, 0, 1)", class = "b") +
  set_prior("student_t(3, 0, 1)", class = "sd", group = "ID")

brms_model &lt;- suppressWarnings(brm(extra ~ group + (1 | ID),
  data = sleep,
  prior = my_custom_priors,
  refresh = 0
))
si(brms_model, verbose = FALSE)


</code></pre>

<hr>
<h2 id='simulate_correlation'>Data Simulation</h2><span id='topic+simulate_correlation'></span><span id='topic+simulate_ttest'></span><span id='topic+simulate_difference'></span>

<h3>Description</h3>

<p>Simulate data with specific characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_correlation(n = 100, r = 0.5, mean = 0, sd = 1, names = NULL, ...)

simulate_ttest(n = 100, d = 0.5, names = NULL, ...)

simulate_difference(n = 100, d = 0.5, names = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_correlation_+3A_n">n</code></td>
<td>
<p>The number of observations to be generated.</p>
</td></tr>
<tr><td><code id="simulate_correlation_+3A_r">r</code></td>
<td>
<p>A value or vector corresponding to the desired correlation
coefficients.</p>
</td></tr>
<tr><td><code id="simulate_correlation_+3A_mean">mean</code></td>
<td>
<p>A value or vector corresponding to the mean of the variables.</p>
</td></tr>
<tr><td><code id="simulate_correlation_+3A_sd">sd</code></td>
<td>
<p>A value or vector corresponding to the SD of the variables.</p>
</td></tr>
<tr><td><code id="simulate_correlation_+3A_names">names</code></td>
<td>
<p>A character vector of desired variable names.</p>
</td></tr>
<tr><td><code id="simulate_correlation_+3A_...">...</code></td>
<td>
<p>Arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="simulate_correlation_+3A_d">d</code></td>
<td>
<p>A value or vector corresponding to the desired difference between
the groups.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Correlation --------------------------------
data &lt;- simulate_correlation(r = 0.5)
plot(data$V1, data$V2)
cor.test(data$V1, data$V2)
summary(lm(V2 ~ V1, data = data))

# Specify mean and SD
data &lt;- simulate_correlation(r = 0.5, n = 50, mean = c(0, 1), sd = c(0.7, 1.7))
cor.test(data$V1, data$V2)
round(c(mean(data$V1), sd(data$V1)), 1)
round(c(mean(data$V2), sd(data$V2)), 1)
summary(lm(V2 ~ V1, data = data))

# Generate multiple variables
cor_matrix &lt;- matrix(
  c(
    1.0, 0.2, 0.4,
    0.2, 1.0, 0.3,
    0.4, 0.3, 1.0
  ),
  nrow = 3
)

data &lt;- simulate_correlation(r = cor_matrix, names = c("y", "x1", "x2"))
cor(data)
summary(lm(y ~ x1, data = data))

# t-test --------------------------------
data &lt;- simulate_ttest(n = 30, d = 0.3)
plot(data$V1, data$V0)
round(c(mean(data$V1), sd(data$V1)), 1)
diff(t.test(data$V1 ~ data$V0)$estimate)
summary(lm(V1 ~ V0, data = data))
summary(glm(V0 ~ V1, data = data, family = "binomial"))

# Difference --------------------------------
data &lt;- simulate_difference(n = 30, d = 0.3)
plot(data$V1, data$V0)
round(c(mean(data$V1), sd(data$V1)), 1)
diff(t.test(data$V1 ~ data$V0)$estimate)
summary(lm(V1 ~ V0, data = data))
summary(glm(V0 ~ V1, data = data, family = "binomial"))
</code></pre>

<hr>
<h2 id='simulate_prior'>Returns Priors of a Model as Empirical Distributions</h2><span id='topic+simulate_prior'></span>

<h3>Description</h3>

<p>Transforms priors information to actual distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_prior(model, n = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_prior_+3A_model">model</code></td>
<td>
<p>A <code>stanreg</code>, <code>stanfit</code>, <code>brmsfit</code>, <code>blavaan</code>, or <code>MCMCglmm</code> object.</p>
</td></tr>
<tr><td><code id="simulate_prior_+3A_n">n</code></td>
<td>
<p>Size of the simulated prior distributions.</p>
</td></tr>
<tr><td><code id="simulate_prior_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+unupdate">unupdate()</a></code> for directly sampling from the prior
distribution (useful for complex priors and designs).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)
if (require("rstanarm")) {
  model &lt;- suppressWarnings(
    stan_glm(mpg ~ wt + am, data = mtcars, chains = 1, refresh = 0)
  )
  simulate_prior(model)
}

</code></pre>

<hr>
<h2 id='simulate_simpson'>Simpson's paradox dataset simulation</h2><span id='topic+simulate_simpson'></span>

<h3>Description</h3>

<p>Simpson's paradox, or the Yule-Simpson effect, is a phenomenon in probability
and statistics, in which a trend appears in several different groups of data
but disappears or reverses when these groups are combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_simpson(
  n = 100,
  r = 0.5,
  groups = 3,
  difference = 1,
  group_prefix = "G_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_simpson_+3A_n">n</code></td>
<td>
<p>The number of observations for each group to be generated (minimum 4).</p>
</td></tr>
<tr><td><code id="simulate_simpson_+3A_r">r</code></td>
<td>
<p>A value or vector corresponding to the desired correlation
coefficients.</p>
</td></tr>
<tr><td><code id="simulate_simpson_+3A_groups">groups</code></td>
<td>
<p>Number of groups (groups can be participants, clusters, anything).</p>
</td></tr>
<tr><td><code id="simulate_simpson_+3A_difference">difference</code></td>
<td>
<p>Difference between groups.</p>
</td></tr>
<tr><td><code id="simulate_simpson_+3A_group_prefix">group_prefix</code></td>
<td>
<p>The prefix of the group name (e.g., &quot;G_1&quot;, &quot;G_2&quot;, &quot;G_3&quot;, ...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- simulate_simpson(n = 10, groups = 5, r = 0.5)

if (require("ggplot2")) {
  ggplot(data, aes(x = V1, y = V2)) +
    geom_point(aes(color = Group)) +
    geom_smooth(aes(color = Group), method = "lm") +
    geom_smooth(method = "lm")
}
</code></pre>

<hr>
<h2 id='spi'>Shortest Probability Interval (SPI)</h2><span id='topic+spi'></span><span id='topic+spi.numeric'></span><span id='topic+spi.stanreg'></span><span id='topic+spi.brmsfit'></span><span id='topic+spi.get_predicted'></span>

<h3>Description</h3>

<p>Compute the <strong>Shortest Probability Interval (SPI)</strong> of posterior distributions.
The SPI is a more computationally stable HDI. The implementation is based on
the algorithm from the <strong>SPIn</strong> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spi(x, ...)

## S3 method for class 'numeric'
spi(x, ci = 0.95, verbose = TRUE, ...)

## S3 method for class 'stanreg'
spi(
  x,
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("location", "all", "conditional", "smooth_terms", "sigma",
    "distributional", "auxiliary"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'brmsfit'
spi(
  x,
  ci = 0.95,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'get_predicted'
spi(x, ci = 0.95, use_iterations = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spi_+3A_x">x</code></td>
<td>
<p>Vector representing a posterior distribution, or a data frame of such
vectors. Can also be a Bayesian model. <strong>bayestestR</strong> supports a wide range
of models (see, for example, <code>methods("hdi")</code>) and not all of those are
documented in the 'Usage' section, because methods for other classes mostly
resemble the arguments of the <code>.numeric</code> or <code>.data.frame</code>methods.</p>
</td></tr>
<tr><td><code id="spi_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
<tr><td><code id="spi_+3A_ci">ci</code></td>
<td>
<p>Value or vector of probability of the (credible) interval - CI
(between 0 and 1) to be estimated. Default to <code>.95</code> (<code style="white-space: pre;">&#8288;95%&#8288;</code>).</p>
</td></tr>
<tr><td><code id="spi_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="spi_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="spi_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="spi_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="spi_+3A_use_iterations">use_iterations</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>x</code> is a <code>get_predicted</code> object,
(returned by <code><a href="insight.html#topic+get_predicted">insight::get_predicted()</a></code>), the function is applied to the
iterations instead of the predictions. This only applies to models that return
iterations for predicted values (e.g., <code>brmsfit</code> models).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SPI is an alternative method to the HDI (<code><a href="#topic+hdi">hdi()</a></code>) to quantify
uncertainty of (posterior) distributions. The SPI is said to be more stable
than the HDI, because, the <em>&quot;HDI can be noisy (that is, have a high Monte Carlo error)&quot;</em>
(Liu et al. 2015). Furthermore, the HDI is sensitive to additional assumptions,
in particular assumptions related to the different estimation methods, which
can make the HDI less accurate or reliable.
</p>


<h3>Value</h3>

<p>A data frame with following columns:
</p>

<ul>
<li> <p><code>Parameter</code> The model parameter(s), if <code>x</code> is a model-object. If <code>x</code> is a
vector, this column is missing.
</p>
</li>
<li> <p><code>CI</code> The probability of the credible interval.
</p>
</li>
<li> <p><code>CI_low</code>, <code>CI_high</code> The lower and upper credible interval limits for the parameters.
</p>
</li></ul>



<h3>Note</h3>

<p>The code to compute the SPI was adapted from the <strong>SPIn</strong> package,
and slightly modified to be more robust for Stan models. Thus, credits go
to Ying Liu for the original SPI algorithm and R implementation.
</p>


<h3>References</h3>

<p>Liu, Y., Gelman, A., &amp; Zheng, T. (2015). Simulation-efficient shortest probability intervals. Statistics and Computing, 25(4), 809–819. https://doi.org/10.1007/s11222-015-9563-8
</p>


<h3>See Also</h3>

<p>Other ci: 
<code><a href="#topic+bci">bci</a>()</code>,
<code><a href="#topic+ci">ci</a>()</code>,
<code><a href="#topic+cwi">cwi</a>()</code>,
<code><a href="#topic+eti">eti</a>()</code>,
<code><a href="#topic+hdi">hdi</a>()</code>,
<code><a href="#topic+si">si</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(bayestestR)

posterior &lt;- rnorm(1000)
spi(posterior)
spi(posterior, ci = c(0.80, 0.89, 0.95))

df &lt;- data.frame(replicate(4, rnorm(100)))
spi(df)
spi(df, ci = c(0.80, 0.89, 0.95))

library(rstanarm)
model &lt;- suppressWarnings(
  stan_glm(mpg ~ wt + gear, data = mtcars, chains = 2, iter = 200, refresh = 0)
)
spi(model)


</code></pre>

<hr>
<h2 id='unupdate'>Un-update Bayesian models to their prior-to-data state</h2><span id='topic+unupdate'></span><span id='topic+unupdate.stanreg'></span><span id='topic+unupdate.brmsfit'></span><span id='topic+unupdate.brmsfit_multiple'></span><span id='topic+unupdate.blavaan'></span>

<h3>Description</h3>

<p>As posteriors are priors that have been updated after observing some data,
the goal of this function is to un-update the posteriors to obtain models
representing the priors. These models can then be used to examine the prior
predictive distribution, or to compare priors with posteriors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unupdate(model, verbose = TRUE, ...)

## S3 method for class 'stanreg'
unupdate(model, verbose = TRUE, ...)

## S3 method for class 'brmsfit'
unupdate(model, verbose = TRUE, ...)

## S3 method for class 'brmsfit_multiple'
unupdate(model, verbose = TRUE, newdata = NULL, ...)

## S3 method for class 'blavaan'
unupdate(model, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unupdate_+3A_model">model</code></td>
<td>
<p>A fitted Bayesian model.</p>
</td></tr>
<tr><td><code id="unupdate_+3A_verbose">verbose</code></td>
<td>
<p>Toggle warnings.</p>
</td></tr>
<tr><td><code id="unupdate_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="unupdate_+3A_newdata">newdata</code></td>
<td>
<p>List of <code>data.frames</code> to update the model with new data.
Required even if the original data should be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function in used internally to compute Bayes factors.
</p>


<h3>Value</h3>

<p>A model un-fitted to the data, representing the prior model.
</p>

<hr>
<h2 id='weighted_posteriors'>Generate posterior distributions weighted across models</h2><span id='topic+weighted_posteriors'></span><span id='topic+weighted_posteriors.data.frame'></span><span id='topic+weighted_posteriors.stanreg'></span><span id='topic+weighted_posteriors.brmsfit'></span><span id='topic+weighted_posteriors.blavaan'></span><span id='topic+weighted_posteriors.BFBayesFactor'></span>

<h3>Description</h3>

<p>Extract posterior samples of parameters, weighted across models. Weighting is
done by comparing posterior model probabilities, via <code><a href="#topic+bayesfactor_models">bayesfactor_models()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_posteriors(..., prior_odds = NULL, missing = 0, verbose = TRUE)

## S3 method for class 'data.frame'
weighted_posteriors(..., prior_odds = NULL, missing = 0, verbose = TRUE)

## S3 method for class 'stanreg'
weighted_posteriors(
  ...,
  prior_odds = NULL,
  missing = 0,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL
)

## S3 method for class 'brmsfit'
weighted_posteriors(
  ...,
  prior_odds = NULL,
  missing = 0,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL
)

## S3 method for class 'blavaan'
weighted_posteriors(
  ...,
  prior_odds = NULL,
  missing = 0,
  verbose = TRUE,
  effects = c("fixed", "random", "all"),
  component = c("conditional", "zi", "zero_inflated", "all"),
  parameters = NULL
)

## S3 method for class 'BFBayesFactor'
weighted_posteriors(
  ...,
  prior_odds = NULL,
  missing = 0,
  verbose = TRUE,
  iterations = 4000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_posteriors_+3A_...">...</code></td>
<td>
<p>Fitted models (see details), all fit on the same data, or a single
<code>BFBayesFactor</code> object.</p>
</td></tr>
<tr><td><code id="weighted_posteriors_+3A_prior_odds">prior_odds</code></td>
<td>
<p>Optional vector of prior odds for the models compared to
the first model (or the denominator, for <code>BFBayesFactor</code> objects). For
<code>data.frame</code>s, this will be used as the basis of weighting.</p>
</td></tr>
<tr><td><code id="weighted_posteriors_+3A_missing">missing</code></td>
<td>
<p>An optional numeric value to use if a model does not contain a
parameter that appears in other models. Defaults to 0.</p>
</td></tr>
<tr><td><code id="weighted_posteriors_+3A_verbose">verbose</code></td>
<td>
<p>Toggle off warnings.</p>
</td></tr>
<tr><td><code id="weighted_posteriors_+3A_effects">effects</code></td>
<td>
<p>Should results for fixed effects, random effects or both be
returned? Only applies to mixed models. May be abbreviated.</p>
</td></tr>
<tr><td><code id="weighted_posteriors_+3A_component">component</code></td>
<td>
<p>Should results for all parameters, parameters for the
conditional model or the zero-inflated part of the model be returned? May
be abbreviated. Only applies to <span class="pkg">brms</span>-models.</p>
</td></tr>
<tr><td><code id="weighted_posteriors_+3A_parameters">parameters</code></td>
<td>
<p>Regular expression pattern that describes the parameters
that should be returned. Meta-parameters (like <code>lp__</code> or <code>prior_</code>) are
filtered by default, so only parameters that typically appear in the
<code>summary()</code> are returned. Use <code>parameters</code> to select specific parameters
for the output.</p>
</td></tr>
<tr><td><code id="weighted_posteriors_+3A_iterations">iterations</code></td>
<td>
<p>For <code>BayesFactor</code> models, how many posterior samples to draw.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that across models some parameters might play different roles. For
example, the parameter <code>A</code> plays a different role in the model <code>Y ~ A + B</code>
(where it is a main effect) than it does in the model <code>Y ~ A + B + A:B</code>
(where it is a simple effect). In many cases centering of predictors (mean
subtracting for continuous variables, and effects coding via <code>contr.sum</code> or
orthonormal coding via <code><a href="#topic+contr.equalprior_pairs">contr.equalprior_pairs</a></code> for factors) can reduce this
issue. In any case you should be mindful of this issue.
</p>
<p>See <code><a href="#topic+bayesfactor_models">bayesfactor_models()</a></code> details for more info on passed models.
</p>
<p>Note that for <code>BayesFactor</code> models, posterior samples cannot be generated
from intercept only models.
</p>
<p>This function is similar in function to <code>brms::posterior_average</code>.
</p>


<h3>Value</h3>

<p>A data frame with posterior distributions (weighted across models) .
</p>


<h3>Note</h3>

<p>For <code style="white-space: pre;">&#8288;BayesFactor &lt; 0.9.12-4.3&#8288;</code>, in some instances there might be
some problems of duplicate columns of random effects in the resulting data
frame.
</p>


<h3>References</h3>


<ul>
<li><p> Clyde, M., Desimone, H., &amp; Parmigiani, G. (1996). Prediction via
orthogonalized model mixing. Journal of the American Statistical
Association, 91(435), 1197-1208.
</p>
</li>
<li><p> Hinne, M., Gronau, Q. F., van den Bergh, D., and Wagenmakers, E.
(2019, March 25). A conceptual introduction to Bayesian Model Averaging.
<a href="https://doi.org/10.31234/osf.io/wgb64">doi:10.31234/osf.io/wgb64</a>
</p>
</li>
<li><p> Rouder, J. N., Haaf, J. M., &amp; Vandekerckhove, J. (2018). Bayesian
inference for psychology, part IV: Parameter estimation and Bayes factors.
Psychonomic bulletin &amp; review, 25(1), 102-113.
</p>
</li>
<li><p> van den Bergh, D., Haaf, J. M., Ly, A., Rouder, J. N., &amp; Wagenmakers,
E. J. (2019). A cautionary note on estimating effect size.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bayesfactor_inclusion">bayesfactor_inclusion()</a></code> for Bayesian model averaging.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("rstanarm") &amp;&amp; require("see") &amp;&amp; interactive()) {
  stan_m0 &lt;- suppressWarnings(stan_glm(extra ~ 1,
    data = sleep,
    family = gaussian(),
    refresh = 0,
    diagnostic_file = file.path(tempdir(), "df0.csv")
  ))

  stan_m1 &lt;- suppressWarnings(stan_glm(extra ~ group,
    data = sleep,
    family = gaussian(),
    refresh = 0,
    diagnostic_file = file.path(tempdir(), "df1.csv")
  ))

  res &lt;- weighted_posteriors(stan_m0, stan_m1, verbose = FALSE)

  plot(eti(res))
}

## With BayesFactor
if (require("BayesFactor")) {
  extra_sleep &lt;- ttestBF(formula = extra ~ group, data = sleep)

  wp &lt;- weighted_posteriors(extra_sleep, verbose = FALSE)

  describe_posterior(extra_sleep, test = NULL, verbose = FALSE)
  # also considers the null
  describe_posterior(wp$delta, test = NULL, verbose = FALSE)
}


## weighted prediction distributions via data.frames
if (require("rstanarm") &amp;&amp; interactive()) {
  m0 &lt;- suppressWarnings(stan_glm(
    mpg ~ 1,
    data = mtcars,
    family = gaussian(),
    diagnostic_file = file.path(tempdir(), "df0.csv"),
    refresh = 0
  ))

  m1 &lt;- suppressWarnings(stan_glm(
    mpg ~ carb,
    data = mtcars,
    family = gaussian(),
    diagnostic_file = file.path(tempdir(), "df1.csv"),
    refresh = 0
  ))

  # Predictions:
  pred_m0 &lt;- data.frame(posterior_predict(m0))
  pred_m1 &lt;- data.frame(posterior_predict(m1))

  BFmods &lt;- bayesfactor_models(m0, m1, verbose = FALSE)

  wp &lt;- weighted_posteriors(
    pred_m0, pred_m1,
    prior_odds = as.numeric(BFmods)[2],
    verbose = FALSE
  )

  # look at first 5 prediction intervals
  hdi(pred_m0[1:5])
  hdi(pred_m1[1:5])
  hdi(wp[1:5]) # between, but closer to pred_m1
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
