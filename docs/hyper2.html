<!DOCTYPE html><html><head><title>Help for package hyper2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hyper2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hyper2-package'>
<p>The Hyperdirichlet Distribution, Mark 2</p></a></li>
<li><a href='#as.ordertable'><p>Convert an order table with DNS entries to a nice order table</p></a></li>
<li><a href='#attemptstable2supp3'><p>Translate attempt tables to hyper3 support functions</p></a></li>
<li><a href='#B'><p>Normalizing constant for the hyperdirichlet distribution</p></a></li>
<li><a href='#balance'><p>Enforce the zero power sum condition</p></a></li>
<li><a href='#baseball'><p>Baseball results, following Agresti</p></a></li>
<li><a href='#carcinoma'><p>Carcinoma dataset discussed by Agresti</p></a></li>
<li><a href='#character_to_number'>
<p>Convert a character vector to a numeric vector</p></a></li>
<li><a href='#chess'><p>Chess playing dataset</p></a></li>
<li><a href='#consistency'><p>Consistency check for hyper2 objects</p></a></li>
<li><a href='#constructor'><p>Formula 1 dataset: the constructors' championship</p></a></li>
<li><a href='#counterstrike'><p>Counterstrike</p></a></li>
<li><a href='#cplusplus'><p>Wrappers to c calls</p></a></li>
<li><a href='#curling'><p>Curling at the Winter Olympics, 1998-2018</p></a></li>
<li><a href='#dirichlet'>
<p>Dirichlet distribution and generalizations</p></a></li>
<li><a href='#eurodance'><p>Eurovision Dance contest dataset</p></a></li>
<li><a href='#eurovision'><p>Eurovision Song contest dataset</p></a></li>
<li><a href='#Extract'>
<p>Extract or replace parts of a hyper2 object</p></a></li>
<li><a href='#fillup'><p>Fillup function</p></a></li>
<li><a href='#formula1'><p>Formula 1 dataset</p></a></li>
<li><a href='#ggol'><p>Order statistics</p></a></li>
<li><a href='#gradient'><p>Differential calculus</p></a></li>
<li><a href='#handover'><p>Dataset on communication breakdown in handover between physicians</p></a></li>
<li><a href='#head.hyper2'><p>First few terms of a  distribution</p></a></li>
<li><a href='#hepatitis'><p>Hepatitis dataset discussed by Agresti</p></a></li>
<li><a href='#hyper2'>
<p>Basic functions in the hyper2 package</p></a></li>
<li><a href='#hyper3'><p>Weighted probability vectors: <code>hyper3</code> objects</p></a></li>
<li><a href='#icons'><p>Dataset on climate change due to O'Neill</p></a></li>
<li><a href='#increment'><p>Increment and decrement operators</p></a></li>
<li><a href='#interzonal'><p>1963 World Chess Championships</p></a></li>
<li><a href='#javelin'><p>Javelin dataset</p></a></li>
<li><a href='#jester'><p>Jester dataset</p></a></li>
<li><a href='#karate'><p>Karate dataset</p></a></li>
<li><a href='#karpov_kasparov_anand'><p>Karpov, Kasparov, Anand</p></a></li>
<li><a href='#keep'><p>Keep or discard players</p></a></li>
<li><a href='#length.hyper2'><p>Length method for hyper2 objects</p></a></li>
<li><a href='#loglik'><p>Log likelihood functions</p></a></li>
<li><a href='#masterchef'><p>Masterchef series 6</p></a></li>
<li><a href='#matrix2supp'><p>Convert a matrix to a likelihood function</p></a></li>
<li><a href='#maxp'><p>Maximum likelihood estimation</p></a></li>
<li><a href='#moto'><p>MotoGP dataset</p></a></li>
<li><a href='#mult_grid'><p>Kronecker matrix product functionality</p></a></li>
<li><a href='#NBA'><p>Basketball dataset</p></a></li>
<li><a href='#Ops.hyper2'><p>Arithmetic Ops Group Methods for hyper2 objects</p></a></li>
<li><a href='#Ops.hyper3'><p>Arithmetic Ops Group Methods for hyper3 objects</p></a></li>
<li><a href='#ordertable'><p>Order tables</p></a></li>
<li><a href='#ordertable2points'><p>Calculate points from an order table</p></a></li>
<li><a href='#ordertable2supp'><p>Translate order tables to support functions</p></a></li>
<li><a href='#ordertrans'><p>Order transformation</p></a></li>
<li><a href='#ordervec2supp3'><p>Various functionality for races and hyper3 likelihood functions</p></a></li>
<li><a href='#pairwise'><p>Pairwise comparisons</p></a></li>
<li><a href='#pentathlon'><p>Pentathlon</p></a></li>
<li><a href='#powerboat'><p>Powerboat dataset</p></a></li>
<li><a href='#Print'><p>Print methods</p></a></li>
<li><a href='#profile'><p>Profile likelihood and support</p></a></li>
<li><a href='#psubs'><p>Substitute players of a hyper2 object</p></a></li>
<li><a href='#pwa'><p>Player with advantage</p></a></li>
<li><a href='#ranktable'><p>Convert rank tables to and from order tables</p></a></li>
<li><a href='#rhyper2'><p>Random <code>hyper2</code> objects</p></a></li>
<li><a href='#rhyper3'><p>Random hyper3 objects</p></a></li>
<li><a href='#rowing'><p>Rowing dataset, sculling</p></a></li>
<li><a href='#rp'><p>Random samples from the prior of a <code>hyper2</code> object</p></a></li>
<li><a href='#rrace'><p>A random race with given BT strengths</p></a></li>
<li><a href='#rrank'><p>Random ranks</p></a></li>
<li><a href='#skating'><p>Figure skating at the 2002 Winter Olympics</p></a></li>
<li><a href='#soling'><p>Sailing at the 2000 Summer Olympics - soling</p></a></li>
<li><a href='#summary.hyper2'><p>Summary method for hyper2 objects</p></a></li>
<li><a href='#suplist'><p>Methods for suplist objects</p></a></li>
<li><a href='#surfing'><p>Surfing dataset</p></a></li>
<li><a href='#T20'><p>Indian Premier League T20 cricket</p></a></li>
<li><a href='#table_tennis'><p>Match outcomes from repeated table tennis matches</p></a></li>
<li><a href='#tennis'><p>Match outcomes from repeated doubles tennis matches</p></a></li>
<li><a href='#tests'><p>Hypothesis testing</p></a></li>
<li><a href='#tidy'><p>Tidy up a hyper2 object</p></a></li>
<li><a href='#universities'><p>New Zealand University ranking data</p></a></li>
<li><a href='#volleyball'><p>Results from the NOCS volleyball league</p></a></li>
<li><a href='#volvo'><p>Race results from the 2014-2015 Volvo Ocean Race</p></a></li>
<li><a href='#zapweak'><p>Zap weak competitors</p></a></li>
<li><a href='#zipf'><p>Zipf's law</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Hyperdirichlet Distribution, Mark 2</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1-0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of routines for the hyperdirichlet distribution
   and reified Bradley-Terry; supersedes the 'hyperdirichlet' package;
   uses 'disordR' discipline &lt;<a href="https://doi.org/10.48550%2FARXIV.2210.03856">doi:10.48550/ARXIV.2210.03856</a>&gt;.  To cite
   in publications please use Hankin 2017 &lt;<a href="https://doi.org/10.32614%2Frj-2017-061">doi:10.32614/rj-2017-061</a>&gt;,
   and for Generalized Plackett-Luce likelihoods use Hankin 2024
   &lt;<a href="https://doi.org/10.18637%2Fjss.v109.i08">doi:10.18637/jss.v109.i08</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, cubature, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, testthat, bookdown, rticles, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0-7), partitions, disordR (&ge; 0.0-9), alabama,
calibrator, Rdpack, magrittr, frab</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/hyper2">https://github.com/RobinHankin/hyper2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/hyper2/issues">https://github.com/RobinHankin/hyper2/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-31 13:26:53 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-31 15:22:53 UTC</td>
</tr>
</table>
<hr>
<h2 id='hyper2-package'>
The Hyperdirichlet Distribution, Mark 2
</h2><span id='topic+hyper2-package'></span>

<h3>Description</h3>

<p>A suite of routines for the hyperdirichlet distribution
   and reified Bradley-Terry; supersedes the 'hyperdirichlet' package;
   uses 'disordR' discipline &lt;doi:10.48550/ARXIV.2210.03856&gt;.  To cite
   in publications please use Hankin 2017 &lt;doi:10.32614/rj-2017-061&gt;,
   and for Generalized Plackett-Luce likelihoods use Hankin 2024
   &lt;doi:10.18637/jss.v109.i08&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> hyper2</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> The Hyperdirichlet Distribution, Mark 2</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.1-0</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> A suite of routines for the hyperdirichlet distribution
   and reified Bradley-Terry; supersedes the 'hyperdirichlet' package;
   uses 'disordR' discipline &lt;doi:10.48550/ARXIV.2210.03856&gt;.  To cite
   in publications please use Hankin 2017 &lt;doi:10.32614/rj-2017-061&gt;,
   and for Generalized Plackett-Luce likelihoods use Hankin 2024
   &lt;doi:10.18637/jss.v109.i08&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> methods, cubature, R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr, markdown, rmarkdown, testthat, bookdown, rticles, covr</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 1.0-7), partitions, disordR (&gt;= 0.0-9), alabama, calibrator, Rdpack, magrittr, frab</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/hyper2</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/hyper2/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> Rdpack</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
B                       Normalizing constant for the hyperdirichlet
                        distribution
Extract.hyper2          Extract or replace parts of a hyper2 object
NBA                     Basketball dataset
Ops.hyper2              Arithmetic Ops Group Methods for hyper2 objects
Ops.hyper3              Arithmetic Ops Group Methods for hyper3 objects
Print                   Print methods
T20                     Indian Premier League T20 cricket
as.ordertable           Convert an order table with DNS entries to a
                        nice order table
attemptstable2supp3     Translate attempt tables to hyper3 support
                        functions
balance                 Enforce the zero power sum condition
baseball                Baseball results, following Agresti
carcinoma               Carcinoma dataset discussed by Agresti
character_to_number     Convert a character vector to a numeric vector
chess                   Chess playing dataset
consistency             Consistency check for hyper2 objects
constructor             Formula 1 dataset: the constructors'
                        championship
counterstrike           Counterstrike
cplusplus               Wrappers to c calls
curling                 Curling at the Winter Olympics, 1998-2018
dirichlet               Dirichlet distribution and generalizations
equalp.test             Hypothesis testing
eurodance               Eurovision Dance contest dataset
eurovision              Eurovision Song contest dataset
fillup                  Fillup function
formula1                Formula 1 dataset
ggol                    Order statistics
gradient                Differential calculus
handover                Dataset on communication breakdown in handover
                        between physicians
head.hyper2             First few terms of a distribution
hepatitis               Hepatitis dataset discussed by Agresti
hyper2                  Basic functions in the hyper2 package
hyper2-package          The Hyperdirichlet Distribution, Mark 2
hyper3                  Weighted probability vectors: 'hyper3' objects
icons                   Dataset on climate change due to O'Neill
increment               Increment and decrement operators
interzonal              1963 World Chess Championships
javelin                 Javelin dataset
jester                  Jester dataset
karate                  Karate dataset
karpov_kasparov_anand   Karpov, Kasparov, Anand
keep                    Keep or discard players
length.hyper2           Length method for hyper2 objects
loglik                  Log likelihood functions
masterchef              Masterchef series 6
matrix2supp             Convert a matrix to a likelihood function
maxp                    Maximum likelihood estimation
moto                    MotoGP dataset
mult_grid               Kronecker matrix product functionality
ordertable              Order tables
ordertable2points       Calculate points from an order table
ordertable2supp         Translate order tables to support functions
ordertrans              Order transformation
ordervec2supp3          Various functionality for races and hyper3
                        likelihood functions
pairwise                Pairwise comparisons
pentathlon              Pentathlon
powerboat               Powerboat dataset
profile                 Profile likelihood and support
psubs                   Substitute players of a hyper2 object
pwa                     Player with advantage
ranktable               Convert rank tables to and from order tables
rhyper2                 Random 'hyper2' objects
rhyper3                 Random hyper3 objects
rowing                  Rowing dataset, sculling
rp                      Random samples from the prior of a 'hyper2'
                        object
rrace                   A random race with given BT strengths
rrank                   Random ranks
skating                 Figure skating at the 2002 Winter Olympics
soling                  Sailing at the 2000 Summer Olympics - soling
summary.hyper2          Summary method for hyper2 objects
suplist                 Methods for suplist objects
surfing                 Surfing dataset
table_tennis            Match outcomes from repeated table tennis
                        matches
tennis                  Match outcomes from repeated doubles tennis
                        matches
tidy                    Tidy up a hyper2 object
universities            New Zealand University ranking data
volleyball              Results from the NOCS volleyball league
volvo                   Race results from the 2014-2015 Volvo Ocean
                        Race
zapweak                 Zap weak competitors
zipf                    Zipf's law
</pre>
<p>A generalization of the Dirichlet distribution, using a more
computationally efficient method than the <span class="pkg">hyperdirichlet</span>
package.  The software is designed for the analysis of order
statistics and team games.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li> 
<p>R. K. S. Hankin (2010). &ldquo;A Generalization of the Dirichlet Distribution&rdquo;,
<em>Journal of Statistical Software</em>, 33(11), 1-18,
<a href="https://doi.org/10.18637/jss.v033.i11">doi:10.18637/jss.v033.i11</a>
</p>
</li>
<li><p> R. K. S. Hankin 2017. &ldquo;Partial Rank Data with the hyper2
Package: Likelihood Functions for Generalized Bradley-Terry Models&rdquo;.
<em>The <span class="rlang"><b>R</b></span> Journal</em> 9:2, pages 429-439, <a href="https://doi.org/10.32614/rj-2017-061">doi:10.32614/rj-2017-061</a>
</p>
</li>
<li><p> R. K. S. Hankin 2024.  &ldquo;Generalized Plackett-Luce
Likelihoods&rdquo;, <em>Journal of Statistical Software</em>, 109(8), 1-17,
<a href="https://doi.org/10.18637/jss.v109.i08">doi:10.18637/jss.v109.i08</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>icons
maxp(icons)
</code></pre>

<hr>
<h2 id='as.ordertable'>Convert an order table with DNS entries to a nice order table</h2><span id='topic+as.ordertable'></span>

<h3>Description</h3>

<p>Given an ordertable such as <code>F1_table_2017</code> which is a
&ldquo;wikitable&rdquo; object, function <code>as.ordertable()</code> returns a
nicified version in which entries such as DNS are replaced with zeros.
Finishing competitors are assigned numbers <code class="reqn">1-n</code> with no gaps; the
function can be used to extract a subset of competitors.
</p>
<p>Function <code>ordertable2supp()</code> offers similar functionality but
returns a <code>hyper2</code> object directly. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ordertable(w)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ordertable_+3A_w">w</code></td>
<td>
<p>A generalized ordertable, a wikitable</p>
</td></tr></table>


<h3>Details</h3>

<p>Operates columnwise, and treats any entry not coercible to numeric as
DNF.
</p>


<h3>Value</h3>

<p>Returns an ordertable suitable for coercion to a <code>hyper2</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable">ordertable</a></code>,<code><a href="#topic+ordertable2supp">ordertable2supp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
as.ordertable(F1_table_2017)
ordertable2supp(as.ordertable(F1_table_2017[1:9,]))

</code></pre>

<hr>
<h2 id='attemptstable2supp3'>Translate attempt tables to hyper3 support functions</h2><span id='topic+attemptstable2supp'></span><span id='topic+attemptstable2supp3'></span>

<h3>Description</h3>

<p>description here
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attemptstable2supp3(a, decreasing, give.supp=TRUE, dnf.last=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attemptstable2supp3_+3A_a">a</code></td>
<td>
<p>Data frame, see details</p>
</td></tr>
<tr><td><code id="attemptstable2supp3_+3A_decreasing">decreasing</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning that the highest
score wins [e.g. javelin distances] and <code>FALSE</code> meaning that the
lowest score wins [e.g. times for a race]</p>
</td></tr>
<tr><td><code id="attemptstable2supp3_+3A_give.supp">give.supp</code></td>
<td>
<p>Boolean, return the support function or the order statistic</p>
</td></tr>
<tr><td><code id="attemptstable2supp3_+3A_dnf.last">dnf.last</code></td>
<td>
<p>Boolean, should NA entries count as coming last (TRUE)
or  be ignored (FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>attemptstable2supp3()</code> is intended for use on attempts
tables like <code>javelin</code>.
</p>
<p>These objects can be generated by running script
<code>inst/javelin.Rmd</code>, which includes some further discussion and
technical documentation, and creates file <code>javelin.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>Value</h3>

<p>Returns a <code>hyper3</code> object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable2supp">ordertable2supp</a></code>,<code><a href="#topic+javelin">javelin</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
jj &lt;- javelin_table[1:3,]
jj
attemptstable2supp3(jj)

</code></pre>

<hr>
<h2 id='B'>Normalizing constant for the hyperdirichlet distribution</h2><span id='topic+B'></span><span id='topic+probability'></span><span id='topic+mgf'></span><span id='topic+mean'></span><span id='topic+Jacobian'></span><span id='topic+dhyper2'></span><span id='topic+dhyper2_e'></span><span id='topic+e_to_p'></span><span id='topic+p_to_e'></span><span id='topic+mean_hyper2'></span>

<h3>Description</h3>

<p>Numerical techniques for calculating the normalizing constant for the hyperdirichlet distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>B(H, disallowed=NULL, give=FALSE, ...)
probability(H, disallowed=NULL, ...)
mgf(H, powers, ...) 
dhyper2(ip,H,...)
dhyper2_e(e,H,include.Jacobian=TRUE)
mean_hyper2(H, normalize=TRUE, ...)
Jacobian(e)
e_to_p(e)
p_to_e(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="B_+3A_h">H</code></td>
<td>
<p>Object of class hyper2</p>
</td></tr>
<tr><td><code id="B_+3A_powers">powers</code></td>
<td>
<p>Vector of length <code>dim(x)</code> whose elements are the
powers of the expectation; see details section</p>
</td></tr>
<tr><td><code id="B_+3A_disallowed">disallowed</code></td>
<td>
<p>Function specifying a subset of the simplex
over which to integrate; default <code>NULL</code> means to integrate over
the whole simplex.  The integration proceeds over <code>p</code> with
<code>disallowed(p)</code> evaluating to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="B_+3A_e">e</code>, <code id="B_+3A_p">p</code></td>
<td>
<p>A vector; see details</p>
</td></tr>
<tr><td><code id="B_+3A_ip">ip</code></td>
<td>
<p>A vector of probabilities corresponding to <code>indep(p)</code>
where <code>p</code> is vector with unit sum</p>
</td></tr>
<tr><td><code id="B_+3A_include.jacobian">include.Jacobian</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to
include the Jacobian transformation in the evaluation, and
<code>FALSE</code> meaning to ignore it; use <code>FALSE</code> for likelihood
work and <code>TRUE</code> for probability densities</p>
</td></tr>
<tr><td><code id="B_+3A_give">give</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return the
value of the integral and <code>TRUE</code> meaning to return the full
output of <code>adaptIntegrate()</code></p>
</td></tr>
<tr><td><code id="B_+3A_normalize">normalize</code></td>
<td>
<p>Boolean, indicates whether return value of
<code>mean_hyper2()</code> is normalized to have unit sum</p>
</td></tr>
<tr><td><code id="B_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>adaptIntegrate()</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Function <code>B()</code> returns the normalizing constant of a
hyperdirichlet likelihood function.  Internally, <code class="reqn">p</code> is
converted to <code>e</code> (by <code>e_to_p()</code>) and the integral proceeds
over a hypercube.  This function can be very slow, especially if
<code>disallowed</code> is used.
</p>
</li>
<li><p> Function <code>dhyper2(ip,H)</code> is a probability density
function on the independent components of a unit-sum vector, that
is, <code>ip=indep(p)</code>.  This function calls <code>B()</code> each time so
might be a performance bottleneck.
</p>
</li>
<li><p> Function <code>probability()</code> gives the probability of an
observation from a hyperdirichlet distribution satisfying
<code>!disallowed(p)</code>.
</p>
</li>
<li><p> Function <code>mgf()</code> is the moment generating function,
taking an argument that specifies the powers of <code>p</code> needed: the
expectation of <code class="reqn">\prod_{i=1}^n {p_i}^{{\rm powers}[i]}</code> is returned.
</p>
</li>
<li><p> Function <code>mean_hyper2()</code> returns the mean value of the
hyperdirichlet distribution.  This is computationally slow (consider
<code>maxp()</code> for a measure of central tendency).  The function
takes a <code>normalize</code> argument, not passed to
<code>adaptIntegrate()</code>: this is Boolean with <code>FALSE</code> meaning
to return the value found by integration directly, and default
<code>TRUE</code> meaning to normalize so the sum is exactly 1
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li><p> Function <code>B()</code> returns a scalar: the normalization
constant
</p>
</li>
<li><p> Function <code>dhyper2()</code> is a probability density function
over <code>indep(p)</code>
</p>
</li>
<li><p> Function <code>mean()</code> returns a <code class="reqn">k</code>-tuple with unit sum
</p>
</li>
<li><p> Function <code>mgf()</code> returns a scalar equal to the expectation of
<code>p^power</code>
</p>
</li>
<li><p> Functions <code>is.proper()</code> and <code>validated()</code> return a Boolean
</p>
</li>
<li><p> Function <code>probability()</code> returns a scalar, a (Bayesian)
probability
</p>
</li></ul>



<h3>Note</h3>

<p>The adapt package is no longer available on CRAN; from 1.4-3, the
package uses <code>adaptIntegrate</code> of the cubature package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglik">loglik</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Two different measures of central tendency:
# mean_hyper2(chess,tol=0.1)   # takes ~10s to run
maxp(chess)                    # faster

# Using the 'disallowed' argument typically results in slow run times;
# use high tol for speed:

# probability(chess,disallowed=function(p){p[1]&gt;p[2]},tol=0.5)
# probability(chess,disallowed=function(p){p[1]&lt;p[2]},tol=0.5)

# Above should sum to 1 [they are exclusive and exhaustive events]


</code></pre>

<hr>
<h2 id='balance'>Enforce the zero power sum condition</h2><span id='topic+balance'></span>

<h3>Description</h3>

<p>Sometimes a <code>hyper2</code> object is unbalanced in the sense that its
powers do not sum to zero.  This is rectified by <code>balance()</code>, which
modifies the power of the bracket corresponding to the sum of all pnames
accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance(H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balance_+3A_h">H</code></td>
<td>
<p>object of class <code>hyper2</code> or <code>hyper3</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a convenience function, all it does is
</p>
<pre>
    H[pnames(H)] &lt;- 0
    H[pnames(H)] &lt;- -sum(pnames(H))
    H
  </pre>
<p>Package vignette <code>zeropower</code> discusses the zero power sum
condition.
</p>


<h3>Value</h3>

<p>Returns a balanced <code>hyper2</code> object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.hyper2">print.hyper2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

H &lt;- hyper2()
H["a"] &lt;- 6
H["b"] &lt;- 3
H[c("a","c")] &lt;- 7
H &lt;- balance(H)
maxp(H)
</code></pre>

<hr>
<h2 id='baseball'>Baseball results, following Agresti</h2><span id='topic+baseball'></span><span id='topic+baseball_maxp'></span><span id='topic+baseball_table'></span>

<h3>Description</h3>

<p>Results from repeated games among seven baseball teams,
following Agresti</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(baseball)</code></pre>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood function</p>


<h3>Details</h3>

<p>Agresti discusses results from seven baseball teams in the 1987 season
of the Eastern Division of the American League.  
</p>
<p>A results table and likelihood function is given in the package as
<code>baseball_table</code> and <code>baseball</code> respectively.  The maximum
likelihood estimate is given as <code>baseball_maxp</code>, but can be
reproduced by <code>maxp(baseball)</code>.
</p>
<p>These objects can be generated by running script
<code>inst/home_advantage.Rmd</code>, which includes some further discussion
and technical documentation, and creates file <code>baseball.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>References</h3>

<p>A. Agresti 2002. &ldquo;Categorical data analysis&rdquo;.  John Wiley and
Sons;   p437
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyper3">hyper3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>baseball_table
baseball_table[1:3,1:3] 
home_away3(baseball_table[1:3,1:3],1.3)

</code></pre>

<hr>
<h2 id='carcinoma'>Carcinoma dataset discussed by Agresti</h2><span id='topic+carcinoma'></span><span id='topic+carcinoma_table'></span><span id='topic+carcinoma_maxp'></span><span id='topic+carcinoma_count'></span>

<h3>Description</h3>

<p>A dataset considered by Agresti.  Seven clinicians are
asked whether they see evidence for carcinoma on different patients.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(carcinoma)</code></pre>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood function</p>


<h3>Details</h3>

<p>Object <code>carcinoma_table</code> is drawn from Agresti.  The first seven
columns correspond to the seven clinicians A-G, the next is the count
of observations, and the remaining columns are fitted values according
to different models discussed by Agresti.
</p>
<p>Object <code>carcinoma</code> is a likelihood function (of class <code>lsl</code>)
on the Bradley-Terry strengths of the seven clinicians.  The
clinicians diagnosed the presence or absence of carcinoma on a total
of 118 patients in a blind rating scheme.  The maximum likelihood
estimator for the clinicicans' Bradley-Terry strengths is given as
<code>carcinoma_maxp</code>, which is computationally expensive to find.
The package also includes <code>carcinoma_count</code>, which is a different
estimator for the Clinicians' BT strengths.
</p>
<p>These objects can be generated by running script <code>inst/carcinoma.Rmd</code>,
which includes some further discussion and technical documentation, and
creates file <code>carcinoma.rda</code> which resides in the <code>data/</code>
directory.
</p>


<h3>References</h3>

<p>A. Agresti, 2002.  &quot;Categorical data analysis&quot;.  John Wiley and
Sons. Table 13.1, p542.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+race3">race3</a></code>,<code><a href="#topic+hepatitis">hepatitis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pie(carcinoma_maxp)
</code></pre>

<hr>
<h2 id='character_to_number'>
Convert a character vector to a numeric vector
</h2><span id='topic+character_to_number'></span><span id='topic+char2num'></span>

<h3>Description</h3>

<p>Convert string descriptions of competitors into their number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>character_to_number(char, pnames)
char2num(char, pnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="character_to_number_+3A_char">char</code></td>
<td>
<p>Character vector to be converted</p>
</td></tr>
<tr><td><code id="character_to_number_+3A_pnames">pnames</code></td>
<td>
<p>Names vector (usually <code>pnames(H)</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In earlier versions of this package, the internal mechanism of functions
such as <code>ggrl()</code>, and all the <code>C++</code> code, operated with the
competitors labelled with a non-negative integer; it is then natural to
refer to the competitors as <code>p1</code>, <code>p2</code>, etc.
</p>
<p>However, sometimes the competitors have names (as in, for example, the
<code>rowing</code> dataset).  If so, it is more natural to refer to the
competitors using their names rather than an arbitrary integer.
</p>
<p>Function <code>character_to_number()</code> converts the names to numbers.  If
an element of <code>char</code> is not present in <code>pnames</code>, an error is
returned (function <code>char2num()</code> is an easy-to-type synonym).  The
function is here because it is used in <code>ggrl()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank_likelihood">rank_likelihood</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- sample(9)
 names(x) &lt;- sample(letters[1:9])
 H &lt;- rank_likelihood(x)
 character_to_number(letters[1:3],pnames(H))

 char2num(c("PB","L"),pnames(icons))



</code></pre>

<hr>
<h2 id='chess'>Chess playing dataset</h2><span id='topic+chess'></span><span id='topic+chess_table'></span><span id='topic+chess_maxp'></span><span id='topic+rock_paper_scissors'></span>

<h3>Description</h3>

<p>A tally of wins and losses for games between three chess players:
Topalov, Anand, Karpov.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chess)</code></pre>


<h3>Details</h3>

<p>(there are three chess datasets in the package, documented at
<code>interzonal.Rd</code> [the 1963 World championship], <code>kka.Rd</code>
[Karpov-Kasparov-Anand dataset], and <code>chess.Rd</code>
[rock-paper-scissors using Topalov-Anand-Karpov])
</p>
<p>This is a very simple dataset that can be used for illustration of
<code>hyper2</code> idiom.
</p>
<p>The players are:
</p>

<ul>
<li><p> Grandmaster Veselin Topalov.  <abbr><span class="acronym">FIDE</span></abbr> world
champion 2005-2006; peak rating 2813
</p>
</li>
<li><p> Grandmaster Viswanathan Anand.  <abbr><span class="acronym">FIDE</span></abbr> world
champion 2000-2002, 2008; peak rating 2799
</p>
</li>
<li><p> Grandmaster Anatoly Karpov.  <abbr><span class="acronym">FIDE</span></abbr> world
champion 1993-1999; peak rating 2780
</p>
</li></ul>

<p>Observe that Topalov beats Anand, Anand beats Karpov, and Karpov beats
Topalov (where &ldquo;beats&rdquo; means &ldquo;wins more games than&rdquo;).
</p>
<p>The games thus resemble a noisy version of &ldquo;rock paper scissors&rdquo;.
</p>
<p>The likelihood function does not record who played white; see
<code>karpov_kasparov_anand</code> for such a dataset.
</p>
<p>These objects can be generated by running script
<code>inst/rock_paper_scissors.Rmd</code>, which includes some further
discussion and technical documentation and creates file <code>chess.rda</code>
which resides in the <code>data/</code> directory.
</p>
<p>File <code>inst/ternaryplot_hyper2.Rmd</code> gives an example showing the
<code>chess</code> likelihood function that uses
<code>Ternary::ternaryPlot()</code>.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://en.chessbase.com/">https://en.chessbase.com/</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+karpov_kasparov_anand">karpov_kasparov_anand</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chess)
maxp(chess)

 mgf(chess,c(Anand=2),tol = 0.1)  # tolerance for speed

</code></pre>

<hr>
<h2 id='consistency'>Consistency check for hyper2 objects</h2><span id='topic+consistency'></span><span id='topic+consistencyplot'></span>

<h3>Description</h3>

<p>Given a <code>hyper2</code> object, calculate the maximum likelihood point in
two ways and plot one against the other to check for consistency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consistency(H, plot=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consistency_+3A_h">H</code></td>
<td>
<p>A <code>hyper2</code> object</p>
</td></tr>
<tr><td><code id="consistency_+3A_plot">plot</code></td>
<td>
<p>If <code>TRUE</code> (default), plot a comparison and return a
matrix invisibly, and if <code>FALSE</code> return the matrix.  Modelled
on argument <code>plot</code> of <code>hist</code></p>
</td></tr>
<tr><td><code id="consistency_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>points()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code>hyper2</code> object, calculate the maximum likelihood
estimate of the players' strengths using <code>maxp()</code>; then reverse
the <code>pnames</code> attribute and calculate the players' strengths
again.  These two estimates should be identical but small differences
highlight numerical problems.  Typically, the differences are small if
there are fewer than about 25 players.
</p>
<p>Reversing the <code>pnames()</code> is cosmetic in theory but is a
non-trivial operation: for example, it changes the identity of the
fillup from the last player to the first.
</p>


<h3>Value</h3>

<p>Returns a named three-row matrix with first row being the direct
evaluate, second row being the reverse of the reversed evaluate, and
the third being the difference
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertrans">ordertrans</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# consistency(icons)

x &lt;- icons
y &lt;- icons
pnames(y) &lt;- rev(pnames(y))
gradient(x,indep(equalp(x)))
gradient(y,indep(equalp(y)))

</code></pre>

<hr>
<h2 id='constructor'>Formula 1 dataset: the constructors' championship</h2><span id='topic+constructor'></span><span id='topic+constructors'></span><span id='topic+constructor_2020'></span><span id='topic+constructor_2020_maxp'></span><span id='topic+constructor_table_2020'></span><span id='topic+constructor_2020_table'></span><span id='topic+constructor_2021'></span><span id='topic+constructor_2021_maxp'></span><span id='topic+constructor_table_2021'></span><span id='topic+constructor_2021_table'></span>

<h3>Description</h3>

<p>Race results from 2017 Formula One constructors' Championship</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(constructor)
</code></pre>


<h3>Format</h3>

<p>A <code>hyper3</code> object that gives a likelihood function</p>


<h3>Details</h3>

<p>The Constructors championship runs parallel to the Formula 1 drivers'
championship.  The package currently includes data from 2020 and 2021; the 
following text applies to both years.  I will add more years eventually.
</p>
<p>Object <code>constructor_2021_table</code> is a dataframe, taken from
Wikipedia, with rows corresponding to performance of a constructor.
Each constructor fields two cars in each race; the identity of the
driver is not important in this context (and indeed may change as the
season progresses).  The first column is the name of the constructor,
the next 22 columns show the ranks of the constructors' cars, and the
final one is the points awarded.  At each venue, the constructor's best
performance is listed first.  The constructors' names change quite
frequently (e.g. &ldquo;Red Bull Racing-TAG Heuer&rdquo; raced 2016,2017, and
2018; &ldquo;Red Bull Racing-Honda&rdquo; raced 2019, 2020, and 2021.  I am
not sure whether to treat these as separate entities or not; file
<code>inst/constructor_names.txt</code> gives a dataframe of team names and
years they competed (not currently part of the package).  The row names
of the dataframe cannot be the constructors because these are not
unique.
</p>
<p>Object <code>constructor_2021_maxp</code> gives the maximum likelihood
estimate for the constructors' strengths. 
The corresponding <code>hyper3</code> likelihood function
<code>constructor_2021</code> is produced by <code>ordertable2supp3()</code>.
</p>
<p>These objects can be generated by running script <code>inst/race3.Rmd</code>,
which includes some further discussion and technical documentation, and
creates file <code>constructor.rda</code> which resides in the <code>data/</code>
directory.
</p>


<h3>References</h3>

<p>Wikipedia contributors. (2022, April 14). 2021 Formula One World
Championship. In _Wikipedia, The Free Encyclopedia_. Retrieved 05:16,
April 17, 2022, from
<a href="https://en.wikipedia.org/w/index.php?title=2021_Formula_One_World_Championship&amp;oldid=1082745216">https://en.wikipedia.org/w/index.php?title=2021_Formula_One_World_Championship&amp;oldid=1082745216</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+formula1">formula1</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dotchart(constructor_2021_maxp)
</code></pre>

<hr>
<h2 id='counterstrike'>Counterstrike</h2><span id='topic+counterstrike'></span><span id='topic+counterstrike_likelihood'></span><span id='topic+counterstrike_maxp'></span><span id='topic+zacslist'></span>

<h3>Description</h3>

<p>A kill-by-kill analysis of a counterstrike game.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(counterstrike)</code></pre>


<h3>Details</h3>

<p>E-sports are a form of competition using video games.  E-sports are
becoming increasingly popular, with high-profile tournaments attracting
over 400 million viewers, and prize pools exceeding US$20m.
</p>
<p>Counter Strike: Global Offensive (CS-GO) is a multiplayer first-person
shooter game in which two teams of five compete in an immersive virtual
reality combat environment.  CS-GO is distinguished by the ability to
download detailed gamefiles in which every aspect of an entire match is
recorded, it being possible to replay the match at will.
</p>
<p>Statistical analysis of such gamefiles is extremely difficult, primarily
due to complex gameplay features such as cooperative teamwork,
within-team communication, and real-time strategic fluidity.
</p>
<p>It is the task of the statistician to make robust inferences from such
complex datasets, and here I discuss data from an influential match
between &ldquo;FaZe Clan&rdquo; and &ldquo;Cloud9&rdquo;, two of the most
successful E-sports syndicates of all time, when they competed at Boston
2018.
</p>
<p>Dataset <code>counterstrike</code> is a loglikelihood function for the
strengths of ten counterstrike players; <code>counterstrike_maxp</code> is a
precomputed evaluate, and <code>zacslist</code> the observations used to
calculate the loglikelihood function.
</p>
<p>The probability model is similar to that of <code>NBA</code>: when a player
kills (scores), this is taken to be a success of the whole team rather
than the shooter.
</p>
<p>File <code>inst/counterstrike.R</code> and <code>inst/counterstrike_random.R</code>
include some further randomisation tests and discussion.
</p>
<p>The objects documented here can be generated by running script
<code>inst/counterstrike.Rmd</code>, which includes some further discussion
and technical documentation and creates file <code>counterstrike.rda</code>
which resides in the <code>data/</code> directory.
</p>
<p>Counterstrike dataset kindly supplied by Zachary Hankin.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://www.youtube.com/watch?v=XKWzlG4jDnI">https://www.youtube.com/watch?v=XKWzlG4jDnI</a>
</p>
</li>
<li> <p><a href="https://en.wikipedia.org/wiki/FaZe_Clan">https://en.wikipedia.org/wiki/FaZe_Clan</a>
</p>
</li>
<li> <p><a href="https://en.wikipedia.org/wiki/Cloud9">https://en.wikipedia.org/wiki/Cloud9</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dotchart(counterstrike_maxp)
</code></pre>

<hr>
<h2 id='cplusplus'>Wrappers to c calls</h2><span id='topic+cplusplus'></span><span id='topic+overwrite'></span><span id='topic+overwrite3'></span><span id='topic+accessor'></span><span id='topic+accessor3'></span><span id='topic+assigner'></span><span id='topic+assigner3'></span><span id='topic+addL'></span><span id='topic+addL3'></span><span id='topic+equal'></span><span id='topic+equality'></span><span id='topic+equality3'></span><span id='topic+identityL'></span><span id='topic+identityL3'></span><span id='topic+evaluate'></span><span id='topic+evaluate3'></span><span id='topic+differentiate'></span><span id='topic+differentiate3'></span><span id='topic+differentiate_n'></span><span id='topic+hyper2_accessor'></span><span id='topic+hyper2_equal'></span><span id='topic+hyper2_addL'></span><span id='topic+hyper2_assigner'></span><span id='topic+hyper2_differentiate'></span><span id='topic+hyper2_evaluate'></span><span id='topic+hyper2_identityL'></span><span id='topic+hyper2_overwrite'></span>

<h3>Description</h3>

<p>Various low-level wrappers to C functions, courtesy of Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overwrite(L1, powers1, L2, powers2)
accessor(L,powers,Lwanted)
assigner(L,p,L2,value)
addL(L1,p1,L2,p2)
identityL(L,p)
evaluate(L, powers, probs, pnames)
differentiate(L, powers, probs, pnames, n)
differentiate_n(L, powers, probs, pnames, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cplusplus_+3A_l">L</code>, <code id="cplusplus_+3A_l1">L1</code>, <code id="cplusplus_+3A_l2">L2</code>, <code id="cplusplus_+3A_lwanted">Lwanted</code></td>
<td>

<p>Lists with character vector elements, used to specify the brackets of
the hyperdirichlet distribution</p>
</td></tr>
<tr><td><code id="cplusplus_+3A_p">p</code>, <code id="cplusplus_+3A_p1">p1</code>, <code id="cplusplus_+3A_p2">p2</code>, <code id="cplusplus_+3A_powers">powers</code>, <code id="cplusplus_+3A_powers1">powers1</code>, <code id="cplusplus_+3A_powers2">powers2</code></td>
<td>

<p>A numeric vector specifying the powers to which the brackets are raised
</p>
</td></tr>
<tr><td><code id="cplusplus_+3A_value">value</code></td>
<td>
<p>RHS in assignment, a numeric vector</p>
</td></tr>
<tr><td><code id="cplusplus_+3A_probs">probs</code></td>
<td>
<p>Vector of probabilities for evaluation of log-likelihood</p>
</td></tr>
<tr><td><code id="cplusplus_+3A_pnames">pnames</code></td>
<td>
<p>Character vector of names</p>
</td></tr>
<tr><td><code id="cplusplus_+3A_n">n</code></td>
<td>
<p>Integer specifying component to differentiate with respect to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are not really intended for the end-user, as
out-of-scope calls may cause crashes.
</p>


<h3>Value</h3>

<p>These functions return a named List</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>

<hr>
<h2 id='curling'>Curling at the Winter Olympics, 1998-2018</h2><span id='topic+curling_table'></span><span id='topic+curling'></span><span id='topic+Curling'></span><span id='topic+curling1'></span><span id='topic+curling2'></span><span id='topic+curling_maxp'></span><span id='topic+curling1_maxp'></span><span id='topic+curling2_maxp'></span>

<h3>Description</h3>

<p>Data for women's Olympic Curling  at the 2002 Winter Olympics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(curling)</code></pre>


<h3>Details</h3>

<p>There are five datasets loaded by <code>data("curling")</code>:
</p>

<ul>
<li> <p><code>curling_table</code>, an order table for Winter Olympics years
1998,2002,2006,2010,2014, and 2018 for 13 countries.
</p>
</li>
<li> <p><code>curling1</code>, a log likelihood function on the assumption
that not attending (indicated by <code>NA</code>) is equivalent to a
<code>DNS</code> in Formula 1
</p>
</li>
<li> <p><code>curling2</code>, a log likelihood function on the assumption
that not attending is noninformative
</p>
</li>
<li> <p><code>curling1_maxp</code> and <code>curling2_maxp</code>, corresponding
evaluates
</p>
</li></ul>

<p>These objects can be generated by running script
<code>inst/curling.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>curling.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>Wikipedia contributors. Curling at the Winter Olympics [Internet].
Wikipedia, The Free Encyclopedia; 2021 Jan 7, 14:23 UTC [cited 2021 Jan
21]. Available from:
<a href="https://en.wikipedia.org/w/index.php?title=Curling_at_the_Winter_Olympics&amp;oldid=998891075">https://en.wikipedia.org/w/index.php?title=Curling_at_the_Winter_Olympics&amp;oldid=998891075</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(curling)
dotchart(curling1_maxp)

</code></pre>

<hr>
<h2 id='dirichlet'>
Dirichlet distribution and generalizations
</h2><span id='topic+dirichlet'></span><span id='topic+rdirichlet'></span><span id='topic+is.dirichlet'></span><span id='topic+rp_unif'></span><span id='topic+gd'></span><span id='topic+Dirichlet'></span><span id='topic+gd'></span><span id='topic+GD'></span><span id='topic+GD_wong'></span><span id='topic+Connor'></span><span id='topic+Mosimann'></span>

<h3>Description</h3>

<p>The Dirichlet distribution in likelihood (for p) form, including the
generalized Dirichlet distribution due to Connor and Mosimann
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirichlet(powers, alpha)
GD(alpha, beta, beta0=0)
GD_wong(alpha, beta)
rdirichlet(n,H)
is.dirichlet(H)
rp_unif(n,H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirichlet_+3A_powers">powers</code></td>
<td>
<p>In function <code>dirichlet()</code> a (named) vector of powers</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_alpha">alpha</code>, <code id="dirichlet_+3A_beta">beta</code></td>
<td>
<p>A vector of parameters for the Dirichlet or
generalized Dirichlet distribution</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_beta0">beta0</code></td>
<td>
<p>In function <code>GD()</code>, an arbitrary parameter</p>
</td></tr>
<tr><td><code id="dirichlet_+3A_h">H</code></td>
<td>
<p>Object of class <code>hyper2</code></p>
</td></tr>
<tr><td><code id="dirichlet_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are really convenience functions.
</p>
<p>Function <code>rdirichlet()</code> returns random samples drawn from a
Dirichlet distribution.  If second argument <code>H</code> is a
<code>hyper2</code> object, it is tested [with <code>is.dirichlet()</code>] for
being a Dirichlet distribution.  If so, samples from it are returned.
If not, (e.g. <code>icons</code>), an error is given.  If <code>H</code> is not a
<code>hyper2</code> object, it is interpreted as a vector of parameters
<code class="reqn">\alpha</code> [<strong>not</strong> a vector of powers].
</p>
<p>Function <code>rp_unif()</code> returns uniformly distributed vectors,
effectively using <code>H*0</code>; but note that this uses Dirichlet
sampling which is much faster and better than the Metropolis-Hastings
functionality documented at <code>rp.Rd</code>.
</p>
<p>Functions <code>GD()</code> and <code>GD_wong()</code> return a likelihood
function corresponding to the Generalized Dirichlet distribution as
presented by Connor and Mosimann, and Wong, respectively.  In
<code>GD_wong()</code>, <code>alpha</code> and <code>beta</code> must be named vectors;
the names of <code>alpha</code> give the names of
<code class="reqn">x_1,\ldots,x_k</code> and the last element of <code>beta</code>
gives the name of <code class="reqn">x_{k+1}</code>.
</p>


<h3>Note</h3>

<p>A dirichlet distribution can have a term with zero power.  But
this poses problems for <code>hyper2</code> objects as zero power brackets
are dropped.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li><p> R. J. Connor and J. E. Mosimann 1969.  &ldquo;Concepts of
independence for proportions with a generalization of the Dirichlet
distribution&rdquo;.  <em>Journal of the American Statistical
Association</em>, 64:194&ndash;206
</p>
</li>
<li><p> T.-T. Wong 1998. &ldquo;Generalized Dirichlet distribution in
Bayesian Analysis&rdquo;.  <em>Applied Mathematics and Computation</em>,
97:165&ndash;181 </p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+hyper2">hyper2</a></code>,<code><a href="#topic+rp">rp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1 &lt;- dirichlet(c(a=1,b=2,c=3))
x2 &lt;- dirichlet(c(c=3,d=4))

x1+x2

H &lt;- dirichlet(c(a=1,b=2,c=3,d=4))
rdirichlet(10,H)
colMeans(rdirichlet(1e4,H))

</code></pre>

<hr>
<h2 id='eurodance'>Eurovision Dance contest dataset</h2><span id='topic+eurodance'></span><span id='topic+Eurodance'></span><span id='topic+eurodance_table'></span><span id='topic+eurodance_maxp'></span>

<h3>Description</h3>

<p>Voting patterns from Eurovision Dance Contest 2008</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eurovision)</code></pre>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood
function.
</p>


<h3>Details</h3>

<p>Object <code>eurodance</code> is a <code>hyper2</code> object that gives a
likelihood function for the skills of the 14 competitor countries in
2008 Eurovision Dance contest.  Object <code>eurodance_table</code> gives the
original dataset and <code>eurodance_maxp</code> the evaluate of the
competitors' Plackett-Luce strengths.
</p>
<p>The dataset is interesting because, in addition to the regular votes by
each nation, there is an Expert jury vote as well.  We may use
Plackett-Luce likelihoods to compare the performance of the Expert jury
with the national votes.
</p>
<p>These objects can be generated by running script
<code>inst/eurodance.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>eurodance.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>References</h3>


<ul>
<li> 
<p>Wikipedia contributors, &ldquo;Eurovision Song Contest
2009&mdash;Wikipedia, The Free Encyclopedia&rdquo;, 2018,
<a href="https://en.wikipedia.org/w/index.php?title=Eurovision_Song_Contest_2009&amp;oldid=838723921">https://en.wikipedia.org/w/index.php?title=Eurovision_Song_Contest_2009&amp;oldid=838723921</a>  [Online; accessed 13-May-2018].
</p>
</li>
<li><p> P. M. E. Altham, personal communication
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+eurodance">eurodance</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eurodance)
dotchart(eurodance_maxp)



</code></pre>

<hr>
<h2 id='eurovision'>Eurovision Song contest dataset</h2><span id='topic+euro'></span><span id='topic+euro2009'></span><span id='topic+eurovision'></span><span id='topic+Eurovision'></span><span id='topic+Eurovision2009'></span><span id='topic+eurovision2009'></span><span id='topic+eurovision2009_votingtable'></span><span id='topic+Eurovision_song_contest'></span><span id='topic+eurovision_table'></span><span id='topic+eurovision_maxp'></span>

<h3>Description</h3>

<p>Voting patterns from Eurovision 2009</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(eurovision)</code></pre>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood
function.
</p>


<h3>Details</h3>

<p>Object <code>eurovision</code> is a <code>hyper2</code> object that gives a
likelihood function for the skills of the 18 competitor countries in
semi-final 1 of the 2009 Eurovision Song contest.  Object
<code>eurovision_table</code> gives the original dataset and
<code>eurovision_maxp</code> the evaluate of the competitors' Plackett-Luce
strengths.
</p>
<p>The motivation for choosing this particular dataset is that Pat Altham
(Statistical Laboratory, Cambridge) considered it with a view to
discover similarities between voters.  In the current analysis, the
likelihood function <code>eurovision</code> assumes their independence.
</p>
<p>These objects can be generated by running script
<code>inst/eurovision.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>eurovision.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>References</h3>


<ul>
<li> 
<p>Wikipedia contributors, &ldquo;Eurovision Song Contest
2009&mdash;Wikipedia, The Free Encyclopedia&rdquo;, 2018,
<a href="https://en.wikipedia.org/w/index.php?title=Eurovision_Song_Contest_2009&amp;oldid=838723921">https://en.wikipedia.org/w/index.php?title=Eurovision_Song_Contest_2009&amp;oldid=838723921</a>  [Online; accessed 13-May-2018].
</p>
</li>
<li><p> P. M. E. Altham, personal communication
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+eurodance">eurodance</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eurovision)
dotchart(eurovision_maxp)



</code></pre>

<hr>
<h2 id='Extract'>
Extract or replace parts of a hyper2 object
</h2><span id='topic+Extract.hyper2'></span><span id='topic+extract'></span><span id='topic+extractor'></span><span id='topic+assign_lowlevel'></span><span id='topic+overwrite_lowlevel'></span><span id='topic++5B.hyper2'></span><span id='topic++5B+3C-.hyper2'></span>

<h3>Description</h3>

<p>Extract or replace parts of a hyper2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyper2'
x[...]
## S3 replacement method for class 'hyper2'
x[index, ...] &lt;- value
assign_lowlevel(x,index,value)
overwrite_lowlevel(x,value)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extract_+3A_x">x</code></td>
<td>
<p>An object of class <code>hyper2</code></p>
</td></tr>
<tr><td><code id="Extract_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
<tr><td><code id="Extract_+3A_index">index</code></td>
<td>
<p>A list with integer vector elements corresponding to the
brackets whose power is to be replaced</p>
</td></tr>
<tr><td><code id="Extract_+3A_value">value</code></td>
<td>
<p>Numeric vector of powers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods should work as expected, although the off-by-one issue
might be a gotcha.
</p>
<p>For the extract method, <code>H[L]</code>, a <code>hyper2</code> object is
returned.  The replace method, <code>H[L] &lt;- value</code>, the index
specifies the brackets whose powers are to be overwritten; standard
<code>disordR</code> protocol is used.
</p>
<p>If the index argument is missing, viz <code>H1[] &lt;- H2</code>, this is a
special case.  Argument <code>H1</code> must be a <code>hyper2</code> object, and
the idiom effectively executes <code>H1[brackets(H2)] &lt;- powers(H2)</code>,
but more efficiently (note that this operation is well-defined even
though the order of the brackets is arbitrary).  This special case is
included in the package because it has a very natural <code>C++</code>
expression [function <code>overwrite()</code> in the <code>src/</code> directory]
that was too neat to omit.
</p>
<p>Altering (incrementing or decrementing) the power of a single bracket
is possible using idiom like <code>H[x] &lt;- H[x] + 1</code>; this is
documented at <code>Ops.hyper2</code>, specifically
<code>hyper2_sum_numeric()</code> and a discussion is given at
<code>increment.Rd</code>.
</p>
<p>Functions <code>assign_lowlevel()</code> and <code>overwrite_lowlevel()</code> are
low-level helper functions and not really intended for the end-user.
</p>


<h3>Value</h3>

<p>The extractor method returns a <code>hyper2</code> object, restricted to the
elements specified
</p>


<h3>Note</h3>

<p>Use <code>powers()</code> and <code>brackets()</code> to extract a numeric vector of
powers or a list of integer vectors respectively.
</p>
<p>Replacement idiom <code>H[x] &lt;- val</code> cannot use non-trivial recycling.
This is because the elements of <code>H</code> are stored in an arbitrary
order, but the elements of <code>val</code> are stored in a particular order.
Also see function <code>hyper2_sum_numeric()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyper2">hyper2</a></code>,<code><a href="#topic+Ops.hyper2">Ops.hyper2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chess)

chess["Topalov"]
chess[c("Topalov","Anand")]
chess[c("Anand","Topalov")]

# Topalov plays Anand and wins:

chess["Topalov"] &lt;- chess["Topalov"]+1 
chess[c("Topalov","Anand")] &lt;- chess[c("Topalov","Anand")]-1


# Topalov plays *Kasparov* and wins:
chess["Topalov"] &lt;- chess["Topalov"] + 1
chess[c("Topalov","Kasparov")] &lt;- chess[c("Topalov","Kasparov")] -1

# magrittr idiom:
# chess["Topalov"] %&lt;&gt;% inc
# chess[c("Topalov","Kasparov")] %&lt;&gt;% dec  

# overwriting idiom:
H &lt;- hyper2(list("Topalov","X"),6)
chess[] &lt;- H

H &lt;- icons

</code></pre>

<hr>
<h2 id='fillup'>Fillup function</h2><span id='topic+fillup'></span><span id='topic+indep'></span>

<h3>Description</h3>

<p>Function <code>fillup()</code> concatenates a vector with a &lsquo;fillup&rsquo;
value to ensure a unit sum; if given a matrix, attaches a column so
the rowsums are 1.
</p>
<p>Function <code>indep()</code> is the inverse: it removes the final element
of a vector, leaving only an independent set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillup(x,H=NULL,total=1)
indep(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillup_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="fillup_+3A_h">H</code></td>
<td>
<p>Object with <code>pnames()</code> attribute, typically of class
<code>hyper2</code> or <code>hyper3</code>, used for names if supplied</p>
</td></tr>
<tr><td><code id="fillup_+3A_total">total</code></td>
<td>
<p>Total value for probability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually you want the total to be one, to enforce the unit sum
constraint.  Passing <code>total=0</code> constrains the sum to be
zero.  This is useful when considering <code class="reqn">\delta p</code>; see the
example at <code>gradient.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+equalp">equalp</a></code>,<code><a href="#topic+gradient">gradient</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>fillup(c(1/2,1/3))

indep(c(1/2,1/3,1/6))

fillup(indep(icons_maxp))  
fillup(indep(icons_maxp),icons)

</code></pre>

<hr>
<h2 id='formula1'>Formula 1 dataset</h2><span id='topic+formula1'></span><span id='topic+formula_1'></span><span id='topic+formula_one'></span><span id='topic+formula1_points_systems'></span><span id='topic+F1'></span><span id='topic+F1_2014'></span><span id='topic+F1_table_2016'></span><span id='topic+F1_table_2017'></span><span id='topic+F1_table_2018'></span><span id='topic+F1_table_2019'></span><span id='topic+formula1_table_2017'></span><span id='topic+F1_points_2017'></span><span id='topic+formula1_points_2017'></span><span id='topic+formula1_2017_table'></span><span id='topic+F1_2015'></span><span id='topic+F1_2016'></span><span id='topic+F1_2017'></span><span id='topic+F1_2018'></span><span id='topic+F1_2019'></span>

<h3>Description</h3>

<p>Race results from 2017 Formula One World Championship</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(formula1)
formula1_points_systems(top=11)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula1_+3A_top">top</code></td>
<td>
<p>Number of drivers to retain in
<code>formula1_points_systems()</code></p>
</td></tr>
</table>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood function</p>


<h3>Details</h3>

<p>Object <code>formula1</code> is a <code>hyper2</code> object that gives a likelihood
function for the strengths of the competitors of the 2017 Formula One
(Drivers') World Championship.  Object <code>F1_table_2017</code> is an order table: a
data frame with rows being drivers, columns being venues, and entries
being places.  Thus looking at the first row, first column we see that
Hamilton placed second in Austria.
</p>
<p>The package uses files like <code>inst/formula1_2017.txt</code> as primary
sources.  These are generally copied from wikipedia, converted into
tab-separated clean seven bit ascii, and tidied up a little.  I have
removed diacritics from names, so we see &ldquo;<code>Raikkonen</code>&rdquo;,
&ldquo;<code>Perez</code>&rdquo;, etc.  Also where distinct drivers with the same
surname compete, I have indicated this, e.g. <code>schumacher_R</code> is Ralf
Schumacher, <code>schumacher_M</code> is Michael, and <code>schumacher_Mick</code>
is Mick; the underscore device means that quoting should not be needed
in <span class="rlang"><b>R</b></span> idiom.  I have not been entirely consistent here, with Bruno Senna
appearing as &ldquo;<code>Senna_B</code>&rdquo; and Nelson Piquet Junior appearing
as &ldquo;<code>PiquetJ</code>&rdquo; [on the grounds that in these cases the
fathers, being more eminent, should be the primary eponym] although this might
change in the future.
</p>
<p>Object <code>F1_table_2017</code> is simply the first 20 columns of
<code>read.table(inst/formula1_2017.txt)</code> and object
<code>F1_points_2017</code> is column 21.  The likelihood function
<code>formula1</code> is <code>ordertable2supp(F1_table_2017)</code>.  The datasets
in the package are derived from text files in the <code>inst/</code> directory
(e.g. <code>formula1_2017.txt</code>) by script file
<code>inst/f1points_Omaker.R</code>.  Executing this script creates files like
<code>formula1_results_2017.rda</code>.
</p>
<p>The text files can be converted directly into <code>ranktable</code> objects
and support functions as follows:
</p>
<pre>
a &lt;- read.table("formula1_2022.txt",header=TRUE)
a &lt;- a[,seq_len(ncol(a)-1)]  # strips out the points column
wikitable_to_ranktable(a)
ordertable2supp(a)
</pre>
<p>Function <code>formula1_points_system()</code> gives various possible points
systems for the winner, second, third, etc, placing drivers.  
</p>
<p>The constructors' championship is discussed at <code>constructor.Rd</code>.
</p>
<p>There is a large amount of documentation in the <code>inst/</code> directory
in the form of Rmd files.
</p>


<h3>References</h3>

<p>&ldquo;Wikipedia contributors&rdquo;, <em>2017 Formula One World
Championship&mdash;Wikipedia, The Free Encyclopedia</em>, 2018.
<a href="https://en.wikipedia.org/w/index.php?title=2017_Formula_One_World_Championship&amp;oldid=839923210">https://en.wikipedia.org/w/index.php?title=2017_Formula_One_World_Championship&amp;oldid=839923210</a>
[Online; accessed 14-May-2018]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable2supp">ordertable2supp</a></code>,<code><a href="#topic+constructor">constructor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(formula1)
## Not run: #Takes too long
dotchart(maxp(formula1))

## End(Not run)

</code></pre>

<hr>
<h2 id='ggol'>Order statistics</h2><span id='topic+ggol'></span><span id='topic+ggrl'></span><span id='topic+goodbad'></span><span id='topic+choose_losers'></span><span id='topic+choose_winners'></span><span id='topic+general_grouped_rank_likelihood'></span><span id='topic+general_grouped_order_likelihood'></span><span id='topic+rank_likelihood'></span><span id='topic+rankvec_likelihood'></span><span id='topic+elimination'></span><span id='topic+race'></span><span id='topic+Plackett'></span><span id='topic+Plackett-Luce'></span>

<h3>Description</h3>

<p>Various functions for calculating the likelihood function for order
statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggrl(H, ...)
general_grouped_rank_likelihood(H, ...)
goodbad(winners,losers)
elimination(all_players)
rank_likelihood(M,times=1)
rankvec_likelihood(v)
race(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggol_+3A_h">H</code></td>
<td>
<p>Object of class <code>hyper2</code></p>
</td></tr>
<tr><td><code id="ggol_+3A_...">...</code></td>
<td>
<p>Numeric or character vectors specifying groups of
players with  equal rank, with higher-ranking groups coming earlier
in the argument list</p>
</td></tr>
<tr><td><code id="ggol_+3A_all_players">all_players</code>, <code id="ggol_+3A_winners">winners</code>, <code id="ggol_+3A_losers">losers</code></td>
<td>
<p>Numeric or character vectors
specifying competitors.  See details</p>
</td></tr>
<tr><td><code id="ggol_+3A_m">M</code></td>
<td>
<p>In function <code>rank_likelihood()</code>, a matrix with each
row corresponding to a race (or judge).  The columns
correspond to the finishing order; thus <code>a=M[i,j]</code> means that
competitor <code>a</code> finished in place <code>j</code> in race <code>i</code></p>
</td></tr>
<tr><td><code id="ggol_+3A_times">times</code></td>
<td>
<p>Vector specifying the number of times each row is
observed</p>
</td></tr>
<tr><td><code id="ggol_+3A_v">v</code></td>
<td>
<p>A character vector specifying ranks.  Thus
<code>c("b","c","a")</code> means that <code>b</code> came first, <code>c</code> second,
and <code>a</code> third</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>These functions are designed to return likelihood functions, in the
form of lists of <code>hyper2()</code> objects, for typical order statistics
such as the results of rowing heats or MasterChef tournaments.
</p>
<p>Function <code>ggrl()</code> is an easily-typed alias for
<code>general_grouped_rank_likelihood()</code>.
</p>
<p>Function <code>goodbad()</code> is a convenience function for <code>ggrl()</code>
in which a bunch of contestants is judged.  It returns a likelihood
function for the observation that the members of one subset were
better than those of another.  Thus
<code>goodbad(letters[1:3],letters[4:5])</code> corresponds to the
observation that <code>d</code> and <code>e</code> were put into an elimination
trial (and <code>abc</code> were not).
</p>
<p>Function <code>elimination()</code> gives a likelihood function for situations
where the <em>weakest</em> player is identified at each stage and
subsequently eliminated from the competition.  It is intended for
situations like the Great British Bake-off and Masterchef in which the
observation is which player was chosen to leave the show.  In this
function, argument <code>all_players</code> is sensitive to order, unlike
<code>choose_winners()</code> and <code>choose_losers()</code> (an integer
<code>n</code> is interpreted as <code>letters[seq_len(n)]</code>).  Element
<code>i</code> of <code>all_players</code> is the <code class="reqn">i^\mathrm{th}</code> player
to be eliminated.  Thus the first element of <code>all_players</code> is the
first player to be eliminated (and would be expected to have the
lowest strength).  The final element of <code>all_players</code> is the last
player to be eliminated (or alternatively the only player not to be
eliminated).
</p>
<p>Function <code>rank_likelihood()</code> takes a matrix <code>M</code> with rows
corresponding to a judge (or race); column names are interpreted as
competitor names.  A named vector is coerced to a one-row matrix.
Each row of <code>M</code> is an order statistic: thus <code>c(3,4,2,1)</code>
means that person 3 came first, person 4 came second, person 2 came
third and person 1 came last.  Note that in data frames like
<code>F1_table_2017</code>, each <em>column</em> is a race.
</p>
<p>Function <code>rankvec_likelihood()</code> takes a character vector of
competitors with the order of elements corresponding to the finishing
order; a Plackett-Luce likelihood function is returned.  Thus
<code>v=c("d","b","c","a")</code> corresponds to <code>d</code> coming first,
<code>b</code> second, <code>c</code> third, and <code>a</code> fourth.  Function
<code>race()</code> is an arguably more memorable synonym.
</p>
<p>An example of <code>race()</code> is given in <code>inst/rowing.Rmd</code>, and
examples of <code>ggrl()</code> are given in <code>inst/loser.Rmd</code> and
<code>inst/masterchef.Rmd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrank">rrank</a></code>,<code><a href="#topic+ordertable2supp">ordertable2supp</a></code>,<code><a href="#topic+race3">race3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
W &lt;- hyper2(pnames=letters[1:5])
W1 &lt;- ggrl(W, 'a', letters[2:4],'e')  # 6-element list
W2 &lt;- ggrl(W, 'b', letters[3:5],'a')  # 6-element list

like_single_list(equalp(W1),W1)
like_series(equalp(W1),list(W1,W2))

if(FALSE){  # takes too long
# run 10 races:
r1 &lt;- rrank(10,p=(7:1)/28)
colnames(r1) &lt;- letters[1:7]

# Likelihood function for r1:
W &lt;- rank_likelihood(r1)

# convert a rank table to a support function:
rank_likelihood(wikitable_to_ranktable(volvo_table))

H &lt;- hyper2()
for(i in 1:20){
  H &lt;- H + race(sample(letters[1:5],sample(3,1),replace=FALSE))
}
equalp.test(H) # should not be significant (null is true)

H1 &lt;- hyper2(pnames=letters[1:5])
H2 &lt;- choose_losers(H1,letters[1:4],letters[1:2])   # {a,b} vs {c,d}; {a,b} lost
maxplist(H2,control=list(maxit=1))  # control set to save time
}

</code></pre>

<hr>
<h2 id='gradient'>Differential calculus</h2><span id='topic+gradient'></span><span id='topic+gradientn'></span><span id='topic+hessian'></span><span id='topic+hessian_lowlevel'></span><span id='topic+is_ok_hessian'></span><span id='topic+bordered_hessian'></span><span id='topic+hessian_bordered'></span>

<h3>Description</h3>

<p>Given a <code>hyper2</code> object and a point in probability space,
function <code>gradient()</code> returns the gradient of the log-likelihood;
function <code>hessian()</code> returns the bordered Hessian matrix.  By
default, both functions are evaluated at the maximum likelihood estimate
for <code class="reqn">p</code>, as given by <code>maxp()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradient(H, probs=indep(maxp(H)))
hessian(H,probs=indep(maxp(H)),border=TRUE)
hessian_lowlevel(L, powers, probs, pnames,n) 
is_ok_hessian(M, give=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradient_+3A_h">H</code></td>
<td>
<p>A <code>hyper2</code> object</p>
</td></tr>
<tr><td><code id="gradient_+3A_l">L</code>, <code id="gradient_+3A_powers">powers</code>, <code id="gradient_+3A_n">n</code></td>
<td>
<p>Components of a <code>hyper2</code> object</p>
</td></tr>
<tr><td><code id="gradient_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities</p>
</td></tr>
<tr><td><code id="gradient_+3A_pnames">pnames</code></td>
<td>
<p>Character vector of names</p>
</td></tr>
<tr><td><code id="gradient_+3A_border">border</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return the
bordered Hessian and <code>FALSE</code> meaning to return the Hessian
(warning: this option does not respect the unit sum constraint)</p>
</td></tr>
<tr><td><code id="gradient_+3A_m">M</code></td>
<td>
<p>A bordered Hessian matrix, understood to have a single
constraint (the unit sum) at the last row and column; the output of
<code>hessian(border=TRUE)</code></p>
</td></tr>
<tr><td><code id="gradient_+3A_give">give</code></td>
<td>
<p>Boolean with default <code>FALSE</code> meaning for function
<code>is_ok_hessian()</code> to return whether or not <code>M</code>
corresponds to a negative-definite  matrix, and <code>TRUE</code> meaning
to return more details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>gradient()</code> returns the gradient of the log-likelihood
function.  If the <code>hyper2</code> object is of size <code class="reqn">n</code>, then argument
<code>probs</code> may be a vector of length <code class="reqn">n-1</code> or <code class="reqn">n</code>; in the
former case it is interpreted as <code>indep(p)</code>.  In both cases, the
returned gradient is a vector of length <code class="reqn">n-1</code>.
The function returns the derivative of the loglikelihood with respect to
the <code class="reqn">n-1</code> independent components of
<code class="reqn">\left(p_1,\ldots,p_n\right)</code>, namely
<code class="reqn">\left(p_1,\ldots,p_{n-1}\right)</code>.  The fillup
value <code class="reqn">p_n</code> is calculated as
<code class="reqn">1-\left(p_1+\cdots + p_{n-1}\right)</code>.
</p>
<p>Function <code>gradientn()</code> returns the gradient of the loglikelihood
function but ignores the unit sum constraint.  If the <code>hyper2</code>
object is of size <code class="reqn">n</code>, then argument <code>probs</code> must be a vector
of length <code class="reqn">n</code>, and the function returns a named vector of length
<code class="reqn">n</code>.  The last element of the vector is not treated differently from
the others; all <code class="reqn">n</code> elements are treated as independent.  The sum
need not equal one.
</p>
<p>Function <code>hessian()</code> returns the <dfn>bordered Hessian</dfn>, a matrix
of size <code class="reqn">n+1\times n+1</code>, which is useful when using
Lagrange's method of undetermined multipliers.  The first row and column
correspond to the unit sum constraint, <code class="reqn">\sum p_1=1</code>.
Row and column names of the matrix are the <code>pnames()</code> of the
<code>hyper2</code> object, plus &ldquo;<code>usc</code>&rdquo; for &ldquo;Unit Sum
Constraint&rdquo;.
</p>
<p>The unit sum constraint borders could have been added with idiom
<code>magic::adiag(0,pad=1,hess)</code>, which might be preferable.
</p>
<p>Function <code>is_ok_hessian()</code> returns the result of the second
derivative test for the maximum likelihood estimate being a local
maximum on the constraint hypersurface.  This is a generalization of the
usual unconstrained problem, for which the test is the Hessian's being
negative-definite.
</p>
<p>Function <code>hessian_lowlevel()</code> is a low-level helper function that
calls the C++ routine.
</p>
<p>Further examples and discussion is given in file
<code>inst/gradient.Rmd</code>.  See also the discussion at <a href="#topic+maxp">maxp</a> on the
different optimization routines available.
</p>


<h3>Value</h3>

<p>Function <code>gradient()</code> returns a vector of length <code class="reqn">n-1</code> with
entries being the gradient of the log-likelihood with respect to the
<code class="reqn">n-1</code> independent components of
<code class="reqn">\left(p_1,\ldots,p_n\right)</code>, namely
<code class="reqn">\left(p_1,\ldots,p_{n-1}\right)</code>.  The fillup
value <code class="reqn">p_n</code> is calculated as
<code class="reqn">1-\left(p_1,\ldots,p_{n-1}\right)</code>.
</p>
<p>If argument <code>border</code> is <code>TRUE</code>, function <code>hessian()</code>
returns an <code class="reqn">n</code>-by-<code class="reqn">n</code> matrix of second derivatives; the borders
are as returned by <code>gradient()</code>.  If <code>border</code> is <code>FALSE</code>,
ignore the fillup value and return an <code class="reqn">n-1</code>-by-<code class="reqn">n-1</code> matrix.
</p>
<p>Calling <code>hessian()</code> at the evaluate will not return exact zeros for
the constraint on the fillup value; <code>gradient()</code> is used and this
does not return exactly zeros at the evaluate.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(chess)
p &lt;- c(1/2,1/3)
delta &lt;- rnorm(2)/1e5  # delta needs to be quite small

deltaL  &lt;- loglik(p+delta,chess) - loglik(p,chess)
deltaLn &lt;- sum(delta*gradient(chess,p + delta/2))   # numeric

deltaL - deltaLn  # should be small [zero to first order]

H &lt;- hessian(icons)
is_ok_hessian(H)

</code></pre>

<hr>
<h2 id='handover'>Dataset on communication breakdown in handover between physicians</h2><span id='topic+handover'></span><span id='topic+handover_table'></span><span id='topic+handover_maxp'></span><span id='topic+handoff'></span><span id='topic+malpractice'></span>

<h3>Description</h3>

<p>Object <code>handover</code> is a likelihood function corresponding to a
dataset arising from 69 medical malpractice claims and concerns
handover (or hand-off) between physicians.  This dataset was analysed
by Lin et al. (2009), and further analysed by Altham and Hankin
(2010).  The computational methods are presented in the (unmaintained)
<span class="pkg">hyperdirichlet</span> and <span class="pkg">aylmer</span> packages and a further
discussion is given in the &ldquo;integration&rdquo; vignette of the
<span class="pkg">hyper2</span> package.  The original dataset is <code>handover_table</code>,
a three-by-three matrix of counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(handover)</code></pre>


<h3>Details</h3>

<p>These objects can be generated by running script
<code>inst/handover.Rmd</code>, which includes some further discussion and
technical documentation, and creates file <code>handover.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>References</h3>


<ul>
<li><p> Y. Lin and S. Lipsitz and D. Sinha and A. A. Gawande and
S. E. Regenbogen and C. C. Greenberg, 2009. &ldquo;Using Bayesian
<code class="reqn">p</code>-values in a <code class="reqn">2\times 2</code> table of matched pairs with
incompletely classified data&rdquo;. <em>Journal of the Royal Statistical
Society, Series C</em>, 58:2
</p>
</li>
<li><p> P. M. E. Altham and R. K. S. Hankin, 2010. &ldquo;Using
recently developed software on a <code class="reqn">2\times 2</code> table of
matched pairs with incompletely classified data&rdquo;.  <em>Journal of
the Royal Statistical Society, series C</em>, 59(2): 377-379
</p>
</li>
<li><p> R. K. S. Hankin 2010. &ldquo;A generalization of the Dirichlet
distribution&rdquo;.   <em>Journal of Statistical software</em>, 33:11
</p>
</li>
<li><p> L. J. West and R. K. S. Hankin 2008. &ldquo;Exact tests for
two-way contingency tables with structural zeros&rdquo;.   <em>Journal
of Statistical software</em>, 28:11
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(handover)
maxp(handover)
</code></pre>

<hr>
<h2 id='head.hyper2'>First few terms of a  distribution</h2><span id='topic+head.hyper2'></span>

<h3>Description</h3>

<p>First few terms in a hyperdirichlet distribution</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyper2'
head(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.hyper2_+3A_x">x</code></td>
<td>
<p>Object of class <code>hyper2</code></p>
</td></tr>
<tr><td><code id="head.hyper2_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>head()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is  <code>x[head(brackets(x), ...)]</code></p>


<h3>Value</h3>

<p>Returns a <code>hyper2</code> object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- zipf(5)
names(p) &lt;- letters[1:5]
H &lt;- rank_likelihood(rrank(20,p))
head(H)


</code></pre>

<hr>
<h2 id='hepatitis'>Hepatitis dataset discussed by Agresti</h2><span id='topic+hepatitis'></span><span id='topic+hepatitis_table'></span><span id='topic+hepatitis_maxp'></span><span id='topic+hepatitis_count'></span>

<h3>Description</h3>

<p>A dataset considered by Agresti</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hepatitis)</code></pre>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood function</p>


<h3>Details</h3>

<p>Object <code>hepatitis_table</code> is drawn from Agresti, table 12.16, page
533.  Object <code>hepatitis</code> is a likelihood function of class
<code>lsl</code> and <code>hepatitis_maxp</code> a pre-calculated evaluate.
</p>
<p>These objects can be generated by running script <code>inst/hepatitis.Rmd</code>,
which includes some further discussion and technical documentation, and
creates file <code>hepatitis.rda</code> which resides in the <code>data/</code>
directory.
</p>


<h3>References</h3>

<p>A. Agresti, 2002.  &quot;Categorical data analysis&quot;.  John Wiley and
Sons. Table 13.1, p542.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+race3">race3</a></code>,<code><a href="#topic+hepatitis">hepatitis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pie(hepatitis_maxp)
</code></pre>

<hr>
<h2 id='hyper2'>
Basic functions in the hyper2 package
</h2><span id='topic+hyper2'></span><span id='topic+brackets'></span><span id='topic+brackets.hyper2'></span><span id='topic+powers'></span><span id='topic+powers.hyper2'></span><span id='topic+powers+3C-'></span><span id='topic+powers+3C-.hyper2'></span><span id='topic+pnames'></span><span id='topic+pnames.hyper2'></span><span id='topic+pnames.suplist'></span><span id='topic+pnames+3C-'></span><span id='topic+pnames+3C-.hyper2'></span><span id='topic+size'></span><span id='topic+size.hyper2'></span><span id='topic+is.hyper2'></span><span id='topic+as.hyper2'></span><span id='topic+is_valid_hyper2'></span><span id='topic+is_constant'></span>

<h3>Description</h3>

<p>Basic functions in the hyper2 package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper2(L=list(), d=0, pnames)
## S3 method for class 'hyper2'
brackets(H)
## S3 method for class 'hyper2'
powers(H)
## S3 method for class 'hyper2'
pnames(H)
## S3 method for class 'suplist'
pnames(H)
size(H)
as.hyper2(L,d,pnames)
is.hyper2(H)
is_valid_hyper2(L,d,pnames)
is_constant(H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyper2_+3A_h">H</code></td>
<td>
<p>A hyper2 object</p>
</td></tr>
<tr><td><code id="hyper2_+3A_l">L</code></td>
<td>
<p>A list of character vectors whose elements specify
the brackets of a hyper2 object</p>
</td></tr>
<tr><td><code id="hyper2_+3A_d">d</code></td>
<td>
<p>A vector of powers; <code>hyper2()</code> recycles <em>only if</em>
<code>d</code> is of length 1</p>
</td></tr>
<tr><td><code id="hyper2_+3A_pnames">pnames</code></td>
<td>

<p>A character vector specifying the names of <code class="reqn">p_1</code> through <code class="reqn">p_n</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are the basic functions of the hyper2 package.  Function
<code>hyper()</code> is the low-level creator function; <code>as.hyper2()</code> is
a bit more user-friendly and attempts to coerce its arguments into a
suitable form; for example, a matrix is interpreted as rows of brackets.
</p>
<p>Functions <code>pnames()</code> and <code>pnames&lt;-()</code> are the accessor and
setter methods for the player names.  Length-zero character strings are
acceptable player names.  The setter method <code>pnames&lt;-()</code> can be
confusing.  Idiom such as <code>pnames(H) &lt;- value</code> does not change the
likelihood function of <code>H</code> (except possibly its domain).  When
called, it changes the <code>pnames</code> internal vector, and will throw an
error if any element of <code>c(brackets(H))</code> is not present in
<code>value</code>.  It has two uses: firstly, to add players who do not
appear in the brackets; and secondly to rearrange the <code>pnames</code>
vector (the canonical use-case is <code>pnames(H) &lt;- rev(pnames(H))</code>).
If you want to change the player names, use <code>psubs()</code> to substitute
players for other players.
</p>
<p>Function <code>is_valid_hyper2()</code> tests for valid input, returning a
Boolean.  This function returns an error if a bracket contains a
repeated element, as in <code>hyper2(list(c("a","a")),1)</code>.
</p>
<p>Note that it is perfectly acceptable to have an element of
<code>pnames</code> that is not present in the likelihood function (this would
correspond to having no information about that particular player).
</p>
<p>Function <code>size()</code> returns the (nominal) length <code class="reqn">n</code> of
nonnegative vector <code class="reqn">p=\left(p_1,\ldots,p_n\right)</code>
where <code class="reqn">p_1+\cdots+p_n=1</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops.hyper2">Ops.hyper2</a></code>,
<code><a href="#topic+Extract.hyper2">Extract.hyper2</a></code>,
<code><a href="#topic+loglik">loglik</a></code>,
<code><a href="#topic+hyper2-package">hyper2-package</a></code>
<code><a href="#topic+psubs">psubs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>o &lt;- hyper2(list("a","b","c",c("a","b"),letters[1:3]),1:5) 

# Verify that the MLE is invariant under reordering
pnames(icons) &lt;- rev(pnames(icons))
maxp(icons) - icons_maxp # should be small

</code></pre>

<hr>
<h2 id='hyper3'>Weighted probability vectors: <code>hyper3</code> objects</h2><span id='topic+hyper3'></span><span id='topic+as.hyper3'></span><span id='topic+hyper3_to_hyper2'></span><span id='topic+as.namedvectorlist'></span><span id='topic+assign_lowlevel3'></span><span id='topic+hyper3_bw'></span><span id='topic+hyper3_nv'></span><span id='topic+hyper3_m'></span><span id='topic+is.hyper3'></span><span id='topic+is_ok_weightedplayers'></span><span id='topic+is_valid_hyper3'></span><span id='topic+loglik_single_redundant'></span><span id='topic+maxp3'></span><span id='topic+list2nv'></span><span id='topic+overwrite_lowlevel3'></span><span id='topic+powers+3C-.hyper3'></span><span id='topic+pnames+3C-.hyper3'></span><span id='topic+weights'></span><span id='topic+weights.hyper3'></span><span id='topic+setweight'></span><span id='topic+as.weight'></span>

<h3>Description</h3>

<p>Objects of class <code>hyper3</code> are a generalization of <code>hyper2</code> objects
that allow the brackets to contain weighted probabilities.
</p>
<p>As a motivating example, suppose two players with Bradley-Terry
strengths <code class="reqn">p_1,p_2</code> play chess where we quantify the first-mover
advantage with a term <code class="reqn">\lambda</code>.  If <code class="reqn">p_1</code> plays
white <code class="reqn">a+b</code> times with <code class="reqn">a</code> wins and <code class="reqn">b</code> losses, and
plays black <code class="reqn">c+d</code> times with <code class="reqn">c</code> wins and <code class="reqn">d</code>
losses, then a sensible likelihood function might be
</p>
<p style="text-align: center;"><code class="reqn">
  \left(\frac{\lambda p_1}{\lambda p_1 + p_2}\right)^{a}
  \left(\frac{p_2        }{\lambda p_1 + p_2}\right)^{b}
  \left(\frac{p_1        }{p_1 + \lambda p_2}\right)^{c}
  \left(\frac{\lambda p_2}{p_1 + \lambda p_2}\right)^{d}
  </code>
</p>

<p>If <code class="reqn">a=1,b=2,c=3,d=4</code> and <code class="reqn">\lambda=1.3</code> appropriate
package idiom might be:
</p>
<pre>

H &lt;- hyper3()
H[c(p1=1.3)]      %&lt;&gt;% inc(1) # a=1
H[c(p2=1)]        %&lt;&gt;% inc(2) # b=2
H[c(p1=1.3,p2=1)] %&lt;&gt;% dec(3) # a+b=1+2=3
H[c(p1=1)]        %&lt;&gt;% inc(3) # c=3
H[c(p2=1.3)]      %&lt;&gt;% inc(4) # d=4
H[c(p1=1,p2=1.3)] %&lt;&gt;% dec(7) # c+d=3+4=7
H
&gt; log( (p1=1)^3 * (p1=1, p2=1.3)^-7 * (p1=1.3)^1 * (p1=1.3, p2=1)^-3 *
(p2=1)^2 * (p2=1.3)^4)
</pre>
<p>The general form of terms of a <code>hyper3</code> object would be
<code class="reqn">\left(w_1p_1+\cdots+w_rp_r\right)^{\alpha}</code>; the
complete object would be
</p>
<p style="text-align: center;"><code class="reqn">
  \mathcal{L}\left(p_1,\ldots,p_n\right)=
  \prod_{j=1}^N\left(\sum_{i=1}^n
  w_{ij}p_i\right)^{\alpha_i}
  </code>
</p>

<p>where we understand that <code class="reqn">p_n=1-\sum_{i=1}^{n-1}p_i</code>;
many of the weights might be zero.  We see that the weights
<code class="reqn">w_{ij}</code> may be arranged as a matrix and this form is taken
by function <code>hyper3_m()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyper3(B = list(), W = list(), powers = 0, pnames)
hyper3_bw(B = list(), W = list(), powers = 0, pnames)
hyper3_nv(L=list(),powers=0,pnames)
hyper3_m(M,p,stripzeros=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyper3_+3A_b">B</code></td>
<td>
<p>A list of brackets</p>
</td></tr>
<tr><td><code id="hyper3_+3A_w">W</code></td>
<td>
<p>A list of weights</p>
</td></tr>
<tr><td><code id="hyper3_+3A_l">L</code></td>
<td>
<p>A list of named vectors</p>
</td></tr>
<tr><td><code id="hyper3_+3A_powers">powers</code></td>
<td>
<p>Numeric vector of powers</p>
</td></tr>
<tr><td><code id="hyper3_+3A_pnames">pnames</code></td>
<td>
<p>Character vector of player names</p>
</td></tr>
<tr><td><code id="hyper3_+3A_m">M</code></td>
<td>
<p>Matrix of weights, column names being player names</p>
</td></tr>
<tr><td><code id="hyper3_+3A_p">p</code></td>
<td>
<p>Vector of powers, length equal to <code>ncol(M)</code></p>
</td></tr>
<tr><td><code id="hyper3_+3A_stripzeros">stripzeros</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to silently
remove all-zero rows of <code>M</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Function <code>hyper3()</code> is the user-friendly creation method,
which dispatches to a helper function depending on its arguments.
</p>
</li>
<li><p> Function <code>hyper3_bw()</code> takes a list of brackets
(character vectors) and a list of weights (numeric vectors)  and
returns a <code>hyper3</code> object.
</p>
</li>
<li><p> Function <code>hyper3_nv()</code> takes a list of named vectors and
returns a <code>hyper3</code> object.
</p>
</li>
<li><p> Function <code>hyper3_m()</code> takes a matrix with rows being the
brackets (entries are weights) and a numeric vector of powers.
</p>
</li>
<li><p> Function <code>evaluate3()</code> is a low-level helper function
that evaluates a log-likelihood at a point in probability space.
Don't use this: use the user-friendly <code>loglik()</code> instead, which
dispatches to <code>evaluate3()</code>.
</p>
</li>
<li><p> Function <code>maxp3()</code> is a placeholder (it is not yet
written).  But the intention is that it will maximize the
log-likelihood of a <code>hyper3</code> object over the Bradley Terry
strengths <em>and</em> any weights given.  This might not be possible
as envisaged right now; I present some thoughts in
<code>inst/kka.Rmd</code>.
</p>
</li>
<li><p> Function <code>list2nv()</code> converts a list of character vectors
into a named vector suitable for use as argument <code>e</code> of
function <code>cheering3()</code>.  It is used in
<code>inst/global_liveability_ranking.Rmd</code>.
</p>
</li>
<li><p> Function <code>as.namedvectorlist()</code> takes a <code>hyper3</code>
object and returns a disoRdered list of named vectors corresponding
to the brackets and their weights.
</p>
</li>
<li><p> Function <code>setweight()</code> alters the weight of every
occurrence of a set of players.  It is vectorised, so
<code>setweight(H,c("a","b"),88:89)</code> sets the weight of <code>a</code> to
88 and <code>b</code> to 89.  Replacement methods are defined, so
&ldquo;<code>H["a"] &lt;- as.weight(3)</code>&rdquo; will set the weight of every
occurrence of player <code>a</code> to 3.  If <code>H</code> is a <code>hyper2</code>
object, it will be coerced to <code>hyper3</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Generally return or deal with <code>hyper3</code> objects
</p>


<h3>Note</h3>

<p>Functionality for <code>hyper3</code> objects is generally indicated by adding
a &ldquo;<code>3</code>&rdquo; to function names, eg <code>gradient()</code> goes to
<code>gradient3()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyper2">hyper2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

hyper3(B=list("a",c("a","b"),"b"),W=list(1.2,c(1.2,1),1),powers=c(3,4,-7))
hyper3(list(c(a=1.2),c(b=1),c(a=1.2,b=1)),powers=c(3,4,-7))
## Above two objects should be identical.

## Third method, send a matrix:
M &lt;- matrix(rpois(15,3),5,3)
colnames(M) &lt;- letters[1:3]
hyper3(M,c(2,3,-1,-5,1))   # second argument interpreted as powers



## Standard way to generate a hyper3 object is to create an empty object
## and populate it using the replacement methods:

a &lt;- hyper3()  # default creation method [empty object]

a[c(p1=1.3)] &lt;- 5
a[c(p2=1  )] &lt;- 2
a[c(p1=1.3,p2=1)] &lt;- -7
a

chess3  # representative simple hyper3 object

H1 &lt;- rankvec_likelihood(letters[sample(6)])
H2 &lt;- rankvec_likelihood(letters[sample(6)])
H1["a"] &lt;- as.weight(1.2)         # "a" has some disadvantage in H1
H1[c("b","c")] &lt;- as.weight(2:3)  # "b" and "c" have some advantage in H1
H2[c("c","d")] &lt;- as.weight(1.5)  # "c" and "d" have some advantage in H2
H1+H2

</code></pre>

<hr>
<h2 id='icons'>Dataset on climate change due to O'Neill</h2><span id='topic+icons'></span><span id='topic+icons_matrix'></span><span id='topic+icons_table'></span><span id='topic+icons_maxp'></span><span id='topic+oneill'></span>

<h3>Description</h3>

<p>Object <code>icons_matrix</code> is a matrix of nine rows and six columns,
one column for each of six icons relevant to climate change.  The
matrix entries show the number of respondents who indicated which icon
they found most concerning.  The nine rows show different classes of
respondents who were exposed to different subsets (of size four) of
the six icons.
</p>
<p>The columns correspond to the different stimulus icons used, detailed
below.  An extensive discussion is given in West and Hankin 2008, and
Hankin 2010; an updated analysis is given in the <code>icons</code>
vignette.
</p>
<p>Object <code>icons</code> is the corresponding likelihood function, which
can be created with <code>saffy(icons_matrix)</code>.
</p>
<p>The object is used in <code>inst/ternaryplot_hyper2.Rmd</code> which shows a
ternary plot of random samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(icons)</code></pre>


<h3>Details</h3>

<p>The six icons were used in this study were:
</p>

<dl>
<dt>PB</dt><dd><p>polar bears, which face extinction through loss of ice
floe hunting grounds</p>
</dd>
<dt>NB</dt><dd><p>The Norfolk Broads, which flood due to intense rainfall
events</p>
</dd>
<dt>L</dt><dd><p>London flooding, as a result of sea level rise</p>
</dd>
<dt>THC</dt><dd><p>The Thermo-haline circulation, which may slow or stop as
a result of anthropogenic modification of the hydrological cycle</p>
</dd>
<dt>OA</dt><dd><p>Oceanic acidification as a result of anthropogenic emissions
of carbon dioxide</p>
</dd>
<dt>WAIS</dt><dd><p>The West Antarctic Ice Sheet, which is calving into the sea
as a result of climate change</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Source</h3>

<p>Data kindly supplied by Saffron O'Neill of the University of East Anglia
</p>


<h3>References</h3>


<ul>
<li><p> S. J. O'Neill and M. Hulme 2009. <em>An iconic approach for
representing climate change</em>.  Global Environmental Change,
19:402-410
</p>
</li>
<li><p> I. Lorenzoni and N. Pidgeon 2005. <em>Defining Dangers of
Climate Change and Individual Behaviour: Closing the Gap</em>. 
In  <em>Avoiding Dangerous Climate Change</em> (conference
proceedings), UK Met Office, Exeter, 1-3 February
</p>
</li>
<li><p> R. K. S. Hankin 2010. &ldquo;A generalization of the Dirichlet
distribution&rdquo;.   <em>Journal of Statistical software</em>, 33:11
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+matrix2supp">matrix2supp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(icons)
pie(icons_maxp)
equalp.test(icons)

</code></pre>

<hr>
<h2 id='increment'>Increment and decrement operators</h2><span id='topic+increment'></span><span id='topic+decrement'></span><span id='topic+trial'></span><span id='topic+inc'></span><span id='topic+dec'></span>

<h3>Description</h3>

<p>Syntactic sugar for incrementing and decrementing likelihood functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inc(H, val = 1)
dec(H, val = 1)
trial(winners,players,val=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="increment_+3A_h">H</code></td>
<td>
<p>A hyper2 object</p>
</td></tr>
<tr><td><code id="increment_+3A_winners">winners</code>, <code id="increment_+3A_players">players</code></td>
<td>
<p>Numeric or character vectors specifying the
winning team and the losing team</p>
</td></tr>
<tr><td><code id="increment_+3A_val">val</code></td>
<td>
<p>Numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A very frequent operation is to increment a single term in a hyper2
object.  If
</p>
<pre>
&gt; H &lt;- hyper2(list("b",c("a","b"),"c",c("b","c")),c(2,4,3,5))
&gt; H
a * (a + b)^4 * b^2 * (b + c)^5 * c^3
</pre>
<p>Suppose we wish to increment the power of <code>a+b</code>.  We could do:
</p>
<pre>
H[c("a","b")] &lt;- H[c("a","b")] + 1
</pre>
<p>(see the discussion of <code>hyper2_sum_numeric</code> at
<code>Ops.hyper2.Rd</code>).  Alternatively we could use <code>magrittr</code> pipes:
</p>
<pre>
H[c("a","b")] %&lt;&gt;% `+`(1)
</pre>
<p>But <code>inc</code> and <code>dec</code> furnish convenient idiom to accomplish the
same thing:
</p>
<pre>
H[c("a","b")] %&lt;&gt;% inc
</pre>
<p>Functions <code>inc</code> and <code>dec</code> default to adding or subtracting 1,
but other values can  be supplied:
</p>
<pre>
H[c("a","b")] %&lt;&gt;% inc(3)
</pre>
<p>Or even 
</p>
<pre>
H[c("a","b")] %&lt;&gt;% inc(H["a"])
</pre>
<p>The convenience function <code>trial()</code> takes this one step further and
increments the &lsquo;winning team&rsquo; and decrements the bracket
containing all players.  The winners are expected to be players.
</p>
<pre>
&gt; trial(c("a","b"),c("a","b","c"))
&gt; (a + b) * (a + b + c)^-1
</pre>
<p>Using <code>trial()</code> in this way ensures that the powers sum to zero.
</p>
<p>The <code>inc</code> and <code>dec</code> operators and the <code>trial()</code>
function are used in <code>inst/kka.Rmd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chess)

## Now suppose we observe an additional match, in which Topalov beats
## Anand.  To incorporate this observation into the LF:



trial("a",c("a","b"))

chess &lt;- chess + trial("Topalov",c("Topalov","Anand"))
</code></pre>

<hr>
<h2 id='interzonal'>1963 World Chess Championships</h2><span id='topic+interzonal'></span><span id='topic+interzonal_maxp'></span><span id='topic+interzonal_table'></span><span id='topic+interzonal_collusion'></span><span id='topic+interzonal_collusion_maxp'></span><span id='topic+curacao'></span><span id='topic+curacao3'></span><span id='topic+stockholm1962'></span><span id='topic+collusion'></span><span id='topic+interzonal_collusion'></span>

<h3>Description</h3>

<p>Likelihood functions for players' strengths in the fifth Interzonal
tournament which occurred as part of the 1963 Chess world Championships
in Stockholm, 1962.
</p>


<h3>Details</h3>

<p>(there are three chess datasets in the package, documented at
<code>interzonal.Rd</code> [the 1963 World championship], <code>kka.Rd</code>
[Karpov-Kasparov-Anand dataset], and <code>chess.Rd</code>
[rock-paper-scissors using Topalov-Anand-Karpov])
</p>
<p>The 1963 World Chess Championship was notable for allegations of Soviet
collusion.  Specifically, Fischer publicly alleged that certain Soviet
players had agreed in advance to draw all their games.  The championship
included an &ldquo;interzonal&rdquo; tournament in which 23 players competed
in Stockholm; and a &ldquo;Candidates&rdquo; tournament in which 8 players
competed in Curacao.
</p>
<p>Likelihood functions <code>interzonal</code> and <code>interzonal_collusion</code>
are created by files &lsquo;<span class="file">inst/interzonal.Rmd</span>&rsquo;, which is heavily
documented and include some analysis.  Object <code>interzonal</code> includes
a term for drawing, (&ldquo;<code>draw</code>&rdquo;), assumed to be the same for
all players; object <code>interzonal_collusion</code> includes in addition to
<code>draw</code>, a term for the drawing in Soviet-Soviet matches,
&ldquo;<code>coll</code>&rdquo;.
</p>
<p>Some other analysis is given in files
<code>inst/curacao11962_threeplayers.R</code> and
<code>inst/curacao1962_threeplayers_rest_monster.Rmd</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chess">chess</a></code>,<code><a href="#topic+karpov_kasparov_anand">karpov_kasparov_anand</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pie(interzonal_maxp)

# samep.test(interzonal,c("Fischer","Geller")) # takes too long
</code></pre>

<hr>
<h2 id='javelin'>Javelin dataset</h2><span id='topic+javelin'></span><span id='topic+javelin1'></span><span id='topic+javelin2'></span><span id='topic+javelin_vector'></span><span id='topic+javelin_maxp'></span><span id='topic+javelin1_maxp'></span><span id='topic+javelin2_maxp'></span><span id='topic+javelin_table'></span>

<h3>Description</h3>

<p>Results from the men's javelin, 2020 Summer Olympics.
</p>

<ul>
<li> <p><code>javelin_table</code>, a dataframe in the form of an
&ldquo;attempts table&rdquo;, detailing the throw distances of eight
competitors (diacritics have been removed) for each of six throws
</p>
</li>
<li> <p><code>javelin1</code> and <code>javelin2</code> Support functions
corresponding to the weighted Plackett-Luce likelihood.  The suffix
&ldquo;1&rdquo; means that no-throws are counted as losing attempts;
suffix &ldquo;2&rdquo; means that no-throws are ignored.
</p>
</li>
<li> <p><code>javelin1_maxp</code> and <code>javelin2_maxp</code> are the
corresponding maximum likelihood estimates for the players'
strengths
</p>
</li>
<li><p>javelin_vector is a named vector with elements being the
throw distances and names being the thrower
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(javelin)</code></pre>


<h3>Format</h3>

<p>As detailed above</p>


<h3>Details</h3>

<p>These objects can be generated by running script
<code>inst/javelin.Rmd</code>, which includes some further discussion and
technical documentation, and creates file <code>javelin.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attemptstable2supp3">attemptstable2supp3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pie(javelin1_maxp)
</code></pre>

<hr>
<h2 id='jester'>Jester dataset</h2><span id='topic+jester'></span><span id='topic+maxjest'></span><span id='topic+jokes'></span><span id='topic+humour'></span><span id='topic+humor'></span><span id='topic+jester_maxp'></span><span id='topic+jester_table'></span>

<h3>Description</h3>

<p>A likelihood function for the Jester datasets</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(jester)</code></pre>


<h3>Details</h3>

<p>Object <code>jester</code> is a likelihood function for the 91 jokes rated by
the first 150 respondents in file &lsquo;<span class="file">jester_dataset_1_3.zip</span>&rsquo;, taken
from Goldberg et al.  Object <code>jester_maxp</code> is the result of running
<code>maxp(jester)</code>.  The results table of (nearly) all jokes and
respondents is given as <code>jester_table</code> in which each row is a joke
and each column a respondent.
</p>
<p>The dataset is interesting because it has been analysed by many workers,
including Goldberg, for patterns; here I assume that all the respondents
behave identically (but randomly).  It is included here because it is a
very severe numerical challenge in the context of the <code>hyper2</code>
package.  I am not convinced that <code>maxjest</code> is even close to the
true evaluate.
</p>
<p>Objects <code>jester</code>, <code>jester_table</code>, and <code>jester_maxp</code> can
be generated by running script &lsquo;<span class="file">inst/jester.Rmd</span>&rsquo;, which includes
some further technical documentation.  This file takes about 10 minutes
to run.
</p>


<h3>References</h3>

<p>Eigentaste: A Constant Time Collaborative Filtering Algorithm.  Ken
Goldberg, Theresa Roeder, Dhruv Gupta, and Chris
Perkins. <em>Information Retrieval</em>, 4(2), 133-151. July 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# maxp(jester)  # takes too long

# Note that the possibly poor identification of the evaluate
#  nevertheless allows us to reject the null of equality:

(LAM &lt;- -2*(loglik(equalp(jester),jester)-loglik(jester_maxp,jester)))
pval &lt;- pchisq(LAM,df=size(jester),lower.tail=FALSE)


</code></pre>

<hr>
<h2 id='karate'>Karate dataset</h2><span id='topic+karate'></span><span id='topic+karate_table'></span><span id='topic+karate_maxp'></span><span id='topic+karate_zermelo'></span>

<h3>Description</h3>

<p>Dataset from the 2018 World Karate Championships, men's 67kg.  It is
an example of a dataset with too many degrees of freedom to be
analysed easily by the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(karate)</code></pre>


<h3>Details</h3>

<p>Object <code>karate_table</code> is a dataframe of results showing results
from the 2018 World Karate Championships, men's 67kg; <code>karate</code> is
the associated likelihood function.  There are two maximum likelihood
estimates given; <code>karate_maxp</code>, the evaluate as returned by
<code>maxp()</code>, and <code>karate_maxp</code>, returned by <code>zermelo()</code> [the
value given by <code>maxp()</code> itself is less likely].
</p>
<p>These objects can be generated by running script <code>inst/karate.Rmd</code>,
which includes some further discussion and technical documentation and
creates file <code>karate.rda</code> which resides in the <code>data/</code>
directory.
</p>


<h3>Note</h3>

<p>Table <code>karate_table</code> misses uninformative matches, that is,
competitions with 0-0 results.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/2018_World_Karate_Championships">https://en.wikipedia.org/wiki/2018_World_Karate_Championships</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zapweak">zapweak</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(karate)
</code></pre>

<hr>
<h2 id='karpov_kasparov_anand'>Karpov, Kasparov, Anand</h2><span id='topic+karpov_kasparov_anand'></span><span id='topic+kka'></span><span id='topic+chess3'></span><span id='topic+chess3_maxp'></span><span id='topic+kka_3draws'></span><span id='topic+kka_3whites'></span><span id='topic+white_wins'></span><span id='topic+drawn_games'></span><span id='topic+black_wins'></span><span id='topic+plays_white_wins'></span><span id='topic+plays_white_draws'></span><span id='topic+plays_white_loses'></span><span id='topic+kka_array'></span>

<h3>Description</h3>

<p>Data of three chess players: Karpov, Kasparov, and Anand.  Includes
two likelihood functions for the strengths of the players, and an
array of game results
</p>


<h3>Details</h3>

<p>(there are three chess datasets in the package, documented at
<code>interzonal.Rd</code> [the 1963 World championship], <code>kka.Rd</code>
[Karpov-Kasparov-Anand dataset], and <code>chess.Rd</code>
[rock-paper-scissors using Topalov-Anand-Karpov])
</p>
<p>The strengths of chess players may be assessed using the generalized
Bradley-Terry model.  The <code>karpov_kasparov_anand</code> <code>hyper2</code>
likelihood function allows one to estimate the players' strengths,
propensity to draw, and also the additional strength conferred by
playing white as personified by a draw monster and a white monster
<code>draw</code> and <code>white</code> respectively.
</p>
<p>Object <code>karpov_kasparov_anand</code> assumes that the draw potential
is the same for all three players; likelihood function
<code>kka_3draws</code> allows the propensity to draw to differ between
the three players.
</p>
<p>The reason that the players are different from those in the
<code>chess</code> dataset is that the original data does not seem to be
available any more.
</p>
<p>Dataset <code>kka</code> refers to scorelines of matches between three
chess players (Kasparov, Karpov, Anand).  It is a named numeric
vector with names such as
&lsquo;<code>karpov_plays_white_beats_kasparov</code>&rsquo; which has value
18: we have a total of 18 games between Karpov and Kasparov in which
Karpov played white and beat Kasparov.
</p>
<p>Object <code>chess3</code> is a simple <code>hyper3</code> object corresponding
to pairwise comparison with draws; <code>chess3_maxp</code> is the
evaluate, conditional on the estimated white-player advantage and
draw proclivity.  This object is created and discussed in
<code>inst/kka.Rmd</code>.  Array <code>kka_array</code> presents the same
information in a 3D array.
</p>
<p>All data drawn from <code>https://www.chessgames.com</code> (search for
&ldquo;Kasparov vs Karpov&rdquo;, etc).  Note that the database allows one
to sort by white wins or black wins (there is a &lsquo;refine search&rsquo;
tab at the bottom).  Some searches have more than one page of results.
Numbers here downloaded 17 February 2019.  Note that only
&lsquo;classical games&rsquo; are considered here (rapid and exhibition
games being ignored).
</p>
<p>These objects can be generated by running script
<code>inst/kka.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>kka.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chess">chess</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>karpov_kasparov_anand
# pie(maxp(karpov_kasparov_anand))  # takes ~10s

M &lt;- kka_array[,,1] + 1i*kka_array[,,3]
home_away(M)
home_away3(M,lambda=1.2)


</code></pre>

<hr>
<h2 id='keep'>Keep or discard players</h2><span id='topic+keep'></span><span id='topic+retain'></span><span id='topic+discard'></span><span id='topic+drop'></span><span id='topic+keep_flawed'></span><span id='topic+retain_flawed'></span><span id='topic+discard_flawed'></span><span id='topic+drop_flawed'></span><span id='topic+keep_flawed2'></span><span id='topic+discard_flawed2'></span>

<h3>Description</h3>

<p>Flawed functionality to keep or discard subsets of the players in
a <code>hyper2</code> object or order table.</p>


<h3>Usage</h3>

<pre><code class='language-R'>discard_flawed2(x, unwanted,...)
keep_flawed(H, wanted)
discard_flawed(H, unwanted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keep_+3A_h">H</code></td>
<td>
<p>A <code>hyper2</code> object</p>
</td></tr>
<tr><td><code id="keep_+3A_x">x</code></td>
<td>
<p>An order table</p>
</td></tr>
<tr><td><code id="keep_+3A_wanted">wanted</code>, <code id="keep_+3A_unwanted">unwanted</code></td>
<td>
<p>Players to keep or discard.  May be character
or integer or logical</p>
</td></tr>
<tr><td><code id="keep_+3A_...">...</code></td>
<td>
<p>Further arguments passed to
<code>wikitable_to_ranktable()</code>, notably <code>points</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Do not use these functions.  They are here as object lessons
in poor thinking.  To work with a subset of competitors, see the
example at <a href="#topic+as.ordertable">as.ordertable</a>.</strong>
</p>
<p>Functions <code>keep_flawed2()</code> and <code>discard_flawed2()</code> take an
order table and keep or discard specified rows, returning a reduced
order table.  This is not a trivial operation.
</p>
<p>Functions <code>keep_flawed()</code> and <code>discard_flawed()</code> will either
keep or discard players specified in the second argument.  It is not
clear to me that these functions have any reasonable probabilistic
interpretation and file <code>inst/retain.Rmd</code> gives a discussion.
</p>
<p>Given a wikitable or ordertable, it is possible to create a likelihood
function based on a subset of rows using the <code>incomplete=TRUE</code>
argument; see the example at <code>?ordertable2supp</code>.  But this method
is flawed too because it treats non-finishers as if they finished in
the order of their rows.
</p>
<p>Function <code>as.ordertable()</code> is the correct way to consider a
subset of players in a wikitable.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable2supp">ordertable2supp</a></code>,<code><a href="#topic+tidy">tidy</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
maxp(icons)
discard_flawed(icons,c("OA","WAIS"))

## Not run: # (takes too long)
data("skating")
maxp(skating)[1:4]      # numbers work, keep the first four skaters
maxp(keep_flawed(skating,pnames(skating)[1:4])) # differs!

## End(Not run)


</code></pre>

<hr>
<h2 id='length.hyper2'>Length method for hyper2 objects</h2><span id='topic+length.hyper2'></span><span id='topic+length'></span>

<h3>Description</h3>

<p>Length method for hyper2 objects, being the number of different brackets
in the expression</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyper2'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.hyper2_+3A_x">x</code></td>
<td>
<p>hyper2 object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("oneill")
length(icons)
seq_along(icons)
</code></pre>

<hr>
<h2 id='loglik'>Log likelihood functions</h2><span id='topic+loglik'></span><span id='topic+loglik_single'></span><span id='topic+like_single_list'></span><span id='topic+like_series'></span>

<h3>Description</h3>

<p>Returns a log-likelihood for a given <code>hyper2</code> or <code>hyper3</code>
object at a specific point in probability space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik(p, H, log = TRUE)
loglik_single(p,H,log=TRUE)
like_single_list(p,Lsub)
like_series(p,L,log=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_+3A_h">H</code></td>
<td>
<p>An object of class <code>hyper2</code> or <code>hyper3</code></p>
</td></tr>
<tr><td><code id="loglik_+3A_p">p</code></td>
<td>
<p>A probability point.  See details</p>
</td></tr>
<tr><td><code id="loglik_+3A_log">log</code></td>
<td>
<p>Boolean with default <code>TRUE</code> meaning to return the
log-likelihood and <code>FALSE</code> meaning to return the likelihood</p>
</td></tr>
<tr><td><code id="loglik_+3A_l">L</code>, <code id="loglik_+3A_lsub">Lsub</code></td>
<td>
<p>A list of <code>hyper2</code> objects, or a list of list of
<code>loglik</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>loglik()</code> is a straightforward likelihood function.  It
can take a vector of length <code>n=size(H)</code> or <code>size(H)-1</code>; if
given the vector
<code class="reqn">p=\left(p_1,\ldots,p_{n-1}\right)</code> it
appends the fillup value, and then returns returns the (log)
likelihood.
</p>
<p>If <code>p</code> is a matrix, the rows are interpreted as probability
points.
</p>
<p>Function <code>loglik_single()</code> is a helper function that takes a
single point in probability space.  Functions
<code>like_single_list()</code> and <code>like_series()</code> are intended for
use with <code>ggrl()</code>.
</p>


<h3>Note</h3>

<p><em>Likelihood</em> is defined up to an arbitrary multiplicative
constant.  Log-likelihood (also known as <em>support</em>) is defined up
to an arbitrary additive constant.
</p>
<p>If function <code>loglik()</code> is given a probability vector of length
<code>n</code>, the vector must satisfy the unit sum constraint (up to a
small tolerance).  Also, it must be a named vector with names
(collectively) equal to the <code>pnames</code> of argument <code>H</code>.
</p>
<pre>
  &gt; pnames(chess)
  [1] "Topalov" "Anand"   "Karpov"  
  &gt; loglik(c(Topalov=0.7,Anand=0.2,Karpov=0.1),chess)
  [1] -69.45364
  &gt; loglik(c(Karpov=0.1,Topalov=0.7,Anand=0.2),chess)  # identical, just a different order
  [1] -69.45364
  </pre>
<p>But if given a vector of length <code>n-1</code> [e.g. the value of
<code>indep()</code>], then the names are ignored and the entries are
interpreted as the BT strengths of <code>pnames(H)[seq_len(n-1)]</code>:
</p>
<pre>
  &gt; loglik(c(0.7,0.2),chess)
  [1] -69.45364
  &gt; loglik(c(foo=0.7,bar=0.2),chess)  # names are ignored 
  [1] -69.45364
  </pre>
<p>(the above applies for <code>H</code> a <code>hyper2</code> or <code>hyper3</code>
object).
</p>
<p>Empty brackets are interpreted consistently: that is, zero whatever
the probability vector (although the print method is not perfect).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxp">maxp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chess)
loglik(c(1/3,1/3),chess)

loglik(rp(14,icons),icons)

## Not run:  # takes too long
like_series(masterchef_maxp,masterchef)
like_series(indep(equalp(masterchef)),masterchef)

## End(Not run)

W &lt;- hyper2(pnames=letters[1:6])
W1 &lt;- ggrl(W, 'a', letters[2:5],'f')              # 24-element list
W2 &lt;- ggrl(W, c('a','b'), c('c','d'),c('e','f'))  # 2^3=8 element list

like_single_list(rep(1/6,5),W1)      # information from first observation
like_series(rep(1/6,5),list(W1,W2))  # information from both observations

# hyper3 objects:
H3 &lt;- ordervec2supp3(letters[c(1,2,3,3,2,1,2)])
loglik(c(a=1,b=2,c=3)/6,H3)
loglik(c(a=1,c=3,b=2)/6,H3) # identical
</code></pre>

<hr>
<h2 id='masterchef'>Masterchef series 6</h2><span id='topic+masterchef'></span><span id='topic+MasterChef'></span><span id='topic+masterchef_maxp'></span><span id='topic+masterchef_constrained_maxp'></span>

<h3>Description</h3>

<p>Data from Australian Masterchef Series 6
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(masterchef)</code></pre>


<h3>Format</h3>

<p>Object <code>masterchef</code> is a list of <code>hyper2</code> objects;
<code>masterchef_pmax</code> and <code>masterchef_constrained_pmax</code> are named
vectors with unit sum.
</p>


<h3>Details</h3>

<p>The object is created using the code in <code>inst/masterchef.Rmd</code>,
which is heavily documented.  Not all the information available is
included in the likelihood function as some of the early rounds result
in an unmanageably large list.  Inclusion is controlled by Boolean
vector <code>doo</code>.
</p>
<p>The definitive source is the coloured table on the wiki page.
</p>


<h3>References</h3>

<p>Wikipedia contributors, &ldquo;MasterChef Australia (series 6),&rdquo;
Wikipedia, The Free Encyclopedia,
<a href="https://en.wikipedia.org/w/index.php?title=MasterChef_Australia_(series_6)&amp;oldid=758432561">https://en.wikipedia.org/w/index.php?title=MasterChef_Australia_(series_6)&amp;oldid=758432561</a>
(accessed January 5, 2017).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggrl">ggrl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
a1 &lt;- indep(equalp(masterchef[[1]]))            # equal strengths
a2 &lt;- indep(masterchef_maxp)               # MLE
a3 &lt;- indep(masterchef_constrained_maxp)   # constrained MLE

## Not run:  # takes too long
like_series(a1, masterchef)
like_series(a2, masterchef)
like_series(a3, masterchef)

## End(Not run)
</code></pre>

<hr>
<h2 id='matrix2supp'>Convert a matrix to a likelihood function</h2><span id='topic+matrix2supp'></span><span id='topic+matrix_to_HD'></span><span id='topic+saffy'></span><span id='topic+volley'></span>

<h3>Description</h3>

<p>Functions to convert matrix observations to likelihood functions.
Each row is an observation of some kind, and each column a player.
</p>
<p>Function <code>ordertable2supp()</code> is documented separately at
<code>ordertable2supp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saffy(M)
volley(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix2supp_+3A_m">M</code></td>
<td>
<p>A matrix of observations</p>
</td></tr></table>


<h3>Details</h3>

<p>Two functions are documented here:
</p>

<ul>
<li> <p><code>saffy()</code>, which converts a matrix of restricted choices
into a likelihood function; it is named for Saffron O'Neill.  The
canonical example would be Saffron's climate change dataset,
documented at <code>icons</code>.  Function <code>saffy()</code> returns the
appropriate likelihood function for the dataset.
</p>
</li>
<li> <p><code>volley()</code>, which converts a matrix of winning and losing
team members to a likelihood function.  The canonical example is the
volleyball dataset.  Each row is a volleyball game; each column is a
player.  An entry of 0 means &ldquo;on the losing side&rdquo;, an entry of
1 means &ldquo;on the winning side&rdquo;, and an entry of <code>NA</code> means
&ldquo;did not play&rdquo;.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+icons">icons</a></code>,<code><a href="#topic+volleyball">volleyball</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
icons == saffy(icons_table)  # should be TRUE

volley(volleyball_table) == volleyball # also should be TRUE

</code></pre>

<hr>
<h2 id='maxp'>Maximum likelihood estimation</h2><span id='topic+maxp'></span><span id='topic+maxplist'></span><span id='topic+maxp_lsl'></span><span id='topic+maxp_single'></span><span id='topic+maxp_single2'></span><span id='topic+maxp_simplex'></span><span id='topic+equalp'></span><span id='topic+allequal'></span><span id='topic+equalprobs'></span>

<h3>Description</h3>

<p>Find the maximum likelihood estimate for p, also equal probabilities</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxp(H, startp=NULL, give=FALSE, fcm=NULL, fcv=NULL, SMALL=1e-6, n=1,
   show=FALSE, justlikes=FALSE, ...)
maxplist(Hlist, startp=NULL, give=FALSE, fcm=NULL, fcv=NULL, SMALL=1e-6, ...)
maxp_single(H, startp=NULL, give=FALSE, fcm=NULL, fcv=NULL, SMALL=1e-6,
   maxtry=100, ...)
maxp_single2(H, startp=NULL, give=FALSE, fcm=NULL, fcv=NULL, SMALL=1e-6,
   maxtry=100, ...)
maxp_simplex(H, n=100, show=FALSE, give=FALSE, ...)
maxp_lsl(HLSL, startp = NULL, give = FALSE, fcm = NULL, fcv = NULL, SMALL=1e-6, ...)
equalp(H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxp_+3A_h">H</code></td>
<td>
<p>A <code>hyper2</code> or <code>hyper3</code> object</p>
</td></tr>
<tr><td><code id="maxp_+3A_hlist">Hlist</code></td>
<td>
<p>A list with elements all <code>hyper2</code> objects</p>
</td></tr>
<tr><td><code id="maxp_+3A_hlsl">HLSL</code></td>
<td>
<p>An <code>lsl</code> object</p>
</td></tr>
<tr><td><code id="maxp_+3A_startp">startp</code></td>
<td>
<p>A vector of probabilities specifying the start-point for
optimization; if a full unit-sum vector, then the fill-up value will
be removed by <code>indep()</code> (except for <code>maxp_lsl()</code>)</p>
</td></tr>
<tr><td><code id="maxp_+3A_give">give</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return just
the evaluate (including fillup), and <code>TRUE</code> meaning to return
the entire formal output of the optimization routine</p>
</td></tr>
<tr><td><code id="maxp_+3A_fcm">fcm</code>, <code id="maxp_+3A_fcv">fcv</code></td>
<td>
<p>Further problem-specific constraints</p>
</td></tr>
<tr><td><code id="maxp_+3A_n">n</code></td>
<td>
<p>Number of start points to use</p>
</td></tr>
<tr><td><code id="maxp_+3A_show">show</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to show successive
estimates</p>
</td></tr>
<tr><td><code id="maxp_+3A_justlikes">justlikes</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return just a
vector of estimated likelihoods</p>
</td></tr>
<tr><td><code id="maxp_+3A_small">SMALL</code></td>
<td>
<p>Numerical minimum for probabilities</p>
</td></tr>
<tr><td><code id="maxp_+3A_maxtry">maxtry</code></td>
<td>
<p>Integer specifying maximum number of times to try
<code>constrOptim()</code> with slightly differing start points, to avoid
a known <span class="rlang"><b>R</b></span> bug which reports <code>wmmin is not finite</code>, bugzilla
id 17703</p>
</td></tr>
<tr><td><code id="maxp_+3A_...">...</code></td>
<td>
<p>Further arguments which <code>maxp()</code> passes to
<code>constrOptim()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>maxp()</code> returns the maximum likelihood estimate for
<code>p</code>, which has the unit sum constraint implemented.
</p>
<p>Function <code>maxplist()</code> does the same but takes a list of
<code>hyper2</code> objects (for example, the output of <code>ggrl()</code>).
Note that <code>maxplist()</code> does not have access to the gradient of
the objective function, which makes it slow.
</p>
<p>If function <code>maxp()</code> is given a <code>suplist</code> object it
dispatches to <code>maxplist()</code>.
</p>
<p>Functions <code>maxp_single()</code> and <code>maxp_single2()</code> are helper
functions which perform a single constrained optimization using
<code>base::constrOptim()</code> or <code>alabama::constrOptim.nl()</code>
respectively.  The functions should produce identical (or at least
very similar) results.  They are used by <code>maxp()</code> and
<code>maxp_simplex()</code> which dispatch to either <code>maxp_single()</code> or
<code>maxp_single2()</code> depending on the value of option
<code>use_alabama</code>.  If <code>TRUE</code>, they will use (experimental)
<code>maxp_single2()</code>, otherwise (default) <code>maxp_single()</code>.
Function <code>maxp_single()</code> is prone to the &ldquo;wmmin not
finite&rdquo; bug [bugzilla id 17703] but on the other hand is a bit
slower.  I am not sure which one is better at this time.
</p>
<p>Function <code>maxp_simplex()</code> is intended for complicated or flat
likelihood functions where finding local maxima might be a problem.
It repeatedly calls <code>maxp_single()</code>, starting from a different
randomly chosen point in the simplex each time.  This function does
not take <code>fcm</code> or <code>fcv</code> arguments, it operates over the
whole simplex (hence the name).  Further arguments, <code>...</code>, are
passed to <code>maxp_single()</code>.
</p>
<p>The functions do not work for the <code>masterchef_series6</code> likelihood
function.  These require a bespoke optimization as shown in the
vignette.
</p>
<p>Function <code>equalp()</code> returns the value of <code class="reqn">p</code> for which all
elements are the same.
</p>
<p>In functions <code>maxp()</code> etc, arguments <code>fcm</code> and <code>fcv</code>
implement linear constraints to be passed to <code>constrOptim()</code>.
These constraints are in addition to the usual nonnegativity
constraints and unit-sum constraint, and are added to the <code>ui</code>
and <code>ci</code> arguments of <code>constrOptim()</code> with <code>rbind()</code>
and <code>c()</code> respectively.  The operative lines are in
<code>maxp_single()</code>:
</p>
<pre>
    UI &lt;- rbind(diag(nrow = n - 1), -1, fcm)
    CI &lt;- c(rep(SMALL, n - 1), -1 + SMALL, fcv)
  </pre>
<p>where in <code>UI</code>, the first <code class="reqn">n-1</code> rows enforce nonnegativity of
<code class="reqn">p_i</code>, <code class="reqn">1\leq p &lt; n</code>; row <code class="reqn">n</code> enforces
nonnegativity of the fillup value <code class="reqn">p_n</code>; and the remaining
(optional) rows enforce additional linear constraints.  Argument
<code>CI</code> is a vector with corresponding elements.
</p>
<p>Examples of their use are given in the &ldquo;icons&rdquo; vignette.
</p>


<h3>Note</h3>

<p>In manpages elsewhere, <code>n=2</code> is sometimes used.  Previous
advice was to use <code>n=10</code> or greater in production work, but I
now think this is overly cautious and <code>n=1</code> is perfectly
adequate unless the dimension of the problem is large.
</p>
<p>The (bordered) Hessian is given by function <code>hessian()</code>,
documented at <code>gradient.Rd</code>; use this to assess the
&ldquo;sharpness&rdquo; of the maximum.
</p>
<p>Function <code>maxp()</code> takes <code>hyper2</code> or <code>hyper3</code> objects
but it does not currently work with <code>lsl</code> objects; use
<code>maxp_lsl()</code>.
</p>
<p>The built-in datasets generally include a pre-calculated result of
running <code>maxp()</code>; thus hyper2 object <code>icons</code> and
<code>icons_maxp</code> are included in the same <code>.rda</code> file.
</p>
<p>Function <code>maxp()</code> can trigger a known <span class="rlang"><b>R</b></span> bug (bugzilla id 17703)
which reports &ldquo;<code>wmmin is not finite</code>&rdquo;.  Setting option
<code>use_alabama</code> to <code>TRUE</code> makes the package use a different
optimization routine.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+gradient">gradient</a></code>,<code><a href="#topic+fillup">fillup</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
maxp(icons)

W &lt;- hyper2(pnames=letters[1:5])
W1 &lt;- ggrl(W, 'a', letters[2:3],'d')  # W1 is a suplist object
## Not run: maxp(W1)  # takes a long time to maximize a suplist

</code></pre>

<hr>
<h2 id='moto'>MotoGP dataset</h2><span id='topic+moto'></span><span id='topic+motoGP'></span><span id='topic+motoGP_2019'></span><span id='topic+moto_table'></span><span id='topic+moto'></span><span id='topic+moto_maxp'></span>

<h3>Description</h3>

<p>Race results from the 2019 Grand Prix motorcycling season</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moto)</code></pre>


<h3>Details</h3>

<p>Object <code>moto_table</code> is a dataframe of results showing ranks of 28
drivers (riders?) in the 2019 FIM MotoGP World Championship.  The format
is standard, that is, can be interpreted by function
<code>ordertable2supp()</code> if the final points column is removed.  The
corresponding support function is <code>motoGP_2019</code>.
</p>
<p>These objects can be generated by running script <code>inst/moto.Rmd</code>,
which includes some further discussion and technical documentation and
creates file <code>moto.rda</code> which resides in the <code>data/</code>
directory.
</p>


<h3>Note</h3>

<p>Many drivers have names with diacritics, which have been removed from
the dataframe.
</p>


<h3>References</h3>

<p>Wikipedia contributors. (2020, February 8). 2019 MotoGP season. In
<em>Wikipedia, The Free Encyclopedia.</em> Retrieved 08:16, February 20,
2020, from <a href="https://en.wikipedia.org/w/index.php?title=2019_MotoGP_season&amp;oldid=939711064">https://en.wikipedia.org/w/index.php?title=2019_MotoGP_season&amp;oldid=939711064</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable2supp">ordertable2supp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pie(moto_maxp)
</code></pre>

<hr>
<h2 id='mult_grid'>Kronecker matrix product functionality</h2><span id='topic+mult_grid'></span><span id='topic+pair_grid'></span>

<h3>Description</h3>

<p>Peculiar version of <code>expand.grid()</code> for matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mult_grid(L)
pair_grid(a,b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mult_grid_+3A_l">L</code></td>
<td>
<p>List of matrices</p>
</td></tr>
<tr><td><code id="mult_grid_+3A_a">a</code>, <code id="mult_grid_+3A_b">b</code></td>
<td>
<p>Matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>pair_grid(a,b)</code> returns a matrix with each column of
<code>a</code> <code>cbind()</code>-ed to each column of <code>b</code>.
</p>
<p>Function <code>mult_grid()</code> takes a list of matrices; it is designed for
use by <code>ggrl()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggrl">ggrl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pair_grid(diag(2),diag(3))
mult_grid(lapply(1:4,diag))
</code></pre>

<hr>
<h2 id='NBA'>Basketball dataset</h2><span id='topic+NBA'></span><span id='topic+NBA_likelihood'></span><span id='topic+NBA_maxp'></span><span id='topic+NBA_table'></span><span id='topic+basketball'></span>

<h3>Description</h3>

<p>A point-by-point analysis of a basketball game
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NBA)</code></pre>


<h3>Details</h3>

<p>Dataset <code>NBA_table</code> is a dataframe contains a point-by-point
analysis of a basketball match.  Each row corresponds to a point scored.
The first column is the time of the score, the second is the number of
points scored, the third shows which team had possession at the start of
play, and the fourth shows which team scored.  The other columns show
the players.  Table entries show whether or not that particular player
was on the pitch when the point was scored.   
</p>
<p>Likelihood function <code>NBA</code> is a <code>hyper2</code> object that gives the
log-likelihood function for this dataset.  There is a player named
&ldquo;<code>possession</code>&rdquo; that is a reified entity representing the
effect of possession.
</p>
<p>Object <code>NBA_maxp</code> is not the result of running <code>maxp(NBA)</code>; it
was obtained by repeatedly running <code>maxp_simplex()</code> on a
fault-tolerant system [it triggers a known <span class="rlang"><b>R</b></span> bug, bugzilla id 17703,
giving a &ldquo;<code>wmmin not finite</code>&rdquo; error].  It is not clear to me
that likelihood function <code>NBA</code> has a well-defined global maximum.
</p>
<p>Object <code>NBA</code> poses difficulty for the numerical optimization
routines for some reason.
</p>
<p>Note that function <code>volley()</code> is not applicable because we need to
include possession.
</p>
<p>These objects can be generated by running script
<code>inst/NBA.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>NBA.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>References</h3>

<p><a href="https://www.espn.com/nba/playbyplay?gameId=400954514">https://www.espn.com/nba/playbyplay?gameId=400954514</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+volleyball">volleyball</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(NBA)
dotchart(NBA_maxp)

</code></pre>

<hr>
<h2 id='Ops.hyper2'>Arithmetic Ops Group Methods for hyper2 objects</h2><span id='topic+Ops.hyper2'></span><span id='topic+Ops'></span><span id='topic+hyper2_add'></span><span id='topic+hyper2_prod'></span><span id='topic+hyper2_sum_numeric'></span><span id='topic+sum.hyper2'></span>

<h3>Description</h3>

<p>Allows arithmetic operators &ldquo;<code>+</code>&rdquo;, &ldquo;<code>*</code>&rdquo; and
comparison operators &ldquo;<code>==</code>&rdquo; and &ldquo;<code>!=</code>&rdquo;, to be
used for hyper2 objects.
</p>
<p>Specifically, <code>H1 + H2</code> implements addition of two log-likelihood
functions, corresponding to incorporation of additional independent
observational data; and <code>n*H1</code> implements <code>H1+H1+...+H1</code>,
corresponding to repeated independent observations of the same data.
</p>
<p>There are no unary operations for this class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyper2'
Ops(e1, e2 = NULL)
## S3 method for class 'hyper2'
sum(x,...,na.rm=FALSE)
hyper2_add(e1,e2)
hyper2_sum_numeric(H,r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.hyper2_+3A_e1">e1</code>, <code id="Ops.hyper2_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>hyper2</code>, here interpreted as
hyperdirichlet distributions</p>
</td></tr>
<tr><td><code id="Ops.hyper2_+3A_x">x</code>, <code id="Ops.hyper2_+3A_...">...</code>, <code id="Ops.hyper2_+3A_na.rm">na.rm</code></td>
<td>
<p>In the <code>sum()</code> method, objects to be summed;
<code>na.rm</code> is currently ignored</p>
</td></tr>
<tr><td><code id="Ops.hyper2_+3A_h">H</code>, <code id="Ops.hyper2_+3A_r">r</code></td>
<td>
<p>In function <code>hyper2_sum_numeric()</code>, object <code>H</code> is
a <code>hyper2</code> object and <code>r</code> is a length-one real vector (a
number)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If two independent datasets have <code>hyper2</code> objects <code>H1</code> and
<code>H2</code>, then package idiom for combining these would be <code>H1+H2</code>;
the additive notation &ldquo;<code>+</code>&rdquo; corresponds to addition of the
support (or multiplication of the likelihood).  So <code>hyper2</code>
objects are better thought of as support functions than likelihood
functions; this is reflected in the print method which explicitly
wraps the likelihood function in a &ldquo;<code>log()</code>&rdquo;.
</p>
<p>Idiom <code>H1-H1</code> returns <code>H1 + (-1)*H2</code>, useful for investigating
the difference between likelihood functions arising from two different
observations, or different probability models.  An example is given in
<code>inst/soling.Rmd</code>.
</p>
<p>Testing for equality is not straightforward for two implementation
reasons.  Firstly, the object itself is stored internally as a
<code>stl</code> <code>map</code>, which does not store keys in any particular
order; and secondly, the <code>stl</code> <code>set</code> class is used for the
brackets.  A set does not include information about the order of its
elements; neither does it admit repeated elements.  See examples.
</p>
<p>Function <code>hyper2_sum_numeric()</code> is defined so that idiom like
<code>icons["L"] + 5</code> works as expected.  This means that
<code>icons["L"] &lt;- icons["L"] + 3</code> and <code>icons["L"] %&lt;&gt;%inc(3)</code>
work (without this, one has to type <code>icons["L"] &lt;-
  powers(icons["L"]) + 3</code>, which sucks).
</p>
<p>Raising a <code>hyper2</code> object to a power returns an error.
</p>


<h3>Value</h3>

<p>Returns a <code>hyper2</code> object or a Boolean.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chess2 &lt;- hyper2(list("Kasparov","Karpov",c("Kasparov","Karpov")),c(2,3,-5))

chess + chess2

maxp(chess+chess2)


</code></pre>

<hr>
<h2 id='Ops.hyper3'>Arithmetic Ops Group Methods for hyper3 objects</h2><span id='topic+Ops.hyper3'></span><span id='topic+hyper3_add'></span><span id='topic+hyper3_prod'></span><span id='topic+hyper3_sum_numeric'></span><span id='topic+hyper3_add'></span><span id='topic+sum.hyper3'></span><span id='topic+hyper3_equal'></span>

<h3>Description</h3>

<p>Allows arithmetic operators &ldquo;<code>+</code>&rdquo;, &ldquo;<code>*</code>&rdquo; and
comparison operators &ldquo;<code>==</code>&rdquo; and &ldquo;<code>!=</code>&rdquo;, to be
used for <code>hyper3</code> objects.
</p>
<p>Specifically, <code>H1 + H2</code> implements addition of two log-likelihood
functions, corresponding to incorporation of additional independent
observational data; and <code>n*H1</code> implements <code>H1+H1+...+H1</code>,
corresponding to repeated independent observations of the same data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyper3'
Ops(e1, e2 = NULL)
hyper3_add(e1,e2)
hyper3_prod(e1,n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.hyper3_+3A_e1">e1</code>, <code id="Ops.hyper3_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>hyper3</code></p>
</td></tr>
<tr><td><code id="Ops.hyper3_+3A_n">n</code></td>
<td>
<p>Numeric vector of length 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pretty much everything documented here is a straightforward translation
of the corresponding <code>hyper2</code> functionality.
</p>


<h3>Value</h3>

<p>Returns a <code>hyper3</code> object or a Boolean.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
H1 &lt;- hyper3(list(c(a=1.2),c(b=1),c(a=1.2,b=1)),powers=c(3,4,-7))
H2 &lt;- hyper3(list(c(a=1.2),c(b=1.2),c(a=2.2,b=1.2)),powers=c(2,3,-5))

H1
H2



</code></pre>

<hr>
<h2 id='ordertable'>Order tables</h2><span id='topic+ordertable'></span><span id='topic+order_table'></span>

<h3>Description</h3>

<p>Order tables</p>


<h3>Details</h3>

<p>The package makes extensive use of order tables and these are discussed
here together with a list of order tables available in the package as
data.  See also <code>ranktable.Rd</code>.
</p>
<p>Consider <code>pentathlon_table</code>:
</p>
<pre>
 &gt; pentathlon_table
              shooting fencing swimming riding running
Moiseev              5       1        1      6       5
Zadneprovskis        6       2        5      5       1
Capalini             4       6        2      3       4
Cerkovskis           3       3        7      7       2
Meliakh              1       7        4      1       6
Michalik             2       4        6      2       7
Walther              7       5        3      4       3
</pre>
<p>Although <code>pentathlon_table</code> is a dataset in the package, the source
dataset is also included in the <code>inst/</code> directory as file
<code>pentathlon.txt</code>; use idiom like
<code>read.table("inst/pentathlon.txt")</code> to load the order table.
</p>
<p>Object <code>pentathlon_table</code> is a representative example of an
ordertable.  Each row is a competitor, each column an event (venue,
judge, ...).  The first row shows Moiseev's ranking in shooting
(5th), fencing (1st), and so on.  The first column shows the ranks of
the competitors in shooting.  Thus Moiseev came fifth, Zadneprovskis
came 6th, and so on.
</p>
<p>However, to create a likelihood function we need ranks, not orders.  We
need to know, for a given event, who came first, who came second, and so
on (an extended discussion on the difference between rank and order is
given at <a href="#topic+rrank">rrank</a>).  We can convert from an order table to a rank
table using <code>ordertable_to_ranktable()</code> (see also
<code>ranktable.Rd</code>):
</p>
<pre>
&gt; ordertable_to_ranktable(pentathlon_table)
         c1            c2            c3         c4       c5           
shooting Meliakh       Michalik      Cerkovskis Capalini Moiseev      
fencing  Moiseev       Zadneprovskis Cerkovskis Michalik Walther      
swimming Moiseev       Capalini      Walther    Meliakh  Zadneprovskis
riding   Meliakh       Michalik      Capalini   Walther  Zadneprovskis
running  Zadneprovskis Cerkovskis    Walther    Capalini Moiseev      
         c6            c7        
shooting Zadneprovskis Walther   
fencing  Capalini      Meliakh   
swimming Michalik      Cerkovskis
riding   Moiseev       Cerkovskis
running  Meliakh       Michalik  
</pre>
<p>Above, we see the same data in a different format (an extended
discussion on the difference between rank and order is given in
<a href="#topic+rrank">rrank</a>).
</p>
<p>Many of the order tables in the package include entries that correspond
to some variation on &ldquo;did not finish&rdquo;.  Consider the <a href="#topic+volvo">volvo</a>
dataset:
</p>
<pre>
&gt; volvo_table_2014
           leg1 leg2 leg3 leg4 leg5 leg6 leg7 leg8 leg9
AbuDhabi      1    3    2    2    1    2    5    3    5
Brunel        3    1    5    5    4    3    1    5    2
Dongfeng      2    2    1    3  DNF    1    4    7    4
MAPFRE        7    4    4    1    2    4    2    4    3
Alvimedica    5    5    3    4    3    5    3    6    1
SCA           6    6    6    6    5    6    6    1    7
Vestas        4  DNF  DNS  DNS  DNS  DNS  DNS    2    6
</pre>
<p>In the above order table, we have <code>DNF</code> for &ldquo;did not finish&rdquo;
and <code>DNS</code> for &ldquo;did not start&rdquo;.  The <code>formula1</code> order
table has other similar entries such as <code>DSQ</code> for
&ldquo;disqualified&rdquo; and a discussion is given at
<code>ordertable2supp.Rd</code>.
</p>
<p>Links are given below to all the order tables in the package.  Note that
the table in <code>inst/eurovision.Rmd</code> (<code>wiki_matrix</code>) is not an
order table because no country is allowed to vote for itself.
</p>
<p>To coerce a table like the Volvo dataset shown above into an order table
[that is, replace <code>DNS</code> with zeros, and also force nonzero entries
to be contiguous], use <code>as.ordertable()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable2supp">ordertable2supp</a></code>,<code><a href="#topic+rrank">rrank</a></code>,
<code><a href="#topic+ranktable">ranktable</a></code>,<code><a href="#topic+as.ordertable">as.ordertable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ordertable_to_ranktable(soling_table)
ordertable2supp(soling_table) == soling  # should be TRUE


</code></pre>

<hr>
<h2 id='ordertable2points'>Calculate points from an order table</h2><span id='topic+ordertable2points'></span>

<h3>Description</h3>

<p>Given an order table and a schedule of points, calculate the points
awarded to each competitor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordertable2points(o, points,totals=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordertable2points_+3A_o">o</code></td>
<td>
<p>Order table</p>
</td></tr>
<tr><td><code id="ordertable2points_+3A_points">points</code></td>
<td>
<p>A numeric vector indicating number of points awarded for
first, second, third, etc placing</p>
</td></tr>
<tr><td><code id="ordertable2points_+3A_totals">totals</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return the
points for each player (row) and <code>FALSE</code> meaning to return the
entire table but with orders replaced with points scored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either an order table or a named numeric vector</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable">ordertable</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
points &lt;- c(25, 18, 15, 12, 10, 8, 6, 4, 2, 1, 0, 0)
o &lt;- as.ordertable(F1_table_2017)
ordertable2points(o,points)

ordertable2points(ranktable_to_ordertable(rrank(9,volvo_maxp)),1)

</code></pre>

<hr>
<h2 id='ordertable2supp'>Translate order tables to support functions</h2><span id='topic+ordertable2supp'></span><span id='topic+ordervec2supp'></span><span id='topic+ordervec2supp'></span><span id='topic+order_obs'></span><span id='topic+salad'></span>

<h3>Description</h3>

<p>Wikipedia gives a nice summary in table form of Formula 1 racing results
on pages like
<a href="https://en.wikipedia.org/wiki/2017_Formula_One_World_Championship">https://en.wikipedia.org/wiki/2017_Formula_One_World_Championship</a>
(at <em>World Drivers' Championship standings</em>) but the data format is
commonly used for many sports [see <code>ordertable.Rd</code>] and function
<code>ordertable2supp()</code> translates such tables into a <code>hyper2</code>
support function and also a order table.
</p>
<p>Both functions interpret zero to mean &ldquo;Did not finish&rdquo; (wikipedia
usually signifies DNF as a blank).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordertable2supp(x, noscore, incomplete=TRUE)
ordervec2supp(d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordertable2supp_+3A_x">x</code></td>
<td>
<p>Data frame, see details</p>
</td></tr>
<tr><td><code id="ordertable2supp_+3A_d">d</code></td>
<td>
<p>A named numeric vector giving order; zero entries are
interpreted as that competitor coming last (due to, e.g., not
finishing)</p>
</td></tr>
<tr><td><code id="ordertable2supp_+3A_incomplete">incomplete</code></td>
<td>
<p>Boolean, with <code>FALSE</code> meaning to insist that
each rank <code class="reqn">1,2,...,n</code> is present [zero entries mean &ldquo;did
not place&rdquo; irregardless].  The default <code>TRUE</code> allows for gaps.
This is useful if we are considering the first few lines of an
ordertable because there might be missing ranks.</p>
</td></tr>
<tr><td><code id="ordertable2supp_+3A_noscore">noscore</code></td>
<td>
<p>Character vector giving the abbreviations
for a non-finishing status such as &ldquo;did not finish&rdquo;
or &ldquo;disqualified&rdquo;.  A missing argument is interpreted as 
<code>c("Ret", "WD", "DNS", "DSQ", "DNP", "NC")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ordertable2supp()</code> is intended for use on order tables
such as found at <a href="https://en.wikipedia.org/wiki/2019_Moto3_season">https://en.wikipedia.org/wiki/2019_Moto3_season</a>.
This is a common format, used for Formula 1, motoGP, and other racing
sports.  Prepared text versions are available in the package in the
<code>inst/</code> directory, for example <code>inst/motoGP_2019.txt</code>.  Use
<code>read.table()</code> to create a data frame which can be interpreted by
<code>ordertable2supp()</code>.
</p>
<p>Function <code>ordervec2supp()</code> takes an order vector <code>d</code> and
returns the corresponding Plackett-Luce loglikelihood function as a
<code>hyper2</code> object.  It requires a named vector; names of the elements
are interpreted as names of the players.  Use argument <code>pnames</code> to
supply the players' names (see the examples).
</p>
<pre>
&gt; x &lt;- c(b=2,c=3,a=1,d=4,e=5) # a: 1st, b: 2nd, c: 3rd etc
&gt; ordervec2supp(x)
log( a * (a + b + c + d + e)^-1 * (a + b + d + e)^-1 * b * (b + d +
e)^-1 * c * (d + e)^-1 * e)
</pre>
<p style="text-align: center;"><code class="reqn">
\frac{a}{a+b+c+d+e}\cdot
\frac{b}{b+c+d+e}\cdot
\frac{c}{c+d+e}\cdot
\frac{d}{d+e}\cdot
\frac{e}{e}
</code>
</p>

<p>Zero entries mean &ldquo;did not finish&rdquo;:
</p>
<pre>
&gt; ordervec2supp(c(b=1,a=0,c=2))  # b: 1st, a: DNF, c: second
log((a + b + c)^-1 * (a + c)^-1 * b * c)
  </pre>
<p style="text-align: center;"><code class="reqn">
\frac{b}{a+b+c}\cdot
\frac{c}{a+c}
</code>
</p>

<p>Note carefully the difference between <code>ordervec2supp()</code> and
<code>rankvec_likelihood()</code>, which takes a character vector:
</p>
<pre>
&gt;  names(sort(x))
[1] "a" "b" "c" "d" "e"
&gt; rankvec_likelihood(names(sort(x)))
log( a * (a + b + c + d + e)^-1 * b * (b + c + d + e)^-1 * c * (c + d +
e)^-1 * d * (d + e)^-1)
&gt; rankvec_likelihood(names(sort(x))) == ordervec2supp(x)
[1] TRUE
&gt; 
</pre>
<p>Function <code>order_obs()</code> was used in the integer-indexed paradigm but
is obsolete in the name paradigm.  A short vignette applying
<code>ordervec2supp()</code> and <code>ordertable2supp()</code> to the <a href="#topic+salad">salad</a>
dataset of the <a href="https://CRAN.R-project.org/package=prefmod"><span class="pkg">prefmod</span></a> package [and further analysed in the
<a href="https://CRAN.R-project.org/package=PlackettLuce"><span class="pkg">PlackettLuce</span></a> package] is presented at <code>inst/salad.Rmd</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>hyper2</code> object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable">ordertable</a></code>,<code><a href="#topic+ordertable2supp3">ordertable2supp3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ordertable2supp(soling_table)

# competitors a-f, racing at two venues:
x &lt;- data.frame(
    venue1=c(1:5,"Ret"),venue2=c("Ret",4,"Ret",1,3,2),
    row.names=letters[1:6])

## First consider all competitors; incomplete=FALSE checks that all
## finishing competitors have ranks 1-n in some order for some n:

ordertable2supp(x,incomplete=FALSE)


## Now consider just a-d; must use default incomplete=TRUE as at venue2
## the second and third ranked competitors are not present in x[1:4,]:

ordertable2supp(x[1:4,])   





## Function ordervec2supp() is lower-level, used for order vectors:

a1 &lt;- c(a=2,b=3,c=1,d=5,e=4) # a: 2nd, b: 3rd, c: 1st, d: 5th, e: 4th
a2 &lt;- c(a=1,b=0,c=0,d=2,e=3) # a: 2nd, b: DNF, c: DNF, d: 2nd, e: 3rd
a3 &lt;- c(a=1,b=3,c=2)         # a: 1st, b: 3rd, c: 2nd. NB only a,b,c competed
a4 &lt;- c(a=1,b=3,c=2,d=0,e=0) # a: 1st, b: 3rd, c: 2nd, d,e: DNF


## results of ordervec2supp() may be added with "+" [if the observations
## are independent]:

H1 &lt;- ordervec2supp(a1) + ordervec2supp(a2) + ordervec2supp(a3)
H2 &lt;- ordervec2supp(a1) + ordervec2supp(a2) + ordervec2supp(a4)

## Thus H1 and H2 are identical except for the third race.  In H1, 'd'
## and 'e' did not compete, but in H2, 'd' and 'e' did not finish (and
## notionally came last):

pmax(H1)
pmax(H2)   # d,e not finishing affects their estimated strength

</code></pre>

<hr>
<h2 id='ordertrans'>Order transformation</h2><span id='topic+ordertrans'></span><span id='topic+ordertransplot'></span>

<h3>Description</h3>

<p>Given an order vector, shuffle so that the players appear in a specified
order. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordertrans(x,players)
ordertransplot(ox,oy,plotlims, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordertrans_+3A_x">x</code></td>
<td>
<p>A (generalized) order vector</p>
</td></tr>
<tr><td><code id="ordertrans_+3A_players">players</code></td>
<td>
<p>A character vector specifying the order in which the
players will be listed; if missing, use <code>sort(names(x))</code></p>
</td></tr>
<tr><td><code id="ordertrans_+3A_ox">ox</code>, <code id="ordertrans_+3A_oy">oy</code></td>
<td>
<p>Rank vectors</p>
</td></tr>
<tr><td><code id="ordertrans_+3A_plotlims">plotlims</code></td>
<td>
<p>Length two numeric vector giving x and y plot limits.
If missing, use sensible default</p>
</td></tr>
<tr><td><code id="ordertrans_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>plot()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best way to describe this function is with an example:
</p>
<pre>
&gt; x &lt;- c(d=2,a=3,b=1,c=4)
&gt; x
d a b c 
2 3 1 4 
</pre>
<p>In the above, we see <code>x</code> is an order vector showing that <code>d</code>
came second, <code>a</code> came third, <code>b</code> came first, and <code>c</code> came
fourth.  This is difficult to deal with because one has to search
through the vector to find a particular competitor, or a particular
rank.  This would be harder if the vector was longer.
If we wish to answer the question &ldquo;where did competitor <code>a</code>
come?  where did <code>b</code> come?&rdquo; we would want an <em>order</em> vector
in which the competitors are in alphabetical order.  This is
accomplished by <code>ordertrans()</code>:
</p>
<pre>
&gt; o &lt;- ordertrans(x)
&gt; o
a b c d 
3 1 4 2 
</pre>
<p>(this is equivalent to <code>o &lt;- x[order(names(x))]</code>).  Object <code>o</code>
contains the same information as <code>x</code>, but presented differently.
This says that <code>a</code> came third, <code>b</code> came first, <code>c</code> came
fourth, and <code>d</code> came second.  In particular, the Plackett-Luce
order statistic is identical:
</p>
<pre>
&gt; ordervec2supp(x) == ordervec2supp(o)
&gt; [1] TRUE
</pre>
<p>There is a nice example of <code>ordertrans()</code> in
<code>inst/eurovision.Rmd</code>, and package vignette <code>ordertrans</code>
provides further discussion and examples.
</p>
<p>Function <code>ordertrans()</code> takes a second argument which allows the
user to arrange an order vector into the order specified.
</p>
<p>Function <code>ordertrans()</code> also works in the context of <code>hyper3</code>
objects:
</p>
<pre>
x &lt;- c(d=2,a=3,b=1,a=4)
x
d a b a 
2 3 1 4 
ordertrans(x)
a a b d 
3 4 1 2 
</pre>
<p>Object <code>x</code> shows that <code>d</code> came second, <code>a</code> came third and
fourth, and <code>b</code> came first.  We can see that <code>ordertrans()</code>
gives the same information in a more intelligible format.  This
functionality is useful in the context of <code>hyper3</code> likelihood
functions.
</p>


<h3>Value</h3>

<p>Returns a named vector</p>


<h3>Note</h3>

<p>The argument to <code>ordertrans()</code> is technically an order vector
because it answers the question &ldquo;where did the first-named
competitor come?&rdquo; (see the discussion at <a href="#topic+rrank">rrank</a>).  But it is
not a helpful order vector because you have to go searching through
the names&mdash;which can appear in any order&mdash;for the competitor you are
interested in.  I guess &ldquo;generalised order vector&rdquo; might be a
better description of the argument.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrank">rrank</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(e=4L,a=7L,c=6L,b=1L,f=2L,g=3L,h=5L,i=8L,d=9L)
x
ordertrans(x,letters[1:9])

o &lt;- skating_table[,1]
names(o) &lt;- rownames(skating_table)
o
ordertrans(o)

ordertrans(sample(icons_maxp),icons)


rL &lt;- volvo_maxp   # rL is "ranks Likelihood"
rL[] &lt;- rank(-volvo_maxp)

r1 &lt;- volvo_table[,1]  # ranks race 1
names(r1) &lt;- rownames(volvo_table)
ordertransplot(rL,r1,xlab="likelihood rank, all races",ylab="rank, race 1")

</code></pre>

<hr>
<h2 id='ordervec2supp3'>Various functionality for races and hyper3 likelihood functions</h2><span id='topic+race3'></span><span id='topic+num3'></span><span id='topic+den3'></span><span id='topic+char2nv'></span><span id='topic+ordervec2supp3'></span><span id='topic+ordervec2supp3a'></span><span id='topic+ordertable2supp3'></span><span id='topic+args2ordervec'></span><span id='topic+race_to_hyper3'></span><span id='topic+cheering'></span><span id='topic+cheering3'></span><span id='topic+rankvec_likelihood3'></span>

<h3>Description</h3>

<p>Various functions for calculating the likelihood function for order
statistics in the context of hyper3 likelihood functions.  Compare
<code>ggol()</code> for <code>hyper2</code> objects.  Used in the
<code>constructor()</code> suite of analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num3(v,helped=NULL,lambda=1)
den3(v,helped=NULL,lambda=1)
char2nv(x)
ordervec2supp3(v,nonfinishers=NULL)
ordervec2supp3a(v,nonfinishers=NULL,helped=NULL,lambda=1)
rankvec_likelihood3(v,nonfinishers=NULL)
ordertable2supp3(a)
cheering3(v,e,help,nonfinishers=NULL)
args2ordervec(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordervec2supp3_+3A_v">v</code></td>
<td>
<p>Ranks in the form of a character vector.  Element <code>v[1]</code>
is the first-placed competitor, element <code>v[2]</code> the second, and
so on.  For example, <code>ordervec2supp3(c('b','b','a','c','a'))</code></p>
</td></tr>
<tr><td><code id="ordervec2supp3_+3A_nonfinishers">nonfinishers</code></td>
<td>
<p>Character vector (a set) showing players that did
not finish.  See details section and examples</p>
</td></tr>
<tr><td><code id="ordervec2supp3_+3A_a">a</code></td>
<td>
<p>An ordertable</p>
</td></tr>
<tr><td><code id="ordervec2supp3_+3A_helped">helped</code></td>
<td>
<p>vector of entities being helped</p>
</td></tr>
<tr><td><code id="ordervec2supp3_+3A_e">e</code>, <code id="ordervec2supp3_+3A_help">help</code>, <code id="ordervec2supp3_+3A_lambda">lambda</code></td>
<td>
<p>Parameters controlling non-independence with
<code>e</code> a named integer vector specifying equivalence classes of
the competitors: names correspond to the competitors, values to
their equivalence class, and <code>help</code> a numeric vector with
entries corresponding to the equivalence classes of <code>e</code> and
values the strength of the support</p>
</td></tr>
<tr><td><code id="ordervec2supp3_+3A_x">x</code></td>
<td>
<p>A character vector of competitors</p>
</td></tr>
<tr><td><code id="ordervec2supp3_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>args2ordervec()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>args2ordervec()</code> takes arguments with names
corresponding to players, and entries corresponding to performances
(e.g. distances thrown by a javelin, or times for completing a
race).  It returns a character vector indicating the rank statistic.
See examples, and also the javelin vignette.
</p>
<p>Function <code>ordervec2supp3()</code> takes character vector showing the
order of finishing [i.e. a rank statistic], and returns a generalized
Plackett-Luce support function in the form of a <code>hyper3</code> object.
It can take the output of <code>args2ordervec()</code> or <code>rrace3()</code>.
For example:
</p>
<p><code>ordervec2supp3(c("a","b"),nonfinishers=c("a","b"))</code>
</p>
<p>corresponds to a race between two twins of strength <code>a</code> and two
twins of strength <code>b</code>, with only one of each pair finishing;
<code>a</code> comes first and <code>b</code> comes second; symbolically
</p>
<p style="text-align: center;"><code class="reqn">a\succ b\succ\left\lbrace a,b\right\rbrace\longrightarrow
    \mathcal{L}(a,b\left|a+b=1\right.)=\frac{a}{2a+2b}\cdot\frac{b}{a+2b}</code>
</p>

<p>Further,
</p>
<p><code>ordervec2supp3(c("a","b"),c("a","b","c"))</code>
</p>
<p>corresponds to adding a singleton competitor of strength <code>c</code> who
did not finish:
</p>
<p style="text-align: center;"><code class="reqn">a\succ b\succ\left\lbrace a,b,c\right\rbrace\longrightarrow
    \mathcal{L}(a,b,c\left|a+b+c=1\right.)=\frac{a}{2a+2b+c}\cdot\frac{b}{a+2b+c}</code>
</p>

<p>(observe that this likelihood function is informative about
<code class="reqn">c</code>).  See the examples section below.  Experimental function
<code>ordervec2supp3a()</code> is a generalized version of
<code>ordervec2supp3()</code> that allows for cheering effects.
</p>
<p>Functions <code>num3()</code> and <code>den3()</code> are low-level helper
functions that calculate the numerator and denominator for
Plackett-Luce likelihood functions with clones; used in
<code>ordervec2supp3()</code> and <code>ordervec2supp3a()</code>.
</p>
<p>Function <code>ordertable2supp3()</code> takes an order table (the canonical
example is the constructors' formula 1 grand prix results, see
<code>constructor.Rd</code> and returns a generalized Plackett-Luce support
function in the form of a <code>hyper3</code> object.
</p>
<p>Function <code>char2nv()</code> takes a character vector and returns a named
vector with entries corresponding to their names' counts.  It is used
in the extraction and replacement methods for <code>hyper3</code> objects.
</p>
<p>Function <code>cheering3()</code> is a generalization of
<code>ordervec2supp3()</code>.  Competitors who are not mentioned in
argument <code>e</code> are assumed to be in an equivalence class of size 1,
that is, they are not supported (or indeed suppressed) by anyone else:
they are singletons in the terminology of Hankin (2006).  Extensive
discussions are presented at <code>inst/plackett_luce_monster.Rmd</code> and
<code>inst/eurovision.Rmd</code>.
</p>
<p>File <code>inst/javelin.Rmd</code> and <code>inst/race3.Rmd</code> show some
use-cases for these functions.
</p>


<h3>Note</h3>

<p>Function <code>ordervec2supp3()</code> is mis-named [it takes a <em>rank</em>
vector, not an <em>order</em> vector]; it will be renamed
<code>rankvec_likelihood3()</code>, eventually.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable2supp">ordertable2supp</a></code>,<code><a href="#topic+ordertrans">ordertrans</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>

ordervec2supp3(c("a","a","b","c","a","b","c"))
ordervec2supp3(rrace3())
ordervec2supp3(c("a","b"),nonfinishers=c("a","b"))  # a &gt; b &gt;&gt; {a,b}



(o &lt;- args2ordervec(a=c(1,6,9), b=c(2,3,4), c=c(1.1,11.1)))
H &lt;- ordervec2supp3(o)
H
# equalp.test(H)   # takes too long for here


## Race: six competitors a-f finishing in alphabetical order.  Mutually
## supporting groups: (acd), (bf), (e).  Competitor "e" is not
## suppported by anyone else (he is a singleton) so does not need to be
## mentioned in argument 'e' and there are only two helpfulnesses to be
## considered: that of (acd) and that of (bf), which we will take to be
## 1.88 and 1.1111 respectively:

cheering3(v=letters[1:6],e=c(a=1,c=1,b=2,d=1,e=2),help=c(1.88,1.1111))




## Another race: four competitors, including two clones of "a", and two
## singletons "b" and "c".  Here "a" helps his clone at 1.88; and "b"
## and "c" help one another at 1.111:

cheering3(v=c("a","b","a","c"),e=c(a=1,b=2,c=2),help=c(1.8,1.111))


## Same race as above but this time there are two clones of "b", one of
## whom did not finish:

cheering3(v=c("a","b","a","c"),e=c(a=1,b=2,c=2),help=c(1.8,1.111),"b")


## Most common case would be that the clones help each other but noone
## else:

cheering3(v=c("a","b","a","c"),e=c(a=1,b=2,c=3),help=c(1.8,1.111,1),"b")



</code></pre>

<hr>
<h2 id='pairwise'>Pairwise comparisons</h2><span id='topic+pairwise'></span><span id='topic+zermelo'></span><span id='topic+home_away'></span><span id='topic+home_away3'></span><span id='topic+white_draw'></span><span id='topic+white_draw3'></span>

<h3>Description</h3>

<p>Function <code>pairwise()</code> takes a matrix of pairwise comparisons and
returns a <code>hyper2</code> likelihood function.  Function
<code>zermelo()</code> gives a standard iterative procedure for likelihood
maximization of pairwise Bradley-Terry likelihoods (such as those
produced by function <code>pairwise()</code>).
</p>
<p>Function <code>home_away()</code> takes two matrices, one for home wins and
one for away wins.  It returns a <code>hyper2</code> support function that
includes a home advantage ghost.  Function <code>home_away3()</code> is the
same, but returns a <code>hyper3</code> object.  A complex matrix is
interpreted as real parts being the home wins and imaginary parts away
wins.
</p>
<p>Function <code>white_draw3()</code> returns a <code>hyper3</code> likelihood
function for pairwise comparisons, one of whom has a home team-type
advantage (white player in the case of chess).  It is designed to
work with an array of dimensions <code class="reqn">n\times n\times 3</code>,
where <code class="reqn">n</code> is the number of players.  It is used in
<code>inst/kka.Rmd</code> to create <code>chess3</code> likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise(M)
zermelo(M, maxit = 100, start, tol = 1e-10, give = FALSE)
home_away(home_games_won, away_games_won)
home_away3(home_games_won, away_games_won,lambda)
white_draw3(A,lambda,D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_+3A_m">M</code></td>
<td>
<p>Matrix of pairwise comparison results</p>
</td></tr>
<tr><td><code id="pairwise_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="pairwise_+3A_start">start</code></td>
<td>
<p>Starting value for iteration; if missing, use
<code>equalp()</code></p>
</td></tr>
<tr><td><code id="pairwise_+3A_tol">tol</code></td>
<td>
<p>Numerical tolerance for stopping criterion</p>
</td></tr>
<tr><td><code id="pairwise_+3A_give">give</code></td>
<td>
<p>Boolean with default <code>FALSE</code> meaning to return the
evaluate and <code>TRUE</code> meaning to return all iterations</p>
</td></tr>
<tr><td><code id="pairwise_+3A_home_games_won">home_games_won</code>, <code id="pairwise_+3A_away_games_won">away_games_won</code></td>
<td>
<p>Matrices showing home games won
and away games won</p>
</td></tr>
<tr><td><code id="pairwise_+3A_lambda">lambda</code></td>
<td>
<p>The home ground advantage
(or white advantage in chess)</p>
</td></tr>
<tr><td><code id="pairwise_+3A_d">D</code></td>
<td>
<p>Weight of draw</p>
</td></tr>
<tr><td><code id="pairwise_+3A_a">A</code></td>
<td>
<p>Array of dimension <code>n*n*3</code>, with <code>A[,,i]</code>
corresponding to white wins, white draws, and white losses for
<code>i=1,2,3</code>.  The canonical example would be <code>kka_array</code>,
see <code>inst/kka.Rmd</code> for details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In function <code>zermelo()</code>, the diagonal is disregarded.
</p>
<p>If <code>home_games_won</code> is complex, then the real parts of the
entries are interpreted as home games won, and the imaginary parts as
away games won.
</p>


<h3>Note</h3>

<p>An extended discussion of <code>pairwise()</code> is given in
<code>inst/zermelo.Rmd</code> and also <code>inst/karate.Rmd</code>.  Functions
<code>home_away()</code> and <code>home_away3()</code> are described and used in
<code>inst/home_advantage.Rmd</code>; see Davidson and Beaver 1977.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li><p> D. R. Hunter 2004. &ldquo;MM algorithms for generalized
Bradley-Terry models&rdquo;. <em>The Annals of Statistics</em>, volume 32,
number 1, pages 384&ndash;406
</p>
</li>
<li><p> S. Borozki and others 2016.  &ldquo;An application of incomplete pairwise
comparison matrices for ranking top tennis
players&rdquo;. <code>arXiv:1611.00538v1</code> <code>10.1016/j.ejor.2015.06.069</code>
</p>
</li>
<li><p> R. R. Davidson and R. J. Beaver 1977. &ldquo;On extending the
Bradley-Terry model to incorporate within-pair order effects&rdquo;.
<em>Biometrics</em>, 33:693&ndash;702
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+maxp">maxp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> #Data is the top 5 players from Borozki's table 1

M &lt;- matrix(c(
0,10,0, 2,5,
4, 0,0, 6,6,
0, 0,0,15,0,
0, 8,0, 0,7,
1 ,0,3, 0,0
),5,5,byrow=TRUE) 
players &lt;-  c("Agassi","Becker","Borg","Connors","Courier")
dimnames(M) &lt;- list(winner=players,loser=players)
M
# e.g. Agassi beats Becker 10 times and loses 4 times
pairwise(M)
zermelo(M)
# maxp(pairwise(M))  # should be identical (takes ~10s to run)


M2 &lt;- matrix(c(NA,19+2i,17,11+2i,16+5i,NA,12+4i,12+6i,12+2i,19+10i,
NA,12+4i,11+2i,16+2i,11+7i,NA),4,4)
teams &lt;- LETTERS[1:4]
dimnames(M2) &lt;- list("@home" = teams,"@away"=teams)
home_away(M2)
# home_away3(M2,lambda=1.2)  # works but takes too long (~3s)
home_away3(M2[1:3,1:3],lambda=1.2) 

M &lt;- kka_array[,,1] + 1i*kka_array[,,3] # ignore draws
home_away(M)
# home_away3(M,lambda=1.3)  # works but takes too long (~3s)

white_draw3(kka_array,1.88,1.11)
</code></pre>

<hr>
<h2 id='pentathlon'>Pentathlon</h2><span id='topic+pentathlon'></span><span id='topic+pentathlon_table'></span><span id='topic+pentathlon_maxp'></span><span id='topic+pentathlon_ordertable'></span>

<h3>Description</h3>

<p>Results from the Men's pentathlon at the 2004 Summer Olympics</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pentathlon)</code></pre>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood function</p>


<h3>Details</h3>

<p>Object <code>pentathlon</code> is a <code>hyper2</code> object that gives a
likelihood function for the strengths of the top seven competitors at
the Modern Men's Pentathlon, 2004 Summer Olympics.
</p>
<p>Object <code>pentathlon_table</code> is an order table: a data frame with rows
being competitors, columns being disciplines, and entries being places.
Thus looking at the first row, first column we see that Moiseev placed
fifth at shooting.
</p>
<p>These objects can be generated by running script
<code>inst/pentathlon.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>pentathlon.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>Note</h3>

<p>Many of the competitors' names have diacritics, which I have removed.</p>


<h3>References</h3>

<p>&ldquo;Wikipedia contributors&rdquo;, <em>Modern pentathlon at the 2004
Summer Olympics - Men's</em>.  Wikipedia, The Free Encyclopedia,
<a href="https://en.wikipedia.org/w/index.php?title=Modern_pentathlon_at_the_2004_Summer_Olympics_%E2%80%93_Men%27s&amp;oldid=833081611">https://en.wikipedia.org/w/index.php?title=Modern_pentathlon_at_the_2004_Summer_Olympics_%E2%80%93_Men%27s&amp;oldid=833081611</a>,
[Online; accessed 5-March-2020]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable">ordertable</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pentathlon)
pie(pentathlon_maxp)
</code></pre>

<hr>
<h2 id='powerboat'>Powerboat dataset</h2><span id='topic+powerboat'></span><span id='topic+powerboat_maxp'></span><span id='topic+powerboat2018'></span><span id='topic+powerboat_2018'></span><span id='topic+powerboat_table'></span>

<h3>Description</h3>

<p>Race results from the 2018 F1 Powerboat World Championship</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(powerboat)</code></pre>


<h3>Details</h3>

<p>Object <code>powerboat_table</code> is a dataframe of results showing ranks
of 21 drivers in the 2018 F1 Powerboat World Championship.  The format
is standard, that is, can be interpreted by function
<code>ordertable2supp()</code> and indeed
<code>ordertable2supp(powerboat_table[,1:7])</code> gives the corresponding
support function, <code>powerboat</code>.
</p>
<p>File <code>inst/powerboat.txt</code> is the source text file; to create
<code>powerboat_table</code> use
</p>
<p><code>read.table(system.file("powerboat.txt",package="hyper2"))</code>
</p>
<p>The dataset used here corrects an apparent typo in the wikipedia table
(see github issue 37).
</p>
<p>These objects can be generated by running script
<code>inst/powerboat.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>powerboat.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>Note</h3>

<p>Many drivers have names with diacritics, which have been removed from
the dataframe.
</p>


<h3>References</h3>

<p>Wikipedia contributors. (2019, October 9). 2018 F1 Powerboat World
Championship. In <em>Wikipedia, The Free Encyclopedia</em>.  Retrieved
00:45, February 21, 2020, from
<a href="https://en.wikipedia.org/w/index.php?title=2018_F1_Powerboat_World_Championship&amp;oldid=920386507">https://en.wikipedia.org/w/index.php?title=2018_F1_Powerboat_World_Championship&amp;oldid=920386507</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable2supp">ordertable2supp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pie(powerboat_maxp)

</code></pre>

<hr>
<h2 id='Print'>Print methods</h2><span id='topic+print.hyper2'></span><span id='topic+print.hyper3'></span><span id='topic+print'></span><span id='topic+Print'></span><span id='topic+pnv'></span><span id='topic+give_warning_on_nonzero_power_sum'></span><span id='topic+nonzero_power_sum'></span><span id='topic+power_sum'></span>

<h3>Description</h3>

<p>Print methods for <code>hyper2</code> and <code>hyper3</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyper2'
print(x, ...)
## S3 method for class 'hyper3'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Print_+3A_x">x</code></td>
<td>
<p>An object of class <code>hyper2</code> or <code>hyper3</code></p>
</td></tr>
<tr><td><code id="Print_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used mainly for their side-effect of printing the log-likelihood
function.  In the print method, a natural logarithm is indicated with
&ldquo;<code>log()</code>&rdquo;&mdash;not &ldquo;<code>ln()</code>&rdquo;&mdash;consistent with <span class="rlang"><b>R</b></span>
builtin terminology <code>base::log()</code>.
</p>
<p>The <code>hyper2</code> print method is sensitive to option
<code>give_warning_on_nonzero_power_sum</code>.  If <code>TRUE</code>, a warning is
issued if the powers have nonzero sum.  This is usually what you want
because observations are typically multinomial; a warning indicates
nonzero sum of powers, which should prompt us to check the coding.
Vignette <code>zeropower</code> gives a discussion of this issue.
</p>


<h3>Value</h3>

<p>Returns the <code>hyper2</code> or <code>hyper3</code> object it was sent,
invisibly.  Function <code>pnv()</code> converts a named vector to a
character string that is used in the <code>hyper3</code> print method.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(chess)
chess
</code></pre>

<hr>
<h2 id='profile'>Profile likelihood and support</h2><span id='topic+profile'></span><span id='topic+profile_support'></span><span id='topic+profile_likelihood'></span><span id='topic+profile_support_single'></span><span id='topic+profile_likelihood_single'></span><span id='topic+proflike'></span><span id='topic+profsupp'></span><span id='topic+profsup'></span>

<h3>Description</h3>

<p>Given a support function, return a profile likelihood curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profsupp(H, i, p, relative=TRUE, ...)
profile_support_single(H, i, p, evaluate=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile_+3A_h">H</code></td>
<td>
<p>hyper2 object</p>
</td></tr>
<tr><td><code id="profile_+3A_i">i</code></td>
<td>
<p>Name of player for which profile support is to be calculated</p>
</td></tr>
<tr><td><code id="profile_+3A_p">p</code></td>
<td>
<p>Strength of element <code>i</code></p>
</td></tr>
<tr><td><code id="profile_+3A_evaluate">evaluate</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to return
the maximal support for <code>p_i=p</code> and <code>TRUE</code> meaning to
return the evaluate</p>
</td></tr>
<tr><td><code id="profile_+3A_relative">relative</code></td>
<td>
<p>Boolean; if <code>TRUE</code> (default), return the support
relative to the maximum support attained; if false, return the
support as returned by <code>profile_support_single()</code>.</p>
</td></tr>
<tr><td><code id="profile_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>maxp()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the support at a particular value of <code class="reqn">p_i</code>, or the
evaluate conditional on <code class="reqn">p_i</code>.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglik">loglik</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:   # takes too long
p &lt;- seq(from=0.5,to=0.4,len=10)
u &lt;- profsupp(icons,"NB",p)
plot(p,u-max(u))
abline(h=c(0,-2))

## End(Not run)
</code></pre>

<hr>
<h2 id='psubs'>Substitute players of a hyper2 object</h2><span id='topic+psubs'></span><span id='topic+psubs_single'></span><span id='topic+psubs_names'></span><span id='topic+psubs_pnames'></span>

<h3>Description</h3>

<p>Given a hyper2 object, substitute some players</p>


<h3>Usage</h3>

<pre><code class='language-R'>psubs(H, from, to)
psubs_single(H, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psubs_+3A_h">H</code></td>
<td>
<p>hyper2 object</p>
</td></tr>
<tr><td><code id="psubs_+3A_from">from</code>, <code id="psubs_+3A_to">to</code></td>
<td>
<p>Character vector of players to substitute and their
substitutes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>psubs()</code> substitutes one or more player names, replacing
player <code>from[i]</code> with <code>to[i]</code>.  If argument <code>to</code> is
missing, all players are substituted, the second argument taken to be
the replacement: interpret <code>psubs(H,vec)</code> as
<code>psubs(H,from=pnames(H),to=vec)</code>.
</p>
<p>Compare <code>pnames&lt;-()</code>, which can only add players, or reorder
existing players.
</p>
<p>Function <code>psubs_single()</code> is a low-level helper function that takes
a single player and its substitute; it is not intended for direct use.
</p>


<h3>Value</h3>

<p>Returns a hyper2 object</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
psubs(icons,c("L","NB"),c("London","Norfolk Broads"))

rhyper2() |&gt; psubs(letters,LETTERS)   # ignore i,j,k,...,z

psubs(icons,tolower(pnames(icons)))

</code></pre>

<hr>
<h2 id='pwa'>Player with advantage</h2><span id='topic+pwa'></span><span id='topic+chameleon'></span><span id='topic+extra_strength'></span><span id='topic+additional_strength'></span><span id='topic+training_strength'></span><span id='topic+wet_strength'></span><span id='topic+white_strength'></span>

<h3>Description</h3>

<p>Commonly, when considering competitive situations we suspect that one
player has an advantage of some type which we would like to quantify in
terms of an additional strength.  Examples might include racing at pole
position, playing white in chess, or playing soccer at one's home
ground.  Function <code>pwa()</code> (&ldquo;player with advantage&rdquo;) returns
a modified <code>hyper2</code> object with the additional strength represented
as a reified entity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwa(H, pwa, chameleon = "S")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pwa_+3A_h">H</code></td>
<td>
<p>A hyper2 object</p>
</td></tr>
<tr><td><code id="pwa_+3A_pwa">pwa</code></td>
<td>
<p>A list of the players with the supposed advantage; may be
character in the case of a named hyper2 object, or an integer
vector</p>
</td></tr>
<tr><td><code id="pwa_+3A_chameleon">chameleon</code></td>
<td>
<p>String representing the advantage</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an object of class <code>hyper2</code> and a competitor <code>a</code>, we
replace every occurrence of <code>a</code> with <code>a+S</code>, with <code>S</code>
representing the extra strength conferred.
</p>
<p>However, the function also takes a vector of competitors.  If there is
more than one competitor, the resulting likelihood function does not
seem to instantiate any simple situation.  
</p>
<p>Nice examples of <code>pwa()</code> are given in &lsquo;<span class="file">inst/cook.Rmd</span>&rsquo; and
&lsquo;<span class="file">inst/universities.Rmd</span>&rsquo;.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>hyper2</code>.</p>


<h3>Note</h3>

<p>Earlier versions of this package gave a contrived sequence of
observations, presented as an example of <code>pwa()</code> with multiple
advantaged competitors.  I removed it because the logic was flawed, but
it featured a chameleon who could impersonate (and indeed eat) certain
competitors, which is why the third argument is so named.
</p>
<p>The aliases commemorate some uses of the function in the vignettes and
markdown files in the &lsquo;<span class="file">inst/</span>&rsquo; directory.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordervec2supp">ordervec2supp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(formula1 |&gt; pwa("Hamilton","pole"))

H &lt;- ordervec2supp(c(a = 2, b = 3, c = 1, d = 5, e = 4))
pwa(H,'a')

## Four races between a,b,c,d:
H1 &lt;- ordervec2supp(c(a = 1, b = 3, c = 4, d = 2))
H2 &lt;- ordervec2supp(c(a = 0, b = 1, c = 3, d = 2))
H3 &lt;- ordervec2supp(c(a = 4, b = 2, c = 1, d = 3))
H4 &lt;- ordervec2supp(c(a = 3, b = 4, c = 1, d = 2))

## Now it is revealed that a,b,c had some advantage in races 1,2,3
## respectively.  Is there evidence that this advantage exists?

## Not run:   # takes ~10 seconds, too long for here
specificp.test(pwa(H1,'a') + pwa(H2,'b') + pwa(H3,'c') + H4,"S")

## End(Not run)


</code></pre>

<hr>
<h2 id='ranktable'>Convert rank tables to and from order tables</h2><span id='topic+ranktable'></span><span id='topic+ranktable_to_ordertable'></span><span id='topic+ordertable_to_ranktable'></span><span id='topic+wikitable_to_ranktable'></span><span id='topic+print.ranktablesummary'></span><span id='topic+ranktable_to_printable_object'></span><span id='topic+summary.ranktable'></span>

<h3>Description</h3>

<p>Convert rank tables (as generated by <code>rrank()</code>, for example) to
order tables like the formula 1 tables; and convert back.  Print and
summary methods for rank tables are documented here.  See also
<code>ordertable.Rd</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranktable_to_ordertable(xrank)
ordertable_to_ranktable(xorder)
wikitable_to_ranktable(wikitable, strict=FALSE)
## S3 method for class 'ranktable'
summary(object, ...)
ranktable_to_printable_object(x)
## S3 method for class 'ranktablesummary'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranktable_+3A_x">x</code>, <code id="ranktable_+3A_xrank">xrank</code>, <code id="ranktable_+3A_object">object</code></td>
<td>
<p>A rank table, an object with class
<code>ranktable</code>, for example the value of <code>rrank()</code></p>
</td></tr>
<tr><td><code id="ranktable_+3A_xorder">xorder</code>, <code id="ranktable_+3A_wikitable">wikitable</code></td>
<td>
<p>Order tables.  Argument <code>wikitable</code>
refers to a generalized order table which can include entries such
as DNF signifying did not finish.</p>
</td></tr>
<tr><td><code id="ranktable_+3A_strict">strict</code></td>
<td>
<p>Controls for <code>wikitable_to_ranktable()</code></p>
</td></tr>
<tr><td><code id="ranktable_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Function <code>ranktable_to_ordertable()</code> is trivial;
<code>ordertable_to_ranktable()</code> less so.  The prototype for order
tables would be <code>skating_table</code>. 
</p>
<p>Function <code>ordertable_to_ranktable(x)</code> checks for each column being
a permutation of <code>seq_len(nrow(x))</code> and, if not, it stops.  In
particular, <abbr><span class="acronym">DNF</span></abbr> entries are out of scope.  To convert order
tables such as <code>F1_table_2017</code>, which include <abbr><span class="acronym">DNF</span></abbr>
entries, use <code>wikitable_to_ranktable()</code> or <code>ordertable2supp()</code>
to produce a likelihood function.
</p>
<p>Function <code>ranktable_to_printable_object()</code> is a helper function
that coerces a <code>ranktable</code> object to a matrix that prints nicely.
</p>
<p>The print method is discussed in
<code>inst/ordertable_to_ranktable.Rmd</code>.
</p>


<h3>Value</h3>

<p>An order table or rank table</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrank">rrank</a></code>,
<code><a href="#topic+ordertable2supp">ordertable2supp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- (5:1)/15
names(p) &lt;- letters[1:5]
xrank &lt;- rrank(12,p,rnames=month.abb)
xorder &lt;- ranktable_to_ordertable(xrank)

## Can convert back and forth:
identical(xrank,ordertable_to_ranktable(ranktable_to_ordertable(xrank)))

# maxp(ordertable2supp(xorder))  # should be close to p
ordertable_to_ranktable(skating_table)

# convert a rank table to a support function:
rank_likelihood(wikitable_to_ranktable(volvo_table))

</code></pre>

<hr>
<h2 id='rhyper2'>Random <code>hyper2</code> objects</h2><span id='topic+rhyper2'></span>

<h3>Description</h3>

<p>Random <code>hyper2</code> loglikelihood functions, intended as quick
&ldquo;get you going&rdquo; examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhyper2(n = 8, s = 5, pairs = TRUE, teams = TRUE, race = TRUE, pnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhyper2_+3A_n">n</code></td>
<td>
<p>Number of competitors, treated as even</p>
</td></tr>
<tr><td><code id="rhyper2_+3A_s">s</code></td>
<td>
<p>Integer, Measure of the complexity of the log likelihood function</p>
</td></tr>
<tr><td><code id="rhyper2_+3A_pairs">pairs</code>, <code id="rhyper2_+3A_teams">teams</code>, <code id="rhyper2_+3A_race">race</code></td>
<td>
<p>Boolean, indicating whether or not to include
different observations</p>
</td></tr>
<tr><td><code id="rhyper2_+3A_pnames">pnames</code></td>
<td>
<p>Character vector of names, if missing interpret as
<code>letters</code>; set to <code>NA</code> meaning no names</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code>rhyper2()</code> returns a likelihood function based on
random observations.  To return a random probability vector drawn from
a from a given (normalized) likelihood function, use <code>rp()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+rp">rp</a></code>,<code><a href="#topic+rrace">rrace</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rhyper2()
rp(2,icons)

</code></pre>

<hr>
<h2 id='rhyper3'>Random hyper3 objects</h2><span id='topic+rracehyper3'></span><span id='topic+rrace3'></span><span id='topic+rwinner3'></span><span id='topic+rhyper3'></span><span id='topic+rpair3'></span>

<h3>Description</h3>

<p>Various random hyper3 objects, in the context of the race metaphor.
They return &ldquo;get you going&rdquo; examples of <code>hyper3</code> objects.
The defaults correspond to simple but non-trivial with straightforward
interpretations.
</p>
<p>The defaults are
</p>
<pre>

 pn: c(a=2,   b=4,   c=2,   d=1  )  # numbers (two "a"s, four "b"s etc)
 ps: c(a=0.3, b=0.1, c=0.2, d=0.4)  # strengths
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>rwinner3(pn=c(a=2,b=4,c=2,d=1),ps=c(a=0.3, b=0.1,c=0.2,d=0.4))
rpair3(n=5,s=3,lambda=1.3)
rrace3(pn=c(a=2,b=4,c=2,d=1),ps=c(a=0.3, b=0.1,c=0.2,d=0.4))
rracehyper3(n=4,size=9,ps=NULL,races=3)
rhyper3(n=5,s=4,type='race',...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhyper3_+3A_pn">pn</code></td>
<td>
<p>A named integer vector showing numbers of each type of player</p>
</td></tr>
<tr><td><code id="rhyper3_+3A_ps">ps</code></td>
<td>
<p>A named vector showing strengths of each type of player</p>
</td></tr>
<tr><td><code id="rhyper3_+3A_n">n</code>, <code id="rhyper3_+3A_size">size</code>, <code id="rhyper3_+3A_races">races</code>, <code id="rhyper3_+3A_s">s</code>, <code id="rhyper3_+3A_type">type</code></td>
<td>
<p>Arguments specifying the complexity 
of the random <code>hyper3</code> object returned.  See details</p>
</td></tr>
<tr><td><code id="rhyper3_+3A_lambda">lambda</code></td>
<td>
<p>Parameter</p>
</td></tr>
<tr><td><code id="rhyper3_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>rracehyper3()</code> or
<code>rpair3()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return <code>hyper3</code> objects, as indicated by the
<code>3</code> in their names.
</p>

<ul>
<li><p> Function <code>rwinner3()</code> is a low-level helper function that
takes a player number argument <code>pn</code>, and a player strength
argument <code>ps</code>.  It performs an <em>in silico</em> race,  and
returns the (name of) the winner, chosen randomly from a field of
runners with appropriate strengths.  It is used repeatedly by
<code>rrace3()</code> to select a winner from the diminishing pool of
still-running players.
</p>
</li>
<li><p> Function <code>rpair3()</code> returns a <code>hyper3</code> object
corresponding to repeated pairwise comparisons including a
white-player advantage represented by <code>lambda</code>.
</p>
</li>
<li><p> Function <code>rrace3()</code> returns a rank statistic corresponding
to finishing order for a Plackett-Luce race.  The output can be
passed to <code>ordervec2supp3()</code>.
</p>
</li>
<li><p> Function <code>rracehyper3()</code> returns a more complicated
<code>hyper3</code> object corresponding to repeated races.
</p>
</li>
<li><p> Function <code>rhyper3()</code> returns an even more complicated
<code>hyper3</code> object corresponding to repeated races and pairwise
comparisons.
</p>
</li></ul>

<p>Argument <code>n</code> generally specifies the number of distinct types of
players.  Files <code>inst/mann_whitney_wilcoxon.Rmd</code> and
<code>inst/javelin.Rmd</code> show some use-cases for these functions.
</p>


<h3>Note</h3>

<p>In function <code>rracehyper3()</code> [and by extension <code>rhyper3()</code>],
if argument <code>n</code> exceeds 26 and argument <code>pn</code> takes its
default value of <code>NULL</code>, then an error will be returned because
there are only 26 players, one for each letter <code>a</code>-<code>z</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrank">rrank</a></code>,<code><a href="#topic+ordertable2supp">ordertable2supp</a></code>,<code><a href="#topic+ordertrans">ordertrans</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rracehyper3()
rrace3()
rwinner3()
rhyper3()
rpair3()
ordervec2supp3(rrace3())

table(replicate(100,which(rrace3(pn=c(a=1,b=10),ps=c(a=0.9,b=0.1))=='a')))

</code></pre>

<hr>
<h2 id='rowing'>Rowing dataset, sculling</h2><span id='topic+rowing'></span><span id='topic+sculling'></span><span id='topic+sculls2016'></span><span id='topic+allrowers'></span><span id='topic+rowing_minimal'></span><span id='topic+rowing_table'></span><span id='topic+rowing_minimal_table'></span><span id='topic+rowing_maxp'></span><span id='topic+rowing_minimal_maxp'></span>

<h3>Description</h3>

<p>Data from Men's single sculls, 2016 Summer Olympics</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rowing)</code></pre>


<h3>Format</h3>

<p>Object <code>rowing</code> is a  <code>hyper2</code> object that gives a likelihood
function for the 2016 men's sculls.
</p>


<h3>Details</h3>

<p>Object <code>rowing</code> is created by the code in <code>inst/rowing.Rmd</code>.
This reads file <code>inst/rowing.txt</code>, each line of which is a heat
showing the finishing order.  Object <code>rowing_table</code> is the
corresponding <span class="rlang"><b>R</b></span> list.
</p>
<p>File <code>inst/rowing_minimal.txt</code> has the same data but with dominated
players (that is, any group of players none of whom have beaten any
player not in the group) have been removed.  This is because dominated
players have a ML strength of zero.
</p>


<h3>References</h3>

<p>Wikipedia contributors, &ldquo;Rowing at the 2016 Summer
Olympics&mdash;Men's single sculls&rdquo;, <em>Wikipedia, The Free
Encyclopedia</em>,
<a href="https://en.wikipedia.org/w/index.php?title=Rowing_at_the_2016_Summer_Olympics_%E2%80%93_Men%27s_single_sculls&amp;oldid=753517240">https://en.wikipedia.org/w/index.php?title=Rowing_at_the_2016_Summer_Olympics_%E2%80%93_Men%27s_single_sculls&amp;oldid=753517240</a>
(accessed December 7, 2016).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggrl">ggrl</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dotchart(rowing_maxp)
</code></pre>

<hr>
<h2 id='rp'>Random samples from the prior of a <code>hyper2</code> object</h2><span id='topic+rp'></span>

<h3>Description</h3>

<p>Uses Metropolis-Hastings to return random samples from the prior of a
<code>hyper2</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rp(n, H, startp = NULL, fcm = NULL, fcv = NULL, SMALL = 1e-06, l=loglik, fillup=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rp_+3A_h">H</code></td>
<td>
<p>Object of class <code>hyper2</code></p>
</td></tr>
<tr><td><code id="rp_+3A_n">n</code></td>
<td>
<p>Number of samples</p>
</td></tr>
<tr><td><code id="rp_+3A_startp">startp</code></td>
<td>
<p>Starting value for the Markov chain, with default
<code>NULL</code> being interpreted as starting from the evaluate</p>
</td></tr>
<tr><td><code id="rp_+3A_fcm">fcm</code>, <code id="rp_+3A_fcv">fcv</code></td>
<td>
<p>Constraints as for <code>maxp()</code></p>
</td></tr>
<tr><td><code id="rp_+3A_small">SMALL</code></td>
<td>
<p>Notional small value for numerical stability</p>
</td></tr>
<tr><td><code id="rp_+3A_l">l</code></td>
<td>
<p>Log-likelihood function with default <code>loglik()</code></p>
</td></tr>
<tr><td><code id="rp_+3A_fillup">fillup</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return a
matrix with the fillup value added, and column names matching the
<code>pnames()</code> of argument <code>H</code></p>
</td></tr>
<tr><td><code id="rp_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the implementation of Metropolis-Hastings from the <code>MCE</code>
package to sample from the posterior PDF of a <code>hyper2</code> object.
</p>
<p>If the distribution is Dirichlet, use <code>rdirichlet()</code> to generate
random observations: it is much faster, and produces serially
independent samples.  To return <em>uniform</em> samples, use
<code>rp_unif()</code> (documented at <code>dirichlet.Rd</code>).
</p>


<h3>Value</h3>

<p>Returns a matrix, each row being a unit-sum observation.</p>


<h3>Note</h3>

<p>Function <code>rp()</code> a random sample from a given normalized
likelihood function.  To return a random likelihood function, use
<code>rhyper2()</code>.
</p>
<p>File <code>inst/ternaryplot_hyper2.Rmd</code> shows how to use
<code>Ternary::ternaryPlot()</code> with <code>rp()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxp">maxp</a></code>,<code><a href="#topic+loglik">loglik</a></code>,<code><a href="#topic+dirichlet">dirichlet</a></code>,<code><a href="#topic+rhyper2">rhyper2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rp(10,icons)

plot(loglik(rp(30,icons),icons),type='b')
</code></pre>

<hr>
<h2 id='rrace'>A random race with given BT strengths</h2><span id='topic+rrace'></span>

<h3>Description</h3>

<p>Returns a rank vector suitable for interpretation with <code>race()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrace(strengths)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrace_+3A_strengths">strengths</code></td>
<td>

<p>Named vector with names being players and values being their
Bradley-Terry strengths</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a simple recursive system to generate the ranks.
</p>


<h3>Value</h3>

<p>Returns a character vector with entries corresponding to the competitor.
The first element is the winner, the second the runner-up, and so on,
until the final element is the last to cross the finishing line.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+rrace3">rrace3</a></code>,<code><a href="#topic+hyper2">hyper2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
o &lt;- c(a=0.4, b=0.3, c=0.2, d=0.1)
rrace(o)

rankvec_likelihood(rrace(o))

D &lt;- t(replicate(10,rrace(o))) # 10 races
H &lt;- hyper2()
for(i in seq_len(nrow(D))){H &lt;- H+rankvec_likelihood(D[i,])}
maxp(H)  # should be close to o
</code></pre>

<hr>
<h2 id='rrank'>Random ranks</h2><span id='topic+rrank'></span><span id='topic+rrank_single'></span><span id='topic+rorder_single'></span><span id='topic+print.ranktable'></span>

<h3>Description</h3>

<p>A function for producing ranks randomly, consistent with a specified
strength vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrank(n = 1, p, pnames=NULL, fill = FALSE, rnames=NULL)
## S3 method for class 'ranktable'
print(x, ...)
rrank_single(p)
rorder_single(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrank_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="rrank_+3A_p">p</code></td>
<td>
<p>Strength vector</p>
</td></tr>
<tr><td><code id="rrank_+3A_pnames">pnames</code></td>
<td>
<p>Character vector (&ldquo;player names&rdquo;) specifying
names of the columns</p>
</td></tr>
<tr><td><code id="rrank_+3A_rnames">rnames</code></td>
<td>
<p>Character vector (&ldquo;row names&rdquo; or &ldquo;race
names&rdquo;) specifying names of the rows</p>
</td></tr>
<tr><td><code id="rrank_+3A_fill">fill</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to interpret
the elements of <code>p</code> as strengths, notionally summing to one;
and <code>TRUE</code> meaning to augment <code>p</code> with a fillup value</p>
</td></tr>
<tr><td><code id="rrank_+3A_x">x</code>, <code id="rrank_+3A_...">...</code></td>
<td>
<p>Arguments passed to the print method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>n=1</code>, <code>rrank()</code> returns a vector; if <code>n&gt;1</code> it returns
a matrix with <code>n</code> rows, each corresponding to a ranking.  The
canonical example is a race in which the probability of competitor
<code class="reqn">i</code> coming first is <code class="reqn">p_i/\sum p_j</code>, where the
summation is over the competitors who have not already finished.
</p>
<p>If, say, the first row of <code>rrank()</code> is <code>c(2,5,1,3,4)</code>, then
competitor 2 came first, competitor 5 came second, competitor 1 came
third, and so on.
</p>
<p>Note that function <code>rrank()</code> returns an object of class
<code>ranktable</code>, which has its own special print method.  The column
names appear as &ldquo;<code>c1, c2, ...</code>&rdquo; which is intended to be read
&ldquo;came first&rdquo;, &ldquo;came second&rdquo;, and so on.  The difference
between <em>rank</em> and <em>order</em> can be confusing.
</p>
<pre>
&gt; x &lt;- c(a=3.01, b=1.04, c=1.99, d=4.1)
&gt; x
   a    b    c    d 
3.01 1.04 1.99 4.10 
&gt; rank(x)
a b c d 
3 1 2 4 
&gt; order(x)
[1] 2 3 1 4
</pre>
<p>In the above, <code>rank()</code> shows us that element <code>a</code> of <code>x</code>
(viz 3.01) is the third largest, element <code>b</code> (viz 1.04) is the
smallest, and so on; <code>order(x)</code> shows us that the smallest element
<code>x</code> is <code>x[2]</code>, the next smallest is <code>x[3]</code>, and so on.
Thus <code>x[order(x)] == sort(x)</code>, and <code>rank(x)[order(x)] ==
seq_along(x)</code>.  In the current context we want ranks not orders; we want
to know who came first, who came second, and so on:
</p>
<pre>
R&gt; rrank(2,(4:1)/10)
     c1 c2 c3 c4
[1,]  2  3  1  4
[2,]  1  3  2  4
R&gt; 
</pre>
<p>In the above, each row is a race; we have four runners and two races.
In the first race (the top row), runner number 2 came first, runner 3
came second, runner 1 came third, and so on.  In the second race (bottom
row), runner 1 came first, etc.  Taking the first race as an example:
</p>
<p><strong>Rank:</strong> who came first? runner 2.  Who came second? runner 3.
Who came third? runner 1.  Who came fourth? runner 4.  Recall that the
Placket-Luce likelihood for a race in which the rank statistic was
<code>2314</code> (the first race) would be <code class="reqn">
\frac{p_2}{p_2+p_3+p_1+p_4}\cdot
\frac{p_3}{p_3+p_1+p_4}\cdot
\frac{p_1}{p_1+p_4}\cdot
\frac{p_4}{p_4}</code>.
</p>
<p><strong>Order:</strong> where did runner 1 come?  third.  Where did runner 2
come?  first.  Where did runner 3 come?  second.  Where did runner 4
come?  fourth.  Thus the order statistic would be <code>3124</code>.
</p>
<p>Function <code>rrank()</code> is designed for <code>rank_likelihood()</code>, which
needs rank data, not order data.  Vignette
&ldquo;<code>skating_analysis</code>&rdquo; gives another discussion.
</p>
<p>Note that function <code>rrank()</code> returns an object of class
&ldquo;<code>rrank</code>&rdquo;, which has its own print method.  This can be
confusing.  Further details are given at <code>ranktable.Rd</code>.
</p>
<p>Function <code>rrank_single()</code> is a low-level helper function:
</p>
<pre>
&gt; p &lt;- c(0.02,0.02,0.9,0.02,0.02,0.02)  # competitor 3 the strongest
&gt; rank_single(p)
[1] 3 2 4 6 4 1
</pre>
<p>Above, we see from <code>p</code> that competitor 3 is the strongest, coming
first with 90% probability.  And indeed the resulting rank statistic
given by <code>rorder_single()</code> shows competitor 3 coming first, 2
coming second, and so on.  Compare <code>rrank_single()</code>:
</p>
<pre>
&gt; rorder_single(p)
[1] 6 3 1 4 5 2
&gt; 
</pre>
<p>Above we see see from <code>rrank_single(p)</code> that competitor 1 came
sixth, competitor 2 came third, and competitor 3 came first (as you
might expect, as competitor 3 is the strongest).  Note that the R idiom
for <code>rorder_single()</code> is the same as that used in the
<a href="https://CRAN.R-project.org/package=permutations"><span class="pkg">permutations</span></a> package for inverting a permutation: <code>o[o] &lt;-
seq_along(o)</code>.
</p>


<h3>Note</h3>

<p>Similar functionality is given by <code>rrace()</code>, documented at
<a href="#topic+rhyper3">rhyper3</a>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertrans">ordertrans</a></code>,<code><a href="#topic+rank_likelihood">rank_likelihood</a></code>,<code><a href="#topic+skating">skating</a></code>,<code><a href="#topic+rhyper3">rhyper3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rrank_single(zipf(9))

ptrue &lt;- (4:1)/10
names(ptrue) &lt;- letters[1:4]
rrank(10,p=ptrue)

H &lt;- rank_likelihood(rrank(40,p=ptrue))

## Following code commented out because they take too long:

# mH &lt;- maxp(H)   # should be close to ptrue
# H &lt;- H + rank_likelihood(rrank(30,mH)) # run some more races
# maxp(H)  # revised estimate with additional data


</code></pre>

<hr>
<h2 id='skating'>Figure skating at the 2002 Winter Olympics</h2><span id='topic+skating'></span><span id='topic+skating_table'></span><span id='topic+skating_maxp'></span><span id='topic+skeleton'></span>

<h3>Description</h3>

<p>A likelihood function for the competitors at the Ladies' Free Skate
at the 2002 Winter Olympics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skating</code></pre>


<h3>Details</h3>

<p>Three objects 
<code>skating</code>, a log-likelihood function for the competitors'
strengths, <code>skating_table</code>, an order table for each of the 9
judges, and <code>skating_maxp</code>, the result of <code>maxp(skating)</code>,
which is included to save time in the examples.
</p>
<p>These objects can be generated by running script
<code>inst/skating.Rmd</code>, which includes some further discussion and
technical documentation.  The dataset is interesting because it has
been analysed by many workers, including Lock and Lock, for
consistency between the judges.
</p>
<p>Note that file is structured so that each competitor is a row, and
each judge is a column.  Function <code>rank_likelihood()</code> requires a
transpose of this to operate.
</p>
<p>Object <code>skating_table</code> is an order table, taken from Lock and
Lock.  It corrects what appears to be an error in which judge 5 ranked
both Butyrskaya and Kettunen 12; there is no 13.  Using EM, I reckon
that Butyrskaya should be ranked twelfth and Kettunen thirteenth.
</p>


<h3>Note</h3>

<p>There is an (<code>Rbuildignore</code>-d) discussion of a
<code>skeleton</code> dataset in the <code>inst/</code> directory of the repo,
it's easy to confuse this with <code>skating</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Figure_skating_at_the_2002_Winter_Olympics#Full_results_2">https://en.wikipedia.org/wiki/Figure_skating_at_the_2002_Winter_Olympics#Full_results_2</a>
</p>
</li>
<li><p> Robin Lock and Kari Frazer Lock, Winter
2003. &ldquo;Judging Figure Skating Judges&rdquo;.  <em>STATS 36</em>, ASA
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(skating)
dotchart(skating_maxp)

ordertable_to_ranktable(skating_table)

rL &lt;- sort(skating_maxp,decreasing=TRUE)
rL[] &lt;- seq_along(rL)
rO &lt;- seq_len(nrow(skating_table))
names(rO) &lt;- rownames(skating_table)
ordertransplot(rO,rL,
   xlab="official rank",ylab="likelihood rank",
   main="Ladies free skating, 2002 Winter Olympics")

</code></pre>

<hr>
<h2 id='soling'>Sailing at the 2000 Summer Olympics - soling</h2><span id='topic+soling'></span><span id='topic+soling_after'></span><span id='topic+soling_maxp'></span><span id='topic+soling_after_maxp'></span><span id='topic+soling2000'></span><span id='topic+soling_table_2000'></span><span id='topic+soling_table'></span><span id='topic+soling2000_rr1'></span><span id='topic+soling2000_rr2'></span><span id='topic+soling2000_qf'></span><span id='topic+soling_table'></span><span id='topic+soling_rr1'></span><span id='topic+soling_rr2'></span><span id='topic+soling_qf'></span><span id='topic+soling_after'></span>

<h3>Description</h3>

<p>Race results from the 2000 Summer Olympics: soling</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(soling)</code></pre>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood function</p>


<h3>Details</h3>

<p>The Soling three person keelboat event at the 2000 Summer Olympic games
furnishes a rich dataset.  An order table and likelihood function is
given in the package as <code>soling_table</code> and <code>soling</code>
respectively.  Data from the round robins and the quarter final is given
in matrices <code>soling_rr1</code>, <code>soling_rr2</code>, <code>soling_qf</code>
respectively.
</p>
<p>These objects can be generated by running script <code>inst/soling.Rmd</code>,
which includes some further discussion and technical documentation, and
creates file <code>soling.rda</code> which resides in the <code>data/</code>
directory.
</p>


<h3>References</h3>

<p>Wikipedia contributors, &ldquo;Sailing at the 2000 Summer Olympics -
Soling,&rdquo; Wikipedia, The Free Encyclopedia,
<a href="https://en.wikipedia.org/w/index.php?title=Sailing_at_the_2000_Summer_Olympics_%E2%80%93_Soling&amp;oldid=945362535">https://en.wikipedia.org/w/index.php?title=Sailing_at_the_2000_Summer_Olympics_%E2%80%93_Soling&amp;oldid=945362535</a>
(accessed March 23, 2020).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable2supp">ordertable2supp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(soling)
ordertable_to_ranktable(soling_table)
pie(soling_maxp)
</code></pre>

<hr>
<h2 id='summary.hyper2'>Summary method for hyper2 objects</h2><span id='topic+summary.hyper2'></span><span id='topic+print.summary.hyper2'></span>

<h3>Description</h3>

<p>Give a summary of a hyper2 object, and a print method</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hyper2'
summary(object, ...)
## S3 method for class 'summary.hyper2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.hyper2_+3A_object">object</code>, <code id="summary.hyper2_+3A_x">x</code></td>
<td>
<p>Object of class hyper2</p>
</td></tr>
<tr><td><code id="summary.hyper2_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mostly self-explanatory, based on the equivalent in the <code>untb</code> package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+hyper2">hyper2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(icons)
</code></pre>

<hr>
<h2 id='suplist'>Methods for suplist objects</h2><span id='topic+suplist'></span><span id='topic+supplist'></span><span id='topic+Ops.suplist'></span><span id='topic+suplist_add'></span><span id='topic+as.suplist'></span><span id='topic+sum.suplist'></span><span id='topic+suplist_times_scalar'></span><span id='topic+lsl'></span><span id='topic+loglik_lsl'></span><span id='topic+Ops.lsl'></span><span id='topic+lsl_add'></span>

<h3>Description</h3>

<p>Basic functionality for lists of <code>hyper2</code> objects, allowing the
user to concatenate independent observations which are themselves
composite objects such as returned by <code>ggrl()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'suplist'
Ops(e1, e2)
## S3 method for class 'suplist'
sum(x,...,na.rm=FALSE)
suplist_add(e1,e2)
suplist_times_scalar(e1,e2)
as.suplist(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="suplist_+3A_e1">e1</code>, <code id="suplist_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>suplist</code>, here interpreted as
a list of possible likelihood functions (who should be added)</p>
</td></tr>
<tr><td><code id="suplist_+3A_x">x</code>, <code id="suplist_+3A_...">...</code>, <code id="suplist_+3A_na.rm">na.rm</code></td>
<td>
<p>In the <code>sum()</code> method, objects to be summed;
<code>na.rm</code> is currently ignored</p>
</td></tr>
<tr><td><code id="suplist_+3A_l">L</code></td>
<td>
<p>A list of <code>hyper2</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>suplist</code> object is a list of <code>hyper2</code> objects.  Each
element is a <code>hyper2</code> object that is consistent with an
incomplete rank observation <code class="reqn">R</code>; the list elements are exclusive
and exhaustive for <code class="reqn">R</code>.  If <code>S</code> is a <code>suplist</code> object,
and <code>S=list(H1,H2,...,Hn)</code> where the <code>Hi</code> are <code>hyper2</code>
objects, then
<code class="reqn">\mbox{Prob}(p|H_1)+\cdots+\mbox{Prob}(p|H_n)</code>.
This is because the elements of a <code>suplist</code> object are disjoint
alternatives.
</p>
<p>It is <strong>incorrect</strong> to say that a likelihood function
<code class="reqn">\mathcal{L}_S(p)</code> for <code class="reqn">p</code> is the sum of separate
likelihood functions.  This is incorrect because the arbitrary
multiplicative constant messes up the math, for example we might have
<code class="reqn">\mathcal{L}_{H_1}(p)=C_1\mathrm{Prob}(p|H_1)</code> and
<code class="reqn">\mathcal{L}_{H_2}(p)=C_2\mathrm{Prob}(p|H_2)</code> and indeed
<code class="reqn">\mathcal{L}_{{H_1}\cup H_2}(p)=C_{12}\left(\mathrm{Prob}(p|H_1)+\mathrm{Prob}(p|H_2)\right)</code>  but
</p>
<p style="text-align: center;"><code class="reqn">\mathcal{L}_{H_1}(p)+\mathcal{L}_{H_2}(p) \neq
   C_1\mathrm{Prob}(p|H_1)+C_2\mathrm{Prob}(p|H_2)</code>
</p>

<p>(the right hand side is meaningless).
</p>
<p>Functions <code>suplist_add()</code> and <code>sum.suplist()</code> implement
&ldquo;<code>S1+S2</code>&rdquo; as the support function for independent
observations <code>S1</code> and <code>S2</code>.  The idea is that the support
functions &ldquo;add&rdquo; in the following sense.  If
<code>S1=list(H1,...,Hr)</code> and <code>S2=list(I1,...,Is)</code> where
<code>Hx,Ix</code> are <code>hyper2</code> objects, then the likelihood function
for &ldquo;<code>S1+S2</code>&rdquo; is the likelihood function for <code>S1</code>
followed by (independent) <code>S2</code>.  Formally
</p>
<p style="text-align: center;"><code class="reqn">
    \mbox{Prob}(p|S_1+S_2) =
    \left(
    \mbox{Prob}(p|H_1)
    +\cdots+
    \mbox{Prob}(p|H_r)
    \right)\cdot\left(
    \mbox{Prob}(p|I_1)
    +\cdots+
    \mbox{Prob}(p|I_s)
    \right)</code>
</p>

<p style="text-align: center;"><code class="reqn">
    \log\mbox{Prob}(p|S_1+S_2) =
    \log\left(
    \mbox{Prob}(p|H_1)
    +\cdots+
    \mbox{Prob}(p|H_r)
    \right)+\log\left(
    \mbox{Prob}(p|I_1)
    +\cdots+
    \mbox{Prob}(p|I_s)
    \right)</code>
</p>

<p>However, <code>S1+S2</code> is typically a large and unwieldy object, and
can be very slow to evaluate.  These functions are here because they
provide slick package idiom.
</p>
<p>The experimental <code>lsl</code> mechanism furnishes an alternative
methodology which is more computationally efficient at the expense of
a non-explicit likelihood function.  It is not clear at present (2022)
which of the two systems is better.
</p>


<h3>Value</h3>

<p>Returns a <code>suplist</code> object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+Ops.hyper2">Ops.hyper2</a></code>,<code><a href="base.html#topic+Extract">Extract</a></code>,<code><a href="#topic+loglik">loglik</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
W &lt;- hyper2(pnames=letters[1:5])
W1 &lt;- ggrl(W, 'a', letters[2:3],'d')  # 2-element list
W2 &lt;- ggrl(W, 'e', letters[1:3],'d')  # 6-element list
W3 &lt;- ggrl(W, 'c', letters[4:5],'a')  # 2-element list

# likelihood function for independent observations  W1,W2,W3:

W1+W2+W3 # A 2*6*2=24-element list

like_single_list(equalp(W),W1+W2+W3)
## Not run: dotchart(maxplist(W1+W1+W3),pch=16) # takes a long time

a &lt;- lsl(list(W1,W2,W3),4:6)  # observe W1 four times, W2 five times and W3 six times
loglik_lsl(equalp(W),a,log=TRUE)

</code></pre>

<hr>
<h2 id='surfing'>Surfing dataset</h2><span id='topic+surfing'></span><span id='topic+surfing_table'></span><span id='topic+surfing_maxp'></span><span id='topic+surfing_venuetypes'></span>

<h3>Description</h3>

<p>Data from the 2019 World Surf League (WSL) tour</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(surfing)</code></pre>


<h3>Details</h3>

<p>The package contains four datasets from WSL 2019:
</p>

<ul>
<li> <p><code>surfing</code>, a log likelihood function for the strengths of
the competitors
</p>
</li>
<li> <p><code>surfing_maxp</code>, corresponding precalculated evaluate
</p>
</li>
<li> <p><code>surfing_venuetypes</code>, a dataframe showing the beach types
at the different venues of the tour
</p>
</li></ul>

<p>These objects can be generated by running script
<code>inst/surfing.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>surfing.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>dotchart(surfing_maxp)

</code></pre>

<hr>
<h2 id='T20'>Indian Premier League T20 cricket</h2><span id='topic+T20'></span><span id='topic+T20_table'></span><span id='topic+T20_toss'></span><span id='topic+T20_maxp'></span><span id='topic+T20_toss_maxp'></span>

<h3>Description</h3>

<p>Cricket dataset, T20 Indian Premier League  2008-2017
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(T20)</code></pre>


<h3>Details</h3>

<p>Dataframe <code>T20_table</code> has one row for each T20 IPL match in the
period 2008-2017 with the exception of seven drawn matches and three
no-result matches which were removed.  Object <code>T20</code> is a
likelihood function for the strengths of the 13 teams, and
<code>T20_toss</code> is a likelihood function that also includes a toss
strength term.
</p>
<p>These objects can be generated by running script <code>inst/T20.Rmd</code>,
which is based on Chandel and Hankin 2019.  This includes some further
discussion and technical documentation and creates file <code>T20.rda</code>
which resides in the <code>data/</code> directory.
</p>


<h3>References</h3>


<ul>
<li><p> T. Chandel and R. K. S. Hankin 2019.  &ldquo;Analysing the
impact of winning a coin toss in the Indian Premier League&rdquo;.
Auckland University of Technology.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>summary(T20)
dotchart(T20_maxp)

</code></pre>

<hr>
<h2 id='table_tennis'>Match outcomes from repeated table tennis matches</h2><span id='topic+table_tennis'></span><span id='topic+table_tennis_serve'></span><span id='topic+ping_pong'></span>

<h3>Description</h3>

<p>Match outcomes from repeated singles table tennis matches</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(table_tennis)</code></pre>


<h3>Format</h3>

<p>A likelihood function corresponding to the match outcomes listed below.
</p>


<h3>Details</h3>

<p>There are four players, A, B, and C, who
play singles table tennis matches with the following results:
</p>

<ul>
<li><p> A vs B, A serves, 5-1
</p>
</li>
<li><p> A vs B, B serves, 1-3
</p>
</li>
<li><p> A vs C, A serves, 4-1
</p>
</li>
<li><p> A vs C, C serves, 1-2
</p>
</li></ul>

<p>As discussed in vignette <code>table_tennis_serve</code>, we wish to assess
the importance of the serve.  The vignette presents a number of analyses
including a profile likelihood plot.
</p>
<p>See vignette <code>table_tennis_serve</code> for an account of how to create
<code>table_tennis</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(table_tennis)
dotchart(maxp(table_tennis))
</code></pre>

<hr>
<h2 id='tennis'>Match outcomes from repeated doubles tennis matches</h2><span id='topic+tennis'></span><span id='topic+tennis_maxp'></span><span id='topic+tennis_ghost_maxp'></span><span id='topic+doubles'></span><span id='topic+doubles_noghost'></span><span id='topic+tennis_noghost'></span><span id='topic+doubles_ghost'></span><span id='topic+tennis_ghost'></span>

<h3>Description</h3>

<p>Match outcomes from repeated doubles tennis matches</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tennis)</code></pre>


<h3>Format</h3>

<p>A hyper2 object corresponding to the match outcomes listed below.
</p>


<h3>Details</h3>

<p>There are four players, <code class="reqn">p_1</code> to <code class="reqn">p_4</code>.  These players
play doubles tennis matches with the following results:
</p>

<table>
<tr>
 <td style="text-align: center;">
  match </td><td style="text-align: center;"> score</td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">\lbrace p_1,p_2\rbrace</code> vs <code class="reqn">\lbrace p_3,p_4\rbrace</code> </td><td style="text-align: center;"> 9-2</td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">\lbrace p_1,p_3\rbrace</code> vs <code class="reqn">\lbrace p_2,p_4\rbrace</code> </td><td style="text-align: center;"> 4-4</td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">\lbrace p_1,p_4\rbrace</code> vs <code class="reqn">\lbrace p_2,p_3\rbrace</code> </td><td style="text-align: center;"> 6-7</td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">\lbrace p_1\rbrace</code> vs <code class="reqn">\lbrace p_3\rbrace</code> </td><td style="text-align: center;"> 10-14</td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">\lbrace p_2\rbrace</code> vs <code class="reqn">\lbrace p_3\rbrace</code> </td><td style="text-align: center;"> 12-14</td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">\lbrace p_1\rbrace</code> vs <code class="reqn">\lbrace p_4\rbrace</code> </td><td style="text-align: center;"> 10-14</td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">\lbrace p_2\rbrace</code> vs <code class="reqn">\lbrace p_4\rbrace</code> </td><td style="text-align: center;"> 11-10</td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">\lbrace p_3\rbrace</code> vs <code class="reqn">\lbrace p_4\rbrace</code> </td><td style="text-align: center;"> 13-13</td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>It is suspected that <code class="reqn">p_1</code> and <code class="reqn">p_2</code> have some form of
team cohesion and play better when paired than when either solo or with
other players.  As the scores show, each player and, apart from p1-p2,
each doubles partnership, is of approximately the same strength.
</p>
<p>Dataset <code>tennis</code> gives the appropriate likelihood function for the
players' strengths; and dataset <code>tennis_ghost</code> gives the
appropriate likelihood function if the extra strength due to team
cohesion of <code class="reqn">\lbrace p_1,p_2\rbrace</code> is represented by a
ghost player.
</p>
<p>These objects can be generated by running script
<code>inst/tennis.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>tennis.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>Source</h3>

<p>Doubles tennis matches at <abbr><span class="acronym">NOCS</span></abbr>, Jan-May 2008</p>


<h3>References</h3>

<p>Robin K. S. Hankin (2010).
&ldquo;A Generalization of the Dirichlet Distribution&rdquo;,
<em>Journal of Statistical Software</em>, 33(11), 1-18
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(tennis)

tennis |&gt; psubs(c("Federer","Laver","Graf","Navratilova"))

## Following line commented out because it takes too long:
# specificp.gt.test(tennis_ghost,"G",0)

</code></pre>

<hr>
<h2 id='tests'>Hypothesis testing</h2><span id='topic+equalp.test'></span><span id='topic+knownp.test'></span><span id='topic+samep.test'></span><span id='topic+specificp.test'></span><span id='topic+print.equalptest'></span><span id='topic+print.hyper2test'></span><span id='topic+specificp.ne.test'></span><span id='topic+specificp.gt.test'></span><span id='topic+specificp.lt.test'></span><span id='topic+specificp.ge.test'></span><span id='topic+specificp.le.test'></span>

<h3>Description</h3>

<p>Tests different nulls against a free alternative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equalp.test(H, startp=NULL, ...)
knownp.test(H, p, ...)
samep.test(H, i, give=FALSE, startp=NULL, ...)
specificp.test(H, i, specificp=1/size(H),
         alternative = c("two.sided","less","greater"),  ...)
specificp.ne.test(H, i, specificp=1/size(H), ...)
specificp.gt.test(H, i, specificp=1/size(H), delta=1e-5, ...)
specificp.lt.test(H, i, specificp=1/size(H), ...)
## S3 method for class 'hyper2test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tests_+3A_h">H</code></td>
<td>
<p>A likelihood function, an object of class <code>hyper2</code></p>
</td></tr>
<tr><td><code id="tests_+3A_p">p</code></td>
<td>
<p>In <code>equalp.test()</code>, putative strength vector to be
tested</p>
</td></tr>
<tr><td><code id="tests_+3A_...">...</code></td>
<td>
<p>Further arguments passed by <code>equalp.test()</code> to
<code>maxp()</code> and ignored by <code>print.hyper2test()</code></p>
</td></tr>
<tr><td><code id="tests_+3A_startp">startp</code></td>
<td>
<p>Starting value for optimization</p>
</td></tr>
<tr><td><code id="tests_+3A_i">i</code></td>
<td>
<p>A character vector of names</p>
</td></tr>
<tr><td><code id="tests_+3A_specificp">specificp</code></td>
<td>
<p>Strength, real number between 0 and 1</p>
</td></tr>
<tr><td><code id="tests_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>two.sided</code> (default),
<code>greater</code> or <code>less</code>.  You can specify just the initial
letter (taken from <code>t.test.Rd</code>)</p>
</td></tr>
<tr><td><code id="tests_+3A_give">give</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return more
detailed debugging information, and default <code>FALSE</code> meaning to
return a more user-friendly object of class <code>equalp.test</code>,
which has its own print method</p>
</td></tr>
<tr><td><code id="tests_+3A_x">x</code></td>
<td>
<p>Object of class <code>equalp.test</code>, the result of
<code>equalp.test()</code></p>
</td></tr>
<tr><td><code id="tests_+3A_delta">delta</code></td>
<td>
<p>Small value for numerical stability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code>hyper2</code> likelihood function, there are a number of
natural questions to ask about the strengths of the players; see
Hankin 2010 (JSS) for examples.  An extended discussion is presented
in vignette &ldquo;<code>hyper2</code>&rdquo; and the functions documented here
cover most of the tests used in the vignette.
</p>
<p>The tests return an object with class <code>hyper2test</code>, which has its
own print method.
</p>

<ul>
<li><p> Function <code>equalp.test(H,p)</code> tests the null that all
strengths are equal to vector <code>p</code>.  If <code>p</code> is missing, it
tests <code class="reqn">H_0\colon p_1=p_2=\cdots=p_n=\frac{1}{n}</code>, for example <code>equalp.test(icons)</code>
</p>
</li>
<li><p> Function <code>knownp.test()</code> tests the null that the strengths
are equal to the elements of named vector <code>p</code>; it is a
generalization of <code>equalp.test()</code>.  Example:
<code>knownp.test(icons,zipf(6))</code>. 
</p>
</li>
<li><p> Function <code>specificp.test(H,i,p)</code> tests
<code class="reqn">H_0\colon p_i=p</code>, for example
<code>specificp.test(icons,"NB",0.1)</code>
</p>
</li>
<li><p> Function <code>samep.test()</code> tests <code class="reqn">H_0\colon
  p_{i_1}=p_{i_2}=\cdots=p_{i_k}</code>, for example
<code>samep.test(icons,c("NB","L"))</code> tests that <code>NB</code> has the same
strength as <code>L</code>. 
</p>
</li>
<li><p> Functions <code>specificp.ne.test(H,i,p)</code>,
<code>specificp.gt.test(H,i,p)</code>, and <code>specificp.lt.test(H,i,p)</code>
are low-level helper functions that implement one- or two-sided versions
of <code>specificp.test()</code> via the <code>alternative</code> argument,
following <code>t.test()</code>
</p>
</li></ul>



<h3>Value</h3>

<p>The test functions return a list with class <code>"hyper2test"</code>
containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the difference in support between the null and
alternative</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the (asymptotic) p-value for the test, based on Wilks's
theorem</p>
</td></tr> 
<tr><td><code>estimate</code></td>
<td>
<p>the maximum likelihood estimate for <code class="reqn">p</code></p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code>specificp.gt.test()</code> includes quite a bit of messing
about to ensure that frequently-used idiom like
<code>specificp.gt.test(icons,"NB",0)</code> works as expected, testing a null
of <code>p_NB=0</code> (observe that <code>specificp.ne.test(icons,"NB",0)</code>
and <code>specificp.gt.test(icons,"NB",0)</code> will (correctly) throw an
error).  In the case of testing a strength's being zero, the support
function is often quite badly-behaved near the constraint [think tossing
a coin with probability <code class="reqn">p</code> twice, observing one head and one tail,
and testing <code class="reqn">p=0</code>; at the constraint, the likelihood is zero, the
support negative infinity, and the gradient of the support is infinite].
Numerically, the code tests <code>p_NB=delta</code>.  Note that similar
machinations are not required in <code>specificp.lt.test()</code> because a
null of <code>p_NB=1</code> is unrealistic.
</p>
<p>Function <code>samep.test()</code> does not have access to gradient
information so it is slow, inaccurate, and may fail completely for
high-dimensional datasets.  If <code>any(i==n)</code>, this constrains the
fillup value; this makes no difference mathematically but the function
idiom is involved.
</p>
<p>In functions <code>specificp.??.test(H,i,...)</code>, if <code>i</code> is not
present in <code>H</code>, an error is returned although technically the
result should be &ldquo;not enough evidence to reject&rdquo;, as <code>H</code> is
uninformative about <code>i</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxp">maxp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
equalp.test(chess)

# samep.test(icons,c("NB","L"))
# knownp.test(icons,zipf(icons))

</code></pre>

<hr>
<h2 id='tidy'>Tidy up a hyper2 object</h2><span id='topic+tidy'></span>

<h3>Description</h3>

<p>Tidy up a hyper2 object by removing players about which we
have no information</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy(H)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_+3A_h">H</code></td>
<td>
<p>A <code>hyper2</code> object</p>
</td></tr></table>


<h3>Details</h3>

<p>Function <code>tidy(H)</code> returns a hyper2 object mathematically
identical to <code>H</code> but with unused players (that is, players that
do not appear in any bracket) removed.  Players about which <code>H</code>
is uninformative are removed from the <code>pnames</code> attribute.
</p>
<p>Note that idiom <code>pnames(H) &lt;- foo</code> can also be used to manipulate
the <code>pnames</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>

H &lt;- hyper2(pnames=letters)
H["a"] &lt;- 1
H["b"] &lt;- 2
H[c("a","b")] &lt;- -3

pnames(H)
pnames(tidy(H))

H == tidy(H)  # should be TRUE



</code></pre>

<hr>
<h2 id='universities'>New Zealand University ranking data</h2><span id='topic+universities'></span><span id='topic+universities_table'></span><span id='topic+universities_maxp'></span>

<h3>Description</h3>

<p>Times Higher Education World University Rankings</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(universities)</code></pre>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood function for
ranking of NZ universities</p>


<h3>Details</h3>

<p>The data is taken directly from the THE website, specifying &ldquo;New Zealand&rdquo;:
</p>
<p><a href="https://www.timeshighereducation.com/world-university-rankings/2020/world-ranking#!/page/0/length/25/locations/NZ/sort_by/rank/sort_order/asc/cols/stats">https://www.timeshighereducation.com/world-university-rankings/2020/world-ranking#!/page/0/length/25/locations/NZ/sort_by/rank/sort_order/asc/cols/stats</a>
</p>
<p>Object <code>universities</code> is a <code>hyper2</code> support function and
<code>universities_table</code> a data frame.  
</p>
<p>These objects can be generated by running script
<code>inst/universities.Rmd</code>, which includes some further discussion and
technical documentation, and creates file <code>universities.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable">ordertable</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(universities)

psubs(universities,c("AUT","UoA"),c("University of Auckland","Auckland University of Technology"))

pie(universities_maxp)

</code></pre>

<hr>
<h2 id='volleyball'>Results from the NOCS volleyball league</h2><span id='topic+volleyball'></span><span id='topic+vb'></span><span id='topic+volleyball_results'></span><span id='topic+volleyball_maxp'></span><span id='topic+volleyball_table'></span><span id='topic+volleyball_matrix'></span><span id='topic+vb_synthetic'></span>

<h3>Description</h3>

<p>Results from the <abbr><span class="acronym">NOCS</span></abbr> volleyball league.  Object
<code>volleyball_table</code> is a matrix in which each column corresponds to
a player and each row corresponds to a volleyball set; <code>volleyball</code>
is the corresponding likelihood function in the form of a <code>hyper2</code>
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(volleyball)</code></pre>


<h3>Details</h3>

<p>A volleyball <dfn>set</dfn> is a Bernoulli trial between two disjoint subsets of
the players.  The two subsets are denoted (after the game) as the
&ldquo;winners&rdquo; and the &ldquo;losers&rdquo;: these are denoted by <code>1</code>
and <code>0</code> respectively.
</p>
<p>Thus the first line reads of <code>volleyball_results</code> reads:
</p>
<pre>
 p1  p2  p3  p4  p5  p6  p7  p8  p9 
 1    0  NA   1   0   0  NA   1  NA
</pre>
<p>showing that the teams were <code>p1</code>, <code>p4</code> and <code>p8</code> against
<code>p2</code>, <code>p5</code> and <code>p6</code>; players <code>p3</code>, <code>p7</code> and
<code>p9</code> did not play.
</p>
<p>These datasets illustrate the fact that such Bernoulli trials are only
weakly informative.  
</p>
<p>These objects can be generated by running script
<code>inst/volleyball.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>volleyball.rda</code> which
resides in the <code>data/</code> directory.
</p>


<h3>Source</h3>

<p>Volleyball games at <abbr><span class="acronym">NOCS</span></abbr>, 2006-2008
</p>


<h3>References</h3>

<p>Robin K. S. Hankin (2010).
&ldquo;A Generalization of the Dirichlet Distribution&rdquo;,
<em>Journal of Statistical Software</em>, 33(11), 1-18
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
volleyball == volley(volleyball_table)  # should be TRUE


</code></pre>

<hr>
<h2 id='volvo'>Race results from the 2014-2015 Volvo Ocean Race</h2><span id='topic+volvo'></span><span id='topic+volvo_ocean_race'></span><span id='topic+volvo_table_2014'></span><span id='topic+volvo2014'></span><span id='topic+volvo_table'></span><span id='topic+volvo_maxp'></span>

<h3>Description</h3>

<p>Race results from the twelfth edition of the
round-the-world Volvo Ocean Race.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(volvo)</code></pre>


<h3>Format</h3>

<p>A <code>hyper2</code> object that gives a likelihood function</p>


<h3>Details</h3>

<p>Object <code>volvo</code> is a <code>hyper2</code> object that gives a likelihood
function for the strengths of the competitors of the 2014-2015 Volvo
Ocean Race; <code>volvo_maxp</code> is a precomputed maximum likelihood
estimate of the competitors' strengths.  Object <code>volvo_table</code> is a
data frame with rows being teams and columns being legs.
</p>
<p>These objects can be generated by running script <code>inst/volvo.Rmd</code>,
which includes some further discussion and technical documentation and
creates file <code>volvo.rda</code> which resides in the <code>data/</code>
directory.
</p>


<h3>References</h3>

<p>Wikipedia contributors, 2019.
&ldquo;2014-2015 Volvo Ocean Race&rdquo;.  In <em>Wikipedia, the free encyclopedia</em>.
Retrieved 22:21, February 28, 2020.
<a href="https://en.wikipedia.org/w/index.php?title=2014%E2%80%932015_Volvo_Ocean_Race&amp;oldid=914916131">https://en.wikipedia.org/w/index.php?title=2014%E2%80%932015_Volvo_Ocean_Race&amp;oldid=914916131</a>,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordertable2supp">ordertable2supp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pie(volvo_maxp)
# equalp.test(volvo)   # takes ~10 seconds to run

# convert table to a support function:
rank_likelihood(wikitable_to_ranktable(volvo_table))


</code></pre>

<hr>
<h2 id='zapweak'>Zap weak competitors</h2><span id='topic+zapweak'></span>

<h3>Description</h3>

<p>Given a <code>hyper2</code> object, discard competitors with a small estimated
strength.</p>


<h3>Usage</h3>

<pre><code class='language-R'>zapweak(H, minstrength = 1e-05, maxit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zapweak_+3A_h">H</code></td>
<td>
<p>Object of class <code>hyper2</code></p>
</td></tr>
<tr><td><code id="zapweak_+3A_minstrength">minstrength</code></td>
<td>
<p>Strength below which to discard competitors</p>
</td></tr>
<tr><td><code id="zapweak_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations; if missing, use
<code>size(H)-1</code></p>
</td></tr>
<tr><td><code id="zapweak_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>maxp()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iteratively discards the weakest player (if the estimated strength is
less than <code>minstrength</code>) using <code>discard_flawed()</code>.
<code>maxp(..,n=1)</code> for efficiency.  
</p>


<h3>Value</h3>

<p>Returns a slimmed-down <code>hyper2</code> object with weak players
removed.
</p>


<h3>Note</h3>

<p>This function is experimental and appears to be overly aggressive.
For some likelihood functions <code>zapweak()</code> removes <em>all</em> the
players.
</p>
<p>I now think that there is no consistent way to remove weaker players
from a likelihood function.  I think the only way to do it is to look
at the dataset that generates the likelihood function, somehow weed
out the players with the poorest performance, and generate a new
likelihood function without them.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+discard_flawed">discard_flawed</a></code>,<code><a href="#topic+maxp">maxp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> zapweak(icons)        # removes noone
# zapweak(rowing)      # removes everyone...

</code></pre>

<hr>
<h2 id='zipf'>Zipf's law</h2><span id='topic+zipf'></span>

<h3>Description</h3>

<p>A very short function that reproduces Zipf's law: a harmonic rank-probability
distribution, formally
</p>
<p style="text-align: center;"><code class="reqn">p(i)=\frac{i^{-1}}{\sum_{i=1}^{N} i^{-1}},\qquad i=1,\ldots,N</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>zipf(n)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipf_+3A_n">n</code></td>
<td>
<p>Integer; if a hyper2 object is supplied this is
interpreted as <code>size(n)</code></p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a numeric vector summing to one</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+knownp.test">knownp.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
zipf(icons)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
