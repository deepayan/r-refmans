<!DOCTYPE html><html><head><title>Help for package tergm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tergm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tergm-package'><p>Fit, Simulate and Diagnose Dynamic Network Models derived from</p>
Exponential-Family Random Graph Models</a></li>
<li><a href='#.extract.fd.formulae'><p>An Internal Function for Extracting (Some) Formation and Dissolution Formulas from a Combined Formula</p></a></li>
<li><a href='#Change-ergmTerm'><p>The Change Operator Term</p></a></li>
<li><a href='#control.simulate.network'><p>Auxiliary for Controlling Separable Temporal ERGM Simulation</p></a></li>
<li><a href='#control.simulate.tergm'><p>Auxiliary for Controlling Temporal ERGM Simulation</p></a></li>
<li><a href='#control.stergm'><p>Auxiliary for Controlling Separable Temporal ERGM Fitting</p></a></li>
<li><a href='#control.tergm'><p>Auxiliary for Controlling Temporal ERGM Fitting</p></a></li>
<li><a href='#control.tergm.godfather'><p>Control parameters for <code>tergm.godfather()</code>.</p></a></li>
<li><a href='#Cross-ergmTerm'><p>The Crossection Operator Term</p></a></li>
<li><a href='#degrange.mean.age-ergmTerm'><p>Average age of ties incident on nodes having degree in a given range</p></a></li>
<li><a href='#degree.mean.age-ergmTerm'><p>Average age of ties incident on nodes having a given degree</p></a></li>
<li><a href='#discord-ergmHint'><p>Discordant dyads</p></a></li>
<li><a href='#discordBDStratTNT-ergmProposal'><p>Temperal TNT proposal with degree bounds</p></a></li>
<li><a href='#discordTNT-ergmProposal'><p>Temperal TNT proposal</p></a></li>
<li><a href='#Diss-ergmTerm'><p>The Dissolution Operator Term</p></a></li>
<li><a href='#edge.ages-ergmTerm'><p>Sum of ages of extant ties</p></a></li>
<li><a href='#EdgeAges-ergmTerm'><p>The EdgeAges Operator Term</p></a></li>
<li><a href='#edgecov.ages-ergmTerm'><p>Weighted sum of ages of extant ties</p></a></li>
<li><a href='#edgecov.mean.age-ergmTerm'><p>Weighted average age of an extant tie</p></a></li>
<li><a href='#edges.ageinterval-ergmTerm'><p>Number of edges with age falling into a specified range</p></a></li>
<li><a href='#Form-ergmTerm'><p>The Formation Operator Term</p></a></li>
<li><a href='#impute.network.list'><p>Impute missing dyads in a series of networks</p></a></li>
<li><a href='#is.durational'><p>Testing for duration dependent models</p></a></li>
<li><a href='#lasttoggle'><p>Lasttoggle</p></a></li>
<li><a href='#mean.age-ergmTerm'><p>Average age of an extant tie</p></a></li>
<li><a href='#NetSeries'><p>A network series specification for conditional modeling.</p></a></li>
<li><a href='#nodefactor.mean.age-ergmTerm'><p>Average ages of extant half-ties incident on nodes of specified attribute levels</p></a></li>
<li><a href='#nodemix.mean.age-ergmTerm'><p>Average ages of extant ties of specified mixing types</p></a></li>
<li><a href='#Persist-ergmTerm'><p>The Persistence Operator Term</p></a></li>
<li><a href='#simulate.network'><p>STERGM wrappers for TERGM simulation</p></a></li>
<li><a href='#simulate.tergm'><p>Draw from the distribution of a Temporal Exponential Family</p>
Random Graph Model</a></li>
<li><a href='#snctrl'><p>Statnet Control</p></a></li>
<li><a href='#staticDiscordTNT-ergmProposal'><p>TNT proposal for CMLE fitting</p></a></li>
<li><a href='#stergm'><p>Separable Temporal Exponential Family Random Graph Models (Deprecated)</p></a></li>
<li><a href='#summary_formula.networkDynamic'><p>Calculation of networkDynamic statistics.</p></a></li>
<li><a href='#tergm'><p>Temporal Exponential-Family Random Graph Models</p></a></li>
<li><a href='#tergm_MCMC_sample'><p>Collects a sample of networks and returns the statistics of each sample</p></a></li>
<li><a href='#tergm-deprecated'><p>Functions that will no longer be supported in future releases of the package</p></a></li>
<li><a href='#tergm.godfather'><p>A function to apply a given series of changes to a network.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>4.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-30</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit, Simulate and Diagnose Models for Network Evolution Based on
Exponential-Family Random Graph Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>ergm (&ge; 4.5.0), network (&ge; 1.18.0), networkDynamic (&ge;
0.11.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, robustbase (&ge; 0.93.5), coda (&ge; 0.19.2), nlme
(&ge; 3.1.139), MASS (&ge; 7.3.51.4), statnet.common (&ge; 4.9.0),
ergm.multi (&ge; 0.2.0), purrr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>ergm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice (&ge; 0.20.38), parallel, rmarkdown (&ge; 1.12), knitr
(&ge; 1.22), tibble, testthat, covr, networkLite</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statnet/tergm/issues">https://github.com/statnet/tergm/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>An integrated set of extensions to the 'ergm' package to analyze and simulate network evolution based on exponential-family random graph models (ERGM). 'tergm' is a part of the 'statnet' suite of packages for network analysis. See Krivitsky and Handcock (2014) &lt;<a href="https://doi.org/10.1111%2Frssb.12014">doi:10.1111/rssb.12014</a>&gt; and Carnegie, Krivitsky, Hunter, and Goodreau (2015) &lt;<a href="https://doi.org/10.1080%2F10618600.2014.903087">doi:10.1080/10618600.2014.903087</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statnet.org">https://statnet.org</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-30 10:29:49 UTC; pavel</td>
</tr>
<tr>
<td>Author:</td>
<td>Pavel N. Krivitsky
    <a href="https://orcid.org/0000-0002-9101-3362"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Mark S. Handcock [aut, ths],
  David R. Hunter [ctb],
  Steven M. Goodreau [ctb, ths],
  Martina Morris [ctb, ths],
  Nicole Bohme Carnegie [ctb],
  Carter T. Butts [ctb],
  Ayn Leslie-Cook [ctb],
  Skye Bender-deMoll [ctb],
  Li Wang [ctb],
  Kirk Li [ctb],
  Chad Klumb [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pavel N. Krivitsky &lt;pavel@statnet.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-30 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tergm-package'>Fit, Simulate and Diagnose Dynamic Network Models derived from
Exponential-Family Random Graph Models</h2><span id='topic+tergm-package'></span>

<h3>Description</h3>

<p><code><a href="#topic+tergm-package">tergm</a></code> is a collection of extensions to the
<code><a href="ergm.html#topic+ergm-package">ergm</a></code> package to fit, diagnose, and simulate
models for dynamic networks &mdash; networks that evolve over time &mdash; based on
exponential-family random graph models (ERGMs). For a list of functions type
<code>help(package='tergm')</code>
</p>


<h3>Details</h3>

<p>When publishing results obtained using this package, please cite the
original authors as described in <code>citation(package="tergm")</code>.
</p>
<p>All programs derived from this package must cite it.
</p>
<p>An exponential-family random graph model (ERGM) postulates an exponential
family over the sample space of networks of interest, and
<code><a href="ergm.html#topic+ergm-package">ergm</a></code> package implements a suite of tools for
modeling single networks using ERGMs.
</p>
<p>There have been a number of extensions of ERGMs for modeling the evolution
of networks, including the temporal ERGM (TERGM) of Hanneke et al. (2010)
and the separable termporal ERGM (STERGM) of Krivitsky and Handcock (2014).
The latter model allows familiar ERGM terms and statistics to be reused in a
dynamic context, interpreted in terms of formation and dissolution
(persistence) of ties. Krivitsky (2012) suggested a method for fitting
dynamic models when only a cross-sectional network is available, provided
some temporal information for it is available as well.
</p>
<p>This package aims to implement these and other ERGM-based models for network
evolution. At this time, it implements, via the <code><a href="#topic+tergm">tergm</a></code>
function, a general framework for modeling tie dynamics in temporal networks
with flexible model specification (including (S)TERGMs).  Estimation options
include a conditional MLE (CMLE) approach for fitting to a series of
networks and an Equilibrium Generalized Method of Moments Estimation (EGMME)
for fitting to a single network with temporal information. For further
development, see the referenced papers.
</p>


<h3>Temporal model specification in <span class="pkg">tergm</span></h3>

<p>The operator terms implemented by <span class="pkg">tergm</span> are <code>Form()</code>,
<code>Persist()</code>, <code>Diss()</code>, <code>Cross()</code>, and <code>Change()</code>.  These are used
to specify how the <code>ergm</code> terms (<code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code>) in a formula are
evaluated across a network time-series.  Note, you cannot use one
of these operators within another temporal, so
<code>Cross(~Form(~edges))</code> is not a valid specification. (Generally,
nesting these operators within other operators will often not work;
nesting other operators within them will almost always work,
however.)
</p>
<p>The durational terms are distinguished either by their name,
<code>mean.age</code>, or their name extensions: <code style="white-space: pre;">&#8288;&lt;name&gt;.ages&#8288;</code>,
<code style="white-space: pre;">&#8288;&lt;name&gt;.mean.age&#8288;</code>, and <code style="white-space: pre;">&#8288;&lt;name&gt;.age.interval&#8288;</code>.  In contrast to
their eponymous terms in <span class="pkg">ergm</span>, these durational
terms take into account the elapsed time since each (term-relevant) dyad in
the network was last toggled.
</p>
<p>As currently implemented, the package does not support use of many
durational terms during estimation, though it may work with some.
But durational terms may be used as targets, monitors, or summary
statistics.  The ability to use these terms in the estimation of
models is under development.
</p>


<h3>Compatibility with previous versions</h3>

<p>If you previously used the <code><a href="#topic+stergm">stergm()</a></code> function in this package, please
note that <code><a href="#topic+stergm">stergm()</a></code> has been superceded by the new <code><a href="#topic+tergm">tergm</a></code>
function, and has been deprecated.  The
<code>dissolution</code> formula in <code><a href="#topic+stergm">stergm()</a></code> maps to the new <code>Persist()</code>
operator in the <code><a href="#topic+tergm">tergm()</a></code> function, <strong>not</strong> the <code>Diss()</code> operator.
</p>
<p>For detailed information on how to download and install the software, go to
the Statnet project website: <a href="https://statnet.org">https://statnet.org</a>.  A tutorial, support
newsgroup, references and links to further resources are provided there.
</p>


<h3>References</h3>

<p>Hanneke S, Fu W and Xing EP (2010). Discrete
Temporal Models of Social Networks. <em>Electronic Journal of Statistics</em>,
2010, 4, 585-605.
<a href="https://doi.org/10.1214/09-EJS548">doi:10.1214/09-EJS548</a>
</p>
<p>Krackhardt, D and Handcock, MS (2006) Heider vs Simmel: Emergent
features in dynamic structures.  ICML Workshop on Statistical
Network Analysis. Springer, Berlin, Heidelberg, 2006.
</p>
<p>Krivitsky PN &amp; Handcock MS (2014) A Separable Model for Dynamic
Networks. <em>Journal of the Royal Statistical Society, Series B</em>, 76(1):
29-46. <a href="https://doi.org/10.1111/rssb.12014">doi:10.1111/rssb.12014</a>
</p>
<p>Krivitsky, PN (2012). Modeling of Dynamic Networks based on
Egocentric Data with Durational Information. <em>Pennsylvania State
University Department of Statistics Technical Report</em>, 2012(2012-01).
<a href="https://web.archive.org/web/20170830053722/https://stat.psu.edu/research/technical-report-files/2012-technical-reports/TR1201A.pdf">https://web.archive.org/web/20170830053722/https://stat.psu.edu/research/technical-report-files/2012-technical-reports/TR1201A.pdf</a>
</p>
<p>Butts CT (2008).  <span class="pkg">network</span>: A Package for Managing Relational
Data in .  <em>Journal of Statistical Software</em>, 24(2).
<a href="https://doi.org/10.18637/jss.v024.i02">doi:10.18637/jss.v024.i02</a>
</p>
<p>Goodreau SM, Handcock MS, Hunter DR, Butts CT, Morris M (2008a).  A
<span class="pkg">statnet</span> Tutorial.  <em>Journal of Statistical Software</em>, 24(8).
<a href="https://doi.org/10.18637/jss.v024.i08">doi:10.18637/jss.v024.i08</a>
</p>
<p>Hunter, D. R. and Handcock, M. S. (2006) Inference in curved
exponential family models for networks, <em>Journal of Computational and
Graphical Statistics</em>, 15: 565-583
</p>
<p>Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b).
<span class="pkg">ergm</span>: A Package to Fit, Simulate and Diagnose Exponential-Family
Models for Networks.  <em>Journal of Statistical Software</em>, 24(3).
<a href="https://doi.org/10.18637/jss.v024.i03">doi:10.18637/jss.v024.i03</a>
</p>
<p>Morris M, Handcock MS, Hunter DR (2008).  Specification of
Exponential-Family Random Graph Models: Terms and Computational Aspects.
<em>Journal of Statistical Software</em>, 24(4).
<a href="https://doi.org/10.18637/jss.v024.i04">doi:10.18637/jss.v024.i04</a>
</p>

<hr>
<h2 id='.extract.fd.formulae'>An Internal Function for Extracting (Some) Formation and Dissolution Formulas from a Combined Formula</h2><span id='topic+.extract.fd.formulae'></span>

<h3>Description</h3>

<p>This function is used in <code>tergm.EGMME.initialfit</code> and also when targets or monitoring
formulas are specified by characters.  It makes a basic attempt to identify the
formation and dissolution formulas within a larger combined formula (which may also
include non-separable terms).  Instances of <code>Form</code> at the top level (which may occur
inside <code>offset</code>) contribute to the formation formula; instances of <code>Persist</code> and
<code>Diss</code> at the top level (which may also occur inside <code>offset</code>) contribute to the
dissolution formula.  All other terms are regarded as non-separable; this includes instances
of <code>Form</code>, <code>Persist</code>, and <code>Diss</code> that occur inside other operator terms,
including inside <code>Offset</code>, and also includes all interactions at the top level (for which
the top level term is effectively the interaction operator <code>*</code> or <code>:</code>),
whether or not they include <code>Form</code>, <code>Persist</code>, and/or <code>Diss</code>.
The formation and dissolution formulas are obtained by adding
the contributing terms, replacing <code>Form</code> and <code>Persist</code> with trivial operators that protect
the environments of their formula arguments but have no effect on statistics or coefficient names
(meaning the formulas effectively become cross-sectional), and replacing <code>Diss</code> by a similar operator
that negates statistics.  These are included in the return value as the <code>form</code> and <code>pers</code>
elements of the list (the &quot;dissolution&quot; formula really being the persistence formula), which also includes
the formula of non-separable terms as <code>nonsep</code>, and the formula of all terms after replacing
<code>Form</code>, <code>Persist</code>, and <code>Diss</code> as described above as <code>all</code>.
</p>
<p>If usage proves problematic, one may specify the monitoring and/or targets formulas explicitly
(rather than by characters), and one may pass initial coefficient values for the EGMME to avoid
running <code>tergm.EGMME.initialfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extract.fd.formulae(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".extract.fd.formulae_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing <code>form</code>, <code>pers</code>, <code>nonsep</code>, and <code>all</code> formulas as described above.
</p>

<hr>
<h2 id='Change-ergmTerm'>The Change Operator Term</h2><span id='topic+Change-ergmTerm'></span><span id='topic+InitErgmTerm.Change+20+28dynamic+29'></span><span id='topic+InitErgmTerm.Change'></span>

<h3>Description</h3>

<p>The Change Operator Term
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Change(
#           formula,
#           lm = ~1,
#           subset = TRUE,
#           weights = 1,
#           contrasts = NULL,
#           offset = 0,
#           label = NULL
#         )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Change-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="ergm.html#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Change-ergmTerm_+3A_lm">lm</code>, <code id="Change-ergmTerm_+3A_subset">subset</code>, <code id="Change-ergmTerm_+3A_weights">weights</code>, <code id="Change-ergmTerm_+3A_contrasts">contrasts</code>, <code id="Change-ergmTerm_+3A_offset">offset</code>, <code id="Change-ergmTerm_+3A_label">label</code></td>
<td>
<p><strong><code><a href="#topic+NetSeries">NetSeries()</a></code> LHS only</strong> arguments to specify time-varying parameters. See <code><a href="ergm.multi.html#topic+N-ergmTerm-c9b59cc1">N()</a></code> term operator in the <span class="pkg">ergm.multi</span> for details. <code>lm</code> formula may reference <code>.Time</code> for the network's time index, <code>.TimeID</code> for the its index in the network series (where the initial network is 1 and the first modelled network is 2), and <code>.TimeDelta</code> for the time elapsed between the network and the immediately previous network in the series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term accepts a model formula
and produces the corresponding model for a network constructed
by taking the dyads that have changed between time steps.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='control.simulate.network'>Auxiliary for Controlling Separable Temporal ERGM Simulation</h2><span id='topic+control.simulate.network'></span><span id='topic+control.simulate.stergm'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning STERGM simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.simulate.network(
  MCMC.burnin.min = 1000,
  MCMC.burnin.max = 1e+05,
  MCMC.burnin.pval = 0.5,
  MCMC.burnin.add = 1,
  MCMC.prop.form = ~discord + sparse,
  MCMC.prop.diss = ~discord + sparse,
  MCMC.prop.weights.form = "default",
  MCMC.prop.weights.diss = "default",
  MCMC.prop.args.form = NULL,
  MCMC.prop.args.diss = NULL,
  MCMC.maxedges = Inf,
  MCMC.maxchanges = 1e+06,
  term.options = NULL,
  MCMC.packagenames = c()
)

control.simulate.stergm(
  MCMC.burnin.min = NULL,
  MCMC.burnin.max = NULL,
  MCMC.burnin.pval = NULL,
  MCMC.burnin.add = NULL,
  MCMC.prop.form = NULL,
  MCMC.prop.diss = NULL,
  MCMC.prop.weights.form = NULL,
  MCMC.prop.weights.diss = NULL,
  MCMC.prop.args.form = NULL,
  MCMC.prop.args.diss = NULL,
  MCMC.maxedges = NULL,
  MCMC.maxchanges = NULL,
  term.options = NULL,
  MCMC.packagenames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.simulate.network_+3A_mcmc.burnin.min">MCMC.burnin.min</code>, <code id="control.simulate.network_+3A_mcmc.burnin.max">MCMC.burnin.max</code>, <code id="control.simulate.network_+3A_mcmc.burnin.pval">MCMC.burnin.pval</code>, <code id="control.simulate.network_+3A_mcmc.burnin.add">MCMC.burnin.add</code></td>
<td>
<p>Number of Metropolis-Hastings steps per time step used in simulation. By default, this
is determined adaptively by keeping track of increments in the
Hamming distance between the transitioned-from network and the
network being sampled. Once <code>MCMC.burnin.min</code> steps have elapsed, the
increments are tested against 0, and when their average number
becomes statistically indistinguishable from 0 (with the p-value
being greater than <code>MCMC.burnin.pval</code>), or
<code>MCMC.burnin.max</code> steps are proposed, whichever comes first,
the simulation is stopped after an additional
<code>MCMC.burnin.add</code> times the number of elapsed steps have been
taken.  (Stopping immediately would bias the sampling.)
</p>
<p>To use a fixed number of steps, set <code>MCMC.burnin.min</code>
and <code>MCMC.burnin.max</code> to the same value.</p>
</td></tr>
<tr><td><code id="control.simulate.network_+3A_mcmc.prop.form">MCMC.prop.form</code></td>
<td>
<p>Hints and/or constraints for selecting and initializing the proposal.</p>
</td></tr>
<tr><td><code id="control.simulate.network_+3A_mcmc.prop.weights.form">MCMC.prop.weights.form</code></td>
<td>
<p>Specifies the proposal weighting scheme to
be used in the MCMC Metropolis-Hastings algorithm.  Possible
choices may be determined by calling <code><a href="ergm.html#topic+ergm_proposal_table">ergm_proposal_table</a></code>.</p>
</td></tr>
<tr><td><code id="control.simulate.network_+3A_mcmc.prop.weights.diss">MCMC.prop.weights.diss</code>, <code id="control.simulate.network_+3A_mcmc.prop.args.diss">MCMC.prop.args.diss</code>, <code id="control.simulate.network_+3A_mcmc.prop.diss">MCMC.prop.diss</code></td>
<td>
<p>Ignored. These are included
for backwards compatibility of calls to <code>control</code>
functions only; they have no effect on <code>simulate</code> behavior.</p>
</td></tr>
<tr><td><code id="control.simulate.network_+3A_mcmc.prop.args.form">MCMC.prop.args.form</code></td>
<td>
<p>An alternative,
direct way of specifying additional arguments to proposals.</p>
</td></tr>
<tr><td><code id="control.simulate.network_+3A_mcmc.maxedges">MCMC.maxedges</code></td>
<td>
<p>The maximum number of edges that may occur during the MCMC sampling. If this number is exceeded at any time, sampling is stopped immediately.</p>
</td></tr>
<tr><td><code id="control.simulate.network_+3A_mcmc.maxchanges">MCMC.maxchanges</code></td>
<td>
<p>Maximum number of changes for
which to allocate space.</p>
</td></tr>
<tr><td><code id="control.simulate.network_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="ergm.html#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="control.simulate.network_+3A_mcmc.packagenames">MCMC.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="stats.html#topic+simulate">simulate</a></code>
function.  See the <code>usage</code> section in <code><a href="#topic+simulate.stergm">simulate.stergm</a></code> for
details.
</p>
<p>These functions are included for backwards compatibility, and users are
encouraged to use <code>control.simulate.tergm</code> or
<code>control.simulate.formula.tergm</code> with the <code><a href="#topic+simulate.tergm">simulate.tergm</a></code>
family of functions instead.  When a
<code>control.simulate.stergm</code> or <code>control.simulate.network</code> object
is passed to one of the <code><a href="#topic+simulate.stergm">simulate.stergm</a></code> functions,
the corresponding <code><a href="#topic+simulate.tergm">simulate.tergm</a></code> function is invoked,
and uses the formation proposal control arguments, ignoring the
dissolution proposal control arguments.
</p>
<p>Note:  The old <code>dissolution</code> formula in <code>stergm</code> represents
tie persistence.  As a result it maps to the new <code>Persist()</code> operator
in <code>tergm</code>, NOT the <code>Diss()</code> operator
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.stergm">simulate.stergm</a></code>,
<code><a href="ergm.html#topic+simulate.formula">simulate.formula</a></code>.  <code><a href="#topic+control.stergm">control.stergm</a></code>
performs a similar function for <code><a href="#topic+stergm">stergm</a></code>.
</p>

<hr>
<h2 id='control.simulate.tergm'>Auxiliary for Controlling Temporal ERGM Simulation</h2><span id='topic+control.simulate.tergm'></span><span id='topic+control.simulate.formula.tergm'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning TERGM simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.simulate.tergm(
  MCMC.burnin.min = NULL,
  MCMC.burnin.max = NULL,
  MCMC.burnin.pval = NULL,
  MCMC.burnin.add = NULL,
  MCMC.prop = NULL,
  MCMC.prop.weights = NULL,
  MCMC.prop.args = NULL,
  MCMC.maxedges = NULL,
  MCMC.maxchanges = NULL,
  term.options = NULL,
  MCMC.packagenames = NULL
)

control.simulate.formula.tergm(
  MCMC.burnin.min = 1000,
  MCMC.burnin.max = 1e+05,
  MCMC.burnin.pval = 0.5,
  MCMC.burnin.add = 1,
  MCMC.prop = ~discord + sparse,
  MCMC.prop.weights = "default",
  MCMC.prop.args = NULL,
  MCMC.maxedges = Inf,
  MCMC.maxchanges = 1e+06,
  term.options = NULL,
  MCMC.packagenames = c()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.simulate.tergm_+3A_mcmc.burnin.min">MCMC.burnin.min</code>, <code id="control.simulate.tergm_+3A_mcmc.burnin.max">MCMC.burnin.max</code>, <code id="control.simulate.tergm_+3A_mcmc.burnin.pval">MCMC.burnin.pval</code>, <code id="control.simulate.tergm_+3A_mcmc.burnin.add">MCMC.burnin.add</code></td>
<td>
<p>Number of Metropolis-Hastings steps
per time step used in simulation. By default, this
is determined adaptively by keeping track of increments in the
Hamming distance between the transitioned-from network and the
network being sampled. Once <code>MCMC.burnin.min</code> steps have elapsed, the
increments are tested against 0, and when their average number
becomes statistically indistinguishable from 0 (with the p-value
being greater than <code>MCMC.burnin.pval</code>), or
<code>MCMC.burnin.max</code> steps are proposed, whichever comes first,
the simulation is stopped after an additional
<code>MCMC.burnin.add</code> times the number of elapsed steps have been
taken.  (Stopping immediately would bias the sampling.)
</p>
<p>To use a fixed number of steps, set <code>MCMC.burnin.min</code>
and <code>MCMC.burnin.max</code> to the same value.</p>
</td></tr>
<tr><td><code id="control.simulate.tergm_+3A_mcmc.prop">MCMC.prop</code></td>
<td>
<p>Hints and/or constraints for selecting and initializing the proposal.</p>
</td></tr>
<tr><td><code id="control.simulate.tergm_+3A_mcmc.prop.weights">MCMC.prop.weights</code></td>
<td>
<p>Specifies the proposal weighting scheme to
be used in the MCMC Metropolis-Hastings algorithm.  Possible
choices may be determined by calling <code><a href="ergm.html#topic+ergm_proposal_table">ergm_proposal_table</a></code>.</p>
</td></tr>
<tr><td><code id="control.simulate.tergm_+3A_mcmc.prop.args">MCMC.prop.args</code></td>
<td>
<p>An alternative, direct way of specifying
additional arguments to the proposal.</p>
</td></tr>
<tr><td><code id="control.simulate.tergm_+3A_mcmc.maxedges">MCMC.maxedges</code></td>
<td>
<p>The maximum number of edges that may occur during the MCMC sampling. If this number is exceeded at any time, sampling is stopped immediately.</p>
</td></tr>
<tr><td><code id="control.simulate.tergm_+3A_mcmc.maxchanges">MCMC.maxchanges</code></td>
<td>
<p>Maximum number of changes for
which to allocate space.</p>
</td></tr>
<tr><td><code id="control.simulate.tergm_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="ergm.html#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="control.simulate.tergm_+3A_mcmc.packagenames">MCMC.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="stats.html#topic+simulate">simulate</a></code>
function.  See the <code>usage</code> section in <code><a href="#topic+simulate.tergm">simulate.tergm</a></code> for
details.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.tergm">simulate.tergm</a></code>,
<code><a href="ergm.html#topic+simulate.formula">simulate.formula</a></code>.  <code><a href="#topic+control.tergm">control.tergm</a></code>
performs a similar function for <code><a href="#topic+tergm">tergm</a></code>.
</p>

<hr>
<h2 id='control.stergm'>Auxiliary for Controlling Separable Temporal ERGM Fitting</h2><span id='topic+control.stergm'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning 'stergm' fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.stergm(
  init.form = NULL,
  init.diss = NULL,
  init.method = NULL,
  force.main = FALSE,
  MCMC.prop.form = ~discord + sparse,
  MCMC.prop.diss = ~discord + sparse,
  MCMC.prop.weights.form = "default",
  MCMC.prop.args.form = NULL,
  MCMC.prop.weights.diss = "default",
  MCMC.prop.args.diss = NULL,
  MCMC.maxedges = Inf,
  MCMC.maxchanges = 1e+06,
  MCMC.packagenames = c(),
  CMLE.MCMC.burnin = 1024 * 16,
  CMLE.MCMC.interval = 1024,
  CMLE.ergm = NULL,
  CMLE.form.ergm = control.ergm(init = init.form, MCMC.burnin = CMLE.MCMC.burnin,
    MCMC.interval = CMLE.MCMC.interval, MCMC.prop = MCMC.prop.form, MCMC.prop.weights =
    MCMC.prop.weights.form, MCMC.prop.args = MCMC.prop.args.form, MCMC.maxedges =
    MCMC.maxedges, MCMC.packagenames = MCMC.packagenames, parallel = parallel,
    parallel.type = parallel.type, parallel.version.check = parallel.version.check,
    parallel.inherit.MT = parallel.inherit.MT, force.main = force.main),
  CMLE.diss.ergm = control.ergm(init = init.diss, MCMC.burnin = CMLE.MCMC.burnin,
    MCMC.interval = CMLE.MCMC.interval, MCMC.prop = MCMC.prop.diss, MCMC.prop.weights =
    MCMC.prop.weights.diss, MCMC.prop.args = MCMC.prop.args.diss, MCMC.maxedges =
    MCMC.maxedges, MCMC.packagenames = MCMC.packagenames, parallel = parallel,
    parallel.type = parallel.type, parallel.version.check = parallel.version.check,
    parallel.inherit.MT = parallel.inherit.MT, force.main = force.main),
  CMLE.NA.impute = c(),
  CMLE.term.check.override = FALSE,
  EGMME.main.method = c("Gradient-Descent"),
  EGMME.initialfit.control = control.ergm(),
  EGMME.MCMC.burnin.min = 1000,
  EGMME.MCMC.burnin.max = 1e+05,
  EGMME.MCMC.burnin.pval = 0.5,
  EGMME.MCMC.burnin.add = 1,
  MCMC.burnin = NULL,
  MCMC.burnin.mul = NULL,
  SAN.maxit = 4,
  SAN.nsteps.times = 8,
  SAN = control.san(term.options = term.options, SAN.maxit = SAN.maxit, SAN.prop =
    MCMC.prop.form, SAN.prop.weights = MCMC.prop.weights.form, SAN.prop.args =
    MCMC.prop.args.form, SAN.nsteps = round(sqrt(EGMME.MCMC.burnin.min *
    EGMME.MCMC.burnin.max)) * SAN.nsteps.times, SAN.packagenames = MCMC.packagenames,
    parallel = parallel, parallel.type = parallel.type, parallel.version.check =
    parallel.version.check, parallel.inherit.MT = FALSE),
  SA.restarts = 10,
  SA.burnin = 1000,
  SA.plot.progress = FALSE,
  SA.max.plot.points = 400,
  SA.plot.stats = FALSE,
  SA.init.gain = 0.1,
  SA.gain.decay = 0.5,
  SA.runlength = 25,
  SA.interval.mul = 2,
  SA.init.interval = 500,
  SA.min.interval = 20,
  SA.max.interval = 500,
  SA.phase1.minruns = 4,
  SA.phase1.tries = 20,
  SA.phase1.jitter = 0.1,
  SA.phase1.max.q = 0.1,
  SA.phase1.backoff.rat = 1.05,
  SA.phase2.levels.max = 40,
  SA.phase2.levels.min = 4,
  SA.phase2.max.mc.se = 0.001,
  SA.phase2.repeats = 400,
  SA.stepdown.maxn = 200,
  SA.stepdown.p = 0.05,
  SA.stop.p = 0.1,
  SA.stepdown.ct = 5,
  SA.phase2.backoff.rat = 1.1,
  SA.keep.oh = 0.5,
  SA.keep.min.runs = 8,
  SA.keep.min = 0,
  SA.phase2.jitter.mul = 0.2,
  SA.phase2.maxreljump = 4,
  SA.guard.mul = 4,
  SA.par.eff.pow = 1,
  SA.robust = FALSE,
  SA.oh.memory = 1e+05,
  SA.refine = c("mean", "linear", "none"),
  SA.se = TRUE,
  SA.phase3.samplesize.runs = 10,
  SA.restart.on.err = TRUE,
  term.options = NULL,
  seed = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.stergm_+3A_init.form">init.form</code>, <code id="control.stergm_+3A_init.diss">init.diss</code></td>
<td>
<p>numeric or <code>NA</code> vector equal in
length to the number of parameters in the formation/dissolution
model or <code>NULL</code> (the default); the initial values for the
estimation and coefficient offset terms. If <code>NULL</code> is
passed, all of the initial values are computed using the method
specified by <code><a href="ergm.html#topic+control.ergm">control$init.method</a></code>.
If a numeric vector is given, the elements of the vector are
interpreted as follows: </p>
 <ul>
<li><p> Elements corresponding to
terms enclosed in <code>offset()</code> are used as the fixed offset
coefficients. These should match the offset values given in
<code>offset.coef.form</code> and <code>offset.coef.diss</code>.
</p>
</li>
<li><p> Elements that do not correspond to offset terms and are not
<code>NA</code> are used as starting values in the estimation.
</p>
</li>
<li><p> Initial values for the elements that are <code>NA</code> are fit
using the method specified by
<code><a href="ergm.html#topic+control.ergm">control$init.method</a></code>.
</p>
</li></ul>
<p> Passing coefficients from a previous run can be used to
&quot;resume&quot; an uncoverged <code><a href="#topic+stergm">stergm</a></code> run.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_init.method">init.method</code></td>
<td>
<p>Estimation method used to acquire initial values
for estimation. If <code>NULL</code> (the default), the initial values
are computed using the edges dissolution approximation (Carnegie
et al.) when appropriate; note that this relies on <code><a href="#topic+.extract.fd.formulae">.extract.fd.formulae</a></code>
to identify the formation and dissolution parts of the formula; the user should
be aware of its behavior and limitations.
If <code>init.method</code> is set to &quot;zeros&quot;, the initial values are set to zeros.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_force.main">force.main</code></td>
<td>
<p>Logical: If TRUE, then force MCMC-based
estimation method, even if the exact MLE can be computed via
maximum pseudolikelihood estimation.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_mcmc.prop.form">MCMC.prop.form</code></td>
<td>
<p>Hints and/or constraints for selecting and initializing the proposal.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_mcmc.prop.weights.form">MCMC.prop.weights.form</code></td>
<td>
<p>Specifies the proposal weighting to use.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_mcmc.prop.args.form">MCMC.prop.args.form</code></td>
<td>
<p>A direct way of specifying arguments to the proposal.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_mcmc.prop.weights.diss">MCMC.prop.weights.diss</code>, <code id="control.stergm_+3A_mcmc.prop.args.diss">MCMC.prop.args.diss</code>, <code id="control.stergm_+3A_mcmc.prop.diss">MCMC.prop.diss</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_mcmc.maxedges">MCMC.maxedges</code></td>
<td>
<p>The maximum number of edges that may occur during the MCMC sampling. If this number is exceeded at any time, sampling is stopped immediately.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_mcmc.maxchanges">MCMC.maxchanges</code></td>
<td>
<p>Maximum number of changes in dynamic
network simulation for which to allocate space.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_mcmc.packagenames">MCMC.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_cmle.mcmc.burnin">CMLE.MCMC.burnin</code></td>
<td>
<p>Burnin used in CMLE fitting.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_cmle.mcmc.interval">CMLE.MCMC.interval</code></td>
<td>
<p>Number of Metropolis-Hastings steps
between successive draws when running MCMC MLE.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_cmle.ergm">CMLE.ergm</code></td>
<td>
<p>A convenience argument for specifying both
<code>CMLE.form.ergm</code> and <code>CMLE.diss.ergm</code> at once.
See <code><a href="ergm.html#topic+control.ergm">control.ergm</a></code>.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_cmle.form.ergm">CMLE.form.ergm</code></td>
<td>
<p>Control parameters used to fit the CMLE.  See
<code><a href="ergm.html#topic+control.ergm">control.ergm</a></code>.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_cmle.diss.ergm">CMLE.diss.ergm</code></td>
<td>
<p>Ignored, with the exception of initial parameter values.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_cmle.na.impute">CMLE.NA.impute</code></td>
<td>
<p>In STERGM CMLE, missing dyads in
transitioned-to networks are accommodated using methods of
Handcock and Gile (2009), but a similar approach to
transitioned-from networks requires much more complex methods
that are not, currently, implemented.  <code>CMLE.NA.impute</code>
controls how missing dyads in transitioned-from networks are be
imputed. See argument <code>imputers</code> of
<code><a href="#topic+impute.network.list">impute.network.list</a></code> for details.
</p>
<p>By default, no imputation is performed, and the fitting stops
with an error if any transitioned-from networks have missing
dyads.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_cmle.term.check.override">CMLE.term.check.override</code></td>
<td>
<p>The method
<code><a href="#topic+stergm">stergm</a>{stergm}</code> uses at this time to fit a series of
more than two networks requires certain assumptions to be made
about the ERGM terms being used, which are tested before a fit is
attempted. This test sometimes fails despite the model being
amenable to fitting, so setting this option to <code>TRUE</code>
overrides the tests.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_egmme.main.method">EGMME.main.method</code></td>
<td>
<p>Estimation method used to find the
Equilibrium Generalized Method of Moments estimator.  Currently
only &quot;Gradient-Descent&quot; is implemented.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_egmme.initialfit.control">EGMME.initialfit.control</code></td>
<td>
<p>Control object for the ergm fit
in tergm.EGMME.initialfit</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_egmme.mcmc.burnin.min">EGMME.MCMC.burnin.min</code>, <code id="control.stergm_+3A_egmme.mcmc.burnin.max">EGMME.MCMC.burnin.max</code></td>
<td>
<p>Number of
Metropolis-Hastings steps
per time step used in EGMME fitting. By default, this is
determined adaptively by keeping track of increments in the
Hamming distance between the transitioned-from network and the
network being sampled. Once <code>EGMME.MCMC.burnin.min</code> steps have elapsed,
the increments are tested against 0, and when their average
number becomes statistically indistinguishable from 0 (with the
p-value being greater than <code>EGMME.MCMC.burnin.pval</code>), or
<code>EGMME.MCMC.burnin.max</code> steps are proposed, whichever comes
first, the simulation is stopped after an additional
<code>EGMME.MCMC.burnin.add</code> times the number of elapsed steps
had been taken. (Stopping immediately would bias the sampling.)
</p>
<p>To use a fixed number of steps, set
<code>EGMME.MCMC.burnin.min</code> and <code>EGMME.MCMC.burnin.max</code> to
the same value.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_egmme.mcmc.burnin.pval">EGMME.MCMC.burnin.pval</code>, <code id="control.stergm_+3A_egmme.mcmc.burnin.add">EGMME.MCMC.burnin.add</code></td>
<td>
<p>Number of
Metropolis-Hastings steps
per time step used in EGMME fitting. By default, this is
determined adaptively by keeping track of increments in the
Hamming distance between the transitioned-from network and the
network being sampled. Once <code>EGMME.MCMC.burnin.min</code> steps have elapsed,
the increments are tested against 0, and when their average
number becomes statistically indistinguishable from 0 (with the
p-value being greater than <code>EGMME.MCMC.burnin.pval</code>), or
<code>EGMME.MCMC.burnin.max</code> steps are proposed, whichever comes
first, the simulation is stopped after an additional
<code>EGMME.MCMC.burnin.add</code> times the number of elapsed steps
had been taken. (Stopping immediately would bias the sampling.)
</p>
<p>To use a fixed number of steps, set
<code>EGMME.MCMC.burnin.min</code> and <code>EGMME.MCMC.burnin.max</code> to
the same value.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_mcmc.burnin">MCMC.burnin</code>, <code id="control.stergm_+3A_mcmc.burnin.mul">MCMC.burnin.mul</code></td>
<td>
<p>No longer used. See
<code>EGMME.MCMC.burnin.min</code>, <code>EGMME.MCMC.burnin.max</code>,
<code>EGMME.MCMC.burnin.pval</code>, <code>EGMME.MCMC.burnin.pval</code>,
<code>EGMME.MCMC.burnin.add</code> and <code>CMLE.MCMC.burnin</code> and
<code>CMLE.MCMC.interval</code>.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_san.maxit">SAN.maxit</code></td>
<td>
<p>When <code>target.stats</code> argument is passed to
<code><a href="ergm.html#topic+ergm">ergm()</a></code>, the maximum number of attempts to use <code><a href="ergm.html#topic+san">san</a></code>
to obtain a network with statistics close to those specified.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_san.nsteps.times">SAN.nsteps.times</code></td>
<td>
<p>Multiplier for <code>SAN.nsteps</code> relative to
<code>MCMC.burnin</code>. This lets one control the amount of SAN burn-in
(arguably, the most important of SAN parameters) without overriding the
other SAN defaults.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_san">SAN</code></td>
<td>
<p>SAN control parameters.  See
<code><a href="ergm.html#topic+control.san">control.san</a></code></p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.restarts">SA.restarts</code></td>
<td>
<p>Maximum number of times to restart a failed
optimization process.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.burnin">SA.burnin</code></td>
<td>
<p>Number of time steps to advance the starting
network before beginning the optimization.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.plot.progress">SA.plot.progress</code>, <code id="control.stergm_+3A_sa.plot.stats">SA.plot.stats</code></td>
<td>
<p>Logical: Plot information
about the fit as it proceeds. If <code>SA.plot.progress==TRUE</code>,
plot the trajectories of the parameters and target statistics as
the optimization progresses. If <code>SA.plot.stats==TRUE</code>, plot
a heatmap representing correlations of target statistics and a
heatmap representing the estimated gradient.
</p>
<p>Do NOT use these with non-interactive plotting devices like
<code><a href="grDevices.html#topic+pdf">pdf</a></code>. (In fact, it will refuse to do that with a
warning.)</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.max.plot.points">SA.max.plot.points</code></td>
<td>
<p>If <code>SA.plot.progress==TRUE</code>, the
maximum number of time points to be plotted. Defaults to 400. If
more iterations elapse, they will be thinned to at most 400
before plotting.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.init.gain">SA.init.gain</code></td>
<td>
<p>Initial gain, the multiplier for the parameter
update size.  If the process initially goes crazy beyond
recovery, lower this value.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.gain.decay">SA.gain.decay</code></td>
<td>
<p>Gain decay factor.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.runlength">SA.runlength</code></td>
<td>
<p>Number of parameter trials and updates per C
run.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.interval.mul">SA.interval.mul</code></td>
<td>
<p>The number of time steps between updates of
the parameters is set to be this times the mean duration of
extant ties.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.init.interval">SA.init.interval</code></td>
<td>
<p>Initial number of time steps between
updates of the parameters.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.min.interval">SA.min.interval</code>, <code id="control.stergm_+3A_sa.max.interval">SA.max.interval</code></td>
<td>
<p>Upper and lower bounds on
the number of time steps between updates of the parameters.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase1.minruns">SA.phase1.minruns</code></td>
<td>
<p>Number of runs during Phase 1 for
estimating the gradient, before every gradient update.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase1.tries">SA.phase1.tries</code></td>
<td>
<p>Number of runs trying to find a reasonable
parameter and network configuration.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase1.jitter">SA.phase1.jitter</code></td>
<td>
<p>Initial jitter standard deviation of each
parameter.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase1.max.q">SA.phase1.max.q</code></td>
<td>
<p>Q-value (false discovery rate) that a
gradient estimate must obtain before it is accepted (since sign
is what is important).</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase1.backoff.rat">SA.phase1.backoff.rat</code>, <code id="control.stergm_+3A_sa.phase2.backoff.rat">SA.phase2.backoff.rat</code></td>
<td>
<p>If the run
produces this relative increase in the approximate objective
function, it will be backed off.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase2.levels.min">SA.phase2.levels.min</code>, <code id="control.stergm_+3A_sa.phase2.levels.max">SA.phase2.levels.max</code></td>
<td>
<p>Range of gain
levels (subphases) to go through.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase2.max.mc.se">SA.phase2.max.mc.se</code></td>
<td>
<p>Approximate precision of the estimates
that must be attained before stopping.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase2.repeats">SA.phase2.repeats</code>, <code id="control.stergm_+3A_sa.stepdown.maxn">SA.stepdown.maxn</code></td>
<td>
<p>A gain level may be
repeated multiple times (up to <code>SA.phase2.repeats</code>) if the
optimizer detects that the objective function is improving or the
estimating equations are not centered around 0, so slowing down
the parameters at that point is counterproductive. To detect this
it looks at the the window controlled by <code>SA.keep.oh</code>,
thinning objective function values to get
<code>SA.stepdown.maxn</code>, and 1) fitting a GLS model for a linear
trend, with AR(2) autocorrelation and 2) conductiong an
approximate Hotelling's T^2 test for equality of estimating
equation values to 0. If there is no significance for either at
<code>SA.stepdown.p</code> <code>SA.stepdown.ct</code> runs in a row, the
gain level (subphase) is allowed to end. Otherwise, the process
continues at the same gain level.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.stepdown.p">SA.stepdown.p</code>, <code id="control.stergm_+3A_sa.stepdown.ct">SA.stepdown.ct</code></td>
<td>
<p>A gain level may be repeated
multiple times (up to <code>SA.phase2.repeats</code>) if the optimizer
detects that the objective function is improving or the
estimating equations are not centered around 0, so slowing down
the parameters at that point is counterproductive.  To detect
this it looks at the the window controlled by <code>SA.keep.oh</code>,
thinning objective function values to get
<code>SA.stepdown.maxn</code>, and 1) fitting a GLS model for a linear
trend, with AR(2) autocorrelation and 2) conductiong an
approximate Hotelling's T^2 test for equality of estimating
equation values to 0. If there is no significance for either at
<code>SA.stepdown.p</code> <code>SA.stepdown.ct</code> runs in a row, the
gain level (subphase) is allowed to end. Otherwise, the process
continues at the same gain level.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.stop.p">SA.stop.p</code></td>
<td>
<p>At the end of each gain level after the minimum,
if the precision is sufficiently high, the relationship between
the parameters and the targets is tested for evidence of local
nonlinearity. This is the p-value used.
</p>
<p>If that test fails to reject, a Phase 3 run is made with the new
parameter values, and the estimating equations are tested for
difference from 0. If this test fails to reject, the optimization
is finished.
</p>
<p>If either of these tests rejects, at <code>SA.stop.p</code>,
optimization is continued for another gain level.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.keep.oh">SA.keep.oh</code>, <code id="control.stergm_+3A_sa.keep.min">SA.keep.min</code>, <code id="control.stergm_+3A_sa.keep.min.runs">SA.keep.min.runs</code></td>
<td>
<p>Parameters
controlling how much of optimization history to keep for gradient
and covariance estimation.
</p>
<p>A history record will be kept if it's at least one of the
following: </p>
 <ul>
<li><p> Among the last <code>SA.keep.oh</code> (a
fraction) of all runs.  </p>
</li>
<li><p> Among the last <code>SA.keep.min</code> (a
count) records.  </p>
</li>
<li><p> From the last <code>SA.keep.min.runs</code> (a
count) optimization runs.  </p>
</li></ul>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase2.jitter.mul">SA.phase2.jitter.mul</code></td>
<td>
<p>Jitter standard deviation of each
parameter is this value times its standard deviation without
jitter.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase2.maxreljump">SA.phase2.maxreljump</code></td>
<td>
<p>To keep the optimization from
&quot;running away&quot; due to, say, a poor gradient estimate building on
itself, if a magnitude of change (Mahalanobis distance) in
parameters over the course of a run divided by average magnitude
of change for recent runs exceeds this, the change is truncated
to this amount times the average for recent runs.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.guard.mul">SA.guard.mul</code></td>
<td>
<p>The multiplier for the range of parameter and
statistics values to compute the guard width.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.par.eff.pow">SA.par.eff.pow</code></td>
<td>
<p>Because some parameters have much, much
greater effects than others, it improves numerical conditioning
and makes estimation more stable to rescale the <code class="reqn">k</code>th
estimating function by <code class="reqn">s_k = (\sum_{i=1}^{q}
  G_{i,k}^2/V_{i,i})^{-p/2}</code>, where <code class="reqn">G_{i,k}</code> is the estimated
gradient of the <code class="reqn">i</code>th target statistics with respect to
<code class="reqn">k</code>th parameter. This parameter sets the value of <code class="reqn">p</code>:
<code>0</code> for no rescaling, <code>1</code> (default) for scaling by
root-mean-square normalized gradient, and greater values for
greater penalty.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.robust">SA.robust</code></td>
<td>
<p>Whether to use robust linear regression (for
gradients) and covariance estimation.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.oh.memory">SA.oh.memory</code></td>
<td>
<p>Absolute maximum number of data points per
thread to store in the full optimization history.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.refine">SA.refine</code></td>
<td>
<p>Method, if any, used to refine the point estimate
at the end: &quot;linear&quot; for linear interpolation, &quot;mean&quot; for
average, and &quot;none&quot; to use the last value.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.se">SA.se</code></td>
<td>
<p>Logical: If TRUE (the default), get an MCMC sample of
statistics at the final estimate and compute the covariance
matrix (and hence standard errors) of the parameters. This sample
is stored and can also be used by
<code><a href="ergm.html#topic+mcmc.diagnostics">mcmc.diagnostics()</a></code> to assess convergence.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.phase3.samplesize.runs">SA.phase3.samplesize.runs</code></td>
<td>
<p>This many optimization runs will
be used to determine whether the optimization has converged and
to estimate the standard errors.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_sa.restart.on.err">SA.restart.on.err</code></td>
<td>
<p>Logical: if <code>TRUE</code> (the default) an
error somewhere in the optimization process will cause it to
restart with a smaller gain value. Otherwise, the process will
stop. This is mainly used for debugging</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="ergm.html#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_parallel">parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on <a href="ergm.html#topic+ergm-parallel">parallel processing</a>
for details and troubleshooting.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_parallel.type">parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code><a href="ergm.html#topic+ergm-parallel">ergm-parallel</a></code></p>
</td></tr>
<tr><td><code id="control.stergm_+3A_parallel.version.check">parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<code><a href="ergm.html#topic+ergm-package">ergm</a></code> running on the slave nodes is the same as
that running on the master node.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_parallel.inherit.mt">parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code><a href="ergm.html#topic+set.MT_terms">set.MT_terms()</a></code> setting.</p>
</td></tr>
<tr><td><code id="control.stergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to other functions This argument
is helpful because it collects any control parameters that have been
deprecated; a warning message is printed in case of deprecated arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="#topic+stergm">stergm</a></code>
function.  See the <code>usage</code> section in <code><a href="#topic+stergm">stergm</a></code> for details.
Generally speaking, <code>control.stergm</code> is remapped to <code>control.tergm</code>,
with dissolution controls ignored and formation controls used as controls
for the overall <code>tergm</code> process.  An exception to this rule is the
initial parameter values specified via <code>init.form</code>, <code>init.diss</code>,
<code>CMLE.form.ergm$init</code>, and <code>CMLE.diss.ergm$init</code>, which will be
remapped jointly with the <code>stergm()</code> arguments <code>offset.coef.form</code>
and <code>offset.coef.diss</code> to determine the initial parameter values passed
to <code>tergm</code>.
</p>
<p>It is recommended that new code make use of <code>tergm</code> and <code>control.tergm</code>
directly; <code>stergm</code> wrappers are included only for backwards compatibility.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>References</h3>

<p>Boer, P., Huisman, M., Snijders,
T.A.B., and Zeggelink, E.P.H. (2003), StOCNET User\'s
Manual. Version 1.4.
</p>
<p>Firth (1993), Bias Reduction in Maximum Likelihood Estimates.
Biometrika, 80: 27-38.
</p>
<p>Hunter, D. R. and M. S. Handcock (2006), Inference in curved
exponential family models for networks. Journal of Computational and
Graphical Statistics, 15: 565-583.
</p>
<p>Hummel, R. M., Hunter, D. R., and Handcock, M. S. (2010), A Steplength
Algorithm for Fitting ERGMs, Penn State Department of Statistics Technical
Report.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stergm">stergm</a></code>,<code><a href="#topic+tergm">tergm</a></code>,<code><a href="#topic+control.tergm">control.tergm</a></code>. The
<code><a href="#topic+control.simulate.stergm">control.simulate.stergm</a></code> function performs a similar
function for <code><a href="#topic+simulate.tergm">simulate.tergm</a></code>.
</p>

<hr>
<h2 id='control.tergm'>Auxiliary for Controlling Temporal ERGM Fitting</h2><span id='topic+control.tergm'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for fine-tuning 'tergm' fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.tergm(
  init = NULL,
  init.method = NULL,
  force.main = FALSE,
  MCMC.prop = ~discord + sparse,
  MCMC.prop.weights = "default",
  MCMC.prop.args = NULL,
  MCMC.maxedges = Inf,
  MCMC.maxchanges = 1e+06,
  MCMC.packagenames = c(),
  CMLE.MCMC.burnin = 1024 * 16,
  CMLE.MCMC.interval = 1024,
  CMLE.ergm = control.ergm(init = init, MCMC.burnin = CMLE.MCMC.burnin, MCMC.interval =
    CMLE.MCMC.interval, MCMC.prop = MCMC.prop, MCMC.prop.weights = MCMC.prop.weights,
    MCMC.prop.args = MCMC.prop.args, MCMC.maxedges = MCMC.maxedges, MCMC.packagenames =
    MCMC.packagenames, parallel = parallel, parallel.type = parallel.type,
    parallel.version.check = parallel.version.check, force.main = force.main,
    term.options = term.options),
  CMLE.NA.impute = c(),
  CMLE.term.check.override = FALSE,
  EGMME.main.method = c("Gradient-Descent"),
  EGMME.initialfit.control = control.ergm(),
  EGMME.MCMC.burnin.min = 1000,
  EGMME.MCMC.burnin.max = 1e+05,
  EGMME.MCMC.burnin.pval = 0.5,
  EGMME.MCMC.burnin.add = 1,
  MCMC.burnin = NULL,
  MCMC.burnin.mul = NULL,
  SAN.maxit = 4,
  SAN.nsteps.times = 8,
  SAN = control.san(term.options = term.options, SAN.maxit = SAN.maxit, SAN.prop =
    MCMC.prop, SAN.prop.weights = MCMC.prop.weights, SAN.prop.args = MCMC.prop.args,
    SAN.nsteps = round(sqrt(EGMME.MCMC.burnin.min * EGMME.MCMC.burnin.max)) *
    SAN.nsteps.times, SAN.packagenames = MCMC.packagenames, parallel = parallel,
    parallel.type = parallel.type, parallel.version.check = parallel.version.check,
    parallel.inherit.MT = parallel.inherit.MT),
  SA.restarts = 10,
  SA.burnin = 1000,
  SA.plot.progress = FALSE,
  SA.max.plot.points = 400,
  SA.plot.stats = FALSE,
  SA.init.gain = 0.1,
  SA.gain.decay = 0.5,
  SA.runlength = 25,
  SA.interval.mul = 2,
  SA.init.interval = 500,
  SA.min.interval = 20,
  SA.max.interval = 500,
  SA.phase1.minruns = 4,
  SA.phase1.tries = 20,
  SA.phase1.jitter = 0.1,
  SA.phase1.max.q = 0.1,
  SA.phase1.backoff.rat = 1.05,
  SA.phase2.levels.max = 40,
  SA.phase2.levels.min = 4,
  SA.phase2.max.mc.se = 0.001,
  SA.phase2.repeats = 400,
  SA.stepdown.maxn = 200,
  SA.stepdown.p = 0.05,
  SA.stop.p = 0.1,
  SA.stepdown.ct = 5,
  SA.phase2.backoff.rat = 1.1,
  SA.keep.oh = 0.5,
  SA.keep.min.runs = 8,
  SA.keep.min = 0,
  SA.phase2.jitter.mul = 0.2,
  SA.phase2.maxreljump = 4,
  SA.guard.mul = 4,
  SA.par.eff.pow = 1,
  SA.robust = FALSE,
  SA.oh.memory = 1e+05,
  SA.refine = c("mean", "linear", "none"),
  SA.se = TRUE,
  SA.phase3.samplesize.runs = 10,
  SA.restart.on.err = TRUE,
  term.options = NULL,
  seed = NULL,
  parallel = 0,
  parallel.type = NULL,
  parallel.version.check = TRUE,
  parallel.inherit.MT = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.tergm_+3A_init">init</code></td>
<td>
<p>numeric or <code>NA</code> vector equal in
length to the number of parameters in the
model or <code>NULL</code> (the default); the initial values for the
estimation and coefficient offset terms. If <code>NULL</code> is
passed, all of the initial values are computed using the method
specified by <code><a href="ergm.html#topic+control.ergm">control$init.method</a></code>.
If a numeric vector is given, the elements of the vector are
interpreted as follows: </p>
 <ul>
<li><p> Elements corresponding to
terms enclosed in <code>offset()</code> are used as the fixed offset
coefficients. These should match the offset values given in
<code>offset.coef</code>.
</p>
</li>
<li><p> Elements that do not correspond to offset terms and are not
<code>NA</code> are used as starting values in the estimation.
</p>
</li>
<li><p> Initial values for the elements that are <code>NA</code> are fit
using the method specified by
<code><a href="ergm.html#topic+control.ergm">control$init.method</a></code>.
</p>
</li></ul>
<p> Passing coefficients from a previous run can be used to
&quot;resume&quot; an uncoverged <code><a href="#topic+tergm">tergm</a></code> run.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_init.method">init.method</code></td>
<td>
<p>Estimation method used to acquire initial values
for estimation. If <code>NULL</code> (the default), the initial values
are computed using the edges dissolution approximation (Carnegie
et al.) when appropriate; note that this relies on <code><a href="#topic+.extract.fd.formulae">.extract.fd.formulae</a></code>
to identify the formation and dissolution parts of the formula; the user should
be aware of its behavior and limitations.
If <code>init.method</code> is set to &quot;zeros&quot;, the initial values are set to zeros.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_force.main">force.main</code></td>
<td>
<p>Logical: If TRUE, then force MCMC-based
estimation method, even if the exact MLE can be computed via
maximum pseudolikelihood estimation.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_mcmc.prop">MCMC.prop</code></td>
<td>
<p>Hints and/or constraints for selecting and initializing the proposal.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_mcmc.prop.weights">MCMC.prop.weights</code></td>
<td>
<p>Specifies the proposal weighting to use.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_mcmc.prop.args">MCMC.prop.args</code></td>
<td>
<p>A direct way of specifying arguments to the proposal.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_mcmc.maxedges">MCMC.maxedges</code></td>
<td>
<p>The maximum number of edges that may occur during the MCMC sampling. If this number is exceeded at any time, sampling is stopped immediately.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_mcmc.maxchanges">MCMC.maxchanges</code></td>
<td>
<p>Maximum number of changes permitted to occur during the simulation.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_mcmc.packagenames">MCMC.packagenames</code></td>
<td>
<p>Names of packages in which to look for change
statistic functions in addition to those autodetected. This argument should
not be needed outside of very strange setups.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_cmle.mcmc.burnin">CMLE.MCMC.burnin</code></td>
<td>
<p>Burnin used in CMLE fitting.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_cmle.mcmc.interval">CMLE.MCMC.interval</code></td>
<td>
<p>Number of Metropolis-Hastings steps
between successive draws when running MCMC MLE.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_cmle.ergm">CMLE.ergm</code></td>
<td>
<p>Control parameters used
to fit the CMLE.  See <code><a href="ergm.html#topic+control.ergm">control.ergm</a></code>.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_cmle.na.impute">CMLE.NA.impute</code></td>
<td>
<p>In TERGM CMLE, missing dyads in
transitioned-to networks are accommodated using methods of
Handcock and Gile (2009), but a similar approach to
transitioned-from networks requires much more complex methods
that are not, currently, implemented.  <code>CMLE.NA.impute</code>
controls how missing dyads in transitioned-from networks are be
imputed. See argument <code>imputers</code> of
<code><a href="#topic+impute.network.list">impute.network.list</a></code> for details.
</p>
<p>By default, no imputation is performed, and the fitting stops
with an error if any transitioned-from networks have missing
dyads.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_cmle.term.check.override">CMLE.term.check.override</code></td>
<td>
<p>The method
<code><a href="#topic+tergm">tergm</a>{tergm}</code> uses at this time to fit a series of
more than two networks requires certain assumptions to be made
about the ERGM terms being used, which are tested before a fit is
attempted. This test sometimes fails despite the model being
amenable to fitting, so setting this option to <code>TRUE</code>
overrides the tests.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_egmme.main.method">EGMME.main.method</code></td>
<td>
<p>Estimation method used to find the
Equilibrium Generalized Method of Moments estimator.  Currently
only &quot;Gradient-Descent&quot; is implemented.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_egmme.initialfit.control">EGMME.initialfit.control</code></td>
<td>
<p>Control object for the ergm fit
in tergm.EGMME.initialfit</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_egmme.mcmc.burnin.min">EGMME.MCMC.burnin.min</code>, <code id="control.tergm_+3A_egmme.mcmc.burnin.max">EGMME.MCMC.burnin.max</code></td>
<td>
<p>Number of
Metropolis-Hastings steps
per time step used in EGMME fitting. By default, this is
determined adaptively by keeping track of increments in the
Hamming distance between the transitioned-from network and the
network being sampled.
Once <code>EGMME.MCMC.burnin.min</code> steps have elapsed,
the increments are tested against 0, and when their average
number becomes statistically indistinguishable from 0 (with the
p-value being greater than <code>EGMME.MCMC.burnin.pval</code>), or
<code>EGMME.MCMC.burnin.max</code> steps are proposed, whichever comes
first, the simulation is stopped after an additional
<code>EGMME.MCMC.burnin.add</code> times the number of elapsed steps
had been taken. (Stopping immediately would bias the sampling.)
</p>
<p>To use a fixed number of steps, set
<code>EGMME.MCMC.burnin.min</code> and <code>EGMME.MCMC.burnin.max</code> to
the same value.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_egmme.mcmc.burnin.pval">EGMME.MCMC.burnin.pval</code>, <code id="control.tergm_+3A_egmme.mcmc.burnin.add">EGMME.MCMC.burnin.add</code></td>
<td>
<p>Number of
Metropolis-Hastings steps
per time step used in EGMME fitting. By default, this is
determined adaptively by keeping track of increments in the
Hamming distance between the transitioned-from network and the
network being sampled.
Once <code>EGMME.MCMC.burnin.min</code> steps have elapsed,
the increments are tested against 0, and when their average
number becomes statistically indistinguishable from 0 (with the
p-value being greater than <code>EGMME.MCMC.burnin.pval</code>), or
<code>EGMME.MCMC.burnin.max</code> steps are proposed, whichever comes
first, the simulation is stopped after an additional
<code>EGMME.MCMC.burnin.add</code> times the number of elapsed steps
had been taken. (Stopping immediately would bias the sampling.)
</p>
<p>To use a fixed number of steps, set
<code>EGMME.MCMC.burnin.min</code> and <code>EGMME.MCMC.burnin.max</code> to
the same value.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_mcmc.burnin">MCMC.burnin</code>, <code id="control.tergm_+3A_mcmc.burnin.mul">MCMC.burnin.mul</code></td>
<td>
<p>No longer used. See
<code>EGMME.MCMC.burnin.min</code>, <code>EGMME.MCMC.burnin.max</code>,
<code>EGMME.MCMC.burnin.pval</code>, <code>EGMME.MCMC.burnin.pval</code>,
<code>EGMME.MCMC.burnin.add</code> and <code>CMLE.MCMC.burnin</code> and
<code>CMLE.MCMC.interval</code>.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_san.maxit">SAN.maxit</code></td>
<td>
<p>When <code>target.stats</code> argument is passed to
<code><a href="ergm.html#topic+ergm">ergm()</a></code>, the maximum number of attempts to use <code><a href="ergm.html#topic+san">san</a></code>
to obtain a network with statistics close to those specified.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_san.nsteps.times">SAN.nsteps.times</code></td>
<td>
<p>Multiplier for <code>SAN.nsteps</code> relative to
<code>MCMC.burnin</code>. This lets one control the amount of SAN burn-in
(arguably, the most important of SAN parameters) without overriding the
other SAN defaults.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_san">SAN</code></td>
<td>
<p>SAN control parameters.  See
<code><a href="ergm.html#topic+control.san">control.san</a></code></p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.restarts">SA.restarts</code></td>
<td>
<p>Maximum number of times to restart a failed
optimization process.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.burnin">SA.burnin</code></td>
<td>
<p>Number of time steps to advance the starting
network before beginning the optimization.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.plot.progress">SA.plot.progress</code>, <code id="control.tergm_+3A_sa.plot.stats">SA.plot.stats</code></td>
<td>
<p>Logical: Plot information
about the fit as it proceeds. If <code>SA.plot.progress==TRUE</code>,
plot the trajectories of the parameters and target statistics as
the optimization progresses. If <code>SA.plot.stats==TRUE</code>, plot
a heatmap representing correlations of target statistics and a
heatmap representing the estimated gradient.
</p>
<p>Do NOT use these with non-interactive plotting devices like
<code><a href="grDevices.html#topic+pdf">pdf</a></code>. (In fact, it will refuse to do that with a
warning.)</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.max.plot.points">SA.max.plot.points</code></td>
<td>
<p>If <code>SA.plot.progress==TRUE</code>, the
maximum number of time points to be plotted. Defaults to 400. If
more iterations elapse, they will be thinned to at most 400
before plotting.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.init.gain">SA.init.gain</code></td>
<td>
<p>Initial gain, the multiplier for the parameter
update size.  If the process initially goes crazy beyond
recovery, lower this value.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.gain.decay">SA.gain.decay</code></td>
<td>
<p>Gain decay factor.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.runlength">SA.runlength</code></td>
<td>
<p>Number of parameter trials and updates per C
run.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.interval.mul">SA.interval.mul</code></td>
<td>
<p>The number of time steps between updates of
the parameters is set to be this times the mean duration of
extant ties.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.init.interval">SA.init.interval</code></td>
<td>
<p>Initial number of time steps between
updates of the parameters.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.min.interval">SA.min.interval</code>, <code id="control.tergm_+3A_sa.max.interval">SA.max.interval</code></td>
<td>
<p>Upper and lower bounds on
the number of time steps between updates of the parameters.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase1.minruns">SA.phase1.minruns</code></td>
<td>
<p>Number of runs during Phase 1 for
estimating the gradient, before every gradient update.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase1.tries">SA.phase1.tries</code></td>
<td>
<p>Number of runs trying to find a reasonable
parameter and network configuration.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase1.jitter">SA.phase1.jitter</code></td>
<td>
<p>Initial jitter standard deviation of each
parameter.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase1.max.q">SA.phase1.max.q</code></td>
<td>
<p>Q-value (false discovery rate) that a
gradient estimate must obtain before it is accepted (since sign
is what is important).</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase1.backoff.rat">SA.phase1.backoff.rat</code>, <code id="control.tergm_+3A_sa.phase2.backoff.rat">SA.phase2.backoff.rat</code></td>
<td>
<p>If the run
produces this relative increase in the approximate objective
function, it will be backed off.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase2.levels.min">SA.phase2.levels.min</code>, <code id="control.tergm_+3A_sa.phase2.levels.max">SA.phase2.levels.max</code></td>
<td>
<p>Range of gain
levels (subphases) to go through.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase2.max.mc.se">SA.phase2.max.mc.se</code></td>
<td>
<p>Approximate precision of the estimates
that must be attained before stopping.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase2.repeats">SA.phase2.repeats</code>, <code id="control.tergm_+3A_sa.stepdown.maxn">SA.stepdown.maxn</code></td>
<td>
<p>A gain level may be
repeated multiple times (up to <code>SA.phase2.repeats</code>) if the
optimizer detects that the objective function is improving or the
estimating equations are not centered around 0, so slowing down
the parameters at that point is counterproductive. To detect this
it looks at the the window controlled by <code>SA.keep.oh</code>,
thinning objective function values to get
<code>SA.stepdown.maxn</code>, and 1) fitting a GLS model for a linear
trend, with AR(2) autocorrelation and 2) conductiong an
approximate Hotelling's T^2 test for equality of estimating
equation values to 0. If there is no significance for either at
<code>SA.stepdown.p</code> <code>SA.stepdown.ct</code> runs in a row, the
gain level (subphase) is allowed to end. Otherwise, the process
continues at the same gain level.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.stepdown.p">SA.stepdown.p</code>, <code id="control.tergm_+3A_sa.stepdown.ct">SA.stepdown.ct</code></td>
<td>
<p>A gain level may be repeated
multiple times (up to <code>SA.phase2.repeats</code>) if the optimizer
detects that the objective function is improving or the
estimating equations are not centered around 0, so slowing down
the parameters at that point is counterproductive.  To detect
this it looks at the the window controlled by <code>SA.keep.oh</code>,
thinning objective function values to get
<code>SA.stepdown.maxn</code>, and 1) fitting a GLS model for a linear
trend, with AR(2) autocorrelation and 2) conductiong an
approximate Hotelling's T^2 test for equality of estimating
equation values to 0. If there is no significance for either at
<code>SA.stepdown.p</code> <code>SA.stepdown.ct</code> runs in a row, the
gain level (subphase) is allowed to end. Otherwise, the process
continues at the same gain level.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.stop.p">SA.stop.p</code></td>
<td>
<p>At the end of each gain level after the minimum,
if the precision is sufficiently high, the relationship between
the parameters and the targets is tested for evidence of local
nonlinearity. This is the p-value used.
</p>
<p>If that test fails to reject, a Phase 3 run is made with the new
parameter values, and the estimating equations are tested for
difference from 0. If this test fails to reject, the optimization
is finished.
</p>
<p>If either of these tests rejects, at <code>SA.stop.p</code>,
optimization is continued for another gain level.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.keep.oh">SA.keep.oh</code>, <code id="control.tergm_+3A_sa.keep.min">SA.keep.min</code>, <code id="control.tergm_+3A_sa.keep.min.runs">SA.keep.min.runs</code></td>
<td>
<p>Parameters
controlling how much of optimization history to keep for gradient
and covariance estimation.
</p>
<p>A history record will be kept if it's at least one of the
following: </p>
 <ul>
<li><p> Among the last <code>SA.keep.oh</code> (a
fraction) of all runs.  </p>
</li>
<li><p> Among the last <code>SA.keep.min</code> (a
count) records.  </p>
</li>
<li><p> From the last <code>SA.keep.min.runs</code> (a
count) optimization runs.  </p>
</li></ul>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase2.jitter.mul">SA.phase2.jitter.mul</code></td>
<td>
<p>Jitter standard deviation of each
parameter is this value times its standard deviation without
jitter.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase2.maxreljump">SA.phase2.maxreljump</code></td>
<td>
<p>To keep the optimization from
&quot;running away&quot; due to, say, a poor gradient estimate building on
itself, if a magnitude of change (Mahalanobis distance) in
parameters over the course of a run divided by average magnitude
of change for recent runs exceeds this, the change is truncated
to this amount times the average for recent runs.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.guard.mul">SA.guard.mul</code></td>
<td>
<p>The multiplier for the range of parameter and
statistics values to compute the guard width.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.par.eff.pow">SA.par.eff.pow</code></td>
<td>
<p>Because some parameters have much, much
greater effects than others, it improves numerical conditioning
and makes estimation more stable to rescale the <code class="reqn">k</code>th
estimating function by <code class="reqn">s_k = (\sum_{i=1}^{q}
  G_{i,k}^2/V_{i,i})^{-p/2}</code>, where <code class="reqn">G_{i,k}</code> is the estimated
gradient of the <code class="reqn">i</code>th target statistics with respect to
<code class="reqn">k</code>th parameter. This parameter sets the value of <code class="reqn">p</code>:
<code>0</code> for no rescaling, <code>1</code> (default) for scaling by
root-mean-square normalized gradient, and greater values for
greater penalty.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.robust">SA.robust</code></td>
<td>
<p>Whether to use robust linear regression (for
gradients) and covariance estimation.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.oh.memory">SA.oh.memory</code></td>
<td>
<p>Absolute maximum number of data points per
thread to store in the full optimization history.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.refine">SA.refine</code></td>
<td>
<p>Method, if any, used to refine the point estimate
at the end: &quot;linear&quot; for linear interpolation, &quot;mean&quot; for
average, and &quot;none&quot; to use the last value.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.se">SA.se</code></td>
<td>
<p>Logical: If TRUE (the default), get an MCMC sample of
statistics at the final estimate and compute the covariance
matrix (and hence standard errors) of the parameters. This sample
is stored and can also be used by
<code><a href="ergm.html#topic+mcmc.diagnostics">mcmc.diagnostics()</a></code> to assess convergence.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.phase3.samplesize.runs">SA.phase3.samplesize.runs</code></td>
<td>
<p>This many optimization runs will
be used to determine whether the optimization has converged and
to estimate the standard errors.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_sa.restart.on.err">SA.restart.on.err</code></td>
<td>
<p>Logical: if <code>TRUE</code> (the default) an
error somewhere in the optimization process will cause it to
restart with a smaller gain value. Otherwise, the process will
stop. This is mainly used for debugging</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="ergm.html#topic+term.options">? term.options</a></code>.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_parallel">parallel</code></td>
<td>
<p>Number of threads in which to run the sampling. Defaults to
0 (no parallelism). See the entry on <a href="ergm.html#topic+ergm-parallel">parallel processing</a>
for details and troubleshooting.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_parallel.type">parallel.type</code></td>
<td>
<p>API to use for parallel processing. Supported values
are <code>"MPI"</code> and <code>"PSOCK"</code>. Defaults to using the <code>parallel</code>
package with PSOCK clusters. See <code><a href="ergm.html#topic+ergm-parallel">ergm-parallel</a></code></p>
</td></tr>
<tr><td><code id="control.tergm_+3A_parallel.version.check">parallel.version.check</code></td>
<td>
<p>Logical: If TRUE, check that the version of
<code><a href="ergm.html#topic+ergm-package">ergm</a></code> running on the slave nodes is the same as
that running on the master node.</p>
</td></tr>
<tr><td><code id="control.tergm_+3A_parallel.inherit.mt">parallel.inherit.MT</code></td>
<td>
<p>Logical: If TRUE, slave nodes and
processes inherit the <code><a href="ergm.html#topic+set.MT_terms">set.MT_terms()</a></code> setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only used within a call to the <code><a href="#topic+tergm">tergm</a></code>
function.  See the <code>usage</code> section in <code><a href="#topic+tergm">tergm</a></code> for details.
</p>


<h3>Value</h3>

<p>A list with arguments as components.
</p>


<h3>References</h3>

<p>Boer, P., Huisman, M., Snijders,
T.A.B., and Zeggelink, E.P.H. (2003), StOCNET User\'s
Manual. Version 1.4.
</p>
<p>Firth (1993), Bias Reduction in Maximum Likelihood Estimates.
Biometrika, 80: 27-38.
</p>
<p>Hunter, D. R. and M. S. Handcock (2006), Inference in curved
exponential family models for networks. Journal of Computational and
Graphical Statistics, 15: 565-583.
</p>
<p>Hummel, R. M., Hunter, D. R., and Handcock, M. S. (2010), A Steplength
Algorithm for Fitting ERGMs, Penn State Department of Statistics Technical
Report.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tergm">tergm</a></code>. The
<code><a href="#topic+control.simulate.tergm">control.simulate.tergm</a></code> function performs a similar
function for <code><a href="#topic+simulate.tergm">simulate.tergm</a></code>.
</p>

<hr>
<h2 id='control.tergm.godfather'>Control parameters for <code><a href="#topic+tergm.godfather">tergm.godfather()</a></code>.</h2><span id='topic+control.tergm.godfather'></span>

<h3>Description</h3>

<p>Returns a list of its arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.tergm.godfather(term.options = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.tergm.godfather_+3A_term.options">term.options</code></td>
<td>
<p>A list of additional arguments to be passed to term initializers. See <code><a href="ergm.html#topic+term.options">? term.options</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='Cross-ergmTerm'>The Crossection Operator Term</h2><span id='topic+Cross-ergmTerm'></span><span id='topic+InitErgmTerm.Cross'></span>

<h3>Description</h3>

<p>The Crossection Operator Term
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Cross(
#           formula,
#           lm = ~1,
#           subset = TRUE,
#           weights = 1,
#           contrasts = NULL,
#           offset = 0,
#           label = NULL
#         )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cross-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="ergm.html#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Cross-ergmTerm_+3A_lm">lm</code>, <code id="Cross-ergmTerm_+3A_subset">subset</code>, <code id="Cross-ergmTerm_+3A_weights">weights</code>, <code id="Cross-ergmTerm_+3A_contrasts">contrasts</code>, <code id="Cross-ergmTerm_+3A_offset">offset</code>, <code id="Cross-ergmTerm_+3A_label">label</code></td>
<td>
<p><strong><code><a href="#topic+NetSeries">NetSeries()</a></code> LHS only</strong> arguments to specify time-varying parameters. See <code><a href="ergm.multi.html#topic+N-ergmTerm-c9b59cc1">N()</a></code> term operator in the <span class="pkg">ergm.multi</span> for details. <code>lm</code> formula may reference <code>.Time</code> for the network's time index, <code>.TimeID</code> for the its index in the network series (where the initial network is 1 and the first modelled network is 2), and <code>.TimeDelta</code> for the time elapsed between the network and the immediately previous network in the series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term accepts a model formula
and produces the corresponding model for the cross-sectional
network. It is mainly useful for CMLE estimation, and has no effect (i.e.,
<code>Cross(~TERM) == ~TERM</code> ) for EGMME and dynamic simulation.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='degrange.mean.age-ergmTerm'>Average age of ties incident on nodes having degree in a given range</h2><span id='topic+degrange.mean.age-ergmTerm'></span><span id='topic+InitErgmTerm.degrange.mean.age'></span>

<h3>Description</h3>

<p>Average age of ties incident on nodes having degree in a given range
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: degrange.mean.age(from, to=+Inf, byarg=NULL, emptyval=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degrange.mean.age-ergmTerm_+3A_from">from</code>, <code id="degrange.mean.age-ergmTerm_+3A_to">to</code></td>
<td>
<p>vectors of distinct
integers or <code>+Inf</code> , for <code>to</code> . If one of the vectors has
length 1, it is recycled to the length of the other. Otherwise, they
must have the same length.</p>
</td></tr>
<tr><td><code id="degrange.mean.age-ergmTerm_+3A_byarg">byarg</code></td>
<td>
<p>specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.). If specified, then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="degrange.mean.age-ergmTerm_+3A_emptyval">emptyval</code></td>
<td>
<p>can be used to specify the value returned if the network does not have any actors
with degree in the specified range. This is, technically, an arbitrary value, but it should
not have a substantial effect unless a non-negligible fraction of
networks at the parameter configuration of interest has no actors
with specified degree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term adds one
network statistic to the model for each element of <code>from</code> (or <code>to</code> ); the <code class="reqn">i</code> th
such statistic equals the average, among all ties incident on nodes
with degree greater than or equal to
<code>from[i]</code> but strictly less than <code>to[i]</code> , of the amount of time elapsed
since the tie's formation. The optional argument
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='degree.mean.age-ergmTerm'>Average age of ties incident on nodes having a given degree</h2><span id='topic+degree.mean.age-ergmTerm'></span><span id='topic+InitErgmTerm.degree.mean.age'></span>

<h3>Description</h3>

<p>Average age of ties incident on nodes having a given degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: degree.mean.age(d, byarg=NULL, emptyval=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.mean.age-ergmTerm_+3A_d">d</code></td>
<td>
<p>a vector of distinct integers</p>
</td></tr>
<tr><td><code id="degree.mean.age-ergmTerm_+3A_byarg">byarg</code></td>
<td>
<p>specifies a vertex attribute (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.). If specified, then separate degree
statistics are calculated for nodes having each separate
value of the attribute.</p>
</td></tr>
<tr><td><code id="degree.mean.age-ergmTerm_+3A_emptyval">emptyval</code></td>
<td>
<p>can be used to specify the value returned if the network does not have any actors
with degree in the specified range. This is, technically, an arbitrary value, but it should
not have a substantial effect unless a non-negligible fraction of
networks at the parameter configuration of interest has no actors
with specified degree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term adds one
network statistic to the model for each element in <code>d</code> ; the <code class="reqn">i</code> th
such statistic equals the average, among all ties incident on nodes
with degree exactly <code>d[i]</code> , of the amount of time elapsed
since the tie's formation. The optional argument
<code>byarg</code> specifies a vertex attribute (see
Specifying Vertex Attributes and Levels
for details). If specified, then separate degree
statistics are calculated for nodes having each separate
value of the attribute.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='discord-ergmHint'>Discordant dyads</h2><span id='topic+discord-ergmHint'></span><span id='topic+InitErgmConstraint.discord'></span><span id='topic+discord-ergmConstraint'></span>

<h3>Description</h3>

<p>Propose toggling discordant dyads with greater
frequency (typically about 50 percent).  May be used in
dynamic fitting and simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># discord
</code></pre>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmHint">ergmHint</a></code> for index of constraints and hints currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='discordBDStratTNT-ergmProposal'>Temperal TNT proposal with degree bounds</h2><span id='topic+discordBDStratTNT-ergmProposal'></span><span id='topic+InitErgmProposal.discordBDStratTNT'></span>

<h3>Description</h3>

<p>A temporal version of <code><a href="ergm.html#topic+ergm-proposals">BDStratTNT</a></code>.  Within each
mixing type, approximately 50\
dyads, and approximately 50\
proposals from the network, all subject to the bounded degree
and mixing type constraints.  The degree bound constraint is imposed
the instantaneous network state
rather than the temporal operator networks).
</p>
<p>arguments are the same as for <code><a href="ergm.html#topic+BDStratTNT-ergmProposal">BDStratTNT</a></code>,
and should be passed in via the <code><a href="ergm.html#topic+bd-ergmConstraint">bd</a></code> and
code<a href="ergm.html#topic+blocks-ergmConstraint">blocks</a> constraints and
<code><a href="ergm.html#topic+strat-ergmHint">strat</a></code> hint.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='discordTNT-ergmProposal'>Temperal TNT proposal</h2><span id='topic+discordTNT-ergmProposal'></span><span id='topic+InitErgmProposal.discordTNT'></span>

<h3>Description</h3>

<p>A temporal version of <code><a href="ergm.html#topic+TNT-ergmProposal">TNT</a></code>, with approximately
codediscordance_fraction of proposed toggles being made on the set of discordant dyads,
approximately <code>1 - discordance_fraction</code> of proposed toggles being TNT proposals from
network.  The value of <code>discordance_fraction</code> can be set by the user as a proposal argument,
defaults to <code>0.5</code>.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='Diss-ergmTerm'>The Dissolution Operator Term</h2><span id='topic+Diss-ergmTerm'></span><span id='topic+InitErgmTerm.Diss+20+28dynamic+29'></span><span id='topic+InitErgmTerm.Diss'></span>

<h3>Description</h3>

<p>The Dissolution Operator Term
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Diss(
#           formula,
#           lm = ~1,
#           subset = TRUE,
#           weights = 1,
#           contrasts = NULL,
#           offset = 0,
#           label = NULL
#         )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diss-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="ergm.html#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Diss-ergmTerm_+3A_lm">lm</code>, <code id="Diss-ergmTerm_+3A_subset">subset</code>, <code id="Diss-ergmTerm_+3A_weights">weights</code>, <code id="Diss-ergmTerm_+3A_contrasts">contrasts</code>, <code id="Diss-ergmTerm_+3A_offset">offset</code>, <code id="Diss-ergmTerm_+3A_label">label</code></td>
<td>
<p><strong><code><a href="#topic+NetSeries">NetSeries()</a></code> LHS only</strong> arguments to specify time-varying parameters. See <code><a href="ergm.multi.html#topic+N-ergmTerm-c9b59cc1">N()</a></code> term operator in the <span class="pkg">ergm.multi</span> for details. <code>lm</code> formula may reference <code>.Time</code> for the network's time index, <code>.TimeID</code> for the its index in the network series (where the initial network is 1 and the first modelled network is 2), and <code>.TimeDelta</code> for the time elapsed between the network and the immediately previous network in the series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term accepts a model formula
and produces the corresponding model for the post-dissolution
network (same as <code>Persist()</code> ), but with all statistics negated.
</p>
<p>Note: This is not the equivalent of the old style <code>dissolution</code> model,
because the signs of the coefficients are reversed. So a larger positive
coefficient for <code>Diss()</code> operator means more dissolution.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='edge.ages-ergmTerm'>Sum of ages of extant ties</h2><span id='topic+edge.ages-ergmTerm'></span><span id='topic+InitErgmTerm.edge.ages'></span>

<h3>Description</h3>

<p>Sum of ages of extant ties
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: edge.ages
</code></pre>


<h3>Details</h3>

<p>This term adds one statistic equaling sum, over all ties
present in the network, of the amount of time elapsed since
formation.
</p>
<p>Unlike <code><a href="#topic+mean.age-ergmTerm">mean.age</a></code> , this statistic is well-defined on
an empty network. However, if used as a target, it appears to
produce highly biased dissolution parameter estimates if the goal
is to get an intended average duration.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='EdgeAges-ergmTerm'>The EdgeAges Operator Term</h2><span id='topic+EdgeAges-ergmTerm'></span><span id='topic+InitErgmTerm.EdgeAges'></span>

<h3>Description</h3>

<p>The EdgeAges Operator Term
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: EdgeAges(formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EdgeAges-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>cross-sectional, dyad-independent model formula</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term accepts a cross-sectional, dyad-independent model
formula.  The statistics of the EdgeAges term are equal to the sum over
all extant ties of the tie age times the on-toggle change statistics for
the tie under the given model formula.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='edgecov.ages-ergmTerm'>Weighted sum of ages of extant ties</h2><span id='topic+edgecov.ages-ergmTerm'></span><span id='topic+InitErgmTerm.edgecov.ages'></span>

<h3>Description</h3>

<p>Weighted sum of ages of extant ties
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: edgecov.ages(x, attrname=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgecov.ages-ergmTerm_+3A_x">x</code>, <code id="edgecov.ages-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>either a square matrix of covariates, one for
each possible edge in the network, the name of a network
attribute of covariates, or a network; if the latter, or if the
network attribute named by <code>x</code> is itself a network, optional
argument <code>attrname</code> provides the name of the quantitative edge
attribute to use for covariate values (in this case, missing
edges in <code>x</code> are assigned a covariate value of zero).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term adds one statistic equaling sum, over all ties
present in the network, of the amount of time elapsed since
formation, multiplied by a dyadic covariate.
</p>
<p>&quot;Weights&quot; can be negative.
</p>
<p>Unlike <code><a href="#topic+edgecov.mean.age-ergmTerm">edgecov.mean.age</a></code> , this statistic is well-defined on
an empty network. However, if used as a target, it appears to
produce highly biased dissolution parameter estimates if the goal
is to get an intended average duration.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='edgecov.mean.age-ergmTerm'>Weighted average age of an extant tie</h2><span id='topic+edgecov.mean.age-ergmTerm'></span><span id='topic+InitErgmTerm.edgecov.mean.age'></span>

<h3>Description</h3>

<p>Weighted average age of an extant tie
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: edgecov.mean.age(x, attrname=NULL, emptyval=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgecov.mean.age-ergmTerm_+3A_x">x</code>, <code id="edgecov.mean.age-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>either a square matrix of covariates, one for
each possible edge in the network, the name of a network
attribute of covariates, or a network; if the latter, or if the
network attribute named by <code>x</code> is itself a network, optional
argument <code>attrname</code> provides the name of the quantitative edge
attribute to use for covariate values (in this case, missing
edges in <code>x</code> are assigned a covariate value of zero).</p>
</td></tr>
<tr><td><code id="edgecov.mean.age-ergmTerm_+3A_emptyval">emptyval</code></td>
<td>
<p>can be used to specify the value returned if the network is empty (or all extant edges have been weighted 0). This is, technically, an arbitrary value, but it should
not have a substantial effect unless a non-negligible fraction of
networks at the parameter configuration of interest is empty
and/or if only a few dyads have nonzero weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term adds one statistic equaling the average, over all ties
present in the network, of the amount of time elapsed since
formation, weighted by a (nonnegative) dyadic covariate.
</p>
<p>The behavior when there are negative weights is undefined.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='edges.ageinterval-ergmTerm'>Number of edges with age falling into a specified range</h2><span id='topic+edges.ageinterval-ergmTerm'></span><span id='topic+InitErgmTerm.edges.ageinterval'></span>

<h3>Description</h3>

<p>Number of edges with age falling into a specified range
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: edges.ageinterval(from, to=+Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges.ageinterval-ergmTerm_+3A_from">from</code>, <code id="edges.ageinterval-ergmTerm_+3A_to">to</code></td>
<td>
<p>parameters to specify the lower bound and strict upper bounds. Can be scalars, vectors of the same length, or one of them must have length one, in which case it is recycled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term counts the number of edges in the network for
which the time elapsed since formation is greater than or equal to
<code>from</code> but strictly less than <code>to</code> . In other words, it
is in the semiopen interval <code style="white-space: pre;">&#8288;[from, to)&#8288;</code> .
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='Form-ergmTerm'>The Formation Operator Term</h2><span id='topic+Form-ergmTerm'></span><span id='topic+InitErgmTerm.Form+20+28dynamic+29'></span><span id='topic+InitErgmTerm.Form'></span>

<h3>Description</h3>

<p>The Formation Operator Term
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Form(
#           formula,
#           lm = ~1,
#           subset = TRUE,
#           weights = 1,
#           contrasts = NULL,
#           offset = 0,
#           label = NULL
#         )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Form-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="ergm.html#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Form-ergmTerm_+3A_lm">lm</code>, <code id="Form-ergmTerm_+3A_subset">subset</code>, <code id="Form-ergmTerm_+3A_weights">weights</code>, <code id="Form-ergmTerm_+3A_contrasts">contrasts</code>, <code id="Form-ergmTerm_+3A_offset">offset</code>, <code id="Form-ergmTerm_+3A_label">label</code></td>
<td>
<p><strong><code><a href="#topic+NetSeries">NetSeries()</a></code> LHS only</strong> arguments to specify time-varying parameters. See <code><a href="ergm.multi.html#topic+N-ergmTerm-c9b59cc1">N()</a></code> term operator in the <span class="pkg">ergm.multi</span> for details. <code>lm</code> formula may reference <code>.Time</code> for the network's time index, <code>.TimeID</code> for the its index in the network series (where the initial network is 1 and the first modelled network is 2), and <code>.TimeDelta</code> for the time elapsed between the network and the immediately previous network in the series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term accepts a model formula
and produces the corresponding model for the post-formation network:
effectively a network containing both previous time step's ties and ties just formed,
the union of the previous and current network. This is the equivalent of the
old-style <code>formation</code> model.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='impute.network.list'>Impute missing dyads in a series of networks</h2><span id='topic+impute.network.list'></span>

<h3>Description</h3>

<p>This function takes a list of networks with missing dyads and returns a list
of networks with missing dyads imputed according to a list of imputation
directives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.network.list(
  nwl,
  imputers = c(),
  nwl.prepend = list(),
  nwl.append = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.network.list_+3A_nwl">nwl</code></td>
<td>
<p>A list of <code><a href="network.html#topic+network">network</a></code> objects or a
<code><a href="ergm.html#topic+network.list">network.list</a></code> object.</p>
</td></tr>
<tr><td><code id="impute.network.list_+3A_imputers">imputers</code></td>
<td>
<p>A character vector giving one or more methods to
impute missing dyads. Currenly implemented methods are as
follows: </p>
 <dl>
<dt><code>next</code></dt><dd><p>Impute the state of the same
dyad in the next network in the list (or later, if that one is
also missing).  This imputation method is likely to lead to an
underestimation of the tie-change rates. The last
network in the list cannot be imputed this way.</p>
</dd>
<dt><code>previous</code></dt><dd><p>Impute the state of the same dyad in
the previous network in the list (or earlier, if that one is also
missing). The first network in the list cannot be imputed this
way.</p>
</dd>  <dt><code>majority</code></dt><dd><p>Impute the missing dyad with
the value of the majority among the non-missing dyads in that
time step's network. A network that has exactly the same number
of ties as non-missing non-ties cannot be imputed this way.</p>
</dd>
<dt><code>0</code></dt><dd><p>Assume missing dyads are all non-ties.</p>
</dd>
<dt><code>1</code></dt><dd><p>Assume missing dyads are all ties.</p>
</dd> </dl>
<p> If
<code>length(imputers)&gt;1</code> the specified imputation methods will
be applied in succession. For example,
<code>imputers=c("next","previous","majority","0")</code> would first
try to impute a missing dyad with the next time step's value. If
it, and all of the later values for that dyad are missing, it
will try to impute it with the previous time step's value. If it,
and all of the earlier values for that dyad are missing as well,
it will try to impute it with the value of the majority of
non-missing dyads for that time step. If there is an exact tie,
it will impute 0.</p>
</td></tr>
<tr><td><code id="impute.network.list_+3A_nwl.prepend">nwl.prepend</code></td>
<td>
<p>An optional list of networks to treat as
preceding those in <code>nwl</code>. They will not be imputed or
returned, but they can be useful for imputing dyads in the first
network in <code>nwl</code>, when using <code>"previous"</code> imputer.</p>
</td></tr>
<tr><td><code id="impute.network.list_+3A_nwl.append">nwl.append</code></td>
<td>
<p>An optional list of networks to treat as
following those in <code>nwl</code>. They will not be imputed or
returned, but they can be useful for imputing dyads in the last
network in <code>nwl</code>, when using <code>"next"</code> imputer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of networks with missing dyads imputed.
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+network">network</a></code>, <code><a href="base.html#topic+is.na">is.na</a></code>
</p>

<hr>
<h2 id='is.durational'>Testing for duration dependent models</h2><span id='topic+is.durational'></span><span id='topic+is.durational.NULL'></span><span id='topic+is.durational.ergm_model'></span><span id='topic+is.durational.ergm_state'></span><span id='topic+is.durational.formula'></span>

<h3>Description</h3>

<p>These functions test whether an ERGM is duration dependent or not.
</p>
<p>The method for <code>NULL</code> always returns <code>FALSE</code> by
convention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.durational(object, ...)

## S3 method for class ''NULL''
is.durational(object, ...)

## S3 method for class 'ergm_model'
is.durational(object, ...)

## S3 method for class 'ergm_state'
is.durational(object, ...)

## S3 method for class 'formula'
is.durational(object, response = NULL, basis = ergm.getnetwork(object), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.durational_+3A_object">object</code></td>
<td>
<p>An ERGM formula, <code><a href="ergm.html#topic+ergm_model">ergm_model</a></code> object, or
<code><a href="ergm.html#topic+ergm_state">ergm_state</a></code> object.</p>
</td></tr>
<tr><td><code id="is.durational_+3A_...">...</code></td>
<td>
<p>Unused at this time.</p>
</td></tr>
<tr><td><code id="is.durational_+3A_response">response</code>, <code id="is.durational_+3A_basis">basis</code></td>
<td>
<p>See <code><a href="ergm.html#topic+ergm">ergm()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the ERGM terms in the model are duration dependent;
<code>FALSE</code> otherwise.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>is.durational(ergm_model)</code>: Test if the <code><a href="ergm.html#topic+ergm_model">ergm_model</a></code> has duration-dependent terms, which call for <code><a href="#topic+lasttoggle">lasttoggle</a></code> data structures.
</p>
</li>
<li> <p><code>is.durational(ergm_state)</code>: Test if the <code><a href="ergm.html#topic+ergm_state">ergm_state</a></code> has duration-dependent terms, which call for <code><a href="#topic+lasttoggle">lasttoggle</a></code> data structures.
</p>
</li></ul>

<hr>
<h2 id='lasttoggle'>Lasttoggle</h2><span id='topic+lasttoggle'></span>

<h3>Description</h3>

<p>A data structure used by <code>tergm</code> for tracking of limited information
about dyad edge histories.
</p>


<h3>Details</h3>

<p>The <code>tergm</code> package handles durational information attached to
<code><a href="network.html#topic+network">network</a></code> objects by way of the <code>time</code> and
<code>lasttoggle</code> network attributes.  The <code>lasttoggle</code> data
structure is a 3-column matrix; the first two columns are tails
and heads (respectively) of dyads, and the third column is the last
time at which the dyad was toggled.  The default last toggle time
is <code>-INT_MAX/2</code>.  Last toggle times for non-edges are
periodically cleared in the C code.  The <code>time</code> network
attribute is simply an integer, and together with the
<code>lasttoggle</code> data it determines the age of an extant
tie as <code>time + 1</code> minus the last toggle time for that dyad.
The default value for <code>time</code> is 0.
</p>

<hr>
<h2 id='mean.age-ergmTerm'>Average age of an extant tie</h2><span id='topic+mean.age-ergmTerm'></span><span id='topic+InitErgmTerm.mean.age'></span>

<h3>Description</h3>

<p>Average age of an extant tie
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: mean.age(emptyval=0, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.age-ergmTerm_+3A_emptyval">emptyval</code></td>
<td>
<p>can be used to specify the value returned if the network is empty. This is, technically, an arbitrary value, but it should
not have a substantial effect unless a non-negligible fraction of
networks at the parameter configuration of interest is empty.</p>
</td></tr>
<tr><td><code id="mean.age-ergmTerm_+3A_log">log</code></td>
<td>
<p>logical specifying if mean log age should be returned instead of mean age</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term adds one statistic equaling the average, over all ties
present in the network, of the amount of time elapsed since
formation.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='NetSeries'>A network series specification for conditional modeling.</h2><span id='topic+NetSeries'></span>

<h3>Description</h3>

<p>A function for specifying the LHS of a temporal network series ERGM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NetSeries(..., order = 1, NA.impute = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NetSeries_+3A_...">...</code></td>
<td>
<p>series specification, in one of three formats:
</p>

<ol>
<li><p> A list of identically- dimensioned and directed networks.
</p>
</li>
<li><p> Several networks as arguments.
</p>
</li>
<li><p> A <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object and a numeric vector of time indices.
</p>
</li></ol>
</td></tr>
<tr><td><code id="NetSeries_+3A_order">order</code></td>
<td>
<p>how many previous networks to store as an accessible
covariate of the model.</p>
</td></tr>
<tr><td><code id="NetSeries_+3A_na.impute">NA.impute</code></td>
<td>
<p>How missing dyads in transitioned-from networks
are be imputed when using conditional estimation. See argument
<code>imputers</code> of <code><a href="#topic+impute.network.list">impute.network.list</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network object with temporal metadata.
</p>


<h3>Note</h3>

<p>It is not recommended to modify the network returned by
<code>NetSeries</code> except by adding and removing edges, and even that
must be done with some care, to avoid putting it into an
inconsistent state.
</p>
<p>It is almost always better to modify the original networks and
regenerate the series.
</p>


<h3>See Also</h3>

<p><a href="ergm.html#topic+ergm-terms">Help on model specification</a> for specific terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(samplk)

# Method 1: list of networks
monks &lt;- NetSeries(list(samplk1,samplk2,samplk3))
ergm(monks ~ Form(~edges)+Diss(~edges))
ergm(monks ~ Form(~edges)+Persist(~edges))

# Method 2: networks as arguments
monks &lt;- NetSeries(samplk1,samplk2,samplk3)
ergm(monks ~ Form(~edges)+Diss(~edges))
ergm(monks ~ Form(~edges)+Persist(~edges))

# Method 3: networkDynamic and time points:
## TODO

</code></pre>

<hr>
<h2 id='nodefactor.mean.age-ergmTerm'>Average ages of extant half-ties incident on nodes of specified attribute levels</h2><span id='topic+nodefactor.mean.age-ergmTerm'></span><span id='topic+InitErgmTerm.nodefactor.mean.age'></span>

<h3>Description</h3>

<p>Average ages of extant half-ties incident on nodes of specified attribute levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodefactor.mean.age(attr, levels=NULL, emptyval=0, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodefactor.mean.age-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodefactor.mean.age-ergmTerm_+3A_levels">levels</code></td>
<td>
<p>controls what levels are included. Note that the default
<code>levels</code> value for <code>nodefactor.mean.age</code> retains all levels, unlike the default
for <code>nodefactor</code> , which omits the first level.</p>
</td></tr>
<tr><td><code id="nodefactor.mean.age-ergmTerm_+3A_emptyval">emptyval</code></td>
<td>
<p>can be used to specify the value returned if the network is empty. A different value may be
specified for each level of <code>attr</code>. The length of <code>emptyval</code> should either be 1 (in which case that value
is used for every level of <code>attr</code> ) or should be equal to the number of retained levels of <code>attr</code> , in
which case the <code>i</code> th value in <code>emptyval</code> is used for the <code>i</code> th retained level of <code>attr</code>. This is,
technically, an arbitrary value, but it should
not have a substantial effect unless a non-negligible fraction of
networks at the parameter configuration of interest is empty.</p>
</td></tr>
<tr><td><code id="nodefactor.mean.age-ergmTerm_+3A_log">log</code></td>
<td>
<p>logical specifying if mean log age should be returned instead of mean age</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term adds one statistic for each level of <code>attr</code> ,
equaling the average, over all half-ties incident on nodes of that level,
of the amount of time elapsed since formation.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='nodemix.mean.age-ergmTerm'>Average ages of extant ties of specified mixing types</h2><span id='topic+nodemix.mean.age-ergmTerm'></span><span id='topic+InitErgmTerm.nodemix.mean.age'></span>

<h3>Description</h3>

<p>Average ages of extant ties of specified mixing types
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: nodemix.mean.age(attr, b1levels=NULL, b2levels=NULL, levels=NULL,
#                          levels2=NULL, emptyval=0, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodemix.mean.age-ergmTerm_+3A_attr">attr</code></td>
<td>
<p>a vertex attribute specification (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details.)</p>
</td></tr>
<tr><td><code id="nodemix.mean.age-ergmTerm_+3A_b1levels">b1levels</code>, <code id="nodemix.mean.age-ergmTerm_+3A_b2levels">b2levels</code>, <code id="nodemix.mean.age-ergmTerm_+3A_levels">levels</code>, <code id="nodemix.mean.age-ergmTerm_+3A_level2">level2</code></td>
<td>
<p>control what statistics are included in the model and the order in which they appear. <code>levels2</code> apply to all networks; <code>levels</code> applies to unipartite networks; <code>b1levels</code> and <code>b2levels</code> apply to bipartite networks (see Specifying Vertex attributes and Levels (<code>?nodal_attributes</code>) for details)</p>
</td></tr>
<tr><td><code id="nodemix.mean.age-ergmTerm_+3A_emptyval">emptyval</code></td>
<td>
<p>can be used to specify the value returned if the network is empty. A different value may be
specified for each mixing type of <code>attr</code>. The length of <code>emptyval</code> should either be 1 (in which case that value
is used for every mixing type of <code>attr</code> ) or should be equal to the number of retained mixing types of <code>attr</code> , in
which case the <code>i</code> th value in <code>emptyval</code> is used for the <code>i</code> th retained mixing type of <code>attr</code>. This is,
technically, an arbitrary value, but it should
not have a substantial effect unless a non-negligible fraction of
networks at the parameter configuration of interest is empty.</p>
</td></tr>
<tr><td><code id="nodemix.mean.age-ergmTerm_+3A_log">log</code></td>
<td>
<p>logical specifying if mean log age should be returned instead of mean age</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term adds one statistic for each mixing type of <code>attr</code> ,
equaling the average, over all ties of that mixing type,
of the amount of time elapsed since formation.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='Persist-ergmTerm'>The Persistence Operator Term</h2><span id='topic+Persist-ergmTerm'></span><span id='topic+InitErgmTerm.Persist+20+28dynamic+29'></span><span id='topic+InitErgmTerm.Persist'></span>

<h3>Description</h3>

<p>The Persistence Operator Term
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: Persist(
#           formula,
#           lm = ~1,
#           subset = TRUE,
#           weights = 1,
#           contrasts = NULL,
#           offset = 0,
#           label = NULL
#         )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Persist-ergmTerm_+3A_formula">formula</code></td>
<td>
<p>a one-sided <code><a href="ergm.html#topic+ergm">ergm()</a></code>-style formula with the terms to be evaluated</p>
</td></tr>
<tr><td><code id="Persist-ergmTerm_+3A_lm">lm</code>, <code id="Persist-ergmTerm_+3A_subset">subset</code>, <code id="Persist-ergmTerm_+3A_weights">weights</code>, <code id="Persist-ergmTerm_+3A_contrasts">contrasts</code>, <code id="Persist-ergmTerm_+3A_offset">offset</code>, <code id="Persist-ergmTerm_+3A_label">label</code></td>
<td>
<p><strong><code><a href="#topic+NetSeries">NetSeries()</a></code> LHS only</strong> arguments to specify time-varying parameters. See <code><a href="ergm.multi.html#topic+N-ergmTerm-c9b59cc1">N()</a></code> term operator in the <span class="pkg">ergm.multi</span> for details. <code>lm</code> formula may reference <code>.Time</code> for the network's time index, <code>.TimeID</code> for the its index in the network series (where the initial network is 1 and the first modelled network is 2), and <code>.TimeDelta</code> for the time elapsed between the network and the immediately previous network in the series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This term accepts a model formula
and produces the corresponding model for the
post-dissolution/persistence network: effectively the network containing
ties that persisted since the last time step.
</p>
<p>This is the equivalent of the old-style <code>dissolution</code> model. So
a larger positive coefficient for <code>Persist()</code> operator means
less dissolution. It
produces the same results as the new <code>Diss()</code> operator, except the
signs of the coefficients are negated.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='simulate.network'>STERGM wrappers for TERGM simulation</h2><span id='topic+simulate.network'></span><span id='topic+simulate.stergm'></span><span id='topic+simulate.networkDynamic'></span>

<h3>Description</h3>

<p>The <code>simulate.network</code> and <code>simulate.networkDynamic</code> wrappers
are provided for backwards compatibility.  It is recommended that new
code make use of the <code>simulate_formula.network</code> and
<code>simulate_formula.networkDynamic</code> functions instead.  See
<code><a href="#topic+simulate.tergm">simulate.tergm</a></code> for details on these new functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'network'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  formation,
  dissolution,
  coef.form,
  coef.diss,
  constraints = ~.,
  monitor = NULL,
  time.slices = 1,
  time.start = NULL,
  time.burnin = 0,
  time.interval = 1,
  time.offset = 1,
  control = control.simulate.network(),
  output = c("networkDynamic", "stats", "changes", "final", "ergm_state"),
  stats.form = FALSE,
  stats.diss = FALSE,
  verbose = FALSE,
  ...
)

## S3 method for class 'networkDynamic'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  formation,
  dissolution,
  coef.form = attr(object, "coef.form"),
  coef.diss = attr(object, "coef.diss"),
  constraints = ~.,
  monitor = NULL,
  time.slices = 1,
  time.start = NULL,
  time.burnin = 0,
  time.interval = 1,
  time.offset = 1,
  control = control.simulate.network(),
  output = c("networkDynamic", "stats", "changes", "final", "ergm_state"),
  stats.form = FALSE,
  stats.diss = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.network_+3A_object">object</code></td>
<td>
<p>an object of type <code><a href="network.html#topic+network">network</a></code> or <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code></p>
</td></tr>
<tr><td><code id="simulate.network_+3A_nsim">nsim</code></td>
<td>
<p>Number of replications (separate chains of networks) of the
process to run and return. The <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> method only
supports <code>nsim=1</code>.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_formation">formation</code>, <code id="simulate.network_+3A_dissolution">dissolution</code></td>
<td>
<p>One-sided <code><a href="ergm.html#topic+ergm">ergm</a></code>-style formulas for
the formation and dissolution models, respectively.  The dissolution model is parameterized in terms of tie persistence.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_coef.form">coef.form</code></td>
<td>
<p>Parameters for the formation model.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_coef.diss">coef.diss</code></td>
<td>
<p>Parameters for the dissolution (persistence) model.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_constraints">constraints</code></td>
<td>
<p>A formula specifying one or more constraints
on the support of the distribution of the networks being modeled. Multiple constraints
may be given, separated by &ldquo;+&rdquo; and &ldquo;-&rdquo; operators. See
<code><a href="ergm.html#topic+ergmConstraint">ergmConstraint</a></code> for the detailed explanation of
their semantics and also for an indexed list of the constraints visible to the <span class="pkg">ergm</span> package.
</p>
<p>The default is to have no constraints except those provided through
the <code><a href="ergm.html#topic+ergmlhs">ergmlhs</a></code> API.
</p>
<p>Together with the model terms in the formula and the reference measure, the constraints
define the distribution of networks being modeled.
</p>
<p>It is also possible to specify a proposal function directly either
by passing a string with the function's name (in which case,
arguments to the proposal should be specified through the
<code>MCMC.prop.args</code> argument to the relevant control function, or
by giving it on the LHS of the hints formula to <code>MCMC.prop</code>
argument to the control function. This will override
the one chosen automatically.
</p>
<p>Note that not all possible combinations of constraints and reference
measures are supported. However, for relatively simple constraints
(i.e., those that simply permit or forbid specific dyads or sets of
dyads from changing), arbitrary combinations should be possible.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_monitor">monitor</code></td>
<td>
<p>A one-sided formula specifying one or more terms whose
value is to be monitored.  If <code>monitor</code> is specified as a character
(one of <code>"formation"</code>, <code>"dissolution"</code>, and <code>"all"</code>) then
the function <code><a href="#topic+.extract.fd.formulae">.extract.fd.formulae</a></code> is used to determine the
corresponding formula; the user should be aware of its behavior and limitations.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_time.slices">time.slices</code></td>
<td>
<p>Number of time slices (or statistics) to return from each
replication of the dynamic process. See below for return types. Defaults to
1, which, if <code>time.burnin==0</code> and <code>time.interval==1</code> (the
defaults), advances the process one time step.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_time.start">time.start</code></td>
<td>
<p>An optional argument specifying the time point at which
the simulation is to start. See Details for further information.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_time.burnin">time.burnin</code></td>
<td>
<p>Number of time steps to discard before starting to
collect network statistics.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_time.interval">time.interval</code></td>
<td>
<p>Number of time steps between successive recordings of
network statistics.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_time.offset">time.offset</code></td>
<td>
<p>Argument specifying the offset between the point when the
state of the network is sampled (<code>time.start</code>) and the the beginning of
the spell that should be recorded for the newly simulated network state.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning,
constructed using <code><a href="#topic+control.simulate.network">control.simulate.network</a></code>.  These are mapped
to <code><a href="#topic+control.simulate.formula.tergm">control.simulate.formula.tergm</a></code> controls by assigning:
</p>

<ul>
<li> <p><code>MCMC.prop.form</code> to <code>MCMC.prop</code>,
</p>
</li>
<li> <p><code>MCMC.prop.args.form</code> to <code>MCMC.prop.args</code>, and
</p>
</li>
<li> <p><code>MCMC.prop.weights.form</code> to <code>MCMC.prop.weights</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate.network_+3A_output">output</code></td>
<td>
<p>A character vector specifying output type: one of
<code>"networkDynamic"</code> (the default), <code>"stats"</code>, <code>"changes"</code>,
<code>"final"</code>, and <code>"ergm_state"</code>, with partial matching allowed.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_stats.form">stats.form</code>, <code id="simulate.network_+3A_stats.diss">stats.diss</code></td>
<td>
<p>Logical: Whether to return
formation/dissolution model statistics. This is not the recommended method:
use the <code>monitor</code> argument instead.  Note that if either <code>stats.form</code>
or <code>stats.diss</code> is <code>TRUE</code>, all generative model statistics will be
returned.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="simulate.network_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that return values may be structured differently than in past versions.
</p>
<p>Remember that in <code>stergm</code>, the dissolution formula is parameterized in
terms of tie persistence: negative coefficients imply lower rates of persistence
and postive coefficients imply higher rates.  The dissolution effects are simply the
negation of these coefficients.
</p>
<p>Because the old <code>dissolution</code> formula in <code>stergm</code> represents
tie persistence, it maps to the new <code>Persist()</code> operator
in the <code>tergm</code> function, NOT the <code>Diss()</code> operator
</p>


<h3>Value</h3>

<p>Depends on the <code>output</code> argument.  See <code><a href="#topic+simulate.tergm">simulate.tergm</a></code>
for details.  Note that some formation/dissolution separated
information is also attached to the return value for calls made through
<code>simulate.network</code> and <code>simulate.networkDynamic</code> in
an attempt to increase backwards compatibility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logit&lt;-function(p)log(p/(1-p))
coef.form.f&lt;-function(coef.diss,density) -log(((1+exp(coef.diss))/(density/(1-density)))-1)

# Construct a network with 20 nodes and 20 edges
n&lt;-20
target.stats&lt;-edges&lt;-20
g0&lt;-network.initialize(n,dir=TRUE)
g1&lt;-san(g0~edges,target.stats=target.stats,verbose=TRUE)

S&lt;-10

# To get an average duration of 10...
duration&lt;-10
coef.diss&lt;-logit(1-1/duration)

# To get an average of 20 edges...
dyads&lt;-network.dyadcount(g1)
density&lt;-edges/dyads
coef.form&lt;-coef.form.f(coef.diss,density)

# ... coefficients.
print(coef.form)
print(coef.diss)

# Simulate a networkDynamic
dynsim&lt;-simulate(g1,formation=~edges,dissolution=~edges,
                 coef.form=coef.form,coef.diss=coef.diss,
                 time.slices=S,verbose=TRUE)

# "Resume" the simulation.
dynsim2&lt;-simulate(dynsim,formation=~edges,dissolution=~edges,time.slices=S,verbose=TRUE)

</code></pre>

<hr>
<h2 id='simulate.tergm'>Draw from the distribution of a Temporal Exponential Family
Random Graph Model</h2><span id='topic+simulate.tergm'></span><span id='topic+simulate_formula.network'></span><span id='topic+simulate_formula.networkDynamic'></span>

<h3>Description</h3>

<p><code><a href="stats.html#topic+simulate">simulate</a></code> is used to draw from temporal
exponential family random network models in their natural parameterizations.
See <code><a href="#topic+tergm">tergm</a></code> for more information on these models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tergm'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  coef = coefficients(object),
  constraints = object$constraints,
  monitor = object$targets,
  time.slices = 1,
  time.start = NULL,
  time.burnin = 0,
  time.interval = 1,
  control = control.simulate.tergm(),
  output = c("networkDynamic", "stats", "changes", "final", "ergm_state"),
  nw.start = NULL,
  stats = FALSE,
  verbose = FALSE,
  ...
)

## S3 method for class 'network'
simulate_formula(
  object,
  nsim = 1,
  seed = NULL,
  coef = NULL,
  constraints = ~.,
  monitor = NULL,
  time.slices = 1,
  time.start = NULL,
  time.burnin = 0,
  time.interval = 1,
  time.offset = 1,
  control = control.simulate.formula.tergm(),
  output = c("networkDynamic", "stats", "changes", "final", "ergm_state"),
  stats = FALSE,
  verbose = FALSE,
  ...,
  basis = ergm.getnetwork(object),
  dynamic = FALSE
)

## S3 method for class 'networkDynamic'
simulate_formula(
  object,
  nsim = 1,
  seed = NULL,
  coef = attr(basis, "coef"),
  constraints = ~.,
  monitor = NULL,
  time.slices = 1,
  time.start = NULL,
  time.burnin = 0,
  time.interval = 1,
  time.offset = 1,
  control = control.simulate.formula.tergm(),
  output = c("networkDynamic", "stats", "changes", "final", "ergm_state"),
  stats = FALSE,
  verbose = FALSE,
  ...,
  basis = eval_lhs.formula(object),
  dynamic = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.tergm_+3A_object">object</code></td>
<td>
<p>for <code>simulate.tergm</code>, an object of type <code><a href="#topic+tergm">tergm</a></code> giving a model fit;
for <code>simulate_formula.network</code> and <code>simulate_formula.networkDynamic</code>, a formula specifying
the model
</p>
<p><code>simulate_formula.network</code> understands the <code><a href="#topic+lasttoggle">lasttoggle</a></code> &quot;API&quot;.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_nsim">nsim</code></td>
<td>
<p>Number of replications (separate chains of networks) of the
process to run and return. The <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> method only
supports <code>nsim=1</code>.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_seed">seed</code></td>
<td>
<p>Seed value (integer) for the random number generator.  See
<code><a href="base.html#topic+set.seed">set.seed</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_coef">coef</code></td>
<td>
<p>Parameters for the model.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_constraints">constraints</code></td>
<td>
<p>A formula specifying one or more constraints
on the support of the distribution of the networks being modeled. Multiple constraints
may be given, separated by &ldquo;+&rdquo; and &ldquo;-&rdquo; operators. See
<code><a href="ergm.html#topic+ergmConstraint">ergmConstraint</a></code> for the detailed explanation of
their semantics and also for an indexed list of the constraints visible to the <span class="pkg">ergm</span> package.
</p>
<p>The default is to have no constraints except those provided through
the <code><a href="ergm.html#topic+ergmlhs">ergmlhs</a></code> API.
</p>
<p>Together with the model terms in the formula and the reference measure, the constraints
define the distribution of networks being modeled.
</p>
<p>It is also possible to specify a proposal function directly either
by passing a string with the function's name (in which case,
arguments to the proposal should be specified through the
<code>MCMC.prop.args</code> argument to the relevant control function, or
by giving it on the LHS of the hints formula to <code>MCMC.prop</code>
argument to the control function. This will override
the one chosen automatically.
</p>
<p>Note that not all possible combinations of constraints and reference
measures are supported. However, for relatively simple constraints
(i.e., those that simply permit or forbid specific dyads or sets of
dyads from changing), arbitrary combinations should be possible.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_monitor">monitor</code></td>
<td>
<p>A one-sided formula specifying one or more terms whose
value is to be monitored.  If <code>monitor</code> is specified as a character
(one of <code>"formation"</code>, <code>"dissolution"</code>, and <code>"all"</code>) then
the function <code><a href="#topic+.extract.fd.formulae">.extract.fd.formulae</a></code> is used to determine the
corresponding formula; the user should be aware of its behavior and limitations.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_time.slices">time.slices</code></td>
<td>
<p>Number of time slices (or statistics) to return from each
replication of the dynamic process. See below for return types. Defaults to
1, which, if <code>time.burnin==0</code> and <code>time.interval==1</code> (the
defaults), advances the process one time step.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_time.start">time.start</code></td>
<td>
<p>An optional argument specifying the time point at which
the simulation is to start. See Details for further information.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_time.burnin">time.burnin</code></td>
<td>
<p>Number of time steps to discard before starting to
collect network statistics.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_time.interval">time.interval</code></td>
<td>
<p>Number of time steps between successive recordings of
network statistics.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning.
Constructed using <code><a href="#topic+control.simulate.tergm">control.simulate.tergm</a></code> or
<code><a href="#topic+control.simulate.formula.tergm">control.simulate.formula.tergm</a></code>.  For backwards compatibility,
control lists from <code><a href="#topic+control.simulate.stergm">control.simulate.stergm</a></code> and
<code><a href="#topic+control.simulate.network">control.simulate.network</a></code> are allowed in calls to
<code>simulate.tergm</code>; they are mapped to <code>control.simulate.tergm</code>
by assigning:
</p>

<ul>
<li> <p><code>MCMC.prop.form</code> to <code>MCMC.prop</code>,
</p>
</li>
<li> <p><code>MCMC.prop.args.form</code> to <code>MCMC.prop.args</code>,
</p>
</li>
<li> <p><code>MCMC.prop.weights.form</code> to <code>MCMC.prop.weights</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_output">output</code></td>
<td>
<p>A character vector specifying output type: one of
<code>"networkDynamic"</code> (the default), <code>"stats"</code>, <code>"changes"</code>, <code>"final"</code>, and
<code>"ergm_state"</code>, with partial matching allowed. See Value section for details.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_nw.start">nw.start</code></td>
<td>
<p>A specification for the starting network to be used by
<code>simulate.tergm</code>, optional for EGMME fits, but required for CMLE and
CMPLE fits: </p>
 <dl>
<dt>a numeric index <code>i</code></dt><dd><p>use <code>i</code>th time-point's
network, where the first network in the series used to fit the model is
defined to be at the first time point;</p>
</dd>
<dt><code>"first"</code> or <code>"last"</code></dt><dd><p>the first or last time point used in
fitting the model; or</p>
</dd>
<dt><code>network</code></dt><dd><p>specify the network directly.</p>
</dd>
</dl>

<p><code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>s
cannot be used as starting networks for <code>simulate.tergm</code> at this time.
(They can be used as starting networks for <code>simulate_formula.networkDynamic</code>,
of course.)</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_stats">stats</code></td>
<td>
<p>Logical: Whether to return
model statistics. This is not the recommended method:
use <code>monitor</code> argument instead.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_time.offset">time.offset</code></td>
<td>
<p>Argument specifying the offset between the point when the
state of the network is sampled (<code>time.start</code>) and the the beginning of
the spell that should be recorded for the newly simulated network state.</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_basis">basis</code></td>
<td>
<p>For the <code>network</code> and <code>networkDynamic</code> methods,
the network to start the simulation from.  (If <code>basis</code> is missing,
the default is the left hand side of the <code>object</code> argument.)</p>
</td></tr>
<tr><td><code id="simulate.tergm_+3A_dynamic">dynamic</code></td>
<td>
<p>Logical; if <code>TRUE</code>, dynamic simulation is performed in
<code>tergm</code>; if <code>FALSE</code> (the default), ordinary <code>ergm</code>
simulation is performed instead.  Note that when <code>dynamic=FALSE</code>,
default argument values for <code>ergm</code>'s <code>simulate</code> methods
are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dynamic process is run forward and the results are returned. For the
method for <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>, the simulation is resumed from the
last generated time point of <code>basis</code> (or the left hand side of <code>object</code>
if <code>basis</code> is missing), by default with the same model
and parameters.
</p>
<p>The starting network for the <code><a href="#topic+tergm">tergm</a></code> object method
(<code>simulate.tergm</code>) is determined by the <code>nw.start</code> argument.
</p>

<ul>
<li><p>If <code>time.start</code> is specified, it is used as the initial
time index of the simulation.
</p>
</li>
<li><p>If <code>time.start</code> is not specified (is <code>NULL</code>), then
if the <code>object</code> carries a time stamp from which to start
or resume the simulation, either in the form
of a <code>"time"</code> network attribute (for the
<code><a href="network.html#topic+network">network</a></code> method &mdash; see the
<code><a href="#topic+lasttoggle">lasttoggle</a></code> &quot;API&quot;) or
in the form of an <code><a href="networkDynamic.html#topic+net.obs.period">net.obs.period</a></code> network attribute (for the
<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> method), this attribute will be used. (If
specified, <code>time.start</code> will override it with a warning.)

</p>
</li>
<li><p>Othewise, the simulation starts at 0.
</p>
</li></ul>



<h3>Value</h3>

<p>Depends on the <code>output</code> argument:
</p>
<table>
<tr><td><code>"stats"</code></td>
<td>
<p>If <code>stats == FALSE</code>, an <code><a href="coda.html#topic+mcmc">mcmc</a></code> matrix with
monitored statistics, and if <code>stats == TRUE</code>, a
list containing elements <code>stats</code> for statistics specified in the
<code>monitor</code> argument, and <code>stats.gen</code> for the model statistics.
If <code>stats == FALSE</code> and no monitored statistics are specified,
an empty list is returned, with a warning.
When <code>nsim&gt;1</code>, an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> (or list of them) of
the statistics is returned instead.</p>
</td></tr>
<tr><td><code>"networkDynamic"</code></td>
<td>
<p>A <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>
object representing the simulated process, with ties present in the
initial network having onset <code>-Inf</code> and ties present at the end
of the simulation having terminus <code>+Inf</code>. The method for
<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> returns the initial
<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> with simulated changes
applied to it. The <code><a href="networkDynamic.html#topic+net.obs.period">net.obs.period</a></code> network attribute is
updated (or added if not existing) to reflect the time period that was
simulated. If the network does not have any <code><a href="networkDynamic.html#topic+persistent.ids">persistent.ids</a></code>
defined for vertices, a vertex.pid will be attached in a vertex attribute
named <code>'tergm_pid'</code> to facilitate 'bookkeeping' between the networkDynamic
argument and the simulated network time step.
Additionally, attributes (<code><a href="base.html#topic+attr">attr</a></code>, not network
attributes) are attached as follows:
</p>

<dl>
<dt><code>formula</code>, <code>monitor</code>:</dt><dd><p>Model
and monitoring formulas used in the simulation, respectively.</p>
</dd>
<dt><code>stats</code>, <code>stats.gen</code>:</dt><dd><p>Network statistics as above.</p>
</dd>
<dt><code>coef</code>:</dt><dd><p>Coefficients used in the simulation.</p>
</dd>
<dt><code>changes</code>:</dt><dd><p>A four-column matrix summarizing the changes in the
<code>"changes"</code> output. (This may be removed in the future.)</p>
</dd>
</dl>

<p>When <code>nsim&gt;1</code>, a <code><a href="ergm.html#topic+network.list">network.list</a></code> of these
<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>s is returned.
</p>
</td></tr>
<tr><td><code>"changes"</code></td>
<td>
<p>An integer matrix with four columns (<code>time</code>,
<code>tail</code>, <code>head</code>, and <code>to</code>), giving the time-stamped
changes relative to the current network. <code>to</code> is <code>1</code> if
a tie was formed and <code>0</code> if a tie was dissolved. The
convention for <code>time</code> is that it gives the time point during
which the change is effective. For example, a row
<code>c(5,2,3,1)</code> indicates that between time <code class="reqn">4</code> and <code class="reqn">5</code>,
a tie from node <code class="reqn">2</code> to node <code class="reqn">3</code> was formed, so that it was
absent at time point <code class="reqn">4</code> and present at time point <code class="reqn">5</code>;
while a row <code>c(5,2,3,0)</code> indicates that in that time, that
tie was dissolved, so that it is was present at time point <code class="reqn">4</code>
and absent at time point <code class="reqn">5</code>.
Additionally, the same attributes (<code><a href="base.html#topic+attr">attr</a></code>, not network
attributes) as with <code>output=="networkDynamic"</code> are attached.
When <code>nsim&gt;1</code>, a list of these change matrices is returned.</p>
</td></tr>
<tr><td><code>"final"</code></td>
<td>
<p>A <code><a href="network.html#topic+network">network</a></code>
object representing the last network in the series generated.
<code><a href="#topic+lasttoggle">lasttoggle</a></code> and <code>time</code> attributes are also included.
Additionally, the same attributes (<code><a href="base.html#topic+attr">attr</a></code>, not network
attributes) as with <code>output=="networkDynamic"</code> are attached.
When <code>nsim&gt;1</code>, a <code><a href="ergm.html#topic+network.list">network.list</a></code> of these
<code><a href="network.html#topic+network">network</a></code>s is returned.
</p>
</td></tr>
<tr><td><code>"ergm_state"</code></td>
<td>
<p>The <code><a href="ergm.html#topic+ergm_state">ergm_state</a></code> object resulting
from the simulation.  Attributes are attached as for other output types.</p>
</td></tr>
</table>
<p>Note that when using <code>simulate_formula.networkDynamic</code> with either
<code>"final"</code> or <code>"ergm_state"</code> for <code>output</code>, the nodes
included in these objects are those produced by <code>network.collapse</code>
at the start time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(samplk)

# Fit a transition from Time 1 to Time 2
samplk12 &lt;- tergm(list(samplk1, samplk2)~
                  Form(~edges+mutual+transitiveties+cyclicalties)+
                  Diss(~edges+mutual+transitiveties+cyclicalties),
                  estimate="CMLE")

# direct simulation from tergm object
sim1 &lt;- simulate(samplk12, nw.start="last")

# equivalent simulation from formula with network LHS;
# must pass dynamic=TRUE for tergm simulation
sim2 &lt;- simulate(samplk2 ~ Form(~edges+mutual+transitiveties+cyclicalties) +
                           Diss(~edges+mutual+transitiveties+cyclicalties),
                           coef = coef(samplk12),
                           dynamic=TRUE)

# the default simulate output is a networkDynamic, and we can simulate
# with a networkDynamic LHS as well
sim3 &lt;- simulate(sim2 ~ Form(~edges+mutual+transitiveties+cyclicalties) +
                        Diss(~edges+mutual+transitiveties+cyclicalties),
                        coef = coef(samplk12),
                        dynamic=TRUE)

</code></pre>

<hr>
<h2 id='snctrl'>Statnet Control</h2><span id='topic+snctrl'></span>

<h3>Description</h3>

<p>A utility to facilitate argument completion of control lists, reexported from <code>statnet.common</code>.
</p>


<h3>Currently recognised control parameters</h3>

<p>This list is updated as packages are loaded and unloaded.
</p>


<h4>Package <span class="pkg">ergm</span></h4>

<dl>
<dt><code><a href="ergm.html#topic+control.ergm">control.ergm</a></code></dt><dd><p><code>drop, init, init.method, main.method, force.main, main.hessian,
             checkpoint, resume, MPLE.samplesize, init.MPLE.samplesize,
             MPLE.type, MPLE.maxit, MPLE.nonvar, MPLE.nonident,
             MPLE.nonident.tol, MPLE.covariance.samplesize,
             MPLE.covariance.method, MPLE.covariance.sim.burnin,
             MPLE.covariance.sim.interval, MPLE.constraints.ignore,
             MCMC.prop, MCMC.prop.weights, MCMC.prop.args,
             MCMC.interval, MCMC.burnin, MCMC.samplesize,
             MCMC.effectiveSize, MCMC.effectiveSize.damp,
             MCMC.effectiveSize.maxruns,
             MCMC.effectiveSize.burnin.pval,
             MCMC.effectiveSize.burnin.min,
             MCMC.effectiveSize.burnin.max,
             MCMC.effectiveSize.burnin.nmin,
             MCMC.effectiveSize.burnin.nmax,
             MCMC.effectiveSize.burnin.PC,
             MCMC.effectiveSize.burnin.scl,
             MCMC.effectiveSize.order.max, MCMC.return.stats,
             MCMC.runtime.traceplot, MCMC.maxedges, MCMC.addto.se,
             MCMC.packagenames, SAN.maxit, SAN.nsteps.times, SAN,
             MCMLE.termination, MCMLE.maxit, MCMLE.conv.min.pval,
             MCMLE.confidence, MCMLE.confidence.boost,
             MCMLE.confidence.boost.threshold,
             MCMLE.confidence.boost.lag, MCMLE.NR.maxit,
             MCMLE.NR.reltol, obs.MCMC.mul, obs.MCMC.samplesize.mul,
             obs.MCMC.samplesize, obs.MCMC.effectiveSize,
             obs.MCMC.interval.mul, obs.MCMC.interval,
             obs.MCMC.burnin.mul, obs.MCMC.burnin, obs.MCMC.prop,
             obs.MCMC.prop.weights, obs.MCMC.prop.args,
             obs.MCMC.impute.min_informative,
             obs.MCMC.impute.default_density, MCMLE.min.depfac,
             MCMLE.sampsize.boost.pow, MCMLE.MCMC.precision,
             MCMLE.MCMC.max.ESS.frac, MCMLE.metric, MCMLE.method,
             MCMLE.dampening, MCMLE.dampening.min.ess,
             MCMLE.dampening.level, MCMLE.steplength.margin,
             MCMLE.steplength, MCMLE.steplength.parallel,
             MCMLE.sequential, MCMLE.density.guard.min,
             MCMLE.density.guard, MCMLE.effectiveSize,
             obs.MCMLE.effectiveSize, MCMLE.interval, MCMLE.burnin,
             MCMLE.samplesize.per_theta, MCMLE.samplesize.min,
             MCMLE.samplesize, obs.MCMLE.samplesize.per_theta,
             obs.MCMLE.samplesize.min, obs.MCMLE.samplesize,
             obs.MCMLE.interval, obs.MCMLE.burnin,
             MCMLE.steplength.solver, MCMLE.last.boost,
             MCMLE.steplength.esteq, MCMLE.steplength.miss.sample,
             MCMLE.steplength.min, MCMLE.effectiveSize.interval_drop,
             MCMLE.save_intermediates, MCMLE.nonvar, MCMLE.nonident,
             MCMLE.nonident.tol, SA.phase1_n, SA.initial_gain,
             SA.nsubphases, SA.min_iterations, SA.max_iterations,
             SA.phase3_n, SA.interval, SA.burnin, SA.samplesize,
             CD.samplesize.per_theta, obs.CD.samplesize.per_theta,
             CD.nsteps, CD.multiplicity, CD.nsteps.obs,
             CD.multiplicity.obs, CD.maxit, CD.conv.min.pval,
             CD.NR.maxit, CD.NR.reltol, CD.metric, CD.method,
             CD.dampening, CD.dampening.min.ess, CD.dampening.level,
             CD.steplength.margin, CD.steplength, CD.adaptive.epsilon,
             CD.steplength.esteq, CD.steplength.miss.sample,
             CD.steplength.min, CD.steplength.parallel,
             CD.steplength.solver, loglik, term.options, seed,
             parallel, parallel.type, parallel.version.check,
             parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.ergm.bridge">control.ergm.bridge</a></code></dt><dd><p><code>bridge.nsteps, bridge.target.se, bridge.bidirectional, MCMC.burnin,
                    MCMC.burnin.between, MCMC.interval,
                    MCMC.samplesize, obs.MCMC.burnin,
                    obs.MCMC.burnin.between, obs.MCMC.interval,
                    obs.MCMC.samplesize, MCMC.prop, MCMC.prop.weights,
                    MCMC.prop.args, obs.MCMC.prop,
                    obs.MCMC.prop.weights, obs.MCMC.prop.args,
                    MCMC.maxedges, MCMC.packagenames, term.options,
                    seed, parallel, parallel.type,
                    parallel.version.check, parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.ergm.godfather">control.ergm.godfather</a></code></dt><dd><p><code>term.options</code></p>
</dd><dt><code><a href="ergm.html#topic+control.gof.ergm">control.gof.ergm</a></code></dt><dd><p><code>nsim, MCMC.burnin, MCMC.interval, MCMC.batch, MCMC.prop,
                 MCMC.prop.weights, MCMC.prop.args, MCMC.maxedges,
                 MCMC.packagenames, MCMC.runtime.traceplot,
                 network.output, seed, parallel, parallel.type,
                 parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="ergm.html#topic+control.gof.formula">control.gof.formula</a></code></dt><dd><p><code>nsim, MCMC.burnin, MCMC.interval, MCMC.batch, MCMC.prop,
                    MCMC.prop.weights, MCMC.prop.args, MCMC.maxedges,
                    MCMC.packagenames, MCMC.runtime.traceplot,
                    network.output, seed, parallel, parallel.type,
                    parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="ergm.html#topic+control.logLik.ergm">control.logLik.ergm</a></code></dt><dd><p><code>bridge.nsteps, bridge.target.se, bridge.bidirectional, MCMC.burnin,
                    MCMC.interval, MCMC.samplesize,
                    obs.MCMC.samplesize, obs.MCMC.interval,
                    obs.MCMC.burnin, MCMC.prop, MCMC.prop.weights,
                    MCMC.prop.args, obs.MCMC.prop,
                    obs.MCMC.prop.weights, obs.MCMC.prop.args,
                    MCMC.maxedges, MCMC.packagenames, term.options,
                    seed, parallel, parallel.type,
                    parallel.version.check, parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.san">control.san</a></code></dt><dd><p><code>SAN.maxit, SAN.tau, SAN.invcov, SAN.invcov.diag, SAN.nsteps.alloc,
            SAN.nsteps, SAN.samplesize, SAN.prop, SAN.prop.weights,
            SAN.prop.args, SAN.packagenames, SAN.ignore.finite.offsets,
            term.options, seed, parallel, parallel.type,
            parallel.version.check, parallel.inherit.MT</code></p>
</dd><dt><code><a href="ergm.html#topic+control.simulate">control.simulate</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.prop, MCMC.prop.weights,
                 MCMC.prop.args, MCMC.batch, MCMC.effectiveSize,
                 MCMC.effectiveSize.damp, MCMC.effectiveSize.maxruns,
                 MCMC.effectiveSize.burnin.pval,
                 MCMC.effectiveSize.burnin.min,
                 MCMC.effectiveSize.burnin.max,
                 MCMC.effectiveSize.burnin.nmin,
                 MCMC.effectiveSize.burnin.nmax,
                 MCMC.effectiveSize.burnin.PC,
                 MCMC.effectiveSize.burnin.scl,
                 MCMC.effectiveSize.order.max, MCMC.maxedges,
                 MCMC.packagenames, MCMC.runtime.traceplot,
                 network.output, term.options, parallel, parallel.type,
                 parallel.version.check, parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.simulate.ergm">control.simulate.ergm</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.scale, MCMC.prop, MCMC.prop.weights,
                      MCMC.prop.args, MCMC.batch, MCMC.effectiveSize,
                      MCMC.effectiveSize.damp,
                      MCMC.effectiveSize.maxruns,
                      MCMC.effectiveSize.burnin.pval,
                      MCMC.effectiveSize.burnin.min,
                      MCMC.effectiveSize.burnin.max,
                      MCMC.effectiveSize.burnin.nmin,
                      MCMC.effectiveSize.burnin.nmax,
                      MCMC.effectiveSize.burnin.PC,
                      MCMC.effectiveSize.burnin.scl,
                      MCMC.effectiveSize.order.max, MCMC.maxedges,
                      MCMC.packagenames, MCMC.runtime.traceplot,
                      network.output, term.options, parallel,
                      parallel.type, parallel.version.check,
                      parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.prop, MCMC.prop.weights,
                         MCMC.prop.args, MCMC.batch,
                         MCMC.effectiveSize, MCMC.effectiveSize.damp,
                         MCMC.effectiveSize.maxruns,
                         MCMC.effectiveSize.burnin.pval,
                         MCMC.effectiveSize.burnin.min,
                         MCMC.effectiveSize.burnin.max,
                         MCMC.effectiveSize.burnin.nmin,
                         MCMC.effectiveSize.burnin.nmax,
                         MCMC.effectiveSize.burnin.PC,
                         MCMC.effectiveSize.burnin.scl,
                         MCMC.effectiveSize.order.max, MCMC.maxedges,
                         MCMC.packagenames, MCMC.runtime.traceplot,
                         network.output, term.options, parallel,
                         parallel.type, parallel.version.check,
                         parallel.inherit.MT, ...</code></p>
</dd><dt><code><a href="ergm.html#topic+control.simulate.formula.ergm">control.simulate.formula.ergm</a></code></dt><dd><p><code>MCMC.burnin, MCMC.interval, MCMC.prop, MCMC.prop.weights,
                              MCMC.prop.args, MCMC.batch,
                              MCMC.effectiveSize,
                              MCMC.effectiveSize.damp,
                              MCMC.effectiveSize.maxruns,
                              MCMC.effectiveSize.burnin.pval,
                              MCMC.effectiveSize.burnin.min,
                              MCMC.effectiveSize.burnin.max,
                              MCMC.effectiveSize.burnin.nmin,
                              MCMC.effectiveSize.burnin.nmax,
                              MCMC.effectiveSize.burnin.PC,
                              MCMC.effectiveSize.burnin.scl,
                              MCMC.effectiveSize.order.max,
                              MCMC.maxedges, MCMC.packagenames,
                              MCMC.runtime.traceplot, network.output,
                              term.options, parallel, parallel.type,
                              parallel.version.check,
                              parallel.inherit.MT, ...</code></p>
</dd></dl>



<h3>See Also</h3>

<p><code><a href="statnet.common.html#topic+snctrl">statnet.common::snctrl()</a></code>
</p>

<hr>
<h2 id='staticDiscordTNT-ergmProposal'>TNT proposal for CMLE fitting</h2><span id='topic+staticDiscordTNT-ergmProposal'></span><span id='topic+InitErgmProposal.staticDiscordTNT'></span>

<h3>Description</h3>

<p>A version of <code><a href="ergm.html#topic+TNT-ergmProposal">TNT</a></code> appropriate for CMLE fitting,
proposals stratified both by discordance status and edge status.  The argument
<code>ref</code> specifies the data relative to which discordance status is defined.
</p>


<h3>Details</h3>

<p>This proposal is not referenced in the lookup table.</p>




<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmProposal">ergmProposal</a></code> for index of proposals currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='stergm'>Separable Temporal Exponential Family Random Graph Models (Deprecated)</h2><span id='topic+stergm'></span>

<h3>Description</h3>

<p><code><a href="#topic+stergm">stergm</a></code> is used for finding Separable Temporal ERGMs'
(STERGMs) Conditional MLE (CMLE) (Krivitsky and Handcock, 2014) and
Equilibrium Generalized Method of Moments Estimator (EGMME)
(Krivitsky, 2009). This function is deprecated in favor of
<code><a href="#topic+tergm">tergm()</a></code>, whose special case it is, and may be removed in a future
version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stergm(
  nw,
  formation,
  dissolution,
  constraints = ~.,
  estimate,
  times = NULL,
  offset.coef.form = NULL,
  offset.coef.diss = NULL,
  targets = NULL,
  target.stats = NULL,
  eval.loglik = NVL(getOption("tergm.eval.loglik"), getOption("ergm.eval.loglik")),
  control = control.stergm(),
  verbose = FALSE,
  ...,
  SAN.offsets = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stergm_+3A_nw">nw</code></td>
<td>
<p>A <code><a href="network.html#topic+network">network</a></code> object (for EGMME); or
<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object, a
<code><a href="ergm.html#topic+network.list">network.list</a></code> object, or a <code><a href="base.html#topic+list">list</a></code> containing
networks (for CMLE and CMPLE).
</p>
<p><code>stergm</code> understands the <code><a href="#topic+lasttoggle">lasttoggle</a></code> &quot;API&quot;.</p>
</td></tr>
<tr><td><code id="stergm_+3A_formation">formation</code>, <code id="stergm_+3A_dissolution">dissolution</code></td>
<td>
<p>One-sided <code><a href="ergm.html#topic+ergm">ergm</a></code>-style formulas for
the formation and dissolution models, respectively.  In <code>stergm</code>,
the dissolution formula is parameterized in
terms of tie persistence: negative coefficients imply lower rates of persistence
and postive coefficients imply higher rates.  The dissolution effects are simply the
negation of these coefficients.</p>
</td></tr>
<tr><td><code id="stergm_+3A_constraints">constraints</code></td>
<td>
<p>A formula specifying one or more constraints
on the support of the distribution of the networks being modeled. Multiple constraints
may be given, separated by &ldquo;+&rdquo; and &ldquo;-&rdquo; operators. See
<code><a href="ergm.html#topic+ergmConstraint">ergmConstraint</a></code> for the detailed explanation of
their semantics and also for an indexed list of the constraints visible to the <span class="pkg">ergm</span> package.
</p>
<p>The default is to have no constraints except those provided through
the <code><a href="ergm.html#topic+ergmlhs">ergmlhs</a></code> API.
</p>
<p>Together with the model terms in the formula and the reference measure, the constraints
define the distribution of networks being modeled.
</p>
<p>It is also possible to specify a proposal function directly either
by passing a string with the function's name (in which case,
arguments to the proposal should be specified through the
<code>MCMC.prop.args</code> argument to the relevant control function, or
by giving it on the LHS of the hints formula to <code>MCMC.prop</code>
argument to the control function. This will override
the one chosen automatically.
</p>
<p>Note that not all possible combinations of constraints and reference
measures are supported. However, for relatively simple constraints
(i.e., those that simply permit or forbid specific dyads or sets of
dyads from changing), arbitrary combinations should be possible.</p>
</td></tr>
<tr><td><code id="stergm_+3A_estimate">estimate</code></td>
<td>
<p>One of &quot;EGMME&quot; for Equilibrium Generalized Method of Moments
Estimation, based on a single network with some temporal information and
making an assumption that it is a product of a STERGM process running to its
stationary (equilibrium) distribution; &quot;CMLE&quot; for Conditional Maximum
Likelihood Estimation, modeling a transition between two networks, or
&quot;CMPLE&quot; for Conditional Maximum PseudoLikelihood Estimation, using MPLE
instead of MLE.  CMPLE is extremely inaccurate at this time.</p>
</td></tr>
<tr><td><code id="stergm_+3A_times">times</code></td>
<td>
<p>For CMLE and CMPLE estimation, times or indexes at
which the networks whose transition is to be modeled are
observed. Default to <code>c(0,1)</code> if <code>nw</code> is a
<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> and to
<code>1:length(nw)</code> (all transitions) if <code>nw</code> is a
<code><a href="ergm.html#topic+network.list">network.list</a></code> or a <code><a href="base.html#topic+list">list</a></code>. Unused for
EGMME. Note that at this time, the selected time points will be
treated as temporally adjacent. Irregularly spaced time series
are not supported at this time.</p>
</td></tr>
<tr><td><code id="stergm_+3A_offset.coef.form">offset.coef.form</code></td>
<td>
<p>Numeric vector to specify offset formation
parameters.</p>
</td></tr>
<tr><td><code id="stergm_+3A_offset.coef.diss">offset.coef.diss</code></td>
<td>
<p>Numeric vector to specify offset dissolution
parameters.</p>
</td></tr>
<tr><td><code id="stergm_+3A_targets">targets</code></td>
<td>
<p>One-sided <code><a href="ergm.html#topic+ergm">ergm</a></code>-style formula specifying
statistics whose moments are used for the EGMME. Unused for CMLE and CMPLE.
Targets is required for EGMME estimation. It may contain any valid ergm
terms.  Any offset terms are used only during the
preliminary SAN run; they are removed automatically for the EGMME proper.
If <code>targets</code> is specified as a character
(one of <code>"formation"</code> and <code>"dissolution"</code>) then
the function <code><a href="#topic+.extract.fd.formulae">.extract.fd.formulae</a></code> is used to determine the
corresponding formula; the user should be aware of its behavior and limitations.</p>
</td></tr>
<tr><td><code id="stergm_+3A_target.stats">target.stats</code></td>
<td>
<p>A vector specifying the values of the <code>targets</code>
statistics that EGMME will try to match.  Defaults to the statistics of
<code>nw</code>. Unused for CMLE and CMPLE.</p>
</td></tr>
<tr><td><code id="stergm_+3A_eval.loglik">eval.loglik</code></td>
<td>
<p>Whether or not to calculate the log-likelihood
of a CMLE STERGM fit. See <code><a href="ergm.html#topic+ergm">ergm</a></code> for details. Can be
set globally via <code>option(tergm.eval.loglik=...)</code>, falling back to
<code>getOption("ergm.eval.loglik")</code> if not set.</p>
</td></tr>
<tr><td><code id="stergm_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning.
Constructed using <code><a href="#topic+control.stergm">control.stergm</a></code>.  Remapped to
<code><a href="#topic+control.tergm">control.tergm</a></code>.</p>
</td></tr>
<tr><td><code id="stergm_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="stergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="stergm_+3A_san.offsets">SAN.offsets</code></td>
<td>
<p>Offset coefficients (if any) to use during the SAN run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stergm</code> function uses a pair of formulas, <code>formation</code> and
<code>dissolution</code> to model tie-dynamics.  The dissolution formula, however, is
parameterized in terms of tie persistence: negative coefficients imply lower
rates of persistence and postive coefficients imply higher rates.
The dissolution effects are simply the negation of these coefficients, but
the discrepancy between the terminology and interpretation has always been
unfortunate, and we have fixed this in the new <code>tergm</code> function.
</p>
<p>If you are making the transition from old <code>stergm</code> to new <code>tergm</code>, note that
the <code>dissolution</code> formula in <code>stergm</code> maps to the new <code>Persist()</code>
operator in the <code>tergm</code> function, NOT the <code>Diss()</code> operator.
</p>


<h3>Value</h3>

<p><code><a href="#topic+stergm">stergm</a></code> returns an object of class <code><a href="#topic+tergm">tergm</a></code>;
see <code><a href="#topic+tergm">tergm()</a></code> for details and methods.
</p>


<h3>References</h3>

<p>Krivitsky P.N. and Handcock M.S. (2014) A Separable Model for Dynamic Networks. <em>Journal of the Royal Statistical Society, Series B</em>, 76(1): 29-46. <a href="https://doi.org/10.1111/rssb.12014">doi:10.1111/rssb.12014</a>
</p>
<p>Krivitsky, P.N. (2012). Modeling of Dynamic Networks based on
Egocentric Data with Durational Information. <em>Pennsylvania State
University Department of Statistics Technical Report</em>, 2012(2012-01).
<a href="https://web.archive.org/web/20170830053722/https://stat.psu.edu/research/technical-report-files/2012-technical-reports/TR1201A.pdf">https://web.archive.org/web/20170830053722/https://stat.psu.edu/research/technical-report-files/2012-technical-reports/TR1201A.pdf</a>
</p>


<h3>See Also</h3>

<p>ergm, network, \
</p>

<hr>
<h2 id='summary_formula.networkDynamic'>Calculation of networkDynamic statistics.</h2><span id='topic+summary_formula.networkDynamic'></span><span id='topic+summary.formula'></span>

<h3>Description</h3>

<p>A method for <code><a href="ergm.html#topic+summary_formula">summary_formula</a></code> to calculate the
specified statistics for an observed <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> at the
specified time point(s).  See <code><a href="ergm.html#topic+ergm-terms">ergm-terms</a></code> for more information
on the statistics that may be specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'networkDynamic'
summary_formula(object, at, ..., basis = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_formula.networkDynamic_+3A_object">object</code></td>
<td>
<p>An <code><a href="stats.html#topic+formula">formula</a></code> object with a
<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> as its LHS. (See
<code><a href="ergm.html#topic+summary_formula">summary_formula</a></code> for more details.)</p>
</td></tr>
<tr><td><code id="summary_formula.networkDynamic_+3A_at">at</code></td>
<td>
<p>A vector of time points at which to calculate the
statistics.</p>
</td></tr>
<tr><td><code id="summary_formula.networkDynamic_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or used by methods.</p>
</td></tr>
<tr><td><code id="summary_formula.networkDynamic_+3A_basis">basis</code></td>
<td>
<p>An optional <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object
relative to which the statistics should be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>length(at)</code> rows, one for each time
point in <code>at</code>, and columns for each term of the formula,
containing the corresponding statistics measured on the network.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergm">ergm()</a></code>, <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>, <code><a href="ergm.html#topic+ergm-terms">ergm-terms</a></code>,
<a href="#topic+summary.formula">summary.formula</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a toy dynamic network
my.nD &lt;- network.initialize(100,directed=FALSE)
activate.vertices(my.nD, onset=0, terminus = 10)
add.edges.active(my.nD,tail=1:2,head=2:3,onset=5,terminus=8)

# use a summary formula to display number of isolates and edges
# at discrete time points
summary(my.nD~isolates+edges, at=1:10)
</code></pre>

<hr>
<h2 id='tergm'>Temporal Exponential-Family Random Graph Models</h2><span id='topic+tergm'></span>

<h3>Description</h3>

<p><code><a href="#topic+tergm">tergm</a></code> is used for finding Temporal ERGMs' (TERGMs) and Separable Temporal ERGMs' (STERGMs)
Conditional MLE (CMLE) (Krivitsky and Handcock, 2010) and Equilibrium
Generalized Method of Moments Estimator (EGMME) (Krivitsky, 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tergm(
  formula,
  constraints = ~.,
  estimate,
  times = NULL,
  offset.coef = NULL,
  targets = NULL,
  target.stats = NULL,
  SAN.offsets = NULL,
  eval.loglik = NVL(getOption("tergm.eval.loglik"), getOption("ergm.eval.loglik")),
  control = control.tergm(),
  verbose = FALSE,
  ...,
  basis = eval_lhs.formula(formula)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tergm_+3A_formula">formula</code></td>
<td>
<p>an ERGM formula.</p>
</td></tr>
<tr><td><code id="tergm_+3A_constraints">constraints</code></td>
<td>
<p>A formula specifying one or more constraints
on the support of the distribution of the networks being modeled. Multiple constraints
may be given, separated by &ldquo;+&rdquo; and &ldquo;-&rdquo; operators. See
<code><a href="ergm.html#topic+ergmConstraint">ergmConstraint</a></code> for the detailed explanation of
their semantics and also for an indexed list of the constraints visible to the <span class="pkg">ergm</span> package.
</p>
<p>The default is to have no constraints except those provided through
the <code><a href="ergm.html#topic+ergmlhs">ergmlhs</a></code> API.
</p>
<p>Together with the model terms in the formula and the reference measure, the constraints
define the distribution of networks being modeled.
</p>
<p>It is also possible to specify a proposal function directly either
by passing a string with the function's name (in which case,
arguments to the proposal should be specified through the
<code>MCMC.prop.args</code> argument to the relevant control function, or
by giving it on the LHS of the hints formula to <code>MCMC.prop</code>
argument to the control function. This will override
the one chosen automatically.
</p>
<p>Note that not all possible combinations of constraints and reference
measures are supported. However, for relatively simple constraints
(i.e., those that simply permit or forbid specific dyads or sets of
dyads from changing), arbitrary combinations should be possible.</p>
</td></tr>
<tr><td><code id="tergm_+3A_estimate">estimate</code></td>
<td>
<p>One of &quot;EGMME&quot; for Equilibrium Generalized Method of Moments
Estimation, based on a single network with some temporal information and
making an assumption that it is a product of a TERGM process running to its
stationary (equilibrium) distribution; &quot;CMLE&quot; for Conditional Maximum
Likelihood Estimation, modeling a transition between two networks, or
&quot;CMPLE&quot; for Conditional Maximum PseudoLikelihood Estimation, using MPLE
instead of MLE.  CMPLE is extremely inaccurate at this time.</p>
</td></tr>
<tr><td><code id="tergm_+3A_times">times</code></td>
<td>
<p>For CMLE and CMPLE estimation, times or indexes at
which the networks whose transition is to be modeled are
observed. Default to <code>c(0,1)</code> if <code>nw</code> is a
<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> and to
<code>1:length(nw)</code> (all transitions) if <code>nw</code> is a
<code><a href="ergm.html#topic+network.list">network.list</a></code> or a <code><a href="base.html#topic+list">list</a></code>. Unused for
EGMME. Note that at this time, the selected time points will be
treated as temporally adjacent. Irregluarly spaced time series
are not supported at this time.</p>
</td></tr>
<tr><td><code id="tergm_+3A_offset.coef">offset.coef</code></td>
<td>
<p>Numeric vector to specify offset parameters.</p>
</td></tr>
<tr><td><code id="tergm_+3A_targets">targets</code></td>
<td>
<p>One-sided <code><a href="ergm.html#topic+ergm">ergm</a></code>-style formula specifying
statistics whose moments are used for the EGMME. Unused for CMLE and CMPLE.
Targets is required for EGMME estimation. It may contain any valid ergm
terms.  Any offset terms are used only during the
preliminary SAN run; they are removed automatically for the EGMME proper.
If <code>targets</code> is specified as a character
(one of <code>"formation"</code> and <code>"dissolution"</code>) then
the function <code><a href="#topic+.extract.fd.formulae">.extract.fd.formulae</a></code> is used to determine the
corresponding formula; the user should be aware of its behavior and limitations.</p>
</td></tr>
<tr><td><code id="tergm_+3A_target.stats">target.stats</code></td>
<td>
<p>A vector specifying the values of the <code>targets</code>
statistics that EGMME will try to match.  Defaults to the statistics of
<code>nw</code>. Unused for CMLE and CMPLE.</p>
</td></tr>
<tr><td><code id="tergm_+3A_san.offsets">SAN.offsets</code></td>
<td>
<p>Offset coefficients (if any) to use during the SAN run.</p>
</td></tr>
<tr><td><code id="tergm_+3A_eval.loglik">eval.loglik</code></td>
<td>
<p>Whether or not to calculate the log-likelihood
of a CMLE TERGM fit. See <code><a href="ergm.html#topic+ergm">ergm</a></code> for details. Can be
set globally via <code>option(tergm.eval.loglik=...)</code>, falling back to
<code>getOption("ergm.eval.loglik")</code> if not set.</p>
</td></tr>
<tr><td><code id="tergm_+3A_control">control</code></td>
<td>
<p>A list of control parameters for algorithm tuning.
Constructed using <code><a href="#topic+control.tergm">control.tergm</a></code>.</p>
</td></tr>
<tr><td><code id="tergm_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="tergm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions.</p>
</td></tr>
<tr><td><code id="tergm_+3A_basis">basis</code></td>
<td>
<p>optional network data overriding the left hand side of <code>formula</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+tergm">tergm</a></code> returns an object of class <code>tergm</code> that
inherits from <code>ergm</code> and has the usual methods (<code><a href="ergm.html#topic+coef.ergm">coef.ergm()</a></code>,
<code><a href="ergm.html#topic+summary.ergm">summary.ergm()</a></code>, <code><a href="ergm.html#topic+mcmc.diagnostics">mcmc.diagnostics()</a></code>, etc.) implemented for
it. Note that <code><a href="ergm.html#topic+gof">gof()</a></code> only works for the CMLE method.
</p>


<h3>References</h3>

<p>Krackhardt, D and Handcock, MS (2006) Heider vs Simmel: Emergent
features in dynamic structures.  ICML Workshop on Statistical
Network Analysis. Springer, Berlin, Heidelberg, 2006.
</p>
<p>Hanneke S, Fu W, and Xing EP (2010). Discrete
Temporal Models of Social Networks. <em>Electronic Journal of Statistics</em>,
2010, 4, 585-605.
<a href="https://doi.org/10.1214/09-EJS548">doi:10.1214/09-EJS548</a>
</p>
<p>Krivitsky P.N. and Handcock M.S. (2014) A Separable Model for Dynamic Networks. <em>Journal of the Royal Statistical Society, Series B</em>, 76(1): 29-46. <a href="https://doi.org/10.1111/rssb.12014">doi:10.1111/rssb.12014</a>
</p>
<p>Krivitsky, P.N. (2012). Modeling of Dynamic Networks based on
Egocentric Data with Durational Information. <em>Pennsylvania State
University Department of Statistics Technical Report</em>, 2012(2012-01).
<a href="http://stat.psu.edu/research/technical-report-files/2012-technical-reports/modeling-of-dynamic-networks-based-on-egocentric-data-with-durational-information">http://stat.psu.edu/research/technical-report-files/2012-technical-reports/modeling-of-dynamic-networks-based-on-egocentric-data-with-durational-information</a>
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+network">network</a></code> and <code><a href="#topic+NetSeries">NetSeries()</a></code> for the data structures,
<code><a href="ergm.html#topic+ergm">ergm()</a></code> and <code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for model specification,
package vignette <code>browseVignettes(package='tergm')</code> for a
short demonstration, the Statnet web site
<a href="https://statnet.org/workshop-tergm/">https://statnet.org/workshop-tergm/</a> for a tutorial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# EGMME Example
par(ask=FALSE)
n&lt;-30
g0&lt;-network.initialize(n,dir=FALSE)

#                     edges, degree(1), mean.age
target.stats&lt;-c(      n*1/2,    n*0.6,        20)

dynfit&lt;-tergm(g0 ~ Form(~edges + degree(1)) + Diss(~edges),
               targets = ~edges+degree(1)+mean.age,
               target.stats=target.stats, estimate="EGMME",
               control=control.tergm(SA.plot.progress=TRUE))

par(ask=TRUE)
mcmc.diagnostics(dynfit)
summary(dynfit)

## End(Not run)

# CMLE Example
data(samplk)

# Fit a transition from Time 1 to Time 2
samplk12 &lt;- tergm(list(samplk1, samplk2)~
                  Form(~edges+mutual+transitiveties+cyclicalties)+
                  Diss(~edges+mutual+transitiveties+cyclicalties),
                  estimate="CMLE")

mcmc.diagnostics(samplk12)
summary(samplk12)

samplk12.gof &lt;- gof(samplk12)

samplk12.gof

plot(samplk12.gof)

plot(samplk12.gof, plotlogodds=TRUE)

# Fit a transition from Time 1 to Time 2 and from Time 2 to Time 3 jointly
samplk123 &lt;- tergm(list(samplk1, samplk2, samplk3)~
                   Form(~edges+mutual+transitiveties+cyclicalties)+
                   Diss(~edges+mutual+transitiveties+cyclicalties),
                   estimate="CMLE")

mcmc.diagnostics(samplk123)
summary(samplk123)


</code></pre>

<hr>
<h2 id='tergm_MCMC_sample'>Collects a sample of networks and returns the statistics of each sample</h2><span id='topic+tergm_MCMC_sample'></span><span id='topic+tergm_MCMC_slave'></span>

<h3>Description</h3>

<p><code>tergm_MCMC_sample</code> is a low-level internal function not intended to
be called directly by end users. It collects a sample of networks and
returns the statistics of each sample, along with a toggle matrix of the
changes needed from the original network to each in the sample.
</p>
<p><code>tergm_MCMC_slave</code> is an even
lower-level function that actually calls the C code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tergm_MCMC_sample(
  nw,
  model,
  model.mon = NULL,
  proposal,
  control,
  theta,
  verbose = FALSE,
  ...,
  eta = ergm.eta(theta, model$etamap)
)

tergm_MCMC_slave(state, eta, control, verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tergm_MCMC_sample_+3A_nw">nw</code></td>
<td>
<p>a <code><a href="network.html#topic+network">network</a></code> object</p>
</td></tr>
<tr><td><code id="tergm_MCMC_sample_+3A_model">model</code></td>
<td>
<p>the model, as returned by <code><a href="ergm.html#topic+ergm_model">ergm_model</a></code></p>
</td></tr>
<tr><td><code id="tergm_MCMC_sample_+3A_model.mon">model.mon</code></td>
<td>
<p>the optional monitoring model, as returned by <code><a href="ergm.html#topic+ergm_model">ergm_model</a></code></p>
</td></tr>
<tr><td><code id="tergm_MCMC_sample_+3A_proposal">proposal</code></td>
<td>
<p>the proposal, as returned by <code><a href="ergm.html#topic+ergm_proposal">ergm_proposal</a></code></p>
</td></tr>
<tr><td><code id="tergm_MCMC_sample_+3A_control">control</code></td>
<td>
<p>the list of control parameters</p>
</td></tr>
<tr><td><code id="tergm_MCMC_sample_+3A_theta">theta</code></td>
<td>
<p>the vector of curved parameters</p>
</td></tr>
<tr><td><code id="tergm_MCMC_sample_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="tergm_MCMC_sample_+3A_eta">eta</code></td>
<td>
<p>the vector of natural parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is normally called inside <code><a href="#topic+simulate.tergm">simulate.tergm</a></code> functions
to prepare inputs for the C sampling code and return its results
</p>


<h3>Value</h3>

<p>returns the MCMC sample as a list containing:
</p>

<ul>
<li><p> statsmatrix.gen: the matrix of sampled statistics for <code>model</code>,
relative to the initial network
</p>
</li>
<li><p> statsmatrix.mon: the matrix of sampled statistics for <code>model.mon</code>,
relative to the initial network
</p>
</li>
<li><p> newnetwork: <code>ergm_state</code> with the final network from the
sampling process
</p>
</li>
<li><p> changed: a matrix of changes, where the first column is
the timestamp of the change, the second and third columns are the tail and head
(respectively) of the changed dyad, and the fourth column is the edge state to which
the dyad was changed; this is only returned if <code>control$changes</code> is <code>TRUE</code>
</p>
</li>
<li><p> maxchanges: the <code>maxchanges</code> value from the control list
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+simulate.tergm">simulate.tergm</a></code>
</p>

<hr>
<h2 id='tergm-deprecated'>Functions that will no longer be supported in future releases of the package</h2><span id='topic+tergm-deprecated'></span>

<h3>Description</h3>

<p>Functions that have been superceed, were never documented, or will be removed from the package for other reasons
</p>

<hr>
<h2 id='tergm.godfather'>A function to apply a given series of changes to a network.</h2><span id='topic+tergm.godfather'></span>

<h3>Description</h3>

<p>Gives the network a series of timed proposals it can't refuse. Returns the
statistics of the network, and, optionally, the final network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tergm.godfather(
  formula,
  changes = NULL,
  toggles = changes[, -4, drop = FALSE],
  start = NULL,
  end = NULL,
  end.network = FALSE,
  stats.start = FALSE,
  verbose = FALSE,
  control = control.tergm.godfather()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tergm.godfather_+3A_formula">formula</code></td>
<td>
<p>An <code><a href="#topic+summary.formula">summary.formula</a></code>-style formula, with
either a <code><a href="network.html#topic+network">network</a></code> or a <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>
as the LHS and statistics to be computed on the RHS. If LHS is a
<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>, it will be used to derive the
changes to the network whose statistics are wanted. Otherwise,
either <code>changes</code> or <code>toggles</code> must be specified, and
the LHS <code><a href="network.html#topic+network">network</a></code> will be used as the starting
network.</p>
</td></tr>
<tr><td><code id="tergm.godfather_+3A_changes">changes</code></td>
<td>
<p>A matrix with four columns: time, tail, head, and
new value, describing the changes to be made. Can only be used if
LHS of <code>formula</code> is not a <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>.</p>
</td></tr>
<tr><td><code id="tergm.godfather_+3A_toggles">toggles</code></td>
<td>
<p>A matrix with three columns: time, tail, and head,
giving the dyads which had changed. Can only be used if LHS of
<code>formula</code> is not a <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>.</p>
</td></tr>
<tr><td><code id="tergm.godfather_+3A_start">start</code></td>
<td>
<p>Time from which to start applying changes.  Note that
the first set of changes will take effect at <code>start + 1</code>.
Defaults to the time point 1 before the earliest change passed.</p>
</td></tr>
<tr><td><code id="tergm.godfather_+3A_end">end</code></td>
<td>
<p>Time at which to finish applying changes.  Defaults to
the last time point at which a change occurs.</p>
</td></tr>
<tr><td><code id="tergm.godfather_+3A_end.network">end.network</code></td>
<td>
<p>Whether to return the network that
results. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tergm.godfather_+3A_stats.start">stats.start</code></td>
<td>
<p>Whether to return the network statistics at
<code>start</code> (before any changes are applied) as the first row of
the statistics matrix.  Defaults to <code>FALSE</code>, to produce
output similar to that of <code><a href="#topic+simulate.tergm">simulate</a></code>
for TERGMs when <code>output="stats"</code>, where initial network's
statistics are not returned.</p>
</td></tr>
<tr><td><code id="tergm.godfather_+3A_verbose">verbose</code></td>
<td>
<p>A logical or an integer to control the amount of
progress and diagnostic information to be printed. <code>FALSE</code>/<code>0</code>
produces minimal output, with higher values producing more
detail. Note that very high values (5+) may significantly slow
down processing.</p>
</td></tr>
<tr><td><code id="tergm.godfather_+3A_control">control</code></td>
<td>
<p>A control list generated by
<code><a href="#topic+control.tergm.godfather">control.tergm.godfather</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>end.network</code> is <code>FALSE</code> (the default), an
<code><a href="coda.html#topic+mcmc">mcmc</a></code> object with the requested network statistics
associated with the network series produced by applying the
specified changes. Its <code><a href="coda.html#topic+mcmc">mcmc</a></code> attributes encode the
timing information: so <code><a href="stats.html#topic+start">start</a>(out)</code> gives the time
point associated with the first row returned, and
<code><a href="stats.html#topic+end">end</a>(out)</code> out the last. The &quot;thinning interval&quot; is
always 1.
</p>
<p>If <code>end.network</code> is <code>TRUE</code>, return a <code><a href="network.html#topic+network">network</a></code> object with
<code><a href="#topic+lasttoggle">lasttoggle</a></code> &quot;extension&quot;, representing the final network, with a
matrix of statistics described in the previous paragraph attached to it as
an <code>attr</code>-style attribute <code>"stats"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.tergm">simulate.tergm()</a></code>, <code><a href="#topic+simulate_formula.network">simulate_formula.network()</a></code>, <code><a href="#topic+simulate_formula.networkDynamic">simulate_formula.networkDynamic()</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
