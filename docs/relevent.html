<!DOCTYPE html><html><head><title>Help for package relevent</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {relevent}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.sociomatrix.eventlist'>
<p>Convert an Event List Into a Sociomatrix</p></a></li>
<li><a href='#relevent-internal'><p>Internal Relevent Package Functions</p></a></li>
<li><a href='#rem'>
<p>Fit a Relational Event Model to Single or Multiple Sequence Data</p></a></li>
<li><a href='#rem.dyad'><p> Fit a Relational Event Model to Dyadic Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-24</td>
</tr>
<tr>
<td>Title:</td>
<td>Relational Event Models</td>
</tr>
<tr>
<td>Author:</td>
<td>Carter T. Butts &lt;buttsc@uci.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carter T. Butts &lt;buttsc@uci.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>trust, sna (&ge; 2.0), coda</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to fit and simulate realizations from relational event models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-24 06:31:16 UTC; buttsc</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-24 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.sociomatrix.eventlist'>
Convert an Event List Into a Sociomatrix
</h2><span id='topic+as.sociomatrix.eventlist'></span>

<h3>Description</h3>

<p>Convert a dyadic event list into an adjacency matrix, such that the <code class="reqn">i,j</code> cell value is the number of <code class="reqn">(i,j)</code> events in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sociomatrix.eventlist(eventlist, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sociomatrix.eventlist_+3A_eventlist">eventlist</code></td>
<td>

<p>a three-column numeric matrix (or equivalent), containing the event list to be converted.
</p>
</td></tr>
<tr><td><code id="as.sociomatrix.eventlist_+3A_n">n</code></td>
<td>

<p>the number of vertices.  If omitted, this is assumed to be contained in an attribute called <code>"n"</code> attached to <code>eventlist</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An event list must be a three-column matrix (or something that can be treated as one), whose second and third columns must contain vertex IDs; these can be given as characters, but must be coercable with <code>as.numeric</code> to numeric form.  Vertex IDs must be integers from <code>1:n</code>, where <code>n</code> is either supplied as an argument, or attached as an attribute of the <code>eventlist</code> object.  The first column of an eventlist matrix conventionally contains the event time, and is ignored; the second and third should contain the IDs of the senders and receivers of events (respectively).  Rows with missing values for one or both vertex IDs are removed during processing (but <code>NA</code>s in the first column have no effect, since the event timing information is not used).
</p>
<p>The resulting output is an <code>n</code> by <code>n</code> adjacency matrix, whose <code>i,j</code> cell is the total number of events in <code>eventlist</code> from vertex <code>i</code> to vertex <code>j</code>.  This can be useful for visualizing or otherwise analyzing the time-marginalized structure of a dyadic interaction network.
</p>


<h3>Value</h3>

<p>A sociomatrix containing the time-aggregated event counts.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rem.dyad">rem.dyad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create a simple event list
el &lt;- cbind(1:6, c(4,4,4,1,3,4), c(1,2,3,3,1,1))

#Convert to matrix form
as.sociomatrix.eventlist(el, 4)

#Can also store n as an attribute
attr(el, "n") &lt;- 4
as.sociomatrix.eventlist(el)

</code></pre>

<hr>
<h2 id='relevent-internal'>Internal Relevent Package Functions</h2><span id='topic+accum.interact'></span><span id='topic+acl.adjmat'></span><span id='topic+acl.adj'></span><span id='topic+acl.deg'></span><span id='topic+accum.ps'></span><span id='topic+acl.ps'></span><span id='topic+acl.tri'></span><span id='topic+accum.rrl'></span><span id='topic+covarPrep'></span>

<h3>Description</h3>

<p>Internal relevent package functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accum.interact(elist, old.acl=NULL)
acl.adj(acl, iter, src, dest)
acl.adjmat(acl, n, iter)
acl.deg(acl, n, cmode=c("in", "out", "total"), old.deg=NULL)
accum.ps(elist)
acl.ps(elist, n, old.ps=NULL)
acl.tri(acl, old.tri=NULL)
accum.rrl(elist, old.rrl=NULL)
covarPrep(covar, n, m, effects=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relevent-internal_+3A_elist">elist</code></td>
<td>
<p>a three-column (time, source, destination) dyadic event list, sorted in ascending temporal order.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_acl">acl</code></td>
<td>
<p>a nested list structure, of the form iteration by ego by alter, containing accumulated dyadic event counts at each event onset.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_iter">iter</code></td>
<td>
<p>iteration (i.e., event) number.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_src">src</code></td>
<td>
<p>integer denoting the sender of a dyadic event.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_dest">dest</code></td>
<td>
<p>integer denoting the receiver of a dyadic event.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_n">n</code></td>
<td>
<p>the number of actors eligible to send/receive events.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_cmode">cmode</code></td>
<td>
<p>the type of degree to be calculated.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_old.acl">old.acl</code></td>
<td>
<p>previously computed acl structure to which new events should be added.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_old.deg">old.deg</code></td>
<td>
<p>previously computed cumulative degree structure to which events should be added.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_old.ps">old.ps</code></td>
<td>
<p>previously computed P-shift structure to which events should be added.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_old.tri">old.tri</code></td>
<td>
<p>previously computed triad structure to which events should be added.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_old.rrl">old.rrl</code></td>
<td>
<p>previously computed recency structure to which events should be added.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_covar">covar</code></td>
<td>
<p>a covariate list, of the form passed normally to <code><a href="#topic+rem.dyad">rem.dyad</a></code>.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_m">m</code></td>
<td>
<p>the intended number of events for which data should be checked.</p>
</td></tr>
<tr><td><code id="relevent-internal_+3A_effects">effects</code></td>
<td>
<p>a logical effect inclusion vector of the type used internally by <code><a href="#topic+rem.dyad">rem.dyad</a></code>.</p>
</td></tr>

</table>


<h3>Details</h3>

<p>Most of these are not to be called by the user; they can be employed by the cogniscenti, but they may change without notice (so use at own risk).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rem">rem</a></code></p>

<hr>
<h2 id='rem'>
Fit a Relational Event Model to Single or Multiple Sequence Data
</h2><span id='topic+rem'></span><span id='topic+rem.ord.dev'></span><span id='topic+rem.int.dev'></span><span id='topic+rem.ord.nlp'></span><span id='topic+rem.int.nlp'></span><span id='topic+print.rem'></span><span id='topic+summary.rem'></span><span id='topic+print.summary.rem'></span>

<h3>Description</h3>

<p>Fits a relational event model to general event sequence data, using either the ordinal or interval time likelihoods.  Maximum likelihood and posterior mode methods are supported, as are local (per sequence) parameters and sequences with exogenous events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rem(eventlist, statslist, supplist = NULL, timing = c("ordinal", 
    "interval"), estimator = c("BPM", "MLE", "BMCMC", "BSIR"), 
    prior.param = list(mu = 0, sigma = 1000, nu = 4), mcmc.draws = 1500, 
    mcmc.thin = 25, mcmc.burn = 2000, mcmc.chains = 3, mcmc.sd = 0.05, 
    mcmc.ind.int = 50, mcmc.ind.sd = 10, sir.draws = 1000, 
    sir.expand = 10, sir.nu = 4, verbose = FALSE)
## S3 method for class 'rem'
print(x, ...)
## S3 method for class 'rem'
summary(object, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rem_+3A_eventlist">eventlist</code></td>
<td>

<p>a two-column matrix (or list thereof) containing the observed event sequence and timing information.
</p>
</td></tr>
<tr><td><code id="rem_+3A_statslist">statslist</code></td>
<td>

<p>an event number by event type by statistic array (or list thereof) containing the sufficient statistics for the model to be estimated.
</p>
</td></tr>
<tr><td><code id="rem_+3A_supplist">supplist</code></td>
<td>

<p>an event number by event type logical array (or list thereof) indicating which events were potentially observable at each point in the event history.
</p>
</td></tr>
<tr><td><code id="rem_+3A_timing">timing</code></td>
<td>

<p>the type of timing information to be used during estimation; <code>"ordinal"</code> indicates that only event order should be employed, while <code>"interval"</code> uses the exact inter-event times.
</p>
</td></tr>
<tr><td><code id="rem_+3A_estimator">estimator</code></td>
<td>

<p>the type of estimator to be used; <code>"MLE"</code> selects maximum likelihood estimation, <code>"BPM"</code> selects Bayesian posterior mode estimation, <code>"BMCMC"</code> selects Bayesian posterior mean estimation via MCMC, and <code>"BSIR"</code> selects Bayesian posterior mean estimation via simulated importance resampling. 
</p>
</td></tr>
<tr><td><code id="rem_+3A_prior.param">prior.param</code></td>
<td>

<p>for the Bayesian methods, the prior parameters to be employed; currently, these are the location, scale, and degrees of freedom parameters for independent t priors, and may be given as vectors (to set different priors for each parameter).  (By default, a diffuse, heavy-tailed t distribution is used.)
</p>
</td></tr>
<tr><td><code id="rem_+3A_mcmc.draws">mcmc.draws</code></td>
<td>

<p>total number of posterior draws to take when using the BMCMC method.
</p>
</td></tr>
<tr><td><code id="rem_+3A_mcmc.thin">mcmc.thin</code></td>
<td>

<p>thinning interval for MCMC draws (BMCMC method).
</p>
</td></tr>
<tr><td><code id="rem_+3A_mcmc.burn">mcmc.burn</code></td>
<td>

<p>number of burn-in iterations to use for each MCMC chain (BMCMC method).
</p>
</td></tr>
<tr><td><code id="rem_+3A_mcmc.chains">mcmc.chains</code></td>
<td>

<p>number of MCMC chains to use (BMCMC method).
</p>
</td></tr>
<tr><td><code id="rem_+3A_mcmc.sd">mcmc.sd</code></td>
<td>

<p>standard deviation for the random walk Metropolis sampler (BMCMC method).
</p>
</td></tr>
<tr><td><code id="rem_+3A_mcmc.ind.int">mcmc.ind.int</code></td>
<td>

<p>interval at which to take draws from the independence sampler (versus the random walk Metropolis sampler).  (BMCMC method).
</p>
</td></tr>
<tr><td><code id="rem_+3A_mcmc.ind.sd">mcmc.ind.sd</code></td>
<td>

<p>standard deviation for the MCMC independence sampler (BMCMC method).
</p>
</td></tr>
<tr><td><code id="rem_+3A_sir.draws">sir.draws</code></td>
<td>

<p>number of SIR draws to take (BSIR method).
</p>
</td></tr>
<tr><td><code id="rem_+3A_sir.expand">sir.expand</code></td>
<td>

<p>expansion factor for the SIR sample; intitial sample size is <code>sir.draws</code> multiplied by <code>sir.expand</code>.
</p>
</td></tr>
<tr><td><code id="rem_+3A_sir.nu">sir.nu</code></td>
<td>

<p>degrees of freedom parameter for the SIR sampling distribution.
</p>
</td></tr>
<tr><td><code id="rem_+3A_verbose">verbose</code></td>
<td>

<p>logical; should verbose progress information be displayed?
</p>
</td></tr>
<tr><td><code id="rem_+3A_x">x</code></td>
<td>
<p> an object of class <code>rem</code>.</p>
</td></tr>
<tr><td><code id="rem_+3A_object">object</code></td>
<td>
<p> an object of class <code>rem</code>.</p>
</td></tr>
<tr><td><code id="rem_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rem</code> fits a general relational event model to one or more event sequences (or &ldquo;histories&rdquo;), using either full interval or ordinal timing information.  Although particularly applicable to &ldquo;egocentric&rdquo; relational event data, <code>rem</code> can be used to fit nearly any standard relational event model; the function depends heavily on user-supplied statistics, however, and thus lacks the built-in functionality of a routine like <code><a href="#topic+rem.dyad">rem.dyad</a></code>.  Four estimation methods are currently supported: maximum likelihood estimation, Bayesian posterior mode estimation, Bayesian posterior mean estimation via MCMC, and Bayesian posterior mean estimation via sampling importance resampling (SIR).  For the Bayesian methods, adjustable independent t priors are employed.  For both mode-based methods, estimates of uncertainty (standard errors or posterior standard deviations) are approximated using the appropriate inverse hessian matrix; for the two simulation-based methods, posterior standard deviations are estimated from the resulting sample.  
</p>
<p>Irrespective of whether Bayesian or frequentist methods are used, the relevant likelihood is either based entirely on the order of events (<code>timing="ordinal"</code>) or on the realized event times (<code>timing="interval"</code>).  In the latter case, all event times are understood to be relative to the onset of observation (i.e., observation starts at time 0), and the last event time given is taken to be the end of the observation period.  (This should generally be marked as exogenous &ndash; see below.)
</p>
<p>Event source/target/content are handled generically by <code>rem</code> via <em>event types</em>.  Each event must be of a given type, and any number of types may be employed (up to limits of time and memory).  Effects within the relational event model are associated with user-supplied statistics, of which any number may again be supplied (model identification notwithstanding).  At each point in the event history, it is possible that only particular types of events may be realized; this constraint can be specified by means of an optional user-supplied support structure.  Finally, it is also possible that an event sequence may be punctuated by <em>exogenous events,</em> which are unmodeled but which may affect the endogenous event dynamics.  These are supported by means of a tacit &ldquo;exogenous&rdquo; event type, which is handled by the estimation routine as appropriate for the specified likelihood.
</p>
<p>Observed event data is supplied to <code>rem</code> via the <code>eventlist</code> argument.  For each event history, the observed events are indicated by a two-column matrix, whose <code class="reqn">i</code>th row contains respectively the event type (as an integer ranging from 1 to the number of event types, inclusive) and the event time for the <code class="reqn">i</code>th event in the history.  (The second column may be omitted in the ordinal case, and will in any event be ignored.)  Events must be given in ascending temporal order; if multiple histories are being modeled simultaneously (e.g., as with egocentric relational event samples), then <code>eventlist</code> should be a list with one matrix per event history.  Exogenous events, if present, are indicated by specifying an event type of 0.  (Note that the &ldquo;type&rdquo; of an exogenous event is irrelevant, since any such properties of exogenous events are handled via the model statistics.)  If exact timing information is used, the hazard for the first event implicitly begins at time 0, and observation implicitly ends with the time of the last event (which should properly be coded as exogenous, unless the sampling design was based on observation of an endogenous terminal event).  Where applicable, censoring due to the sampling interval is accounted for in the data likelihood (assuming that the user has set the model statistics appropriately).
</p>
<p>Statistics for the relational event model are specified in a manner somewhat analogous to that of <code>eventlist</code>.  Like the latter, <code>statslist</code> is generally a list with one element per event history, or a single element where only a single history is to be examined.  Each element of <code>statslist</code> should be a list containing either one or two three-dimensional arrays, with the first dimension indexing event order (from first event to last, including exogenous events where applicable), the second indexing event type (in order corresponding to the integer values of <code>eventlist</code>), and the third indexing the model statistics.  The <code class="reqn">ijk</code>th cell of a <code>statslist</code> array is thus the value of the <code class="reqn">k</code>th statistic prospectively impacting the hazard of observing an event of type <code class="reqn">j</code> as the <code class="reqn">i</code>th event in the history (given the previous <code class="reqn">i-1</code> realized events).  Models estimated by <em>rem</em> are regular in the sense that one parameter is estimated per statistic; intuitively, a large value of a <code class="reqn">ijk</code>th <code>statslist</code> cell associatd with a large (positive) parameter represents an increased hazard of observing a type <code class="reqn">j</code> event at the <code class="reqn">i</code>th point in the respective history, while the same statistic associated with a highly negative parameter represents a correspondingly diminished hazard of observing said event.  (The total hazard of a given event type is equal to <code class="reqn">\exp(\theta^T s_{ij})</code>, where <code class="reqn">\theta</code> is the vector of model parameters and <code class="reqn">s_{ij}</code> is the corresponding vector of sufficient statistics for a type <code class="reqn">j</code> event given the <code class="reqn">i-1</code> previously realized events; see the reference below for details.)  It is up to the user to supply these statistics, and moreover to ensure that they are well-behaved (e.g., not linearly dependent).  An array within a <code>statslist</code> element may be designated as <em>global</em> or <em>local</em> by assigning it to the appropriately named list element.  Statistics belonging to a global array are assumed to correspond to parameters that are homogeneous across event histories, and are estimated in a pooled fashion; if global arrays are supplied, they must be given for every element of <code>statslist</code> (and must carry the same statistics and event types, although these statistics will not typically take the same values).  Statistics belonging to a local array, on the other hand, are taken as idiosyncratic to the event history in question, and their corresponding parameters are estimated locally.  Both local and global statistics may be employed simultaneously if desired, but at least one must be specified in any case.  <code>rem</code> will return an error if passed a <code>statslist</code> with obvious inconsistencies.
</p>
<p>If desired, support constraints for the event histories can be specified using <code>supplist</code>.  <code>supplist</code> should be a list with one element per history, each of which should be an event order by event type logical matrix.  The <code class="reqn">ij</code>th cell of this matrix should be <code>TRUE</code> if an event of type <code>j</code> was a possible next event given the preceding code <code class="reqn">i-1</code> events, and <code>FALSE</code> otherwise.  (By default, all events are assumed to be possible at all times.)  As with the model statistics, the elements of the support list must be user supplied, and will often be history-dependent.  (E.g., in a model for spell-based data, event types will come in onset/termination pairs, with terminal events necessarily being preceded by corresponding onset events.)
</p>
<p>Given the above structure, <code>rem</code> will attempt to find a maximum likelihood or posterior estimate for the model parameters, as appropriate given <code>estimator</code>.  In the latter case, the prior parameters for each parameter may be set using <code>prior.param</code>.  Each parameter is taken to be <em>a priori</em> t distributed, with the indicated location, scale, and degree of freedom parameters; by default, a fairly diffuse and heavy-tailed prior is used.  By specifying the elements of <code>prior.param</code> as vectors, it is possible to employ different priors for each model parameter.  In this case, the vector elements are used in the order of the statistics (first global, then each local in order by event history).  Standard errors or posterior standard deviation estimates are returned as appropriate, along with various goodness-of-fit indices.  (Bear in mind that the &ldquo;p-values&rdquo; shown in the summary method for the posterior mode case are based on posterior quantiles (under an assumption of asymptotic normality), and should be interpreted in this fashion.)
</p>
<p>For the MCMC sampling method, a combined independence and random walk Metropolis scheme is employed.  Proposals are multivariate Gaussian, with standard deviations as set via the appropriate arguments.  (These may be given as vectors, with one entry per parameter, if desired.)  Gewke and Gelman-Rubin MCMC diagnostics (produced by the <code>coda</code> package) are computed, and are stored as elements <code>geweke</code> and <code>gelman.rubin</code> within the model fit object.  The posterior draws themselves are stored as an element called <code>draws</code> within the model fit object, with corresponding log-posterior values <code>lp</code>.
</p>
<p>The SIR method initially seeks the posterior mode (identically to the BPM method), and obtains approximate scale information using the Hessian of the log-posterior surface.  This is used to generate a set of approximate posterior draws via a multivariate t distribution centered on the posterior mode, with degrees of freedom given by <code>sir.nu</code>.  This crude sample is then refined by importance resampling, the final result of which is stored as element <code>draws</code> (with log-posterior vector <code>lp</code>) in the model fit object.  As with the BMCMC procedure, posterior mean and standard deviations are estimated from the final sample, although the mode information is retained in elements <code>coef.mode</code> and <code>cov.hess</code>.
</p>
<p>As a general matter, the MLE and BPM methods are most dependent upon asymptotic assumptions, but are also (usually) the least computationally complex.  BMCMC requires no such assumptions, but can be extremely slow (and, like all MCMC methods, depends upon the quality of the MCMC sample).  The BSIR method is something of a compromise between BPM and BMCMC, starting with a mode approximation but refining it in the direction of the true posterior surface; as one might expect, its cost is also intermediate between these extremes.  For well-behaved models on large data sets, all methods are likely to produce nearly identical results.  The simulation-based methods (particularly BMCMC) may be safer in less salutary circumstances.  (Tests conducted by the author have so far obtained the best overall results from the BPM, particularly vis a vis estimates of uncertainty &ndash; this advice may or may not generalize, however.)
</p>


<h3>Value</h3>

<p>An object of class <code>rem</code>, for which <code><a href="base.html#topic+print">print</a></code> and <code><a href="base.html#topic+summary">summary</a></code> methods currently exist.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a>
</p>


<h3>References</h3>

<p>Butts, C.T.  (2008).  &ldquo;A Relational Event Framework for Social Action.&rdquo;  <em>Sociological Methodology</em>, 38(1). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rem.dyad">rem.dyad</a></code>
</p>

<hr>
<h2 id='rem.dyad'> Fit a Relational Event Model to Dyadic Data </h2><span id='topic+rem.dyad.lambda'></span><span id='topic+rem.dyad.lprior'></span><span id='topic+rem.dyad.nlpost'></span><span id='topic+rem.dyad.n2llik'></span><span id='topic+rem.dyad.n2llik.samp'></span><span id='topic+rem.dyad.nlpost.samp'></span><span id='topic+rem.dyad.gof'></span><span id='topic+rem.dyad'></span><span id='topic+rem.dyad'></span><span id='topic+print.rem.dyad'></span><span id='topic+print.summary.rem.dyad'></span><span id='topic+summary.rem.dyad'></span><span id='topic+simulate.rem.dyad'></span>

<h3>Description</h3>

<p>Fits a relational event model to dyadic edgelist data, using either the ordinal or temporal likelihood.  Maximum likelihood, posterior mode, and posterior importance resampling methods are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rem.dyad(edgelist, n, effects = NULL, ordinal = TRUE, acl = NULL,
    cumideg = NULL, cumodeg = NULL, rrl = NULL, covar = NULL, ps = NULL,
    tri = NULL, optim.method = "BFGS", optim.control = list(), 
    coef.seed = NULL, hessian = FALSE, sample.size = Inf, verbose = TRUE, 
    fit.method = c("BPM", "MLE", "BSIR"), conditioned.obs = 0, 
    prior.mean = 0, prior.scale = 100, prior.nu = 4, sir.draws = 500, 
    sir.expand = 10, sir.nu = 4, gof = TRUE)
## S3 method for class 'rem.dyad'
print(x, ...)
## S3 method for class 'rem.dyad'
summary(object, ...) 
## S3 method for class 'rem.dyad'
simulate(object, nsim = object$m, seed = NULL, 
    coef = NULL, covar = NULL, edgelist = NULL, redraw.timing = FALSE,
    redraw.events = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rem.dyad_+3A_edgelist">edgelist</code></td>
<td>
<p> a three-column edgelist matrix, with each row containing (in order) the time/order, sender, and receiver for the event in question, or <code>NULL</code> to create a model skeleton (useful for simulation). </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_n">n</code></td>
<td>
<p> number of senders/receivers. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_effects">effects</code></td>
<td>
<p> a character vector indicating which effects to use; see below for specification. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_ordinal">ordinal</code></td>
<td>
<p> logical; should the ordinal likelihood be used?  (If <code>FALSE</code>, the temporal likelihood is used instead.) </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_acl">acl</code></td>
<td>
<p> optionally, a pre-computed acl structure. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_cumideg">cumideg</code></td>
<td>
<p> optionally, a pre-computed cumulative indegree structure. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_cumodeg">cumodeg</code></td>
<td>
<p> optionally, a pre-computed cumulative outdegree stucture. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_rrl">rrl</code></td>
<td>
<p> optionally, a pre-computed recency-ranked communications list. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_covar">covar</code></td>
<td>
<p> an optional list of sender/receiver/event covariates. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_ps">ps</code></td>
<td>
<p> optionally, a pre-computed p-shift matrix. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_tri">tri</code></td>
<td>
<p> optionally, a pre-computed triad statistic structure. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_optim.method">optim.method</code></td>
<td>
<p> the method to be used by <code><a href="stats.html#topic+optim">optim</a></code>. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_optim.control">optim.control</code></td>
<td>
<p> additional control parameters to <code><a href="stats.html#topic+optim">optim</a></code>. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_coef.seed">coef.seed</code></td>
<td>
<p>an optional vector of coefficients to use as the starting point for the optimization process; if <code>edgelist==NULL</code>, this is the vector of embedded coefficients for the model skeleton.</p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_hessian">hessian</code></td>
<td>
<p> logical; compute the hessian of the log-likelihood/posterior surface? </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_sample.size">sample.size</code></td>
<td>
<p> sample size to use when estimating the sum of event rates. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_verbose">verbose</code></td>
<td>
<p> logical; deliver progress reports? </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_fit.method">fit.method</code></td>
<td>
<p> method to use when fitting the model. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_conditioned.obs">conditioned.obs</code></td>
<td>
<p> the number of initial observations on which to condition when fitting the model (defaults to 0).</p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_prior.mean">prior.mean</code></td>
<td>
<p> for Bayesian estimation, location vector for prior distribution (multivariate-t).  (Can be a single value.)</p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_prior.scale">prior.scale</code></td>
<td>
<p> for Bayesian estimation, scale vector for prior distribution.  (Can be a single value.) </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_prior.nu">prior.nu</code></td>
<td>
<p> for Bayesian estimation, degrees of freedom for prior distribution. (Setting this to <code>Inf</code> results in a Gaussian prior.) </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_sir.draws">sir.draws</code></td>
<td>
<p> for sampling importance resampling method, the number of posterior draws to take (post-resampling). </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_sir.expand">sir.expand</code></td>
<td>
<p> for sampling importance resampling method, the expansion factor to use in the initial (pre-resampling) sample; sample size is <code>sir.expand*sir.draws</code>.</p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_sir.nu">sir.nu</code></td>
<td>
<p> for sampling importance resampling method, the degrees of freedom for the t distribution used to obtain initial (pre-resampling) sample. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_gof">gof</code></td>
<td>
<p>logical; calculate goodness-of-fit information?</p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_x">x</code></td>
<td>
<p> an object of class <code>rem.dyad</code>.</p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_object">object</code></td>
<td>
<p> an object of class <code>rem.dyad</code>.</p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_nsim">nsim</code></td>
<td>
<p> number of events to simulate (defaults to the observed sequence length in the fitted model). </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_seed">seed</code></td>
<td>
<p> random number seed to use for simulation. </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_coef">coef</code></td>
<td>
<p> optional vector of coefficients to override those in the fitted model object, for simulation purposes.</p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_redraw.timing">redraw.timing</code></td>
<td>
<p> logical; should any prespecified events in <code>edgelist</code> have their timings redrawn during simulation? </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_redraw.events">redraw.events</code></td>
<td>
<p> logical; should any prespecified events in <code>edgelist</code> have their senders and receivers redrawn during simulation? </p>
</td></tr>
<tr><td><code id="rem.dyad_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rem.dyad</code> fits a (dyadic) relational event model to an event sequence, using either the full temporal or ordinal data likelihoods.  Three estimation methods are currently supported: maximum likelihood estimation, Bayesian posterior mode estimation, and Bayesian sampling importance resampling.  For the Bayesian methods, an adjustable multivariate-t (or, if <code>prior.nu==Inf</code>, Gaussian) prior is employed.  In the case of Bayesian sampling importance resampling, the posterior mode (and the hessian of the posterior about it) is used as the basis for a multivariate-t sample, which is then resampled via SIR methods to obtain an approximate set of posterior draws.  While this approximation is not guaranteed to work well, it is generally more robust than pure mode approximations (or, in the case of the MLE, estimates of uncertainty derived from the inverse hessian matrix).
</p>
<p>Whether Bayesian or frequentist methods are used, the relevant likelihood is either based entirely on the order of events (<code>ordinal=TRUE</code>) or on the realized event times (<code>ordinal=FALSE</code>).  In the latter case, all event times are understood to be relative to the onset of observation (i.e., observation starts at time 0), and the last event time given is taken to be the end of the observation period.  (If an event is also specified, this event is ignored.)
</p>
<p>Effects to be fit by <code>rem.dyad</code> are determined by the eponymous <code>effects</code> argument, a character vector which lists the effects to be used.  These are as follows:
</p>

<ul>
<li> <p><code>NIDSnd</code>: Normalized indegree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future sending rate
</p>
</li>
<li> <p><code>NIDRec</code>: Normalized indegree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future receiving rate
</p>
</li>
<li> <p><code>NODSnd</code>: Normalized outdegree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future sending rate
</p>
</li>
<li> <p><code>NODRec</code>: Normalized outdegree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future receiving rate
</p>
</li>
<li> <p><code>NTDegSnd</code>: Normalized total degree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future sending rate
</p>
</li>
<li> <p><code>NTDegRec</code>: Normalized total degree of <code class="reqn">v</code> affects <code class="reqn">v</code>'s future receiving rate
</p>
</li>
<li> <p><code>FrPSndSnd</code>: Fraction of <code class="reqn">v</code>'s past actions directed to <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>FrRecSnd</code>: Fraction of <code class="reqn">v</code>'s past receipt of actions from <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>RRecSnd</code>: Recency of receipt of actions from <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>RSndSnd</code>: Recency of sending to <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>CovSnd</code>: Covariate effect for outgoing actions (requires a <code>covar</code> entry of the same name)
</p>
</li>
<li> <p><code>CovRec</code>: Covariate effect for incoming actions (requires a <code>covar</code> entry of the same name)
</p>
</li>
<li> <p><code>CovInt</code>: Covariate effect for both outgoing and incoming actions (requires a <code>covar</code> entry of the same name)
</p>
</li>
<li> <p><code>CovEvent</code>: Covariate effect for each <code class="reqn">(v,v')</code> action (requires a <code>covar</code> entry of the same name)
</p>
</li>
<li> <p><code>OTPSnd</code>: Number of outbound two-paths from <code class="reqn">v</code> to <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>ITPSnd</code>: Number of incoming two-paths from <code class="reqn">v'</code> to <code class="reqn">v</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>OSPSnd</code>: Number of outbound shared partners for <code class="reqn">v</code> and <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>ISPSnd</code>: Number of inbound shared partners for <code class="reqn">v</code> and <code class="reqn">v'</code> affects <code class="reqn">v</code>'s future rate of sending to <code class="reqn">v'</code>
</p>
</li>
<li> <p><code>FESnd</code>: Fixed effects for outgoing actions
</p>
</li>
<li> <p><code>FERec</code>: Fixed effects for incoming actions
</p>
</li>
<li> <p><code>FEInt</code>: Fixed effects for both outgoing and incoming actions
</p>
</li>
<li> <p><code>PSAB-BA</code>: P-Shift effect (turn receiving) &ndash; AB-&gt;BA (dyadic)
</p>
</li>
<li> <p><code>PSAB-B0</code>: P-Shift effect (turn receiving) &ndash; AB-&gt;B0 (non-dyadic)
</p>
</li>
<li> <p><code>PAAB-BY</code>: P-Shift effect (turn receiving) &ndash; AB-&gt;BY (dyadic)
</p>
</li>
<li> <p><code>PSA0-X0</code>: P-Shift effect (turn claiming) &ndash; A0-&gt;X0 (non-dyadic)
</p>
</li>
<li> <p><code>PSA0-XA</code>: P-Shift effect (turn claiming) &ndash; A0-&gt;XA (non-dyadic)
</p>
</li>
<li> <p><code>PSA0-XY</code>: P-Shift effect (turn claiming) &ndash; A0-&gt;XY (non-dyadic)
</p>
</li>
<li> <p><code>PSAB-X0</code>: P-Shift effect (turn usurping) &ndash; AB-&gt;X0 (non-dyadic)
</p>
</li>
<li> <p><code>PSAB-XA</code>: P-Shift effect (turn usurping) &ndash; AB-&gt;XA (dyadic)
</p>
</li>
<li> <p><code>PSAB-XB</code>: P-Shift effect (turn usurping) &ndash; AB-&gt;XB (dyadic)
</p>
</li>
<li> <p><code>PSAB-XY</code>: P-Shift effect (turn usurping) &ndash; AB-&gt;XY (dyadic)
</p>
</li>
<li> <p><code>PSA0-AY</code>: P-Shift effect (turn continuing) &ndash; A0-&gt;AY (non-dyadic)
</p>
</li>
<li> <p><code>PSAB-A0</code>: P-Shift effect (turn continuing) &ndash; AB-&gt;A0 (non-dyadic)
</p>
</li>
<li> <p><code>PSAB-AY</code>: P-Shift effect (turn continuing) &ndash; AB-&gt;AY (dyadic)
</p>
</li></ul>

<p>Note that not all effects may lead to identified models in all cases - it is up to the user to ensure that the postulated model makes sense.
</p>
<p>Data to be used by <code>rem.dyad</code> must consist of an edgelist matrix, whose rows contain information on successive events.  This matrix must have three columns, containing (respectively) the event times, sender IDs (as integers from 1 to <code>n</code>), and receiver IDs (also from 1 to <code>n</code>).  As already noted, event times should be relative to onset of observation where the temporal likelihood is being used; otherwise, only event order is employed.  In the temporal likelihood case, the last row should contain the time for the termination of the observation period &ndash; any event on this row is ignored.  If <code>conditioned.obs&gt;0</code>, the relevant number of initial observations is taken as fixed, and the likelihood of the remaining sequence is calculated conditional on these values; this can be useful when analyzing an event history with no clear starting point.
</p>
<p>If covariates effects are indicated, then appropriate covariate values must be supplied as a list in argument <code>covar</code>.  The elements of <code>covar</code> should be given the same name as the effect type to which they correspond (e.g., <code>CovSnd</code>, <code>CovRec</code>, etc.); any other elements will be ignored.  The format of a given covariate element depends both on the effect type and on the number of covariates specified.  The basic cases are as follows:
</p>

<ul>
<li><p> Single covariate, time invariant: For <code>CovSnd</code>, <code>CovRec</code>, or <code>CovInt</code>, a vector or single-column matrix/array.  For <code>CovEvent</code>, an <code>n</code> by <code>n</code> matrix or array.
</p>
</li>
<li><p> Multiple covariates, time invariant: For <code>CovSnd</code>, <code>CovRec</code>, or <code>CovInt</code>, a two-dimensional <code>n</code> by <code>p</code> matrix/array whose columns contain the respective covariates.  For <code>CovEvent</code>, a <code>p</code> by <code>n</code> by <code>n</code> array, whose first dimension indexes the covariate matrices.
</p>
</li>
<li><p> Single or multiple covariates, time varying: For <code>CovSnd</code>, <code>CovRec</code>, or <code>CovInt</code>, an <code>m</code> by <code>p</code> by n array whose respective dimensions index time (i.e., event number), covariate, and actor.  For <code>CovEvent</code>, a <code>m</code> by <code>p</code> by <code>n</code> by <code>n</code> array, whose dimensions are analogous to the previous case.
</p>
</li></ul>

<p>Note that &ldquo;time varying&rdquo; covariates may only change values when events transpire; thus, they should be regarded as temporally endogenous.  (See the reference below for details.) 
</p>
<p>If called with <code>edgelist==NULL</code>, <code>rem.dyad</code> will produce a &ldquo;model skeleton&rdquo; object containing the effects and other information, but no model fit.  (The seed coefficients, if given, are entered as the coefficients in the model, or else an uninteresting default set is used.)  The main purpose for this object is to set up an <em>ab initio</em> simulation, as described below: once the skeleton is created, the <code><a href="stats.html#topic+simulate">simulate</a></code> method can be used to generate draws from that model (without fitting to a data set).
</p>
<p>A <code><a href="stats.html#topic+simulate">simulate</a></code> method is provided for <code>rem.dyad</code> objects, which allows simulation of new event sequences from a fitted or skeleton model.  By default, a new sequence of length equal to the original sequence to which the model object was fitted is simulated (if applicable), but other lengths may be chosen using <code>nsim</code>.  Although the coefficients in the model object are used by default, this may also be altered by specifying <code>coef</code>.  Note that any covariates used must be passed to the simulate command via <code>covar</code> (using the same format as in the original model); this is in part because <code>rem.dyad</code> objects do not currently save their input data, and in part because dynamic covariates must always be the length of the simulated sequence (and hence must be factored when a non-default <code>nsim</code> value is used).  For models fit using <code>ordinal=TRUE</code>, the overall pacing of events will be arbitrary (more specifically, the simulation will tacitly assume that each event has a unit base hazard), but the relative timing is not.  See below for examples of both simulation using a fitted model object and <em>ab initio</em> simulation without fitting a model to data.
</p>
<p>For simulation, it is possible to fix the first portion of the event history by passing an event list matrix to the <code>edgelist</code> argument; this must be compatible with the target model (i.e., the vertex IDs must match), and it cannot contain <code>NA</code> values.  (Thus, if starting with an exact timing seqence with a last line containing <code>NA</code>s, this must be removed.)  If the input event list contains <code>m</code> events, then these are assumed to supply the first <code>m</code> events of the target sequence; if <code>m&gt;nsim</code>, then any excess events are discarded.  By default, the input events are taken as fixed.  However, specifying <code>redraw.timing=TRUE</code> will lead the event timings to be redrawn, and <code>redraw.events</code> will lead the sender/reciver pairs to be redrawn.  This allows e.g. for an observed ordinal time sequence to be given a simulated exact time realization, by setting <code>nsim</code> to the event list length and setting <code>redraw.timing=TRUE</code>.  The more obvious use case is to simply extend an observed sequence, in which case one should use <code>nsim</code> greater than the input sequence length (i.e., the input length plus the number of new events to generate) and leave the <code>redraw</code> paraeters set to <code>FALSE</code>.  
</p>


<h3>Value</h3>

<p>For <code>rem.dyad</code>, an object of class <code>rem.dyad</code>.  For the <code>simulate</code> method, an event list.





</p>


<h3>Author(s)</h3>

<p> Carter T. Butts <a href="mailto:buttsc@uci.edu">buttsc@uci.edu</a> </p>


<h3>References</h3>

<p> Butts, C.T.  (2008).  &ldquo;A Relational Event Framework for Social Action.&rdquo;  <em>Sociological Methodology</em>, 38(1). </p>


<h3>See Also</h3>

 <p><code><a href="#topic+rem">rem</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Generate some simple sample data based on fixed effects
roweff&lt;-rnorm(10)                                     #Build rate matrix
roweff&lt;-roweff-roweff[1]                   #Adjust for later convenience
coleff&lt;-rnorm(10)
coleff&lt;-coleff-coleff[1]
lambda&lt;-exp(outer(roweff,coleff,"+"))
diag(lambda)&lt;-0
ratesum&lt;-sum(lambda)
esnd&lt;-as.vector(row(lambda))                  #List of senders/receivers
erec&lt;-as.vector(col(lambda))
time&lt;-0
edgelist&lt;-vector()
while(time&lt;15){                   # Observe the system for 15 time units
  drawsr&lt;-sample(1:100,1,prob=as.vector(lambda))        #Draw from model
  time&lt;-time+rexp(1,ratesum)
  if(time&lt;=15)                                             #Censor at 15
    edgelist&lt;-rbind(edgelist,c(time,esnd[drawsr],erec[drawsr]))
  else
    edgelist&lt;-rbind(edgelist,c(15,NA,NA))
}

#Fit the model, ordinal BPM
effects&lt;-c("FESnd","FERec")
fit.ord&lt;-rem.dyad(edgelist,10,effects=effects,hessian=TRUE)
summary(fit.ord)
par(mfrow=c(1,2))                                #Check the coefficients
plot(roweff[-1],fit.ord$coef[1:9],asp=1)
abline(0,1)
plot(coleff[-1],fit.ord$coef[10:18],asp=1)
abline(0,1)

#Now, find the temporal BPM
fit.time&lt;-rem.dyad(edgelist,10,effects=effects,ordinal=FALSE,hessian=TRUE)
summary(fit.time)
plot(fit.ord$coef,fit.time$coef,asp=1)                  #Similar results
abline(0,1)

#Finally, try the BSIR method (note: a much larger expansion factor
#is recommended in practice)
fit.bsir&lt;-rem.dyad(edgelist,10,effects=effects,fit.method="BSIR",
    sir.draws=100,sir.expand=5)
summary(fit.bsir)
par(mfrow=c(3,3))   #Examine the approximate posterior marginals
for(i in 1:9){
  hist(fit.bsir$post[,i],main=names(fit.bsir$coef)[i],prob=TRUE)
  abline(v=roweff[i+1],col=2,lwd=3)
}
for(i in 10:18){
  hist(fit.bsir$post[,i],main=names(fit.bsir$coef)[i],prob=TRUE)
  abline(v=coleff[i-8],col=2,lwd=3)
}

#Simulate an event sequence from the temporal model
sim&lt;-simulate(fit.time,nsim=50000) #Simulate 50000 events
head(sim)                          #Show the event list
par(mfrow=c(1,2))                  #Check the behavior
esnd&lt;-exp(c(0,fit.time$coef[1:9]))
esnd&lt;-esnd/sum(esnd)*5e4           #Expected sending count
erec&lt;-exp(c(0,fit.time$coef[10:18]))
erec&lt;-erec/sum(erec)*5e4           #Expected sending count
plot(esnd,tabulate(sim[,2]),xlab="Expected Out-events",ylab="Out-events")
abline(0,1,col=2)
plot(erec,tabulate(sim[,3]),xlab="Expected In-events",ylab="In-events")
abline(0,1,col=2)

#Keep the first 10 events of the simulated sequence, and produce 10 more
sim.pre&lt;-sim[1:10,]
sim2&lt;-simulate(fit.time,nsim=20,edgelist=sim.pre)
sim.pre                            #See the first 10 events
sim2                               #First 10 events preserved
all(sim2[1:10,]==sim.pre)          #All TRUE

#Repeat, but redrawing part of the input sequence
sim2.t&lt;-simulate(fit.time,nsim=20,edgelist=sim.pre,redraw.timing=TRUE)
sim2.e&lt;-simulate(fit.time,nsim=20,edgelist=sim.pre,redraw.events=TRUE)
sim2.t                             #Events kept, timings not
sim2.t[1:10,]==sim.pre             #Second two columns TRUE
sim2.e                             #Timing kept, events not
sim2.e[1:10,]==sim.pre             #(Note: some events may repeat by chance!)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
