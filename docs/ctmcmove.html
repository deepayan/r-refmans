<!DOCTYPE html><html><head><title>Help for package ctmcmove</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ctmcmove}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ctmcmove-package'>
<p>ctmcmove</p></a></li>
<li><a href='#ctmc.sim'>
<p>Code to simulate a continuous-time Markov chain.</p></a></li>
<li><a href='#ctmc2glm'>
<p>Convert a &quot;ctmc&quot; object into Poisson glm format.</p></a></li>
<li><a href='#get.rate.matrix'>
<p>Create a CTMC rate matrix from rasters and parameter estimates.</p></a></li>
<li><a href='#get.UD'>
<p>Find the stationary distribution of the CTMC.</p></a></li>
<li><a href='#mcmc.fmove'>
<p>Fit continuous-time functional movement model to telemetry data.</p></a></li>
<li><a href='#path2ctmc'>
<p>Function to turn a discrete-time continuous-space path into a CTMC path.</p>
</a></li>
<li><a href='#Pctmc'>
<p>Transition Matrix of a CTMC.</p></a></li>
<li><a href='#rast.grad'>
<p>Creates gradient rasters from a raster object.</p></a></li>
<li><a href='#seal'>
<p>Data for one foraging trip by a male northern fur seal (NFS).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling Animal Movement with Continuous-Time Discrete-Space
Markov Chains</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-04-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Ephraim Hanks</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ephraim Hanks &lt;hanks@psu.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), raster, Matrix, fda, gdistance, sp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mgcv, dismo, crawl</td>
</tr>
<tr>
<td>Description:</td>
<td>Software to facilitates taking movement data in xyt format and pairing it with raster covariates within a continuous time Markov chain (CTMC) framework.  As described in Hanks et al. (2015) &lt;<a href="https://doi.org/10.1214%2F14-AOAS803">doi:10.1214/14-AOAS803</a>&gt; , this allows flexible modeling of movement in response to covariates (or covariate gradients) with model fitting possible within a Poisson GLM framework. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-04-20 13:37:37 UTC; ephraim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-04-20 13:58:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='ctmcmove-package'>
ctmcmove
</h2><span id='topic+ctmcmove-package'></span><span id='topic+ctmcmove'></span>

<h3>Description</h3>

<p>Software to facilitates taking movement data in xyt format and pairing it with raster covariates within a continuous time Markov chain (CTMC) framework.  As described in Hanks et al. (2015) &lt;DOI:10.1214/14-AOAS803&gt; , this allows flexible modeling of movement in response to covariates (or covariate gradients) with model fitting possible within a Poisson GLM framework.
</p>


<h3>Details</h3>

<p>Typical work flow for analysis of telemetry / GPS movement data:
</p>
<p>1. Fit a quasi-continuous path model to telemetry xyt data.  The
ctmcmove package facilitates this through the &quot;mcmc.fmove&quot; function.
</p>
<p>2. Create or import raster layers (from package &quot;raster&quot;) for each
covariate.
</p>
<p>3. Impute a quasi-continuous path (done jointly with model fitting in
the &quot;mcmc.fmove&quot; function.
</p>
<p>4. Turn the quasi-continuous path into a CTMC discrete-space
path using the &quot;path2ctmc&quot; command.
</p>
<p>5. Turn discrete-space path into Poisson GLM format using the
&quot;ctmc2glm&quot; command.
</p>
<p>6. Repeat #3 - #5 multiple times (M times).  Stack together the response &quot;z&quot;,
model matrix &quot;X&quot;, and offset &quot;tau&quot; elements from each imputed path. 
</p>
<p>7. Fit a Poisson GLM model to the stacked data with response &quot;z&quot;,
model matrix &quot;X&quot;, offset &quot;log(tau)&quot;, and weights for each row equal to &quot;1/M&quot;.
</p>
<p>7 (alternate).  Alternately, multiple imputation could be used, as
described in Hanks et al., (2015).
</p>


<h3>Author(s)</h3>

<p>Ephraim M. Hanks
</p>
<p>Maintainer: Ephraim M. Hanks
</p>


<h3>References</h3>

<p>Hanks, E. M.; Hooten, M. B. &amp; Alldredge, M. W. Continuous-time
Discrete-space Models for Animal Movement The Annals of Applied
Statistics, 2015, 9, 145-165
</p>
<p>Hanks, E.; Hooten, M.; Johnson, D. &amp; Sterling, J. Velocity-Based
Movement Modeling for Individual and Population Level Inference PLoS
ONE, Public Library of Science, 2011, 6, e22795
</p>
<p>Hooten, M. B.; Johnson, D. S.; Hanks, E. M. &amp; Lowry, J. H. Agent-Based
Inference for Animal Movement and Selection Journal of Agricultural,
Biological, and Environmental Statistics, 2010, 15, 523-538
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

##
## Example of using a CTMC model for movement
##
## Steps:
##  1. Fit Quasi-Continuous Path Model to telemetry data (done using Buderman et al 2015)
##  2. Create covariate raster objects (the CTMC will be on the raster
##     grid cells)
##  3. Impute a quasi-continuous path
##  4. Turn quasi-continuous path into a CTMC discrete-space path
##  5. Turn discrete-space path into latent Poisson GLM format
##  6. Fit a Poisson GLM model to the data
##

library(ctmcmove)
data(seal)
xyt=seal$locs[,3:1]
head(xyt)
plot(xyt[,1:2],type="b")
xy=xyt[,-3]
x=xyt[,1]
y=xyt[,2]
t=xyt[,3]


########################


##########################################################################
##
## 1. Fit functional movement model to telemetry data
##
##########################################################################

library(fda)

## Define the knots of the spline expansion.
##
## Problems with fitting the functional movement model can often be fixed by
## varying the spacing of the knots.
knots = seq(min(t),max(t),by=1/4)
## create B-spline basis vectors used to approximate the path
b=create.bspline.basis(c(min(t),max(t)),breaks=knots,norder=3)
## define the sequence of times on which to sample the imputed path
tpred=seq(min(t),max(t),by=1/24/60)



## Fit latent Gaussian model using MCMC
out=mcmc.fmove(xy,t,b,tpred,QQ="CAR",n.mcmc=400,a=1,r=1,num.paths.save=30)
str(out)

## plot 3 imputed paths
plot(xy,type="b")
points(out$pathlist[[1]]$xy,col="red",type="l")
points(out$pathlist[[2]]$xy,col="blue",type="l")
points(out$pathlist[[3]]$xy,col="green",type="l")


##########################################################################
##
## 2. Creating rasters
##
##########################################################################

cov.df=seal$cov.df
str(cov.df)

NN=sqrt(nrow(cov.df$X))
sst=matrix(seal$cov.df$X$sst,NN,byrow=TRUE)
sst=sst[NN:1,]
sst=raster(sst,xmn=min(seal$cov.df$X$x),xmx=max(seal$cov.df$X$x),
           ymn=min(seal$cov.df$X$y),ymx=max(seal$cov.df$X$y))


crs(sst)="+proj=longlat +datum=WGS84"
plot(sst)

chA=matrix(seal$cov.df$X$chA,NN,byrow=TRUE)
chA=chA[NN:1,]
chA=raster(chA,xmn=min(seal$cov.df$X$x),xmx=max(seal$cov.df$X$x),
           ymn=min(seal$cov.df$X$y),ymx=max(seal$cov.df$X$y))
crs(chA)="+proj=longlat +datum=WGS84"

pro=matrix(seal$cov.df$X$pro,NN,byrow=TRUE)
pro=pro[NN:1,]
npp=raster(pro,xmn=min(seal$cov.df$X$x),xmx=max(seal$cov.df$X$x),
           ymn=min(seal$cov.df$X$y),ymx=max(seal$cov.df$X$y))
crs(npp)="+proj=longlat +datum=WGS84"


int=sst
values(int) &lt;- 1

d2r=int
rookery.cell=cellFromXY(int,xyt[1,1:2])
values(d2r)=NA
values(d2r)[rookery.cell]=0
d2r=distance(d2r)

grad.stack=stack(sst,chA,npp,d2r)
names(grad.stack) &lt;- c("sst","cha","npp","d2r")

plot(sst)
points(xyt[,1:2],type="b")

plot(grad.stack)


##########################################################################
##
## 3 Impute Quasi-Continuous Paths
##
##########################################################################

P=20

plot(sst,col=grey.colors(100))
for(i in 1:P){
    points(out$pathlist[[i]]$xy,col=i,type="l",lwd=2)
}
points(xyt[,1:2],type="b",pch=20,cex=2,lwd=2)

##########################################################################
##
## 4. Turn continuous space path into a CTMC discrete space path
##
##########################################################################

path=out$pathlist[[1]]
ctmc=path2ctmc(path$xy,path$t,int,method="LinearInterp")
## alternate method, useful if you have impassible barriers, but slower
## ctmc=path2ctmc(path$xy,path$t,int,method="ShortestPath")

str(ctmc)

##########################################################################
##
## 5. Turn CTMC discrete path into latent Poisson GLM data
##
##########################################################################


loc.stack=stack(int,sst)
names(loc.stack) &lt;- c("Intercept","sst.loc")

glm.list=list()
glm.list[[1]]=ctmc2glm(ctmc,loc.stack,grad.stack)

str(glm.list)

for(i in 2:P){
    cat(i," ")
    path=out$pathlist[[i]]
    ctmc=path2ctmc(path$xy,path$t,int,method="LinearInterp")
    glm.list[[i]]=ctmc2glm(ctmc,loc.stack,grad.stack)
}

## remove transitions that are nearly instantaneous
##  (These are essentially outliers in the following regression analyses)
for(i in 1:P){
    idx.0=which(glm.list[[i]]$tau&lt;10^-5)
    if(length(idx.0)&gt;0){
        glm.list[[i]]=glm.list[[i]][-idx.0,]
    }
    glm.list[[i]]$t=glm.list[[i]]$t-min(glm.list[[i]]$t)
}


##
## Stack the P imputations together
##

glm.data=glm.list[[1]]
for(i in 2:P){
    glm.data=rbind(glm.data,glm.list[[i]])
}

str(glm.data)

##########################################################################
##
## 6. Fit Poisson GLM
##    (here we are fitting all "M" paths simultaneously,
##     giving each one a weight of "1/M")
##
##########################################################################

fit.SWL=glm(z~cha+npp+sst+crw+d2r+sst.loc,
        weights=rep(1/P,nrow(glm.data)),family="poisson",offset=log(tau),data=glm.data)
summary(fit.SWL)

beta.hat.SWL=coef(fit.SWL)
beta.se.SWL=summary(fit.SWL)$coef[,2]

##########################################################################
##
## 6. Fit Poisson GLM
##    (here we are fitting using Multiple Imputation
##
##########################################################################

## Fit each path individually
glm.fits=list()
for(i in 1:P){
    glm.fits[[i]]=glm(z~cha+npp+sst+crw+d2r+sst.loc,
        family="poisson",offset=log(tau),data=glm.list[[i]])
}

## get point estimates and sd estimates using Rubin's MI combining rules
beta.hat.mat=integer()
beta.se.mat=integer()
for(i in 1:P){
    beta.hat.mat=rbind(beta.hat.mat,coef(glm.fits[[i]]))
    beta.se.mat=rbind(beta.se.mat,summary(glm.fits[[i]])$coef[,2])
}

beta.hat.mat
beta.se.mat

## E(beta) = E_paths(E(beta|path))
beta.hat.MI=apply(beta.hat.mat,2,mean)
beta.hat.MI

## Var(beta) = E_paths(Var(beta|path))+Var_paths(E(beta|path))
beta.var.MI=apply(beta.se.mat^2,2,mean)+apply(beta.hat.mat,2,var)
beta.se.MI=sqrt(beta.var.MI)

cbind(beta.hat.MI,beta.se.MI)

##
## compare estimates from MI and Stacked Weighted Likelihood approach
##

## standardize regression coefficients by multiplying by the SE of the X matrix
sds=apply(model.matrix(fit.SWL),2,sd)
sds[1]=1

## plot MI and SWL regression coefficients
par(mfrow=c(1,2))
plot(beta.hat.MI*sds,beta.hat.SWL*sds,main="(a) Coefficient Estimates",
xlab="Weighted Likelihood Coefficient",
ylab="Multiple Imputation Coefficient",pch=20,cex=2)
abline(0,1,col="red")
plot(log(beta.se.MI),log(beta.se.SWL),
main="(b) Estimated log(Standard Errors)",xlab="Weighted Likelihood log(SE)",
 ylab="Multiple Imputation log(SE)",pch=20,cex=2)
abline(0,1,col="red")


###########################################################################
##
## 6. (Alternate) We can use any software which fits Poisson glm data.
##    The following uses "gam" in package "mgcv" to fit a time-varying
##    effect of "d2r" using penalized regression splines.  The result
##    is similar to that found in:
##
##    Hanks, E.; Hooten, M.; Johnson, D. &amp; Sterling, J. Velocity-Based
##    Movement Modeling for Individual and Population Level Inference
##    PLoS ONE, Public Library of Science, 2011, 6, e22795
##
###########################################################################

library(mgcv)

fit=gam(z~cha+npp+crw+sst.loc+s(t,by=-d2r),
        weights=rep(1/P,nrow(glm.data)),family="poisson",offset=log(tau),data=glm.data)
summary(fit)

plot(fit)
abline(h=0,col="red")





############################################################
##
## Overview Plot
##
############################################################


## pdf("sealfig.pdf",width=8.5,height=8.85)
par(mfrow=c(3,3))
##
plot(sst,col=(terrain.colors(30)),main="(a) Sea Surface Temperature")
points(xyt[1,1:2]-c(0,.05),type="p",pch=17,cex=2,col="red")
points(xyt[,1:2],type="b",pch=20,cex=.75,lwd=1)
##
plot(d2r/1000,col=(terrain.colors(30)),main="(b) Distance to Rookery")
points(xyt[1,1:2]-c(0,.05),type="p",pch=17,cex=2,col="red")
points(xyt[,1:2],type="b",pch=20,cex=.75,lwd=1)
##
image(sst,col=rev(terrain.colors(30)),main="(c) Imputed Functional Paths",xlab="",ylab="")
for(i in 1:5){
    ## points(out$pathlist[[i]]$xy,col=i+1,type="l",lwd=3)
    points(out$pathlist[[i]]$xy,col=i+1,type="l",lwd=2)
}
points(xyt[,1:2],type="p",pch=20,cex=.75,lwd=1)
##
ee=extent(c(188.5,190.5,58.4,59.1))
sst.crop=crop(sst,ee)
bg=sst.crop
values(bg)=NA
for(i in c(2)){
    values(bg)[cellFromXY(bg,out$pathlist[[i]]$xy)] &lt;- 1
}
image(sst.crop,col=(terrain.colors(30)),xlim=c(188.85,190.2),
ylim=c(58.5,59),main="(d) CTMC Path",xlab="",ylab="")
image(bg,col="blue",xlim=c(188.85,190.2),ylim=c(58.5,59),add=TRUE)
for(i in c(2)){
    points(out$pathlist[[i]]$xy,col=i,type="l",lwd=3)
}
points(xyt[,1:2],type="b",pch=20,cex=2,lwd=2)
##
image(sst.crop,col=(terrain.colors(30)),xlim=c(189.62,189.849),
ylim=c(58.785,58.895),main="(e) CTMC Model Detail",xlab="",ylab="")
abline(v=189.698+res(sst)[1]*c(-1,0,1,2))
abline(h=58.823+res(sst)[2]*c(-1,0,1,2))
##
plot(fit,main="(f) Time-Varying Response to Rookery",shade=TRUE,
shade.col="orange",lwd=3,rug=F,xlab="Day of Trip",
ylab="Coefficient of Distance To Rookery")
abline(h=0,col="red")
##



###############################################
##
## Get UD (following Kenady et al 2017+)
##
###############################################

RR=get.rate.matrix(fit.SWL,loc.stack,grad.stack)
UD=get.UD(RR,method="lu")
ud.rast=sst
values(ud.rast) &lt;- as.numeric(UD)
plot(ud.rast)


###############################################
##
## Get shortest path and current maps (following Brennan et al 2017+)
##
###############################################

library(gdistance)

## create a dummy transition layer from a raster.
## make sure the "directions" argument matches that used in path2ctmc
## also make sure to add the "symm=FALSE" argument
trans=transition(sst,mean,directions=4,symm=FALSE)
## now replace the transition object with the "rate" matrix
## so "conductance" values are "transition rates"
transitionMatrix(trans) &lt;- RR
str(trans)

##
## now calculate least cost paths using "shortestPath" from gdistance
##

## pick start and end locations
plot(sst)
st=c(185,59.5)
en=c(190,57.3)

st.cell=cellFromXY(sst,st)
en.cell=cellFromXY(sst,en)

## shortest path
sp=shortestPath(trans,st,en,output="SpatialLines")
plot(sst,main="Shortest Path (SST in background)")
lines(sp,col="brown",lwd=7)



##
## Now calculate "current maps" that show space use of random walkers
## moving between two given locations.
##
## gdistance's "passage" function allows for asymmetric transition rates
##

passage.gdist=passage(trans,st,en,theta=.001,totalNet="net")
plot((passage.gdist))



## End(Not run)

</code></pre>

<hr>
<h2 id='ctmc.sim'>
Code to simulate a continuous-time Markov chain.
</h2><span id='topic+ctmc.sim'></span>

<h3>Description</h3>

<p>Simulates a CTMC with given rate matrix (Q) for a time (T), or until
it reaches a final absorbing state.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctmc.sim(Q,start.state=1,T=1,final.state=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctmc.sim_+3A_q">Q</code></td>
<td>

<p>A square matrix.  Either a rate matrix or the infinitessimal generator of the CTMC.
</p>
</td></tr>
<tr><td><code id="ctmc.sim_+3A_start.state">start.state</code></td>
<td>

<p>An integer - the starting state for the simulation.
</p>
</td></tr>
<tr><td><code id="ctmc.sim_+3A_t">T</code></td>
<td>

<p>A numeric value greater than zero.  The time window for simulating the
CTMC will be [0,T].
</p>
</td></tr>
<tr><td><code id="ctmc.sim_+3A_final.state">final.state</code></td>
<td>

<p>Either NA or an integer.  If an integer, the chain will be simulated
until it enters the &quot;final.state&quot;, at which time the simulation will
be terminated.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code uses the Gillespie algorithm to simulate a CTMC path in
continuous time.
</p>


<h3>Value</h3>

<table>
<tr><td><code>ec</code></td>
<td>
<p>A vector of the sequential grid cells (the embedded chain)
in the CTMC movement path</p>
</td></tr>
<tr><td><code>rt</code></td>
<td>
<p>A vector of residence times in each sequential grid cell
in the CTMC movement path</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ephraim M. Hanks

</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For example code, do
##
## &gt; help(ctmcMove)
</code></pre>

<hr>
<h2 id='ctmc2glm'>
Convert a &quot;ctmc&quot; object into Poisson glm format.
</h2><span id='topic+ctmc2glm'></span>

<h3>Description</h3>

<p>Transforms a &quot;ctmc&quot; object and covariate rasters into data suitable for analysis using
Poisson GLM software (like glm in R). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctmc2glm(ctmc, stack.static, stack.grad, crw = TRUE,
    normalize.gradients = FALSE, grad.point.decreasing = TRUE,
    include.cell.locations=TRUE,directions=4,zero.idx=integer())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctmc2glm_+3A_ctmc">ctmc</code></td>
<td>

<p>A &quot;ctmc&quot; object (output from &quot;path2ctmc&quot;).
</p>
</td></tr>
<tr><td><code id="ctmc2glm_+3A_stack.static">stack.static</code></td>
<td>

<p>A rasterStack object, where each layer in the stack is a location-based covariate.
</p>
</td></tr>
<tr><td><code id="ctmc2glm_+3A_stack.grad">stack.grad</code></td>
<td>

<p>A rasterStack object, where each layer in the stack is a directional
gradient-based covariate
</p>
</td></tr>
<tr><td><code id="ctmc2glm_+3A_crw">crw</code></td>
<td>

<p>Logical.  If TRUE (default), an autocovariate is created for each cell
visited in the CTMC movement path.  The autocovariate is a
unit-length directional vector pointing from the center of the most
recent grid cell to the center of the current grid cell. 
</p>
</td></tr>
<tr><td><code id="ctmc2glm_+3A_normalize.gradients">normalize.gradients</code></td>
<td>

<p>Logical.  Default is FALSE.  If TRUE, then all gradient
covariates are normalized by dividing by the length of the gradient
vector at each point.</p>
</td></tr>
<tr><td><code id="ctmc2glm_+3A_grad.point.decreasing">grad.point.decreasing</code></td>
<td>

<p>Logical.  If TRUE, then the gradient covariates are positive in the
direction of decreasing values of the covariate.  If FALSE, then the
gradient covariates are positive in the direction of increasing values
of the covariate (like a true gradient).
</p>
</td></tr>
<tr><td><code id="ctmc2glm_+3A_include.cell.locations">include.cell.locations</code></td>
<td>

<p>Logical.  If TRUE, then the x and y locations of the centers of the (1) current
and (2) neighboring raster cells will be returned for each row in the created 
data matrix.
</p>
</td></tr>
<tr><td><code id="ctmc2glm_+3A_directions">directions</code></td>
<td>

<p>Integer.  Either 4 (indicating a &quot;Rook's neighborhood&quot; of 4
neighboring grid cells) or 8 (indicating a
&quot;King's neighborhood&quot; of 8 neighboring grid cells).
</p>
</td></tr>
<tr><td><code id="ctmc2glm_+3A_zero.idx">zero.idx</code></td>
<td>

<p>Integer vector of the indices of raster cells that are not passable and should be
excluded.  These are cells where movement should be impossible.  Default is zero.idx=integer().
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This code creates one data row for each possible transition from each
grid cell visited by the CTMC path.
</p>


<h3>Value</h3>

<table>
<tr><td><code>z</code></td>
<td>
<p>Response variable (either zero or 1) for analysis using GLM
software.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Matrix of predictor variables for analysis using GLM
software.  Created from the location-based
and gradient-based covariates.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Offset for each row in a Poisson GLM with log link.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>Vector of the time each raster grid cell was entered</p>
</td></tr> 

</table>


<h3>Author(s)</h3>

<p>Ephraim M. Hanks

</p>


<h3>References</h3>

<p>Hanks, E. M.; Hooten, M. B. &amp; Alldredge, M. W. Continuous-time
Discrete-space Models for Animal Movement The Annals of Applied
Statistics, 2015, 9, 145-165
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For example code, do
##
## &gt; help(ctmcMove)
</code></pre>

<hr>
<h2 id='get.rate.matrix'>
Create a CTMC rate matrix from rasters and parameter estimates.
</h2><span id='topic+get.rate.matrix'></span>

<h3>Description</h3>

<p>Creates a CTMC rate matrix from rasters and parameter estimates
(perhaps from a GLM analysis). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rate.matrix(object, stack.static, stack.grad,
    normalize.gradients = FALSE, grad.point.decreasing = TRUE,
    directions=4, zero.idx=integer(), coef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.rate.matrix_+3A_object">object</code></td>
<td>

<p>A fitted GLM or GAM object used to fit the CTMC movement model
</p>
</td></tr>
<tr><td><code id="get.rate.matrix_+3A_stack.static">stack.static</code></td>
<td>

<p>A rasterStack object, where each layer in the stack is a location-based covariate.
</p>
</td></tr>
<tr><td><code id="get.rate.matrix_+3A_stack.grad">stack.grad</code></td>
<td>

<p>A rasterStack object, where each layer in the stack is a directional
gradient-based covariate
</p>
</td></tr>
<tr><td><code id="get.rate.matrix_+3A_normalize.gradients">normalize.gradients</code></td>
<td>

<p>Logical.  Default is FALSE.  If TRUE, then all gradient
covariates are normalized by dividing by the length of the gradient
vector at each point.</p>
</td></tr>
<tr><td><code id="get.rate.matrix_+3A_grad.point.decreasing">grad.point.decreasing</code></td>
<td>

<p>Logical.  If TRUE, then the gradient covariates are positive in the
direction of decreasing values of the covariate.  If FALSE, then the
gradient covariates are positive in the direction of increasing values
of the covariate (like a true gradient).
</p>
</td></tr>
<tr><td><code id="get.rate.matrix_+3A_directions">directions</code></td>
<td>

<p>Integer.  Either 4 (indicating a &quot;Rook's neighborhood&quot; of 4
neighboring grid cells) or 8 (indicating a
&quot;King's neighborhood&quot; of 8 neighboring grid cells).
</p>
</td></tr>
<tr><td><code id="get.rate.matrix_+3A_zero.idx">zero.idx</code></td>
<td>

<p>Integer vector of the indices of raster cells that are not passable and should be
excluded.  These are cells where movement should be impossible.  Default is zero.idx=integer().
</p>
</td></tr>
<tr><td><code id="get.rate.matrix_+3A_coef">coef</code></td>
<td>
<p>A vector of coefficents to use in place of those in 'object'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the covariate rasters in stack.static (motility
covariates) and stack.grad (gradient covariates) and creates a CTMC
rate matrix defining movement between all neighboring raster grid
cells.  It is NOT possible to include an autocovariate here (&quot;crw&quot; in
ctmc2glm).  If such was included in the original fitted model, then the crw term is set equal to zero.
</p>


<h3>Value</h3>

<p>An n-by-n Matrix of CTMC rate values.

</p>


<h3>Author(s)</h3>

<p>Ephraim M. Hanks

</p>


<h3>References</h3>

<p>Hanks, E. M.; Hooten, M. B. &amp; Alldredge, M. W. Continuous-time
Discrete-space Models for Animal Movement.  The Annals of Applied
Statistics, 2015, 9, 145-165
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For example code, do
##
## &gt; help(ctmcMove)
</code></pre>

<hr>
<h2 id='get.UD'>
Find the stationary distribution of the CTMC.
</h2><span id='topic+get.UD'></span>

<h3>Description</h3>

<p>Finds the stationary distribution (proportional utilization
distribution) implied by a CTMC movement model with a given rate
matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.UD(R,method="lu",maxiter, start, tol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.UD_+3A_r">R</code></td>
<td>

<p>Rate matrix with R[i,j] equal to the CTMC rate of movement from
raster cell i to neighboring raster cell j.  R[i,j]=0 implies that
cells i and j are not first order neighbors.
</p>
</td></tr>
<tr><td><code id="get.UD_+3A_method">method</code></td>
<td>
<p>Either &quot;lu&quot; (default) or &quot;limit&quot;.  See Details for a description of the two methods.
</p>
</td></tr>
<tr><td><code id="get.UD_+3A_start">start</code></td>
<td>
<p>A value for the starting distribution for the 'limit' method. Defaults to 1/num. cells. Ignored for method='lu'.</p>
</td></tr>
<tr><td><code id="get.UD_+3A_maxiter">maxiter</code></td>
<td>
<p>Total number of iterations for limit method if tolerance not reached first. Defaults to 100. Ignored for method='lu'.</p>
</td></tr>
<tr><td><code id="get.UD_+3A_tol">tol</code></td>
<td>
<p>Value used to assess convergence for limit method. If max(abs(pi1-pi0))&lt;tol, limit method has converged. Defaults to sqrt(.Machine$double.eps)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calculates the stationary distribution of the CTMC.  If method=&quot;lu&quot;, then the method used is the
method on pg. 455 of Harrod and Plemmons (1984).  If method=&quot;limit&quot;, then the stationary distribution is approximated by brute-force simulation.  If R is a sparse
Matrix object, then sparse matrix methods are used, making this
calculation extremely efficient.

</p>


<h3>Value</h3>

<p>Vector of the stationary distribution at each raster grid cell 
</p>



<h3>Author(s)</h3>

<p>Ephraim M. Hanks

</p>


<h3>References</h3>

<p>Harrod, W. J. &amp; Plemmons, R. J.  Comparison of some direct methods for
computing stationary distributions of Markov chains.  SIAM Journal on
Scientific and Statistical Computing, 1984, 5, 453-469
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For example code, do
##
## &gt; help(ctmcMove)
</code></pre>

<hr>
<h2 id='mcmc.fmove'>
Fit continuous-time functional movement model to telemetry data.
</h2><span id='topic+mcmc.fmove'></span>

<h3>Description</h3>

<p>Fits a functional movement model to telemetry data following Buderman
et al., 2015.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc.fmove(xy,t,fdabasis,tpred=t,QQ="CAR2",a=1,b=1,r=1,q=1,
           n.mcmc=100,num.paths.save=10,sigma.fixed=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.fmove_+3A_xy">xy</code></td>
<td>

<p>A two-column matrix with each row corresponding to the x,y locations
of a telemetry location.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_t">t</code></td>
<td>

<p>A numeric vector of length = nrow(xy), with the i-th entry corresponding
to the time of the i-th telemetry location in xy.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_fdabasis">fdabasis</code></td>
<td>

<p>A &quot;basisfd&quot; object, typically resulting from a call to
&quot;create.bspline.basis&quot; in the fda package.  Other basis functions
can be used.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_tpred">tpred</code></td>
<td>

<p>Numeric vector of times to impute the quasi-continuous path.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_qq">QQ</code></td>
<td>

<p>The precision matrix of the fda basis coefficients.  This can either
be a string, taking on values of &quot;CAR1&quot; or &quot;CAR2&quot;, or can be a user
specified matrix (or sparse matrix using the Matrix package) of
dimension equal to the number of basis functions in fdabasis.
Defaults to &quot;CAR2&quot;.  &quot;CAR1&quot; will result in less-smooth paths.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_a">a</code></td>
<td>

<p>The shape parameter of the inverse gamma prior on the observation
variance.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_b">b</code></td>
<td>

<p>The scale parameter of the inverse gamma prior on the observation
variance.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_r">r</code></td>
<td>

<p>The shape parameter of the inverse gamma prior on the partial sill
parameter of the spline basis coefficients.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_q">q</code></td>
<td>

<p>The scale parameter of the inverse gamma prior on the partial sill
parameter of the spline basis coefficients.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_n.mcmc">n.mcmc</code></td>
<td>

<p>Number of mcmc iterations to run.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_num.paths.save">num.paths.save</code></td>
<td>

<p>Number of quasi-continuous path realizations to save.  Defaults to
10.
</p>
</td></tr>
<tr><td><code id="mcmc.fmove_+3A_sigma.fixed">sigma.fixed</code></td>
<td>

<p>Numeric value (or the default NA).  If NA, then the observation
variance sigma^2 is estimated using MCMC.  If a numeric value, this
is the fixed standard deviation of the observation error.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits the functional movement model of Buderman et al., 2015, and
outputs quasi-continuous paths that stochastically interpolate between
telemetry locations.  The model fit is as follows (written out for 1-D):
</p>
<p>y_t = observed location at time t
</p>
<p>z_t = Sum_k beta_k*phi_k(t) = true location at time t, expressed using
a linear combination of spline basis functions phi_k(t).
</p>
<p>y_t ~ N( z_t , sigma^2 )
</p>
<p>beta ~ N( 0 , tau^2 * QQ^-1 )
</p>
<p>sigma^2 ~ IG(a,b)
</p>
<p>tau^2 ~ IG(r,q)
</p>


<h3>Value</h3>

<table>
<tr><td><code>s2.save</code></td>
<td>
<p>Numeric vector of the values of sigma^2 at each mcmc
iteration</p>
</td></tr>
<tr><td><code>tau2.save</code></td>
<td>
<p>Numeric vector of the values of tau^2 at each mcmc
iteration</p>
</td></tr>
<tr><td><code>pathlist</code></td>
<td>
<p>A list of length num.paths.save, with each item itself
being a list with two entries:
</p>
<p>xy = a matrix with rows corresponding to x,y locations of the
quasi-continuous path imputation
</p>
<p>t = a vector with entries corresponding to the times at which the
quasi-continuous path was imputed
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ephraim M. Hanks

</p>


<h3>References</h3>

<p>Buderman, F.E.; Hooten, M. B.; Ivan, J. S. and Shenk, T. M.  A
functional model for characterizing long-distance movement behavior.
Methods in Ecology and Evolution, 2016, 7, 264-273. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For example code, do
##
## &gt; help(ctmcMove)
</code></pre>

<hr>
<h2 id='path2ctmc'>
Function to turn a discrete-time continuous-space path into a CTMC path.

</h2><span id='topic+path2ctmc'></span>

<h3>Description</h3>

<p>This function takes a movement path defined by xyt values (not
necessarily equally spaced in time), and converts it into a CTMC path
(a continuous-time discrete-space path on grid cells in a raster).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path2ctmc(xy, t, rast,directions=4,zero.idx=integer(),print.iter=FALSE,
method="ShortestPath")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path2ctmc_+3A_xy">xy</code></td>
<td>

<p>A matrix of x,y locations at T time points.

</p>
</td></tr>
<tr><td><code id="path2ctmc_+3A_t">t</code></td>
<td>

<p>A vector of T times associated with the T locations in &quot;xy&quot;.
</p>
</td></tr>
<tr><td><code id="path2ctmc_+3A_rast">rast</code></td>
<td>

<p>A raster object or raster stack object that will define the
discrete-space grid cells for the CTMC movement path.
</p>
</td></tr>
<tr><td><code id="path2ctmc_+3A_directions">directions</code></td>
<td>

<p>Integer.  Either 4 (indicating a &quot;Rook's neighborhood&quot; of 4
neighboring grid cells) or 8 (indicating a
&quot;King's neighborhood&quot; of 8 neighboring grid cells).
</p>
</td></tr>
<tr><td><code id="path2ctmc_+3A_zero.idx">zero.idx</code></td>
<td>

<p>Integer vector of the indices of raster cells that are not passable
and should be excluded.  These are cells where movement should be
impossible.  Default is zero.idx=integer(). 
</p>
</td></tr>
<tr><td><code id="path2ctmc_+3A_print.iter">print.iter</code></td>
<td>

<p>Logical.  If true, then the progress stepping through each
observed location in &quot;xy&quot; and &quot;t&quot; will be output in the 
terminal.
</p>
</td></tr>
<tr><td><code id="path2ctmc_+3A_method">method</code></td>
<td>

<p>Specifies interpolation method.  Either &quot;ShortestPath&quot;, which uses
the shortest graphical path on the raster graph, or &quot;LinearInterp&quot;,
which linearly interpolates between observed locations.
&quot;ShortestPath&quot; is slower, slightly more accurate, and allows for
impassible barriers specified through &quot;zero.idx&quot;.  &quot;LinearInterp&quot; is
faster but does not allow for impassible barriers.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This takes a xyt path and turns it into a list of the embedded chain
and residence times of a continuous time Markov chain walk on the
graph.  A &quot;zero.idx&quot; indicates impassible grid cells.  When successive
(x,y) locations are not in the same grid cell, a shortest path between
locations is found using the &quot;shortestPath&quot; function from gdistance,
and the time between (x,y) locations is then 
evenly divided between all grid cells in the shortest path.  

</p>


<h3>Value</h3>

<table>
<tr><td><code>ec</code></td>
<td>
<p>A vector of the sequential grid cells (the embedded chain)
in the CTMC movement path</p>
</td></tr>
<tr><td><code>rt</code></td>
<td>
<p>A vector of residence times in each sequential grid cell in
the CTMC movement path</p>
</td></tr>
<tr><td><code>trans.times</code></td>
<td>
<p>A vector of times in which the movement path enters
the grid cell in &quot;ec&quot;.</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Ephraim M. Hanks

</p>


<h3>References</h3>

<p>Hanks, E. M.; Hooten, M. B. &amp; Alldredge, M. W. Continuous-time
Discrete-space Models for Animal Movement The Annals of Applied
Statistics, 2015, 9, 145-165
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For example code, do
##
## &gt; help(ctmcMove)
</code></pre>

<hr>
<h2 id='Pctmc'>
Transition Matrix of a CTMC.
</h2><span id='topic+Pctmc'></span>

<h3>Description</h3>

<p>Computes the transition matrix P(t) of a CTMC with given rate matrix (Q) and time (t).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pctmc(Q,t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pctmc_+3A_q">Q</code></td>
<td>

<p>A square matrix.  Either a rate matrix or the infinitessimal generator of the CTMC.
</p>
</td></tr>
<tr><td><code id="Pctmc_+3A_t">t</code></td>
<td>

<p>A numeric value - the time step.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the method of homogenization to compute the probability transition matrix given by exp(Q*t).
</p>


<h3>Value</h3>

<p>A square matrix P with entries P[i,j]=Prob(X(t)=j|X(0)=i)
</p>


<h3>Author(s)</h3>

<p>Ephraim M. Hanks

</p>


<h3>References</h3>

<p>Hanks, E. M.; Hooten, M. B. &amp; Alldredge, M. W. Continuous-time
Discrete-space Models for Animal Movement The Annals of Applied
Statistics, 2015, 9, 145-165
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For example code, do
##
## &gt; help(ctmcMove)
</code></pre>

<hr>
<h2 id='rast.grad'>
Creates gradient rasters from a raster object.
</h2><span id='topic+rast.grad'></span>

<h3>Description</h3>

<p>This function takes a raster stack or raster object and creates two
matrices for each raster layer, one which contains the x coordinates
of the gradient of the raster layer and one which contains the y
coordinates of the gradient of the raster layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rast.grad(rasterstack)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rast.grad_+3A_rasterstack">rasterstack</code></td>
<td>
<p>A raster layer or raster stack from package &quot;raster&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gradient is computed using the &quot;terrain&quot; function in raster.

</p>


<h3>Value</h3>

<table>
<tr><td><code>xy</code></td>
<td>
<p>A matrix of x and y coordinates of each cell in the raster
stack or raster layer.  The order is the order of the cells in the
raster object.</p>
</td></tr>
<tr><td><code>grad.x</code></td>
<td>
<p>a matrix where each column is the x-coordinates of the
gradient for one raster layer</p>
</td></tr>
<tr><td><code>grad.y</code></td>
<td>
<p>a matrix where each column is the y-coordinates of the
gradient for one raster layer</p>
</td></tr>
<tr><td><code>rast.grad.x</code></td>
<td>
<p>A raster stack where each raster layer is the
x-coordinates of the gradient for one covariate</p>
</td></tr>
<tr><td><code>rast.grad.y</code></td>
<td>
<p>A raster stack where each raster layer is the
x-coordinates of the gradient for one covariate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ephraim M. Hanks
</p>


<h3>References</h3>

<p>Hanks, E. M.; Hooten, M. B. &amp; Alldredge, M. W. Continuous-time
Discrete-space Models for Animal Movement The Annals of Applied
Statistics, 2015, 9, 145-165
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For example code, do
##
## &gt; help(ctmcMove)
</code></pre>

<hr>
<h2 id='seal'>
Data for one foraging trip by a male northern fur seal (NFS).
</h2><span id='topic+seal'></span>

<h3>Description</h3>

<p>seal$locs contains xyt locations for ARGOS fixes on the seal's
location in the &quot;datetime&quot;, &quot;latitude&quot;, and &quot;longitude&quot; columns.
</p>
<p>seal$cov.df contains a data.frame of spatial covariate values for sea surface
temperature (sst), chlorophyll A levels (chA) and net primary
production (npp).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("seal")</code></pre>


<h3>Format</h3>

<p>The format is:
</p>
<p>$ locs      :'data.frame':	163 obs. of  6 variables:
</p>
<p>..$ datetime  : num [1:163] 36741 36741 36741 36742 36742 ...
</p>
<p>..$ latitude  : num [1:163] 57.2 57.3 57.3 57.2 57.5 ...
</p>
<p>..$ longitude : num [1:163] 190 190 190 190 190 ...
</p>
<p>..$ landseamig: int [1:163] 0 1 1 1 1 1 1 1 1 1 ...
</p>
<p>..$ lqadjust  : int [1:163] 5 1 0 -2 -2 1 -2 -2 -2 -2 ...
</p>
<p>..$ lq        : Factor w/ 8 levels &quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,..: 5 2 1 7 7 2 7 7 7 7 ...
</p>
<p>$ sex       : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2
</p>
<p>$ cov.df    :List of 4
</p>
<p>..$ X       :'data.frame':	10000 obs. of  5 variables:
</p>
<p>.. ..$ x  : num [1:10000] 184 184 184 184 184 ...
</p>
<p>.. ..$ y  : num [1:10000] 56.7 56.7 56.7 56.7 56.7 ...
</p>
<p>.. ..$ chA: num [1:10000] 1.19 0.924 0.744 0.709 0.733 ...
</p>
<p>.. ..$ sst: num [1:10000] 9.07 10.35 10.27 10.43 9.98 ...
</p>
<p>.. ..$ pro: num [1:10000] 853 821 823 849 886 ...
</p>


<h3>Details</h3>

<p>Covariate Rasters and ARGOS telemetry data for one NFS
near the Pribilof islands.

</p>


<h3>Source</h3>

<p>Hanks, E.; Hooten, M.; Johnson, D. &amp; Sterling, J. Velocity-Based
Movement Modeling for Individual and Population Level Inference PLoS
ONE, Public Library of Science, 2011, 6, e22795
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## For example code, do
##
## &gt; help(ctmcmove)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
