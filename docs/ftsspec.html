<!DOCTYPE html><html><head><title>Help for package ftsspec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ftsspec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Epanechnikov_kernel'><p>The Epanechnikov weight function, with support in <code class="reqn">[-1,1]</code></p></a></li>
<li><a href='#ftsspec'><p>ftsspec: collection of functions  for estimating spectral density operator of functional time series (FTS) and comparing the spectral density operator of two functional time series, in a way that allows detection of differences of the spectral density operator in frequencies and along the curve length.</p></a></li>
<li><a href='#Generate_filterMA'><p>Generate the Filter of a multivariate MA process</p></a></li>
<li><a href='#Get_noise_sd'><p>Get the square root of the covariance matrix associated to a noise type</p></a></li>
<li><a href='#lines.SampleSpecDiffFreq'><p>Plotting function for <code>SampleSpecDiffFreq</code> class</p></a></li>
<li><a href='#Marginal_basis_pval'><p>Compute the marginal  p-values at each basis coefficients of for testing the equality of two spectral density kernels</p></a></li>
<li><a href='#plot.SampleSpec'><p>Plotting method for object inheriting from class <code>SampleSpec</code></p></a></li>
<li><a href='#plot.SampleSpecDiffFreq'><p>Plotting function for <code>SampleSpecDiffFreq</code> class</p></a></li>
<li><a href='#plot.SampleSpecDiffFreqCurvelength'><p>Plotting method for class <code>SampleSpecDiffFreqCurvelength</code></p></a></li>
<li><a href='#plot.SpecMA'><p>Plotting method for object inheriting from class <code>SpecMA</code></p></a></li>
<li><a href='#print.SampleSpecDiffFreqCurvelength'><p>Printing method for class <code>SampleSpecDiffFreqCurvelength</code></p></a></li>
<li><a href='#PvalAdjust'><p>Generic function to adjust pvalues</p></a></li>
<li><a href='#Simulate_new_MA'><p>Simulate a new Moving Average (MA) vector time series and return the time series</p></a></li>
<li><a href='#Spec'><p>Compute Spectral Density of Functional Time Series</p></a></li>
<li><a href='#Spec_compare_fixed_freq'><p>Test if two spectral density operators at  some  fixed frequency are equal.</p></a></li>
<li><a href='#Spec_compare_localize_freq'><p>Compare the spectral density operator of two Functional Time Series and localize frequencies at which they differ.</p></a></li>
<li><a href='#Spec_compare_localize_freq_curvelength'><p>Compare the spectral density operator of two Functional Time Series and localize frequencies at which they differ, and (spatial) regions where they differ</p></a></li>
<li><a href='#SpecMA'><p>'Spectral density operator of a MA vector process' Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spectral Density Estimation and Comparison for Functional Time
Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Shahin Tavakoli [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Shahin Tavakoli &lt;s.tavakoli@statslab.cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for estimating spectral density operator of functional
    time series (FTS) and comparing the spectral density operator of two
    functional time series, in a way that allows detection of differences of
    the spectral density operator in frequencies and along the curve length.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sna (&ge; 2.3-2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-09-08 09:02:39 UTC; st624</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-09-08 13:13:41</td>
</tr>
</table>
<hr>
<h2 id='Epanechnikov_kernel'>The Epanechnikov weight function, with support in <code class="reqn">[-1,1]</code></h2><span id='topic+Epanechnikov_kernel'></span>

<h3>Description</h3>

<p>The Epanechnikov weight function, with support in <code class="reqn">[-1,1]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Epanechnikov_kernel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Epanechnikov_kernel_+3A_x">x</code></td>
<td>
<p>argument at which the function is evaluated</p>
</td></tr>
</table>

<hr>
<h2 id='ftsspec'>ftsspec: collection of functions  for estimating spectral density operator of functional time series (FTS) and comparing the spectral density operator of two functional time series, in a way that allows detection of differences of the spectral density operator in frequencies and along the curve length.</h2><span id='topic+ftsspec'></span><span id='topic+ftsspec-package'></span>

<h3>Description</h3>

<p>ftsspec: collection of functions  for estimating spectral density operator of functional time series (FTS) and comparing the spectral density operator of two functional time series, in a way that allows detection of differences of the spectral density operator in frequencies and along the curve length.
</p>


<h3>References</h3>

<p><cite>Tavakoli, Shahin and Panaretos, Victor M. &quot;Detecting and Localizing Differences in Functional Time Series Dynamics: A Case Study in Molecular Biophysics&quot;, 2014, under revision</cite>
</p>

<hr>
<h2 id='Generate_filterMA'>Generate the Filter of a multivariate MA process</h2><span id='topic+Generate_filterMA'></span>

<h3>Description</h3>

<p>Generate the Filter of a multivariate MA process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Generate_filterMA(d.ts, d.n, MA.len = 3, ma.scale = rep(1, MA.len),
  a.smooth.coef = 0, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generate_filterMA_+3A_d.ts">d.ts</code></td>
<td>
<p>dimension of the (output) time series</p>
</td></tr>
<tr><td><code id="Generate_filterMA_+3A_d.n">d.n</code></td>
<td>
<p>dimension of the noise that is filtered</p>
</td></tr>
<tr><td><code id="Generate_filterMA_+3A_ma.len">MA.len</code></td>
<td>
<p>Length of the filter. Set to 3 by default.</p>
</td></tr>
<tr><td><code id="Generate_filterMA_+3A_ma.scale">ma.scale</code></td>
<td>
<p>scaling factor of each lag matrix. See details.</p>
</td></tr>
<tr><td><code id="Generate_filterMA_+3A_a.smooth.coef">a.smooth.coef</code></td>
<td>
<p>A coefficient to shrink coefficients of filter. Set to 0 by default.</p>
</td></tr>
<tr><td><code id="Generate_filterMA_+3A_seed">seed</code></td>
<td>
<p>The random seed used to generate the filter. Set to 1 by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>d.ts x d.n x MA.len</code> array
</p>


<h3>Details</h3>

<p>Generates a filter (i.e. a <code>d.ts x d.n x MA.len</code> array) for a moving
average process. The entries of the filter are generate randomly, but can be
reproduced by specifying the random seed <code>seed</code>.
</p>
<p>The <code>ma.scale</code> parameter should be a vector of length <code>MA.len</code>,
and corresponds to a scaling factor applied to each lag of the filter of the
MA process that is generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma.scale1=c(-1.4,2.3,-2)
a1=Generate_filterMA(10, 10, MA.len=3, ma.scale=ma.scale1, seed=10)
str(a1)
rm(a1)
</code></pre>

<hr>
<h2 id='Get_noise_sd'>Get the square root of the covariance matrix associated to a noise type</h2><span id='topic+Get_noise_sd'></span>

<h3>Description</h3>

<p>Get the square root of the covariance matrix associated to a noise type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Get_noise_sd(noise.type, d.n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Get_noise_sd_+3A_noise.type">noise.type</code></td>
<td>
<p>the type of noise that is driving the MA process. See Details section.</p>
</td></tr>
<tr><td><code id="Get_noise_sd_+3A_d.n">d.n</code></td>
<td>
<p>dimension of the noise that is filtered</p>
</td></tr>
</table>

<hr>
<h2 id='lines.SampleSpecDiffFreq'>Plotting function for <code>SampleSpecDiffFreq</code> class</h2><span id='topic+lines.SampleSpecDiffFreq'></span>

<h3>Description</h3>

<p>Plotting function for <code>SampleSpecDiffFreq</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SampleSpecDiffFreq'
lines(x, method = NA, Kmax = 4, pch = 20,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.SampleSpecDiffFreq_+3A_x">x</code></td>
<td>
<p>object of the class <code>SampleSpecDiffFreq</code></p>
</td></tr>
<tr><td><code id="lines.SampleSpecDiffFreq_+3A_method">method</code></td>
<td>
<p>method used to adjust p-values</p>
</td></tr>
<tr><td><code id="lines.SampleSpecDiffFreq_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of levels K for which the pvalues are plotted
(used only if autok==0)</p>
</td></tr>
<tr><td><code id="lines.SampleSpecDiffFreq_+3A_pch">pch</code></td>
<td>
<p>the plot character to be used</p>
</td></tr>
<tr><td><code id="lines.SampleSpecDiffFreq_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to plot()</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Spec_compare_localize_freq">Spec_compare_localize_freq</a></code>
</p>

<hr>
<h2 id='Marginal_basis_pval'>Compute the marginal  p-values at each basis coefficients of for testing the equality of two spectral density kernels</h2><span id='topic+Marginal_basis_pval'></span>

<h3>Description</h3>

<p>Compute the marginal  p-values at each basis coefficients of for testing the equality of two spectral density kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Marginal_basis_pval(spec1, spec2, m, kappa.square, is.pi.multiple)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Marginal_basis_pval_+3A_spec1">spec1</code></td>
<td>
<p>The two sample spectral densities (at the same frequency <code class="reqn">\omega</code>) to be compared.</p>
</td></tr>
<tr><td><code id="Marginal_basis_pval_+3A_spec2">spec2</code></td>
<td>
<p>The two sample spectral densities (at the same frequency <code class="reqn">\omega</code>) to be compared.</p>
</td></tr>
<tr><td><code id="Marginal_basis_pval_+3A_m">m</code></td>
<td>
<p>The number of Fourier frequencies over which the periodogram
operator was smoothed.</p>
</td></tr>
<tr><td><code id="Marginal_basis_pval_+3A_kappa.square">kappa.square</code></td>
<td>
<p>the L2-norm of the weight function used to estimate the
spectral density operator</p>
</td></tr>
<tr><td><code id="Marginal_basis_pval_+3A_is.pi.multiple">is.pi.multiple</code></td>
<td>
<p>A logical variable, to specify if <code class="reqn">\omega = {0, \pi}</code> or not.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.SampleSpec'>Plotting method for object inheriting from class <code>SampleSpec</code></h2><span id='topic+plot.SampleSpec'></span>

<h3>Description</h3>

<p>Plotting method for object inheriting from class <code>SampleSpec</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SampleSpec'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SampleSpec_+3A_x">x</code></td>
<td>
<p>An object of the class <code>SampleSpec</code></p>
</td></tr>
<tr><td><code id="plot.SampleSpec_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to plot()</p>
</td></tr>
</table>

<hr>
<h2 id='plot.SampleSpecDiffFreq'>Plotting function for <code>SampleSpecDiffFreq</code> class</h2><span id='topic+plot.SampleSpecDiffFreq'></span>

<h3>Description</h3>

<p>Plotting function for <code>SampleSpecDiffFreq</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SampleSpecDiffFreq'
plot(x, method = NA, Kmax = 4, pch = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SampleSpecDiffFreq_+3A_x">x</code></td>
<td>
<p>object of the class <code>SampleSpecDiffFreq</code></p>
</td></tr>
<tr><td><code id="plot.SampleSpecDiffFreq_+3A_method">method</code></td>
<td>
<p>method used to adjust p-values</p>
</td></tr>
<tr><td><code id="plot.SampleSpecDiffFreq_+3A_kmax">Kmax</code></td>
<td>
<p>maximum number of levels K for which the pvalues are plotted
(used only if autok==0)</p>
</td></tr>
<tr><td><code id="plot.SampleSpecDiffFreq_+3A_pch">pch</code></td>
<td>
<p>the plot character to be used</p>
</td></tr>
<tr><td><code id="plot.SampleSpecDiffFreq_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to plot()</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Spec_compare_localize_freq">Spec_compare_localize_freq</a></code>
</p>

<hr>
<h2 id='plot.SampleSpecDiffFreqCurvelength'>Plotting method for class <code>SampleSpecDiffFreqCurvelength</code></h2><span id='topic+plot.SampleSpecDiffFreqCurvelength'></span>

<h3>Description</h3>

<p>Plotting method for class <code>SampleSpecDiffFreqCurvelength</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SampleSpecDiffFreqCurvelength'
plot(x, ncolumns = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SampleSpecDiffFreqCurvelength_+3A_x">x</code></td>
<td>
<p>Object of the class <code>SampleSpecDiffFreqCurvelength</code></p>
</td></tr>
<tr><td><code id="plot.SampleSpecDiffFreqCurvelength_+3A_ncolumns">ncolumns</code></td>
<td>
<p>number of columns for the plots</p>
</td></tr>
<tr><td><code id="plot.SampleSpecDiffFreqCurvelength_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <code>plot()</code></p>
</td></tr>
</table>

<hr>
<h2 id='plot.SpecMA'>Plotting method for object inheriting from class <code>SpecMA</code></h2><span id='topic+plot.SpecMA'></span>

<h3>Description</h3>

<p>Plotting method for object inheriting from class <code>SpecMA</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpecMA'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SpecMA_+3A_x">x</code></td>
<td>
<p>A object of the class <code>SpecMA</code></p>
</td></tr>
<tr><td><code id="plot.SpecMA_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to plot()</p>
</td></tr>
</table>

<hr>
<h2 id='print.SampleSpecDiffFreqCurvelength'>Printing method for class <code>SampleSpecDiffFreqCurvelength</code></h2><span id='topic+print.SampleSpecDiffFreqCurvelength'></span>

<h3>Description</h3>

<p>Printing method for class <code>SampleSpecDiffFreqCurvelength</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SampleSpecDiffFreqCurvelength'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SampleSpecDiffFreqCurvelength_+3A_x">x</code></td>
<td>
<p>Object of the class <code>SampleSpecDiffFreqCurvelength</code></p>
</td></tr>
<tr><td><code id="print.SampleSpecDiffFreqCurvelength_+3A_...">...</code></td>
<td>
<p>Additional arguments for print</p>
</td></tr>
</table>

<hr>
<h2 id='PvalAdjust'>Generic function to adjust pvalues</h2><span id='topic+PvalAdjust'></span><span id='topic+PvalAdjust.SampleSpecDiffFreq'></span>

<h3>Description</h3>

<p>Generic function to adjust pvalues
</p>
<p>function to adjust pvalues for class <code>SampleSpecDiffFreq</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PvalAdjust(sample.spec.diff, method)

## S3 method for class 'SampleSpecDiffFreq'
PvalAdjust(sample.spec.diff, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PvalAdjust_+3A_sample.spec.diff">sample.spec.diff</code></td>
<td>
<p>Object of the class
<code>SampleSpecDiffFreq</code></p>
</td></tr>
<tr><td><code id="PvalAdjust_+3A_method">method</code></td>
<td>
<p>method used to adjust p-values</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Spec_compare_localize_freq">Spec_compare_localize_freq</a></code>
</p>

<hr>
<h2 id='Simulate_new_MA'>Simulate a new Moving Average (MA) vector time series and return the time series</h2><span id='topic+Simulate_new_MA'></span>

<h3>Description</h3>

<p>Simulate a new Moving Average (MA) vector time series and return the time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Simulate_new_MA(a, T.len, noise.type, DEBUG = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Simulate_new_MA_+3A_a">a</code></td>
<td>
<p>Array, returned by <code>Generate_filterMA</code>, containing the filter of the MA process</p>
</td></tr>
<tr><td><code id="Simulate_new_MA_+3A_t.len">T.len</code></td>
<td>
<p>Numeric, the length of the time series to generate</p>
</td></tr>
<tr><td><code id="Simulate_new_MA_+3A_noise.type">noise.type</code></td>
<td>
<p>the type of noise that is driving the MA process. See Details section.</p>
</td></tr>
<tr><td><code id="Simulate_new_MA_+3A_debug">DEBUG</code></td>
<td>
<p>Logical, for outputting information on the progress of the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>T.len x dim(a)[1]</code> matrix, where each column corresponds to a
coordinate of the vector time series
</p>


<h3>Details</h3>

<p>The function simulates a moving average process of dimension
<code>dim(a)[1]</code>, defined by </p>
<p style="text-align: center;"><code class="reqn">X[t,] =  a[,,1]  * epsilon[,t-1] + a[,,2]
* epsilon[,t-2] + ... + a[,,dim(a)[3]] * epsilon[t-dim(a)[3]]  </code>
</p>

<p><code>noise.type</code> specifies the nature and internal correlation of the noise
that is driving the MA process. It can take the values
</p>

<dl>
<dt><code>white-noise</code></dt><dd><p> the noise is Gaussian with covariance matrix identity</p>
</dd>
<dt><code>white-noise</code></dt><dd><p>the noise is Gaussian with diagonal covariance
matrix, whose j-th diagonal entry is <code class="reqn">((j - 0.5 )*pi)^(-1)</code></p>
</dd>
<dt><code>studentk</code></dt><dd><p>the coordinates  of the noise are independent and
have a student t distribution with 'k' degrees of freedom, standardized to
have variance 1</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>ma.scale1=c(-1.4,2.3,-2)
a1=Generate_filterMA(6, 6, MA.len=3, ma.scale=ma.scale1)
X=Simulate_new_MA(a1, T.len=512, noise.type='wiener')
plot.ts(X)
</code></pre>

<hr>
<h2 id='Spec'>Compute Spectral Density of Functional Time Series</h2><span id='topic+Spec'></span>

<h3>Description</h3>

<p>This function estimates the spectral density operator of a Functional Time Series (FTS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spec(X, W = Epanechnikov_kernel, B.T = (dim(X)[1])^(-1/5),
  only.diag = FALSE, trace = FALSE, demean = TRUE, subgrid = FALSE,
  subgrid.density = 10, verbose = 0,
  subgrid.density.relative.to.bandwidth = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spec_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">T \times nbasis</code> matrix of containing the coordinates of the FTS
expressed in a basis. Each row corresponds to a time point, and each column
corresponds to the coefficient of the corresponding basis function of the  FTS.</p>
</td></tr>
<tr><td><code id="Spec_+3A_w">W</code></td>
<td>
<p>The weight function used to smooth the periodogram operator. Set by
default to be the Epanechnikov kernel</p>
</td></tr>
<tr><td><code id="Spec_+3A_b.t">B.T</code></td>
<td>
<p>The bandwidth of frequencies over which the periodogram operator
is smoothed. If <code>B.T=0</code>,  the periodogram operator is returned.</p>
</td></tr>
<tr><td><code id="Spec_+3A_only.diag">only.diag</code></td>
<td>
<p>A logical variable to choose if the function only computes
the marginal spectral density of each basis coordinate
(<code>only.diag=TRUE</code>). <code>only.diag=FALSE</code> by default, the full spectral
density operator is computed .</p>
</td></tr>
<tr><td><code id="Spec_+3A_trace">trace</code></td>
<td>
<p>A logical variable to choose if only the trace of the spectral
density operator is computed. <code>trace=FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="Spec_+3A_demean">demean</code></td>
<td>
<p>A logical variable to choose if the FTS is centered before
computing its spectral density operator.</p>
</td></tr>
<tr><td><code id="Spec_+3A_subgrid">subgrid</code></td>
<td>
<p>A logical variable to choose if the spectral density operator
is only returned for a subgrid of the Fourier frequencies, which can be
useful in large datasets to reduce memory usage. <code>subgrid=FALSE</code> by
default.</p>
</td></tr>
<tr><td><code id="Spec_+3A_subgrid.density">subgrid.density</code></td>
<td>
<p>Only used if <code>subgrid=TRUE</code>. Specifies the
approximate number of frequencies within the bandwidth over which the
periodogram operator is smoothed.</p>
</td></tr>
<tr><td><code id="Spec_+3A_verbose">verbose</code></td>
<td>
<p>A  variable to show the progress of the computations. By
default, <code>verbose=0</code>.</p>
</td></tr>
<tr><td><code id="Spec_+3A_subgrid.density.relative.to.bandwidth">subgrid.density.relative.to.bandwidth</code></td>
<td>
<p>logical parameter to specify if
<code>subgrid.density</code> is specified relative to the bandwidth parameter <code>B.T</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>spec</dt><dd><p>The estimated spectral density operator. The first dimension corresponds to the different frequencies over which the spectral density operators are estimated.</p>
</dd>
<dt>omega</dt><dd><p>The frequencies over which the spectral density is estimated.</p>
</dd>
<dt>m</dt><dd><p>The number of Fourier frequencies over which the periodogram operator was smoothed.</p>
</dd>
<dt>bw</dt><dd><p>The equivalent Bandwidth used in the weight function W(), as defined in Bloomfield (1976, p.201).</p>
</dd>
<dt>weight</dt><dd><p>The weight function used to smooth the periodogram operator.</p>
</dd>
<dt>kappa.square</dt><dd><p>The L2 norm of the weight function W.</p>
</dd>
</dl>



<h3>References</h3>

<p><a href="stats.html#topic+spec.pgram">spec.pgram</a> function of R.
</p>
<p><cite> Bloomfield, P. (1976) &quot;Fourier Analysis of Time Series:
An Introduction&quot;, Wiley.</cite>
</p>
<p><cite>Panaretos, V. M. and Tavakoli, S., &quot;Fourier Analysis of Functional Time Series&quot;, Ann. Statist. Volume 41, Number 2 (2013), 568-603.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma.scale1=c(-1.4,2.3,-2)
a1=Generate_filterMA(10, 10, MA.len=3, ma.scale=ma.scale1)
X=Simulate_new_MA(a1, T.len=512, noise.type='wiener')
ans=Spec(X, trace=FALSE, only.diag=FALSE)
plot(ans)
plot(Spec(X, trace=FALSE, only.diag=FALSE, subgrid=TRUE, subgrid.density=10,
subgrid.density.relative.to.bandwidth=FALSE))
rm(ans)
</code></pre>

<hr>
<h2 id='Spec_compare_fixed_freq'>Test if two spectral density operators at  some  fixed frequency are equal.</h2><span id='topic+Spec_compare_fixed_freq'></span>

<h3>Description</h3>

<p>A test for the null hypothesis that two spectral density operators (at the
same frequency <code class="reqn">\omega</code>) are equal, using a pseudo-AIC criterion for the
choice of the truncation parameter. (used in
<code><a href="#topic+Spec_compare_localize_freq">Spec_compare_localize_freq</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spec_compare_fixed_freq(spec1, spec2, is.pi.multiple, m, kappa.square,
  autok = 2, K.fixed = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spec_compare_fixed_freq_+3A_spec1">spec1</code>, <code id="Spec_compare_fixed_freq_+3A_spec2">spec2</code></td>
<td>
<p>The two sample spectral densities (at the same frequency <code class="reqn">\omega</code>) to be compared.</p>
</td></tr>
<tr><td><code id="Spec_compare_fixed_freq_+3A_is.pi.multiple">is.pi.multiple</code></td>
<td>
<p>A logical variable, to specify if <code class="reqn">\omega = {0, \pi}</code> or not.</p>
</td></tr>
<tr><td><code id="Spec_compare_fixed_freq_+3A_m">m</code></td>
<td>
<p>The number of Fourier frequencies over which the periodogram
operator was smoothed.</p>
</td></tr>
<tr><td><code id="Spec_compare_fixed_freq_+3A_kappa.square">kappa.square</code></td>
<td>
<p>the L2-norm of the weight function used to estimate the
spectral density operator</p>
</td></tr>
<tr><td><code id="Spec_compare_fixed_freq_+3A_autok">autok</code></td>
<td>
<p>A variable used to specify if (and which) pseudo-AIC criterion
is used to select the truncation parameter <code class="reqn">K</code>.</p>
</td></tr>
<tr><td><code id="Spec_compare_fixed_freq_+3A_k.fixed">K.fixed</code></td>
<td>
<p>The value of K used if <code>autok=0</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p><cite>Tavakoli, Shahin and Panaretos, Victor M. &quot;Detecting and Localizing Differences in Functional Time Series Dynamics: A Case Study in Molecular Biophysics&quot;, 2014, under revision</cite>
</p>
<p><cite>Panaretos, Victor M., David Kraus, and John H. Maddocks.
&quot;Second-order comparison of Gaussian random functions and the geometry of
DNA minicircles.&quot; Journal of the American Statistical Association 105.490
(2010): 670-682.</cite>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Spec_compare_localize_freq">Spec_compare_localize_freq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma.scale2=ma.scale1=c(-1.4,2.3,-2)
ma.scale2[3] = ma.scale1[3]+.3
a1=Generate_filterMA(10, 10, MA.len=3, ma.scale=ma.scale1)
a2=Generate_filterMA(10, 10, MA.len=3, ma.scale=ma.scale2)
X=Simulate_new_MA(a1, T.len=512, noise.type='wiener')
Y=Simulate_new_MA(a2, T.len=512, noise.type='wiener')
spec.X = Spec(X)
spec.Y = Spec(Y)
Spec_compare_fixed_freq(spec.X$spec[1,,], spec.Y$spec[1,,],
is.pi.multiple=TRUE, spec.X$m, spec.X$kappa.square)
</code></pre>

<hr>
<h2 id='Spec_compare_localize_freq'>Compare the spectral density operator of two Functional Time Series and localize frequencies at which they differ.</h2><span id='topic+Spec_compare_localize_freq'></span>

<h3>Description</h3>

<p>Compare the spectral density operator of two Functional Time Series and localize frequencies at which they differ.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spec_compare_localize_freq(X, Y, B.T = (dim(X)[1])^(-1/5), W, autok = 2,
  subgrid.density, verbose = 0, demean = FALSE, K.fixed = NA,
  subgrid.density.relative.to.bandwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spec_compare_localize_freq_+3A_x">X</code>, <code id="Spec_compare_localize_freq_+3A_y">Y</code></td>
<td>
<p>The <code class="reqn">T \times nbasis</code> matrices of containing the coordinates, expressed in some functional basis,  of the two FTS that to be compared.
expressed in a basis.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_+3A_b.t">B.T</code></td>
<td>
<p>The bandwidth of frequencies over which the periodogram operator
is smoothed. If <code>B.T=0</code>,  the periodogram operator is returned.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_+3A_w">W</code></td>
<td>
<p>The weight function used to smooth the periodogram operator. Set by
default to be the Epanechnikov kernel</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_+3A_autok">autok</code></td>
<td>
<p>A variable used to specify if (and which) pseudo-AIC criterion
is used to select the truncation parameter <code class="reqn">K</code>.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_+3A_subgrid.density">subgrid.density</code></td>
<td>
<p>Only used if <code>subgrid=TRUE</code>. Specifies the
approximate number of frequencies within the bandwidth over which the
periodogram operator is smoothed.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_+3A_verbose">verbose</code></td>
<td>
<p>A  variable to show the progress of the computations. By
default, <code>verbose=0</code>.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_+3A_demean">demean</code></td>
<td>
<p>A logical variable to choose if the FTS is centered before
computing its spectral density operator.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_+3A_k.fixed">K.fixed</code></td>
<td>
<p>The value of K used if <code>autok=0</code>.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_+3A_subgrid.density.relative.to.bandwidth">subgrid.density.relative.to.bandwidth</code></td>
<td>
<p>logical parameter to specify if
<code>subgrid.density</code> is specified relative to the bandwidth parameter <code>B.T</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>X,Y</code> must be of equal size <code class="reqn">T.len \times d</code>, where T.len is the length of the time series, and <code class="reqn">d</code> is the number of basis functions. Each row corresponds to a time point, and each column
corresponds to the coefficient of the corresponding basis function of the  FTS.
</p>
<p><code>autok=0</code> returns the p-values for <code class="reqn">K=1, \ldots, \code{K.fixed}</code>.
<code>autok=1</code> uses the <code>AIC</code> criterion of Tavakoli \&amp; Panaretos
(2015), which is a generalization of the pseudo-AIC introduced in Panaretos
et al (2010).
<code>autok=2</code> uses the <code>AIC*</code> criterion of Tavakoli \&amp; Panaretos
(2015), which is an extension of the <code>AIC</code> criterion that takes into
account the difficulty associated with the estimation of eigenvalues of a
compact operator.
</p>


<h3>References</h3>

<p><cite>Tavakoli, Shahin and Panaretos, Victor M. &quot;Detecting and Localizing Differences in Functional Time Series Dynamics: A Case Study in Molecular Biophysics&quot;, 2014, under revision</cite>
</p>
<p><cite>Panaretos, Victor M., David Kraus, and John H. Maddocks.
&quot;Second-order comparison of Gaussian random functions and the geometry of
DNA minicircles.&quot; Journal of the American Statistical Association 105.490
(2010): 670-682.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ma.scale2=ma.scale1=c(-1.4,2.3,-2)
ma.scale2[3] = ma.scale1[3]+.0
a1=Generate_filterMA(10, 10, MA.len=3, ma.scale=ma.scale1)
a2=Generate_filterMA(10, 10, MA.len=3, ma.scale=ma.scale2)
X=Simulate_new_MA(a1, T.len=512, noise.type='wiener')
Y=Simulate_new_MA(a2, T.len=512, noise.type='wiener')
ans0=Spec_compare_localize_freq(X, Y, W=Epanechnikov_kernel, autok=2,
subgrid.density=10, verbose=0, demean=FALSE,
subgrid.density.relative.to.bandwidth=TRUE)
plot(ans0)
plot(ans0, method='fdr')
PvalAdjust(ans0, method='fdr') ## print FDR adjusted p-values
abline(h=.05, lty=3)
ans0=Spec_compare_localize_freq(X, Y, W=Epanechnikov_kernel, autok=0,
subgrid.density=10, verbose=0, demean=FALSE,
subgrid.density.relative.to.bandwidth=TRUE, K.fixed=4) ## fixed values of K
plot(ans0)
plot(ans0, 'fdr')
plot(ans0, 'holm')
PvalAdjust(ans0, method='fdr')
rm(ans0)
</code></pre>

<hr>
<h2 id='Spec_compare_localize_freq_curvelength'>Compare the spectral density operator of two Functional Time Series and localize frequencies at which they differ, and (spatial) regions where they differ</h2><span id='topic+Spec_compare_localize_freq_curvelength'></span>

<h3>Description</h3>

<p>Compare the spectral density operator of two Functional Time Series and localize frequencies at which they differ, and (spatial) regions where they differ
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spec_compare_localize_freq_curvelength(X, Y, B.T = (dim(X)[1])^(-1/5), W,
  alpha = 0.05, accept = 0, reject = 1, verbose = 0, demean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spec_compare_localize_freq_curvelength_+3A_x">X</code></td>
<td>
<p>The <code class="reqn">T \times nbasis</code> matrices of containing the coordinates, expressed in some functional basis,  of the two FTS that to be compared.
expressed in a basis.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_curvelength_+3A_y">Y</code></td>
<td>
<p>The <code class="reqn">T \times nbasis</code> matrices of containing the coordinates, expressed in some functional basis,  of the two FTS that to be compared.
expressed in a basis.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_curvelength_+3A_b.t">B.T</code></td>
<td>
<p>The bandwidth of frequencies over which the periodogram operator
is smoothed. If <code>B.T=0</code>,  the periodogram operator is returned.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_curvelength_+3A_w">W</code></td>
<td>
<p>The weight function used to smooth the periodogram operator. Set by
default to be the Epanechnikov kernel</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_curvelength_+3A_alpha">alpha</code></td>
<td>
<p>level for the test</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_curvelength_+3A_accept">accept</code>, <code id="Spec_compare_localize_freq_curvelength_+3A_reject">reject</code></td>
<td>
<p>values for accepted, rejected regions</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_curvelength_+3A_verbose">verbose</code></td>
<td>
<p>A  variable to show the progress of the computations. By
default, <code>verbose=0</code>.</p>
</td></tr>
<tr><td><code id="Spec_compare_localize_freq_curvelength_+3A_demean">demean</code></td>
<td>
<p>A logical variable to choose if the FTS is centered before
computing its spectral density operator.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ma.scale2=ma.scale1=c(-1.4,2.3,-2)
ma.scale2[3] = ma.scale1[3]+.4
a1=Generate_filterMA(10, 10, MA.len=3, ma.scale=ma.scale1)
a2=Generate_filterMA(10, 10, MA.len=3, ma.scale=ma.scale2)
X=Simulate_new_MA(a1, T.len=2^9, noise.type='wiener')
Y=Simulate_new_MA(a2, T.len=2^9, noise.type='wiener')
ans0=Spec_compare_localize_freq_curvelength(X, Y, W=Epanechnikov_kernel, alpha=.01, demean=TRUE)
print(ans0)
plot(ans0)
rm(ma.scale1, ma.scale2, a1, a2, X, Y, ans0)
</code></pre>

<hr>
<h2 id='SpecMA'>'Spectral density operator of a MA vector process' Object</h2><span id='topic+SpecMA'></span>

<h3>Description</h3>

<p>'Spectral density operator of a MA vector process' Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpecMA(a, nfreq = 2^9, noise.type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpecMA_+3A_a">a</code></td>
<td>
<p>the filter of the moving average</p>
</td></tr>
<tr><td><code id="SpecMA_+3A_nfreq">nfreq</code></td>
<td>
<p>the number of frequencies between 0 and pi at which the
spectral density has to be computed</p>
</td></tr>
<tr><td><code id="SpecMA_+3A_noise.type">noise.type</code></td>
<td>
<p>the type of noise that is driving the MA process. See
<code><a href="#topic+Simulate_new_MA">Simulate_new_MA</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ma.scale1=c(-1.4,2.3,-2)
a1=Generate_filterMA(6, 6, MA.len=3, ma.scale=ma.scale1)
a1.spec=SpecMA(a1, nfreq=512, noise.type='wiener')
plot(a1.spec)
rm(a1, a1.spec)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
