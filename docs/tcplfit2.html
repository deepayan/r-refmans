<!DOCTYPE html><html><head><title>Help for package tcplfit2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tcplfit2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acgnlsobj'><p>AC GNLS Objective Function</p></a></li>
<li><a href='#acy'><p>Activity Concentration y</p></a></li>
<li><a href='#bmdbounds'><p>BMD Bounds</p></a></li>
<li><a href='#bmdobj'><p>BMD Objective Function</p></a></li>
<li><a href='#cnst'><p>Constant Model</p></a></li>
<li><a href='#concRespCore'><p>Concentration Response Core</p></a></li>
<li><a href='#concRespPlot'><p>Concentration Response Plot</p></a></li>
<li><a href='#exp2'><p>Exponential 2 Model</p></a></li>
<li><a href='#exp3'><p>Exponential 3 Model</p></a></li>
<li><a href='#exp4'><p>Exponential 4 Model</p></a></li>
<li><a href='#exp5'><p>Exponential 5 Model</p></a></li>
<li><a href='#fitcnst'><p>Constant Model Fit</p></a></li>
<li><a href='#fitexp2'><p>Exponential 2 Model Fit</p></a></li>
<li><a href='#fitexp3'><p>Exponential 3 Model Fit</p></a></li>
<li><a href='#fitexp4'><p>Exponential 4 Model Fit</p></a></li>
<li><a href='#fitexp5'><p>Exponential 5 Model Fit</p></a></li>
<li><a href='#fitgnls'><p>Gain-Loss Model Fit</p></a></li>
<li><a href='#fithill'><p>Hill Model Fit</p></a></li>
<li><a href='#fitpoly1'><p>Polynomial 1 (Linear) Model Fit</p></a></li>
<li><a href='#fitpoly2'><p>Polynomial 2 (Quadratic) Model Fit</p></a></li>
<li><a href='#fitpow'><p>Power Model Fit</p></a></li>
<li><a href='#gnls'><p>Gain-Loss Model</p></a></li>
<li><a href='#gnlsderivobj'><p>GNLS Derivative Objective Function</p></a></li>
<li><a href='#hillfn'><p>Hill Model</p></a></li>
<li><a href='#hitcont'><p>Continuous Hitcalls</p></a></li>
<li><a href='#hitcontinner'><p>Continuous Hitcalls Inner</p></a></li>
<li><a href='#hitlogic'><p>Hit Logic (Discrete)</p></a></li>
<li><a href='#hitloginner'><p>Hit Logic Inner (Discrete)</p></a></li>
<li><a href='#loggnls'><p>Log Gain-Loss Model</p></a></li>
<li><a href='#loghill'><p>Log Hill Model</p></a></li>
<li><a href='#mc0'><p>Sample multi-concentration data set from invitrodb</p></a></li>
<li><a href='#mc3'><p>Sample concentration-response data set from invitrodb</p></a></li>
<li><a href='#nestselect'><p>Nest Select</p></a></li>
<li><a href='#poly1'><p>Polynomial 1 Model</p></a></li>
<li><a href='#poly2'><p>Polynomial 2 Model</p></a></li>
<li><a href='#pow'><p>Power Model</p></a></li>
<li><a href='#signatures'><p>Sample concentration-response data set from HTTR</p></a></li>
<li><a href='#tcplfit2_core'><p>Concentration-response curve fitting</p></a></li>
<li><a href='#tcplhit2_core'><p>Hitcalling Function</p></a></li>
<li><a href='#tcplObj'><p>Concentration Response Objective Function</p></a></li>
<li><a href='#toplikelihood'><p>Top Likelihood</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Concentration-Response Modeling of HTS or Transcriptomics Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs the basic concentration response curve fitting used 
    in the 'tcpl' package. It is a substitute for the original tcplFit() function 
    (and sub-functions) and allows a wider variety of concentration-response models. 
    All of the models included in the 'BMDExpress' package are now part of this package,
    and the output includes a calculation of the bmd (Benchmark Dose or concentration) 
    value.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, stringi, DT, data.table, tcpl, prettydoc</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, methods, numDeriv, RColorBrewer, stringr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-10 18:11:28 UTC; jbrown20</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Sheffield [aut],
  Richard Judson [ctb],
  Jason Brown [ctb, cre],
  Sarah E. Davidson [ctb],
  Zhihui Zhao [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jason Brown &lt;brown.jason@epa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-10 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='acgnlsobj'>AC GNLS Objective Function</h2><span id='topic+acgnlsobj'></span>

<h3>Description</h3>

<p>GNLS objective function set to y for gnls solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acgnlsobj(x, y, tp, ga, p, la, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acgnlsobj_+3A_x">x</code></td>
<td>
<p>Concentration.</p>
</td></tr>
<tr><td><code id="acgnlsobj_+3A_y">y</code></td>
<td>
<p>Desired activity level.</p>
</td></tr>
<tr><td><code id="acgnlsobj_+3A_tp">tp</code></td>
<td>
<p>Top.</p>
</td></tr>
<tr><td><code id="acgnlsobj_+3A_ga">ga</code></td>
<td>
<p>Gain AC50.</p>
</td></tr>
<tr><td><code id="acgnlsobj_+3A_p">p</code></td>
<td>
<p>Gain power.</p>
</td></tr>
<tr><td><code id="acgnlsobj_+3A_la">la</code></td>
<td>
<p>Loss AC50.</p>
</td></tr>
<tr><td><code id="acgnlsobj_+3A_q">q</code></td>
<td>
<p>Loss power.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Difference between GNLS model repsone at x and y.
</p>

<hr>
<h2 id='acy'>Activity Concentration y</h2><span id='topic+acy'></span>

<h3>Description</h3>

<p>Returns concentration at which model equals y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acy(
  y,
  modpars,
  type = "hill",
  returntop = FALSE,
  returntoploc = FALSE,
  getloss = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acy_+3A_y">y</code></td>
<td>
<p>Activity value at which the concentration is desired. y
should be less than the model's top, if there is one, and greater
than zero.</p>
</td></tr>
<tr><td><code id="acy_+3A_modpars">modpars</code></td>
<td>
<p>List of named model parameters. Model parameters can
include: &quot;a&quot;, &quot;b&quot;, &quot;ga&quot;, &quot;la&quot;, &quot;p&quot;, &quot;q&quot;, &quot;tp&quot;. ga and la should NOT
be in log units.</p>
</td></tr>
<tr><td><code id="acy_+3A_type">type</code></td>
<td>
<p>Model type; must be one of: &quot;exp1&quot;, &quot;exp2&quot;, &quot;exp3&quot;, &quot;exp4&quot;,
&quot;gnls&quot;, &quot;hill&quot;,  &quot;poly1&quot;, &quot;poly2&quot;, &quot;pow&quot;.</p>
</td></tr>
<tr><td><code id="acy_+3A_returntop">returntop</code></td>
<td>
<p>When TRUE, returns actual top value for gnls. Has no
effect for other models.</p>
</td></tr>
<tr><td><code id="acy_+3A_returntoploc">returntoploc</code></td>
<td>
<p>When TRUE, returns concentration of top for gnls.
Has no effect for other models. If top location can't be found,
NA is returned.</p>
</td></tr>
<tr><td><code id="acy_+3A_getloss">getloss</code></td>
<td>
<p>When TRUE, returns value on loss side of curve for gnls.
Has no effect for other models.</p>
</td></tr>
<tr><td><code id="acy_+3A_verbose">verbose</code></td>
<td>
<p>When TRUE, shows warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mathematically inverts model functions of the given type, except for gnls,
which is numerically inverted. gnls returns NA when y &gt; tp. Other options
return the actual top (as opposed to theoretical tp) and top location for
gnls model. gnls model defaults to giving concentration on gain side. Only
one of getloss, returntop, and returntoploc should be TRUE at a time.  If
top location solution fails for gnls, top is set to tp. Returns NA if gnls
numerical solver fails. Returns NA if model was not successfully fit.
</p>


<h3>Value</h3>

<p>Ouputs concentration at activity y, or gnls top or top concentration,
when applicable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acy(1, list(ga = 10, tp = 2, p = 3), type = "hill")
acy(1, list(ga = .1, tp = 2, p = 3, q = 3,la = 10), type = "gnls")
acy(1, list(ga = .1, tp = 2, p = 3, q = 3,la = 10), type = "gnls", getloss = TRUE)
acy(1, list(ga = .1, tp = 2, p = 3, q = 3,la = 10), type = "gnls", returntop = TRUE)
acy(1, list(ga = .1, tp = 2, p = 3, q = 3,la = 10), type = "gnls", returntoploc = TRUE)

</code></pre>

<hr>
<h2 id='bmdbounds'>BMD Bounds</h2><span id='topic+bmdbounds'></span>

<h3>Description</h3>

<p>Uses maximum likelihood method to tune the upper and lower bounds on the BMD (BMDU, BMDL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmdbounds(
  fit_method,
  bmr,
  pars,
  conc,
  resp,
  onesidedp = 0.05,
  bmd = NULL,
  which.bound = "lower"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmdbounds_+3A_fit_method">fit_method</code></td>
<td>
<p>Fit method: &quot;exp2&quot;, &quot;exp3&quot;, &quot;exp4&quot;, &quot;exp5&quot;, &quot;hill&quot;, &quot;gnls&quot;,
&quot;poly1&quot;, &quot;poly2&quot;, or &quot;pow&quot;.</p>
</td></tr>
<tr><td><code id="bmdbounds_+3A_bmr">bmr</code></td>
<td>
<p>Benchmark response.</p>
</td></tr>
<tr><td><code id="bmdbounds_+3A_pars">pars</code></td>
<td>
<p>Named vector of model parameters: a,b,tp,ga,p,la,q,er output by
httrfit, and in that order.</p>
</td></tr>
<tr><td><code id="bmdbounds_+3A_conc">conc</code></td>
<td>
<p>Vector of concentrations (NOT in log units).</p>
</td></tr>
<tr><td><code id="bmdbounds_+3A_resp">resp</code></td>
<td>
<p>Vector of responses corresponding to given concentrations.</p>
</td></tr>
<tr><td><code id="bmdbounds_+3A_onesidedp">onesidedp</code></td>
<td>
<p>The one-sided p-value. Default of .05 corresponds to 5
percentile BMDL, 95 percentile BMDU, and 90 percent CI.</p>
</td></tr>
<tr><td><code id="bmdbounds_+3A_bmd">bmd</code></td>
<td>
<p>Can optionally input the bmd when already known to avoid
unnecessary calculation.</p>
</td></tr>
<tr><td><code id="bmdbounds_+3A_which.bound">which.bound</code></td>
<td>
<p>Returns BMDU if which.bound = &quot;upper&quot;; returns BMDL if
which.bound = &quot;lower&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes in concentration response fit details and outputs a bmdu or bmdl, as
desired. If bmd is not finite, returns NA. If the objective function doesn't
change sign or the root finding otherwise fails, it returns NA. These
failures are not uncommon since some curves just don't reach the desired
confidence level.
</p>


<h3>Value</h3>

<p>Returns either the BMDU or BMDL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc = c(.03, .1, .3, 1, 3, 10, 30, 100)
resp = c(.1,-.1,0,1.1,1.9,2,2.1,1.9)
pars = c(tp = 1.973356, ga = 0.9401224, p = 3.589397, er =  -2.698579)
bmdbounds(fit_method = "hill", bmr = .5, pars, conc, resp)
bmdbounds(fit_method = "hill", bmr = .5, pars, conc, resp, which.bound = "upper")
</code></pre>

<hr>
<h2 id='bmdobj'>BMD Objective Function</h2><span id='topic+bmdobj'></span>

<h3>Description</h3>

<p>Utility function for bmdbounds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmdobj(bmd, fname, bmr, conc, resp, ps, mll, onesp, partype = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmdobj_+3A_bmd">bmd</code></td>
<td>
<p>Benchmark dose.</p>
</td></tr>
<tr><td><code id="bmdobj_+3A_fname">fname</code></td>
<td>
<p>Function name: &quot;exp2&quot;, &quot;exp3&quot;, &quot;exp4&quot;, &quot;exp5&quot;, &quot;hillfn&quot;, &quot;gnls&quot;,
&quot;poly1&quot;, &quot;poly2&quot;, or &quot;pow&quot;.</p>
</td></tr>
<tr><td><code id="bmdobj_+3A_bmr">bmr</code></td>
<td>
<p>Benchmark response.</p>
</td></tr>
<tr><td><code id="bmdobj_+3A_conc">conc</code></td>
<td>
<p>Vector of concentrations NOT in log units.</p>
</td></tr>
<tr><td><code id="bmdobj_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="bmdobj_+3A_ps">ps</code></td>
<td>
<p>Named list of parameters.</p>
</td></tr>
<tr><td><code id="bmdobj_+3A_mll">mll</code></td>
<td>
<p>Maximum log-likelihood of winning model.</p>
</td></tr>
<tr><td><code id="bmdobj_+3A_onesp">onesp</code></td>
<td>
<p>One-sided p-value.</p>
</td></tr>
<tr><td><code id="bmdobj_+3A_partype">partype</code></td>
<td>
<p>Number for parameter type. Type 1 is y-scaling: a or tp.
Type 2 is x-scaling: b or ga, when available, a otherwise. Type 3 is
power scaling: p when available, then b or ga, then a if no others.
Since bmd is linked to the x-scale, type 2 should always be used. Other
types can also be vulnerable to underflow/overflow.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objective function value to find the zero of.
</p>

<hr>
<h2 id='cnst'>Constant Model</h2><span id='topic+cnst'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = 0</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnst(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnst_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters (ignored)</p>
</td></tr>
<tr><td><code id="cnst_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cnst(1,1)

</code></pre>

<hr>
<h2 id='concRespCore'>Concentration Response Core</h2><span id='topic+concRespCore'></span>

<h3>Description</h3>

<p>Core of concentration response curve fitting for pvalue based cutoff. This
function calls tcplfit2_core to get curve fits, and then tcplhit2_core to
perform the hitcalling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concRespCore(
  row,
  fitmodels = c("cnst", "hill", "gnls", "poly1", "poly2", "pow", "exp2", "exp3", "exp4",
    "exp5"),
  conthits = TRUE,
  aicc = FALSE,
  force.fit = FALSE,
  bidirectional = TRUE,
  verbose = FALSE,
  do.plot = FALSE,
  return.details = FALSE,
  bmr_scale = 1.349,
  bmd_low_bnd = NULL,
  bmd_up_bnd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concRespCore_+3A_row">row</code></td>
<td>
<p>A named list that must include:
</p>

<ul>
<li><p> conc - list of concentrations (not in log units)
</p>
</li>
<li><p> resp - list of corresponding responses
</p>
</li>
<li><p> bmed - median of noise estimate.
</p>
</li>
<li><p> cutoff - noise cutoff
</p>
</li>
<li><p> onesd - 1 standard deviation of the noise (for bmd calculation)
</p>
</li></ul>

<p>Other elements (usually identifiers, like casrn) of row will be attached to
the final output.</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_fitmodels">fitmodels</code></td>
<td>
<p>Vector of model names to use.</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_conthits">conthits</code></td>
<td>
<p>conthits = TRUE uses continuous hitcalls, otherwise they're
discrete.</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_aicc">aicc</code></td>
<td>
<p>aicc = TRUE uses corrected AIC to choose winning method; otherwise
regular AIC.</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_force.fit">force.fit</code></td>
<td>
<p>If TRUE force the fitting to proceed even if there are no points
outside of the bounds (default FALSE)</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE allow fitting to happen in both directions (default TRUE)</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, write extra output from tcplfit2_core (default FALSE)</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_do.plot">do.plot</code></td>
<td>
<p>If TRUE, create a plot in the tcplfit2_core function (default FALSE)</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_return.details">return.details</code></td>
<td>
<p>If TRUE, return the hitcalling details and the summary, if FALSE (default), just return the summary</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_bmr_scale">bmr_scale</code></td>
<td>
<p>- bmr scaling factor (for bmd calculation) default = 1.349</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_bmd_low_bnd">bmd_low_bnd</code></td>
<td>
<p>Multiplier for bmd lower bound.  A value of .1 would require the bmd to be no lower
than 1/10th of the lowest concentration tested.</p>
</td></tr>
<tr><td><code id="concRespCore_+3A_bmd_up_bnd">bmd_up_bnd</code></td>
<td>
<p>Multiplier for the bmd upper bound.  A value of 10 would require the bmd to be no lower
than 10 times the highest concentration tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements. The first (summary) is the output from tcplhit2_core. The second, params is the
output from tcplfit2_core
a dataframe of one row containing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- list(.03, .1, .3, 1, 3, 10, 30, 100)
resp &lt;- list(0, .2, .1, .4, .7, .9, .6, 1.2)
row &lt;- list(conc = conc,
            resp = resp,
            bmed = 0,
            cutoff = 1,
            onesd = .5,
            name = "some chemical",
            assay = "some assay")
concRespCore(row, conthits = TRUE)
concRespCore(row, aicc = TRUE)
</code></pre>

<hr>
<h2 id='concRespPlot'>Concentration Response Plot</h2><span id='topic+concRespPlot'></span>

<h3>Description</h3>

<p>Plots a concentration response curve for one sample/endpoint combination.
This is a generic function and it is expected that users will make their own versions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>concRespPlot(row, ymin = -120, ymax = 120, draw.error.arrows = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concRespPlot_+3A_row">row</code></td>
<td>
<p>Named list containing:
</p>

<ul>
<li><p> conc - conc string separated by |'s
</p>
</li>
<li><p> resp - response string separated by |'s
</p>
</li>
<li><p> method - scoring method determines plot bounds
</p>
</li>
<li><p> name - chemical name for plot title
</p>
</li>
<li><p> cutoff - noise cutoff
</p>
</li>
<li><p> bmr - baseline median response; level at which bmd is calculated
</p>
</li>
<li><p> er - fitted error term for plotting error bars
</p>
</li>
<li><p> a, tp, b, ga, p, la, q - other model parameters for fit curve
</p>
</li>
<li><p> fit_method - curve fit method
</p>
</li>
<li><p> bmd, bmdl, bmdu - bmd, bmd lower bound, and bmd upper bound
</p>
</li>
<li><p> ac50, acc - curve value at 50% of top, curve value at cutoff
</p>
</li>
<li><p> top - curve top
</p>
</li>
<li><p> name - name of the chemical
</p>
</li>
<li><p> assay - name of the assay, signature, or other endpoint
</p>
</li>
<li><p> other identifiers
</p>
</li></ul>

<p>Other elements are ignored.</p>
</td></tr>
<tr><td><code id="concRespPlot_+3A_ymin">ymin</code></td>
<td>
<p>Minimum value of response for the plot</p>
</td></tr>
<tr><td><code id="concRespPlot_+3A_ymax">ymax</code></td>
<td>
<p>Maximum value of response for the plot</p>
</td></tr>
<tr><td><code id="concRespPlot_+3A_draw.error.arrows">draw.error.arrows</code></td>
<td>
<p>If TRUE, draw lines representing the uncertainty in the response estimate,
instead of the actual response points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>row is one row of data from concRespCore
</p>


<h3>Value</h3>

<p>No output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
conc &lt;- list(.03, .1, .3, 1, 3, 10, 30, 100)
resp &lt;- list(0, .2, .1, .4, .7, .9, .6, 1.2)
row &lt;- list(conc = conc,
            resp = resp,
            bmed = 0,
            cutoff = 0.25,
            onesd = 0.125,
            name = "some chemical",
            assay = "some assay")
res &lt;- concRespCore(row, conthits = TRUE)
concRespPlot(res,ymin=-2.5,ymax=2.,5)


</code></pre>

<hr>
<h2 id='exp2'>Exponential 2 Model</h2><span id='topic+exp2'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = a*(e^{(x/b)}- 1)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp2(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp2_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: a,b,er</p>
</td></tr>
<tr><td><code id="exp2_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp2(c(1,2),1)

</code></pre>

<hr>
<h2 id='exp3'>Exponential 3 Model</h2><span id='topic+exp3'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = a*(e^{(x/b)^p} - 1)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp3(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp3_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: a,b,p,er</p>
</td></tr>
<tr><td><code id="exp3_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp3(c(1,2,2),1)

</code></pre>

<hr>
<h2 id='exp4'>Exponential 4 Model</h2><span id='topic+exp4'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = tp*(1-2^{(-x/ga)})</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp4(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp4_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: tp,ga,er</p>
</td></tr>
<tr><td><code id="exp4_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp4(c(1,2),1)

</code></pre>

<hr>
<h2 id='exp5'>Exponential 5 Model</h2><span id='topic+exp5'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = tp*(1-2^{(-(x/ga)^p)})</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp5(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp5_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: tp,ga,p,er</p>
</td></tr>
<tr><td><code id="exp5_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp5(c(1,2,3),1)

</code></pre>

<hr>
<h2 id='fitcnst'>Constant Model Fit</h2><span id='topic+fitcnst'></span>

<h3>Description</h3>

<p>Function that fits a constant line <code class="reqn">f(x) = 0</code> and returns generic
model outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitcnst(conc, resp, nofit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitcnst_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fitcnst_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fitcnst_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
<tr><td><code id="fitcnst_+3A_...">...</code></td>
<td>
<p>Space for parameters so fitcnst can be called similar to other fitting functions (currently unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. aic, rme, and er are set to NA in case of nofit or failure. pars
always equals &quot;er&quot;.
</p>


<h3>Value</h3>

<p>List of five elements: success, aic (Akaike Information Criteria),
rme (root mean square error), er (error parameter), pars (parameter names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitcnst(c(.1,1,10,100), c(1,2,0,-1))
fitcnst(c(.1,1,10,100), c(1,2,0,-1), nofit = TRUE)
</code></pre>

<hr>
<h2 id='fitexp2'>Exponential 2 Model Fit</h2><span id='topic+fitexp2'></span>

<h3>Description</h3>

<p>Function that fits to <code class="reqn">f(x) = a*(e^{(x/b)}- 1)</code> and returns generic model outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitexp2(conc, resp, bidirectional = TRUE, verbose = FALSE, nofit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitexp2_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fitexp2_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fitexp2_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE, model can be positive or negative; if FALSE, it
will be positive only.</p>
</td></tr>
<tr><td><code id="fitexp2_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gives optimization and hessian inversion details.</p>
</td></tr>
<tr><td><code id="fitexp2_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero background and increasing absolute response are assumed. Parameters are
&quot;a&quot; (y scale), &quot;b&quot; (x scale), and error term &quot;er&quot;.
success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. cov = 1 for a successful hessian inversion, 0 if it fails, and NA
if nofit = TRUE. aic, rme, modl, parameters, and parameter sds are set to
NA in case of nofit or failure.
</p>


<h3>Value</h3>

<p>Named list containing: success, aic (Akaike Information Criteria),
cov (success of covariance calculation), rme (root mean square error),
modl (vector of model values at given concentrations),
parameters values, parameter sd (standard deviation) estimates, pars
(vector of parameter names), sds (vector of parameter sd names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitexp2(c(.1,1,10,100), c(0,.1,1,10))
</code></pre>

<hr>
<h2 id='fitexp3'>Exponential 3 Model Fit</h2><span id='topic+fitexp3'></span>

<h3>Description</h3>

<p>Function that fits to <code class="reqn">f(x) = a*(e^{(x/b)^p} - 1)</code> and returns generic model
outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitexp3(
  conc,
  resp,
  bidirectional = TRUE,
  verbose = FALSE,
  nofit = FALSE,
  dmin = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitexp3_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fitexp3_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fitexp3_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE, model can be positive or negative; if FALSE, it
will be positive only.</p>
</td></tr>
<tr><td><code id="fitexp3_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gives optimization and hessian inversion details.</p>
</td></tr>
<tr><td><code id="fitexp3_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
<tr><td><code id="fitexp3_+3A_dmin">dmin</code></td>
<td>
<p>Minimum allowed value of p.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero background and increasing absolute response are assumed. Parameters are
&quot;a&quot; (y scale), &quot;b&quot; (x scale), &quot;p&quot; (power), and error term &quot;er&quot;.
success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. cov = 1 for a successful hessian inversion, 0 if it fails, and NA
if nofit = TRUE. aic, rme, modl, parameters, and parameter sds are set to
NA in case of nofit or failure.
</p>


<h3>Value</h3>

<p>Named list containing: success, aic (Akaike Information Criteria),
cov (success of covariance calculation), rme (root mean square error),
modl (vector of model values at given concentrations),
parameters values, parameter sd (standard deviation) estimates, pars
(vector of parameter names), sds (vector of parameter sd names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitexp3(c(.03,.1,.3,1,3,10,30,100), c(0,0,.1, .2, .4, 1, 4, 50))
</code></pre>

<hr>
<h2 id='fitexp4'>Exponential 4 Model Fit</h2><span id='topic+fitexp4'></span>

<h3>Description</h3>

<p>Function that fits to <code class="reqn">f(x) = tp*(1-2^{(-x/ga)})</code> and returns generic model
outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitexp4(conc, resp, bidirectional = TRUE, verbose = FALSE, nofit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitexp4_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fitexp4_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fitexp4_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE, model can be positive or negative; if FALSE, it
will be positive only.</p>
</td></tr>
<tr><td><code id="fitexp4_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gives optimization and hessian inversion details.</p>
</td></tr>
<tr><td><code id="fitexp4_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero background and increasing absolute response are assumed. Parameters are
&quot;tp&quot; (top), &quot;ga&quot; (AC50), and error term &quot;er&quot;.
success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. cov = 1 for a successful hessian inversion, 0 if it fails, and NA
if nofit = TRUE. aic, rme, modl, parameters, and parameter sds are set to
NA in case of nofit or failure.
</p>


<h3>Value</h3>

<p>Named list containing: success, aic (Akaike Information Criteria),
cov (success of covariance calculation), rme (root mean square error),
modl (vector of model values at given concentrations),
parameters values, parameter sd (standard deviation) estimates, pars
(vector of parameter names), sds (vector of parameter sd names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitexp4(c(.03,.1,.3,1,3,10,30,100), c(0,0,.1, .2, .5, 1, 1.5, 2))
</code></pre>

<hr>
<h2 id='fitexp5'>Exponential 5 Model Fit</h2><span id='topic+fitexp5'></span>

<h3>Description</h3>

<p>Function that fits to <code class="reqn">f(x) = tp*(1-2^{(-(x/ga)^p)})</code> and returns generic model
outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitexp5(
  conc,
  resp,
  bidirectional = TRUE,
  verbose = FALSE,
  nofit = FALSE,
  dmin = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitexp5_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fitexp5_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fitexp5_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE, model can be positive or negative; if FALSE, it
will be positive only.</p>
</td></tr>
<tr><td><code id="fitexp5_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gives optimization and hessian inversion details.</p>
</td></tr>
<tr><td><code id="fitexp5_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
<tr><td><code id="fitexp5_+3A_dmin">dmin</code></td>
<td>
<p>Minimum allowed value of p.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero background and increasing absolute response are assumed. Parameters are
&quot;tp&quot; (top), &quot;ga&quot; (AC50), &quot;p&quot; (power), and error term &quot;er&quot;.
success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. cov = 1 for a successful hessian inversion, 0 if it fails, and NA
if nofit = TRUE. aic, rme, modl, parameters, and parameter sds are set to
NA in case of nofit or failure.
</p>


<h3>Value</h3>

<p>Named list containing: success, aic (Akaike Information Criteria),
cov (success of covariance calculation), rme (root mean square error),
modl (vector of model values at given concentrations),
parameters values, parameter sd (standard deviation) estimates, pars
(vector of parameter names), sds (vector of parameter sd names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitexp5(c(.03,.1,.3,1,3,10,30,100), c(0,0,.1, .2, .5, 1, 1.5, 2))
</code></pre>

<hr>
<h2 id='fitgnls'>Gain-Loss Model Fit</h2><span id='topic+fitgnls'></span>

<h3>Description</h3>

<p>Function that fits to <code class="reqn">f(x) = \frac{tp}{[(1 + (ga/x)^p )(1 + (x/la)^q )]}</code>
and returns generic model outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitgnls(
  conc,
  resp,
  bidirectional = TRUE,
  verbose = FALSE,
  nofit = FALSE,
  minwidth = 1.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitgnls_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fitgnls_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fitgnls_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE, model can be positive or negative; if FALSE, it
will be positive only.</p>
</td></tr>
<tr><td><code id="fitgnls_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gives optimization and hessian inversion details.</p>
</td></tr>
<tr><td><code id="fitgnls_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
<tr><td><code id="fitgnls_+3A_minwidth">minwidth</code></td>
<td>
<p>Minimum allowed distance between gain ac50 and loss ac50 (in
log10 units).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Concentrations are converted internally to log10 units and optimized with
<code class="reqn">f(x) = \frac{tp}{[(1 + 10^{(p*(ga-x))} )(1 + 10^{(q*(x-la))} )]}</code>,
then ga, la, ga_sd, and la_sd are converted back to regular units before returning.
Zero background and increasing initial absolute response are assumed.
Parameters are &quot;tp&quot; (top), &quot;ga&quot; (gain AC50), &quot;p&quot; (gain power), &quot;la&quot;
(loss AC50),&quot;q&quot; (loss power) and error term &quot;er&quot;.
success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. cov = 1 for a successful hessian inversion, 0 if it fails, and NA
if nofit = TRUE. aic, rme, modl, parameters, and parameter sds are set to
NA in case of nofit or failure.
</p>


<h3>Value</h3>

<p>Named list containing: success, aic (Akaike Information Criteria),
cov (success of covariance calculation), rme (root mean square error),
modl (vector of model values at given concentrations),
parameters values, parameter sd (standard deviation) estimates, pars
(vector of parameter names), sds (vector of parameter sd names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitgnls(c(.03,.1,.3,1,3,10,30,100), c(0,.3,1, 2, 2.1, 1.5, .8, .2))
</code></pre>

<hr>
<h2 id='fithill'>Hill Model Fit</h2><span id='topic+fithill'></span>

<h3>Description</h3>

<p>Function that fits to <code class="reqn">f(x) = \frac{tp}{[(1 + (ga/x)^p )]}</code> and returns generic model
outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fithill(conc, resp, bidirectional = TRUE, verbose = FALSE, nofit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fithill_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fithill_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fithill_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE, model can be positive or negative; if FALSE, it
will be positive only.</p>
</td></tr>
<tr><td><code id="fithill_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gives optimization and hessian inversion details.</p>
</td></tr>
<tr><td><code id="fithill_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Concentrations are converted internally to log10 units and optimized with
<code class="reqn">f(x) = \frac{tp}{(1 + 10^{(p*(ga-x))} )}</code>, then ga and ga_sd are converted back to
regular units before returning.
Zero background and increasing initial absolute response are assumed.
Parameters are &quot;tp&quot; (top), &quot;ga&quot; (gain AC50), &quot;p&quot; (gain power), and error
term &quot;er&quot;.
success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. cov = 1 for a successful hessian inversion, 0 if it fails, and NA
if nofit = TRUE. aic, rme, modl, parameters, and parameter sds are set to
NA in case of nofit or failure.
</p>


<h3>Value</h3>

<p>Named list containing: success, aic (Akaike Information Criteria),
cov (success of covariance calculation), rme (root mean square error),
modl (vector of model values at given concentrations),
parameters values, parameter sd (standard deviation) estimates, pars
(vector of parameter names), sds (vector of parameter sd names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fithill(c(.03,.1,.3,1,3,10,30,100), c(0,0,.1, .2, .5, 1, 1.5, 2))
</code></pre>

<hr>
<h2 id='fitpoly1'>Polynomial 1 (Linear) Model Fit</h2><span id='topic+fitpoly1'></span>

<h3>Description</h3>

<p>Function that fits to <code class="reqn">f(x) = a*x</code> and returns generic model outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitpoly1(conc, resp, bidirectional = TRUE, verbose = FALSE, nofit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitpoly1_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fitpoly1_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fitpoly1_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE, model can be positive or negative; if FALSE, it
will be positive only.</p>
</td></tr>
<tr><td><code id="fitpoly1_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gives optimization and hessian inversion details.</p>
</td></tr>
<tr><td><code id="fitpoly1_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero background and increasing absolute response are assumed. Parameters are
&quot;a&quot; (y scale) and error term &quot;er&quot;.
success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. cov = 1 for a successful hessian inversion, 0 if it fails, and NA
if nofit = TRUE. aic, rme, modl, parameters, and parameter sds are set to
NA in case of nofit or failure.
</p>


<h3>Value</h3>

<p>Named list containing: success, aic (Akaike Information Criteria),
cov (success of covariance calculation), rme (root mean square error),
modl (vector of model values at given concentrations),
parameters values, parameter sd (standard deviation) estimates, pars
(vector of parameter names), sds (vector of parameter sd names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitpoly1(c(.03,.1,.3,1,3,10,30,100), c(0,.01,.1, .1, .2, .5, 2, 5))
</code></pre>

<hr>
<h2 id='fitpoly2'>Polynomial 2 (Quadratic) Model Fit</h2><span id='topic+fitpoly2'></span>

<h3>Description</h3>

<p>Function that fits to <code class="reqn">f(x) = a*(\frac{x}{b} + \frac{x^2}{b^2})</code> and
returns generic model outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitpoly2(conc, resp, bidirectional = TRUE, verbose = FALSE, nofit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitpoly2_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fitpoly2_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fitpoly2_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE, model can be positive or negative; if FALSE, it
will be positive only.</p>
</td></tr>
<tr><td><code id="fitpoly2_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gives optimization and hessian inversion details.</p>
</td></tr>
<tr><td><code id="fitpoly2_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero background and monotonically increasing absolute response are assumed.
Parameters are &quot;a&quot; (y scale), &quot;b&quot; (x scale), and error term &quot;er&quot;.
success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. cov = 1 for a successful hessian inversion, 0 if it fails, and NA
if nofit = TRUE. aic, rme, modl, parameters, and parameter sds are set to
NA in case of nofit or failure.
</p>


<h3>Value</h3>

<p>Named list containing: success, aic (Akaike Information Criteria),
cov (success of covariance calculation), rme (root mean square error),
modl (vector of model values at given concentrations),
parameters values, parameter sd (standard deviation) estimates, pars
(vector of parameter names), sds (vector of parameter sd names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitpoly2(c(.03,.1,.3,1,3,10,30,100), c(0,.01,.1, .1, .2, .5, 2, 8))
</code></pre>

<hr>
<h2 id='fitpow'>Power Model Fit</h2><span id='topic+fitpow'></span>

<h3>Description</h3>

<p>Function that fits to <code class="reqn">f(x) = a*x^p</code> and returns generic model outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitpow(
  conc,
  resp,
  bidirectional = TRUE,
  verbose = FALSE,
  nofit = FALSE,
  nmin = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitpow_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values NOT in log units.</p>
</td></tr>
<tr><td><code id="fitpow_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="fitpow_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If TRUE, model can be positive or negative; if FALSE, it
will be positive only.</p>
</td></tr>
<tr><td><code id="fitpow_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, gives optimization and hessian inversion details.</p>
</td></tr>
<tr><td><code id="fitpow_+3A_nofit">nofit</code></td>
<td>
<p>If nofit = TRUE, returns formatted output filled with missing values.</p>
</td></tr>
<tr><td><code id="fitpow_+3A_nmin">nmin</code></td>
<td>
<p>Minimum allowed value of p.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Zero background and monotonically increasing absolute response are assumed.
Parameters are &quot;a&quot; (y scale), &quot;p&quot; (power), and error term &quot;er&quot;.
success = 1 for a successful fit, 0 if optimization failed, and NA if
nofit = TRUE. cov = 1 for a successful hessian inversion, 0 if it fails, and NA
if nofit = TRUE. aic, rme, modl, parameters, and parameter sds are set to
NA in case of nofit or failure.
</p>


<h3>Value</h3>

<p>Named list containing: success, aic (Akaike Information Criteria),
cov (success of covariance calculation), rme (root mean square error),
modl (vector of model values at given concentrations),
parameters values, parameter sd (standard deviation) estimates, pars
(vector of parameter names), sds (vector of parameter sd names).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fitpow(c(.03,.1,.3,1,3,10,30,100), c(0,.01,.1, .1, .2, .5, 2, 8))
</code></pre>

<hr>
<h2 id='gnls'>Gain-Loss Model</h2><span id='topic+gnls'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = \frac{tp}{[(1 + (ga/x)^p )(1 + (x/la)^q )]}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnls(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnls_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: tp,ga,p,la,q,er</p>
</td></tr>
<tr><td><code id="gnls_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gnls(c(1,2,1,2,2),1)

</code></pre>

<hr>
<h2 id='gnlsderivobj'>GNLS Derivative Objective Function</h2><span id='topic+gnlsderivobj'></span>

<h3>Description</h3>

<p>Derivative of the gnls function set to zero for top location solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnlsderivobj(x, tp, ga, p, la, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnlsderivobj_+3A_x">x</code></td>
<td>
<p>Concentration.</p>
</td></tr>
<tr><td><code id="gnlsderivobj_+3A_tp">tp</code></td>
<td>
<p>Top.</p>
</td></tr>
<tr><td><code id="gnlsderivobj_+3A_ga">ga</code></td>
<td>
<p>Gain AC50.</p>
</td></tr>
<tr><td><code id="gnlsderivobj_+3A_p">p</code></td>
<td>
<p>Gain power.</p>
</td></tr>
<tr><td><code id="gnlsderivobj_+3A_la">la</code></td>
<td>
<p>Loss AC50.</p>
</td></tr>
<tr><td><code id="gnlsderivobj_+3A_q">q</code></td>
<td>
<p>Loss power.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of gnls derivative at x.
</p>

<hr>
<h2 id='hillfn'>Hill Model</h2><span id='topic+hillfn'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = \frac{tp}{[(1 + (ga/x)^p )]}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hillfn(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hillfn_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: tp,ga,p,er</p>
</td></tr>
<tr><td><code id="hillfn_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hillfn(c(1,2,3),1)

</code></pre>

<hr>
<h2 id='hitcont'>Continuous Hitcalls</h2><span id='topic+hitcont'></span>

<h3>Description</h3>

<p>Wrapper that computes continuous hitcalls for a provided concRespCore input row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hitcont(indf, xs = NULL, ys = NULL, newcutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hitcont_+3A_indf">indf</code></td>
<td>
<p>Dataframe similar to concRespCore output. Must contain &quot;conc&quot; and &quot;resp&quot;
columns if xs and ys are not provided. Must contain &quot;top&quot;, &quot;ac50&quot;, &quot;er&quot;,
&quot;fit_method&quot;, &quot;caikwt&quot;, and &quot;mll&quot; columns as well as columns for each
model parameter.</p>
</td></tr>
<tr><td><code id="hitcont_+3A_xs">xs</code></td>
<td>
<p>List of concentration vectors that can be provided for speed.</p>
</td></tr>
<tr><td><code id="hitcont_+3A_ys">ys</code></td>
<td>
<p>List of response vectors that can be provided for speed.</p>
</td></tr>
<tr><td><code id="hitcont_+3A_newcutoff">newcutoff</code></td>
<td>
<p>Vector of new cutoff values to use. Length should be equal
to rows in indf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>indf parameter columns should be NA when not required by fit method. &quot;conc&quot;
and &quot;resp&quot; entries should be a single string with values separated by |.
Details on indf columns can be found in concRespCore.
</p>


<h3>Value</h3>

<p>Vector of hitcalls between 0 and 1 with length equal to indf row
number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- list(.03, .1, .3, 1, 3, 10, 30, 100)
resp &lt;- list(0, .2, .1, .4, .7, .9, .6, 1.2)
row &lt;- list(
  conc = conc,
  resp = resp,
  bmed = 0,
  cutoff = 1,
  onesd = .5,
  name = "some chemical",
  assay = "some assay"
)
res &lt;- concRespCore(row, conthits = TRUE)
hitcont(res, newcutoff = 0.2)

</code></pre>

<hr>
<h2 id='hitcontinner'>Continuous Hitcalls Inner</h2><span id='topic+hitcontinner'></span>

<h3>Description</h3>

<p>Calculates continuous hitcall using 3 statistical metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hitcontinner(conc, resp, top, cutoff, er, ps, fit_method, caikwt, mll)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hitcontinner_+3A_conc">conc</code></td>
<td>
<p>Vector of concentrations.</p>
</td></tr>
<tr><td><code id="hitcontinner_+3A_resp">resp</code></td>
<td>
<p>Vector of responses.</p>
</td></tr>
<tr><td><code id="hitcontinner_+3A_top">top</code></td>
<td>
<p>Model top.</p>
</td></tr>
<tr><td><code id="hitcontinner_+3A_cutoff">cutoff</code></td>
<td>
<p>Desired cutoff.</p>
</td></tr>
<tr><td><code id="hitcontinner_+3A_er">er</code></td>
<td>
<p>Model error parameter.</p>
</td></tr>
<tr><td><code id="hitcontinner_+3A_ps">ps</code></td>
<td>
<p>Vector of used model parameters in order: a, tp, b, ga, p, la, q, er.</p>
</td></tr>
<tr><td><code id="hitcontinner_+3A_fit_method">fit_method</code></td>
<td>
<p>Name of winning fit method (should never be constant).</p>
</td></tr>
<tr><td><code id="hitcontinner_+3A_caikwt">caikwt</code></td>
<td>
<p>Akaike weight of constant model relative to winning model.</p>
</td></tr>
<tr><td><code id="hitcontinner_+3A_mll">mll</code></td>
<td>
<p>Maximum log-likelihood of winning model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called either directly from concRespCore or
via hitcont. Details of how to compute function input are in
concRespCore.
</p>


<h3>Value</h3>

<p>Continuous hitcall between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc = c(.03,.1,.3,1,3,10,30,100)
resp = c(0,.1,0,.2,.6,.9,1.1,1)
top = 1.023239
er = -3.295307
ps = c(1.033239, 2.453014, 1.592714, er = -3.295307) #tp,ga,p,er
fit_method = "hill"
caikwt = 1.446966e-08
mll = 12.71495
hitcontinner(conc,resp,top,cutoff = 0.8, er,ps,fit_method, caikwt, mll)
hitcontinner(conc,resp,top,cutoff = 1, er,ps,fit_method, caikwt, mll)
hitcontinner(conc,resp,top,cutoff = 1.2, er,ps,fit_method, caikwt, mll)
</code></pre>

<hr>
<h2 id='hitlogic'>Hit Logic (Discrete)</h2><span id='topic+hitlogic'></span>

<h3>Description</h3>

<p>Wrapper that computes discrete hitcalls for a provided concRespCore dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hitlogic(indf, newbmad = NULL, xs = NULL, ys = NULL, newcutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hitlogic_+3A_indf">indf</code></td>
<td>
<p>Dataframe similar to concRespCore input Must contain &quot;conc&quot; and &quot;resp&quot;
columns if xs and ys are not provided. Must contain &quot;cutoff&quot; and &quot;bmad_factor&quot;
columns if newbmad is not NULL. Must contain &quot;top&quot; and &quot;ac50&quot; columns. &quot;conc&quot;
and &quot;resp&quot; entries should be a single string with values separated by |.</p>
</td></tr>
<tr><td><code id="hitlogic_+3A_newbmad">newbmad</code></td>
<td>
<p>(Deprecated) New number of bmads to use for the cutoff.</p>
</td></tr>
<tr><td><code id="hitlogic_+3A_xs">xs</code></td>
<td>
<p>List of concentration vectors that can be provided for speed.</p>
</td></tr>
<tr><td><code id="hitlogic_+3A_ys">ys</code></td>
<td>
<p>List of response vectors that can be provided for speed.</p>
</td></tr>
<tr><td><code id="hitlogic_+3A_newcutoff">newcutoff</code></td>
<td>
<p>Vector of new cutoff values to use. Length should be equal
to rows in indf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of hitcalls with length equal to number of rows in indf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc = rep(".03|.1|.3|1|3|10|30|100",2)
resp = rep("0|0|.1|.1|.5|.5|1|1",2)
indf = data.frame(top = c(1,1), ac50 = c(3,4), conc = conc, resp = resp,
  stringsAsFactors = FALSE)
hitlogic(indf, newcutoff = c(.8,1.2))
</code></pre>

<hr>
<h2 id='hitloginner'>Hit Logic Inner (Discrete)</h2><span id='topic+hitloginner'></span>

<h3>Description</h3>

<p>Contains hit logic, called directly during CR fitting or later through &quot;hitlogic&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hitloginner(conc = NULL, resp, top, cutoff, ac50 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hitloginner_+3A_conc">conc</code></td>
<td>
<p>Vector of concentrations (No longer necessary).</p>
</td></tr>
<tr><td><code id="hitloginner_+3A_resp">resp</code></td>
<td>
<p>Vector of responses.</p>
</td></tr>
<tr><td><code id="hitloginner_+3A_top">top</code></td>
<td>
<p>Model top.</p>
</td></tr>
<tr><td><code id="hitloginner_+3A_cutoff">cutoff</code></td>
<td>
<p>Desired cutoff.</p>
</td></tr>
<tr><td><code id="hitloginner_+3A_ac50">ac50</code></td>
<td>
<p>Model AC50 (No longer necessary).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to keep the actual hit rules in one
location so it can be called during CR fitting, and then again after the fact
for a variety of cutoffs. Curves fit with constant winning should have
top = NA, generating a miss.
</p>


<h3>Value</h3>

<p>Outputs 1 for hit, 0 for miss.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hitloginner(resp = 1:8, top = 7, cutoff = 5) #hit
hitloginner(resp = 1:8, top = 7, cutoff = 7.5) #miss: top too low
hitloginner(resp = 1:8, top = 9, cutoff = 8.5) #miss: no response&gt; cutoff
hitloginner(resp = 1:8, top = NA, cutoff = 5) #miss: no top (constant)
</code></pre>

<hr>
<h2 id='loggnls'>Log Gain-Loss Model</h2><span id='topic+loggnls'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = \frac{tp}{[(1 + 10^{(p*(ga-x))} )(1 + 10^{(q*(x-la))} )]}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loggnls(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loggnls_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: tp,ga,p,la,q,er (ga and la are in log10-scale)</p>
</td></tr>
<tr><td><code id="loggnls_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (log10 units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loggnls(c(1,2,1,2,2),1)

</code></pre>

<hr>
<h2 id='loghill'>Log Hill Model</h2><span id='topic+loghill'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = \frac{tp}{(1 + 10^{(p*(ga-x))} )}</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loghill(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loghill_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: tp,ga,p,er (ga is in log10-scale)</p>
</td></tr>
<tr><td><code id="loghill_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (log10 units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>loghill(c(1,2,3),1)

</code></pre>

<hr>
<h2 id='mc0'>Sample multi-concentration data set from invitrodb</h2><span id='topic+mc0'></span>

<h3>Description</h3>

<p>A data set containing 1831 chemicals worth of data for the ACEA_AR assay,
Data from the assay component ACEA_AR_agonist_80hr was analyzed in the
positive analysis fitting direction relative to DMSO as the neutral
control and baseline of activity.
The data can be accessed further through invitrodb and tcpl see
https://www.epa.gov/chemical-research/exploring-toxcast-data#Download.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc0
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.table</code> (inherits from <code>data.frame</code>) with 53608 rows and 13 columns.
</p>


<h3>Details</h3>

<p>This data is extracted from the released version of the ToxCast database,
invitrodb, at level 0 (mc0) and contains the concentration-response information.
</p>
<p>A data frame with 53608 rows and 13 variables:
</p>

<ul>
<li><p> m0id - Level 0 id
</p>
</li>
<li><p> spid - Sample id
</p>
</li>
<li><p> acid - Unique assay component id; unique numeric id for each assay component
</p>
</li>
<li><p> apid - Assay plate id
</p>
</li>
<li><p> rowi - Row index (location on assay plate)
</p>
</li>
<li><p> coli - Column index (location on assay plate)
</p>
</li>
<li><p> wllt - Well type
</p>
</li>
<li><p> wllq - well quality
</p>
</li>
<li><p> conc - concentration
</p>
</li>
<li><p> rval - raw value
</p>
</li>
<li><p> srcf - Source file name
</p>
</li>
<li><p> clowder_uid - clowder unique id for source files
</p>
</li>
<li><p> git_hash - hash key for pre-processing scripts
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://doi.org/10.23645/epacomptox.6062623.v10">doi:10.23645/epacomptox.6062623.v10</a>
</p>

<hr>
<h2 id='mc3'>Sample concentration-response data set from invitrodb</h2><span id='topic+mc3'></span>

<h3>Description</h3>

<p>A data set containing 100 chemicals worth of data for the Tox21 assay
TOX21_ERa_BLA_Agonist_ratio, which measures response to estrogen receptor agonists.
The data can be accessed further through the Comptox Chemicals Dashboard
(<a href="https://comptox.epa.gov/dashboard">https://comptox.epa.gov/dashboard</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc3
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 32175 rows and 7 columns.
</p>


<h3>Details</h3>

<p>This data is extracted from the released version of the ToxCast database,
invitrodb, at level 3 (mc3) and contains the concentration-response information.
</p>
<p>A data frame with 32175 rows and 7 variables:
</p>

<ul>
<li><p> dtxsid - DSSTox generic substance ID
</p>
</li>
<li><p> casrn - Chemical Abstracts Registry Number (CASRN)
</p>
</li>
<li><p> name - chemical name
</p>
</li>
<li><p> spid - sample ID - there can be multiple samples per chemical
</p>
</li>
<li><p> logc - log10(concentration), micromolar (uM)
</p>
</li>
<li><p> resp - response in %
</p>
</li>
<li><p> assay - name of the assay / assay component endpoint name
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://doi.org/10.23645/epacomptox.6062623.v5">doi:10.23645/epacomptox.6062623.v5</a>
</p>

<hr>
<h2 id='nestselect'>Nest Select</h2><span id='topic+nestselect'></span>

<h3>Description</h3>

<p>Chooses between nested models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nestselect(aics, mod1, mod2, dfdiff, pval = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nestselect_+3A_aics">aics</code></td>
<td>
<p>Named vector of model aics (can include extra models).</p>
</td></tr>
<tr><td><code id="nestselect_+3A_mod1">mod1</code></td>
<td>
<p>Name of model 1, the model with fewer degrees of freedom.</p>
</td></tr>
<tr><td><code id="nestselect_+3A_mod2">mod2</code></td>
<td>
<p>Name of model 2, the model with more degrees of freedom.</p>
</td></tr>
<tr><td><code id="nestselect_+3A_dfdiff">dfdiff</code></td>
<td>
<p>Absolute difference in number of degrees of freedom
(i.e. the difference in parameters).</p>
</td></tr>
<tr><td><code id="nestselect_+3A_pval">pval</code></td>
<td>
<p>P-value for nested model test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named aic vector with losing model removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aics = c(-5,-6,-3)
names(aics) = c("poly1", "poly2", "hill")
nestselect(aics, "poly1", "poly2", 1)

aics = c(-5,-7,-3)
names(aics) = c("poly1", "poly2", "hill")
nestselect(aics, "poly1", "poly2", 1)
</code></pre>

<hr>
<h2 id='poly1'>Polynomial 1 Model</h2><span id='topic+poly1'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = a*x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly1(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly1_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: a,er</p>
</td></tr>
<tr><td><code id="poly1_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poly1(1,1)

</code></pre>

<hr>
<h2 id='poly2'>Polynomial 2 Model</h2><span id='topic+poly2'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = a*(\frac{x}{b} + \frac{x^2}{b^2})</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly2(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly2_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: a,b,er</p>
</td></tr>
<tr><td><code id="poly2_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poly2(c(1,2),1)

</code></pre>

<hr>
<h2 id='pow'>Power Model</h2><span id='topic+pow'></span>

<h3>Description</h3>

<p><code class="reqn">f(x) = a*x^p</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow(ps, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pow_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters: a,p,er</p>
</td></tr>
<tr><td><code id="pow_+3A_x">x</code></td>
<td>
<p>Vector of concentrations (regular units)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of model responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pow(c(1,2),1)

</code></pre>

<hr>
<h2 id='signatures'>Sample concentration-response data set from HTTR</h2><span id='topic+signatures'></span>

<h3>Description</h3>

<p>A data set containing 6 of the active transcriptional signatures after
perturbation of MCF7 cells with Clomiphene citrate (1:1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signatures
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 6 rows and 8 columns.
</p>


<h3>Details</h3>

<p>A data frame with 6 rows and 8 variables:
</p>

<ul>
<li><p> sample_id - experimental sample ID
</p>
</li>
<li><p> dtxsid - DSSTox generic substance ID
</p>
</li>
<li><p> name - chemical name
</p>
</li>
<li><p> signature - transcriptional signature name
</p>
</li>
<li><p> cutoff - the 95% confidence interval from the baseline response (2 lowest concentrations)
</p>
</li>
<li><p> onesd - one standard deviation of the baseline response
</p>
</li>
<li><p> conc - experimental concentrations, micromolar (uM)
</p>
</li>
<li><p> resp - transcriptional signature response for each experimental concentrations, ssGSEA score
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://doi.org/10.1093/toxsci/kfab009">doi:10.1093/toxsci/kfab009</a>
</p>


<h3>References</h3>

<p>Joshua A. Harrill, Logan J. Everett, Derik E. Haggard,
Thomas Sheffield, Joseph L. Bundy, Clinton M. Willis, Russell S. Thomas,
Imran Shah, Richard S. Judson, High-Throughput Transcriptomics Platform for
Screening Environmental Chemicals, Toxicological Sciences, Volume 181,
Issue 1, May 2021, Pages 68 - 89, https://doi.org/10.1093/toxsci/kfab009.
</p>

<hr>
<h2 id='tcplfit2_core'>Concentration-response curve fitting</h2><span id='topic+tcplfit2_core'></span>

<h3>Description</h3>

<p>Concentration response curve fitting using the methods from BMDExpress
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplfit2_core(
  conc,
  resp,
  cutoff,
  force.fit = FALSE,
  bidirectional = TRUE,
  verbose = FALSE,
  do.plot = FALSE,
  fitmodels = c("cnst", "hill", "gnls", "poly1", "poly2", "pow", "exp2", "exp3", "exp4",
    "exp5"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplfit2_core_+3A_conc">conc</code></td>
<td>
<p>Vector of concentrations (NOT in log units).</p>
</td></tr>
<tr><td><code id="tcplfit2_core_+3A_resp">resp</code></td>
<td>
<p>Vector of responses.</p>
</td></tr>
<tr><td><code id="tcplfit2_core_+3A_cutoff">cutoff</code></td>
<td>
<p>Desired cutoff. If no absolute responses &gt; cutoff and
force.fit = FALSE, will only fit constant model.</p>
</td></tr>
<tr><td><code id="tcplfit2_core_+3A_force.fit">force.fit</code></td>
<td>
<p>If force.fit = TRUE, will fit all models regardless of cutoff.</p>
</td></tr>
<tr><td><code id="tcplfit2_core_+3A_bidirectional">bidirectional</code></td>
<td>
<p>If bidirectional = FALSE, will only give positive fits.</p>
</td></tr>
<tr><td><code id="tcplfit2_core_+3A_verbose">verbose</code></td>
<td>
<p>If verbose = TRUE, will print optimization details and aics.</p>
</td></tr>
<tr><td><code id="tcplfit2_core_+3A_do.plot">do.plot</code></td>
<td>
<p>If do.plot = TRUE, will generate a plot comparing model curves.</p>
</td></tr>
<tr><td><code id="tcplfit2_core_+3A_fitmodels">fitmodels</code></td>
<td>
<p>Vector of model names to try fitting. Missing models still
return a skeleton output filled with NAs.</p>
</td></tr>
<tr><td><code id="tcplfit2_core_+3A_...">...</code></td>
<td>
<p>Other fitting parameters (deprecated).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All models are equal to 0 at 0 concentration (zero background).
To add more models in the future, write a fit____ function, and add the model
name to the fitmodels and modelnames vectors.
</p>


<h3>Value</h3>

<p>List of N(models) elements, one for each of the models run (up to 10),
followed by a last element &quot;modelnames&quot;, which is a  vector of model names so
other functions can easily cycle through the output. For a full list, see the
documentation for the individual fitting method functions. For each model there
is a sublist with elements including:
</p>

<ul>
<li><p> success - was the model successfully fit
</p>
</li>
<li><p> aic - the AIC value
</p>
</li>
<li><p> cov - success of the the covariance matrix calculation
</p>
</li>
<li><p> rme - root mean error of the data around the curve
</p>
</li>
<li><p> modl - vector of model values at the given concentrations
</p>
</li>
<li><p> tp - the top of the curve fit
</p>
</li>
<li><p> ga - the AC50 or Hill paramters
</p>
</li>
<li><p> er - the error term
</p>
</li>
<li><p> ... other paramters specific to the model (see the documentation for the specific models)
</p>
</li>
<li><p> tp_sd, ga_sd, p_sd, etc., the values of the standard deviations of the paramters for the models
</p>
</li>
<li><p> er_sd - standard deviation of the error term
</p>
</li>
<li><p> pars - the names of the parameters
</p>
</li>
<li><p> sds - the names of the standard deviations of the paramters
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(.03, .1, .3, 1, 3, 10, 30, 100)
resp &lt;- c(0, .1, 0, .2, .6, .9, 1.1, 1)
output &lt;- tcplfit2_core(conc, resp, .8,
  fitmodels = c("cnst", "hill"), verbose = TRUE,
  do.plot = TRUE
)
</code></pre>

<hr>
<h2 id='tcplhit2_core'>Hitcalling Function</h2><span id='topic+tcplhit2_core'></span>

<h3>Description</h3>

<p>Core of hitcalling function. This method chooses the winning model from tcplfit2_core,
extracts the top and ac50, computes the hitcall, and calculates bmd/bmdl/bmdu among other
statistics. Nested model selection is used to choose between poly1/poly2, then
the model with the lowest AIC (or AICc) is declared the winner. Continuous
hitcalls requires tcplfit2_core to be run with force.fit = TRUE and &quot;cnst&quot; never to
be chosen as the winner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplhit2_core(
  params,
  conc,
  resp,
  cutoff,
  onesd,
  bmr_scale = 1.349,
  bmed = 0,
  conthits = TRUE,
  aicc = FALSE,
  identifiers = NULL,
  bmd_low_bnd = NULL,
  bmd_up_bnd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplhit2_core_+3A_params">params</code></td>
<td>
<p>The output from tcplfit2_core</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_conc">conc</code></td>
<td>
<p>list of concentrations (not in log units)</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_resp">resp</code></td>
<td>
<p>list of corresponding responses</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_cutoff">cutoff</code></td>
<td>
<p>noise cutoff</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_onesd">onesd</code></td>
<td>
<p>1 standard deviation of the noise (for bmd calculation)</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_bmr_scale">bmr_scale</code></td>
<td>
<p>bmr scaling factor. Default = 1.349</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_bmed">bmed</code></td>
<td>
<p>median of noise estimate. Default 0</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_conthits">conthits</code></td>
<td>
<p>conthits = TRUE uses continuous hitcalls, otherwise they're
discrete. Default TRUE</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_aicc">aicc</code></td>
<td>
<p>aicc = TRUE uses corrected AIC to choose winning method; otherwise
regular AIC. Default FALSE</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_identifiers">identifiers</code></td>
<td>
<p>A one-row data frame containing identifiers of the concentration-response profile,
such as the chemical name or other identifiers, and any assay identifiers. The column names
identify the type of value. This can be NULL. The values will be included in the output
summary data frame</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_bmd_low_bnd">bmd_low_bnd</code></td>
<td>
<p>Multiplier for bmd lower bound.  A value of .1 would require the bmd to be no lower
than 1/10th of the lowest concentration tested.</p>
</td></tr>
<tr><td><code id="tcplhit2_core_+3A_bmd_up_bnd">bmd_up_bnd</code></td>
<td>
<p>Multiplier for the bmd upper bound.  A value of 10 would require the bmd to be no lower
than 10 times the highest concentration tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of with the detailed results from all of the different model fits.
The elements of summary are:
</p>

<ul>
<li><p> any elements of the identifiers input
</p>
</li>
<li><p> n_gt_cutoff - number of data points above the cutoff
</p>
</li>
<li><p> cutoff - noise cutoff
</p>
</li>
<li><p> fit_method - curve fit method
</p>
</li>
<li><p> top_over_cutoff - top divided by cutoff
</p>
</li>
<li><p> rmse - RMSE of the data points around the best model curve
</p>
</li>
<li><p> a - fitting parameter methods: exp2, exp3, poly1, poly2, pow
</p>
</li>
<li><p> b - fitting parameter methods: exp2, exp3, ploy2
</p>
</li>
<li><p> p - fitting parameter methods: exp3, exp5, gnls, hill, pow
</p>
</li>
<li><p> q - fitting parameter methods: gnls,
</p>
</li>
<li><p> tp - top of the curve
</p>
</li>
<li><p> ga - ac50 for the rising curve in a gnls model or the Hill model
</p>
</li>
<li><p> la - ac50 for the falling curve in a gnls model
</p>
</li>
<li><p> er - fitted error term for plotting error bars
</p>
</li>
<li><p> bmr - benchmark response; level at which bmd is calculated = onesd*bmr_scale default bmr_scale is 1.349
</p>
</li>
<li><p> bmd - benchmark dose, curve value at bmr
</p>
</li>
<li><p> bmdl - lower limit on the bmd
</p>
</li>
<li><p> bmdu - upper limit on the bmd
</p>
</li>
<li><p> caikwt - one factor used in calculating the continuous hitcall. It is calcalated from the formula
= exp(-aic(cnst)/2)/(exp(-aic(cnst)/2) + exp(-aic(fit_method)/2)) and measures how much lower the
selected method AIC is than that for the constant model
</p>
</li>
<li><p> mll - another factor used in calcualting the continuous hitcall = length(modpars) - aic(fit_method)/2
</p>
</li>
<li><p> hitcall - the final hitcall, a value ranging from 0 to 1
</p>
</li>
<li><p> top - curve top
</p>
</li>
<li><p> ac50 - curve value at 50% of top, curve value at cutoff
</p>
</li>
<li><p> lc50 - curve value at 50% of top corresponding to the loss side of the gain-loss curve
</p>
</li>
<li><p> ac5 - curve value at 5% of top
</p>
</li>
<li><p> ac10 - curve value at 10% of top
</p>
</li>
<li><p> ac20 - curve value at 20% of top
</p>
</li>
<li><p> acc - curve value at cutoff
</p>
</li>
<li><p> ac1sd - curve value at 1 standard deviation
</p>
</li>
<li><p> conc - conc string separated by |'s
</p>
</li>
<li><p> resp - response string separated by |'s
</p>
</li></ul>


<hr>
<h2 id='tcplObj'>Concentration Response Objective Function</h2><span id='topic+tcplObj'></span>

<h3>Description</h3>

<p>Log-likelihood to be maximized during CR fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcplObj(p, conc, resp, fname, errfun = "dt4", err = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcplObj_+3A_p">p</code></td>
<td>
<p>Vector of parameters, must be in order: a, tp, b, ga, p, la, q, er.
Does not require names.</p>
</td></tr>
<tr><td><code id="tcplObj_+3A_conc">conc</code></td>
<td>
<p>Vector of concentrations in log10 units for loghill/loggnls, in
regular units otherwise.</p>
</td></tr>
<tr><td><code id="tcplObj_+3A_resp">resp</code></td>
<td>
<p>Vector of corresponding responses.</p>
</td></tr>
<tr><td><code id="tcplObj_+3A_fname">fname</code></td>
<td>
<p>Name of model function.</p>
</td></tr>
<tr><td><code id="tcplObj_+3A_errfun">errfun</code></td>
<td>
<p>Which error distribution to assume for each point. &quot;dt4&quot; is the
original 4 degrees of freedom t-distribution. &quot;dnorm&quot; is the normal
distribution.</p>
</td></tr>
<tr><td><code id="tcplObj_+3A_err">err</code></td>
<td>
<p>An optional estimation of error for the given fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a generalized version of the log-likelihood estimation
functions used in the ToxCast Pipeline (TCPL).
Hill model uses fname &quot;loghill&quot; and gnls uses fname &quot;loggnls&quot;. Other model
functions have the same fname as their model name; i.e. exp2 uses &quot;exp2&quot;, etc.
errfun = &quot;dnorm&quot; may be better suited to gsva pathway scores than &quot;dt4&quot;.
Setting err could be used to fix error based on the null data noise
distribution instead of fitting the error when maximizing log-likelihood.
</p>


<h3>Value</h3>

<p>Log-likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc = c(.03,.1 , .3 , 1  , 3 , 10 , 30  , 100)
resp = c( 0 , 0 , .1 ,.2 , .5 , 1  , 1.5 , 2  )
p = c(tp = 2, ga = 3, p = 4, er = .5)
tcplObj(p,conc,resp,"exp5")

lconc = log10(conc)
tcplObj(p,lconc,resp,"loghill")
</code></pre>

<hr>
<h2 id='toplikelihood'>Top Likelihood</h2><span id='topic+toplikelihood'></span>

<h3>Description</h3>

<p>Probability of top being above cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toplikelihood(fname, cutoff, conc, resp, ps, top, mll)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toplikelihood_+3A_fname">fname</code></td>
<td>
<p>Model function name (equal to model name except hill which
uses &quot;hillfn&quot;)</p>
</td></tr>
<tr><td><code id="toplikelihood_+3A_cutoff">cutoff</code></td>
<td>
<p>Desired cutoff.</p>
</td></tr>
<tr><td><code id="toplikelihood_+3A_conc">conc</code></td>
<td>
<p>Vector of concentrations.</p>
</td></tr>
<tr><td><code id="toplikelihood_+3A_resp">resp</code></td>
<td>
<p>Vector of responses.</p>
</td></tr>
<tr><td><code id="toplikelihood_+3A_ps">ps</code></td>
<td>
<p>Vector of parameters, must be in order: a, tp, b, ga, p, la, q, er</p>
</td></tr>
<tr><td><code id="toplikelihood_+3A_top">top</code></td>
<td>
<p>Model top.</p>
</td></tr>
<tr><td><code id="toplikelihood_+3A_mll">mll</code></td>
<td>
<p>Winning model maximum log-likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Should only be called by hitcontinner. Uses profile likelihood, similar
to bmdbounds. Here, the y-scale type parameter is substituted in such a
way that the top equals the cutoff. Then the log-likelihood is compared to
the maximum log-likelihood using chisq function to retrieve probability.
</p>


<h3>Value</h3>

<p>Probability of top being above cutoff.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fname = "hillfn"
conc = c(.03,.1,.3,1,3,10,30,100)
resp = c(0,.1,0,.2,.6,.9,1.1,1)
ps = c(1.033239, 2.453014, 1.592714, er = -3.295307)
top = 1.023239
mll = 12.71495
toplikelihood(fname, cutoff = .8, conc, resp, ps, top, mll)
toplikelihood(fname, cutoff = 1, conc, resp, ps, top, mll)
toplikelihood(fname, cutoff = 1.2, conc, resp, ps, top, mll)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
