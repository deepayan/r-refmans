<!DOCTYPE html><html lang="en"><head><title>Help for package tame</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tame}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tame-package'><p>Timing and ATC based Medication Clustering</p></a></li>
<li><a href='#amounts'><p>Frequency tables for medication amount</p></a></li>
<li><a href='#cluster_selector'><p>Finding chosen cluster names</p></a></li>
<li><a href='#complications'><p>A Simulated Data Set About Pregnancy Complications</p></a></li>
<li><a href='#eczema'><p>A Simulated Data Set About Eczema</p></a></li>
<li><a href='#employ'><p>Employ a Clustering to New Data</p></a></li>
<li><a href='#enrich'><p>Enrich Clustering Parameter</p></a></li>
<li><a href='#frequencies'><p>The Frequency of Assignment to Each Cluster</p></a></li>
<li><a href='#interactions'><p>Timing and ATC pattern interactions</p></a></li>
<li><a href='#is.medic'><p>Test if an object is a medic-object</p></a></li>
<li><a href='#medic'><p>Medication clustering (based on ATC and timing)</p></a></li>
<li><a href='#medications'><p>ATC Code Frequency Within Clusters</p></a></li>
<li><a href='#method_selector'><p>Method Selector</p></a></li>
<li><a href='#parameters_constructor'><p>Internal option constructor</p></a></li>
<li><a href='#refactor'><p>Refactor Cluster Levels</p></a></li>
<li><a href='#summary.medic'><p>Summary of medic object</p></a></li>
<li><a href='#trajectories'><p>Timing pattern frequency within clusters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Timing, Anatomical, Therapeutic and Chemical Based Medication
Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Agglomerative hierarchical clustering with a bespoke distance 
  measure based on medication similarities in the Anatomical Therapeutic 
  Chemical Classification System, medication timing and 
  medication amount or dosage. Tools for summarizing, illustrating and 
  manipulating the cluster objects are also available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, fuzzyjoin, magrittr, purrr, Rfast, rlang, stats,
stringr, tibble, tidyr, tidyselect, Rcpp (&ge; 1.0.8)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Laksafoss/tame/issues">https://github.com/Laksafoss/tame/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-23 08:48:03 UTC; B245807</td>
</tr>
<tr>
<td>Author:</td>
<td>Anna Laksafoss <a href="https://orcid.org/0000-0002-9898-2924"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anna Laksafoss &lt;adls@ssi.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-23 14:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='tame-package'>Timing and ATC based Medication Clustering</h2><span id='topic+tame'></span><span id='topic+tame-package'></span>

<h3>Description</h3>

<p>Agglomerative hierarchical clustering with a bespoke distance measure based
on medication ATC codes similarities, medication timing and medication amount
or dosage. Tools for summarizing, illustrating and manipulating the cluster
objects are also available.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Anna Laksafoss <a href="mailto:adls@ssi.dk">adls@ssi.dk</a> (<a href="https://orcid.org/0000-0002-9898-2924">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/Laksafoss/tame/issues">https://github.com/Laksafoss/tame/issues</a>
</p>
</li></ul>


<hr>
<h2 id='amounts'>Frequency tables for medication amount</h2><span id='topic+amounts'></span>

<h3>Description</h3>

<p>The function <code>amounts()</code> calculates the number of unique
medications for each individual and presents the count frequencies by
cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amounts(
  clustering,
  only = NULL,
  clusters = NULL,
  count_grouper = function(x) {
     cut(x, breaks = c(0, 1, 2, Inf), labels = c("1",
    "2", "3+"))
 },
  additional_data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amounts_+3A_only">only</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>object</code> and/or <code>additional_data</code>.
</p>
<p>The default <code>NULL</code> selects all clusterings in <code>object</code>.</p>
</td></tr>
<tr><td><code id="amounts_+3A_clusters">clusters</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the cluster or clusters in <code>object</code> one wants to
see summaries of. Names can be used as if they were positions in the data
frame, so expressions like I:IV can be used to select a range of clusters.
</p>
<p>The default <code>NULL</code> selects all clusters in the chosen clusterings of
<code>object</code>.</p>
</td></tr>
<tr><td><code id="amounts_+3A_count_grouper">count_grouper</code></td>
<td>
<p>A function for grouping counts. As a standard it groups
counts as 1 medication, 2 medications, and 3+ medications.</p>
</td></tr>
<tr><td><code id="amounts_+3A_additional_data">additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>. This is often
used in conjuction with <code>only</code> to select specific clusterings based on
<code>additional_data</code>.</p>
</td></tr>
<tr><td><code id="amounts_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the internal summary function.
</p>

<ul>
<li> <p><code>cluster_wise</code>  an option in the <code>medications()</code> function.
</p>
</li>
<li> <p><code>m</code> an option in the <code>medications()</code> function. A numeric restricting the
number of distinct ATC codes plotted within each cluster. That is, the
(at most) <code>m</code> most frequent ATC codes within that cluster is given a
color.
</p>
</li>
<li> <p><code>q</code> an option in the <code>medications()</code> function. A numeric between 0 and 1
restricting the minimal ATC codes frequency displayed within each
cluster.
</p>
</li>
<li> <p><code>count_grouper</code> an option in the <code>amounts()</code> function. A function for
grouping counts. As a standard it groups counts as 1 medication, 2
medications, and 3+ medications.
</p>
</li>
<li> <p><code>atc_groups</code> A data.frame specifying the ATC groups to summaries by. The
data.frame must have two columns: (1) <code>regex</code> giving regular expressions
specifying the wanted ATC groups and (2) <code>atc_groups</code> the name of this
ATC grouping. As a standard the anatomical level (first level) of the ATC
codes is used.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>amounts()</code> calculates the number of ATC codes an individual has, and then
outputs the number of individuals within a cluster that has that many ATC
codes. Moreover, various relevant percentages or calculated. See Value below
for more details on these percentages.
</p>


<h3>Value</h3>

<p><code>amounts()</code> returns a data frame of class <code>summary.medic.amounts</code>
</p>

<ul>
<li> <p><code>cluster_name</code> the name of the clustering.
</p>
</li>
<li> <p><code>cluster</code> the cluster name.
</p>
</li>
<li> <p><code>m</code> number of ATC codes.
</p>
</li>
<li> <p><code>n_people</code> number of people in <code>cluster</code> that has <code>m</code> different ATC codes.
</p>
</li>
<li> <p><code>n_medications</code> the total number of medication across people in this
<code>cluster</code> with <code>m</code> different ATC codes.
</p>
</li>
<li> <p><code>p_people_analysis</code> percentage of people in <code>cluster</code> with <code>m</code> different
ATC codes in analysis.
</p>
</li>
<li> <p><code>p_people_cluster</code> percentage of people with <code>m</code> different ATC codes in
<code>cluster</code>.
</p>
</li>
<li> <p><code>p_medications_in_analysis</code> percentage of medication given in <code>cluster</code>
with <code>m</code> different ATC codes in analysis.
</p>
</li>
<li> <p><code>p_medications_in_cluster</code> percentage of medication given with <code>m</code>
different ATC codes in <code>cluster</code>.
</p>
</li>
<li> <p><code>p_people_with_n_unique_medications</code> percentage of people in <code>cluster</code>
with <code>m</code> different ATC codes.
</p>
</li>
<li> <p><code>p_medications_with_n_unique_medications</code> percentage of medication in
<code>cluster</code> with <code>m</code> different ATC codes.
</p>
</li></ul>


<hr>
<h2 id='cluster_selector'>Finding chosen cluster names</h2><span id='topic+cluster_selector'></span>

<h3>Description</h3>

<p>The <code>cluster_selector()</code> function finds the name of the chosen clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_selector(clustering, clusters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_selector_+3A_clusters">clusters</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the cluster or clusters in <code>object</code> one wants to
see summaries of. Names can be used as if they were positions in the data
frame, so expressions like I:IV can be used to select a range of clusters.
</p>
<p>The default <code>NULL</code> selects all clusters in the chosen clusterings of
<code>object</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cluster_selector()</code> finds the names of the chosen clusters present in
the <code>clustering</code> &lt;<code>medic</code>&gt; object. This function is used in all of
the investigative functions called by <code><a href="base.html#topic+summary">summary()</a></code>.
</p>


<h3>Value</h3>

<p>A character vector with the names of the chosen clusters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+method_selector">method_selector()</a></code> is another selector method used through out
the package.
</p>

<hr>
<h2 id='complications'>A Simulated Data Set About Pregnancy Complications</h2><span id='topic+complications'></span>

<h3>Description</h3>

<p>We use this data set in all the examples in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complications
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 149 rows and 8 columns.
</p>

<hr>
<h2 id='eczema'>A Simulated Data Set About Eczema</h2><span id='topic+eczema'></span>

<h3>Description</h3>

<p>A Simulated Data Set About Eczema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eczema
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 50644 rows and 7 columns.
</p>

<hr>
<h2 id='employ'>Employ a Clustering to New Data</h2><span id='topic+employ'></span>

<h3>Description</h3>

<p>Employ a clustering to new data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>employ(
  object,
  new_data,
  only = NULL,
  additional_data = NULL,
  assignment_method = "nearest_cluster",
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="employ_+3A_object">object</code></td>
<td>
<p>A <code>medic</code> clustering object for which employment is desired.</p>
</td></tr>
<tr><td><code id="employ_+3A_new_data">new_data</code></td>
<td>
<p>A data frame in which to look for variables with</p>
</td></tr>
<tr><td><code id="employ_+3A_only">only</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>object</code> and/or <code>additional_data</code> and specifies which clusterings should be
employed to the new data.</p>
</td></tr>
<tr><td><code id="employ_+3A_additional_data">additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>. This is often
used in conjuction with <code>only</code> to select specific clusterings based on
<code>additional_data</code>.</p>
</td></tr>
<tr><td><code id="employ_+3A_assignment_method">assignment_method</code></td>
<td>
<p>A character naming the employment method. The
default assignment method <code>"nearest_cluster"</code> matches people in <code>new_data</code>
to their nearest cluster in the chosen clusterings from <code>object</code>. As
finding exact matches (the next assignment method) is contained within this
strategy the <code>"exact_only"</code> matches are also reported in additional columns
in the output.
</p>
<p>The assignment method <code>"exact_only"</code> only matches a person from <code>new_data</code>
to a cluster if they are a perfect match to anyone in <code>object</code>. Thus,
people from <code>new_data</code> are not guaranteed assignment to a cluster.</p>
</td></tr>
<tr><td><code id="employ_+3A_parallel">parallel</code></td>
<td>
<p>A logical or an integer. If <code>FALSE</code>, the default, no
parallelization is done.
</p>
<p>If <code>TRUE</code> or an integer larger than 2L parallelization is implemented via
<a href="parallel.html#topic+clusterApply">parLapply</a> from the <strong>parallel</strong> package. When
<code>parallel</code> is <code>TRUE</code> the number of <a href="parallel.html#topic+makeCluster">clusters</a>
is set to <a href="parallel.html#topic+detectCores">detectCores</a> - 1, and when <code>parallel</code> is
an integer then the number of <a href="parallel.html#topic+makeCluster">clusters</a> is set to
<code>parallel</code>. For more details on the parallelization method see
<a href="parallel.html#topic+clusterApply">parallel::parLapply</a>.</p>
</td></tr>
<tr><td><code id="employ_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the employment procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>employ</code> returns a <code>medic</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>part1 &lt;- complications[1:100,]
part2 &lt;- complications[101:149,]

clust &lt;- medic(part1, id = id, atc = atc, k = 3)

# Nearest cluster matching
employ(clust, part2)

# Only exact matching
employ(clust, part2, assignment_method = "exact_only")

</code></pre>

<hr>
<h2 id='enrich'>Enrich Clustering Parameter</h2><span id='topic+enrich'></span>

<h3>Description</h3>

<p>Enrich the parameter information in a clustering with user-defined data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enrich(object, additional_data = NULL, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enrich_+3A_object">object</code></td>
<td>
<p>A <code>medic</code> object for enrichment.</p>
</td></tr>
<tr><td><code id="enrich_+3A_additional_data">additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>.</p>
</td></tr>
<tr><td><code id="enrich_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by. This variables is
passed to the <code>by</code> term in a <code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code> and inherits its
behavior:
</p>
<p>If <code>NULL</code>, the default, the join will perform a natural join, using all
variables in common across the <code>parameters</code> and
<code>additional_data</code>.
</p>
<p>To join by different variables on <code>parameters</code> and
<code>additional_data</code>, use a named vector. For example,
<code>by = c("k" = "cluster_size")</code> will match <code>parameters$k</code> to
<code>additional_data$cluster_size</code>.
</p>
<p>To join by multiple variables, use a vector with length &gt; 1. For example,
<code>by = c("k", "summation_method")</code> will match <code>parameters$k</code> to
<code>additional_data$k</code> and <code>parameters$summation_method</code> to <br />
<code>additional_data$summation_method</code>. Use a named vector to match different
variables in <code>parameters</code> and <code>additional_data</code>.
</p>
<p>For example, <code>by = c("k" = "cluster_size", "summation_method" = "sm")</code>
will match <code>parameters$k</code> to <code>additional_data$cluster_size</code> and
<code>parameters$summation_method</code> to <code>additional_data$sm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>enrich()</code> function is a joining function used for enriching the
clustering characteristics with user-defined data. This function is used in
all of the investigative functions with a <code>additional_data</code> statement such as
<code><a href="#topic+frequencies">frequencies()</a></code> and <code><a href="#topic+amounts">amounts()</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <em>medic</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clust &lt;- medic(
   complications,
   id = id,
   atc = atc,
   timing = first_trimester:third_trimester,
   k = 3:5
)

new_parameters &lt;- data.frame(k = 3:5, size = c("small", "small", "large"))

enrich(clust, new_parameters)

</code></pre>

<hr>
<h2 id='frequencies'>The Frequency of Assignment to Each Cluster</h2><span id='topic+frequencies'></span>

<h3>Description</h3>

<p>The function <code>frequencies()</code> calculates the number and frequency of
individuals assigned to each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frequencies(
  clustering,
  only = NULL,
  clusters = NULL,
  additional_data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frequencies_+3A_only">only</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>object</code> and/or <code>additional_data</code>.
</p>
<p>The default <code>NULL</code> selects all clusterings in <code>object</code>.</p>
</td></tr>
<tr><td><code id="frequencies_+3A_clusters">clusters</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the cluster or clusters in <code>object</code> one wants to
see summaries of. Names can be used as if they were positions in the data
frame, so expressions like I:IV can be used to select a range of clusters.
</p>
<p>The default <code>NULL</code> selects all clusters in the chosen clusterings of
<code>object</code>.</p>
</td></tr>
<tr><td><code id="frequencies_+3A_additional_data">additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>. This is often
used in conjuction with <code>only</code> to select specific clusterings based on
<code>additional_data</code>.</p>
</td></tr>
<tr><td><code id="frequencies_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the internal summary function.
</p>

<ul>
<li> <p><code>cluster_wise</code>  an option in the <code>medications()</code> function.
</p>
</li>
<li> <p><code>m</code> an option in the <code>medications()</code> function. A numeric restricting the
number of distinct ATC codes plotted within each cluster. That is, the
(at most) <code>m</code> most frequent ATC codes within that cluster is given a
color.
</p>
</li>
<li> <p><code>q</code> an option in the <code>medications()</code> function. A numeric between 0 and 1
restricting the minimal ATC codes frequency displayed within each
cluster.
</p>
</li>
<li> <p><code>count_grouper</code> an option in the <code>amounts()</code> function. A function for
grouping counts. As a standard it groups counts as 1 medication, 2
medications, and 3+ medications.
</p>
</li>
<li> <p><code>atc_groups</code> A data.frame specifying the ATC groups to summaries by. The
data.frame must have two columns: (1) <code>regex</code> giving regular expressions
specifying the wanted ATC groups and (2) <code>atc_groups</code> the name of this
ATC grouping. As a standard the anatomical level (first level) of the ATC
codes is used.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>frequencies()</code> calculates the number of individuals assigned to
each cluster and the associated frequency of assignment.
</p>


<h3>Value</h3>

<p><code>frequencies()</code> returns a data frame with class
<code>summary.medic.frequencies</code>.
</p>

<ul>
<li> <p><code>cluster_name</code> the name of the clustering.
</p>
</li>
<li> <p><code>cluster</code> the cluster name.
</p>
</li>
<li> <p><code>n</code> the number of observations assigned to this <code>cluster</code>.
</p>
</li>
<li> <p><code>p</code> the percent of observations assigned to this <code>cluster</code>.
</p>
</li></ul>


<hr>
<h2 id='interactions'>Timing and ATC pattern interactions</h2><span id='topic+interactions'></span>

<h3>Description</h3>

<p>The function <code>interactions()</code> calculates the frequencies of distinct timing
and ATC combinations within clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactions(
  clustering,
  only = NULL,
  clusters = NULL,
  atc_groups = data.frame(regex = paste0("^", LETTERS), atc_groups = LETTERS),
  additional_data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interactions_+3A_only">only</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>object</code> and/or <code>additional_data</code>.
</p>
<p>The default <code>NULL</code> selects all clusterings in <code>object</code>.</p>
</td></tr>
<tr><td><code id="interactions_+3A_clusters">clusters</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the cluster or clusters in <code>object</code> one wants to
see summaries of. Names can be used as if they were positions in the data
frame, so expressions like I:IV can be used to select a range of clusters.
</p>
<p>The default <code>NULL</code> selects all clusters in the chosen clusterings of
<code>object</code>.</p>
</td></tr>
<tr><td><code id="interactions_+3A_atc_groups">atc_groups</code></td>
<td>
<p>A data.frame specifying the ATC groups to summaries by. The
data.frame must have two columns:
</p>

<ul>
<li> <p><code>regex</code> giving regular expressions specifying the wanted ATC groups.
</p>
</li>
<li> <p><code>atc_groups</code> the name of this ATC grouping.
</p>
</li></ul>

<p>As a standard the anatomical level (first level) of the ATC codes is used.</p>
</td></tr>
<tr><td><code id="interactions_+3A_additional_data">additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>. This is often
used in conjuction with <code>only</code> to select specific clusterings based on
<code>additional_data</code>.</p>
</td></tr>
<tr><td><code id="interactions_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the internal summary function.
</p>

<ul>
<li> <p><code>cluster_wise</code>  an option in the <code>medications()</code> function.
</p>
</li>
<li> <p><code>m</code> an option in the <code>medications()</code> function. A numeric restricting the
number of distinct ATC codes plotted within each cluster. That is, the
(at most) <code>m</code> most frequent ATC codes within that cluster is given a
color.
</p>
</li>
<li> <p><code>q</code> an option in the <code>medications()</code> function. A numeric between 0 and 1
restricting the minimal ATC codes frequency displayed within each
cluster.
</p>
</li>
<li> <p><code>count_grouper</code> an option in the <code>amounts()</code> function. A function for
grouping counts. As a standard it groups counts as 1 medication, 2
medications, and 3+ medications.
</p>
</li>
<li> <p><code>atc_groups</code> A data.frame specifying the ATC groups to summaries by. The
data.frame must have two columns: (1) <code>regex</code> giving regular expressions
specifying the wanted ATC groups and (2) <code>atc_groups</code> the name of this
ATC grouping. As a standard the anatomical level (first level) of the ATC
codes is used.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>interactions()</code> calculates both the number of people with unique timing
trajectory and ATC group, as given by <code>atc_groups</code>, in each cluster.
</p>


<h3>Value</h3>

<p><code>interactions()</code> returns a data frame of class <code>summary.medic.interactions</code>
</p>

<ul>
<li> <p><code>cluster_name</code> the name of the clustering.
</p>
</li>
<li> <p><code>cluster</code> the cluster name.
</p>
</li>
<li> <p><code>n</code> the number of people in the cluster.
</p>
</li>
<li> <p><code>atc_group</code> ATC groups as specified by the <code>atc_groups</code> input.
</p>
</li>
<li> <p><em>timing variable</em> a unique timing pattern in <code>cluster</code> and <code>atc_group</code>.
</p>
</li>
<li> <p><code>n_interaction</code> number of people in this cluster with this timing and atc
group combination.
</p>
</li></ul>


<hr>
<h2 id='is.medic'>Test if an object is a medic-object</h2><span id='topic+is.medic'></span>

<h3>Description</h3>

<p>Test if an object is a medic-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.medic(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.medic_+3A_object">object</code></td>
<td>
<p>Any object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> is the object inherits from the <code>medic</code> class and has the required
elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clust &lt;- medic(complications, id = id, atc = atc, k = 3)
is.medic(clust)

</code></pre>

<hr>
<h2 id='medic'>Medication clustering (based on ATC and timing)</h2><span id='topic+medic'></span>

<h3>Description</h3>

<p>The <code>medic</code> method uses agglomerative hierarchical clustering with a
bespoke distance measure based on medication ATC codes similarities,
medication timing and medication amount or dosage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medic(
  data,
  k = 5,
  id,
  atc,
  timing,
  base_clustering,
  linkage = "complete",
  summation_method = "sum_of_minima",
  alpha = 1,
  beta = 1,
  gamma = 1,
  p = 1,
  theta = (5:0)/5,
  parallel = FALSE,
  return_distance_matrix = FALSE,
  set_seed = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medic_+3A_data">data</code></td>
<td>
<p>A data frame containing all the variables for the clustering.</p>
</td></tr>
<tr><td><code id="medic_+3A_k">k</code></td>
<td>
<p>a vector specifying the number of clusters to identify.</p>
</td></tr>
<tr><td><code id="medic_+3A_id">id</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the variable in <code>data</code> describing person id.</p>
</td></tr>
<tr><td><code id="medic_+3A_atc">atc</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the variable in <code>data</code> containing ATC codes.</p>
</td></tr>
<tr><td><code id="medic_+3A_timing">timing</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the variable or variables in <code>data</code> describing
medication timing. Variable names can be used as if they were positions in
the data frame, so expressions like x:y can be used to select a range of
variables. Moreover, pattern matching selection helpers such as
<code><a href="tidyselect.html#topic+starts_with">starts_with</a></code> or
<code><a href="tidyselect.html#topic+starts_with">num_range</a></code> may also be used to select timing
variables.</p>
</td></tr>
<tr><td><code id="medic_+3A_base_clustering">base_clustering</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An
unquoted expression naming the variable in <code>data</code> that gives an initial
clustering to start the <code>medic</code> from or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="medic_+3A_linkage">linkage</code></td>
<td>
<p>The agglomeration method to be used in the clustering. This
should be (an unambiguous abbreviation of) one of &quot;ward.D&quot;, &quot;ward.D2&quot;,
&quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot;
(= WPGMC) or &quot;centroid&quot; (= UPGMC). See <a href="stats.html#topic+hclust">stats::hclust</a> for more
information. For a discussion of linkage criterion choice see
<em>details</em> below.</p>
</td></tr>
<tr><td><code id="medic_+3A_summation_method">summation_method</code></td>
<td>
<p>The summation method used in the distance measure.
This  should be either &quot;double_sum&quot; or &quot;sum_of_minima&quot;. See
<em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="medic_+3A_alpha">alpha</code></td>
<td>
<p>A number giving the tuning of the normalization. See
<em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="medic_+3A_beta">beta</code></td>
<td>
<p>A number giving the power of the individual medication
combinations. See <em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="medic_+3A_gamma">gamma</code></td>
<td>
<p>A number giving the weight of the timing terms. See
<em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="medic_+3A_p">p</code></td>
<td>
<p>The power of the Minkowski distance used in the timing-specific
distance. See <em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="medic_+3A_theta">theta</code></td>
<td>
<p>A vector of length 6 specifying the tuning of the ATC measure.
See <em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="medic_+3A_parallel">parallel</code></td>
<td>
<p>A logical or an integer. If <code>FALSE</code>, the default, no
parallelization is done.
</p>
<p>If <code>TRUE</code> or an integer larger than 2L parallelization is implemented via
<a href="parallel.html#topic+clusterApply">parLapply</a> from the <strong>parallel</strong> package. When
<code>parallel</code> is <code>TRUE</code> the number of <a href="parallel.html#topic+makeCluster">clusters</a>
is set to <a href="parallel.html#topic+detectCores">detectCores</a> - 1, and when <code>parallel</code> is
an integer then the number of <a href="parallel.html#topic+makeCluster">clusters</a> is set to
<code>parallel</code>. For more details on the parallelization method see
<a href="parallel.html#topic+clusterApply">parallel::parLapply</a>.</p>
</td></tr>
<tr><td><code id="medic_+3A_return_distance_matrix">return_distance_matrix</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="medic_+3A_set_seed">set_seed</code></td>
<td>
<p>A logical or an integer.</p>
</td></tr>
<tr><td><code id="medic_+3A_...">...</code></td>
<td>
<p>Additional arguments not currently in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>medic</code> method uses agglomerative hierarchical
clustering with a bespoke distance measure based on medication ATC codes and
timing similarities to assign medication pattern clusters to people.
</p>
<p>Two versions of the distance measure are available:
</p>
<p>The <em>double sum</em>:
</p>
<p style="text-align: center;"><code class="reqn">%
  d(p_i, p_j) = N_{\alpha}(M_i \times M_j) \sum_{m\in M_i}\sum_{n \in M_j}%
  ((1 + D_{\theta}(m,n)) (1 + \gamma T_p(t_{im},t_{jn})) - 1)^{\beta}.%
</code>
</p>

<p>and the <em>sum of minima</em>:
</p>
<p style="text-align: center;"><code class="reqn">%
  d(p_i, p_j) = \frac{1}{2}(N_{\alpha}(M_i)\sum_{m\in M_i}\min_{n \in M_j}%
  ((1 + D_{\theta}(m,n)) (1 + \gamma T_p(t_{im},t_{jn})) - 1)^{\beta} +
  N_{\alpha}(M_j) \sum_{n\in M_j}\min_{m \in M_i}%
  ((1 + D_{\theta}(m,n)) (1 + \gamma T_p(t_{im},t_{jn})) - 1)^{\beta}).%
</code>
</p>



<h4>Normalization</h4>

<p style="text-align: center;"><code class="reqn">%
  N_{\alpha}(x) = |x|^{-\alpha}%
</code>
</p>

<p>If the normalization tuning, <code>alpha</code>, is 0, then no normalization is
preformed and the distance measure becomes highly dependent on the number of
distinct medications given. That is, people using more medication will have
larger distances to others. If the normalization tuning, <code>alpha</code>, is 1 -
the default - then the summation is normalized with the number of terms in
the sum, in other words, the average is calculated.
</p>



<h4>ATC distance</h4>

<p>The central idea of this method, namely the ATC distance, is given as
</p>
<p style="text-align: center;"><code class="reqn">%
  D_{\theta}(x, y) = \sum_{i=1,...,5}1\{x and y match on level i, but not level i + 1\}\theta_i%
</code>
</p>

<p>The ATC distance is tuned using the vector <code>theta</code>.
</p>
<p>Note that two ATC codes are said to match at level i when they are identical
at level i. E.g. the two codes N06AB01 and N06AA01 match on level 1, 2, and 3
as they are both &quot;N&quot; at level 1, &quot;N06&quot; at level 2, and &quot;N06A&quot; at level 3,
but at level 4 they differ (&quot;N06AB&quot; and &quot;N06AA&quot; are not the same).
</p>



<h4>Timing distance</h4>

<p>The timing distance is a simple Minkowski distance:
</p>
<p style="text-align: center;"><code class="reqn">%
  T(x,y) =(\sum_{t \in T} |x_t - y_t|^p)^{1/p}.%
</code>
</p>

<p>When <code>p</code> is 1, the default, the Manhattan distance is used.
</p>



<h3>Value</h3>

<p>An object of class <em>medic</em> which describes the clusters produced
the hierarchical clustering process. The object is a list with components:
</p>

<dl>
<dt>data</dt><dd><p>the inputted data frame <code>data</code> with the cluster
assignments appended at the end.</p>
</dd>
<dt>clustering</dt><dd><p>a data frame with the person id as given by <code>id</code>,
the <code>.analysis_order</code> and the clusters found.</p>
</dd>
<dt>variables</dt><dd><p>a list of the variables used in the clustering.</p>
</dd>
<dt>parameters</dt><dd><p>a data frame with all the inputted clustering
parameters and the corresponding method names. These method names
correspond to the column names for each cluster in the <code>clustering</code>
data frame described right above.</p>
</dd>
<dt>key</dt><dd><p>a list of keys used internally in the function to keep track of
simplified versions of the data.</p>
</dd>
<dt>distance_matrix</dt><dd><p>the distance matrices for each method if
<code>return_distance_matrix</code> is <code>TRUE</code> otherwise <code>NULL</code>.</p>
</dd>
<dt>call</dt><dd><p>the matched call.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><a href="#topic+summary.medic">summary.medic</a> for summaries and plots.
</p>
<p><a href="#topic+employ">employ</a> for employing an existing clustering to new data.
</p>
<p><a href="#topic+enrich">enrich</a> for enriching the meta data in the <code>medic</code> object with additional
data.
</p>
<p><a href="dplyr.html#topic+bind">bind</a> for binding together two comparable lists of clusterings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple clustering based only on ATC
clust &lt;- medic(complications, id = id, atc = atc, k = 3)

# A simple clustering with both ATC and timing
clust &lt;- medic(
  complications,
  id = id,
  atc = atc,
  timing = first_trimester:third_trimester,
  k = 3
)


</code></pre>

<hr>
<h2 id='medications'>ATC Code Frequency Within Clusters</h2><span id='topic+medications'></span>

<h3>Description</h3>

<p>The function <code>medications()</code> calculates the frequency of the different
unique ATC codes within each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medications(
  clustering,
  only = NULL,
  clusters = NULL,
  cluster_wise = TRUE,
  m = 3,
  q = 0.05,
  additional_data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medications_+3A_only">only</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>object</code> and/or <code>additional_data</code>.
</p>
<p>The default <code>NULL</code> selects all clusterings in <code>object</code>.</p>
</td></tr>
<tr><td><code id="medications_+3A_clusters">clusters</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the cluster or clusters in <code>object</code> one wants to
see summaries of. Names can be used as if they were positions in the data
frame, so expressions like I:IV can be used to select a range of clusters.
</p>
<p>The default <code>NULL</code> selects all clusters in the chosen clusterings of
<code>object</code>.</p>
</td></tr>
<tr><td><code id="medications_+3A_cluster_wise">cluster_wise</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="medications_+3A_m">m</code></td>
<td>
<p>A numeric restricting the number of distinct ATC codes plotted
within each cluster. That is, the (at most) <code>m</code> most frequent ATC
codes within that cluster is given a color.</p>
</td></tr>
<tr><td><code id="medications_+3A_q">q</code></td>
<td>
<p>A numeric between 0 and 1 restricting the minimal ATC codes
frequency displayed within each cluster.</p>
</td></tr>
<tr><td><code id="medications_+3A_additional_data">additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>. This is often
used in conjuction with <code>only</code> to select specific clusterings based on
<code>additional_data</code>.</p>
</td></tr>
<tr><td><code id="medications_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the internal summary function.
</p>

<ul>
<li> <p><code>cluster_wise</code>  an option in the <code>medications()</code> function.
</p>
</li>
<li> <p><code>m</code> an option in the <code>medications()</code> function. A numeric restricting the
number of distinct ATC codes plotted within each cluster. That is, the
(at most) <code>m</code> most frequent ATC codes within that cluster is given a
color.
</p>
</li>
<li> <p><code>q</code> an option in the <code>medications()</code> function. A numeric between 0 and 1
restricting the minimal ATC codes frequency displayed within each
cluster.
</p>
</li>
<li> <p><code>count_grouper</code> an option in the <code>amounts()</code> function. A function for
grouping counts. As a standard it groups counts as 1 medication, 2
medications, and 3+ medications.
</p>
</li>
<li> <p><code>atc_groups</code> A data.frame specifying the ATC groups to summaries by. The
data.frame must have two columns: (1) <code>regex</code> giving regular expressions
specifying the wanted ATC groups and (2) <code>atc_groups</code> the name of this
ATC grouping. As a standard the anatomical level (first level) of the ATC
codes is used.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>medication()</code> calculates the number of individuals with a specific ATC
code within a cluster. Moreover, it calculates the percentage of people with
this medication assigned to this cluster and the percent of people within
the cluster with this medication.
</p>


<h3>Value</h3>

<p><code>medications()</code> returns a data frame with class
<code>summary.medic.medications</code>.
</p>

<ul>
<li> <p><code>cluster_name</code> the name of the clustering.
</p>
</li>
<li> <p><code>cluster</code> the cluster name.
</p>
</li>
<li> <p><code>atc</code> ATC codes.
</p>
</li>
<li> <p><code>n</code> number of people with this ATC code in this <code>cluster</code>.
</p>
</li>
<li> <p><code>p_analysis</code> the percentage of people with this ATC code assigned to this
<code>cluster</code>.
</p>
</li>
<li> <p><code>p_cluster</code> the percent of people within the <code>cluster</code> with this ATC code.
</p>
</li></ul>


<hr>
<h2 id='method_selector'>Method Selector</h2><span id='topic+method_selector'></span>

<h3>Description</h3>

<p>The <code>method_selector()</code> is a filtering function for extracting only the
relevant <code>parameters</code> from a &lt;<code>medic</code>&gt; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method_selector(clustering, only, additional_data = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="method_selector_+3A_only">only</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>object</code> and/or <code>additional_data</code>.
</p>
<p>The default <code>NULL</code> selects all clusterings in <code>object</code>.</p>
</td></tr>
<tr><td><code id="method_selector_+3A_additional_data">additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>. This is often
used in conjuction with <code>only</code> to select specific clusterings based on
<code>additional_data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>method_selector()</code> function is a filtering function used for extracting
the characteristics of the chosen method. This function is used in all of
the investigative functions called by <code><a href="base.html#topic+summary">summary()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>parameters</code> data frame with at least the following columns
</p>

<ul>
<li> <p><code>cluster_name</code> the name of the clustering cluster_name.
</p>
</li>
<li> <p><code>clustering</code> the name of the clustering group before the number of
clusters is chosen.
</p>
</li>
<li> <p><code>linkage</code> the linkage criteria.
</p>
</li>
<li> <p><code>alpha</code> the normalization tuning.
</p>
</li>
<li> <p><code>beta</code> the timing importance tuning.
</p>
</li>
<li> <p><code>gamma</code> the dose importance tuning.
</p>
</li>
<li> <p><code>theta</code> the ATC measure tuning.
</p>
</li>
<li> <p><code>k</code> the number of clusters.
</p>
</li></ul>

<p>where each row specifies the parameters for the chosen methods. Any
additional columns present in the the outcome are from the
<code>additional_data</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster_selector">cluster_selector()</a></code> is another selector method used through out
the package.
</p>

<hr>
<h2 id='parameters_constructor'>Internal option constructor</h2><span id='topic+parameters_constructor'></span>

<h3>Description</h3>

<p>Given the input of the <code>medic</code> this function checks the
input and constructs a data frame with the analysis parameters specified by
the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters_constructor(
  data,
  id,
  k = 5,
  atc,
  timing,
  base_clustering,
  linkage = "complete",
  summation_method = "sum_of_minima",
  alpha = 1,
  beta = 1,
  gamma = 1,
  p = 1,
  theta = (5:0)/5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parameters_constructor_+3A_data">data</code></td>
<td>
<p>A data frame containing all the variables for the clustering.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_id">id</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the variable in <code>data</code> describing person id.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_k">k</code></td>
<td>
<p>a vector specifying the number of clusters to identify.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_atc">atc</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the variable in <code>data</code> containing ATC codes.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_timing">timing</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the variable or variables in <code>data</code> describing
medication timing. Variable names can be used as if they were positions in
the data frame, so expressions like x:y can be used to select a range of
variables. Moreover, pattern matching selection helpers such as
<code><a href="tidyselect.html#topic+starts_with">starts_with</a></code> or
<code><a href="tidyselect.html#topic+starts_with">num_range</a></code> may also be used to select timing
variables.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_base_clustering">base_clustering</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An
unquoted expression naming the variable in <code>data</code> that gives an initial
clustering to start the <code>medic</code> from or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_linkage">linkage</code></td>
<td>
<p>The agglomeration method to be used in the clustering. This
should be (an unambiguous abbreviation of) one of &quot;ward.D&quot;, &quot;ward.D2&quot;,
&quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot;
(= WPGMC) or &quot;centroid&quot; (= UPGMC). See <a href="stats.html#topic+hclust">stats::hclust</a> for more
information. For a discussion of linkage criterion choice see
<em>details</em> below.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_summation_method">summation_method</code></td>
<td>
<p>The summation method used in the distance measure.
This  should be either &quot;double_sum&quot; or &quot;sum_of_minima&quot;. See
<em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_alpha">alpha</code></td>
<td>
<p>A number giving the tuning of the normalization. See
<em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_beta">beta</code></td>
<td>
<p>A number giving the power of the individual medication
combinations. See <em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_gamma">gamma</code></td>
<td>
<p>A number giving the weight of the timing terms. See
<em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_p">p</code></td>
<td>
<p>The power of the Minkowski distance used in the timing-specific
distance. See <em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_theta">theta</code></td>
<td>
<p>A vector of length 6 specifying the tuning of the ATC measure.
See <em>details</em> below for more information.</p>
</td></tr>
<tr><td><code id="parameters_constructor_+3A_...">...</code></td>
<td>
<p>Additional arguments not currently in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the parameters for clustering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parameters_constructor(
   data = complications, 
   k = 3, 
   id = id,
   atc = atc
)

</code></pre>

<hr>
<h2 id='refactor'>Refactor Cluster Levels</h2><span id='topic+refactor'></span>

<h3>Description</h3>

<p>Refactor the levels of the chosen clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refactor(object, ..., inheret_parameters = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refactor_+3A_object">object</code></td>
<td>
<p>A <code>medic</code> object.</p>
</td></tr>
<tr><td><code id="refactor_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Name-value pairs.
<code>...</code> is passed to <code><a href="dplyr.html#topic+mutate">dplyr::mutate</a></code>, and therefor inherits its behavior:
</p>
<p>The name gives the name of the new clustering in the output. The value can
be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A function of another clustering.
</p>
</li></ul>

<p>When a recording uses the name of an existing clustering, this new
clustering will overwrite the existing one.</p>
</td></tr>
<tr><td><code id="refactor_+3A_inheret_parameters">inheret_parameters</code></td>
<td>
<p>A logical. If <code>TRUE</code> a new clustering overwriting
an existing clustering inherits the <code>parameters</code> of the old.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>medic</code> object with relevant clusterings refactored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
clust &lt;- medic(complications, id = id, atc = atc, k = 3:4)

# Refactor one clustering
refactor(
  clust,
  `cluster_1_k=4` = dplyr::recode(`cluster_1_k=4`, IV = "III")
)

# Refactor all clusterings
refactor(
  clust,
  dplyr::across(
    dplyr::everything(),
    ~dplyr::recode(., IV = "III")
  )
)

</code></pre>

<hr>
<h2 id='summary.medic'>Summary of medic object</h2><span id='topic+summary.medic'></span><span id='topic+print.summary.medic'></span><span id='topic+plot.summary.medic'></span>

<h3>Description</h3>

<p>Make cluster characterizing summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'medic'
summary(
  object,
  only = NULL,
  clusters = NULL,
  outputs = c("frequencies", "medications", "amounts", "trajectories", "interactions"),
  additional_data = NULL,
  ...
)

## S3 method for class 'summary.medic'
print(x, ...)

## S3 method for class 'summary.medic'
plot(x, by, facet, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.medic_+3A_object">object</code></td>
<td>
<p>An object for which a summary is desired.</p>
</td></tr>
<tr><td><code id="summary.medic_+3A_only">only</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>object</code> and/or <code>additional_data</code>.
</p>
<p>The default <code>NULL</code> selects all clusterings in <code>object</code>.</p>
</td></tr>
<tr><td><code id="summary.medic_+3A_clusters">clusters</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the cluster or clusters in <code>object</code> one wants to
see summaries of. Names can be used as if they were positions in the data
frame, so expressions like I:IV can be used to select a range of clusters.
</p>
<p>The default <code>NULL</code> selects all clusters in the chosen clusterings of
<code>object</code>.</p>
</td></tr>
<tr><td><code id="summary.medic_+3A_outputs">outputs</code></td>
<td>
<p>A character vector naming the desired characteristics to
output. The default names all possible output types.</p>
</td></tr>
<tr><td><code id="summary.medic_+3A_additional_data">additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>. This is often
used in conjuction with <code>only</code> to select specific clusterings based on
<code>additional_data</code>.</p>
</td></tr>
<tr><td><code id="summary.medic_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the internal summary function.
</p>

<ul>
<li> <p><code>cluster_wise</code>  an option in the <code>medications()</code> function.
</p>
</li>
<li> <p><code>m</code> an option in the <code>medications()</code> function. A numeric restricting the
number of distinct ATC codes plotted within each cluster. That is, the
(at most) <code>m</code> most frequent ATC codes within that cluster is given a
color.
</p>
</li>
<li> <p><code>q</code> an option in the <code>medications()</code> function. A numeric between 0 and 1
restricting the minimal ATC codes frequency displayed within each
cluster.
</p>
</li>
<li> <p><code>count_grouper</code> an option in the <code>amounts()</code> function. A function for
grouping counts. As a standard it groups counts as 1 medication, 2
medications, and 3+ medications.
</p>
</li>
<li> <p><code>atc_groups</code> A data.frame specifying the ATC groups to summaries by. The
data.frame must have two columns: (1) <code>regex</code> giving regular expressions
specifying the wanted ATC groups and (2) <code>atc_groups</code> the name of this
ATC grouping. As a standard the anatomical level (first level) of the ATC
codes is used.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summary.medic_+3A_x">x</code></td>
<td>
<p>A <code>summary.medic</code> object for printing or plotting.</p>
</td></tr>
<tr><td><code id="summary.medic_+3A_by">by</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt;</p>
</td></tr>
<tr><td><code id="summary.medic_+3A_facet">facet</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of clustering characteristics of class <code>summary.medic</code> is returned. It
can contain any of the following characteristics:
</p>


<h4>Frequencies</h4>

<p>The number of individuals assigned to each cluster and the associated
frequency of assignment.
</p>



<h4>Medications</h4>

<p>The number of individuals with a specific ATC code within a cluster.
Moreover, it calculates the percentage of people with this medication
assigned to this cluster and the percent of people within the cluster with
this medication.
</p>



<h4>Amounts</h4>

<p>The number of ATC codes an individual has, and then outputs the number of
individuals within a cluster that has that many ATC codes. Moreover, various
relevant percentages or calculated. See Value below for more details on these
percentages.
</p>



<h4>Trajectories</h4>

<p>The number of unique timing trajectories in each cluster, and the average
timing trajectories in each cluster.
</p>



<h4>Interactions</h4>

<p>The number of people with unique timing trajectory and ATC group, as given by
<code>atc_groups</code>, in each cluster.
</p>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(summary.medic)</code>: Print method for medic-objects
</p>
</li>
<li> <p><code>plot(summary.medic)</code>: Plot method for medic-objects
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>clust &lt;- medic(complications, id = id, atc = atc, k = 3:5)

</code></pre>

<hr>
<h2 id='trajectories'>Timing pattern frequency within clusters</h2><span id='topic+trajectories'></span>

<h3>Description</h3>

<p><code>trajectories()</code> calculates the average timing paths within clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trajectories(
  clustering,
  only = NULL,
  clusters = NULL,
  additional_data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trajectories_+3A_only">only</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>object</code> and/or <code>additional_data</code>.
</p>
<p>The default <code>NULL</code> selects all clusterings in <code>object</code>.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_clusters">clusters</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; An unquoted
expression naming the cluster or clusters in <code>object</code> one wants to
see summaries of. Names can be used as if they were positions in the data
frame, so expressions like I:IV can be used to select a range of clusters.
</p>
<p>The default <code>NULL</code> selects all clusters in the chosen clusterings of
<code>object</code>.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_additional_data">additional_data</code></td>
<td>
<p>A data frame with additional data that may be
(left-)joined onto the <code>parameters</code> in <code>object</code>. This is often
used in conjuction with <code>only</code> to select specific clusterings based on
<code>additional_data</code>.</p>
</td></tr>
<tr><td><code id="trajectories_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the internal summary function.
</p>

<ul>
<li> <p><code>cluster_wise</code>  an option in the <code>medications()</code> function.
</p>
</li>
<li> <p><code>m</code> an option in the <code>medications()</code> function. A numeric restricting the
number of distinct ATC codes plotted within each cluster. That is, the
(at most) <code>m</code> most frequent ATC codes within that cluster is given a
color.
</p>
</li>
<li> <p><code>q</code> an option in the <code>medications()</code> function. A numeric between 0 and 1
restricting the minimal ATC codes frequency displayed within each
cluster.
</p>
</li>
<li> <p><code>count_grouper</code> an option in the <code>amounts()</code> function. A function for
grouping counts. As a standard it groups counts as 1 medication, 2
medications, and 3+ medications.
</p>
</li>
<li> <p><code>atc_groups</code> A data.frame specifying the ATC groups to summaries by. The
data.frame must have two columns: (1) <code>regex</code> giving regular expressions
specifying the wanted ATC groups and (2) <code>atc_groups</code> the name of this
ATC grouping. As a standard the anatomical level (first level) of the ATC
codes is used.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>trajectories()</code> calculates both the number of unique timing trajectories in
each cluster and the average timing trajectories in each cluster.
</p>


<h3>Value</h3>

<p><code>trajectories()</code> returns a list of class <code>summary.medic.trajectories</code> with
two data frames:
</p>


<h4>average</h4>


<ul>
<li> <p><code>cluster_name</code> the name of the clustering.
</p>
</li>
<li> <p><code>cluster</code> the <code>cluster</code> name.
</p>
</li>
<li> <p><em>timing variables</em> the average timing value in <code>cluster</code>.
</p>
</li>
<li> <p><code>n</code> the number of people in <code>cluster</code>.
</p>
</li></ul>




<h4>individual</h4>


<ul>
<li> <p><code>cluster_name</code> the name of the clustering.
</p>
</li>
<li> <p><code>cluster</code> the cluster name.
</p>
</li>
<li> <p><em>timing variables</em> a unique timing pattern in <code>cluster</code>.
</p>
</li>
<li> <p><code>n</code> number of people with this unique timing pattern.
</p>
</li></ul>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
