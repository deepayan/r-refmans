<!DOCTYPE html><html><head><title>Help for package betapart</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {betapart}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#betapart'><p>Partitioning beta diversity into turnover and nestedness components</p></a></li>
<li><a href='#bbsData'><p>BBS data by state for two timeslices</p></a></li>
<li><a href='#beta.multi'><p>Multiple-site dissimilarities</p></a></li>
<li><a href='#beta.multi.abund'>
<p>Abundance-based multiple-site dissimilarities</p></a></li>
<li><a href='#beta.pair'>
<p>Incidence-based pair-wise dissimilarities</p></a></li>
<li><a href='#beta.pair.abund'>
<p>Abundance-based pair-wise dissimilarities</p></a></li>
<li><a href='#beta.para.control'>
<p>Specifying Control Values for Internal Parallel Cluster</p></a></li>
<li><a href='#beta.sample'>
<p>Resampling multiple-site dissimilarity for n sites</p></a></li>
<li><a href='#beta.sample.abund'>
<p>Resampling abundance-based multiple-site dissimilarity for n sites</p></a></li>
<li><a href='#beta.temp'>
<p>Temporal change in community composition</p></a></li>
<li><a href='#betapart.core'>
<p>Core calculations of betapart</p></a></li>
<li><a href='#betapart.core.abund'>
<p>Core calculations of betapart for abundance-based dissimilarity measures</p></a></li>
<li><a href='#betatest'><p>A data set of 4 communities, 107 species and a 4D functional space</p></a></li>
<li><a href='#boot.coefs.decay'>
<p>Bootstrapping the parameters of distance-decay models computed with decay.model()</p></a></li>
<li><a href='#bray.part'>
<p>Partitioning pair-wise Bray-Curtis dissimilarities</p></a></li>
<li><a href='#ceram.n'><p>Cerambycidae from Northern European Countries</p></a></li>
<li><a href='#ceram.s'><p>Cerambycidae from Southern European Countries</p></a></li>
<li><a href='#coords.n'><p>Spatial coordinates for Southern European Countries</p></a></li>
<li><a href='#coords.s'><p>Spatial coordinates for Southern European Countries</p></a></li>
<li><a href='#decay.model'>
<p>Fitting distance decay models to pair-wise assemblage similarity</p></a></li>
<li><a href='#functional.beta.multi'>
<p>Multiple-site functional dissimilarities</p></a></li>
<li><a href='#functional.beta.pair'>
<p>Pair-wise functional dissimilarities</p></a></li>
<li><a href='#functional.betapart.core'>
<p>Core calculations of functional dissimilarities metrics</p></a></li>
<li><a href='#functional.betapart.core.pairwise'><p>functional.betapart.core.pairwise</p></a></li>
<li><a href='#inter_geom'><p>Internal function to compute convexhull volume</p></a></li>
<li><a href='#inter_geom_coord'><p>Internal function to compute convexhull volume and vertice coordinates</p></a></li>
<li><a href='#inter_rcdd'><p>Internal function to compute convexhull volume</p></a></li>
<li><a href='#inter_rcdd_coord'><p>Internal function to compute convexhull volume and vertice coordinates</p></a></li>
<li><a href='#phylo.beta.multi'>
<p>Multiple-site phylogenetic dissimilarities</p></a></li>
<li><a href='#phylo.beta.pair'>
<p>Pair-wise phylogenetic dissimilarities</p></a></li>
<li><a href='#phylo.betapart.core'>
<p>Core calculations of phylogenetic dissimilarities metrics</p></a></li>
<li><a href='#plot.decay'>
<p>Plotting distance decay curves from models computed with decay.model()</p></a></li>
<li><a href='#qhull.opt'><p>Specifying control Values for convexhull volume estimation</p></a></li>
<li><a href='#zdep'>
<p>Assessing the differences between parameters of two distance-decay models computed with decay.model().</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Partitioning Beta Diversity into Turnover and Nestedness
Components</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-13</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, fastmatch, geometry, picante, rcdd, doSNOW, foreach,
snow, itertools, minpack.lm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>vegan</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to compute pair-wise dissimilarities (distance matrices) and multiple-site dissimilarities, separating the turnover and nestedness-resultant components of taxonomic (incidence and abundance based), functional and phylogenetic beta diversity.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andres Baselga &lt;andres.baselga@usc.es&gt;</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-13 10:17:06 UTC; andre</td>
</tr>
<tr>
<td>Author:</td>
<td>Andres Baselga [aut, cre],
  David Orme [aut],
  Sebastien Villeger [aut],
  Julien De Bortoli [aut],
  Fabien Leprieur [aut],
  Maxime Logez [aut],
  Sara Martinez-Santalla [aut],
  Ramiro Martin-Devasa [aut],
  Carola Gomez-Rodriguez [aut],
  Rosa M. Crujeiras [aut],
  Renato Henriques-Silva [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-13 17:10:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='betapart'>Partitioning beta diversity into turnover and nestedness components</h2><span id='topic+betapart-package'></span><span id='topic+betapart'></span>

<h3>Description</h3>

<p><span class="pkg">betapart</span> allows computing pair-wise dissimilarities (distance matrices) and multiple-site dissimilarities, separating the turnover 
and nestedness-resultant components of taxonomic (incidence and abundance based), functional and phylogenetic beta diversity.
</p>


<h3>Details</h3>

<p>The partitioning of incidence-based dissimilarity can be performed for two different families of indices: 
Sorensen and Jaccard. The pairwise function <code>beta.pair</code> yields 3 distance matrices accounting 
for the spatial turnover and the nestedness components of beta-diversity. The third distance 
matrix accounts for the sum of both components, i.e. total dissimilarity (a monotonic transformation 
of beta diversity). 
The multiple site function <code>beta.multi</code> yields the spatial turnover and the nestedness components of 
overall dissimilarity, and the sum of both components, total dissimilarity. The basic calculations for all these 
multiple-site measures and pairwise dissimilarity matrices can be computed using the function <code>betapart.core</code>, 
which returns an object of class <code>betapart</code>. This is useful for large datasets as the consuming calculations 
are done only once, and its result can then be used for computing many indices. 
The multiple-site values can be randomly sampled a specified number of times for a specified number of sites using 
the function <code>beta.sample</code>. 
The aforementioned indices used for assessing spatial patterns can also be used for measuring temporal changes in community composition with the 
function <code>beta.temp</code>.
Likewise, an analogous framework has been implemented for separating the two components of abundance-based 
dissimilarity (balanced changes in abundance vs. abundance gradients) using commands <code>beta.pair.abund</code>, <code>beta.multi.abund</code>, 
<code>betapart.core.abund</code>, and <code>beta.sample.abund</code>.
The framework has been extended for functional beta diversity with commands <code>functional.betapart.core</code>, 
<code>functional.beta.pair</code> and <code>functional.beta.multi</code>, and for phylogenetic beta diversity with commands <code>phylo.betapart.core</code>, 
<code>phylo.beta.pair</code> and <code>phylo.beta.multi</code>.
The package also allows fitting negative exponential, power law or Gompertz distance-decay models for assessing the relationship between assemblage (dis)similarity and spatial (or other) distance. <code>decay.model</code> fits the nonlinear distance-decay function via the <span class="pkg">minpack.lm</span> package, <code>plot.decay</code> plots the distance-decay pattern and the fitted model, <code>boot.coefs.decay</code> bootstraps the paramaters of the distance-decay model, and <code>zdep</code> assesses the differences between parameters of two distance-decay models.
</p>


<h3>Author(s)</h3>

<p>Andres Baselga, David Orme, Sebastien Villéger, Julien De Bortoli, Fabien Leprieur, Maxime Logez, Sara Martínez-Santalla, Ramiro Martín-Devasa, Carola Gómez-Rodríguez, and Rosa M. Crujeiras
</p>


<h3>References</h3>

<p>Baselga, A. 2010. Partitioning the turnover and nestedness components of beta diversity. Global Ecology and Biogeography 19:134-143
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness. 
Global Ecology and Biogeography 21, 1223-1232
</p>
<p>Baselga, A. 2013. Separating the two components of abundance-based dissimilarity: balanced changes in abundance vs. 
abundance gradients. Methods in Ecology and Evolution, 4: 552-557
</p>
<p>Baselga, A. 2017. Partitioning abundance-based multiple-site dissimilarity into components: balanced variation in abundance and 
abundance gradients. Methods in Ecology and Evolution 8: 799-808
</p>
<p>Baselga A, Leprieur, F. 2015. Comparing methods to separate components of beta diversity. Methods in Ecology and Evolution 6: 1069-1079
</p>
<p>Baselga A, Orme CDL. 2012. betapart: an R package for the study of beta diversity. Methods Ecol. Evol. 3: 808-812
</p>
<p>Gómez-Rodríguez, C. &amp; Baselga, A. 2018. Variation among European beetle taxa in patterns of distance decay 
of similarity suggests a major role of dispersal processes. Ecography, in press
</p>
<p>Legendre P. 2014. Interpreting the replacement and richness difference components of beta diversity. Global Ecology and Biogeography, 23: 1324–1334
</p>
<p>Leprieur F, Albouy C, De Bortoli J, Cowman PF, Belwood DR, Mouillot D. 2012. Quantifying phylogenetic beta diversity: 
distinguishing between &quot;true&quot; turnover of lineages and phylogenetic diversity gradients. PLoS One 7(8): e42760 
</p>
<p>Martín-Devasa R, Martínez-Santalla S, Gómez-Rodríguez C, Crujeiras RM, Baselga A. 2022. Species range size shapes distance decay in community similarity. Diversity and Distributions 28: 1348-1357
</p>
<p>Martín-Devasa R, Martínez-Santalla S, Gómez-Rodríguez C, Crujeiras RM, Baselga A. 2022. Comparing distance-decay parameters: a novel test under pairwise dependence. Ecological Informatics 72: 101894 
</p>
<p>Martínez-Santalla S, Martín-Devasa R, Gómez-Rodríguez C, Crujeiras RM, Baselga A. 2022. Assessing the 
non-linear decay of community similarity: permutation and site-block resampling significance tests. 
Journal of Biogeography 49: 968-978
</p>
<p>Villéger, S. Grenouillet, G., Brosse, S. 2013. Decomposing functional beta-diversity reveals that low functional 
beta-diversity is driven by low functional turnover in European fish assemblages. Global Ecology and Biogeography, 22: 671-681
</p>

<hr>
<h2 id='bbsData'>BBS data by state for two timeslices</h2><span id='topic+bbsData'></span><span id='topic+bbs1980'></span><span id='topic+bbs2000'></span>

<h3>Description</h3>

<p>The data consists of binary presence/absence matrices for 569 bird 
species across 49 US states for two time slices (1980 - 1985 and 2000 - 2005). 
Only species (identified by AOU number) recorded during both time periods are included. 
The data are taken from the North American Breeding Bird Survey dataset and from a 
version of the database downloaded in May 2009.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bbsData)</code></pre>


<h3>Format</h3>

<p>Two matrices (bbs1980 and bbs2000) of identical structure showing the presence/absence of the species as binary data.
</p>

<dl>
<dt><code>state</code></dt><dd><p>US states by USPS two letter codes.</p>
</dd>
<dt><code>aou</code></dt><dd><p>Species identity by AOU species ID numbers.</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://www.pwrc.usgs.gov/BBS/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bbsData)
str(bbs1980)
str(bbs2000)
</code></pre>

<hr>
<h2 id='beta.multi'>Multiple-site dissimilarities</h2><span id='topic+beta.multi'></span>

<h3>Description</h3>

<p>Computes 3 multiple-site dissimilarities accounting for the spatial turnover 
and the nestedness components of beta diversity, and the sum of both values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.multi(x, index.family="sorensen")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.multi_+3A_x">x</code></td>
<td>
<p> data frame, where rows are sites and columns are species. Alternatively <code>x</code> can 
be a <code>betapart</code> object derived from the <code>betapart.core</code> function</p>
</td></tr>
<tr><td><code id="beta.multi_+3A_index.family">index.family</code></td>
<td>
<p> family of dissimilarity indices, partial match of <code>"sorensen"</code> or <code>"jaccard"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the three multiple site dissimilarity values.
</p>
<p>For <code>index.family="sorensen"</code> the three indices are:
</p>
<table>
<tr><td><code>beta.SIM</code></td>
<td>
<p> value of the turnover component, measured as Simpson dissimilarity</p>
</td></tr>
<tr><td><code>beta.SNE</code></td>
<td>
<p> value of the nestedness component, measured as nestedness-resultant fraction of Sorensen dissimilarity</p>
</td></tr>
<tr><td><code>beta.SOR</code></td>
<td>
<p> value of the overall beta diversity, measured as Sorensen dissimilarity</p>
</td></tr>
</table>
<p>For <code>index.family="jaccard"</code> the three indices are:
</p>
<table>
<tr><td><code>beta.JTU</code></td>
<td>
<p> value of the turnover component, measured as turnover fraction of Jaccard dissimilarity</p>
</td></tr>
<tr><td><code>beta.JNE</code></td>
<td>
<p> value of the nestedness component, measured as nestedness-resultant fraction of Jaccard dissimilarity</p>
</td></tr>
<tr><td><code>beta.JAC</code></td>
<td>
<p> value of the overall beta diversity, measured as Jaccard dissimilarity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Baselga, A. 2010. Partitioning the turnover and nestedness components of beta diversity. Global Ecology and Biogeography 19:134-143
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness. 
Global Ecology and Biogeography 21, 1223-1232
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.pair">beta.pair</a></code>, <code><a href="#topic+beta.sample">beta.sample</a></code>, <code><a href="#topic+betapart.core">betapart.core</a></code>, <code><a href="#topic+beta.temp">beta.temp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ceram.s)
ceram.beta&lt;-beta.multi(ceram.s, index.family="sor")
</code></pre>

<hr>
<h2 id='beta.multi.abund'>
Abundance-based multiple-site dissimilarities
</h2><span id='topic+beta.multi.abund'></span>

<h3>Description</h3>

<p>Computes 3 multiple-site dissimilarities accounting for the (i) balanced variation 
and (ii) abundance gradient components of dissimilarity, and the sum of both values (i.e. total abundance-based dissimilarity)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.multi.abund(x, index.family="bray")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.multi.abund_+3A_x">x</code></td>
<td>
<p> data frame, where rows are sites and columns are species. Alternatively <code>x</code> can 
be a <code>betapart.abund</code> object derived from the <code>betapart.core.abund</code> function</p>
</td></tr>
<tr><td><code id="beta.multi.abund_+3A_index.family">index.family</code></td>
<td>
<p> family of dissimilarity indices, partial match of <code>"bray"</code> or <code>"ruzicka"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the three multiple site dissimilarity values.
</p>
<p>For <code>index.family="bray"</code> the three indices are:
</p>
<table>
<tr><td><code>beta.BRAY.BAL</code></td>
<td>
<p> value of the balanced variation component of Bray-Curtis multiple-site dissimilarity</p>
</td></tr>
<tr><td><code>beta.BRAY.GRA</code></td>
<td>
<p> value of the abundance-gradient component of Bray-Curtis multiple-site dissimilarity</p>
</td></tr>
<tr><td><code>beta.BRAY</code></td>
<td>
<p> value of the overall dissimilarity, measured as Bray-Curtis multiple-site dissimilarity</p>
</td></tr>
</table>
<p>For <code>index.family="ruzicka"</code> the three indices are:
</p>
<table>
<tr><td><code>beta.RUZ.BAL</code></td>
<td>
<p> value of the balanced variation component of Ruzicka multiple-site dissimilarity</p>
</td></tr>
<tr><td><code>beta.RUZ.GRA</code></td>
<td>
<p> value of the abundance-gradient component of Ruzicka multiple-site dissimilarity</p>
</td></tr>
<tr><td><code>beta.RUZ</code></td>
<td>
<p> value of the overall dissimilarity, measured as Ruzicka multiple-site dissimilarity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga
</p>


<h3>References</h3>

<p>Baselga, A. 2017. Partitioning abundance-based multiple-site dissimilarity into components: balanced variation in abundance and abundance gradients. Methods in Ecology and Evolution 8: 799-808
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.pair.abund">beta.pair.abund</a></code>, <code><a href="#topic+beta.sample.abund">beta.sample.abund</a></code>, <code><a href="#topic+betapart.core.abund">betapart.core.abund</a></code>, <code><a href="#topic+beta.multi">beta.multi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(vegan)
data(BCI)
beta.multi.abund(BCI, index.family="bray")
</code></pre>

<hr>
<h2 id='beta.pair'>
Incidence-based pair-wise dissimilarities
</h2><span id='topic+beta.pair'></span>

<h3>Description</h3>

<p>Computes 3 distance matrices accounting for the (i) turnover (replacement),
(ii) nestedness-resultant component, and (iii) total dissimilarity (i.e. the sum of both components).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.pair(x, index.family = "sorensen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.pair_+3A_x">x</code></td>
<td>

<p>data frame, where rows are sites and columns are species. Alternatively <code>x</code> can be a <code>betapart</code> object derived from the <code>betapart.core</code> function
</p>
</td></tr>
<tr><td><code id="beta.pair_+3A_index.family">index.family</code></td>
<td>

<p>family of dissimilarity indices, partial match of <code>"sorensen"</code> or <code>"jaccard"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with three dissimilarity matrices.
For <code>index.family="sorensen"</code> the three matrices are:
</p>
<table>
<tr><td><code>beta.sim</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for spatial turnover (replacement), measured as Simpson pair-wise dissimilarity</p>
</td></tr>
<tr><td><code>beta.sne</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for nestedness-resultant dissimilarity, measured as the nestedness-fraction of Sorensen pair-wise dissimilarity</p>
</td></tr>
<tr><td><code>beta.sor</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for total dissimilarity, measured as Sorensen pair-wise dissimilarity (a monotonic transformation of beta diversity)</p>
</td></tr>
</table>
<p>For <code>index.family="jaccard"</code> the three matrices are:
</p>
<table>
<tr><td><code>beta.jtu</code></td>
<td>
 <p><code>dist</code> dissimilarity matrix accounting for spatial turnover, measured as the turnover-fraction of Jaccard pair-wise dissimilarity</p>
</td></tr>
<tr><td><code>beta.jne</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for nestedness-resultant dissimilarity, measured as the nestedness-fraction of Jaccard pair-wise dissimilarity</p>
</td></tr>
<tr><td><code>beta.jac</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for beta diversity, measured as Jaccard pair-wise dissimilarity (a monotonic transformation of beta diversity)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Baselga, A. 2010. Partitioning the turnover and nestedness components of beta diversity. Global Ecology and Biogeography 19:134-143
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness. Global Ecology and Biogeography 21, 1223-1232
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.pair.abund">beta.pair.abund</a></code>, code<a href="#topic+beta.multi">beta.multi</a>, <code><a href="#topic+beta.sample">beta.sample</a></code>, <code><a href="#topic+betapart.core">betapart.core</a></code>, <code><a href="#topic+beta.temp">beta.temp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ceram.s)
ceram.dist&lt;-beta.pair(ceram.s, index.family="jac")
</code></pre>

<hr>
<h2 id='beta.pair.abund'>
Abundance-based pair-wise dissimilarities
</h2><span id='topic+beta.pair.abund'></span>

<h3>Description</h3>

<p>Computes 3 distance matrices accounting for the (i) balanced variation in abundances,
(ii) abundance gradients, and (iii) total dissimilarity (i.e. the sum of both components).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.pair.abund(x, index.family = "bray")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.pair.abund_+3A_x">x</code></td>
<td>

<p>data frame, where rows are sites and columns are species. Alternatively <code>x</code> can be a <code>betapart.abund</code> object derived from the <code>betapart.core.abund</code> function
</p>
</td></tr>
<tr><td><code id="beta.pair.abund_+3A_index.family">index.family</code></td>
<td>

<p>family of dissimilarity indices, partial match of <code>"bray"</code> or <code>"ruzicka"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with three dissimilarity matrices.
For <code>index.family="bray"</code> the three matrices are:
</p>
<table>
<tr><td><code>beta.bray.bal</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for the dissimilarity derived from balanced variation in abundance between sites</p>
</td></tr>
<tr><td><code>beta.bray.gra</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for the dissimilarity derived from unidirectional abundance gradients</p>
</td></tr>
<tr><td><code>beta.bray</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for total abundance-based dissimilarity between sites, measured as the Bray-Curtis index</p>
</td></tr>
</table>
<p>For <code>index.family="ruzicka"</code> the three matrices are:
</p>
<table>
<tr><td><code>beta.ruz.bal</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for the dissimilarity derived from balanced variation in abundance between sites</p>
</td></tr>
<tr><td><code>beta.ruz.gra</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for the dissimilarity derived from unidirectional abundance gradients</p>
</td></tr>
<tr><td><code>beta.ruz</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for total abundance-based dissimilarity between sites, measured as the Ruzicka index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga
</p>


<h3>References</h3>

<p>Baselga, A. 2013. Separating the two components of abundance-based dissimilarity: balanced changes in abundance vs. abundance gradients. Methods in Ecology and Evolution 4: 552–557
</p>
<p>Legendre, P. 2014. Interpreting the replacement and richness difference components of beta diversity. Global Ecology and Biogeography, 23: 1324–1334
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.multi.abund">beta.multi.abund</a></code>, <code><a href="#topic+beta.sample.abund">beta.sample.abund</a></code>, <code><a href="#topic+betapart.core.abund">betapart.core.abund</a></code>, <code><a href="#topic+beta.pair">beta.pair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(vegan)
data(BCI)
BCI.pair&lt;-beta.pair.abund(BCI, index.family="bray")
</code></pre>

<hr>
<h2 id='beta.para.control'>
Specifying Control Values for Internal Parallel Cluster
</h2><span id='topic+beta.para.control'></span>

<h3>Description</h3>

<p>The values supplied in the <code>beta.para.control()</code> call replace the defaults, and a list with all settings (i.e., values for all possible arguments) is returned. The returned list is used to define the internal parallel cluster of the <code>functional.betapart.core</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.para.control(nc = floor(parallel::detectCores()/2), type = "SOCK", 
                              LB = TRUE, size = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.para.control_+3A_nc">nc</code></td>
<td>
<p> number of cores to use. Default is half of the available cores.</p>
</td></tr>
<tr><td><code id="beta.para.control_+3A_type">type</code></td>
<td>
<p> character - the type of cluster to be used, either <code>"SOCK"</code>, <code>"PSOCK"</code> or <code>"FORK"</code> (not on Windows).</p>
</td></tr>
<tr><td><code id="beta.para.control_+3A_lb">LB</code></td>
<td>
<p> logical indicating if load balancing has to be used. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="beta.para.control_+3A_size">size</code></td>
<td>
<p> number of operation run on each core at each iteration. Default is <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>Maxime Logez
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(beta.para.control(nc = 2, LB = FALSE))
</code></pre>

<hr>
<h2 id='beta.sample'>
Resampling multiple-site dissimilarity for n sites
</h2><span id='topic+beta.sample'></span>

<h3>Description</h3>

<p>Resamples the 3 multiple-site dissimilarities (turnover, nestedness-resultant fraction, and overall 
beta diversity) for a subset of sites of the original data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.sample(x, index.family="sorensen", sites=nrow(x$data), samples = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.sample_+3A_x">x</code></td>
<td>
<p> data frame, where rows are sites and columns are species. Alternatively <code>x</code> can 
be a <code>betapart</code> object derived from the <code>betapart.core</code> function.</p>
</td></tr>
<tr><td><code id="beta.sample_+3A_index.family">index.family</code></td>
<td>
<p> family of dissimilarity indices, partial match of <code>"sorensen"</code> or <code>"jaccard"</code>.</p>
</td></tr>
<tr><td><code id="beta.sample_+3A_sites">sites</code></td>
<td>
<p> number of sites for which multiple-site dissimilarities will be computed. If not specified, default is all sites.</p>
</td></tr>
<tr><td><code id="beta.sample_+3A_samples">samples</code></td>
<td>
<p> number of repetitions. If not specified, default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with a dataframe with the resampled 3 multiple-site dissimilarities 
(turnover fraction, nestedness-resultant fraction and overall dissimilarity; see <code><a href="#topic+beta.multi">beta.multi</a></code>), 
a vector with the respective means and a vector with the respective standard deviation.
</p>
<p>For <code>index.family="sorensen"</code>:
</p>
<table>
<tr><td><code>sampled.values</code></td>
<td>
<p> dataframe containing beta.SIM, beta.SNE and beta.SOR for all samples</p>
</td></tr>
<tr><td><code>mean.values</code></td>
<td>
<p> vector containing the mean values of beta.SIM, beta.SNE and beta.SOR among samples</p>
</td></tr>
<tr><td><code>sd.values</code></td>
<td>
<p> vector containing the sd values of beta.SIM, beta.SNE and beta.SOR among samples</p>
</td></tr>
</table>
<p>For <code>index.family="jaccard"</code>:
</p>
<table>
<tr><td><code>sampled.values</code></td>
<td>
<p> dataframe containing beta.JTU, beta.JNE and beta.JAC for all samples</p>
</td></tr>
<tr><td><code>mean.values</code></td>
<td>
<p> vector containing the mean values of beta.JTU, beta.JNE and beta.JAC among samples</p>
</td></tr>
<tr><td><code>sd.values</code></td>
<td>
<p> vector containing the sd values of beta.JTU, beta.JNE and beta.JAC among samples</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Baselga, A. 2010. Partitioning the turnover and nestedness components of beta diversity. Global Ecology and Biogeography 19:134-143
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness. 
Global Ecology and Biogeography 21, 1223-1232
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.multi">beta.multi</a></code>, <code><a href="#topic+beta.sample">beta.sample</a></code>, <code><a href="#topic+beta.temp">beta.temp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read the data for Northern and Southern European cerambycids
data(ceram.s)
data(ceram.n)

# Resample 100 times the multiple-site dissimilarities
# for 10 countries.
beta.ceram.s&lt;-beta.sample(ceram.s, index.family="sor", sites=10, samples=100)
beta.ceram.n&lt;-beta.sample(ceram.n, index.family="sor", sites=10, samples=100)

# Plot the distributions of beta.SIM in Southern Europe (red) 
# and Northern Europe (blue)
plot(density(beta.ceram.s$sampled.values$beta.SIM), col="red", xlim=c(0,1))
lines(density(beta.ceram.n$sampled.values$beta.SIM), col="blue")

# Compute the p-value of difference in beta.SIM between South and North 
# (i.e. the probability of finding in the North a higher value than 
# in the South)
p.value.beta.SIM&lt;-length(which(beta.ceram.s$sampled.values$beta.SIM&lt;
beta.ceram.n$sampled.values$beta.SIM))/100

p.value.beta.SIM
# The result is 0 and we used 100 samples, so p&lt;0.01
</code></pre>

<hr>
<h2 id='beta.sample.abund'>
Resampling abundance-based multiple-site dissimilarity for n sites
</h2><span id='topic+beta.sample.abund'></span>

<h3>Description</h3>

<p>Resamples the 3 abundance-based multiple-site dissimilarities (balanced variation fraction,abundance-gradient fraction, and overall 
dissimilarity) for a subset of sites of the original data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.sample.abund(x, index.family="bray", sites = nrow(x), samples = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.sample.abund_+3A_x">x</code></td>
<td>
<p> data frame, where rows are sites and columns are species</p>
</td></tr>
<tr><td><code id="beta.sample.abund_+3A_index.family">index.family</code></td>
<td>
<p> family of dissimilarity indices, partial match of <code>"bray"</code> or <code>"ruzicka"</code>.</p>
</td></tr>
<tr><td><code id="beta.sample.abund_+3A_sites">sites</code></td>
<td>
<p> number of sites for which multiple-site dissimilarities will be computed. If not specified, default is all sites.</p>
</td></tr>
<tr><td><code id="beta.sample.abund_+3A_samples">samples</code></td>
<td>
<p> number of repetitions. If not specified, default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with a dataframe with the resampled 3 multiple-site dissimilarities 
(balanced variation fraction, abundance-gradient fraction and overall dissimilarity; see <code><a href="#topic+beta.multi.abund">beta.multi.abund</a></code>), 
a vector with the respective means and a vector with the respective standard deviation.
</p>
<p>For <code>index.family="bray"</code>:
</p>
<table>
<tr><td><code>sampled.values</code></td>
<td>
<p> dataframe containing beta.BRAY.BAL, beta.BRAY.GRA and beta.BRAY for all samples</p>
</td></tr>
<tr><td><code>mean.values</code></td>
<td>
<p> vector containing the mean values of beta.BRAY.BAL, beta.BRAY.GRA and beta.BRAY among samples</p>
</td></tr>
<tr><td><code>sd.values</code></td>
<td>
<p> vector containing the sd values of beta.BRAY.BAL, beta.BRAY.GRA and beta.BRAY among samples</p>
</td></tr>
</table>
<p>For <code>index.family="ruzicka"</code>:
</p>
<table>
<tr><td><code>sampled.values</code></td>
<td>
<p> dataframe containing beta.RUZ.BAL, beta.RUZ.GRA and beta.RUZ for all samples</p>
</td></tr>
<tr><td><code>mean.values</code></td>
<td>
<p> vector containing the mean values of beta.RUZ.BAL, beta.RUZ.GRA and beta.RUZ among samples</p>
</td></tr>
<tr><td><code>sd.values</code></td>
<td>
<p> vector containing the sd values of beta.RUZ.BAL, beta.RUZ.GRA and beta.RUZ among samples</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga
</p>


<h3>References</h3>

<p>Baselga, A. 2017. Partitioning abundance-based multiple-site dissimilarity into components: balanced variation in abundance and abundance gradients. Methods in Ecology and Evolution 8: 799-808
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.multi.abund">beta.multi.abund</a></code>, <code><a href="#topic+beta.sample">beta.sample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(vegan)
data(BCI)
beta.sample.abund(BCI, index.family="bray", sites=10, samples=100)
</code></pre>

<hr>
<h2 id='beta.temp'>
Temporal change in community composition
</h2><span id='topic+beta.temp'></span>

<h3>Description</h3>

<p>Computes the dissimilarity for each locality between time 1 and time 2, considering 
the turnover and nestedness components of temporal change, and the sum of both values (overall change)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.temp(x, y, index.family="sorensen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.temp_+3A_x">x</code></td>
<td>
<p> data frame for time 1, where rows are sites and columns are species</p>
</td></tr>
<tr><td><code id="beta.temp_+3A_y">y</code></td>
<td>
<p> data frame for time 2, where rows are sites and columns are species. 
<code>x</code> and <code>y</code> must contain exactly the same sites and species</p>
</td></tr>
<tr><td><code id="beta.temp_+3A_index.family">index.family</code></td>
<td>
<p> family of dissimilarity indices, partial match of <code>"sorensen"</code> or <code>"jaccard"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data frame where rows are sites and columns are pairwise dissimilarity 
values between cell composition in time 1 and time 2. For <code>index.family="sorensen"</code> the indices are 
beta.sim, beta.sne, and beta.sor. For <code>index.family="jaccard"</code> the indices are beta.jtu, beta.sne, and beta.jac. 
</p>


<h3>Author(s)</h3>

<p>Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Baselga, A. 2010. Partitioning the turnover and nestedness components of beta diversity. Global Ecology and Biogeography 19:134-143
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness. 
Global Ecology and Biogeography 21, 1223-1232
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.multi">beta.multi</a></code>, <code><a href="#topic+beta.pair">beta.pair</a></code>, <code><a href="#topic+beta.sample">beta.sample</a></code>, <code><a href="#topic+betapart.core">betapart.core</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bbsData)
bbs.t &lt;- beta.temp(bbs1980, bbs2000, index.family="sor")
</code></pre>

<hr>
<h2 id='betapart.core'>
Core calculations of betapart
</h2><span id='topic+betapart.core'></span>

<h3>Description</h3>

<p>Computes the basic quantities needed for computing the multiple-site beta diversity measures
and pairwise dissimilarity matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betapart.core(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betapart.core_+3A_x">x</code></td>
<td>
<p> data frame, where rows are sites and columns are species</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>betapart</code> with the following elements:
</p>
<table>
<tr><td><code>sumSi</code></td>
<td>
<p> the sum of the species richness values of all sites</p>
</td></tr>
<tr><td><code>St</code></td>
<td>
<p> the total richness in the dataset</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> the multiple-site analog of the shared species term</p>
</td></tr>
<tr><td><code>shared</code></td>
<td>
<p> a matrix containing the number of species shared between pairs of sites</p>
</td></tr>
<tr><td><code>not.shared</code></td>
<td>
<p> a matrix containing the number of species not shared between pairs of sites: b, c</p>
</td></tr>
<tr><td><code>sum.not.shared</code></td>
<td>
<p> a matrix containing the total number of species not shared between pairs of sites: b+c</p>
</td></tr>
<tr><td><code>max.not.shared</code></td>
<td>
<p> a matrix containing the total maximum number of species not shared between pairs of sites: max(b,c)</p>
</td></tr>
<tr><td><code>min.not.shared</code></td>
<td>
<p> a matrix containing the total minimum number of species not shared between pairs of sites: min(b,c)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Baselga, A. 2010. Partitioning the turnover and nestedness components of beta diversity. Global Ecology and Biogeography 19:134-143
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness. 
Global Ecology and Biogeography 21, 1223-1232
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.multi">beta.multi</a></code>, <code><a href="#topic+beta.pair">beta.pair</a></code>, <code><a href="#topic+beta.sample">beta.sample</a></code>, <code><a href="#topic+beta.temp">beta.temp</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ceram.s)
ceram.core.s&lt;-betapart.core(ceram.s)
ceram.dist.jac&lt;-beta.pair(ceram.core.s, index.family="jac")
ceram.dist.sor&lt;-beta.pair(ceram.core.s, index.family="sor")
ceram.multi.jac&lt;-beta.multi(ceram.core.s, index.family="jac")
ceram.multi.sor&lt;-beta.multi(ceram.core.s, index.family="sor")

</code></pre>

<hr>
<h2 id='betapart.core.abund'>
Core calculations of betapart for abundance-based dissimilarity measures
</h2><span id='topic+betapart.core.abund'></span>

<h3>Description</h3>

<p>Computes the basic quantities needed for computing the abundance-based multiple-site 
dissimilarity measures and pairwise dissimilarity matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betapart.core.abund(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betapart.core.abund_+3A_x">x</code></td>
<td>
<p> data frame, where rows are sites and columns are species</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>betapart.abund</code> with the following elements:
</p>
<table>
<tr><td><code>multiple.shared.abund</code></td>
<td>
<p> the multiple-site intersection component in terms of abundances (AM)</p>
</td></tr>
<tr><td><code>pair.shared.abund</code></td>
<td>
<p> a matrix containing the agreement in abundance between pairs of sites (A)</p>
</td></tr>
<tr><td><code>min.not.shared.abund</code></td>
<td>
<p> a matrix containing the minimum disagreement in abundance between pairs of sites: min(B,C)</p>
</td></tr>
<tr><td><code>max.not.shared.abund</code></td>
<td>
<p> a matrix containing the maximum disagreement in abundance between pairs of sites between pairs of sites: max(B,C)</p>
</td></tr>
<tr><td><code>pair.not.shared.abund</code></td>
<td>
<p> a matrix containing the total disagreement in abundance between pairs of sites: B+C</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga
</p>


<h3>References</h3>

<p>Baselga, A. 2013. Separating the two components of abundance-based dissimilarity: balanced changes in 
abundance vs. abundance gradients. Methods in Ecology and Evolution, 4: 552–557
</p>
<p>Legendre, P. 2014. Interpreting the replacement and richness difference components of beta diversity. 
Global Ecology and Biogeography, 23: 1324–1334
</p>
<p>Baselga, A. 2017. Partitioning abundance-based multiple-site dissimilarity into components: balanced variation in abundance and abundance gradients. Methods in Ecology and Evolution, 8: 799-808
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.multi.abund">beta.multi.abund</a></code>, <code><a href="#topic+beta.pair.abund">beta.pair.abund</a></code>, <code><a href="#topic+beta.sample.abund">beta.sample.abund</a></code>, <code><a href="#topic+betapart.core">betapart.core</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(vegan)
data(BCI)
core.BCI&lt;-betapart.core.abund(BCI)
pair.BCI&lt;-beta.pair.abund(core.BCI)
multi.BCI&lt;-beta.multi.abund(core.BCI)
</code></pre>

<hr>
<h2 id='betatest'>A data set of 4 communities, 107 species and a 4D functional space</h2><span id='topic+betatest'></span>

<h3>Description</h3>

<p>A data set to test the functions to dissimilarities matricies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("betatest")</code></pre>


<h3>Format</h3>

<p><code>betatest</code> is a list of two elements.
</p>

<dl>
<dt><code>comm.test</code></dt><dd><p> a dataframe with the presence/absence of 107 species among 4 sites</p>
</dd>
<dt><code>traits.test</code></dt><dd><p> a dataframe of the traits (4 axes) of the 107 species</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(betatest)
str(betatest$comm.test)
str(betatest$traits.test)
</code></pre>

<hr>
<h2 id='boot.coefs.decay'>
Bootstrapping the parameters of distance-decay models computed with decay.model() 
</h2><span id='topic+boot.coefs.decay'></span>

<h3>Description</h3>

<p>Takes the output of decay.model() and bootstraps the parameters of the model (i.e. intercept and slope in negative exponential or power law models, or position parameter and slope in Gompertz models).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.coefs.decay(m1, resamples, st.val = c(1, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.coefs.decay_+3A_m1">m1</code></td>
<td>
<p> the output of decay.model().</p>
</td></tr>
<tr><td><code id="boot.coefs.decay_+3A_resamples">resamples</code></td>
<td>
<p> the number of bootstrap resamples.</p>
</td></tr>
<tr><td><code id="boot.coefs.decay_+3A_st.val">st.val</code></td>
<td>
<p> starting values for the nonlinear model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with: 
</p>
<table>
<tr><td><code>model.type</code></td>
<td>
<p>  functional form of the model, either negative exponential or power law.</p>
</td></tr>
<tr><td><code>y.type</code></td>
<td>
<p>  similarties or dissimilarities.</p>
</td></tr>
<tr><td><code>boot.coefs</code></td>
<td>
<p>  a matrix with the coefficients bootstrapped distributions, including 
values of the first parameter (intercept or position parameter) in the first column, and values of the second parameter (slope) in the second column.</p>
</td></tr>
<tr><td><code>original.coefs</code></td>
<td>
<p>  model coefficients as estimated with a nonlinear model using decay.model().</p>
</td></tr>
<tr><td><code>mean.boot</code></td>
<td>
<p>  the mean of the bootstrapped distributions.</p>
</td></tr>
<tr><td><code>sd.boot</code></td>
<td>
<p>  the standard deviation of the bootstrapped distributions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sara Martínez-Santalla, Ramiro Martín-Devasa, Carola Gómez-Rodríguez, Rosa M. Crujeiras, Andrés Baselga
</p>


<h3>References</h3>

<p>Gómez-Rodríguez, C. &amp; Baselga, A. 2018. Variation among European beetle taxa in patterns of distance decay 
of similarity suggests a major role of dispersal processes. Ecography 41: 1825-1834
</p>
<p>Martínez-Santalla S, Martín-Devasa R, Gómez-Rodríguez C, Crujeiras RM, Baselga A. 2022. Assessing the 
non-linear decay of community similarity: permutation and site-block resampling significance tests. 
Journal of Biogeography 49: 968-978
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decay.model">decay.model</a></code>, <code><a href="#topic+zdep">zdep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# presence/absence tables for longhorn beetles of South Europe
data(ceram.s)

# spatial coordinates of territories in South Europe
data(coords.s)

# dissimilarity matrix
ceram.s.sim&lt;-beta.pair(ceram.s)$beta.sim

# spatial distances in km
distgeo.s&lt;-dist(coords.s[,1:2])

# Negative exponential model for the decay of similarity with spatial distance
decay.south&lt;-decay.model(y=1-ceram.s.sim, x=distgeo.s, y.type="sim", model.type="exp")

# Site-block bootstrap
boot.coefs.decay(decay.south, resamples=100)

</code></pre>

<hr>
<h2 id='bray.part'>
Partitioning pair-wise Bray-Curtis dissimilarities
</h2><span id='topic+bray.part'></span>

<h3>Description</h3>

<p>Computes 3 distance matrices accounting for the balanced variation and abundance gradient components 
of Bray-Curtis dissimilarity, and the sum of both values (i.e. Bray-Curtis dissimilarity)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bray.part(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bray.part_+3A_x">x</code></td>
<td>
<p> data frame of species abundances, where rows are sites and columns are species.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with three dissimilarity matrices.
</p>
<table>
<tr><td><code>bray.bal</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for the dissimilarity derived from 
balanced variation in abundance between sites</p>
</td></tr>
<tr><td><code>bray.gra</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for the dissimilarity derived from
unidirectional abundance gradients</p>
</td></tr>
<tr><td><code>bray</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for total abundance-based dissimilarity 
between sites, measured as the Bray-Curtis index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga
</p>


<h3>References</h3>

<p>Baselga, A. 2013. Separating the two components of abundance-based dissimilarity: balanced changes in abundance vs. abundance gradients. Methods in Ecology and Evolution 4: 552–557
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.pair">beta.pair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(vegan)
data(BCI)
BCI.matrices&lt;-bray.part(BCI)
</code></pre>

<hr>
<h2 id='ceram.n'>Cerambycidae from Northern European Countries</h2><span id='topic+ceram.n'></span>

<h3>Description</h3>

<p>The ceram.n data frame has 18 rows and 634 columns. Columns are presence/absence values of 634 species. The variable names are formed from the scientific names. The row names are standard country abbreviations, excepting RSS (Southern European Russia), RSC (Central European Russia) and RSN (Northern European Russia).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ceram.n)</code></pre>


<h3>Source</h3>

<p>http://www.cerambycidae.net/</p>


<h3>References</h3>


<ol>
<li><p>Danilevsky, M. L. 2007. A check-list of Longicorn Beetles (Coleoptera, Cerambycoidea) of Europe.Available at http://www.cerambycidae.net/
</p>
</li>
<li><p>Baselga, A. 2008. Determinants of species richness, endemism and turnover in European longhorn beetles. Ecography 31:263-271
</p>
</li></ol>

<hr>
<h2 id='ceram.s'>Cerambycidae from Southern European Countries</h2><span id='topic+ceram.s'></span>

<h3>Description</h3>

<p>The ceram.s data frame has 15 rows and 634 columns. Columns are presence/absence values of 634 species. The variable names are formed from the scientific names. The case names are standard country abbreviations, excepting SS (Serbia) and CBH (Croatia and Bosnia-Herzegovina).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ceram.s)</code></pre>


<h3>Source</h3>

<p>http://www.cerambycidae.net/</p>


<h3>References</h3>


<ol>
<li><p>Danilevsky, M. L. 2007. A check-list of Longicorn Beetles (Coleoptera, Cerambycoidea) of Europe.Available at http://www.cerambycidae.net/
</p>
</li>
<li><p>Baselga, A. 2008. Determinants of species richness, endemism and turnover in European longhorn beetles. Ecography 31:263-271
</p>
</li></ol>

<hr>
<h2 id='coords.n'>Spatial coordinates for Southern European Countries</h2><span id='topic+coords.n'></span>

<h3>Description</h3>

<p>The coords.n data frame has 18 rows and 4 columns. Columns are UTM and latlong coordinates. The row names are standard country abbreviations, excepting RSS (Southern European Russia), RSC (Central European Russia) and RSN (Northern European Russia).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coords.n)</code></pre>


<h3>References</h3>


<ol>
<li><p>Baselga, A. 2008. Determinants of species richness, endemism and turnover in European longhorn beetles. Ecography 31:263-271
</p>
</li></ol>

<hr>
<h2 id='coords.s'>Spatial coordinates for Southern European Countries</h2><span id='topic+coords.s'></span>

<h3>Description</h3>

<p>The coords.s data frame has 15 rows and 4 columns. Columns are UTM and latlong coordinates. TThe row names are standard country abbreviations, excepting SS (Serbia) and CBH (Croatia and Bosnia-Herzegovina).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coords.s)</code></pre>


<h3>References</h3>


<ol>
<li><p>Baselga, A. 2008. Determinants of species richness, endemism and turnover in European longhorn beetles. Ecography 31:263-271
</p>
</li></ol>

<hr>
<h2 id='decay.model'>
Fitting distance decay models to pair-wise assemblage similarity 
</h2><span id='topic+decay.model'></span>

<h3>Description</h3>

<p>Fits a nonlinear model describing (i) the decay of assemblage similarity with spatial (or any other) distance,
or, equivalently, (ii) the increase of assemblage dissimilarity with distance. Nonlinear models are fitted 
via the nls.lm function in the minpack.lm package (which uses the Levenberg-Marquardt Nonlinear Least-Squares 
Algorithm). Implemented functional forms are either the (i) negative exponential, (ii) power law, or (iii) Gompertz models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decay.model(y, x, model.type = "exponential", y.type = "similarities", 
perm = 100, st.val = c(1, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decay.model_+3A_y">y</code></td>
<td>
<p> codedist object, either containing similarities or dissimilarities between pairs of assemblages.</p>
</td></tr>
<tr><td><code id="decay.model_+3A_x">x</code></td>
<td>
<p> codedist object, containing distances (spatial or other) between pairs of assemblages.</p>
</td></tr>
<tr><td><code id="decay.model_+3A_model.type">model.type</code></td>
<td>
<p> functional form of the model, either negative exponential, power law, or Gompertz,
partial match of <code>"exponential"</code>, <code>"power"</code>, or <code>"gompertz"</code>.</p>
</td></tr>
<tr><td><code id="decay.model_+3A_y.type">y.type</code></td>
<td>
<p> polarity of the codedist object (i.e. 1 means total similarity or total dissimilarity), 
partial match of <code>"similarities"</code> or <code>"dissimilarities"</code>.</p>
</td></tr>
<tr><td><code id="decay.model_+3A_perm">perm</code></td>
<td>
<p> number of permutations to assess significance.</p>
</td></tr>
<tr><td><code id="decay.model_+3A_st.val">st.val</code></td>
<td>
<p> starting values for the nonlinear model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with: 
</p>
<table>
<tr><td><code>data.y</code></td>
<td>
<p> original y data, codedist object, either containing similarities or dissimilarities between pairs of assemblages.</p>
</td></tr>
<tr><td><code>data.x</code></td>
<td>
<p> original x data, codedist object, containing distances (spatial or other) between pairs of assemblages.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> the fitted nonlinear model.</p>
</td></tr>
<tr><td><code>model.type</code></td>
<td>
<p>  functional form of the model, either negative exponential, power law, or Gompertz.</p>
</td></tr>
<tr><td><code>y.type</code></td>
<td>
<p>  similarties or dissimilarities.</p>
</td></tr>
<tr><td><code>first.parameter</code></td>
<td>
<p>  first parameter of the model. It can be either the intercept, i.e. similarity or dissimilarity at distance=0, in negative exponential or power law models, or the position parameter in Gompertz models.</p>
</td></tr>
<tr><td><code>second.parameter</code></td>
<td>
<p>  slope of the model, i.e. rate at which similarity decreases with distance, or dissimilarity 
increases with distance in a negative exponential, power law or Gompertz model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>  AIC of the model.</p>
</td></tr>
<tr><td><code>pseudo.r.squared</code></td>
<td>
<p>  proportion of the variation in the dependent variable that the model accounts for.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>  significance of the model, as estimated from a permutation test.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sara Martínez-Santalla, Ramiro Martín-Devasa, Carola Gómez-Rodríguez, Rosa M. Crujeiras, Andrés Baselga
</p>


<h3>References</h3>

<p>Gómez-Rodríguez C, Baselga A. 2018. Variation among European beetle taxa in patterns of distance decay 
of similarity suggests a major role of dispersal processes. Ecography 41: 1825-1834
</p>
<p>Martínez-Santalla S, Martín-Devasa R, Gómez-Rodríguez C, Crujeiras RM, Baselga A. 2022. Assessing the 
non-linear decay of community similarity: permutation and site-block resampling significance tests. 
Journal of Biogeography 49: 968-978
</p>
<p>Martín-Devasa R, Martínez-Santalla S, Gómez-Rodríguez C, Crujeiras RM, Baselga A. 2022. Species range size shapes distance decay in community similarity. Diversity and Distributions 28: 1348-1357
</p>


<h3>See Also</h3>

<p><code><a href="#topic+beta.pair">beta.pair</a></code>, <code><a href="#topic+beta.pair.abund">beta.pair.abund</a></code>, <code><a href="#topic+plot.decay">plot.decay</a></code>, <code><a href="#topic+boot.coefs.decay">boot.coefs.decay</a></code>, <code><a href="#topic+zdep">zdep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# presence/absence tables for longhorn beetles of South and North Europe
data(ceram.s)
data(ceram.n)

# spatial coordinates of territories in South and North Europe
data(coords.s)
data(coords.n)

# dissimilarity matrices
ceram.s.sim&lt;-beta.pair(ceram.s)$beta.sim
ceram.n.sim&lt;-beta.pair(ceram.n)$beta.sim

# spatial distances in km
distgeo.s&lt;-dist(coords.s[,1:2])
distgeo.n&lt;-dist(coords.n[,1:2])

# Negative exponential models for the decay of similarity with spatial distance
decay.south&lt;-decay.model(y=1-ceram.s.sim, x=distgeo.s, y.type="sim", model.type="exp")
decay.north&lt;-decay.model(y=1-ceram.n.sim, x=distgeo.n, y.type="sim", model.type="exp")

# Plot the decay models
plot.decay(decay.south, col="red")
plot.decay(decay.north, col="blue", add=TRUE)

# Equivalent models for the increase of dissimilarity with spatial distance
increase.south&lt;-decay.model(y=ceram.s.sim, x=distgeo.s, y.type="dissim", model.type="exp")
increase.north&lt;-decay.model(y=ceram.n.sim, x=distgeo.n, y.type="dissim", model.type="exp")

# Plot the decay models
plot.decay(increase.south, col="red")
plot.decay(increase.north, col="blue", add=TRUE)

</code></pre>

<hr>
<h2 id='functional.beta.multi'>
Multiple-site functional dissimilarities
</h2><span id='topic+functional.beta.multi'></span>

<h3>Description</h3>

<p>Computes 3 multiple-site functional dissimilarities accounting for the spatial turnover 
and the nestedness components of functional beta diversity, and the sum of both values.
Functional dissimilarities are based on volume of convex hulls intersections in a multidimensional functional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional.beta.multi(x, traits, index.family="sorensen", warning.time=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="functional.beta.multi_+3A_x">x</code></td>
<td>
<p> data frame, where rows are sites and columns are species. Alternatively <code>x</code> can 
be a <code>functional.betapart</code> object derived from the <code>functional.betapart.core</code> function</p>
</td></tr>
<tr><td><code id="functional.beta.multi_+3A_traits">traits</code></td>
<td>
<p> if <code>x</code> is not a <code>functional.betapart</code> object, a data frame, where rows are species and columns are functional space dimensions (i.e. quantitative traits or synthetic axes after PCoA). Number of species in each site must be strictly higher than number of dimensions. Number of dimensions should not exceed 4 and number of sites should not exceed 10. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="functional.beta.multi_+3A_index.family">index.family</code></td>
<td>
<p> family of dissimilarity indices, partial match of <code>"sorensen"</code> or <code>"jaccard"</code>.</p>
</td></tr>
<tr><td><code id="functional.beta.multi_+3A_warning.time">warning.time</code></td>
<td>
<p> a logical value indicating whether computation of multiple-site dissimilarities would stop if number of dimensions exceeds 4 or if number of sites exceeds 10. If turn to <code>FALSE</code>, computation process can be tracked in the <code>step.fbc.txt</code> file, see <code>Details</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> For multiple-site dissimilarities metrics (N&gt;2 sites), the volume of the union of the N convex hulls is computed using the inclusion-exclusion principle (Villéger et al., 2011). It requires to compute the volume of all the intersections between 2 to N convex hulls. Intersection between k&gt;2 convex hulls is computed as the intersection between the two convex hulls shaping intersections between the corresponding k-1 convex hulls, e.g. V(AnBnC)=V( (AnB)n(BnC) ). For N sites, computing multiple-site dissimilarity metrics thus requires computing 2^N-(N+1) pair-wise intersections between convex hulls in a multidimensional functional space.
Computation time of	the intersection between two convex hulls increases with the number of dimensions (D) of the functional space. Therefore, to prevent from running very long computation process <code>warning.time</code> is set by default to stop the function if D&gt;4 or N&gt;10.
Computation progress can be tracked in the &quot;step.fbc.txt&quot; file written in the working directory. This table shows proportion of steps completed for computing convex hull volume shaping each site (&quot;FRi&quot;) and intersections between them (&quot;intersection_k&quot;).
Note that the the <code>betapart</code> package now supports external parallel computing for null models. However, this functionality is only availabe in <code>functional.betapart.core</code>. In this case, use the <code>functional.betapart</code> object as <code>x</code> in this function. See <code>functional.betapart.core</code> for more details. 
</p>


<h3>Value</h3>

<p>The function returns a list with the three multiple site functional dissimilarity values.
</p>
<p>For <code>index.family="sorensen"</code> the three indices are:
</p>
<table>
<tr><td><code>beta.SIM</code></td>
<td>
<p> value of the functional turnover component, measured as Simpson derived functional dissimilarity</p>
</td></tr>
<tr><td><code>beta.SNE</code></td>
<td>
<p> value of the functional nestedness component, measured as nestedness-resultant fraction of Sorensen derived functional dissimilarity</p>
</td></tr>
<tr><td><code>beta.SOR</code></td>
<td>
<p> value of the overall functional beta diversity, measured as Sorensen derived functional dissimilarity</p>
</td></tr>
</table>
<p>For <code>index.family="jaccard"</code> the three indices are:
</p>
<table>
<tr><td><code>beta.JTU</code></td>
<td>
<p> value of the functional turnover component, measured as turnover fraction of Jaccard derived functional dissimilarity</p>
</td></tr>
<tr><td><code>beta.JNE</code></td>
<td>
<p> value of the functional nestedness component, measured as nestedness-resultant fraction of Jaccard derived functional dissimilarity</p>
</td></tr>
<tr><td><code>beta.JAC</code></td>
<td>
<p> value of the overall functional beta diversity, measured as Jaccard derived functional dissimilarity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Villéger, Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Villéger S., Novack-Gottshal P. &amp; Mouillot D. 2011. The multidimensionality of the niche reveals functional diversity changes in benthic marine biotas across geological time. Ecology Letters 14: 561-568
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness. Global Ecology and Biogeography 21: 1223-1232
</p>
<p>Villéger, S. Grenouillet, G., Brosse, S. 2013. Decomposing functional beta-diversity reveals that low functional beta-diversity is driven by low functional turnover in European fish assemblages. Global Ecology and Biogeography 22: 671–681
</p>


<h3>See Also</h3>

<p><code><a href="#topic+functional.beta.pair">functional.beta.pair</a></code>, <code><a href="#topic+functional.betapart.core">functional.betapart.core</a></code>, <code><a href="#topic+beta.multi">beta.multi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### 4 communities in a 2D functional space (convex hulls are rectangles)
traits.test&lt;-cbind( c(1,1,1,2,2,3,3,4,4,5,5) , c(1,2,4,1,2,3,5,1,4,3,5) )
	dimnames(traits.test)&lt;-list(paste("sp",1:11,sep="") , c("Trait 1","Trait 2") ) 

comm.test&lt;-matrix(0,4,11,dimnames=list( c("A","B","C","D") , paste("sp",1:11,sep="") ) )
comm.test["A",c(1,2,4,5)]&lt;-1
comm.test["B",c(1,3,8,9)]&lt;-1
comm.test["C",c(6,7,10,11)]&lt;-1
comm.test["D",c(2,4,7,9)]&lt;-1

plot(5,5,xlim=c(0,6), ylim=c(0,6), type="n", xlab="Trait 1",ylab="Trait 2")
points(traits.test[,1],traits.test[,2], pch=21,cex=1.5,bg="black")
rect(1,1,4,4, col="#458B0050", border="#458B00") ; text(2.5,2.5,"B",col="#458B00",cex=1.5)	
polygon(c(2,1,3,4), c(1,2,5,4), col="#DA70D650", border="#DA70D6") ; 
text(2.5,3,"D",col="#DA70D6",cex=1.5)	
rect(1,1,2,2, col="#FF000050" , border="#FF0000") ; text(1.5,1.5,"A",col="#FF0000",cex=1.5)	
rect(3,3,5,5, col="#1E90FF50", border="#1E90FF") ; text(4,4.2,"C",col="#1E90FF",cex=1.5)	

test.multi&lt;-functional.beta.multi(x=comm.test, traits=traits.test, index.family = "jaccard" )
test.multi

test.multi.ABC&lt;-functional.beta.multi(x=comm.test[c("A","B","C"),], traits=traits.test, 
index.family = "jaccard" )
test.multi.ABC

test.multi.ABD&lt;-functional.beta.multi(x=comm.test[c("A","B","D"),], traits=traits.test, 
index.family = "jaccard" )
test.multi.ABD
</code></pre>

<hr>
<h2 id='functional.beta.pair'>
Pair-wise functional dissimilarities
</h2><span id='topic+functional.beta.pair'></span>

<h3>Description</h3>

<p>Computes 3 distance matrices accounting for the spatial turnover and nestedness components 
of functional beta diversity, and the sum of both values. 
Functional dissimilarities are based on volume of convex hulls intersections in a multidimensional functional space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional.beta.pair(x, traits, index.family="sorensen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="functional.beta.pair_+3A_x">x</code></td>
<td>
<p> data frame, where rows are sites and columns are species. Alternatively <code>x</code> can 
be a <code>functional.betapart</code> object derived from the <code>functional.betapart.core</code> function or from the <code>functional.betapart.core.pairwise</code> function.</p>
</td></tr> 
<tr><td><code id="functional.beta.pair_+3A_traits">traits</code></td>
<td>
<p> if <code>x</code> is not a <code>functional.betapart</code> object, a data frame, where rows are species and columns are functional space dimensions (i.e. quantitative traits or synthetic axes after PCoA). Number of species in each site must be strictly higher than number of dimensions.</p>
</td></tr>
<tr><td><code id="functional.beta.pair_+3A_index.family">index.family</code></td>
<td>
<p> family of dissimilarity indices, partial match of <code>"sorensen"</code> or <code>"jaccard"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a <code>data.frame</code> then <code>functional.betapart.core.pairwise</code> is called to compute the distance matrices necessary to compute the different components of the beta diversity. Only the default argument values will be used, while <code>functional.betapart.core.pairwise</code> integrates options that could be much more efficient, such as internal parallelisation, or different options for the convexhull volume estimation. 
Note that the the <code>betapart</code> package now supports external parallel computing for null models. As for internal parallelisation, these functionalities are only availabe in <code>functional.betapart.core</code> or in <code>functional.betapart.core.pairwise</code>. In this case, use the <code>functional.betapart</code> object as <code>x</code> in this function. See <code>functional.betapart.core</code> and <code>functional.betepart.core.pairwise</code> for more details.   
</p>


<h3>Value</h3>

<p>The function returns a list with three functional dissimilarity matrices.
</p>
<p>For <code>index.family="sorensen"</code> the three matrices are:
</p>
<table>
<tr><td><code>funct.beta.sim</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for functional turnover, measured as Simpson derived pair-wise functional dissimilarity</p>
</td></tr>
<tr><td><code>funct.beta.sne</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for nestedness-resultant functional dissimilarity, measured as the nestedness-fraction of Sorensen derived pair-wise functional dissimilarity</p>
</td></tr>
<tr><td><code>funct.beta.sor</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for functional beta diversity, measured as Sorensen derived pair-wise functional dissimilarity</p>
</td></tr>
</table>
<p>For <code>index.family="jaccard"</code> the three matrices are:
</p>
<table>
<tr><td><code>funct.beta.jtu</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for functional turnover, measured as the turnover-fraction of Jaccard derived pair-wise functional dissimilarity</p>
</td></tr>
<tr><td><code>funct.beta.jne</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for nestedness-resultant functional dissimilarity, measured as the nestedness-fraction of Jaccard derived pair-wise functional dissimilarity</p>
</td></tr>
<tr><td><code>funct.beta.jac</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for functional beta diversity, measured as Jaccard derived pair-wise functional dissimilarity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Villéger, Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Villéger S., Novack-Gottshal P. &amp; Mouillot D. 2011. The multidimensionality of the niche reveals functional diversity changes in benthic marine biotas across geological time. Ecology Letters 14: 561-568
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness. Global Ecology and Biogeography 21: 1223-1232
</p>
<p>Villéger, S. Grenouillet, G., Brosse, S. 2013. Decomposing functional beta-diversity reveals that low functional beta-diversity is driven by low functional turnover in European fish assemblages. Global Ecology and Biogeography 22: 671–681
</p>


<h3>See Also</h3>

<p><code><a href="#topic+functional.beta.multi">functional.beta.multi</a></code>, <code><a href="#topic+functional.betapart.core">functional.betapart.core</a></code>, <code><a href="#topic+functional.betapart.core.pairwise">functional.betapart.core.pairwise</a></code>, <code><a href="#topic+beta.pair">beta.pair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### 4 communities in a 2D functional space (convex hulls are rectangles)
traits.test&lt;-cbind( c(1,1,1,2,2,3,3,4,4,5,5) , c(1,2,4,1,2,3,5,1,4,3,5) )
	dimnames(traits.test)&lt;-list(paste("sp",1:11,sep="") , c("Trait 1","Trait 2") ) 

comm.test&lt;-matrix(0,4,11,dimnames=list( c("A","B","C","D") , paste("sp",1:11,sep="") ) )
comm.test["A",c(1,2,4,5)]&lt;-1
comm.test["B",c(1,3,8,9)]&lt;-1
comm.test["C",c(6,7,10,11)]&lt;-1
comm.test["D",c(2,4,7,9)]&lt;-1

plot(5,5,xlim=c(0,6), ylim=c(0,6), type="n", xlab="Trait 1",ylab="Trait 2")
points(traits.test[,1],traits.test[,2], pch=21,cex=1.5,bg="black")
rect(1,1,4,4, col="#458B0050", border="#458B00") ; text(2.5,2.5,"B",col="#458B00",cex=1.5)	
polygon(c(2,1,3,4), c(1,2,5,4), col="#DA70D650", border="#DA70D6") ; 
text(2.5,3,"D",col="#DA70D6",cex=1.5)	
rect(1,1,2,2, col="#FF000050" , border="#FF0000") ; text(1.5,1.5,"A",col="#FF0000",cex=1.5)	
rect(3,3,5,5, col="#1E90FF50", border="#1E90FF") ; text(4,4.2,"C",col="#1E90FF",cex=1.5)	

test.pair&lt;-functional.beta.pair(x=comm.test, traits=traits.test, index.family = "jaccard")
lapply(test.pair,round,2)

#### with functional.betapart.core.pairwise
test1 &lt;- functional.betapart.core.pairwise(comm.test, traits.test)
test.pair &lt;- functional.beta.pair(test1)
## Not run: 
#### if internal parallelisation would be interesting (large community matrix)
test1 &lt;- functional.betapart.core.pairwise(comm.test, traits.test, parallel = TRUE,
                                           opt.parallel = list(nc = 2))
test.pair &lt;- functional.beta.pair(test1)

## End(Not run)
</code></pre>

<hr>
<h2 id='functional.betapart.core'>
Core calculations of functional dissimilarities metrics
</h2><span id='topic+functional.betapart.core'></span>

<h3>Description</h3>

<p>Computes the basic quantities needed for computing the multiple-site functional beta diversity measures
and pairwise functional dissimilarity matrices. This version of the function now supports internal parallelization to fasten the computations and external parallelization for null models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional.betapart.core(x, traits, multi = TRUE, warning.time = TRUE, 
                         return.details = FALSE, fbc.step = FALSE, 
                         parallel = FALSE, opt.parallel = beta.para.control(),
                         convhull.opt = qhull.opt(),
                         progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="functional.betapart.core_+3A_x">x</code></td>
<td>
<p> data frame, where rows are sites and columns are species.</p>
</td></tr>
<tr><td><code id="functional.betapart.core_+3A_traits">traits</code></td>
<td>
<p>  data frame, where rows are species and columns are functional space dimensions (i.e. quantitative traits or synthetic axes after PCoA). Number of species in each site must be strictly higher than number of dimensions.</p>
</td></tr>
<tr><td><code id="functional.betapart.core_+3A_multi">multi</code></td>
<td>
<p> a logical value indicating whether basic quantities for multiple-site functional beta-diversity should be computed. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="functional.betapart.core_+3A_warning.time">warning.time</code></td>
<td>
<p> a logical value indicating whether computation of multiple-site dissimilarities would stop if number of dimensions exceeds 4 or if number of sites exceeds 10. If turn to <code>FALSE</code>, computation process can be tracked in the <code>step.fbc.txt</code> file, see <code>Details</code>.</p>
</td></tr>
<tr><td><code id="functional.betapart.core_+3A_return.details">return.details</code></td>
<td>
<p> a logical value indicating whether volume and coordinates of vertices of convex hulls shaping each site and their intersections in the functional space should be returned.</p>
</td></tr>
<tr><td><code id="functional.betapart.core_+3A_fbc.step">fbc.step</code></td>
<td>
<p> a logical value indicating whether the computation progress tracking file &quot;step.fbc.txt&quot; should be created; Setting it to <code>FALSE</code> will speed up the function. It is automatically turn to <code>FALSE</code> when parallel is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="functional.betapart.core_+3A_parallel">parallel</code></td>
<td>
<p> a logical value indicating if internal parallelization is used to compute pairwise dissimilarities, see <code>Examples</code>. If <code>multi</code> is set to <code>TRUE</code> parallelization will be turned-off.</p>
</td></tr>
<tr><td><code id="functional.betapart.core_+3A_opt.parallel">opt.parallel</code></td>
<td>
<p> a list of values to replace the default values returned by the function <code><a href="#topic+beta.para.control">beta.para.control</a></code> to customize the cluster used for parallel computing.</p>
</td></tr>
<tr><td><code id="functional.betapart.core_+3A_convhull.opt">convhull.opt</code></td>
<td>
<p> a list of values to replace the default values returned by the function <code><a href="#topic+qhull.opt">qhull.opt</a></code>, to pass options to the <code><a href="geometry.html#topic+convhulln">convhulln</a></code> function. The first element, <code>conv1</code>, set the options that be used by default with <code>convhulln</code>, while the second element, <code>conv2</code>, set the options that will be used if <code>convhulln</code> returns an error. By default (<code>conv1 = 'QJ'</code> and <code>conv2 = NULL</code>). If <code>convhulln</code> generates an error, a <code>NA</code> is returned. This prevents the function to stop when encountering an error.</p>
</td></tr>
<tr><td><code id="functional.betapart.core_+3A_progress">progress</code></td>
<td>
<p> a logical indicating if a progress bar should be displayed (<code>TRUE</code>) or not (by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p> For multiple-site dissimilarities metrics (N&gt;2 sites), the volume of the union of the N convex hulls is computed using the inclusion-exclusion principle (Villéger et al., 2011). It requires to compute the volume of all the intersections between 2 to N convex hulls. Intersection between k&gt;2 convex hulls is computed as the intersection between the two convex hulls shaping intersections between the corresponding k-1 convex hulls, e.g. V(AnBnC)=V( (AnB)n(BnC) ). For N sites, computing multiple-site dissimilarity metrics thus requires computing 2^N-(N+1) pair-wise intersections between convex hulls in a multidimensional functional space.
Computation time of	the intersection between two convex hulls increases with the number of dimensions (D) of the functional space. Therefore, to prevent from running very long computation process <code>warning.time</code> is set by default to stop the function if D&gt;4 or N&gt;10.
</p>
<p>If <code>fbc.step</code> is set to <code>TRUE</code>, computation progress can be tracked in the &quot;step.fbc.txt&quot; file written in the working directory. This table shows proportion of steps completed for computing convex hull volume shaping each site (&quot;FRi&quot;) and intersections between them (&quot;intersection_k&quot;). This is only possible when computations are not performed in parallel, and this whatever the type of parallelization used (external or internal).  
</p>
<p>If <code>parallel</code> is set to <code>TRUE</code>, computation will be run though the creation of a cluster. This is interesting when beta diversity computation is long. When the number of sites increase and/or when the taxonomic richness is highly variable between sites, parallelization becomes more and more interesting. On small matrices, the running time could inflate due to the creation of the cluster and its management. 
</p>


<h3>Value</h3>

<p>The function returns an object of class <code>betapart</code> with the following elements:
</p>
<table>
<tr><td><code>sumFRi</code></td>
<td>
<p> the sum of the functional richness values of all sites</p>
</td></tr>
<tr><td><code>FRt</code></td>
<td>
<p> the total functional richness in the dataset</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> the multiple-site analog of the shared functional richness term</p>
</td></tr>
<tr><td><code>shared</code></td>
<td>
<p> a matrix containing the functional richness shared between pairs of sites</p>
</td></tr>
<tr><td><code>not.shared</code></td>
<td>
<p> a matrix containing the functional richness not shared between pairs of sites: b, c</p>
</td></tr>
<tr><td><code>sum.not.shared</code></td>
<td>
<p> a matrix containing the total functional richness not shared between pairs of sites: b+c</p>
</td></tr>
<tr><td><code>max.not.shared</code></td>
<td>
<p> a matrix containing the total maximum functional richness not shared between pairs of sites: max(b,c)</p>
</td></tr>
<tr><td><code>min.not.shared</code></td>
<td>
<p> a matrix containing the total minimum functional richness not shared between pairs of sites: min(b,c)</p>
</td></tr>
<tr><td><code>details</code></td>
<td>
<p> if <code>return.details=TRUE</code> a list of two lists: 
<code>$CH</code> a list with a vector (<code>FRi</code>) of functional richness in each site (i.e. convex hull volume) and <code>coord_vertices</code> a list of N matrices with the coordinates of species being vertices in the D-dimensions functional space. 
<code>$intersections</code> a list of 3 lists: <code>$combinations</code>, N-1 matrices with all combinations of 2 to N sites (numbers are rank of sites in x) ; <code>$volumes</code>, N-1 vectors with the volume inside the intersection between each combination of sites ; <code>$coord_vertices</code>, list of N-1 matrices with the coordinates of the vertices shaping these intersections (NA if no intersection). See <a href="http://www.qhull.org/html/qh-optq.htm">http://www.qhull.org/html/qh-optq.htm</a> for the possible options.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sébastien Villéger, Andrés Baselga, David Orme, Renato Henriques-Silva, Maxime Logez 
</p>


<h3>References</h3>

<p>Villéger S., Novack-Gottshal P. &amp; Mouillot D. 2011. The multidimensionality of the niche reveals functional diversity changes in benthic marine biotas across geological time. Ecology Letters. 14, 561-568
</p>
<p>Baselga, A. 2012. The relationship between species replacement, dissimilarity derived from nestedness, and nestedness. 
Global Ecology and Biogeography 21, 1223-1232
</p>
<p>Villéger, S. Grenouillet, G., Brosse, S. 2012. Decomposing functional beta-diversity reveals that low functional beta-diversity is driven by low functional turnover in European fish assemblages. Global Ecology and Biogeography, in press
</p>


<h3>See Also</h3>

<p><code><a href="#topic+functional.beta.multi">functional.beta.multi</a></code>, <code><a href="#topic+functional.beta.pair">functional.beta.pair</a></code>, <code><a href="#topic+betapart.core">betapart.core</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### 4 communities in a 2D functional space (convex hulls are rectangles)
traits.test &lt;- cbind(c(1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5), 
                     c(1, 2, 4, 1, 2, 3, 5, 1, 4, 3, 5))
dimnames(traits.test) &lt;- list(paste("sp", 1:11, sep=""), c("Trait 1", "Trait 2")) 

comm.test &lt;- matrix(0, 4, 11, dimnames = list(c("A", "B", "C", "D"), 
                    paste("sp", 1:11, sep="")))
comm.test["A", c(1, 2, 4, 5)] &lt;- 1
comm.test["B", c(1, 3, 8, 9)] &lt;- 1
comm.test["C", c(6, 7, 10, 11)] &lt;- 1
comm.test["D", c(2, 4, 7, 9)] &lt;- 1

plot(5, 5, xlim = c(0, 6), ylim = c(0, 6), type = "n", xlab = "Trait 1", ylab = "Trait 2")
points(traits.test[, 1], traits.test[, 2], pch = 21, cex = 1.5, bg = "black")
rect(1, 1, 4, 4, col = "#458B0050", border = "#458B00")
text(2.5, 2.5, "B" , col = "#458B00", cex = 1.5)	
polygon(c(2, 1, 3, 4), c(1, 2, 5, 4), col = "#DA70D650", border = "#DA70D6") 
text(2.5, 3, "D", col = "#DA70D6", cex = 1.5)	
rect(1, 1, 2, 2, col = "#FF000050", border = "#FF0000")
text(1.5, 1.5, "A", col = "#FF0000", cex = 1.5)	
rect(3, 3, 5, 5, col = "#1E90FF50", border = "#1E90FF")
text(4, 4.2, "C", col = "#1E90FF", cex = 1.5)	

# for multiple dissimilarity, multi = TRUE
test.core &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
                                      multi = TRUE, return.details = FALSE)
test.core

# for pairwise dissimilarity, multi = FALSE
test.core &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
                                      multi = FALSE, return.details = FALSE)
test.core

# to use systematilcally the "QJ" options 
test.core &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
                                      multi = FALSE, return.details = FALSE,
                                      convhull.opt = list(conv1 = "QJ"))

# to use the "QJ" options only if the convhull function generates an error
# instead of returning NA
test.core &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
                                      multi = FALSE, return.details = FALSE,
                                      convhull.opt = list(conv2 = "QJ"))

# using functional.betapart.core to get details on intersections
# when only pairwise dissimilarity is computed
test.core.pair &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
                                           multi = FALSE, return.details = TRUE)
test.core.pair

# for multiple dissimilarity
test.core.multi &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
                                            multi = TRUE, return.details = TRUE)
test.core.multi


# using core outputs to compute pairwise and multiple functional dissimilarities
functional.beta.pair(x = test.core.pair, index.family = "jaccard" )
functional.beta.multi(x = test.core.multi, index.family = "jaccard" )


##### using internal parallelisation to fasten pairiwse dissimilarity
# by default it use serial computation
test.core.pair &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
                                           multi = FALSE, return.details = FALSE, 
                                           fbc.step = FALSE, parallel = FALSE)
                                          
# by default it uses half of the cores and 1 task per run (this can be customised)
# test.core.pairp &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
#                                            multi = FALSE, return.details = FALSE, 
#                                            fbc.step = FALSE, parallel = TRUE)

# you can set the number of core to use :
test.core.pairp &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
                                            multi = FALSE, return.details = FALSE, 
                                            fbc.step = FALSE, parallel = TRUE, 
                                            opt.parallel = beta.para.control(nc = 2))
all.equal(test.core.pair, test.core.pairp)

# library(microbenchmark)
# microbenchmark(serial = 
#                  functional.betapart.core(comm.test, traits.test, multi = FALSE, 
#                                           return.details = FALSE, fbc.step = FALSE,
#                                           parallel = FALSE),
#                nc2 = 
#                  functional.betapart.core(comm.test, traits.test, multi = FALSE, 
#                                           return.details = FALSE, fbc.step = FALSE,
#                                           parallel = TRUE, 
#                                           opt.parallel = beta.para.control(nc = 2)),
#                nc4 =
#                  functional.betapart.core(comm.test, traits.test, multi = FALSE, 
#                                           return.details = FALSE, fbc.step = FALSE,
#                                           parallel = TRUE, 
#                                           opt.parallel = beta.para.control(nc = 4))
# )

## Not run: 
# If the number of species is very different among communities
# load-balancing parallelisation could be very efficient
# especially when the number of community is high
test.core.pairp &lt;- functional.betapart.core(comm.test, traits.test, multi = FALSE, 
                                            return.details = FALSE, fbc.step = FALSE,
                                            parallel = TRUE, 
                                            opt.parallel = 
                                              beta.para.control(nc = 2, LB = TRUE))

# use you can use fork cluster (but not on Windows)
#test.core.pairp &lt;- functional.betapart.core(comm.test, traits.test, multi = FALSE, 
#                                            return.details = FALSE, fbc.step = FALSE,
#                                            parallel = TRUE, 
#                                            opt.parallel = 
#                                              beta.para.control(nc = 2, type = "FORK"))

# finally you can customise the number of task run at each time
test.core.pairp &lt;- functional.betapart.core(comm.test, traits.test, multi = FALSE, 
                                            return.details = FALSE, fbc.step = FALSE,
                                            parallel = TRUE, 
                                            opt.parallel = 
                                              beta.para.control(nc = 2, size = 6))

# using internal parallelisation is not always useful, especially on small data set
# load balancing is very helpful when species richness are highly variable

# Null model using 'external' parallel computing 

# Example 1: pairwise functional beta diversity (functional.beta.pair)
# Note that this is an example with a small number of samples and null model 
# permutations for illustration.
# Real null model analyses should have a much greater number of samples and permutations.

##### 4 communities in a 3D functional space

comm.test &lt;- matrix(0, 4, 11, dimnames = list(c("A", "B", "C", "D"), 
                                              paste("sp", 1:11, sep = "")))
comm.test["A", c(1, 2, 4, 5)] &lt;- 1
comm.test["B", c(1, 3, 8, 9)] &lt;- 1
comm.test["C", c(6, 7, 10, 11)] &lt;- 1
comm.test["D", c( 2, 4, 7, 9)] &lt;- 1

set.seed(1)
traits.test &lt;- matrix(rnorm(11*3, mean = 0, sd = 1), 11, 3) 
dimnames(traits.test) &lt;- list(paste("sp", 1:11, sep = "") , 
                              c("Trait 1", "Trait 2", "Trait 3"))

# Required packages
library(doSNOW)
library(picante)
library(fastmatch)
library(foreach)


# define number of cores
# Use parallel::detectCores() to determine number of cores available in your machine
nc &lt;- 2 

# 4 cores would be better (nc &lt;- 4)

# create cluster
cl &lt;- snow::makeCluster(nc)

# register parallel backend
doSNOW::registerDoSNOW(cl)

# define number of permutations for the null model (the usual is 1000)
# make sure that nperm/nc is a whole number so that all cores have the same number 
# of permutations to work on
nperm &lt;- 100

test.score &lt;- functional.betapart.core(comm.test, traits.test, multi = FALSE, 
                                       warning.time = FALSE, return.details = FALSE, 
                                       fbc.step = FALSE, parallel = FALSE)

obs.pair.func.dis &lt;- functional.beta.pair(x = test.score, index.family = "sorensen")

# transform functional.beta.pair results into a matrix
obs.pair.func.dis &lt;- do.call(rbind, obs.pair.func.dis)

# set names for each pair of site
pair_names &lt;- combn(rownames(comm.test), 2, FUN = paste, collapse = "_")
colnames(obs.pair.func.dis) &lt;- pair_names

# export necessary variables and functions to the cluster of cores
snow::clusterExport(cl = cl, c("comm.test", "traits.test"),
                        envir = environment())

# creation of an iterator to run 1 comparaisons on each core at time
it &lt;- itertools::isplitIndices(nperm, chunkSize = 1)

# parallel computation
null.pair.func.dis &lt;- 
  foreach(n = it, .combine = c, .packages=c("picante","betapart","fastmatch")) %dopar% {
                                
          # it enables to adjust the number of permutations (nt) done on each run
          nt &lt;- length(n)
          null.pair.temp &lt;- vector(mode = "list", length = nt)
                                
          # for each core "n" perform "nt" permutations
          for (j in 1:nt){ 
                    
            # randomize community with chosen null model
            # for this particular example we used the "independent swap algorithm" 
            # but the user can choose other types of permutation
            # or create it's own null model 
            null.comm.test &lt;- randomizeMatrix(comm.test, null.model = "independentswap", 
                                              iterations=1000)
                                  
            # execute functional.betapart.core function 
            null.test.score &lt;- 
              try(functional.betapart.core(null.comm.test, traits = traits.test, 
                                           multi = FALSE, warning.time = FALSE, 
                                           return.details = FALSE,  fbc.step = FALSE, 
                                           parallel = FALSE), silent = TRUE)
            # using 'external' parallelisation it is necessary to set parralel to FALSE
                                  
            # in this artificial example there are a few combinations of species that 
            # the convex hull cannot be calculated due to some odd geometric combination 
            # so we need to re-permute the community matrix 
            while(inherits(null.test.score, "try-error")){
                                    
              null.comm.test &lt;- randomizeMatrix(comm.test, null.model = "independentswap", 
                                                iterations = 1000)
              null.test.score &lt;- 
                try(functional.betapart.core(x = null.comm.test, traits = traits.test, 
                                             multi = FALSE, warning.time = FALSE, 
                                             return.details = FALSE, fbc.step = FALSE, 
                                             parallel = FALSE), silent = TRUE)
              }
                                  
            # compute the pairwise beta-diversity null values and input them in the 
            # temporary result matrix
            res &lt;- functional.beta.pair(x = null.test.score, index.family = "sorensen")
            null.pair.temp[[j]] &lt;- do.call(rbind, res)
                                  
        }
        #retrieve the results from each core
        null.pair.temp
    }

# stop cluster
snow::stopCluster(cl)


# compute the mean, standard deviation and p-values of dissimilarity metrics
# for each pair of site

mean.null.pair.func &lt;- matrix(numeric(), ncol = ncol(obs.pair.func.dis), 
                              nrow = nrow(obs.pair.func.dis))
sd.null.pair.func &lt;- matrix(numeric(), ncol = ncol(obs.pair.func.dis), 
                            nrow = nrow(obs.pair.func.dis))
p.pair.func.dis &lt;- matrix(numeric(), ncol = ncol(obs.pair.func.dis), 
                          nrow = nrow(obs.pair.func.dis))

# for each one of the 3 null dissimilarity metrics (SIN, SNE and SOR) 
for (j in 1:nrow(obs.pair.func.dis)){
  matnull &lt;- sapply(null.pair.func.dis, function(x) x[j,])
  mean.null.pair.func[j,] &lt;- rowMeans(matnull)
  sd.null.pair.func[j,] &lt;- sqrt(rowSums((matnull - mean.null.pair.func[j,])^2)/(nperm-1))
  p.pair.func.dis[j,] &lt;- rowSums(matnull &gt;= obs.pair.func.dis[j,]) 
  p.pair.func.dis[j,] &lt;- (pmin(p.pair.func.dis[j,],nperm-p.pair.func.dis[j,])+1)/(nperm+1)
  # the +1 is to take into account that the observed value is one of the possibilities
}

# compute standardized effect sizes
ses.pair.func.dis &lt;- (obs.pair.func.dis - mean.null.pair.func)/sd.null.pair.func


# Example 2: multiple functional beta diversity (functional.beta.multi)
# Note that this is an example with a small number of samples and null model
# permutations for illustration.
# Real null model analyses should have a much greater number of samples 
# and permutations.

##### 4 communities in a 3D functional space

comm.test &lt;- matrix(0, 4, 11,dimnames = list(c("A", "B", "C", "D"), 
                                             paste("sp", 1:11, sep = "")))
comm.test["A", c(1, 2, 4, 5)] &lt;- 1
comm.test["B", c(1, 3, 8, 9)] &lt;- 1
comm.test["C", c(6, 7, 10, 11)] &lt;- 1
comm.test["D", c(2, 4, 7, 9)]&lt;-1

set.seed(1)
traits.test &lt;- matrix(rnorm(11*3, mean=0, sd=1), 11, 3) 
dimnames(traits.test) &lt;- list(paste("sp", 1:11, sep=""), 
                              c("Trait 1", "Trait 2", "Trait 3"))

# Required packages
library(doSNOW)
library(picante)
library(fastmatch)
library(foreach)


# define number of cores
# Use parallel::detectCores() to determine number of cores available in your machine
nc &lt;- 2 

# create cluster
cl &lt;- snow::makeCluster(nc)

# register parallel backend 
doSNOW::registerDoSNOW(cl)

# define number of permutations for the null model (the usual is 1000)
# make sure that nperm/nc is a whole number so that all cores have the same number 
# of permutations to work on
nperm &lt;- 10

# compute observed values for multiple functional dissimilarities
test.score &lt;- functional.betapart.core(comm.test, traits.test, multi = TRUE, 
                                       warning.time = FALSE, return.details = FALSE, 
                                       fbc.step = FALSE, parallel = FALSE)
obs.multi.func.dis &lt;- do.call(cbind, functional.beta.multi(test.score, 
                                                           index.family = "sorensen"))

# export necessary variables and functions to the cluster of cores
snow::clusterExport(cl = cl, c("comm.test", "traits.test"), 
                        envir=environment())

it &lt;- itertools::isplitIndices(nperm, chunkSize = 1)
  
null.multi.func.dis &lt;- 
  foreach(n = it, .combine = rbind, 
          .packages = c("picante","betapart","fastmatch")) %dopar% {
                                 
    # for each core, create temporary matrix to store 3 null multiple functional 
    # dissimilarity indices (SIN, SNE,SOR)
    null.multi.temp &lt;- matrix(numeric(), ncol = 3, nrow = length(n), 
                              dimnames = list(NULL, c("funct.beta.SIM", "funct.beta.SNE", 
                                              "funct.beta.SOR")))
                                 
    # number of tasks per core (i.e., permutations per core)
    nt &lt;- length(n)
                                 
    # for each core "n" perform "nt" permutations
    for (j in 1:nt) { 
                                     
      # randomize community matrix with chosen null model (for this example 
      # we chose the "independent swap" algorithm) 
      null.comm.test &lt;- randomizeMatrix(comm.test, null.model="independentswap", 
                                        iterations=1000)
                                   
      # execute functional.betapart.core function identifying each "n" core 
      # with the core.ident argument for external parallelization, 
      null.test.score &lt;- 
        try(functional.betapart.core(null.comm.test, traits.test, multi = TRUE,  
                                     warning.time = FALSE, return.details = FALSE, 
                                     fbc.step = FALSE, parallel = FALSE), 
            silent = TRUE)
                                   
      # in this artificial example there are a few combinations of species
      # that the convex hull 
      # cannot be calculated due to some odd geometric combination so we 
      # need to re-permute the community matrix 
                                   
      while(inherits(null.test.score, "try-error")){
        null.comm.test &lt;- randomizeMatrix(comm.test, null.model="independentswap", 
                                          iterations=1000)
        null.test.score &lt;- 
          try(functional.betapart.core(null.comm.test, traits.test, multi = TRUE,
                                       warning.time = FALSE, return.details = FALSE, 
                                       fbc.step = FALSE, parallel = FALSE), 
              silent = TRUE)
        }    
      # input null values in the temporary result matrix
      null.multi.temp[j,] &lt;- unlist(functional.beta.multi(null.test.score, 
                                                          index.family = "sorensen"))
      }
    # recover results from each core
    null.multi.temp
    }

# close cluster
snow::stopCluster(cl)

# result matrix
result &lt;- matrix(numeric(), ncol = 3, nrow = 3, 
                 dimnames = list(c("obs", "ses", "p"), colnames(obs.multi.func.dis)))

# input observed values for the multiple functional dissimilarity indices (SIN, SNE,SOR)
result[1,] = obs.multi.func.dis

# compute standardized effect sizes (ses) for the multiple functional
# dissimilarity indices (SIN, SNE,SOR)
result[2,] &lt;- (obs.multi.func.dis-colMeans(null.multi.func.dis, na.rm=TRUE))/
  apply(null.multi.func.dis,2, sd, na.rm=TRUE)

# compute p-values for the multiple functional dissimilarity indices (SIN, SNE,SOR)
for (i in 1:3) {
  result[3, i] &lt;- sum(obs.multi.func.dis[i]&lt;=null.multi.func.dis[,i])
  result[3, i] &lt;- (pmin(result[3, i], nperm - result[3, i]) + 1)/(nperm+1)
}
# the +1 is to take into account that the observed value is one of the possibilities

result
###     

## End(Not run)

</code></pre>

<hr>
<h2 id='functional.betapart.core.pairwise'>functional.betapart.core.pairwise</h2><span id='topic+functional.betapart.core.pairwise'></span>

<h3>Description</h3>

<p>Computes the basic quantities needed for computing the pairwise functional dissimilarity matrices. 
This function is similar to functional.betapart.core with multi=FALSE but it provides more options for computing convex hulls shaping each assemblage (through option passed to qhull algorithm in 'geometry::convhulln()' as well as their intersections (computed based on library 'geometry' whenever possible, else with 'rcdd' as in functional.betapart.core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>functional.betapart.core.pairwise(x, traits, 
                                  return.details = TRUE,
                                  parallel = FALSE, 
                                  opt.parallel = beta.para.control(), 
                                  convhull.opt = qhull.opt(),
                                  progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="functional.betapart.core.pairwise_+3A_x">x</code></td>
<td>
<p>A data frame, where rows are sites and columns are species.</p>
</td></tr>
<tr><td><code id="functional.betapart.core.pairwise_+3A_traits">traits</code></td>
<td>
<p>A data frame, where rows are species and columns are functional space 
dimensions (i.e. quantitative traits or synthetic axes after PCoA). Number of species
in each site must be strictly higher than number of dimensions.</p>
</td></tr>
<tr><td><code id="functional.betapart.core.pairwise_+3A_return.details">return.details</code></td>
<td>
<p>A logical value indicating if informations concerning the 
computation of the convexhull volumes should be returned (<code>TRUE</code>) or not (<code>FALSE</code>). See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="functional.betapart.core.pairwise_+3A_parallel">parallel</code></td>
<td>
<p>A logical value indicating if internal parallelization is used to compute pairwise dissimilarities (<code>TRUE</code>), see Examples..</p>
</td></tr>
<tr><td><code id="functional.betapart.core.pairwise_+3A_opt.parallel">opt.parallel</code></td>
<td>
<p>A list of four values to modify default values used to define and run the parallel cluster. 
See <code><a href="#topic+beta.para.control">beta.para.control</a></code> and the <code>Details</code> section.</p>
</td></tr>
<tr><td><code id="functional.betapart.core.pairwise_+3A_convhull.opt">convhull.opt</code></td>
<td>
<p>A list of two named vectors of character <code>conv1</code> and <code>conv2</code> defining the options that 
will be passed to the <code><a href="geometry.html#topic+convhulln">convhulln</a></code> function to compute the convexhull volumes (<a href="http://www.qhull.org/html/qh-optq.htm">http://www.qhull.org/html/qh-optq.htm</a>).
<code>conv1</code> sets the default option that will be passed tp <code>convhulln</code> (<code>'QJ'</code> by default instead of <code>'Qt'</code>), 
while <code>conv2</code> set the options if <code>convhulln</code> return an error with options set by <code>conv1</code>. 
See <code>Details</code> and the examples.</p>
</td></tr>
<tr><td><code id="functional.betapart.core.pairwise_+3A_progress">progress</code></td>
<td>
<p>A logical indicating if a progress bar should be displayed (<code>TRUE</code>) or not (by default) (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<ul>
<li><p>opt.parallel: Among the four options (see <code><a href="#topic+beta.para.control">beta.para.control</a></code>),
the number of cores (<code>nc</code>) and the number of convexhull volumes computed by each core at each iteration <code>size</code>
are the most important with this function. As <code><a href="#topic+inter_rcdd">inter_rcdd</a></code> is very fast, it is necessary to set a large value (&gt;100) for <code>size</code>.
Otherwise the parallelisation would not be so efficient. With a low number of communities using internal parallelisation will 
slow down the function.
</p>
</li>
<li><p>convhull.opt: Some specific distribution of points could generate errors when computing the convexhull volumes with
the default qhull options ('Qt'), that is why <code>'QJ'</code> was preferred as default values (<code>conv1</code>). Sometimes, it could be 
interesting to use alternative options such as 'Qt' or 'Qs' or to use alternative options to achieve the computation. 
These alternative options could be used to compute all the convexhull volumes with <code>conv1</code> or only when an error occurs
using <code>conv2</code>. It is thus possible to define <code>conv1</code> as <code>'Qt'</code> to use the default 'qhull' options but to prevent error 
by setting <code>'QJ'</code> to the <code>conv2</code> argument.
</p>
</li></ul>




<h3>Value</h3>

<p>The function returns an object of class <code>betapart</code> with the following elements:
</p>

<dl>
<dt>sumFRi</dt><dd><p> The sum of the functional richness values of all sites</p>
</dd>
<dt>FRt</dt><dd><p> The total functional richness in the dataset <code>NA</code>. Kept for compatibility with <code>functional.betapart.core</code></p>
</dd>
<dt>a</dt><dd><p> The multiple-site analog of the shared functional richness term, <code>NA</code>. Kept for compatibility with <code>functional.betapart.core</code> </p>
</dd>
<dt>shared</dt><dd><p> A matrix containing the functional richness shared between pairs of sites</p>
</dd>
<dt>not.shared</dt><dd><p> A matrix containing the functional richness not shared between pairs of sites: b, c</p>
</dd>
<dt>sum.not.shared</dt><dd><p> A matrix containing the total functional richness not shared between pairs of sites: b+c</p>
</dd>
<dt>max.not.shared</dt><dd><p> A matrix containing the total maximum functional richness not shared between pairs of sites: max(b,c)</p>
</dd>
<dt>min.not.shared</dt><dd><p> A matrix containing the total minimum functional richness not shared between pairs of sites: min(b,c)</p>
</dd>
<dt>details</dt><dd> <p><code>NA</code> if <code>return.details = FALSE</code>. Otherwise a list of two elements: 
</p>

<ul>
<li><p><code>$FRi</code> a data frame with two columns, the <code>FRi</code> values and the qhull options used to compute them (<code>qhull.opt</code>).
</p>
</li>
<li><p><code>$Intersection</code> a data frame with the pairs of communities (<code>Comms</code>), 
the function used to compute the volume of their intersections (<code>Inter</code>) and the qhull options used (<code>qhull.opt</code>)
</p>
</li></ul>

</dd>
</dl>




<h3>Examples</h3>

<pre><code class='language-R'>##### 4 communities in a 2D functional space (convex hulls are rectangles)
traits.test &lt;- cbind(c(1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5), 
                    c(1, 2, 4, 1, 2, 3, 5, 1, 4, 3, 5))
dimnames(traits.test) &lt;- list(paste("sp", 1:11, sep=""), c("Trait 1", "Trait 2")) 

comm.test &lt;- matrix(0, 4, 11, dimnames = list(c("A", "B", "C", "D"), 
                                             paste("sp", 1:11, sep="")))
comm.test["A", c(1, 2, 4, 5)] &lt;- 1
comm.test["B", c(1, 3, 8, 9)] &lt;- 1
comm.test["C", c(6, 7, 10, 11)] &lt;- 1
comm.test["D", c(2, 4, 7, 9)] &lt;- 1

plot(5, 5, xlim = c(0, 6), ylim = c(0, 6), type = "n", xlab = "Trait 1", ylab = "Trait 2")
points(traits.test[, 1], traits.test[, 2], pch = 21, cex = 1.5, bg = "black")
rect(1, 1, 4, 4, col = "#458B0050", border = "#458B00")
text(2.5, 2.5, "B" , col = "#458B00", cex = 1.5)	
polygon(c(2, 1, 3, 4), c(1, 2, 5, 4), col = "#DA70D650", border = "#DA70D6") 
text(2.5, 3, "D", col = "#DA70D6", cex = 1.5)	
rect(1, 1, 2, 2, col = "#FF000050", border = "#FF0000")
text(1.5, 1.5, "A", col = "#FF0000", cex = 1.5)	
rect(3, 3, 5, 5, col = "#1E90FF50", border = "#1E90FF")
text(4, 4.2, "C", col = "#1E90FF", cex = 1.5)	

# for pairwise dissimilarity
test.core &lt;- functional.betapart.core.pairwise(x = comm.test, traits = traits.test,
                                               return.details = FALSE)
test.core
# equivalent to 
test &lt;- functional.betapart.core(x = comm.test, traits = traits.test,
                                 return.details = FALSE,
                                 multi = FALSE)
all.equal(test.core, test)

# using core outputs to compute pairwise and multiple functional dissimilarities
functional.beta.pair(x = test.core, index.family = "jaccard" )

## Not run: 
#### using convhulln options
# a data set that generates NA (due to errors) with functional.betapart.core
data(betatest)
# a list of 2 data.frame : comm.test &amp; traits.test
comm.test &lt;- betatest$comm.test
traits.test &lt;- betatest$traits.test

test &lt;- functional.betapart.core(x = comm.test, traits = traits.test,
                                 return.details = FALSE,
                                 multi = FALSE)

any(is.na(test$shared))
# no NA because the default option was set to QJ
# if we use the default option of qhull (Qt) :
test &lt;- functional.betapart.core(x = comm.test, traits = traits.test,
                                 return.details = FALSE,
                                 multi = FALSE,
                                 convhull.opt = list(conv1 = "Qt"))
any(is.na(test$shared))
# some NA arise

## End(Not run)
# with functional.betapart.core.pairwise
test.core &lt;- functional.betapart.core.pairwise(x = comm.test, traits = traits.test,
                                               return.details = FALSE,
                                               convhull.opt = list(conv1 = "Qt"))
any(is.na(test.core$shared))
# here no NA were generated because the volumes of the intersections
# were computed only with inter_geom
# to know which functions were used, set return.details to TRUE
test.core &lt;- functional.betapart.core.pairwise(x = comm.test, traits = traits.test,
                                               return.details = TRUE,
                                               convhull.opt = list(conv1 = "Qt"))
test.core$details$Intersection

#### convhull options
traits.test &lt;- cbind(c(1, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5) , 
                     c(1, 2, 4, 1, 2, 3, 5, 1, 4, 3, 5))
dimnames(traits.test) &lt;- list(paste("sp", 1:11, sep=""), c("Trait 1", "Trait 2")) 

comm.test &lt;- matrix(0, 4, 11,
                    dimnames = list(c("A", "B", "C", "D"), paste("sp", 1:11, sep="")))
comm.test["A", c(1, 2, 4, 5)] &lt;- 1
comm.test["B", c(1, 3, 8, 9)] &lt;- 1
comm.test["C", c(6, 7, 10, 11)] &lt;- 1
comm.test["D", c(2, 4, 7, 9)] &lt;- 1 

# simulating a case with species very close to each other
# here species 2, 4, 3, 8  close to species 1 
# so it is like commA and commB have only 2 species instead of 4 in the 2D space
traits.test0&lt;-traits.test
traits.test0[c(2,5),]&lt;-traits.test0[1,]+10^-6
traits.test0[c(3,8),]&lt;-traits.test0[1,]+10^-6
traits.test0

## Not run: 
# trying .core function with default qhull option
core.test0 &lt;- functional.betapart.core(x = comm.test, traits = traits.test0, multi=FALSE,
                                       convhull.opt = list(conv1 = "Qt"))
core.test0 # crashing because of coplanarity

# trying new .core.pairwise with default qhull option for convex hull
core.pair_test0 &lt;- functional.betapart.core.pairwise(x = comm.test, traits = traits.test0,
                                                     convhull.opt = list(conv1 = "Qt"))

# with default qhull options (Qt) it coud be impossible to compute the functional volumes
# this is why 'Qj' is now used as the default option for the convexhull volumes

# but other options could be passed to convexhull

# trying new core.pairwise with Qs for convex hull
core.pair_test0_Qs &lt;- functional.betapart.core.pairwise(x = comm.test, 
                                                        traits = traits.test0,
                                                        convhull.opt = list(conv1= "Qs"))
# not working

## End(Not run)

# trying new .pairwise with QJ (default option) for convex hull
core.pair_test0_Qj &lt;- functional.betapart.core.pairwise(x = comm.test, traits = traits.test0,
                                                        convhull.opt = list(conv1 = "QJ"),
                                                        return.details = TRUE)
# OK and QJ applied to each volume computation
core.pair_test0_Qj

# equivalent to 
core.pair_test0_Qj &lt;- functional.betapart.core.pairwise(x = comm.test, traits = traits.test0,
                                                        return.details = TRUE)

# but QJ could be applied only when error are generated with other options :
core.pair_test0_Qja &lt;- functional.betapart.core.pairwise(x = comm.test, traits = traits.test0,
                                                         convhull.opt = list(conv1 = "Qt",
                                                                             conv2 = "QJ"),
                                                         return.details = TRUE)
# OK and QJ applied only for one volume computation (community 'B')

core.pair_test0_Qja
# numerous intersection had to be computed with inter_rcdd

# the results are comparable
all.equal(core.pair_test0_Qj[-9], core.pair_test0_Qja[-9]) # -9 to remove details

# the pairwise functional functional betadiversity
functional.beta.pair(core.pair_test0_Qj, index.family = "jaccard")

## Not run: 
##### using internal parallelisation to fasten pairiwse dissimilarity
# by default (parallel = FALSE) the code is run in serial
test.core.pair &lt;- functional.betapart.core.pairwise(x = comm.test, traits = traits.test, 
                                                    parallel = FALSE)
# when using internal parallelisation and default options 
# it uses half of the cores and 1 task per run (this can be customised)
# test.core.pairp &lt;- functional.betapart.core(x = comm.test, traits = traits.test, 
#                                            multi = FALSE, return.details = FALSE, 
#                                            fbc.step = FALSE, parallel = TRUE)
# you can set the number of core to use :
test.core.pairp &lt;- 
  functional.betapart.core.pairwise(x = comm.test, traits = traits.test, 
                                    parallel = TRUE, 
                                    opt.parallel = beta.para.control(nc = 2))
all.equal(test.core.pair, test.core.pairp)


# as inter_geom is much more faster than inter_rccd it is useful to increase the number
# of calculus run per iteration to limit the time consumed by the cluster itself
# you can play on size (this would not have sense here as there is only few computation)

  test.core.pairp &lt;- 
    functional.betapart.core.pairwise(x = comm.test, traits = traits.test, 
                                      parallel = TRUE, 
                                      opt.parallel = 
                                      beta.para.control(nc = 2,
                                                        size = 100))
  all.equal(test.core.pair, test.core.pairp)
  
  
library(microbenchmark)
  microbenchmark(
    serial = functional.betapart.core.pairwise(comm.test, traits.test),
    nc2 = functional.betapart.core.pairwise(comm.test, traits.test,
                                            parallel = TRUE,
                                            opt.parallel = beta.para.control(nc = 2)),
    nc4 = functional.betapart.core.pairwise(comm.test, traits.test, multi = FALSE,
                                            parallel = TRUE,
                                            opt.parallel = beta.para.control(nc = 4))
  )


# If the number of species is very different among communities
# load-balancing parallelisation could be more efficient
# especially when the number of community is high
test.core.pairp &lt;- 
  functional.betapart.core.pairwise(comm.test, traits.test, 
                                    parallel = TRUE, 
                                    opt.parallel = beta.para.control(nc = 2, LB = TRUE))

# use you can use fork cluster (but not on Windows)
test.core.pairp &lt;- 
  functional.betapart.core.pairwise(comm.test, traits.test,
                                      parallel = TRUE,
                                      opt.parallel = 
                                        beta.para.control(nc = 2, type = "FORK"))

 
# a progress bar can be displayed to asses the evolution of the computations
  test.core.pairp &lt;- 
    functional.betapart.core.pairwise(comm.test, traits.test,
                                      parallel = TRUE,
                                      opt.parallel = 
                                        beta.para.control(nc = 2, LB = TRUE),
                                      progress = TRUE)


# using internal parallelisation is not always useful, especially on small data set
# load balancing is very helpful when species richness are highly variable

# Null model using 'external' parallel computing 

# Example 1: pairwise functional beta diversity (functional.beta.pair)
# Note that this is an example with a small number of samples and null model 
# permutations for illustration.
# Real null model analyses should have a much greater number of samples and permutations.

##### 4 communities in a 3D functional space

comm.test &lt;- matrix(0, 4, 11, dimnames = list(c("A", "B", "C", "D"), 
                                              paste("sp", 1:11, sep = "")))
comm.test["A", c(1, 2, 4, 5)] &lt;- 1
comm.test["B", c(1, 3, 8, 9)] &lt;- 1
comm.test["C", c(6, 7, 10, 11)] &lt;- 1
comm.test["D", c( 2, 4, 7, 9)] &lt;- 1

set.seed(1)
traits.test &lt;- matrix(rnorm(11*3, mean = 0, sd = 1), 11, 3) 
dimnames(traits.test) &lt;- list(paste("sp", 1:11, sep = "") , 
                              c("Trait 1", "Trait 2", "Trait 3"))

# Required packages
library(doSNOW)
library(picante)
library(foreach)
library(itertools)

# define number of permutations for the null model (the usual is 1000)
# make sure that nperm/nc is a whole number so that all cores have the same number 
# of permutations to work on
nperm &lt;- 100

test.score &lt;- functional.betapart.core.pairwise(comm.test, traits.test)

obs.pair.func.dis &lt;- functional.beta.pair(x = test.score, index.family = "sorensen")

# transform functional.beta.pair results into a matrix
obs.pair.func.dis &lt;- do.call(rbind, obs.pair.func.dis)

# set names for each pair of site
pair_names &lt;- combn(rownames(comm.test), 2, FUN = paste, collapse = "_")
colnames(obs.pair.func.dis) &lt;- pair_names

# define number of cores
# Use parallel::detectCores() to determine number of cores available in your machine
nc &lt;- 2 

# 4 cores would be better (nc &lt;- 4)

# create cluster
cl &lt;- snow::makeCluster(nc)

# register parallel backend
doSNOW:::registerDoSNOW(cl)

# export necessary variables and functions to the cluster of cores
snow::clusterExport(cl = cl, c("comm.test", "traits.test"),
                    envir = environment())

# creation of an iterator to run 1 comparaisons on each core at time
it &lt;- itertools::isplitIndices(nperm, chunkSize = 10)

null.pair.func.dis &lt;- 
  foreach(n = it, .combine = c, 
          .packages=c("picante","betapart","fastmatch", "rcdd", "geometry")) %dopar% {
            
            # it enables to adjust the number of permutations (nt) done on each run
            nt &lt;- length(n)
            null.pair.temp &lt;- vector(mode = "list", length = nt)
            
            # for each core "n" perform "nt" permutations
            for (j in 1:nt){ 
              
              # randomize community with chosen null model
              # for this particular example we used the "independent swap algorithm" 
              # but the user can choose other types of permutation
              # or create it's own null model 
              null.comm.test &lt;- randomizeMatrix(comm.test, null.model = "independentswap", 
                                                iterations=1000)
              
              # execute functional.betapart.core function 
              null.test.score &lt;- 
                functional.betapart.core.pairwise(null.comm.test, traits = traits.test, 
                                                  parallel = FALSE)
              # using 'external' parallelisation it is necessary to set parralel to FALSE
              
              # in this artificial example there are a few combinations of species that 
              # the convex hull cannot be calculated due to some odd geometric combination 
              # so we need to specify to use the 'QJ' options in case of errors
              
              # compute the pairwise beta-diversity null values and input them in the 
              # temporary result matrix
              res &lt;- functional.beta.pair(x = null.test.score, index.family = "sorensen")
              null.pair.temp[[j]] &lt;- do.call(rbind, res)
            }
            #retrieve the results from each core
            null.pair.temp
          }

# stop cluster
snow::stopCluster(cl)

#compute the mean, standard deviation and p-values of dissimilarity metrics
# for each pair of site

mean.null.pair.func &lt;- matrix(numeric(), ncol = ncol(obs.pair.func.dis), 
                              nrow = nrow(obs.pair.func.dis))
sd.null.pair.func &lt;- matrix(numeric(), ncol = ncol(obs.pair.func.dis), 
                            nrow = nrow(obs.pair.func.dis))
p.pair.func.dis &lt;- matrix(numeric(), ncol = ncol(obs.pair.func.dis), 
                          nrow = nrow(obs.pair.func.dis))

# for each one of the 3 null dissimilarity metrics (SIN, SNE and SOR) 
for (j in 1:nrow(obs.pair.func.dis)){
  matnull &lt;- sapply(null.pair.func.dis, function(x) x[j,])
  mean.null.pair.func[j,] &lt;- rowMeans(matnull)
  sd.null.pair.func[j,] &lt;- sqrt(rowSums((matnull - mean.null.pair.func[j,])^2)/(nperm-1))
  p.pair.func.dis[j,] &lt;- rowSums(matnull &gt;= obs.pair.func.dis[j,]) 
  p.pair.func.dis[j,] &lt;- (pmin(p.pair.func.dis[j,],nperm-p.pair.func.dis[j,])+1)/(nperm+1)
  # the +1 is to take into account that the observed value is one of the possibilities
}

# compute standardized effect sizes
ses.pair.func.dis &lt;- (obs.pair.func.dis - mean.null.pair.func)/sd.null.pair.func

## End(Not run)
</code></pre>

<hr>
<h2 id='inter_geom'>Internal function to compute convexhull volume</h2><span id='topic+inter_geom'></span>

<h3>Description</h3>

<p>Estimation of the convexhull volume of the intersection of two hypervolumes based on the <code><a href="geometry.html#topic+intersectn">intersectn</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_geom(ps1, ps2, options = "Tv", tol = 0, fp = NULL, qhull.opt = "n FA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inter_geom_+3A_ps1">ps1</code></td>
<td>
<p>A matrix of coordinates.</p>
</td></tr>
<tr><td><code id="inter_geom_+3A_ps2">ps2</code></td>
<td>
<p>A second matrix of coordinates.</p>
</td></tr>
<tr><td><code id="inter_geom_+3A_options">options</code></td>
<td>
<p>Options pass to <code><a href="geometry.html#topic+halfspacen">halfspacen</a></code>.</p>
</td></tr>
<tr><td><code id="inter_geom_+3A_tol">tol</code></td>
<td>
<p>Tolerance, see <code><a href="geometry.html#topic+intersectn">intersectn</a></code>.</p>
</td></tr>
<tr><td><code id="inter_geom_+3A_fp">fp</code></td>
<td>
<p>Coordinates of feasible point (NULL).</p>
</td></tr>
<tr><td><code id="inter_geom_+3A_qhull.opt">qhull.opt</code></td>
<td>
<p>qhull options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the convex hull volume of the intersection of two hypervolumes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inter_rcdd">inter_rcdd</a></code>, <code><a href="geometry.html#topic+intersectn">intersectn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mat1 &lt;- matrix(runif(30), 10)
mat2 &lt;- matrix(runif(30), 10)
inter_geom(mat1, mat2)
## End(Not run)
</code></pre>

<hr>
<h2 id='inter_geom_coord'>Internal function to compute convexhull volume and vertice coordinates</h2><span id='topic+inter_geom_coord'></span>

<h3>Description</h3>

<p>Estimation of the convexhull volume and the vertices of the intersection of two hypervolumes based on geometry functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_geom_coord(
  ps1,
  ps2,
  options = "Tv",
  tol = 0,
  fp = NULL,
  qhull.opt = "n FA"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inter_geom_coord_+3A_ps1">ps1</code></td>
<td>
<p>A matrix of coordinates.</p>
</td></tr>
<tr><td><code id="inter_geom_coord_+3A_ps2">ps2</code></td>
<td>
<p>A second matrix of coordinates.</p>
</td></tr>
<tr><td><code id="inter_geom_coord_+3A_options">options</code></td>
<td>
<p>Options pass to <code><a href="geometry.html#topic+halfspacen">halfspacen</a></code>.</p>
</td></tr>
<tr><td><code id="inter_geom_coord_+3A_tol">tol</code></td>
<td>
<p>Tolerance, see <code><a href="geometry.html#topic+intersectn">intersectn</a></code>.</p>
</td></tr>
<tr><td><code id="inter_geom_coord_+3A_fp">fp</code></td>
<td>
<p>Coordinates of feasible point (NULL).</p>
</td></tr>
<tr><td><code id="inter_geom_coord_+3A_qhull.opt">qhull.opt</code></td>
<td>
<p>qhull options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements.
</p>
<dl>
<dt>coord</dt><dd><p> the vertice coordinates</p>
</dd>
<dt>vol</dt><dd><p> a volume corresponding to the intersection of the two hypervolumes</p>
</dd>
</dl>




<h3>See Also</h3>

<p><code><a href="#topic+inter_rcdd_coord">inter_rcdd_coord</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mat1 &lt;- matrix(runif(30), 10)
mat2 &lt;- matrix(runif(30), 10)
inter_geom_coord(mat1, mat2)
## End(Not run)
</code></pre>

<hr>
<h2 id='inter_rcdd'>Internal function to compute convexhull volume</h2><span id='topic+inter_rcdd'></span>

<h3>Description</h3>

<p>Estimation of the convexhull volume of the intersection of two hypervolumes based on rcdd functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_rcdd(set1, set2, qhull.opt = "FA", conv2 = function(...) NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inter_rcdd_+3A_set1">set1</code></td>
<td>
<p>A matrix of coordinates</p>
</td></tr>
<tr><td><code id="inter_rcdd_+3A_set2">set2</code></td>
<td>
<p>A matrix of coordinates</p>
</td></tr>
<tr><td><code id="inter_rcdd_+3A_qhull.opt">qhull.opt</code></td>
<td>
<p>Qhull options, see <a href="http://www.qhull.org/html/qh-optq.htm">http://www.qhull.org/html/qh-optq.htm</a></p>
</td></tr>
<tr><td><code id="inter_rcdd_+3A_conv2">conv2</code></td>
<td>
<p>A function applyed if the convexhull function crashes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A volume corresponding to the intersection of the two hypervolumes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inter_geom">inter_geom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mat1 &lt;- matrix(runif(30), 10)
mat2 &lt;- matrix(runif(30), 10)
inter_rcdd(mat1, mat2)
## End(Not run)
</code></pre>

<hr>
<h2 id='inter_rcdd_coord'>Internal function to compute convexhull volume and vertice coordinates</h2><span id='topic+inter_rcdd_coord'></span>

<h3>Description</h3>

<p>Estimation of the convexhull volume and the vertices of the intersection of two hypervolumes based on rcdd functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inter_rcdd_coord(set1, set2, qhull.opt = "FA", conv2 = function(...) NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inter_rcdd_coord_+3A_set1">set1</code></td>
<td>
<p>A matrix of coordinates</p>
</td></tr>
<tr><td><code id="inter_rcdd_coord_+3A_set2">set2</code></td>
<td>
<p>A matrix of coordinates</p>
</td></tr>
<tr><td><code id="inter_rcdd_coord_+3A_qhull.opt">qhull.opt</code></td>
<td>
<p>Qhull options, see <a href="http://www.qhull.org/html/qh-optq.htm">http://www.qhull.org/html/qh-optq.htm</a></p>
</td></tr>
<tr><td><code id="inter_rcdd_coord_+3A_conv2">conv2</code></td>
<td>
<p>A function applyed if the convexhull function crashes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 2 elements.
</p>
<dl>
<dt>coord</dt><dd><p> the vertice coordinates</p>
</dd>
<dt>vol</dt><dd><p> a volume corresponding to the intersection of the two hypervolumes</p>
</dd>
</dl>




<h3>See Also</h3>

<p><code><a href="#topic+inter_geom_coord">inter_geom_coord</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: mat1 &lt;- matrix(runif(30), 10)
mat2 &lt;- matrix(runif(30), 10)
inter_rcdd_coord(mat1, mat2)
## End(Not run)
</code></pre>

<hr>
<h2 id='phylo.beta.multi'>
Multiple-site phylogenetic dissimilarities
</h2><span id='topic+phylo.beta.multi'></span>

<h3>Description</h3>

<p>Computes 3 distance values accounting for the multiple-site phylogenetic turnover and nestedness components
of phylogenetic beta diversity, and the sum of both values.
Phylogenetic dissimilarities are based on Faith's phylogenetic diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo.beta.multi(x, tree, index.family="sorensen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo.beta.multi_+3A_x">x</code></td>
<td>
<p> a community matrix or data frame, where rows are sites and columns are species. Alternatively <code>x</code> can 
be a <code>phylo.betapart</code> object derived from the <code>phylo.betapart.core</code> function</p>
</td></tr>
<tr><td><code id="phylo.beta.multi_+3A_tree">tree</code></td>
<td>
<p> a phylogenetic tree of class phylo with tips names identic to species names from the community matrix.</p>
</td></tr>
<tr><td><code id="phylo.beta.multi_+3A_index.family">index.family</code></td>
<td>
<p> family of dissimilarity indices, partial match of <code>"sorensen"</code> or <code>"jaccard"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Sorensen dissimilarity index allows computing  the PhyloSor index (Bryant et al. 2008) whereas the Jaccard dissimilarity index allows computing the UniFrac index (Lozupone &amp; Knight 2005).
</p>


<h3>Value</h3>

<p>The function returns a list with three phylogenetic dissimilarity values.
</p>
<p>For <code>index.family="sorensen"</code> the three values are:
</p>
<table>
<tr><td><code>phylo.beta.sim</code></td>
<td>
 <p><code>dist</code> object, dissimilarity value accounting for phylogenetic turnover, measured as Simpson derived multiple-site phylogenetic dissimilarity</p>
</td></tr>
<tr><td><code>phylo.beta.sne</code></td>
<td>
 <p><code>dist</code> object, dissimilarity value accounting for nestedness-resultant phylogenetic dissimilarity, measured as the nestedness-fraction of Sorensen derived multiple-site phylogenetic dissimilarity</p>
</td></tr>
<tr><td><code>phylo.beta.sor</code></td>
<td>
 <p><code>dist</code> object, dissimilarity value accounting for phylogenetic beta diversity, measured as Sorensen derived multiple-site phylogenetic dissimilarity</p>
</td></tr>
</table>
<p>For <code>index.family="jaccard"</code> the three values are:
</p>
<table>
<tr><td><code>phylo.beta.jtu</code></td>
<td>
 <p><code>dist</code> object, dissimilarity value accounting for phylogenetic turnover, measured as the turnover-fraction of Jaccard derived multiple-site phylogenetic dissimilarity</p>
</td></tr>
<tr><td><code>phylo.beta.jne</code></td>
<td>
 <p><code>dist</code> object, dissimilarity value accounting for nestedness-resultant phylogenetic dissimilarity, measured as the nestedness-fraction of Jaccard derived multiple-site phylogenetic dissimilarity</p>
</td></tr>
<tr><td><code>phylo.beta.jac</code></td>
<td>
 <p><code>dist</code> object, dissimilarity value accounting for phylogenetic beta diversity, measured as Jaccard derived multiple-site phylogenetic dissimilarity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien De Bortoli (juldebortoli@yahoo.fr), Fabien Leprieur(fabien.leprieur@univ-montp2.fr), Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Baselga A. (2012) The relationship between species replacement, dissimilarity derived from nestedness, and nestedness.
Global Ecology and Biogeography 21, 1223-1232
</p>
<p>Bryant JA, Lamanna C, Morlon H, Kerkhoff AJ, Enquist BJ, et al. (2008) Microbes on mountainsides: Contrasting elevational patterns of bacterial and plant diversity. Proceedings of the National Academy of Sciences of the United States of America 105: 11505-11511.
</p>
<p>Faith DP, Lozupone CA, Nipperess D, Knight R (2009) The Cladistic Basis for the Phylogenetic Diversity (PD) Measure Links Evolutionary Features to Environmental Gradients and Supports Broad Applications of Microbial Ecology's &quot;Phylogenetic Beta Diversity&quot; Framework. Int J Mol Sci 10: 4723-4741. doi: 10.3390/ijms10114723.
</p>
<p>Leprieur F, Albouy C, De Bortoli J, Cowman PF, Bellwood DR, et al. (2012) Quantifying Phylogenetic Beta Diversity: Distinguishing between &quot;True&quot; Turnover of Lineages and Phylogenetic Diversity Gradients. PLoS ONE 7(8): e42760. doi:10.1371/journal.pone.0042760
</p>
<p>Lozupone C, Knight R (2005) UniFrac: a new phylogenetic method for comparing microbial communities. Applied and Environmental Microbiology 71: 8228-8235.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylo.betapart.core">phylo.betapart.core</a></code>, <code><a href="#topic+beta.multi">beta.multi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# toy tree for 6 species (sp1 to sp6)
require(ape)
toy.tree&lt;-read.tree(text="(((sp1:1,sp2:1):5,(sp3:3,sp4:3):3):2,(sp5:7,sp6:7):1);")
plot(toy.tree)

# toy community table with 6 assemblages (A to F) with 6 species (sp1 to sp6)
toy.comm&lt;-matrix(nrow=6, ncol=6)
rownames(toy.comm)&lt;-c("A","B","C","D","E","F")
colnames(toy.comm)&lt;-c("sp1","sp2","sp3","sp4","sp5","sp6")
toy.comm[1,]&lt;-c(1,1,1,0,0,0)
toy.comm[2,]&lt;-c(0,1,1,1,0,0)
toy.comm[3,]&lt;-c(0,0,1,1,1,0)
toy.comm[4,]&lt;-c(0,0,1,1,1,1)
toy.comm[5,]&lt;-c(0,0,0,1,1,1)
toy.comm[6,]&lt;-c(1,0,0,1,1,1)

toy.phylobetamulti&lt;-phylo.beta.multi(toy.comm, toy.tree, index.family="sor")
toy.betamulti&lt;-beta.multi(toy.comm, index.family="sor")

</code></pre>

<hr>
<h2 id='phylo.beta.pair'>
Pair-wise phylogenetic dissimilarities
</h2><span id='topic+phylo.beta.pair'></span>

<h3>Description</h3>

<p>Computes 3 distance matrices accounting for the phylogenetic turnover and nestedness components
of phylogenetic beta diversity, and the sum of both values.
Phylogenetic dissimilarities are based on Faith's phylogenetic diversity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo.beta.pair(x, tree, index.family="sorensen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo.beta.pair_+3A_x">x</code></td>
<td>
<p> a community matrix or data frame, where rows are sites and columns are species. Alternatively <code>x</code> can 
be a <code>phylo.betapart</code> object derived from the <code>phylo.betapart.core</code> function</p>
</td></tr>
<tr><td><code id="phylo.beta.pair_+3A_tree">tree</code></td>
<td>
<p> a phylogenetic tree of class phylo with tips names identic to species names from the community matrix.</p>
</td></tr>
<tr><td><code id="phylo.beta.pair_+3A_index.family">index.family</code></td>
<td>
<p> family of dissimilarity indices, partial match of <code>"sorensen"</code> or <code>"jaccard"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Sorensen dissimilarity index allows computing  the PhyloSor index (Bryant et al. 2008) whereas the Jaccard dissimilarity index allows computing the UniFrac index (Lozupone &amp; Knight 2005).
</p>


<h3>Value</h3>

<p>The function returns a list with three phylogenetic dissimilarity matrices.
</p>
<p>For <code>index.family="sorensen"</code> the three matrices are:
</p>
<table>
<tr><td><code>phylo.beta.sim</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for phylogenetic turnover, measured as Simpson derived pair-wise phylogenetic dissimilarity</p>
</td></tr>
<tr><td><code>phylo.beta.sne</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for nestedness-resultant phylogenetic dissimilarity, measured as the nestedness-fraction of Sorensen derived pair-wise phylogenetic dissimilarity</p>
</td></tr>
<tr><td><code>phylo.beta.sor</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for phylogenetic beta diversity, measured as Sorensen derived pair-wise phylogenetic dissimilarity</p>
</td></tr>
</table>
<p>For <code>index.family="jaccard"</code> the three matrices are:
</p>
<table>
<tr><td><code>phylo.beta.jtu</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for phylogenetic turnover, measured as the turnover-fraction of Jaccard derived pair-wise phylogenetic dissimilarity</p>
</td></tr>
<tr><td><code>phylo.beta.jne</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for nestedness-resultant phylogenetic dissimilarity, measured as the nestedness-fraction of Jaccard derived pair-wise phylogenetic dissimilarity</p>
</td></tr>
<tr><td><code>phylo.beta.jac</code></td>
<td>
 <p><code>dist</code> object, dissimilarity matrix accounting for phylogenetic beta diversity, measured as Jaccard derived pair-wise phylogenetic dissimilarity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien De Bortoli (juldebortoli@yahoo.fr), Fabien Leprieur(fabien.leprieur@univ-montp2.fr), Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Baselga A. (2012) The relationship between species replacement, dissimilarity derived from nestedness, and nestedness.
Global Ecology and Biogeography 21, 1223-1232
</p>
<p>Bryant JA, Lamanna C, Morlon H, Kerkhoff AJ, Enquist BJ, et al. (2008) Microbes on mountainsides: Contrasting elevational patterns of bacterial and plant diversity. Proceedings of the National Academy of Sciences of the United States of America 105: 11505-11511.
</p>
<p>Faith DP, Lozupone CA, Nipperess D, Knight R (2009) The Cladistic Basis for the Phylogenetic Diversity (PD) Measure Links Evolutionary Features to Environmental Gradients and Supports Broad Applications of Microbial Ecology's &quot;Phylogenetic Beta Diversity&quot; Framework. Int J Mol Sci 10: 4723-4741. doi: 10.3390/ijms10114723. 
</p>
<p>Leprieur F, Albouy C, De Bortoli J, Cowman PF, Bellwood DR, et al. (2012) Quantifying Phylogenetic Beta Diversity: Distinguishing between &quot;True&quot; Turnover of Lineages and Phylogenetic Diversity Gradients. PLoS ONE 7(8): e42760. doi:10.1371/journal.pone.0042760
</p>
<p>Lozupone C, Knight R (2005) UniFrac: a new phylogenetic method for comparing microbial communities. Applied and Environmental Microbiology 71: 8228-8235.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylo.betapart.core">phylo.betapart.core</a></code>, <code><a href="#topic+beta.pair">beta.pair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# toy tree for 6 species (sp1 to sp6)
require(ape)
toy.tree&lt;-read.tree(text="(((sp1:1,sp2:1):5,(sp3:3,sp4:3):3):2,(sp5:7,sp6:7):1);")
plot(toy.tree)

# toy community table with 6 assemblages (A to F) with 6 species (sp1 to sp6)
toy.comm&lt;-matrix(nrow=6, ncol=6)
rownames(toy.comm)&lt;-c("A","B","C","D","E","F")
colnames(toy.comm)&lt;-c("sp1","sp2","sp3","sp4","sp5","sp6")
toy.comm[1,]&lt;-c(1,1,1,0,0,0)
toy.comm[2,]&lt;-c(0,1,1,1,0,0)
toy.comm[3,]&lt;-c(0,0,1,1,1,0)
toy.comm[4,]&lt;-c(0,0,1,1,1,1)
toy.comm[5,]&lt;-c(0,0,0,1,1,1)
toy.comm[6,]&lt;-c(1,0,0,1,1,1)


toy.phylobetapair&lt;-phylo.beta.pair(toy.comm, toy.tree, index.family="sor")
toy.betapair&lt;-beta.pair(toy.comm, index.family="sor")
plot(toy.betapair$beta.sim,toy.phylobetapair$phylo.beta.sim)
plot(toy.betapair$beta.sne,toy.phylobetapair$phylo.beta.sne)
</code></pre>

<hr>
<h2 id='phylo.betapart.core'>
Core calculations of phylogenetic dissimilarities metrics
</h2><span id='topic+phylo.betapart.core'></span>

<h3>Description</h3>

<p>Computes the basic quantities needed for computing the multiple-site phylogenetic beta diversity measures
and pairwise phylogenetic dissimilarity matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phylo.betapart.core(x, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phylo.betapart.core_+3A_x">x</code></td>
<td>
<p> a community matrix or data frame, where rows are sites and columns are species.</p>
</td></tr>
<tr><td><code id="phylo.betapart.core_+3A_tree">tree</code></td>
<td>
<p> a phylogenetic tree of class phylo with tips names identic to species names from the community matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with:
</p>
<table>
<tr><td><code>sumSi</code></td>
<td>
<p> the sum of the phylogenetic diversity values of all sites</p>
</td></tr>
<tr><td><code>St</code></td>
<td>
<p> the total phylogenetic diversity in the dataset</p>
</td></tr>
<tr><td><code>shared</code></td>
<td>
<p> a matrix containing the phylogenetic diversity shared between pairs of sites</p>
</td></tr>
<tr><td><code>sum.not.shared</code></td>
<td>
<p> a matrix containing the total phylogenetic diversity not shared between pairs of sites: b+c</p>
</td></tr>
<tr><td><code>max.not.shared</code></td>
<td>
<p> a matrix containing the total maximum phylogenetic diversity not shared between pairs of sites: max(b,c)</p>
</td></tr>
<tr><td><code>min.not.shared</code></td>
<td>
<p> a matrix containing the total minimum phylogenetic diversity not shared between pairs of sites: min(b,c)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julien De Bortoli (juldebortoli@yahoo.fr), Fabien Leprieur(fabien.leprieur@univ-montp2.fr), Andrés Baselga and David Orme
</p>


<h3>References</h3>

<p>Baselga A. (2012) The relationship between species replacement, dissimilarity derived from nestedness, and nestedness.
Global Ecology and Biogeography 21, 1223-1232
</p>
<p>Bryant JA, Lamanna C, Morlon H, Kerkhoff AJ, Enquist BJ, et al. (2008) Microbes on mountainsides: Contrasting elevational patterns of bacterial and plant diversity. Proceedings of the National Academy of Sciences of the United States of America 105: 11505-11511.
</p>
<p>Faith DP, Lozupone CA, Nipperess D, Knight R (2009) The Cladistic Basis for the Phylogenetic Diversity (PD) Measure Links Evolutionary Features to Environmental Gradients and Supports Broad Applications of Microbial Ecology's &quot;Phylogenetic Beta Diversity&quot; Framework. Int J Mol Sci 10: 4723-4741. doi: 10.3390/ijms10114723.
</p>
<p>Leprieur F, Albouy C, De Bortoli J, Cowman PF, Bellwood DR, et al. (2012) Quantifying Phylogenetic Beta Diversity: Distinguishing between &quot;True&quot; Turnover of Lineages and Phylogenetic Diversity Gradients. PLoS ONE 7(8): e42760. doi:10.1371/journal.pone.0042760
</p>
<p>Lozupone C, Knight R (2005) UniFrac: a new phylogenetic method for comparing microbial communities. Applied and Environmental Microbiology 71: 8228-8235.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+phylo.beta.pair">phylo.beta.pair</a></code>, <code><a href="#topic+phylo.beta.multi">phylo.beta.multi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# toy tree for 6 species (sp1 to sp6)
require(ape)
toy.tree&lt;-read.tree(text="(((sp1:1,sp2:1):5,(sp3:3,sp4:3):3):2,(sp5:7,sp6:7):1);")
plot(toy.tree)

# toy community table with 6 assemblages (A to F) with 6 species (sp1 to sp6)
toy.comm&lt;-matrix(nrow=6, ncol=6)
rownames(toy.comm)&lt;-c("A","B","C","D","E","F")
colnames(toy.comm)&lt;-c("sp1","sp2","sp3","sp4","sp5","sp6")
toy.comm[1,]&lt;-c(1,1,1,0,0,0)
toy.comm[2,]&lt;-c(0,1,1,1,0,0)
toy.comm[3,]&lt;-c(0,0,1,1,1,0)
toy.comm[4,]&lt;-c(0,0,1,1,1,1)
toy.comm[5,]&lt;-c(0,0,0,1,1,1)
toy.comm[6,]&lt;-c(1,0,0,1,1,1)

toy.phylocore&lt;-phylo.betapart.core(toy.comm, toy.tree)
</code></pre>

<hr>
<h2 id='plot.decay'>
Plotting distance decay curves from models computed with decay.model() 
</h2><span id='topic+plot.decay'></span>

<h3>Description</h3>

<p>Takes the output of decay.model() and plots a distance-decay curve, either a negative exponential 
or power law function as estimated with decay.model().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decay'
plot(x, xlim=c(0,max(x$data.x)), ylim=c(0,1), 
add=FALSE, remove.dots=FALSE, col="black", pch=1, lty=1, lwd=5, cex=1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.decay_+3A_x">x</code></td>
<td>
<p> the output of decay.model().</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_xlim">xlim</code></td>
<td>
<p> the range of spatial distances to be plotted, default is from 0 to the maximum distance in the data.</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_ylim">ylim</code></td>
<td>
<p> the range of assemblage similarities or dissimilarities to be plotted, default is from 0 to 1.</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_add">add</code></td>
<td>
<p> add to the previous plot.</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_remove.dots">remove.dots</code></td>
<td>
<p> remove the dots from the plot, thus retaining just the decay curve.</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_col">col</code></td>
<td>
<p> colour used.</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_pch">pch</code></td>
<td>
<p> symbol used for points.</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_lty">lty</code></td>
<td>
<p> line type.</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_lwd">lwd</code></td>
<td>
<p> line width.</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_cex">cex</code></td>
<td>
<p> scale of text and symbols.</p>
</td></tr>
<tr><td><code id="plot.decay_+3A_...">...</code></td>
<td>
<p> other parameters for plotting functions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrés Baselga
</p>


<h3>References</h3>

<p>Gómez-Rodríguez, C. &amp; Baselga, A. 2018. Variation among European beetle taxa in patterns of distance decay 
of similarity suggests a major role of dispersal processes. Ecography 41: 1825-1834
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decay.model">decay.model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# presence/absence tables for longhorn beetles of South and North Europe
data(ceram.s)
data(ceram.n)

# spatial coordinates of territories in South and North Europe
data(coords.s)
data(coords.n)

# dissimilarity matrices
ceram.s.sim&lt;-beta.pair(ceram.s)$beta.sim
ceram.n.sim&lt;-beta.pair(ceram.n)$beta.sim

# spatial distances in km
distgeo.s&lt;-dist(coords.s[,1:2])
distgeo.n&lt;-dist(coords.n[,1:2])

# Negative exponential models for the decay of similarity with spatial distance
decay.south&lt;-decay.model(y=1-ceram.s.sim, x=distgeo.s, y.type="sim", model.type="exp")
decay.north&lt;-decay.model(y=1-ceram.n.sim, x=distgeo.n, y.type="sim", model.type="exp")

# Plot the decay models
plot.decay(decay.south, col="red")
plot.decay(decay.north, col="blue", add=TRUE)

# Equivalent models for the increase of dissimilarity with spatial distance
increase.south&lt;-decay.model(y=ceram.s.sim, x=distgeo.s, y.type="dissim", model.type="exp")
increase.north&lt;-decay.model(y=ceram.n.sim, x=distgeo.n, y.type="dissim", model.type="exp")

# Plot the decay models
plot.decay(increase.south, col="red")
plot.decay(increase.north, col="blue", add=TRUE)

</code></pre>

<hr>
<h2 id='qhull.opt'>Specifying control Values for convexhull volume estimation</h2><span id='topic+qhull.opt'></span>

<h3>Description</h3>

<p>Set the default value to use inside the <code>functional.betapart.core</code> and <code>functional.betapart.pairwise</code> functions. 
It defined the options to use with the <code>convhulln</code> fonction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qhull.opt(conv1 = "QJ", conv2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qhull.opt_+3A_conv1">conv1</code></td>
<td>
<p>A character vector specifying qhull options.</p>
</td></tr>
<tr><td><code id="qhull.opt_+3A_conv2">conv2</code></td>
<td>
<p>A character vector specifying qhull options to use if the internal computation of convexhull volumes generates an error. By default (<code>NULL</code>) <code>NA</code> is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>conv1</code> defined options that will be use systematically when calling convhulln to estimate the convexhull volume of the intersection, while
<code>conv2</code> whill be used only if the first call to convhulln would have generated an error. For the complete list of possible options see For the list of options see  <a href="http://www.qhull.org/html/qh-optq.htm">http://www.qhull.org/html/qh-optq.htm</a>. 
By default, no option are passed which would generates <code>NA</code> if internal error. Setting one of the two elements to &quot;QJ&quot; can solve different issues 
with very close numerical estimation (difference lower than 1e-4 in our tests).
</p>


<h3>Value</h3>

<p>A named list of two elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inter_rcdd">inter_rcdd</a></code>, <code><a href="#topic+inter_geom">inter_geom</a></code>, <code><a href="geometry.html#topic+convhulln">convhulln</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: qhull.opt()
qhull.opt(conv1 = 'QJ')
qhull.opt(conv1 = "Qt", conv2 = 'QJ')
## End(Not run)
</code></pre>

<hr>
<h2 id='zdep'>
Assessing the differences between parameters of two distance-decay models computed with decay.model(). 
</h2><span id='topic+zdep'></span>

<h3>Description</h3>

<p>Takes two distance-decay models fitted with decay.model() and assess via block-site bootstrap whether the parameters of both models are equal. Two tests are conducted independently, one for the equality of the first parameters of both models, another for the equality of the second parameters (slopes) of both models. The null hypothesis is that parameters of both models are equal. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zdep(m1, m2, resamples, st.val = c(1, 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zdep_+3A_m1">m1</code></td>
<td>
<p> first distance decay model, the output of decay.model().</p>
</td></tr>
<tr><td><code id="zdep_+3A_m2">m2</code></td>
<td>
<p> second distance decay model, the output of decay.model().</p>
</td></tr>
<tr><td><code id="zdep_+3A_resamples">resamples</code></td>
<td>
<p> the number of bootstrap resamples.</p>
</td></tr>
<tr><td><code id="zdep_+3A_st.val">st.val</code></td>
<td>
<p> starting values for the nonlinear model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a dataframe with the tests statistics (Z.dep) and respective p values for both model parameters.
</p>


<h3>Author(s)</h3>

<p>Ramiro Martín-Devasa, Sara Martínez-Santalla, Carola Gómez-Rodríguez, Rosa M. Crujeiras, Andrés Baselga
</p>


<h3>References</h3>

<p>Martín-Devasa R, Martínez-Santalla S, Gómez-Rodríguez C, Crujeiras RM, Baselga A. 2022. Comparing distance-decay parameters: a novel test under pairwise dependence. Ecological Informatics 72: 101894 
</p>
<p>Martínez-Santalla S, Martín-Devasa R, Gómez-Rodríguez C, Crujeiras RM, Baselga A. 2022. Assessing the 
non-linear decay of community similarity: permutation and site-block resampling significance tests. 
Journal of Biogeography 49: 968-978
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decay.model">decay.model</a></code>, <code><a href="#topic+plot.decay">plot.decay</a></code>, <code><a href="#topic+boot.coefs.decay">boot.coefs.decay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># presence/absence tables for longhorn beetles of South and North Europe
data(ceram.s)
data(ceram.n)

# spatial coordinates of territories in South and North Europe
data(coords.s)
data(coords.n)

# dissimilarity matrices
ceram.s.sim&lt;-beta.pair(ceram.s)$beta.sim
ceram.n.sim&lt;-beta.pair(ceram.n)$beta.sim

# spatial distances in km
distgeo.s&lt;-dist(coords.s[,1:2])
distgeo.n&lt;-dist(coords.n[,1:2])

# Negative exponential distance decay models
decay.south&lt;-decay.model(y=1-ceram.s.sim, x=distgeo.s, y.type="sim", model.type="exp")
decay.north&lt;-decay.model(y=1-ceram.n.sim, x=distgeo.n, y.type="sim", model.type="exp")

# Plot the decay models
plot.decay(decay.south, col="red")
plot.decay(decay.north, col="blue", add=TRUE)

# Assess North-South difference between intercepts and slopes
zdep(decay.south, decay.north, resamples=1000)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
