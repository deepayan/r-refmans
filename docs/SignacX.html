<!DOCTYPE html><html><head><title>Help for package SignacX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SignacX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CID.entropy'><p>Normalized Shannon entropy-based &quot;unclassified&quot; assignment</p></a></li>
<li><a href='#CID.GetDistMat'><p>Computes distance matrix from edge list</p></a></li>
<li><a href='#CID.IsUnique'><p>Extracts unique elements</p></a></li>
<li><a href='#CID.LoadData'><p>Load data file from directory</p></a></li>
<li><a href='#CID.LoadEdges'><p>Load edges from edge list for single cell network</p></a></li>
<li><a href='#CID.Louvain'><p>Detects community substructure by Louvain community detection</p></a></li>
<li><a href='#CID.Normalize'><p>Library size normalize</p></a></li>
<li><a href='#CID.smooth'><p>Smoothing function</p></a></li>
<li><a href='#CID.writeJSON'><p>Writes JSON file for SPRING integration</p></a></li>
<li><a href='#GenerateLabels'><p>Generates cellular phenotype labels</p></a></li>
<li><a href='#Genes_Of_Interest'><p>Genes of interest for drug discovery / disease biology research</p></a></li>
<li><a href='#get_colors'><p>Get HEX colors</p></a></li>
<li><a href='#GetModels_HPCA'><p>Loads neural network models from GitHub</p></a></li>
<li><a href='#GetTrainingData_HPCA'><p>Loads bootstrapped HPCA training data from GitHub</p></a></li>
<li><a href='#KSoftImpute'><p>KNN-based imputation</p></a></li>
<li><a href='#MASC'><p>Mixed effect modeling</p></a></li>
<li><a href='#ModelGenerator'><p>Generates an ensemble of neural network models.</p></a></li>
<li><a href='#SaveCountsToH5'><p>Save count_matrix.h5 files for SPRING integration</p></a></li>
<li><a href='#Signac'><p>Classification of cellular phenotypes in single cell data</p></a></li>
<li><a href='#SignacBoot'><p>Generates bootstrapped single cell data</p></a></li>
<li><a href='#SignacFast'><p>Fast classification of cellular phenotypes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Cell Type Identification and Discovery from Single Cell Gene
Expression Data</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mathew Chamberlain &lt;chamberlainphd@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mathewchamberlain/SignacX">https://github.com/mathewchamberlain/SignacX</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mathewchamberlain/SignacX/issues">https://github.com/mathewchamberlain/SignacX/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>neuralnet, lme4, methods, Matrix, pbmcapply, Seurat(&ge; 3.2.0),
RJSONIO, igraph (&ge; 1.2.1), jsonlite (&ge; 1.5), RColorBrewer (&ge;
1.1.2), stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>hdf5r, rhdf5, knitr, rmarkdown, formatR</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of neural networks trained with flow-sorted gene expression data to classify cellular phenotypes in single cell RNA-sequencing data. See Chamberlain M et al. (2021) &lt;<a href="https://doi.org/10.1101%2F2021.02.01.429207">doi:10.1101/2021.02.01.429207</a>&gt; for more details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-18 02:53:21 UTC; ubuntu</td>
</tr>
<tr>
<td>Author:</td>
<td>Mathew Chamberlain [aut, cre],
  Virginia Savova [aut],
  Richa Hanamsagar [aut],
  Frank Nestle [aut],
  Emanuele de Rinaldis [aut],
  Sanofi US [fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-18 16:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='CID.entropy'>Normalized Shannon entropy-based &quot;unclassified&quot; assignment</h2><span id='topic+CID.entropy'></span>

<h3>Description</h3>

<p><code>CID.entropy</code> calculates the normalized Shannon entropy of labels for each cell
among k-nearest neighbors less than four-degrees apart, and then sets cells with statistically
significant large Shannon entropy to be &quot;Unclassified.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CID.entropy(ac, distM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CID.entropy_+3A_ac">ac</code></td>
<td>
<p>a character vector of cell type labels</p>
</td></tr>
<tr><td><code id="CID.entropy_+3A_distm">distM</code></td>
<td>
<p>the distance matrix, see ?CID.GetDistMat</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector like 'ac' but with cells type labels set to &quot;Unclassified&quot; if there was high normalized Shannon entropy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data classified previously (see \code{SignacFast})
P &lt;- readRDS("celltypes.rds")
S &lt;- readRDS("pbmcs.rds")

# get edges from default assay from Seurat object
default.assay &lt;- Seurat::DefaultAssay(S)
edges = S@graphs[[which(grepl(paste0(default.assay, "_nn"), names(S@graphs)))]]

# get distance matrix
D = CID.GetDistMat(edges)

# entropy-based unclassified labels labels
entropy = CID.entropy(ac = P$L2, distM = D)

## End(Not run)
</code></pre>

<hr>
<h2 id='CID.GetDistMat'>Computes distance matrix from edge list</h2><span id='topic+CID.GetDistMat'></span>

<h3>Description</h3>

<p><code>CID.GetDistMat</code> returns the distance matrix (i.e., adjacency matrix, second-degree adjacency matrix, ..., etc.)
from an edge list. Here, edges is the edge list, and n is the order of the connetions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CID.GetDistMat(edges, n = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CID.GetDistMat_+3A_edges">edges</code></td>
<td>
<p>a data frame with two columns; V1 and V2, specifying the cell-cell edge list for the network</p>
</td></tr>
<tr><td><code id="CID.GetDistMat_+3A_n">n</code></td>
<td>
<p>maximum network distance to subtend (n neighbors)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>adjacency matrices for distances &lt; n
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Loads edges
file.dir = "https://kleintools.hms.harvard.edu/tools/client_datasets/"
file = "CITESEQ_EXPLORATORY_CITESEQ_5K_PBMCS/FullDataset_v1_protein/edges.csv"
download.file(paste0(file.dir, file, "?raw=true"), destfile = "edges.csv")

# data.dir is your path to the "edges.csv" file
edges = CID.LoadEdges(data.dir = ".")

# get distance matrix (adjacency matrices with up to fourth-order connections) from edge list
distance_matrices = CID.GetDistMat(edges)

## End(Not run)
</code></pre>

<hr>
<h2 id='CID.IsUnique'>Extracts unique elements</h2><span id='topic+CID.IsUnique'></span>

<h3>Description</h3>

<p><code>CID.IsUnique</code> returns a Boolean for the unique elements of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CID.IsUnique(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CID.IsUnique_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean, unique elements are TRUE
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a dummy variable
dummy = c("A", "A", "B", "C")

# get only unique elements
logik = CID.IsUnique(dummy) 
dummy[logik]
</code></pre>

<hr>
<h2 id='CID.LoadData'>Load data file from directory</h2><span id='topic+CID.LoadData'></span>

<h3>Description</h3>

<p>Loads 'matrix.mtx' and 'genes.txt' files from a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CID.LoadData(data.dir, mfn = "matrix.mtx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CID.LoadData_+3A_data.dir">data.dir</code></td>
<td>
<p>Directory containing matrix.mtx and genes.txt.</p>
</td></tr>
<tr><td><code id="CID.LoadData_+3A_mfn">mfn</code></td>
<td>
<p>file name; default is 'matrix.mtx'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix with rownames equivalent to the names in genes.txt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Loads data from SPRING

# dir is your path to the "categorical_coloring_data.json" file
dir = "./FullDataset_v1"

# load expression data
E = CID.LoadData(data.dir = dir)

## End(Not run)
</code></pre>

<hr>
<h2 id='CID.LoadEdges'>Load edges from edge list for single cell network</h2><span id='topic+CID.LoadEdges'></span>

<h3>Description</h3>

<p><code>CID.LoadEdges</code> loads edges, typically after running the SPRING pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CID.LoadEdges(data.dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CID.LoadEdges_+3A_data.dir">data.dir</code></td>
<td>
<p>A directory where &quot;edges.csv&quot; file is located</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The edge list in data frame format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Loads edges
file.dir = "https://kleintools.hms.harvard.edu/tools/client_datasets/"
file = "CITESEQ_EXPLORATORY_CITESEQ_5K_PBMCS/FullDataset_v1_protein/edges.csv"
download.file(paste0(file.dir, file, "?raw=true"), destfile = "edges.csv")

# data.dir is your path to the "edges.csv" file
edges = CID.LoadEdges(data.dir = ".")

## End(Not run)
</code></pre>

<hr>
<h2 id='CID.Louvain'>Detects community substructure by Louvain community detection</h2><span id='topic+CID.Louvain'></span>

<h3>Description</h3>

<p><code>CID.Louvain</code> determines Louvain clusters from an edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CID.Louvain(edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CID.Louvain_+3A_edges">edges</code></td>
<td>
<p>A data frame or matrix with edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the community substructures of the graph corresponding to Louvain clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Loads edges
file.dir = "https://kleintools.hms.harvard.edu/tools/client_datasets/"
file = "CITESEQ_EXPLORATORY_CITESEQ_5K_PBMCS/FullDataset_v1_protein/edges.csv"
download.file(paste0(file.dir, file, "?raw=true"), destfile = "edges.csv")

# data.dir is your path to the "edges.csv" file
edges = CID.LoadEdges(data.dir = ".")

# get louvain clusters from edge list
clusters = CID.Louvain(edges)

## End(Not run)
</code></pre>

<hr>
<h2 id='CID.Normalize'>Library size normalize</h2><span id='topic+CID.Normalize'></span>

<h3>Description</h3>

<p><code>CID.Normalize</code> normalizes the expression matrix to the mean library size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CID.Normalize(E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CID.Normalize_+3A_e">E</code></td>
<td>
<p>Expression matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized expression matrix where each cell sums to the mean total counts
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# download single cell data for classification
file.dir = "https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/"
file = "pbmc_1k_v3_filtered_feature_bc_matrix.h5"
download.file(paste0(file.dir, file), "Ex.h5")

# load data, process with Seurat
library(Seurat)
E = Read10X_h5(filename = "Ex.h5")

# observe average total counts
mean(Matrix::colSums(E))

# run normalization
E_norm = CID.Normalize(E)

# check normalization
kmu = mean(Matrix::colSums(E_norm))
head(kmu)

## End(Not run)
</code></pre>

<hr>
<h2 id='CID.smooth'>Smoothing function</h2><span id='topic+CID.smooth'></span>

<h3>Description</h3>

<p><code>CID.smooth</code> uses k-nearest neighbors to identify cells which
correspond to a different label than the majority of their first-degree neighbors. If so,
those annotations are &quot;smoothed.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CID.smooth(ac, dM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CID.smooth_+3A_ac">ac</code></td>
<td>
<p>list containing a character vector where each element is a cell type or cell state assignment.</p>
</td></tr>
<tr><td><code id="CID.smooth_+3A_dm">dM</code></td>
<td>
<p>distance matrix (see ?CID.GetDistMat).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with smoothed labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load data classified previously (see SignacFast)
P &lt;- readRDS("celltypes.rds")
S &lt;- readRDS("pbmcs.rds")

# get edges from default assay from Seurat object
default.assay &lt;- Seurat::DefaultAssay(S)
edges = S@graphs[[which(grepl(paste0(default.assay, "_nn"), names(S@graphs)))]]

# get distance matrix
D = CID.GetDistMat(edges)

# smooth labels
smoothed = CID.smooth(ac = P$CellTypes, dM = D[[1]])

## End(Not run)
</code></pre>

<hr>
<h2 id='CID.writeJSON'>Writes JSON file for SPRING integration</h2><span id='topic+CID.writeJSON'></span>

<h3>Description</h3>

<p><code>CID.writeJSON</code> is a SPRING-integrated function for writing a JSON file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CID.writeJSON(
  cr,
  json_new = "categorical_coloring_data.json",
  spring.dir,
  new_populations = NULL,
  new_colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CID.writeJSON_+3A_cr">cr</code></td>
<td>
<p>output from <code><a href="#topic+GenerateLabels">GenerateLabels</a></code></p>
</td></tr>
<tr><td><code id="CID.writeJSON_+3A_json_new">json_new</code></td>
<td>
<p>Filename where annotations will be saved for new SPRING color tracks. Default is &quot;categorical_coloring_data_new.json&quot;.</p>
</td></tr>
<tr><td><code id="CID.writeJSON_+3A_spring.dir">spring.dir</code></td>
<td>
<p>Directory where file 'categorical_coloring_data.json' is located. If set, will add Signac annotations to the file.</p>
</td></tr>
<tr><td><code id="CID.writeJSON_+3A_new_populations">new_populations</code></td>
<td>
<p>Character vector specifying any new cell types that Signac has learned. Default is NULL.</p>
</td></tr>
<tr><td><code id="CID.writeJSON_+3A_new_colors">new_colors</code></td>
<td>
<p>Character vector specifying the HEX color codes for new cell types. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A categorical_coloring_data.json file with Signac annotations and Louvain clusters added.
</p>

<hr>
<h2 id='GenerateLabels'>Generates cellular phenotype labels</h2><span id='topic+GenerateLabels'></span>

<h3>Description</h3>

<p><code>GenerateLabels</code> returns a list of cell type and cell state labels, as well as novel cellular phenotypes and unclassified cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateLabels(
  cr,
  E = NULL,
  smooth = TRUE,
  new_populations = NULL,
  new_categories = NULL,
  min.cells = 10,
  spring.dir = NULL,
  graph.used = "nn"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateLabels_+3A_cr">cr</code></td>
<td>
<p>list returned by <code><a href="#topic+Signac">Signac</a></code> or by <code><a href="#topic+SignacFast">SignacFast</a></code>.</p>
</td></tr>
<tr><td><code id="GenerateLabels_+3A_e">E</code></td>
<td>
<p>a sparse gene (rows) by cell (column) matrix, or a Seurat object. Rows are HUGO symbols.</p>
</td></tr>
<tr><td><code id="GenerateLabels_+3A_smooth">smooth</code></td>
<td>
<p>if TRUE, smooths the cell type classifications. Default is TRUE.</p>
</td></tr>
<tr><td><code id="GenerateLabels_+3A_new_populations">new_populations</code></td>
<td>
<p>Character vector specifying any new cell types that were learned by Signac. Default is NULL.</p>
</td></tr>
<tr><td><code id="GenerateLabels_+3A_new_categories">new_categories</code></td>
<td>
<p>If new_populations are set to a cell type, new_category is a corresponding character vector indicating the population that the new population belongs to. Default is NULL.</p>
</td></tr>
<tr><td><code id="GenerateLabels_+3A_min.cells">min.cells</code></td>
<td>
<p>If desired, any cell population with equal to or less than N cells is set to &quot;Unclassified.&quot; Default is 10 cells.</p>
</td></tr>
<tr><td><code id="GenerateLabels_+3A_spring.dir">spring.dir</code></td>
<td>
<p>If using SPRING, directory to categorical_coloring_data.json. Default is NULL.</p>
</td></tr>
<tr><td><code id="GenerateLabels_+3A_graph.used">graph.used</code></td>
<td>
<p>If using Seurat object by default, Signac uses the nearest neighbor graph in the graphs field of the Seurat object. Other options are &quot;wnn&quot; to use weighted nearest neighbors, as well as &quot;snn&quot; to use shared nearest neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cell type labels for cell types, cell states and novel populations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# download single cell data for classification
file.dir = "https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/"
file = "pbmc_1k_v3_filtered_feature_bc_matrix.h5"
download.file(paste0(file.dir, file), "Ex.h5")

# load data, process with Seurat
library(Seurat)
E = Read10X_h5(filename = "Ex.h5")
pbmc &lt;- CreateSeuratObject(counts = E, project = "pbmc")

# run Seurat pipeline
pbmc &lt;- SCTransform(pbmc, verbose = FALSE)
pbmc &lt;- RunPCA(pbmc, verbose = FALSE)
pbmc &lt;- FindNeighbors(pbmc, dims = 1:30, verbose = FALSE)

# classify cells
labels = SignacFast(E = pbmc)
celltypes = GenerateLabels(labels, E = pbmc)

## End(Not run)
</code></pre>

<hr>
<h2 id='Genes_Of_Interest'>Genes of interest for drug discovery / disease biology research</h2><span id='topic+Genes_Of_Interest'></span>

<h3>Description</h3>

<p>3,304 genes curated from external sources
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Genes_Of_Interest
</code></pre>


<h3>Format</h3>

<p>A data frame with five columns
</p>

<dl>
<dt>Genes</dt><dd><p>genes, identified by HUGO symbols</p>
</dd>
<dt>CellPhoneDB</dt><dd><p>0 if not in CellPhoneDB, 1 if gene is listed as a receptor in CellPhoneDB</p>
</dd>
<dt>GWAS</dt><dd><p>0 if not GWAS, 1 if GWAS in GWAS catalog</p>
</dd>
<dt>PI_drugs</dt><dd><p>0 if not in Priority Index paper, 1 if gene is listed as a drug target in priority index paper</p>
</dd>
<dt>PI_GWAS</dt><dd><p>0 if not in Priority Index GWAS list, 1 if gene is listed as GWAS in priority index paper</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='get_colors'>Get HEX colors</h2><span id='topic+get_colors'></span>

<h3>Description</h3>

<p>Get HEX colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_colors(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_colors_+3A_p">P</code></td>
<td>
<p>A character vector of cell type labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of HEX colors for each category of cell type labels
</p>

<hr>
<h2 id='GetModels_HPCA'>Loads neural network models from GitHub</h2><span id='topic+GetModels_HPCA'></span>

<h3>Description</h3>

<p><code>GetModels_HPCA</code> returns a list of neural network models that were trained with the HPCA training data.
The HPCA training data has 18 classification tasks with bootstrapped training data.
The training data are split into two distinct cellular phenotypes (i.e., immune and nonimmune).
<code>GetModels_HPCA</code> downloads pre-computed neural networks trained to classify cells for each task (n = 100 models trained for each tasks).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetModels_HPCA()
</code></pre>


<h3>Value</h3>

<p>list of 1,800 neural network models stacked to solve 18 classification problems.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SignacFast">SignacFast</a></code>, <code><a href="#topic+ModelGenerator">ModelGenerator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
P = GetModels()

## End(Not run)
</code></pre>

<hr>
<h2 id='GetTrainingData_HPCA'>Loads bootstrapped HPCA training data from GitHub</h2><span id='topic+GetTrainingData_HPCA'></span>

<h3>Description</h3>

<p><code>GetTrainingData_HPCA</code> returns a list of bootstrapped HPCA training data.
The HPCA training data has 18 classification tasks, each split into two distinct cellular phenotypes (i.e., immune and nonimmune).
<code>GetTrainingData_HPCA</code> downloads bootstrapped training data to use for model-building.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetTrainingData_HPCA()
</code></pre>


<h3>Value</h3>

<p>A list with two elements; 'Reference' are the training data, and 'genes' &ndash; the union of all features present in the training data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
P = GetTrainingData_HPCA()

## End(Not run)
</code></pre>

<hr>
<h2 id='KSoftImpute'>KNN-based imputation</h2><span id='topic+KSoftImpute'></span>

<h3>Description</h3>

<p><code>KSoftImpute</code> is an ultra-fast method for imputing missing gene expression values in single cell data.
<code>KSoftImpute</code> uses k-nearest neighbors to impute the expression of each gene by the weighted average of itself
and it's first-degree neighbors. Weights for imputation are determined by the number of detected genes. This method
works for large data sets (&gt;100,000 cells) in under a minute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KSoftImpute(E, dM = NULL, genes.to.use = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KSoftImpute_+3A_e">E</code></td>
<td>
<p>A gene-by-sample count matrix (sparse matrix or matrix) with genes identified by their HUGO symbols.</p>
</td></tr>
<tr><td><code id="KSoftImpute_+3A_dm">dM</code></td>
<td>
<p>see ?CID.GetDistMat</p>
</td></tr>
<tr><td><code id="KSoftImpute_+3A_genes.to.use">genes.to.use</code></td>
<td>
<p>a character vector of genes to impute. Default is NULL.</p>
</td></tr>
<tr><td><code id="KSoftImpute_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, code reports outputs. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An expression matrix (sparse matrix) with imputed values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Signac">Signac</a></code> and <code><a href="#topic+SignacFast">SignacFast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# download single cell data for classification
file.dir = "https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/"
file = "pbmc_1k_v3_filtered_feature_bc_matrix.h5"
download.file(paste0(file.dir, file), "Ex.h5")

# load data, process with Seurat
library(Seurat)
E = Read10X_h5(filename = "Ex.h5")
pbmc &lt;- CreateSeuratObject(counts = E, project = "pbmc")

# run Seurat pipeline
pbmc &lt;- SCTransform(pbmc, verbose = FALSE)
pbmc &lt;- RunPCA(pbmc, verbose = FALSE)
pbmc &lt;- RunUMAP(pbmc, dims = 1:30, verbose = FALSE)
pbmc &lt;- FindNeighbors(pbmc, dims = 1:30, verbose = FALSE)

# get edges from default assay from Seurat object
default.assay &lt;- Seurat::DefaultAssay(pbmc)
edges = pbmc@graphs[[which(grepl(paste0(default.assay, "_nn"), names(pbmc@graphs)))]]

# get distance matrix
dM = CID.GetDistMat(edges)

# run imputation
Z = KSoftImpute(E = E, dM = dM, verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='MASC'>Mixed effect modeling</h2><span id='topic+MASC'></span>

<h3>Description</h3>

<p><code><a href="#topic+MASC">MASC</a></code> was imported from <a href="https://github.com/immunogenomics/masc">https://github.com/immunogenomics/masc</a>.
Performs mixed-effect modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MASC(
  dataset,
  cluster,
  contrast,
  random_effects = NULL,
  fixed_effects = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MASC_+3A_dataset">dataset</code></td>
<td>
<p>data frame of covariate, cell type, clustering or disease information</p>
</td></tr>
<tr><td><code id="MASC_+3A_cluster">cluster</code></td>
<td>
<p>celltypes returned by Signac or cluster identities</p>
</td></tr>
<tr><td><code id="MASC_+3A_contrast">contrast</code></td>
<td>
<p>Typically disease</p>
</td></tr>
<tr><td><code id="MASC_+3A_random_effects">random_effects</code></td>
<td>
<p>User specified random effect variables in dataset</p>
</td></tr>
<tr><td><code id="MASC_+3A_fixed_effects">fixed_effects</code></td>
<td>
<p>User specific fixed effects in dataset</p>
</td></tr>
<tr><td><code id="MASC_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, algorithm reports outputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mixed effect model results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load metadata
file.dir = "https://kleintools.hms.harvard.edu/tools/client_datasets/"
file = "AMP_Phase1_SLE_Apr2019/FullDataset_v1/categorical_coloring_data.json"
download.file(paste0(file.dir, file, "?raw=true"), destfile = "categorical_coloring_data.json")
d = rjson::fromJSON(file='categorical_coloring_data.json')
d = data.frame(sapply(d, function(x) x$label_list))

# run MASC
x = d$CellStates # optionally use clusters or cell types
d$Disease = factor(d$Disease) # the contrast term must be encoded as a factor
Q = MASC(d, cluster = x, contrast = 'Disease', random_effects = c( "Tissue", "Plate", "Sample"))

## End(Not run)
</code></pre>

<hr>
<h2 id='ModelGenerator'>Generates an ensemble of neural network models.</h2><span id='topic+ModelGenerator'></span>

<h3>Description</h3>

<p><code><a href="#topic+ModelGenerator">ModelGenerator</a></code> generates an ensemble of neural network models
each trained to classify cellular phenotypes using the reference data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ModelGenerator(
  R,
  N = 1,
  num.cores = 1,
  verbose = TRUE,
  hidden = 1,
  set.seed = TRUE,
  seed = "42"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ModelGenerator_+3A_r">R</code></td>
<td>
<p>Reference data set returned by <code><a href="#topic+GetTrainingData_HPCA">GetTrainingData_HPCA</a></code></p>
</td></tr>
<tr><td><code id="ModelGenerator_+3A_n">N</code></td>
<td>
<p>Number of neural networks to train. Default is 1.</p>
</td></tr>
<tr><td><code id="ModelGenerator_+3A_num.cores">num.cores</code></td>
<td>
<p>Number of cores to use for parallel computing. Default is 1.</p>
</td></tr>
<tr><td><code id="ModelGenerator_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, code will report outputs. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ModelGenerator_+3A_hidden">hidden</code></td>
<td>
<p>Number of hidden layers in the neural network. Default is 1.</p>
</td></tr>
<tr><td><code id="ModelGenerator_+3A_set.seed">set.seed</code></td>
<td>
<p>If TRUE, seed is set to ensure reproducibility of these results. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ModelGenerator_+3A_seed">seed</code></td>
<td>
<p>if set.seed is TRUE, the seed can be set. Default is 42.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, each containing N neural network models
</p>


<h3>See Also</h3>

<p>[SignacFast()] for a function that uses the models generated by this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# download training data set from GitHub
Ref = GetTrainingData_HPCA()

# train a stack of 1,800 neural network models
Models = ModelGenerator(R = Ref, N = 100, num.cores = 4)

# save models
save(Models, file = "models.rda")

## End(Not run)
</code></pre>

<hr>
<h2 id='SaveCountsToH5'>Save count_matrix.h5 files for SPRING integration</h2><span id='topic+SaveCountsToH5'></span>

<h3>Description</h3>

<p>To integrate with SPRING, <code>SaveCountsToH5</code> saves expression matrices
in a sparse &quot;.h5&quot; format to be read with SPRING notebooks in Jupyter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SaveCountsToH5(D, data.dir, genome = "GRCh38")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SaveCountsToH5_+3A_d">D</code></td>
<td>
<p>A list of count matrices</p>
</td></tr>
<tr><td><code id="SaveCountsToH5_+3A_data.dir">data.dir</code></td>
<td>
<p>directory (will be created if it does not exist) where results are saved</p>
</td></tr>
<tr><td><code id="SaveCountsToH5_+3A_genome">genome</code></td>
<td>
<p>default is GRCh38.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix.h5 file, where each is background corrected
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# download single cell data for classification
file.dir = "https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/"
file = "pbmc_1k_v3_filtered_feature_bc_matrix.h5"
download.file(paste0(file.dir, file), "Ex.h5")

# load data
library(Seurat)
E = Read10X_h5(filename = "Ex.h5")

# save counts to h5 files
SaveCountsToH5(E, data.dir = "counts_h5")


## End(Not run)
</code></pre>

<hr>
<h2 id='Signac'>Classification of cellular phenotypes in single cell data</h2><span id='topic+Signac'></span>

<h3>Description</h3>

<p><code>Signac</code> trains and then uses an ensemble of neural networks to classify cellular phenotypes using an expression matrix or Seurat object.
The neural networks are trained with the HPCA training data using only features that are present
in both the single cell and HPCA training data set. <code>Signac</code> returns annotations at each level of the classification
hierarchy, which are then converted into cell type labels using <code><a href="#topic+GenerateLabels">GenerateLabels</a></code>. For a faster alternative,
try <code><a href="#topic+SignacFast">SignacFast</a></code>, which uses pre-computed neural network models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Signac(
  E,
  R = "default",
  spring.dir = NULL,
  N = 100,
  num.cores = 1,
  threshold = 0,
  smooth = TRUE,
  impute = TRUE,
  verbose = TRUE,
  do.normalize = TRUE,
  return.probability = FALSE,
  hidden = 1,
  set.seed = TRUE,
  seed = "42",
  graph.used = "nn"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Signac_+3A_e">E</code></td>
<td>
<p>a sparse gene (rows) by cell (column) matrix, or a Seurat object. Rows are HUGO symbols.</p>
</td></tr>
<tr><td><code id="Signac_+3A_r">R</code></td>
<td>
<p>Reference data. If 'default', R is set to GetTrainingData_HPCA().</p>
</td></tr>
<tr><td><code id="Signac_+3A_spring.dir">spring.dir</code></td>
<td>
<p>If using SPRING, directory to categorical_coloring_data.json. Default is NULL.</p>
</td></tr>
<tr><td><code id="Signac_+3A_n">N</code></td>
<td>
<p>Number of machine learning models to train (for nn and svm). Default is 100.</p>
</td></tr>
<tr><td><code id="Signac_+3A_num.cores">num.cores</code></td>
<td>
<p>Number of cores to use. Default is 1.</p>
</td></tr>
<tr><td><code id="Signac_+3A_threshold">threshold</code></td>
<td>
<p>Probability threshold for assigning cells to &quot;Unclassified.&quot; Default is 0.</p>
</td></tr>
<tr><td><code id="Signac_+3A_smooth">smooth</code></td>
<td>
<p>if TRUE, smooths the cell type classifications. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Signac_+3A_impute">impute</code></td>
<td>
<p>if TRUE, gene expression values are imputed prior to cell type classification (see <code><a href="#topic+KSoftImpute">KSoftImpute</a></code>). Default is TRUE.</p>
</td></tr>
<tr><td><code id="Signac_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, code will report outputs. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Signac_+3A_do.normalize">do.normalize</code></td>
<td>
<p>if TRUE, cells are normalized to the mean library size. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Signac_+3A_return.probability">return.probability</code></td>
<td>
<p>if TRUE, returns the probability associated with each cell type label. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Signac_+3A_hidden">hidden</code></td>
<td>
<p>Number of hidden layers in the neural network. Default is 1.</p>
</td></tr>
<tr><td><code id="Signac_+3A_set.seed">set.seed</code></td>
<td>
<p>If true, seed is set to ensure reproducibility of these results. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Signac_+3A_seed">seed</code></td>
<td>
<p>if set.seed is TRUE, seed is set to 42.</p>
</td></tr>
<tr><td><code id="Signac_+3A_graph.used">graph.used</code></td>
<td>
<p>If using Seurat object by default, Signac uses the nearest neighbor graph in the graphs field of the Seurat object. Other options are &quot;wnn&quot; to use weighted nearest neighbors, as well as &quot;snn&quot; to use shared nearest neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors: cell type annotations (L1, L2, ...) at each level of the hierarchy
as well as 'clusters' for the Louvain clustering results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SignacFast">SignacFast</a></code>, a faster alternative that only differs from <code><a href="#topic+Signac">Signac</a></code> in nuanced T cell phenotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# download single cell data for classification
file.dir = "https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/"
file = "pbmc_1k_v3_filtered_feature_bc_matrix.h5"
download.file(paste0(file.dir, file), "Ex.h5")

# load data, process with Seurat
library(Seurat)
E = Read10X_h5(filename = "Ex.h5")
pbmc &lt;- CreateSeuratObject(counts = E, project = "pbmc")

# run Seurat pipeline
pbmc &lt;- SCTransform(pbmc, verbose = FALSE)
pbmc &lt;- RunPCA(pbmc, verbose = FALSE)
pbmc &lt;- RunUMAP(pbmc, dims = 1:30, verbose = FALSE)
pbmc &lt;- FindNeighbors(pbmc, dims = 1:30, verbose = FALSE)

# classify cells
labels = Signac(E = pbmc)
celltypes = GenerateLabels(labels, E = pbmc)

# add labels to Seurat object, visualize
pbmc &lt;- Seurat::AddMetaData(pbmc, metadata=celltypes$CellTypes_novel, col.name = "immmune")
pbmc &lt;- Seurat::SetIdent(pbmc, value='immmune')
DimPlot(pbmc)

# save results
saveRDS(pbmc, "example_pbmcs.rds")

## End(Not run)
</code></pre>

<hr>
<h2 id='SignacBoot'>Generates bootstrapped single cell data</h2><span id='topic+SignacBoot'></span>

<h3>Description</h3>

<p><code>SignacBoot</code> uses a Seurat object or an expression matrix and performs feature selection, normalization and bootstrapping
to generate a training data set to be used for cell type or cluster classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SignacBoot(
  E,
  L,
  labels,
  size = 1000,
  impute = TRUE,
  spring.dir = NULL,
  logfc.threshold = 0.25,
  p.val.adj = 0.05,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SignacBoot_+3A_e">E</code></td>
<td>
<p>a gene (rows) by cell (column) matrix, sparse matrix or a Seurat object. Rows are HUGO symbols.</p>
</td></tr>
<tr><td><code id="SignacBoot_+3A_l">L</code></td>
<td>
<p>cell type categories for learning.</p>
</td></tr>
<tr><td><code id="SignacBoot_+3A_labels">labels</code></td>
<td>
<p>cell type labels corresponding to the columns of E.</p>
</td></tr>
<tr><td><code id="SignacBoot_+3A_size">size</code></td>
<td>
<p>Number of bootstrapped samples for machine learning. Default is 1,000.</p>
</td></tr>
<tr><td><code id="SignacBoot_+3A_impute">impute</code></td>
<td>
<p>if TRUE, performs imputation prior to bootstrapping (see <code><a href="#topic+KSoftImpute">KSoftImpute</a></code>). Default is TRUE.</p>
</td></tr>
<tr><td><code id="SignacBoot_+3A_spring.dir">spring.dir</code></td>
<td>
<p>if using SPRING, directory to categorical_coloring_data.json. Default is NULL.</p>
</td></tr>
<tr><td><code id="SignacBoot_+3A_logfc.threshold">logfc.threshold</code></td>
<td>
<p>Cutoff for feature selection. Default is 0.25.</p>
</td></tr>
<tr><td><code id="SignacBoot_+3A_p.val.adj">p.val.adj</code></td>
<td>
<p>Cutoff for feature selection. Default is 0.05.</p>
</td></tr>
<tr><td><code id="SignacBoot_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, code speaks. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Training data set (data.frame) to be used for building new models=.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelGenerator">ModelGenerator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load Seurat object from SignacFast example
P &lt;- readRDS("pbmcs.rds")

# run feature selection + bootstrapping to generate 2,000 bootstrapped cells
x = P@meta.data$celltypes
R_learned = SignacBoot(P, L = c("B.naive", "B.memory"), labels = x)

## End(Not run)
</code></pre>

<hr>
<h2 id='SignacFast'>Fast classification of cellular phenotypes</h2><span id='topic+SignacFast'></span>

<h3>Description</h3>

<p><code>SignacFast</code> uses pre-computed neural network models to classify cellular phenotypes in single cell data:
these models were pre-trained with the HPCA training data. Any features that are
present in the training data and absent in the single cell data are set to zero. 
This is a factor of ~5-10 speed improvement over <code><a href="#topic+Signac">Signac</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SignacFast(
  E,
  Models = "default",
  spring.dir = NULL,
  num.cores = 1,
  threshold = 0,
  smooth = TRUE,
  impute = TRUE,
  verbose = TRUE,
  do.normalize = TRUE,
  return.probability = FALSE,
  graph.used = "nn"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SignacFast_+3A_e">E</code></td>
<td>
<p>a gene (rows) by cell (column) matrix, sparse matrix or a Seurat object. Rows are HUGO symbols.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_models">Models</code></td>
<td>
<p>if 'default', as returned by <code><a href="#topic+GetModels_HPCA">GetModels_HPCA</a></code>. An ensemble of 1,800 neural network models.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_spring.dir">spring.dir</code></td>
<td>
<p>If using SPRING, directory to categorical_coloring_data.json. Default is NULL.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_num.cores">num.cores</code></td>
<td>
<p>number of cores to use for parallel computation. Default is 1.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_threshold">threshold</code></td>
<td>
<p>Probability threshold for assigning cells to &quot;Unclassified.&quot; Default is 0.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_smooth">smooth</code></td>
<td>
<p>if TRUE, smooths the cell type classifications. Default is TRUE.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_impute">impute</code></td>
<td>
<p>if TRUE, gene expression values are imputed prior to cell type classification (see <code><a href="#topic+KSoftImpute">KSoftImpute</a></code>). Default is TRUE.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE, code will report outputs. Default is TRUE.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_do.normalize">do.normalize</code></td>
<td>
<p>if TRUE, cells are normalized to the mean library size. Default is TRUE.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_return.probability">return.probability</code></td>
<td>
<p>if TRUE, returns the probability associated with each cell type label. Default is TRUE.</p>
</td></tr>
<tr><td><code id="SignacFast_+3A_graph.used">graph.used</code></td>
<td>
<p>If using Seurat object by default, Signac uses the nearest neighbor graph in the graphs field of the Seurat object. Other options are &quot;wnn&quot; to use weighted nearest neighbors, as well as &quot;snn&quot; to use shared nearest neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors: cell type annotations (L1, L2, ...) at each level of the hierarchy
as well as 'clusters' for the Louvain clustering results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Signac">Signac</a></code> for another classification function.
</p>
<p><code><a href="#topic+Signac">Signac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# download single cell data for classification
file.dir = "https://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_1k_v3/"
file = "pbmc_1k_v3_filtered_feature_bc_matrix.h5"
download.file(paste0(file.dir, file), "Ex.h5")

# load data, process with Seurat
library(Seurat)
E = Read10X_h5(filename = "Ex.h5")
pbmc &lt;- CreateSeuratObject(counts = E, project = "pbmc")
pbmc &lt;- SCTransform(pbmc)
pbmc &lt;- RunPCA(pbmc, verbose = FALSE)
pbmc &lt;- RunUMAP(pbmc, dims = 1:30, verbose = FALSE)
pbmc &lt;- FindNeighbors(pbmc, dims = 1:30, verbose = FALSE)

# classify cells
labels = SignacFast(E = pbmc)
celltypes = GenerateLabels(labels, E = pbmc)

# add labels to Seurat object, visualize
lbls &lt;- factor(celltypes$CellStates)
levels(lbls) &lt;- sort(unique(lbls))
pbmc &lt;- AddMetaData(pbmc, metadata=celltypes$CellStates, col.name = "celltypes")
pbmc &lt;- SetIdent(pbmc, value='celltypes')
DimPlot(pbmc, label = T)

# save results
saveRDS(pbmc, "pbmcs.rds")
saveRDS(celltypes, "celltypes.rds")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
