<!DOCTYPE html><html lang="en"><head><title>Help for package scdensity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scdensity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#scdensity-package'><p>scdensity: Shape-constrained kernel density estimation.</p></a></li>
<li><a href='#AddBinObjects'><p>A small function to add the objects needed for the binning QP to the problem list.</p></a></li>
<li><a href='#BinningStep'><p>Carry out the binning step.</p></a></li>
<li><a href='#BuildConCheckGrid'><p>A function to add the constraint-checking grid</p></a></li>
<li><a href='#BuildConstraints'><p>Build objects Apos, Aunit, Aeq, Ashape, bshape</p></a></li>
<li><a href='#CleanWeights'><p>Clean out near-zeros from a probability weights vector and re-normalize</p></a></li>
<li><a href='#ConvolutionMatrix'><p>Computes a matrix of Gaussian kernel convolution values given two vectors.</p></a></li>
<li><a href='#displayFailure'><p>Display estimation results to console in an unsuccessful case.</p></a></li>
<li><a href='#displaySuccess'><p>Display estimation results to console in a successful case.</p></a></li>
<li><a href='#EstimationStep'><p>Carry out the shape-constrained estimation</p></a></li>
<li><a href='#getQuantile'><p>Estimate a specific quantile of a pdf given abscissa and ordinate values.</p></a></li>
<li><a href='#getQuantileFunction'><p>Build a quantile function for a given constrained density estimator.</p></a></li>
<li><a href='#improve'><p>Move points closer to a target while maintaining a constraint.</p></a></li>
<li><a href='#InitializeP'><p>Initialize the list of problem-related objects.</p></a></li>
<li><a href='#isBoundedL'><p>Check for zeros at the left side of a vector of function values.</p></a></li>
<li><a href='#isBoundedR'><p>Check for zeros at the right side of a vector of function values.</p></a></li>
<li><a href='#isMonotoneL'><p>Check for monotonicity of function values in the left tail.</p></a></li>
<li><a href='#isMonotoneR'><p>Check for monotonicity of function values in the right tail.</p></a></li>
<li><a href='#isUnimodal'><p>Check for unimodality of function values.</p></a></li>
<li><a href='#MakeCenters'><p>Create a vector of kernel centers covering [LB, UB].</p></a></li>
<li><a href='#makeOF'><p>A function factory for making the search objective function.</p></a></li>
<li><a href='#NormalGridFcn'><p>Compute the values of n normal PDFs (or their derivatives at m grid points).</p></a></li>
<li><a href='#plot.scdensity'><p>Plot method for class <code>scdensity</code>.</p></a></li>
<li><a href='#print.scdensity'><p>Print method for class <code>scdensity</code>.</p></a></li>
<li><a href='#print.summary.scdensity'><p>Prints the information in a <code>summary.scdensity</code> object to the console.</p></a></li>
<li><a href='#QPsolve'><p>A wrapper to call solve.QP.</p></a></li>
<li><a href='#scdensity'><p>Shape-constrained kernel density estimation.</p></a></li>
<li><a href='#SequentialLineMin'><p>Minimize a function of r variables by sequential univariate searches.</p></a></li>
<li><a href='#SpectralShift'><p>Performs the spectral shift on a matrix to make it numerically positive definite.</p></a></li>
<li><a href='#summary.scdensity'><p>Summary method for class <code>scdensity</code>.</p></a></li>
<li><a href='#WeightedKDE'><p>Function to carry out the weighted or adjusted KDE optimization.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Shape-Constrained Kernel Density Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements methods for obtaining kernel density estimates
    subject to a variety of shape constraints (unimodality, bimodality, 
    symmetry, tail monotonicity, bounds, and constraints on the number of 
    inflection points). Enforcing constraints can eliminate unwanted waves or 
    kinks in the estimate, which improves its subjective appearance and can 
    also improve statistical performance. The main function scdensity() is 
    very similar to the density() function in 'stats', allowing 
    shape-restricted estimates to be obtained with little effort. The 
    methods implemented in this package are described in Wolters and Braun 
    (2017) &lt;<a href="https://doi.org/10.1080%2F03610918.2017.1288247">doi:10.1080/03610918.2017.1288247</a>&gt;, Wolters (2012) 
    &lt;<a href="https://doi.org/10.18637%2Fjss.v047.i06">doi:10.18637/jss.v047.i06</a>&gt;, and Hall and Huang (2002) 
    <a href="https://www3.stat.sinica.edu.tw/statistica/j12n4/j12n41/j12n41.htm">https://www3.stat.sinica.edu.tw/statistica/j12n4/j12n41/j12n41.htm</a>.
    See the scdensity() help for for full citations.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>quadprog, lpSolve</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-27 13:07:41 UTC; krams</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark A. Wolters <a href="https://orcid.org/0000-0001-7638-8222"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark A. Wolters &lt;mark@mwolters.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-27 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='scdensity-package'>scdensity: Shape-constrained kernel density estimation.</h2><span id='topic+scdensity-package'></span>

<h3>Description</h3>

<p>This package computes one-dimensional Gaussian kernel density estimates subject to a
variety of shape constraints, including unimodality, bimodality, symmetry, and others.
</p>


<h3>Details</h3>

<p>All of the package's functionality can be accessed through the function
<code><a href="#topic+scdensity">scdensity()</a></code>.  See that function's help file.  The function is used
just like <code><a href="stats.html#topic+density">stats::density()</a></code>, but with extra arguments for handling the constraints.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mark A. Wolters <a href="mailto:mark@mwolters.com">mark@mwolters.com</a> (<a href="https://orcid.org/0000-0001-7638-8222">ORCID</a>)
</p>

<hr>
<h2 id='AddBinObjects'>A small function to add the objects needed for the binning QP to the problem list.</h2><span id='topic+AddBinObjects'></span>

<h3>Description</h3>

<p>A small function to add the objects needed for the binning QP to the problem list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddBinObjects(P, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddBinObjects_+3A_p">P</code></td>
<td>
<p>A list with the problem details.</p>
</td></tr>
<tr><td><code id="AddBinObjects_+3A_s">s</code></td>
<td>
<p>A vector of centers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified problem list.
</p>

<hr>
<h2 id='BinningStep'>Carry out the binning step.</h2><span id='topic+BinningStep'></span>

<h3>Description</h3>

<p>Carry out the binning step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinningStep(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BinningStep_+3A_p">P</code></td>
<td>
<p>The list of problem objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input list, with extra members modified.
</p>

<hr>
<h2 id='BuildConCheckGrid'>A function to add the constraint-checking grid</h2><span id='topic+BuildConCheckGrid'></span>

<h3>Description</h3>

<p>A function to add the constraint-checking grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildConCheckGrid(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BuildConCheckGrid_+3A_p">P</code></td>
<td>
<p>List with problem details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modified list.
</p>

<hr>
<h2 id='BuildConstraints'>Build objects Apos, Aunit, Aeq, Ashape, bshape</h2><span id='topic+BuildConstraints'></span>

<h3>Description</h3>

<p>This function builds the matrices/vectors needed to implement shape constraints in the
estimation step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BuildConstraints(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BuildConstraints_+3A_p">P</code></td>
<td>
<p>A list of problem obejcts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same list, with Apos, Aunit, Aeq, Ashape, bshape filled in.
</p>

<hr>
<h2 id='CleanWeights'>Clean out near-zeros from a probability weights vector and re-normalize</h2><span id='topic+CleanWeights'></span>

<h3>Description</h3>

<p>Clean out near-zeros from a probability weights vector and re-normalize
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CleanWeights(w)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CleanWeights_+3A_w">w</code></td>
<td>
<p>A vector of probability weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the near-zeros removed, still summing to 1.
</p>

<hr>
<h2 id='ConvolutionMatrix'>Computes a matrix of Gaussian kernel convolution values given two vectors.</h2><span id='topic+ConvolutionMatrix'></span>

<h3>Description</h3>

<p>If <code>x</code> and <code>s</code> are n- and m-vectors, respectively, returns the n-by-m matrix
of convolution values using Gaussian kernel with bandwidth <code>h</code>.  If <code>x</code> and
<code>s</code> are equal, the spectral shift is done to ensure the matrix is numerically
positive definite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvolutionMatrix(x, s, h, threshold = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConvolutionMatrix_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="ConvolutionMatrix_+3A_s">s</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="ConvolutionMatrix_+3A_h">h</code></td>
<td>
<p>A positive bandwidth.</p>
</td></tr>
<tr><td><code id="ConvolutionMatrix_+3A_threshold">threshold</code></td>
<td>
<p>Threshold value passed to SpectralShift.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of convolution values.
</p>

<hr>
<h2 id='displayFailure'>Display estimation results to console in an unsuccessful case.</h2><span id='topic+displayFailure'></span>

<h3>Description</h3>

<p>Display estimation results to console in an unsuccessful case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayFailure(pts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="displayFailure_+3A_pts">pts</code></td>
<td>
<p>The important points.</p>
</td></tr>
</table>

<hr>
<h2 id='displaySuccess'>Display estimation results to console in a successful case.</h2><span id='topic+displaySuccess'></span>

<h3>Description</h3>

<p>Display estimation results to console in a successful case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displaySuccess(pts, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="displaySuccess_+3A_pts">pts</code></td>
<td>
<p>The important points.</p>
</td></tr>
<tr><td><code id="displaySuccess_+3A_value">value</code></td>
<td>
<p>The objective function value.</p>
</td></tr>
</table>

<hr>
<h2 id='EstimationStep'>Carry out the shape-constrained estimation</h2><span id='topic+EstimationStep'></span>

<h3>Description</h3>

<p>Carry out the shape-constrained estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimationStep(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EstimationStep_+3A_p">P</code></td>
<td>
<p>The problem list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Problem list with estimate objects.
</p>

<hr>
<h2 id='getQuantile'>Estimate a specific quantile of a pdf given abscissa and ordinate values.</h2><span id='topic+getQuantile'></span>

<h3>Description</h3>

<p>Estimate a specific quantile of a pdf given abscissa and ordinate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQuantile(x, y, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getQuantile_+3A_x">x</code></td>
<td>
<p>The abscissa values of the pdf</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_y">y</code></td>
<td>
<p>The ordinate values of the pdf</p>
</td></tr>
<tr><td><code id="getQuantile_+3A_p">p</code></td>
<td>
<p>The probability at which to evaluate the quantile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated quantile.
</p>

<hr>
<h2 id='getQuantileFunction'>Build a quantile function for a given constrained density estimator.</h2><span id='topic+getQuantileFunction'></span>

<h3>Description</h3>

<p>This function implements a crude but numerically reliable method to approximate the
quantile function of an <code>scdensity</code> estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getQuantileFunction(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getQuantileFunction_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>scdensity</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that takes a fraction and returns the quantile.
</p>

<hr>
<h2 id='improve'>Move points closer to a target while maintaining a constraint.</h2><span id='topic+improve'></span>

<h3>Description</h3>

<p><code>improve(startValue, x, confun)</code> uses a greedy algorithm to move the elements of a
user-supplied vector <code>startValue</code> closer to their target values <code>x</code>, while
continually satisfying the constraint-checking function <code>confun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improve(
  startValue,
  x,
  confun,
  verbose = FALSE,
  maxpasses = 500,
  tol = diff(range(c(startValue, x))/1e+05)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="improve_+3A_startvalue">startValue</code></td>
<td>
<p>The vector of starting values for the search.  Must satisfy
<code>confun(startValue) == TRUE</code></p>
</td></tr>
<tr><td><code id="improve_+3A_x">x</code></td>
<td>
<p>The target values.</p>
</td></tr>
<tr><td><code id="improve_+3A_confun">confun</code></td>
<td>
<p>The constraint-checking function. <code>confun(y)</code> must return a Boolean value
that is invariant to permutations of its vector argument <code>y</code>.</p>
</td></tr>
<tr><td><code id="improve_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether or not information about iteration progress
should be printed to the console.</p>
</td></tr>
<tr><td><code id="improve_+3A_maxpasses">maxpasses</code></td>
<td>
<p>The maximum allowable number of sweeps through the data points.  At each pass,
every point that is not pinned at the constraint boundary is moved toward its target point in a
stepping-out procedure.</p>
</td></tr>
<tr><td><code id="improve_+3A_tol">tol</code></td>
<td>
<p>Numerical tolerance for constraint checking.  A point is considered to be at the
constraint boundary if adding <code>tol</code> to it causes the constraint to be violated. If <code>tol</code>
is too large, the algorithm will terminate prematurely.  If it is too small, run time will be
increased with no discernible benefit in the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm implemented here is the one in Wolters (2012), &quot;A Greedy Algorithm for Unimodal
Kernel Density Estimation by Data Sharpening,&quot; <em>Journal of Statistical Software</em>, 47(6).
It could conceivably be useful as a part of other gradient-free optimization schemes where
we have an infeasible point and a feasible one, and we seek a point that is on
the constraint boundary near the infeasible one.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>startValue</code>, with elements closer to <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Constrain points to be inside the hypercube with vertices at -1 and +1.
#The target point is a vector of independent random standard normal variates.
#Start at rep(0,n) and "improve" the solution toward the target.
n &lt;- 20
incube &lt;- function(x) all(x &lt;= 1 &amp; x &gt;= -1)
x0 &lt;- rep(0,n)
target &lt;- sort(rnorm(n))
xstar &lt;- improve(x0, target, incube, verbose=TRUE)
dist &lt;- abs(target - xstar)
zapsmall(cbind(target, xstar, dist), 4)
</code></pre>

<hr>
<h2 id='InitializeP'>Initialize the list of problem-related objects.</h2><span id='topic+InitializeP'></span>

<h3>Description</h3>

<p>Initialize the list of problem-related objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InitializeP(x, h, constraints, method, opts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="InitializeP_+3A_x">x</code></td>
<td>
<p>The data vector.</p>
</td></tr>
<tr><td><code id="InitializeP_+3A_h">h</code></td>
<td>
<p>The bandwidth (a positive scalar).</p>
</td></tr>
<tr><td><code id="InitializeP_+3A_constraints">constraints</code></td>
<td>
<p>The vector of constraint strings.</p>
</td></tr>
<tr><td><code id="InitializeP_+3A_method">method</code></td>
<td>
<p>Either &quot;weightedKDE&quot; or &quot;adjustedKDE&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list in the form needed by WeightedKDE(), with additional elements initialized
to their default values.
</p>

<hr>
<h2 id='isBoundedL'>Check for zeros at the left side of a vector of function values.</h2><span id='topic+isBoundedL'></span>

<h3>Description</h3>

<p>Given a vector of n function values and an index ix, check whether values 1:ix are zero.
Returns TRUE if they are, FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isBoundedL(f, ix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isBoundedL_+3A_f">f</code></td>
<td>
<p>A vector of function values for increasing abscissa values.</p>
</td></tr>
<tr><td><code id="isBoundedL_+3A_ix">ix</code></td>
<td>
<p>An index giving the cutoff for checking for zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As in <code>isUnimodal</code>, the values are first scaled to fill [0, 1] and then rounded to
four decimal places.  Because of this it is still possible to use the &quot;bounded support&quot;
constraints with the Gaussian kernel.
</p>
<p>This function is intended to be called from other functions in the scdensity package.
It does not implement any argument checking.
</p>


<h3>Value</h3>

<p>A logical value indicating if the constraint is satisfied.
</p>

<hr>
<h2 id='isBoundedR'>Check for zeros at the right side of a vector of function values.</h2><span id='topic+isBoundedR'></span>

<h3>Description</h3>

<p>Given a vector of n function values and an index ix, check whether values with indices
greater than or equal to ix are zero. Returns TRUE if they are, FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isBoundedR(f, ix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isBoundedR_+3A_f">f</code></td>
<td>
<p>A vector of function values for increasing abscissa values.</p>
</td></tr>
<tr><td><code id="isBoundedR_+3A_ix">ix</code></td>
<td>
<p>An index giving the cutoff for checking for zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As in <code>isUnimodal</code>, the values are first scaled to fill [0, 1] and then rounded to
four decimal places.  Because of this it is still possible to use the &quot;bounded support&quot;
constraints with the Gaussian kernel.
</p>
<p>This function is intended to be called from other functions in the scdensity package.
It does not implement any argument checking.
</p>


<h3>Value</h3>

<p>A logical value indicating if the constraint is satisfied.
</p>

<hr>
<h2 id='isMonotoneL'>Check for monotonicity of function values in the left tail.</h2><span id='topic+isMonotoneL'></span>

<h3>Description</h3>

<p>Given a vector of n function values and an index ix, determines whether the function
values having indices less than or equal to ix are non-decreasing or non-increasing.
Returns TRUE if they are, FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isMonotoneL(f, ix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isMonotoneL_+3A_f">f</code></td>
<td>
<p>A vector of function values for increasing abscissa values.</p>
</td></tr>
<tr><td><code id="isMonotoneL_+3A_ix">ix</code></td>
<td>
<p>An index giving the cutoff for checking monotonicity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As in <code>isUnimodal</code>, the values are first scaled to fill [0, 1] and then rounded to
four decimal places.  This eliminates unwanted detection of tiny differences as modes.
</p>
<p>This function is intended to be called from other functions in the scdensity package.
It does not implement any argument checking.
</p>


<h3>Value</h3>

<p>A logical value indicating if the constraint is satisfied.
</p>

<hr>
<h2 id='isMonotoneR'>Check for monotonicity of function values in the right tail.</h2><span id='topic+isMonotoneR'></span>

<h3>Description</h3>

<p>Given a vector of n function values and an index ix, determines whether the function
values having indices greater than or equal to ix are non-decreasing or non-increasing.
Returns TRUE if they are, FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isMonotoneR(f, ix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isMonotoneR_+3A_f">f</code></td>
<td>
<p>A vector of function values for increasing abscissa values.</p>
</td></tr>
<tr><td><code id="isMonotoneR_+3A_ix">ix</code></td>
<td>
<p>An index giving the cutoff for checking monotonicity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As in <code>isUnimodal</code>, the values are first scaled to fill [0, 1] and then rounded to
four decimal places.  This eliminates unwanted detection of tiny differences as modes.
</p>
<p>This function is intended to be called from other functions in the scdensity package.
It does not implement any argument checking.
</p>


<h3>Value</h3>

<p>A logical value indicating if the constraint is satisfied.
</p>

<hr>
<h2 id='isUnimodal'>Check for unimodality of function values.</h2><span id='topic+isUnimodal'></span>

<h3>Description</h3>

<p>Given a set of function values for increasing abscissa values, we call this unimodal if
there are zero or one values that are greater than all of their neighbors. Before
checking for modes, the values are scaled to fill [0, 1] and then rounded to four
decimal places.  This eliminates unwanted detection of tiny differences as modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isUnimodal(f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isUnimodal_+3A_f">f</code></td>
<td>
<p>A vector of function values for increasing abscissa values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be called from other functions in the scdensity package.
It does not implement any argument checking.
</p>


<h3>Value</h3>

<p>A logical value indicating if unimodality is satisfied.
</p>

<hr>
<h2 id='MakeCenters'>Create a vector of kernel centers covering [LB, UB].</h2><span id='topic+MakeCenters'></span>

<h3>Description</h3>

<p>Make the spacing as large as possible without going over <code>width</code>.
If symmetric, ensure we have an even number of centers that are symmetric around <code>PoS</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeCenters(LB, UB, width, minspace, PoS = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MakeCenters_+3A_lb">LB</code></td>
<td>
<p>The lower bound.</p>
</td></tr>
<tr><td><code id="MakeCenters_+3A_ub">UB</code></td>
<td>
<p>The upper bound.</p>
</td></tr>
<tr><td><code id="MakeCenters_+3A_width">width</code></td>
<td>
<p>The maximum possible spacing.</p>
</td></tr>
<tr><td><code id="MakeCenters_+3A_minspace">minspace</code></td>
<td>
<p>The minimum allowable spacing.</p>
</td></tr>
<tr><td><code id="MakeCenters_+3A_pos">PoS</code></td>
<td>
<p>Point of symmetry (default NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of kernel centers.
</p>

<hr>
<h2 id='makeOF'>A function factory for making the search objective function.</h2><span id='topic+makeOF'></span>

<h3>Description</h3>

<p>Used when we need to search for important points.
P is the problem list. It should have already gone through BuildConCheckGrid and
BinningStep. The returned function must return a value even if WeightedKDE() fails.
In case of failure, just assign a large random value to the objective value (to keep
the search from stagnating or moving systematically in one direction).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeOF(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeOF_+3A_p">P</code></td>
<td>
<p>The list of problem details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The objective function.
</p>

<hr>
<h2 id='NormalGridFcn'>Compute the values of n normal PDFs (or their derivatives at m grid points).</h2><span id='topic+NormalGridFcn'></span>

<h3>Description</h3>

<p>Grid points are specified in g. Returns an m-by-n matrix.  The (i,j)th element of
the matrix is the rth derivative of N(mu(j),sd(j)) at g(i).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NormalGridFcn(g, r, mu, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NormalGridFcn_+3A_g">g</code></td>
<td>
<p>Locations at which to evaluate the normal densities.</p>
</td></tr>
<tr><td><code id="NormalGridFcn_+3A_r">r</code></td>
<td>
<p>Derivative degree of the densities to evaluate (0, 1, 2, or 3).</p>
</td></tr>
<tr><td><code id="NormalGridFcn_+3A_mu">mu</code></td>
<td>
<p>Means/locations for the normal densities.</p>
</td></tr>
<tr><td><code id="NormalGridFcn_+3A_sd">sd</code></td>
<td>
<p>Standard deviations of the normal densities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An m-by-n matrix as described above.
</p>

<hr>
<h2 id='plot.scdensity'>Plot method for class <code>scdensity</code>.</h2><span id='topic+plot.scdensity'></span>

<h3>Description</h3>

<p>Creates a plot of a shape-constrained kernel density estimate.  The amount of information
in the plot is controlled by <code>detail</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdensity'
plot(
  x,
  detail = 4,
  main = c("Density Estimate", "Q-Q Plot"),
  xlab = c(x$data.name, "Constrained KDE Quantiles"),
  ylab = c("Density", "Sample Quantiles"),
  type = c("l", "l", "p"),
  lty = c(1, 2, 0),
  pch = c(-1, -1, 1),
  col = c("black", gray(0.4), "black"),
  lwd = c(2, 1, 0),
  zero.line = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.scdensity_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>scdensity</code>.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_detail">detail</code></td>
<td>
<p>An integer from 1 to 4, indicating the level of information to include in
the plot.  1: plot only the constrained estimate.  2: draw both the constrained and
unconstrained estimates on the same plot.  3: add a rug showing the data points.
4: additionally plot a Q-Q plot of the observed data versus the constrained estimate in a
second panel (for qualitative assessment of goodness-of-fit).</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_main">main</code></td>
<td>
<p>A string passed on to the <code>main</code> argument of the plot command. If
<code>detail == 4</code>, pass a vector of two strings to specify titles for both subfigures.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_xlab">xlab</code></td>
<td>
<p>A string passed on to the <code>xlab</code> argument of the plot command. If
<code>detail == 4</code>, pass a vector of two strings to specify x labels for both subfigures.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_ylab">ylab</code></td>
<td>
<p>A string passed on to the <code>ylab</code> argument of the plot command. If
<code>detail == 4</code>, pass a vector of two strings to specify y labels for both subfigures.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_type">type</code></td>
<td>
<p>A vector of up to 3 strings specifying the <code>type</code> of plot used for 1)
the constrained estimate, 2) the unconstrained estimate, and 3) the Q-Q plot.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_lty">lty</code></td>
<td>
<p>A vector of up to length 3, specifying the <code>lty</code> arguments passed to the
plot commands for 1) the constrained estimate, 2) the unconstrained estimate, and 3)
the Q-Q plot. See the description of <code>lty</code> in <code><a href="graphics.html#topic+par">graphics::par()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_pch">pch</code></td>
<td>
<p>A vector of up to 3 integers specifying the <code>pch</code> argument passed to the
plot commands for 1) the constrained estimate, 2) the unconstrained estimate, and 3)
the Q-Q plot.  See <code><a href="graphics.html#topic+points">graphics::points()</a></code> for the integer codes.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_col">col</code></td>
<td>
<p>A vector of up to 3 strings specifying the <code>col</code> argument passed to the
plot commands for 1) the constrained estimate, 2) the unconstrained estimate, and 3)
the Q-Q plot.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_lwd">lwd</code></td>
<td>
<p>A vector of up to length 3 specifying the <code>lwd</code> argument passed to the
plot commands for 1) the constrained estimate, 2) the unconstrained estimate, and 3)
the Q-Q plot.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_zero.line">zero.line</code></td>
<td>
<p>A logical value indicating whether or not a horizontal line should be
drawn through zero to aid visualization.</p>
</td></tr>
<tr><td><code id="plot.scdensity_+3A_...">...</code></td>
<td>
<p>Extra parameters passed to the initial <code>plot</code> command for each subfigure.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Basic usage:
x &lt;- rlnorm(30)
scKDE &lt;- scdensity(x)
plot(scKDE)

# Show only the constrained estimate
plot(scKDE, detail=1)

# Show the constrained and unconstrained estimates.  Change line color and width.
plot(scKDE, detail=2, col=c("red","blue"), lwd=c(3,2))

# Show the Q-Q plot, but change that plot's symbol and its size.
plot(scKDE, detail=4, pch=c(-1, -1, 3), cex=0.5)
</code></pre>

<hr>
<h2 id='print.scdensity'>Print method for class <code>scdensity</code>.</h2><span id='topic+print.scdensity'></span>

<h3>Description</h3>

<p>Displays the names of the elements of the scdensity list object
and their sizes and types. Includes minimal comments about the most important elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdensity'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.scdensity_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>scensity</code>.</p>
</td></tr>
<tr><td><code id="print.scdensity_+3A_...">...</code></td>
<td>
<p>Included for consistency with generic functions.</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.scdensity'>Prints the information in a <code>summary.scdensity</code> object to the console.</h2><span id='topic+print.summary.scdensity'></span>

<h3>Description</h3>

<p>Prints the information in a <code>summary.scdensity</code> object to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.scdensity'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.scdensity_+3A_x">x</code></td>
<td>
<p>An object of S3 class <code>summary.scdensity</code>.</p>
</td></tr>
<tr><td><code id="print.summary.scdensity_+3A_...">...</code></td>
<td>
<p>Included for consistency with generic functions.</p>
</td></tr>
</table>

<hr>
<h2 id='QPsolve'>A wrapper to call solve.QP.</h2><span id='topic+QPsolve'></span>

<h3>Description</h3>

<p>This function takes arguments slightly differently from solve.QP, to make it more
convenient for internal use.  It also implements measures to robustify calls to solve.QP:
</p>

<ul>
<li><p> A rounding hack to prevent a bug in solve.QP that occasionally produces all-NaN
solutions without returning a warning or error.  Rounding has been found to eliminate
<em>almost</em> all such bugs.
</p>
</li>
<li><p> A call to lpSolve's lp() to check feasibility before running solve.QP
</p>
</li>
<li><p> solve.QP is called within tryCatch to eliminate unwanted crashes.
</p>
</li></ul>

<p>The output of this function is a list with elements
</p>

<ul>
<li> <p><code>flag</code> is 0 for successful completion, 1 for failure at the LP check stage,
and 2 for failure at the QP stage (usually the &quot;NaN solution&quot; bug).
</p>
</li>
<li> <p><code>QP</code> is the list returned by <code>solve.QP</code>.  If the QP was not run due to
infeasibility, this element is NULL.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>QPsolve(D, d, A, b, Aeq, beq)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QPsolve_+3A_d">D</code></td>
<td>
<p>The matrix of the quadratic objective.</p>
</td></tr>
<tr><td><code id="QPsolve_+3A_d">d</code></td>
<td>
<p>The vector in the linear term of the quadratic objective.</p>
</td></tr>
<tr><td><code id="QPsolve_+3A_a">A</code></td>
<td>
<p>The matrix of inequality constraints.</p>
</td></tr>
<tr><td><code id="QPsolve_+3A_b">b</code></td>
<td>
<p>The vector of RHS of the inequalities.</p>
</td></tr>
<tr><td><code id="QPsolve_+3A_aeq">Aeq</code></td>
<td>
<p>The matrix of equality constraints.</p>
</td></tr>
<tr><td><code id="QPsolve_+3A_beq">beq</code></td>
<td>
<p>The vector of RHS of the equalities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>solve.QP defines its quadratic program as minimizing 1/2 * x'Dx - x'd, subject to
constraints A'x &gt;= b.  Equality constraints have to be in the first rows of A'.
</p>
<p>This function minimizes x'Dx - x'd, subject to inequality constraints Ax &gt;= b and
Equality constraints Aeq*x = beq.
</p>


<h3>Value</h3>

<p>A list with elements described above.
</p>

<hr>
<h2 id='scdensity'>Shape-constrained kernel density estimation.</h2><span id='topic+scdensity'></span><span id='topic+density'></span>

<h3>Description</h3>

<p><code>scdensity</code> computes kernel density estimates that satisfy specified shape
restrictions. It is used in the same way as <code><a href="stats.html#topic+density">stats::density()</a></code>, and takes
most of that function's arguments. Its default behavior is to compute a unimodal estimate.
Use argument <code>constraint</code> to choose different shape constraints, <code>method</code> to
choose a different estimation method, and <code>opts</code> to specify method- and
constraint-specific options. The result is a list of S3 class <code>scdensity</code>, which
may be inspected via print, summary, and plot methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scdensity(
  x,
  bw = "nrd0",
  constraint = c("unimodal", "monotoneRightTail", "monotoneLeftTail", "twoInflections",
    "twoInflections+", "boundedLeft", "boundedRight", "symmetric", "bimodal"),
  method = c("adjustedKDE", "weightedKDE", "greedySharpenedKDE"),
  opts = NULL,
  adjust = 1,
  n = 512,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scdensity_+3A_x">x</code></td>
<td>
<p>A vector of data from which the estimate is to be computed.</p>
</td></tr>
<tr><td><code id="scdensity_+3A_bw">bw</code></td>
<td>
<p>The bandwidth.  It is specified as either a numerical value or as one of the
character strings <code>"nrd0"</code>,  <code>"nrd"</code>, <code>"ucv"</code>, <code>"bcv"</code>, or
<code>"SJ"</code>, exactly as in <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="scdensity_+3A_constraint">constraint</code></td>
<td>
<p>A vector of strings giving the operative shape constraints. Elements
must partially match different alternatives among <code>"unimodal"</code>,
<code>"monotoneRightTail"</code>,<code>"monotoneLeftTail"</code>, <code>"twoInflections"</code>,
<code>"twoInflections+"</code>, <code>"boundedLeft"</code>, <code>"boundedRight"</code>,
<code>"symmetric"</code>, and <code>"bimodal"</code>.</p>
</td></tr>
<tr><td><code id="scdensity_+3A_method">method</code></td>
<td>
<p>A string giving the method of enforcing shape constraints.  It must
paritally match one of <code>"adjustedKDE"</code>, <code>"weightedKDE"</code>, or
<code>"greedySharpenedKDE"</code>.</p>
</td></tr>
<tr><td><code id="scdensity_+3A_opts">opts</code></td>
<td>
<p>A list giving options specific to the chosen constraints and/or method. E.g.
use <code>opts = list(modeLocation = 0)</code> to force the mode to be at zero when the
constraint is <code>unimodal</code>. See below for lists of
available options.</p>
</td></tr>
<tr><td><code id="scdensity_+3A_adjust">adjust</code></td>
<td>
<p>A scaling factor for the bandwidth, just as in <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="scdensity_+3A_n">n</code></td>
<td>
<p>The number of points returned in the density estimate.  Same as in
<code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
<tr><td><code id="scdensity_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating whether or not to remove missing values from <code>x</code>.
Same as in <code><a href="stats.html#topic+density">stats::density()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All density estimates in this package use the Gaussian kernel.  It is the only common
kernel function with three continuous derivatives everywhere.  The <code>adjustedKDE</code> and
<code>weightedKDE</code> methods require continuous derivatives to ensure numerical stability.
</p>
<p>The default estimation method, <code>adjustedKDE</code>, can handle all of the available constraints.  The
<code>weightedKDE</code> method can handle every constraint except <code>symmetric</code>, while the
<code>greedySharpenedKDE</code> method can handle only <code>unimodal</code>, <code>monotoneRightTail</code>,
<code>monotoneLeftTail</code>, <code>boundedLeft</code>, and <code>boundedRight</code>. The <code>opts</code> list can
also be used to supply method-specific control parameters.  See the &quot;Method details&quot; section
for more.
</p>
<p>Each constraint has a corresponding control parameter that can be supplied as an element of
<code>opts</code>.  The control parameters are described in the following table.  See the &quot;Constraint
details&quot; section for definitions of each constraint.
</p>
<p><img src="../help/figures/ConstraintsTable.svg" width=650 alt="constraints Table" />

</p>
<p>More than one shape constraint can be specified simultaneously.  Certain combinations of constraints
(e.g., <code>unimodal</code> and <code>monotoneRightTail</code>) are redundant, and will cause a warning. Other
combinations (e.g., <code>unimodal</code> and <code>bimodal</code>) are incompatible and will cause an error.
The figure below summarizes the valid constraint combinations.
</p>
<p><img src="../help/figures/ConstraintCombos.svg" width=650 alt="valid constraint combinations" />

</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>constraint</code> The constraint(s) used for estimation.  Might differ from
the constraints supplied to the function if they included redundant constraints.
</p>
</li>
<li> <p><code>method</code> The estimation method used.
</p>
</li>
<li> <p><code>f0</code> A function.  Use <code>f0(v)</code> to evaluate the unconstrained KDE at the points in
<code>v</code>.
</p>
</li>
<li> <p><code>fhat</code> A function. Use <code>fhat(v)</code> to evaluate the constrained KDE at the points in
<code>v</code>.
</p>
</li>
<li> <p><code>data</code> The data used to generate the estimate.
</p>
</li>
<li> <p><code>bw</code> The bandwidth used.
</p>
</li>
<li> <p><code>extra</code> A list holding additional outputs that are specific to the chosen method.
See the &quot;method details&quot; section.
</p>
</li>
<li> <p><code>x</code> A vector of abscissa values for plotting the estimate.  Same as in
<code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li> <p><code>y</code> A vector of ordinate values for plotting the estimate.  Same as in
<code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li>
<li> <p><code>n</code> The sample size, not including missing values.  Note, this <code>n</code> has
no relation to the <code>n</code> provided in the arguments.
</p>
</li>
<li> <p><code>data.name</code> Deparsed name of the <code>x</code> argument, used in plotting.
</p>
</li>
<li> <p><code>call</code> The call to the function.
</p>
</li>
<li> <p><code>has.na</code> Always <code>FALSE</code>.  Included for consistency with
<code><a href="stats.html#topic+density">stats::density()</a></code>.
</p>
</li></ul>



<h3>Constraint details</h3>

<p>All of the constraints other than <code>symmetric</code> are restrictions on the sign of the estimate, or
its derviatives, over certain intervals.  The boundaries of the intervals may be called
<em>important points</em>. If <code>method="greedySharpenedKDE"</code>, the important points are determined
implicitly during estimation.  For the other methods, the locations of the important points may be
supplied in <code>opts</code>; in most cases they are optional.  If they are not provided, estimation
will be run iteratively inside a search routine (<code><a href="#topic+SequentialLineMin">SequentialLineMin</a></code>) to find good values,
and these values will be returned in the <code>extra</code> list.
</p>
<p>Here is a list of the constraints with their definitions and any relevant comments about their
usage.
</p>

<ul>
<li> <p><code>unimodal</code>: The estimate is nondecreasing to the left of <code>opts$modeLocation</code>, and
nonincreasing to the right.  If <code>modeLocation</code> is not supplied, it is found by search.
</p>
</li>
<li> <p><code>monotoneRightTail</code>: The estimate is nonincreasing to the right of the <code>opts$rightTail</code>
percentile of the unconstrained estimate. <code>rightTail</code> is a numeric value between 0 and 100.
If it is not supplied, it is set to its default value, 90.
</p>
</li>
<li> <p><code>monotoneLeftTail</code>: The estimate is nondecreasing to the left of the <code>opts$leftTail</code>
percentile of the unconstrained estimate. <code>leftTail</code> is a numeric value between 0 and 100. If
it is not supplied, it is set to its default value, 10.
</p>
</li>
<li> <p><code>twoInflections</code>: The estimate has two inflection points, found at
<code>opts$inflectionPoints[1]</code> and <code>opts$inflectionPoints[2]</code>. This constraint implies unimodality,
but provides greater smoothness than <code>unimodal</code>. If <code>inflectionPoints</code> is not supplied, it is
found by search.
</p>
</li>
<li> <p><code>twoInflections+</code>: The <em>derivative</em> of the estimate has three inflection
points, located at <code>opts$inflectionPoints[1]</code>, <code>opts$inflectionPoints[2]</code>, and
<code>opts$inflectionPoints[3]</code>.  This constraint implies <code>twoInflections</code> but is even smoother.
Most parametric densities with two tails satisfy this constraint.  If <code>inflectionPoints</code> is not
supplied, it is found by search.
</p>
</li>
<li> <p><code>boundedLeft</code>: The estimate is zero to the left of <code>opts$lowerBound</code>. The value of
<code>lowerBound</code> must be specified in <code>opts</code>. This constraint is implemented only up to a
numerical tolerance. Consequently it is still possible to use it with the Gaussian kernel.
</p>
</li>
<li> <p><code>boundedRight</code>: The estimate is zero to the right of <code>opts$upperBound</code>. The value of
<code>upperBound</code> must be specified in <code>opts</code>. This constraint is
implemented only up to a numerical tolerance.  Consequently it is still possible to use
it with the Gaussian kernel.
</p>
</li>
<li> <p><code>symmetric</code>: The estimate is symmetric around <code>opts$pointOfSymmetry</code>. If
<code>pointOfSymmetry</code> is not provided, it is found by search.
</p>
</li>
<li> <p><code>bimodal</code>: The estimate has modes at <code>opts$modeLocation[1]</code> and <code>opts$modeLocation[3]</code>,
with an antimode (local minimum) at <code>opts$modeLocation[2]</code>. If <code>modeLocation</code> is not
specified, it is found by search.
</p>
</li></ul>



<h3>Method details</h3>

<p>The <code>adjustedKDE</code> and <code>weightedKDE</code> methods are implemented using a common framework
where the standard KDE is first approximated by a binning step, after which the constrained estimate
is obtained. The <code>greedySharpenedKDE</code> method uses a different approach.
</p>


<h4>adjustedKDE and weightedKDE</h4>

<p>The <code>adjustedKDE</code> method is based on the method of Wolters and Braun (2017).  The method
uses the usual unconstrained kernel density estimate as a pilot estimate, and adjusts the shape of
this estimate by adding a function to it.  The function is selected to minimally change the
shape of the pilot estimate while ensuring the constraints are satisfied. Any of the constraints
can be used with this method.
</p>
<p>The <code>weightedKDE</code> method is based on the method of Hall and Huang (2002).
The method uses a weighted kernel density estimator, with the weights minimally
perturbed such that the constraint is satisfied. Any of the constraints except <code>symmetric</code>
may be used with this method.
</p>
<p>For either of these methods, the following optional arguments can be provided as elements of <code>opts</code>:
</p>

<ul>
<li> <p><code>ncheck</code>:  The number of abscissa points used for constraint checking.  By default,
this is set to <code>max(100, ceiling((diff(range(x)) + 6*h) / h))</code>, where <code>h</code> is
the bandwidth. With this default it should be rare to encounter constraint violations large enough
to be visible in a plot.  In the event that constraint violations are observed, re-run the estimation
with a larger value of <code>ncheck</code>.
</p>
</li>
<li> <p><code>verbose</code>: If <code>TRUE</code>, progress information will be displayed in the console.
The main use of this is to track the progress of the search for important points. Default is <code>FALSE</code>.
</p>
</li></ul>

<p>When either of these methods are used, the output list <code>extra</code> contains elements giving the locations of the
important points used in the final estimate (e.g., <code>modeLocation</code> if the estimate is unimodal or
bimodal). Additionally, it containts the following elements:
</p>

<ul>
<li> <p><code>conCheckGrid</code>: A vector giving the abscissa values at which the constraints were enforced.
</p>
</li>
<li> <p><code>binnedCenters</code>: A vector giving the locations of the kernel centers determined in the
binning step.
</p>
</li>
<li> <p><code>binnedWeights</code>: The weights corresponding to the binned centers.
</p>
</li>
<li> <p><code>finalCenters</code>: The kernel centers used for the final estimate.
</p>
</li>
<li> <p><code>finalWeights</code>: The weights used for the final estimate.
</p>
</li></ul>




<h4>greedySharpenedKDE</h4>

<p>The <code>greedySharpenedKDE</code> method is described in Wolters (2012a, 2012b). It uses a data sharpening
(shifting the data points) approach.  Starting from an initial solution that satisfies the constraints,
a greedy algorithm (implemented in the function <code><a href="#topic+improve">improve</a></code>) is used to move the points as close as
possible to the observed data while maintaining feasibility.
</p>
<p>The following optional arguments can be provided as elements of <code>opts</code>:
</p>

<ul>
<li> <p><code>startValue</code> &mdash; A vector of the same length as <code>x</code>, giving the feasible
initial solution from which the algorithm is started.  If not specified, a vector with
all data points at the location of the unconstrained estimate's highest mode will be used.
Note, it is not guaranteed that the default will satisfy every constraint for every data
set.
</p>
</li>
<li> <p><code>verbose</code>: If <code>TRUE</code>, information about iteration progress will be printed
to the console. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>maxpasses</code>: Each &quot;pass&quot; through the data points moves each point one-by-one in a greedy fasion.
This option limits the maximum number of passes. Default is 500.
</p>
</li>
<li> <p><code>tol</code>: A numerical tolerance for constraint checking.  See <code><a href="#topic+improve">improve</a></code>.
</p>
</li>
<li> <p><code>ILS</code>: An integer greater than zero.  If supplied, the greedy algorithm is run inside an
iterated local search metaheuristic, as described in Wolters (2012b, sec. 3.4). This can improve solution
quality, but requires the greedy search to be run <code>2*ILS</code> extra times.
</p>
</li></ul>

<p>When this method is used, the output list <code>extra</code> contains the following elements:
</p>

<ul>
<li> <p><code>xstar</code>: The final vector of &quot;sharpened&quot; data points used to generate the
estimate.
</p>
</li></ul>




<h3>References</h3>

<p>Hall and Huang (2002), Unimodal Density Estimation Using Kernel Methods, <em>Statistica Sinica</em>,
12, 965-990.
</p>
<p>Wolters and Braun (2017), Enforcing Shape Constraints on a Probability Density Estimate Using an Additive
Adjustment curve, <em>Communications in Statistics - Simulation and Computation</em>,
47(3), 672-691.
</p>
<p>Wolters (2012a), A Greedy Algorithm for Unimodal Kernel Density Estimation by Data Sharpening,
<em>Journal of Statistical Software</em>, 46(6), 1–26.
</p>
<p>Wolters (2012b), Methods for Shape-Constrained Kernel Density Estimation. Ph.D. Thesis, University
of Western Ontario.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.scdensity">plot.scdensity</a></code> plot method, <code><a href="#topic+print.scdensity">print.scdensity</a></code> print
method, and <code><a href="#topic+summary.scdensity">summary.scdensity</a></code> summary method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Default method gives a unimodal estimate using adjustment curve method.
x &lt;- rlnorm(30)
scKDE &lt;- scdensity(x)
scKDE
summary(scKDE)
plot(scKDE, detail=2)
plot(scKDE, detail=4)

# Constrain the first and fourth quartiles to be monotone, using greedy sharpening method.
x &lt;- rt(50, df=3)
scKDE &lt;- scdensity(x, bw="SJ", adjust=0.5, constraint=c("monotoneL", "monotoneR"),
                   opts=list(verbose=TRUE, leftTail=25, rightTail=75), method="greedy")
plot(scKDE)

# Compare unimodal, twoInflections, and twoInflections+ constraints
x &lt;- rnorm(100)
h &lt;- 0.5 * bw.SJ(x)
fhat1 &lt;- scdensity(x, bw=h, constraint="unimodal")
fhat2 &lt;- scdensity(x, bw=h, constraint="twoInflections")
fhat3 &lt;- scdensity(x, bw=h, constraint="twoInflections+")
plot(density(x, bw=h))
lines(fhat1$x, fhat1$y, col="red")
lines(fhat2$x, fhat2$y, col="blue")
lines(fhat3$x, fhat3$y, col="green", lwd=2)

</code></pre>

<hr>
<h2 id='SequentialLineMin'>Minimize a function of r variables by sequential univariate searches.</h2><span id='topic+SequentialLineMin'></span>

<h3>Description</h3>

<p>The function seeks to minimize <code>fcn</code>, a scalar function of <code class="reqn">r</code> variables.  <code>v0</code>
is a starting solution and <code>bounds</code> is a 2-vector giving upper and lower limits for
elements of the solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SequentialLineMin(fcn, bounds, v0, tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SequentialLineMin_+3A_fcn">fcn</code></td>
<td>
<p>A function with taking an r-vector as its first argument: call as <code>fcn(v,...)</code>.</p>
</td></tr>
<tr><td><code id="SequentialLineMin_+3A_bounds">bounds</code></td>
<td>
<p>A 2-vector giving the upper and lower limits for elements of a solution.</p>
</td></tr>
<tr><td><code id="SequentialLineMin_+3A_v0">v0</code></td>
<td>
<p>A starting solution, with increasing elements. An r-vector. Not used if r == 1.</p>
</td></tr>
<tr><td><code id="SequentialLineMin_+3A_tol">tol</code></td>
<td>
<p>Tolerance passed to <code>optimize</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is designed to search for solutions of the form <code class="reqn">v = [v_1 v_2 \ldots v_r]</code>,
where <code>bounds(1)</code> <code class="reqn">&lt; v_1 &lt; v_2 &lt; ... &lt; v_r &lt;</code> <code> bounds(2)</code>. It loops through the solution vector
one variable at a time, and does a 1-D line search using <code>optimize()</code> for an improving
value of that variable.  So when optimizing <code class="reqn">v_i</code>, it searches the interval <code class="reqn">(v_{i-1},
v_{i+1})</code> to maintain the increasing nature of <code class="reqn">v</code>. The overall search terminates once a
pass through all <code class="reqn">r</code> elements of <code class="reqn">v</code> fails to produce any changes to <code class="reqn">v</code>.
</p>


<h3>Value</h3>

<p>a list with elements:
</p>
<table role = "presentation">
<tr><td><code>minimizer</code></td>
<td>
<p>An r-vector containing the solution.</p>
</td></tr>
<tr><td><code>minimum</code></td>
<td>
<p>The objective function value at the solution.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>fcn &lt;- function(v) (v[1]+1)^2 + (v[2]-1)^2
SequentialLineMin(fcn, c(-5,5), c(-3,3))

</code></pre>

<hr>
<h2 id='SpectralShift'>Performs the spectral shift on a matrix to make it numerically positive definite.</h2><span id='topic+SpectralShift'></span>

<h3>Description</h3>

<p>Matrix <code>L</code> is assumed to have eigenvalues that are either all positive, or very
close to zero.  If any eigenvalues are less than less than <code>threshold</code>, a positive
quantity is added to the diagonal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpectralShift(L, threshold = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SpectralShift_+3A_l">L</code></td>
<td>
<p>A square numeric matrix.</p>
</td></tr>
<tr><td><code id="SpectralShift_+3A_threshold">threshold</code></td>
<td>
<p>The eigenvalue threshold. Default 1E-10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The spectral-shifted matrix.
</p>

<hr>
<h2 id='summary.scdensity'>Summary method for class <code>scdensity</code>.</h2><span id='topic+summary.scdensity'></span>

<h3>Description</h3>

<p>Collects high-level information about the <code>scdensity</code> object and some descriptive
statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scdensity'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.scdensity_+3A_object">object</code></td>
<td>
<p>An object of S3 class <code>scensity</code>.</p>
</td></tr>
<tr><td><code id="summary.scdensity_+3A_...">...</code></td>
<td>
<p>Included for consistency with generic functions.</p>
</td></tr>
</table>

<hr>
<h2 id='WeightedKDE'>Function to carry out the weighted or adjusted KDE optimization.</h2><span id='topic+WeightedKDE'></span>

<h3>Description</h3>

<p>This function sets up the problem and finds an optimal shape-constrained estimate for a
specified set of important points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeightedKDE(P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WeightedKDE_+3A_p">P</code></td>
<td>
<p>A list, as created by InitializeP().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mutated version of the input list, with additional elements giving the optimization
output.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
