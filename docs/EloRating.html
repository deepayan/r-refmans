<!DOCTYPE html><html lang="en"><head><title>Help for package EloRating</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EloRating}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EloRating-package'>
<p>Animal Dominance Hierarchies by Elo Rating</p></a></li>
<li><a href='#.diffmat'><p>difference matrix</p></a></li>
<li><a href='#.elo.seq_old'><p>calculate Elo ratings</p></a></li>
<li><a href='#.incon'><p>number of inconsistencies</p></a></li>
<li><a href='#.sincon'><p>strength of inconsistencies</p></a></li>
<li><a href='#adv'><p>Dominance sequence from Albers and de Vries (2001)</p></a></li>
<li><a href='#adv2'><p>Dominance sequence from Albers and de Vries (2001)</p></a></li>
<li><a href='#advpres'><p>Fictional presence data for Albers and de Vries (2001)</p></a></li>
<li><a href='#baboons1'><p>Baboon dominance sequences</p></a></li>
<li><a href='#bonobos'><p>Dominance matrix from de Vries et al. 2006</p></a></li>
<li><a href='#CBI'><p>Clutton-Brock et al 1979 index (CBI)</p></a></li>
<li><a href='#coresidence'><p>coresidence summary</p></a></li>
<li><a href='#correctly_predicted'><p>correctly predicted outcomes</p></a></li>
<li><a href='#creatematrix'><p>create a dominance matrix</p></a></li>
<li><a href='#createstartvalues'><p>calculate start values from prior knowledge</p></a></li>
<li><a href='#DCindex'><p>Directional Consistency Index</p></a></li>
<li><a href='#devries98'><p>Dominance matrix from de Vries (1998)</p></a></li>
<li><a href='#dommats'><p>Example dominance matrices</p></a></li>
<li><a href='#DS'><p>David's score</p></a></li>
<li><a href='#dyadic_dom'><p>dyadic dominance relations</p></a></li>
<li><a href='#dyadic_reversals'><p>changes in dyadic relationships</p></a></li>
<li><a href='#e.single'><p>Elo ratings for a single interaction</p></a></li>
<li><a href='#elo.seq'><p>calculate Elo ratings</p></a></li>
<li><a href='#eloplot'><p>Elo rating plots</p></a></li>
<li><a href='#extract_elo'><p>extract Elo ratings from elo object</p></a></li>
<li><a href='#h.index'><p>linearity indices</p></a></li>
<li><a href='#heatmapplot'><p>heatmap</p></a></li>
<li><a href='#incontable'><p>number and strength of inconsistencies</p></a></li>
<li><a href='#individuals'><p>individuals present in the group</p></a></li>
<li><a href='#ISI'><p>de Vries' I&amp;SI ranking</p></a></li>
<li><a href='#ISIranks'><p>ISI ranks</p></a></li>
<li><a href='#lastdaypresent'><p>last day an individual was present</p></a></li>
<li><a href='#likelo'><p>(log) likelihood of Elo-rating model</p></a></li>
<li><a href='#mat2seq'><p>matrix to sequence conversion</p></a></li>
<li><a href='#optimizek'><p>optimize the k parameter</p></a></li>
<li><a href='#optistart'><p>optimize start values</p></a></li>
<li><a href='#presence_summary'><p>Summarize presence data</p></a></li>
<li><a href='#print.elo'><p>prints its argument</p></a></li>
<li><a href='#print.seqchecknopres'><p>prints its argument</p></a></li>
<li><a href='#print.sequencecheck'><p>prints its argument</p></a></li>
<li><a href='#prunk'><p>unknown relationships</p></a></li>
<li><a href='#randomelo'><p>calculate Elo ratings from an interaction matrix</p></a></li>
<li><a href='#randomeloextract'><p>extract ratings from random sequences based on an interaction matrix</p></a></li>
<li><a href='#randomsequence'><p>random dominance interaction sequence</p></a></li>
<li><a href='#scale_elo'><p>standardize Elo ratings</p></a></li>
<li><a href='#seqcheck'><p>runs raw data diagnostics for Elo rating</p></a></li>
<li><a href='#simple_dom'><p>simple dominance indices</p></a></li>
<li><a href='#stab_elo'><p>stability index <em>S</em></p></a></li>
<li><a href='#steepness'><p>hierarchy steepness based on David's scores</p></a></li>
<li><a href='#summary.elo'><p>summarize elo object</p></a></li>
<li><a href='#traj_elo'><p>calculate dominance trajectory</p></a></li>
<li><a href='#transitivity'><p>triangle transitivity</p></a></li>
<li><a href='#winprob'><p>expected winning probability</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Animal Dominance Hierarchies by Elo Rating</td>
</tr>
<tr>
<td>Version:</td>
<td>0.46.18</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christof Neumann &lt;christofneumann1@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to quantify animal dominance hierarchies. The major focus is on Elo rating and its ability to deal with temporal dynamics in dominance interaction sequences. For static data, David's score and de Vries' I&amp;SI are also implemented. In addition, the package provides functions to assess transitivity, linearity and stability of dominance networks. See Neumann et al (2011) &lt;<a href="https://doi.org/10.1016%2Fj.anbehav.2011.07.016">doi:10.1016/j.anbehav.2011.07.016</a>&gt; for an introduction.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>zoo, sna, network, R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), knitr, aniDom, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gobbios/EloRating">https://github.com/gobbios/EloRating</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gobbios/EloRating/issues">https://github.com/gobbios/EloRating/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-15 15:33:28 UTC; CNeumann</td>
</tr>
<tr>
<td>Author:</td>
<td>Christof Neumann <a href="https://orcid.org/0000-0002-0236-1219"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Lars Kulik [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-15 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='EloRating-package'>
Animal Dominance Hierarchies by Elo Rating
</h2><span id='topic+EloRating-package'></span><span id='topic+EloRating'></span>

<h3>Description</h3>

<p>Provides functions to quantify animal dominance hierarchies. The major focus is on Elo rating and its ability to deal with temporal dynamics in dominance interaction sequences. For static data, David's score and de Vries' I&amp;SI are also implemented. In addition, the package provides functions to assess transitivity, linearity and stability of dominance networks. See Neumann et al (2011) &lt;doi:10.1016/j.anbehav.2011.07.016&gt; for an introduction.
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Christof Neumann &lt;christofneumann1@gmail.com&gt;
</p>


<h3>References</h3>

<p>Elo, A. E. 1978. The Rating of Chess Players, Past and Present. New York: Arco.
</p>
<p>Albers, P. C. H. &amp; de Vries, H. 2001. Elo-rating as a tool in the sequential estimation of dominance strengths. Animal Behaviour, 61, 489-495 (<a href="https://doi.org/10.1006/anbe.2000.1571">doi:10.1006/anbe.2000.1571</a>).
</p>
<p>Neumann, C., Duboscq, J., Dubuc, C., Ginting, A., Irwan, A. M., Agil, M., Widdig, A. &amp; Engelhardt, A. 2011. Assessing dominance hierarchies: validation and advantages of progressive evaluation with Elo-rating. Animal Behaviour, 82, 911-921 (<a href="https://doi.org/10.1016/j.anbehav.2011.07.016">doi:10.1016/j.anbehav.2011.07.016</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date)
summary(SEQ)
</code></pre>

<hr>
<h2 id='.diffmat'>difference matrix</h2><span id='topic+.diffmat'></span>

<h3>Description</h3>

<p>difference matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.diffmat(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".diffmat_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix with winner in rows and losers in columns, for example the output from <code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>helper function for <code><a href="#topic+ISI">ISI</a></code>
</p>


<h3>Value</h3>

<p>a matrix with ranking differences assuming that the matrix reflects the order. This information is contained in the upper triangle of the returned matrix.
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
EloRating:::.diffmat(bonobos)

</code></pre>

<hr>
<h2 id='.elo.seq_old'>calculate Elo ratings</h2><span id='topic+.elo.seq_old'></span>

<h3>Description</h3>

<p>calculate Elo ratings from a sequence of dominance interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.elo.seq_old(
  winner,
  loser,
  Date,
  draw = NULL,
  presence = NULL,
  startvalue = 1000,
  k = 100,
  normprob = TRUE,
  init = "average",
  iterate = 0,
  runcheck = TRUE,
  progressbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".elo.seq_old_+3A_winner">winner</code></td>
<td>
<p>either a factor or character vector with winner IDs of dyadic dominance interactions</p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_loser">loser</code></td>
<td>
<p>either a factor or character vector with loser IDs of dyadic dominance interactions</p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_date">Date</code></td>
<td>
<p>character vector of form &quot;YYYY-MM-DD&quot; with the date of the respective interaction</p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_draw">draw</code></td>
<td>
<p>logical, which interactions ended undecided (i.e. drawn or tied)? By default all <code>FALSE</code>, i.e. no undecided interactions occurred. Note that in this case, <code>winner</code>/<code>loser</code> values can be interchanged</p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_presence">presence</code></td>
<td>
<p>optional data.frame, to supply data about presence and absence of individuals for part of the time the data collection covered. see details</p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_startvalue">startvalue</code></td>
<td>
<p>the value of Elo ratings of the two individuals that are involved in the first interaction of the overall sequence prior to this interaction. By default set to 1000. See also <code>init</code></p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_k">k</code></td>
<td>
<p>factor <em>k</em> that determines the maximum change in ratings. By default <code>k=100</code></p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_normprob">normprob</code></td>
<td>
<p>logical (by default <code>TRUE</code>). Should a normal curve be assumed for calculating the winning/losing probablities, or a logistic curve. See <code><a href="#topic+winprob">winprob</a></code> for details</p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_init">init</code></td>
<td>
<p>character, what Elo rating does an individual have prior to its first interaction. Three options are available:
<code>average</code>: individuals always start with the value specified in <code>startvalue</code>. Given stable composition of the group, this also reflects the average Elo rating on each day in that group, <br />
<code>bottom</code>: subjects entering at the current lowest Elo value if the lowest value getting lower its getting lower for all subjects which had this lowest values before, it is reflecting that in some species new subjects entering a group at the bottom level &quot;bottom entry&quot;<br />
<code>bottom_low</code>: same as <code>bottom</code> but additionally the start values getting after the first interaction lower for all non-interacting subjects and, reflecting that we have at start no knowledge about the subjects this option offers for &quot;bottom entry&quot; species the possibility to consider that in a way that those subjects which are not interacting getting lower from start on</p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_iterate">iterate</code></td>
<td>
<p>not yet implemented</p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_runcheck">runcheck</code></td>
<td>
<p>logical, should several checks regarding data integrety be performed, by default <code>TRUE</code>. See <code><a href="#topic+seqcheck">seqcheck</a></code></p>
</td></tr>
<tr><td><code id=".elo.seq_old_+3A_progressbar">progressbar</code></td>
<td>
<p>logical, should progress bars be displayed, by default <code>progressbar=TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>the presence 'matrix' is actually an object of class <code>data.frame</code> containing information about wether an individual was present on a given day or not. The first column represents the dates, running at least from the date of the earliest interaction until at least the date of the last interaction with one line per day (regardless of whether there were actually interactions observed on each day). Further, each individual is represented as a column in which &quot;1&quot; indicates an individual was present on the row-date and a &quot;0&quot; indicates the individuals absence on this date. <code>NA</code>s are not allowed. See <code><a href="#topic+advpres">advpres</a></code> for an example.
</p>


<h3>Value</h3>

<p>An object of class <code>elo</code>, which is list with 10 items that serves as basis to extract relevant information:
</p>
<table role = "presentation">
<tr><td><code>mat</code></td>
<td>
<p>a date by ID-<code>matrix</code> with raw Elo ratings</p>
</td></tr>
<tr><td><code>lmat</code></td>
<td>
<p>a date by ID-<code>matrix</code> with raw Elo ratings</p>
</td></tr>
<tr><td><code>cmat</code></td>
<td>
<p>a date by ID-<code>matrix</code> with raw Elo ratings</p>
</td></tr>
<tr><td><code>pmat</code></td>
<td>
<p>a date by ID-<code>matrix</code> with with presence data</p>
</td></tr>
<tr><td><code>nmat</code></td>
<td>
<p>a date by ID-<code>matrix</code> containing the number of interactions a given ID was involved in on a given day</p>
</td></tr>
<tr><td><code>logtable</code></td>
<td>
<p>details on each single interaction</p>
</td></tr>
<tr><td><code>stability</code></td>
<td>
<p>a <code>data.frame</code> containing information about stability (see <code><a href="#topic+stab_elo">stab_elo</a></code>) </p>
</td></tr>
<tr><td><code>truedates</code></td>
<td>
<p>vector of class <code>Date</code> covering the ranges of dates in the dataset</p>
</td></tr>
<tr><td><code>misc</code></td>
<td>
<p>various</p>
</td></tr>
<tr><td><code>allids</code></td>
<td>
<p>a (sorted) character vector with all IDs that occur in the dataset</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christof Neumann and Lars Kulik
</p>


<h3>References</h3>

<p>Elo AE (1978).
<em>The rating of chess players, past and present</em>.
Arco, New York.
</p>
<p>Albers PCH, de Vries H (2001).
&ldquo;Elo-rating as a tool in the sequential estimation of dominance strengths.&rdquo;
<em>Animal Behaviour</em>, <b>61</b>, 489-495.
<a href="https://doi.org/10.1006/anbe.2000.1571">doi:10.1006/anbe.2000.1571</a>.
</p>
<p>Neumann C, Duboscq J, Dubuc C, Ginting A, Irwan AM, Agil M, Widdig A, Engelhardt A (2011).
&ldquo;Assessing dominance hierarchies: validation and advantages of progressive evaluation with elo-rating.&rdquo;
<em>Animal Behaviour</em>, <b>82</b>, 911-921.
<a href="https://doi.org/10.1016/j.anbehav.2011.07.016">doi:10.1016/j.anbehav.2011.07.016</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- EloRating:::.elo.seq_old(winner=adv$winner, loser=adv$loser, Date=adv$Date)
summary(SEQ)

</code></pre>

<hr>
<h2 id='.incon'>number of inconsistencies</h2><span id='topic+.incon'></span>

<h3>Description</h3>

<p>calculate number of inconsistencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.incon(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".incon_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix with winner in rows and losers in columns, for example the output from <code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer, the number of inconsistencies in the matrix
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>de Vries H (1998).
&ldquo;Finding a dominance order most consistent with a linear hierarchy: a new procedure and review.&rdquo;
<em>Animal Behaviour</em>, <b>55</b>, 827-843.
<a href="https://doi.org/10.1006/anbe.1997.0708">doi:10.1006/anbe.1997.0708</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
EloRating:::.incon(bonobos)

</code></pre>

<hr>
<h2 id='.sincon'>strength of inconsistencies</h2><span id='topic+.sincon'></span>

<h3>Description</h3>

<p>calculate strength of inconsistencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sincon(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".sincon_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix with winner in rows and losers in columns, for example the output from <code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>helper function for <code><a href="#topic+ISI">ISI</a></code>
</p>


<h3>Value</h3>

<p>integer, the summed strength of inconsistencies in the matrix
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>de Vries H (1998).
&ldquo;Finding a dominance order most consistent with a linear hierarchy: a new procedure and review.&rdquo;
<em>Animal Behaviour</em>, <b>55</b>, 827-843.
<a href="https://doi.org/10.1006/anbe.1997.0708">doi:10.1006/anbe.1997.0708</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
EloRating:::.sincon(bonobos)

</code></pre>

<hr>
<h2 id='adv'>Dominance sequence from Albers and de Vries (2001)</h2><span id='topic+adv'></span>

<h3>Description</h3>

<p>Dominance sequence from Albers and de Vries (2001)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(adv)
</code></pre>


<h3>Format</h3>

<p>Fictional example of an interaction sequence, with 33 interactions between 7 individuals.
</p>


<h3>References</h3>

<p>Albers PCH, de Vries H (2001).
&ldquo;Elo-rating as a tool in the sequential estimation of dominance strengths.&rdquo;
<em>Animal Behaviour</em>, <b>61</b>, 489-495.
<a href="https://doi.org/10.1006/anbe.2000.1571">doi:10.1006/anbe.2000.1571</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
</code></pre>

<hr>
<h2 id='adv2'>Dominance sequence from Albers and de Vries (2001)</h2><span id='topic+adv2'></span>

<h3>Description</h3>

<p>Dominance sequence from Albers and de Vries (2001) with added information about interaction type and whether interaction ended in a draw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(adv2)
</code></pre>


<h3>Format</h3>

<p>Fictional example of an interaction sequence, with 33 interactions between 7 individuals.
</p>


<h3>References</h3>

<p>Albers PCH, de Vries H (2001).
&ldquo;Elo-rating as a tool in the sequential estimation of dominance strengths.&rdquo;
<em>Animal Behaviour</em>, <b>61</b>, 489-495.
<a href="https://doi.org/10.1006/anbe.2000.1571">doi:10.1006/anbe.2000.1571</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv2)
</code></pre>

<hr>
<h2 id='advpres'>Fictional presence data for Albers and de Vries (2001)</h2><span id='topic+advpres'></span>

<h3>Description</h3>

<p>Fictional presence data for Albers and de Vries (2001)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(advpres)
</code></pre>


<h3>Format</h3>

<p>Fictional example of an interaction sequence, with 33 interactions between 7 individuals.
</p>


<h3>References</h3>

<p>Albers PCH, de Vries H (2001).
&ldquo;Elo-rating as a tool in the sequential estimation of dominance strengths.&rdquo;
<em>Animal Behaviour</em>, <b>61</b>, 489-495.
<a href="https://doi.org/10.1006/anbe.2000.1571">doi:10.1006/anbe.2000.1571</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(advpres)
</code></pre>

<hr>
<h2 id='baboons1'>Baboon dominance sequences</h2><span id='topic+baboons1'></span><span id='topic+baboons2'></span><span id='topic+baboons3'></span><span id='topic+baboons4'></span><span id='topic+baboons5'></span><span id='topic+baboons'></span>

<h3>Description</h3>

<p>Baboon dominance sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baboons1
</code></pre>


<h3>Format</h3>

<p>Data sets of 5 groups of baboons, with date, winner and loser columns
</p>


<h3>Details</h3>

<p>The exact dates of the interactions were not given in the actual online data sets, so I set them to roughly match the data collection period presented in the actual paper (1996 - 2011)
</p>


<h3>References</h3>

<p>Franz M, McLean E, Tung J, Altmann J, Alberts SC (2015).
&ldquo;Self-organizing dominance hierarchies in a wild primate population.&rdquo;
<em>Proceedings of the Royal Society B: Biological Sciences</em>, <b>282</b>, 20151512.
<a href="https://doi.org/10.1098/rspb.2015.1512">doi:10.1098/rspb.2015.1512</a>.
</p>
<p>Franz M, McLean E, Tung J, Altmann J, Alberts SC (2015).
&ldquo;Data from: Self-organizing dominance hierarchies in a wild primate population.&rdquo;
<em>Dryad</em>.
<a href="https://doi.org/10.5061/dryad.d0g0d">doi:10.5061/dryad.d0g0d</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(baboons1)
</code></pre>

<hr>
<h2 id='bonobos'>Dominance matrix from de Vries et al. 2006</h2><span id='topic+bonobos'></span>

<h3>Description</h3>

<p>Dominance matrix of seven bonobos
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bonobos)
</code></pre>


<h3>Format</h3>

<p>Integer matrix, with column and row names. Winners in rows and losers in columns.
</p>


<h3>References</h3>

<p>de Vries H, Stevens JMG, Vervaecke H (2006).
&ldquo;Measuring and testing the steepness of dominance hierarchies.&rdquo;
<em>Animal Behaviour</em>, <b>71</b>, 585-592.
<a href="https://doi.org/10.1016/j.anbehav.2005.05.015">doi:10.1016/j.anbehav.2005.05.015</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
</code></pre>

<hr>
<h2 id='CBI'>Clutton-Brock et al 1979 index (CBI)</h2><span id='topic+CBI'></span>

<h3>Description</h3>

<p>Clutton-Brock et al 1979 index (CBI)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBI(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CBI_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results of this function diverge from published examples in some
cases. While the function produces identical scores as the results in
Gammell et al. (2003) and
de Vries and Appleby (2000) there are some slight deviations
for the example in Whitehead (2008). The final
example from Bang et al. (2010) is fairly off, but that
seems to be because these authors might have applied different definitions:
Bang et al. (2010) talk about 'who dominates' while
(Clutton-Brock et al. 1979) consider 'who won interactions',
which are two very different conceptualizations, and which might explain the
discrepancies.
</p>


<h3>Value</h3>

<p>a named numeric vector with the indices for each individual
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>Clutton-Brock TH, Albon SD, Gibson RM, Guinness FE (1979).
&ldquo;The logical stag: adaptive aspects of fighting in red deer (<em>Cervus elaphus</em> L.).&rdquo;
<em>Animal Behaviour</em>, <b>27</b>, 211-225.
<a href="https://doi.org/10.1016/0003-3472%2879%2990141-6">doi:10.1016/0003-3472(79)90141-6</a>.
</p>
<p>Bang A, Deshpande SA, Sumana A, Gadagkar R (2010).
&ldquo;Choosing an appropriate index to construct dominance hierarchies in animal societies: a comparison of three indices.&rdquo;
<em>Animal Behaviour</em>, <b>79</b>, 631-636.
<a href="https://doi.org/10.1016/j.anbehav.2009.12.009">doi:10.1016/j.anbehav.2009.12.009</a>.
</p>
<p>Gammell MP, de Vries H, Jennings DJ, Carlin CM, Hayden TJ (2003).
&ldquo;David's score: a more appropriate dominance ranking method than Clutton-Brock et al.'s index.&rdquo;
<em>Animal Behaviour</em>, <b>66</b>, 601-605.
<a href="https://doi.org/10.1006/anbe.2003.2226">doi:10.1006/anbe.2003.2226</a>.
</p>
<p>de Vries H, Appleby MC (2000).
&ldquo;Finding an appropriate order for a hierarchy: a comparison of the I&amp;SI and the BBS methods.&rdquo;
<em>Animal Behaviour</em>, <b>59</b>, 239-245.
<a href="https://doi.org/10.1006/anbe.1999.1299">doi:10.1006/anbe.1999.1299</a>.
</p>
<p>Whitehead H (2008).
<em>Analyzing animal societies: quantitative methods for vertebrate social analysis</em>.
University of Chicago Press, Chicago.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example from Gammell et al 2003 (table 1)
m &lt;- matrix(0, nrow = 5, ncol = 5)
m[upper.tri(m)] &lt;- 100
m[1, 5] &lt;- 99
m[5, 1] &lt;- 1
colnames(m) &lt;- rownames(m) &lt;- c("r", "s", "t", "u", "v")
m
CBI(m)

# example from Whitehead 2008 (table 5.8, 5.9)
m &lt;- c(0, 2, 0, 5, 2, 2, 1, 0, 2, 0,
       0, 0, 2, 2, 1, 0, 3, 2, 1, 1,
       0, 1, 0, 1, 1, 3, 1, 1, 4, 0,
       0, 0, 0, 0, 1, 1, 1, 0, 1, 0,
       0, 0, 0, 0, 0, 7, 1, 4, 2, 3,
       0, 0, 0, 0, 0, 0, 2, 3, 6, 10,
       0, 1, 1, 0, 2, 0, 0, 0, 0, 2,
       0, 0, 0, 1, 0, 0, 0, 0, 1, 1,
       0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
mat &lt;- matrix(m, nrow = 10, byrow = TRUE)
colnames(mat) &lt;- rownames(mat) &lt;- c("x907", "x915", "x912", "x910", "x917",
                                    "x898", "x897", "x911", "x904", "x902")
round(CBI(mat), 2)
# results in book:
# 33, 2.75, 3.08, 0.91, 0.86, 0.82, 0.92, 0.53, 0.23, 0.03

simple_dom(mat2seq(mat)$winner, mat2seq(mat)$loser)

# example from Bang et al 2010 (table 1)
m &lt;- c(0, 1, 0, 2,
       1, 0, 4, 0,
       2, 2, 0, 3,
       3, 0, 1, 0)
m &lt;- matrix(m, ncol = 4, byrow = TRUE)
m &lt;- t(m)
colnames(m) &lt;- rownames(m) &lt;- letters[1:4]
CBI(m)
# results in paper:
# 1.43, 1, 0.7, 1

# and from de Vries and Appleby (2000, table 4)
m &lt;- c(0, 1, 1, 4, 0, 3, 6,
       0, 0, 1, 4, 0, 0, 0,
       0, 0, 0, 1, 1, 3, 14,
       0, 0, 0, 0, 2, 2, 1,
       0, 0, 0, 0, 0, 17, 2,
       0, 0, 0, 0, 0, 0, 12,
       0, 0, 0, 0, 0, 0, 0)
m &lt;- matrix(m, ncol = 7, byrow = TRUE)
colnames(m) &lt;- rownames(m) &lt;- letters[1:7]
CBI(m)
simple_dom(mat2seq(m)$winner, mat2seq(m)$loser)
</code></pre>

<hr>
<h2 id='coresidence'>coresidence summary</h2><span id='topic+coresidence'></span>

<h3>Description</h3>

<p>coresidence summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coresidence(eloobject)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coresidence_+3A_eloobject">eloobject</code></td>
<td>
<p>result from <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a summary of the presence of individuals (and dyads) during the data sequence. This will be only informative if there was actually presence information supplied to <code>elo.seq</code>.
</p>


<h3>Value</h3>

<p>a list with three items:
</p>

<dl>
<dt><code>$global</code> (a numeric vector)</dt><dd>

<dl>
<dt><code>n_int</code></dt><dd><p>total number of interactions</p>
</dd>
<dt><code>n_dyads</code></dt><dd><p>total number of dyads</p>
</dd>
<dt><code>prop_nocores</code></dt><dd><p>proportion of dyads that were never co-resident</p>
</dd>
<dt><code>mean_cores_prop</code></dt><dd><p>mean proportion over individuals of proportions of all other IDs the focal was co-resident with at some point</p>
</dd>
</dl>

</dd>
<dt><code>$dyads</code> (a data.frame)</dt><dd>

<dl>
<dt><code>id1, id2</code></dt><dd><p>the IDs</p>
</dd>
<dt><code>n_int</code></dt><dd><p>number of interactions for dyad</p>
</dd>
<dt><code>cores_dur</code></dt><dd><p>the duration of co-residence</p>
</dd>
<dt><code>none_dur</code></dt><dd><p>the duration for neither ID being present (both are absent)</p>
</dd>
<dt><code>one_dur</code></dt><dd><p>the duration of time when one ID was present but not the other</p>
</dd>
</dl>

</dd>
<dt><code>$individuals</code> (a data.frame)</dt><dd>

<dl>
<dt><code>id</code></dt><dd><p>the ID</p>
</dd>
<dt><code>n_int</code></dt><dd><p>number of interactions</p>
</dd>
<dt><code>presdays</code></dt><dd><p>days of presence</p>
</dd>
<dt><code>cores_n_ind</code></dt><dd><p>co-resident with these individuals at some point</p>
</dd>
<dt><code>cores_prop</code></dt><dd><p>proportion of individuals with which ID was co-resident</p>
</dd>
<dt><code>stints</code></dt><dd><p>number of continuous bouts of presence</p>
</dd>
</dl>

</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+presence_summary">presence_summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
IA &lt;- randomsequence(nID = 10, avgIA = 20, presence = c(0.7, 0.8))
SEQ &lt;- elo.seq(winner = IA$seqdat$winner, loser = IA$seqdat$loser, Date = IA$seqdat$Date,
               presence = IA$pres, runcheck = FALSE, progressbar = FALSE)
coresidence(SEQ)
</code></pre>

<hr>
<h2 id='correctly_predicted'>correctly predicted outcomes</h2><span id='topic+correctly_predicted'></span><span id='topic+correctly_predicted.default'></span><span id='topic+correctly_predicted.elo'></span><span id='topic+correctly_predicted.fastelo'></span><span id='topic+correctly_predicted.list'></span><span id='topic+correctly_predicted.matrix'></span>

<h3>Description</h3>

<p>correctly predicted outcomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctly_predicted(xdata, ...)

## Default S3 method:
correctly_predicted(xdata, ...)

## S3 method for class 'elo'
correctly_predicted(xdata, exclude_draws = TRUE, daterange = NULL, ...)

## S3 method for class 'fastelo'
correctly_predicted(xdata, ...)

## S3 method for class 'list'
correctly_predicted(xdata, ...)

## S3 method for class 'matrix'
correctly_predicted(xdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctly_predicted_+3A_xdata">xdata</code></td>
<td>
<p>result from <code><a href="#topic+elo.seq">elo.seq</a></code>, <code><a href="#topic+fastelo">fastelo</a></code>,
a square interaction matrix or a list with two items where the first is a
character vector with ID names (which represents the rank order to be
checked) and the second is an interaction matrix (which needs to be square
and which has column and row names)</p>
</td></tr>
<tr><td><code id="correctly_predicted_+3A_...">...</code></td>
<td>
<p>additional arguments depending on the class of object you supplied</p>
</td></tr>
<tr><td><code id="correctly_predicted_+3A_exclude_draws">exclude_draws</code></td>
<td>
<p>logical, should draws be excluded from the calculation,
by default <code>TRUE</code>. If they are included, such interactions will be
scored as incorrectly predicted.</p>
</td></tr>
<tr><td><code id="correctly_predicted_+3A_daterange">daterange</code></td>
<td>
<p>character or Date of length two, which allows to restrict
the time range to be considered for <code>elo</code> objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you provide results from <code><a href="#topic+elo.seq">elo.seq</a></code> or
<code><a href="#topic+fastelo">fastelo</a></code>, this function first extracts the number of
interactions for which a winning expectation can be expressed, i.e. for all
interactions for which the winning probability for either individual is
different from 0.5. If the winning probability for both IDs is 0.5 then
either outcome is equally likely and hence it cannot be verified whether
the winning probability 'worked correctly'.
</p>
<p>If you provide an interaction matrix, the order of columns in which it is
supplied is taken as the order to be checked, i.e. this just calculates the
proportion of interactions that are in upper triangle of the matrix.
</p>
<p>If you provide a list with a rank order and an interaction matrix, the matrix
will be 'reshuffled' according to the rank order and then all entries above
the diagonal will be divided by the total number of interactions.
</p>
<p>Note that there is one potential issue for the list-based method (rank order
and interaction matrix supplied), which is that it can't accomodate tied
ranks.
</p>


<h3>Value</h3>

<p>a list with two items where the first item is the proportion of
correctly predicted outcomes and the second item is the total number of
interactions for which the winning probability is not 0.5 (in the case of
elo or fastelo) or the total number of interactions (in case of matrix or
list)
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>correctly_predicted(default)</code>: default method for logical vector
</p>
</li>
<li> <p><code>correctly_predicted(elo)</code>: for usage with results of
<code><a href="#topic+elo.seq">elo.seq</a></code>
</p>
</li>
<li> <p><code>correctly_predicted(fastelo)</code>: for usage with results of
<code><a href="#topic+fastelo">fastelo</a></code>
</p>
</li>
<li> <p><code>correctly_predicted(list)</code>: for usage with a list of order and
interaction matrix
</p>
</li>
<li> <p><code>correctly_predicted(matrix)</code>: for usage with an interaction matrix
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
res &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date)
correctly_predicted(res)
correctly_predicted(res, daterange = c("2010-01-10", "2010-01-20"))
# only one interaction considered because for the first no expection was
# expressed (same starting values for both contestants)
correctly_predicted(res, daterange = c("2010-01-01", "2010-01-02"))

data("devries98")
correctly_predicted(list(colnames(devries98), devries98))
# is the same as
correctly_predicted(devries98)
# reversed order
correctly_predicted(list(rev(colnames(devries98)), devries98))

mat &lt;- matrix(ncol = 10, nrow = 10, 0)
colnames(mat) &lt;- rownames(mat) &lt;- letters[1:10]
mat[upper.tri(mat)] &lt;- 101
mat[lower.tri(mat)] &lt;- 100
# correct order
order1 &lt;- colnames(mat)
correctly_predicted(list(order1, mat))
# not very good

# the worst possible order for that matrix:
order2 &lt;- rev(order1)
correctly_predicted(list(order2, mat))
# not much worse than order 1...

mat &lt;- matrix(ncol = 10, nrow = 10, 0)
colnames(mat) &lt;- rownames(mat) &lt;- letters[1:10]
mat[upper.tri(mat)] &lt;- 1
mat[1, 2] &lt;- 100
# correct ranking
order1 &lt;- letters[1:10]
correctly_predicted(xdata = list(order1, mat))
# almost correct order
order2 &lt;- c("b", "a", letters[3:10])
correctly_predicted(xdata = list(order2, mat))

</code></pre>

<hr>
<h2 id='creatematrix'>create a dominance matrix</h2><span id='topic+creatematrix'></span>

<h3>Description</h3>

<p>create a dominance matrix from the underlying observed sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>creatematrix(
  eloobject,
  daterange = NULL,
  drawmethod = "omit",
  onlyinteracting = FALSE,
  winners,
  losers,
  draw = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="creatematrix_+3A_eloobject">eloobject</code></td>
<td>
<p>output from <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="creatematrix_+3A_daterange">daterange</code></td>
<td>
<p>character of length 2, date range to which the matrix should correspond (default from beginning to end of sequence)</p>
</td></tr>
<tr><td><code id="creatematrix_+3A_drawmethod">drawmethod</code></td>
<td>
<p>character with the following options:<br />
<code>"omit"</code> = undecided interactions (draws/ties) are ignored (default)<br />
<code>"0.5"</code> = each undecided is counted half a win for each dyad member<br />
<code>"1"</code> = each undecided interaction is counted twice, i.e. as win for both individuals</p>
</td></tr>
<tr><td><code id="creatematrix_+3A_onlyinteracting">onlyinteracting</code></td>
<td>
<p>logical, indicating whether all individuals that were present (default, <code>TRUE</code>) are shown in the matrix, or only those that were involved in an interaction in the specified date period. If no presence data was supplied to <code><a href="#topic+elo.seq">elo.seq</a></code>, it is assumed that all individuals were present at all times</p>
</td></tr>
<tr><td><code id="creatematrix_+3A_winners">winners</code></td>
<td>
<p>vector of winners (see details)</p>
</td></tr>
<tr><td><code id="creatematrix_+3A_losers">losers</code></td>
<td>
<p>vector of losers (see details)</p>
</td></tr>
<tr><td><code id="creatematrix_+3A_draw">draw</code></td>
<td>
<p>logical vector (currently not doing anything)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works with either the output of <code><a href="#topic+elo.seq">elo.seq</a></code>, or with two vectors of winners and losers. If you use winner and loser vectors, their arguments need to be named, and also the remaining arguments (<code>daterange=</code> and <code>onlyinteracting=</code>) are ignored. The function does not yet allow to include draws if you supply winner/loser vectors. If you go via the <code><a href="#topic+elo.seq">elo.seq</a></code>-route, the function can handle draws (via the <code>drawmethod=</code> argument).
</p>


<h3>Value</h3>

<p>square matrix with dominance interactions (winner in rows, loser in columns)
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
# from winner/loser sequence directly
creatematrix(winners=adv$winner, losers=adv$loser)
# via an eloobject
SEQ &lt;- elo.seq(winner=adv$winner, loser=adv$loser, Date=adv$Date)
# create dyadic matrix over the entire period of data collection
creatematrix(SEQ)
# limit to a subset of interactions
creatematrix(SEQ, daterange=c("2010-01-25", "2010-02-01"))
# limit to a subset of interactions and show only those IDs that were
# involved in at least one interaction
creatematrix(SEQ, daterange=c("2010-01-25", "2010-02-01"),
             onlyinteracting=TRUE)
             
# interactions restricted to single date
creatematrix(SEQ, daterange = c("2010-01-25", "2010-01-25"))

## dealing with undecided interactions
data(adv2)
SEQ &lt;- elo.seq(winner=adv2$winner, loser=adv2$loser, Date=adv2$Date,
               draw=adv2$tie)
# omit ties/draws
creatematrix(SEQ)
# omit ties/draws
creatematrix(SEQ, drawmethod="0.5")
# omit ties/draws
creatematrix(SEQ, drawmethod="1")
</code></pre>

<hr>
<h2 id='createstartvalues'>calculate start values from prior knowledge</h2><span id='topic+createstartvalues'></span>

<h3>Description</h3>

<p>calculate start values from prior knowledge
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createstartvalues(
  ranks = NULL,
  rankclasses = NULL,
  shape = 0.3,
  startvalue = 1000,
  k = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createstartvalues_+3A_ranks">ranks</code></td>
<td>
<p>named vector, contains the ordinal ranks of all individuals for which such prior knowledge exists, names of the vector refer to the individual codes as they occur in the interaction sequence supplied to <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="createstartvalues_+3A_rankclasses">rankclasses</code></td>
<td>
<p>list with four items, each representing a rank class in descending order, if a given rank class is empty supply it as <code>NULL</code>, see details and examples</p>
</td></tr>
<tr><td><code id="createstartvalues_+3A_shape">shape</code></td>
<td>
<p>numeric, between 0 and 1, by default <code>shape=0.3</code>. This value determines the 'steepness' of the initial values. Steepest is at <code>shape=0</code> and shallowest is at <code>shape=1</code>. See examples.</p>
</td></tr>
<tr><td><code id="createstartvalues_+3A_startvalue">startvalue</code></td>
<td>
<p>numeric, the rating value with which an individual starts into the rating process. By default <code>startvalue=1000</code></p>
</td></tr>
<tr><td><code id="createstartvalues_+3A_k">k</code></td>
<td>
<p>numeric, the <em>k</em> factor that determines the maximum change in ratings. By default <code>k=100</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>only one of <code>ranks</code> or <code>rankclasses</code> can be supplied.
</p>
<p>if you wish to supply rank classes you need to supply four categories and it is assumed that the first list item is the highest class. If you have less than four rank classes, you still need to supply a list with four items and set those that you wish to ignore to <code>NULL</code>, see examples.
</p>


<h3>Value</h3>

<p>list with three items:<br />
</p>
<table role = "presentation">
<tr><td><code>res</code></td>
<td>
<p>a named numeric vector with the startvalues to be supplied to <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p><em>k</em> factor used</p>
</td></tr>
<tr><td><code>startvalue</code></td>
<td>
<p>start value used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>Newton-Fisher NE (2017).
&ldquo;Modeling social dominance: Elo-ratings, prior history, and the intensity of aggression.&rdquo;
<em>International Journal of Primatology</em>, <b>38</b>, 427-447.
<a href="https://doi.org/10.1007/s10764-017-9952-2">doi:10.1007/s10764-017-9952-2</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># assuming a group with 7 individuals
# with four rank classes
myrankclasses &lt;- list(alpha = "a", high=c("b", "c"), mid=c("d", "e"), low=c("f", "g"))
createstartvalues(rankclasses = myrankclasses)
# with two rank classes
myrankclasses2 &lt;- list(class1 = NULL, high=c("a", "b", "c"), class3=NULL, low=c("d", "e", "f", "g"))
createstartvalues(rankclasses = myrankclasses2)

# with ordinal ranks
myranks &lt;- 1:7; names(myranks) &lt;- letters[1:7]
createstartvalues(ranks = myranks)
</code></pre>

<hr>
<h2 id='DCindex'>Directional Consistency Index</h2><span id='topic+DCindex'></span>

<h3>Description</h3>

<p>calculate Directional Consistency Index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DCindex(interactionmatrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DCindex_+3A_interactionmatrix">interactionmatrix</code></td>
<td>
<p>square interaction matrix with winner in rows and losers in columns, for example the output from <code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value, the DCI
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>van Hooff JARAM, Wensing JAB (1987).
&ldquo;Dominance and its behavioural measures in a captive wolf pack.&rdquo;
In Frank H (ed.), <em>Man and Wolf</em>, 219-252.
Junk, Dordrecht.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date)
mat &lt;- creatematrix(SEQ)
DCindex(mat)

# or directly from a matrix
data(bonobos)
DCindex(bonobos)
</code></pre>

<hr>
<h2 id='devries98'>Dominance matrix from de Vries (1998)</h2><span id='topic+devries98'></span>

<h3>Description</h3>

<p>Fictional dominance matrix from de Vries (1998) from 10 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(devries98)
</code></pre>


<h3>Format</h3>

<p>Named integer matrix.
</p>


<h3>References</h3>

<p>de Vries H (1998).
&ldquo;Finding a dominance order most consistent with a linear hierarchy: a new procedure and review.&rdquo;
<em>Animal Behaviour</em>, <b>55</b>, 827-843.
<a href="https://doi.org/10.1006/anbe.1997.0708">doi:10.1006/anbe.1997.0708</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(devries98)
</code></pre>

<hr>
<h2 id='dommats'>Example dominance matrices</h2><span id='topic+dommats'></span>

<h3>Description</h3>

<p>Example dominance matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dommats
</code></pre>


<h3>Format</h3>

<p>A named list with dominance matrices:
</p>

<ul>
<li> <p><code>badgers</code>: 7 badgers (Hewitt et al 2009, Fig. A1 PO2004)
</p>
</li>
<li> <p><code>squirrels</code>: 8 squirrels (Farentinos 1972, Table 1C)
</p>
</li>
<li> <p><code>elephants</code>: 7 elephants (Archie et al 2006, Fig. 2, JA)
</p>
</li></ul>



<h3>References</h3>

<p>Farentinos RC (1972).
&ldquo;Social dominance and mating activity in the tassel-eared squirrel (<em>Sciurus aberti ferreus</em>).&rdquo;
<em>Animal Behaviour</em>, <b>20</b>, 316-326.
<a href="https://doi.org/10.1016/S0003-3472%2872%2980053-8">doi:10.1016/S0003-3472(72)80053-8</a>.
</p>
<p>Archie EA, Morrison TA, Foley CAH, Moss CJ, Alberts SC (2006).
&ldquo;Dominance rank relationships among wild female African elephants, <em>Loxodonta africana</em>.&rdquo;
<em>Animal Behaviour</em>, <b>71</b>, 117-127.
<a href="https://doi.org/10.1016/j.anbehav.2005.03.023">doi:10.1016/j.anbehav.2005.03.023</a>.
</p>
<p>Hewitt SE, Macdonald DW, Dugdale HL (2009).
&ldquo;Context-dependent linear dominance hierarchies in social groups of European badgers, <em>Meles meles</em>.&rdquo;
<em>Animal Behaviour</em>, <b>77</b>, 161-169.
<a href="https://doi.org/10.1016/j.anbehav.2008.09.022">doi:10.1016/j.anbehav.2008.09.022</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dommats)
</code></pre>

<hr>
<h2 id='DS'>David's score</h2><span id='topic+DS'></span>

<h3>Description</h3>

<p>calculate David's scores from an interaction matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DS(interactionmatrix, prop = c("Dij", "Pij"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DS_+3A_interactionmatrix">interactionmatrix</code></td>
<td>
<p>square interaction matrix with winner in rows and losers in columns, for example the output from <code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
<tr><td><code id="DS_+3A_prop">prop</code></td>
<td>
<p>the type of dyadic win proportion to be use. By default corrected for number of interactions in a dyad (<code>prop="Dij"</code>), otherwise the raw proportion (<code>prop="Pij"</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with columns ID, DS (David's scores) and normDS (normalized David's scores)
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>David HA (1987).
&ldquo;Ranking from unbalanced paired-comparison data.&rdquo;
<em>Biometrika</em>, <b>74</b>, 432-436.
<a href="https://doi.org/10.1093/biomet/74.2.432">doi:10.1093/biomet/74.2.432</a>.
</p>
<p>Gammell MP, de Vries H, Jennings DJ, Carlin CM, Hayden TJ (2003).
&ldquo;David's score: a more appropriate dominance ranking method than Clutton-Brock et al.'s index.&rdquo;
<em>Animal Behaviour</em>, <b>66</b>, 601-605.
<a href="https://doi.org/10.1006/anbe.2003.2226">doi:10.1006/anbe.2003.2226</a>.
</p>
<p>de Vries H, Stevens JMG, Vervaecke H (2006).
&ldquo;Measuring and testing the steepness of dominance hierarchies.&rdquo;
<em>Animal Behaviour</em>, <b>71</b>, 585-592.
<a href="https://doi.org/10.1016/j.anbehav.2005.05.015">doi:10.1016/j.anbehav.2005.05.015</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
DS(bonobos)
DS(bonobos, prop = "Pij")

</code></pre>

<hr>
<h2 id='dyadic_dom'>dyadic dominance relations</h2><span id='topic+dyadic_dom'></span>

<h3>Description</h3>

<p>dyadic dominance relations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyadic_dom(winner, loser, Date = NULL, daterange = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dyadic_dom_+3A_winner">winner</code></td>
<td>
<p>character or factor with winner</p>
</td></tr>
<tr><td><code id="dyadic_dom_+3A_loser">loser</code></td>
<td>
<p>character or factor with winner</p>
</td></tr>
<tr><td><code id="dyadic_dom_+3A_date">Date</code></td>
<td>
<p>not yet implemented</p>
</td></tr>
<tr><td><code id="dyadic_dom_+3A_daterange">daterange</code></td>
<td>
<p>not yet implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with one row per dyad
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xdata &lt;- randomsequence(nID = 5, avgIA = 10, reversals = 0.1)$seqdat
dyadic_dom(xdata$winner, xdata$loser)
</code></pre>

<hr>
<h2 id='dyadic_reversals'>changes in dyadic relationships</h2><span id='topic+dyadic_reversals'></span>

<h3>Description</h3>

<p>compare dyadic relationships before and after a certain date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyadic_reversals(eloobject, cutpoint = NULL, daterange = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dyadic_reversals_+3A_eloobject">eloobject</code></td>
<td>
<p>result from <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="dyadic_reversals_+3A_cutpoint">cutpoint</code></td>
<td>
<p>character or Date, the date at which to split into pre and
post (default is <code>NULL</code>, where the data is split in
halves). The actual date here will be included in the 'pre'
period.</p>
</td></tr>
<tr><td><code id="dyadic_reversals_+3A_daterange">daterange</code></td>
<td>
<p>character or Date of length 2, the date range to be
considered (default is <code>NULL</code> where the entire date
range in the data is used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with one line per dyad:
</p>

<dl>
<dt>id1,id2</dt><dd><p>the dyad</p>
</dd>
<dt>pre_n,post_n</dt><dd><p>the number of interactions for that dyad pre and
post cutpoint date</p>
</dd>
<dt>pre,post</dt><dd><p>which of the two was dominant (<code>1</code> = id1, <code>2</code> =
id2, <code>0</code> = tied relationship, <code>NA</code> = unknown
relationship, i.e. 0 interactions)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
eloobject &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date)
# split at halfway point ("2010-01-17")
# one reversal: a-f
dyadic_reversals(eloobject)
# shift split date so that both interactions for a/f occur in the post period,
# which makes it a tie in post and unknown in pre
dyadic_reversals(eloobject, cutpoint = "2010-01-10")
</code></pre>

<hr>
<h2 id='e.single'>Elo ratings for a single interaction</h2><span id='topic+e.single'></span>

<h3>Description</h3>

<p>calculate/update Elo ratings for a single dyadic interaction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e.single(ELO1old, ELO2old, outcome, k = 100, normprob = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="e.single_+3A_elo1old">ELO1old</code>, <code id="e.single_+3A_elo2old">ELO2old</code></td>
<td>
<p>numeric, Elo rating of the first and second individual</p>
</td></tr>
<tr><td><code id="e.single_+3A_outcome">outcome</code></td>
<td>
<p><code>1</code> = first individual wins and second looses<br />
<code>2</code> = second individual wins and first looses<br />
<code>0</code> = interaction ends in a draw/tie (no winner and no looser)</p>
</td></tr>
<tr><td><code id="e.single_+3A_k">k</code></td>
<td>
<p>numeric, <em>k</em> factor, by default <code>k = 100</code></p>
</td></tr>
<tr><td><code id="e.single_+3A_normprob">normprob</code></td>
<td>
<p>logical (by default <code>TRUE</code>). Should a normal curve be assumed for calculating the winning/losing probablities, or a logistic curve. See <code><a href="#topic+winprob">winprob</a></code> for details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of length 2 with updated ratings of first and second individual after the interaction
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>Elo AE (1978).
<em>The rating of chess players, past and present</em>.
Arco, New York.
</p>
<p>Albers PCH, de Vries H (2001).
&ldquo;Elo-rating as a tool in the sequential estimation of dominance strengths.&rdquo;
<em>Animal Behaviour</em>, <b>61</b>, 489-495.
<a href="https://doi.org/10.1006/anbe.2000.1571">doi:10.1006/anbe.2000.1571</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e.single(ELO1old = 1200, ELO2old = 1000, outcome = 1, k = 100)
# same as before
e.single(ELO1old = 1000, ELO2old = 1200, outcome = 2, k = 100)
# an undecided interaction
e.single(ELO1old = 1200, ELO2old = 1000, outcome = 0, k = 100)
# if rating differences are too big, no change occurs
# if higher-rated individual wins
e.single(ELO1old = 2000, ELO2old = 1000, outcome = 1, k = 100)
# same as before but lower-rated individual wins and
# therefore wins maximum number of points possible (i.e. k)
e.single(ELO1old = 2000, ELO2old = 1000, outcome = 2, k = 100)

</code></pre>

<hr>
<h2 id='elo.seq'>calculate Elo ratings</h2><span id='topic+elo.seq'></span><span id='topic+fastelo'></span>

<h3>Description</h3>

<p>calculate Elo ratings from a sequence of dominance interactions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elo.seq(winner, loser, Date, draw = NULL, presence = NULL, startvalue = 1000,
               k = 100, normprob = TRUE, init = "average", intensity = NULL,
               iterate = 0, runcheck = TRUE, progressbar = FALSE)
fastelo(WINNER, LOSER, ALLIDS, KVALS, STARTVALUES, NORMPROB = TRUE, ROUND = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elo.seq_+3A_winner">winner</code></td>
<td>
<p>either a factor or character vector with winner IDs of dyadic dominance interactions</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_loser">loser</code></td>
<td>
<p>either a factor or character vector with loser IDs of dyadic dominance interactions</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_date">Date</code></td>
<td>
<p>character vector of form &quot;YYYY-MM-DD&quot; with the date of the respective interaction</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_draw">draw</code></td>
<td>
<p>logical, which interactions ended undecided (i.e. drawn or tied)? By default all <code>FALSE</code>, i.e. no undecided interactions occurred. Note that in this case, <code>winner</code>/<code>loser</code> values can be interchanged</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_presence">presence</code></td>
<td>
<p>optional data.frame, to supply data about presence and absence of individuals for part of the time the data collection covered. see details</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_startvalue">startvalue</code></td>
<td>
<p>the value of Elo ratings of the two individuals that are involved in the first interaction of the overall sequence prior to this interaction. By default set to 1000. See also <code>init</code></p>
</td></tr>
<tr><td><code id="elo.seq_+3A_k">k</code></td>
<td>
<p>factor <em>k</em> that determines the maximum change in ratings. By default <code>k=100</code></p>
</td></tr>
<tr><td><code id="elo.seq_+3A_normprob">normprob</code></td>
<td>
<p>logical (by default <code>TRUE</code>). Should a normal curve be assumed for calculating the winning/losing probabilities, or a logistic curve. See <code><a href="#topic+winprob">winprob</a></code> for details</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_init">init</code></td>
<td>
<p>character, what Elo rating does an individual have prior to its first interaction. Three options are available:
<code>average</code>: individuals always start with the value specified in <code>startvalue</code>. Given stable composition of the group, this also reflects the average Elo rating on each day in that group, <br />
<code>bottom</code>: subjects entering at the current lowest Elo value if the lowest value getting lower its getting lower for all subjects which had this lowest values before, it is reflecting that in some species new subjects entering a group at the bottom level &quot;bottom entry&quot;<br />
<code>bottom_low</code>: same as <code>bottom</code> but additionally the start values getting after the first interaction lower for all non-interacting subjects and, reflecting that we have at start no knowledge about the subjects this option offers for &quot;bottom entry&quot; species the possibility to consider that in a way that those subjects which are not interacting getting lower from start on</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_intensity">intensity</code></td>
<td>
<p>a character vector or factor describing intensity of interaction, to be matched with custom k values if specified</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_iterate">iterate</code></td>
<td>
<p>not yet implemented</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_runcheck">runcheck</code></td>
<td>
<p>logical, should several checks regarding data integrity be performed, by default <code>TRUE</code>. See <code><a href="#topic+seqcheck">seqcheck</a></code></p>
</td></tr>
<tr><td><code id="elo.seq_+3A_progressbar">progressbar</code></td>
<td>
<p>logical, should progress bars be displayed, by default <code>progressbar=TRUE</code></p>
</td></tr>
<tr><td><code id="elo.seq_+3A_winner">WINNER</code></td>
<td>
<p>same as <code>winner</code> for use in <code>fastelo()</code></p>
</td></tr>
<tr><td><code id="elo.seq_+3A_loser">LOSER</code></td>
<td>
<p>same as <code>loser</code> for use in <code>fastelo()</code></p>
</td></tr>
<tr><td><code id="elo.seq_+3A_allids">ALLIDS</code></td>
<td>
<p>character vector, contains all the indivuals IDS</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_kvals">KVALS</code></td>
<td>
<p>numeric vector of the same length <code>WINNER</code>, i.e. one k value for each interaction</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_startvalues">STARTVALUES</code></td>
<td>
<p>numeric vector of the same length as <code>ALLIDS</code>, i.e. one start value for each individual</p>
</td></tr>
<tr><td><code id="elo.seq_+3A_normprob">NORMPROB</code></td>
<td>
<p>logical, by default <code>TRUE</code>: same as <code>normprob</code> for use in <code>fastelo()</code></p>
</td></tr>
<tr><td><code id="elo.seq_+3A_round">ROUND</code></td>
<td>
<p>logical, by default <code>TRUE</code>: should ratings be rounded to integers. For use in <code>fastelo()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The presence 'matrix' is actually an object of class <code>data.frame</code> containing information about wether an individual was present on a given day or not. The first column represents the dates, running at least from the date of the earliest interaction until at least the date of the last interaction with one line per day (regardless of whether there were actually interactions observed on each day). Further, each individual is represented as a column in which &quot;1&quot; indicates an individual was present on the row-date and a &quot;0&quot; indicates the individuals absence on this date. <code>NA</code>s are not allowed. See <code><a href="#topic+advpres">advpres</a></code> for an example.
</p>
<p>The function <code>fastelo()</code> is a stripped-down version of <code>elo.seq()</code>, which performs only the most basic calculations while ignoring anything that is date and presence related. Neither does it perform data checks. In other words, it just calculates ratings based on the sequence. It's most useful in simulations, for example when estimating optimal k parameters. Its main advantage is its speed, which is substantially faster than <code>elo.seq()</code>. Note that currently there is no support for tied interactions. The main difference to note is that both, start values and k values have to be supplied as vectors with one value for each individual and interaction respectively.
</p>


<h3>Value</h3>

<p>An object of class <code>elo</code>, which is list with 10 items that serves as basis to extract relevant information:
</p>
<table role = "presentation">
<tr><td><code>mat</code></td>
<td>
<p>a date by ID-<code>matrix</code> with raw Elo ratings</p>
</td></tr>
<tr><td><code>lmat</code></td>
<td>
<p>a date by ID-<code>matrix</code> with raw Elo ratings</p>
</td></tr>
<tr><td><code>cmat</code></td>
<td>
<p>a date by ID-<code>matrix</code> with raw Elo ratings</p>
</td></tr>
<tr><td><code>pmat</code></td>
<td>
<p>a date by ID-<code>matrix</code> with with presence data</p>
</td></tr>
<tr><td><code>nmat</code></td>
<td>
<p>a date by ID-<code>matrix</code> containing the number of interactions a given ID was involved in on a given day</p>
</td></tr>
<tr><td><code>logtable</code></td>
<td>
<p>details on each single interaction</p>
</td></tr>
<tr><td><code>stability</code></td>
<td>
<p>a <code>data.frame</code> containing information about stability (see <code><a href="#topic+stab_elo">stab_elo</a></code>) </p>
</td></tr>
<tr><td><code>truedates</code></td>
<td>
<p>vector of class <code>Date</code> covering the ranges of dates in the dataset</p>
</td></tr>
<tr><td><code>misc</code></td>
<td>
<p>various</p>
</td></tr>
<tr><td><code>allids</code></td>
<td>
<p>a (sorted) character vector with all IDs that occur in the dataset</p>
</td></tr>
</table>
<p><code>fastelo()</code> returns a list with ten items:
</p>
<table role = "presentation">
<tr><td><code>$ratings</code></td>
<td>
<p>numeric vector of the final ratings in the same order as <code>ALLIDS</code></p>
</td></tr>
<tr><td><code>$winprobs</code></td>
<td>
<p>numeric vector with winning probabilities in the same order as the interactions were supplied</p>
</td></tr>
<tr><td><code>$rtype</code></td>
<td>
<p>character of length 1, as a marker that the result comes from <code>fastelo()</code></p>
</td></tr>
<tr><td><code>$startvalues</code></td>
<td>
<p>numeric vector with start values</p>
</td></tr>
<tr><td><code>$kvalues</code></td>
<td>
<p>numeric vector with k values</p>
</td></tr>
<tr><td><code>$winner</code></td>
<td>
<p>character vector with winners</p>
</td></tr>
<tr><td><code>$loser</code></td>
<td>
<p>character vector with losers</p>
</td></tr>
<tr><td><code>$allids</code></td>
<td>
<p>character vector with all IDs that occur in the sequence</p>
</td></tr>
<tr><td><code>$normprob</code></td>
<td>
<p>logical, was normal probability used for winning expectations</p>
</td></tr>
<tr><td><code>$round</code></td>
<td>
<p>logical, was rounding to integers used during the calculation of ratings</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christof Neumann and Lars Kulik
</p>


<h3>References</h3>

<p>Elo AE (1978).
<em>The rating of chess players, past and present</em>.
Arco, New York.
</p>
<p>Albers PCH, de Vries H (2001).
&ldquo;Elo-rating as a tool in the sequential estimation of dominance strengths.&rdquo;
<em>Animal Behaviour</em>, <b>61</b>, 489-495.
<a href="https://doi.org/10.1006/anbe.2000.1571">doi:10.1006/anbe.2000.1571</a>.
</p>
<p>Neumann C, Duboscq J, Dubuc C, Ginting A, Irwan AM, Agil M, Widdig A, Engelhardt A (2011).
&ldquo;Assessing dominance hierarchies: validation and advantages of progressive evaluation with elo-rating.&rdquo;
<em>Animal Behaviour</em>, <b>82</b>, 911-921.
<a href="https://doi.org/10.1016/j.anbehav.2011.07.016">doi:10.1016/j.anbehav.2011.07.016</a>.
</p>
<p>Newton-Fisher NE (2017).
&ldquo;Modeling social dominance: Elo-ratings, prior history, and the intensity of aggression.&rdquo;
<em>International Journal of Primatology</em>, <b>38</b>, 427-447.
<a href="https://doi.org/10.1007/s10764-017-9952-2">doi:10.1007/s10764-017-9952-2</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
res &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date)
summary(res)

# with custom k
data(adv2)
table(adv2$intensity)

myks &lt;- list(displace = 20, fight = 200)
res &lt;- elo.seq(winner = adv2$winner, loser = adv2$loser, Date = adv2$Date,
               k = myks, intensity = adv2$intensity)
extract_elo(res)
summary(res)

# with custom start values
# if we know prior ranks:
myranks &lt;- 1:7
names(myranks) &lt;- letters[1:7]
mypriors &lt;- createstartvalues(myranks, shape = 0.3)
res &lt;- elo.seq(winner = adv2$winner, loser = adv2$loser, Date = adv2$Date,
               k = myks, intensity = adv2$intensity, startvalue = mypriors$res)
extract_elo(res)

# compare elo.seq and fastelo
xdata &lt;- randomsequence(10, 500)
allids &lt;- colnames(xdata$pres)[2:ncol(xdata$pres)]
winner &lt;- xdata$seqdat$winner
loser &lt;- xdata$seqdat$loser
Date &lt;- xdata$seqdat$Date
k &lt;- rep(100, length(winner))
svals &lt;- rep(1000, length(allids))

res1 &lt;- fastelo(WINNER = winner, LOSER = loser, ALLIDS = allids, KVALS = k,
                STARTVALUES = svals, NORMPROB = TRUE)$ratings
names(res1) &lt;- allids
res1 &lt;- sort(res1, decreasing = TRUE)
res2 &lt;- extract_elo(elo.seq(winner = winner, loser = loser, Date = Date,
                            startvalue = 1000, k = 100, normprob = TRUE,
                            runcheck = FALSE))
res1
res2
</code></pre>

<hr>
<h2 id='eloplot'>Elo rating plots</h2><span id='topic+eloplot'></span>

<h3>Description</h3>

<p>plot Elo ratings for all or selected individuals over a specified time period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eloplot(
  eloobject,
  ids = "all",
  interpolate = "yes",
  from = "start",
  to = "end",
  color = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eloplot_+3A_eloobject">eloobject</code></td>
<td>
<p>elo object, output of <code><a href="#topic+elo.seq">elo.seq</a></code> function</p>
</td></tr>
<tr><td><code id="eloplot_+3A_ids">ids</code></td>
<td>
<p>character, <code>"all"</code> will plot trajectories for all individuals within the dataset. <code>"first.20"</code> will plot the 20 first individuals. <code>"random.20"</code> will plot 20 randomly chosen individuals from the dataset. Alternatively, provide a list of individual IDs.</p>
</td></tr>
<tr><td><code id="eloplot_+3A_interpolate">interpolate</code></td>
<td>
<p>character, by default (<code>"yes"</code>) plot interpolated Elo values or plot Elo values without interpolation (<code>"no"</code>)</p>
</td></tr>
<tr><td><code id="eloplot_+3A_from">from</code></td>
<td>
<p>character, either <code>"start"</code>, i.e. the plotted date range will start at the first date of the dataset, or provide a custom date (&quot;YYYY-MM-DD&quot;)</p>
</td></tr>
<tr><td><code id="eloplot_+3A_to">to</code></td>
<td>
<p>character, either <code>"end"</code>, i.e. the plotted date range will end at the last date of the dataset, or provide a custom date (&quot;YYYY-MM-DD&quot;)</p>
</td></tr>
<tr><td><code id="eloplot_+3A_color">color</code></td>
<td>
<p>logical, the plot is either colored (<code>TRUE</code>) or in black and white with symbols</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a visual inspection of an Elo object it is useful to plot the calculated trajectories. We recommend not to plot trajectories for more than 20 individuals at once.
</p>
<p>Note also, if plots for IDs are requested that had observations on only one day, these IDs are excluded from plotting and a corresponding warning message is produced.
</p>


<h3>Value</h3>

<p>a plot
</p>


<h3>Author(s)</h3>

<p>Lars Kulik and Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- elo.seq(winner=adv$winner, loser=adv$loser, Date=adv$Date)
eloplot(SEQ, ids="all", interpolate="yes", from="start", to="end",
        color=TRUE)
</code></pre>

<hr>
<h2 id='extract_elo'>extract Elo ratings from elo object</h2><span id='topic+extract_elo'></span>

<h3>Description</h3>

<p>extract Elo ratings from elo object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_elo(
  eloobject,
  extractdate = eloobject$misc["maxDate"],
  standardize = FALSE,
  IDs = NULL,
  NA.interpolate = FALSE,
  daterange = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_elo_+3A_eloobject">eloobject</code></td>
<td>
<p>result from <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="extract_elo_+3A_extractdate">extractdate</code></td>
<td>
<p>character, date on which Elo ratings should be obtained, defaults to the last day in the data set</p>
</td></tr>
<tr><td><code id="extract_elo_+3A_standardize">standardize</code></td>
<td>
<p>logical, should the returned ratings be scaled between 0 and 1. Default is <code>FALSE</code>. See <code><a href="#topic+scale_elo">scale_elo</a></code></p>
</td></tr>
<tr><td><code id="extract_elo_+3A_ids">IDs</code></td>
<td>
<p>character, specify IDs for which ratings are returned. By default, returns all that were present on the date or at least on one day of the date range</p>
</td></tr>
<tr><td><code id="extract_elo_+3A_na.interpolate">NA.interpolate</code></td>
<td>
<p>if <code>FALSE</code> (default), the last known rating is returned, which might not be from the specified date itself (but older). If <code>TRUE</code>, ratings on days without observations are linearly interpolated between days with known ratings (i.e. dates with observed interactions)</p>
</td></tr>
<tr><td><code id="extract_elo_+3A_daterange">daterange</code></td>
<td>
<p>if averaged ratings are desired, supply here the number of days from <br />
<code>extractdate - 1</code>. By default (<code>daterange = 1</code>), the ratings of the single <code>extractdate</code> are returned. <code>daterange = 2</code> produces average ratings from <code>extractdate</code> and the day after, and so on...</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>extractdate</code> can be also a vector of dates. In this case, the <code>IDs</code> argument has to be either a vector of length 1 (i.e. a single individual) or a vector of the same length as <code>extractdate</code>. In the first case, the ratings for the same individual are returned on the dates specified in <code>extractdate</code>. In the second case, dates and IDs are matched, i.e. the rating of the individual on that date is returned in the same order as the dates/IDs vectors.
</p>


<h3>Value</h3>

<p>named (IDs) vector of (average) Elo ratings, or an unnamed vector of ratings (if length of <code>extracte</code> is larger than 1)
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- elo.seq(winner=adv$winner, loser=adv$loser, Date=adv$Date)
extract_elo(SEQ, "2010-01-30")
extract_elo(SEQ, "2010-01-30", standardize=TRUE)

# same ratings (regardless of NA.interpolate),
# since "g" was observed on both days
extract_elo(SEQ, "2010-01-29", IDs="g")
extract_elo(SEQ, "2010-01-29", IDs="g", NA.interpolate=TRUE)

extract_elo(SEQ, "2010-01-31", IDs="g")
extract_elo(SEQ, "2010-01-31", IDs="g", NA.interpolate=TRUE)

# different ratings (depending on NA.interpolate),
# since "g" was not observed that day
extract_elo(SEQ, "2010-01-30", IDs="g")
extract_elo(SEQ, "2010-01-30", IDs="g", NA.interpolate=TRUE)

extract_elo(SEQ, "2010-01-10", daterange=5)
extract_elo(SEQ, "2010-01-10", daterange=5, NA.interpolate=TRUE)

# and for multiple dates and a single IDs
dates &lt;- sample(adv$Date, size = 10, replace = TRUE)
ids &lt;- "b"
extract_elo(eloobject = SEQ, extractdate = dates, standardize = FALSE, IDs = ids)

# and for multiple dates and IDs
dates &lt;- sample(adv$Date, size = 10, replace = TRUE)
ids &lt;- sample(colnames(advpres)[2:8], size = 10, replace = TRUE)
extract_elo(eloobject = SEQ, extractdate = dates, standardize = FALSE, IDs = ids)

</code></pre>

<hr>
<h2 id='h.index'>linearity indices</h2><span id='topic+h.index'></span>

<h3>Description</h3>

<p>linearity indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>h.index(interactionmatrix, loops = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="h.index_+3A_interactionmatrix">interactionmatrix</code></td>
<td>
<p>square interaction matrix with winner in rows and losers in columns, for example the output from <code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
<tr><td><code id="h.index_+3A_loops">loops</code></td>
<td>
<p>numeric, the number of randomizations to perform (by default: 1000)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the expected value of <em>h</em> can also be calculated as 3/(N+1).
</p>


<h3>Value</h3>

<p>a data.frame with with values for the number of individuals in the matrix (N), linearity indices (h, h' and expected h), p-value, number of randomizations, and number of unknown and tied relationships.
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>Appleby MC (1983).
&ldquo;The probability of linearity in hierarchies.&rdquo;
<em>Animal Behaviour</em>, <b>31</b>, 600-608.
<a href="https://doi.org/10.1016/S0003-3472%2883%2980084-0">doi:10.1016/S0003-3472(83)80084-0</a>.
</p>
<p>de Vries H (1995).
&ldquo;An improved test of linearity in dominance hierarchies containing unknown or tied relationships.&rdquo;
<em>Animal Behaviour</em>, <b>50</b>, 1375-1389.
<a href="https://doi.org/10.1016/0003-3472%2895%2980053-0">doi:10.1016/0003-3472(95)80053-0</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
h.index(bonobos)

</code></pre>

<hr>
<h2 id='heatmapplot'>heatmap</h2><span id='topic+heatmapplot'></span>

<h3>Description</h3>

<p>heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmapplot(
  formula,
  data,
  xbreaks = NULL,
  ybreaks = NULL,
  addvals = FALSE,
  addN = FALSE,
  digits = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmapplot_+3A_formula">formula</code></td>
<td>
<p>formula for plot</p>
</td></tr>
<tr><td><code id="heatmapplot_+3A_data">data</code></td>
<td>
<p>data set for plot (typically a data frame)</p>
</td></tr>
<tr><td><code id="heatmapplot_+3A_xbreaks">xbreaks</code></td>
<td>
<p>numeric, the breakpoints for the horizontal axis</p>
</td></tr>
<tr><td><code id="heatmapplot_+3A_ybreaks">ybreaks</code></td>
<td>
<p>numeric, the breakpoints for the vertical axis</p>
</td></tr>
<tr><td><code id="heatmapplot_+3A_addvals">addvals</code></td>
<td>
<p>add the response values to the plot</p>
</td></tr>
<tr><td><code id="heatmapplot_+3A_addn">addN</code></td>
<td>
<p>add the sample size to the plot</p>
</td></tr>
<tr><td><code id="heatmapplot_+3A_digits">digits</code></td>
<td>
<p>numeric: if response variable is plotted, round to this many digits (default is 1)</p>
</td></tr>
<tr><td><code id="heatmapplot_+3A_...">...</code></td>
<td>
<p>other parameters passed on to plot() or text()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xdata &lt;- expand.grid(a = seq(0, 1, 0.1), b = seq(10, 20, 1))
xdata$resp &lt;- rnorm(nrow(xdata))
heatmapplot(resp ~ a + b, data = xdata)

set.seed(123)
xdata &lt;- expand.grid(k = seq(8, 200, length.out = 31), shape = seq(0, 1, length.out = 31))
idata &lt;- randomsequence(10, 50, reversals = 0.3)
allids &lt;- colnames(idata$pres)[2:ncol(idata$pres)]
winner &lt;- as.character(idata$seqdat$winner)
loser &lt;- as.character(idata$seqdat$loser)

myranks &lt;- 1:length(allids)
names(myranks) &lt;- allids

for(i in 1:nrow(xdata)) {
  kv &lt;- rep(xdata$k[i], length(winner))
  sv &lt;- createstartvalues(ranks = myranks, shape = xdata$shape[i])$res
  res &lt;- fastelo(WINNER = winner, LOSER = loser, ALLIDS = allids, KVALS = kv, STARTVALUES = sv,
                 ROUND = FALSE)
  xdata$ll[i] &lt;- likelo(res)
}

heatmapplot(ll ~ k + shape, data = xdata)
</code></pre>

<hr>
<h2 id='incontable'>number and strength of inconsistencies</h2><span id='topic+incontable'></span>

<h3>Description</h3>

<p>calculate number and strength of inconsistencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incontable(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incontable_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix with winner in rows and losers in columns, for example the output from <code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with inconsistencies and their strength
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>de Vries H (1998).
&ldquo;Finding a dominance order most consistent with a linear hierarchy: a new procedure and review.&rdquo;
<em>Animal Behaviour</em>, <b>55</b>, 827-843.
<a href="https://doi.org/10.1006/anbe.1997.0708">doi:10.1006/anbe.1997.0708</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
incontable(bonobos)

</code></pre>

<hr>
<h2 id='individuals'>individuals present in the group</h2><span id='topic+individuals'></span>

<h3>Description</h3>

<p>returns IDs, number or IDs, or CV of number of present individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>individuals(
  eloobject,
  from = eloobject$misc["maxDate"],
  to = NULL,
  outp = c("N", "IDs", "CV")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="individuals_+3A_eloobject">eloobject</code></td>
<td>
<p>result from <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="individuals_+3A_from">from</code></td>
<td>
<p>character, from which date onwards should the ID statistics be calculated. By default the first date in the sequence is used</p>
</td></tr>
<tr><td><code id="individuals_+3A_to">to</code></td>
<td>
<p>character, until which date should the ID statistics be calculated. By default <code>NULL</code>, i.e. the returned information refers to only the date specified by <code>from</code></p>
</td></tr>
<tr><td><code id="individuals_+3A_outp">outp</code></td>
<td>
<p>character, one of three options to determine which kind of information is returned: (1) <code>"N"</code>: the (average) number of individuals present, (2) <code>"IDs"</code>: the actual IDs, and (3): <code>"CV"</code>: coefficient of number of individuals present</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>to=NULL</code>, either the IDs (<code>outp="IDs"</code>) or the number of individuals (<code>outp="N"</code>) present on this day is returned. <code>outp="CV"</code> is not defined in such a case (returns <code>NA</code>).
</p>
<p>if a <code>to</code> date is set (i.e. different from <code>NULL</code>), either the IDs of all individuals that were present on at least one day of the date range (<code>outp="IDs"</code>) is returned or the average number of individuals present during this time (<code>outp="N"</code>). If <code>outp="CV"</code>, the coefficient of variation of the number of individuals present is returned, which might be considererd another measure of stability on the group level.
</p>


<h3>Value</h3>

<p>numeric or character
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date)
individuals(SEQ, outp = "N")
individuals(SEQ, outp = "IDs")
individuals(SEQ, outp = "CV") # not defined

# consider additional presence information
data(advpres)
SEQ &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date,
               presence = advpres)
individuals(SEQ, outp = "N")
individuals(SEQ, outp = "IDs")
individuals(SEQ, outp = "CV") # not defined

# across a date range
individuals(SEQ, from = "2010-01-01", to = "2010-01-31", outp = "N")
individuals(SEQ, from = "2010-01-01", to = "2010-01-31", outp = "IDs")
individuals(SEQ, from = "2010-01-01", to = "2010-01-31", outp = "CV")
</code></pre>

<hr>
<h2 id='ISI'>de Vries' I&amp;SI ranking</h2><span id='topic+ISI'></span>

<h3>Description</h3>

<p>de Vries' I&amp;SI ranking
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISI(mat, runs = 5000, printmessages = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISI_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix with winner in rows and losers in columns, for example the output from <code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
<tr><td><code id="ISI_+3A_runs">runs</code></td>
<td>
<p>numeric, number of iterations, by default <code>5000</code></p>
</td></tr>
<tr><td><code id="ISI_+3A_printmessages">printmessages</code></td>
<td>
<p>logical, should the number of I and SI be printed (as well as a message if there is more than one solution). By default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of interations is set substantially higher than what was suggested in the de Vries' 1998 paper, because my algorithm here is less efficient.
</p>
<p>The I&amp;SI algorithm (c.f. de Vries 1998) does not necessarily result in a unique order (see example below). If such a case occurs, all (equally good) solutions are returned as a list.
</p>
<p>The function checks whether a <code>table</code> is supplied instead of a <code>matrix</code> and converts from table to matrix if possible (trying to keep the column and row names if supplied in the table).
</p>
<p>If the matrix does not have column-names, unique column- and row-names are assigned.
</p>


<h3>Value</h3>

<p>a list with the best possible matrix (or matrices if there is more than one best solution)
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>de Vries H (1998).
&ldquo;Finding a dominance order most consistent with a linear hierarchy: a new procedure and review.&rdquo;
<em>Animal Behaviour</em>, <b>55</b>, 827-843.
<a href="https://doi.org/10.1006/anbe.1997.0708">doi:10.1006/anbe.1997.0708</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ISIranks">ISIranks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(devries98)
 h.index(devries98)
 ISI(devries98)

 ##
 data(adv)
 SEQ &lt;- elo.seq(winner=adv$winner, loser=adv$loser, Date=adv$Date)
 mat &lt;- creatematrix(SEQ)
 res &lt;- ISI(mat)
 # note that this matrix is not sufficiently linear to justify such ordering
 h.index(mat)

</code></pre>

<hr>
<h2 id='ISIranks'>ISI ranks</h2><span id='topic+ISIranks'></span>

<h3>Description</h3>

<p>ISI ranks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ISIranks(x, sortbyID = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ISIranks_+3A_x">x</code></td>
<td>
<p>a list of matrices, with the same column names, typically the output of <code><a href="#topic+ISI">ISI</a></code></p>
</td></tr>
<tr><td><code id="ISIranks_+3A_sortbyid">sortbyID</code></td>
<td>
<p>logical, should the output be sorted by ID (default is <code>TRUE</code>). If <code>FALSE</code>, output is sorted by (average rank)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if there is more than one solution resulting from <code><a href="#topic+ISI">ISI</a></code>, average (mean) ranks will be calculated. If there is only one solution, the average rank will be the same as the rank from the (one) ISI ranking
</p>


<h3>Value</h3>

<p>a data.frame with at least three columns: IDs, their average rank and the rankings of all rankings that satisfy ISI's minimum criteria
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no unique solution
data(adv)
mat &lt;- creatematrix(winners = adv$winner, losers = adv$loser)
set.seed(123)
res &lt;- ISI(mat)
ISIranks(res)
ISIranks(res, sortbyID = FALSE)

# only one (and unique) solution
data(bonobos)
set.seed(123)
res &lt;- ISI(bonobos)
ISIranks(res)
ISIranks(res, sortbyID = FALSE)
</code></pre>

<hr>
<h2 id='lastdaypresent'>last day an individual was present</h2><span id='topic+lastdaypresent'></span>

<h3>Description</h3>

<p>last day an individual was present with respect to a reference date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lastdaypresent(x, ID = "all", refdate = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lastdaypresent_+3A_x">x</code></td>
<td>
<p>output from <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="lastdaypresent_+3A_id">ID</code></td>
<td>
<p>character, if <code>"all"</code>, all individuals are returned, otherwise only for the desired ID</p>
</td></tr>
<tr><td><code id="lastdaypresent_+3A_refdate">refdate</code></td>
<td>
<p>character or Date (YYYY-MM-DD), up to which date the presence data should be considered, by default the last date of the sequene</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the function can result in <code>NA</code> for two reasons. 1) the ID is not found in the presence data, which is accompanied by a warning and 2) the ID was not yet present if a referene date is specified
</p>


<h3>Value</h3>

<p>Date or <code>NA</code>
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
data(advpres)
SEQ &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date,
               presence = advpres)
lastdaypresent(SEQ, ID = "all", refdate = "2010-01-02")
lastdaypresent(SEQ, ID = "f", refdate = "2010-02-02")
</code></pre>

<hr>
<h2 id='likelo'>(log) likelihood of Elo-rating model</h2><span id='topic+likelo'></span>

<h3>Description</h3>

<p>(log) likelihood of Elo-rating model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelo(eloobject, burnin = 0, ll = TRUE, daterange = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likelo_+3A_eloobject">eloobject</code></td>
<td>
<p>output from <code><a href="#topic+elo.seq">elo.seq</a></code> (or from <code><a href="#topic+fastelo">fastelo</a></code>)</p>
</td></tr>
<tr><td><code id="likelo_+3A_burnin">burnin</code></td>
<td>
<p>numeric, the number of interactions to be excluded from the calculation of the (log) likelihood. This parameter is ignored if a date range is supplied. By default <code>burnin = 0</code>, i.e. all interactions are considered.</p>
</td></tr>
<tr><td><code id="likelo_+3A_ll">ll</code></td>
<td>
<p>logical, should the log likelihood be returned rather than the likelihood, by default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="likelo_+3A_daterange">daterange</code></td>
<td>
<p>character or Date of length 2, gives the date range for which likelihood should be calculated. By default, the entire date range of all interactions is considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the (log) likelihood of a dominance interaction sequence. The likelihood is the product of all winning probabilities (for each interaction).
</p>


<h3>Value</h3>

<p>numeric of length 1, the (log) likelihood
</p>


<h3>References</h3>

<p>Franz M, McLean E, Tung J, Altmann J, Alberts SC (2015).
&ldquo;Self-organizing dominance hierarchies in a wild primate population.&rdquo;
<em>Proceedings of the Royal Society B: Biological Sciences</em>, <b>282</b>, 20151512.
<a href="https://doi.org/10.1098/rspb.2015.1512">doi:10.1098/rspb.2015.1512</a>.
</p>
<p>McMahan CA, Morris MD (1984).
&ldquo;Application of maximum likelihood paired comparison ranking to estimation of a linear dominance hierarchy in animal societies.&rdquo;
<em>Animal Behaviour</em>, <b>32</b>, 374-378.
<a href="https://doi.org/10.1016/S0003-3472%2884%2980271-7">doi:10.1016/S0003-3472(84)80271-7</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
res &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date, k = 200)
likelo(res)
res &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date, k = 100)
likelo(res)
ks &lt;- seq(100, 400, by = 20)
liks &lt;- numeric(length(ks))
for(i in 1:length(liks)) {
  liks[i] &lt;- likelo(elo.seq(winner = adv$winner, loser = adv$loser,
                    Date = adv$Date, k = ks[i]))
}
plot(ks, liks, type = "l")

# discard early interactions via 'burnin'
likelo(res)
# the same as above:
likelo(res, burnin = 0)
# discard the first 10 interactions:
likelo(res, burnin = 10)
# discard all but the last interaction:
likelo(res, burnin = 32)
# which is the same as the log of the last winning probability:
log(winprob(res$logtable$Apre[33], res$logtable$Bpre[33]))
</code></pre>

<hr>
<h2 id='mat2seq'>matrix to sequence conversion</h2><span id='topic+mat2seq'></span><span id='topic+mat2seqint'></span>

<h3>Description</h3>

<p>matrix to sequence conversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2seq(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mat2seq_+3A_mat">mat</code></td>
<td>
<p>square interaction matrix with winner in rows and losers in columns (can have column/row names or not)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with a winner and a loser column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(c(0,1,1,0,0,1,0,0,0), ncol=3, byrow = TRUE)
rownames(mat) &lt;- colnames(mat) &lt;- LETTERS[1:3]
mat2seq(mat)

mat &lt;- matrix(c(0,1,1,0,0,1,3,0,0), ncol=3, byrow = TRUE)
rownames(mat) &lt;- colnames(mat) &lt;- LETTERS[1:3]
mat2seq(mat)

# without column names
mat &lt;- matrix(c(0,1,1,0,0,1,0,0,0), ncol=3, byrow = TRUE)
mat2seq(mat)

</code></pre>

<hr>
<h2 id='optimizek'>optimize the k parameter</h2><span id='topic+optimizek'></span>

<h3>Description</h3>

<p>optimize the k parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizek(
  eloobject,
  krange = c(2, 400),
  optimode = "loop",
  resolution = 100,
  itype = NULL,
  daterange = NULL,
  burnin = 0,
  doplot = FALSE,
  progbar = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimizek_+3A_eloobject">eloobject</code></td>
<td>
<p>output from <code><a href="#topic+elo.seq">elo.seq</a></code> or from <code><a href="#topic+fastelo">fastelo</a></code></p>
</td></tr>
<tr><td><code id="optimizek_+3A_krange">krange</code></td>
<td>
<p>either a vector of length 2, giving the range of k values to be tested, or a named list with vectors of length 2, in which each list item is named according to different interaction types (see the <code>intensity=</code> argument in <code><a href="#topic+elo.seq">elo.seq</a></code>)</p>
</td></tr>
<tr><td><code id="optimizek_+3A_optimode">optimode</code></td>
<td>
<p>character, either <code>"loop"</code> or <code>"optimize"</code>. See details.</p>
</td></tr>
<tr><td><code id="optimizek_+3A_resolution">resolution</code></td>
<td>
<p>numeric, the number of steps between the range of k values to be tested. Currently only a single value can be supplied here and in case <code>krange</code> is a list this value will be applied to all items in this list</p>
</td></tr>
<tr><td><code id="optimizek_+3A_itype">itype</code></td>
<td>
<p>character or factor containing the different interaction types, which is only relevant if <code>krange</code> is a list. The content of <code>itype</code> and the names of <code>krange</code> have to match!</p>
</td></tr>
<tr><td><code id="optimizek_+3A_daterange">daterange</code></td>
<td>
<p>character or Date of length 2, provides a date range for optimization. Only relevant in case <code>eloobject</code> is the result of <code>elo.seq()</code></p>
</td></tr>
<tr><td><code id="optimizek_+3A_burnin">burnin</code></td>
<td>
<p>numeric, the number of interactions to be excluded from the calculation of the (log) likelihood. This parameter is ignored if a date range is supplied. By default <code>burnin = 0</code>, i.e. all interactions are considered.</p>
</td></tr>
<tr><td><code id="optimizek_+3A_doplot">doplot</code></td>
<td>
<p>logical, should a plot be returned. Works only if <code>optimode = "loop"</code>, and only if there are maximally two different interaction types</p>
</td></tr>
<tr><td><code id="optimizek_+3A_progbar">progbar</code></td>
<td>
<p>logical, should a progress bar be displayed, not yet implemented</p>
</td></tr>
<tr><td><code id="optimizek_+3A_...">...</code></td>
<td>
<p>additional arguments for the plot and text functions, e.g. for setting <code>cex</code> or <code>lwd</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function attempts to find the objectively best k parameter. This is done by a maximum likelihood approach in which the likelihood is represented by the individual winning probabilities. In a perfect situation, in each interaction the winner would have a winning probability of 1, whereas in the worst case, in each interaction the winner would have a winning probability of 0.
</p>
<p>There are two major approaches to find the best k. One does it 'by hand', i.e. by means of a loop trying many different k values (specified by <code>resolution</code>), recalculating the ratings (and associated winning probabilities) and return the likelihood for each k value. The second approach uses the <code>optimize</code> function, but this is not yet implemented.
</p>
<p>One thing to note is that you can use interaction-level k values, i.e. if you have interactions of different types (e.g. fights vs. displacements) you can try to find the optimal k for each interaction type. This is achieved in the (<code>"loop"</code> approach by trying different <em>combinations</em> of k values. Because of the combinatorial nature of this approach, the number of individual sequences to be fitted increases sharply with higher resolutions: if you have two different interaction types and use a resolution of 5, the function will need to run 25 (= 5 * 5) iterations. If you use a more reasonable resolution of 100 the number of iterations will be already 10000. Also note that in that case the actual plotting of the results might take a lot of time in such cases. Just try with low values first to see whether it works as expected and the potentially increase the resolution.
</p>


<h3>Value</h3>

<p>a list with two items: (1) <code>$best</code>, a data frame with one line, in which the maximal log likelihood is returned alongside the one or several corresponding k values, and (2) <code>$complete</code>, a data frame with all the values tested and their log likelihoods
</p>


<h3>References</h3>

<p>Franz M, McLean E, Tung J, Altmann J, Alberts SC (2015).
&ldquo;Self-organizing dominance hierarchies in a wild primate population.&rdquo;
<em>Proceedings of the Royal Society B: Biological Sciences</em>, <b>282</b>, 20151512.
<a href="https://doi.org/10.1098/rspb.2015.1512">doi:10.1098/rspb.2015.1512</a>.
</p>
<p>McMahan CA, Morris MD (1984).
&ldquo;Application of maximum likelihood paired comparison ranking to estimation of a linear dominance hierarchy in animal societies.&rdquo;
<em>Animal Behaviour</em>, <b>32</b>, 374-378.
<a href="https://doi.org/10.1016/S0003-3472%2884%2980271-7">doi:10.1016/S0003-3472(84)80271-7</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv2)
res &lt;- elo.seq(winner = adv2$winner, loser = adv2$loser, Date = adv2$Date)
optimizek(eloobject = res, krange = c(50, 400), resolution = 200, doplot = TRUE)$best

# with a burnin value set:
optimizek(eloobject = res, krange = c(50, 400), resolution = 200, burnin = 15, doplot = TRUE)$best

# using different interaction intensities
myks &lt;- list(displace = 20, fight = 200)
res &lt;- elo.seq(winner = adv2$winner, loser = adv2$loser, Date = adv2$Date,
               k = myks, intensity = adv2$intensity)
optimizek(eloobject = res, optimode = "loop",
          krange = list(fight = c(50, 600), displace = c(20, 200)),
          resolution = 100, itype = adv2$intensity, main = 'bla')$best
</code></pre>

<hr>
<h2 id='optistart'>optimize start values</h2><span id='topic+optistart'></span>

<h3>Description</h3>

<p>experimental function to test different sets of randomly selected start
values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optistart(
  eloobject,
  burnin = 0,
  spread = 200,
  runs = 2000,
  doplot = FALSE,
  initialcohort = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optistart_+3A_eloobject">eloobject</code></td>
<td>
<p>output from <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="optistart_+3A_burnin">burnin</code></td>
<td>
<p>numeric, the number of interactions to be excluded from the
calculation of the (log) likelihood. This parameter is ignored if a
date range is supplied. By default <code>burnin = 0</code>, i.e. all
interactions are considered.</p>
</td></tr>
<tr><td><code id="optistart_+3A_spread">spread</code></td>
<td>
<p>numeric, the standard deviation of the ratings to be tested
(by default 200)</p>
</td></tr>
<tr><td><code id="optistart_+3A_runs">runs</code></td>
<td>
<p>numeric, number of inital ratings to be tested (by default 2000)</p>
</td></tr>
<tr><td><code id="optistart_+3A_doplot">doplot</code></td>
<td>
<p>logical, should the distribution of log likelihoods be plotted</p>
</td></tr>
<tr><td><code id="optistart_+3A_initialcohort">initialcohort</code></td>
<td>
<p>logical, not yet implemented</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if the plot is produced, the red line indicates the log-likelihood
when all individuals are assigned the same starting value
</p>
<p>the item <code>$best</code> reflects the optimal start values found
</p>


<h3>Value</h3>

<p>a list with multiple items:
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
xdata &lt;- randomsequence(8, 100)$seqdat
res1 &lt;- elo.seq(xdata$winner, xdata$loser, xdata$Date)
ores &lt;- optistart(res1)
res2 &lt;- elo.seq(xdata$winner, xdata$loser, xdata$Date, startvalue = ores$best)
eloplot(res1)
eloplot(res2)
</code></pre>

<hr>
<h2 id='presence_summary'>Summarize presence data</h2><span id='topic+presence_summary'></span>

<h3>Description</h3>

<p>Summarize presence data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presence_summary(presence, from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="presence_summary_+3A_presence">presence</code></td>
<td>
<p>a data.frame with one date column (needs to be named &quot;Date&quot;) and columns for each individual with 0/1 indicating absence/presence of that individual on that date</p>
</td></tr>
<tr><td><code id="presence_summary_+3A_from">from</code></td>
<td>
<p>character indicating the beginning of the period to be considered (by default the first date in the Date column)</p>
</td></tr>
<tr><td><code id="presence_summary_+3A_to">to</code></td>
<td>
<p>character indicating the end of the period to be considered (by default the last date in the Date column)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an individual left and/or joined multiple times, this will be indicated by the <code>stint</code> column.
</p>
<p>The <code>init</code> column marks those individuals that were present on the beginning of the period considered.
</p>


<h3>Value</h3>

<p>a data.frame with entries for each individual indicating the first and last dates of their stays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(advpres)
presence_summary(advpres)

presence_summary(advpres, from = "2010-01-27", to = "2010-02-02")
</code></pre>

<hr>
<h2 id='print.elo'>prints its argument</h2><span id='topic+print.elo'></span>

<h3>Description</h3>

<p>prints its argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elo'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.elo_+3A_x">x</code></td>
<td>
<p>result from <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="print.elo_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- elo.seq(winner=adv$winner, loser=adv$loser, Date=adv$Date)
print(SEQ)
</code></pre>

<hr>
<h2 id='print.seqchecknopres'>prints its argument</h2><span id='topic+print.seqchecknopres'></span>

<h3>Description</h3>

<p>prints its argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqchecknopres'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.seqchecknopres_+3A_x">x</code></td>
<td>
<p>result from <code><a href="#topic+seqcheck">seqcheck</a></code></p>
</td></tr>
<tr><td><code id="print.seqchecknopres_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
print(seqcheck(winner = adv$winner, loser = adv$loser, Date = adv$Date))
</code></pre>

<hr>
<h2 id='print.sequencecheck'>prints its argument</h2><span id='topic+print.sequencecheck'></span>

<h3>Description</h3>

<p>prints its argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sequencecheck'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sequencecheck_+3A_x">x</code></td>
<td>
<p>result from <code><a href="#topic+seqcheck">seqcheck</a></code></p>
</td></tr>
<tr><td><code id="print.sequencecheck_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (ignored here)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
data(advpres)
print(seqcheck(winner = adv$winner, loser = adv$loser, Date = adv$Date,
                 presence = advpres))
</code></pre>

<hr>
<h2 id='prunk'>unknown relationships</h2><span id='topic+prunk'></span>

<h3>Description</h3>

<p>unknown relationships
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prunk(eloobject, daterange = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prunk_+3A_eloobject">eloobject</code></td>
<td>
<p>output from <code><a href="#topic+elo.seq">elo.seq</a></code> or a matrix, e.g. from <code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
<tr><td><code id="prunk_+3A_daterange">daterange</code></td>
<td>
<p>date range to be considered (character or Date of length 2), by default considers the entire date range of the sequence. In case the function works on a matrix this is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, proportion of unknown relationships (and total N) when considering all possible dyads, and the same after accounting for co-residency. For matrices, considering co-residency is ignored.
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv); data(advpres)
x &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date, presence = advpres)
prunk(x, c("2010-01-01", "2010-01-15"))
mat &lt;- creatematrix(x, c("2010-01-01", "2010-01-15"))
prunk(mat)
</code></pre>

<hr>
<h2 id='randomelo'>calculate Elo ratings from an interaction matrix</h2><span id='topic+randomelo'></span>

<h3>Description</h3>

<p>calculate Elo ratings from an interaction matrix based on randomly
generated sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomelo(
  interactionmatrix,
  runs = 2000,
  normprob = TRUE,
  k = 100,
  progressbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomelo_+3A_interactionmatrix">interactionmatrix</code></td>
<td>
<p>square interaction matrix with winner in rows and
losers in columns, for example the output from
<code><a href="#topic+creatematrix">creatematrix</a></code></p>
</td></tr>
<tr><td><code id="randomelo_+3A_runs">runs</code></td>
<td>
<p>number of randomly generated sequences based on the interactions
in the <code>interactionmatrix</code></p>
</td></tr>
<tr><td><code id="randomelo_+3A_normprob">normprob</code></td>
<td>
<p>logical (by default <code>TRUE</code>). Should a normal curve be
assumed for calculating the winning/losing probablities, or a logistic
curve. See <code><a href="#topic+winprob">winprob</a></code> for details</p>
</td></tr>
<tr><td><code id="randomelo_+3A_k">k</code></td>
<td>
<p>numeric, factor <em>k</em> that determines the maximum change in
ratings. By default <code>k=100</code></p>
</td></tr>
<tr><td><code id="randomelo_+3A_progressbar">progressbar</code></td>
<td>
<p>logical, should progress bars be displayed, by default
<code>progressbar=TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of length 2. The first element contains a matrix with the final
rating of each individual from each random sequence. IDs are in the columns,
each run is represented as one row. The second element of the list contains
the original interaction matrix.
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
elores &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date)
mat &lt;- creatematrix(elores)
res &lt;- randomelo(mat, 10)
data.frame(ID = colnames(res[[1]]), avg = round(colMeans(res[[1]]), 1))
</code></pre>

<hr>
<h2 id='randomeloextract'>extract ratings from random sequences based on an interaction matrix</h2><span id='topic+randomeloextract'></span>

<h3>Description</h3>

<p>extract ratings from random sequences based on an interaction matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomeloextract(x, ID, mode = c("obj", "samp", "avg"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomeloextract_+3A_x">x</code></td>
<td>
<p>output from <code><a href="#topic+randomelo">randomelo</a></code></p>
</td></tr>
<tr><td><code id="randomeloextract_+3A_id">ID</code></td>
<td>
<p>character, ID</p>
</td></tr>
<tr><td><code id="randomeloextract_+3A_mode">mode</code></td>
<td>
<p>character, one of three: 1) <code>"obj"</code>: a random value from all
the sequences; 2) <code>"samp"</code>: a random value sampled from a normal
distribution with mean and sd of all randomized values; 3)
<code>"avg"</code>: the average value from all the runs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
elores &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date)
mat &lt;- creatematrix(elores)
res &lt;- randomelo(mat, runs = 10)
randomeloextract(res, "a", "samp")
randomeloextract(res, "a", "obj")
randomeloextract(res, "a", "avg")
</code></pre>

<hr>
<h2 id='randomsequence'>random dominance interaction sequence</h2><span id='topic+randomsequence'></span>

<h3>Description</h3>

<p>create a random dominance sequence for testing or simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomsequence(
  nID = 10,
  avgIA = 20,
  startdate = as.Date("2000-01-01"),
  alphabet = TRUE,
  reversals = 0.1,
  ties = NULL,
  presence = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomsequence_+3A_nid">nID</code></td>
<td>
<p>integer, number of IDs, must be less than 2601</p>
</td></tr>
<tr><td><code id="randomsequence_+3A_avgia">avgIA</code></td>
<td>
<p>numeric, average number of interactions an individual is involved in</p>
</td></tr>
<tr><td><code id="randomsequence_+3A_startdate">startdate</code></td>
<td>
<p>character, a start date, by default <code>"2000-01-01"</code></p>
</td></tr>
<tr><td><code id="randomsequence_+3A_alphabet">alphabet</code></td>
<td>
<p>logical, should the individual within an interaction that comes first in alphabetical order be the winner? By default <code>TRUE</code>, which gives some orderliness in the hierarchy</p>
</td></tr>
<tr><td><code id="randomsequence_+3A_reversals">reversals</code></td>
<td>
<p>numeric, proportion of interactions that ends in reversed outcomes, i.e. the initial winner (if <code>alphabet=TRUE) the first according to alphanumeric order</code>) is changed into the loser. By default <code>0.1</code></p>
</td></tr>
<tr><td><code id="randomsequence_+3A_ties">ties</code></td>
<td>
<p>numeric, proportion of interactions that ends undecided</p>
</td></tr>
<tr><td><code id="randomsequence_+3A_presence">presence</code></td>
<td>
<p>numeric vector of length 2. The first value indicates what proportion of individuals are absent for some time. The second value indicates the proportion of time (days) these individuals are absent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>randomsequence</code>, which is a list with the following items:
</p>
<table role = "presentation">
<tr><td><code>seqdat</code></td>
<td>
<p>an interaction sequence</p>
</td></tr>
<tr><td><code>pres</code></td>
<td>
<p>a presence matrix, actually a <code>data.frame</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IA &lt;- randomsequence()
SEQ &lt;- elo.seq(winner = IA$seqdat$winner, loser = IA$seqdat$loser, Date = IA$seqdat$Date,
               runcheck = FALSE, progressbar = FALSE)
stab_elo(SEQ)
#
IA &lt;- randomsequence(presence = c(0.5, 0.5))
SEQ &lt;- elo.seq(winner = IA$seqdat$winner, loser = IA$seqdat$loser, Date = IA$seqdat$Date,
               presence = IA$pres, runcheck = FALSE, progressbar = FALSE)
stab_elo(SEQ)

</code></pre>

<hr>
<h2 id='scale_elo'>standardize Elo ratings</h2><span id='topic+scale_elo'></span><span id='topic+scale.elo'></span>

<h3>Description</h3>

<p>standardize Elo ratings between 0 and 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_elo(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_elo_+3A_x">x</code></td>
<td>
<p>numeric, a vector of Elo ratings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of Elo ratings, which are scaled between 0 and 1, with the highest rating that is supplied becoming 1, the lowest becoming 0, and all others being proportionally scaled in between
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- elo.seq(winner=adv$winner, loser=adv$loser, Date=adv$Date)
extract_elo(SEQ, "2010-01-30")
extract_elo(SEQ, "2010-01-30", standardize=TRUE)

# same as
scale_elo(extract_elo(SEQ, "2010-01-30"))
</code></pre>

<hr>
<h2 id='seqcheck'>runs raw data diagnostics for Elo rating</h2><span id='topic+seqcheck'></span>

<h3>Description</h3>

<p>runs some diagnostics on the data supplied to <a href="#topic+elo.seq">elo.seq</a>, to check whether <a href="#topic+elo.seq">elo.seq</a> will run without errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqcheck(winner, loser, Date, draw = NULL, presence = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqcheck_+3A_winner">winner</code></td>
<td>
<p>either a factor or character vector with winner IDs of dyadic dominance interactions</p>
</td></tr>
<tr><td><code id="seqcheck_+3A_loser">loser</code></td>
<td>
<p>either a factor or character vector with loser IDs of dyadic dominance interactions</p>
</td></tr>
<tr><td><code id="seqcheck_+3A_date">Date</code></td>
<td>
<p>character vector of form &quot;YYYY-MM-DD&quot; with the date of the respective interaction</p>
</td></tr>
<tr><td><code id="seqcheck_+3A_draw">draw</code></td>
<td>
<p>logical, which interactions ended undecided (i.e. drawn or tied)? By default all <code>FALSE</code>, i.e. no undecided interactions occurred. Note that in this case, <code>winner</code>/<code>loser</code> values can be interchanged</p>
</td></tr>
<tr><td><code id="seqcheck_+3A_presence">presence</code></td>
<td>
<p>optional data.frame, to supply data about presence and absence of individuals for part of the time the data collection covered. see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>calender dates (for the sequence as well as in the first column of <code>presence</code>, if supplied) need to be in &quot;YYYY-MM-DD&quot; format!
</p>
<p><code>seqcheck</code> will return two types of messages: warnings and errors. Errors will result in the data NOT working when supplied to <code>elo.seq</code>, and need to be fixed. Warning message do not necessarily lead to failure of executing <code>elo.seq</code>. Note that by default <code>seqcheck</code> is part of <code>elo.seq</code>. If any error or warning is produced by <code>seqcheck</code>, these data will not work in <code><a href="#topic+elo.seq">elo.seq</a></code>. Some warning (but not error) messages can be ignored (see below) and if the <code>runcheck</code> argument in <code>elo.seq</code> is set to <code>FALSE</code> Elo-ratings will be calculated properly in such cases.
</p>
<p>The actual checks (and corresponding messages) that are performed are described in more detail here:
</p>
<p>Most likely (i.e. in our experience), problems are caused by mismatches between the interaction data and the corresponding presence data.
</p>
<p>Errors:<br />
<code>Presence starts AFTER data</code>: indicates that during interactions at the beginning of the sequence, no corresponding information was found in the presence data. Solution: augment presence data, or remove interactions until the date on which presence data starts
</p>
<p><code>Presence stops BEFORE data</code>: refers to the corresponding problem towards the end of interaction and presence data
</p>
<p><code>During the following interactions, IDs were absent...</code>: indicates that according to the presence data, IDs were absent (i.e. &quot;0&quot;), but interactions with them occured on the very date(s) according to the interaction data
</p>
<p><code>The following IDs occur in the data sequence but NOT...</code>: there is/are no columns corresponding to the listed IDs in the presence data
</p>
<p><code>There appear to be gaps in your presence (days missing?)...</code>: check whether your presence data includes a line for <em>each date</em> starting from the date of the first interaction through to the date of the last interaction
</p>
<p>Warnings:
</p>
<p><code>Presence continues beyond data</code>: indicates that presence and interaction data do not end on the same date.
</p>
<p><code>Presence starts earlier than data</code>: indicates that presence and interaction data do not start on the same date.
</p>
<p><code>The following IDs occur in the presence data but NOT...</code>: there are more ID columns in the presence data than IDs occuring in the interaction data
</p>
<p><code>Date column is not ordered</code>: The dates are not supplied in ascending order. <code><a href="#topic+elo.seq">elo.seq</a></code> will still work but the results won't be reliable because the interactions were not in the correct sequence.
</p>
<p>Other warnings/errors can result from inconsistencies in either the presence or sequence data, or be of a more general nature:
</p>
<p>Errors:
</p>
<p><code>No 'Date' column found</code>: in the presence data, no column exists with the name/header &quot;Date&quot;. Please rename (or add) the necessary column named &quot;Date&quot; to your presence data.
</p>
<p><code>At least one presence entry is not 1 or 0</code>: presence data must come in binary form, i.e. an ID was either present (&quot;1&quot;) or absent (&quot;0&quot;) on a given date. No <code>NA</code>s or other values are allowed.
</p>
<p><code>Your data vectors do not match in length</code>: at least one of the three mandatory arguments (winner, loser, Date) differs from one other in length. Consider handling your data in a data.frame, which avoids this error.
</p>
<p>Warnings:
</p>
<p><code>IDs occur in the data with inconsistent capitalization</code>: because <code>R</code> is case-sensitive, &quot;A&quot; and &quot;a&quot; are considered different individuals. If such labelling of IDs is on purpose, ignore the warning and set <code>runcheck=FALSE</code> when calling <code>elo.seq()</code>
</p>
<p><code>There is (are) X case(s) in which loser ID equals winner ID</code>: winner and loser represent the same ID
</p>
<p><code>The following individuals were observed only on one day</code>: while not per se a problem for the calculation of Elo ratings, individuals that were observed only on one day (irrespective of the number of interactions on that day) cannot be plotted. <code><a href="#topic+eloplot">eloplot</a></code> will give a warning in such cases, too.
</p>


<h3>Value</h3>

<p>returns textual information about possible issues with the supplied data set, or states that data are fine for running with <code><a href="#topic+elo.seq">elo.seq</a></code>
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
seqcheck(winner = adv$winner, loser = adv$loser, Date = adv$Date)
data(advpres)
seqcheck(winner = adv$winner, loser = adv$loser, Date = adv$Date,
         presence = advpres)

# create faulty presence data
# remove one line from presence data
faultypres &lt;- advpres[-1, ]
# make all individuals absent on one day
faultypres[5, 2:8] &lt;- 0
# run check
seqcheck(winner = adv$winner, loser = adv$loser, Date = adv$Date,
         presence = faultypres)

# fix first error
faultypres &lt;- rbind(faultypres[1, ], faultypres)
faultypres$Date[1] &lt;- "2010-01-01"

# run check again
seqcheck(winner = adv$winner, loser = adv$loser, Date = adv$Date,
         presence = faultypres)

# fix presence on date for interaction number 6
faultypres[6, 2:8] &lt;- 1

# run check again
seqcheck(winner = adv$winner, loser = adv$loser, Date = adv$Date,
         presence = faultypres)
# all good now
</code></pre>

<hr>
<h2 id='simple_dom'>simple dominance indices</h2><span id='topic+simple_dom'></span>

<h3>Description</h3>

<p>simple dominance indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_dom(winner, loser, Date = NULL, daterange = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simple_dom_+3A_winner">winner</code></td>
<td>
<p>character or factor with winner</p>
</td></tr>
<tr><td><code id="simple_dom_+3A_loser">loser</code></td>
<td>
<p>character or factor with winner</p>
</td></tr>
<tr><td><code id="simple_dom_+3A_date">Date</code></td>
<td>
<p>not yet implemented</p>
</td></tr>
<tr><td><code id="simple_dom_+3A_daterange">daterange</code></td>
<td>
<p>not yet implemented</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The indices that are calculated are the following
</p>

<dl>
<dt><code>winprop</code></dt><dd><p>the proportion of all interactions won</p>
</dd>
<dt><code>domover</code></dt><dd><p>the proportion of individuals dominated (regardless of whether any interactions may have occured, i.e. the number of individuals dominated is divided by N - 1 for all individuals)</p>
</dd>
<dt><code>domover_rel</code></dt><dd><p>the proportion of individuals dominated with which the focal interacted</p>
</dd>
</dl>



<h3>Value</h3>

<p>a data.frame with one row per individual and several 'simple' dominance indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xdata &lt;- randomsequence(nID = 10, avgIA = 20, reversals = 0.2)$seqdat
simple_dom(xdata$winner, xdata$loser)
</code></pre>

<hr>
<h2 id='stab_elo'>stability index <em>S</em></h2><span id='topic+stab_elo'></span><span id='topic+stab.elo'></span>

<h3>Description</h3>

<p>calculates the <em>S</em> index as metric for the overall stability of a hierarchy during a specified time period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stab_elo(
  eloobject,
  from = min(eloobject$stability$date),
  to = max(eloobject$stability$date),
  weight = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stab_elo_+3A_eloobject">eloobject</code></td>
<td>
<p>an object of class <code>"elo"</code>, usually the result of a call to <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="stab_elo_+3A_from">from</code></td>
<td>
<p>character, from which date onwards should <em>S</em> be calculated. By default the first date in the sequence is used</p>
</td></tr>
<tr><td><code id="stab_elo_+3A_to">to</code></td>
<td>
<p>character, until which date should <em>S</em> be calculated. By default the last date in the sequence is used</p>
</td></tr>
<tr><td><code id="stab_elo_+3A_weight">weight</code></td>
<td>
<p>logical, should single rank changes be weighted by the Elo rating of the highest-rated individual involved in a rank change? Default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>S</em> ranges between 0 and 1, where 0 indicates an unstable hierarchy, in which the ordering reverses every other day, and 1, in which the ordering is stable and no rank changes occur.
</p>
<p>In contrast to the originally proposed <em>S</em>, this version is now standardized between 0 and 1, and additionally, the interpretation is reversed, i.e. 1 refers to stable situations, whereas values closer to 0 indicate more instable hierarchies
</p>


<h3>Value</h3>

<p>returns the <em>S</em> index
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>Neumann C, Duboscq J, Dubuc C, Ginting A, Irwan AM, Agil M, Widdig A, Engelhardt A (2011).
&ldquo;Assessing dominance hierarchies: validation and advantages of progressive evaluation with elo-rating.&rdquo;
<em>Animal Behaviour</em>, <b>82</b>, 911-921.
<a href="https://doi.org/10.1016/j.anbehav.2011.07.016">doi:10.1016/j.anbehav.2011.07.016</a>.
</p>
<p>McDonald DB, Shizuka D (2013).
&ldquo;Comparative transitive and temporal orderliness in dominance networks.&rdquo;
<em>Behavioral Ecology</em>, <b>24</b>, 511-520.
<a href="https://doi.org/10.1093/beheco/ars192">doi:10.1093/beheco/ars192</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- elo.seq(winner=adv$winner, loser=adv$loser, Date=adv$Date)
stab_elo(SEQ)
stab_elo(SEQ, weight=FALSE)
stab_elo(SEQ, from="2010-01-20", to="2010-01-30")
stab_elo(SEQ, from="2010-01-20", to="2010-01-30", weight=FALSE)
</code></pre>

<hr>
<h2 id='steepness'>hierarchy steepness based on David's scores</h2><span id='topic+steepness'></span><span id='topic+steepint'></span>

<h3>Description</h3>

<p>hierarchy steepness based on David's scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steepness(mat, nrand = 0, Dij = TRUE, returnfig = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="steepness_+3A_mat">mat</code></td>
<td>
<p>square dominance matrix</p>
</td></tr>
<tr><td><code id="steepness_+3A_nrand">nrand</code></td>
<td>
<p>numeric, the number of runs for the randomization test</p>
</td></tr>
<tr><td><code id="steepness_+3A_dij">Dij</code></td>
<td>
<p>logical, by default <code>TRUE</code> i.e. corrected for number of interactions in a dyad, otherwise simple proportion of wins/losses</p>
</td></tr>
<tr><td><code id="steepness_+3A_returnfig">returnfig</code></td>
<td>
<p>logical, should a figure be produced that shows the distribution of expected steepness</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector, with the observed steepness, the expected steepness, p-value and the number of randomizations used
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>de Vries H, Stevens JMG, Vervaecke H (2006).
&ldquo;Measuring and testing the steepness of dominance hierarchies.&rdquo;
<em>Animal Behaviour</em>, <b>71</b>, 585-592.
<a href="https://doi.org/10.1016/j.anbehav.2005.05.015">doi:10.1016/j.anbehav.2005.05.015</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
steepness(bonobos) # no randomization test

# with randomization test
steepness(bonobos, nrand = 100)

</code></pre>

<hr>
<h2 id='summary.elo'>summarize elo object</h2><span id='topic+summary.elo'></span>

<h3>Description</h3>

<p>summarize elo object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'elo'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.elo_+3A_object">object</code></td>
<td>
<p>an object of class <code>"elo"</code>, usually the result of a call to <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="summary.elo_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (ignored)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IA &lt;- randomsequence()
SEQ &lt;- elo.seq(winner=IA$seqdat$winner, loser=IA$seqdat$loser,
               Date=IA$seqdat$Date, draw=IA$seqdat$Draw,
               presence=IA$pres)
summary(SEQ)
</code></pre>

<hr>
<h2 id='traj_elo'>calculate dominance trajectory</h2><span id='topic+traj_elo'></span>

<h3>Description</h3>

<p>calculate individual Elo rating trajectory over time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traj_elo(
  eloobject,
  ID,
  from = min(eloobject$stability$date),
  to = max(eloobject$stability$date)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traj_elo_+3A_eloobject">eloobject</code></td>
<td>
<p>result from <code><a href="#topic+elo.seq">elo.seq</a></code></p>
</td></tr>
<tr><td><code id="traj_elo_+3A_id">ID</code></td>
<td>
<p>character, the ID(s) of the individual(s)</p>
</td></tr>
<tr><td><code id="traj_elo_+3A_from">from</code></td>
<td>
<p>character, from which date onwards should the trajectory be calculated. By default the first date in the sequence is used</p>
</td></tr>
<tr><td><code id="traj_elo_+3A_to">to</code></td>
<td>
<p>character, until which date should the trajectory be calculated. By default the last date in the sequence is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with as many lines as specified in <code>ID</code>, columns for ID, date range, the actual slope (trajectory), and the number of observed interactions within the date range
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adv)
SEQ &lt;- elo.seq(winner = adv$winner, loser = adv$loser, Date = adv$Date)
traj_elo(SEQ, "a")

traj_elo(SEQ, "a", from = "2010-01-20", to = "2010-01-30")

# no slope available if ID was not observed interacting
# inside the date range
traj_elo(SEQ, "a", from = "2010-01-17", to = "2010-01-18")

# no slope available if ID was only observed interacting
# once within the date range
traj_elo(SEQ, "a", from = "2010-01-17", to = "2010-01-19")

# for several individuals
traj_elo(SEQ, c("a", "b", "c"))
</code></pre>

<hr>
<h2 id='transitivity'>triangle transitivity</h2><span id='topic+transitivity'></span>

<h3>Description</h3>

<p>triangle transitivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitivity(m, runs = 2000, returnfig = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transitivity_+3A_m">m</code></td>
<td>
<p>square dominance matrix</p>
</td></tr>
<tr><td><code id="transitivity_+3A_runs">runs</code></td>
<td>
<p>numeric, the number of runs for the randomization test</p>
</td></tr>
<tr><td><code id="transitivity_+3A_returnfig">returnfig</code></td>
<td>
<p>logical, should a figure be produced that shows the distribution of expectation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of length four
</p>


<h3>References</h3>

<p>Shizuka D, McDonald DB (2012).
&ldquo;A social network perspective on measurements of dominance hierarchies.&rdquo;
<em>Animal Behaviour</em>, <b>83</b>, 925-934.
<a href="https://doi.org/10.1016/j.anbehav.2012.01.011">doi:10.1016/j.anbehav.2012.01.011</a>.
</p>
<p><a href="https://shizukalab.com/r/triangle-transitivity-in-dominance-hierarchies-directed-graphs/">https://shizukalab.com/r/triangle-transitivity-in-dominance-hierarchies-directed-graphs/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bonobos)
transitivity(bonobos)
</code></pre>

<hr>
<h2 id='winprob'>expected winning probability</h2><span id='topic+winprob'></span>

<h3>Description</h3>

<p>calculate expected probability of winning given known strengths of two opponents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winprob(elo1, elo2, normprob = TRUE, fac = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="winprob_+3A_elo1">elo1</code></td>
<td>
<p>Elo rating from individual for which the winning probability should be calculated</p>
</td></tr>
<tr><td><code id="winprob_+3A_elo2">elo2</code></td>
<td>
<p>Elo rating of the opponent</p>
</td></tr>
<tr><td><code id="winprob_+3A_normprob">normprob</code></td>
<td>
<p>logical (by default <code>TRUE</code>). Should a normal curve be assumed for calculating the winning/losing probablities, or not (see details).</p>
</td></tr>
<tr><td><code id="winprob_+3A_fac">fac</code></td>
<td>
<p>numeric (by default <code>NULL</code>). A scaling factor (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elo (1978) proposed three ways of calculating winning probabilities (section 8.73), one of which (the &lsquo;linear&rsquo; approach) is ignored here because it &ldquo;lacks the sophistication and flexibility to express the limitation on D [rating difference] and the deflation controls required for integrity of the ratings&rdquo;. Between the two remaining approaches (normal and logistic), Elo favored initially the normal over the logistic function, though he writes that the logistic function &ldquo;better reflects large deviations in an extended series&rdquo;. Because of Elo's initial preference, the default approach taken by the package's functions is the normal one, though it can be changed to the logistic one if desired.
</p>
<p>In the meantime, several studies have used an addtional approach to calculate winning probabilities, which is based on an exponential distribution. This can be invoked by setting <code>normprob = FALSE</code> and <code>fac</code> to some number. The value I have seen used is 0.01 (Franz et al. 2015). Sánchez-Tójar et al. (2018) refer to it as <code>sigmoid.param</code> in their <code>aniDom</code> package. Goffe et al. (2018) also use this approach but their scaling factor is 1 (referred to as <code>diff_f</code>) because their ratings are on a completely different scale.
</p>
<p>Finally, this function is for demonstration only, i.e. it is not used anywhere in the package (other than in vignettes). As such, the functions in the package (most importantly <code><a href="#topic+e.single">e.single</a></code>) only allow the two primary options for the calculation of winning probabilities (for now).
</p>


<h3>Value</h3>

<p>numeric, expected chance of first individual to win an interacation with the second individual
</p>


<h3>Author(s)</h3>

<p>Christof Neumann
</p>


<h3>References</h3>

<p>Elo AE (1978).
<em>The rating of chess players, past and present</em>.
Arco, New York.
</p>
<p>Franz M, McLean E, Tung J, Altmann J, Alberts SC (2015).
&ldquo;Self-organizing dominance hierarchies in a wild primate population.&rdquo;
<em>Proceedings of the Royal Society B: Biological Sciences</em>, <b>282</b>, 20151512.
<a href="https://doi.org/10.1098/rspb.2015.1512">doi:10.1098/rspb.2015.1512</a>.
</p>
<p>Sánchez-Tójar A, Schroeder J, Farine DR (2018).
&ldquo;A practical guide for inferring reliable dominance hierarchies and estimating their uncertainty.&rdquo;
<em>Journal of Animal Ecology</em>, <b>87</b>, 594-608.
<a href="https://doi.org/10.1111/1365-2656.12776">doi:10.1111/1365-2656.12776</a>.
</p>
<p>Goffe AS, Fischer J, Sennhenn-Reulen H (2018).
&ldquo;Bayesian inference and simulation approaches improve the assessment of Elo-ratings in the analysis of social behaviour.&rdquo;
<em>Methods in Ecology and Evolution</em>, <b>9</b>, 2131-2144.
<a href="https://doi.org/10.1111/2041-210X.13072">doi:10.1111/2041-210X.13072</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>winprob(1200,1000)
winprob(1000,1200)
winprob(1000,1000)
winprob(1200,1000, normprob = FALSE)
winprob(1000,1200, normprob = FALSE)
winprob(1000,1000, normprob = FALSE)
winprob(1200,1000, normprob = FALSE, fac = 0.01)
winprob(1000,1200, normprob = FALSE, fac = 0.01)
winprob(1000,1000, normprob = FALSE, fac = 0.01)

# compare different algorithms visually
w &lt;- rep(0, 1001) # winner rating: constant
l &lt;- w - 0:1000 # loser rating: varying

elonorm &lt;- numeric(length(w))
eloexpo &lt;- numeric(length(w))
eloopti &lt;- numeric(length(w))
eloopti2 &lt;- numeric(length(w))

for(i in 1:length(w)) {
  elonorm[i] &lt;- winprob(w[i], l[i], normprob = TRUE)
  eloexpo[i] &lt;- winprob(w[i], l[i], normprob = FALSE)
  eloopti[i] &lt;- winprob(w[i], l[i], normprob = FALSE, fac = 0.01)
  eloopti2[i] &lt;- winprob(w[i], l[i], normprob = FALSE, fac = 0.005)
}

plot(0, 0, type = "n", las = 1, yaxs = "i",
     xlim = c(0, 1000), ylim = c(0.5, 1),
     xlab = "rating difference",
     ylab = "winning probability")
points(abs(l), elonorm, "l", col = "#4B0055", lwd = 3)
points(abs(l), eloexpo, "l", col = "#007094", lwd = 3)
points(abs(l), eloopti, "l", col = "#00BE7D", lwd = 2)
points(abs(l), eloopti2, "l", col = "#FDE333", lwd = 2)

legend("bottomright",
       legend = c("normal", "logistic", "exponential (fac = 0.01)", "exponential (fac = 0.005)"),
       col = c("#4B0055", "#007094", "#00BE7D", "#FDE333"),
       lwd = 2,
       cex = 0.9)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
