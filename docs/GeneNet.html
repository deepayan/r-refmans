<!DOCTYPE html><html lang="en"><head><title>Help for package GeneNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GeneNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GeneNet-package'><p>The GeneNet package</p></a></li>
<li><a href='#arth800'><p>Time Series Expression Data for 800 Arabidopsis Thaliana Genes</p></a></li>
<li><a href='#cor0.test'><p>Test of Vanishing (Partial) Correlation</p></a></li>
<li><a href='#ecoli'><p>Microarray Time Series Data for 102 E. Coli Genes</p>
Genes</a></li>
<li><a href='#GeneNet-internal'><p>Internal GeneNet Functions</p></a></li>
<li><a href='#ggm.estimate.pcor'><p>Graphical Gaussian Models: Small Sample Estimation of Partial Correlation</p></a></li>
<li><a href='#ggm.simulate.data'><p>Graphical Gaussian Models: Simulation of Data</p></a></li>
<li><a href='#ggm.simulate.pcor'><p>Graphical Gaussian Models: Simulation of Networks</p></a></li>
<li><a href='#kappa2n'><p>Relationship Between Sample Size and the Degree of Freedom of Correlation Distribution</p></a></li>
<li><a href='#network.make.graph'><p>Graphical Gaussian Models: Plotting the Network</p></a></li>
<li><a href='#network.test.edges'><p>Graphical Gaussian Models: Assess Significance of Edges (and Directions)</p></a></li>
<li><a href='#z.transform'><p>Variance-Stabilizing Transformations of the Correlation Coefficient</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.2.16</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-11-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling and Inferring Gene Networks</td>
</tr>
<tr>
<td>Author:</td>
<td>Juliane Schaefer, Rainer Opgen-Rhein, and
        Korbinian Strimmer.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Korbinian Strimmer &lt;strimmerlab@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2), corpcor (&ge; 1.6.10), longitudinal (&ge; 1.1.13),
fdrtool (&ge; 1.2.17)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>graph, Rgraphviz</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyzes gene expression
  (time series) data with focus on the inference of gene networks.
  In particular, GeneNet implements the methods of Schaefer and 
  Strimmer (2005a,b,c) and Opgen-Rhein and Strimmer (2006, 2007)
  for learning large-scale gene association networks (including
  assignment of putative directions).  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://strimmerlab.github.io/software/genenet/">https://strimmerlab.github.io/software/genenet/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-11-14 17:27:22 UTC; strimmer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-14 18:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='GeneNet-package'>The GeneNet package</h2><span id='topic+GeneNet-package'></span>

<h3>Description</h3>

<p>GeneNet is a package for analyzing gene expression
(time series) data with focus on the inference of gene networks.
In particular, GeneNet implements the methods of Sch\&quot;afer and 
Strimmer (2005a,b,c) and Opgen-Rhein and Strimmer (2006, 2007)
for learning large-scale gene association networks (including
assignment of putative directions).  
</p>


<h3>Author(s)</h3>

<p>Juliane Sch\&quot;afer, Rainer Opgen-Rhein, and Korbinian Strimmer (<a href="https://strimmerlab.github.io/">https://strimmerlab.github.io/</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggm.estimate.pcor">ggm.estimate.pcor</a>, <a href="#topic+network.test.edges">network.test.edges</a>, <a href="#topic+extract.network">extract.network</a>, <a href="#topic+network.make.dot">network.make.dot</a>.</code>
</p>

<hr>
<h2 id='arth800'>Time Series Expression Data for 800 Arabidopsis Thaliana Genes</h2><span id='topic+arth800'></span><span id='topic+arth800.descr'></span><span id='topic+arth800.expr'></span><span id='topic+arth800.mexpr'></span><span id='topic+arth800.name'></span><span id='topic+arth800.probe'></span><span id='topic+arth800.symbol'></span>

<h3>Description</h3>

<p>This data set describes the temporal expression of 800 genes
of <em>A. thaliana</em> during the diurnal cycle.   The 800 genes are
a subset of the data presented in Smith et al. (2004) and were
selected for periodicity according to the method implemented
in the R package GeneCycle (<a href="https://cran.r-project.org/package=GeneCycle">https://cran.r-project.org/package=GeneCycle</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(arth800)
</code></pre>


<h3>Format</h3>

<p><code>arth800.expr</code> is a <code><a href="longitudinal.html#topic+longitudinal">longitudinal</a></code> 
object with repetitions, and contains the log2 transformed expression data. 
</p>
<p><code>arth800.mexpr</code> is a <code><a href="longitudinal.html#topic+longitudinal">longitudinal</a></code> 
object, and contains the mean expression levels of <code>arth800.expr</code>.
</p>
<p><code>arth800.descr</code>, <code>arth800.name</code>, <code>arth800.probe</code>, 
<code>arth800.symbol</code> are vectors containing additional information about each gene.
</p>


<h3>Source</h3>

<p>The micoarray experiments were performed in the laboratory of S. Smith (Edinburgh).
The data are available from the NASCArrays database under 
experiment reference number NASCARRAYS-60.
</p>


<h3>References</h3>

<p>Smith et al. 2004. Diurnal changes in the transcriptom encoding 
enzymes of starch metabolism provide evidence for both transcriptional
and posttranscriptional regulation of starch metabolism in Arabidopsis 
leaves.  Plant Physiol. 136: 2687-2699
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneNet library
library("GeneNet")

# load data set
data(arth800)

is.longitudinal(arth800.expr)
summary(arth800.expr)

# plot first nine time series
plot(arth800.expr, 1:9)
</code></pre>

<hr>
<h2 id='cor0.test'>Test of Vanishing (Partial) Correlation</h2><span id='topic+cor0.test'></span>

<h3>Description</h3>

<p><code>cor0.test</code> computes a p-value for the two-sided test with the null
hypothesis H0: rho == 0 versus the alternative hypothesis HA: rho != 0.
</p>
<p>If <code>method="student"</code> is selected then the statistic 
<code>t=r*sqrt((kappa-1)/(1-r*r))</code> is considered which under H0 is
student-t distributed with <code>df=kappa-1</code>.  This method is exact.
</p>
<p>If <code>method="dcor0"</code> is selected then the p-value is computed
directly from the null distribution of the (partial) correlation
(see <code><a href="fdrtool.html#topic+dcor0">dcor0</a></code>).
This method is also exact.
</p>
<p>If <code>method="ztransform"</code> is selected then the p-value is computed
using the z-transform (see <code><a href="#topic+z.transform">z.transform</a></code>), i.e. using 
a suitable chosen normal distribution.
This method returns approximate p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor0.test(r, kappa, method=c("student", "dcor0", "ztransform"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor0.test_+3A_r">r</code></td>
<td>
<p>observed correlation</p>
</td></tr>
<tr><td><code id="cor0.test_+3A_kappa">kappa</code></td>
<td>
<p>degree of freedom of the null-distribution</p>
</td></tr>
<tr><td><code id="cor0.test_+3A_method">method</code></td>
<td>
<p>method used to compute the p-value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A p-value.
</p>


<h3>Author(s)</h3>

<p>Juliane Sch\&quot;afer and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="fdrtool.html#topic+dcor0">dcor0</a></code>,  <code><a href="#topic+kappa2n">kappa2n</a></code>, <code><a href="#topic+z.transform">z.transform</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneNet library
library("GeneNet")

# covariance matrix
m.cov &lt;- rbind(
 c(3,1,1,0),
 c(1,3,0,1),
 c(1,0,2,0),
 c(0,1,0,2)
)

# compute partial correlations
m.pcor &lt;- cor2pcor(m.cov)
m.pcor

# corresponding p-values 
# assuming a sample size of 25, i.e. kappa=22
kappa2n(22, 4)
cor0.test(m.pcor, kappa=22)
cor0.test(m.pcor, kappa=22) &lt; 0.05

# p-values become smaller with larger r 
cor0.test(0.7, 12)
cor0.test(0.8, 12)
cor0.test(0.9, 12)

# comparison of various methods
cor0.test(0.2, 45, method="student")
cor0.test(0.2, 45, method="dcor0")
cor0.test(0.2, 45, method="ztransform")
</code></pre>

<hr>
<h2 id='ecoli'>Microarray Time Series Data for 102 E. Coli Genes 
Genes</h2><span id='topic+ecoli'></span>

<h3>Description</h3>

<p>This data set describes the temporal expression of 102 genes
of <em>E. Coli</em> after induction of the expression of SOD
(recombinant human superoxide dismutase).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ecoli)
</code></pre>


<h3>Format</h3>

<p><code>caulobacter</code> is a <code><a href="longitudinal.html#topic+longitudinal">longitudinal</a></code> object
containing the data from the Schmidt-Heck et al. (2004) experiment.
Essentially, this is a matrix with with 102 columns (=genes)
and 9 rows (=time points).  All expression levels are given in
log2-ratios with respect to the first time point (i.e. the
induction at time 0).
</p>


<h3>Source</h3>

<p>The micoarray experiment was performed at the Institute of Applied
Microbiology, University of Agricultural Sciences of Vienne.
The data and the experiment is described in Schmidt-Heck et al. (2004).
</p>


<h3>References</h3>

<p>Schmidt-Heck, W., Guthke, R., Toepfer, S., Reischer, H., Duerrschmid, K.,
and Bayer, K. (2004) Reverse engineering of the stress response during 
expression of a recombinant protein.
In: <em>Proceedings of the EUNITE 2004 European Symposium on Intelligent
Technologies, Hybrid Systems and their Implementation on Smart Adaptive 
Systems, June 10-12, 2004, Aachen, Germany</em>, Verlag Mainz, 
Wissenschaftsverlag, Aachen, 2004, 407-441 (ISBN 3-86130-368-X).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneNet library
library("GeneNet")

# load data set
data(ecoli)
is.longitudinal(ecoli)

# how many samples and how many genes?
dim(ecoli)
summary(ecoli)
get.time.repeats(ecoli)

# plot first nine time series
plot(ecoli, 1:9)
</code></pre>

<hr>
<h2 id='GeneNet-internal'>Internal GeneNet Functions</h2><span id='topic+myrmvnorm'></span><span id='topic+ggm.list.edges'></span>

<h3>Description</h3>

<p>Internal GeneNet functions.
</p>


<h3>Note</h3>

<p>These are not to be called by the user (or in some cases are just
waiting for proper documentation to be written).
</p>

<hr>
<h2 id='ggm.estimate.pcor'>Graphical Gaussian Models: Small Sample Estimation of Partial Correlation</h2><span id='topic+ggm.estimate.pcor'></span>

<h3>Description</h3>

<p><code>ggm.estimate.pcor</code> offers an interface to two related shrinkage estimators
of partial correlation. Both are fast, statistically efficient, and can be used for
analyzing small sample data.  
</p>
<p>The default method &quot;statics&quot; employs the function 
<code><a href="corpcor.html#topic+pcor.shrink">pcor.shrink</a></code> whereas the &quot;dynamic&quot; method relies on 
<code><a href="longitudinal.html#topic+dyn.pcor">dyn.pcor</a></code> (in the <code>longitudinal</code> package).  The difference between the two estimators
is that the latter takes  the spacings between time points into account
if the input are multiple time course data (these must be provided as 
<code><a href="longitudinal.html#topic+longitudinal">longitudinal</a></code> object).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggm.estimate.pcor(x, method = c("static", "dynamic"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggm.estimate.pcor_+3A_x">x</code></td>
<td>
<p>data matrix (each rows corresponds to one multivariate observation)</p>
</td></tr>
<tr><td><code id="ggm.estimate.pcor_+3A_method">method</code></td>
<td>
<p>method used to estimate the partial correlation matrix.
Available options are &quot;static&quot; (the default) and &quot;dynamic&quot; - both
are shrinkage methods.</p>
</td></tr>
<tr><td><code id="ggm.estimate.pcor_+3A_...">...</code></td>
<td>
<p>options passed to <code><a href="corpcor.html#topic+pcor.shrink">pcor.shrink</a></code>
and to <code><a href="longitudinal.html#topic+dyn.pcor">dyn.pcor</a></code> (in the <code>longitudinal</code> package).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the shrinkage estimators we refer to Opgen-Rhein and Strimmer (2006a,b)
and Sch\&quot;afer and Strimmer (2005), as well as to the manual pages of 
<code><a href="corpcor.html#topic+pcor.shrink">pcor.shrink</a></code> (in the <code>corpcor</code> package) and <code><a href="longitudinal.html#topic+dyn.pcor">dyn.pcor</a></code> (in the <code>longitudinal</code> package).
</p>
<p>Previously, this function offered several furthers options.
The old option called &quot;shrinkage&quot; corresponds to the present &quot;static&quot; option.
The other old options &quot;observed.pcor&quot;, &quot;partial.bagged.cor&quot;, and &quot;bagged.pcor&quot;
are now considered obselete and have been removed.
</p>


<h3>Value</h3>

<p>An estimated partial correlation matrix.
</p>


<h3>Author(s)</h3>

<p>Rainer Opgen-Rhein,
Juliane Sch\&quot;afer, and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Opgen-Rhein, R., and K. Strimmer. 2006a. Inferring gene dependency networks from 
genomic longitudinal data: a functional data approach.
REVSTAT <b>4</b>:53-65. 
</p>
<p>Opgen-Rhein, R., and K. Strimmer. 2006b. Using regularized dynamic correlation 
to infer gene dependency networks from time-series microarray data. 
The 4th International Workshop on Computational Systems Biology,
WCSB 2006 (June 12-13, 2006, Tampere, Finland). 
</p>
<p>Sch\&quot;afer, J., and Strimmer, K. (2005).  A shrinkage approach to large-scale
covariance estimation and implications for functional genomics. 
Statist. Appl. Genet. Mol. Biol. <b>4</b>:32.
&lt;DOI:10.2202/1544-6115.1175&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggm.simulate.data">ggm.simulate.data</a></code>, <code><a href="#topic+ggm.estimate.pcor">ggm.estimate.pcor</a></code>,
<code><a href="corpcor.html#topic+pcor.shrink">pcor.shrink</a></code>, and <code><a href="longitudinal.html#topic+dyn.pcor">dyn.pcor</a></code> (in the <code>longitudinal</code> package)</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load GeneNet library
library("GeneNet")

# generate random network with 40 nodes 
# it contains 780=40*39/2 edges of which 5 percent (=39) are non-zero
true.pcor &lt;- ggm.simulate.pcor(40)
  
# simulate data set with 40 observations
m.sim &lt;- ggm.simulate.data(40, true.pcor)

# simple estimate of partial correlations
estimated.pcor &lt;- cor2pcor( cor(m.sim) )

# comparison of estimated and true values
sum((true.pcor-estimated.pcor)^2)

# a slightly better estimate ...
estimated.pcor.2 &lt;- ggm.estimate.pcor(m.sim)
sum((true.pcor-estimated.pcor.2)^2)


## End(Not run)
</code></pre>

<hr>
<h2 id='ggm.simulate.data'>Graphical Gaussian Models: Simulation of Data</h2><span id='topic+ggm.simulate.data'></span>

<h3>Description</h3>

<p><code>ggm.simulate.data</code> takes a positive definite partial correlation matrix and
generates an i.i.d. sample from the corresponding standard multinormal distribution 
(with mean 0 and variance 1).  If the input matrix <code>pcor</code> is not positive definite
an error is thrown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggm.simulate.data(sample.size, pcor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggm.simulate.data_+3A_sample.size">sample.size</code></td>
<td>
<p>sample size of simulated data set</p>
</td></tr>
<tr><td><code id="ggm.simulate.data_+3A_pcor">pcor</code></td>
<td>
<p>partial correlation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multinormal data matrix.
</p>


<h3>Author(s)</h3>

<p>Juliane Sch\&quot;afer and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Sch\&quot;afer, J., and Strimmer, K. (2005).  An empirical Bayes approach to inferring
large-scale gene association networks. <em>Bioinformatics</em> <b>21</b>:754-764.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggm.simulate.pcor">ggm.simulate.pcor</a></code>, <code><a href="#topic+ggm.estimate.pcor">ggm.estimate.pcor</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load GeneNet library
library("GeneNet")

# generate random network with 40 nodes 
# it contains 780=40*39/2 edges of which 5 percent (=39) are non-zero
true.pcor &lt;- ggm.simulate.pcor(40)
  
# simulate data set with 40 observations
m.sim &lt;- ggm.simulate.data(40, true.pcor)

# simple estimate of partial correlations
estimated.pcor &lt;- cor2pcor( cor(m.sim) )

# comparison of estimated and true values
sum((true.pcor-estimated.pcor)^2)

# a slightly better estimate ...
estimated.pcor.2 &lt;- ggm.estimate.pcor(m.sim)
sum((true.pcor-estimated.pcor.2)^2)

</code></pre>

<hr>
<h2 id='ggm.simulate.pcor'>Graphical Gaussian Models: Simulation of Networks</h2><span id='topic+ggm.simulate.pcor'></span>

<h3>Description</h3>

<p><code>ggm.simulate.pcor</code> generates a random matrix of partial correlations that 
corresponds to a GGM network of a given size (<code>num.nodes</code>)
with a specified fraction of non-zero edges.  The diagonal entries of the output matrix contain 1.
</p>
<p>If <code>stdprec=TRUE</code> then the standardised precision matrix is returned instead of the patrix of partial
correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggm.simulate.pcor(num.nodes, etaA=0.05, stdprec=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggm.simulate.pcor_+3A_num.nodes">num.nodes</code></td>
<td>
<p>number of nodes in the network</p>
</td></tr>
<tr><td><code id="ggm.simulate.pcor_+3A_etaa">etaA</code></td>
<td>
<p>fraction of edges with non-zero partial correlation (default: 0.05)</p>
</td></tr>
<tr><td><code id="ggm.simulate.pcor_+3A_stdprec">stdprec</code></td>
<td>
<p>return standardised precision matrix, rather than matrix of partial correlations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simulation of the partial correlation matrix works by generating a diagonally dominant matrix
as a positive definite precision matrix (inverse covariance matrix), which is 
subsequently standardized and transformed into the matrix of partial correlations.
For the full algorithm see Sch\&quot;afer and Strimmer (2005).
</p>


<h3>Value</h3>

<p>A positive partial correlation matrix (diagonal 1) with positive definite underlying precision matrix.
</p>
<p>If <code>stdprec=TRUE</code> then the standardised precision matrix is returned instead.
</p>


<h3>Author(s)</h3>

<p>Juliane Sch\&quot;afer and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Sch\&quot;afer, J., and Strimmer, K. (2005).  An empirical Bayes approach to inferring
large-scale gene association networks. <em>Bioinformatics</em> <b>21</b>:754-764.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggm.simulate.data">ggm.simulate.data</a></code>,<code><a href="#topic+ggm.estimate.pcor">ggm.estimate.pcor</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# load GeneNet library
library("GeneNet")

# generate random network with 40 nodes 
# it contains 780=40*39/2 edges of which 5 percent (=39) are non-zero
true.pcor &lt;- ggm.simulate.pcor(40)
  
# simulate data set with 40 observations
m.sim &lt;- ggm.simulate.data(40, true.pcor)

# simple estimate of partial correlations
estimated.pcor &lt;- cor2pcor( cor(m.sim) )

# comparison of estimated and true values
sum((true.pcor-estimated.pcor)^2)

# a slightly better estimate ...
estimated.pcor.2 &lt;- ggm.estimate.pcor(m.sim)
sum((true.pcor-estimated.pcor.2)^2)


## End(Not run)
</code></pre>

<hr>
<h2 id='kappa2n'>Relationship Between Sample Size and the Degree of Freedom of Correlation Distribution</h2><span id='topic+kappa2n'></span><span id='topic+n2kappa'></span>

<h3>Description</h3>

<p>The function <code>kappa2n</code> returns the sample size that
corresponds to a given degree of freedom kappa, whereas <code>n2kappa</code>
converts sample size to the corresponding degree of freedom. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kappa2n(kappa, p=2)
n2kappa(n, p=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kappa2n_+3A_kappa">kappa</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code id="kappa2n_+3A_p">p</code></td>
<td>
<p>number of variables (p=2 corresponds to simple correlation)</p>
</td></tr>
<tr><td><code id="kappa2n_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The degree of freedom kappa of the sample distribution of the empirical correlation
coefficient depends both on the sample size n and the number p of investigated variables, 
i.e. whether simple or partial correlation coefficients are being considered.
For p=2 (simple correlation coefficient) the degree of freedom equals <code>kappa = n-1</code>,
whereas for arbitrary p (with p-2 variables eliminated in the partial correlation coefficient)
<code>kappa = n-p+1</code> (see also <code><a href="fdrtool.html#topic+dcor0">dcor0</a></code>).
</p>


<h3>Value</h3>

<p>The sample size n corresponding to a given kappa, or the degree of freedom
kappa corresponding to a given p.
</p>


<h3>Author(s)</h3>

<p>Juliane Sch\&quot;afer and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>See Also</h3>

<p><code><a href="fdrtool.html#topic+dcor0">dcor0</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneNet library
library("GeneNet")


# sample sizes corresponding to kappa=7
kappa2n(7)     # simple correlation
kappa2n(7, 40) # partial correlation with p=40 variables

# degree of freedom corresponding to n=100
n2kappa(100)
n2kappa(100,40)
</code></pre>

<hr>
<h2 id='network.make.graph'>Graphical Gaussian Models: Plotting the Network</h2><span id='topic+network.make.graph'></span><span id='topic+network.make.dot'></span><span id='topic+node.degree'></span><span id='topic+edge.info'></span><span id='topic+num.nodes'></span>

<h3>Description</h3>

<p><code>network.make.dot</code> converts an edge list as obtained by <code><a href="#topic+network.test.edges">network.test.edges</a></code>
into a &quot;dot&quot; file that can directly be used for plotting the network with graphviz.
</p>
<p><code>network.make.graph</code> converts an edge list as obtained by <code><a href="#topic+network.test.edges">network.test.edges</a></code>
into a graph object. 
</p>
<p><code>edge.info</code> shows the edge weights and the edge directions. 
</p>
<p><code>node.degree</code> shows number of edges connected to a node (bi-directional/undirected edges are counted only once).
</p>
<p><code>num.nodes</code> shows the number of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.make.dot(filename, edge.list, node.labels, main=NULL, show.edge.labels=FALSE)
network.make.graph(edge.list, node.labels, drop.singles=FALSE)
edge.info(gr)
node.degree(gr)
num.nodes(gr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="network.make.graph_+3A_filename">filename</code></td>
<td>
<p>name of file containg the &quot;dot&quot; commands for graphviz</p>
</td></tr>
<tr><td><code id="network.make.graph_+3A_edge.list">edge.list</code></td>
<td>
<p>a data frame, as obtained by <code><a href="#topic+network.test.edges">network.test.edges</a></code>, listing all
edges to be included in the graph</p>
</td></tr>
<tr><td><code id="network.make.graph_+3A_node.labels">node.labels</code></td>
<td>
<p>a vector with labels for each node (will be converted to type character)</p>
</td></tr> 
<tr><td><code id="network.make.graph_+3A_main">main</code></td>
<td>
<p>title included in plot</p>
</td></tr>
<tr><td><code id="network.make.graph_+3A_show.edge.labels">show.edge.labels</code></td>
<td>
<p>plot correlation values as edge labels (default: FALSE)</p>
</td></tr>
<tr><td><code id="network.make.graph_+3A_drop.singles">drop.singles</code></td>
<td>
<p>remove unconnected nodes</p>
</td></tr>
<tr><td><code id="network.make.graph_+3A_gr">gr</code></td>
<td>
<p>a graph object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For network plotting the software &quot;graphviz&quot; is employed (<a href="https://www.graphviz.org">https://www.graphviz.org</a>).
</p>
<p>For the functions <code>network.plot.graph</code> and <code>network.make.graph</code>  the &quot;graph&quot; and &quot;Rgraphviz&quot; 
packages from the  Bioconductor project (<a href="https://www.bioconductor.org">https://www.bioconductor.org</a>) is required. 
</p>


<h3>Value</h3>

<p><code>network.make.dot</code> produces a &quot;dot&quot; network description file that
can directly be fed into graphviz in order to produce a plot of a network.
</p>
<p><code>network.make.graph</code> returns a graph object, suitable for plotting with functions from
the &quot;Rgraphviz&quot; library.
</p>
<p><code>edge.info</code> returns a list containing vector of weights for all edges contained in a graph, and a vector listing the directions of the edges (using Rgraphviz
conventions &quot;forward&quot; for directed edge, and &quot;none&quot; for bi-directional/undirected edge). 
</p>
<p><code>num.nodes</code> returns the number of nodes.
</p>


<h3>Author(s)</h3>

<p>Juliane Sch\&quot;afer,
Rainer Opgen-Rhein, and
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network.test.edges">network.test.edges</a></code>, <code>plot.graph</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneNet library
library("GeneNet")
 
# generate random network with 20 nodes and 10 percent edges (=19 edges)
true.pcor &lt;- ggm.simulate.pcor(20, 0.1)

# convert to edge list 
test.results &lt;- ggm.list.edges(true.pcor)[1:19,]

########  use graphviz directly to produce a plot ##########

# uncomment for actual use!

# nlab &lt;- LETTERS[1:20]
# ggm.make.dot(filename="test.dot", test.results, nlab, main = "A graph") 
# system("fdp -T svg -o test.svg test.dot") # SVG format


########  use Rgraphviz produce a plot ##########

# uncomment for actual use!

# nlab &lt;- LETTERS[1:20]
# gr &lt;- network.make.graph( test.results, nlab) 
# gr 
# num.nodes(gr)
# edge.info(gr)
# gr2 &lt;- network.make.graph( test.results, nlab, drop.singles=TRUE) 
# gr2 
# num.nodes(gr2)
# edge.info(gr2)

# plot network
# NOTE: this requires the installation of the "Rgraphviz" library
# library("Rgraphviz")
# plot(gr, "fdp")
# plot(gr2, "fdp")

## for a full example with beautified Rgraphviz plot see 
## the example scripts provide with GeneNet (e.g. arabidopis-net.R)


</code></pre>

<hr>
<h2 id='network.test.edges'>Graphical Gaussian Models: Assess Significance of Edges (and Directions)</h2><span id='topic+network.test.edges'></span><span id='topic+extract.network'></span>

<h3>Description</h3>

<p><code>network.test.edges</code> returns a data frame containing all edges listed
in order of the magnitude of the partial correlation associated with each edge.
If <code>fdr=TRUE</code> then in addition the
p-values, q-values and posterior probabilities (=1 - local fdr) for each potential 
edge are computed.
</p>
<p><code>extract.network</code> returns a data frame with a subset of significant
edges. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.test.edges(r.mat, fdr=TRUE, direct=FALSE, plot=TRUE, ...)
extract.network(network.all, method.ggm=c("prob", "qval","number"), 
      cutoff.ggm=0.8, method.dir=c("prob","qval","number", "all"), 
      cutoff.dir=0.8, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="network.test.edges_+3A_r.mat">r.mat</code></td>
<td>
<p>matrix of partial correlations</p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_fdr">fdr</code></td>
<td>
<p>estimate q-values and local fdr</p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_direct">direct</code></td>
<td>
<p>compute additional statistics for obtaining a partially directed network</p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_plot">plot</code></td>
<td>
<p>plot density and distribution function and (local) fdr values</p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code> </p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_network.all">network.all</code></td>
<td>
<p>list with partial correlations and fdr values for all potential edges
(i.e. the output of <code>network.test.edges</code></p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_method.ggm">method.ggm</code></td>
<td>
<p>determines which criterion is used to select significant partial correlations (default: prob)</p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_cutoff.ggm">cutoff.ggm</code></td>
<td>
<p>default cutoff for significant partial correlations</p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_method.dir">method.dir</code></td>
<td>
<p>determines which criterion is used to select significant directions (default: prob) </p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_cutoff.dir">cutoff.dir</code></td>
<td>
<p>default cutoff for significant directions</p>
</td></tr>
<tr><td><code id="network.test.edges_+3A_verbose">verbose</code></td>
<td>
<p>print information on the number of significant edges etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For assessing the significance of edges in the GGM 
a mixture model is fitted to the partial correlations using <code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code>. 
This results in (i)  two-sided p-values for the test of non-zero correlation,
(ii) corresponding posterior probabilities (= 1- local fdr), as well as (iii) tail
area-based q-values.  See  Sch\&quot;afer and Strimmer (2005) for details.
</p>
<p>For determining putatative directions on this GGM log-ratios of standardized partial 
variances re estimated, and subsequently the corresponding (local) fdr values are
computed - see Opgen-Rhein and Strimmer (2007).
</p>


<h3>Value</h3>

<p><code>network.test.edges</code> returns a
data frame with the following columns:
</p>
<table role = "presentation">
<tr><td><code>pcor</code></td>
<td>
<p>correlation (from r.mat)</p>
</td></tr>
<tr><td><code>node1</code></td>
<td>
<p>first node connected to edge</p>
</td></tr>
<tr><td><code>node2</code></td>
<td>
<p>second node connected to edge</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p-value</p>
</td></tr>
<tr><td><code>qval</code></td>
<td>
<p>q-value</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>probability that edge is nonzero (= 1-local fdr</p>
</td></tr>
<tr><td><code>log.spvar</code></td>
<td>
<p>log ratio of standardized partial variance (determines direction)</p>
</td></tr>
<tr><td><code>pval.dir</code></td>
<td>
<p>p-value (directions)</p>
</td></tr>
<tr><td><code>qval.dir</code></td>
<td>
<p>q-value (directions)</p>
</td></tr>
<tr><td><code>prob.dir</code></td>
<td>
<p>1-local fdr (directions) </p>
</td></tr>
</table>
<p>Each row in the data frame corresponds to one edge, and the rows are sorted
according the absolute strength of the correlation (from strongest to weakest)
</p>
<p><code>extract.network</code> processes the above data frame containing all potential edges,
and returns a dataframe with a subset of edges.  If applicable, an additional
last column (11) contains additional information on the directionality of an edge.
</p>


<h3>Author(s)</h3>

<p>Rainer Opgen-Rhein,
Juliane Sch\&quot;afer,
Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Sch\&quot;afer, J., and Strimmer, K. (2005).  An empirical Bayes approach to inferring
large-scale gene association networks. <em>Bioinformatics</em> <b>21</b>:754-764.
</p>
<p>Opgen-Rhein, R., and K. Strimmer. (2007). From correlation to causation networks: 
a simple approximate learning algorithm and its application to high-dimensional 
plant gene expression data. <em>BMC Syst. Biol.</em> <b>1</b>:37.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor0.test">cor0.test</a></code>,
<code><a href="fdrtool.html#topic+fdrtool">fdrtool</a></code>,
<code><a href="#topic+ggm.estimate.pcor">ggm.estimate.pcor</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneNet library
library("GeneNet")
 
# ecoli data 
data(ecoli)

# estimate partial correlation matrix 
inferred.pcor &lt;- ggm.estimate.pcor(ecoli)

# p-values, q-values and posterior probabilities for each potential edge 
#
test.results &lt;- network.test.edges(inferred.pcor)

# show best 20 edges (strongest correlation)
test.results[1:20,]

# extract network containing edges with prob &gt; 0.9 (i.e. local fdr &lt; 0.1)
net &lt;- extract.network(test.results, cutoff.ggm=0.9)
net

# how many are significant based on FDR cutoff Q=0.05 ?
num.significant.1 &lt;- sum(test.results$qval &lt;= 0.05)
test.results[1:num.significant.1,]

# how many are significant based on "local fdr" cutoff (prob &gt; 0.9) ?
num.significant.2 &lt;- sum(test.results$prob &gt; 0.9)
test.results[test.results$prob &gt; 0.9,]

# parameters of the mixture distribution used to compute p-values etc.
c &lt;- fdrtool(sm2vec(inferred.pcor), statistic="correlation")
c$param

</code></pre>

<hr>
<h2 id='z.transform'>Variance-Stabilizing Transformations of the Correlation Coefficient</h2><span id='topic+z.transform'></span><span id='topic+hotelling.transform'></span>

<h3>Description</h3>

<p><code>z.transform</code> implements Fisher's (1921)  first-order and Hotelling's (1953) 
second-order transformations to stabilize the distribution of the correlation coefficient.
After the transformation the data follows approximately a
normal distribution  with constant variance (i.e. independent of the mean). 
</p>
<p>The Fisher transformation is simply <code>z.transform(r) = atanh(r)</code>.
</p>
<p>Hotelling's transformation requires the specification of the degree of freedom <code>kappa</code> of
the underlying distribution. This depends on the sample size n used to compute the
sample correlation and whether simple ot partial correlation coefficients are considered.
If there are p variables, with p-2 variables eliminated, the degree of freedom is <code>kappa=n-p+1</code>.
(cf. also <code><a href="fdrtool.html#topic+dcor0">dcor0</a></code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z.transform(r)
hotelling.transform(r, kappa)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z.transform_+3A_r">r</code></td>
<td>
<p>vector of sample correlations</p>
</td></tr>
<tr><td><code id="z.transform_+3A_kappa">kappa</code></td>
<td>
<p>degrees of freedom of the distribution of the correlation coefficient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector of transformed sample correlation coefficients.
</p>


<h3>Author(s)</h3>

<p>Korbinian Strimmer (<a href="https://strimmerlab.github.io">https://strimmerlab.github.io</a>).
</p>


<h3>References</h3>

<p>Fisher, R.A. (1921). On the 'probable error' of a coefficient of correlation deduced from
a small sample. <em>Metron</em>, <b>1</b>, 1&ndash;32.
</p>
<p>Hotelling, H. (1953). New light on the correlation coefficient and its transformation.
<em>J. Roy. Statist. Soc. B</em>, <b>15</b>, 193&ndash;232.
</p>


<h3>See Also</h3>

 <p><code><a href="fdrtool.html#topic+dcor0">dcor0</a></code>,  <code><a href="#topic+kappa2n">kappa2n</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load GeneNet library
library("GeneNet")

# small example data set 
r &lt;- c(-0.26074194, 0.47251437, 0.23957283,-0.02187209,-0.07699437,
       -0.03809433,-0.06010493, 0.01334491,-0.42383367,-0.25513041)

# transformed data
z1 &lt;- z.transform(r)
z2 &lt;- hotelling.transform(r,7)
z1
z2
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
