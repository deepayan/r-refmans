<!DOCTYPE html><html><head><title>Help for package Platypus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Platypus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GEX_cluster_genes'><p>Differentially expressed genes between clusters or data subsets</p></a></li>
<li><a href='#GEX_cluster_genes_heatmap'><p>Heatmap of cluster defining genes</p></a></li>
<li><a href='#GEX_cluster_membership'><p>Cluster membership plots by sample</p></a></li>
<li><a href='#GEX_coexpression_coefficient'><p>Coexpression of selected genes</p></a></li>
<li><a href='#GEX_DEgenes'><p>Wrapper for differential gene expression analysis and plotting</p></a></li>
<li><a href='#GEX_dottile_plot'><p>GEX Dottile plots</p></a></li>
<li><a href='#GEX_gene_visualization'><p>Visualization of marker expression in a data set or of predefined genes (B cells, CD4 T cells and CD8 T cells).</p></a></li>
<li><a href='#GEX_GSEA'><p>GEX Gene Set Enrichment Analysis and plotting</p></a></li>
<li><a href='#GEX_heatmap'><p>Flexible GEX heatmap wrapper</p></a></li>
<li><a href='#GEX_lineage_trajectories'><p>This is a function to infer single cell trajectories and identifying lineage structures on clustered cells. Using the slingshot library</p></a></li>
<li><a href='#GEX_pairwise_DEGs'><p>Wrapper for calculating pairwise differentially expressed genes</p></a></li>
<li><a href='#GEX_phenotype'><p>Assignment of cells to phenotypes based on selected markers</p></a></li>
<li><a href='#GEX_phenotype_per_clone'><p>Plotting of GEX phenotype by VDJ clone</p></a></li>
<li><a href='#GEX_proportions_barplot'><p>Plots proportions of a group of cells within a secondary group of cells. E.g. The proportions of samples in seurat clusters, or the proportions of samples in defined cell subtypes</p></a></li>
<li><a href='#GEX_scatter_coexpression'><p>Scatter plot for coexpression of two selected genes</p></a></li>
<li><a href='#GEX_volcano'><p>Flexible wrapper for GEX volcano plots</p></a></li>
<li><a href='#PlatypusDB_AIRR_to_VGM'><p>AIRR to Platypus V3 VGM compatibility function</p></a></li>
<li><a href='#PlatypusDB_load_from_disk'><p>PlatypusDB utility for import of local datasets</p></a></li>
<li><a href='#PlatypusDB_VGM_to_AIRR'><p>Platypus V3 VGM to AIRR compatibility function</p></a></li>
<li><a href='#small_vgm'><p>Small VDJ GEX matrix (VGM) for function testing purposes</p></a></li>
<li><a href='#VDJ_abundances'><p>Calculate abundances/counts of specific features for a VDJ dataframe</p></a></li>
<li><a href='#VDJ_alpha_beta_Vgene_circos'><p>Produces a Circos plot from the VDJ_analyze output. Connects the V-alpha with the corresponding V-beta gene for each clonotype.</p></a></li>
<li><a href='#VDJ_antigen_integrate'><p>Integrates antigen-specific information into the VDJ/VDJ.GEX.matrix[[1]] object</p></a></li>
<li><a href='#VDJ_assemble_for_PnP'><p>Ab sequence assembly for recombinant PnP expression</p></a></li>
<li><a href='#VDJ_build'><p>Minimal version of the VDJ building part from VDJ_GEX_matrix() function. Optimized for for Cell Ranger v7 and suitable for older Cell Ranger versions.</p></a></li>
<li><a href='#VDJ_call_enclone'><p>(Re)clonotype a VDJ object using cellranger's enclone tool</p></a></li>
<li><a href='#VDJ_circos'><p>Plots a Circos diagram from an adjacency matrix. Uses the Circlize chordDiagram function. Is called by VDJ_clonotype_clusters_circos(), VDJ_alpha_beta_Vgene_circos() and VDJ_VJ_usage_circos() functions or works on its own when supplied with an adjacency matrix.</p></a></li>
<li><a href='#VDJ_clonal_barplot'><p>Function to create stacked barplots to visualize clonal expansion per repertoire directly from a VDJ matrix (either from the minimal_VDJ() or VDJ_GEX_matrix())</p></a></li>
<li><a href='#VDJ_clonal_donut'><p>Circular VDJ expansion plots</p></a></li>
<li><a href='#VDJ_clonal_expansion'><p>Flexible wrapper for clonal expansion barplots by isotype, GEX cluster etc.</p></a></li>
<li><a href='#VDJ_clonotype'><p>Platypus V3 clonotyping wrapper</p></a></li>
<li><a href='#VDJ_clonotype_v3_w_enclone'><p>Updated clonotyping function based on implications for cells with different chain numbers than 1 VDJ 1 VJ chains.</p></a></li>
<li><a href='#VDJ_contigs_to_vgm'><p>Formats &quot;VDJ_contigs_annotations.csv&quot; files from cell ranger to match the VDJ_GEX_matrix output using only cells with 1VDJ and 1VJ chain</p></a></li>
<li><a href='#VDJ_db_annotate'><p>Wrapper function of VDJ_antigen_integrate function</p></a></li>
<li><a href='#VDJ_db_load'><p>Load and preprocess a list of antigen-specific databases</p></a></li>
<li><a href='#VDJ_diversity'><p>Calculates and plots common diversity and overlap measures for repertoires and alike. Requires the vegan package</p></a></li>
<li><a href='#VDJ_dynamics'><p>Tracks a specific VDJ column across multiple samples/timepoints.</p></a></li>
<li><a href='#VDJ_expand_aberrants'><p>Expand the aberrant cells in a VDJ dataframe by converting them into additional rows</p></a></li>
<li><a href='#VDJ_extract_germline_consensus_ref'><p>Making the trimmed reference and concatenating fr1-fr4</p></a></li>
<li><a href='#VDJ_germline'><p>Infer germline from the desired software/caller</p></a></li>
<li><a href='#VDJ_get_public'><p>Function to get shared/public elements across multiple repertoires</p></a></li>
<li><a href='#VDJ_GEX_clonotype_clusters_circos'><p>Makes a Circos plot from the VDJ_GEX_integrate output. Connects the clonotypes with the corresponding clusters.</p></a></li>
<li><a href='#VDJ_GEX_matrix'><p>VDJ GEX processing and integration wrapper</p></a></li>
<li><a href='#VDJ_GEX_overlay_clones'><p>Overlay clones on GEX projection</p></a></li>
<li><a href='#VDJ_GEX_stats'><p>Standalone VDJ and GEX statistics.</p></a></li>
<li><a href='#VDJ_kmers'><p>Calculates and plots kmers distributions and frequencies.</p></a></li>
<li><a href='#VDJ_network'><p>Similarity networks based on CDR3 regions</p></a></li>
<li><a href='#VDJ_ordination'><p>Performs ordination/dimensionality reduction for a species incidence matrix, depending on the species selected in the feature.columns parameter.</p></a></li>
<li><a href='#VDJ_overlap_heatmap'><p>Wrapper to determine and plot overlap between VDJ features across groups</p></a></li>
<li><a href='#VDJ_phylogenetic_trees'><p>Creates phylogenetic trees from a VDJ dataframe</p></a></li>
<li><a href='#VDJ_phylogenetic_trees_plot'><p>Phylogenetic tree plotting</p></a></li>
<li><a href='#VDJ_plot_SHM'><p>Plotting of somatic hypermutation counts</p></a></li>
<li><a href='#VDJ_public'><p>Function to get shared/public elements across multiple repertoires</p></a></li>
<li><a href='#VDJ_rarefaction'><p>Plots rarefaction curves for species denoted in the feature.columns parameter across groups determined by grouping.columns</p></a></li>
<li><a href='#VDJ_variants_per_clone'><p>Wrapper for variant analysis by clone</p></a></li>
<li><a href='#VDJ_Vgene_usage'><p>V(D)J gene usage stacked barplots</p></a></li>
<li><a href='#VDJ_Vgene_usage_barplot'><p>V(D)J gene usage barplots</p></a></li>
<li><a href='#VDJ_Vgene_usage_stacked_barplot'><p>V(D)J gene usage stacked barplots</p></a></li>
<li><a href='#VDJ_VJ_usage_circos'><p>Makes a Circos plot from the VDJ_analyze output. Connects the V gene with the corresponding J gene for each clonotype.</p></a></li>
<li><a href='#VGM_build'><p>Function to obtain the VGM object by integrating the VDJ and GEX/Seurat objects</p></a></li>
<li><a href='#VGM_expand_featurebarcodes'><p>Utility for feature barcode assignment including clonal information</p></a></li>
<li><a href='#VGM_expanded_clones'><p>VDJ utility for T/F column for clonal expansion</p></a></li>
<li><a href='#VGM_integrate'><p>Utility for VDJ GEX matrix to integrated VDJ and GEX objects after addition of data to either</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Single-Cell Immune Repertoire and Gene Expression Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>We present 'Platypus', an open-source software platform providing a user-friendly interface to investigate B-cell receptor and T-cell receptor repertoires from scSeq experiments. 'Platypus' provides a framework to automate and ease the analysis of single-cell immune repertoires while also incorporating transcriptional information involving unsupervised clustering, gene expression and gene ontology. This R version of 'Platypus' is part of the 'ePlatypus' ecosystem for computational analysis of immunogenomics data: Yermanos et al. (2021) &lt;<a href="https://doi.org/10.1093%2Fnargab%2Flqab023">doi:10.1093/nargab/lqab023</a>&gt;, Cotet et al. (2023) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtad553">doi:10.1093/bioinformatics/btad553</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>3.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Yermanos &lt;ayermanos@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Biostrings, cowplot, dplyr, ggplot2, ggtree, jsonlite, knitr,
magrittr, Matrix(&ge; 1.3-3), plyr, reshape2, seqinr, Seurat,
SeuratObject(&ge; 4.1.3), stringr, tibble, tidyr, utils, useful</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AnnotationDbi, ape, BiocGenerics, biomaRt, circlize, cluster,
doParallel, fgsea, ggalluvial, ggrepel, ggridges, gridExtra,
harmony, igraph, iNEXT, limma, kmer, msigdbr, phangorn,
pheatmap, phytools, purrr, readr, readxl, rstudioapi, Rtsne,
scales, sf, SingleCellExperiment, slingshot, stringdist,
tidytree, tidyselect, tidyverse, umap, vegan, viridis, testthat
(&ge; 3.0.0),</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-20 16:43:07 UTC; tudorcotet</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Yermanos [aut, cre],
  Andreas Agrafiotis [ctb],
  Victor Kreiner [ctb],
  Tudor-Stefan Cotet [ctb],
  Raphael Kuhn [ctb],
  Danielle Shlesinger [ctb],
  Jiami Han [ctb],
  Vittoria Martinolli D'Arcy [ctb],
  Lucas Stalder [ctb],
  Daphne van Ginneken [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 20:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='GEX_cluster_genes'>Differentially expressed genes between clusters or data subsets</h2><span id='topic+GEX_cluster_genes'></span>

<h3>Description</h3>

<p>For more flexibility consider GEX_DEgenes(). Extracts the differentially expressed genes between two samples. This function uses the FindMarkers function from the Seurat package. Further parameter control can be accomplished by calling the function directly on the output of automate_GEX or VDJ_GEX_matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_cluster_genes(GEX, min.pct, filter, base, platypus.version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_cluster_genes_+3A_gex">GEX</code></td>
<td>
<p>Output Seurat object of either automate_GEX for platypus.version v2 or of VDJ_GEX_matrix for platypus.version v3 (usually VDJ_GEX_matrix.output[[2]])</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_+3A_min.pct">min.pct</code></td>
<td>
<p>The minimum percentage of cells expressing a gene in either of the two groups to be compared. Default is 0.25</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_+3A_filter">filter</code></td>
<td>
<p>Character vector of initials of the genes to be filtered. Default is c(&quot;MT-&quot;, &quot;RPL&quot;, &quot;RPS&quot;), which filters mitochondrial and ribosomal genes.</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_+3A_base">base</code></td>
<td>
<p>The base with respect to which logarithms are computed. Default: 2</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_+3A_platypus.version">platypus.version</code></td>
<td>
<p>is set automatically</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing the output from the FindMarkers function, which contains information regarding the genes that are differentially regulated, statistics (p value and log fold change), and the percent of cells expressing the particular gene. Ech element in the list corresponds to the clusters in numerical order. For example, the first element in the list output[[1]] corresponds to the genes deferentially expressed in cluster 0 in GEX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GEX_cluster_genes(GEX = subset(Platypus::small_vgm[[2]], seurat_clusters %in% c(0,1)), min.pct = .25
, filter = c("MT-", "RPL", "RPS"))

</code></pre>

<hr>
<h2 id='GEX_cluster_genes_heatmap'>Heatmap of cluster defining genes</h2><span id='topic+GEX_cluster_genes_heatmap'></span>

<h3>Description</h3>

<p>Produces a heatmap displaying the expression of the top genes that define each cluster in the Seurat object. The output heatmap is derived from DoHeatmap from Seurat and thereby can be edited using typical ggplot interactions. The number of genes per cluster and the nunber of cells to display can be specified by the user. Either the log fold change or the p value can be used to select the top n genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_cluster_genes_heatmap(
  GEX,
  GEX_cluster_genes.output,
  n.genes.per.cluster,
  metric,
  max.cell,
  group.colors,
  slot,
  platypus.version
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_cluster_genes_heatmap_+3A_gex">GEX</code></td>
<td>
<p>Output Seurat object of either automate_GEX for platypus.version v2 or of VDJ_GEX_matrix for platypus.version v3 (usually VDJ_GEX_matrix.output[[2]])</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_heatmap_+3A_gex_cluster_genes.output">GEX_cluster_genes.output</code></td>
<td>
<p>The output from the GEX_cluster_genes function - this should be a list with each list element corresponding to the genes, p values, logFC, pct expression for the genes deferentially regulated for each cluster.</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_heatmap_+3A_n.genes.per.cluster">n.genes.per.cluster</code></td>
<td>
<p>An integer value determining how many genes per cluster to display in the output heatmap. This number should be adjusted based on the number of clusters. Too many genes per cluster and clusters may cause a problem with the heatmap function in Seurat.</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_heatmap_+3A_metric">metric</code></td>
<td>
<p>The metric that dictates which are the top n genes returned. Possible options are &quot;p.value&quot; (default), &quot;avg_logFC&quot;, &quot;top_logFC&quot;, &quot;bottom_logFC&quot;. &quot;top_logFC&quot; returns the top expressed genes for each cluster, whereas &quot;bottom_logFC&quot; returns the least expressed genes per cluster-both by log fold change.</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_heatmap_+3A_max.cell">max.cell</code></td>
<td>
<p>The max number of cells to display in the heatmap for each cluster, which corresponds to the number of columns. Default is set to 100 cells per cluster.</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_heatmap_+3A_group.colors">group.colors</code></td>
<td>
<p>Optional character vector. Array of colors with the same length as GEX_cluster_genes.output to color bars above the heatmap. Defaults to rainbow palette</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_heatmap_+3A_slot">slot</code></td>
<td>
<p>Seurat object slot from which to plot gene expression data.</p>
</td></tr>
<tr><td><code id="GEX_cluster_genes_heatmap_+3A_platypus.version">platypus.version</code></td>
<td>
<p>is set automatically</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heatmap from the function DoHeatmap from the package Seurat, which is a ggplot object that can be modified or plotted. The number of genes is determined by the n.genes parameter and the number of cells per cluster is determined by the max.cell argument. This function gives a visual description of the top genes differentially expressed in each cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
GEX_cluster_genes_output &lt;- GEX_cluster_genes(GEX =
subset(Platypus::small_vgm[[2]],
seurat_clusters %in% c(0,1)), min.pct = .25
, filter = c("MT-", "RPL", "RPS"))

cluster_defining_gene_heatmap &lt;- GEX_cluster_genes_heatmap(GEX =
Platypus::small_vgm[[2]]
,GEX_cluster_genes.output=GEX_cluster_genes_output
,n.genes.per.cluster=5,metric="p.value",max.cell=5)
})

</code></pre>

<hr>
<h2 id='GEX_cluster_membership'>Cluster membership plots by sample</h2><span id='topic+GEX_cluster_membership'></span>

<h3>Description</h3>

<p>Plots the cluster membership for each of the distinct samples in the Seurat object from the automate_GEX function. The distinct samples are determined by &quot;sample_id&quot; field in the Seurat object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_cluster_membership(GEX, by.group, platypus.version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_cluster_membership_+3A_gex">GEX</code></td>
<td>
<p>Output Seurat object containing gene expression data from automate_GEX (platypus.version = &quot;v2&quot;) or VDJ_GEX_matrix (platypus.version = &quot;v3&quot;, usually VDJ_GEX_matrix.output[[2]])function that contained at least two distinct biological samples. The different biological samples correspond to integer values (v2) or factor values (v3) in the order of the working directories initially supplied to the automate_GEX function.</p>
</td></tr>
<tr><td><code id="GEX_cluster_membership_+3A_by.group">by.group</code></td>
<td>
<p>Logical indicating whether to look at the cluster distribution per group (using the group_id column). Default is set to FALSE.</p>
</td></tr>
<tr><td><code id="GEX_cluster_membership_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Version of platypus to use. Defaults to &quot;v2&quot;. If an output of the GEX_automate function is supplied, set to &quot;v2&quot;. If an output of the VDJ_GEX_matrix function is supplied set to &quot;v3&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object in which the values on the x axis correspond to each cluster found in the Seurat object. The y axis corresponds to the percentage of cells found in each cluster. The bar and color corresponds to the distinct sample_id.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GEX_cluster_membership(GEX= Platypus::small_vgm[[2]], platypus.version = "v3")
</code></pre>

<hr>
<h2 id='GEX_coexpression_coefficient'>Coexpression of selected genes</h2><span id='topic+GEX_coexpression_coefficient'></span>

<h3>Description</h3>

<p>Returns eiter a plot or numeric data of coexpression levels of selected genes.Coexpression % is calculated as the quotient of double positive cells (counts \&gt; 0) and the sum of total cells positive for either genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_coexpression_coefficient(GEX, genes, subsample.n, plot.dotmap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_coexpression_coefficient_+3A_gex">GEX</code></td>
<td>
<p>GEX seurat object generated with VDJ_GEX_matrix (VDJ_GEX_matrix.output\[\[2\]\])</p>
</td></tr>
<tr><td><code id="GEX_coexpression_coefficient_+3A_genes">genes</code></td>
<td>
<p>Character vector. At least 2 genes present in rownames(GEX). Use &quot;all&quot; to include all genes. The number of comparisons to make is the length(genes)! (factorial). More than 100 genes are not recommended.</p>
</td></tr>
<tr><td><code id="GEX_coexpression_coefficient_+3A_subsample.n">subsample.n</code></td>
<td>
<p>Interger. Number of cells to subsample. If set to 100, 100 cells will be randomly sampled for the calculation</p>
</td></tr>
<tr><td><code id="GEX_coexpression_coefficient_+3A_plot.dotmap">plot.dotmap</code></td>
<td>
<p>Boolean. Whether to return a plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe if pot.dotmap == FALSE or a ggplot if plot.dotmap == TRUE detailing the coexpression levels of selected genes within the given cell population
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GEX_coexpression_coefficient(GEX = Platypus::small_vgm[[2]]
, genes = c("CD19", "CD83"), subsample.n = "none", plot.dotmap = FALSE)
</code></pre>

<hr>
<h2 id='GEX_DEgenes'>Wrapper for differential gene expression analysis and plotting</h2><span id='topic+GEX_DEgenes'></span>

<h3>Description</h3>

<p>Extracts the differentially expressed genes between two groups of cells. These groups are defined as cells having either of two entries (group1, group2) in the grouping.column of the input Seurat object metadata This function uses the FindMarkers function from the Seurat package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_DEgenes(
  GEX,
  FindMarkers.out,
  grouping.column,
  group1,
  group2,
  min.pct,
  filter,
  return.plot,
  logFC,
  color.p.threshold,
  color.log.threshold,
  color.by.threshold,
  up.genes,
  down.genes,
  base,
  label.n.top.genes,
  genes.to.label,
  platypus.version,
  size.top.colorbar
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_DEgenes_+3A_gex">GEX</code></td>
<td>
<p>Output Seurat object from automate_GEX or VDJ_GEX_matrix_function (VDJ_GEX_matrix.output[[2]]) function that contained at least two distinct biological groups.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_findmarkers.out">FindMarkers.out</code></td>
<td>
<p>OPTIONAL: the output of the FindMarkers function. This skips the DEG calculation step and outputs desired plots. All plotting parameters function as normal. Grouping parameters and min.pct are ignored.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_grouping.column">grouping.column</code></td>
<td>
<p>Character. A column name of GEX@meta.data. In this column, group1 and group2 should be found. Defaults to &quot;sample_id&quot;. Could also be set to &quot;seurat_clusters&quot; to generate DEGs between cells of 2 chosen clusters.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_group1">group1</code></td>
<td>
<p>either character or integer specifying the first group of cells that should be compared. (e.g. &quot;s1&quot; if sample_id is used as grouping.column)</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_group2">group2</code></td>
<td>
<p>either character or integer specifying the first group of cells that should be compared. (e.g. &quot;s2&quot; if sample_id is used as grouping.column)</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_min.pct">min.pct</code></td>
<td>
<p>The minimum percentage of cells expressing a gene in either of the two groups to be compared.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_filter">filter</code></td>
<td>
<p>Character vector of initials of the genes to be filtered. Default is c(&quot;MT-&quot;, &quot;RPL&quot;, &quot;RPS&quot;), which filters mitochondrial and ribosomal genes.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_return.plot">return.plot</code></td>
<td>
<p>Character specifying if a &quot;heatmap&quot;, &quot;heatmap&quot; or a &quot;volcano&quot; or &quot;none&quot; is to be returned. If not &quot;none&quot; then @return is a list where the first element is a dataframe and the second a plot (see @return). Defaults to none</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_logfc">logFC</code></td>
<td>
<p>Logical specifying whether the genes will be displayed based on logFC (TRUE) or pvalue (FALSE).</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_color.p.threshold">color.p.threshold</code></td>
<td>
<p>numeric specifying the adjusted p-value threshold for geom_points to be colored. Default is set to 0.01.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_color.log.threshold">color.log.threshold</code></td>
<td>
<p>numeric specifying the absolute logFC threshold for geom_points to be colored. Default is set to 0.25.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_color.by.threshold">color.by.threshold</code></td>
<td>
<p>Boolean. Set to TRUE to color by color.p.threshold and color.log.threshold. Set to FALSE for a continuous color scale by fold change.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_up.genes">up.genes</code></td>
<td>
<p>FOR HEATMAP Integer specifying the number of upregulated genes to be shown.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_down.genes">down.genes</code></td>
<td>
<p>FOR HEATMAP Integer specifying the number of downregulated genes to be shown.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_base">base</code></td>
<td>
<p>The base with respect to which logarithms are computed. Default: 2</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_label.n.top.genes">label.n.top.genes</code></td>
<td>
<p>FOR VOLCANO Interger. How many top genes to label either by Fold change (if logFC ==TRUE) or by p.value (if logFC == FALSE). More than 50 are not recommended. Also works in conjunction with genes.to.label</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_genes.to.label">genes.to.label</code></td>
<td>
<p>FOR VOLCANO Character vector of genes to label irregardless of their p value.</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Function works with V2 and V3, no need to set this parameter</p>
</td></tr>
<tr><td><code id="GEX_DEgenes_+3A_size.top.colorbar">size.top.colorbar</code></td>
<td>
<p>Integer. Size of the top colorbar for heatmap plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe containing the output from the FindMarkers function, which contains information regarding the genes that are differentially regulated, statistics (p value and log fold change), and the percent of cells expressing the particular gene for both groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DEGs &lt;- GEX_DEgenes(GEX = Platypus::small_vgm[[2]],min.pct = .25,
group1 = "s1",group2 = "s2", return.plot = "volcano")
</code></pre>

<hr>
<h2 id='GEX_dottile_plot'>GEX Dottile plots</h2><span id='topic+GEX_dottile_plot'></span>

<h3>Description</h3>

<p>Outputs a dotplot for gene expression, where the color of each dot is scaled by the gene expression level and the size is scaled by the % of cells positive for the gene
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_dottile_plot(GEX, genes, group.by, threshold.to.plot, platypus.version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_dottile_plot_+3A_gex">GEX</code></td>
<td>
<p>GEX seurat object generated with VDJ_GEX_matrix</p>
</td></tr>
<tr><td><code id="GEX_dottile_plot_+3A_genes">genes</code></td>
<td>
<p>Character vector. Genes of those in rownames(GEX) to plot. Can be any number, but more then 30 is discuraged because of cluttering</p>
</td></tr>
<tr><td><code id="GEX_dottile_plot_+3A_group.by">group.by</code></td>
<td>
<p>Character. Name of a column in GEX@meta.data to split the plot by. If set to \&quot;none\&quot;, a plot with a single column will be produced.</p>
</td></tr>
<tr><td><code id="GEX_dottile_plot_+3A_threshold.to.plot">threshold.to.plot</code></td>
<td>
<p>Integer 1-100. % of cells which must be expressing the feature to plot a point. If below, the field will be left empty</p>
</td></tr>
<tr><td><code id="GEX_dottile_plot_+3A_platypus.version">platypus.version</code></td>
<td>
<p>This is coded for \&quot;v3\&quot; only, but in practice any Seurat Object can be fed in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object were the dot size indicates the percentage of expressing cells and the dot color indicates the expression level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GEX_dottile_plot(GEX = Platypus::small_vgm[[2]], genes = c("CD19","CD83"),
group.by = "seurat_clusters", threshold.to.plot = 5)

</code></pre>

<hr>
<h2 id='GEX_gene_visualization'>Visualization of marker expression in a data set or of predefined genes (B cells, CD4 T cells and CD8 T cells).</h2><span id='topic+GEX_gene_visualization'></span>

<h3>Description</h3>

<p>Visualization of marker expression in a data set or of predefined genes (B cells, CD4 T cells and CD8 T cells).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_gene_visualization(
  GEX,
  gene_set,
  predefined_genes = c("B_cell", "CD4_T_cell", "CD8_T_cell"),
  group.by
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_gene_visualization_+3A_gex">GEX</code></td>
<td>
<p>GEX output of the VDJ_GEX_matrix function (VDJ_GEX_matrix[[2]])).</p>
</td></tr>
<tr><td><code id="GEX_gene_visualization_+3A_gene_set">gene_set</code></td>
<td>
<p>Character vector containing the markers of interest given by the user.</p>
</td></tr>
<tr><td><code id="GEX_gene_visualization_+3A_predefined_genes">predefined_genes</code></td>
<td>
<p>Character vector to chose between B_cell, CD4_T_cell, and CD8_T_cell.</p>
</td></tr>
<tr><td><code id="GEX_gene_visualization_+3A_group.by">group.by</code></td>
<td>
<p>Character. Column name of vgm to group plots by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list. Element[[1]] is the feature plot of markers of interest or predefined genes. Element[[2]] is the dottile plot of markers of interest or predefined genes. Element[[3]] is the violin plot of markers of interest or predefined genes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GEX_gene_visualization(GEX = Platypus::small_vgm[[2]], predefined_genes = "B_cell")

</code></pre>

<hr>
<h2 id='GEX_GSEA'>GEX Gene Set Enrichment Analysis and plotting</h2><span id='topic+GEX_GSEA'></span>

<h3>Description</h3>

<p>Conducts a Gene Set Enrichment Analysis (GSEA) on a set of genes submitted in a data frame with a metric each.
Works with the output of GEX_genes_cluster or a custom data frame containing the gene symbols either in a column &quot;symbols&quot; or as rownames and a metric for each gene.
The name of the column containing the metric has to be declared via the input metric.colname.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_GSEA(
  GEX.cluster.genes.output,
  MT.Rb.filter,
  filter,
  path.to.pathways,
  metric.colname,
  pval.adj.cutoff,
  Enrichment.Plots,
  my.own.geneset,
  eps,
  platypus.version
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_GSEA_+3A_gex.cluster.genes.output">GEX.cluster.genes.output</code></td>
<td>
<p>Data frame containing the list of gene symbols and a metric. Function works directly with GEX_cluster_genes output.</p>
</td></tr>
<tr><td><code id="GEX_GSEA_+3A_mt.rb.filter">MT.Rb.filter</code></td>
<td>
<p>Logical, should Mitotic and Ribosomal genes be filtered out of the geneset. True by default.</p>
</td></tr>
<tr><td><code id="GEX_GSEA_+3A_filter">filter</code></td>
<td>
<p>Character vector containing the identifying symbol sequence for the genes which should be filtered out, if MT.Rb.filter == TRUE. By default set to c(&quot;MT-&quot;, &quot;RPL&quot;, &quot;RPS&quot;).</p>
</td></tr>
<tr><td><code id="GEX_GSEA_+3A_path.to.pathways">path.to.pathways</code></td>
<td>
<p>Either a path to gmt file containing the gene sets (can be downloaded from MSigDB) or vector where first element specifies species and second element specifies the MSigDB collection abbreviation. E.g.: c(&quot;Homo sapiens&quot;, &quot;H&quot;). Mouse C7 (immunologic signature) gene set will be used by default.</p>
</td></tr>
<tr><td><code id="GEX_GSEA_+3A_metric.colname">metric.colname</code></td>
<td>
<p>Name of column which contains the metric used for the ranking of the submitted genelist. &quot;avg_logFC&quot; is used by default.</p>
</td></tr>
<tr><td><code id="GEX_GSEA_+3A_pval.adj.cutoff">pval.adj.cutoff</code></td>
<td>
<p>Only genes with a more significant adjusted pvalue are considered. Default: 0.001</p>
</td></tr>
<tr><td><code id="GEX_GSEA_+3A_enrichment.plots">Enrichment.Plots</code></td>
<td>
<p>List of Gene-set names which should be plotted as Enrichment plots in addition to the top 10 Up and Downregulated Genesets.</p>
</td></tr>
<tr><td><code id="GEX_GSEA_+3A_my.own.geneset">my.own.geneset</code></td>
<td>
<p>A list, where each element contains a gene list and is named with the corresponding pathway name. Default is set to FALSE, so that gene sets from MSigDB are used. Should not contain &quot;.gmt&quot; in name.</p>
</td></tr>
<tr><td><code id="GEX_GSEA_+3A_eps">eps</code></td>
<td>
<p>Numeric, specifying boundary for calculating the p value in the GSEA.</p>
</td></tr>
<tr><td><code id="GEX_GSEA_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Function works with V2 and V3, no need to set this parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing a tibble with the gene sets and their enrichment scores and Enrichment plots. List element [[1]]: Dataframe with Genesets and statistics. [[2]]: Enrichment plots of top10 Up regulated genesets. [[3]]: Enrichment plots of top10 Down regulated genesets. [[4]]: Enrichment plots of submited gene-sets in parameter Enrichment.Plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
df &lt;- GEX_cluster_genes(Platypus::small_vgm[[2]])

output &lt;- GEX_GSEA(GEX.cluster.genes.output =  df[[1]], MT.Rb.filter = TRUE
, path.to.pathways = "./c5.go.bp.v7.2.symbols.gmt")
cowplot::plot_grid(plotlist=output[[2]], ncol=2)

output &lt;- GEX_GSEA(GEX.cluster.genes.output =  df[[1]], MT.Rb.filter = TRUE
, path.to.pathways = c("Mus musculus", "C7"))

output &lt;- GEX_GSEA(GEX.cluster.genes.output =  df[[1]], MT.Rb.filter = TRUE
, my.own.geneset = my_geneset)
})

</code></pre>

<hr>
<h2 id='GEX_heatmap'>Flexible GEX heatmap wrapper</h2><span id='topic+GEX_heatmap'></span>

<h3>Description</h3>

<p>Produces a heatmap containing gene expression information at the clonotype level. The rows correspond to different genes that can either be determined by pre-made sets of B or T cell markers, or can be customized by the user. The columns correspond to individual cells and the colors correspond to the different clonotype families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_heatmap(
  GEX,
  b.or.t,
  sample.index,
  clone.rank.threshold,
  custom.array,
  slot
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_heatmap_+3A_gex">GEX</code></td>
<td>
<p>A single seurat object from clonotype_GEX function corresponding to all of the samples in a single VDJ_analyze object. This will likely be supplied as clonotype_GEX.output[[i]] if there were multiple, distinct transcriptomes.</p>
</td></tr>
<tr><td><code id="GEX_heatmap_+3A_b.or.t">b.or.t</code></td>
<td>
<p>Logical indicating if B or T cell gene panel should be used.</p>
</td></tr>
<tr><td><code id="GEX_heatmap_+3A_sample.index">sample.index</code></td>
<td>
<p>Corresponds to which repertoire should be used in the case that the length of clonotype.list has a length greater than 1. The transcriptional profiles from only one repertoire can be plotted at a time.</p>
</td></tr>
<tr><td><code id="GEX_heatmap_+3A_clone.rank.threshold">clone.rank.threshold</code></td>
<td>
<p>A numeric that specifies the threshold clonal rank that specifies which clonotypes to extract transcriptome information from. For example, if 10 is supplied then the gene expression for the top ten clones included on the heatmap, separated by clonotype.</p>
</td></tr>
<tr><td><code id="GEX_heatmap_+3A_custom.array">custom.array</code></td>
<td>
<p>Corresponds to which repertoire should be used in the case that the length of clonotype.list has a length greater than 1. The transcriptional profiles from only one repertoire can be plotted at a time.</p>
</td></tr>
<tr><td><code id="GEX_heatmap_+3A_slot">slot</code></td>
<td>
<p>Seurat data slot from which to plot values. Can be &quot;raw.data&quot;, &quot;data&quot; or &quot;scale.data&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a heatmap via Seurat::DoHeatmap of gene expression per clonotype
</p>


<h3>See Also</h3>

<p>VDJ_extract_sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>small_vgm &lt;- Platypus::small_vgm
small_vgm[[2]]$clone_rank &lt;- c(1:nrow(small_vgm[[2]]@meta.data))
GEX_heatmap(GEX = small_vgm[[2]],b.or.t = "custom"
,clone.rank.threshold = 1,sample.index = "s1"
,custom.array = c("CD24A","CD83"), slot = "data")

</code></pre>

<hr>
<h2 id='GEX_lineage_trajectories'>This is a function to infer single cell trajectories and identifying lineage structures on clustered cells. Using the slingshot library</h2><span id='topic+GEX_lineage_trajectories'></span>

<h3>Description</h3>

<p>This is a function to infer single cell trajectories and identifying lineage structures on clustered cells. Using the slingshot library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_lineage_trajectories(GEX, grouping, cluster.num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_lineage_trajectories_+3A_gex">GEX</code></td>
<td>
<p>GEX output of the VDJ_GEX_matrix function (VDJ_GEX_matrix[[2]]))</p>
</td></tr>
<tr><td><code id="GEX_lineage_trajectories_+3A_grouping">grouping</code></td>
<td>
<p>Determine by which identifier to group by. E.g. 'group_id' or default 'seurat_clusters' which are automatically generated in the clustering process.</p>
</td></tr>
<tr><td><code id="GEX_lineage_trajectories_+3A_cluster.num">cluster.num</code></td>
<td>
<p>A seurat cluster number for starting point of the lineage. Can be identified by using Seurat::DimPlot(VGM[[2]],group.by = &quot;seurat_clusters&quot;). Default is &quot;0&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list. Element [[1]] returns updated GEX object with the inferred pseudotime trajectories per lineage. [[2]] returns the UMAP with the grouped cells. [[3]] and [[4]] show the slingshot inferred trajectories in two different styles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
lineage_trajectories &lt;- GEX_lineage_trajectories(Platypus::small_vgm[[2]],
 grouping = 'group_id',
 cluster.num = "3")
})

</code></pre>

<hr>
<h2 id='GEX_pairwise_DEGs'>Wrapper for calculating pairwise differentially expressed genes</h2><span id='topic+GEX_pairwise_DEGs'></span>

<h3>Description</h3>

<p>Produces and saves a list of volcano plots with each showing differentially expressed genes between pairs groups. If e.g. seurat_clusters used as group.by, a plot will be generated for every pairwise comparison of clusters. For large numbers of this may take longer to run. Only available for platypus v3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_pairwise_DEGs(
  GEX,
  group.by,
  min.pct,
  RP.MT.filter,
  label.n.top.genes,
  genes.to.label,
  save.plot,
  save.csv
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_pairwise_DEGs_+3A_gex">GEX</code></td>
<td>
<p>Output Seurat object of the VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[2]])</p>
</td></tr>
<tr><td><code id="GEX_pairwise_DEGs_+3A_group.by">group.by</code></td>
<td>
<p>Character. Defaults to &quot;seurat_clusters&quot; Column name of GEX@meta.data to use for pairwise comparisons. More than 20 groups are discuraged.</p>
</td></tr>
<tr><td><code id="GEX_pairwise_DEGs_+3A_min.pct">min.pct</code></td>
<td>
<p>Numeric. Defaults to 0.25 passed to Seurat::FindMarkers</p>
</td></tr>
<tr><td><code id="GEX_pairwise_DEGs_+3A_rp.mt.filter">RP.MT.filter</code></td>
<td>
<p>Boolean. Defaults to True. If True, mitochondrial and ribosomal genes are filtered out from the output of Seurat::FindMarkers</p>
</td></tr>
<tr><td><code id="GEX_pairwise_DEGs_+3A_label.n.top.genes">label.n.top.genes</code></td>
<td>
<p>Integer. Defaults to 50. Defines how many genes are labelled via geom_text_repel. Genes are ordered by adjusted p value and the first label.n.genes are labelled</p>
</td></tr>
<tr><td><code id="GEX_pairwise_DEGs_+3A_genes.to.label">genes.to.label</code></td>
<td>
<p>Character vector. Defaults to &quot;none&quot;. Vector of gene names to plot independently of their p value. Can be used in combination with label.n.genes.</p>
</td></tr>
<tr><td><code id="GEX_pairwise_DEGs_+3A_save.plot">save.plot</code></td>
<td>
<p>Boolean. Defaults to False. Whether to save plots as appropriately named .png files</p>
</td></tr>
<tr><td><code id="GEX_pairwise_DEGs_+3A_save.csv">save.csv</code></td>
<td>
<p>Boolean. Defaults to False. Whether to save deg tables as appropriately named .csv files</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list with out[[i]][[1]] being ggplot volcano plots and out[[i]][[2]] being source DEG dataframes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GEX_pairwise_DEGs(GEX = Platypus::small_vgm[[2]],group.by = "sample_id"
,min.pct = 0.25,RP.MT.filter = TRUE,label.n.top.genes = 2,genes.to.label = c("CD24A")
,save.plot = FALSE, save.csv = FALSE)

</code></pre>

<hr>
<h2 id='GEX_phenotype'>Assignment of cells to phenotypes based on selected markers</h2><span id='topic+GEX_phenotype'></span>

<h3>Description</h3>

<p>Adds a column to a VGM[[2]] Seurat object containing cell phenotype assignments. Defaults for T and B cells are available. Marker sets are customizable as below
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_phenotype(seurat.object, cell.state.names, cell.state.markers, default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_phenotype_+3A_seurat.object">seurat.object</code></td>
<td>
<p>A single seurat object / VDJ_GEX_matrix.output[[2]] object</p>
</td></tr>
<tr><td><code id="GEX_phenotype_+3A_cell.state.names">cell.state.names</code></td>
<td>
<p>Character vector containing the cell state labels defined by the markers in cell.state.markers parameter. Example is c(&quot;NaiveCd4&quot;,&quot;MemoryCd4&quot;).</p>
</td></tr>
<tr><td><code id="GEX_phenotype_+3A_cell.state.markers">cell.state.markers</code></td>
<td>
<p>Character vector containing the gene names for each state. ; is used to use multiple markers within a single gene state. Different vector elements correspond to different states. Order must match cell.state.names containing the c(&quot;CD4+;CD44-&quot;,&quot;CD4+;IL7R+;CD44+&quot;).</p>
</td></tr>
<tr><td><code id="GEX_phenotype_+3A_default">default</code></td>
<td>
<p>Default is TRUE - will use predefined gene sets and cell states.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input Seurat object with an additional column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vgm.phenotyped &lt;- GEX_phenotype(seurat.object = Platypus::small_vgm[[2]]
, default = TRUE)

</code></pre>

<hr>
<h2 id='GEX_phenotype_per_clone'>Plotting of GEX phenotype by VDJ clone</h2><span id='topic+GEX_phenotype_per_clone'></span>

<h3>Description</h3>

<p>Integrates VDJ and gene expression libraries by providing cluster membership seq_per_vdj object and the index of the cell in the Seurat RNA-seq object.
! For platypus.version == &quot;v3&quot; and VDJ_GEX_matrix output the function will iterate over entries in the sample_id column of the GEX by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_phenotype_per_clone(
  GEX,
  clonotype.ids,
  global.clonotypes,
  GEX.group.by,
  GEX.clonotypes,
  platypus.version
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_phenotype_per_clone_+3A_gex">GEX</code></td>
<td>
<p>For platypus.version == &quot;v3&quot; the GEX object from the output of the VDJ_GEX_matrix function (VDJ_GEX_matrix.output \[\[2\]\]). For platypus.version == &quot;v2&quot; a single seurat object from automate_GEX function after labeling cell phenotypes using the GEX_phenotype function.</p>
</td></tr>
<tr><td><code id="GEX_phenotype_per_clone_+3A_clonotype.ids">clonotype.ids</code></td>
<td>
<p>For platypus.version == &quot;v2&quot; Output from either VDJ_analyze or VDJ_clonotype functions. This list should correspond to a single GEX.list object, in which each list element in clonotype.list is found in the GEX.object. Furthermore, these repertoires should be found in the automate_GEX library.</p>
</td></tr>
<tr><td><code id="GEX_phenotype_per_clone_+3A_global.clonotypes">global.clonotypes</code></td>
<td>
<p>Boolean. Defaults to FALSE. Set to True if clonotyping has been done across samples</p>
</td></tr>
<tr><td><code id="GEX_phenotype_per_clone_+3A_gex.group.by">GEX.group.by</code></td>
<td>
<p>For platypus.version == &quot;v3&quot;. Character. Column name of the GEX@meta.data to group barplot by. Defaults to seurat_clusters</p>
</td></tr>
<tr><td><code id="GEX_phenotype_per_clone_+3A_gex.clonotypes">GEX.clonotypes</code></td>
<td>
<p>For platypus.version == &quot;v3&quot;. Numeric vector with ids of clonotypes to plot e.g. c(1,2,3,4). Can also be set to &quot;topclones&quot;</p>
</td></tr>
<tr><td><code id="GEX_phenotype_per_clone_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Set to either &quot;v2&quot; or &quot;v3&quot; depending on wether suppyling GEX_automate or VDJ_GEX_matrix\[\[2\]\] objects. Defaults to &quot;v3&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a stacked barplot that visualizes the seurat cluster membership for different cell phenotypes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>small_vgm_cl &lt;- Platypus::small_vgm
small_vgm_cl[[2]]$clonotype_id_10x &lt;- "clonotype1"
GEX_phenotype_per_clone(GEX = small_vgm_cl[[2]]
, GEX.clonotypes = c(1), GEX.group.by = "seurat_clusters", platypus.version = "v3")

</code></pre>

<hr>
<h2 id='GEX_proportions_barplot'>Plots proportions of a group of cells within a secondary group of cells. E.g. The proportions of samples in seurat clusters, or the proportions of samples in defined cell subtypes</h2><span id='topic+GEX_proportions_barplot'></span>

<h3>Description</h3>

<p>Plots proportions of a group of cells within a secondary group of cells. E.g. The proportions of samples in seurat clusters, or the proportions of samples in defined cell subtypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_proportions_barplot(GEX, source.group, target.group, stacked.plot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_proportions_barplot_+3A_gex">GEX</code></td>
<td>
<p>GEX Seurat object generated with VDJ_GEX_matrix (VDJ_GEX_matrix.output[[2]])</p>
</td></tr>
<tr><td><code id="GEX_proportions_barplot_+3A_source.group">source.group</code></td>
<td>
<p>Character. A column name of the GEX@meta.data with the group of which proportions should be plotted</p>
</td></tr>
<tr><td><code id="GEX_proportions_barplot_+3A_target.group">target.group</code></td>
<td>
<p>Character. A column name of the GEX@meta.data with the group to calculate proportions within. If unsure, see examples for clarification</p>
</td></tr>
<tr><td><code id="GEX_proportions_barplot_+3A_stacked.plot">stacked.plot</code></td>
<td>
<p>Boolean. Defaults to FALSE. Whether to return a stacked barplot, with the y axis representing the % of cells of the target group. If set to FALSE a normal barplot (position = &quot;dodge&quot;) will be returned with the y axis representing the % of cells of the source group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot barplot showing cell proportions by source and target group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
GEX_proportions_barplot(GEX = Platypus::small_vgm[[2]], source.group = "sample_id"
, target.group = "seurat_clusters",stacked.plot = FALSE)
GEX_proportions_barplot(GEX = Platypus::small_vgm[[2]],
source.group = "seurat_clusters", target.group = "sample_id"
,stacked.plot = TRUE)
})

</code></pre>

<hr>
<h2 id='GEX_scatter_coexpression'>Scatter plot for coexpression of two selected genes</h2><span id='topic+GEX_scatter_coexpression'></span>

<h3>Description</h3>

<p>Plots a composite figure showing single marker expression as histograms and coexpression as a scatterplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_scatter_coexpression(GEX, gene.1, gene.2, color.theme)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_scatter_coexpression_+3A_gex">GEX</code></td>
<td>
<p>GEX seurat object generated with VDJ_GEX_matrix</p>
</td></tr>
<tr><td><code id="GEX_scatter_coexpression_+3A_gene.1">gene.1</code></td>
<td>
<p>Character. Name of a gene in rownames(VDJ.matrix)</p>
</td></tr>
<tr><td><code id="GEX_scatter_coexpression_+3A_gene.2">gene.2</code></td>
<td>
<p>Character. Name of a gene in rownames(VDJ.matrix)</p>
</td></tr>
<tr><td><code id="GEX_scatter_coexpression_+3A_color.theme">color.theme</code></td>
<td>
<p>Character. A color to use for the composite plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a gridplot showing coexpression scatterplot as well as histograms of gene.1 and gene.2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gene1 &lt;- "CD24A"
gene2 &lt;- "CD83"
GEX_scatter_coexpression(GEX = Platypus::small_vgm[[2]], gene1,gene2)

</code></pre>

<hr>
<h2 id='GEX_volcano'>Flexible wrapper for GEX volcano plots</h2><span id='topic+GEX_volcano'></span>

<h3>Description</h3>

<p>Plots a volcano plot from the output of the FindMarkers function from the Seurat package or the GEX_cluster_genes function alternatively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEX_volcano(
  DEGs.input,
  input.type,
  condition.1,
  condition.2,
  explicit.title,
  RP.MT.filter,
  color.p.threshold,
  color.log.threshold,
  label.p.threshold,
  label.logfc.threshold,
  n.label.up,
  n.label.down,
  by.logFC,
  maximum.overlaps,
  plot.adj.pvalue
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEX_volcano_+3A_degs.input">DEGs.input</code></td>
<td>
<p>Either output data frame from the FindMarkers function from the Seurat package or GEX_cluster_genes list output.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_input.type">input.type</code></td>
<td>
<p>Character specifing the input type as either &quot;findmarkers&quot; or &quot;cluster.genes&quot;. Defaults to &quot;cluster.genes&quot;</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_condition.1">condition.1</code></td>
<td>
<p>either character or integer specifying ident.1 that was used in the FindMarkers function from the Seurat package. Should be left empty when using the GEX_cluster_genes output.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_condition.2">condition.2</code></td>
<td>
<p>either character or integer specifying ident.2 that was used in the FindMarkers function from the Seurat package. Should be left empty when using the GEX_cluster_genes output.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_explicit.title">explicit.title</code></td>
<td>
<p>logical specifying whether the title should include logFC information for each condition.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_rp.mt.filter">RP.MT.filter</code></td>
<td>
<p>Boolean. Defaults to TRUE. Whether to exclude ribosomal and mitochondrial genes.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_color.p.threshold">color.p.threshold</code></td>
<td>
<p>numeric specifying the adjusted p-value threshold for geom_points to be colored. Default is set to 0.01.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_color.log.threshold">color.log.threshold</code></td>
<td>
<p>numeric specifying the absolute logFC threshold for geom_points to be colored. Default is set to 0.25.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_label.p.threshold">label.p.threshold</code></td>
<td>
<p>numeric specifying the adjusted p-value threshold for genes to be labeled via geom_text_repel. Default is set to 0.001.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_label.logfc.threshold">label.logfc.threshold</code></td>
<td>
<p>numeric specifying the absolute logFC threshold for genes to be labeled via geom_text_repel. Default is set to 0.75.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_n.label.up">n.label.up</code></td>
<td>
<p>numeric specifying the number of top upregulated genes to be labeled via geom_text_repel. Genes will be ordered by adjusted p-value. Overrides the &quot;label.p.threshold&quot; and &quot;label.logfc.threshold&quot; parameters.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_n.label.down">n.label.down</code></td>
<td>
<p>numeric specifying the number of top downregulated genes to be labeled via geom_text_repel. Genes will be ordered by adjusted p-value. Overrides the &quot;label.p.threshold&quot; and &quot;label.logfc.threshold&quot; parameters.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_by.logfc">by.logFC</code></td>
<td>
<p>logical. If set to TRUE n.label.up and n.label.down will label genes ordered by logFC instead of adjusted p-value.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_maximum.overlaps">maximum.overlaps</code></td>
<td>
<p>integer specifying removal of labels with too many overlaps. Default is set to Inf.</p>
</td></tr>
<tr><td><code id="GEX_volcano_+3A_plot.adj.pvalue">plot.adj.pvalue</code></td>
<td>
<p>logical specifying whether adjusted p-value should by plotted on the y-axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a volcano plot from the output of the FindMarkers function from the Seurat package, which is a ggplot object that can be modified or plotted. Infinite p-values are set defined value of the highest -log(p) + 100.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
GEX_volcano(findmarkers.output = FindMarkers.Output
, condition.1 = "cluster1", condition.2 = "cluster2"
, maximum.overlaps = 20)

GEX_volcano(findmarkers.output = FindMarkers.Output
, condition.1 = "cluster1", condition.2 = "cluster2"
, n.label.up = 50, n.label.down = 20)

GEX_volcano(findmarkers.output = GEX_cluster_genes.Output
, cluster.genes.output =TRUE)
})

</code></pre>

<hr>
<h2 id='PlatypusDB_AIRR_to_VGM'>AIRR to Platypus V3 VGM compatibility function</h2><span id='topic+PlatypusDB_AIRR_to_VGM'></span>

<h3>Description</h3>

<p>Loads in and converts input AIRR-compatible tsv file(s) into the Platypus VGM object format.All compulsory AIRR data columns are needed. Additionally, the following columns are required: v_call, cell_id, clone_id. If trim.and.align is set to TRUE additionally the following columns are needed: v_sequence_start, j_sequence_end.
Note on TRUST4 input: TRUST4 (https://doi.org/10.1038/s41592-021-01142-n2) is a newly alignment tool for VDJ data by the Shirley lab. It is able to also extract VDJ sequences from 10x GEX data. We are actively testing TRUST4 as an alternative to Cellranger and can not give recommendations as of now. This function does support the conversion of TRUST4 airr output data into the Platypus VGM format. In that case, an extra column will be added describing whether the full length VDJ sequence was extracted for any given cell and chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlatypusDB_AIRR_to_VGM(
  AIRR.input,
  get.VDJ.stats,
  VDJ.combine,
  trim.and.align,
  filter.overlapping.barcodes.VDJ,
  group.id,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlatypusDB_AIRR_to_VGM_+3A_airr.input">AIRR.input</code></td>
<td>
<p>Source of the AIRR table(s) as a list. There are 2 available input options: 1. 1. List with local paths to .tsv files / 3. List of AIRR tables loaded in as R objects within the current R environment.</p>
</td></tr>
<tr><td><code id="PlatypusDB_AIRR_to_VGM_+3A_get.vdj.stats">get.VDJ.stats</code></td>
<td>
<p>Boolean. Defaults to TRUE. Whether to generate summary statistics on repertoires and output those as output_VGM[[3]]</p>
</td></tr>
<tr><td><code id="PlatypusDB_AIRR_to_VGM_+3A_vdj.combine">VDJ.combine</code></td>
<td>
<p>Boolean. Defaults to TRUE. Whether to integrate repertoires. A sample identifier will be appended to each barcode both. Highy recommended for all later functions</p>
</td></tr>
<tr><td><code id="PlatypusDB_AIRR_to_VGM_+3A_trim.and.align">trim.and.align</code></td>
<td>
<p>Boolean. defaults to FALSE. Whether to trim VJ/VDJ seqs and add information from alignment in AIRR dataframe columns. ! No alignment is done here, instead, columns containing alignment information in the AIRR dataframes are reformatted.</p>
</td></tr>
<tr><td><code id="PlatypusDB_AIRR_to_VGM_+3A_filter.overlapping.barcodes.vdj">filter.overlapping.barcodes.VDJ</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to remove barcodes which are shared among samples in the GEX analysis. Shared barcodes normally appear at a very low rate.</p>
</td></tr>
<tr><td><code id="PlatypusDB_AIRR_to_VGM_+3A_group.id">group.id</code></td>
<td>
<p>vector with integers specifying the group membership. c(1,1,2,2) would specify the first two elements of the input AIRR list are in group 1 and the third/fourth input elements will be in group 2.</p>
</td></tr>
<tr><td><code id="PlatypusDB_AIRR_to_VGM_+3A_verbose">verbose</code></td>
<td>
<p>Writes runtime status to console. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A VDJ_GEX_Matrix object used in Platypus V3 as an input to most analysis and plotting functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VGM &lt;- PlatypusDB_AIRR_to_VGM(AIRR.input =
list("~/pathto/s1/airr_rearrangement.tsv", "~pathto/s2/airr_rearrangement.tsv"),
VDJ.combine = TRUE, group.id = c(1,2), filter.overlapping.barcodes.VDJ = TRUE)
})

</code></pre>

<hr>
<h2 id='PlatypusDB_load_from_disk'>PlatypusDB utility for import of local datasets</h2><span id='topic+PlatypusDB_load_from_disk'></span>

<h3>Description</h3>

<p>Utility function for loading in local dataset as VDJ_GEX_matrix and PlatypusDB compatible R objects. Especially useful when wanting to integrate local and public datasets. This function only imports and does not make changes to format, row and column names. Exception: filtered_contig.fasta are appended to the filtered_contig_annotations.csv as a column for easy access
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlatypusDB_load_from_disk(
  VDJ.out.directory.list,
  GEX.out.directory.list,
  FB.out.directory.list,
  batches
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlatypusDB_load_from_disk_+3A_vdj.out.directory.list">VDJ.out.directory.list</code></td>
<td>
<p>List containing paths to VDJ output directories from cell ranger. This pipeline assumes that the output file names have not been changed from the default 10x settings in the /outs/ folder. This is compatible with B and T cell repertoires (both separately and simultaneously).</p>
</td></tr>
<tr><td><code id="PlatypusDB_load_from_disk_+3A_gex.out.directory.list">GEX.out.directory.list</code></td>
<td>
<p>List containing paths the outs/ directory of each sample or directly the raw or filtered_feature_bc_matrix folder. Order of list items must be the same as for VDJ. This outs directory may also contain Feature Barcode (FB) information. Do not specify FB.out.directory in this case.</p>
</td></tr>
<tr><td><code id="PlatypusDB_load_from_disk_+3A_fb.out.directory.list">FB.out.directory.list</code></td>
<td>
<p>List of paths pointing at the outs/ directory of output of the Cellranger counts function which contain Feature barcode counts. Any input will overwrite potential FB data loaded from the GEX input directories. Length must match VDJ and GEX directory inputs. (in case of a single FB output directory for multiple samples, please specifiy this directory as many times as needed)</p>
</td></tr>
<tr><td><code id="PlatypusDB_load_from_disk_+3A_batches">batches</code></td>
<td>
<p>Integer vector. Defaults to all 1, yielding all samples with batch number &quot;b1&quot;. Give a batch number to each sample (each entry in the VDJ/GEX input lists). This will be saved as element 5 in the sample list output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Large nested list object containing all needed Cellranger outputs to run the VDJ_GEX_matrix function. Level 1 of the list are samples, level 2 are VDJ GEX and metadata information. (e.g. out[[1]][[1]] corresponds to VDJ data objects of sample 1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ.in &lt;- list()
VDJ.in[[1]] &lt;- c("~/VDJ/S1/")
VDJ.in[[2]] &lt;- c("~/VDJ/S2/")
GEX.in &lt;- list()
GEX.in[[1]] &lt;- c("~/GEX/S1/")
GEX.in[[2]] &lt;- c("~/GEX/S2/")
PlatypusDB_load_from_disk(VDJ.out.directory.list = VDJ.in, GEX.out.directory.list = GEX.in)
})

</code></pre>

<hr>
<h2 id='PlatypusDB_VGM_to_AIRR'>Platypus V3 VGM to AIRR compatibility function</h2><span id='topic+PlatypusDB_VGM_to_AIRR'></span>

<h3>Description</h3>

<p>Exports AIRR compatible tables supplemented with VDJ and GEX information from the Platypus VGM object and the cellranger output airr_rearrangements.tsv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlatypusDB_VGM_to_AIRR(
  VGM,
  VDJ.features.to.append,
  GEX.features.to.append,
  airr.rearrangements,
  airr.integrate
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlatypusDB_VGM_to_AIRR_+3A_vgm">VGM</code></td>
<td>
<p>Output object of the VDJ_GEX_matrix function generated with VDJ.combine = T, GEX.combine = T (to merge all samples) and integrate.VDJ.to.GEX = T (to integrate VDJ and GEX data)</p>
</td></tr>
<tr><td><code id="PlatypusDB_VGM_to_AIRR_+3A_vdj.features.to.append">VDJ.features.to.append</code></td>
<td>
<p>Character vector. Defaults to &quot;none&quot;. Can be either &quot;all&quot; or column names of the VGM VDJ matrix (VGM[[1]]) to append to the AIRR compatible table.</p>
</td></tr>
<tr><td><code id="PlatypusDB_VGM_to_AIRR_+3A_gex.features.to.append">GEX.features.to.append</code></td>
<td>
<p>Character vector. Defaults to &quot;none&quot;. Can be either &quot;all&quot; or GEX metadata column names or Gene names of the VGM GEX object (VGM[[2]])(passed to Seurat::FetchData()) to append to the AIRR compatible table. For a list of available features run: names(VGM[[2]]@meta.data) and rownames(VGM[[2]])</p>
</td></tr>
<tr><td><code id="PlatypusDB_VGM_to_AIRR_+3A_airr.rearrangements">airr.rearrangements</code></td>
<td>
<p>Source of the airr_rearrangements.tsv file as generated by Cellranger. There are 3 available input options: 1. R list object from Platypus_DB_load_from_disk or Platypus_DB_fetch / 2. List with local paths to airr_rearrangements.tsv / 3. List of airr_rearrangements.tsv loaded in as R objects within the current R enviroment. ! Order of input list must be identical to that of sample_ids in the VGM ! If not provided or set to &quot;none&quot; CIGAR strings in output will be empty.</p>
</td></tr>
<tr><td><code id="PlatypusDB_VGM_to_AIRR_+3A_airr.integrate">airr.integrate</code></td>
<td>
<p>Boolean. Defaults to TRUE, whether to integrate output AIRR tables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length of samples in VGM containing a AIRR-compatible dataframe for each sample if airr.integrate = F or a single dataframe if airr.integrate = T ! Cave the format: VGM object =&gt; 1 cell = 1 row; AIRR table 1 cell = as many rows as VDJ and VJ chains available for that cell. GEX cell-level information is attached to all rows containing a chain of that cell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
airr.list.out &lt;- PlatypusDB_VGM_to_AIRR(VGM = VGM
, VDJ.features.to.append = c("VDJ_cdr3s_aa")
, GEX.features.to.append = c("CTLA4", "TOX"), airr.rearrangements = Data.in)

airr.list.out &lt;- PlatypusDB_VGM_to_AIRR(VGM = VGM
, VDJ.features.to.append = c("VDJ_cdr3s_aa")
, GEX.features.to.append = c("CTLA4", "TOX"),
airr.rearrangements =list("~/path_to/s1/airr.rearrangement.tsv"
,"~/path_to/s2/airr_rearrangement.tsv"))

airr.list.out &lt;- PlatypusDB_VGM_to_AIRR(VGM = VGM
, VDJ.features.to.append = c("VDJ_cdr3s_aa")
, GEX.features.to.append = c("CTLA4", "TOX"),
airr.rearrangements = list(airr_rearrangements.s1, airr_rearrangements_2))

VDJ.out.directory.list &lt;- list()
VDJ.out.directory.list[[1]] &lt;- c("~/cellrangerVDJ/s1")
VDJ.out.directory.list[[2]] &lt;- c("~/cellrangerVDJ/s2")

GEX.out.directory.list &lt;- list()
GEX.out.directory.list[[1]] &lt;- c("~/cellrangerGEX/s1")
GEX.out.directory.list[[2]] &lt;- c("~/cellrangerGEX/s2")
VGM &lt;- VDJ_GEX_matrix(VDJ.out.directory.list = VDJ.out.directory.list,
GEX.out.directory.list = GEX.out.directory.list,
GEX.integrate = TRUE, VDJ.combine = TRUE, integrate.GEX.to.VDJ = TRUE
, integrate.VDJ.to.GEX = TRUE,
get.VDJ.stats = FALSE, trim.and.align = FALSE)
airr.list.out &lt;- PlatypusDB_VGM_to_AIRR(VGM = VGM,
VDJ.features.to.append = c("VDJ_sequence_nt_trimmed","VJ_sequence_nt_trimmed"),
GEX.features.to.append = c("UMAP_1","UMAP_2","CTLA4", "TOX"),
airr.rearrangements = c("~/cellrangerVDJ/s1/airr_rearrangement.tsv"
,"~/cellrangerVDJ/s2/airr_rearrangement.tsv"))
})


</code></pre>

<hr>
<h2 id='small_vgm'>Small VDJ GEX matrix (VGM) for function testing purposes</h2><span id='topic+small_vgm'></span>

<h3>Description</h3>

<p>Small VDJ GEX matrix (VGM) for function testing purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>small_vgm
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 5.
</p>


<h3>References</h3>

<p>R package Platypus : https://doi.org/10.1093/nargab/lqab023
</p>

<hr>
<h2 id='VDJ_abundances'>Calculate abundances/counts of specific features for a VDJ dataframe</h2><span id='topic+VDJ_abundances'></span>

<h3>Description</h3>

<p>Calculate the absolute counts or proportions of a specific cell-level feature (column in the VDJ/VDJ.GEX.matrix[[1]] object), per an optional specific grouping factor (e.g., clonotype via 'clonotype_id') and an optional sample factor(e.g., 'sample_id'). Outputs either a count dataframe of the specific feature or a ggplot2 barplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_abundances(
  VDJ,
  feature.columns,
  proportions,
  specific.features,
  grouping.column,
  max.groups,
  specific.groups,
  sample.column,
  VDJ.VJ.1chain,
  treat.incomplete.groups,
  treat.incomplete.features,
  combine.features,
  treat.combined.features,
  treat.combined.groups,
  specific.feature.colors,
  output.format
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_abundances_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_feature.columns">feature.columns</code></td>
<td>
<p>vector of strings, denoting the columns of the VDJ/VDJ.GEX.matrix[[1]] object from which to extract the unique feature values (for which we will calculate the counts or proportions).</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_proportions">proportions</code></td>
<td>
<p>string, 'absolute' will return the absolute counts, 'group.level.proportions' will return the counts divided by the total number or elements/values in the specific groups (group level proportions), 'sample.level.proportions' will return the counts divided by the total number of elements in the sample.</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_specific.features">specific.features</code></td>
<td>
<p>vector of specific feature values (or NULL) for which to calculate counts/proportions, from the specified feature.columns parameter (only works if a single feature column is specified in feature.columns).</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_grouping.column">grouping.column</code></td>
<td>
<p>string, vector of strings, or 'none' - represents the column from the VDJ/VDJ.GEX.matrix[[1]] object by which to group counting process. This is usually the 'clonotype_id' column to calculate frequencies at the clonotype level. If 'none', no grouping will be done. To group by multiple columns, input the specific columns as a vector of strings.
For example, if feature.columns='VDJ_cgene' and grouping.column='clonotype_id', we will obtain a count dataframe of the frequencies of each isotype per unique clonotype (per sample if sample.column='sample_id').</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_max.groups">max.groups</code></td>
<td>
<p>integer or NULL, the maximum number of groups for which to count features. If NULL, it will count for all groups.</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_specific.groups">specific.groups</code></td>
<td>
<p>vector of strings (or 'none'), if the counting should be done only for specific groups (e.g., count the frequency of isotype only for clonotypes 1 and 2 if feature.columns='VDJ_cgene', grouping.column='clonotype_id' and specific.groups=c('clonotype1', 'clonotype2'))</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_sample.column">sample.column</code></td>
<td>
<p>string, represents the sample column if your VDJ/VDJ.GEX.matrix[[1]] object has multiple samples (usually 'sample_id')</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_vdj.vj.1chain">VDJ.VJ.1chain</code></td>
<td>
<p>boolean, if T will remove aberrant cells (more than 1 VDJ of VJ chain), if F it will keep them.</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_treat.incomplete.groups">treat.incomplete.groups</code></td>
<td>
<p>string, method of dealing with groups which are missing the features in the feature.columns parameter (e.g., a clonotype which does not have any transcriptomic clusters annotations if feature.columns='transcript_cluster').'exclude' - excludes groups with no cells for the specific features, 'unknown' - sets them as unknown</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_treat.incomplete.features">treat.incomplete.features</code></td>
<td>
<p>string, method of dealing with missing feature values (e.g., a clonotype has several NA values for the 'VDJ_cgene' feature.column - cells with NA values). 'unknown' - counted as unknown, 'exclude' - excludes completely, 'max.global' - replaces value by max value of that feature across the repertoire, 'max.group' - replaced by the max feature value inside that group, 'proportional' - iteratively assigns the missing values to the known groups, keeping the same proportions.</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_combine.features">combine.features</code></td>
<td>
<p>boolean - if T and we have two columns in feature.columns, will combine the feature values for each cell in the VDJ object, counting them as a single feature when calculating proportions.</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_treat.combined.features">treat.combined.features</code></td>
<td>
<p>string, method of dealing with combined features with missing values. 'exclude' will be treated similarly to excluding incomplete feature values (excluding them completely if a single value is missing from the combination), or 'include' and will be treated as a new feature value.</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_treat.combined.groups">treat.combined.groups</code></td>
<td>
<p>string, method of dealing with combined groups with missing values, in case the grouping.column parameter is a vector of strings. 'exclude' will exclude the combined group altogether if a group value is missing/NA. 'include' will include such groups in the analysis.</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_specific.feature.colors">specific.feature.colors</code></td>
<td>
<p>named list of specific colors to be used in the final barplots, for each unique feature value in the VDJ object's feature.columns values.
For example, if we have a feature column of binders with unique values=c('yes', 'no'), specific.feature.colors=list('yes'='blue', 'no'='red') will color them accordingly.</p>
</td></tr>
<tr><td><code id="VDJ_abundances_+3A_output.format">output.format</code></td>
<td>
<p>string, either 'plots' to obtain barplots, 'abundance.df' to obtain the count dataframe, or 'abundance.df.list' to obtain a list of count dataframes, for each sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a count dataframe with the following columns: group(=unique group value, e.g., 'clonotype1' if grouping.column='clonotype_id'), sample, group_frequency, unique_feature_values, feature_value_counts, total_feature_names
or a barplot of the counts/proportions per feature, per group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VDJ_abundances(VDJ = Platypus::small_vgm[[1]],
feature.columns='VDJ_cgene', proportions='absolute',
grouping.column='clonotype_id', specific.groups='none',
output.format='plot')

</code></pre>

<hr>
<h2 id='VDJ_alpha_beta_Vgene_circos'>Produces a Circos plot from the VDJ_analyze output. Connects the V-alpha with the corresponding V-beta gene for each clonotype.</h2><span id='topic+VDJ_alpha_beta_Vgene_circos'></span>

<h3>Description</h3>

<p>Produces a Circos plot from the VDJ_analyze output. Connects the V-alpha with the corresponding V-beta gene for each clonotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_alpha_beta_Vgene_circos(
  VGM,
  V.or.J,
  B.or.Tcells,
  label.threshold,
  c.threshold,
  cell.level,
  clonotype.per.gene.threshold,
  c.count.label,
  c.count.label.size,
  platypus.version,
  filter1H1L,
  gene.label,
  gene.label.size,
  arr.col,
  arr.direction,
  topX,
  platy.theme,
  clonotype.column
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_vgm">VGM</code></td>
<td>
<p>The output of the VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[1]]) has to be supplied. For Platypus v2: The output of the VDJ_GEX_integrate function (Platypus platypus.version v2). A list of data frames for each sample containing the clonotype information and cluster membership information.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_v.or.j">V.or.J</code></td>
<td>
<p>Determines whether to plot the alpha beta gene pairing of the V or J genes. &quot;V&quot;, &quot;J&quot; or &quot;both&quot; as possible inputs. Default: &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_b.or.tcells">B.or.Tcells</code></td>
<td>
<p>Specify whether B or T cells are being analyzed (&quot;B&quot; or &quot;T&quot;). If not specified, function attempts to decide based on gene names.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_label.threshold">label.threshold</code></td>
<td>
<p>Genes are only labeled if the count is larger then the label.threshold. By default all label.threshold = 0 (all genes are labeled).</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_c.threshold">c.threshold</code></td>
<td>
<p>Only clonotypes are considered with a frequency higher then c.threshold. Allows to filter for only highly expanded clonotypes.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_cell.level">cell.level</code></td>
<td>
<p>Logical, defines whether weight of connection should be based on number of clonotypes of number of cells. Default: number of clonotypes.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_clonotype.per.gene.threshold">clonotype.per.gene.threshold</code></td>
<td>
<p>How many clonotypes are required to plot a sector for a gene. Filters the rows and colums of the final adjacency matrix.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_c.count.label">c.count.label</code></td>
<td>
<p>Boolean, lets the user decide if the gene and count labels should be plotted or not. Default = T.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_c.count.label.size">c.count.label.size</code></td>
<td>
<p>Determines the font size of the gene labels. By default the font size for count labels is 0.6.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Which platypus.version of platypus is being used. Default = v3. Set to v3 if VDJ_GEX_matrix.output[[1]] is used</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_filter1h1l">filter1H1L</code></td>
<td>
<p>Whether to filter the input VGM in &quot;v3&quot; to only include cells with 1 VDJ and 1 VJ chain. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_gene.label">gene.label</code></td>
<td>
<p>Boolean, lets the user decide if the gene labels should be plotted or not.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_gene.label.size">gene.label.size</code></td>
<td>
<p>Determines the font size of the gene labels. By default the labelsize is automatically adjusted to 0.7 for labels with two or less digits, 0.6 for labels between 2 and 6 digits, and 0.4 for all longer labels. A manually defined font size will be the same for all labels!</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_arr.col">arr.col</code></td>
<td>
<p>Data.frame with three columns where the first two indicate the names of genes, clonotypes or clusters to be connected, and the third corresponds to the color of the arrow. Default set to data.frame(c(&quot;dummy.clonotype&quot;), c(&quot;dummy.cluster&quot;), c(&quot;dummy.color&quot;)), so no arrow is drawn.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_arr.direction">arr.direction</code></td>
<td>
<p>Either 1 or -1 and determines the direction of the arrow. Default=1.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_topx">topX</code></td>
<td>
<p>Filters for the top X clonotypes and only plots the respective gene combinations or cluster memberships.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_platy.theme">platy.theme</code></td>
<td>
<p>Allows plotting in the new &quot;pretty&quot; theme or the older &quot;spiky&quot; theme without group labels and radial arrangement of gene.labels. Default = &quot;pretty&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_alpha_beta_Vgene_circos_+3A_clonotype.column">clonotype.column</code></td>
<td>
<p>Which column in VGM contains the clonotyping information? Default=&quot;clonotype_id_10X&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a circos plot and a list object with the following elememts for N samples: [[1 to N]] The first N listelements corresponds to the recorded circos plots for N beeing the number or samples in the VGM. Since Circlize uses the R base plotting funciton, this is not a ggplot object but can still be replotted by calling the first list element. [[N+1]] Adjacency matrix forwarded to VDJ_circos(). This Matrix contains the counts and can be used for manual replotting using VDJ_circos directly. [[N+2]] Contains a named list with colors for each connection drawn and can be used for manual replotting using VDJ_circos directly. [[N+3]] Contains a named list with grouping information and can be used for manual replotting using VDJ_circos directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
alpha_beta_VJgene &lt;- VDJ_alpha_beta_Vgene_circos(Platypus::small_vgm[[1]])
alpha_beta_VJgene[[1]]


</code></pre>

<hr>
<h2 id='VDJ_antigen_integrate'>Integrates antigen-specific information into the VDJ/VDJ.GEX.matrix[[1]] object</h2><span id='topic+VDJ_antigen_integrate'></span>

<h3>Description</h3>

<p>Integrate antigen-specific information from a list of antigen dataframes or antigen csv file paths. The antigen data should contain either the clonotypes, cell barcodes, or sequences with the specific column names of the VDJ/VDJ.GEX.matrix[[1]] object. These columns will be used to rematch the binder information at the cell, sequence, or clonotype level into the main VDJ.GEX.matrix[[1]].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_antigen_integrate(
  VDJ,
  antigen.data.list,
  antigen.features,
  binder.threshold,
  VDJ.VJ.1chain,
  match.by,
  matching.type,
  distance.threshold,
  cores,
  sample.id,
  aberrant.chosen.sequences,
  output.format
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_antigen_integrate_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_antigen.data.list">antigen.data.list</code></td>
<td>
<p>list of antigen csv file paths or antigen dataframes for the specific antigen datasets. To ease matching, the column names by which we will match should be the same as the column names in the original VDJ/VDJ.GEX.matrix[[1]] object.</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_antigen.features">antigen.features</code></td>
<td>
<p>vector of columns of antigen features to be integrated from the antigen csv files into the VDJ/VDJ.GEX.matrix[[1]] object. The vector can also use unique, short-hand names of the columns to add (e.g., 'affinity' for 'octet.affinity.[nM]').</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_binder.threshold">binder.threshold</code></td>
<td>
<p>list or nested list of threshold values and specific features by which to define binders in the VDJ.
For example, if binder.threshold=list(list('affinity', 0.2), list('elisa', 0.8)), we will have two new binder columns: binders_affinity if the values are greater than 0.2, binders_elisa if they are greater than 0.8.</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_vdj.vj.1chain">VDJ.VJ.1chain</code></td>
<td>
<p>boolean, if T will remove aberrant cells (more than 1 VDJ of VJ chain), if F it will keep them in the VDJ when matching antigen data.</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_match.by">match.by</code></td>
<td>
<p>string, represents the method by which to match the antigen data and integrate it into the VDJ/VDJ.GEX.matrix[[1]] object. 'clonotype' will match by 'clonotype_id' (needs to be present in the antigen data), 'clonotype.v3' will match by v3 cellranger clonotypes (you need a v3_clonotypes column in the VDJ/VDJ.GEX.matrix[[1]], 'cdr3.aa' by VDJ and VJ cdr3s amino acid sequences, 'cdrh3.aa' by VDJ cdr3s amino acid sequences, 'VDJ.VJ.aa' by full VDJ and VJ aa sequences, 'VDJ.VJ.nt' by trimmed nt VDJ and VJ sequences (must run VDJ_call_MIXCR first on the VDJ),'cdr3.nt' by VDJ and VJ cdr3s as nucleotides, 'cdrh3.nt.' by VDJ cdr3s as nucleotides, 'absolut' will match the VDJ_cdr3s_aa with the CDR3 column in Absolut! datasets.</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_matching.type">matching.type</code></td>
<td>
<p>string, either 'exact' for exact sequence matching if the match.by parameter is a sequence type, or 'homology' for homology matching (matches if the Levehnstein distance is less than the distance.threshold parameter).</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_distance.threshold">distance.threshold</code></td>
<td>
<p>integer, maximum string distance value by which to match sequences in the antigen data and sequences in the VDJ object (to further integrate the antigen data).</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallel computations. Defaults to number of available cores. Setting this parameter is good practice on clusters.</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_sample.id">sample.id</code></td>
<td>
<p>boolean, if T then will also match by the 'sample_id' column in the antigen dataframes.</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_aberrant.chosen.sequences">aberrant.chosen.sequences</code></td>
<td>
<p>boolean, if T will add a column of the chosen aberrant sequences (which matched a sequence in the antigen data) if matching by sequence (and VDJ.VJ.1chain=F).</p>
</td></tr>
<tr><td><code id="VDJ_antigen_integrate_+3A_output.format">output.format</code></td>
<td>
<p>string, 'vgm' - returns the full VDJ object, 'dataframe.per.sample' - list of VDJ dataframes for each sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either the original VDJ dataframe with additional columns of the antigen features integrated, a list of VDJ dataframes per sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ_antigen_integrate(VDJ,antigen.directory.list=antigen.directory.list,
antigen.feature=c('elisa', 'affinity'),VDJ.VJ.1chain=T,
match.by='clonotype',sample.id=T, output.format='vgm')
})

</code></pre>

<hr>
<h2 id='VDJ_assemble_for_PnP'>Ab sequence assembly for recombinant PnP expression</h2><span id='topic+VDJ_assemble_for_PnP'></span>

<h3>Description</h3>

<p>Assembles sequences from MIXCR output into inserts for expression in PnP cells. For detailes check https://doi.org/10.1038/ncomms12535 ! ALWAYS VALIDATE INDIVIDUAL SEQUENCE IN GENEIOUS OR OTHER SOFTWARE BEFORE ORDERING SEQUENCES FOR EXPRESSION ! Check notes on column content below ! Only cells with 1 VDJ and 1 VJ sequence are considered. Warnings are issued if sequences do not pass necessary checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_assemble_for_PnP(
  VDJ.mixcr.matrix,
  id.column,
  species,
  manual_IgKC,
  manual_2A,
  manual_VDJLeader,
  write.to.disk,
  filename,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_assemble_for_PnP_+3A_vdj.mixcr.matrix">VDJ.mixcr.matrix</code></td>
<td>
<p>Output dataframe from the VDJ_call_MIXCR function or a dataframe generated using the VDJ_GEX_matrix function and supplemented with MIXCR information (Needed columns: All Framework and CDR sequences)</p>
</td></tr>
<tr><td><code id="VDJ_assemble_for_PnP_+3A_id.column">id.column</code></td>
<td>
<p>Character. Column name of VDJ.mixcr.matrix to use as ID for the assembled sequences. Defaults to &quot;barcode&quot;</p>
</td></tr>
<tr><td><code id="VDJ_assemble_for_PnP_+3A_species">species</code></td>
<td>
<p>Character. Which IgKC sequence to use. Can be &quot;human&quot; or &quot;mouse&quot;. Defaults to &quot;mouse&quot;</p>
</td></tr>
<tr><td><code id="VDJ_assemble_for_PnP_+3A_manual_igkc">manual_IgKC</code></td>
<td>
<p>Character. Manual overwrite for sequence used as IgKC.</p>
</td></tr>
<tr><td><code id="VDJ_assemble_for_PnP_+3A_manual_2a">manual_2A</code></td>
<td>
<p>Character. Manual overwrite for sequence used as Furine 2A site.</p>
</td></tr>
<tr><td><code id="VDJ_assemble_for_PnP_+3A_manual_vdjleader">manual_VDJLeader</code></td>
<td>
<p>Character. Manual overwrite for sequence used as VDJ Leader and signal peptide.</p>
</td></tr>
<tr><td><code id="VDJ_assemble_for_PnP_+3A_write.to.disk">write.to.disk</code></td>
<td>
<p>Boolean. Defaults to TRUE. Whether to save assembled sequences to working directory</p>
</td></tr>
<tr><td><code id="VDJ_assemble_for_PnP_+3A_filename">filename</code></td>
<td>
<p>Character. Output file name for .fasta and .csv files if write.to.disk == TRUE. Defaults to PnP_assembled_seqs.fasta/.csv</p>
</td></tr>
<tr><td><code id="VDJ_assemble_for_PnP_+3A_verbose">verbose</code></td>
<td>
<p>Print runtime message to console. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input VGM matrix with one additional column containing the assembles sequences. If write.to.disk == TRUE writes a CSV containing key columns of the VGM as well as a .FASTA file to the current working director (getwd())
! Important notes on column content:
1. The column &quot;seq_length_check&quot; contains either &quot;passed&quot; or &quot;FAILED&quot;. If FAILED, this means that at least one of the sequences (e.g. FRL1) was shorter than 9NTs and therefore considered invalid. Please check for missing sequences if you find any warnings
2. The column &quot;seq_codon_check&quot; is deemed &quot;passed&quot; if all CDR and FR input sequences of a cell contain only full codons (i.e. are divisible by 3)
3. The column &quot;PnP_assembled_seqs&quot; contains the assembled sequences / inserts for PnP expression. These should be validated manually in Geneious or other software and can then be ordered to be synthesized.
4. The column &quot;PnP_assembled_annotations&quot; contains a string of annotations for the respective assembled sequence. The structure is | [Sequence element] -&gt; [index (starting from 1) of last nucleotide of the sequence element] ...
5. The column &quot;PnP_assembled_translations&quot; contains the amino acid translation of the full contig that will result from the assembled insert in the backbone PnP vector. Please note: the sequences in the PnP_assembled_translation resulted from pasting the VJ leader sequence (contained in the PnP vector backbone), the PnP_assembled_seqs (The insert itself) and a surrogate stop codon ATAA. If correct, the translation should only contain one * (stop codon) at the very end. For reference: VJLeader sequence: ATGGATTTTCAGGTGCAGATTTTCAGCTTCCTGCTAATCAGCGCTTCAGTTATAATGTCCCGGGGG
6. The column &quot;seq_VJCDR3_check&quot; is deemed &quot;passed&quot; if the translated sequence of the input VJ CDR3 is found in the translated assembled sequence. If this test fails, there is likely an issue with the VJ segment
7. The column &quot;seq_Fur2A_check&quot; is deemed &quot;passed&quot; if correct AA sequence of the 2A site is found in the translated assembled sequence. If this test fails, and the seq_VJCDR3_test was passed, there is likely an issue at the border between VJ and IgKC/2A sequences
8. The column &quot;seq_VDJCDR3_check&quot; is deemed &quot;passed&quot; if the translated sequence of the input VDJ CDR3 is found in the translated assembled sequence.
9. The column &quot;seq_splicesite_check&quot; is deemed passed if the last 6 nucleotides of the assembled sequence are one of the following: &quot;TCCTCA&quot;, &quot;TCTTCA&quot;,&quot;TCGTCA&quot;,&quot;TCATCA&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VGM_with_PnP_seq &lt;- VDJ_assemble_for_PnP(VDJ.mixcr.matrix = VDJ_call_MIXCR.output
, id.column = "barcode",species = "mouse", manual_IgKC = "none", manual_2A = "none"
, manual_VDJLeader = "none", write.to.disk = FALSE, filename = "PnP_seq_example")
})

</code></pre>

<hr>
<h2 id='VDJ_build'>Minimal version of the VDJ building part from VDJ_GEX_matrix() function. Optimized for for Cell Ranger v7 and suitable for older Cell Ranger versions.</h2><span id='topic+VDJ_build'></span>

<h3>Description</h3>

<p>Minimal version of the VDJ building part from VDJ_GEX_matrix() function. Adapted for Cell Ranger v7 and older versions as well. Currently, Seurat objects need to be integrated by matching barcodes from the Seurat object's metadata with the barcodes of the VDJ dataframe.
Authors: Valentijn Tromp, Tudor-Stefan Cotet, Victor Kreiner, Aurora Desideri Perea, Evgenios Kladis, Anamay Samant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_build(
  VDJ.directory,
  VDJ.sample.list,
  remove.divergent.cells,
  complete.cells.only,
  trim.germlines,
  gap.opening.cost,
  parallel,
  num.cores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_build_+3A_vdj.directory">VDJ.directory</code></td>
<td>
<p>string - path to parent directory containing the output folders (one folder for each sample) of Cell Ranger. This pipeline assumes that the output file names have not been changed from the default 10x settings in the /outs/ folder. This is compatible with B and T cell repertoires. ! Neccessary 5 files within this folder: 'filtered_contig_annotations.csv', 'filtered_contig.fasta', 'consensus_annotations.csv', 'consensus.fasta', and 'concat_ref.fasta'.</p>
</td></tr>
<tr><td><code id="VDJ_build_+3A_vdj.sample.list">VDJ.sample.list</code></td>
<td>
<p>list - list of paths to the output folders (one folder for each sample) of Cell Ranger. This pipeline assumes that the output file names have not been changed from the default 10x settings in the /outs/ folder. This is compatible with B and T cell repertoires. ! Neccessary 5 files within this folder: 'filtered_contig_annotations.csv', 'filtered_contig.fasta', 'consensus_annotations.csv', 'consensus.fasta', and 'concat_ref.fasta'.</p>
</td></tr>
<tr><td><code id="VDJ_build_+3A_remove.divergent.cells">remove.divergent.cells</code></td>
<td>
<p>bool - if TRUE, cells with more than one VDJ transcript or more than one VJ transcript will be excluded. This could be due to multiple cells being trapped in one droplet or due to light chain dual expression (concerns ~2-5% of B cells, see DOI:10.1084/jem.181.3.1245). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="VDJ_build_+3A_complete.cells.only">complete.cells.only</code></td>
<td>
<p>bool - if TRUE, only cells with both a VDJ transcripts and a VJ transcript are included in the VDJ dataframe. Keeping only cells with 1 VDJ and 1 VJ transcript could be preferable for downstream analysis. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="VDJ_build_+3A_trim.germlines">trim.germlines</code></td>
<td>
<p>bool - if TRUE, the raw germline sequences of each clone will be trimmed using the the consensus sequences of that clone as reference seqeunces (using BIostrings::pairwiseAlignment with the option &quot;global-local&quot; and a gap opening cost = gap.opening.cost). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="VDJ_build_+3A_gap.opening.cost">gap.opening.cost</code></td>
<td>
<p>float or Inf - the cost for opening a gap in Biostrings::pairwiseAlignment when aligning and trimming germline sequences. Defaults to Inf (gapless alignment).</p>
</td></tr>
<tr><td><code id="VDJ_build_+3A_parallel">parallel</code></td>
<td>
<p>bool - if TRUE, the per-sample VDJ building is executed in parallel (parallelized across samples). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="VDJ_build_+3A_num.cores">num.cores</code></td>
<td>
<p>integer - number of cores to be used when parallel = TRUE. Defaults to all available cores - 1 or the number of sample folders in 'VDJ.directory' (depending which number is smaller).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the VDJ dataframe / VGM[[1]] object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ &lt;- VDJ_build(VDJ_directory)
})

</code></pre>

<hr>
<h2 id='VDJ_call_enclone'>(Re)clonotype a VDJ object using cellranger's enclone tool</h2><span id='topic+VDJ_call_enclone'></span>

<h3>Description</h3>

<p>Calls recon to clonotype a VDJ object given a VDJ.directory (with sample folders which should include the all_contig_annotations.json file) - outputs a new VDJ with updated clonotype_id, clonotype_id_10x, and clonotype_frequency columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_call_enclone(
  VDJ,
  VDJ.directory,
  global.clonotype,
  samples.to.clonotype,
  samples.to.combine,
  same.origin,
  output.format,
  operating.system,
  parallel
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_call_enclone_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_call_enclone_+3A_vdj.directory">VDJ.directory</code></td>
<td>
<p>string - directory for the VDJ data, should be the main folder which includes the individual sample folders (each with the all_contig_annotations.json file that is used by enclone)</p>
</td></tr>
<tr><td><code id="VDJ_call_enclone_+3A_global.clonotype">global.clonotype</code></td>
<td>
<p>bool - if T, will use clonotype definitions irrespective of samples. Must also be T is you wish to merge clonotypes from two specific (which should be specified in the samples.to.combine parameter)</p>
</td></tr>
<tr><td><code id="VDJ_call_enclone_+3A_samples.to.clonotype">samples.to.clonotype</code></td>
<td>
<p>- vector - lists the samples names which should be clonotyped. The unspecified samples will keep their old clonotype defintions.</p>
</td></tr>
<tr><td><code id="VDJ_call_enclone_+3A_samples.to.combine">samples.to.combine</code></td>
<td>
<p>- vector or list of vectors - lists the samples which you wish to have their clonotypes merged (e.g., c('s1','s2') to only merge the first 2 samples, or list(c('s1','s3'), c('s2', 's4')) to merge the first and third, second and fourth, respectively). global.clonotype must be set to T!</p>
</td></tr>
<tr><td><code id="VDJ_call_enclone_+3A_same.origin">same.origin</code></td>
<td>
<p>bool - if the merged samples come from the same donor, with the same or with different origins. If two datasets come from the same origin, enclone will filter to remove certain artifacts.</p>
</td></tr>
<tr><td><code id="VDJ_call_enclone_+3A_output.format">output.format</code></td>
<td>
<p>string - 'vgm' to output a VGM-specific VDJ dataframe (all samples in the same dataframe).</p>
</td></tr>
<tr><td><code id="VDJ_call_enclone_+3A_operating.system">operating.system</code></td>
<td>
<p>string - operating system on which enclone will be run. 'Windows' for Windows, 'Linux' for Linux, 'Darwin' for MacOS.</p>
</td></tr>
<tr><td><code id="VDJ_call_enclone_+3A_parallel">parallel</code></td>
<td>
<p>bool - if T, the program will be executed in parallel, on no. cores = max. available cores - 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reclonotyped VDJ object using the enclone software and 10x-specific clonotype deifinition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ_call_enclone(vdj, VDJ.directory, samples.to.combine = c('s1', 's2', 's3'), global.clonotype = T)
})

</code></pre>

<hr>
<h2 id='VDJ_circos'>Plots a Circos diagram from an adjacency matrix. Uses the Circlize chordDiagram function. Is called by VDJ_clonotype_clusters_circos(), VDJ_alpha_beta_Vgene_circos() and VDJ_VJ_usage_circos() functions or works on its own when supplied with an adjacency matrix.</h2><span id='topic+VDJ_circos'></span>

<h3>Description</h3>

<p>Plots a Circos diagram from an adjacency matrix. Uses the Circlize chordDiagram function. Is called by VDJ_clonotype_clusters_circos(), VDJ_alpha_beta_Vgene_circos() and VDJ_VJ_usage_circos() functions or works on its own when supplied with an adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_circos(
  Adj_matrix,
  platy.theme,
  group,
  grid.col,
  label.threshold,
  axis,
  c.count.label,
  arr.col,
  arr.direction,
  gene.label.size,
  gene.label,
  c.count.label.size
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_circos_+3A_adj_matrix">Adj_matrix</code></td>
<td>
<p>Adjacency matrix to be plotted. Rownames and Colnames correspond to genes to be matched and entries determine the weight of the connection between the genes (eg. number of clonotypes expressing these two genes).</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_platy.theme">platy.theme</code></td>
<td>
<p>Allows plotting in the new &quot;pretty&quot; theme or the older &quot;spiky&quot; theme without group labels and radial arrangement of gene.labels. Default = &quot;pretty&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_group">group</code></td>
<td>
<p>Named list of genes, with list elements corresponding to group-names, and element names being the gene-names. Is generated by VDJ_VJ_usage and VDJ_alpha_beta_Vgene_circos.</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_grid.col">grid.col</code></td>
<td>
<p>Named list of genes, with list elements corresponding to color and element names being gene-names. If not supplied it is generated randomly within the function. Is also generated by VDJ_VJ_usage and VDJ_alpha_beta_Vgene_circos.</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_label.threshold">label.threshold</code></td>
<td>
<p>Genes are only labeled if the count is larger then the label.threshold. By default all label.threshold = 0 (all genes are labeled).</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_axis">axis</code></td>
<td>
<p>Option to choose the count axis for each gene. &quot;default&quot;, &quot;percent&quot; or &quot;max&quot;  possible. Default: &quot;max&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_c.count.label">c.count.label</code></td>
<td>
<p>Boolean, lets the user decide if the gene and count labels should be plotted or not. Default = T.</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_arr.col">arr.col</code></td>
<td>
<p>Data.frame with three columns where the first two indicate the names of genes, clonotypes or clusters to be connected, and the third corresponds to the color of the arrow. Default set to data.frame(c(&quot;dummy.clonotype&quot;), c(&quot;dummy.cluster&quot;), c(&quot;dummy.color&quot;)), so no arrow is drawn.</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_arr.direction">arr.direction</code></td>
<td>
<p>Either 1 or -1 and determines the direction of the arrow. Default=1.</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_gene.label.size">gene.label.size</code></td>
<td>
<p>Determines the font size of the gene labels. By default the labelsize is automatically adjusted to 0.7 for labels with two or less digits, 0.6 for labels between 2 and 6 digits, and 0.4 for all longer labels. A manually defined font size will be the same for all labels!</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_gene.label">gene.label</code></td>
<td>
<p>Boolean, lets the user decide if the gene labels should be plotted or not.</p>
</td></tr>
<tr><td><code id="VDJ_circos_+3A_c.count.label.size">c.count.label.size</code></td>
<td>
<p>Determines the font size of the gene labels. By default the font size for count labels is 0.6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a circos plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ_circos(Adj_matrix =  VDJ_alpha_beta_Vgene_circos_output[[2]][[1]],
  grid.col = VDJ_alpha_beta_Vgene_circos_output[[3]],
  group = VDJ_alpha_beta_Vgene_circos_output[[4]],
  c.count.label.size = 0.4,
  gene.label.size = 0.5,
  arr.col = data.frame(c("TRBV10"),c("TRBJ2-7"), c("black")),
  axis="percent")
})

</code></pre>

<hr>
<h2 id='VDJ_clonal_barplot'>Function to create stacked barplots to visualize clonal expansion per repertoire directly from a VDJ matrix (either from the minimal_VDJ() or VDJ_GEX_matrix())</h2><span id='topic+VDJ_clonal_barplot'></span>

<h3>Description</h3>

<p>Function to create stacked barplots to visualize clonal expansion per repertoire directly from a VDJ matrix (either from the minimal_VDJ() or VDJ_GEX_matrix()).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_clonal_barplot(
  VDJ,
  counts.to.use,
  group.by,
  expanded.colors,
  non.expanded.color
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_clonal_barplot_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ matrix (either from the minimal_VDJ() or VDJ_GEX_matrix()</p>
</td></tr>
<tr><td><code id="VDJ_clonal_barplot_+3A_counts.to.use">counts.to.use</code></td>
<td>
<p>The column name in the VDJ matrix of the clonotypes you want to use. Defaults to &quot;clonotype_id&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_barplot_+3A_group.by">group.by</code></td>
<td>
<p>The column name in the VDJ matrix on which you want to seperate the repertoire plots. If the entire VDJ matrix is one repertoire, this argument should be &quot;none&quot; or empty.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_barplot_+3A_expanded.colors">expanded.colors</code></td>
<td>
<p>Character vector. Colors to use for expanded clones. Should be more than 3 for better visibility. Defaults to a &quot;darkorchid3&quot;-based palette.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_barplot_+3A_non.expanded.color">non.expanded.color</code></td>
<td>
<p>Character. Color to use for non expanded clones. Defaults to &quot;black&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with a ggplot for each group.by element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- VDJ_clonal_barplot(Platypus::small_vgm[[1]],
counts.to.use = "clonotype_id_10x",group.by = "sample_id")

</code></pre>

<hr>
<h2 id='VDJ_clonal_donut'>Circular VDJ expansion plots</h2><span id='topic+VDJ_clonal_donut'></span>

<h3>Description</h3>

<p>Generate circular plots of clonal expansion per repertoire directly from the VDJ matrix of the VDJ_GEX_matrix function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_clonal_donut(
  VDJ,
  counts.to.use,
  label.size,
  not.expanded.label.vjust,
  not.expanded.label.hjust,
  total.label.vjust,
  total.label.hjust,
  expanded.colors,
  non.expanded.color
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_clonal_donut_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ dataframe generated using the VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[1]]). Plots will be made by sample and using the clonal frequencies specified by counts.to.use</p>
</td></tr>
<tr><td><code id="VDJ_clonal_donut_+3A_counts.to.use">counts.to.use</code></td>
<td>
<p>How to count clonotypes and cells. A column name of the VDJ matrix containing clonotype IDs. This defaults to &quot;clonotype_id_10x&quot;, which reflects clonotypes by Cellranger in an unaltered VGM. To use counts from the VDJ_clonotype_v3 function set this parameter to the relevant column e.g. &quot;clonotype_id_cdr.aa&quot; or   &quot;global_clonotype_id_cdr.aa&quot; are two examples.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_donut_+3A_label.size">label.size</code></td>
<td>
<p>Size of text labels. All parameters below are purely for graphical purposes and optional. If necessary changes should be made in small (0.1) increments. ! It is recommended to optimize these ONLY once a format for saving the plot is set.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_donut_+3A_not.expanded.label.vjust">not.expanded.label.vjust</code></td>
<td>
<p>Numeric. Regulates the vertical position of the label for non expanded cells</p>
</td></tr>
<tr><td><code id="VDJ_clonal_donut_+3A_not.expanded.label.hjust">not.expanded.label.hjust</code></td>
<td>
<p>Numeric. Regulates the horizontal position of the label for non expanded cells</p>
</td></tr>
<tr><td><code id="VDJ_clonal_donut_+3A_total.label.vjust">total.label.vjust</code></td>
<td>
<p>Numeric. Regulates the vertical position of the center label</p>
</td></tr>
<tr><td><code id="VDJ_clonal_donut_+3A_total.label.hjust">total.label.hjust</code></td>
<td>
<p>Numeric. Regulates the horizontal position of the center label</p>
</td></tr>
<tr><td><code id="VDJ_clonal_donut_+3A_expanded.colors">expanded.colors</code></td>
<td>
<p>Character vector. Colors to use for expanded clones. Should be more than 3 for better visibility. Defaults to a &quot;darkorchid3&quot;-based palette.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_donut_+3A_non.expanded.color">non.expanded.color</code></td>
<td>
<p>Character. Color to use for non expanded clones. Defaults to &quot;black&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of circular plots showing proportions of expanded clones and non-expanded clones. One plot is generated for each sample in the sample_id column
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VDJ_clonal_donut(VDJ = Platypus::small_vgm[[1]])

</code></pre>

<hr>
<h2 id='VDJ_clonal_expansion'>Flexible wrapper for clonal expansion barplots by isotype, GEX cluster etc.</h2><span id='topic+VDJ_clonal_expansion'></span>

<h3>Description</h3>

<p>Clonal frequency plot displaying clonal expansion for either T and B cells with Platypus v3 input. Only available for Platypus &quot;v3&quot; available. For v2 plotting of B cell clonotype expansion and isotypes please refer to VDJ_isotypes_per_clone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_clonal_expansion(
  VDJ,
  celltype,
  clones,
  subtypes,
  isotypes.to.plot,
  species,
  treat.incomplete.clones,
  treat.incomplete.cells,
  group.by,
  color.by,
  variant.plot
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_clonal_expansion_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ dataframe generated using the VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[1]])</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_celltype">celltype</code></td>
<td>
<p>Character. Either &quot;Tcells&quot; or &quot;Bcells&quot;. If set to Tcells bars will not be colored by default and the parameters treat_incomplete_cells, treat_incomplete_clones, subtypes and species are ignored. The color.by and group.by arguments work identically for both celltypes. If none provided it will detect this param from the celltype column.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_clones">clones</code></td>
<td>
<p>numeric value indicating the number of clones to be considered for the clonal expansion plot. Default value is 50. For a standard plot more than 50 is discouraged. When showing only one - possibly rare - isotype via isotypes.to.plot it may be useful to set this number higher (e.g. 100-200)</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_subtypes">subtypes</code></td>
<td>
<p>Logical indicating whether to display isotype subtypes or not.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_isotypes.to.plot">isotypes.to.plot</code></td>
<td>
<p>Character vector. Defaults to &quot;all&quot;. This can be set to any number of specific Isotypes, that are to be shown exclusively. For example, to show only clones containing IgG, input &quot;IGHG&quot;. If only wanting to check clones with IgA and IgD input c(&quot;IGHA&quot;,&quot;IGHD&quot;). Works equally if subtypes are set to TRUE. Is ignored if color.by is not set to &quot;isotype&quot;</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_species">species</code></td>
<td>
<p>Character indicating whether the samples are from &quot;Mouse&quot; or &quot;Human&quot;. Default is &quot;Human&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_treat.incomplete.clones">treat.incomplete.clones</code></td>
<td>
<p>Character indicating how to proceed with clonotypes lacking a VDJC (in other words, no cell within the clonotype has a VDJC). &quot;exclude&quot; removes these clonotypes from the analysis. &quot;include&quot; keeps these clonotypes in the analysis. In the plot they will appear has having an unknown isotype.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_treat.incomplete.cells">treat.incomplete.cells</code></td>
<td>
<p>Character indicating how to proceed with cells assigned to a clonotype but missing a VDJC. &quot;proportional&quot; to fill in the VDJ isotype according to the proportions present in of clonotype (in case present proportions are not replicable in the total number of cells e.g. 1/3 in 10 cells, values are rounded to the next full integer and if the new counts exceed the total number of cells, 1 is subtracted from the isotype of highest frequency. If the number is below the number of cell, 1 is added to the isotype with lowest frequency to preserve diversity), &quot;exclude&quot; to exclude them from analysis and rank clonotypes only by the number of cells with a heavy chain. This ranking may deviate from the frequency column in the clonotype table. CAVE: if treat_incomplete_cells is set to &quot;exclude&quot;, clonotypes lacking a VDJC entierly will be removed from the analysis. This results in a similar but not identical output as when treat_incomplete_clones is set to true. The two parameters are thereby non-redundant.</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_group.by">group.by</code></td>
<td>
<p>Character. Defaults to &quot;sample_id&quot;. Column name of VDJ to split VDJ by. For each unique entry in that column a plot will be generated. Therefore plots can be generated by sample_id, group_id or any other metadata item.To get plots for the whole repertoire set to &quot;none&quot;</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_color.by">color.by</code></td>
<td>
<p>Character. Defaults to &quot;isotype&quot;. If set to &quot;isotype&quot; bars are colored by the respective IgH chain or in grey for T cells. This can alternatively be set to any column name of the VDJ. This allows coloring clones by their V_gene usage or by GEX clusters</p>
</td></tr>
<tr><td><code id="VDJ_clonal_expansion_+3A_variant.plot">variant.plot</code></td>
<td>
<p>Logical indicating whether to plot the output showing the variants or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a nested list. out[[1]] are plots out[[2]] are raw datatables containing also barcode and CDR3 information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clonal_out &lt;- VDJ_clonal_expansion(VDJ = Platypus::small_vgm[[1]],
 celltype = "Bcells", clones = 30,subtypes = FALSE, species = "Mouse"
 ,treat.incomplete.clones = "exclude"
 ,treat.incomplete.cells = "proportional")

clonal_out &lt;- VDJ_clonal_expansion(VDJ = Platypus::small_vgm[[1]]
, celltype = "Bcells", clones = 30,subtypes = FALSE, species = "Mouse"
,treat.incomplete.clones = "exclude"
,treat.incomplete.cells = "proportional"
,color.by = "seurat_clusters") #change grouping with group.by = "column name"
clonal_out[[1]] #list of plots
clonal_out[[2]] #list of source dataframes
</code></pre>

<hr>
<h2 id='VDJ_clonotype'>Platypus V3 clonotyping wrapper</h2><span id='topic+VDJ_clonotype'></span>

<h3>Description</h3>

<p>Updated clonotyping function based on implications for cells with different chain numbers than 1 VDJ 1 VJ chains.
</p>
<p>This function offers two types of hierarchical clonotyping. The hierarchical option &quot;single.chains&quot; only merges cell with a single chain into clonotypes composed of cells with 1 VDJ 1 VJ chain. This is based on the assumption, that during mRNA capture and RT-PCR in GEMs, not all transcripts are captured and therefore cells may result missing a VDJ or VJ chain.
The hierarchical option &quot;double.and.single.chains&quot; is based on the assumption, that cells with 1 VDJ and 2 VJ chains exist. For a review of the work concerning such cells as well as 2 VDJ 1 VJ cells please consult: https://doi.org/10.4049/jimmunol.1800904. The user may set a threshold of occurrence number above which cells with 1 VDJ 2 VJ chains are considered to be true and other cells with 1 VDJ 1 VJ, 1 VDJ 0 VJ and 0 VDJ 1 VDJ may be merged into the same clonotype by the strategy provided by the user. Cells with 2 VDJ chains are currently not considered in this process, as these are reported to be much rarer and, if appearing in the dataset are more likely to be doublets.
We advice the user to carefully examine the output after hierarchical clonotyping before proceeding with further analysis.
We thank Prof. Vijayanand as well as Vicente and Emmanuel from his lab for the discussions that have helped with improving the original Platypus clonotyping strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_clonotype(
  VDJ,
  clone.strategy,
  homology.threshold,
  hierarchical,
  triple.chain.count.threshold,
  global.clonotype,
  VDJ.VJ.1chain,
  output.format,
  platypus.version
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_clonotype_+3A_vdj">VDJ</code></td>
<td>
<p>For platypus v2 output from VDJ_analyze function. This should be a list of clonotype dataframes, with each list element corresponding to a single VDJ repertoire. For platypus v3 VDJ output from the VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[1]])</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_+3A_clone.strategy">clone.strategy</code></td>
<td>
<p>(Updated keywords, previous format is also functional) String describing the clonotyping strategy. Possible options are 10x.default, cdr3.nt, cdr3.aa, VDJJ.VJJ, VDJJ.VJJ.cdr3length, VDJJ.VJJ.cdr3length.cdr3.homology, VDJJ.VJJ.cdr3length.VDJcdr3.homology, cdr3.homology, VDJcdr3.homology. cdr3.aa will convert the default cell ranger clonotyping to amino acid based. 'VDJJ.VJJ' groups B cells with identical germline genes (V and J segments for both heavy chain and light chain. Those arguments including 'cdr3length' will group all sequences with identical VDJ and VJ CDR3 sequence lengths. Those arguments including 'cdr3.homology' will additionally impose a homology requirement for CDRH3 and CDRL3 sequences.'CDR3.homology',or 'CDRH3.homology' will group sequences based on homology only (either of the whole CDR3 sequence or of the VDJ CDR3 sequence respectively).
All homology calculations are performed on the amino acid level.</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_+3A_homology.threshold">homology.threshold</code></td>
<td>
<p>Numeric value between 0 and 1 corresponding to the homology threshold forn the clone.strategy arguments that require a homology threshold. Default value is set to 70 percent sequence homology. For 70 percent homology, 0.3 should be supplied as input.</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_+3A_hierarchical">hierarchical</code></td>
<td>
<p>Character. Defaults to &quot;none&quot;. This is an extention specifically for cells with aberrant numbers of chains (i.e. 0VDJ 1VJ, 1VDJ 0VJ, 0VDJ 2VJ, 2VDJ 0VJ). Cells with 2VDJ 2VJ are filtered out as these are most likely doublets.
If set to &quot;none&quot; aberrant cells are assigned to their own clonotypes.
If set to &quot;single.chains&quot; the function will proceed in two steps: 0. Prefiltering: cells with 2 VDJ 2 VJ chains as well as cells with 2 VDJ and any number of VJ chains are filtered out. 1. define clonotypes classically with all cells containing exactly 1VDJ 1VJ chains. 2. For cells with only a single chain (either VDJ or VJ), check if any clone exists, which matches the clonotyping criteria for this chain. If true, add this cell to that clone. If false, create a new clone containing that cell. In case that more than 1 existing clone matches the aberrant cell, the cell is assigned to the most frequent existing clone. Two reasons are behind this decision: 2.1. The aberrant cells is numerically more likely to be a part of the more frequent existing clone. 2.2 In case of a wrong assignment, the effect of the error is lower, if an already expanded clone is increase by one count, rather than a existing non-expanded clone being assigned a second entry and thereby resulting as expanded. Cells 
If set to &quot;double.and.single.chains&quot; the function will proceed as if set to &quot;single.chains&quot; but include two more steps
3. Check the frequency of each cell 1 VDJ 2 VJ chain exact clone (by exact nucleotide CDR3 matching). Only if this count exceeds the triple.chain.count.threshold, the clone is used as a &quot;hub clone&quot;. This protects from merging clonotypes on the basis of rare doublets.
4. Merge existing clonotypes into the 1 VDJ 2 VJ clonotypes as they match with the assumption that e.g. a cell with 1 VDJ 1 VJ is part of that same clonotype, but missing a VJ chain due to stochastical sampling</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_+3A_triple.chain.count.threshold">triple.chain.count.threshold</code></td>
<td>
<p>Minimal occurrance frequency for any cell with more than 2 of either VDJ or VJ chain (e.g. 2 VDJ 1 VJ) for it to be considered as a trustworthy clone for hierarchical clonotyping ONLY when hierarchical is set to &quot;double.and.single.chains&quot;. Defaults to 3, meaning that, an exact combination of three chains needs to appear in the dataset at least 3 times for it to be considered as a clone, into which other cells are merged. (For the counting of exact combination of chains CDR3 nucleotide string matching is used, even if clonotyping by homology)</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_+3A_global.clonotype">global.clonotype</code></td>
<td>
<p>Logical specifying whether clonotyping should occur across samples or only within a single sample (grouping via sample_id column).</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_+3A_vdj.vj.1chain">VDJ.VJ.1chain</code></td>
<td>
<p>Logical specifying whether cells other than once with 1 VDJ and 1 VJ chains should be considered.</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_+3A_output.format">output.format</code></td>
<td>
<p>Parameter output.format is deprecated. If non VGM-style output is required please refer to the function VDJ_clonotype. Output is VGM style VDJ by cell dataframe</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Only &quot;v3&quot; available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a VGM[[1]]-type dataframe. The columns clonotype_id and clonotype_frequency are updated with the new clonotyping strategy. They represent the &quot;active strategy&quot; that downstream functions will use. Furthermore extra columns are added with clonotyping information.New columns are named by clonotyping strategy so to allow for multiple clonotyping identifiers to be present in the same VDJ dataframe and make comparisons between these straighforward.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reclonotyped_vgm &lt;- VDJ_clonotype(VDJ=Platypus::small_vgm[[1]],
clone.strategy="cdr3.nt",
hierarchical = "none", global.clonotype = TRUE)

reclonotyped_vgm &lt;- VDJ_clonotype(VDJ=Platypus::small_vgm[[1]],
clone.strategy="cdr3.homology", homology.threshold = 0.5,
hierarchical = "single.chains", global.clonotype = TRUE)

</code></pre>

<hr>
<h2 id='VDJ_clonotype_v3_w_enclone'>Updated clonotyping function based on implications for cells with different chain numbers than 1 VDJ 1 VJ chains.</h2><span id='topic+VDJ_clonotype_v3_w_enclone'></span>

<h3>Description</h3>

<p>This function offers two types of hierarchical clonotyping. The hierarchical option &quot;single.chains&quot; only merges cell with a single chain into clonotypes composed of cells with 1 VDJ 1 VJ chain. This is based on the assumption, that during mRNA capture and RT-PCR in GEMs, not all transcripts are captured and therefore cells may result missing a VDJ or VJ chain.
The hierarchical option &quot;double.and.single.chains&quot; is based on the assumption, that cells with 1 VDJ and 2 VJ chains exist. For a review of the work concerning such cells as well as 2 VDJ 1 VJ cells please consult: https://doi.org/10.4049/jimmunol.1800904. The user may set a threshold of occurrence number above which cells with 1 VDJ 2 VJ chains are considered to be true and other cells with 1 VDJ 1 VJ, 1 VDJ 0 VJ and 0 VDJ 1 VDJ may be merged into the same clonotype by the strategy provided by the user. Cells with 2 VDJ chains are currently not considered in this process, as these are reported to be much rarer and, if appearing in the dataset are more likely to be doublets.
We advice the user to carefully examine the output after hierarchical clonotyping before proceeding with further analysis.
We thank Prof. Vijayanand as well as Vicente and Emmanuel from his lab for the discussions that have helped with improving the original Platypus clonotyping strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_clonotype_v3_w_enclone(
  VDJ,
  VDJ.directory,
  clone.strategy,
  samples.to.clonotype,
  samples.to.combine,
  homology.threshold,
  hierarchical,
  triple.chain.count.threshold,
  global.clonotype,
  VDJ.VJ.1chain,
  same.origin,
  platypus.version,
  operating.system
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_vdj">VDJ</code></td>
<td>
<p>For platypus v2 output from VDJ_analyze function. This should be a list of clonotype dataframes, with each list element corresponding to a single VDJ repertoire. For platypus v3 VDJ output from the VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[1]])</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_vdj.directory">VDJ.directory</code></td>
<td>
<p>Cellranger output directory for VDJ files.</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_clone.strategy">clone.strategy</code></td>
<td>
<p>(Updated keywords, previous format is also functional) String describing the clonotyping strategy. Possible options are 10x.default, cdr3.nt, cdr3.aa, VDJJ.VJJ, VDJJ.VJJ.cdr3length, VDJJ.VJJ.cdr3length.cdr3.homology, VDJJ.VJJ.cdr3length.VDJcdr3.homology, cdr3.homology, VDJcdr3.homology. cdr3.aa will convert the default cell ranger clonotyping to amino acid based. 'VDJJ.VJJ' groups B cells with identical germline genes (V and J segments for both heavy chain and light chain. Those arguments including 'cdr3length' will group all sequences with identical VDJ and VJ CDR3 sequence lengths. Those arguments including 'cdr3.homology' will additionally impose a homology requirement for CDRH3 and CDRL3 sequences.'CDR3.homology',or 'CDRH3.homology' will group sequences based on homology only (either of the whole CDR3 sequence or of the VDJ CDR3 sequence respectively).
All homology calculations are performed on the amino acid level.</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_samples.to.clonotype">samples.to.clonotype</code></td>
<td>
<p>Vector - lists the samples names which should be clonotyped. The unspecified samples will keep their old clonotype defintions.</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_samples.to.combine">samples.to.combine</code></td>
<td>
<p>Vector or list of vectors - lists the samples which you wish to have their clonotypes merged (e.g., c('s1','s2') to only merge the first 2 samples, or list(c('s1','s3'), c('s2', 's4')) to merge the first and third, second and fourth, respectively). global.clonotype must be set to T!</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_homology.threshold">homology.threshold</code></td>
<td>
<p>Numeric value between 0 and 1 corresponding to the homology threshold forn the clone.strategy arguments that require a homology threshold. Default value is set to 70 percent sequence homology. For 70 percent homology, 0.3 should be supplied as input.</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_hierarchical">hierarchical</code></td>
<td>
<p>Character. Defaults to &quot;none&quot;. This is an extention specifically for cells with aberrant numbers of chains (i.e. 0VDJ 1VJ, 1VDJ 0VJ, 0VDJ 2VJ, 2VDJ 0VJ). Cells with 2VDJ 2VJ are filtered out as these are most likely doublets.
If set to &quot;none&quot; aberrant cells are assigned to their own clonotypes.
If set to &quot;single.chains&quot; the function will proceed in two steps: 0. Prefiltering: cells with 2 VDJ 2 VJ chains as well as cells with 2 VDJ and any number of VJ chains are filtered out. 1. define clonotypes classically with all cells containing exactly 1VDJ 1VJ chains. 2. For cells with only a single chain (either VDJ or VJ), check if any clone exists, which matches the clonotyping criteria for this chain. If true, add this cell to that clone. If false, create a new clone containing that cell. In case that more than 1 existing clone matches the aberrant cell, the cell is assigned to the most frequent existing clone. Two reasons are behind this decision: 2.1. The aberrant cells is numerically more likely to be a part of the more frequent existing clone. 2.2 In case of a wrong assignment, the effect of the error is lower, if an already expanded clone is increase by one count, rather than a existing non-expanded clone being assigned a second entry and thereby resulting as expanded. Cells 
If set to &quot;double.and.single.chains&quot; the function will proceed as if set to &quot;single.chains&quot; but include two more steps
3. Check the frequency of each cell 1 VDJ 2 VJ chain exact clone (by exact nucleotide CDR3 matching). Only if this count exceeds the triple.chain.count.threshold, the clone is used as a &quot;hub clone&quot;. This protects from merging clonotypes on the basis of rare doublets.
4. Merge existing clonotypes into the 1 VDJ 2 VJ clonotypes as they match with the assumption that e.g. a cell with 1 VDJ 1 VJ is part of that same clonotype, but missing a VJ chain due to stochastical sampling</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_triple.chain.count.threshold">triple.chain.count.threshold</code></td>
<td>
<p>Minimal occurrance frequency for any cell with more than 2 of either VDJ or VJ chain (e.g. 2 VDJ 1 VJ) for it to be considered as a trustworthy clone for hierarchical clonotyping ONLY when hierarchical is set to &quot;double.and.single.chains&quot;. Defaults to 3, meaning that, an exact combination of three chains needs to appear in the dataset at least 3 times for it to be considered as a clone, into which other cells are merged. (For the counting of exact combination of chains CDR3 nucleotide string matching is used, even if clonotyping by homology)</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_global.clonotype">global.clonotype</code></td>
<td>
<p>Logical specifying whether clonotyping should occur across samples or only within a single sample (grouping via sample_id column).</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_vdj.vj.1chain">VDJ.VJ.1chain</code></td>
<td>
<p>Logical specifying whether cells other than once with 1 VDJ and 1 VJ chains should be considered.</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_same.origin">same.origin</code></td>
<td>
<p>Logical - if the merged samples come from the same donor, with the same or with different origins. If two datasets come from the same origin, enclone will filter to remove certain artifacts.</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Only &quot;v3&quot; available</p>
</td></tr>
<tr><td><code id="VDJ_clonotype_v3_w_enclone_+3A_operating.system">operating.system</code></td>
<td>
<p>Character - operating system on which enclone will be run. 'Windows' for Windows, 'Linux' for Linux, 'Darwin' for MacOS.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a VGM[[1]]-type dataframe. The columns clonotype_id and clonotype_frequency are updated with the new clonotyping strategy. They represent the &quot;active strategy&quot; that downstream functions will use. Furthermore extra columns are added with clonotyping information.New columns are named by clonotyping strategy so to allow for multiple clonotyping identifiers to be present in the same VDJ dataframe and make comparisons between these straighforward.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reclonotyped_vgm &lt;- VDJ_clonotype(VDJ=Platypus::small_vgm[[1]],
clone.strategy="cdr3.nt",
hierarchical = "none", global.clonotype = TRUE)

reclonotyped_vgm &lt;- VDJ_clonotype(VDJ=Platypus::small_vgm[[1]],
clone.strategy="cdr3.homology", homology.threshold = 0.5,
hierarchical = "single.chains", global.clonotype = TRUE)

</code></pre>

<hr>
<h2 id='VDJ_contigs_to_vgm'>Formats &quot;VDJ_contigs_annotations.csv&quot; files from cell ranger to match the VDJ_GEX_matrix output using only cells with 1VDJ and 1VJ chain</h2><span id='topic+VDJ_contigs_to_vgm'></span>

<h3>Description</h3>

<p>Formats &quot;VDJ_contigs_annotations.csv&quot; files from cell ranger to match the VDJ_GEX_matrix output using only cells with 1VDJ and 1VJ chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_contigs_to_vgm(directory, sample.names, celltype, FB, platypus.version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_contigs_to_vgm_+3A_directory">directory</code></td>
<td>
<p>list containing paths to the &quot;filtered_contig_annotations.csv&quot; files from cell ranger.</p>
</td></tr>
<tr><td><code id="VDJ_contigs_to_vgm_+3A_sample.names">sample.names</code></td>
<td>
<p>vector specifying sample names.</p>
</td></tr>
<tr><td><code id="VDJ_contigs_to_vgm_+3A_celltype">celltype</code></td>
<td>
<p>Character. Either &quot;Tcells&quot; or &quot;Bcells&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_contigs_to_vgm_+3A_fb">FB</code></td>
<td>
<p>Integer specifying whether VGM should contain Feature Barcode columns or not. Default set to FALSE.</p>
</td></tr>
<tr><td><code id="VDJ_contigs_to_vgm_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Function based on VGM object from V3, no need to set this parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with column names that match the VDJ_GEX_matrix output. Can be appended to the VDJ_GEX_matrix output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
directory.list &lt;- list()
directory.list[[1]] &lt;- c("~/Dataset_1/filtered_contig_annotations.csv")
directory.list[[2]] &lt;- c("~/Dataset_1/filtered_contig_annotations.csv")
filtered_contig_vgm &lt;- VDJ_contigs_to_vgm(directory = directory.list,
sample.names = c(s3,s4), celltype = "Tcells")
})

</code></pre>

<hr>
<h2 id='VDJ_db_annotate'>Wrapper function of VDJ_antigen_integrate function</h2><span id='topic+VDJ_db_annotate'></span>

<h3>Description</h3>

<p>Wraps the VDJ_antigen_integrate function and uses it to annotate a VDJ dataframe with antigen information. Needs to VDJ_db_load to be executed first, with preprocess=T and vgm.names=T to obtain the same column names as in the VDJ (to allow for sequence matching).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_db_annotate(VDJ, db.list, database.features, match, homology, lv.distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_db_annotate_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_db_annotate_+3A_db.list">db.list</code></td>
<td>
<p>list of database dataframes or csv file paths, obtained from VDJ_db_load with .</p>
</td></tr>
<tr><td><code id="VDJ_db_annotate_+3A_database.features">database.features</code></td>
<td>
<p>list of features/column names to be integrated from the databases.</p>
</td></tr>
<tr><td><code id="VDJ_db_annotate_+3A_match">match</code></td>
<td>
<p>string - sequences by which to match and integrate the antigen information. Currently, only 'cdr3.aa' and 'cdrh3.aa' are supported, as all databases have these two sequence types ('VJ_cdr3s_aa','VDJ_cdr3s_aa').</p>
</td></tr>
<tr><td><code id="VDJ_db_annotate_+3A_homology">homology</code></td>
<td>
<p>string - 'exact' for exact sequence matchings, 'homology' for homology matching.</p>
</td></tr>
<tr><td><code id="VDJ_db_annotate_+3A_lv.distance">lv.distance</code></td>
<td>
<p>integer - maximum Levehnstein distance threshold for the homology matchings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>VDJ with new columns - antigen information integrated from the antigen databases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ_db_annotate(VDJ=VDJ,db.list=db.list,database.features='Epitope',match='cdr3.aa',homology=FALSE)
})

</code></pre>

<hr>
<h2 id='VDJ_db_load'>Load and preprocess a list of antigen-specific databases</h2><span id='topic+VDJ_db_load'></span>

<h3>Description</h3>

<p>Preprocessing function for several antigen databases for both TCRs (VDJdb, McPAS-TCR, TBAdb) and BCRs (TBAdb), saving them either at a specified path, or loading them as a database list for downstream integration/analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_db_load(
  databases,
  file.paths,
  preprocess,
  species,
  filter.sequences,
  remove.na,
  vgm.names,
  keep.only.common,
  output.format,
  saving.path
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_db_load_+3A_databases">databases</code></td>
<td>
<p>list of databases to be processed and saved. Currently supported ones include: VDJdb(='vdjdb'), McPAS-TCR(='mcpas'), TBAdb(='tbdadb_tcr' or 'tbadb_bcr').</p>
</td></tr>
<tr><td><code id="VDJ_db_load_+3A_file.paths">file.paths</code></td>
<td>
<p>list of file paths for the specified databases (in the database parameter). If NULL, will try to locally download the databases from the archived download links.</p>
</td></tr>
<tr><td><code id="VDJ_db_load_+3A_preprocess">preprocess</code></td>
<td>
<p>boolean - if T, will preprocess each database individually.</p>
</td></tr>
<tr><td><code id="VDJ_db_load_+3A_species">species</code></td>
<td>
<p>string - either 'Human' or 'Mouse', the species for the processed database. Needs preprocess=T.</p>
</td></tr>
<tr><td><code id="VDJ_db_load_+3A_filter.sequences">filter.sequences</code></td>
<td>
<p>string - 'VDJ' to remove rows with NA VDJ sequences, 'VJ' to remove rows with NA VJ sequences, 'VDJ.VJ' to remove rows with both VDJ and VJ sequences missing. Needs preprocess=T.</p>
</td></tr>
<tr><td><code id="VDJ_db_load_+3A_remove.na">remove.na</code></td>
<td>
<p>string or NULL - 'all' will remove all rows with missing values from the database, 'common' will remove only rows with missing values for the shared columns among all databases ('VJ_cdr3s_aa','VDJ_cdr3s_aa','Species','Epitope','Antigen species'), 'vgm' will remove missing values for columns shared with the VDJ object (specific to each database). Needs preprocess=T.</p>
</td></tr>
<tr><td><code id="VDJ_db_load_+3A_vgm.names">vgm.names</code></td>
<td>
<p>boolean - if T, will change all column names of the shared columns (with VDJ) to match those from VDJ. Use this to integrate the antigen data into VDJ using VDJ_antigen_integrate or VDJ_db_annotate. Needs preprocess=T.</p>
</td></tr>
<tr><td><code id="VDJ_db_load_+3A_keep.only.common">keep.only.common</code></td>
<td>
<p>boolean - if T, will only keep the columns shared between all databases ('VJ_cdr3s_aa','VDJ_cdr3s_aa','Species','Epitope','Antigen species') for each processed database. Needs preprocess=T.</p>
</td></tr>
<tr><td><code id="VDJ_db_load_+3A_output.format">output.format</code></td>
<td>
<p>string - 'df.list' to save all databases as a list, 'save' to save them as csv files.</p>
</td></tr>
<tr><td><code id="VDJ_db_load_+3A_saving.path">saving.path</code></td>
<td>
<p>string - directory where the processed databases should be locally saved if output.format='save'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Processed antigen-specific databases for both TCRs and BCRs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ_db_load(databases=list('vdjdb'),file.paths=NULL,
preprocess=TRUE,species='Mouse',filter.sequences='VDJ.VJ',
remove.na='vgm', vgm.names=TRUE, keep.only.common=TRUE,
output.format='df.list', saving.path = tempdir())
})

</code></pre>

<hr>
<h2 id='VDJ_diversity'>Calculates and plots common diversity and overlap measures for repertoires and alike. Requires the vegan package</h2><span id='topic+VDJ_diversity'></span>

<h3>Description</h3>

<p>Calculates and plots common diversity and overlap measures for repertoires and alike. Requires the vegan package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_diversity(
  VDJ,
  feature.columns,
  grouping.column,
  metric,
  VDJ.VJ.1chain,
  subsample.to.same.n
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_diversity_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ dataframe output from the VDJ_GEX_matrix function.</p>
</td></tr>
<tr><td><code id="VDJ_diversity_+3A_feature.columns">feature.columns</code></td>
<td>
<p>Character vector. One or more column names from the VDJ of which diversity or overlap metrics are calculated. if more than one column is provided (e.g. c(&quot;VDJ_cdr3s_aa&quot;,&quot;VJ_cdr3s_aa&quot;)) these columns will be pasted together before metric calculation.</p>
</td></tr>
<tr><td><code id="VDJ_diversity_+3A_grouping.column">grouping.column</code></td>
<td>
<p>Character. Column name of a column to group metrics by. This could be &quot;sample_id&quot; to calculate the metric for each sample. This column is required if metric = &quot;simpson&quot;. If so, the simpson overlap index will be calculated pairwise for all combinations of elements in the grouping.column. Defaults to &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_diversity_+3A_metric">metric</code></td>
<td>
<p>Character. Diversity or overlap metric to calculate. Can be c(&quot;richness&quot;, &quot;bergerparker&quot;, &quot;simpson&quot;, &quot;ginisimpson&quot;, &quot;shannon&quot;, &quot;shannonevenness&quot;, &quot;jaccard&quot;). Defaults to &quot;shannon&quot;. If jaccard is selected, a heatmap with the pairwise comparisons between all groups is returned. If any of the others is selected, a dotplot is returned</p>
</td></tr>
<tr><td><code id="VDJ_diversity_+3A_vdj.vj.1chain">VDJ.VJ.1chain</code></td>
<td>
<p>Boolean defaults to TRUE. Whether to filter out aberrant cells (more than 1 VDJ or VJ chain).</p>
</td></tr>
<tr><td><code id="VDJ_diversity_+3A_subsample.to.same.n">subsample.to.same.n</code></td>
<td>
<p>Boolean defaults to TRUE. Whether to subsample larger groups down to the size of the smallest group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot with the calculated metric for each group (if provided).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot &lt;- VDJ_diversity(VDJ = Platypus::small_vgm[[1]],
,feature.columns = c("VDJ_cdr3s_aa"), grouping.column = "sample_id"
,metric = "shannon")

VDJ_diversity(VDJ = Platypus::small_vgm[[1]],
,feature.columns = c("VDJ_cdr3s_aa","VJ_cdr3s_aa"), grouping.column = "sample_id"
,metric = "ginisimpson")

VDJ_diversity(VDJ = Platypus::small_vgm[[1]],
,feature.columns = c("VDJ_jgene"), grouping.column = "sample_id"
,metric = "jaccard")

</code></pre>

<hr>
<h2 id='VDJ_dynamics'>Tracks a specific VDJ column across multiple samples/timepoints.</h2><span id='topic+VDJ_dynamics'></span>

<h3>Description</h3>

<p>Track a VDJ column across multiple samples or timepoints. Tracking consists of creating a per sample/timepoint dataframe of unique values for the VDJ column and their respective counts inside that timepoints/repertoire. Also creates alluvial plots to show the temporal dynamics of the tracked elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_dynamics(
  VDJ,
  columns.to.track,
  starting.point.repertoire,
  track.all.elements,
  track.only.common,
  max.elements.to.track,
  specific.elements.to.track,
  additional.grouping.column,
  max.additional.groups,
  specific.additional.groups,
  timepoints.column,
  proportions.level,
  output.format,
  ignore.legend
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_dynamics_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_columns.to.track">columns.to.track</code></td>
<td>
<p>string or list of strings - VDJ column with values to track (e.g., 'VDJ_cgene' will track the changes in isotype counts/proportions across multiple timepoints, defined by the timepoints.column). If two columns are provided and tracked, then a new values will be created by combining the values from each column.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_starting.point.repertoire">starting.point.repertoire</code></td>
<td>
<p>string or integer - the repertoire from which to start tracking (1 = will start at the first repertoire, 's3' will start at repertoire 's3').</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_track.all.elements">track.all.elements</code></td>
<td>
<p>boolean - if T (and track.only.common=F), it will track all elements across all repertoires/timepoints.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_track.only.common">track.only.common</code></td>
<td>
<p>boolean - if T (and track.all.elements=F), it will only track the common elements across all repertoires/timepoints.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_max.elements.to.track">max.elements.to.track</code></td>
<td>
<p>integer or NULL - the maximum number of elements to track (elements are first sorted by frequency/abundance). If NULL, it will track all elements.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_specific.elements.to.track">specific.elements.to.track</code></td>
<td>
<p>vector of strings or NULL - specific elements we want tracked. If NULL, all elements will be tracked.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_additional.grouping.column">additional.grouping.column</code></td>
<td>
<p>string or 'none' - VDJ column for calculating the frequency/counts of elements on a per-group level. If output.format='plot', each unique group will have its own bar plot of timepoints/repertoires (x axis) and feature counts (y axis). If NULL, no additional grouping will be done.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_max.additional.groups">max.additional.groups</code></td>
<td>
<p>integer or NULL - the maximum number of additional groups to consider (groups are first ordered by their frequency = total number of cells in that group in the VDJ matrix). If NULL, all groups will be considered.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_specific.additional.groups">specific.additional.groups</code></td>
<td>
<p>vector of strings or NULL - specific grouping factors we want to consider. If NULL, all grouping factors will be considered.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_timepoints.column">timepoints.column</code></td>
<td>
<p>string - VDJ column with either timepoints or repertoires across which we want to track our elements (usually 'sample_id').</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_proportions.level">proportions.level</code></td>
<td>
<p>string - 'absolute.counts' for absolute counts, 'group' for per group proportions, 'repertoire' for per repertoire/timepoint proportions.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_output.format">output.format</code></td>
<td>
<p>string - 'plot' for alluvial barplots, 'df' for count/proportions dataframes of the tracked elements.</p>
</td></tr>
<tr><td><code id="VDJ_dynamics_+3A_ignore.legend">ignore.legend</code></td>
<td>
<p>boolean - if T, the legend will not be included in the resulting ggplot object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a count dataframe of the tracked elements across multiple timepoints/repertoires, or alluvial barplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VDJ_dynamics(VDJ = Platypus::small_vgm[[1]],
columns.to.track='clonotype_id', starting.point.repertoire=1,
max.elements.to.track=10, timepoints.column='sample_id',
output.format='plot')

</code></pre>

<hr>
<h2 id='VDJ_expand_aberrants'>Expand the aberrant cells in a VDJ dataframe by converting them into additional rows</h2><span id='topic+VDJ_expand_aberrants'></span>

<h3>Description</h3>

<p>Expand the aberrant cells in a VDJ dataframe by converting them into additional rows. Aberrant cells consist of cells with more than 1 VDJ or VJ chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_expand_aberrants(
  VDJ,
  chain.to.expand,
  add.barcode.prefix,
  additional.VDJ.features,
  additional.VJ.features,
  add.CDR3aa,
  add.expanded.number,
  recalculate.clonotype.frequency
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_expand_aberrants_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_expand_aberrants_+3A_chain.to.expand">chain.to.expand</code></td>
<td>
<p>string, 'VDJ' to expand VDJ aberrants, 'VJ' to expand VJ aberrants, 'VDJ.VJ' for both.</p>
</td></tr>
<tr><td><code id="VDJ_expand_aberrants_+3A_add.barcode.prefix">add.barcode.prefix</code></td>
<td>
<p>boolean - if T, a new barcode will be added for each expanded aberrant.</p>
</td></tr>
<tr><td><code id="VDJ_expand_aberrants_+3A_additional.vdj.features">additional.VDJ.features</code></td>
<td>
<p>vector of strings - VDJ_expand_aberrants will only expand across the sequence columns of VDJ. If you have additional columns with aberrant cell features (e.g., both 'yes' and 'no' binders for a single sequence), where the aberrants are VDJ-specific, include them here.</p>
</td></tr>
<tr><td><code id="VDJ_expand_aberrants_+3A_additional.vj.features">additional.VJ.features</code></td>
<td>
<p>vector of strings - VDJ_expand_aberrants will only expand across the sequence columns of VDJ. If you have additional columns with aberrant cell features (e.g., both 'yes' and 'no' binders for a single sequence), where the aberrants are VJ-specific, include them here.</p>
</td></tr>
<tr><td><code id="VDJ_expand_aberrants_+3A_add.cdr3aa">add.CDR3aa</code></td>
<td>
<p>boolean - if T, will create a new column 'CDR3aa' with pasted VDJ_cdr3s_aa and VJ_cdr3s_aa.</p>
</td></tr>
<tr><td><code id="VDJ_expand_aberrants_+3A_add.expanded.number">add.expanded.number</code></td>
<td>
<p>boolean - if T, will add the number of new cells resulting from an aberrant one.</p>
</td></tr>
<tr><td><code id="VDJ_expand_aberrants_+3A_recalculate.clonotype.frequency">recalculate.clonotype.frequency</code></td>
<td>
<p>boolean - if T, will recalculate the clonotype frequencies for the resulting, expanded VDJ.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a VDJ format dataframe in which cells with more than one VDJ or VJ chain are split into multiple rows each containing only one VDJ VJ chain combination.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VDJ_expand_aberrants(VDJ = Platypus::small_vgm[[1]],
chain.to.expand='VDJ.VJ',
add.barcode.prefix=TRUE, recalculate.clonotype.frequency=FALSE)

</code></pre>

<hr>
<h2 id='VDJ_extract_germline_consensus_ref'>Making the trimmed reference and concatenating fr1-fr4</h2><span id='topic+VDJ_extract_germline_consensus_ref'></span>

<h3>Description</h3>

<p>Function that takes the VDJ and the fr1-fr4 sequence per antibody
Based on the ref argument, if TRUE it also returns the returns in the VDJ/VJ_ref.nt/aa the trimmed reference based
on the alignement with the consensus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_extract_germline_consensus_ref(
  VDJ,
  n_clones = NA,
  samples = NA,
  ref = TRUE,
  path_toData = "../Data/"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_extract_germline_consensus_ref_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or vgm[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_extract_germline_consensus_ref_+3A_n_clones">n_clones</code></td>
<td>
<p>integer, denoting the top n clones to get the reference. If NA it is performed in all clones</p>
</td></tr>
<tr><td><code id="VDJ_extract_germline_consensus_ref_+3A_samples">samples</code></td>
<td>
<p>list of sample names, with the same order as they were accessed to make the VGM</p>
</td></tr>
<tr><td><code id="VDJ_extract_germline_consensus_ref_+3A_ref">ref</code></td>
<td>
<p>bool, denoting whether or not we trim the reference of the antibodies.</p>
</td></tr>
<tr><td><code id="VDJ_extract_germline_consensus_ref_+3A_path_todata">path_toData</code></td>
<td>
<p>str, denoting the folder containing the VDJ folder with VDJ information per sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>$vdj: VDJ containing the VDJ/VJ_ref.nt/aa columns if ref = TRUE and the full_VDJ, full_VJ columns with the fr1-fr4. $clones: clone_ids for which a reference was made.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
samples = c('LCMV', 'TNFR')
vgm = read("VGM.RData")
n_clones = 20
result = VDJ_extract_germline_consensus_ref(vgm$VDJ, n_clones,
samples, ref = TRUE,
path_toData="../Data/")
VDJ = result[1]$vdj
clone_counts = result[2]$clones
})


</code></pre>

<hr>
<h2 id='VDJ_germline'>Infer germline from the desired software/caller</h2><span id='topic+VDJ_germline'></span>

<h3>Description</h3>

<p>Function to infer the germline from the tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_germline(VDJ, germlines.from, VDJ.only)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_germline_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ dataframe obtained after calling VDJ_call_MIXCR or any other germline you want to use</p>
</td></tr>
<tr><td><code id="VDJ_germline_+3A_germlines.from">germlines.from</code></td>
<td>
<p>MIXCR or any other germline caller - default: MIXCR</p>
</td></tr>
<tr><td><code id="VDJ_germline_+3A_vdj.only">VDJ.only</code></td>
<td>
<p>boolean - if T, only Heavy Chain (VDJ) germline will be inferred</p>
</td></tr>
</table>


<h3>Value</h3>

<p>VDJ with the updated germline
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ_germline(VDJ, germlines.from='MIXCR',
VDJ.only=T)
})

</code></pre>

<hr>
<h2 id='VDJ_get_public'>Function to get shared/public elements across multiple repertoires</h2><span id='topic+VDJ_get_public'></span>

<h3>Description</h3>

<p>Function to get shared elements across multiple repertoires, specified by the feature.columns parameter (a column of the VDJ matrix). If two columns are specified in feature.columns, the resulting shared features will combine the values from each column (at a per-cell level).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_get_public(
  VDJ,
  feature.columns,
  repertoire.column,
  specific.repertoires,
  find.public.all,
  find.public.percentage,
  treat.combined.features,
  output.format
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_get_public_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_get_public_+3A_feature.columns">feature.columns</code></td>
<td>
<p>Character or character vector columns of features to be assayed</p>
</td></tr>
<tr><td><code id="VDJ_get_public_+3A_repertoire.column">repertoire.column</code></td>
<td>
<p>string - the repertoire-defining column (default to 'sample_id').</p>
</td></tr>
<tr><td><code id="VDJ_get_public_+3A_specific.repertoires">specific.repertoires</code></td>
<td>
<p>vector of strings or NULL - if only the shared elements from specific repertoires should be taken into account. If NULL, will output the shared/public elements across all repertoires.</p>
</td></tr>
<tr><td><code id="VDJ_get_public_+3A_find.public.all">find.public.all</code></td>
<td>
<p>boolean - if T, will look for the public elements across all repertoires</p>
</td></tr>
<tr><td><code id="VDJ_get_public_+3A_find.public.percentage">find.public.percentage</code></td>
<td>
<p>list - the first element denotes the percentage of repertoires to get shared elements for, the second element is the maximum number of repertoire combinations to consider (can be NULL to consider all).</p>
</td></tr>
<tr><td><code id="VDJ_get_public_+3A_treat.combined.features">treat.combined.features</code></td>
<td>
<p>string - 'exclude' will exclude combined features with one element missing, 'include' will include and considers them as a new feature value.</p>
</td></tr>
<tr><td><code id="VDJ_get_public_+3A_output.format">output.format</code></td>
<td>
<p>string - 'df' to get a shared element dataframe (with columns = Repertoire and Public), 'list' for a list of shared elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a dataframe of public elements across multiple repertoires or a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VDJ_get_public(VDJ = Platypus::small_vgm[[1]],
feature.columns='VDJ_cdr3s_aa', find.public.all=TRUE,
output.format='df')

</code></pre>

<hr>
<h2 id='VDJ_GEX_clonotype_clusters_circos'>Makes a Circos plot from the VDJ_GEX_integrate output. Connects the clonotypes with the corresponding clusters.</h2><span id='topic+VDJ_GEX_clonotype_clusters_circos'></span>

<h3>Description</h3>

<p>Makes a Circos plot from the VDJ_GEX_integrate output. Connects the clonotypes with the corresponding clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_GEX_clonotype_clusters_circos(
  VGM,
  topX,
  label.threshold,
  axis,
  c.threshold,
  c.count.label,
  c.count.label.size,
  n_cluster,
  platypus.version,
  gene.label,
  gene.label.size,
  arr.col,
  arr.direction,
  platy.theme,
  clonotype.column
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_vgm">VGM</code></td>
<td>
<p>The output of the VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[1]]) has to be supplied. For Platypus v2: The output of the VDJ_GEX_integrate function (Platypus platypus.version v2). A list of data frames for each sample containing the clonotype information and cluster membership information.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_topx">topX</code></td>
<td>
<p>Filters for the top X clonotypes and only plots the respective gene combinations or cluster memberships.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_label.threshold">label.threshold</code></td>
<td>
<p>Genes are only labeled if the count is larger then the label.threshold. By default all label.threshold = 0 (all genes are labeled).</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_axis">axis</code></td>
<td>
<p>Character. Axis scaling. Defaults to &quot;max&quot;. Passed to VDJ_circos</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_c.threshold">c.threshold</code></td>
<td>
<p>Only clonotypes are considered with a frequency higher then c.threshold. Allows to filter for only highly expanded clonotypes.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_c.count.label">c.count.label</code></td>
<td>
<p>Boolean, lets the user decide if the gene and count labels should be plotted or not. Default = T.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_c.count.label.size">c.count.label.size</code></td>
<td>
<p>Determines the font size of the gene labels. By default the font size for count labels is 0.6.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_n_cluster">n_cluster</code></td>
<td>
<p>Integer. No default.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Input version to use. Defaults to &quot;v3&quot; for VDJ_GEX_matrix input</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_gene.label">gene.label</code></td>
<td>
<p>Boolean, lets the user decide if the gene labels should be plotted or not.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_gene.label.size">gene.label.size</code></td>
<td>
<p>Determines the font size of the gene labels. By default the labelsize is automatically adjusted to 0.7 for labels with two or less digits, 0.6 for labels between 2 and 6 digits, and 0.4 for all longer labels. A manually defined font size will be the same for all labels!</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_arr.col">arr.col</code></td>
<td>
<p>Data.frame with three columns where the first two indicate the names of genes, clonotypes or clusters to be connected, and the third corresponds to the color of the arrow. Default set to data.frame(c(&quot;dummy.clonotype&quot;), c(&quot;dummy.cluster&quot;), c(&quot;dummy.color&quot;)), so no arrow is drawn.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_arr.direction">arr.direction</code></td>
<td>
<p>Either 1 or -1 and determines the direction of the arrow. Default=1.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_platy.theme">platy.theme</code></td>
<td>
<p>Allows plotting in the new &quot;pretty&quot; theme or the older &quot;spiky&quot; theme without group labels and radial arrangement of gene.labels. Default = &quot;pretty&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_clonotype_clusters_circos_+3A_clonotype.column">clonotype.column</code></td>
<td>
<p>Which column in VGM contains the clonotyping information? Default=&quot;clonotype_id_10X&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a circos plot and a list object with the following elememts for N samples: [[1 to N]] The first N listelements corresponds to the recorded circos plots for N beeing the number or samples in the VGM. Since Circlize uses the R base plotting funciton, this is not a ggplot object but can still be replotted by calling the first list element. [[N+1]] Adjacency matrix forwarded to VDJ_circos(). This Matrix contains the counts and can be used for manual replotting using VDJ_circos directly. [[N+2]] Contains a named list with colors for each connection drawn and can be used for manual replotting using VDJ_circos directly. [[N+3]] Contains a named list with grouping information and can be used for manual replotting using VDJ_circos directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
 clonotype.clusters &lt;- VDJ_GEX_clonotype_clusters_circos(Platypus::small_vgm[[1]],
 n_cluster=8, topX = 20)
 clonotype.clusters[[1]]
 })


</code></pre>

<hr>
<h2 id='VDJ_GEX_matrix'>VDJ GEX processing and integration wrapper</h2><span id='topic+VDJ_GEX_matrix'></span>

<h3>Description</h3>

<p>This function is designed as a common input to the Platypus pipeline. Integration of datasets as well as VDJ and GEX information is done here. Please check the Platypus V3 vignette for a detailed walkthrough of the output structure. In short: output[[1]] = VDJ table, output[[2]] = GEX Seurat object and output[[3]] = statistics
[FB] Feature barcode (FB) technology is getting increasingly popular, which is why Platypus V3 fully supports their use as sample delimiters. As of V3, Platpyus does not support Cite-seq data natively, also the VDJ_GEX_matrix function is technically capable of loading a Cite-seq matrix and integrating it with VDJ. For details on how to process sequencing data with FB data and how to supply this information to the VDJ_GEX_matrix function, please consult the dedicated vignette on FB data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_GEX_matrix(
  VDJ.out.directory.list,
  GEX.out.directory.list,
  FB.out.directory.list,
  Data.in,
  Seurat.in,
  group.id,
  GEX.read.h5,
  VDJ.combine,
  GEX.integrate,
  integrate.GEX.to.VDJ,
  integrate.VDJ.to.GEX,
  exclude.GEX.not.in.VDJ,
  filter.overlapping.barcodes.GEX,
  filter.overlapping.barcodes.VDJ,
  get.VDJ.stats,
  append.raw.reference,
  select.excess.chains.by.umi.count,
  excess.chain.confidence.count.threshold,
  trim.and.align,
  parallel.processing,
  numcores,
  gap.opening.cost,
  gap.extension.cost,
  exclude.on.cell.state.markers,
  exclude.on.barcodes,
  integration.method,
  VDJ.gene.filter,
  mito.filter,
  norm.scale.factor,
  n.feature.rna,
  n.count.rna.min,
  n.count.rna.max,
  n.variable.features,
  cluster.resolution,
  neighbor.dim,
  mds.dim,
  FB.count.threshold,
  FB.ratio.threshold,
  FB.exclude.pattern,
  subsample.barcodes,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_GEX_matrix_+3A_vdj.out.directory.list">VDJ.out.directory.list</code></td>
<td>
<p>List containing paths to VDJ output directories from cell ranger. This pipeline assumes that the output file names have not been changed from the default 10x settings in the /outs/ folder. This is compatible with B and T cell repertoires. ! Neccessary files within this folder: filtered_contig_annotations.csv, clonotypes.csv, concat_ref.fasta, all_contig_annotations.csv (only if trim.and.align == TRUE) and metrics_summary.csv (Optional, will be appended to stats table if get.VDJ.stats == TRUE)</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_gex.out.directory.list">GEX.out.directory.list</code></td>
<td>
<p>List containing paths the outs/ directory of each sample or directly the raw or filtered_feature_bc_matrix folder. Order of list items must be the same as for VDJ. These may be paths to cellranger aggr or cellranger multi output directories. In that case, additional matrices found, will be loaded as either GEX or FB (Feature barcodes) depending on the number of features in the matrix.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_fb.out.directory.list">FB.out.directory.list</code></td>
<td>
<p>[FB] List of paths pointing at the outs/ directory of output from the Cellranger counts function which contain Feature barcode counts. ! Single list elements can be a path or &quot;PLACEHOLDER&quot;, if the corresponding input in the VDJ or GEX path does not have any adjunct FB data. This is only the case when integrating two datasets of which only one has FB data. See examples for details. Any input will overwrite potential FB data loaded from the GEX input directories. This may be important, if wanting to input unfiltered FB data that will cover also cells in VDJ not present in GEX.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_data.in">Data.in</code></td>
<td>
<p>Input for R objects from either the PlatypusDB_load_from_disk or the PlatypusDB_fetch function. If provided, input directories should not be specified. If you wish to integrate local and downloaded data, please load them via load_from_disk and fetch and provide as a list (e.g. Data.in = list(load_from_disk.output, fetch.output))</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_seurat.in">Seurat.in</code></td>
<td>
<p>Alternative to GEX.out.directory.list. A seurat object. VDJ.integrate has to be set to TRUE. In metadata the column of the seurat object, sample_id and group_id must be present. sample_id must contain ids in the format &quot;s1&quot;, &quot;s2&quot; ... &quot;sn&quot; and must be matching the order of VDJ.out.directory.list. No processing (i.e. data normalisation and integration) will be performed on these objects. They will be returned as part of the VGM and with additional VDJ data if integrate.VDJ.to.GEX = T. Filtering parameters such as overlapping barcodes, exclude.GEX.not.in.VDJ and exclude.on.cell.state.markers will be applied to the Seurat.in GEX object(s).</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_group.id">group.id</code></td>
<td>
<p>vector with integers specifying the group membership. c(1,1,2,2) would specify the first two elements of the input VDJ/GEX lists are in group 1 and the third/fourth input elements will be in group 2.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_gex.read.h5">GEX.read.h5</code></td>
<td>
<p>Boolean. defaults to FALSE. Whether to read GEX data from an H5 file. If set to true, please provide the each directory containing a cellranger H5 output file or a direct path to a filtered_feature_bc_matrix.h5 as one GEX.out.directory.list element.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_vdj.combine">VDJ.combine</code></td>
<td>
<p>Boolean. Defaults to TRUE. Whether to integrate repertoires. A sample identifier will be appended to each barcode both in GEX as well as in VDJ. Recommended for all later functions</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_gex.integrate">GEX.integrate</code></td>
<td>
<p>Boolean. Defaults to TRUE. Whether to integrate GEX data. Default settings use the seurat scale.data option to integrate datasets. Sample identifiers will be appended to each barcode both in GEX and VDJ This is helpful when analysing different samples from the same organ or tissue, while it may be problematic when analysing different tissues.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_integrate.gex.to.vdj">integrate.GEX.to.VDJ</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to integrate GEX metadata (not raw counts) into the VDJ output dataframe ! Only possible, if GEX.integrate and VDJ.combine are either both FALSE or both TRUE</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_integrate.vdj.to.gex">integrate.VDJ.to.GEX</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to integrate VDJ data into GEX seurat object as metadata. ! Only possible, if GEX.integrate and VDJ.combine are either both FALSE or both TRUE</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_exclude.gex.not.in.vdj">exclude.GEX.not.in.VDJ</code></td>
<td>
<p>Boolean. defaults to FALSE. Whether to delete all GEX cell entries, for which no VDJ information is available. Dependent on data quality and sequencing depth this may reduce the GEX cell count by a significant number</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_filter.overlapping.barcodes.gex">filter.overlapping.barcodes.GEX</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to remove barcodes which are shared among samples in the GEX analysis. Shared barcodes normally appear at a very low rate.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_filter.overlapping.barcodes.vdj">filter.overlapping.barcodes.VDJ</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to remove barcodes which are shared among samples in the GEX analysis. Shared barcodes normally appear at a very low rate.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_get.vdj.stats">get.VDJ.stats</code></td>
<td>
<p>Boolean. defaults to TRUE. Whether to generate general statistics table for VDJ repertoires. This is appended as element [[3]] of the output list.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_append.raw.reference">append.raw.reference</code></td>
<td>
<p>Boolean. Defaults to TRUE. This appends the raw reference sequence for each contig even if trim.and.align is set to FALSE.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_select.excess.chains.by.umi.count">select.excess.chains.by.umi.count</code></td>
<td>
<p>Boolean. Defaults to FALSE. There are several methods of dealing with cells containing reads for more than 1VDJ and 1VJ chain. While many analyses just exclude such cells, the VGM is designed to keep these for downstream evaluation (e.g. in VDJ_clonotype). This option presents an evidenced-based way of selectively keeping or filtering only one of the present VDJ  and VJ chains each. This works in conjunction with the parameter excess.chain.confidence.count.threshold (below) Idea source: Zhang W et al. Sci Adv. 2021 (10.1126/sciadv.abf5835)</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_excess.chain.confidence.count.threshold">excess.chain.confidence.count.threshold</code></td>
<td>
<p>Interger. Defaults to 1000. This sets a umi count threshold for keeping excessive chains in a cell (e.g. T cells with 2 VJ and 1 VDJ chain) and only has an effect if select.excess.chains.by.umi.count is set to TRUE. For a given cell with chains and their UMI counts: VDJ1 = 3, VDJ2 = 7, VJ1 = 6. If count.threshold is kept at default (1000), the VDJ chain with the most UMIs will be kept (VDJ2), while the other is filtered out (VDJ1), leaving the cell as VDJ2, VJ1. If the count.threshold is set to 3, both chains VDJ chains of this cell are kept as their UMI counts are equal or greater to the count.threshold and therefore deemed high confidence chains. In the case of UMI counts being equal for two chains AND below the count.threshold, the first contig entry is kept, while the second is filtered. To avoid filtering excess chains, set select.excess.chains.by.umi.count to FALSE. For further notes on the implication of these please refer to the documentation of the parameter hierarchical in the function VDJ_clonotype_v3.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_trim.and.align">trim.and.align</code></td>
<td>
<p>Boolean. Defaults to FALSE. Whether to trim VJ/VDJ seqs, align them to the 10x reference and trim the reference. This is useful to get full sequences for antibody expression or numbers of somatic hypermutations. !Setting this to TRUE significantly increases computational time</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_parallel.processing">parallel.processing</code></td>
<td>
<p>Character string. Can be &quot;parlapply&quot; for Windows system, &quot;mclapply&quot; for unix and Mac systems or &quot;none&quot; to use a simple for loop (slow!). Default is &quot;none&quot; for compatibility reasons. For the parlapply option the packages parallel, doParallel and the dependency foreach are required</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_numcores">numcores</code></td>
<td>
<p>Number of cores used for parallel processing. Defaults to number of cores available. If you want to chek how many cores are available use the library Parallel and its command detectCores() (Not setting a limit here when running this function on a cluster may cause a crash)</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_gap.opening.cost">gap.opening.cost</code></td>
<td>
<p>Argument passed to Biostrings::pairwiseAlignment during alignment to reference. Defaults to 10</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_gap.extension.cost">gap.extension.cost</code></td>
<td>
<p>Argument passed to Biostrings::pairwiseAlignment during alignment to reference. Defaults to 4</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_exclude.on.cell.state.markers">exclude.on.cell.state.markers</code></td>
<td>
<p>Character vector. If no input is provided or input is &quot;none&quot;, no cells are excluded. Input format should follow: Character vector containing the gene names for each state. ; is used to use multiple markers within a single gene state. Different vector elements correspond to different states. Example: c(&quot;CD4+;CD44-&quot;,&quot;CD4+;IL7R+;CD44+&quot;). All cells which match any of the given states (in the example case any of the 2) are excluded. This is useful in case different and non lymphocyte cells were co-sequenced. It should give the option to e.g. exclude B cells in the analysis of T cells in a dataset.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_exclude.on.barcodes">exclude.on.barcodes</code></td>
<td>
<p>Character vector. Provide a list of 10x barcodes WITHOUT the terminal id (-1 , -2 etc.) to exclude from GEX and VDJ prior to processing.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_integration.method">integration.method</code></td>
<td>
<p>String specifying which data normalization and integration pipeline should be used. Default is &quot;scale.data&quot;, which correspondings to the ScaleData function internal to harmony package. 'anchors' scales data individually and then finds and align cells in similar states as described here: https://satijalab.org/seurat/articles/integration_introduction.html. 'sct'specifies SCTransform from the Seurat package. &quot;harmony&quot; should be specificied to perform harmony integration. This method requires the harmony package from bioconductor.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_vdj.gene.filter">VDJ.gene.filter</code></td>
<td>
<p>Logical indicating if variable genes from the b cell receprot and t cell receptor should be removed from the analysis. True is highly recommended to avoid clonal families clustering together.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_mito.filter">mito.filter</code></td>
<td>
<p>Numeric specifying which percent of genes are allowed to be composed of mitochondrial genes. This value may require visual inspection and can be specific to each sequencing experiment. Users can visualize the percentage of genes corresponding to mitochondrial genes using the function &quot;investigate_mitochondial_genes&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_norm.scale.factor">norm.scale.factor</code></td>
<td>
<p>Scaling factor for the standard Seurat pipeline. Default is set to 10000 as reported in Seurat documentation.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_n.feature.rna">n.feature.rna</code></td>
<td>
<p>Numeric that specifies which cells should be filtered out due to low number of detected genes. Default is set to 0. Seurat standard pipeline uses 2000.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_n.count.rna.min">n.count.rna.min</code></td>
<td>
<p>Numeric that specifies which cells should be filtered out due to low RNA count.Default is set to 0. Seurat standard pipeline without VDJ information uses 200.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_n.count.rna.max">n.count.rna.max</code></td>
<td>
<p>Numeric that specifies which cells should be filtered out due to high RNA count.Default is set to infinity. Seurat standard pipeline without VDJ information uses 2500.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_n.variable.features">n.variable.features</code></td>
<td>
<p>Numeric specifying the number of variable features. Default set to 2000 as specified in Seurat standard pipeline.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_cluster.resolution">cluster.resolution</code></td>
<td>
<p>Numeric specifying the resolution that will be supplied to Seurat's FindClusters function. Default is set to 0.5. Increasing this number will increase the number of distinct Seurat clusters. Suggested to examine multiple parameters to ensure gene signatures differentiating clusters remains constant.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_neighbor.dim">neighbor.dim</code></td>
<td>
<p>Numeric vector specifying which dimensions should be supplied in the FindNeighbors function from Seurat. Default input is '1:10'.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_mds.dim">mds.dim</code></td>
<td>
<p>Numeric vector specifying which dimensions should be supplied into dimensional reduction techniques in Seurat and Harmony. Default input is '1:10'.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_fb.count.threshold">FB.count.threshold</code></td>
<td>
<p>Numeric. Defaults to 10. For description of Feature Barcode assignment see parameter FB.ratio.threshold above</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_fb.ratio.threshold">FB.ratio.threshold</code></td>
<td>
<p>Numeric. Defaults to 2 Threshold for assignment of feature barcodes by counts. A feature barcode is assigned to a cell if its counts are &gt;FB.count.threshold and if its counts are FB.ratio.threshold-times higher than the counts of the feature barcode with second most counts.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_fb.exclude.pattern">FB.exclude.pattern</code></td>
<td>
<p>Character (regex compatible). If a feature barcode matches this pattern it will be excluded from the hashing sample assignments. This may be neccessary if CITE-seq barcodes and hashing barcodes are sequenced in the same run.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_subsample.barcodes">subsample.barcodes</code></td>
<td>
<p>For development purposes only. If set to TRUE the function will run on 100 cells only to increase speeds of debugging</p>
</td></tr>
<tr><td><code id="VDJ_GEX_matrix_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE prints runtime info to console. Defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single cell matrix including VDJ and GEX info. Format is a list with out[[1]] = a VDJ dataframe (or list of dataframes if VDJ.combine == FALSE, not recommended) containing also selected GEX information of integrate.GEX.to.VDJ = T. out[[2]] = GEX Seurat object with the metadata also containing GEX information if integrate.VDJ.to.GEX = T. out[[3]] = Dataframe with statistics on GEX and VDJ. out[[4]] = runtime parameters. out[[5]] = session info
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ.out.directory.list &lt;- list()
VDJ.out.directory.list[[1]] &lt;- c("~/VDJ/S1/")
VDJ.out.directory.list[[2]] &lt;- c("~/VDJ/S2/")
GEX.out.directory.list &lt;- list()
GEX.out.directory.list[[1]] &lt;- c("~/GEX/S1/")
GEX.out.directory.list[[2]] &lt;- c("~/GEX/S2/")
VGM &lt;- VDJ_GEX_matrix(
VDJ.out.directory.list = VDJ.out.directory.list
,GEX.out.directory.list = GEX.out.directory.list
,GEX.integrate = T
,VDJ.combine = T
,integrate.GEX.to.VDJ = T
,integrate.VDJ.to.GEX = T
,exclude.GEX.not.in.VDJ = F
,filter.overlapping.barcodes.GEX = F
,filter.overlapping.barcodes.VDJ = F
,get.VDJ.stats = T
,parallel.processing = "none"
,subsample.barcodes = F
,trim.and.align = F
,group.id = c(1,2))
})

</code></pre>

<hr>
<h2 id='VDJ_GEX_overlay_clones'>Overlay clones on GEX projection</h2><span id='topic+VDJ_GEX_overlay_clones'></span>

<h3>Description</h3>

<p>Highlights the cells belonging to any number of top clonotypes or of specifically selected clonotypes from one or more samples or groups in a GEX dimensional reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_GEX_overlay_clones(
  GEX,
  reduction,
  n.clones,
  clones.to.plot,
  by.sample,
  by.other.group,
  ncol.facet,
  pt.size,
  clone.colors,
  others.color,
  split.plot.and.legend,
  platypus.version
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_gex">GEX</code></td>
<td>
<p>A single seurat object from VDJ_GEX_matrix, which also includes VDJ information in the metadata (set integrate.VDJ.to.GEX to TRUE in the VDJ_GEX_matrix function) (VDJ_GEX_matrix.output[[2]]) ! Clone ids and frequencies are drawn from the columns &quot;clonotype_id&quot; and &quot;clonotype_frequency&quot;</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_reduction">reduction</code></td>
<td>
<p>Character. Defaults to &quot;umap&quot;. Name of the reduction to overlay clones on. Can be &quot;pca&quot;, &quot;umap&quot;, &quot;tsne&quot;</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_n.clones">n.clones</code></td>
<td>
<p>Integer. Defaults to 5. To PLOT TOP N CLONES. Number of Top clones to plot. If either by.sample or by.group is TRUE, n.clones clones from each sample or group will be overlayed</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_clones.to.plot">clones.to.plot</code></td>
<td>
<p>Character. Alternative to n.clones. TO PLOT SPECIFIC CLONES. Must reference a column in the GEX@meta.data filled with TRUE and FALSE. Entries with TRUE label are plotted. Such a column may be generated using GEX@metadata$clones_to_plot_column &lt;- GEX@metadata$Some_cell_identifier == &quot;Interesting&quot;</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_by.sample">by.sample</code></td>
<td>
<p>Boolean. Defaults to FALSE. Whether to overlay clones by sample. If set to TRUE this will generate a facet_wrap plot with as many facets as samples.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_by.other.group">by.other.group</code></td>
<td>
<p>Character string. Defaults to &quot;none&quot;. Must be a valid column name of the metadata of the input seurat object. If so, this will generate a facet_wrap plot with as many facets unique entries in the specified column. This may be useful to plot cell type specific clones</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_ncol.facet">ncol.facet</code></td>
<td>
<p>Integer. Defaults to 2. Number of columns in the facet_wrap plot if by.sample or by.group is TRUE</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_pt.size">pt.size</code></td>
<td>
<p>Numeric. Defaults to 1. Size of points in DimPlot. Passed to Seurat::DimPlot</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_clone.colors">clone.colors</code></td>
<td>
<p>Character vector. Defaults to rainbow(n.clones). Colors to use for individual clones. One can provide either a vector of length n.clones or a of length Nr. of samples/groups \* n.clones. In case that a vector of length n.clones is provided and by.group or by.sample is TRUE, colors are repeated for each sample/group</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_others.color">others.color</code></td>
<td>
<p>Character. Color for cells that are not selected i.e. not part of the overlayed clonotypes. Defaults to &quot;grey80&quot;. To hide the rest of the umap set to &quot;white&quot;</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_split.plot.and.legend">split.plot.and.legend</code></td>
<td>
<p>Boolean. Defaults to FALSE. Whether to return the plot and the legend separately as a list. This can be useful if legends get large and distort the actual plots. The packages gridExtra and cowplot are required for this. If set to TRUE a list is returned where out[[1]] is the plot which can be printed just by executing out[[1]]; out[[2]] is the legend, which can be printed either using plot(out[[2]]) or grid.arrange(out[[2]])</p>
</td></tr>
<tr><td><code id="VDJ_GEX_overlay_clones_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Character. At the moment this function runs only on the output of the VDJ_GEX_matrix function meaning that it is exclusively part of Platypus &quot;v3&quot;. With further updates the functionality will be extended.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object or a list of a ggplot and a gtable legend (if split.plot.and.legend \=\= TRUE). Theme, colors etc. may be changed directly by adding new elements to this output (e.g. out \+ theme_minimal())
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
overlay_clones_plot &lt;- VDJ_GEX_overlay_clones(
GEX = Platypus::small_vgm[[2]], reduction = "umap"
,n.clones = 5, by.sample = FALSE
,by.other.group = "none", pt.size = 1,split.plot.and.legend = FALSE)

overlay_clones_plot &lt;- VDJ_GEX_overlay_clones(
GEX = Platypus::small_vgm[[2]], reduction = "umap"
,n.clones = 5, by.sample = TRUE, by.other.group = "none"
,pt.size = 1,ncol.facet = 2, split.plot.and.legend = FALSE)

overlay_clones_plot &lt;- VDJ_GEX_overlay_clones(
GEX = Platypus::small_vgm[[2]], reduction = "umap"
,n.clones = 5, by.sample = TRUE, by.other.group = "group_id", pt.size = 1
,ncol.facet = 2, split.plot.and.legend = TRUE)

</code></pre>

<hr>
<h2 id='VDJ_GEX_stats'>Standalone VDJ and GEX statistics.</h2><span id='topic+VDJ_GEX_stats'></span>

<h3>Description</h3>

<p>Gives stats on number and quality of reads. This function is integrated into the VDJ_GEX_matrix. Before running, please check list element [[3]] of VDJ_GEX_matrix output for already generated statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_GEX_stats(
  VDJ.out.directory,
  GEX.out.directory,
  sample.names,
  metrics10x,
  save.csv,
  filename
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_GEX_stats_+3A_vdj.out.directory">VDJ.out.directory</code></td>
<td>
<p>List of paths with each element containing the path to the output of cellranger VDJ runs. This pipeline assumes that the output file names have not been changed from the default 10x settings in the /outs/ folder. This is compatible with B and T cell repertoires (both separately and simultaneously).</p>
</td></tr>
<tr><td><code id="VDJ_GEX_stats_+3A_gex.out.directory">GEX.out.directory</code></td>
<td>
<p>OPTIONAL list of paths with each element containing the path to the output of cellranger GEX runs. This pipeline assumes that the output file names have not been changed from the default 10x settings in the /outs/ folder. This is compatible with B and T cell repertoires (both separately and simultaneously).</p>
</td></tr>
<tr><td><code id="VDJ_GEX_stats_+3A_sample.names">sample.names</code></td>
<td>
<p>OPTIONAL: an array of the same length as the input VDJ.out.directory list with custom names for each sample. If not provided samples will be numbered by processing order</p>
</td></tr>
<tr><td><code id="VDJ_GEX_stats_+3A_metrics10x">metrics10x</code></td>
<td>
<p>Whether to append metrics_summary.csv information provided by Cellranger for both VDJ and GEX. Defaults to T</p>
</td></tr>
<tr><td><code id="VDJ_GEX_stats_+3A_save.csv">save.csv</code></td>
<td>
<p>Boolean. Defaults to TRUE. Whether to directly save the resuts as a comma delimited .csv file in the current working directory.</p>
</td></tr>
<tr><td><code id="VDJ_GEX_stats_+3A_filename">filename</code></td>
<td>
<p>Character ending in .csv. Filename to save .csv as.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a single matrix where the rows are individual cells and the columns are repertoire features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
stats &lt;- VDJ_GEX_stats(VDJ.out.directory = VDJ.out.directory.list
,GEX.out.directory = GEX.out.directory.list,sample.names = c(1:4)
,metrics10x = TRUE,save.csv = FALSE)
})

</code></pre>

<hr>
<h2 id='VDJ_kmers'>Calculates and plots kmers distributions and frequencies.</h2><span id='topic+VDJ_kmers'></span>

<h3>Description</h3>

<p>Calculates and plots kmers distributions and frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_kmers(
  VDJ,
  sequence.column,
  grouping.column,
  kmer.k,
  max.kmers,
  specific.kmers,
  plot.format,
  as.proportions
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_kmers_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ dataframe output from the VDJ_GEX_matrix function.</p>
</td></tr>
<tr><td><code id="VDJ_kmers_+3A_sequence.column">sequence.column</code></td>
<td>
<p>Character vector. One or more sequence column names from the VDJ for kmer counting. if more than one column is provided (e.g. c(&quot;VDJ_cdr3s_aa&quot;,&quot;VJ_cdr3s_aa&quot;)) these columns will be pasted together before counting the kmers.</p>
</td></tr>
<tr><td><code id="VDJ_kmers_+3A_grouping.column">grouping.column</code></td>
<td>
<p>Character. Column name of a column to group kmer counting by. This could be &quot;sample_id&quot; to group each kmer by the sample.</p>
</td></tr>
<tr><td><code id="VDJ_kmers_+3A_kmer.k">kmer.k</code></td>
<td>
<p>Integer. Length k of each kmer.</p>
</td></tr>
<tr><td><code id="VDJ_kmers_+3A_max.kmers">max.kmers</code></td>
<td>
<p>Integer. Maximum number of kmers to be plotted in the output barplots.</p>
</td></tr>
<tr><td><code id="VDJ_kmers_+3A_specific.kmers">specific.kmers</code></td>
<td>
<p>Character vector. Specific kmers to be plotted in the output barplots.</p>
</td></tr>
<tr><td><code id="VDJ_kmers_+3A_plot.format">plot.format</code></td>
<td>
<p>Character. The output plot format: 'barplot' for barplots of kmer frequency per group, 'pca' for group-level PCA reduction across the kmer vectors, 'density' for kmer count density plots.</p>
</td></tr>
<tr><td><code id="VDJ_kmers_+3A_as.proportions">as.proportions</code></td>
<td>
<p>Boolean. If TRUE, will return the kmer barplot as proportions instead of absolute counts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot with the kmer analysis depedning on the plot.format parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
 VDJ_kmers(VDJ = Platypus::small_vgm[[1]],
 sequence.column = c("VDJ_cdr3s_aa"), grouping.column = "sample_id", kmer.k = 2, max.kmers = 5)
 })


</code></pre>

<hr>
<h2 id='VDJ_network'>Similarity networks based on CDR3 regions</h2><span id='topic+VDJ_network'></span>

<h3>Description</h3>

<p>Creates a similarity network where clones with similar CDR3s are connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_network(
  VDJ,
  distance.cutoff,
  per.sample,
  platypus.version,
  known.binders,
  hcdr3.only,
  is.bulk
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_network_+3A_vdj">VDJ</code></td>
<td>
<p>Either (for platypus version &quot;v2&quot;) output from VDJ_analyze function. This should be a list of clonotype dataframes, with each list element corresponding to a single VDJ repertoire, OR (for platypus version &quot;v3&quot;) the the VDJ matrix output of the VDJ_GEX_matrix() function (VDJ.GEX.matrix.output[[1]])</p>
</td></tr>
<tr><td><code id="VDJ_network_+3A_distance.cutoff">distance.cutoff</code></td>
<td>
<p>The threshold Levenshtein distance for which two nodes will be connected on the similarity network.</p>
</td></tr>
<tr><td><code id="VDJ_network_+3A_per.sample">per.sample</code></td>
<td>
<p>logical value indicating if a single networks should be produced for each mouse.</p>
</td></tr>
<tr><td><code id="VDJ_network_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Character. Defaults to &quot;v3&quot;. Can be &quot;v2&quot; or &quot;v3&quot; dependent on the input format</p>
</td></tr>
<tr><td><code id="VDJ_network_+3A_known.binders">known.binders</code></td>
<td>
<p>Either a character vector with cdr3s of known binders or a data frame with cdr3s in the first and the corresponding specificity in the second column. If this parameter is defined, the output will be a network with only edges between known binders and the repertoire nodes and edges between the known binders that have at least one edge to a repertoire node</p>
</td></tr>
<tr><td><code id="VDJ_network_+3A_hcdr3.only">hcdr3.only</code></td>
<td>
<p>logical value indicating if the network is based on heavy chain cdr3s (hcdr3.only = T) or pasted heavy and light chain cdr3s (hcdr3.only = F), works for platypus.version 3 only</p>
</td></tr>
<tr><td><code id="VDJ_network_+3A_is.bulk">is.bulk</code></td>
<td>
<p>logical value indicating whether the VDJ input was generated from bulk-sequencing data using the bulk_to_vgm function. If is.bulk = T, the VDJ_network function is compatible for use with bulk data. Defaults to False (F).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list containing networks and network information. If per.sample is set to TRUE then the result will be a network for each repertoire. If per.sample ==FALSE, output[[1]] &lt;- will contain the network, output[[2]] will contain the dataframe with information on each node, such as frequency, mouse origin etc. output[[3]] will contain the connected index - these numbers indicate that the nodes are connected to at least one other node. output[[4]] contains the paired graph - so the graph where only the connected nodes are drawn.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
network_out &lt;- VDJ_network(VDJ = Platypus::small_vgm[[1]],per.sample = FALSE,distance.cutoff = 2)
})

</code></pre>

<hr>
<h2 id='VDJ_ordination'>Performs ordination/dimensionality reduction for a species incidence matrix, depending on the species selected in the feature.columns parameter.</h2><span id='topic+VDJ_ordination'></span>

<h3>Description</h3>

<p>Performs ordination/dimensionality reduction for a species incidence matrix, depending on the species selected in the feature.columns parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_ordination(
  VDJ,
  feature.columns,
  grouping.column,
  method,
  reduction.level,
  VDJ.VJ.1chain,
  umap.n.neighbours,
  tsne.perplexity
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_ordination_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ dataframe output from the VDJ_GEX_matrix function.</p>
</td></tr>
<tr><td><code id="VDJ_ordination_+3A_feature.columns">feature.columns</code></td>
<td>
<p>Character vector. One or more column names from the VDJ to indicate the unique species for the incidence/count matrix. if more than one column is provided (e.g. c(&quot;VDJ_cdr3s_aa&quot;,&quot;VJ_cdr3s_aa&quot;)) these columns will be pasted together before metric calculation.</p>
</td></tr>
<tr><td><code id="VDJ_ordination_+3A_grouping.column">grouping.column</code></td>
<td>
<p>Character. Column name of a column to group the ordination by. This could be &quot;sample_id&quot; to reduce across each sample. Indicative of 'sites' in a typical community data matrix/incidence matrix used in community ecology analyses (species by sites).</p>
</td></tr>
<tr><td><code id="VDJ_ordination_+3A_method">method</code></td>
<td>
<p>Character. The ordination method; choose from either: PCA - 'pca', t-SNE - 'tsne', UMAP - 'umap', PCOA/MDS - 'mds', DCA - 'dca'.</p>
</td></tr>
<tr><td><code id="VDJ_ordination_+3A_reduction.level">reduction.level</code></td>
<td>
<p>Character. Whether to reduce across groups ('groups'), features/sequences ('features'), or both ('both').</p>
</td></tr>
<tr><td><code id="VDJ_ordination_+3A_vdj.vj.1chain">VDJ.VJ.1chain</code></td>
<td>
<p>Boolean defaults to TRUE. Whether to filter out aberrant cells (more than 1 VDJ or VJ chain).</p>
</td></tr>
<tr><td><code id="VDJ_ordination_+3A_umap.n.neighbours">umap.n.neighbours</code></td>
<td>
<p>Integer. Control the t-SNE perplexity when method = 'tsne'.</p>
</td></tr>
<tr><td><code id="VDJ_ordination_+3A_tsne.perplexity">tsne.perplexity</code></td>
<td>
<p>Integrer. Defaults to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot with the ordination analysis performer across features, groups, or both
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot &lt;- VDJ_ordination(VDJ = Platypus::small_vgm[[1]]
,feature.columns = c("VDJ_cdr3s_aa"), grouping.column = "sample_id"
,method = "pca", reduction.level = 'groups')

</code></pre>

<hr>
<h2 id='VDJ_overlap_heatmap'>Wrapper to determine and plot overlap between VDJ features across groups</h2><span id='topic+VDJ_overlap_heatmap'></span>

<h3>Description</h3>

<p>Yields overlap heatmap and datatable of features or combined features for different samples or groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_overlap_heatmap(
  VDJ,
  feature.columns,
  grouping.column,
  jaccard,
  plot.type,
  pvalues.label.size,
  axis.label.size,
  add.barcode.table
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_overlap_heatmap_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ output of the VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[1]])</p>
</td></tr>
<tr><td><code id="VDJ_overlap_heatmap_+3A_feature.columns">feature.columns</code></td>
<td>
<p>A character array of column names of which the overlap should be displayed. The content of these columns is pasted together (separated by &quot;/&quot;). E.g. if the overlap in cells germline gene usage is desired, the input could be c(&quot;VDJ_jgene&quot;,&quot;VDJ_dgene&quot;,&quot;VDJ_vgene&quot;). These columns would be pasted and compared across the grouping variable.</p>
</td></tr>
<tr><td><code id="VDJ_overlap_heatmap_+3A_grouping.column">grouping.column</code></td>
<td>
<p>A column which acts as a grouping variable. If repertoires are to be compared use the sample_id column.</p>
</td></tr>
<tr><td><code id="VDJ_overlap_heatmap_+3A_jaccard">jaccard</code></td>
<td>
<p>Boolean. Defaults to FALSE. If set to TRUE, the overlap will be reported as jaccard index. If set to FALSE the overlap will be repored as absolute counts</p>
</td></tr>
<tr><td><code id="VDJ_overlap_heatmap_+3A_plot.type">plot.type</code></td>
<td>
<p>Character. Either &quot;ggplot&quot; or &quot;pheatmap&quot;. Defaults to Pheatmap</p>
</td></tr>
<tr><td><code id="VDJ_overlap_heatmap_+3A_pvalues.label.size">pvalues.label.size</code></td>
<td>
<p>Numeric. Defaults to 4. Is passed on to ggplot theme</p>
</td></tr>
<tr><td><code id="VDJ_overlap_heatmap_+3A_axis.label.size">axis.label.size</code></td>
<td>
<p>Numeric. Defaults to 4. Is passed on to ggplot theme</p>
</td></tr>
<tr><td><code id="VDJ_overlap_heatmap_+3A_add.barcode.table">add.barcode.table</code></td>
<td>
<p>Boolean. Defaults to T. Whether to generate a dataframe with frequencies and barcodes of cells with overlapping features. This is useful to e.g. analyze deferentially expressed genes between cells of two samples or groups expressing the same VDJ or VJ chain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of a ggplot (out[[1]]), the source table or matrix for the plot out[[2]] and a table containing additional information in case that add.barcode.table was set to TRUE (out[[3]])
</p>


<h3>Examples</h3>

<pre><code class='language-R'>overlap &lt;- VDJ_overlap_heatmap(VDJ = Platypus::small_vgm[[1]]
,feature.columns = c("VDJ_cdr3s_aa"),
grouping.column = "sample_id", axis.label.size = 15
,plot.type = "ggplot")

</code></pre>

<hr>
<h2 id='VDJ_phylogenetic_trees'>Creates phylogenetic trees from a VDJ dataframe</h2><span id='topic+VDJ_phylogenetic_trees'></span>

<h3>Description</h3>

<p>Creates phylogenetic trees as tidytree dataframes from an input VDJ dataframe. The resulting phylogenetic trees can be plotted using VDJ_phylogenetic_trees_plot. Both of these functions require the tidytree and ggtree packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_phylogenetic_trees(
  VDJ,
  sequence.type,
  as.nucleotide,
  trimmed,
  include.germline,
  global.clonotype,
  VDJ.VJ.1chain,
  additional.feature.columns,
  filter.na.columns,
  maximum.lineages,
  minimum.sequences,
  maximum.sequences,
  tree.algorithm,
  tree.level,
  n.trees.combined,
  germline.scale.factor,
  output.format,
  parallel
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_sequence.type">sequence.type</code></td>
<td>
<p>string - sequences which will be used when creating the phylogenetic trees. 'cdr3' for CDR3s of both VDJs and VJs, 'cdrh3' for VDJ CDR3s, 'VDJ.VJ' for pasted full sequences of both VDJ and VJ, 'VDJ' for full VDJ sequences, 'VJ' for full VJ.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_as.nucleotide">as.nucleotide</code></td>
<td>
<p>boolean - if T, will only consider the DNA sequences specified by sequence.type, else it will consider the amino acid ones.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_trimmed">trimmed</code></td>
<td>
<p>boolean - in the case of full VDJ or VJ nt sequences, if the trimmed sequences should be consider (trimmed=T), or raw ones. You need to call MIXCR first on the VDJ dataframe using VDJ_call_MIXCR().</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_include.germline">include.germline</code></td>
<td>
<p>boolean - if T, a germline sequence will be included in the trees (root), obtained by pasting the VDJ_trimmed_ref and VJ_trimmed_ref sequences. You need to call MIXCR first on the VDJ dataframe using VDJ_call_MIXCR().</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_global.clonotype">global.clonotype</code></td>
<td>
<p>boolean - if T, will ignore samples from the sample_id column, creating global clonotypes.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_vdj.vj.1chain">VDJ.VJ.1chain</code></td>
<td>
<p>boolean - if T, will remove aberrant cells from the VDJ matrix.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_additional.feature.columns">additional.feature.columns</code></td>
<td>
<p>list of strings or NULL - VDJ column names which will comprise the per-sequence features to be included in the tidytree dataframe, which will be used to label nodes/ determines their color/ size etc. See also the VDJ_phylogenetic_trees_plot function.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_filter.na.columns">filter.na.columns</code></td>
<td>
<p>list of strings - VDJ columns names: if a phylogenetic tree/tidytree dataframe has all elements = NA in that feature, that tree will be completely removed.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_maximum.lineages">maximum.lineages</code></td>
<td>
<p>integer or 'all' - maximum number of clonotypes to create trees for. If 'all', will create trees for all clonotypes.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_minimum.sequences">minimum.sequences</code></td>
<td>
<p>integer - lower bound of sequences for a tree. Defaults to 3. Trees with a lower number will be automatically removed.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_maximum.sequences">maximum.sequences</code></td>
<td>
<p>integer - upper bound of sequences for a tree. Additional sequences will be removed, after being ordered by their total frequency.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_tree.algorithm">tree.algorithm</code></td>
<td>
<p>string - the algorithm used when constructing the phylogenetic trees. 'nj' for Neighbour-Joining, 'bionj', 'fastme.bal', and 'fastme.ols'</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_tree.level">tree.level</code></td>
<td>
<p>string - level at which to build phylogenetic trees. 'intraclonal' - tree per clonotype, per sample, 'global.clonotype' - global clonotype trees (include.germline must be F), irrespective of sample, 'combine.first.trees' will combine the trees for the most expanded clonotypes, per sample (include.germline must be F).</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_n.trees.combined">n.trees.combined</code></td>
<td>
<p>integer - number of trees to combine if tree.level='combine.first.trees'.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_germline.scale.factor">germline.scale.factor</code></td>
<td>
<p>numeric - as germlines are incredibly distant from their closest neighbours (in the tree), this controls the scale factor for the germline tree branch length for more intelligible downstream plotting.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_output.format">output.format</code></td>
<td>
<p>string - 'tree.df.list' returns a nested list of tidytree dataframes, per clonotype and per sample; 'lineage.df.list' returns a list of lineage dataframes - unique sequences per clonotype,</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_+3A_parallel">parallel</code></td>
<td>
<p>string - parallelization method to be used to accelerate computations, 'none', 'mclapply', or 'parlapply'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nested list of tidytree dataframes or lineage dataframes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
VDJ_phylogenetic_trees(VDJ=Platypus::small_vgm[[1]], sequence.type='VDJ.VJ',
trimmed=TRUE, as.nucleotide=TRUE, include.germline=TRUE,
additional.feature.columns=NULL, tree.level='intraclonal',
output.format='tree.df.list')
})

</code></pre>

<hr>
<h2 id='VDJ_phylogenetic_trees_plot'>Phylogenetic tree plotting</h2><span id='topic+VDJ_phylogenetic_trees_plot'></span>

<h3>Description</h3>

<p>Function to plot phylogenetic trees obtained from VDJ_phylogenetic_trees
</p>
<p>!Requires the ggtree package to be loaded! Plots trees from function VDJ_phylogenetic_trees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_phylogenetic_trees_plot(
  tree.dfs,
  color.by,
  size.by,
  shape.by,
  specific.leaf.colors,
  specific.leaf.shapes
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_phylogenetic_trees_plot_+3A_tree.dfs">tree.dfs</code></td>
<td>
<p>nested list of tidytree dataframes obtained from VDJ_phylogenetic_trees with output.format='tree.df.list'. tree.dfs[[1]][[2]] represent a tree dataframe for the first sample, second clonotype.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_plot_+3A_color.by">color.by</code></td>
<td>
<p>string - VDJ or tree df column name which will be used to color the tree nodes.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_plot_+3A_size.by">size.by</code></td>
<td>
<p>string or NULL - VDJ or tree df column name which determines the node size. If NULL, node sizes will be equal.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_plot_+3A_shape.by">shape.by</code></td>
<td>
<p>string or NULL - VDJ or tree df column name which determines the node shape. If NULL, node sizes will be equal.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_plot_+3A_specific.leaf.colors">specific.leaf.colors</code></td>
<td>
<p>named list or NULL - if NULL, colors will be automatically selected for each node according to its color.by value.</p>
</td></tr>
<tr><td><code id="VDJ_phylogenetic_trees_plot_+3A_specific.leaf.shapes">specific.leaf.shapes</code></td>
<td>
<p>named list or NULL - if NULL, shapes will be automatically selected for each node according to its shape.by value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nested list of ggtree plot objects for each sample and each clonotype.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
tree.dfs &lt;- VDJ_phylogenetic_trees(VDJ=Platypus::small_vgm[[1]], sequence.type='VDJ.VJ',
trimmed=TRUE, as.nucleotide=TRUE, include.germline=TRUE,
additional.feature.columns=NULL, tree.level='intraclonal',
output.format='tree.df.list')
VDJ_phylogenetic_trees_plot(tree.dfs,color.by='clonotype_id', size.by='sequence_frequency')
})

</code></pre>

<hr>
<h2 id='VDJ_plot_SHM'>Plotting of somatic hypermutation counts</h2><span id='topic+VDJ_plot_SHM'></span>

<h3>Description</h3>

<p>Plots for SHM based on MIXCR output generated using the VDJ_call_MIXCR function and appended to the VDJ.GEX.matrix.output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_plot_SHM(
  VDJ.mixcr.matrix,
  group.by,
  quantile.label,
  point.size,
  mean.line.color,
  stats.to.console,
  platypus.version
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_plot_SHM_+3A_vdj.mixcr.matrix">VDJ.mixcr.matrix</code></td>
<td>
<p>Output dataframe from the VDJ_call_MIXCR function or a dataframe generated using the VDJ_GEX_matrix function and supplemented with MIXCR information</p>
</td></tr>
<tr><td><code id="VDJ_plot_SHM_+3A_group.by">group.by</code></td>
<td>
<p>Character. Defaults to &quot;sample_id&quot;. Column name of VDJ.matrix to split VDJ.matrix by. For each unique entry in that column a set of plots will be generated. This can be useful to plot SHM by expansion or by transcriptomics-derived clusters</p>
</td></tr>
<tr><td><code id="VDJ_plot_SHM_+3A_quantile.label">quantile.label</code></td>
<td>
<p>Numeric. Defaults to 0.9. Which points to label in the SHM scatterplot. If set to 0.9, the top 10% of cells by SHM number will be labelled. If ggrepel throws a warning, concerning overlap it is recommended to attempt to lable less points to avoid cluttering</p>
</td></tr>
<tr><td><code id="VDJ_plot_SHM_+3A_point.size">point.size</code></td>
<td>
<p>Size of points in plots. Passed to geom_jitter()</p>
</td></tr>
<tr><td><code id="VDJ_plot_SHM_+3A_mean.line.color">mean.line.color</code></td>
<td>
<p>Color of mean bar in dotplots. Passed to geom_errorbar()</p>
</td></tr>
<tr><td><code id="VDJ_plot_SHM_+3A_stats.to.console">stats.to.console</code></td>
<td>
<p>Boolean. Defaults to FALSE. Prints basic statistics (AOV \+ post hoc test) to console</p>
</td></tr>
<tr><td><code id="VDJ_plot_SHM_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Character. Only &quot;v3&quot; available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of ggplot objects. out\[\[1\]\] is a boxplot comparing SHM by group.by. out\[\[2\]\] to out\[\[n\]\] are plots for each group that visualize VDJ and VJ SHM distribution for each group. Data for any plot can be accessed via out \[\[any\]\]$data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>small_vgm &lt;- Platypus::small_vgm
small_vgm[[1]]$VDJ_SHM &lt;- as.integer(rnorm(nrow(small_vgm[[1]]), mean = 5, sd = 3))
small_vgm[[1]]$VJ_SHM &lt;- as.integer(rnorm(nrow(small_vgm[[1]]), mean = 5, sd = 3))

SHM_plots &lt;- VDJ_plot_SHM(VDJ = small_vgm[[1]]
, group.by = "sample_id", quantile.label = 0.9)

SHM_plots &lt;- VDJ_plot_SHM(VDJ = small_vgm[[1]]
, group.by = "seurat_clusters", quantile.label = 0.99)

</code></pre>

<hr>
<h2 id='VDJ_public'>Function to get shared/public elements across multiple repertoires</h2><span id='topic+VDJ_public'></span>

<h3>Description</h3>

<p>Function to get shared elements across multiple repertoires, specified by the feature.columns parameter (a column of the VDJ matrix). If two columns are specified in feature.columns, the resulting shared features will combine the values from each column (at a per-cell level).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_public(
  VDJ,
  feature.columns,
  grouping.column,
  specific.groups,
  find.public.all,
  find.public.percentage,
  treat.combined.features,
  output.format
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_public_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ or VDJ.GEX.matrix[[1]] object, as obtained from the VDJ_GEX_matrix function in Platypus.</p>
</td></tr>
<tr><td><code id="VDJ_public_+3A_feature.columns">feature.columns</code></td>
<td>
<p>Character or character vector columns of features to be assayed</p>
</td></tr>
<tr><td><code id="VDJ_public_+3A_grouping.column">grouping.column</code></td>
<td>
<p>string - the repertoire/group-defining column (default to 'sample_id').</p>
</td></tr>
<tr><td><code id="VDJ_public_+3A_specific.groups">specific.groups</code></td>
<td>
<p>vector of strings or NULL - if only the shared elements from specific repertoires should be taken into account. If NULL, will output the shared/public elements across all repertoires.</p>
</td></tr>
<tr><td><code id="VDJ_public_+3A_find.public.all">find.public.all</code></td>
<td>
<p>boolean - if T, will look for the public elements across all repertoires</p>
</td></tr>
<tr><td><code id="VDJ_public_+3A_find.public.percentage">find.public.percentage</code></td>
<td>
<p>list - the first element denotes the percentage of repertoires to get shared elements for, the second element is the maximum number of repertoire combinations to consider (can be NULL to consider all).</p>
</td></tr>
<tr><td><code id="VDJ_public_+3A_treat.combined.features">treat.combined.features</code></td>
<td>
<p>string - 'exclude' will exclude combined features with one element missing, 'include' will include and considers them as a new feature value.</p>
</td></tr>
<tr><td><code id="VDJ_public_+3A_output.format">output.format</code></td>
<td>
<p>string - 'df' to get a shared element dataframe (with columns = Repertoire and Public), 'list' for a list of shared elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a dataframe of public elements across multiple repertoires or a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VDJ_get_public(VDJ = small_vgm[[1]],
feature.columns='VDJ_cdr3s_aa', find.public.all=TRUE,
output.format='df')

</code></pre>

<hr>
<h2 id='VDJ_rarefaction'>Plots rarefaction curves for species denoted in the feature.columns parameter across groups determined by grouping.columns</h2><span id='topic+VDJ_rarefaction'></span>

<h3>Description</h3>

<p>Plots rarefaction curves for species denoted in the feature.columns parameter across groups determined by grouping.columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_rarefaction(
  VDJ,
  feature.columns,
  grouping.column,
  VDJ.VJ.1chain,
  rarefaction.type,
  hill.numbers,
  number.resamples,
  sample.sizes,
  endpoint
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_rarefaction_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ dataframe output from the VDJ_GEX_matrix function.</p>
</td></tr>
<tr><td><code id="VDJ_rarefaction_+3A_feature.columns">feature.columns</code></td>
<td>
<p>Character vector. One or more column names from the VDJ to indicate the unique species for the rarefaction (to rarefy across). If more than one column is provided (e.g. c(&quot;VDJ_cdr3s_aa&quot;,&quot;VJ_cdr3s_aa&quot;)) these columns will be pasted together.</p>
</td></tr>
<tr><td><code id="VDJ_rarefaction_+3A_grouping.column">grouping.column</code></td>
<td>
<p>Character. Column name of a column to group the rarefaction by. This could be &quot;sample_id&quot; for rarefaction curves for each sample.</p>
</td></tr>
<tr><td><code id="VDJ_rarefaction_+3A_vdj.vj.1chain">VDJ.VJ.1chain</code></td>
<td>
<p>Boolean defaults to TRUE. Whether to filter out aberrant cells (more than 1 VDJ or VJ chain).</p>
</td></tr>
<tr><td><code id="VDJ_rarefaction_+3A_rarefaction.type">rarefaction.type</code></td>
<td>
<p>Character. Options for the iNEXT rarefaction - 'sample.size','coverage.based', or 'sample.completeness'.</p>
</td></tr>
<tr><td><code id="VDJ_rarefaction_+3A_hill.numbers">hill.numbers</code></td>
<td>
<p>Integer/ vector of integers. The Hill numbers to be plotted out (0 - species richness, 1 - Shannon diversity, 2 - Simpson  diversity)</p>
</td></tr>
<tr><td><code id="VDJ_rarefaction_+3A_number.resamples">number.resamples</code></td>
<td>
<p>Integer. Number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="VDJ_rarefaction_+3A_sample.sizes">sample.sizes</code></td>
<td>
<p>Vector if integers. The sample size points at which rarefaction should be performed. Defaults to NULL</p>
</td></tr>
<tr><td><code id="VDJ_rarefaction_+3A_endpoint">endpoint</code></td>
<td>
<p>Integer. The maximum sample size for rarefaction extrapolation. Defaults to NULL = 2 times the sample size for each sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot with the ordination analysis performer across features, groups, or both
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

try({
plot &lt;- VDJ_diversity(VDJ = Platypus::small_vgm[[1]],
,feature.columns = c("VDJ_cdr3s_aa"), grouping.column = "sample_id")
})

</code></pre>

<hr>
<h2 id='VDJ_variants_per_clone'>Wrapper for variant analysis by clone</h2><span id='topic+VDJ_variants_per_clone'></span>

<h3>Description</h3>

<p>Returns statistics and plots to examine diversity of any sequence or metadata item within clones on a by sample level or global level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_variants_per_clone(
  VDJ,
  variants.of,
  clonotypes.col,
  stringDist.method,
  split.by,
  platypus.version
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_variants_per_clone_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ output of the VDJ_GEX_matrix (VDJ_GEX_matrix.output[[1]]). VDJ matrix supplemented with with MIXCR information is also valid</p>
</td></tr>
<tr><td><code id="VDJ_variants_per_clone_+3A_variants.of">variants.of</code></td>
<td>
<p>Character vector. Defaults to c(&quot;VDJ_cdr3s_aa&quot;, &quot;VJ_cdr3s_aa&quot;). Column name(s) of VDJ to examine variants of. If more than one name is given, these columns will be pasted together. The default will therefore return statistics on the number of variants of VDJ and VJ cdr3s in every clone</p>
</td></tr>
<tr><td><code id="VDJ_variants_per_clone_+3A_clonotypes.col">clonotypes.col</code></td>
<td>
<p>Column name of the VDJ column containing clonotype information. Defaults to &quot;clonotype_id_10x&quot;. This is useful if alternative clonotyping strategies have been used and are stored in other columns</p>
</td></tr>
<tr><td><code id="VDJ_variants_per_clone_+3A_stringdist.method">stringDist.method</code></td>
<td>
<p>Character. Passed to Biostrings::strinDist. Method to calculate distance between variants of a clone. Defaults to &quot;levenshtein&quot;. Other options are &quot;hamming&quot;, &quot;quality&quot;. If &quot;hamming&quot; variants of a clone will be shortened from the end to the shortest variant to make all input sequences the same length.</p>
</td></tr>
<tr><td><code id="VDJ_variants_per_clone_+3A_split.by">split.by</code></td>
<td>
<p>Character. Defaults to &quot;sample_id&quot;. Column name of VDJ to split the analysis by. This is necessary, if clonotyping was done on a per sample level (e.g. &quot;clonotype1&quot; in sample 1 is not the same sequence as &quot;clonotype1&quot; in sample 2). If clonotyping was done across samples and no splitting is necessary input &quot;none&quot;</p>
</td></tr>
<tr><td><code id="VDJ_variants_per_clone_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Character. Only &quot;v3&quot; available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of dataframes. Each dataframe contains the statistics of one split.by element (by default: one sample)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>variants_per_clone &lt;- VDJ_variants_per_clone(VDJ = Platypus::small_vgm[[1]]
,variants.of = c("VDJ_cdr3s_aa", "VJ_cdr3s_aa"),
stringDist.method = "levenshtein", split.by = "sample_id")

</code></pre>

<hr>
<h2 id='VDJ_Vgene_usage'>V(D)J gene usage stacked barplots</h2><span id='topic+VDJ_Vgene_usage'></span>

<h3>Description</h3>

<p>Produces a matrix counting the number of occurences for each VDJ and VJ Vgene combinations for each list enty in VDJ.clonotype.output or for each sample_id in VDJ.matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_Vgene_usage(VDJ, group.by, platypus.version)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_Vgene_usage_+3A_vdj">VDJ</code></td>
<td>
<p>For platypus.version = &quot;v2&quot; output from VDJ_analyze function. This should be a list of clonotype dataframes, with each list element corresponding to a single VDJ repertoire. For platypus.version = &quot;v3&quot; output VDJ dataframe from VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[1]])</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_+3A_group.by">group.by</code></td>
<td>
<p>Character. Defaults to &quot;sample_id&quot;. Column name of VDJ to group plot by.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Character. Defaults to &quot;v3&quot;. Can be &quot;v2&quot; or &quot;v3&quot; dependent on the input format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of matrices containing the number of Vgene heavy/light chain combinations per repertoire.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example.vdj.vgene_usage &lt;- VDJ_Vgene_usage(VDJ =
Platypus::small_vgm[[1]], platypus.version = "v3")

</code></pre>

<hr>
<h2 id='VDJ_Vgene_usage_barplot'>V(D)J gene usage barplots</h2><span id='topic+VDJ_Vgene_usage_barplot'></span>

<h3>Description</h3>

<p>Produces a barplot with the most frequently used IgH and IgK/L Vgenes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_Vgene_usage_barplot(
  VDJ,
  group.by,
  HC.gene.number,
  LC.Vgene,
  LC.gene.number,
  platypus.version,
  is.bulk
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_Vgene_usage_barplot_+3A_vdj">VDJ</code></td>
<td>
<p>Either (for platypus version &quot;v2&quot;) output from VDJ_analyze function. This should be a list of clonotype dataframes, with each list element corresponding to a single VDJ repertoire, OR (for platypus version &quot;v3&quot;) the the VDJ matrix output of the VDJ_GEX_matrix() function (VDJ.GEX.matrix.output[[1]])</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_barplot_+3A_group.by">group.by</code></td>
<td>
<p>Character. Defaults to &quot;sample_id&quot;. Column name of VDJ to group plot by.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_barplot_+3A_hc.gene.number">HC.gene.number</code></td>
<td>
<p>Numeric value indicating the top genes to be dispayed. If this number is higher than the total number of unique HC V genes in the VDJ repertoire, then this number is equal to the number of unique HC V genes.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_barplot_+3A_lc.vgene">LC.Vgene</code></td>
<td>
<p>Logical indicating whether to make a barplot of the LC V genes distribution. Default is set to FALSE.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_barplot_+3A_lc.gene.number">LC.gene.number</code></td>
<td>
<p>Numeric value indicating the top genes to be dispayed. If this number is higher than the total number of unique LC V genes in the VDJ repertoire, then this number is equal to the number of unique LC V genes.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_barplot_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Character. Defaults to &quot;v3&quot;. Can be &quot;v2&quot; or &quot;v3&quot; dependent on the input format</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_barplot_+3A_is.bulk">is.bulk</code></td>
<td>
<p>logical value indicating whether the VDJ input was generated from bulk-sequencing data using the bulk_to_vgm function. If is.bulk = T, the VDJ_Vgene_usage_barplot function is compatible for use with bulk data. Defaults to False (F).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of ggplot objects which show the distribution of IgH and IgK/L V genes for the most used V genes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VDJ_Vgene_usage_barplot(VDJ = Platypus::small_vgm[[1]],
HC.gene.number = 2, platypus.version = "v3")

</code></pre>

<hr>
<h2 id='VDJ_Vgene_usage_stacked_barplot'>V(D)J gene usage stacked barplots</h2><span id='topic+VDJ_Vgene_usage_stacked_barplot'></span>

<h3>Description</h3>

<p>Produces a stacked barplot with the fraction of the most frequently used IgH and IgK/L Vgenes. This function can be used in combination with the VDJ_Vgene_usage_barplot to vizualize V gene usage per sample and among samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_Vgene_usage_stacked_barplot(
  VDJ,
  group.by,
  HC.gene.number,
  Fraction.HC,
  LC.Vgene,
  LC.gene.number,
  Fraction.LC,
  platypus.version,
  is.bulk
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_Vgene_usage_stacked_barplot_+3A_vdj">VDJ</code></td>
<td>
<p>Either (for platypus version &quot;v2&quot;) output from VDJ_analyze function. This should be a list of clonotype dataframes, with each list element corresponding to a single VDJ repertoire, OR (for platypus version &quot;v3&quot;) the the VDJ matrix output of the VDJ_GEX_matrix() function (normally VDJ.GEX.matrix.output[[1]])</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_stacked_barplot_+3A_group.by">group.by</code></td>
<td>
<p>Character. Defaults to &quot;sample_id&quot;. Column name of VDJ to group plot by.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_stacked_barplot_+3A_hc.gene.number">HC.gene.number</code></td>
<td>
<p>Numeric value indicating the top genes to be dispayed. If this number is higher than the total number of unique HC V genes in the VDJ repertoire, then this number is equal to the number of unique HC V genes.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_stacked_barplot_+3A_fraction.hc">Fraction.HC</code></td>
<td>
<p>Numeric value indicating the minimum fraction of clones expressing a particular HC V gene. If the usage of a particular gene is below this value, then this gene is excluded. If the usage of a particular gene is above this value even in one sample, then this gene is included in the analysis. Default value is set to 0, thus all genes are selected.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_stacked_barplot_+3A_lc.vgene">LC.Vgene</code></td>
<td>
<p>Logical indicating whether to make a barplot of the LC V gene distribution. Default is set to FALSE.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_stacked_barplot_+3A_lc.gene.number">LC.gene.number</code></td>
<td>
<p>Numeric value indicating the top genes to be dispayed. If this number is higher than the total number of unique LC V genes in the VDJ repertoire, then this number is equal to the number of unique LC V genes.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_stacked_barplot_+3A_fraction.lc">Fraction.LC</code></td>
<td>
<p>Numeric value indicating the minimum fraction of clones expressing a particular LC V gene. If the usage of a particular gene is below this value, then this gene is excluded. If the usage of a particular gene is above this value even in one sample, then this gene is included in the analysis. Default value is set to 0, thus all genes are selected.</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_stacked_barplot_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Set according to input format to either &quot;v2&quot; or &quot;v3&quot;. Defaults to &quot;v3&quot;</p>
</td></tr>
<tr><td><code id="VDJ_Vgene_usage_stacked_barplot_+3A_is.bulk">is.bulk</code></td>
<td>
<p>logical value indicating whether the VDJ input was generated from bulk-sequencing data using the bulk_to_vgm function. If is.bulk = T, the VDJ_Vgene_usage_stacked_barplot function is compatible for use with bulk data. Defaults to False (F).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of ggplot objects which show the stacked distribution of IgH and IgK/L V genes for the most used V genes. Returns an empty plot if the Fraction.HC or Fraction.LC that were selected were too high, resulting in the exclusion of all the genes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example.vdj.vgene_usage &lt;- VDJ_Vgene_usage_stacked_barplot(
VDJ = Platypus::small_vgm[[1]], LC.Vgene = TRUE
,HC.gene.number = 15, Fraction.HC = 1, platypus.version = "v3")

</code></pre>

<hr>
<h2 id='VDJ_VJ_usage_circos'>Makes a Circos plot from the VDJ_analyze output. Connects the V gene with the corresponding J gene for each clonotype.</h2><span id='topic+VDJ_VJ_usage_circos'></span>

<h3>Description</h3>

<p>Makes a Circos plot from the VDJ_analyze output. Connects the V gene with the corresponding J gene for each clonotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VDJ_VJ_usage_circos(
  VGM,
  VDJ.or.VJ,
  label.threshold,
  cell.level,
  c.threshold,
  clonotype.per.gene.threshold,
  c.count.label,
  c.count.label.size,
  platypus.version,
  filter1H1L,
  gene.label,
  gene.label.size,
  arr.col,
  arr.direction,
  topX,
  platy.theme,
  clonotype.column
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_vgm">VGM</code></td>
<td>
<p>The output of the VDJ_GEX_matrix function (VDJ_GEX_matrix.output[[1]]) has to be supplied. For Platypus v2: The output of the VDJ_GEX_integrate function (Platypus platypus.version v2). A list of data frames for each sample containing the clonotype information and cluster membership information.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_vdj.or.vj">VDJ.or.VJ</code></td>
<td>
<p>Determines whether to plot the V J gene pairing of the alpha or beta chain. &quot;VDJ&quot;, &quot;VJ&quot; or &quot;both&quot; as possible inputs. Default: &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_label.threshold">label.threshold</code></td>
<td>
<p>Genes are only labeled if the count is larger then the label.threshold. By default all label.threshold = 0 (all genes are labeled).</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_cell.level">cell.level</code></td>
<td>
<p>Logical, defines whether weight of connection should be based on number of clonotypes of number of cells. Default: number of clonotypes.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_c.threshold">c.threshold</code></td>
<td>
<p>Only clonotypes are considered with a frequency higher then c.threshold. Allows to filter for only highly expanded clonotypes.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_clonotype.per.gene.threshold">clonotype.per.gene.threshold</code></td>
<td>
<p>How many clonotypes are required to plot a sector for a gene. Filters the rows and colums of the final adjacency matrix.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_c.count.label">c.count.label</code></td>
<td>
<p>Boolean, lets the user decide if the gene and count labels should be plotted or not. Default = T.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_c.count.label.size">c.count.label.size</code></td>
<td>
<p>Determines the font size of the gene labels. By default the font size for count labels is 0.6.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_platypus.version">platypus.version</code></td>
<td>
<p>Which platypus.version of platypus is being used. Default = v3. Set to v3 if VDJ_GEX_matrix.output[[1]] is used</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_filter1h1l">filter1H1L</code></td>
<td>
<p>Whether to filter the input VGM in &quot;v3&quot; to only include cells with 1 VDJ and 1 VJ chain. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_gene.label">gene.label</code></td>
<td>
<p>Boolean, lets the user decide if the gene labels should be plotted or not.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_gene.label.size">gene.label.size</code></td>
<td>
<p>Determines the font size of the gene labels. By default the labelsize is automatically adjusted to 0.7 for labels with two or less digits, 0.6 for labels between 2 and 6 digits, and 0.4 for all longer labels. A manually defined font size will be the same for all labels!</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_arr.col">arr.col</code></td>
<td>
<p>Data.frame with three columns where the first two indicate the names of genes, clonotypes or clusters to be connected, and the third corresponds to the color of the arrow. Default set to data.frame(c(&quot;dummy.clonotype&quot;), c(&quot;dummy.cluster&quot;), c(&quot;dummy.color&quot;)), so no arrow is drawn.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_arr.direction">arr.direction</code></td>
<td>
<p>Either 1 or -1 and determines the direction of the arrow. Default=1.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_topx">topX</code></td>
<td>
<p>Filters for the top X clonotypes and only plots the respective gene combinations or cluster memberships.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_platy.theme">platy.theme</code></td>
<td>
<p>Allows plotting in the new &quot;pretty&quot; theme or the older &quot;spiky&quot; theme without group labels and radial arrangement of gene.labels. Default = &quot;pretty&quot;.</p>
</td></tr>
<tr><td><code id="VDJ_VJ_usage_circos_+3A_clonotype.column">clonotype.column</code></td>
<td>
<p>Which column in VGM contains the clonotyping information? Default=&quot;clonotype_id_10X&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a circos plot and a list object with the following elememts for N samples: [[1 to N]] The first N listelements corresponds to the recorded circos plots for N beeing the number or samples in the VGM. Since Circlize uses the R base plotting funciton, this is not a ggplot object but can still be replotted by calling the first list element. [[N+1]] Adjacency matrix forwarded to VDJ_circos(). This Matrix contains the counts and can be used for manual replotting using VDJ_circos directly. [[N+2]] Contains a named list with colors for each connection drawn and can be used for manual replotting using VDJ_circos directly. [[N+3]] Contains a named list with grouping information and can be used for manual replotting using VDJ_circos directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 usage_circos_VDJVJ &lt;- VDJ_VJ_usage_circos(Platypus::small_vgm[[1]])
 usage_circos_VDJVJ[[1]]


</code></pre>

<hr>
<h2 id='VGM_build'>Function to obtain the VGM object by integrating the VDJ and GEX/Seurat objects</h2><span id='topic+VGM_build'></span>

<h3>Description</h3>

<p>Takes as input a VDJ data frame (as obtained from the VDJ function in Platypus) and a Seurat object. Outputs an integrated VGM object (a list with the first element - the VDJ object; second element - the Seurat object).
Integration involves matching by barcodes and adding all features from one object to the other and vice-versa.
Authors: Tudor-Stefan Cotet, Victor Kreiner
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VGM_build(VDJ, GEX, merge.by, additional.dataframes, columns.to.transfer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VGM_build_+3A_vdj">VDJ</code></td>
<td>
<p>VDJ data frame, obtained from the Platypus VDJ() function</p>
</td></tr>
<tr><td><code id="VGM_build_+3A_gex">GEX</code></td>
<td>
<p>Seurat object for the single-cell immune receptor repertoire analysis.</p>
</td></tr>
<tr><td><code id="VGM_build_+3A_merge.by">merge.by</code></td>
<td>
<p>string - the column name to match both objects/dataframes by. Should be present in both objects (Seurat object meta.data and VDJ dataframe). Defaults to &quot;barcode.&quot;</p>
</td></tr>
<tr><td><code id="VGM_build_+3A_additional.dataframes">additional.dataframes</code></td>
<td>
<p>vector of data frames - additional dataframes to be matched/merged to the VDJ and GEX. Will be matched by the column denoted in the merge.by parameter (should be present in the VDJ and all subsequent dataframes).</p>
</td></tr>
<tr><td><code id="VGM_build_+3A_columns.to.transfer">columns.to.transfer</code></td>
<td>
<p>string or vector of strings - columns that should be transferred/appended across all objects (matched by the merge.by parameter). Defaults to &quot;all&quot; - all unique columns from GEX not present in VDJ and vice-versa.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output VGM object: a list with the first element - the VDJ object; second element - the GEX/Seurat object. Additonal elements are appended to the list if additional.dataframes is not null.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
try({
small_vgm &lt;- VGM_build(
VDJ = small_vgm[[1]],
GEX = small_vgm[[2]],
columns.to.transfer = 'all') #transfer all new columns
})

</code></pre>

<hr>
<h2 id='VGM_expand_featurebarcodes'>Utility for feature barcode assignment including clonal information</h2><span id='topic+VGM_expand_featurebarcodes'></span>

<h3>Description</h3>

<p>The VGM_expand_featurebarcodes function function can be used to trace back the cell origin of each sample after using cell hashing for single-cell sequencing. Replaces the original sample_id column of a vgm object with a pasted version of the original sample_id and the last digits of the feature barcode.
</p>
<p>The original sample_id is stored in a new column called original_sample_id. Additionally, a second new column is created containing final barcode assignment information.
Those barcodes match the origin FB_assignment if by.majority.barcodes is set to FALSE (default). However, if this input parameter is set to TRUE, the majority barcode assignment in stored in this colum.
</p>
<p>Note: The majority barcode of a cell is the feature barcode which is  most frequently assigned to the cells clonotype (10x default clonotype).
The majority barcode assignment can be used under the assumption that all cells which are assigned to the same clonotype (within one sample), originate from the same donor organ or at least the same donor depending on the experimental setup.
</p>
<p>For example: The original sample_id of a cell is &quot;s1&quot;, the cell belongs to &quot;clonotype1&quot; and the feature barcode assigned to it is &quot;i1-TotalSeq-C0953&quot;. If by.majority.barcodes default (FALSE) is used, the resulting new sample_id would be &quot;s1_0953&quot;.
However, if majority barcode assignment is used AND &quot;i1-TotalSeq-C0953&quot; is not the most frequently occurring barcode in &quot;clonotype1&quot; but rather barcode &quot;i1-TotalSeq-C0951&quot;, the new sample_id would be &quot;s1_0951&quot;.
&ndash;&gt; e.g., if 15 cells belong to clonotype1: 3 cells have no assigned barcode, 2 are assigned to &quot;i1-TotalSeq-C0953&quot; and 10 are assigned to &quot;i1-TotalSeq-C0951&quot; &ndash;&gt; all 15 cells will have the new sample_id &quot;s1_0951&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VGM_expand_featurebarcodes(
  vgm,
  by.majority.barcodes,
  integrate.in.gex,
  vdj.only,
  platypus.version
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VGM_expand_featurebarcodes_+3A_vgm">vgm</code></td>
<td>
<p>VGM output of VDJ_GEX_matrix function (Platypus V3)</p>
</td></tr>
<tr><td><code id="VGM_expand_featurebarcodes_+3A_by.majority.barcodes">by.majority.barcodes</code></td>
<td>
<p>Logical. Default is FALSE. Indicated whether strict barcode assignment or majority barcode assignment should be used to create the new sample_id. If TRUE, for each clonotype the most frequent feature barcode will be chosen and assigned to each cell, even if that cell itself does not have this particular barcode assigned.</p>
</td></tr>
<tr><td><code id="VGM_expand_featurebarcodes_+3A_integrate.in.gex">integrate.in.gex</code></td>
<td>
<p>Logical. Default is FALSE. If TRUE, the newly created sample_id's are integrated into gex component as well. Not recommended if no further gex analysis is done due to much longer computational time.</p>
</td></tr>
<tr><td><code id="VGM_expand_featurebarcodes_+3A_vdj.only">vdj.only</code></td>
<td>
<p>Logical. Defines if only vdj information is provided as input. Default is set to FALSE. If set to TRUE a vdj dataframe has to be provided as input (vgm = vdj). Also, integrate.in.gex is automatically set to FALSE since no gex (vgm[[2]]) information is provided.</p>
</td></tr>
<tr><td><code id="VGM_expand_featurebarcodes_+3A_platypus.version">platypus.version</code></td>
<td>
<p>This function works with &quot;v3&quot; only, there is no need to set this parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a vgm with new sample_id's in case vdj.only is set to FALSE (default). If vdj.only is set to true only the vdj dataframe with new sample_id's is returned.
Note: If vdj.only is set to default (FALSE), VDJ information in the metadata of the GEX object is necessary. For this set integrate.VDJ.to.GEX to TRUE in the VDJ_GEX_matrix function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vgm_expanded_fb &lt;- VGM_expand_featurebarcodes(
vgm = small_vgm[[1]],
by.majority.barcodes = FALSE,
integrate.in.gex=FALSE, vdj.only= TRUE)

vgm_expanded_fb &lt;- VGM_expand_featurebarcodes(
vgm = small_vgm,
by.majority.barcodes = FALSE,
integrate.in.gex=TRUE, vdj.only= FALSE)

vgm_expanded_fb &lt;- VGM_expand_featurebarcodes(vgm = small_vgm,
by.majority.barcodes = TRUE,
integrate.in.gex=TRUE, vdj.only= FALSE)

</code></pre>

<hr>
<h2 id='VGM_expanded_clones'>VDJ utility for T/F column for clonal expansion</h2><span id='topic+VGM_expanded_clones'></span>

<h3>Description</h3>

<p>Adds discrete columns containing TRUE / FALSE on whether a given cell is part of a expanded or not-expanded clonotype. Threshold frequency can be set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VGM_expanded_clones(VGM, add.to.VDJ, add.to.GEX, expansion.threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VGM_expanded_clones_+3A_vgm">VGM</code></td>
<td>
<p>Output object from the VDJ_GEX_matrix function (VDJ_GEX_matrix.output)</p>
</td></tr>
<tr><td><code id="VGM_expanded_clones_+3A_add.to.vdj">add.to.VDJ</code></td>
<td>
<p>Boolean. Whether to add expanded columns to VDJ matrix. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="VGM_expanded_clones_+3A_add.to.gex">add.to.GEX</code></td>
<td>
<p>Boolean. Whether to add expanded columns to GEX matrix. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="VGM_expanded_clones_+3A_expansion.threshold">expansion.threshold</code></td>
<td>
<p>Integer. Defaults to 1. Cells in clonotypes above this threshold will be marked as expanded = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output object from the VDJ_GEX_matrix function with added columns containing TRUE / FALSE values based on clonotype frequency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
VGM &lt;- VGM_expanded_clones(
VGM = Platypus::small_vgm, add.to.VDJ = TRUE, add.to.GEX = TRUE,
expansion.threshold = 1)

</code></pre>

<hr>
<h2 id='VGM_integrate'>Utility for VDJ GEX matrix to integrated VDJ and GEX objects after addition of data to either</h2><span id='topic+VGM_integrate'></span>

<h3>Description</h3>

<p>(Re)-intergrated VDJ and GEX of one or two separate VGM objects. This can be used as a simple &quot;updating&quot; utility function, if metadata has been added to the VDJ dataframe and is also needed in the GEX matrix or the reverse. Entries are integrated by barcode. If barcodes have been altered (barcode column in VDJ and cell names in GEX), the function will not yield results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VGM_integrate(VGM, columns.to.transfer, genes.to.VDJ, seurat.slot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VGM_integrate_+3A_vgm">VGM</code></td>
<td>
<p>Output object from the VDJ_GEX_matrix function (VDJ_GEX_matrix.output)</p>
</td></tr>
<tr><td><code id="VGM_integrate_+3A_columns.to.transfer">columns.to.transfer</code></td>
<td>
<p>Optional. Character Vector. Column names of either the VDJ matrix or GEX meta.data that should be transferred to the corresponding other matrix. if not provided all columns missing from one will be integrated into the other matrix</p>
</td></tr>
<tr><td><code id="VGM_integrate_+3A_genes.to.vdj">genes.to.VDJ</code></td>
<td>
<p>Character vector of gene names in GEX. In many cases it is useful to extract expression values for a gene to metadata. This is done via SeuratObject::FetchData(vars  = genes,slot = seurat.slot) function. The VGM integrate takes gene ids, extracts these and adds them to the VDJ dataframe. If provided, no other columns are integrated between VDJ and GEX and columns.to.transfer is ignored.</p>
</td></tr>
<tr><td><code id="VGM_integrate_+3A_seurat.slot">seurat.slot</code></td>
<td>
<p>GEX object data slot to pull from. Can be 'counts', 'data', or 'scale.data'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An output object from the VDJ_GEX_matrix function with added columns in VDJ or GEX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
small_vgm[[1]] &lt;- VDJ_clonotype(VDJ=Platypus::small_vgm[[1]],
clone.strategy="cdr3.nt",
hierarchical = "single.chains", global.clonotype = TRUE)

small_vgm &lt;- VGM_integrate(
VGM = small_vgm,
columns.to.transfer = NULL) #transfer all new columns

small_vgm &lt;- VGM_integrate(
VGM = small_vgm,
columns.to.transfer = c("global_clonotype_id_cdr3.nt"))

small_vgm &lt;- VGM_integrate(
small_vgm, genes.to.VDJ = c("CD19","CD24A"),seurat.slot = "counts")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
