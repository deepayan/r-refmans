<!DOCTYPE html><html><head><title>Help for package spatgraphs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatgraphs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adj2sg'><p>sgadj to sg</p></a></li>
<li><a href='#as.sg'><p>Class creator</p></a></li>
<li><a href='#as.sgadj'><p>Creator for sgadj-class</p></a></li>
<li><a href='#as.sgc'><p>Creator for sgc</p></a></li>
<li><a href='#cut.sg'><p>cut edges</p></a></li>
<li><a href='#edgeLengths'><p>Edge lengths</p></a></li>
<li><a href='#is_sg'><p>verify class sg</p></a></li>
<li><a href='#plot.sg'><p>Plot a spatial graph</p></a></li>
<li><a href='#plot.sgadj'><p>plot sgadj</p></a></li>
<li><a href='#plot.sgc'><p>plot clusters</p></a></li>
<li><a href='#plot.sgspectral'><p>plot spectral clustering results</p></a></li>
<li><a href='#plot3_sg'><p>Plot 3d graph</p></a></li>
<li><a href='#print.sg'><p>Print method for sg</p></a></li>
<li><a href='#print.sgadj'><p>print method for sgadj</p></a></li>
<li><a href='#print.sgc'><p>sgc print method</p></a></li>
<li><a href='#prune_sg'><p>Prune a graph</p></a></li>
<li><a href='#remove_nodes'><p>Remove edges connected to certain nodes</p></a></li>
<li><a href='#sg_parse_coordinates'><p>Parse input for coordinates</p></a></li>
<li><a href='#sg_verify_parameters'><p>Verify input parameters for the graph</p></a></li>
<li><a href='#sg2adj'><p>sg to sgadj</p></a></li>
<li><a href='#sg2dxf'><p>sg to dxf format</p></a></li>
<li><a href='#sg2igraph'><p>sg to igraph</p></a></li>
<li><a href='#sg2sparse'><p>Make a sparse adjacency matrix from sg-object</p></a></li>
<li><a href='#sg2sym'><p>Symmetrisation of sg adjacency matrix</p>
wrapper for 1way and 2way symmetrisation</a></li>
<li><a href='#sg2wadj'><p>weighted sg to weighted adjacency matrix</p></a></li>
<li><a href='#shortestPath'><p>shortest path on the graph</p></a></li>
<li><a href='#sparse2sg'><p>Make an sg-object from adjacency matrix</p></a></li>
<li><a href='#spatcluster'><p>Compute the connected components of a graph</p></a></li>
<li><a href='#spatgraph'><p>Compute the edges of a spatial graph</p></a></li>
<li><a href='#spectral_sg'><p>spectral clustering</p></a></li>
<li><a href='#summary.sg'><p>sg summary</p></a></li>
<li><a href='#summary.sgc'><p>sgc summary</p></a></li>
<li><a href='#t.sg'><p>Transpose sg object</p></a></li>
<li><a href='#t.sgadj'><p>Transpose sgadj object</p></a></li>
<li><a href='#weight_sg'><p>Set weights to edges of sg</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graph Edge Computations for Spatial Point Patterns</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Tuomas Rajala</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tuomas Rajala &lt;tuomas.rajala@iki.fi&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Graphs (or networks) and graph component
        calculations for spatial locations in 1D, 2D, 3D etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.6), Matrix, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rgl</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-10 11:25:29 UTC; 03130236</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-10 12:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='adj2sg'>sgadj to sg</h2><span id='topic+adj2sg'></span>

<h3>Description</h3>

<p>sgadj to sg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adj2sg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adj2sg_+3A_x">x</code></td>
<td>
<p>sgadj object</p>
</td></tr>
</table>

<hr>
<h2 id='as.sg'>Class creator</h2><span id='topic+as.sg'></span>

<h3>Description</h3>

<p>Class creator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sg(edges = list(), type = "?", pars = NULL, note = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sg_+3A_edges">edges</code></td>
<td>
<p>list of neighbourhoods</p>
</td></tr>
<tr><td><code id="as.sg_+3A_type">type</code></td>
<td>
<p>type</p>
</td></tr>
<tr><td><code id="as.sg_+3A_pars">pars</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="as.sg_+3A_note">note</code></td>
<td>
<p>notes</p>
</td></tr>
</table>

<hr>
<h2 id='as.sgadj'>Creator for sgadj-class</h2><span id='topic+as.sgadj'></span>

<h3>Description</h3>

<p>Creator for sgadj-class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sgadj(edges = NULL, type = "?", pars = NULL, other = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sgadj_+3A_edges">edges</code></td>
<td>
<p>edge list-of-lists</p>
</td></tr>
<tr><td><code id="as.sgadj_+3A_type">type</code></td>
<td>
<p>of the graph</p>
</td></tr>
<tr><td><code id="as.sgadj_+3A_pars">pars</code></td>
<td>
<p>parameters for the graph</p>
</td></tr>
<tr><td><code id="as.sgadj_+3A_other">other</code></td>
<td>
<p>other comments</p>
</td></tr>
</table>

<hr>
<h2 id='as.sgc'>Creator for sgc</h2><span id='topic+as.sgc'></span>

<h3>Description</h3>

<p>Creator for sgc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.sgc(clusters, type = "?", pars = NULL, note = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.sgc_+3A_clusters">clusters</code></td>
<td>
<p>list of clusters as point indices</p>
</td></tr>
<tr><td><code id="as.sgc_+3A_type">type</code></td>
<td>
<p>type</p>
</td></tr>
<tr><td><code id="as.sgc_+3A_pars">pars</code></td>
<td>
<p>parameters</p>
</td></tr>
<tr><td><code id="as.sgc_+3A_note">note</code></td>
<td>
<p>notes</p>
</td></tr>
</table>

<hr>
<h2 id='cut.sg'>cut edges</h2><span id='topic+cut.sg'></span>

<h3>Description</h3>

<p>cut edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sg'
cut(x, data, R, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut.sg_+3A_x">x</code></td>
<td>
<p>sg graph object</p>
</td></tr>
<tr><td><code id="cut.sg_+3A_data">data</code></td>
<td>
<p>point pattern used for computing g</p>
</td></tr>
<tr><td><code id="cut.sg_+3A_r">R</code></td>
<td>
<p>cutting length</p>
</td></tr>
<tr><td><code id="cut.sg_+3A_...">...</code></td>
<td>
<p>ignored
</p>
<p>Removes edges with length &gt; R.</p>
</td></tr>
</table>

<hr>
<h2 id='edgeLengths'>Edge lengths</h2><span id='topic+edgeLengths'></span>

<h3>Description</h3>

<p>Edge lengths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgeLengths(g, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgeLengths_+3A_g">g</code></td>
<td>
<p>sg-object</p>
</td></tr>
<tr><td><code id="edgeLengths_+3A_x">x</code></td>
<td>
<p>point pattern</p>
</td></tr>
<tr><td><code id="edgeLengths_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='is_sg'>verify class sg</h2><span id='topic+is_sg'></span>

<h3>Description</h3>

<p>verify class sg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_sg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_sg_+3A_x">x</code></td>
<td>
<p>object to check</p>
</td></tr>
</table>

<hr>
<h2 id='plot.sg'>Plot a spatial graph</h2><span id='topic+plot.sg'></span>

<h3>Description</h3>

<p>Rudimentary plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sg'
plot(
  x,
  data,
  which = NULL,
  add = FALSE,
  addPoints = FALSE,
  points.pch = 1,
  points.col = 1,
  points.cex = 1,
  max.edges = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sg_+3A_x">x</code></td>
<td>
<p>an 'sg' graph object</p>
</td></tr>
<tr><td><code id="plot.sg_+3A_data">data</code></td>
<td>
<p>The point pattern object, same as for computing the 'g'</p>
</td></tr>
<tr><td><code id="plot.sg_+3A_which">which</code></td>
<td>
<p>Indices of which out-edges to plot. Default: all</p>
</td></tr>
<tr><td><code id="plot.sg_+3A_add">add</code></td>
<td>
<p>Add to existing plot? (default: FALSE)</p>
</td></tr>
<tr><td><code id="plot.sg_+3A_addpoints">addPoints</code></td>
<td>
<p>Add points? Will be added if add=FALSE</p>
</td></tr>
<tr><td><code id="plot.sg_+3A_points.pch">points.pch</code></td>
<td>
<p>point styling</p>
</td></tr>
<tr><td><code id="plot.sg_+3A_points.col">points.col</code></td>
<td>
<p>point styling</p>
</td></tr>
<tr><td><code id="plot.sg_+3A_points.cex">points.cex</code></td>
<td>
<p>point styling</p>
</td></tr>
<tr><td><code id="plot.sg_+3A_max.edges">max.edges</code></td>
<td>
<p>limit of edges to try to plot, gets very slow at high count. default 1e4</p>
</td></tr>
<tr><td><code id="plot.sg_+3A_...">...</code></td>
<td>
<p>passed to 'lines' function</p>
</td></tr>
</table>

<hr>
<h2 id='plot.sgadj'>plot sgadj</h2><span id='topic+plot.sgadj'></span>

<h3>Description</h3>

<p>plot sgadj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgadj'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sgadj_+3A_x">x</code></td>
<td>
<p>sgadj object</p>
</td></tr>
<tr><td><code id="plot.sgadj_+3A_...">...</code></td>
<td>
<p>passed to plot.sg
</p>
<p>converts to sg and plots that.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.sgc'>plot clusters</h2><span id='topic+plot.sgc'></span>

<h3>Description</h3>

<p>plot clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgc'
plot(x, data, atleast = 2, add = FALSE, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sgc_+3A_x">x</code></td>
<td>
<p>spatcluster-cluster object</p>
</td></tr>
<tr><td><code id="plot.sgc_+3A_data">data</code></td>
<td>
<p>point pattern object used for computing the graph</p>
</td></tr>
<tr><td><code id="plot.sgc_+3A_atleast">atleast</code></td>
<td>
<p>plot only cluster with 'atleast' points in them</p>
</td></tr>
<tr><td><code id="plot.sgc_+3A_add">add</code></td>
<td>
<p>add or plot new</p>
</td></tr>
<tr><td><code id="plot.sgc_+3A_col">col</code></td>
<td>
<p>colors for clusters, chosen randomly if missing.</p>
</td></tr>
<tr><td><code id="plot.sgc_+3A_...">...</code></td>
<td>
<p>passed to points</p>
</td></tr>
</table>

<hr>
<h2 id='plot.sgspectral'>plot spectral clustering results</h2><span id='topic+plot.sgspectral'></span>

<h3>Description</h3>

<p>plot spectral clustering results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgspectral'
plot(x, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sgspectral_+3A_x">x</code></td>
<td>
<p>spectral_sg result</p>
</td></tr>
<tr><td><code id="plot.sgspectral_+3A_data">data</code></td>
<td>
<p>point pattern</p>
</td></tr>
<tr><td><code id="plot.sgspectral_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='plot3_sg'>Plot 3d graph</h2><span id='topic+plot3_sg'></span>

<h3>Description</h3>

<p>Plot 3d graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3_sg(x, data, which, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3_sg_+3A_x">x</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="plot3_sg_+3A_data">data</code></td>
<td>
<p>coordinates</p>
</td></tr>
<tr><td><code id="plot3_sg_+3A_which">which</code></td>
<td>
<p>points of which out-edges will be plotted</p>
</td></tr>
<tr><td><code id="plot3_sg_+3A_...">...</code></td>
<td>
<p>passed to segments3d</p>
</td></tr>
</table>

<hr>
<h2 id='print.sg'>Print method for sg</h2><span id='topic+print.sg'></span>

<h3>Description</h3>

<p>Print sg class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sg'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sg_+3A_x">x</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="print.sg_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print basic info.
</p>

<hr>
<h2 id='print.sgadj'>print method for sgadj</h2><span id='topic+print.sgadj'></span>

<h3>Description</h3>

<p>print method for sgadj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgadj'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sgadj_+3A_x">x</code></td>
<td>
<p>sgadj object</p>
</td></tr>
<tr><td><code id="print.sgadj_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.sgc'>sgc print method</h2><span id='topic+print.sgc'></span>

<h3>Description</h3>

<p>sgc print method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sgc_+3A_x">x</code></td>
<td>
<p>sgc object</p>
</td></tr>
<tr><td><code id="print.sgc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='prune_sg'>Prune a graph</h2><span id='topic+prune_sg'></span>

<h3>Description</h3>

<p>Prune a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune_sg(g, level = 1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_sg_+3A_g">g</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="prune_sg_+3A_level">level</code></td>
<td>
<p>pruning level</p>
</td></tr>
<tr><td><code id="prune_sg_+3A_verbose">verbose</code></td>
<td>
<p>verbosity</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remove edges from a graph by their path connectivity.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(50*2), ncol=2)
g &lt;- spatgraph(x, "MST")
gp &lt;- prune_sg(g, level = 2)
plot(g, x, lty=2)
plot(gp, x, add=TRUE, col=2)

</code></pre>

<hr>
<h2 id='remove_nodes'>Remove edges connected to certain nodes</h2><span id='topic+remove_nodes'></span>

<h3>Description</h3>

<p>Remove the existence of particular nodes from the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_nodes(g, i, fuse = FALSE, verb = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_nodes_+3A_g">g</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="remove_nodes_+3A_i">i</code></td>
<td>
<p>indices of nodes for which to remove the edges</p>
</td></tr>
<tr><td><code id="remove_nodes_+3A_fuse">fuse</code></td>
<td>
<p>Should the neighours of removed nodes be connected?</p>
</td></tr>
<tr><td><code id="remove_nodes_+3A_verb">verb</code></td>
<td>
<p>verbose?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically, just clear the neighbourhood of selected indices. If fuse=TRUE,
connect neighbours together (excluding i's). Should work over several remove nodes
along a path.
</p>
<p>Note: g should be symmetric. use sg2sym to force symmetry, it is not checked.
</p>
<p>Warning: In development.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(200), ncol=2)
g &lt;- spatgraph(x, "RST", c(1,0))
g &lt;- sg2sym(g)
i &lt;- sample(100, 50)
k &lt;- setdiff(1:100, i)
gs &lt;- remove_nodes(g, i, fuse=TRUE)
plot(g,x, add=FALSE)
points(x[k,], pch=19, col=4)
plot(gs, x, add=TRUE, lty=2, col=3)

</code></pre>

<hr>
<h2 id='sg_parse_coordinates'>Parse input for coordinates</h2><span id='topic+sg_parse_coordinates'></span>

<h3>Description</h3>

<p>Extract the coordinate locations from the input object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_parse_coordinates(x, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_parse_coordinates_+3A_x">x</code></td>
<td>
<p>Input object containing the coordinates in some format.</p>
</td></tr>
<tr><td><code id="sg_parse_coordinates_+3A_verbose">verbose</code></td>
<td>
<p>Print out info of the coordinates.</p>
</td></tr>
</table>

<hr>
<h2 id='sg_verify_parameters'>Verify input parameters for the graph</h2><span id='topic+sg_verify_parameters'></span>

<h3>Description</h3>

<p>Mainly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg_verify_parameters(coord, type, par, maxR, doDists, preGraph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg_verify_parameters_+3A_coord">coord</code></td>
<td>
<p>Coordinates of the locations</p>
</td></tr>
<tr><td><code id="sg_verify_parameters_+3A_type">type</code></td>
<td>
<p>Type of graph</p>
</td></tr>
<tr><td><code id="sg_verify_parameters_+3A_par">par</code></td>
<td>
<p>Parameter(s) for the graph</p>
</td></tr>
<tr><td><code id="sg_verify_parameters_+3A_maxr">maxR</code></td>
<td>
<p>Maximum range for edges, helps in large patterns.</p>
</td></tr>
<tr><td><code id="sg_verify_parameters_+3A_dodists">doDists</code></td>
<td>
<p>Precompute distances? Speeds up some graphs, takes up memory.</p>
</td></tr>
<tr><td><code id="sg_verify_parameters_+3A_pregraph">preGraph</code></td>
<td>
<p>Precomputed graph, taken as a super-graph</p>
</td></tr>
</table>

<hr>
<h2 id='sg2adj'>sg to sgadj</h2><span id='topic+sg2adj'></span>

<h3>Description</h3>

<p>sg to sgadj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg2adj(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg2adj_+3A_x">x</code></td>
<td>
<p>sg object</p>
</td></tr>
</table>

<hr>
<h2 id='sg2dxf'>sg to dxf format</h2><span id='topic+sg2dxf'></span>

<h3>Description</h3>

<p>sg to dxf format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg2dxf(g, x, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg2dxf_+3A_g">g</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="sg2dxf_+3A_x">x</code></td>
<td>
<p>pattern object used for computing g</p>
</td></tr>
<tr><td><code id="sg2dxf_+3A_file">file</code></td>
<td>
<p>filename for output</p>
</td></tr>
</table>

<hr>
<h2 id='sg2igraph'>sg to igraph</h2><span id='topic+sg2igraph'></span>

<h3>Description</h3>

<p>Obsolete. Use igraph::graph_from_adj_list on the graph edges element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg2igraph(g, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg2igraph_+3A_g">g</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="sg2igraph_+3A_x">x</code></td>
<td>
<p>possibly the location pattern</p>
</td></tr>
<tr><td><code id="sg2igraph_+3A_...">...</code></td>
<td>
<p>not used
</p>
<p>Not implemented. You can use the 'graph_from_adj_list'-function in 'igraph'-package on the edges-element of the graph.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ix &lt;- igraph::graph_from_adj_list(x$edges)

## End(Not run)

</code></pre>

<hr>
<h2 id='sg2sparse'>Make a sparse adjacency matrix from sg-object</h2><span id='topic+sg2sparse'></span>

<h3>Description</h3>

<p>Make a sparse adjacency matrix from sg-object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg2sparse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg2sparse_+3A_x">x</code></td>
<td>
<p>sg-object</p>
</td></tr>
</table>

<hr>
<h2 id='sg2sym'>Symmetrisation of sg adjacency matrix
wrapper for 1way and 2way symmetrisation</h2><span id='topic+sg2sym'></span>

<h3>Description</h3>

<p>Symmetrisation of sg adjacency matrix
wrapper for 1way and 2way symmetrisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg2sym(x, way = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg2sym_+3A_x">x</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="sg2sym_+3A_way">way</code></td>
<td>
<p>1: OR rule, 2: AND rule for keeping edges.</p>
</td></tr>
</table>

<hr>
<h2 id='sg2wadj'>weighted sg to weighted adjacency matrix</h2><span id='topic+sg2wadj'></span>

<h3>Description</h3>

<p>weighted sg to weighted adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sg2wadj(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sg2wadj_+3A_x">x</code></td>
<td>
<p>weighted sg object</p>
</td></tr>
</table>

<hr>
<h2 id='shortestPath'>shortest path on the graph</h2><span id='topic+shortestPath'></span>

<h3>Description</h3>

<p>Djikstra's algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortestPath(i, j, g, x = NULL, dbg = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortestPath_+3A_i">i</code></td>
<td>
<p>index from</p>
</td></tr>
<tr><td><code id="shortestPath_+3A_j">j</code></td>
<td>
<p>index to</p>
</td></tr>
<tr><td><code id="shortestPath_+3A_g">g</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="shortestPath_+3A_x">x</code></td>
<td>
<p>optional point pattern from which g was computed</p>
</td></tr>
<tr><td><code id="shortestPath_+3A_dbg">dbg</code></td>
<td>
<p>verbose</p>
</td></tr>
</table>

<hr>
<h2 id='sparse2sg'>Make an sg-object from adjacency matrix</h2><span id='topic+sparse2sg'></span>

<h3>Description</h3>

<p>Make an sg-object from adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparse2sg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparse2sg_+3A_x">x</code></td>
<td>
<p>square matrix. non-0 elements are taken as edge presence.</p>
</td></tr>
</table>

<hr>
<h2 id='spatcluster'>Compute the connected components of a graph</h2><span id='topic+spatcluster'></span>

<h3>Description</h3>

<p>Compute the connected components of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatcluster(x, verbose = TRUE, sym = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatcluster_+3A_x">x</code></td>
<td>
<p>sg-object</p>
</td></tr>
<tr><td><code id="spatcluster_+3A_verbose">verbose</code></td>
<td>
<p>print info</p>
</td></tr>
<tr><td><code id="spatcluster_+3A_sym">sym</code></td>
<td>
<p>force symmetry of edges</p>
</td></tr>
</table>

<hr>
<h2 id='spatgraph'>Compute the edges of a spatial graph</h2><span id='topic+spatgraph'></span>

<h3>Description</h3>

<p>Given a spatial point pattern, we compute the edges of a graph (network) for a specified type of edge relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatgraph(
  x,
  type = "geometric",
  par = NULL,
  verbose = FALSE,
  maxR = 0,
  doDists = FALSE,
  preGraph = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatgraph_+3A_x">x</code></td>
<td>
<p>Input point pattern object</p>
</td></tr>
<tr><td><code id="spatgraph_+3A_type">type</code></td>
<td>
<p>Type of the graph</p>
</td></tr>
<tr><td><code id="spatgraph_+3A_par">par</code></td>
<td>
<p>Parameter(s) for the graph</p>
</td></tr>
<tr><td><code id="spatgraph_+3A_verbose">verbose</code></td>
<td>
<p>Print details</p>
</td></tr>
<tr><td><code id="spatgraph_+3A_maxr">maxR</code></td>
<td>
<p>Maximum range for edges, helps in large patterns.</p>
</td></tr>
<tr><td><code id="spatgraph_+3A_dodists">doDists</code></td>
<td>
<p>Precompute distances? Speeds up some graphs, takes up memory.</p>
</td></tr>
<tr><td><code id="spatgraph_+3A_pregraph">preGraph</code></td>
<td>
<p>Precomputed graph, taken as a super-graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several edge definitions are supported:
</p>

<dl>
<dt>geometric</dt><dd><p>par=numeric&gt;0. Geometric graph, par = connection radius.</p>
</dd>
<dt>knn</dt><dd><p>par=integer&gt;0. k-nearest neighbours graph, par = k.</p>
</dd>
<dt>mass_geometric</dt><dd><p>Connect two points if ||x-y||&lt;m(x). par=vector giving the m(x_i)'s</p>
</dd>
<dt>markcross</dt><dd><p>Connect two points if ||x-y||&lt;m(x)+m(y). par = vector giving the m(x_i)'s</p>
</dd>
<dt>gabriel</dt><dd><p>Gabriel graph. Additional parameter for allowing <code>par=k</code> instead of 0 points in the circle.</p>
</dd>
<dt>MST</dt><dd><p>Minimal spanning tree.</p>
</dd>
<dt>SIG</dt><dd><p>Spheres of Influence.</p>
</dd>
<dt>RST</dt><dd><p>Radial spanning tree, par=origin of radiation, coordinate vector</p>
</dd>
<dt>RNG</dt><dd><p>Relative neighbourhood graph</p>
</dd>
<dt>CCC</dt><dd><p>Class-Cover-Catch, par=factor vector of point types. The factor vector is converted to integers according to R's internal representation of factors, and the points with type 1 will be the target. Use <a href="stats.html#topic+relevel">relevel</a> to change the target.</p>
</dd>
</dl>

<p>The parameter 'maxR' can be given to bring n^3 graphs closer to n^2. k-nearest neighbours will warn if
maxR is too small (&lt;k neighbours for some points), others, like RNG, don't so be careful.
</p>
<p>Voronoi diagram aka Delaunay triangulation is not supported as other R-packages can do it,
see. e.g. package 'deldir'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# basic example
x &lt;- matrix(runif(50*2), ncol=2)
g &lt;- spatgraph(x, "knn", par=3)
plot(g, x)

# bigger example
xb &lt;- matrix(runif(5000*2), ncol=2)
gb &lt;- spatgraph(xb, "RNG", maxR=0.1)

</code></pre>

<hr>
<h2 id='spectral_sg'>spectral clustering</h2><span id='topic+spectral_sg'></span>

<h3>Description</h3>

<p>spectral clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral_sg(g, m = 2, K = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectral_sg_+3A_g">g</code></td>
<td>
<p>sg object. Should be weighted (with weight_sg-function)</p>
</td></tr>
<tr><td><code id="spectral_sg_+3A_m">m</code></td>
<td>
<p>levels to consider</p>
</td></tr>
<tr><td><code id="spectral_sg_+3A_k">K</code></td>
<td>
<p>number of assumed clusters</p>
</td></tr>
</table>

<hr>
<h2 id='summary.sg'>sg summary</h2><span id='topic+summary.sg'></span>

<h3>Description</h3>

<p>sg summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sg'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sg_+3A_object">object</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="summary.sg_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='summary.sgc'>sgc summary</h2><span id='topic+summary.sgc'></span>

<h3>Description</h3>

<p>sgc summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sgc_+3A_object">object</code></td>
<td>
<p>sgc object</p>
</td></tr>
<tr><td><code id="summary.sgc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='t.sg'>Transpose sg object</h2><span id='topic+t.sg'></span>

<h3>Description</h3>

<p>This will transpose the adjacency matrix underlying the graph. Will transform
to and from sgadj-object (see 'sg2adj')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sg'
t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t.sg_+3A_x">x</code></td>
<td>
<p>sg-object.</p>
</td></tr>
</table>

<hr>
<h2 id='t.sgadj'>Transpose sgadj object</h2><span id='topic+t.sgadj'></span>

<h3>Description</h3>

<p>This will transpose the adjacency matrix underlying the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgadj'
t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t.sgadj_+3A_x">x</code></td>
<td>
<p>sgadj object</p>
</td></tr>
</table>

<hr>
<h2 id='weight_sg'>Set weights to edges of sg</h2><span id='topic+weight_sg'></span>

<h3>Description</h3>

<p>For each edge e(i,j) between points i,j, set the weight f(||x_i-x_j||)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_sg(g, x, f = function(x) exp(-x^2/scale), scale = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_sg_+3A_g">g</code></td>
<td>
<p>sg object</p>
</td></tr>
<tr><td><code id="weight_sg_+3A_x">x</code></td>
<td>
<p>point pattern used in g</p>
</td></tr>
<tr><td><code id="weight_sg_+3A_f">f</code></td>
<td>
<p>function for the weight</p>
</td></tr>
<tr><td><code id="weight_sg_+3A_scale">scale</code></td>
<td>
<p>additional scale parameter for the default f</p>
</td></tr>
<tr><td><code id="weight_sg_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default f(x) = exp(-x^2/scale)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
