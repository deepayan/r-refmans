<!DOCTYPE html><html><head><title>Help for package NetFACS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NetFACS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_inactive_single_units'><p>Add inactive (missing) single units</p></a></li>
<li><a href='#calculate_combination_size'><p>Calculate combination size</p></a></li>
<li><a href='#conditional_probabilities'><p>Summarise dyadic combination of elements</p></a></li>
<li><a href='#define_contexts'><p>Define truth for AUs active in different contexts</p></a></li>
<li><a href='#define_joint_prob'><p>Joint probability distribution of AUs</p></a></li>
<li><a href='#distribution.plot'><p>Plots the observed probability for an element against the distribution of the null model</p></a></li>
<li><a href='#element.plot'><p>Plots the observed and expected probabilities for the basic elements based on the condition</p></a></li>
<li><a href='#element.specificity'><p>(Defunct) Tests how much each element increases the specificity of all</p>
combinations it is in</a></li>
<li><a href='#emotions_set'><p>Letter Data</p></a></li>
<li><a href='#entropy_overall'><p>Calculate information content of the dataset</p></a></li>
<li><a href='#entropy.overall'><p>(Deprecated) Calculate information content of the dataset</p></a></li>
<li><a href='#equal_observations'><p>Check that ALL objects have the same number of observations</p></a></li>
<li><a href='#event_size_plot'><p>Plots the probability that a combination of a certain size appears</p></a></li>
<li><a href='#get_active_elements'><p>Extract active elements from matrix</p></a></li>
<li><a href='#get_data'><p>Extract used data from a <code>netfacs</code> object</p></a></li>
<li><a href='#is.netfacs'><p>Checks if argument is a <code>netfacs</code> object</p></a></li>
<li><a href='#is.netfacs_multiple'><p>Checks if argument is a <code>netfacs_multiple</code> object</p></a></li>
<li><a href='#is.netfacs_specificity'><p>Checks if argument is a <code>netfacs_specificity</code> object</p></a></li>
<li><a href='#letternet'><p>Letter Data</p></a></li>
<li><a href='#multiple_netfacs_network'><p>Creates network objects out of the netfacs data</p></a></li>
<li><a href='#multiple_network_plot'><p>Plots networks for multiple conditions</p></a></li>
<li><a href='#multiple.netfacs'><p>(Deprecated) Applies the <code>netfacs</code> function across multiple</p>
levels of the condition and puts them in a list</a></li>
<li><a href='#mutual.information'><p>Calculates the pointwise mutual information of units with each other</p></a></li>
<li><a href='#mutual.information.condition'><p>Tests how much each element increases the specificity of all combinations it</p>
is in</a></li>
<li><a href='#netfacs'><p>Create probability distribution of combinations of elements in the data</p></a></li>
<li><a href='#netfacs_bootstrap'><p>Calculate expected probability from single bootstrap</p></a></li>
<li><a href='#netfacs_extract'><p>Extract results from a netfacs object</p></a></li>
<li><a href='#netfacs_multiple'><p>Applies the <code>netfacs</code> function across multiple levels of the</p>
condition and puts them in a list</a></li>
<li><a href='#netfacs_network'><p>Creates a network object out of the netfacs data</p></a></li>
<li><a href='#netfacs_randomize'><p>Calculate probabilities from single randomization</p></a></li>
<li><a href='#netfacs.reciprocity'><p>Calculate reciprocity of probabilities that two elements appear together</p></a></li>
<li><a href='#network_conditional'><p>Create a network based on conditional probabilities of dyads of elements</p></a></li>
<li><a href='#network_plot'><p>Plots a network object</p></a></li>
<li><a href='#network_summary'><p>Returns all kinds of network measures for the netfacs network</p></a></li>
<li><a href='#network_summary_graph'><p>Returns all kinds of graph-level network measures for the netfacs network</p></a></li>
<li><a href='#network.conditional'><p>(Deprecated) Produce conditional probabilities of dyads of elements, and</p>
graph object based on conditional probabilities</a></li>
<li><a href='#overlap_network'><p>Plots the overlap of multiple conditions as bipartite network</p></a></li>
<li><a href='#overlap.network'><p>(Deprecated) Plots the overlap of multiple conditions as bipartite network.</p></a></li>
<li><a href='#possible_combinations'><p>Calculate all possible combinations of elements</p></a></li>
<li><a href='#prepare.netfacs'><p>Take data that are not currently in format and turn them into the correct format for netfacs function</p></a></li>
<li><a href='#print.netfacs'><p>Print method for objects of class <code>netfacs</code></p></a></li>
<li><a href='#print.netfacs_multiple'><p>Print method for objects of class <code>netfacs_multiple</code></p></a></li>
<li><a href='#probability_of_combination'><p>Calculate probabilities of single elements and combinations occurring</p></a></li>
<li><a href='#probability_of_event_size'><p>Count number of event sizes</p></a></li>
<li><a href='#sim_facs'><p>Simulate FACS data</p></a></li>
<li><a href='#specificity'><p>Specificity</p></a></li>
<li><a href='#specificity_increase'><p>Tests how much each element increases the specificity of all combinations it</p>
is in</a></li>
<li><a href='#summarise_combination'><p>Summarise combination results from bootstrap</p></a></li>
<li><a href='#summarise_event_size'><p>Summarise event size probabilities</p></a></li>
<li><a href='#upsample'><p>Up sample</p></a></li>
<li><a href='#validate_condition'><p>Check that condition arguments are formatted correctly</p></a></li>
<li><a href='#validate_data'><p>Check that 'data' argument is formatted correctly</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Network Applications to Facial Communication Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to analyze and visualize communication data, 
      based on network theory and resampling methods. 
      Farine, D. R. (2017) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12772">doi:10.1111/2041-210X.12772</a>&gt;;
      Carsey, T., &amp; Harden, J. (2014) &lt;<a href="https://doi.org/10.4135%2F9781483319605">doi:10.4135/9781483319605</a>&gt;.
      Primarily targeted at datasets of facial expressions coded with the Facial Action Coding System. 
      Ekman, P., Friesen, W. V., &amp; Hager, J. C. (2002). "Facial action coding system - investigator's guide" <a href="https://www.paulekman.com/facial-action-coding-system/">https://www.paulekman.com/facial-action-coding-system/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2.0)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>arrangements, doParallel, dplyr, igraph, ggplot2, ggraph,
magrittr, patchwork, parallel, picante, rlang, Rfast, tibble,
tidygraph, tidyr, vctrs, methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-06 17:06:53 UTC; avrincon</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Mielke [aut],
  Bridget M. Waller [aut],
  Claire Perez [aut],
  Alan V. Rincon [aut, cre],
  Julie Duboscq [aut],
  Jerome Micheletta [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alan V. Rincon &lt;avrincon1@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-06 17:32:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_inactive_single_units'>Add inactive (missing) single units</h2><span id='topic+add_inactive_single_units'></span>

<h3>Description</h3>

<p>Add inactive (missing) single units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_inactive_single_units(d, single.units)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_inactive_single_units_+3A_d">d</code></td>
<td>
<p>A dataframe, result of <code><a href="#topic+probability_of_combination">probability_of_combination</a></code></p>
</td></tr>
<tr><td><code id="add_inactive_single_units_+3A_single.units">single.units</code></td>
<td>
<p>A character vector of single AUs</p>
</td></tr>
</table>

<hr>
<h2 id='calculate_combination_size'>Calculate combination size</h2><span id='topic+calculate_combination_size'></span>

<h3>Description</h3>

<p>Calculate combination size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_combination_size(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_combination_size_+3A_x">x</code></td>
<td>
<p>A character vector of AU combinations, sep by _</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector
</p>

<hr>
<h2 id='conditional_probabilities'>Summarise dyadic combination of elements</h2><span id='topic+conditional_probabilities'></span>

<h3>Description</h3>

<p>For all dyadic combinations that appear in the test dataset, this function
returns the probability of A occurring (P(A)), the probability of B occurring
(P(B)), the probability of A and B occurring simultaneously (P(AandB)) and, the
probability of A given B (P(A|B)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_probabilities(netfacs.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditional_probabilities_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>An object of class <code><a href="#topic+netfacs">netfacs</a></code> or
<code><a href="#topic+netfacs_multiple">netfacs_multiple</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary <code><a href="tibble.html#topic+tibble">tibble</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+network_conditional">network_conditional</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 50,
  combination.size = 2
)

conditional_probabilities(angry.face)
</code></pre>

<hr>
<h2 id='define_contexts'>Define truth for AUs active in different contexts</h2><span id='topic+define_contexts'></span>

<h3>Description</h3>

<p>Define truth for AUs active in different contexts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_contexts(aus, n_active_aus, contexts = NULL, au_fidelity = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_contexts_+3A_aus">aus</code></td>
<td>
<p>A character vector of AUs</p>
</td></tr>
<tr><td><code id="define_contexts_+3A_n_active_aus">n_active_aus</code></td>
<td>
<p>A numeric vector, the same length as contexts, indicating
the number of AUs active per context.</p>
</td></tr>
<tr><td><code id="define_contexts_+3A_contexts">contexts</code></td>
<td>
<p>A character vector of contexts</p>
</td></tr>
<tr><td><code id="define_contexts_+3A_au_fidelity">au_fidelity</code></td>
<td>
<p>A number between 1 and 0.5, indicating the probability
that an AU is active in a context.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities with contexts in rows and AUs in columns
</p>

<hr>
<h2 id='define_joint_prob'>Joint probability distribution of AUs</h2><span id='topic+define_joint_prob'></span>

<h3>Description</h3>

<p>Joint probability distribution of AUs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_joint_prob(aus, n_jp = 2, min_jp = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_joint_prob_+3A_aus">aus</code></td>
<td>
<p>A character vector of AUs</p>
</td></tr>
<tr><td><code id="define_joint_prob_+3A_n_jp">n_jp</code></td>
<td>
<p>Number of joint probabilities &gt;0</p>
</td></tr>
<tr><td><code id="define_joint_prob_+3A_min_jp">min_jp</code></td>
<td>
<p>Minimum joint probability. Must be between 0 and 1</p>
</td></tr>
</table>

<hr>
<h2 id='distribution.plot'>Plots the observed probability for an element against the distribution of the null model</h2><span id='topic+distribution.plot'></span>

<h3>Description</h3>

<p>The function takes all single elements in a netfacs object, and plots the distribution of probabilities under the null hypothesis, marking where the observed probability falls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distribution.plot(netfacs.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distribution.plot_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from netfacs() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a ggplot showing for each element the distribution of expected probabilities (blue) and the observed probability (black line)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?
data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 100,
  combination.size = 2
)

# show distribution of AU4
distribution.plot(netfacs.data = angry.face)$"4"
</code></pre>

<hr>
<h2 id='element.plot'>Plots the observed and expected probabilities for the basic elements based on the condition</h2><span id='topic+element.plot'></span>

<h3>Description</h3>

<p>The function takes all single elements in a netfacs object, and plots the observed value and the expected value based on all randomisations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element.plot(netfacs.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element.plot_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from netfacs() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a ggplot showing for each element the observed probability and expected probability
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?
data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 100,
  combination.size = 2
)
# plot all
element.plot(netfacs.data = angry.face)
</code></pre>

<hr>
<h2 id='element.specificity'>(Defunct) Tests how much each element increases the specificity of all
combinations it is in</h2><span id='topic+element.specificity'></span>

<h3>Description</h3>

<p>This function is defunct Please see <code><a href="#topic+specificity_increase">specificity_increase</a></code>
instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>element.specificity(netfacs.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="element.specificity_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from <code><a href="#topic+netfacs">netfacs</a></code> function</p>
</td></tr>
</table>

<hr>
<h2 id='emotions_set'>Letter Data</h2><span id='topic+emotions_set'></span>

<h3>Description</h3>

<p>Data from the Extended Cohn-Kanade database, FACS data and emotions for posed images
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(emotions_set)
</code></pre>


<h3>Format</h3>

<p>An object of class.
</p>


<h3>References</h3>

<p>Lucey P, Cohn JF, Kanade T, Saragih J, Ambadar Z, Matthews I (2010) The extended Cohn-Kanade dataset (CK+): A complete dataset for action unit and emotion-specified expression. In: 2010 IEEE Computer Society Conference on Computer Vision and Pattern Recognition - Workshops, CVPRW 2010. pp 94-101
</p>

<hr>
<h2 id='entropy_overall'>Calculate information content of the dataset</h2><span id='topic+entropy_overall'></span>

<h3>Description</h3>

<p>Compares the observed and expected information content of the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy_overall(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_overall_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+netfacs">netfacs</a></code> or simply a binary matrix
of 0s and 1s, with elements in columns and events in rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a summary <code><a href="tibble.html#topic+tibble">tibble</a></code>
containing the observed entropy, expected entropy and entropy ratio
(observed / expected) of the dataset. Observed entropy is calculated using
Shannon's information entropy formula <code class="reqn">- \sum_{i = 1}^n p_i \log
  (p_i)</code>. Expected entropy is based on randomization (shuffling the observed
elements while maintaining the number of elements per row) and represents
the maximum entropy that a dataset with the same properties as this one can
reach. Ratios closer to 0 are more ordered; ratios closer to 1 are more
random.
</p>


<h3>References</h3>

<p>Shannon, C. E. (1948). A Mathematical Theory of Communication.
<em>Bell System Technical Journal</em>.
<code>https://doi.org/10.1002/j.1538-7305.1948.tb01338.x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?
data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 100,
  combination.size = 2
)

entropy_overall(angry.face)
</code></pre>

<hr>
<h2 id='entropy.overall'>(Deprecated) Calculate information content of the dataset</h2><span id='topic+entropy.overall'></span>

<h3>Description</h3>

<p>This function is deprecated. Please see <code><a href="#topic+entropy_overall">entropy_overall</a></code>
instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy.overall(x, netfacs.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy.overall_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+netfacs">netfacs</a></code> or simply a binary matrix
of 0s and 1s, with elements in columns and events in rows.</p>
</td></tr>
<tr><td><code id="entropy.overall_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>deprecated. Please use x instead.</p>
</td></tr>
</table>

<hr>
<h2 id='equal_observations'>Check that ALL objects have the same number of observations</h2><span id='topic+equal_observations'></span>

<h3>Description</h3>

<p>lenght(vector), nrow(matrix), nrow(dataframe)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equal_observations(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equal_observations_+3A_x">x</code></td>
<td>
<p>Object to compare number of observations</p>
</td></tr>
<tr><td><code id="equal_observations_+3A_...">...</code></td>
<td>
<p>Additional objects to compare number of observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical
</p>

<hr>
<h2 id='event_size_plot'>Plots the probability that a combination of a certain size appears</h2><span id='topic+event_size_plot'></span><span id='topic+event.size.plot'></span>

<h3>Description</h3>

<p>The function takes all combination size in a netfacs object, and plots the distribution of ratios between the observed value and all randomisations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_size_plot(netfacs.data)

event.size.plot(netfacs.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_size_plot_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from netfacs() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a ggplot showing for each combination size the observed and expected probabilities of occurrance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?
data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 100,
  combination.size = 2
)

event_size_plot(angry.face)
</code></pre>

<hr>
<h2 id='get_active_elements'>Extract active elements from matrix</h2><span id='topic+get_active_elements'></span>

<h3>Description</h3>

<p>Extract active elements from matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_active_elements(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_active_elements_+3A_m">m</code></td>
<td>
<p>A binary matrix where 1 indicates an element was active. colnames(m)
must contain the element names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors
</p>

<hr>
<h2 id='get_data'>Extract used data from a <code>netfacs</code> object</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p>Extract used data from a <code>netfacs</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(x, condition = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_+3A_x">x</code></td>
<td>
<p>extract data from the test condition of a <code>netfacs</code> object</p>
</td></tr>
<tr><td><code id="get_data_+3A_condition">condition</code></td>
<td>
<p>one of &quot;all&quot; (default), &quot;test&quot; or &quot;null&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='is.netfacs'>Checks if argument is a <code>netfacs</code> object</h2><span id='topic+is.netfacs'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>netfacs</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.netfacs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.netfacs_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>

<hr>
<h2 id='is.netfacs_multiple'>Checks if argument is a <code>netfacs_multiple</code> object</h2><span id='topic+is.netfacs_multiple'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>netfacs_multiple</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.netfacs_multiple(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.netfacs_multiple_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>

<hr>
<h2 id='is.netfacs_specificity'>Checks if argument is a <code>netfacs_specificity</code> object</h2><span id='topic+is.netfacs_specificity'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>netfacs_specificity</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.netfacs_specificity(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.netfacs_specificity_+3A_x">x</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object</p>
</td></tr>
</table>

<hr>
<h2 id='letternet'>Letter Data</h2><span id='topic+letternet'></span>

<h3>Description</h3>

<p>Data from the German, English, and French Versions of The Communist Manifesto, to have large datasets to test different functions in this package for now
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(letternet)
</code></pre>


<h3>Format</h3>

<p>An object of class.
</p>


<h3>References</h3>

<p>Marx &amp; Engels, 'The Communist Manifesto'
</p>

<hr>
<h2 id='multiple_netfacs_network'>Creates network objects out of the netfacs data</h2><span id='topic+multiple_netfacs_network'></span><span id='topic+multiple.netfacs.network'></span>

<h3>Description</h3>

<p>Takes the results of the nefacs object for combinations of 2 elements and
turns them into a network object (class <code><a href="igraph.html#topic+igraph">igraph</a></code> and
<code><a href="tidygraph.html#topic+tbl_graph">tbl_graph</a></code>) that can be used for further plotting and analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiple_netfacs_network(
  netfacs.list,
  link = "unweighted",
  significance = 0.01,
  min.count = 1,
  min.prob = 0,
  ignore.element = NULL
)

multiple.netfacs.network(
  netfacs.list,
  link = "unweighted",
  significance = 0.01,
  min.count = 1,
  min.prob = 0,
  ignore.element = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiple_netfacs_network_+3A_netfacs.list">netfacs.list</code></td>
<td>
<p>list of multiple objects resulting from
<code><a href="#topic+netfacs">netfacs</a></code> function or the <code><a href="#topic+netfacs_multiple">netfacs_multiple</a></code>
function</p>
</td></tr>
<tr><td><code id="multiple_netfacs_network_+3A_link">link</code></td>
<td>
<p>determines how nodes/elements are connected. 'unweighted' gives a
1 to significant connections and 0 to all others; 'weighted' gives the
difference between observed and expected probability of co-occurrence;
'raw' just uses the observed probability of co-occurrence; 'SRI' uses the
simple ratio index/affinity (probability of co-occurrence/ (probabilities
of each element and the combination))</p>
</td></tr>
<tr><td><code id="multiple_netfacs_network_+3A_significance">significance</code></td>
<td>
<p>numeric value, determining the p-value below which
combinations are considered to be dissimilar enough from the null
distribution</p>
</td></tr>
<tr><td><code id="multiple_netfacs_network_+3A_min.count">min.count</code></td>
<td>
<p>numeric value, suggesting how many times a combination
should at least occur to be displayed</p>
</td></tr>
<tr><td><code id="multiple_netfacs_network_+3A_min.prob">min.prob</code></td>
<td>
<p>numeric value, suggesting the probability at which a
combination should at least occur to be displayed</p>
</td></tr>
<tr><td><code id="multiple_netfacs_network_+3A_ignore.element">ignore.element</code></td>
<td>
<p>vector of elements that will not be considered for the
network, e.g. because they are too common or too rare or their
interpretation is not relevant here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a network object where the nodes are the elements,
edges represent their co-occurrence, and the vertex and edge attributes
contain all additional information from the netfacs object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emotions_set)
emo.faces &lt;- netfacs_multiple(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  ran.trials = 10, # only for example
  combination.size = 2
)

emo.nets &lt;- multiple_netfacs_network(emo.faces)
</code></pre>

<hr>
<h2 id='multiple_network_plot'>Plots networks for multiple conditions</h2><span id='topic+multiple_network_plot'></span><span id='topic+multiple.network.plot'></span>

<h3>Description</h3>

<p>The function takes multiple network objects and plots them next to each other
while keeping the element positions etc constant. Uses <code><a href="ggraph.html#topic+ggraph">ggraph</a></code>
function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiple_network_plot(netfacs.graphs, sig.level = 0.01, sig.nodes.only = FALSE)

multiple.network.plot(netfacs.graphs, sig.level = 0.01, sig.nodes.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiple_network_plot_+3A_netfacs.graphs">netfacs.graphs</code></td>
<td>
<p>List of network objects resulting from
<code><a href="#topic+netfacs_multiple">netfacs_multiple</a></code> function or
<code><a href="#topic+multiple_netfacs_network">multiple_netfacs_network</a></code> function</p>
</td></tr>
<tr><td><code id="multiple_network_plot_+3A_sig.level">sig.level</code></td>
<td>
<p>Numeric between 0 and 1. P value used to determine whether
nodes are significant. Default = 0.01.</p>
</td></tr>
<tr><td><code id="multiple_network_plot_+3A_sig.nodes.only">sig.nodes.only</code></td>
<td>
<p>Logical. Should only nodes that were significant in _at
least_ one of the networks be included in the plots? Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a <code><a href="ggraph.html#topic+ggraph">ggraph</a></code> plot showing connections
between nodes in the different networks. Elements that are significantly
more likely to occur than expected are large, non-significant elements are
small, and absent elements are absent.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emotions_set)
emo.faces &lt;- netfacs_multiple(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  duration = NULL,
  ran.trials = 10, # only for example
  control = NULL,
  random.level = NULL,
  combination.size = 2
)

emo.nets &lt;- multiple_netfacs_network(emo.faces, min.count = 5)
multiple_network_plot(emo.nets)
</code></pre>

<hr>
<h2 id='multiple.netfacs'>(Deprecated) Applies the <code><a href="#topic+netfacs">netfacs</a></code> function across multiple
levels of the condition and puts them in a list</h2><span id='topic+multiple.netfacs'></span>

<h3>Description</h3>

<p>This function is deprecated. Please see <code><a href="#topic+netfacs_multiple">netfacs_multiple</a></code>
instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiple.netfacs(
  data,
  condition = NULL,
  duration = NULL,
  ran.trials = 1000,
  control = NULL,
  random.level = NULL,
  combination.size = NULL,
  tail = "upper.tail",
  use_parallel = TRUE,
  n_cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiple.netfacs_+3A_data">data</code></td>
<td>
<p>A binary matrix with one column per element, and one row per
event, consisting of 1 (element was active during that event) and 0
(element was not active).</p>
</td></tr>
<tr><td><code id="multiple.netfacs_+3A_condition">condition</code></td>
<td>
<p>character vector of same length as 'data' that contains
information on the condition each event belongs to, so probabilities can be
compared across conditions</p>
</td></tr>
<tr><td><code id="multiple.netfacs_+3A_duration">duration</code></td>
<td>
<p>A numeric vector that contains information on the duration of
each event; if NULL, all events are assumed to have equal duration.</p>
</td></tr>
<tr><td><code id="multiple.netfacs_+3A_ran.trials">ran.trials</code></td>
<td>
<p>Number of randomisations that will be performed to find the
null distribution.</p>
</td></tr>
<tr><td><code id="multiple.netfacs_+3A_control">control</code></td>
<td>
<p>A list of vectors that are used as control variables. During
bootstraps, the ratio of events in each level will be adapted. So, for
example, if in the test distribution, there are three angry participants
for each happy participant, the null distribution will maintain that ratio.</p>
</td></tr>
<tr><td><code id="multiple.netfacs_+3A_random.level">random.level</code></td>
<td>
<p>A character vector of the level on which the
randomization should take place. If NULL, the randomization takes place on
the event level (i.e., every row can either be selected or not); if a
vector is provided, the randomization takes place on the levels of that
vector rather than individual events.</p>
</td></tr>
<tr><td><code id="multiple.netfacs_+3A_combination.size">combination.size</code></td>
<td>
<p>A positive integer, indicating the maximum
combination size of element combinations. Higher numbers will increase
computation time. Default is 2.</p>
</td></tr>
<tr><td><code id="multiple.netfacs_+3A_tail">tail</code></td>
<td>
<p>Either 'upper.tail' (proportion of null probabilities that are
larger than observed probabilities), or 'lower.tail' (proportion of null
probabilities that are smaller than observed probabilities); default is
'upper.tail'.</p>
</td></tr>
<tr><td><code id="multiple.netfacs_+3A_use_parallel">use_parallel</code></td>
<td>
<p>Logical, indicating whether randomization or bootstrap
should be parallelized (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="multiple.netfacs_+3A_n_cores">n_cores</code></td>
<td>
<p>Numeric, indicating the number cores to be used for
parallelization. Default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns for each level of the condition a list equivalent to
the results of the netfacs function; can be used to create multiple
networks and graphs at the same time
</p>

<hr>
<h2 id='mutual.information'>Calculates the pointwise mutual information of units with each other</h2><span id='topic+mutual.information'></span>

<h3>Description</h3>

<p>Calculates the pointwise mutual information of units with each other
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual.information(netfacs.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual.information_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from netfacs() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a dataframe that includes all combinations, their
occurrence counts and probabilities, and the pointwise mutual information
(standardised between -1 and 1). 1 means seeing one necessitates seeing the
other, -1 means one precludes the other
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?

data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = NULL,
  test.condition = NULL,
  ran.trials = 100,
  combination.size = 4
)

mutual.information(angry.face)

</code></pre>

<hr>
<h2 id='mutual.information.condition'>Tests how much each element increases the specificity of all combinations it
is in</h2><span id='topic+mutual.information.condition'></span>

<h3>Description</h3>

<p>The function takes all elements and dyadic combinations of elements in a
netfacs object, goes through all combinations these elements are in, and
compares the specificity (strength with which the combination identifies the
test condition) of all combinations with the element and the same
combinations without the element, to test how much specificity the element
adds when added to a signal. Only works for netfacs objects based on
comparison between conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutual.information.condition(netfacs.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutual.information.condition_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from netfacs() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a list with two data frames that include all
elements and first-order combinations that occur at all, the number of
combinations that each element/combination is part of, and how much adding
this element to a combination adds on average to its specificity, and how
often it occurs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?

data(emotions_set)
angry.face &lt;- netfacs(
 data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  null.condition = NULL,
  ran.trials = 100,
  combination.size = 4
)

head(mutual.information.condition(angry.face), 20)

</code></pre>

<hr>
<h2 id='netfacs'>Create probability distribution of combinations of elements in the data</h2><span id='topic+netfacs'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+netfacs">netfacs</a></code> function underlies most other functions in this
package. <br /> It takes the data set and reports the observed and expected
probabilities that elements and combinations of elements occur in this data
set, and whether this differs from a null condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netfacs(
  data,
  condition = NULL,
  test.condition = NULL,
  null.condition = NULL,
  duration = NULL,
  ran.trials = 1000,
  control = NULL,
  random.level = NULL,
  combination.size = 2,
  tail = "upper.tail",
  use_parallel = TRUE,
  n_cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netfacs_+3A_data">data</code></td>
<td>
<p>A binary matrix with one column per element, and one row per
event, consisting of 1 (element was active during that event) and 0
(element was not active).</p>
</td></tr>
<tr><td><code id="netfacs_+3A_condition">condition</code></td>
<td>
<p>A character vector the same length as 'data' that contains
information on the condition each event belongs to, so probabilities can be
compared across conditions; if NULL, all events will be tested against a
random null condition based on permutations.</p>
</td></tr>
<tr><td><code id="netfacs_+3A_test.condition">test.condition</code></td>
<td>
<p>A string, indicating the level of 'condition' that is
supposed to be tested.</p>
</td></tr>
<tr><td><code id="netfacs_+3A_null.condition">null.condition</code></td>
<td>
<p>A string, indicating the level of 'condition' that is
used to create the null distribution of values; if NULL, all levels that
are not the test condition will be used.</p>
</td></tr>
<tr><td><code id="netfacs_+3A_duration">duration</code></td>
<td>
<p>A numeric vector that contains information on the duration of
each event; if NULL, all events are assumed to have equal duration.</p>
</td></tr>
<tr><td><code id="netfacs_+3A_ran.trials">ran.trials</code></td>
<td>
<p>Number of randomisations that will be performed to find the
null distribution.</p>
</td></tr>
<tr><td><code id="netfacs_+3A_control">control</code></td>
<td>
<p>A list of vectors that are used as control variables. During
bootstraps, the ratio of events in each level will be adapted. So, for
example, if in the test distribution, there are three angry participants
for each happy participant, the null distribution will maintain that ratio.</p>
</td></tr>
<tr><td><code id="netfacs_+3A_random.level">random.level</code></td>
<td>
<p>A character vector of the level on which the
randomization should take place. If NULL, the randomization takes place on
the event level (i.e., every row can either be selected or not); if a
vector is provided, the randomization takes place on the levels of that
vector rather than individual events.</p>
</td></tr>
<tr><td><code id="netfacs_+3A_combination.size">combination.size</code></td>
<td>
<p>A positive integer, indicating the maximum
combination size of element combinations. Higher numbers will increase
computation time. Default is 2.</p>
</td></tr>
<tr><td><code id="netfacs_+3A_tail">tail</code></td>
<td>
<p>Either 'upper.tail' (proportion of null probabilities that are
larger than observed probabilities), or 'lower.tail' (proportion of null
probabilities that are smaller than observed probabilities); default is
'upper.tail'.</p>
</td></tr>
<tr><td><code id="netfacs_+3A_use_parallel">use_parallel</code></td>
<td>
<p>Logical, indicating whether randomization or bootstrap
should be parallelized (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="netfacs_+3A_n_cores">n_cores</code></td>
<td>
<p>Numeric, indicating the number cores to be used for
parallelization. Default is 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the 'condition' and 'test.condition' arguments are specified, the
null distribution of probability values are based on bootstraps of the null
condition. If the 'condition' argument is not specified, the null
distribution is based on random permutations of the data.
</p>
<p>For a general overview on how to use the netfacs function and package see
<code>vignette("netfacs_tutorial")</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>netfacs</code>, which contains the probabilities
of observing element combinations in the data, along with other useful
information. The resulting object is the basis for most other functions in
this package.
</p>


<h3>Author(s)</h3>

<p>Alex Mielke, Alan V. Rincon
</p>


<h3>References</h3>

<p>Mielke, A., Waller, B. M., Perez, C., Rincon, A. V., Duboscq, J.,
&amp; Micheletta, J. (2021). NetFACS: Using network science to understand
facial communication systems. <em>Behavior Research Methods</em>.
<code>https://doi.org/10.3758/s13428-021-01692-5</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netfacs_multiple">netfacs_multiple</a></code>, <code><a href="#topic+netfacs_extract">netfacs_extract</a></code>,
<code><a href="#topic+conditional_probabilities">conditional_probabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?

data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  null.condition = NULL,
  duration = NULL,
  ran.trials = 100,
  control = NULL,
  random.level = NULL,
  combination.size = 5,
  tail = "upper.tail",
  use_parallel = TRUE,
  n_cores = 2
)

head(angry.face$result, 20)
angry.face$event.size.information


</code></pre>

<hr>
<h2 id='netfacs_bootstrap'>Calculate expected probability from single bootstrap</h2><span id='topic+netfacs_bootstrap'></span>

<h3>Description</h3>

<p>Calculate expected probability from single bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netfacs_bootstrap(
  subject,
  subject.weight,
  null.subjects,
  null.elements,
  test.combinations,
  max.combination.size,
  max.event.size
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netfacs_bootstrap_+3A_subject">subject</code></td>
<td>
<p>A character vector of unique subjects present in the data</p>
</td></tr>
<tr><td><code id="netfacs_bootstrap_+3A_subject.weight">subject.weight</code></td>
<td>
<p>A numeric vector of weights to be used when sampling
subjects</p>
</td></tr>
<tr><td><code id="netfacs_bootstrap_+3A_null.subjects">null.subjects</code></td>
<td>
<p>A denoting the subject of null.elements</p>
</td></tr>
<tr><td><code id="netfacs_bootstrap_+3A_null.elements">null.elements</code></td>
<td>
<p>A list of active elements in the null condition</p>
</td></tr>
<tr><td><code id="netfacs_bootstrap_+3A_test.combinations">test.combinations</code></td>
<td>
<p>A vector denoting AU combinations that are present
in the test data</p>
</td></tr>
<tr><td><code id="netfacs_bootstrap_+3A_max.combination.size">max.combination.size</code></td>
<td>
<p>A positive integer indicating the maximum AU
combination size considered in the bootstrap</p>
</td></tr>
<tr><td><code id="netfacs_bootstrap_+3A_max.event.size">max.event.size</code></td>
<td>
<p>A positive integer indicating the maximum event size to
be considered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of bootstrapped probabilities for combinations and event sizes
</p>

<hr>
<h2 id='netfacs_extract'>Extract results from a netfacs object</h2><span id='topic+netfacs_extract'></span><span id='topic+netfacs.extract'></span>

<h3>Description</h3>

<p>Extract results from a <code><a href="#topic+netfacs">netfacs</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netfacs_extract(
  netfacs.data,
  combination.size = NULL,
  significance = 1,
  min.count = 0,
  min.prob = 0
)

netfacs.extract(
  netfacs.data,
  combination.size = NULL,
  significance = 1,
  min.count = 0,
  min.prob = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netfacs_extract_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>An object of class <code><a href="#topic+netfacs">netfacs</a></code>.</p>
</td></tr>
<tr><td><code id="netfacs_extract_+3A_combination.size">combination.size</code></td>
<td>
<p>Numeric, denoting the combination size(s) that should
be extracted. If <code>NULL</code> (default), all combination sizes are returned.</p>
</td></tr>
<tr><td><code id="netfacs_extract_+3A_significance">significance</code></td>
<td>
<p>Numeric value between 0 and 1, determining the p-value
below which combinations are considered to be dissimilar enough from the
null distribution.</p>
</td></tr>
<tr><td><code id="netfacs_extract_+3A_min.count">min.count</code></td>
<td>
<p>Numeric, denoting the minimum number of times an element
combination occurred.</p>
</td></tr>
<tr><td><code id="netfacs_extract_+3A_min.prob">min.prob</code></td>
<td>
<p>Numeric value between 0 and 1, denoting the minimum
probability an element combination occurred to be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a <code><a href="tibble.html#topic+tibble">tibble</a></code> data.frame
that contains the results of the <code><a href="#topic+netfacs">netfacs</a></code> object. By default,
returns all results for all observed combinations, but can optionally
pre-filter results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?
data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 10,
  combination.size = 2
)

netfacs_extract(angry.face)
</code></pre>

<hr>
<h2 id='netfacs_multiple'>Applies the <code><a href="#topic+netfacs">netfacs</a></code> function across multiple levels of the
condition and puts them in a list</h2><span id='topic+netfacs_multiple'></span>

<h3>Description</h3>

<p>Take dataset and report observed and expected likelihood that elements and
combinations of elements occur in this dataset, and whether this differs from
a null condition. Expected values are based on bootstraps of null
distribution, so the values represent distribution of element co-occurrence
under null condition. The resulting object is the basis for most other
functions in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netfacs_multiple(
  data,
  condition,
  duration = NULL,
  ran.trials = 1000,
  control = NULL,
  random.level = NULL,
  combination.size = 2,
  tail = "upper.tail",
  use_parallel = TRUE,
  n_cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netfacs_multiple_+3A_data">data</code></td>
<td>
<p>A binary matrix with one column per element, and one row per
event, consisting of 1 (element was active during that event) and 0
(element was not active).</p>
</td></tr>
<tr><td><code id="netfacs_multiple_+3A_condition">condition</code></td>
<td>
<p>character vector of same length as 'data' that contains
information on the condition each event belongs to, so probabilities can be
compared across conditions</p>
</td></tr>
<tr><td><code id="netfacs_multiple_+3A_duration">duration</code></td>
<td>
<p>A numeric vector that contains information on the duration of
each event; if NULL, all events are assumed to have equal duration.</p>
</td></tr>
<tr><td><code id="netfacs_multiple_+3A_ran.trials">ran.trials</code></td>
<td>
<p>Number of randomisations that will be performed to find the
null distribution.</p>
</td></tr>
<tr><td><code id="netfacs_multiple_+3A_control">control</code></td>
<td>
<p>A list of vectors that are used as control variables. During
bootstraps, the ratio of events in each level will be adapted. So, for
example, if in the test distribution, there are three angry participants
for each happy participant, the null distribution will maintain that ratio.</p>
</td></tr>
<tr><td><code id="netfacs_multiple_+3A_random.level">random.level</code></td>
<td>
<p>A character vector of the level on which the
randomization should take place. If NULL, the randomization takes place on
the event level (i.e., every row can either be selected or not); if a
vector is provided, the randomization takes place on the levels of that
vector rather than individual events.</p>
</td></tr>
<tr><td><code id="netfacs_multiple_+3A_combination.size">combination.size</code></td>
<td>
<p>A positive integer, indicating the maximum
combination size of element combinations. Higher numbers will increase
computation time. Default is 2.</p>
</td></tr>
<tr><td><code id="netfacs_multiple_+3A_tail">tail</code></td>
<td>
<p>Either 'upper.tail' (proportion of null probabilities that are
larger than observed probabilities), or 'lower.tail' (proportion of null
probabilities that are smaller than observed probabilities); default is
'upper.tail'.</p>
</td></tr>
<tr><td><code id="netfacs_multiple_+3A_use_parallel">use_parallel</code></td>
<td>
<p>Logical, indicating whether randomization or bootstrap
should be parallelized (default is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="netfacs_multiple_+3A_n_cores">n_cores</code></td>
<td>
<p>Numeric, indicating the number cores to be used for
parallelization. Default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>netfacs_multiple</code>, which contains the
probabilities of observing element combinations in one condition vs. all
other conditions, along with other useful information. The resulting object
is the basis for most other functions in this package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netfacs">netfacs</a></code>, <code><a href="#topic+netfacs_extract">netfacs_extract</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emotions_set)
emo.faces &lt;- netfacs_multiple(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  ran.trials = 10, # only for example
  combination.size = 2
)

netfacs_extract(emo.faces)
</code></pre>

<hr>
<h2 id='netfacs_network'>Creates a network object out of the netfacs data</h2><span id='topic+netfacs_network'></span><span id='topic+netfacs.network'></span>

<h3>Description</h3>

<p>Takes the results of the nefacs object for combinations of 2 elements and
turns them into a network object (igraph) that can be used for
further plotting and analyses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netfacs_network(
  netfacs.data,
  link = "unweighted",
  significance = 0.01,
  min.count = 1,
  min.prob = 0,
  ignore.element = NULL
)

netfacs.network(
  netfacs.data,
  link = "unweighted",
  significance = 0.01,
  min.count = 1,
  min.prob = 0,
  ignore.element = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netfacs_network_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from <code><a href="#topic+netfacs">netfacs</a></code> function</p>
</td></tr>
<tr><td><code id="netfacs_network_+3A_link">link</code></td>
<td>
<p>determines how nodes/elements are connected. 'unweighted' gives a
1 to significant connections and 0 to all others; 'weighted' gives the
difference between observed and expected probability of co-occurrence;
'raw' just uses the observed probability of co-occurrence</p>
</td></tr>
<tr><td><code id="netfacs_network_+3A_significance">significance</code></td>
<td>
<p>numeric value, determining the p-value below which
combinations are considered to be dissimilar enough from the null
distribution</p>
</td></tr>
<tr><td><code id="netfacs_network_+3A_min.count">min.count</code></td>
<td>
<p>numeric value, suggesting how many times a combination
should at least occur to be displayed</p>
</td></tr>
<tr><td><code id="netfacs_network_+3A_min.prob">min.prob</code></td>
<td>
<p>numeric value, suggesting the probability at which a
combination should at least occur to be displayed</p>
</td></tr>
<tr><td><code id="netfacs_network_+3A_ignore.element">ignore.element</code></td>
<td>
<p>vector of elements that will not be considered for the
network, e.g. because they are too common or too rare or their
interpretation is not relevant here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a network object where the nodes are the elements,
edges represent their co-occurrence, and the vertex and edge attributes
contain all additional information from the netfacs object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 100,
  combination.size = 2
)

anger.net &lt;- netfacs_network(
  netfacs.data = angry.face,
  link = "unweighted",
  significance = 0.01,
  min.count = 1
)
</code></pre>

<hr>
<h2 id='netfacs_randomize'>Calculate probabilities from single randomization</h2><span id='topic+netfacs_randomize'></span>

<h3>Description</h3>

<p>Calculate probabilities from single randomization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netfacs_randomize(m, test.combinations, max.combination.size, max.event.size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netfacs_randomize_+3A_m">m</code></td>
<td>
<p>A numeric matrix</p>
</td></tr>
<tr><td><code id="netfacs_randomize_+3A_test.combinations">test.combinations</code></td>
<td>
<p>A vector of AU combinations observed in test data</p>
</td></tr>
<tr><td><code id="netfacs_randomize_+3A_max.combination.size">max.combination.size</code></td>
<td>
<p>A positive integer</p>
</td></tr>
<tr><td><code id="netfacs_randomize_+3A_max.event.size">max.event.size</code></td>
<td>
<p>A Positive integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of randomized probabilities for combinations and event sizes
</p>

<hr>
<h2 id='netfacs.reciprocity'>Calculate reciprocity of probabilities that two elements appear together</h2><span id='topic+netfacs.reciprocity'></span>

<h3>Description</h3>

<p>For all dyadic combinations that ever appear, this function calculates how
reciprocal the conditional probabilities (i.e. probability of A given B, and
B given A) of the two elements are. Combinations that are highly reciprocal
indicate that the two elements always occur together and might represent a
fixed combination, while low reciprocity might indicate that one element is
an extension of the other. Values approaching -1 indicate that one element is
strongly dependent on the other, but this is not reciprocated; values around
0 indicate that neither is conditional on the other; and values approaching 1
indicate that both values are conditional on each other. If P[A|B] is the
larger conditional probability, the reciprocity is calculated as reciprocity
= ((P[B|A]/P[A|B]) - (P[A|B] - P[B|A])) * P[A|B].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netfacs.reciprocity(netfacs.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netfacs.reciprocity_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from netfacs() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a data frame with each combination, the reciprocity
of conditional occurrence from -1 (one element entirely depends on the
other, but not vice versa) to 1 (both elements always occur together)
</p>
<p>The directions and conditional probabilities of both elements are
also returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?
data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 100,
  combination.size = 2
)

netfacs.reciprocity(angry.face)
</code></pre>

<hr>
<h2 id='network_conditional'>Create a network based on conditional probabilities of dyads of elements</h2><span id='topic+network_conditional'></span>

<h3>Description</h3>

<p>This is a convenience function to create and visualize a network of
conditional probabilities for all dyadic element combinations of a
<code><a href="#topic+netfacs">netfacs</a></code> object. Conditional probabilities are calculated using
the <code><a href="#topic+conditional_probabilities">conditional_probabilities</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_conditional(
  netfacs.data,
  min.prob = 0,
  min.count = 0,
  ignore.element = NULL,
  plot.bubbles = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_conditional_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from <code><a href="#topic+netfacs">netfacs</a></code> or
<code><a href="#topic+conditional_probabilities">conditional_probabilities</a></code> functions.</p>
</td></tr>
<tr><td><code id="network_conditional_+3A_min.prob">min.prob</code></td>
<td>
<p>minimum conditional probability that should be shown in the
graph</p>
</td></tr>
<tr><td><code id="network_conditional_+3A_min.count">min.count</code></td>
<td>
<p>minimum number of times that a combination should occur
before being included in the graph</p>
</td></tr>
<tr><td><code id="network_conditional_+3A_ignore.element">ignore.element</code></td>
<td>
<p>string vector, can be used to exclude certain elements
when creating the plots</p>
</td></tr>
<tr><td><code id="network_conditional_+3A_plot.bubbles">plot.bubbles</code></td>
<td>
<p>if TRUE (default), then the nodes in the network plots
will be surrounded by bubbles; if FALSE, the edges connect the names
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns named list that includes a
<code><a href="tidygraph.html#topic+tbl_graph">tbl_graph</a></code> network and a
<code><a href="ggraph.html#topic+ggraph">ggraph</a></code> plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+netfacs">netfacs</a></code>, <code><a href="#topic+conditional_probabilities">conditional_probabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?
data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 100,
  combination.size = 2
)

conditional.probs &lt;- conditional_probabilities(angry.face)

network_conditional(
  netfacs.data = conditional.probs,
  min.prob = 0.01,
  min.count = 3,
  ignore.element = "25",
  plot.bubbles = FALSE
)
</code></pre>

<hr>
<h2 id='network_plot'>Plots a network object</h2><span id='topic+network_plot'></span><span id='topic+network.plot'></span>

<h3>Description</h3>

<p>Plots the network created using the <code><a href="#topic+netfacs_network">netfacs_network</a></code> function;
for networks with clear clusterin of elements, clusters can get different
colours
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_plot(
  netfacs.graph,
  title = "network",
  clusters = FALSE,
  plot.bubbles = FALSE,
  hide.unconnected = TRUE
)

network.plot(
  netfacs.graph,
  title = "network",
  clusters = FALSE,
  plot.bubbles = FALSE,
  hide.unconnected = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_plot_+3A_netfacs.graph">netfacs.graph</code></td>
<td>
<p>igraph network object resulting from
<code><a href="#topic+netfacs_network">netfacs_network</a></code></p>
</td></tr>
<tr><td><code id="network_plot_+3A_title">title</code></td>
<td>
<p>string of the graph's main title</p>
</td></tr>
<tr><td><code id="network_plot_+3A_clusters">clusters</code></td>
<td>
<p>if <code>TRUE</code>, <code><a href="igraph.html#topic+cluster_fast_greedy">cluster_fast_greedy</a></code> is
used to establish possible clusters in the dataset</p>
</td></tr>
<tr><td><code id="network_plot_+3A_plot.bubbles">plot.bubbles</code></td>
<td>
<p>if TRUE, then the nodes in the network plots will be
surrounded by bubbles; if FALSE, the edges connect the names directly</p>
</td></tr>
<tr><td><code id="network_plot_+3A_hide.unconnected">hide.unconnected</code></td>
<td>
<p>if TRUE, then the nodes that do not have any
significant connections will be hidden in the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a <code><a href="ggraph.html#topic+ggraph">ggraph</a></code> plot of the network,
where the size of nodes indicates how often they occur on their own, and
edges indicate significant co-occurrence between them
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 10,
  combination.size = 2
)

anger.net &lt;- netfacs_network(
  netfacs.data = angry.face,
  link = "unweighted",
  significance = 0.01,
  min.count = 1
)

network_plot(anger.net,
             title = "Angry Faces",
             clusters = FALSE,
             plot.bubbles = TRUE)
</code></pre>

<hr>
<h2 id='network_summary'>Returns all kinds of network measures for the netfacs network</h2><span id='topic+network_summary'></span><span id='topic+network.summary'></span>

<h3>Description</h3>

<p>Calculates node level centrality measures from the network object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_summary(netfacs.graph)

network.summary(netfacs.graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_summary_+3A_netfacs.graph">netfacs.graph</code></td>
<td>
<p>igraph network object resulting from
<a href="#topic+netfacs_network">netfacs_network</a> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a data frame with the element, its 'strength' (mean
probability of co-occurrence), 'eigenvector' centrality (connection to
other highly connected elements), 'betweenness' centrality (number of
connections running through the element), and a number of other network
measures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 10,
  combination.size = 2
)

anger.net &lt;- netfacs_network(
  netfacs.data = angry.face,
  link = "unweighted",
  significance = 0.01,
  min.count = 1
)

network_summary(anger.net)
</code></pre>

<hr>
<h2 id='network_summary_graph'>Returns all kinds of graph-level network measures for the netfacs network</h2><span id='topic+network_summary_graph'></span><span id='topic+network.summary.graph'></span>

<h3>Description</h3>

<p>Calculates graph level summary measures from the network object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_summary_graph(netfacs.net)

network.summary.graph(netfacs.net)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_summary_graph_+3A_netfacs.net">netfacs.net</code></td>
<td>
<p>igraph network object resulting from
<a href="#topic+netfacs_network">netfacs_network</a> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a dataframe with the number of elements in the
graph, the number of connected edges, mean strength of connections,
transitivity (mean number of closed triads), diameter (furthest path
between two elements), degree centralization, and mean distance between
elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 10,
  combination.size = 2
)

anger.net &lt;- netfacs_network(
  netfacs.data = angry.face,
  link = "unweighted",
  significance = 0.01,
  min.count = 1
)

network_summary_graph(anger.net)
</code></pre>

<hr>
<h2 id='network.conditional'>(Deprecated) Produce conditional probabilities of dyads of elements, and
graph object based on conditional probabilities</h2><span id='topic+network.conditional'></span>

<h3>Description</h3>

<p>This function is deprecated. Please see <code><a href="#topic+network_conditional">network_conditional</a></code>
instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network.conditional(
  netfacs.data,
  min.prob = 0,
  min.count = 0,
  ignore.element = NULL,
  plot.bubbles = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network.conditional_+3A_netfacs.data">netfacs.data</code></td>
<td>
<p>object resulting from <code><a href="#topic+netfacs">netfacs</a></code> or
<code><a href="#topic+conditional_probabilities">conditional_probabilities</a></code> functions.</p>
</td></tr>
<tr><td><code id="network.conditional_+3A_min.prob">min.prob</code></td>
<td>
<p>minimum conditional probability that should be shown in the
graph</p>
</td></tr>
<tr><td><code id="network.conditional_+3A_min.count">min.count</code></td>
<td>
<p>minimum number of times that a combination should occur
before being included in the graph</p>
</td></tr>
<tr><td><code id="network.conditional_+3A_ignore.element">ignore.element</code></td>
<td>
<p>string vector, can be used to exclude certain elements
when creating the plots</p>
</td></tr>
<tr><td><code id="network.conditional_+3A_plot.bubbles">plot.bubbles</code></td>
<td>
<p>if TRUE (default), then the nodes in the network plots
will be surrounded by bubbles; if FALSE, the edges connect the names
directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a dataframe that includes all dyadic combinations
and their observed and conditional probabilities
</p>

<hr>
<h2 id='overlap_network'>Plots the overlap of multiple conditions as bipartite network</h2><span id='topic+overlap_network'></span>

<h3>Description</h3>

<p>The function takes multiple netfacs objects and plots how different elements
connect the conditions, based on the conditional probabilities that the
element occurs in the condition and that the condition is seen when the
element is present
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap_network(
  x,
  min.prob = 0,
  min.count = 5,
  significance = 0.01,
  specificity = 0.1,
  ignore.element = NULL,
  clusters = FALSE,
  plot.bubbles = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_network_+3A_x">x</code></td>
<td>
<p>list of objects resulting from <code><a href="#topic+specificity">specificity</a></code> or
<code><a href="#topic+netfacs">netfacs</a></code></p>
</td></tr>
<tr><td><code id="overlap_network_+3A_min.prob">min.prob</code></td>
<td>
<p>minimum conditional probability that should be shown in the
graph</p>
</td></tr>
<tr><td><code id="overlap_network_+3A_min.count">min.count</code></td>
<td>
<p>minimum number of times that a combination should occur
before being included in the graph</p>
</td></tr>
<tr><td><code id="overlap_network_+3A_significance">significance</code></td>
<td>
<p>sets the level of significance that combinations have to
pass before added to the network</p>
</td></tr>
<tr><td><code id="overlap_network_+3A_specificity">specificity</code></td>
<td>
<p>for the 'reduced' graph, select only elements that surpass
this context specificity value</p>
</td></tr>
<tr><td><code id="overlap_network_+3A_ignore.element">ignore.element</code></td>
<td>
<p>string vector, can be used to exclude certain elements
when creating the plots</p>
</td></tr>
<tr><td><code id="overlap_network_+3A_clusters">clusters</code></td>
<td>
<p>boolean; if TRUE, the cluster_fast_greedy algorithm is used
to detect underlying community structure, based on the occurrence
probability network</p>
</td></tr>
<tr><td><code id="overlap_network_+3A_plot.bubbles">plot.bubbles</code></td>
<td>
<p>if TRUE, then the nodes in the network plots will be
surrounded by bubbles; if FALSE, the edges connect the names directly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a <code><a href="ggraph.html#topic+ggraph">ggraph</a></code> plot where each
condition is connected to those elements that occur significantly in this
condition, and each element is connected to each condition under which it
occurs significantly more than expected. Creates four graphs: context
specificity, occurrence in that context, a combined graph, and a 'reduced'
graph where edges are only included if they pass the 'specificity' value
set by the user
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(emotions_set)
emo.faces &lt;- netfacs_multiple(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  ran.trials = 10,
  combination.size = 2
)
# calculate element specificity
spec &lt;- specificity(emo.faces)

overlap &lt;- overlap_network(spec,
                           min.prob = 0.01,
                           min.count = 3,
                           significance = 0.01,
                           specificity = 0.5,
                           ignore.element = "25",
                           clusters = TRUE,
                           plot.bubbles = TRUE)

</code></pre>

<hr>
<h2 id='overlap.network'>(Deprecated) Plots the overlap of multiple conditions as bipartite network.</h2><span id='topic+overlap.network'></span>

<h3>Description</h3>

<p>This function is deprecated. Please see <code><a href="#topic+overlap_network">overlap_network</a></code>
instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap.network(
  netfacs.list,
  min.prob = 0,
  min.count = 5,
  significance = 0.01,
  specificity = 0.1,
  ignore.element = NULL,
  clusters = FALSE,
  plot.bubbles = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap.network_+3A_netfacs.list">netfacs.list</code></td>
<td>
<p>list of objects resulting from <code><a href="#topic+netfacs">netfacs</a></code> or
<code><a href="#topic+netfacs_multiple">netfacs_multiple</a></code></p>
</td></tr>
<tr><td><code id="overlap.network_+3A_min.prob">min.prob</code></td>
<td>
<p>minimum conditional probability that should be shown in the
graph</p>
</td></tr>
<tr><td><code id="overlap.network_+3A_min.count">min.count</code></td>
<td>
<p>minimum number of times that a combination should occur
before being included in the graph</p>
</td></tr>
<tr><td><code id="overlap.network_+3A_significance">significance</code></td>
<td>
<p>sets the level of significance that combinations have to
pass before added to the network</p>
</td></tr>
<tr><td><code id="overlap.network_+3A_specificity">specificity</code></td>
<td>
<p>for the 'reduced' graph, select only elements that surpass
this context specificity value</p>
</td></tr>
<tr><td><code id="overlap.network_+3A_ignore.element">ignore.element</code></td>
<td>
<p>string vector, can be used to exclude certain elements
when creating the plots</p>
</td></tr>
<tr><td><code id="overlap.network_+3A_clusters">clusters</code></td>
<td>
<p>boolean; if TRUE, the cluster_fast_greedy algorithm is used
to detect underlying community structure, based on the occurrence
probability network</p>
</td></tr>
<tr><td><code id="overlap.network_+3A_plot.bubbles">plot.bubbles</code></td>
<td>
<p>if TRUE, then the nodes in the network plots will be
surrounded by bubbles; if FALSE, the edges connect the names directly</p>
</td></tr>
</table>

<hr>
<h2 id='possible_combinations'>Calculate all possible combinations of elements</h2><span id='topic+possible_combinations'></span>

<h3>Description</h3>

<p>Takes a vector of elements and returns a vector with all possible
combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possible_combinations(elements, maxlen, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="possible_combinations_+3A_elements">elements</code></td>
<td>
<p>A vector of elements</p>
</td></tr>
<tr><td><code id="possible_combinations_+3A_maxlen">maxlen</code></td>
<td>
<p>maximum size of combinations to be considered</p>
</td></tr>
<tr><td><code id="possible_combinations_+3A_sep">sep</code></td>
<td>
<p>String. Separator used for showing combinations of elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with all element combinations
</p>

<hr>
<h2 id='prepare.netfacs'>Take data that are not currently in format and turn them into the correct format for netfacs function</h2><span id='topic+prepare.netfacs'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+netfacs">netfacs</a></code> function requires data to be entered with the element data as a matrix of each element by each event,
with occurrence marked as 1 and non-occurrence marked as 0.<br />
This is often not the case, so this function transforms data in other routine formats to have the right look.<br />
Specifically, users can define whether they want to enter 'photos', which indicates that all elements in an event are simply strung together in a vector; or they define 'video', in which case it is assumed that each element has a start and an end point in a specified video
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare.netfacs(
  elements,
  type = c("video", "photo"),
  video.id = NULL,
  start.time = NULL,
  duration = NULL,
  separator = ",",
  frame.duration = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare.netfacs_+3A_elements">elements</code></td>
<td>
<p>vector with either one element per index (for videos) or all elements that occurred in the whole event (for photos)</p>
</td></tr>
<tr><td><code id="prepare.netfacs_+3A_type">type</code></td>
<td>
<p>either 'video' or 'photo'. If 'photo', the function separates the string and returns a matrix of the correct dimensions. If 'video', the function creates a matrix using the highest common factor of all 'durations' and for each of those 'frames' assigns whether each element was present or absent</p>
</td></tr>
<tr><td><code id="prepare.netfacs_+3A_video.id">video.id</code></td>
<td>
<p>name of the video, so all cases are treated together. For photos, can be entered so that photos can be matched to IDs after</p>
</td></tr>
<tr><td><code id="prepare.netfacs_+3A_start.time">start.time</code></td>
<td>
<p>for videos, time when the element is first active</p>
</td></tr>
<tr><td><code id="prepare.netfacs_+3A_duration">duration</code></td>
<td>
<p>for videos, how long is the element active for</p>
</td></tr>
<tr><td><code id="prepare.netfacs_+3A_separator">separator</code></td>
<td>
<p>for photos, how are elements separated in the list</p>
</td></tr>
<tr><td><code id="prepare.netfacs_+3A_frame.duration">frame.duration</code></td>
<td>
<p>for videos, how long is a 'frame' supposed to last? If NULL, frame duration is the shortest 'duration' of any element specified</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assumption for this function is that for photos, elements are stored like this: <br />
'AU1/AU2/AU3/AU4'<br />
'AU1/AU3/AU4'<br />
'AU1/AU2'<br />
<br />
For videos, the assumption is that they are stored in a data frame like this: <br />
element = AU1, video.id = 1, start.time = 0.5, duration = 2sec
</p>


<h3>Value</h3>

<p>Function returns a list with element.matrix (the matrix of elements and when they occurred) and video.info (the supporting information, e.g. video names, durations, frames etc)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for a photo
au.photos &lt;- c(
  "AU1/AU5/AU9",
  "AU1/AU2",
  "AU1/AU2/AU10",
  "AU1/AU2",
  "AU5/AU17/AU18",
  "AU6/AU12"
)
au.names &lt;- c("photo1", "photo2", "photo3", "photo4", "photo5", "photo6")
au.prepared &lt;- prepare.netfacs(
  elements = au.photos,
  type = "photo",
  video.id = au.names,
  separator = "/"
)
au.prepared$element.matrix
au.prepared$video.info

# for a video
aus &lt;- c(
  "AU1", "AU5", "AU9",
  "AU1", "AU2",
  "AU1", "AU2", "AU10",
  "AU1", "AU2",
  "AU5", "AU17", "AU18",
  "AU6", "AU12"
)
video.names &lt;- c(
  rep("video1", 3),
  rep("video2", 2),
  rep("video3", 3),
  rep("video4", 2),
  rep("video5", 3),
  rep("video6", 2)
)
start.times &lt;- c(
  0.1, 0.2, 0.3,
  0.1, 0.3,
  0.1, 0.4, 0.4,
  0.1, 0.2,
  0.1, 0.5, 0.6,
  0.1, 0.2
)
durations &lt;- rep(0.3, times = length(start.times))
frame.dur &lt;- 0.05
au.prepared &lt;- prepare.netfacs(
  elements = aus,
  type = "video",
  video.id = video.names,
  start.time = start.times,
  duration = durations,
  frame.duration = frame.dur
)
head(au.prepared$element.matrix)
head(au.prepared$video.info)
</code></pre>

<hr>
<h2 id='print.netfacs'>Print method for objects of class <code>netfacs</code></h2><span id='topic+print.netfacs'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>netfacs</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netfacs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.netfacs_+3A_x">x</code></td>
<td>
<p>An object of class <code>netfacs</code></p>
</td></tr>
<tr><td><code id="print.netfacs_+3A_...">...</code></td>
<td>
<p>Additional arguments that would be passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='print.netfacs_multiple'>Print method for objects of class <code>netfacs_multiple</code></h2><span id='topic+print.netfacs_multiple'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>netfacs_multiple</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'netfacs_multiple'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.netfacs_multiple_+3A_x">x</code></td>
<td>
<p>An object of class <code>netfacs_multiple</code></p>
</td></tr>
<tr><td><code id="print.netfacs_multiple_+3A_...">...</code></td>
<td>
<p>Additional arguments that would be passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='probability_of_combination'>Calculate probabilities of single elements and combinations occurring</h2><span id='topic+probability_of_combination'></span>

<h3>Description</h3>

<p>Calculate probabilities of single elements and combinations occurring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probability_of_combination(elements, maxlen, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probability_of_combination_+3A_elements">elements</code></td>
<td>
<p>A vector with all elements observed together at an event. Or
a list of vectors or a binary matrix with elements as <code>colnames()</code></p>
</td></tr>
<tr><td><code id="probability_of_combination_+3A_maxlen">maxlen</code></td>
<td>
<p>maximum size of combinations to be considered</p>
</td></tr>
<tr><td><code id="probability_of_combination_+3A_sep">sep</code></td>
<td>
<p>String. Separator used for showing combinations of elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a dataframe with observed probabilities for each
combination in the dataset
</p>

<hr>
<h2 id='probability_of_event_size'>Count number of event sizes</h2><span id='topic+probability_of_event_size'></span>

<h3>Description</h3>

<p>Count number of event sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probability_of_event_size(elements, max.event.size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probability_of_event_size_+3A_elements">elements</code></td>
<td>
<p>A list of vectors containing active elements or a binary
matrix with events in rows</p>
</td></tr>
<tr><td><code id="probability_of_event_size_+3A_max.event.size">max.event.size</code></td>
<td>
<p>A positive integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector, including probabilities for event sizes that were not
observed in the data
</p>

<hr>
<h2 id='sim_facs'>Simulate FACS data</h2><span id='topic+sim_facs'></span>

<h3>Description</h3>

<p>Simulate FACS data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_facs(m, n_obs = 10, jp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_facs_+3A_m">m</code></td>
<td>
<p>A matrix with condition as<code>rownames</code>, elements as
<code>colnames</code>, and probabilities of observing an element as values.</p>
</td></tr>
<tr><td><code id="sim_facs_+3A_n_obs">n_obs</code></td>
<td>
<p>Number of observations per condition to simulate</p>
</td></tr>
<tr><td><code id="sim_facs_+3A_jp">jp</code></td>
<td>
<p>An optional list of matrices, the same length as <code>nrow(m)</code>
with the joint probabilities of elements</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>elements &lt;- as.character(1:10)
conditions &lt;- letters[1:2]
# randomly generate probability of elements
probabilities &lt;-
  sapply(elements, function(x) {
    p &lt;- runif(length(conditions))
    setNames(round(p, 1), nm = conditions)
  })
sim_facs(probabilities)
</code></pre>

<hr>
<h2 id='specificity'>Specificity</h2><span id='topic+specificity'></span>

<h3>Description</h3>

<p>Calculate specificity of element combinations to a given condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specificity(
  x,
  condition,
  test.condition = NULL,
  null.condition = NULL,
  combination.size = NULL,
  upsample = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specificity_+3A_x">x</code></td>
<td>
<p>A binary matrix, with AUs as <code>colnames</code>, or an object of class
<code><a href="#topic+netfacs">netfacs</a></code></p>
</td></tr>
<tr><td><code id="specificity_+3A_condition">condition</code></td>
<td>
<p>A character condition vector</p>
</td></tr>
<tr><td><code id="specificity_+3A_test.condition">test.condition</code></td>
<td>
<p>A string, denoting the test condition. If <code>NULL</code>
(default) specificity is calculated for all conditions.</p>
</td></tr>
<tr><td><code id="specificity_+3A_null.condition">null.condition</code></td>
<td>
<p>A string, denoting the null condition. If <code>NULL</code>
(default) all observations not part of the test.condition will be
considered part of the null.</p>
</td></tr>
<tr><td><code id="specificity_+3A_combination.size">combination.size</code></td>
<td>
<p>A positive integer, indicating the maximum
combination size of element combinations. If <code>NULL</code> (default), the
maximum combination size observed in the x is used.</p>
</td></tr>
<tr><td><code id="specificity_+3A_upsample">upsample</code></td>
<td>
<p>Logical. Should minority condition(s) be
<code><a href="#topic+upsample">upsample</a></code>d? <code>TRUE</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specificity values are biased when the number of observations per
condition is highly imbalanced. When <code>upsample</code> = <code>TRUE</code>
(recommended), the condition(s) with fewer observations are randomly
<code><a href="#topic+upsample">upsample</a></code>d to match the number of observations in the most
common condition prior to the specificity calculation. This procedure
minimizes the bias in the specificity results.
</p>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>specificity(
  x = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger"
)
</code></pre>

<hr>
<h2 id='specificity_increase'>Tests how much each element increases the specificity of all combinations it
is in</h2><span id='topic+specificity_increase'></span>

<h3>Description</h3>

<p>The function takes all elements and dyadic combinations of elements in a
netfacs object, goes through all combinations these elements are in, and
compares the specificity (strength with which the combination identifies the
test condition) of all combinations with the element and the same
combinations without the element, to test how much specificity the element
adds when added to a signal. Only works for netfacs objects based on
comparison between conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specificity_increase(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specificity_increase_+3A_x">x</code></td>
<td>
<p>object resulting from <code><a href="#topic+specificity">specificity</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function returns a list with two data frames that include all
elements and first-order combinations that occur at all, the number of
combinations that each element/combination is part of, and how much adding
this element to a combination adds on average to its specificity, and how
often it occurs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### how do angry facial expressions differ from non-angry ones?
data(emotions_set)
angry.face &lt;- netfacs(
  data = emotions_set[[1]],
  condition = emotions_set[[2]]$emotion,
  test.condition = "anger",
  ran.trials = 10,
  combination.size = 2
)

spec &lt;- specificity(angry.face)
specificity_increase(spec)
</code></pre>

<hr>
<h2 id='summarise_combination'>Summarise combination results from bootstrap</h2><span id='topic+summarise_combination'></span>

<h3>Description</h3>

<p>Summarise combination results from bootstrap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_combination(
  combination,
  combination.size,
  observed.prob,
  boot.prob,
  tail,
  test.count
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_combination_+3A_combination">combination</code></td>
<td>
<p>A vector of AU combinations</p>
</td></tr>
<tr><td><code id="summarise_combination_+3A_combination.size">combination.size</code></td>
<td>
<p>A vector denoting the number of active AUs in combination</p>
</td></tr>
<tr><td><code id="summarise_combination_+3A_observed.prob">observed.prob</code></td>
<td>
<p>A vector with probability of combination in test data</p>
</td></tr>
<tr><td><code id="summarise_combination_+3A_boot.prob">boot.prob</code></td>
<td>
<p>A matrix with boot probabilities of a given combination in
columns</p>
</td></tr>
<tr><td><code id="summarise_combination_+3A_tail">tail</code></td>
<td>
<p>upper.tail or lower.tail,</p>
</td></tr>
<tr><td><code id="summarise_combination_+3A_test.count">test.count</code></td>
<td>
<p>Number of times a combination occurs in test dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>

<hr>
<h2 id='summarise_event_size'>Summarise event size probabilities</h2><span id='topic+summarise_event_size'></span>

<h3>Description</h3>

<p>Summarise event size probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_event_size(observed.prob, boot.prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_event_size_+3A_observed.prob">observed.prob</code></td>
<td>
<p>A named vector with probabilities of event sizes.</p>
</td></tr>
<tr><td><code id="summarise_event_size_+3A_boot.prob">boot.prob</code></td>
<td>
<p>A matrix with boot probabilities of a given event
size. Combination size in rows, trials in columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe
</p>

<hr>
<h2 id='upsample'>Up sample</h2><span id='topic+upsample'></span>

<h3>Description</h3>

<p>Randomly up-sample the minority condition(s) to have the same number of
observations as the majority condition. Random samples are added to the
existing observations of the minority conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upsample(x, condition, .name = "condition")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upsample_+3A_x">x</code></td>
<td>
<p>A data.frame or something coercible to one</p>
</td></tr>
<tr><td><code id="upsample_+3A_condition">condition</code></td>
<td>
<p>A character vector the same length as 'x' denoting which
condition each observation belongs to</p>
</td></tr>
<tr><td><code id="upsample_+3A_.name">.name</code></td>
<td>
<p>A string used to name the condition column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(
  condition = c(rep("a", times = 7), rep("b", times = 3)),
  x = sample(0:1, size = 10, replace = TRUE),
  y = sample(0:1, size = 10, replace = TRUE)
)

upsample(x = d, condition = d$condition)
</code></pre>

<hr>
<h2 id='validate_condition'>Check that condition arguments are formatted correctly</h2><span id='topic+validate_condition'></span>

<h3>Description</h3>

<p>Check that condition arguments are formatted correctly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_condition(data, condition, test.condition, null.condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_condition_+3A_data">data</code></td>
<td>
<p>data passed by the user</p>
</td></tr>
<tr><td><code id="validate_condition_+3A_condition">condition</code></td>
<td>
<p>condition passed by the user</p>
</td></tr>
<tr><td><code id="validate_condition_+3A_test.condition">test.condition</code></td>
<td>
<p>condition passed by the user</p>
</td></tr>
<tr><td><code id="validate_condition_+3A_null.condition">null.condition</code></td>
<td>
<p>condition passed by the user</p>
</td></tr>
</table>

<hr>
<h2 id='validate_data'>Check that 'data' argument is formatted correctly</h2><span id='topic+validate_data'></span>

<h3>Description</h3>

<p>Check that 'data' argument is formatted correctly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_data(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_data_+3A_data">data</code></td>
<td>
<p>data passed by the user</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data as a matrix
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
