<!DOCTYPE html><html><head><title>Help for package gaussplotR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gaussplotR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autofit_gaussian_2D'><p>Automatically determine the best-fitting 2D-Gaussian for a data set</p></a></li>
<li><a href='#characterize_gaussian_fits'><p>Characterize the orientation of fitted 2D-Gaussians</p></a></li>
<li><a href='#compare_gaussian_fits'><p>Compare fitted 2D-Gaussians and determine the best-fitting model</p></a></li>
<li><a href='#fit_gaussian_2D'><p>Determine the best-fit parameters for a specific 2D-Gaussian model</p></a></li>
<li><a href='#gaussplot_sample_data'><p>Sample data set</p></a></li>
<li><a href='#get_volume_gaussian_2D'><p>Compute volume under 2D-Gaussian</p></a></li>
<li><a href='#ggplot_gaussian_2D'><p>Plot a 2D-Gaussian via ggplot</p></a></li>
<li><a href='#predict_gaussian_2D'><p>Predict values from a fitted 2D-Gaussian</p></a></li>
<li><a href='#rgl_gaussian_2D'><p>Produce a 3D plot of the 2D-Gaussian via rgl</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit, Predict and Plot 2D Gaussians</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Functions to fit two-dimensional Gaussian functions, predict values from
    fits, and produce plots of predicted data via either 'ggplot2' or base R 
    plotting.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1.9000</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.3.0), metR (&ge; 0.7.0), rgl, viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/vbaliga/gaussplotR">https://github.com/vbaliga/gaussplotR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/vbaliga/gaussplotR/issues">https://github.com/vbaliga/gaussplotR/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-02 19:55:48 UTC; vbali</td>
</tr>
<tr>
<td>Author:</td>
<td>Vikram B. Baliga <a href="https://orcid.org/0000-0002-9367-8974"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vikram B. Baliga &lt;vbaliga87@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-02 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='autofit_gaussian_2D'>Automatically determine the best-fitting 2D-Gaussian for a data set</h2><span id='topic+autofit_gaussian_2D'></span>

<h3>Description</h3>

<p>Automatically determine the best-fitting 2D-Gaussian for a data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autofit_gaussian_2D(
  data,
  comparison_method = "rmse",
  maxiter = 1000,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autofit_gaussian_2D_+3A_data">data</code></td>
<td>
<p>A data.frame that contains the raw data (generally rectilinearly
gridded data, but this is not a strict requirement). Columns must be named
<code>"X_values"</code>, <code>"Y_values"</code> and <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="autofit_gaussian_2D_+3A_comparison_method">comparison_method</code></td>
<td>
<p>One of &quot;rmse&quot;, &quot;rss&quot;, or &quot;AIC&quot;; what metric should
be used to determine the &quot;best-fitting&quot; Gaussian?</p>
</td></tr>
<tr><td><code id="autofit_gaussian_2D_+3A_maxiter">maxiter</code></td>
<td>
<p>Default 1000. A positive integer specifying the maximum number
of iterations allowed. See <code>stats::nls.control()</code> for more details.</p>
</td></tr>
<tr><td><code id="autofit_gaussian_2D_+3A_simplify">simplify</code></td>
<td>
<p>TRUE or FALSE. If TRUE, return only the coefficients, model,
model_error_stats, and fit_method for the best-fitting model. If FALSE, a
model comparison table is also included in the returned list as
<code>$model_comparison</code>. This table is obtained via
<code>compare_gaussian_fits()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs <code>fit_gaussian_2D()</code> three times: once for
each of the &quot;main&quot; types of models: 1) elliptical, unconstrained; 2)
elliptical, log; 3) circular. In all three cases, amplitudes and
orientations are unconstrained. The function <code>compare_gaussian_fits()</code>
is then used to determine which of these three models is the best-fitting,
using the <code>comparison_method</code> argument to make the decision.
</p>


<h3>Value</h3>

<p>If <code>simplify = TRUE</code>, a list with the components:
</p>

<ul>
<li><p>&quot;coefs&quot; A data.frame of fitted model parameters.
</p>
</li>
<li><p>&quot;model&quot; The model object, fitted by <code>stats::nls()</code>.
</p>
</li>
<li><p>&quot;model_error_stats&quot; A data.frame detailing the rss, rmse, deviance,
and AIC of the fitted model.
</p>
</li>
<li><p>&quot;fit_method&quot; A character vector that indicates which method and
orientation strategy was used by this function.
</p>
</li></ul>

<p>If <code>simplify = FALSE</code>, a model comparison table is also included
in the returned list as <code>$model_comparison</code>. This table is obtained
via <code>compare_gaussian_fits()</code>.
</p>


<h3>Author(s)</h3>

<p>Vikram B. Baliga
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
}
</code></pre>

<hr>
<h2 id='characterize_gaussian_fits'>Characterize the orientation of fitted 2D-Gaussians</h2><span id='topic+characterize_gaussian_fits'></span>

<h3>Description</h3>

<p>The orientation and partial correlations of Gaussian data are analyzed
according to Levitt et al. 1994 and Priebe et al. 2003. Features include
computation of partial correlations between response variables and
independent and diagonally-tuned predictions, along with Z-difference
scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>characterize_gaussian_fits(
  fit_objects_list = NULL,
  data = NULL,
  constrain_amplitude = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="characterize_gaussian_fits_+3A_fit_objects_list">fit_objects_list</code></td>
<td>
<p>A list of outputs from <code>fit_gaussian_2D()</code>. See
Details for more. This is the preferred input object for this function.</p>
</td></tr>
<tr><td><code id="characterize_gaussian_fits_+3A_data">data</code></td>
<td>
<p>A data.frame that contains the raw data (generally rectilinearly
gridded data, but this is not a strict requirement). Columns must be named
<code>"X_values"</code>, <code>"Y_values"</code> and <code>"response"</code>. See
<code>fit_gaussian_2D()</code> for details.</p>
</td></tr>
<tr><td><code id="characterize_gaussian_fits_+3A_constrain_amplitude">constrain_amplitude</code></td>
<td>
<p>Default FALSE; should the amplitude of the
Gaussian be set to the maximum value of the <code>"response"</code> variable
(<code>TRUE</code>), or should the amplitude fitted by <code>stats::nls()</code>
(<code>FALSE</code>)? See <code>fit_gaussian_2D()</code> for details.</p>
</td></tr>
<tr><td><code id="characterize_gaussian_fits_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed to
<code>fit_gaussian_2D()</code> if data are supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function accepts either a list of objects output from
<code>fit_gaussian_2D()</code> (preferred) or a data.frame that contains the raw
data.
</p>
<p>The supplied fit_objects_list must be a list that contains objects returned
by <code>fit_gaussian_2D()</code>. This list must contain exactly three models. All
three models must have been run using <code>method = "elliptical_log"</code>. The
models must be: 1) one in which orientation is unconstrained, 2) one in which
orientation is constrained to Q = 0 (i.e. a diagonally-oriented Gaussian),
and 3) one in which orientation is constrained to Q = -1 (i.e. a
horizontally-oriented Gaussian). See this function's Examples for guidance.
</p>
<p>Should raw data be provided instead of the fit_objects_list, the
<code>characterize_gaussian_fits()</code> runs <code>fit_gaussian_2D()</code> internally.
This is generally not recommended, as difficulties in fitting models via
<code>stats::nls()</code> are more easily troubleshot by the optional arguments in
<code>fit_gaussian_2D()</code>. Nevertheless, supplying raw data instead of a list
of fitted models is feasible, though your mileage may vary.
</p>


<h3>Value</h3>

<p>A list with the following:
</p>

<ul>
<li><p>&quot;model_comparison&quot; A model comparison output (i.e. what is produced
by <code>compare_gaussian_fits()</code>), which indicates the relative preference
of each of the three models.
</p>
</li>
<li><p>&quot;Q_table&quot; A data.frame that provides information on the value of Q
from the best-fitting model, along with the 5-95% confidence intervals of
this estimate.
</p>
</li>
<li><p>&quot;r_i&quot; A numeric, the correlation of the data with the independent
(Q = -1) prediction.
</p>
</li>
<li><p>&quot;r_s&quot; A numeric, the correlation of the data with the diagonally-
oriented (Q = 0) prediction.
</p>
</li>
<li><p>&quot;r_is&quot; A numeric, the correlation between the independent
(Q = -1) prediction and the the diagonally-oriented (Q = 0) prediction.
</p>
</li>
<li><p>&quot;R_indp&quot; A numeric, partial correlation of the response variable
with the independent (Q = -1) prediction.
</p>
</li>
<li><p>&quot;R_diag&quot; A numeric, partial correlation of the response variable
with the diagonally-oriented (Q = 0) prediction.
</p>
</li>
<li><p>&quot;ZF_indp&quot; A numeric, the Fisher Z-transform of the R_indp
coefficient. See Winship et al. 2006 for details.
</p>
</li>
<li><p>&quot;ZF_diag&quot; A numeric, the Fisher Z-transform of the R_diag
coefficient. See Winship et al. 2006 for details.
</p>
</li>
<li><p>&quot;Z_diff&quot; A numeric, the Z-difference between ZF_indp and ZF_diag.
See Winship et al. 2006 for details.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vikram B. Baliga
</p>


<h3>References</h3>

<p>Levitt JB, Kiper DC, Movshon JA. Receptive fields and functional architecture
of macaque V2. J Neurophysiol. 1994 71:2517â€“2542.
</p>
<p>Priebe NJ, Cassanello CR, Lisberger SG. The neural representation of speed in
macaque area MT/V5. J Neurosci. 2003 Jul 2;23(13):5650-61. doi:
10.1523/JNEUROSCI.23-13-05650.2003.
</p>
<p>Winship IR, Crowder N, Wylie DRW. Quantitative reassessment of speed tuning
in the accessory optic system and pretectum of pigeons. J Neurophysiol. 2006
95(1):546-551. doi: 10.1152/jn.00921.2005
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(gaussplotR)

  ## Load the sample data set
  data(gaussplot_sample_data)

  ## The raw data we'd like to use are in columns 1:3
  samp_dat &lt;-
    gaussplot_sample_data[,1:3]

  ## Fit the three required models
  gauss_fit_uncn &lt;-
    fit_gaussian_2D(
      samp_dat,
      method = "elliptical_log",
      constrain_amplitude = FALSE,
      constrain_orientation = "unconstrained"
    )

  gauss_fit_diag &lt;-
    fit_gaussian_2D(
      samp_dat,
      method = "elliptical_log",
      constrain_amplitude = FALSE,
      constrain_orientation = 0
    )

  gauss_fit_indp &lt;-
    fit_gaussian_2D(
      samp_dat,
      method = "elliptical_log",
      constrain_amplitude = FALSE,
      constrain_orientation = -1
    )

  ## Combine the outputs into a list
  models_list &lt;-
    list(
      gauss_fit_uncn,
      gauss_fit_diag,
      gauss_fit_indp
    )

  ## Now characterize
  out &lt;-
    characterize_gaussian_fits(models_list)
  out

  ## Alternatively, the raw data itself can be supplied.
  ## This is less preferred, as fitting of models may fail
  ## internally.
  out2 &lt;-
    characterize_gaussian_fits(data = samp_dat)

  ## This produces the same output, assuming models are fit without error
  identical(out, out2)
}
</code></pre>

<hr>
<h2 id='compare_gaussian_fits'>Compare fitted 2D-Gaussians and determine the best-fitting model</h2><span id='topic+compare_gaussian_fits'></span>

<h3>Description</h3>

<p>Compare fitted 2D-Gaussians and determine the best-fitting model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_gaussian_fits(fit_objects_list, comparison_method = "rmse")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_gaussian_fits_+3A_fit_objects_list">fit_objects_list</code></td>
<td>
<p>A list of outputs from <code>fit_gaussian_2D()</code>. See
Details for more</p>
</td></tr>
<tr><td><code id="compare_gaussian_fits_+3A_comparison_method">comparison_method</code></td>
<td>
<p>One of &quot;rmse&quot;, &quot;rss&quot;, or &quot;AIC&quot;; what metric should
be used to determine the &quot;best-fitting&quot; Gaussian?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the argument <code>fit_objects_list</code>, a list of fitted model
objects (output from <code>fit_gaussian_2D()</code>) can simply be combined via
<code>list()</code>. Naming the list is optional; should you supply names, the
output of <code>compare_gaussian_fits()</code> will refer to specific models by
these names.
</p>


<h3>Value</h3>

<p>A list with the components:
</p>

<ul>
<li><p>&quot;preferred_model&quot; A character indicating the name of the preferred
model (or if a named list was not provided, a model number is given in
the order of the original supplied list). 
</p>
</li>
<li><p>&quot;comparison_table&quot; A data.frame detailing the rss, rmse, deviance,
and AIC of the fitted models. The data.frame is sorted by the
comparison_method that was selected.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vikram B. Baliga
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  library(gaussplotR)

  ## Load the sample data set
  data(gaussplot_sample_data)

  ## The raw data we'd like to use are in columns 1:3
  samp_dat &lt;-
    gaussplot_sample_data[,1:3]

  ## Fit a variety of different models
  gauss_fit_ue &lt;-
    fit_gaussian_2D(samp_dat)
  gauss_fit_uel &lt;-
    fit_gaussian_2D(samp_dat, method = "elliptical_log")
  gauss_fit_cir &lt;-
    fit_gaussian_2D(samp_dat, method = "circular")

  ## Combine the outputs into a list
  models_list &lt;-
    list(
      unconstrained_elliptical = gauss_fit_ue,
      unconstrained_elliptical_log = gauss_fit_uel,
      circular = gauss_fit_cir
    )

  ## Compare via rmse
  models_compared &lt;-
    compare_gaussian_fits(
      fit_objects_list = models_list,
      comparison_method = "rmse" ## the default
    )
}
</code></pre>

<hr>
<h2 id='fit_gaussian_2D'>Determine the best-fit parameters for a specific 2D-Gaussian model</h2><span id='topic+fit_gaussian_2D'></span>

<h3>Description</h3>

<p>Determine the best-fit parameters for a specific 2D-Gaussian model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_gaussian_2D(
  data,
  method = "elliptical",
  constrain_amplitude = FALSE,
  constrain_orientation = "unconstrained",
  user_init = NULL,
  maxiter = 1000,
  verbose = FALSE,
  print_initial_params = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_gaussian_2D_+3A_data">data</code></td>
<td>
<p>A data.frame that contains the raw data (generally rectilinearly
gridded data, but this is not a strict requirement). Columns must be named
<code>"X_values"</code>, <code>"Y_values"</code> and <code>"response"</code>.</p>
</td></tr>
<tr><td><code id="fit_gaussian_2D_+3A_method">method</code></td>
<td>
<p>Choice of <code>"elliptical"</code>, <code>"elliptical_log"</code>, or
<code>"circular"</code>. Determine which specific implementation of 2D-Gaussian
to use. See Details for more.</p>
</td></tr>
<tr><td><code id="fit_gaussian_2D_+3A_constrain_amplitude">constrain_amplitude</code></td>
<td>
<p>Default FALSE; should the amplitude of the
Gaussian be set to the maximum value of the <code>"response"</code> variable
(<code>TRUE</code>), or should the amplitude fitted by <code>stats::nls()</code>
(<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="fit_gaussian_2D_+3A_constrain_orientation">constrain_orientation</code></td>
<td>
<p>If using <code>"elliptical"</code> or <code>method =
  "elliptical_log"</code>, should the orientation of the Gaussian be unconstrained
(i.e. the best-fit orientation is returned) or should it be pre-set by the
user? See Details for more. Defaults to <code>"unconstrained"</code>.</p>
</td></tr>
<tr><td><code id="fit_gaussian_2D_+3A_user_init">user_init</code></td>
<td>
<p>Default NULL; if desired, the user can supply initial values
for the parameters of the chosen model. See Details for more.</p>
</td></tr>
<tr><td><code id="fit_gaussian_2D_+3A_maxiter">maxiter</code></td>
<td>
<p>Default 1000. A positive integer specifying the maximum number
of iterations allowed. See <code>stats::nls.control()</code> for more details.</p>
</td></tr>
<tr><td><code id="fit_gaussian_2D_+3A_verbose">verbose</code></td>
<td>
<p>TRUE or FALSE; should the trace of the iteration be printed?
See the <code>trace</code> argument of <code>stats::nls()</code> for more detail.</p>
</td></tr>
<tr><td><code id="fit_gaussian_2D_+3A_print_initial_params">print_initial_params</code></td>
<td>
<p>TRUE or FALSE; should the set of initial
parameters supplied to <code>stats::nls()</code> be printed to the console? Set
to FALSE by default to avoid confusion with the fitted parameters attained
after using <code>stats::nls()</code>.</p>
</td></tr>
<tr><td><code id="fit_gaussian_2D_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stats::nls.control()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stats::nls()</code> is used to fit parameters for a 2D-Gaussian to
the supplied data. Each method uses (slightly) different sets of
parameters. Note that for a small (but non-trivial) proportion of data
sets, nonlinear least squares may fail due to singularities or other
issues. Most often, this occurs because of the starting parameters that are
fed in. By default, this function attempts to set default parameters by
making an educated guess about the major aspects of the supplied data.
Should this strategy fail, the user can make use of the <code>user_init</code>
argument to supply an alternate set of starting values.
</p>
<p>The simplest method is <code>method = "circular"</code>. Here, the 2D-Gaussian is
constrained to have a roughly circular shape (i.e. spread in X- and Y- are
roughly equal). If this method is used, the fitted parameters are: Amp
(amplitude), X_peak (x-axis peak location), Y_peak (y-axis peak location),
X_sig (spread along x-axis), and Y_sig (spread along y-axis).
</p>
<p>A more generic method (and the default) is <code>method = "elliptical"</code>.
This allows the fitted 2D-Gaussian to take a more ellipsoid shape (but note
that <code>method = "circular"</code> can be considered a special case of this).
If this method is used, the fitted parameters are: A_o (a constant term),
Amp (amplitude), theta (rotation, in radians, from the x-axis in the
clockwise direction), X_peak (x-axis peak location), Y_peak (y-axis peak
location), a (width of Gaussian along x-axis), and b (width of Gaussian
along y-axis).
</p>
<p>A third method is <code>method = "elliptical_log"</code>. This is a further
special case in which log2-transformed data may be used. See Priebe et al.
2003 for more details. Parameters from this model include: Amp (amplitude),
Q (orientation parameter), X_peak (x-axis peak location), Y_peak (y-axis
peak location), X_sig (spread along x-axis), and Y_sig (spread along
y-axis).
</p>
<p>If using either <code>method = "elliptical"</code> or <code>method =
  "elliptical_log"</code>, the <code>"constrain_orientation"</code> argument can be used
to specify how the orientation is set. In most cases, the user should use
the default &quot;unconstrained&quot; setting for this argument. Doing so will
provide the best-fit 2D-Gaussian (assuming that the solution yielded by
<code>stats::nls()</code> converges on the global optimum).
</p>
<p>Setting <code>constrain_orientation</code> to a numeric (e.g.
<code>constrain_orientation = pi/2</code>) will force the orientation of the
Gaussian to the specified value. Note that this is handled differently by
<code>method = "elliptical"</code> vs <code>method = "elliptical_log"</code>. In
<code>method = "elliptical"</code>, the theta parameter dictates the rotation, in
radians, from the x-axis in the clockwise direction. In contrast, the
<code>method = "elliptical_log"</code> procedure uses a Q parameter to determine
the orientation of the 2D-Gaussian. Setting <code>constrain_orientation =
  0</code> will result in a diagonally-oriented Gaussian, whereas setting
<code>constrain_orientation = -1</code> will result in horizontal orientation.
See Priebe et al. 2003 for more details.
</p>
<p>The <code>user_init</code> argument can also be used to supply a vector of
initial values for the A, Q, X_peak, Y_peak, X_var, and Y_var parameters.
If the user chooses to make use of <code>user_init</code>, then a vector
containing all parameters must be supplied in a particular order.
</p>
<p>Additional arguments to the <code>control</code> argument in <code>stats::nls()</code>
can be supplied via <code>...</code>.
</p>


<h3>Value</h3>

<p>A list with the components:
</p>

<ul>
<li><p>&quot;coefs&quot; A data.frame of fitted model parameters.
</p>
</li>
<li><p>&quot;model&quot; The model object, fitted by <code>stats::nls()</code>.
</p>
</li>
<li><p>&quot;model_error_stats&quot; A data.frame detailing the rss, rmse, deviance,
and AIC of the fitted model.
</p>
</li>
<li><p>&quot;fit_method&quot; A character vector that indicates which method and
orientation strategy was used by this function.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Vikram B. Baliga
</p>


<h3>References</h3>

<p>Priebe NJ, Cassanello CR, Lisberger SG. The neural representation
of speed in macaque area MT/V5. J Neurosci. 2003 Jul 2;23(13):5650-61. doi:
10.1523/JNEUROSCI.23-13-05650.2003.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  ## Load the sample data set
  data(gaussplot_sample_data)

  ## The raw data we'd like to use are in columns 1:3
  samp_dat &lt;-
    gaussplot_sample_data[,1:3]


  #### Example 1: Unconstrained elliptical ####
  ## This fits an unconstrained elliptical by default
  gauss_fit &lt;-
    fit_gaussian_2D(samp_dat)

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  library(ggplot2); library(metR)
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)


  #### Example 2: Constrained elliptical_log ####
  ## This fits a constrained elliptical, as in Priebe et al. 2003
  gauss_fit &lt;-
    fit_gaussian_2D(
      samp_dat,
      method = "elliptical_log",
      constrain_orientation = -1
    )

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)
}
</code></pre>

<hr>
<h2 id='gaussplot_sample_data'>Sample data set</h2><span id='topic+gaussplot_sample_data'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> of raw data and fitted 2D-Gaussian parameters; intended
for use with <code>predict_gaussian_2D()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussplot_sample_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 36 rows and 11 variables:
</p>

<dl>
<dt>X_values</dt><dd><p>vector of numeric values for the x-axis</p>
</dd>
<dt>Y_values</dt><dd><p>vector of numeric values for the y-axis</p>
</dd>
<dt>response</dt><dd><p>vector of numeric values for the response variable</p>
</dd>
<dt>norm_g_resp</dt><dd><p>normalized values from the 2D-Gaussian fit</p>
</dd>
<dt>g_resp</dt><dd><p>values from the 2D-Gaussian fit</p>
</dd>
<dt>A</dt><dd><p>amplitude of 2D-Gaussian (repeated)</p>
</dd>
<dt>X_peak</dt><dd><p>location of peak x-axis value (repeated)</p>
</dd>
<dt>X_var</dt><dd><p>variance in x (repeated)</p>
</dd>
<dt>Q</dt><dd><p>orientation parameter of the gaussian (repeated)</p>
</dd>
<dt>Y_peak</dt><dd><p>location of peak y-axis value (repeated)</p>
</dd>
<dt>Y_var</dt><dd><p>variance in y (repeated)</p>
</dd>
</dl>


<hr>
<h2 id='get_volume_gaussian_2D'>Compute volume under 2D-Gaussian</h2><span id='topic+get_volume_gaussian_2D'></span>

<h3>Description</h3>

<p>Compute volume under 2D-Gaussian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_volume_gaussian_2D(X_sig, Y_sig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_volume_gaussian_2D_+3A_x_sig">X_sig</code></td>
<td>
<p>numeric value(s) of the x-axis spread (sigma)</p>
</td></tr>
<tr><td><code id="get_volume_gaussian_2D_+3A_y_sig">Y_sig</code></td>
<td>
<p>numeric value(s) of the y-axis spread (sigma)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Volume under the 2D-Gaussian is computed as:
<code>2 * pi * sqrt(abs(X_sig)) * sqrt(abs(Y_sig))</code>
</p>
<p>Numeric vectors can be supplied to <code>X_sig</code> and <code>Y_sig</code>. If vectors
of length greater than 1 are given, the function computes volume for each
sequential pair of <code>X_sig</code>, <code>Y_sig</code> values. The lengths of these
supplied vectors must be identical.
</p>


<h3>Value</h3>

<p>Numeric value(s) indicating the computed volume(s)
</p>


<h3>Author(s)</h3>

<p>Vikram B. Baliga
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gaussplotR)

get_volume_gaussian_2D(5, 3) #24.33467
</code></pre>

<hr>
<h2 id='ggplot_gaussian_2D'>Plot a 2D-Gaussian via ggplot</h2><span id='topic+ggplot_gaussian_2D'></span>

<h3>Description</h3>

<p>Plot a 2D-Gaussian via ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_gaussian_2D(
  gauss_data,
  normalize = TRUE,
  contour_thickness = 0.04,
  contour_color = "black",
  bins = 15,
  viridis_dir = 1,
  viridis_opt = "B",
  x_lab = "X values",
  y_lab = "Y values",
  axis.text = element_text(size = 6),
  axis.title = element_text(size = 7),
  axis.ticks = element_line(size = 0.3),
  plot.margin = unit(c(0.1, 0.1, 0.1, 0.1), "cm"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_gaussian_2D_+3A_gauss_data">gauss_data</code></td>
<td>
<p>Data.frame with X_values, Y_values, and predicted_values,
e.g. exported from <code>predict_gaussian_2D()</code></p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_normalize">normalize</code></td>
<td>
<p>Default TRUE, should predicted_values be normalized on a 0
to 1 scale?</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_contour_thickness">contour_thickness</code></td>
<td>
<p>Thickness of contour lines</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_contour_color">contour_color</code></td>
<td>
<p>Color of the contour lines</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_bins">bins</code></td>
<td>
<p>Number of bins for the contour plot</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_viridis_dir">viridis_dir</code></td>
<td>
<p>See &quot;direction&quot; in scale_fill_viridis_c()</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_viridis_opt">viridis_opt</code></td>
<td>
<p>See &quot;option&quot; in scale_fill_viridis_c()</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_x_lab">x_lab</code></td>
<td>
<p>Arguments passed to xlab()</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_y_lab">y_lab</code></td>
<td>
<p>Arguments passed to ylab()</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_axis.text">axis.text</code></td>
<td>
<p>Arguments passed to axis.text</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_axis.title">axis.title</code></td>
<td>
<p>Arguments passed to axis.title</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_axis.ticks">axis.ticks</code></td>
<td>
<p>Arguments passed to axis.ticks</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_plot.margin">plot.margin</code></td>
<td>
<p>Arguments passed to plot.margin</p>
</td></tr>
<tr><td><code id="ggplot_gaussian_2D_+3A_...">...</code></td>
<td>
<p>Other arguments supplied to <code>ggplot2::theme()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that uses metR::geom_contour_fill() to display the
2D-Gaussian
</p>


<h3>Author(s)</h3>

<p>Vikram B. Baliga
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  ## Load the sample data set
  data(gaussplot_sample_data)

  ## The raw data we'd like to use are in columns 1:3
  samp_dat &lt;-
    gaussplot_sample_data[,1:3]


  #### Example 1: Unconstrained elliptical ####
  ## This fits an unconstrained elliptical by default
  gauss_fit &lt;-
    fit_gaussian_2D(samp_dat)

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  library(ggplot2); library(metR)
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)


  #### Example 2: Constrained elliptical_log ####
  ## This fits a constrained elliptical, as in Priebe et al. 2003
  gauss_fit &lt;-
    fit_gaussian_2D(
      samp_dat,
      method = "elliptical_log",
      constrain_orientation = -1
    )

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)
}
</code></pre>

<hr>
<h2 id='predict_gaussian_2D'>Predict values from a fitted 2D-Gaussian</h2><span id='topic+predict_gaussian_2D'></span>

<h3>Description</h3>

<p>Predict values from a fitted 2D-Gaussian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_gaussian_2D(fit_object, X_values, Y_values, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_gaussian_2D_+3A_fit_object">fit_object</code></td>
<td>
<p>Either the output of <code>gaussplotR::fit_gaussian_2D()</code>
or a list that contains coefficients and fit methods (see Details).</p>
</td></tr>
<tr><td><code id="predict_gaussian_2D_+3A_x_values">X_values</code></td>
<td>
<p>vector of numeric values for the x-axis</p>
</td></tr>
<tr><td><code id="predict_gaussian_2D_+3A_y_values">Y_values</code></td>
<td>
<p>vector of numeric values for the y-axis</p>
</td></tr>
<tr><td><code id="predict_gaussian_2D_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes Gaussian parameters have been fitted beforehand. No
fitting of parameters is done within this function; these can be
supplied via the object created by <code>gaussplotR::fit_gaussian_2D()</code>.
</p>
<p>If <code>fit_object</code> is not an object created by
<code>gaussplotR::fit_gaussian_2D()</code>, <code>predict_gaussian_2D()</code> attempts
to parse <code>fit_object</code> as a list of two items. The coefficients of the
fit must be supplied as a one-row, named data.frame within
<code>fit_object$coefs</code>, and details of the methods for fitting the Gaussian
must be contained as a character vector in <code>fit_object$fit_method</code>. This
character vector in <code>fit_object$fit_method</code> must be a named vector that
provides information about the method, amplitude constraint choice, and
orientation constraint choice, using the names <code>method</code>,
<code>amplitude</code>, and <code>orientation</code>. <code>method</code> must be one of:
<code>"elliptical"</code>, <code>"elliptical_log"</code>, or <code>"circular"</code>.
<code>amplitude</code> and <code>orientation</code> must each be either
<code>"unconstrained"</code> or <code>"constrained"</code>. For example, <code>c(method =
"elliptical", amplitude = "unconstrained", orientation = "unconstrained")</code>.
One exception to this is when <code>method = "circular"</code>, in which case
<code>orientation</code> must be <code>NA</code>, e.g.: <code>c(method = "circular",
amplitude = "unconstrained", orientation = NA)</code>.
</p>


<h3>Value</h3>

<p>A data.frame with the supplied <code>X_values</code> and <code>Y_values</code>
along with the predicted values of the 2D-Gaussian
(<code>predicted_values</code>)
</p>


<h3>Author(s)</h3>

<p>Vikram B. Baliga
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  ## Load the sample data set
  data(gaussplot_sample_data)

  ## The raw data we'd like to use are in columns 1:3
  samp_dat &lt;-
    gaussplot_sample_data[,1:3]


  #### Example 1: Unconstrained elliptical ####
  ## This fits an unconstrained elliptical by default
  gauss_fit &lt;-
    fit_gaussian_2D(samp_dat)

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  library(ggplot2); library(metR)
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)


  #### Example 2: Constrained elliptical_log ####
  ## This fits a constrained elliptical, as in Priebe et al. 2003
  gauss_fit &lt;-
    fit_gaussian_2D(
      samp_dat,
      method = "elliptical_log",
      constrain_orientation = -1
    )

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)
}
</code></pre>

<hr>
<h2 id='rgl_gaussian_2D'>Produce a 3D plot of the 2D-Gaussian via rgl</h2><span id='topic+rgl_gaussian_2D'></span>

<h3>Description</h3>

<p>Produce a 3D plot of the 2D-Gaussian via rgl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgl_gaussian_2D(
  gauss_data,
  normalize = TRUE,
  viridis_dir = 1,
  viridis_opt = "B",
  x_lab = "X values",
  y_lab = "Y values",
  box = FALSE,
  aspect = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgl_gaussian_2D_+3A_gauss_data">gauss_data</code></td>
<td>
<p>Data.frame with X_values, Y_values, and predicted_values,
e.g. exported from <code>predict_gaussian_2D()</code></p>
</td></tr>
<tr><td><code id="rgl_gaussian_2D_+3A_normalize">normalize</code></td>
<td>
<p>Default TRUE, should predicted_values be normalized on a 0
to 1 scale?</p>
</td></tr>
<tr><td><code id="rgl_gaussian_2D_+3A_viridis_dir">viridis_dir</code></td>
<td>
<p>See &quot;direction&quot; in scale_fill_viridis_c()</p>
</td></tr>
<tr><td><code id="rgl_gaussian_2D_+3A_viridis_opt">viridis_opt</code></td>
<td>
<p>See &quot;option&quot; in scale_fill_viridis_c()</p>
</td></tr>
<tr><td><code id="rgl_gaussian_2D_+3A_x_lab">x_lab</code></td>
<td>
<p>Arguments passed to xlab()</p>
</td></tr>
<tr><td><code id="rgl_gaussian_2D_+3A_y_lab">y_lab</code></td>
<td>
<p>Arguments passed to ylab()</p>
</td></tr>
<tr><td><code id="rgl_gaussian_2D_+3A_box">box</code></td>
<td>
<p>Whether to draw a box; see <code>rgl::plot3d()</code></p>
</td></tr>
<tr><td><code id="rgl_gaussian_2D_+3A_aspect">aspect</code></td>
<td>
<p>Whether to adjust the aspect ratio; see <code>rgl::plot3d()</code></p>
</td></tr>
<tr><td><code id="rgl_gaussian_2D_+3A_...">...</code></td>
<td>
<p>Other arguments supplied to <code>rgl::plot3d()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rgl object (i.e. of the class 'rglHighlevel'). See
<code>rgl::plot3d()</code> for details.
</p>


<h3>Author(s)</h3>

<p>Vikram B. Baliga
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  ## Load the sample data set
  data(gaussplot_sample_data)

  ## The raw data we'd like to use are in columns 1:3
  samp_dat &lt;-
    gaussplot_sample_data[,1:3]


  #### Example 1: Unconstrained elliptical ####
  ## This fits an unconstrained elliptical by default
  gauss_fit &lt;-
    fit_gaussian_2D(samp_dat)

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  library(ggplot2); library(metR)
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)


  #### Example 2: Constrained elliptical_log ####
  ## This fits a constrained elliptical, as in Priebe et al. 2003
  gauss_fit &lt;-
    fit_gaussian_2D(
      samp_dat,
      method = "elliptical_log",
      constrain_orientation = -1
    )

  ## Generate a grid of x- and y- values on which to predict
  grid &lt;-
    expand.grid(X_values = seq(from = -5, to = 0, by = 0.1),
                Y_values = seq(from = -1, to = 4, by = 0.1))

  ## Predict the values using predict_gaussian_2D
  gauss_data &lt;-
    predict_gaussian_2D(
      fit_object = gauss_fit,
      X_values = grid$X_values,
      Y_values = grid$Y_values,
    )

  ## Plot via ggplot2 and metR
  ggplot_gaussian_2D(gauss_data)

  ## Produce a 3D plot via rgl
  rgl_gaussian_2D(gauss_data)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
