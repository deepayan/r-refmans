<!DOCTYPE html><html><head><title>Help for package gmvarkit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gmvarkit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_data'><p>Add data to an object of class 'gsmvar' defining a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#all_pos_ints'><p>Check whether all arguments are positive integers</p></a></li>
<li><a href='#alt_gmvar'><p>DEPRECATED! USE THE FUNCTION alt_gsmvar INSTEAD!</p>
Construct a GMVAR model based on results from an arbitrary estimation round of <code>fitGSMVAR</code></a></li>
<li><a href='#alt_gsmvar'><p>Construct a GMVAR, StMVAR, or G-StMVAR model based on results from an arbitrary estimation round of <code>fitGSMVAR</code></p></a></li>
<li><a href='#calc_gradient'><p>Calculate gradient or Hessian matrix</p></a></li>
<li><a href='#change_parametrization'><p>Change parametrization of a parameter vector</p></a></li>
<li><a href='#change_regime'><p>Change regime parameters <strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code></p>
of the given parameter vector</a></li>
<li><a href='#check_constraints'><p>Check the constraint matrix has the correct form</p></a></li>
<li><a href='#check_data'><p>Check the data is in the correct form</p></a></li>
<li><a href='#check_gsmvar'><p>Checks whether the given object has class attribute 'gsmvar'</p></a></li>
<li><a href='#check_null_data'><p>Checks whether the given object contains data</p></a></li>
<li><a href='#check_parameters'><p>Check that the given parameter vector satisfies the model assumptions</p></a></li>
<li><a href='#check_pMd'><p>Check that p, M, and d are correctly set</p></a></li>
<li><a href='#check_same_means'><p>Check whether the parametrization is correct for usage of same means restrictions</p></a></li>
<li><a href='#cond_moment_plot'><p>Conditional mean or variance plot for a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#cond_moments'><p>Compute conditional moments of a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#create_J_matrix'><p>Create a special matrix J</p></a></li>
<li><a href='#diag_Omegas'><p>Simultaneously diagonalize two covariance matrices</p></a></li>
<li><a href='#diagnostic_plot'><p>Quantile residual diagnostic plot for a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#dlogmultinorm'><p>Calculate logarithms of multiple multivariate normal densities with varying</p>
mean and constant covariance matrix</a></li>
<li><a href='#dlogmultistudent'><p>Calculate logarithms of multiple multivariate Student's t densities with varying</p>
mean and covariance matrix of specific structure, but constant degrees of freedom.</a></li>
<li><a href='#estimate_sgsmvar'><p>Maximum likelihood estimation of a structural GMVAR, StMVAR, or G-StMVAR model</p>
with preliminary estimates</a></li>
<li><a href='#euromone'><p>A monthly Euro area data covering the period from January 1999 to December 2021 (276 observations) and consisting four variables:</p>
cyclical component of log industrial production index, the log-difference of harmonized consumer price index, the log-difference
of Brent crude oil prices (Europe), and an interest rate variable. The interest rate variable is the Euro overnight index average
rate (EONIA) from January 1999 to October 2008, and after that the Wu and Xia (2016) shadow rate, which is not constrained by the zero lower
bound and also quantifies unconventional monetary policy measures. The log-difference of the harmonized consumer price index is
multiplied by hundred and the log-difference of oil price by ten. This data is the one that was used in Virolainen (2022).</a></li>
<li><a href='#fitGMVAR'><p>DEPRECATED! USE THE FUNCTION fitGSMVAR INSTEAD! Two-phase maximum likelihood estimation of a GMVAR model</p></a></li>
<li><a href='#fitGSMVAR'><p>Two-phase maximum likelihood estimation of a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#form_boldA'><p>Form the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; matrices related to the VAR processes</p></a></li>
<li><a href='#format_valuef'><p>Function factory for value formatting</p></a></li>
<li><a href='#GAfit'><p>Genetic algorithm for preliminary estimation of a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#gdpdef'><p>U.S. real GDP percent change and GDP implicit price deflator percent change.</p></a></li>
<li><a href='#get_alpha_mt'><p>Get mixing weights alpha_mt (this function is for internal use)</p></a></li>
<li><a href='#get_boldA_eigens'><p>Calculate absolute values of the eigenvalues of the &quot;bold A&quot; matrices containing the AR coefficients</p></a></li>
<li><a href='#get_IC'><p>Calculate AIC, HQIC, and BIC</p></a></li>
<li><a href='#get_minval'><p>Returns the default smallest allowed log-likelihood for given data.</p></a></li>
<li><a href='#get_omega_eigens'><p>Calculate the eigenvalues of the &quot;Omega&quot; error term covariance matrices</p></a></li>
<li><a href='#get_regime_autocovs'><p>Calculate regimewise autocovariance matrices</p></a></li>
<li><a href='#get_regime_autocovs_int'><p>Calculate regimewise autocovariance matrices</p></a></li>
<li><a href='#get_regime_means'><p>Calculate regime means <code class="reqn">\mu_{m}</code></p></a></li>
<li><a href='#get_regime_means_int'><p>Calculate regime means <code class="reqn">\mu_{m}</code></p></a></li>
<li><a href='#get_Sigmas'><p>Calculate the dp-dimensional covariance matrices <code class="reqn">\Sigma_{m,p}</code> in the mixing weights</p>
of the GMVAR, StMVAR, or G-StMVAR model.</a></li>
<li><a href='#get_symmetric_sqrt'><p>Calculate symmetric square root matrix of a positive definite covariance</p>
matrix</a></li>
<li><a href='#get_test_Omega'><p>Compute covariance matrix Omega used in quantile residual tests</p></a></li>
<li><a href='#get_unconstrained_structural_pars'><p>Get structural parameters that indicate there are no constraints</p></a></li>
<li><a href='#get_varying_h'><p>Get differences 'h' which are adjusted for overly large degrees of freedom parameters</p></a></li>
<li><a href='#GFEVD'><p>Estimate generalized forecast error variance decomposition for structural</p>
(and reduced form) GMVAR, StMVAR, and G-StMVAR models.</a></li>
<li><a href='#GIRF'><p>Estimate generalized impulse response function for</p>
structural (and reduced form) GMVAR, StMVAR, and G-StMVAR models.</a></li>
<li><a href='#GMVAR'><p>DEPRECATED! USE THE FUNCTION GSMVAR INSTEAD! Create a class 'gsmvar' object defining</p>
a reduced form or structural GMVAR model</a></li>
<li><a href='#gmvar_to_gsmvar'><p>Makes class 'gmvar' objects compatible with the functions using class 'gsmvar' objects</p></a></li>
<li><a href='#gmvar_to_sgmvar'><p>DEPRECATED! USE THE FUNCTION fitGSMVAR INSTEAD!</p>
Switch from two-regime reduced form GMVAR model to a structural model.</a></li>
<li><a href='#gmvarkit-package'><p>gmvarkit: Estimate Gaussian and Student's t Mixture Vector Autoregressive Models</p></a></li>
<li><a href='#GSMVAR'><p>Create a class 'gsmvar' object defining a reduced form or structural GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#gsmvar_to_sgsmvar'><p>Switch from two-regime reduced form GMVAR, StMVAR, or G-StMVAR model to a structural model.</p></a></li>
<li><a href='#in_paramspace'><p>Determine whether the parameter vector lies in the parameter space</p></a></li>
<li><a href='#in_paramspace_int'><p>Determine whether the parameter vector lies in the parameter space</p></a></li>
<li><a href='#is_stationary'><p>Check the stationary condition of a given GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#iterate_more'><p>Maximum likelihood estimation of a GMVAR, StMVAR, or G-StMVAR model with preliminary estimates</p></a></li>
<li><a href='#linear_IRF'><p>Estimate linear impulse response function based on a single regime of a structural GMVAR,</p>
StMVAR, or G-StMVAR model.</a></li>
<li><a href='#loglikelihood'><p>Compute log-likelihood of a GMVAR, StMVAR, or G-StMVAR model using parameter vector</p></a></li>
<li><a href='#loglikelihood_int'><p>Compute log-likelihood of a GMVAR, StMVAR, and G-StMVAR models</p></a></li>
<li><a href='#LR_test'><p>Perform likelihood ratio test for a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#mat_power'><p>Compute the j:th power of a square matrix A</p></a></li>
<li><a href='#n_params'><p>Calculate the number of parameters in a GMVAR, StMVAR, or G-StMVAR model's parameter vector</p></a></li>
<li><a href='#Pearson_residuals'><p>Calculate multivariate Pearson residuals of a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#pick_all_phi0_A'><p>Pick all <code class="reqn">\phi_{m,0}</code> or <code class="reqn">\mu_{m}</code> and <code class="reqn">A_{m,1},...,A_{m,p}</code> parameter values</p></a></li>
<li><a href='#pick_allA'><p>Pick coefficient all matrices</p></a></li>
<li><a href='#pick_alphas'><p>Pick mixing weight parameters <code class="reqn">\alpha_{m}, m=1,...,M</code></p></a></li>
<li><a href='#pick_Am'><p>Pick coefficient matrices</p></a></li>
<li><a href='#pick_Ami'><p>Pick coefficient matrix</p></a></li>
<li><a href='#pick_df'><p>Pick the degrees of freedom parameters <strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code></p></a></li>
<li><a href='#pick_lambdas'><p>Pick the structural parameters eigenvalue 'lambdas'</p></a></li>
<li><a href='#pick_Omegas'><p>Pick covariance matrices</p></a></li>
<li><a href='#pick_phi0'><p>Pick <code class="reqn">\phi_{m,0}</code> or <code class="reqn">\mu_{m}</code>, m=1,..,M vectors</p></a></li>
<li><a href='#pick_regime'><p>Pick regime parameters <strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m},\nu_{m})</code></p></a></li>
<li><a href='#pick_W'><p>Pick the structural parameter matrix W</p></a></li>
<li><a href='#plot.gmvarpred'><p>plot method for class 'gmvarpred' objects</p></a></li>
<li><a href='#plot.gsmvarpred'><p>plot method for class 'gsmvarpred' objects</p></a></li>
<li><a href='#plot.qrtest'><p>Quantile residual tests</p></a></li>
<li><a href='#predict.gmvar'><p>DEPRECATED! USE THE FUNCTION predict.gsmvar INSTEAD! Predict method for class 'gmvar' objects</p></a></li>
<li><a href='#predict.gsmvar'><p>Predict method for class 'gsmvar' objects</p></a></li>
<li><a href='#print_std_errors'><p>Print standard errors of a GMVAR, StMVAR, or G-StMVAR model in the same form as the model estimates are printed</p></a></li>
<li><a href='#print.gmvar'><p>Deprecated S3 methods for the deprecated class 'gmvar'</p></a></li>
<li><a href='#print.gmvarsum'><p>Summary print method from objects of class 'gmvarsum'</p></a></li>
<li><a href='#print.gsmvarpred'><p>Print method for class 'gsmvarpred' objects</p></a></li>
<li><a href='#print.gsmvarsum'><p>Summary print method from objects of class 'gsmvarsum'</p></a></li>
<li><a href='#print.hypotest'><p>Print method for the class hypotest</p></a></li>
<li><a href='#profile_logliks'><p>Plot profile log-likehoods around the estimates</p></a></li>
<li><a href='#quantile_residuals'><p>Calculate multivariate quantile residuals of a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#quantile_residuals_int'><p>Calculate multivariate quantile residuals of GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#random_coefmats'><p>Create random VAR-model <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code>.</p></a></li>
<li><a href='#random_coefmats2'><p>Create random stationary VAR model <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code>.</p></a></li>
<li><a href='#random_covmat'><p>Create random VAR model error term covariance matrix</p></a></li>
<li><a href='#random_df'><p>Create random degrees of freedom parameter values</p></a></li>
<li><a href='#random_ind'><p>Create random mean-parametrized parameter vector of a GMVAR, StMVAR, or G-StMVAR model that may not be stationary</p></a></li>
<li><a href='#random_ind2'><p>Create somewhat random parameter vector of a GMVAR, StMVAR, or G-StMVAR model that is always stationary</p></a></li>
<li><a href='#Rao_test'><p>Perform Rao's score test for a GSMVAR model</p></a></li>
<li><a href='#redecompose_Omegas'><p>In the decomposition of the covariance matrices (Muirhead, 1982, Theorem A9.9), change</p>
the order of the covariance matrices.</a></li>
<li><a href='#reform_constrained_pars'><p>Reform constrained parameter vector into the &quot;standard&quot; form</p></a></li>
<li><a href='#reform_data'><p>Reform data</p></a></li>
<li><a href='#reform_structural_pars'><p>Reform structural parameter vector into the &quot;standard&quot; form</p></a></li>
<li><a href='#regime_distance'><p>Calculate &quot;distance&quot; between two (scaled) regimes</p>
<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code></a></li>
<li><a href='#reorder_W_columns'><p>Reorder columns of the W-matrix and lambda parameters of a structural GMVAR, StMVAR, or G-StMVAR model.</p></a></li>
<li><a href='#simulate.gsmvar'><p>Simulate method for class 'gsmvar' objects</p></a></li>
<li><a href='#simulateGMVAR'><p>DEPRECATED! USE THE FUNCTION simulate.gsmvar INSTEAD! Simulate from GMVAR process</p></a></li>
<li><a href='#smart_covmat'><p>Create random VAR-model <code class="reqn">(dxd)</code> error term covariance matrix <code class="reqn">\Omega</code></p>
fairly close to a given <strong>positive definite</strong> covariance matrix using (scaled)
Wishart distribution</a></li>
<li><a href='#smart_df'><p>Create random degrees of freedom parameter values close to given values</p></a></li>
<li><a href='#smart_ind'><p>Create random parameter vector of a GMVAR, StMVAR, or G-StMVAR model fairly close to a given</p>
parameter vector</a></li>
<li><a href='#sort_and_standardize_alphas'><p>Sort mixing weight parameters in a decreasing order and standardize them</p>
to sum to one. For G-StMVAR models, the mixing weight parameters are sorted
to a decreasing order for GMVAR and StMVAR type regimes separately.</a></li>
<li><a href='#sort_components'><p>Sort components in parameter vector according to mixing weights into a decreasing order</p></a></li>
<li><a href='#sort_W_and_lambdas'><p>Sort the columns of W matrix by sorting the lambda parameters of the second regime to increasing order</p></a></li>
<li><a href='#standard_errors'><p>Calculate standard errors for estimates of a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#stmvar_to_gstmvar'><p>Estimate a G-StMVAR model based on a StMVAR model that has large degrees of freedom parameters</p></a></li>
<li><a href='#stmvarpars_to_gstmvar'><p>Transform a StMVAR (or G-StMVAR) model parameter vector to the corresponding G-StMVAR model parameter vector</p>
with the large df parameters removed.</a></li>
<li><a href='#swap_parametrization'><p>Swap the parametrization of a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#swap_W_signs'><p>Swap all signs in pointed columns a the <code class="reqn">W</code> matrix of a structural GMVAR, StMVAR, or G-StMVAR model.</p></a></li>
<li><a href='#uncond_moments'><p>Calculate the unconditional mean, variance, the first p autocovariances, and the first p autocorrelations</p>
of a GMVAR, StMVAR, or G-StMVAR process</a></li>
<li><a href='#uncond_moments_int'><p>Calculate the unconditional mean, variance, the first p autocovariances, and the first p autocorrelations</p>
of a GMVAR, StMVAR, or G-StMVAR process</a></li>
<li><a href='#unvec'><p>Reverse vectorization operator</p></a></li>
<li><a href='#unvech'><p>Reverse operator of the parsimonious vectorization operator <code>vech</code></p></a></li>
<li><a href='#unWvec'><p>Reverse vectorization operator that restores zeros</p></a></li>
<li><a href='#update_numtols'><p>Update the stationarity and positive definiteness numerical tolerances of an</p>
existing class 'gsmvar' model.</a></li>
<li><a href='#usamon'><p>A quarterly U.S. data covering the period from 1954Q3 to 2021Q4 (270 observations) and consisting four variables:</p>
the log-difference of real GDP, the log-difference of GDP implicit price deflator, the log-difference of producer
price index (all commodities), and an interest rate variable. The interest rate variable is the effective federal funds
rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate, which is not constrained by the zero lower
bound and also quantifies unconventional monetary policy measures. The log-differences of the GDP, GDP deflator,
and producer price index are multiplied by hundred. This data is used in Virolainen (forthcoming).</a></li>
<li><a href='#usamone'><p>A quarterly U.S. data covering the period from 1954Q3 to 2021Q4 (270 observations) and consisting four variables:</p>
cyclical component of the log of real GDP, the log-difference of GDP implicit price deflator, the log-difference of producer
price index (all commodities), and an interest rate variable. The interest rate variable is the effective federal funds
rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate, which is not constrained by the zero lower
bound and also quantifies unconventional monetary policy measures. The log-differences of the GDP deflator and producer price
index are multiplied by hundred.</a></li>
<li><a href='#VAR_pcovmat'><p>Calculate the dp-dimensional covariance matrix of p consecutive</p>
observations of a VAR process</a></li>
<li><a href='#vec'><p>Vectorization operator</p></a></li>
<li><a href='#vech'><p>Parsimonious vectorization operator for symmetric matrices</p></a></li>
<li><a href='#Wald_test'><p>Perform Wald test for a GMVAR, StMVAR, or G-StMVAR model</p></a></li>
<li><a href='#warn_df'><p>Warn about large degrees of freedom parameter values</p></a></li>
<li><a href='#warn_eigens'><p>Warn about near-unit-roots in some regimes</p></a></li>
<li><a href='#Wvec'><p>Vectorization operator that removes zeros</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimate Gaussian and Student's t Mixture Vector Autoregressive
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Unconstrained and constrained maximum likelihood estimation of structural and reduced form 
    Gaussian mixture vector autoregressive, Student's t mixture vector autoregressive, and Gaussian and Student's t
    mixture vector autoregressive models, quantile residual tests, graphical diagnostics,
    simulations, forecasting, and estimation of generalized impulse response function and generalized 
    forecast error variance decomposition.
    Leena Kalliovirta, Mika Meitz, Pentti Saikkonen (2016) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2016.02.012">doi:10.1016/j.jeconom.2016.02.012</a>&gt;,
    Savi Virolainen (forthcoming) &lt;<a href="https://doi.org/10.1080%2F07350015.2024.2322090">doi:10.1080/07350015.2024.2322090</a>&gt;,
    Savi Virolainen (2022) &lt;<a href="https://arxiv.org/abs/2109.13648">arXiv:2109.13648</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/saviviro/gmvarkit/issues">https://github.com/saviviro/gmvarkit/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>Brobdingnag (&ge; 1.2-4), mvnfast (&ge; 0.2.5), parallel (&ge;
3.0.0), stats (&ge; 3.0.0), pbapply (&ge; 1.4-2), graphics (&ge;
3.0.0), grDevices (&ge; 3.0.0), gsl (&ge; 2.1-6), methods (&ge;
3.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 15:27:53 UTC; savi</td>
</tr>
<tr>
<td>Author:</td>
<td>Savi Virolainen [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Savi Virolainen &lt;savi.virolainen@helsinki.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 16:12:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_data'>Add data to an object of class 'gsmvar' defining a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+add_data'></span>

<h3>Description</h3>

<p><code>add_data</code> adds or updates data to object of class '<code>gsmvar</code>' that defines
a GMVAR, StMVAR, or G-StMVAR model. Also calculates mixing weights and quantile residuals accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_data(data, gsmvar, calc_cond_moments = TRUE, calc_std_errors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_data_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="add_data_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="add_data_+3A_calc_cond_moments">calc_cond_moments</code></td>
<td>
<p>should conditional means and covariance matrices should be calculated?
Default is <code>TRUE</code> if the model contains data and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="add_data_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class 'gsmvar' defining the specified GSMVAR, StMVAR, or G-StMVAR model with the data added to the model.
If the object already contained data, the data will be updated.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+update_numtols">update_numtols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(1, 2), d=2 model:
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005,
  0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012,
  0.136, 0.674)
mod12 &lt;- GSMVAR(p=1, M=2, d=2, params=params12)
mod12

mod12_2 &lt;- add_data(gdpdef, mod12)
mod12_2

# StMVAR(1, 2), d=2 model:
mod12t &lt;- GSMVAR(p=1, M=2, d=2, params=c(params12, 10, 12), model="StMVAR")
mod12t
mod12t_2 &lt;- add_data(gdpdef, mod12t)
mod12t_2

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
  0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
  0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(p=2, M=2, d=2, params=params22s, structural_pars=list(W=W_22))
mod22s

mod22s_2 &lt;- add_data(gdpdef, mod22s)
mod22s_2
</code></pre>

<hr>
<h2 id='all_pos_ints'>Check whether all arguments are positive integers</h2><span id='topic+all_pos_ints'></span>

<h3>Description</h3>

<p><code>all_pos_ints</code> checks whether all the elements in a vector
are positive integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_pos_ints(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_pos_ints_+3A_x">x</code></td>
<td>
<p>a vector containing the elements to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> or <code>FALSE</code> accordingly.
</p>

<hr>
<h2 id='alt_gmvar'>DEPRECATED! USE THE FUNCTION alt_gsmvar INSTEAD!
Construct a GMVAR model based on results from an arbitrary estimation round of <code>fitGSMVAR</code></h2><span id='topic+alt_gmvar'></span>

<h3>Description</h3>

<p>DEPRECATED! USE THE FUNCTION alt_gsmvar INSTEAD! <code>alt_gsmvar</code> constructs
a GMVAR model based on results from an arbitrary estimation round of <code>fitGSMVAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alt_gmvar(
  gmvar,
  which_round = 1,
  which_largest,
  calc_cond_moments = TRUE,
  calc_std_errors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alt_gmvar_+3A_gmvar">gmvar</code></td>
<td>
<p>object of class 'gmvar'</p>
</td></tr>
<tr><td><code id="alt_gmvar_+3A_which_round">which_round</code></td>
<td>
<p>based on which estimation round should the model be constructed? An integer value in 1,...,<code>ncalls</code>.</p>
</td></tr>
<tr><td><code id="alt_gmvar_+3A_which_largest">which_largest</code></td>
<td>
<p>based on estimation round with which largest log-likelihood should the model be constructed?
An integer value in 1,...,<code>ncalls</code>. For example, <code>which_largest=2</code> would take the second largest log-likelihood
and construct the model based on the corresponding estimates. If used, then <code>which_round</code> is ignored.</p>
</td></tr>
<tr><td><code id="alt_gmvar_+3A_calc_cond_moments">calc_cond_moments</code></td>
<td>
<p>should conditional means and covariance matrices should be calculated?
Default is <code>TRUE</code> if the model contains data and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="alt_gmvar_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's sometimes useful to examine other estimates than the one with the highest log-likelihood. This function
is wrapper around <code>GSMVAR</code> that picks the correct estimates from an object returned by <code>fitGSMVAR</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the specified reduced form or structural GMVAR,
StMVAR, or G-StMVAR model. Can be used to work with other functions provided in <code>gmvarkit</code>.
</p>
<p>Note that the first autocovariance/correlation matrix in <code>$uncond_moments</code> is for the lag zero,
the second one for the lag one, etc.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+alt_gsmvar">alt_gsmvar</a></code>
</p>

<hr>
<h2 id='alt_gsmvar'>Construct a GMVAR, StMVAR, or G-StMVAR model based on results from an arbitrary estimation round of <code>fitGSMVAR</code></h2><span id='topic+alt_gsmvar'></span>

<h3>Description</h3>

<p><code>alt_gsmvar</code> constructs a GMVAR, StMVAR, or G-StMVAR model based on results from
an arbitrary estimation round of <code>fitGSMVAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alt_gsmvar(
  gsmvar,
  which_round = 1,
  which_largest,
  calc_cond_moments = TRUE,
  calc_std_errors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alt_gsmvar_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="alt_gsmvar_+3A_which_round">which_round</code></td>
<td>
<p>based on which estimation round should the model be constructed? An integer value in 1,...,<code>ncalls</code>.</p>
</td></tr>
<tr><td><code id="alt_gsmvar_+3A_which_largest">which_largest</code></td>
<td>
<p>based on estimation round with which largest log-likelihood should the model be constructed?
An integer value in 1,...,<code>ncalls</code>. For example, <code>which_largest=2</code> would take the second largest log-likelihood
and construct the model based on the corresponding estimates. If used, then <code>which_round</code> is ignored.</p>
</td></tr>
<tr><td><code id="alt_gsmvar_+3A_calc_cond_moments">calc_cond_moments</code></td>
<td>
<p>should conditional means and covariance matrices should be calculated?
Default is <code>TRUE</code> if the model contains data and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="alt_gsmvar_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's sometimes useful to examine other estimates than the one with the highest log-likelihood. This function
is wrapper around <code>GSMVAR</code> that picks the correct estimates from an object returned by <code>fitGSMVAR</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the specified reduced form or structural GMVAR,
StMVAR, or G-StMVAR model. Can be used to work with other functions provided in <code>gmvarkit</code>.
</p>
<p>Note that the first autocovariance/correlation matrix in <code>$uncond_moments</code> is for the lag zero,
the second one for the lag one, etc.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+update_numtols">update_numtols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMVAR(1,2) model
fit12 &lt;- fitGSMVAR(gdpdef, p=1, M=2, ncalls=2, seeds=4:5)
fit12
fit12_2 &lt;- alt_gsmvar(fit12, which_largest=2)
fit12_2

</code></pre>

<hr>
<h2 id='calc_gradient'>Calculate gradient or Hessian matrix</h2><span id='topic+calc_gradient'></span><span id='topic+calc_hessian'></span><span id='topic+get_gradient'></span><span id='topic+get_hessian'></span><span id='topic+get_foc'></span><span id='topic+get_soc'></span>

<h3>Description</h3>

<p><code>calc_gradient</code> or <code>calc_hessian</code> calculates the gradient or Hessian matrix
of the given function at the given point using central difference numerical approximation.
<code>get_gradient</code> or <code>get_hessian</code> calculates the gradient or Hessian matrix of the
log-likelihood function at the parameter estimates of a class <code>'gsmvar'</code> object. <code>get_soc</code>
returns eigenvalues of the Hessian matrix, and <code>get_foc</code> is the same as <code>get_gradient</code>
but named conveniently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_gradient(x, fn, h = 6e-06, varying_h = NULL, ...)

calc_hessian(x, fn, h = 6e-06, varying_h = NULL, ...)

get_gradient(gsmvar, custom_h = NULL)

get_hessian(gsmvar, custom_h = NULL)

get_foc(gsmvar, custom_h = NULL)

get_soc(gsmvar, custom_h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_gradient_+3A_x">x</code></td>
<td>
<p>a numeric vector specifying the point where the gradient or Hessian should be calculated.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_fn">fn</code></td>
<td>
<p>a function that takes in argument <code>x</code> as the <strong>first</strong> argument.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_h">h</code></td>
<td>
<p>difference used to approximate the derivatives.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_varying_h">varying_h</code></td>
<td>
<p>a numeric vector with the same length as <code>x</code> specifying the difference <code>h</code>
for each dimension separately. If <code>NULL</code> (default), then the difference given as parameter <code>h</code>
will be used for all dimensions.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>fn</code></p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_custom_h">custom_h</code></td>
<td>
<p>same as <code>varying_h</code> except thaqt if <code>NULL</code> (default), then the difference used
for differentiating overly large degrees of freedom parameters is adjusted to avoid numerical problems,
and the difference <code>6e-6</code> is used for the other parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In particular, the functions <code>get_foc</code> and <code>get_soc</code> can be used to check whether
the found estimates denote a (local) maximum point, a saddle point, or something else. Note that
profile log-likelihood functions can be conveniently plotted with the function <code>profile_logliks</code>.
</p>


<h3>Value</h3>

<p>Gradient functions return numerical approximation of the gradient and Hessian functions return
numerical approximation of the Hessian. <code>get_soc</code> returns eigenvalues of the Hessian matrix.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Simple function
  foo &lt;- function(x) x^2 + x
  calc_gradient(x=1, fn=foo)
  calc_gradient(x=-0.5, fn=foo)

  # More complicated function
  foo &lt;- function(x, a, b) a*x[1]^2 - b*x[2]^2
  calc_gradient(x=c(1, 2), fn=foo, a=0.3, b=0.1)

  
  # GMVAR(1,2), d=2 model:
  params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005,
   0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012,
   0.136, 0.674)
  mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)
  get_gradient(mod12)
  get_hessian(mod12)
  get_soc(mod12)
  
</code></pre>

<hr>
<h2 id='change_parametrization'>Change parametrization of a parameter vector</h2><span id='topic+change_parametrization'></span>

<h3>Description</h3>

<p><code>change_parametrization</code> changes the parametrization of the given parameter
vector to <code>change_to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_parametrization(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  change_to = c("intercept", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_parametrization_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="change_parametrization_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_change_to">change_to</code></td>
<td>
<p>either &quot;intercept&quot; or &quot;mean&quot; specifying to which parametrization it should be switched to.
If set to <code>"intercept"</code>, it's assumed that <code>params</code> is mean-parametrized, and if set to <code>"mean"</code>
it's assumed that <code>params</code> is intercept-parametrized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parametrization cannot be changed for models with same_means constraints!
</p>


<h3>Value</h3>

<p>Returns parameter vector described in <code>params</code>, but with parametrization changed from intercept to mean
(when <code>change_to==mean</code>) or from mean to intercept (when <code>change_to==intercept</code>).
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='change_regime'>Change regime parameters <strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code>
of the given parameter vector</h2><span id='topic+change_regime'></span>

<h3>Description</h3>

<p><code>change_regime</code> changes the regime parameters (excluding mixing weights parameter)
of the pointed regime to the new given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_regime(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  m,
  regime_pars,
  structural_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_regime_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="change_regime_+3A_d">d</code></td>
<td>
<p>number of time series in the system, i.e. the dimension.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_m">m</code></td>
<td>
<p>which component?</p>
</td></tr>
<tr><td><code id="change_regime_+3A_regime_pars">regime_pars</code></td>
<td>

<dl>
<dt>For reduced form models:</dt><dd><p>a size <code class="reqn">((pd^2+d+d(d+1)/2)x1)</code> vector
(<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">,\nu_m</code>)<code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m},\nu_m)</code>.</p>
</dd>
<dt>For structural models:</dt><dd><p>a length <code class="reqn">pd^2 + d</code> vector <code class="reqn">(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\nu_m)</code>.</p>
</dd>
</dl>
<p>In the case of a GMVAR type regime, <code class="reqn">\nu_m</code> is omitted.
</p>
</td></tr>
<tr><td><code id="change_regime_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not currently support models with AR, mean, alpha, or lambda parameter constraints.
</p>


<h3>Value</h3>

<p>Returns parameter vector with <code>m</code>:th regime changed to <code>regime_pars</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='check_constraints'>Check the constraint matrix has the correct form</h2><span id='topic+check_constraints'></span>

<h3>Description</h3>

<p><code>check_constraints</code> checks that the constraints are correctly set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_constraints(
  p,
  M,
  d,
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_constraints_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_constraints_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="check_constraints_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="check_constraints_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Checks the constraints and throws an error
if something is wrong.
</p>

<hr>
<h2 id='check_data'>Check the data is in the correct form</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p><code>check_data</code> checks the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(data, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="check_data_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Checks the data and tries to correct it. Throws an error if something is wrong and
returns the corrected data otherwise.
</p>

<hr>
<h2 id='check_gsmvar'>Checks whether the given object has class attribute 'gsmvar'</h2><span id='topic+check_gsmvar'></span>

<h3>Description</h3>

<p><code>check_gsmvar</code> checks that the object has class attribute 'gsmvar'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_gsmvar(object, object_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_gsmvar_+3A_object">object</code></td>
<td>
<p>S3 object to be tested</p>
</td></tr>
<tr><td><code id="check_gsmvar_+3A_object_name">object_name</code></td>
<td>
<p>what is the name of the object that should of class 'gsmvar'?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an error if the object doesn't have the class attribute 'gsmvar'.
</p>

<hr>
<h2 id='check_null_data'>Checks whether the given object contains data</h2><span id='topic+check_null_data'></span>

<h3>Description</h3>

<p><code>check_null_data</code> checks that the gsmvar object has data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_null_data(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_null_data_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an error if is.null(gsmvar$data).
</p>

<hr>
<h2 id='check_parameters'>Check that the given parameter vector satisfies the model assumptions</h2><span id='topic+check_parameters'></span>

<h3>Description</h3>

<p><code>check_parameters</code> checks whether the given parameter vector satisfies
the model assumptions. Does NOT consider the identifiability condition!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_parameters(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_parameters_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_parameters_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="check_parameters_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="check_parameters_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an informative error if there is something wrong with the parameter vector.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# These examples will cause an informative error

# GMVAR(1, 1), d=2 model:
params11 &lt;- c(1.07, 127.71, 0.99, 0.00, -0.01, 1.00, 4.05,
  2.22, 8.87)
check_parameters(p=1, M=1, d=2, params=params11)

# GMVAR(2, 2), d=2 model:
params22 &lt;- c(1.39, -0.77, 1.31, 0.14, 0.09, 1.29, -0.39,
 -0.07, -0.11, -0.28, 0.92, -0.03, 4.84, 1.01, 5.93, 1.25,
  0.08, -0.04, 1.27, -0.27, -0.07, 0.03, -0.31, 5.85, 10.57,
  9.84, 0.74)
check_parameters(p=2, M=2, d=2, params=params22)

# GMVAR(2, 2), d=2 model with AR-parameters restricted to be
# the same for both regimes:
C_mat &lt;- rbind(diag(2*2^2), diag(2*2^2))
params222c &lt;- c(1.03, 2.36, 1.79, 3.00, 1.25, 0.06,0.04,
 1.34, -0.29, -0.08, -0.05, -0.36, 0.93, -0.15, 5.20,
 5.88, 3.56, 9.80, 1.37)
check_parameters(p=2, M=2, d=2, params=params22c, constraints=C_mat)

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints
# (no error):
params22s &lt;- c(1.03, 2.36, 1.79, 3, 1.25, 0.06, 0.04, 1.34, -0.29,
 -0.08, -0.05, -0.36, 1.2, 0.05, 0.05, 1.3, -0.3, -0.1, -0.05, -0.4,
  0.89, 0.72, -0.37, 2.16, 7.16, 1.3, 0.37)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
check_parameters(p=2, M=2, d=2, params=params22s,
 structural_pars=list(W=W_22))

## End(Not run)
</code></pre>

<hr>
<h2 id='check_pMd'>Check that p, M, and d are correctly set</h2><span id='topic+check_pMd'></span>

<h3>Description</h3>

<p><code>check_pMd</code> checks the arguments p, M, and d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pMd(p, M, d, model = c("GMVAR", "StMVAR", "G-StMVAR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pMd_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="check_pMd_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_pMd_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an error if something is wrong.
</p>

<hr>
<h2 id='check_same_means'>Check whether the parametrization is correct for usage of same means restrictions</h2><span id='topic+check_same_means'></span>

<h3>Description</h3>

<p><code>check_same_means</code> checks whether the parametrization is correct for
usage of same means restrictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_same_means(parametrization, same_means)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_same_means_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="check_same_means_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an error if parametrization type is not &quot;mean&quot; and means are constrained
</p>

<hr>
<h2 id='cond_moment_plot'>Conditional mean or variance plot for a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+cond_moment_plot'></span>

<h3>Description</h3>

<p><code>cond_moment_plot</code> plots the one-step in-sample conditional means/variances of the model along with
the individual time series contained in the model (e.g. the time series the model was fitted to). Also plots
the regimewise conditional means/variances multiplied with mixing weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_moment_plot(
  gsmvar,
  which_moment = c("mean", "variance"),
  grid = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_moment_plot_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="cond_moment_plot_+3A_which_moment">which_moment</code></td>
<td>
<p>should conditional means or variances be plotted?</p>
</td></tr>
<tr><td><code id="cond_moment_plot_+3A_grid">grid</code></td>
<td>
<p>add grid to the plots?</p>
</td></tr>
<tr><td><code id="cond_moment_plot_+3A_...">...</code></td>
<td>
<p>additional paramters passed to <code>grid(...)</code> plotting the grid if <code>grid == TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional mean plot works best if the data contains positive values only.
<code>acf</code> from the package <code>stats</code> and the plot method for class <code>'acf'</code> objects is employed.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>,
<code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>,
<code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(2, 2), d=2 model;
params22 &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22)
cond_moment_plot(mod22, which_moment="mean")
cond_moment_plot(mod22, which_moment="variance")
cond_moment_plot(mod22, which_moment="mean", grid=TRUE, lty=3)

# G-StMVAR(2, 1, 1), d=2 model:
params22gs &lt;- c(0.697, 0.154, 0.049, 0.374, 0.476, 0.318, -0.645, -0.302,
 -0.222, 0.193, 0.042, -0.013, 0.048, 0.554, 0.033, 0.184, 0.005, -0.186,
  0.683, 0.256, 0.031, 0.026, 0.204, 0.583, -0.002, 0.048, 0.182, 4.334)
mod22gs &lt;- GSMVAR(gdpdef, p=2, M=c(1, 1), params=params22gs, model="G-StMVAR")
cond_moment_plot(mod22gs, which_moment="mean")
cond_moment_plot(mod22gs, which_moment="variance")

#StMVAR(4, 1), d=2 model:
params41t &lt;- c(0.512, -0.002, 0.243, 0.024, -0.088, 0.452, 0.242, 0.011,
  0.093, 0.162, -0.097, 0.033, -0.339, 0.19, 0.091, 0.006, 0.168, 0.101,
  0.516, -0.005, 0.054, 4.417)
mod41t &lt;- GSMVAR(gdpdef, p=4, M=1, params=params41t, model="StMVAR")
cond_moment_plot(mod41t, which_moment="mean")
cond_moment_plot(mod41t, which_moment="variance")
</code></pre>

<hr>
<h2 id='cond_moments'>Compute conditional moments of a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+cond_moments'></span>

<h3>Description</h3>

<p><code>cond_moments</code> compute conditional regimewise means, conditional means, and conditional covariance matrices
of a GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_moments(
  data,
  p,
  M,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  to_return = c("regime_cmeans", "regime_ccovs", "total_cmeans", "total_ccovs",
    "arch_scalars"),
  minval = NA,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_moments_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cond_moments_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="cond_moments_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_to_return">to_return</code></td>
<td>
<p>should the regimewise conditional means, total conditional means, or total conditional covariance matrices
be returned?</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_minval">minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first p values are used as the initial values, and by conditional we mean conditioning on the past. Formulas
for the conditional means and covariance matrices are given in equations (3) and (4) of KMS (2016).
</p>


<h3>Value</h3>


<dl>
<dt>If <code>to_return=="regime_cmeans"</code>:</dt><dd><p>an <code>[T-p, d, M]</code> array containing the regimewise conditional means
(the first p values are used as the initial values).</p>
</dd>
<dt>If <code>to_return=="regime_ccovs"</code>:</dt><dd><p>an <code>[d, d, T-p, M]</code> array containing the regimewise conditional
covariance matrices (the first p values are used as the initial values). The index <code>[ , , t, m]</code> gives the time
<code>t</code> conditional covariance matrix for the regime <code>m</code>.</p>
</dd>
<dt>If <code>to_return=="total_cmeans"</code>:</dt><dd><p>a <code>[T-p, d]</code> matrix containing the conditional means of the process
(the first p values are used as the initial values).</p>
</dd>
<dt>If <code>to_return=="total_ccov"</code>:</dt><dd><p>an <code>[d, d, T-p]</code> array containing the conditional covariance matrices of the process
(the first p values are used as the initial values).</p>
</dd>
<dt>If <code>to_return=="arch_scalars"</code>:</dt><dd><p>a <code>[T-p, M]</code> matrix containing the regimewise arch scalars
multiplying error term covariance matrix in the conditional covariance matrix of the regime. For GMVAR type regimes, these
are all ones (the first p values are used as the initial values).</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other moment functions: 
<code><a href="#topic+get_regime_autocovs">get_regime_autocovs</a>()</code>,
<code><a href="#topic+get_regime_means">get_regime_means</a>()</code>,
<code><a href="#topic+uncond_moments">uncond_moments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(2, 2), d=2 model;
params22 &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
cond_moments(data=gdpdef, p=2, M=2, params=params22, to_return="regime_cmeans")
cond_moments(data=gdpdef, p=2, M=2, params=params22, to_return="total_cmeans")
cond_moments(data=gdpdef, p=2, M=2, params=params22, to_return="total_ccovs")
</code></pre>

<hr>
<h2 id='create_J_matrix'>Create a special matrix J</h2><span id='topic+create_J_matrix'></span>

<h3>Description</h3>

<p><code>create_J_matrix</code> generates a d x dp matrix J, where the first d x d block is the identity matrix I_d,
and the rest is filled with zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_J_matrix(d, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_J_matrix_+3A_d">d</code></td>
<td>
<p>An integer representing the dimension of the identity matrix.</p>
</td></tr>
<tr><td><code id="create_J_matrix_+3A_p">p</code></td>
<td>
<p>An integer representing the factor by which to extend the matrix with zeros.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">d x dp</code> matrix <code class="reqn">J</code> where the first <code class="reqn">d x d</code> block is the identity matrix <code class="reqn">I_d</code>,
and the rest is filled with zeros.
</p>

<hr>
<h2 id='diag_Omegas'>Simultaneously diagonalize two covariance matrices</h2><span id='topic+diag_Omegas'></span>

<h3>Description</h3>

<p><code>diag_Omegas</code> Simultaneously diagonalizes two covariance matrices using
eigenvalue decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_Omegas(Omega1, Omega2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_Omegas_+3A_omega1">Omega1</code></td>
<td>
<p>a positive definite <code class="reqn">(dxd)</code> covariance matrix <code class="reqn">(d&gt;1)</code></p>
</td></tr>
<tr><td><code id="diag_Omegas_+3A_omega2">Omega2</code></td>
<td>
<p>another positive definite <code class="reqn">(dxd)</code> covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the return value and Muirhead (1982), Theorem A9.9 for details.
</p>


<h3>Value</h3>

<p>Returns a length <code class="reqn">d^2 + d</code> vector where the first <code class="reqn">d^2</code> elements
are <code class="reqn">vec(W)</code> with the columns of <code class="reqn">W</code> being (specific) eigenvectors of
the matrix <code class="reqn">\Omega_2\Omega_1^{-1}</code> and the rest <code class="reqn">d</code> elements are the
corresponding eigenvalues &quot;lambdas&quot;. The result satisfies <code class="reqn">WW' = Omega1</code> and
<code class="reqn">Wdiag(lambdas)W' = Omega2</code>.
</p>
<p>If <code>Omega2</code> is not supplied, returns a vectorized symmetric (and pos. def.)
square root matrix of <code>Omega1</code>.
</p>


<h3>Warning</h3>

<p>No argument checks! Does not work with dimension <code class="reqn">d=1</code>!
</p>


<h3>References</h3>


<ul>
<li><p> Muirhead R.J. 1982. Aspects of Multivariate Statistical Theory, <em>Wiley</em>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 2
W0 &lt;- matrix(1:(d^2), nrow=2)
lambdas0 &lt;- 1:d
(Omg1 &lt;- W0%*%t(W0))
(Omg2 &lt;- W0%*%diag(lambdas0)%*%t(W0))
res &lt;- diag_Omegas(Omg1, Omg2)
W &lt;- matrix(res[1:(d^2)], nrow=d, byrow=FALSE)
tcrossprod(W) # == Omg1
lambdas &lt;- res[(d^2 + 1):(d^2 + d)]
W%*%diag(lambdas)%*%t(W) # == Omg2
</code></pre>

<hr>
<h2 id='diagnostic_plot'>Quantile residual diagnostic plot for a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+diagnostic_plot'></span>

<h3>Description</h3>

<p><code>diagnostic_plot</code> plots a multivariate quantile residual diagnostic plot
for either autocorrelation, conditional heteroskedasticity, or normality, or simply draws
the quantile residual time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic_plot(
  gsmvar,
  type = c("all", "series", "ac", "ch", "norm"),
  maxlag = 12,
  wait_time = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic_plot_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="diagnostic_plot_+3A_type">type</code></td>
<td>
<p>which type of diagnostic plot should be plotted?
</p>

<ul>
<li><p><code>"all"</code> all below sequentially.
</p>
</li>
<li><p><code>"series"</code> the quantile residual time series.
</p>
</li>
<li><p><code>"ac"</code> the quantile residual autocorrelation and cross-correlation functions.
</p>
</li>
<li><p><code>"ch"</code> the squared quantile residual autocorrelation and cross-correlation functions.
</p>
</li>
<li><p><code>"norm"</code> the quantile residual histogram with theoretical standard normal
density (dashed line) and standard normal QQ-plots.
</p>
</li></ul>
</td></tr>
<tr><td><code id="diagnostic_plot_+3A_maxlag">maxlag</code></td>
<td>
<p>the maximum lag considered in types <code>"ac"</code> and <code>"ch"</code>.</p>
</td></tr>
<tr><td><code id="diagnostic_plot_+3A_wait_time">wait_time</code></td>
<td>
<p>if <code>type == all</code> how many seconds to wait before showing next figure?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Auto- and cross-correlations (types <code>"ac"</code> and <code>"ch"</code>) are calculated with the function
<code>acf</code> from the package <code>stats</code> and the plot method for class <code>'acf'</code> objects is employed.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>,
<code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+Rao_test">Rao_test</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>, <code><a href="stats.html#topic+acf">acf</a></code>,
<code><a href="stats.html#topic+density">density</a></code>, <code><a href="#topic+predict.gsmvar">predict.gsmvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(1,2), d=2 model:
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319,
 0.005, 0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185,
 -0.012, 0.136, 0.674)
mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)
diagnostic_plot(mod12, type="series")
diagnostic_plot(mod12, type="ac")

# GMVAR(2,2), d=2 model:
params22 &lt;-  c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406,
 -0.005, 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218,
 0.02, -0.119, 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004,
  0.105, 0.58)
mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22)
diagnostic_plot(mod22, type="ch")
diagnostic_plot(mod22, type="norm")

# G-StMVAR(2, 1, 1), d=2 model:
params22gs &lt;- c(0.697, 0.154, 0.049, 0.374, 0.476, 0.318, -0.645, -0.302,
 -0.222, 0.193, 0.042, -0.013, 0.048, 0.554, 0.033, 0.184, 0.005, -0.186,
  0.683, 0.256, 0.031, 0.026, 0.204, 0.583, -0.002, 0.048, 0.182, 4.334)
mod22gs &lt;- GSMVAR(gdpdef, p=2, M=c(1, 1), params=params22gs, model="G-StMVAR")
diagnostic_plot(mod22gs, wait_time=0)
</code></pre>

<hr>
<h2 id='dlogmultinorm'>Calculate logarithms of multiple multivariate normal densities with varying
mean and constant covariance matrix</h2><span id='topic+dlogmultinorm'></span>

<h3>Description</h3>

<p><code>dlogmultinorm</code> calculates logarithms of multiple multivariate normal
densities with varying mean and constant covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlogmultinorm(y, mu, inv_Omega, log_det_Omega)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlogmultinorm_+3A_y">y</code></td>
<td>
<p>dimension <code class="reqn">(T x k)</code> matrix where each row is a k-dimensional vector</p>
</td></tr>
<tr><td><code id="dlogmultinorm_+3A_mu">mu</code></td>
<td>
<p>dimension <code class="reqn">(T x k)</code> matrix where each row is the mean of the k-dimensional
vector in corresponding row of <code>y</code>.</p>
</td></tr>
<tr><td><code id="dlogmultinorm_+3A_inv_omega">inv_Omega</code></td>
<td>
<p>inverse of the <code class="reqn">(k x k)</code> covariance matrix Omega.</p>
</td></tr>
<tr><td><code id="dlogmultinorm_+3A_log_det_omega">log_det_Omega</code></td>
<td>
<p>logarithm of the determinant of the covariance matrix Omega.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a size <code class="reqn">(T x 1)</code> vector containing the multinormal densities in logarithm.
</p>

<hr>
<h2 id='dlogmultistudent'>Calculate logarithms of multiple multivariate Student's t densities with varying
mean and covariance matrix of specific structure, but constant degrees of freedom.</h2><span id='topic+dlogmultistudent'></span>

<h3>Description</h3>

<p><code>dlogmultistudent</code> calculates logarithms of multiple multivariate
Student's t densities with varying mean and covaraince matrix of specific structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlogmultistudent(y, mu, inv_Omega, log_det_Omega, arch_scalars, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlogmultistudent_+3A_y">y</code></td>
<td>
<p>dimension <code class="reqn">(T x k)</code> matrix where each row is a k-dimensional vector</p>
</td></tr>
<tr><td><code id="dlogmultistudent_+3A_mu">mu</code></td>
<td>
<p>dimension <code class="reqn">(T x k)</code> matrix where each row is the mean of the k-dimensional
vector in corresponding row of <code>y</code>.</p>
</td></tr>
<tr><td><code id="dlogmultistudent_+3A_inv_omega">inv_Omega</code></td>
<td>
<p>inverse of the <code class="reqn">(k x k)</code> covariance matrix Omega.</p>
</td></tr>
<tr><td><code id="dlogmultistudent_+3A_log_det_omega">log_det_Omega</code></td>
<td>
<p>logarithm of the determinant of the covariance matrix Omega.</p>
</td></tr>
<tr><td><code id="dlogmultistudent_+3A_arch_scalars">arch_scalars</code></td>
<td>
<p>length <code class="reqn">T</code> numeric vector containing the coefficients that multiply
the covariance matrix <code>Omega</code>.</p>
</td></tr>
<tr><td><code id="dlogmultistudent_+3A_df">df</code></td>
<td>
<p>the degrees of freedom parameter that is common for all <code class="reqn">t=1,...,T</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a size <code class="reqn">(T x 1)</code> vector containing the  multivariate Student's t
densities in logarithm.
</p>

<hr>
<h2 id='estimate_sgsmvar'>Maximum likelihood estimation of a structural GMVAR, StMVAR, or G-StMVAR model
with preliminary estimates</h2><span id='topic+estimate_sgsmvar'></span>

<h3>Description</h3>

<p><code>estimate_gsmvar</code> uses a genetic algorithm and variable metric algorithm to estimate the parameters
of a structural GMVAR, StMVAR, or G-StMVAR model with the method of maximum likelihood and preliminary
estimates from (typically identified) reduced form or structural GSMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_sgsmvar(
  gsmvar,
  new_W,
  ncalls = 16,
  ncores = 2,
  maxit = 1000,
  seeds = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_sgsmvar_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="estimate_sgsmvar_+3A_new_w">new_W</code></td>
<td>
<p>What should be the constraints on the W-matrix (or equally B-matrix)? Provide a <code class="reqn">(d x d)</code> matrix
(where <code>d</code> is the number of time series in the system) expressing the constraints such that <code>NA</code> signifies
that the element is not constrained, strictly positive real number signifies strict positive sign constraint,
strictly negative real number signified strict negative sign constraints, and zero signifies a zero constraints.</p>
</td></tr>
<tr><td><code id="estimate_sgsmvar_+3A_ncalls">ncalls</code></td>
<td>
<p>the number of estimation rounds that should be performed.</p>
</td></tr>
<tr><td><code id="estimate_sgsmvar_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to be used in numerical differentiation. Multiple cores
are not supported on Windows, though.</p>
</td></tr>
<tr><td><code id="estimate_sgsmvar_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="estimate_sgsmvar_+3A_seeds">seeds</code></td>
<td>
<p>a length <code>ncalls</code> vector containing the random number generator seed for each call to the genetic algorithm,
or <code>NULL</code> for not initializing the seed. Exists for creating reproducible results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of <code>estimate_gsmvar</code> is to provide a convenient tool to estimate (typically over)identified
structural GSMVAR models when preliminary estimates are available from a fitted reduced form or structural GMVAR
model. Often one estimates a two-regime reduced form model and then uses the function <code>gsmvar_to_sgsmvar</code> to
obtain the corresponding, statistically identified structural model. After obtaining the statistically identified
structural model, overidentifying constraints may be placed the W-matrix (or equally B-matrix). This function makes
imposing the overidentifying constraints and estimating the overidentified structural model convenient.
<strong>Reduced form models can be directly used as lower-triangular Cholesky identified SVARs without having
to estimate a structural model separately.</strong>
</p>
<p><strong>Note that the surface of the log-likelihood function is extremely multimodal, and this function is designed
to only explore the neighbourhood of the preliminary estimates, so it finds its way reliably to the correct MLE
only the preliminary estimates are close it in the first place. Use the function directly fitGSMVAR for a more thorough
search of the parameter space, if necessary.</strong> This function calls <code>fitGSMVAR</code> by construction an initial population to
the genetic algorithm from a preliminary guess of the new estimates. The smart mutations are set to begin from the
first generation.
</p>
<p>In order to the impose the constraints you wish, it might be useful to first run the model through the functioons
<code>reorder_W_columns</code> and <code>swap_W_signs</code>. <strong>Particularly check that the sign constraints are readily
satisfied. If not, the estimated solution might not be correct MLE.</strong>
</p>
<p><code>estimate_sgsmvar</code> can also be used to estimate models that are not identified, i.e., one regime models. If it
supplied with a reduced form model, it will first apply the function <code>gsmvar_to_sgsmvar</code>, then impose the
constraints and finally estimate the model.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the estimated GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code> <code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples that use parallel computing!
## Running the below examples takes 30 seconds

# GMVAR(1,2) model
fit12 &lt;- fitGSMVAR(gdpdef, p=1, M=2, ncalls=2, seeds=1:2) # Reduced form
fit12s &lt;- gsmvar_to_sgsmvar(fit12) # Structural
fit12s
# Constrain the lower right element of W (or B-matrix) to zero, and for
# global identification the first elements of each column to strictly positive.
(new_W &lt;- matrix(c(1, NA, 1, 0), nrow=2))
new_fit12s &lt;- estimate_sgsmvar(fit12s, new_W, ncalls=2, ncores=2, seeds=1:2)
new_fit12s # Overidentified model

# Cholesky VAR(1)
fit11 &lt;- fitGSMVAR(gdpdef, p=1, M=1, ncalls=2, seeds=1:2) # Reduced form
(new_W &lt;- matrix(c(1, NA, 0, 1), nrow=2))
new_fit11s &lt;- estimate_sgsmvar(fit11, new_W, ncalls=2, ncores=2, seeds=1:2)
print(new_fit11s, digits=4)
# Also: gsmvar_to_sgsmvar(fit11, cholesky=TRUE) gives Cholesky VAR

</code></pre>

<hr>
<h2 id='euromone'>A monthly Euro area data covering the period from January 1999 to December 2021 (276 observations) and consisting four variables:
cyclical component of log industrial production index, the log-difference of harmonized consumer price index, the log-difference
of Brent crude oil prices (Europe), and an interest rate variable. The interest rate variable is the Euro overnight index average
rate (EONIA) from January 1999 to October 2008, and after that the Wu and Xia (2016) shadow rate, which is not constrained by the zero lower
bound and also quantifies unconventional monetary policy measures. The log-difference of the harmonized consumer price index is
multiplied by hundred and the log-difference of oil price by ten. This data is the one that was used in Virolainen (2022).</h2><span id='topic+euromone'></span>

<h3>Description</h3>

<p>The cyclical component of the log of industrial production index was obtained by applying the linear projection filter proposed
by Hamilton (2018) using the parameter values h=24 and p=12. In order to obtain as accurate estimates as possible, we applied the
filter to the full available sample from January 1991 to December 2021 before extracting our sample period from it.
package lpirfs (Admmer, 2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euromone
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of class <code>'ts'</code> with 276 rows and 4 columns with one time series in each column:
</p>

<dl>
<dt>First column (IPI):</dt><dd><p>The cyclical component of the log of industrial production index,
url is https://sdw.ecb.europa.eu/quickview.do?SERIES_KEY=132.STS.M.I8.Y.PROD.NS0010.4.000.</p>
</dd>
<dt>Second column (HCPI):</dt><dd><p>The log-difference of harmonized consumer price index,
url is https://sdw.ecb.europa.eu/quickview.do?SERIES_KEY=122.ICP.M.U2.Y.000000.3.INX.</p>
</dd>
<dt>Third column (OIL):</dt><dd><p>The log-difference of Brent crude oil price (Europe),
<a href="https://fred.stlouisfed.org/series/MCOILBRENTEU">https://fred.stlouisfed.org/series/MCOILBRENTEU</a>.</p>
</dd>
<dt>Third column (RATE):</dt><dd><p>The EONIA from January 1999 to October 2008 and after that the Wu and Xia (2016) shadow rate,
urls are https://sdw.ecb.europa.eu/quickview.do?SERIES_KEY=143.FM.M.U2.EUR.4F.MM.EONIA.HSTA and
<a href="https://sites.google.com/view/jingcynthiawu/shadow-rates">https://sites.google.com/view/jingcynthiawu/shadow-rates</a>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Federal Reserve Bank of St. Louis database and the Federal Reserve Bank of Atlanta's website
</p>


<h3>References</h3>


<ul>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li>
<li><p> Wu J. and Xia F. 2016. Measuring the macroeconomic impact of monetary policy at the zero lower bound.
<em>Journal of Money, Credit and Banking</em>, 48(2-3): 253-291.
</p>
</li></ul>


<hr>
<h2 id='fitGMVAR'>DEPRECATED! USE THE FUNCTION fitGSMVAR INSTEAD! Two-phase maximum likelihood estimation of a GMVAR model</h2><span id='topic+fitGMVAR'></span>

<h3>Description</h3>

<p>DEPRECATED! USE THE FUNCTION fitGSMVAR INSTEAD!
<code>fitGMVAR</code> estimates a GMVAR model model in two phases:
in the first phase it uses a genetic algorithm to find starting values for a gradient based
variable metric algorithm, which it then uses to finalize the estimation in the second phase.
Parallel computing is utilized to perform multiple rounds of estimations in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGMVAR(
  data,
  p,
  M,
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  structural_pars = NULL,
  ncalls = M^6,
  ncores = 2,
  maxit = 1000,
  seeds = NULL,
  print_res = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitGMVAR_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_ncalls">ncalls</code></td>
<td>
<p>the number of estimation rounds that should be performed.</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_ncores">ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing.</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_seeds">seeds</code></td>
<td>
<p>a length <code>ncalls</code> vector containing the random number generator seed for each call to the genetic algorithm,
or <code>NULL</code> for not initializing the seed. Exists for creating reproducible results.</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_print_res">print_res</code></td>
<td>
<p>should summaries of estimation results be printed?</p>
</td></tr>
<tr><td><code id="fitGMVAR_+3A_...">...</code></td>
<td>
<p>additional settings passed to the function <code>GAfit</code> employing the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you wish to estimate a structural model without overidentifying constraints that is identified statistically,
specify your W matrix is <code>structural_pars</code> to be such that it contains the same sign constraints in a single row
(e.g. a row of ones) and leave the other elements as <code>NA</code>. In this way, the genetic algorithm works the best.
The ordering and signs of the columns of the W matrix can be changed afterwards with the functions
<code>reorder_W_columns</code> and <code>swap_W_signs</code>.
</p>
<p>Because of complexity and high multimodality of the log-likelihood function, it's <strong>not certain</strong> that the estimation
algorithms will end up in the global maximum point. It's expected that most of the estimation rounds will end up in
some local maximum or saddle point instead. Therefore, a (sometimes large) number of estimation rounds is required
for reliable results. Because of the nature of the model, the estimation may fail especially in the cases where the
number of mixture components is chosen too large. <strong>With two regimes and couple hundred observations in a two-dimensional
time series, 50 rounds is usually enough. Several hundred estimation rounds often suffices for reliably fitting two-regimes
models to 3 or 4 dimensional time series. With more than two regimes and more than couple hundred
observations, thousands of estimation rounds (or more) are often required to obtain reliable results.</strong>
</p>
<p>The estimation process is computationally heavy and it might take considerably long time for large models with
large number of observations. If the iteration limit <code>maxit</code> in the variable metric algorithm is reached,
one can continue the estimation by iterating more with the function <code>iterate_more</code>. Alternatively, one may
use the found estimates as starting values for the genetic algorithm and and employ another round of estimation
(see <code>?GAfit</code> how to set up an initial population with the dot parameters).
</p>
<p><strong>If the estimation algorithm fails to create an initial population for the genetic algorithm</strong>,
it usually helps to scale the individual series so that the AR coefficients (of a VAR model) will be
relative small, preferably less than one. Even if one is able to create an initial population, it should
be preferred to scale the series so that most of the AR coefficients will not be very large, as the
estimation algorithm works better with relatively small AR coefficients. If needed, another package can be used
to fit linear VARs to the series to see which scaling of the series results in relatively small AR coefficients.
</p>
<p>The code of the genetic algorithm is mostly based on the description by <em>Dorsey and Mayer (1995)</em> but it
includes some extra features that were found useful for this particular estimation problem. For instance,
the genetic algorithm uses a slightly modified version of the individually adaptive crossover and mutation
rates described by <em>Patnaik and Srinivas (1994)</em> and employs (50%) fitness inheritance discussed
by <em>Smith, Dike and Stegmann (1995)</em>.
</p>
<p>The gradient based variable metric algorithm used in the second phase is implemented with function <code>optim</code>
from the package <code>stats</code>.
</p>
<p>Note that the structural models are even more difficult to estimate than the reduced form models due to
the different parametrization of the covariance matrices, so larger number of estimation rounds should be considered.
Also, be aware that if the lambda parameters are constrained in any other way than by restricting some of them to be
identical, the parameter &quot;lambda_scale&quot; of the genetic algorithm (see <code>?GAfit</code>) needs to be carefully adjusted accordingly.
<strong>When estimating a structural model that imposes overidentifiying constraints to a time series with <code class="reqn">d&gt;3</code>,
it is highly recommended to create an initial population based on the estimates of a statistically identified model
(when <code class="reqn">M=2</code>). This is because currently obtaining the ML estimate reliably to such a structural model seems
difficult in many application.</strong>
</p>
<p>Finally, the function fails to calculate approximate standard errors and the parameter estimates are near the border
of the parameter space, it might help to use smaller numerical tolerance for the stationarity and positive
definiteness conditions. The numerical tolerance of an existing model can be changed with the function
<code>update_numtols</code>.
</p>
<p><strong>Filtering inappropriate estimates:</strong> If <code>filter_estimates == TRUE</code>, the function will automatically filter
out estimates that it deems &quot;inappropriate&quot;. That is, estimates that are not likely solutions of interest.
Specifically, solutions that incorporate a near-singular error term covariance matrix (any eigenvalue less than <code class="reqn">0.002</code>),
mixing weights such that they are close to zero for almost all <code class="reqn">t</code> for at least one regime, or mixing weight parameter
estimate close to zero (or one). It also filters out estimates with any modulus &quot;bold A&quot; eigenvalues larger than 0.9985,
as the solution is near the boundary of the stationarity region and likely not a local maximum. You can also set
<code>filter_estimates=FALSE</code> and find the solutions of interest yourself by using the
function <code>alt_gsmvar</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the estimated (reduced form or structural) GMVAR, StMVAR, or G-StMVAR model.
Multivariate quantile residuals (Kalliovirta and Saikkonen 2010) are also computed and included in the returned object.
In addition, the returned object contains the estimates and log-likelihood values from all the estimation rounds performed.
The estimated parameter vector can be obtained at <code>gsmvar$params</code> (and corresponding approximate standard errors
at <code>gsmvar$std_errors</code>). See <code>?GSMVAR</code> for the form of the parameter vector, if needed.
</p>
<p>Remark that the first autocovariance/correlation matrix in <code>$uncond_moments</code> is for the lag zero,
the second one for the lag one, etc.
</p>


<h3>References</h3>


<ul>
<li><p> Dorsey R. E. and Mayer W. J. 1995. Genetic algorithms for estimation problems with multiple optima,
nondifferentiability, and other irregular features. <em>Journal of Business &amp; Economic Statistics</em>,
<strong>13</strong>, 53-66.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Patnaik L.M. and Srinivas M. 1994. Adaptive Probabilities of Crossover and Mutation in Genetic Algorithms.
<em>Transactions on Systems, Man and Cybernetics</em> <strong>24</strong>, 656-667.
</p>
</li>
<li><p> Smith R.E., Dike B.A., Stegmann S.A. 1995. Fitness inheritance in genetic algorithms.
<em>Proceedings of the 1995 ACM Symposium on Applied Computing</em>, 345-350.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>
</p>

<hr>
<h2 id='fitGSMVAR'>Two-phase maximum likelihood estimation of a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+fitGSMVAR'></span>

<h3>Description</h3>

<p><code>fitGSMVAR</code> estimates a GMVAR, StMVAR, or G-StMVAR model model in two phases:
in the first phase it uses a genetic algorithm to find starting values for a gradient based
variable metric algorithm, which it then uses to finalize the estimation in the second phase.
Parallel computing is utilized to perform multiple rounds of estimations in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGSMVAR(
  data,
  p,
  M,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  ncalls = (M + 1)^5,
  ncores = 2,
  maxit = 1000,
  seeds = NULL,
  print_res = TRUE,
  use_parallel = TRUE,
  filter_estimates = TRUE,
  calc_std_errors = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitGSMVAR_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_ncalls">ncalls</code></td>
<td>
<p>the number of estimation rounds that should be performed.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_ncores">ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_seeds">seeds</code></td>
<td>
<p>a length <code>ncalls</code> vector containing the random number generator seed for each call to the genetic algorithm,
or <code>NULL</code> for not initializing the seed. Exists for creating reproducible results.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_print_res">print_res</code></td>
<td>
<p>should summaries of estimation results be printed?</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_use_parallel">use_parallel</code></td>
<td>
<p>employ parallel computing? If <code>FALSE</code>, no progression bar etc will be generated.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_filter_estimates">filter_estimates</code></td>
<td>
<p>should the likely inappropriate estimates be filtered? See details.</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>calculate approximate standard errors for the estimates?</p>
</td></tr>
<tr><td><code id="fitGSMVAR_+3A_...">...</code></td>
<td>
<p>additional settings passed to the function <code>GAfit</code> employing the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you wish to estimate a structural model without overidentifying constraints that is identified statistically,
specify your W matrix is <code>structural_pars</code> to be such that it contains the same sign constraints in a single row
(e.g. a row of ones) and leave the other elements as <code>NA</code>. In this way, the genetic algorithm works the best.
The ordering and signs of the columns of the W matrix can be changed afterwards with the functions
<code>reorder_W_columns</code> and <code>swap_W_signs</code>.
</p>
<p>Because of complexity and high multimodality of the log-likelihood function, it's <strong>not certain</strong> that the estimation
algorithms will end up in the global maximum point. It's expected that most of the estimation rounds will end up in
some local maximum or saddle point instead. Therefore, a (sometimes large) number of estimation rounds is required
for reliable results. Because of the nature of the model, the estimation may fail especially in the cases where the
number of mixture components is chosen too large. <strong>With two regimes and couple hundred observations in a two-dimensional
time series, 50 rounds is usually enough. Several hundred estimation rounds often suffices for reliably fitting two-regimes
models to 3 or 4 dimensional time series. With more than two regimes and more than couple hundred
observations, thousands of estimation rounds (or more) are often required to obtain reliable results.</strong>
</p>
<p>The estimation process is computationally heavy and it might take considerably long time for large models with
large number of observations. If the iteration limit <code>maxit</code> in the variable metric algorithm is reached,
one can continue the estimation by iterating more with the function <code>iterate_more</code>. Alternatively, one may
use the found estimates as starting values for the genetic algorithm and and employ another round of estimation
(see <code>?GAfit</code> how to set up an initial population with the dot parameters).
</p>
<p><strong>If the estimation algorithm fails to create an initial population for the genetic algorithm</strong>,
it usually helps to scale the individual series so that the AR coefficients (of a VAR model) will be
relative small, preferably less than one. Even if one is able to create an initial population, it should
be preferred to scale the series so that most of the AR coefficients will not be very large, as the
estimation algorithm works better with relatively small AR coefficients. If needed, another package can be used
to fit linear VARs to the series to see which scaling of the series results in relatively small AR coefficients.
</p>
<p>The code of the genetic algorithm is mostly based on the description by <em>Dorsey and Mayer (1995)</em> but it
includes some extra features that were found useful for this particular estimation problem. For instance,
the genetic algorithm uses a slightly modified version of the individually adaptive crossover and mutation
rates described by <em>Patnaik and Srinivas (1994)</em> and employs (50%) fitness inheritance discussed
by <em>Smith, Dike and Stegmann (1995)</em>.
</p>
<p>The gradient based variable metric algorithm used in the second phase is implemented with function <code>optim</code>
from the package <code>stats</code>.
</p>
<p>Note that the structural models are even more difficult to estimate than the reduced form models due to
the different parametrization of the covariance matrices, so larger number of estimation rounds should be considered.
Also, be aware that if the lambda parameters are constrained in any other way than by restricting some of them to be
identical, the parameter &quot;lambda_scale&quot; of the genetic algorithm (see <code>?GAfit</code>) needs to be carefully adjusted accordingly.
<strong>When estimating a structural model that imposes overidentifiying constraints to a time series with <code class="reqn">d&gt;3</code>,
it is highly recommended to create an initial population based on the estimates of a statistically identified model
(when <code class="reqn">M=2</code>). This is because currently obtaining the ML estimate reliably to such a structural model seems
difficult in many application.</strong>
</p>
<p>Finally, the function fails to calculate approximate standard errors and the parameter estimates are near the border
of the parameter space, it might help to use smaller numerical tolerance for the stationarity and positive
definiteness conditions. The numerical tolerance of an existing model can be changed with the function
<code>update_numtols</code>.
</p>
<p><strong>Filtering inappropriate estimates:</strong> If <code>filter_estimates == TRUE</code>, the function will automatically filter
out estimates that it deems &quot;inappropriate&quot;. That is, estimates that are not likely solutions of interest.
Specifically, solutions that incorporate a near-singular error term covariance matrix (any eigenvalue less than <code class="reqn">0.002</code>),
mixing weights such that they are close to zero for almost all <code class="reqn">t</code> for at least one regime, or mixing weight parameter
estimate close to zero (or one). It also filters out estimates with any modulus &quot;bold A&quot; eigenvalues larger than 0.9985,
as the solution is near the boundary of the stationarity region and likely not a local maximum. You can also set
<code>filter_estimates=FALSE</code> and find the solutions of interest yourself by using the
function <code>alt_gsmvar</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the estimated (reduced form or structural) GMVAR, StMVAR, or G-StMVAR model.
Multivariate quantile residuals (Kalliovirta and Saikkonen 2010) are also computed and included in the returned object.
In addition, the returned object contains the estimates and log-likelihood values from all the estimation rounds performed.
The estimated parameter vector can be obtained at <code>gsmvar$params</code> (and corresponding approximate standard errors
at <code>gsmvar$std_errors</code>). See <code>?GSMVAR</code> for the form of the parameter vector, if needed.
</p>
<p>Remark that the first autocovariance/correlation matrix in <code>$uncond_moments</code> is for the lag zero,
the second one for the lag one, etc.
</p>


<h3>S3 methods</h3>

<p>The following S3 methods are supported for class <code>'gsmvar'</code>: <code>logLik</code>, <code>residuals</code>, <code>print</code>, <code>summary</code>,
<code>predict</code>, <code>simulate</code>, and <code>plot</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Dorsey R. E. and Mayer W. J. 1995. Genetic algorithms for estimation problems with multiple optima,
nondifferentiability, and other irregular features. <em>Journal of Business &amp; Economic Statistics</em>,
<strong>13</strong>, 53-66.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Patnaik L.M. and Srinivas M. 1994. Adaptive Probabilities of Crossover and Mutation in Genetic Algorithms.
<em>Transactions on Systems, Man and Cybernetics</em> <strong>24</strong>, 656-667.
</p>
</li>
<li><p> Smith R.E., Dike B.A., Stegmann S.A. 1995. Fitness inheritance in genetic algorithms.
<em>Proceedings of the 1995 ACM Symposium on Applied Computing</em>, 345-350.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+stmvar_to_gstmvar">stmvar_to_gstmvar</a></code>, <code><a href="#topic+predict.gsmvar">predict.gsmvar</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+simulate.gsmvar">simulate.gsmvar</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+print_std_errors">print_std_errors</a></code>,
<code><a href="#topic+swap_parametrization">swap_parametrization</a></code>, <code><a href="#topic+get_gradient">get_gradient</a></code>, <code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+GFEVD">GFEVD</a></code>, <code><a href="#topic+LR_test">LR_test</a></code>,
<code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>, <code><a href="#topic+stmvar_to_gstmvar">stmvar_to_gstmvar</a></code>, <code><a href="#topic+reorder_W_columns">reorder_W_columns</a></code>,
<code><a href="#topic+swap_W_signs">swap_W_signs</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>, <code><a href="#topic+update_numtols">update_numtols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples that use parallel computing!
# Running all the below examples will take approximately 3-4 minutes.

# GMVAR(1,2) model: 10 estimation rounds with seeds set
# for reproducibility
fit12 &lt;- fitGSMVAR(gdpdef, p=1, M=2, ncalls=10, seeds=1:10)
fit12
plot(fit12)
summary(fit12)
print_std_errors(fit12)
profile_logliks(fit12)

# The rest of the examples only use a single estimation round with a given
# seed that produces the MLE to reduce running time of the examples. When
# estimating models for empirical applications, a large number of estimation
# rounds (ncalls = a large number) should be performed to ensure reliability
# of the estimates (see the section details).

# StMVAR(2, 2) model
fit22t &lt;- fitGSMVAR(gdpdef, p=2, M=2, model="StMVAR", ncalls=1, seeds=1)
fit22t # Overly large degrees of freedom estimate in the 2nd regime!
fit22gs &lt;- stmvar_to_gstmvar(fit22t) # So switch it to GMVAR type!
fit22gs # This is the appropriate G-StMVAR model based on the above StMVAR model.
fit22gss &lt;- gsmvar_to_sgsmvar(fit22gs) # Switch to structural model
fit22gss # This is the implied statistically identified structural model.

# Structural GMVAR(1,2) model identified with sign
# constraints.
W_122 &lt;- matrix(c(1, 1, -1, 1), nrow=2)
fit12s &lt;- fitGSMVAR(gdpdef, p=1, M=2, structural_pars=list(W=W_122),
  ncalls=1, seeds=1)
fit12s
# A statistically identified structural model can also be obtained with
# gsmvar_to_sgsmvar(fit12)


# GMVAR(2,2) model with autoregressive parameters restricted
# to be the same for both regimes
C_mat &lt;- rbind(diag(2*2^2), diag(2*2^2))
fit22c &lt;- fitGSMVAR(gdpdef, p=2, M=2, constraints=C_mat, ncalls=1, seeds=1)
fit22c

# G-StMVAR(2, 1, 1) model with autoregressive parameters and unconditional means restricted
# to be the same for both regimes:
fit22gscm &lt;- fitGSMVAR(gdpdef, p=2, M=c(1, 1), model="G-StMVAR", constraints=C_mat,
   parametrization="mean", same_means=list(1:2), ncalls=1, seeds=1)

# GMVAR(2,2) model with autoregressive parameters restricted
# to be the same for both regimes and non-diagonal elements
# the coefficient matrices constrained to zero.
tmp &lt;- matrix(c(1, rep(0, 10), 1, rep(0, 8), 1, rep(0, 10), 1),
 nrow=2*2^2, byrow=FALSE)
C_mat2 &lt;- rbind(tmp, tmp)
fit22c2 &lt;- fitGSMVAR(gdpdef, p=2, M=2, constraints=C_mat2, ncalls=1,
  seeds=1)
fit22c2

</code></pre>

<hr>
<h2 id='form_boldA'>Form the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; matrices related to the VAR processes</h2><span id='topic+form_boldA'></span>

<h3>Description</h3>

<p><code>form_boldA</code> creates the &quot;bold A&quot; coefficient matrices related to
VAR processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_boldA(p, M, d, all_A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="form_boldA_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="form_boldA_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="form_boldA_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="form_boldA_+3A_all_a">all_A</code></td>
<td>
<p>4D array containing all coefficient matrices <code class="reqn">A_{m,i}</code>, obtained from <code>pick_allA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns 3D array containing the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; matrices related to each component VAR-process.
The matrix <strong><code class="reqn">A_{m}</code></strong> can be obtained by choosing <code>[, , m]</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='format_valuef'>Function factory for value formatting</h2><span id='topic+format_valuef'></span>

<h3>Description</h3>

<p><code>format_valuef</code> is a function factory for
formatting values with certain number of digits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_valuef(digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_valuef_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function that takes an atomic vector as argument
and returns it formatted to character with <code>digits</code> decimals.
</p>

<hr>
<h2 id='GAfit'>Genetic algorithm for preliminary estimation of a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+GAfit'></span>

<h3>Description</h3>

<p><code>GAfit</code> estimates the specified GMVAR, StMVAR, or G-StMVAR model using a genetic algorithm.
It's designed to find starting values for gradient based methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAfit(
  data,
  p,
  M,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  ngen = 200,
  popsize,
  smart_mu = min(100, ceiling(0.5 * ngen)),
  initpop = NULL,
  mu_scale,
  mu_scale2,
  omega_scale,
  W_scale,
  lambda_scale,
  ar_scale = 0.2,
  upper_ar_scale = 1,
  ar_scale2 = 1,
  regime_force_scale = 1,
  red_criteria = c(0.05, 0.01),
  pre_smart_mu_prob = 0,
  to_return = c("alt_ind", "best_ind"),
  minval,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAfit_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GAfit_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function</p>
</td></tr>
<tr><td><code id="GAfit_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="GAfit_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="GAfit_+3A_ngen">ngen</code></td>
<td>
<p>a positive integer specifying the number of generations to be ran through in
the genetic algorithm.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_popsize">popsize</code></td>
<td>
<p>a positive even integer specifying the population size in the genetic algorithm.
Default is <code>10*n_params</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_smart_mu">smart_mu</code></td>
<td>
<p>a positive integer specifying the generation after which the random mutations
in the genetic algorithm are &quot;smart&quot;. This means that mutating individuals will mostly mutate fairly
close (or partially close) to the best fitting individual (which has the least regimes with time varying
mixing weights practically at zero) so far.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_initpop">initpop</code></td>
<td>
<p>a list of parameter vectors from which the initial population of the genetic algorithm
will be generated from. The parameter vectors should be...
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code>
with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is a <code class="reqn">(d(M-1) x r)</code>
constraint matrix.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_mu_scale2">mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>2*sd(data[,i]), i=1,..,d</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_omega_scale">omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
structural model is considered.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_w_scale">W_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector partly specifying the scale and variability of the
random covariance matrices in random mutations. The elements of the matrix <code class="reqn">W</code> are drawn independently
from such normal distributions that the expectation of the main <strong>diagonal</strong> elements of the first
regime's error term covariance matrix <code class="reqn">\Omega_1 = WW'</code> is <code>W_scale</code>. The distribution of <code class="reqn">\Omega_1</code>
will be in some sense like a Wishart distribution but with the columns (elements) of <code class="reqn">W</code> obeying the given
constraints. The constraints are accounted for by setting the element to be always zero if it is subject to a zero
constraint and for sign constraints the absolute value or negative the absolute value are taken, and then the
variances of the elements of <code class="reqn">W</code> are adjusted accordingly. This argument is ignored if reduced form model
is considered.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_lambda_scale">lambda_scale</code></td>
<td>
<p>a length <code class="reqn">M - 1</code> vector specifying the <strong>standard deviation</strong> of the mean zero normal
distribution from which the eigenvalue <code class="reqn">\lambda_{mi}</code> parameters are drawn from in random mutations.
As the eigenvalues should always be positive, the absolute value is taken. The elements of <code>lambda_scale</code>
should be strictly positive real numbers with the <code class="reqn">m-1</code>th element giving the degrees of freedom for the <code class="reqn">m</code>th
regime. The expected value of the main <strong>diagonal</strong> elements <code class="reqn">ij</code> of the <code class="reqn">m</code>th <code class="reqn">(m&gt;1)</code> error term covariance
matrix will be <code>W_scale[i]*(d - n_i)^(-1)*sum(lambdas*ind_fun)</code> where the <code class="reqn">(d x 1)</code> vector <code>lambdas</code> is
drawn from the absolute value of the t-distribution, <code>n_i</code> is the number of zero constraints in the <code class="reqn">i</code>th
row of <code class="reqn">W</code> and <code>ind_fun</code> is an indicator function that takes the value one iff the <code class="reqn">ij</code>th element of
<code class="reqn">W</code> is not constrained to zero. Basically, larger lambdas (or smaller degrees of freedom) imply larger variance.
</p>
<p>If the lambda parameters are <strong>constrained</strong> with the <code class="reqn">(d(M - 1) x r)</code> constraint matrix <code class="reqn">C_lambda</code>,
then provide a length <code class="reqn">r</code> vector specifying the standard deviation of the (absolute value of the) mean zero
normal distribution each of the <code class="reqn">\gamma</code> parameters are drawn from (the <code class="reqn">\gamma</code> is a <code class="reqn">(r x 1)</code> vector).
The expected value of the main diagonal elements of the covariance matrices then depend on the constraints.
</p>
<p>This argument is ignored if <code class="reqn">M==1</code> or a reduced form model is considered. Default is <code>rep(3, times=M-1)</code>
if lambdas are not constrained and <code>rep(3, times=r)</code> if lambdas are constrained.
</p>
<p>As with omega_scale and W_scale, this argument should be adjusted carefully if specified by hand. <strong>NOTE</strong>
that if lambdas are constrained in some other way than restricting some of them to be identical, this parameter
should be adjusted accordingly in order to the estimation succeed!</p>
</td></tr>
<tr><td><code id="GAfit_+3A_ar_scale">ar_scale</code></td>
<td>
<p>a positive real number between zero and one, adjusting how large AR parameter values are typically
proposed in construction of the initial population: larger value implies larger coefficients (in absolute value).
After construction of the initial population, a new scale is drawn from <code>(0, upper_ar_scale)</code> uniform
distribution in each iteration. With large <code>p</code> or <code>d</code>, <code>ar_scale</code> is restricted from above,
see the details section.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_upper_ar_scale">upper_ar_scale</code></td>
<td>
<p>the upper bound for <code>ar_scale</code> parameter (see above) in the random mutations. Setting
this too high might lead to failure in proposing new parameters that are well enough inside the parameter space,
and especially with large <code>p</code> one might want to try smaller upper bound (e.g., 0.5). With large <code>p</code> or
<code>d</code>, <code>upper_ar_scale</code> is restricted from above, see the details section.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_ar_scale2">ar_scale2</code></td>
<td>
<p>a positive real number adjusting how large AR parameter values are typically proposed in some
random mutations (if AR constraints are employed, in all random mutations): larger value implies <strong>smaller</strong> coefficients
(in absolute value). <strong>Values larger than 1 can be used if the AR coefficients are expected to be very small.
If set smaller than 1, be careful as it might lead to failure in the creation of stationary parameter candidates</strong></p>
</td></tr>
<tr><td><code id="GAfit_+3A_regime_force_scale">regime_force_scale</code></td>
<td>
<p>a non-negative real number specifying how much should natural selection favor individuals
with less regimes that have almost all mixing weights (practically) at zero. Set to zero for no favoring or large
number for heavy favoring. Without any favoring the genetic algorithm gets more often stuck in an area of the
parameter space where some regimes are wasted, but with too much favouring the best genes might never mix into
the population and the algorithm might converge poorly. Default is <code>1</code> and it gives <code class="reqn">2x</code> larger surviving
probability weights for individuals with no wasted regimes compared to individuals with one wasted regime.
Number <code>2</code> would give <code class="reqn">3x</code> larger probability weights etc.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_red_criteria">red_criteria</code></td>
<td>
<p>a length 2 numeric vector specifying the criteria that is used to determine whether a regime is
redundant (or &quot;wasted&quot;) or not.
Any regime <code>m</code> which satisfies <code>sum(mixingWeights[,m] &gt; red_criteria[1]) &lt; red_criteria[2]*n_obs</code> will
be considered &quot;redundant&quot;. One should be careful when adjusting this argument (set <code>c(0, 0)</code> to fully disable
the 'redundant regime' features from the algorithm).</p>
</td></tr>
<tr><td><code id="GAfit_+3A_pre_smart_mu_prob">pre_smart_mu_prob</code></td>
<td>
<p>A number in <code class="reqn">[0,1]</code> giving a probability of a &quot;smart mutation&quot; occuring randomly in each
iteration before the iteration given by the argument <code>smart_mu</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_to_return">to_return</code></td>
<td>
<p>should the genetic algorithm return the best fitting individual which has &quot;positive enough&quot; mixing
weights for as many regimes as possible (<code>"alt_ind"</code>) or the individual which has the highest log-likelihood
in general (<code>"best_ind"</code>) but might have more wasted regimes?</p>
</td></tr>
<tr><td><code id="GAfit_+3A_minval">minval</code></td>
<td>
<p>a real number defining the minimum value of the log-likelihood function that will be considered.
Values smaller than this will be treated as they were <code>minval</code> and the corresponding individuals will
never survive. The default is <code>-(10^(ceiling(log10(n_obs)) + d) - 1)</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_seed">seed</code></td>
<td>
<p>a single value, interpreted as an integer, or NULL, that sets seed for the random number generator in the beginning of
the function call. If calling <code>GAfit</code> from <code>fitGSMVAR</code>, use the argument <code>seeds</code> instead of passing the argument
<code>seed</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The core of the genetic algorithm is mostly based on the description by <em>Dorsey and Mayer (1995)</em>.
It utilizes a slightly modified version of the individually adaptive crossover and mutation rates described
by <em>Patnaik and Srinivas (1994)</em> and employs (50%) fitness inheritance discussed by
<em>Smith, Dike and Stegmann (1995)</em>.
</p>
<p>By &quot;redundant&quot; or &quot;wasted&quot; regimes we mean regimes that have the time varying mixing weights practically at
zero for almost all t. A model including redundant regimes would have about the same log-likelihood value without
the redundant regimes and there is no purpose to have redundant regimes in a model.
</p>
<p>Some of the AR coefficients are drawn with the algorithm by Ansley and Kohn (1986). However,
when using large <code>ar_scale</code> with large <code>p</code> or <code>d</code>, numerical inaccuracies caused
by the imprecision of the float-point presentation may result in errors or nonstationary AR-matrices.
Using smaller <code>ar_scale</code> facilitates the usage of larger <code>p</code> or <code>d</code>. Therefore, we bound
<code>upper_ar_scale</code> from above by <code class="reqn">1-pd/150</code> when <code>p*d&gt;40</code> and by <code class="reqn">1</code> otherwise.
</p>


<h3>Value</h3>

<p>Returns the estimated parameter vector which has the form described in <code>initpop</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity. <em>Journal of statistical computation
and simulation</em>, <strong>24</strong>:2,  99-106.
</p>
</li>
<li><p> Dorsey R. E. and Mayer W. J. 1995. Genetic algorithms for estimation problems with multiple optima,
nondifferentiability, and other irregular features. <em>Journal of Business &amp; Economic Statistics</em>,
<strong>13</strong>, 53-66.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Patnaik L.M. and Srinivas M. 1994. Adaptive Probabilities of Crossover and Mutation in Genetic Algorithms.
<em>Transactions on Systems, Man and Cybernetics</em> <strong>24</strong>, 656-667.
</p>
</li>
<li><p> Smith R.E., Dike B.A., Stegmann S.A. 1995. Fitness inheritance in genetic algorithms.
<em>Proceedings of the 1995 ACM Symposium on Applied Computing</em>, 345-350.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
 # Preliminary estimation of a G-StMVAR(1, 1, 1) model with 50 generations.
 GA_estimates &lt;- GAfit(gdpdef, p=1, M=c(1, 1), model="G-StMVAR",
                       ngen=50, seed=1)
 GA_estimates

</code></pre>

<hr>
<h2 id='gdpdef'>U.S. real GDP percent change and GDP implicit price deflator percent change.</h2><span id='topic+gdpdef'></span>

<h3>Description</h3>

<p>A dataset containing a quarterly U.S. time series with two components:
the percentage change of real GDP and the percentage change of GDP implicit price deflator,
covering the period from 1959Q1 - 2019Q4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdpdef
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of class <code>'ts'</code> with 244 rows and 2 columns with one time series in each column:
</p>

<dl>
<dt>First column (GDP):</dt><dd><p>The quarterly percent change of real U.S. GDP, from 1959Q1 to 2019Q4,
<a href="https://fred.stlouisfed.org/series/GDPC1">https://fred.stlouisfed.org/series/GDPC1</a>.</p>
</dd>
<dt>Second column (GDPDEF):</dt><dd><p>The quarterly percent change of U.S. GDP implicit price deflator, from 1959Q1 to 2019Q4,
<a href="https://fred.stlouisfed.org/series/GDPDEF">https://fred.stlouisfed.org/series/GDPDEF</a>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Federal Reserve Bank of St. Louis database
</p>

<hr>
<h2 id='get_alpha_mt'>Get mixing weights alpha_mt (this function is for internal use)</h2><span id='topic+get_alpha_mt'></span>

<h3>Description</h3>

<p><code>get_alpha_mt</code> computes the mixing weights based on
the logarithm of the multivariate normal densities in the definition of
the mixing weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alpha_mt(M, log_mvdvalues, alphas, epsilon, conditional, also_l_0 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_alpha_mt_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_log_mvdvalues">log_mvdvalues</code></td>
<td>
<p><code class="reqn">T x M</code> matrix containing the log multivariate normal densities.</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_alphas">alphas</code></td>
<td>
<p><code class="reqn">M x 1</code> vector containing the mixing weight pa</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_epsilon">epsilon</code></td>
<td>
<p>the smallest number such that its exponent is wont classified as numerically zero
(around <code>-698</code> is used).</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function
should be used.</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_also_l_0">also_l_0</code></td>
<td>
<p>return also l_0 (the first term in the exact log-likelihood function)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that we index the time series as <code class="reqn">-p+1,...,0,1,...,T</code> as in Kalliovirta et al. (2016).
</p>


<h3>Value</h3>

<p>Returns the mixing weights a matrix of the same dimension as <code>log_mvdvalues</code> so
that the t:th row is for the time point t and m:th column is for the regime m.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loglikelihood_int">loglikelihood_int</a></code>
</p>

<hr>
<h2 id='get_boldA_eigens'>Calculate absolute values of the eigenvalues of the &quot;bold A&quot; matrices containing the AR coefficients</h2><span id='topic+get_boldA_eigens'></span>

<h3>Description</h3>

<p><code>get_boldA_eigens</code> calculates absolute values of the eigenvalues of
the &quot;bold A&quot; matrices containing the AR coefficients for each mixture component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_boldA_eigens(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_boldA_eigens_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with <code class="reqn">d*p</code> rows and <code class="reqn">M</code> columns - one column for each regime.
The <code class="reqn">m</code>th column contains the absolute values (or modulus) of the eigenvalues of the &quot;bold A&quot; matrix containing
the AR coefficients correspinding to regime <code class="reqn">m</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(2, 2), d=2 model
params22 &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
  0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
mod22 &lt;- GSMVAR(p=2, M=2, d=2, params=params22)
get_boldA_eigens(mod22)
</code></pre>

<hr>
<h2 id='get_IC'>Calculate AIC, HQIC, and BIC</h2><span id='topic+get_IC'></span>

<h3>Description</h3>

<p><code>get_IC</code> calculates the information criteria values AIC, HQIC, and BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_IC(loglik, npars, obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_IC_+3A_loglik">loglik</code></td>
<td>
<p>log-likelihood value</p>
</td></tr>
<tr><td><code id="get_IC_+3A_npars">npars</code></td>
<td>
<p>number of (freely estimated) parameters in the model</p>
</td></tr>
<tr><td><code id="get_IC_+3A_obs">obs</code></td>
<td>
<p>numbers of observations with starting values excluded for conditional models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for conditional models with different autoregressive order p the
information criteria values are <strong>NOT</strong> comparable.
</p>


<h3>Value</h3>

<p>Returns a data frame containing the information criteria values.
</p>

<hr>
<h2 id='get_minval'>Returns the default smallest allowed log-likelihood for given data.</h2><span id='topic+get_minval'></span>

<h3>Description</h3>

<p><code>get_minval</code> returns the default smallest allowed log-likelihood for given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_minval(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_minval_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exists to avoid dublication inside the package.
</p>


<h3>Value</h3>

<p>Returns <code>-(10^(ceiling(log10(nrow(data)) + ncol(data))) - 1)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GAfit">GAfit</a></code>
</p>

<hr>
<h2 id='get_omega_eigens'>Calculate the eigenvalues of the &quot;Omega&quot; error term covariance matrices</h2><span id='topic+get_omega_eigens'></span>

<h3>Description</h3>

<p><code>get_omega_eigens</code> calculates the eigenvalues of the &quot;Omega&quot; error
term covariance matrices for each mixture component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_omega_eigens(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_omega_eigens_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with <code class="reqn">d</code> rows and <code class="reqn">M</code> columns - one column for each regime.
The <code class="reqn">m</code>th column contains the eigenvalues of the &quot;Omega&quot; error term covariance matrix
of the <code class="reqn">m</code>th regime.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(2, 2), d=2 model
params22 &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
  0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
mod22 &lt;- GSMVAR(p=2, M=2, d=2, params=params22)
get_omega_eigens(mod22)
</code></pre>

<hr>
<h2 id='get_regime_autocovs'>Calculate regimewise autocovariance matrices</h2><span id='topic+get_regime_autocovs'></span>

<h3>Description</h3>

<p><code>get_regime_autocovs</code> calculates the first p regimewise autocovariance
matrices <code class="reqn">\Gamma_{m}(j)</code> for the given GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regime_autocovs(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_regime_autocovs_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code class="reqn">(d x d x p+1 x M)</code> array containing the first p regimewise autocovariance matrices.
The subset <code>[, , j, m]</code> contains the j-1:th lag autocovariance matrix of the m:th regime.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other moment functions: 
<code><a href="#topic+cond_moments">cond_moments</a>()</code>,
<code><a href="#topic+get_regime_means">get_regime_means</a>()</code>,
<code><a href="#topic+uncond_moments">uncond_moments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(1,2), d=2 model:
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005,
 0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012,
 0.136, 0.674)
mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)
get_regime_autocovs(mod12)

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
 0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
 0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22s, structural_pars=list(W=W_22))
mod22s
get_regime_autocovs(mod22s)
</code></pre>

<hr>
<h2 id='get_regime_autocovs_int'>Calculate regimewise autocovariance matrices</h2><span id='topic+get_regime_autocovs_int'></span>

<h3>Description</h3>

<p><code>get_regime_autocovs_int</code> calculates the regimewise autocovariance matrices <code class="reqn">\Gamma_{m}(j)</code>
<code class="reqn">j=0,1,...,p</code> for the given GSMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regime_autocovs_int(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_regime_autocovs_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_regime_autocovs_int_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_int_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_int_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_int_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="get_regime_autocovs_int_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="get_regime_autocovs_int_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code class="reqn">(d x d x p+1 x M)</code> array containing the first p regimewise autocovariance matrices.
The subset <code>[, , j, m]</code> contains the j-1:th lag autocovariance matrix of the m:th regime.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>


<hr>
<h2 id='get_regime_means'>Calculate regime means <code class="reqn">\mu_{m}</code></h2><span id='topic+get_regime_means'></span>

<h3>Description</h3>

<p><code>get_regime_means</code> calculates regime means <code class="reqn">\mu_{m} = (I - \sum A_{m,i})^(-1))</code>
for the given GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regime_means(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_regime_means_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">(dxM)</code> matrix containing regime mean <code class="reqn">\mu_{m}</code> in the m:th column, <code class="reqn">m=1,..,M</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uncond_moments">uncond_moments</a></code>, <code><a href="#topic+get_regime_autocovs">get_regime_autocovs</a></code>, <code><a href="#topic+cond_moments">cond_moments</a></code>
</p>
<p>Other moment functions: 
<code><a href="#topic+cond_moments">cond_moments</a>()</code>,
<code><a href="#topic+get_regime_autocovs">get_regime_autocovs</a>()</code>,
<code><a href="#topic+uncond_moments">uncond_moments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(1,2), d=2 model:
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005,
 0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012,
 0.136, 0.674)
mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)
mod12
get_regime_means(mod12)

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
 0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
 0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22s, structural_pars=list(W=W_22))
mod22s
get_regime_means(mod22s)
</code></pre>

<hr>
<h2 id='get_regime_means_int'>Calculate regime means <code class="reqn">\mu_{m}</code></h2><span id='topic+get_regime_means_int'></span>

<h3>Description</h3>

<p><code>get_regime_means</code> calculates regime means <code class="reqn">\mu_{m} = (I - \sum A)^(-1))</code>
from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regime_means_int(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_regime_means_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="get_regime_means_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_regime_means_int_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="get_regime_means_int_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="get_regime_means_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="get_regime_means_int_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="get_regime_means_int_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="get_regime_means_int_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="get_regime_means_int_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="get_regime_means_int_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">(dxM)</code> matrix containing regime mean <code class="reqn">\mu_{m}</code> in the m:th column, <code class="reqn">m=1,..,M</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='get_Sigmas'>Calculate the dp-dimensional covariance matrices <code class="reqn">\Sigma_{m,p}</code> in the mixing weights
of the GMVAR, StMVAR, or G-StMVAR model.</h2><span id='topic+get_Sigmas'></span>

<h3>Description</h3>

<p><code>get_Sigmas</code> calculates the dp-dimensional covariance matrices <code class="reqn">\Sigma_{m,p}</code>
in the mixing weights of the GMVAR, StMVAR, or G-StMVAR model so that the algorithm proposed by McElroy (2017) employed
whenever it reduces the computation time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_Sigmas(p, M, d, all_A, all_boldA, all_Omega)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_Sigmas_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_all_a">all_A</code></td>
<td>
<p>4D array containing all coefficient matrices <code class="reqn">A_{m,i}</code>, obtained from <code>pick_allA</code>.</p>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_all_bolda">all_boldA</code></td>
<td>
<p>3D array containing the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; matrices related to each mixture component VAR-process,
obtained from <code>form_boldA</code>. Will be computed if not given.</p>
</td></tr>
<tr><td><code id="get_Sigmas_+3A_all_omega">all_Omega</code></td>
<td>
<p>a <code>[d, d, M]</code> array containing the covariance matrix Omegas</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the dp-dimensional covariance matrix using the formula (2.1.39) in Ltkepohl (2005) when
<code>d*p &lt; 12</code> and using the algorithm proposed by McElroy (2017) otherwise.
</p>
<p>The code in the implementation of the McElroy's (2017) algorithm (in the function <code>VAR_pcovmat</code>) is
adapted from the one provided in the supplementary material of McElroy (2017). Reproduced under GNU General
Public License, Copyright (2015) Tucker McElroy.
</p>


<h3>Value</h3>

<p>Returns a <code>[dp, dp, M]</code> array containing the dp-dimensional covariance matrices for each regime.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. 2022. Structural Gaussian mixture vector autoregressive model with application to the asymmetric
effects of monetary policy shocks. Unpublished working paper, available as arXiv:2007.04713.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>


<hr>
<h2 id='get_symmetric_sqrt'>Calculate symmetric square root matrix of a positive definite covariance
matrix</h2><span id='topic+get_symmetric_sqrt'></span>

<h3>Description</h3>

<p><code>get_symmetric_sqrt</code> calculates symmetric square root matrix
of a positive definite covariance matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_symmetric_sqrt(Omega)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_symmetric_sqrt_+3A_omega">Omega</code></td>
<td>
<p>a positive definite covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vectorized symmetric square root matrix of the matrix <code>Omega</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='get_test_Omega'>Compute covariance matrix Omega used in quantile residual tests</h2><span id='topic+get_test_Omega'></span>

<h3>Description</h3>

<p><code>get_test_Omega</code> computes the covariance matrix Omega used in the
quantile residuals tests described by <em>Kalliovirta and Saikkonen 2010</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_test_Omega(
  data,
  p,
  M,
  params,
  model,
  conditional,
  parametrization,
  constraints,
  same_means,
  weight_constraints,
  structural_pars = NULL,
  g,
  dim_g,
  ncores = 1,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_test_Omega_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function
should be used.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_g">g</code></td>
<td>
<p>function g specifying the transformation.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_dim_g">dim_g</code></td>
<td>
<p>output dimension of the transformation <code>g</code>.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to be used in numerical differentiation. Multiple cores
are not supported on Windows, though.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the covariance matrix Omega described by <em>Kalliovirta and Saikkonen 2010</em>.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>


<hr>
<h2 id='get_unconstrained_structural_pars'>Get structural parameters that indicate there are no constraints</h2><span id='topic+get_unconstrained_structural_pars'></span>

<h3>Description</h3>

<p><code>get_unconstrained_struct_pars</code> return structural parameters that indicate there are no constraints
(except possibly sign constraints).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unconstrained_structural_pars(structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_unconstrained_structural_pars_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Intended to be called after calling the function <code>reform_constrained_pars</code> to avoid remove the constraints
again in any further function calls as this will create bugs.
</p>


<h3>Value</h3>

<p>Returns a list with <code>$W</code> being <code class="reqn">(d x d)</code> matrix of NAs and <code>$C_lambda</code> being <code>NULL</code>. If the
supplied argument is <code>NULL</code>, returns <code>NULL</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='get_varying_h'>Get differences 'h' which are adjusted for overly large degrees of freedom parameters</h2><span id='topic+get_varying_h'></span>

<h3>Description</h3>

<p><code>get_varying_h</code> adjusts differences for overly large degrees of freedom parameters
for finite difference approximation of the derivatives of the log-likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_varying_h(M, params, model = c("GMVAR", "StMVAR", "G-StMVAR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_varying_h_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_varying_h_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="get_varying_h_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used for approximating gradient and Hessian of a StMVAR or G-StMVAR model.
Very large degrees of freedom parameters cause significant numerical error if too small differences
are used.
</p>


<h3>Value</h3>

<p>Returns a vector with the same length as <code>params</code>. For other parameters than degrees
of freedom parameters larger than 100, the differences will be <code>6e-6</code>. For the large degrees of
freedom parameters, the difference will be <code>signif(df/1000, digits=2)</code>.
</p>

<hr>
<h2 id='GFEVD'>Estimate generalized forecast error variance decomposition for structural
(and reduced form) GMVAR, StMVAR, and G-StMVAR models.</h2><span id='topic+GFEVD'></span><span id='topic+plot.gfevd'></span><span id='topic+print.gfevd'></span>

<h3>Description</h3>

<p><code>GFEVD</code> estimates generalized forecast error variance decomposition for structural
(and reduced form) GMVAR, StMVAR, and G-StMVAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GFEVD(
  gsmvar,
  shock_size = 1,
  N = 30,
  initval_type = c("data", "random", "fixed"),
  R1 = 250,
  R2 = 250,
  init_regimes = NULL,
  init_values = NULL,
  which_cumulative = numeric(0),
  include_mixweights = FALSE,
  ncores = 2,
  seeds = NULL
)

## S3 method for class 'gfevd'
plot(x, ...)

## S3 method for class 'gfevd'
print(x, ..., digits = 2, N_to_print)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GFEVD_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_shock_size">shock_size</code></td>
<td>
<p>What shocks size should be used for all shocks? By the definition of the SGMVAR,
SStMVAR, and SG-StMVAR model, the conditional covariance matrix of the structural shock is identity matrix.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_n">N</code></td>
<td>
<p>a positive integer specifying the horizon how far ahead should the GFEVD be calculated.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_initval_type">initval_type</code></td>
<td>
<p>What type initial values are used for estimating the GIRFs that the GFEVD is based on?
</p>

<dl>
<dt><code>"data"</code>:</dt><dd><p>Estimate the GIRF for all the possible length <code class="reqn">p</code> histories in the data.</p>
</dd>
<dt><code>"random"</code>:</dt><dd><p>Estimate the GIRF for several random initial values generated from the stationary
distribution of the process or from the stationary distribution of specific regime(s) chosen with the
argument <code>init_regimes</code>. The number of initial values is set with the argument <code>R2</code>.</p>
</dd>
<dt><code>"fixed"</code>:</dt><dd><p>Estimate the GIRF for a fixed initial value only, which is specified with the argument
<code>init_values</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GFEVD_+3A_r1">R1</code></td>
<td>
<p>the number of repetitions used to estimate GIRF for each initial
value.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_r2">R2</code></td>
<td>
<p>the number of initial values to be drawn if <code>initval_type="random"</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_init_regimes">init_regimes</code></td>
<td>
<p>a numeric vector of length at most <code class="reqn">M</code> and elements
in <code class="reqn">1,...,M</code> specifying the regimes from which the initial values
should be generated from. The initial values will be generated from a
mixture distribution with the mixture components being the stationary
distributions of the specific regimes and the (proportional) mixing weights
given by the mixing weight parameters of those regimes. Note that if
<code>init_regimes=1:M</code>, the initial values are generated from the
stationary distribution of the process and if <code>init_regimes=m</code>, the
initial value are generated from the stationary distribution of the
<code class="reqn">m</code>th regime. Ignored if the argument <code>init_values</code> is specified.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_init_values">init_values</code></td>
<td>
<p>a size <code class="reqn">(pxd)</code> matrix specifying the initial values, where d is the number
of time series in the system. The <strong>last</strong> row will be used as initial values for the first lag,
the second last row for second lag etc. If not specified, initial values will be drawn according to
mixture distribution specifed by the argument <code>init_regimes</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_which_cumulative">which_cumulative</code></td>
<td>
<p>a numeric vector with values in <code class="reqn">1,...,d</code>
(<code>d=ncol(data)</code>) specifying which the variables for which the impulse
responses should be cumulative. Default is none.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_include_mixweights">include_mixweights</code></td>
<td>
<p>should the GFEVD be estimated for the mixing weights as well? Note that this is
ignored if <code>M=1</code> and if <code>M=2</code> the GFEVD will be the same for both regime's mixing weights.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_ncores">ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing. Only
single core computing is supported if an initial value is specified (and
the GIRF won't thus be estimated multiple times).</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_seeds">seeds</code></td>
<td>
<p>a numeric vector containing the random number generator seed for estimation
of each GIRF. Should have the length...
</p>

<ul>
<li><p> ...<code>nrow(data) - p + 1</code> if <code>initval_type="data"</code>.
</p>
</li>
<li><p> ...<code>R2</code> if <code>initval_type="random"</code>.
</p>
</li>
<li><p> ...<code>1</code> if <code>initval_type="fixed."</code>.
</p>
</li></ul>

<p>Set to <code>NULL</code> for not initializing the seed. Exists for creating reproducible results.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_x">x</code></td>
<td>
<p>object of class <code>'gfevd'</code> generated by the function <code>GFEVD</code>.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
<tr><td><code id="GFEVD_+3A_n_to_print">N_to_print</code></td>
<td>
<p>an integer specifying the horizon how far to print the estimates.
The default is that all the values are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model DOES NOT need to be structural in order for this function to be
applicable. When an identified structural GMVAR, StMVAR, or G-StMVAR model is
provided in the argument <code>gsmvar</code>, the identification imposed by the model
is used. When a reduced form model is provided in the argument <code>gsmvar</code>,
lower triangular Cholesky identification is used to identify the shocks.
</p>
<p>The GFEVD is a forecast error variance decomposition calculated with the generalized impulse response function (GIRF).
Lanne and Nyberg (2016) for details. Note, however, that the related GIRFs are calculated using the algorithm given in
Virolainen (2022).
</p>


<h3>Value</h3>

<p>Returns and object of class 'gfevd' containing the GFEVD for all the variables and if
<code>include_mixweights=TRUE</code> also to the mixing weights. Note that the decomposition does not
exist at horizon zero for mixing weights because the related GIRFs are always zero at impact.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(gfevd)</code>: plot method
</p>
</li>
<li> <p><code>print(gfevd)</code>: print method
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Lanne M. and Nyberg H. 2016. Generalized Forecast Error Variance Decomposition for Linear
and Nonlineae Multivariate Models. <em>Oxford Bulletin of Economics and Statistics</em>, <strong>78</strong>, 4, 595-603.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+linear_IRF">linear_IRF</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>,
<code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>, <code><a href="#topic+reorder_W_columns">reorder_W_columns</a></code>, <code><a href="#topic+swap_W_signs">swap_W_signs</a></code>, <code><a href="#topic+simulate.gsmvar">simulate.gsmvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 # These are long-running examples that use parallel computing.
 # It takes approximately 30 seconds to run all the below examples.

 ## StMVAR(1, 2), d=2 model identified recursively by lower-triangular
 ## Cholesky decomposition (i.e., reduced form model is specified):
 params12t &lt;- c(0.55, 0.11, 0.34, 0.05, -0.01, 0.72, 0.58, 0.01, 0.06, 0.17,
   0.25, 0.34, 0.05, -0.01, 0.72, 0.50, -0.01, 0.20, 0.60, 3.00, 12.00)
 mod12t &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12t, model="StMVAR")

 # Estimating the GFEVD using all possible histories in the data as the
 # initial values:
 gfevd0 &lt;- GFEVD(mod12t, N=24, R1=10, initval_type="data")
 gfevd0
 plot(gfevd0)
 ## NOTE: Use larger R1 is empirical applications! Small R1 is used
 ## here only to fasten the execution time of the examples.

 ## Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
 params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
  0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
  0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
 W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
 mod22s &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22s,
  structural_pars=list(W=W_22))
 mod22s
 # Alternatively, use:
 #fit22s &lt;- fitGSMVAR(gdpdef, p=2, M=2, structural_pars=list(W=W_22),
 #                   ncalls=20, seeds=1:20)
 # To obtain an estimated version of the same model.

 # Estimating the GFEVD using all possible histories in the data as the
 # initial values:
 gfevd1 &lt;- GFEVD(mod22s, N=24, R1=10, initval_type="data")
 gfevd1
 plot(gfevd1)

 # Estimate GFEVD with the initial values generated from the stationary
 # distribution of the process:
 gfevd2 &lt;- GFEVD(mod22s, N=24, R1=10, R2=100, initval_type="random")
 gfevd2
 plot(gfevd2)

 # Estimate GFEVD with fixed hand specified initial values. We use the
 # unconditional mean of the process:
 myvals &lt;- rbind(mod22s$uncond_moments$uncond_mean,
                 mod22s$uncond_moments$uncond_mean)
 gfevd3 &lt;- GFEVD(mod22s, N=36, R1=50, initval_type="fixed",
  init_values=myvals, include_mixweights=TRUE)
 gfevd3
 plot(gfevd3)
 
</code></pre>

<hr>
<h2 id='GIRF'>Estimate generalized impulse response function for
structural (and reduced form) GMVAR, StMVAR, and G-StMVAR models.</h2><span id='topic+GIRF'></span><span id='topic+plot.girf'></span><span id='topic+print.girf'></span>

<h3>Description</h3>

<p><code>GIRF</code> estimates generalized impulse response function for
structural (and reduced form) GMVAR, StMVAR, and G-StMVAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GIRF(
  gsmvar,
  which_shocks,
  shock_size = 1,
  N = 30,
  R1 = 250,
  R2 = 250,
  init_regimes = 1:sum(gsmvar$model$M),
  init_values = NULL,
  which_cumulative = numeric(0),
  scale = NULL,
  scale_type = c("instant", "peak"),
  scale_horizon = N,
  ci = c(0.95, 0.8),
  include_mixweights = TRUE,
  ncores = 2,
  plot_res = TRUE,
  seeds = NULL,
  ...
)

## S3 method for class 'girf'
plot(x, add_grid = FALSE, margs, ...)

## S3 method for class 'girf'
print(x, ..., digits = 2, N_to_print)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GIRF_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_which_shocks">which_shocks</code></td>
<td>
<p>a numeric vector of length at most <code class="reqn">d</code>
(<code>=ncol(data)</code>) and elements in <code class="reqn">1,...,d</code> specifying the
structural shocks for which the GIRF should be estimated.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_shock_size">shock_size</code></td>
<td>
<p>a non-zero scalar value specifying the common size for all scalar
components of the structural shock. Note that the conditional covariance
matrix of the structural shock is an identity matrix and that the
(generalized) impulse responses may not be symmetric to the sign and size
of the shock.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_n">N</code></td>
<td>
<p>a positive integer specifying the horizon how far ahead should the
generalized impulse responses be calculated.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_r1">R1</code></td>
<td>
<p>the number of repetitions used to estimate GIRF for each initial
value.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_r2">R2</code></td>
<td>
<p>the number of initial values to be drawn from a stationary
distribution of the process or of a specific regime? The confidence bounds
will be sample quantiles of the GIRFs based on different initial values.
Ignored if the argument <code>init_value</code> is specified.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_init_regimes">init_regimes</code></td>
<td>
<p>a numeric vector of length at most <code class="reqn">M</code> and elements
in <code class="reqn">1,...,M</code> specifying the regimes from which the initial values
should be generated from. The initial values will be generated from a
mixture distribution with the mixture components being the stationary
distributions of the specific regimes and the (proportional) mixing weights
given by the mixing weight parameters of those regimes. Note that if
<code>init_regimes=1:M</code>, the initial values are generated from the
stationary distribution of the process and if <code>init_regimes=m</code>, the
initial value are generated from the stationary distribution of the
<code class="reqn">m</code>th regime. Ignored if the argument <code>init_values</code> is specified.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_init_values">init_values</code></td>
<td>
<p>a size <code class="reqn">(pxd)</code> matrix specifying the initial values, where d is the number
of time series in the system. The <strong>last</strong> row will be used as initial values for the first lag,
the second last row for second lag etc. If not specified, initial values will be drawn according to
mixture distribution specifed by the argument <code>init_regimes</code>.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_which_cumulative">which_cumulative</code></td>
<td>
<p>a numeric vector with values in <code class="reqn">1,...,d</code>
(<code>d=ncol(data)</code>) specifying which the variables for which the impulse
responses should be cumulative. Default is none.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_scale">scale</code></td>
<td>
<p>should the GIRFs to some of the shocks be scaled so that they
correspond to a specific magnitude of instantaneous or peak response
of some specific variable (see the argument <code>scale_type</code>)?
Provide a length three vector where the shock of interest
is given in the first element (an integer in <code class="reqn">1,...,d</code>), the variable of
interest is given in the second element (an integer in <code class="reqn">1,...,d</code>), and
the magnitude of its instantaneous or peak response in the third element
(a non-zero real number). If the GIRFs of multiple shocks should be scaled, provide
a matrix which has one column for each of the shocks with the columns being
the length three vectors described above.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_scale_type">scale_type</code></td>
<td>
<p>If argument <code>scale</code> is specified, should the GIRFs be
scaled to match an instantaneous response (<code>"instant"</code>) or peak response
(<code>"peak"</code>). If <code>"peak"</code>, the scale is based on the largest magnitude
of peak response in absolute value. Ignored if <code>scale</code> is not specified.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_scale_horizon">scale_horizon</code></td>
<td>
<p>If <code>scale_type == "peak"</code> what the maximum horizon up
to which peak response is expected? Scaling won't based on values after this.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_ci">ci</code></td>
<td>
<p>a numeric vector with elements in <code class="reqn">(0, 1)</code> specifying the
confidence levels of the confidence intervals.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_include_mixweights">include_mixweights</code></td>
<td>
<p>should the generalized impulse response be
calculated for the mixing weights as well? <code>TRUE</code> or <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_ncores">ncores</code></td>
<td>
<p>the number CPU cores to be used in parallel computing. Only
single core computing is supported if an initial value is specified (and
the GIRF won't thus be estimated multiple times).</p>
</td></tr>
<tr><td><code id="GIRF_+3A_plot_res">plot_res</code></td>
<td>
<p><code>TRUE</code> if the results should be plotted, <code>FALSE</code> if
not.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_seeds">seeds</code></td>
<td>
<p>a length <code>R2</code> vector containing the random number generator
seed for estimation of each GIRF. A single number of an initial value is
specified. or <code>NULL</code> for not initializing the seed. Exists for
creating reproducible results.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>grid</code> which plots grid to the figure.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_x">x</code></td>
<td>
<p>object of class <code>'girf'</code> generated by the function <code>GIRF</code>.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_add_grid">add_grid</code></td>
<td>
<p>should grid be added to the plots?</p>
</td></tr>
<tr><td><code id="GIRF_+3A_margs">margs</code></td>
<td>
<p>numeric vector of length four that adjusts the
<code>[bottom_marginal, left_marginal, top_marginal, right_marginal]</code>
as the relative sizes of the marginals to the figures of the responses.</p>
</td></tr>
<tr><td><code id="GIRF_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
<tr><td><code id="GIRF_+3A_n_to_print">N_to_print</code></td>
<td>
<p>an integer specifying the horizon how far to print the estimates and
confidence intervals. The default is that all the values are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model DOES NOT need to be structural in order for this function to be
applicable. When an identified structural GMVAR, StMVAR, or G-StMVAR model is
provided in the argument <code>gsmvar</code>, the identification imposed by the model
is used. When a reduced form model is provided in the argument <code>gsmvar</code>,
lower triangular Cholesky identification is used to identify the shocks.
</p>
<p>The confidence bounds reflect uncertainty about the initial state (but
currently not about the parameter estimates) if initial values are not
specified. If initial values are specified, there won't currently be
confidence intervals. See the cited paper by Virolainen (2022) for details
about the algorithm.
</p>
<p>Note that if the argument <code>scale</code> is used, the scaled responses of
the mixing weights might be more than one in absolute value.
</p>


<h3>Value</h3>

<p>Returns a class <code>'girf'</code> list with the GIRFs in the first
element (<code>$girf_res</code>) and the used arguments the rest. The first
element containing the GIRFs is a list with the <code class="reqn">m</code>th element
containing the point estimates for the GIRF in <code>$point_est</code> (the first
element) and confidence intervals in <code>$conf_ints</code> (the second
element). The first row is for the GIRF at impact <code class="reqn">(n=0)</code>, the second
for <code class="reqn">n=1</code>, the third for <code class="reqn">n=2</code>, and so on.
</p>
<p>The element <code>$all_girfs</code> is a list containing results from all the individual GIRFs
obtained from the MC repetitions. Each element is for one shock and results are in
array of the form <code>[horizon, variables, MC-repetitions]</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(girf)</code>: plot method
</p>
</li>
<li> <p><code>print(girf)</code>: print method
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GFEVD">GFEVD</a></code>, <code><a href="#topic+linear_IRF">linear_IRF</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>,
<code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>, <code><a href="#topic+reorder_W_columns">reorder_W_columns</a></code>,
<code><a href="#topic+swap_W_signs">swap_W_signs</a></code>, <code><a href="#topic+simulate.gsmvar">simulate.gsmvar</a></code>,
<code><a href="#topic+predict.gsmvar">predict.gsmvar</a></code>, <code><a href="#topic+profile_logliks">profile_logliks</a></code>,
<code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+LR_test">LR_test</a></code>,
<code><a href="#topic+Wald_test">Wald_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 # These are long-running examples that use parallel computing.
 # It takes approximately 30 seconds to run all the below examples.

 ## StMVAR(1, 2), d=2 model identified recursively by lower-triangular
 ## Cholesky decomposition (i.e., reduced form model is specified):
 params12t &lt;- c(0.55, 0.11, 0.34, 0.05, -0.01, 0.72, 0.58, 0.01, 0.06, 0.17,
   0.25, 0.34, 0.05, -0.01, 0.72, 0.50, -0.01, 0.20, 0.60, 3.00, 12.00)
 mod12t &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12t, model="StMVAR")

 # Estimating the GIRFs of both structural shocks with initial values
 # drawn from the stationary distribution of the process,
 # 12 periods ahead, confidence levels 0.95 and 0.8:
 girf0 &lt;- GIRF(mod12t, N=12, R1=100, R2=100)
 girf0
 plot(girf0)
 ## NOTE: Small R1 and R2 is used here to shorten the estimation time.
 ## Larger R1 and R2 should be considered in empirical applications!

 ## Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
 params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
  0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
   0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
 W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
 mod22s &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22s,
  structural_pars=list(W=W_22))
 mod22s
 # Alternatively, use:
 #fit22s &lt;- fitGSMVAR(gdpdef, p=2, M=2, structural_pars=list(W=W_22),
 #                   ncalls=20, seeds=1:20)
 # To obtain an estimated version of the same model.

 # Estimating the GIRFs of both structural shocks with initial values
 # drawn from the stationary distribution of the process,
 # 12 periods ahead, confidence levels 0.95 and 0.8:
 girf1 &lt;- GIRF(mod22s, N=12, R1=100, R2=100)
 girf1
 plot(girf1)

 # Estimating the GIRF of the second shock only, 12 periods ahead
 # and shock size 1, initial values drawn from the stationary distribution
 # of the first regime, confidence level 0.9:
 girf2 &lt;- GIRF(mod22s, which_shocks=2, shock_size=1, N=12, init_regimes=1,
               ci=0.9, R1=100, R2=100)

 # Estimating the GIRFs of both structural shocks, negative one standard
 # error shock, N=20 periods ahead, estimation based on 200 Monte Carlo
 # simulations, and fixed initial values given by the last p observations
 # of the data:
 girf3 &lt;- GIRF(mod22s, shock_size=-1, N=20, R1=200,
               init_values=mod22s$data)
 
</code></pre>

<hr>
<h2 id='GMVAR'>DEPRECATED! USE THE FUNCTION GSMVAR INSTEAD! Create a class 'gsmvar' object defining
a reduced form or structural GMVAR model</h2><span id='topic+GMVAR'></span>

<h3>Description</h3>

<p><code>GSMVAR</code> creates a class <code>'gsmvar'</code> object that defines
a reduced form or structural GMVAR model DEPRECATED! USE THE FUNCTION GSMVAR INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GMVAR(
  data,
  p,
  M,
  d,
  params,
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  structural_pars = NULL,
  calc_cond_moments,
  calc_std_errors = FALSE,
  stat_tol = 0.001,
  posdef_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GMVAR_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a single times series. <code>NA</code> values are not supported. Ignore if defining a model without data is desired.</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GMVAR_+3A_d">d</code></td>
<td>
<p>number of times series in the system, i.e. <code>ncol(data)</code>. This can be
used to define GSMVAR models without data and can be ignored if <code>data</code> is provided.</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function
should be used.</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="GMVAR_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_calc_cond_moments">calc_cond_moments</code></td>
<td>
<p>should conditional means and covariance matrices should be calculated?
Default is <code>TRUE</code> if the model contains data and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="GMVAR_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is provided, then also multivariate quantile residuals (<em>Kalliovirta and Saikkonen 2010</em>)
are computed and included in the returned object.
</p>
<p>If the function fails to calculate approximative standard errors and the parameter values are near the border
of the parameter space, it might help to use smaller numerical tolerance for the stationarity and positive
definiteness conditions.
</p>
<p>The first plot displays the time series together with estimated mixing weights.
The second plot displays a (Gaussian) kernel density estimates of the individual series
together with the marginal stationary density implied by the model. The colored regimewise
stationary densities are multiplied with the mixing weight parameter estimates.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the specified reduced form or structural GMVAR,
StMVAR, or G-StMVAR model. Can be used to work with other functions provided in <code>gmvarkit</code>.
</p>
<p>Note that the first autocovariance/correlation matrix in <code>$uncond_moments</code> is for the lag zero,
the second one for the lag one, etc.
</p>


<h3>About S3 methods</h3>

<p>Only the <code>print</code> method is available if data is not provided.
If data is provided, then in addition to the ones listed above, the <code>predict</code> method is also available.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+GSMVAR">GSMVAR</a></code>
</p>

<hr>
<h2 id='gmvar_to_gsmvar'>Makes class 'gmvar' objects compatible with the functions using class 'gsmvar' objects</h2><span id='topic+gmvar_to_gsmvar'></span>

<h3>Description</h3>

<p><code>gmvar_to_gsmvar</code> class 'gmvar' objects compatible with the functions using
s class 'gsmvar' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmvar_to_gsmvar(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmvar_to_gsmvar_+3A_gsmvar">gsmvar</code></td>
<td>
<p>a class 'gmvar' or 'gsmvar' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This exists so that models estimated with earlier versions
of the package can be used conveniently.
</p>


<h3>Value</h3>

<p>If the provided object has the class 'gsmvar', the provided object
is returned without modifications. If the provided object has the class 'gmvar',
its element <code>$model</code> is given a new subelement called also model and this is
set to be &quot;GMVAR&quot;. Also, the class of this object is changes to 'gsmvar' and then
it is returned.
</p>

<hr>
<h2 id='gmvar_to_sgmvar'>DEPRECATED! USE THE FUNCTION fitGSMVAR INSTEAD!
Switch from two-regime reduced form GMVAR model to a structural model.</h2><span id='topic+gmvar_to_sgmvar'></span>

<h3>Description</h3>

<p>DEPRECATED! USE THE FUNCTION fitGSMVAR INSTEAD!
<code>gsmvar_to_sgsmvar</code> constructs SGMVAR model based on a reduced
form GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmvar_to_sgmvar(gmvar, calc_std_errors = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmvar_to_sgmvar_+3A_gmvar">gmvar</code></td>
<td>
<p>object of class 'gmvar'</p>
</td></tr>
<tr><td><code id="gmvar_to_sgmvar_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The switch is made by simultaneously diagonalizing the two error term covariance matrices
with a well known matrix decomposition (Muirhead, 1982, Theorem A9.9) and then normalizing the
diagonal of the matrix W positive (which implies positive diagonal of the B-matrix). Models with
more that two regimes are not supported because the matrix decomposition does not generally
exists for more than two covariance matrices. If the model has only one regime (= regular SVAR model),
a symmetric and pos. def. square root matrix of the error term covariance matrix is used <strong>unless</strong>
<code>cholesky = TRUE</code> is set in the arguments, in which case Cholesky identification is employed.
</p>
<p>In order to employ a structural model with Cholesky identification and multiple regimes (<code>M &gt; 1</code>),
use the function <code>GIRF</code> directly with a reduced form model (see <code>?GIRF</code>).
</p>
<p>The columns of <code class="reqn">W</code> as well as the lambda parameters can be re-ordered (without changing the implied
reduced form model) afterwards with the function <code>reorder_W_columns</code>. Also all signs in any column
of <code class="reqn">W</code> can be swapped (without changing the implied reduced form model) afterwards with the function
<code>swap_W_signs</code>. These two functions work with models containing any number of regimes.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining a structural GMVAR, StMVAR, or G-StMVAR model based on a
two-regime reduced form GMVAR, StMVAR, or G-StMVAR model, with the main diagonal of the B-matrix normalized to be
positive.
</p>


<h3>References</h3>


<ul>
<li><p> Muirhead R.J. 1982. Aspects of Multivariate Statistical Theory, <em>Wiley</em>.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>
</p>

<hr>
<h2 id='gmvarkit-package'>gmvarkit: Estimate Gaussian and Student's t Mixture Vector Autoregressive Models</h2><span id='topic+gmvarkit'></span><span id='topic+gmvarkit-package'></span>

<h3>Description</h3>

<p><code>gmvarkit</code> is a package for reduced form and structural Gaussian mixture vector
autoregressive (GMVAR), Student's t Mixture Vector Autoregressive (StMVAR),
or Gaussian and Student's t Mixture Vector Autoregressive (G-StMVAR) model analysis.
It provides functions for unconstrained and constrained maximum likelihood estimation of the model parameters,
quantile residuals tests, graphical diagnostics, estimation of generalized impulse response function,
estimation of generalized forecast error variance decomposition, simulation from GMVAR processes,
forecasting, and more.
</p>
<p>The readme file is a good place to start and the vignette might be useful too.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Savi Virolainen <a href="mailto:savi.virolainen@helsinki.fi">savi.virolainen@helsinki.fi</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/saviviro/gmvarkit/issues">https://github.com/saviviro/gmvarkit/issues</a>
</p>
</li></ul>


<hr>
<h2 id='GSMVAR'>Create a class 'gsmvar' object defining a reduced form or structural GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+GSMVAR'></span><span id='topic+logLik.gsmvar'></span><span id='topic+residuals.gsmvar'></span><span id='topic+summary.gsmvar'></span><span id='topic+plot.gsmvar'></span><span id='topic+print.gsmvar'></span>

<h3>Description</h3>

<p><code>GSMVAR</code> creates a class <code>'gsmvar'</code> object that defines
a reduced form or structural GMVAR, StMVAR, or G-StMVAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GSMVAR(
  data,
  p,
  M,
  d,
  params,
  conditional = TRUE,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  calc_cond_moments,
  calc_std_errors = FALSE,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)

## S3 method for class 'gsmvar'
logLik(object, ...)

## S3 method for class 'gsmvar'
residuals(object, ...)

## S3 method for class 'gsmvar'
summary(object, ..., digits = 2)

## S3 method for class 'gsmvar'
plot(x, ..., type = c("both", "series", "density"))

## S3 method for class 'gsmvar'
print(x, ..., digits = 2, summary_print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GSMVAR_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a single times series. <code>NA</code> values are not supported. Ignore if defining a model without data is desired.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GSMVAR_+3A_d">d</code></td>
<td>
<p>number of times series in the system, i.e. <code>ncol(data)</code>. This can be
used to define GSMVAR models without data and can be ignored if <code>data</code> is provided.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function
should be used.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_calc_cond_moments">calc_cond_moments</code></td>
<td>
<p>should conditional means and covariance matrices should be calculated?
Default is <code>TRUE</code> if the model contains data and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_object">object</code></td>
<td>
<p>object of class <code>'gsmvar'</code> generated by <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_digits">digits</code></td>
<td>
<p>number of digits to be printed.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_x">x</code></td>
<td>
<p>object of class <code>'gsmvar'</code> generated by <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_type">type</code></td>
<td>
<p>which type figure should be produced? Or both?</p>
</td></tr>
<tr><td><code id="GSMVAR_+3A_summary_print">summary_print</code></td>
<td>
<p>if set to <code>TRUE</code> then the print
will include log-likelihood and information criteria values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is provided, then also multivariate quantile residuals (<em>Kalliovirta and Saikkonen 2010</em>)
are computed and included in the returned object.
</p>
<p>If the function fails to calculate approximative standard errors and the parameter values are near the border
of the parameter space, it might help to use smaller numerical tolerance for the stationarity and positive
definiteness conditions.
</p>
<p>The first plot displays the time series together with estimated mixing weights.
The second plot displays a (Gaussian) kernel density estimates of the individual series
together with the marginal stationary density implied by the model. The colored regimewise
stationary densities are multiplied with the mixing weight parameter estimates.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the specified reduced form or structural GMVAR,
StMVAR, or G-StMVAR model. Can be used to work with other functions provided in <code>gmvarkit</code>.
</p>
<p>Note that the first autocovariance/correlation matrix in <code>$uncond_moments</code> is for the lag zero,
the second one for the lag one, etc.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>logLik(gsmvar)</code>: Log-likelihood method
</p>
</li>
<li> <p><code>residuals(gsmvar)</code>: residuals method to extract multivariate quantile residuals
</p>
</li>
<li> <p><code>summary(gsmvar)</code>: summary method
</p>
</li>
<li> <p><code>plot(gsmvar)</code>: plot method for class 'gsmvar'
</p>
</li>
<li> <p><code>print(gsmvar)</code>: print method
</p>
</li></ul>


<h3>About S3 methods</h3>

<p>If data is not provided, only the <code>print</code> and <code>simulate</code> methods are available.
If data is provided, then in addition to the ones listed above, <code>predict</code> method is also available.
See <code>?simulate.gsmvar</code> and <code>?predict.gsmvar</code> for details about the usage.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+add_data">add_data</a></code>, <code><a href="#topic+swap_parametrization">swap_parametrization</a></code>, <code><a href="#topic+GIRF">GIRF</a></code>,
<code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>, <code><a href="#topic+stmvar_to_gstmvar">stmvar_to_gstmvar</a></code>, <code><a href="#topic+reorder_W_columns">reorder_W_columns</a></code>,
<code><a href="#topic+swap_W_signs">swap_W_signs</a></code>, <code><a href="#topic+update_numtols">update_numtols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(1, 2), d=2 model:
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005,
  0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012,
  0.136, 0.674)
mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)
mod12

# GMVAR(1, 2), d=2 model without data
mod12_2 &lt;- GSMVAR(p=1, M=2, d=2, params=params12)
mod12_2

# StMVAR(1, 2), d=2 model:
mod12t &lt;- GSMVAR(gdpdef, p=1, M=2, params=c(params12, 10, 20),
                 model="StMVAR")
mod12t

# G-StMVAR(1, 1, 1), d=2 model:
mod12gs &lt;- GSMVAR(gdpdef, p=1, M=c(1, 1), params=c(params12, 20),
                  model="G-StMVAR")
mod12gs

# GMVAR(2, 2), d=2 model with mean-parametrization:
params22 &lt;- c(0.869, 0.549, 0.223, 0.059, -0.151, 0.395, 0.406,
 -0.005, 0.083, 0.299, 0.215, 0.002, 0.03, 0.576, 1.168, 0.218,
 0.02, -0.119, 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004,
 0.105, 0.58)
mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22, parametrization="mean")
mod22

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
  0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
  0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22s,
 structural_pars=list(W=W_22))
mod22s
</code></pre>

<hr>
<h2 id='gsmvar_to_sgsmvar'>Switch from two-regime reduced form GMVAR, StMVAR, or G-StMVAR model to a structural model.</h2><span id='topic+gsmvar_to_sgsmvar'></span>

<h3>Description</h3>

<p><code>gsmvar_to_sgsmvar</code> constructs SGMVAR, SStMVAR, or SG-StMVAR model based on a reduced
form GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsmvar_to_sgsmvar(gsmvar, calc_std_errors = TRUE, cholesky = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsmvar_to_sgsmvar_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="gsmvar_to_sgsmvar_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
<tr><td><code id="gsmvar_to_sgsmvar_+3A_cholesky">cholesky</code></td>
<td>
<p>if <code>M == 1</code>, should the lower triangular Cholesky identification be employed?
See details for using Cholesky identification with <code>M &gt; 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The switch is made by simultaneously diagonalizing the two error term covariance matrices
with a well known matrix decomposition (Muirhead, 1982, Theorem A9.9) and then normalizing the
diagonal of the matrix W positive (which implies positive diagonal of the B-matrix). Models with
more that two regimes are not supported because the matrix decomposition does not generally
exists for more than two covariance matrices. If the model has only one regime (= regular SVAR model),
a symmetric and pos. def. square root matrix of the error term covariance matrix is used <strong>unless</strong>
<code>cholesky = TRUE</code> is set in the arguments, in which case Cholesky identification is employed.
</p>
<p>In order to employ a structural model with Cholesky identification and multiple regimes (<code>M &gt; 1</code>),
use the function <code>GIRF</code> directly with a reduced form model (see <code>?GIRF</code>).
</p>
<p>The columns of <code class="reqn">W</code> as well as the lambda parameters can be re-ordered (without changing the implied
reduced form model) afterwards with the function <code>reorder_W_columns</code>. Also all signs in any column
of <code class="reqn">W</code> can be swapped (without changing the implied reduced form model) afterwards with the function
<code>swap_W_signs</code>. These two functions work with models containing any number of regimes.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining a structural GMVAR, StMVAR, or G-StMVAR model based on a
two-regime reduced form GMVAR, StMVAR, or G-StMVAR model, with the main diagonal of the B-matrix normalized to be
positive.
</p>


<h3>References</h3>


<ul>
<li><p> Muirhead R.J. 1982. Aspects of Multivariate Statistical Theory, <em>Wiley</em>.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+reorder_W_columns">reorder_W_columns</a></code>,
<code><a href="#topic+swap_W_signs">swap_W_signs</a></code>, <code><a href="#topic+stmvar_to_gstmvar">stmvar_to_gstmvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Reduced form GMVAR(1,2) model
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319,
 0.005, 0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185,
 -0.012, 0.136, 0.674)
mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)

# Form a structural model based on the reduced form model:
mod12s &lt;- gsmvar_to_sgsmvar(mod12)
mod12s

#' # Reduced form StMVAR(1,2) model
mod12t &lt;- GSMVAR(gdpdef, p=1, M=2, params=c(params12, 11, 12), model="StMVAR")

# Form a structural model based on the reduced form model:
mod12ts &lt;- gsmvar_to_sgsmvar(mod12t)
mod12ts

</code></pre>

<hr>
<h2 id='in_paramspace'>Determine whether the parameter vector lies in the parameter space</h2><span id='topic+in_paramspace'></span>

<h3>Description</h3>

<p><code>in_paramspace</code> checks whether the given parameter vector lies in
the parameter space. Does NOT test the identification conditions!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_paramspace(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_paramspace_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="in_paramspace_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="in_paramspace_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the given parameter vector lies in the parameter space
and <code>FALSE</code> otherwise.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(1,1), d=2 model:
params11 &lt;- c(1.07, 127.71, 0.99, 0.00, -0.01, 0.99, 4.05,
  2.22, 8.87)
in_paramspace(p=1, M=1, d=2, params=params11)

# GMVAR(2,2), d=2 model:
params22 &lt;- c(1.39, -0.77, 1.31, 0.14, 0.09, 1.29, -0.39,
 -0.07, -0.11, -0.28, 0.92, -0.03, 4.84, 1.01, 5.93, 1.25,
  0.08, -0.04, 1.27, -0.27, -0.07, 0.03, -0.31, 5.85, 3.57,
  9.84, 0.74)
in_paramspace(p=2, M=2, d=2, params=params22)

# GMVAR(2,2), d=2 model with AR-parameters restricted to be
# the same for both regimes:
C_mat &lt;- rbind(diag(2*2^2), diag(2*2^2))
params22c &lt;- c(1.03, 2.36, 1.79, 3.00, 1.25, 0.06,0.04,
 1.34, -0.29, -0.08, -0.05, -0.36, 0.93, -0.15, 5.20,
 5.88, 3.56, 9.80, 0.37)
in_paramspace(p=2, M=2, d=2, params=params22c, constraints=C_mat)

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(1.03, 2.36, 1.79, 3, 1.25, 0.06, 0.04, 1.34, -0.29,
 -0.08, -0.05, -0.36, 1.2, 0.05, 0.05, 1.3, -0.3, -0.1, -0.05, -0.4,
  0.89, 0.72, -0.37, 2.16, 7.16, 1.3, 0.37)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
in_paramspace(p=2, M=2, d=2, params=params22s,
  structural_pars=list(W=W_22))
</code></pre>

<hr>
<h2 id='in_paramspace_int'>Determine whether the parameter vector lies in the parameter space</h2><span id='topic+in_paramspace_int'></span>

<h3>Description</h3>

<p><code>in_paramspace_int</code> checks whether the parameter vector lies in the parameter
space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in_paramspace_int(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  all_boldA,
  alphas,
  all_Omega,
  W_constraints = NULL,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="in_paramspace_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_all_bolda">all_boldA</code></td>
<td>
<p>3D array containing the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; matrices related to each mixture component VAR-process,
obtained from <code>form_boldA</code>. Will be computed if not given.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_alphas">alphas</code></td>
<td>
<p>(Mx1) vector containing all mixing weight parameters, obtained from <code>pick_alphas</code>.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_all_omega">all_Omega</code></td>
<td>
<p>3D array containing all covariance matrices <code class="reqn">\Omega_{m}</code>, obtained from <code>pick_Omegas</code>.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_w_constraints">W_constraints</code></td>
<td>
<p>set <code>NULL</code> for reduced form models. For structural models, this should be the
constraint matrix <code class="reqn">W</code> from the list of structural parameters.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="in_paramspace_int_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter vector in the argument <code>params</code> should be unconstrained and it is used for
structural models only.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the given parameter values are in the parameter space and <code>FALSE</code> otherwise.
This function does NOT consider the identifiability condition!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='is_stationary'>Check the stationary condition of a given GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+is_stationary'></span>

<h3>Description</h3>

<p><code>is_stationary</code> checks the stationarity condition of a GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_stationary(
  p,
  M,
  d,
  params,
  all_boldA = NULL,
  structural_pars = NULL,
  tolerance = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_stationary_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="is_stationary_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="is_stationary_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="is_stationary_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="is_stationary_+3A_all_bolda">all_boldA</code></td>
<td>
<p>3D array containing the <code class="reqn">((dp)x(dp))</code> &quot;bold A&quot; matrices related to each mixture component VAR-process,
obtained from <code>form_boldA</code>. Will be computed if not given.</p>
</td></tr>
<tr><td><code id="is_stationary_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="is_stationary_+3A_tolerance">tolerance</code></td>
<td>
<p>Returns <code>FALSE</code> if modulus of any eigenvalue is larger or equal to <code>1-tolerance</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model is constrained, remove the constraints first with the function <code>reform_constrained_pars</code>.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the model is stationary and <code>FALSE</code> if not. Based on the argument <code>tolerance</code>,
<code>is_stationary</code> may return <code>FALSE</code> when the parameter vector is in the stationarity region, but
very close to the boundary (this is used to ensure numerical stability in estimation of the model parameters).
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='iterate_more'>Maximum likelihood estimation of a GMVAR, StMVAR, or G-StMVAR model with preliminary estimates</h2><span id='topic+iterate_more'></span>

<h3>Description</h3>

<p><code>iterate_more</code> uses a variable metric algorithm to finalize maximum likelihood
estimation of a GMVAR, StMVAR, or G-StMVAR model (object of class <code>'gsmvar'</code>) which already has preliminary estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate_more(
  gsmvar,
  maxit = 100,
  calc_std_errors = TRUE,
  custom_h = NULL,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterate_more_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations in the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>calculate approximate standard errors for the estimates?</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_custom_h">custom_h</code></td>
<td>
<p>A numeric vector with same the length as the parameter vector: i:th element of custom_h is the difference
used in central difference approximation for partial differentials of the log-likelihood function for the i:th parameter.
If <code>NULL</code> (default), then the difference used for differentiating overly large degrees of freedom parameters
is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other parameters.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of <code>iterate_more</code> is to provide a simple and convenient tool to finalize
the estimation when the maximum number of iterations is reached when estimating a GMVAR, StMVAR, or G-StMVAR model
with the main estimation function <code>fitGSMVAR</code>. <code>iterate_more</code> is essentially a wrapper
around the function <code>optim</code> from the package <code>stats</code> and <code>GSMVAR</code> from the package
<code>gmvarkit</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the estimated GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+update_numtols">update_numtols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples that use parallel computing!
## Running the below examples takes approximately 2 minutes

# GMVAR(1,2) model, only 5 iterations of the variable metric
# algorithm
fit12 &lt;- fitGSMVAR(gdpdef, p=1, M=2, ncalls=1, maxit=5, seeds=1)
fit12

# Iterate more:
fit12_2 &lt;- iterate_more(fit12)
fit12_2

</code></pre>

<hr>
<h2 id='linear_IRF'>Estimate linear impulse response function based on a single regime of a structural GMVAR,
StMVAR, or G-StMVAR model.</h2><span id='topic+linear_IRF'></span><span id='topic+plot.irf'></span><span id='topic+print.irf'></span>

<h3>Description</h3>

<p><code>linear_IRF</code> estimates linear impulse response function based on a single regime
of a structural GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_IRF(
  gsmvar,
  N = 30,
  regime = 1,
  which_cumulative = numeric(0),
  scale = NULL,
  ci = NULL,
  bootstrap_reps = 100,
  ncores = 2,
  ncalls = 1,
  seeds = NULL,
  ...
)

## S3 method for class 'irf'
plot(x, shocks_to_plot, ...)

## S3 method for class 'irf'
print(x, ..., digits = 2, N_to_print, shocks_to_print)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_IRF_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code> defining a structural or reduced form
GSMVAR model. For a reduced form model, the shocks are automatically identified by
the lower triangular Cholesky decomposition.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_n">N</code></td>
<td>
<p>a positive integer specifying the horizon how far ahead should the
linear impulse responses be calculated.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_regime">regime</code></td>
<td>
<p>Based on which regime the linear IRF should be calculated?
An integer in <code class="reqn">1,...,M</code>.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_which_cumulative">which_cumulative</code></td>
<td>
<p>a numeric vector with values in <code class="reqn">1,...,d</code>
(<code>d=ncol(data)</code>) specifying which the variables for which the linear impulse
responses should be cumulative. Default is none.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_scale">scale</code></td>
<td>
<p>should the linear IRFs to some of the shocks be scaled so that they
correspond to a specific instantaneous response of some specific
variable? Provide a length three vector where the shock of interest
is given in the first element (an integer in <code class="reqn">1,...,d</code>), the variable of
interest is given in the second element (an integer in <code class="reqn">1,...,d</code>), and
its instantaneous response in the third element (a non-zero real number).
If the linear IRFs of multiple shocks should be scaled, provide a matrix which has one
column for each of the shocks with the columns being the length three vectors described above.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_ci">ci</code></td>
<td>
<p>a real number in <code class="reqn">(0, 1)</code> specifying the confidence level of the
confidence intervals calculated via a fixed-design wild residual bootstrap method.
Available only for models that impose linear autoregressive dynamics
(excluding changes in the volatility regime).</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_bootstrap_reps">bootstrap_reps</code></td>
<td>
<p>the number of bootstrap repetitions for estimating confidence bounds.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to be used in parallel computing when bootstrapping confidence bounds.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_ncalls">ncalls</code></td>
<td>
<p>on how many estimation rounds should each bootstrap estimation be based on?
Does not have to be very large since initial estimates used are based on the initially fitted model.
Larger number of rounds gives more reliable results but is computationally more demanding.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_seeds">seeds</code></td>
<td>
<p>a numeric vector of length <code>bootstrap_reps</code> initializing the seed for the random
generator for each bootstrap replication.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_x">x</code></td>
<td>
<p>object of class <code>'irf'</code> generated by the function <code>linear_IRF</code>.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_shocks_to_plot">shocks_to_plot</code></td>
<td>
<p>IRFs of which shocks should be plotted? A numeric vector
with elements in <code>1,...,d</code>.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_n_to_print">N_to_print</code></td>
<td>
<p>an integer specifying the horizon how far to print the estimates and
confidence intervals. The default is that all the values are printed.</p>
</td></tr>
<tr><td><code id="linear_IRF_+3A_shocks_to_print">shocks_to_print</code></td>
<td>
<p>the responses to which should should be printed?
A numeric vector with elements in <code>1,...,d</code>. The default is that responses to
all the shocks are printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model DOES NOT need to be structural in order for this function to be
applicable. When an identified structural GMVAR, StMVAR, or G-StMVAR model is
provided in the argument <code>gsmvar</code>, the identification imposed by the model
is used. When a reduced form model is provided in the argument <code>gsmvar</code>,
lower triangular Cholesky identification is used to identify the shocks.
</p>
<p>If the autoregressive dynamics of the model are linear (i.e., either M == 1 or mean and AR parameters
are constrained identical across the regimes), confidence bounds can be calculated based on a type of fixed-design
wild residual bootstrap method. See Virolainen (forthcoming) for a related discussion. We employ the method described
in Herwartz and Ltkepohl (2014); see also the relevant chapters in Kilian and Ltkepohl (2017).
</p>


<h3>Value</h3>

<p>Returns a class <code>'irf'</code> list with the following elements:
</p>

<dl>
<dt><code>$point_est</code>:</dt><dd><p>a 3D array <code>[variables, shock, horizon]</code> containing the point estimates of the IRFs.
Note that the first slice is for the impact responses and the slice i+1 for the period i. The response of the
variable 'i1' to the shock 'i2' is subsetted as <code>$point_est[i1, i2, ]</code>.</p>
</dd>
<dt><code>$conf_ints</code>:</dt><dd><p>bootstrapped confidence intervals for the IRFs in a <code>[variables, shock, horizon, bound]</code>
4D array. The lower bound is obtained as <code>$conf_ints[, , , 1]</code>, and similarly the upper bound as
<code>$conf_ints[, , , 2]</code>. The subsetted 3D array is then the bound in a form similar to <code>$point_est</code>.</p>
</dd>
<dt><code>$all_bootstrap_reps</code>:</dt><dd><p>IRFs from all of the bootstrap replications in a <code>[variables, shock, horizon, rep]</code>.
4D array. The IRF from replication i1 is obtained as <code>$all_bootstrap_reps[, , , i1]</code>, and the subsetted 3D array
is then the in a form similar to <code>$point_est</code>.</p>
</dd>
<dt>Other elements:</dt><dd><p>contains some of the arguments the <code>linear_IRF</code> was called with.</p>
</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(irf)</code>: plot method
</p>
</li>
<li> <p><code>print(irf)</code>: print method
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Herwartz H. and Ltkepohl H. 2014. Structural vector autoregressions with Markov switching:
Combining conventional with statistical identification of shocks. <em>Journal of Econometrics</em>,
183, pp. 104-116.
</p>
</li>
<li><p> Kilian L. and Ltkepohl H. 2017. Structural Vectors Autoregressive Analysis.
<em>Cambridge University Press</em>, Cambridge.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+GFEVD">GFEVD</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>,
<code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>, <code><a href="#topic+reorder_W_columns">reorder_W_columns</a></code>, <code><a href="#topic+swap_W_signs">swap_W_signs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
 # These are long running examples that take a few minutes to run

 ## GMVAR, p=5, M=2, d=2 model with linear AR dynamics.
 # recursive identification, IRF based on the first regime:
 params52cm &lt;- c(0.788, 0.559, 0.277, 0.038, -0.061, 0.463, 0.286, 0,
               0.035, 0.161, -0.112, 0.031, -0.313, 0.183, 0.103, 0.014,
               0.002, 0.143, -0.089, -0.013, 0.182, -0.04, 1.3, 0.008,
               0.139, 0.277, -0.005, 0.032, 0.118)
 mod52cm &lt;- GSMVAR(data=gdpdef, p=5, M=2, params=params52cm,
                   constraints=rbind(diag(5*2^2), diag(5*2^2)),
                   same_means=list(1:2), parametrization="mean")
 irf1 &lt;- linear_IRF(mod52cm, regime=1, N=20, scale=cbind(c(1, 1, 1), c(2, 2, 1)))
 print(irf1, digits=3)
 plot(irf1)

 # Identification by heteroskedasticity, bootstrapped confidence intervals and
 # and scaled instantaneous effects of the shocks. Note that in actual
 # empirical application, a larger number of bootstrap reps should be used.
 mod52cms &lt;- gsmvar_to_sgsmvar(mod52cm)
 irf2 &lt;- linear_IRF(mod52cms, regime=1, N=20, ci=0.68, bootstrap_reps=10,
                    ncalls=1, seeds=1:10, ncores=1)
 plot(irf2)
 
</code></pre>

<hr>
<h2 id='loglikelihood'>Compute log-likelihood of a GMVAR, StMVAR, or G-StMVAR model using parameter vector</h2><span id='topic+loglikelihood'></span>

<h3>Description</h3>

<p><code>loglikelihood</code> computes log-likelihood of a GMVAR, StMVAR, or G-StMVAR model using parameter vector
instead of an object of class 'gsmvar'. Exists for convenience if one wants to for example
employ other estimation algorithms than the ones used in <code>fitGSMVAR</code>. Use <code>minval</code> to
control what happens when the parameter vector is outside the parameter space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood(
  data,
  p,
  M,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  minval = NA,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="loglikelihood_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function
should be used.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_minval">minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>loglikelihood_int</code> takes use of the function <code>dmvn</code> from the package <code>mvnfast</code>.
</p>


<h3>Value</h3>

<p>Returns log-likelihood if <code>params</code> is in the parameters space and <code>minval</code> if not.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+calc_gradient">calc_gradient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(2, 2), d=2 model;
params22 &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
loglikelihood(data=gdpdef, p=2, M=2, params=params22)

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
 0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
 0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
loglikelihood(data=gdpdef, p=2, M=2, params=params22s, structural_pars=list(W=W_22))
</code></pre>

<hr>
<h2 id='loglikelihood_int'>Compute log-likelihood of a GMVAR, StMVAR, and G-StMVAR models</h2><span id='topic+loglikelihood_int'></span>

<h3>Description</h3>

<p><code>loglikelihood_int</code> computes log-likelihoodof a GMVAR, StMVAR, and G-StMVAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood_int(
  data,
  p,
  M,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  to_return = c("loglik", "mw", "mw_tplus1", "loglik_and_mw", "terms", "regime_cmeans",
    "regime_ccovs", "total_cmeans", "total_ccovs", "arch_scalars",
    "loglik_mw_archscalars"),
  check_params = TRUE,
  minval = NULL,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood_int_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function
should be used.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_to_return">to_return</code></td>
<td>
<p>should the returned object be the log-likelihood value, which is default, or something else?
See the section &quot;Return&quot; for all the options.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_check_params">check_params</code></td>
<td>
<p>should it be checked that the parameter vector satisfies the model assumptions? Can be skipped to save
computation time if it does for sure.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_minval">minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>loglikelihood_int</code> takes use of the function <code>dmvn</code> from the package <code>mvnfast</code>.
</p>


<h3>Value</h3>


<dl>
<dt>By default:</dt><dd><p>log-likelihood value of the specified GMVAR, StMVAR, or G-StMVAR model,</p>
</dd>
<dt>If <code>to_return=="mw"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the mixing weights: for m:th component in m:th column.</p>
</dd>
<dt>If <code>to_return=="mw_tplus1"</code>:</dt><dd><p>a size ((n_obs-p+1)xM) matrix containing the mixing weights: for m:th component in m:th column.
The last row is for <code class="reqn">\alpha_{m,T+1}</code>.</p>
</dd>
<dt>If <code>to_return=="terms"</code>:</dt><dd><p>a size ((n_obs-p)x1) numeric vector containing the terms <code class="reqn">l_{t}</code>.</p>
</dd>
<dt>if <code>to_return=="loglik_and_mw"</code>:</dt><dd><p>a list of two elements. The first element contains the log-likelihood value and the
second element contains the mixing weights.</p>
</dd>
<dt>If <code>to_return=="regime_cmeans"</code>:</dt><dd><p>an <code>[T-p, d, M]</code> array containing the regimewise conditional means
(the first p values are used as the initial values).</p>
</dd>
<dt>If <code>to_return=="regime_ccovs"</code>:</dt><dd><p>an <code>[d, d, T-p, M]</code> array containing the regimewise conditional
covariance matrices (the first p values are used as the initial values). The index <code>[ , , t, m]</code> gives the time
<code>t</code> conditional covariance matrix for the regime <code>m</code>.</p>
</dd>
<dt>If <code>to_return=="total_cmeans"</code>:</dt><dd><p>a <code>[T-p, d]</code> matrix containing the conditional means of the process
(the first p values are used as the initial values).</p>
</dd>
<dt>If <code>to_return=="total_ccov"</code>:</dt><dd><p>an <code>[d, d, T-p]</code> array containing the conditional covariance matrices of the process
(the first p values are used as the initial values).</p>
</dd>
<dt>If <code>to_return=="arch_scalars"</code>:</dt><dd><p>a <code>[T-p, M]</code> matrix containing the regimewise arch scalars
multiplying error term covariance matrix in the conditional covariance matrix of the regime. For GMVAR type regimes, these
are all ones (the first p values are used as the initial values).</p>
</dd>
<dt>if <code>to_return=="loglik_mw_archscalars"</code>:</dt><dd><p>a list of three elements. The first element contains the log-likelihood value, the
second element contains the mixing weights, the third element contains the arch scalars
(this is used in <code>quantile_residuals_int</code>).</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>


<hr>
<h2 id='LR_test'>Perform likelihood ratio test for a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+LR_test'></span>

<h3>Description</h3>

<p><code>LR_test</code> performs a likelihood ratio test for a GMVAR, StMVAR, or G-StMVAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR_test(gsmvar1, gsmvar2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LR_test_+3A_gsmvar1">gsmvar1</code></td>
<td>
<p>an object of class <code>'gsmvar'</code> generated by <code>fitGSMVAR</code> or <code>GSMVAR</code>, containing
the <strong>freely estimated</strong> model.</p>
</td></tr>
<tr><td><code id="LR_test_+3A_gsmvar2">gsmvar2</code></td>
<td>
<p>an object of class <code>'gsmvar'</code> generated by <code>fitGSMVAR</code> or <code>GSMVAR</code>, containing
the <strong>constrained</strong> model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a likelihood ratio test, testing the null hypothesis that the true parameter value lies
in the constrained parameter space. Under the null, the test statistic is asymptotically
<code class="reqn">\chi^2</code>-distributed with <code class="reqn">k</code> degrees of freedom, <code class="reqn">k</code> being the difference in the dimensions
of the unconstrained and constrained parameter spaces.
</p>
<p>Note that this function does <strong>not</strong> verify that the two models are actually nested.
</p>


<h3>Value</h3>

<p>A list with class &quot;hypotest&quot; containing the test results and arguments used to calculate the test.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+Rao_test">Rao_test</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## These are long running examples that use parallel computing!
 ## The below examples take around 1 minute to run.

 # Structural GMVAR(2, 2), d=2 model with recursive identification
 W22 &lt;- matrix(c(1, NA, 0, 1), nrow=2, byrow=FALSE)
 fit22s &lt;- fitGSMVAR(gdpdef, p=2, M=2, structural_pars=list(W=W22),
                     ncalls=1, seeds=2)

 # The same model but the AR coefficients restricted to be the same
 # in both regimes:
 C_mat &lt;- rbind(diag(2*2^2), diag(2*2^2))
 fit22sc &lt;- fitGSMVAR(gdpdef, p=2, M=2, constraints=C_mat,
                      structural_pars=list(W=W22), ncalls=1, seeds=1)

 # Test the AR constraints with likelihood ratio test:
 LR_test(fit22s, fit22sc)
 
</code></pre>

<hr>
<h2 id='mat_power'>Compute the j:th power of a square matrix A</h2><span id='topic+mat_power'></span>

<h3>Description</h3>

<p><code>mat_power</code> computes the j:th power of a square matrix A using
exponentiation by squaring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat_power(A, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat_power_+3A_a">A</code></td>
<td>
<p>A square numeric matrix.</p>
</td></tr>
<tr><td><code id="mat_power_+3A_j">j</code></td>
<td>
<p>A natural number representing the power to which the matrix will be raised.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix which is A raised to the power j.
</p>

<hr>
<h2 id='n_params'>Calculate the number of parameters in a GMVAR, StMVAR, or G-StMVAR model's parameter vector</h2><span id='topic+n_params'></span>

<h3>Description</h3>

<p><code>n_params</code> calculates the number of parameters in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_params(
  p,
  M,
  d,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_params_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="n_params_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="n_params_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="n_params_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="n_params_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="n_params_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="n_params_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="n_params_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the number of parameters in the parameter vector of the specified
GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='Pearson_residuals'>Calculate multivariate Pearson residuals of a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+Pearson_residuals'></span>

<h3>Description</h3>

<p><code>Pearson_residuals</code> calculates multivariate Pearson residuals for a GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pearson_residuals(gsmvar, standardize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pearson_residuals_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="Pearson_residuals_+3A_standardize">standardize</code></td>
<td>
<p>Should the residuals be standardized? Use <code>FALSE</code> to obtain raw residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code class="reqn">((n_obs-p) x d)</code> matrix containing the residuals,
<code class="reqn">j</code>:th column corresponds to the time series in the <code class="reqn">j</code>:th column of the data.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+quantile_residuals">quantile_residuals</a></code>,
<code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(1,2), d=2 model:
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005, 0.03,
 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012, 0.136, 0.674)
mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)
Pearson_residuals(mod12, standardize=FALSE) # Raw residuals
Pearson_residuals(mod12, standardize=TRUE) # Standardized to identity cov.matrix.

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
 0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
 0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22s, structural_pars=list(W=W_22))
Pearson_residuals(mod22s, standardize=FALSE) # Raw residuals
Pearson_residuals(mod22s, standardize=TRUE) # Standardized to identity cov.matrix.
</code></pre>

<hr>
<h2 id='pick_all_phi0_A'>Pick all <code class="reqn">\phi_{m,0}</code> or <code class="reqn">\mu_{m}</code> and <code class="reqn">A_{m,1},...,A_{m,p}</code> parameter values</h2><span id='topic+pick_all_phi0_A'></span>

<h3>Description</h3>

<p><code>pick_all_phi0_A</code> picks the intercept or mean parameters and vectorized coefficient
matrices from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_all_phi0_A(p, M, d, params, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_all_phi0_A_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_all_phi0_A_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_all_phi0_A_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="pick_all_phi0_A_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="pick_all_phi0_A_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">((pd^2+d)xM)</code> matrix containing <code class="reqn">(\phi_{m,0}, vec(A_{m,1}),...,vec(A_{m,p}))</code> in the m:th column,
or <code class="reqn">(\mu_{m}, vec(A_{m,1}),...,vec(A_{m,p}))</code> if the parameter vector is mean-parametrized, m=1,..,M.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_allA'>Pick coefficient all matrices</h2><span id='topic+pick_allA'></span>

<h3>Description</h3>

<p><code>pick_allA</code> picks all coefficient matrices <code class="reqn">A_{m,i} (i=1,..,p, m=1,..,M)</code>
from the given parameter vector so that they are arranged in a 4D array with the fourth dimension
indicating each component and third dimension indicating each lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_allA(p, M, d, params, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_allA_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_allA_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_allA_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="pick_allA_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="pick_allA_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns a 4D array containing the coefficient matrices of the all components. Coefficient matrix
<code class="reqn">A_{m,i}</code> can be obtained by choosing <code>[, , i, m]</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_alphas'>Pick mixing weight parameters <code class="reqn">\alpha_{m}, m=1,...,M</code></h2><span id='topic+pick_alphas'></span>

<h3>Description</h3>

<p><code>pick_alphas</code> picks the mixing weight parameters from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_alphas(p, M, d, params, model = c("GMVAR", "StMVAR", "G-StMVAR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_alphas_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_alphas_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_alphas_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="pick_alphas_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a length M vector containing the mixing weight parameters <code class="reqn">alpha_{m}, m=1,...,M</code>,
including the non-parametrized <code class="reqn">alpha_{M}</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_Am'>Pick coefficient matrices</h2><span id='topic+pick_Am'></span>

<h3>Description</h3>

<p><code>pick_Am</code> picks the coefficient matrices <code class="reqn">A_{m,i} (i=1,..,p)</code>
from the given parameter vector so that they are arranged in a 3D array with the
third dimension indicating each lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_Am(p, M, d, params, m, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_Am_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_Am_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_Am_+3A_d">d</code></td>
<td>
<p>number of time series in the system, i.e. the dimension.</p>
</td></tr>
<tr><td><code id="pick_Am_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="pick_Am_+3A_m">m</code></td>
<td>
<p>which component?</p>
</td></tr>
<tr><td><code id="pick_Am_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns a 3D array containing the coefficient matrices of the given component.
A coefficient matrix <code class="reqn">A_{m,i}</code> can be obtained by choosing <code>[, , i]</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_Ami'>Pick coefficient matrix</h2><span id='topic+pick_Ami'></span>

<h3>Description</h3>

<p><code>pick_Ami</code> picks the coefficient matrix <code class="reqn">A_{m,i}</code> from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_Ami(p, M, d, params, m, i, structural_pars = NULL, unvec = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_Ami_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_Ami_+3A_d">d</code></td>
<td>
<p>number of time series in the system, i.e. the dimension.</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_m">m</code></td>
<td>
<p>which component?</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_i">i</code></td>
<td>
<p>which lag in 1,...,p?</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="pick_Ami_+3A_unvec">unvec</code></td>
<td>
<p>if <code>FALSE</code> then vectorized version of <code class="reqn">A_{m,i}</code> will be returned instead of matrix.
Default if <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns the i:th lag coefficient matrix of m:th component, <code class="reqn">A_{m,i}</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_df'>Pick the degrees of freedom parameters <strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code></h2><span id='topic+pick_df'></span>

<h3>Description</h3>

<p><code>pick_df</code> picks  the degrees of freedom parameters from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_df(M, params, model = c("GMVAR", "StMVAR", "G-StMVAR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_df_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_df_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained models are supported, but obtaining the degrees of freedom does not require
specifying the constraints.
</p>


<h3>Value</h3>

<p>Returns a length <code class="reqn">M2</code> vector containing the degrees of freedom parameters
<strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>. In the case of the GMVAR model (<code class="reqn">M2=0</code>),
returns a numeric vector of length zero.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_lambdas'>Pick the structural parameters eigenvalue 'lambdas'</h2><span id='topic+pick_lambdas'></span>

<h3>Description</h3>

<p><code>pick_lambdas</code> picks the structural parameters eigenvalue 'lambdas from a parameter vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_lambdas(p, M, d, params, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_lambdas_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_lambdas_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_lambdas_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="pick_lambdas_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="pick_lambdas_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained parameter vectors are not supported. Not even constraints in <code class="reqn">W</code>!
</p>


<h3>Value</h3>

<p>Returns a length <code class="reqn">(d*(M - 1))</code> vector <code class="reqn">(\lambda_{2},...,\lambda_{M})</code>
(see the argument <code>params</code>) from a parameter vector of a SGSMVAR model.
Returns <code>numeric(0)</code> for reduced form models or when <code class="reqn">M=1</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_Omegas'>Pick covariance matrices</h2><span id='topic+pick_Omegas'></span>

<h3>Description</h3>

<p><code>pick_Omegas</code> picks the covariance matrices <code class="reqn">\Omega_{m} (m=1,..,M)</code>
from the given parameter vector so that they are arranged in a 3D array with the third
dimension indicating each component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_Omegas(p, M, d, params, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_Omegas_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_Omegas_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_Omegas_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="pick_Omegas_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="pick_Omegas_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns a 3D array containing the covariance matrices of the given model. Coefficient matrix
<code class="reqn">\Omega_{m}</code> can be obtained by choosing <code>[, , m]</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_phi0'>Pick <code class="reqn">\phi_{m,0}</code> or <code class="reqn">\mu_{m}</code>, m=1,..,M vectors</h2><span id='topic+pick_phi0'></span>

<h3>Description</h3>

<p><code>pick_phi0</code> picks the intercept or mean parameters from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_phi0(p, M, d, params, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_phi0_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_phi0_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_phi0_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="pick_phi0_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="pick_phi0_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Does not support constrained parameter vectors.
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">(dxM)</code> matrix containing <code class="reqn">\phi_{m,0}</code> in the m:th column or
<code class="reqn">\mu_{m}</code> if the parameter vector is mean-parametrized, <code class="reqn">, m=1,..,M</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_regime'>Pick regime parameters <strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m},\nu_{m})</code></h2><span id='topic+pick_regime'></span>

<h3>Description</h3>

<p><code>pick_regime</code> picks the regime-parameters from the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_regime(
  p,
  M,
  d,
  params,
  m,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  with_df = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_regime_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_regime_+3A_d">d</code></td>
<td>
<p>number of time series in the system, i.e. the dimension.</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_m">m</code></td>
<td>
<p>which component?</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="pick_regime_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="pick_regime_+3A_with_df">with_df</code></td>
<td>
<p>should the degrees of freedom parameter (if any) be included?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in some cases, a numeric vector of length zero is returned (see section Return)
</p>


<h3>Value</h3>


<dl>
<dt>For reduced form models:</dt><dd>

<dl>
<dt>For <strong>GMVAR</strong> model:</dt><dd><p>a length <code class="reqn">pd^2+d+d(d+1)/2</code> vector containing
<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,1})</code> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>.</p>
</dd>
<dt>For <strong>StMVAR</strong> model:</dt><dd><p>a length <code class="reqn">pd^2+d+d(d+1)/2 + 1</code> vector containing
(<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">,\nu_{m}</code>), where <code class="reqn">\nu_{m}</code> is dropped if <code>with_df == FALSE</code>.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> model:</dt><dd><p>Same as GMVAR for GMVAR type regimes and same as StMVAR for StMVAR type regimes.</p>
</dd>
</dl>

</dd>
<dt>For structural models:</dt><dd>

<dl>
<dt>For <strong>SGMVAR</strong> model:</dt><dd><p>a length <code class="reqn">pd^2 + d</code> vector <code class="reqn">(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">)</code>.</p>
</dd>
<dt>For <strong>StMVAR</strong> model:</dt><dd><p>a length <code class="reqn">pd^2 + d + 1</code> vector <code class="reqn">(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\nu_{m})</code>,
where <code class="reqn">\nu_{m}</code> is dropped if <code>with_df == FALSE</code>.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> model:</dt><dd><p>Same as GMVAR for GMVAR type regimes and same as StMVAR for StMVAR type regimes.</p>
</dd>
</dl>

</dd>
<dt>When AR constraints are employed:</dt><dd><p>As above, but without <strong><code class="reqn">\phi_{m}</code></strong>.</p>
</dd>
<dt>When mean constaints are employed:</dt><dd><p>As above, but without <code class="reqn">\phi_{m,0}</code> (which are <code class="reqn">\mu_m</code> in this case).</p>
</dd>
<dt>When lambda constraints are employed:</dt><dd><p>As above. Note that lambda parameters are not returned in any specification.</p>
</dd>
<dt>When weight constraints are employed:</dt><dd><p>As above. Note that alpha parameters are not returned in any specification.</p>
</dd>
</dl>

<p>Note that if both, AR and mean constraints are employed, a lenght zero numeric vector is returned for
structural GMVAR type regimes (or structural StMVAR type regimes if <code>with_df=FALSE</code>).
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='pick_W'>Pick the structural parameter matrix W</h2><span id='topic+pick_W'></span>

<h3>Description</h3>

<p><code>pick_W</code> picks the structural parameter matrix W from a parameter vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_W(p, M, d, params, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_W_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_W_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_W_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="pick_W_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="pick_W_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained parameter vectors are not supported. Not even constraints in <code class="reqn">W</code>!
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">(d x d)</code> matrix <code class="reqn">W</code> from a parameter vector of a SGSMVAR model.
Returns <code>NULL</code> for reduced form models.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='plot.gmvarpred'>plot method for class 'gmvarpred' objects</h2><span id='topic+plot.gmvarpred'></span><span id='topic+print.gmvarpred'></span>

<h3>Description</h3>

<p><code>plot.gmvarpred</code> is plot method for gsmvarpred objects.
EXISTS FOR BACKWARD COMPATIBILITY. THE CLASS 'gmvarpred' IS DEPRECATED FROM
THE VERSION 2.0.0 ONWARD: WE USE THE CLASS 'gsmvarpred' NOW.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmvarpred'
plot(x, ..., nt, mix_weights = TRUE, add_grid = TRUE)

## S3 method for class 'gmvarpred'
print(x, ..., digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gmvarpred_+3A_x">x</code></td>
<td>
<p>object of class <code>'gsmvarpred'</code> generated by <code>predict.gsmvar</code>.</p>
</td></tr>
<tr><td><code id="plot.gmvarpred_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>grid</code> which plots grid to the figure.</p>
</td></tr>
<tr><td><code id="plot.gmvarpred_+3A_nt">nt</code></td>
<td>
<p>a positive integer specifying the number of observations to be plotted
along with the prediction (ignored if <code>plot_res==FALSE</code>). Default is <code>round(nrow(data)*0.15)</code>.</p>
</td></tr>
<tr><td><code id="plot.gmvarpred_+3A_mix_weights">mix_weights</code></td>
<td>
<p><code>TRUE</code> if forecasts for mixing weights should be plotted,
<code>FALSE</code> in not.</p>
</td></tr>
<tr><td><code id="plot.gmvarpred_+3A_add_grid">add_grid</code></td>
<td>
<p>should grid be added to the plots?</p>
</td></tr>
<tr><td><code id="plot.gmvarpred_+3A_digits">digits</code></td>
<td>
<p>how many digits to print?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods exist so that objects created with earlier versions
of the package can be used normally.
</p>

<hr>
<h2 id='plot.gsmvarpred'>plot method for class 'gsmvarpred' objects</h2><span id='topic+plot.gsmvarpred'></span>

<h3>Description</h3>

<p><code>plot.gsmvarpred</code> is plot method for gsmvarpred objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmvarpred'
plot(x, ..., nt, mix_weights = TRUE, add_grid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gsmvarpred_+3A_x">x</code></td>
<td>
<p>object of class <code>'gsmvarpred'</code> generated by <code>predict.gsmvar</code>.</p>
</td></tr>
<tr><td><code id="plot.gsmvarpred_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>grid</code> which plots grid to the figure.</p>
</td></tr>
<tr><td><code id="plot.gsmvarpred_+3A_nt">nt</code></td>
<td>
<p>a positive integer specifying the number of observations to be plotted
along with the prediction (ignored if <code>plot_res==FALSE</code>). Default is <code>round(nrow(data)*0.15)</code>.</p>
</td></tr>
<tr><td><code id="plot.gsmvarpred_+3A_mix_weights">mix_weights</code></td>
<td>
<p><code>TRUE</code> if forecasts for mixing weights should be plotted,
<code>FALSE</code> in not.</p>
</td></tr>
<tr><td><code id="plot.gsmvarpred_+3A_add_grid">add_grid</code></td>
<td>
<p>should grid be added to the plots?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is used plot forecasts of GSMVAR processes
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='plot.qrtest'>Quantile residual tests</h2><span id='topic+plot.qrtest'></span><span id='topic+print.qrtest'></span><span id='topic+quantile_residual_tests'></span>

<h3>Description</h3>

<p><code>quantile_residual_tests</code> performs quantile residual tests described
by <em>Kalliovirta and Saikkonen 2010</em>, testing autocorrelation, conditional heteroskedasticity,
and normality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qrtest'
plot(x, ...)

## S3 method for class 'qrtest'
print(x, ..., digits = 3)

quantile_residual_tests(
  gsmvar,
  lags_ac = c(1, 3, 6, 12),
  lags_ch = lags_ac,
  nsim = 1,
  ncores = 1,
  print_res = TRUE,
  stat_tol,
  posdef_tol,
  df_tol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.qrtest_+3A_x">x</code></td>
<td>
<p>object of class <code>'qrtest'</code> generated by the function <code>quantile_residual_tests)</code>.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_lags_ac">lags_ac</code></td>
<td>
<p>a positive integer vector specifying the lags used to test autocorrelation.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_lags_ch">lags_ch</code></td>
<td>
<p>a positive integer vector specifying the lags used to test conditional heteroskedasticity.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_nsim">nsim</code></td>
<td>
<p>to how many simulations should the covariance matrix Omega used in the qr-tests be based on?
If smaller than sample size, then the covariance matrix will be evaluated from the sample. Larger number
of simulations might improve the tests size properties but it increases the computation time.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to be used in numerical differentiation. Multiple cores
are not supported on Windows, though.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_print_res">print_res</code></td>
<td>
<p>should the test results be printed while computing the tests?</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the function fails to calculate the tests because of numerical problems and the parameter values
are near the border of the parameter space, it might help to use smaller numerical tolerance for the
stationarity and positeve definiteness conditions. The numerical tolerance of an existing model
can be changed with the function <code>update_numtols</code> or you can set it directly with the arguments
<code>stat_tol</code> and <code>posdef_tol</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'qrtest'</code> which has its own print method. The returned object
is a list containing the quantile residual test results for normality, autocorrelation, and conditional
heteroskedasticity. The autocorrelation and conditional heteroskedasticity results also contain the
associated (vectorized) individual statistics divided by their standard errors
(see <em>Kalliovirta and Saikkonen 2010</em>, s.17-20) under the label <code>$ind_stats</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(qrtest)</code>: Plot p-values of the autocorrelation and conditional
heteroskedasticity tests.
</p>
</li>
<li> <p><code>print(qrtest)</code>: Print method for class 'qrtest'
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+quantile_residuals">quantile_residuals</a></code>, <code><a href="#topic+GIRF">GIRF</a></code>,
<code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+predict.gsmvar">predict.gsmvar</a></code>, <code><a href="#topic+profile_logliks">profile_logliks</a></code>,
<code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>, <code><a href="#topic+update_numtols">update_numtols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMVAR(3,2) model
fit32 &lt;- fitGSMVAR(gdpdef, p=3, M=2, ncalls=1, seeds=2)
qrtests32 &lt;- quantile_residual_tests(fit32)
qrtests32
plot(qrtests32)

# Structural GMVAR(1,2) model identified with sign
# constraints and build with hand-specified parameter values.
# Tests based on simulation procedure with nsim=1000:
params12s &lt;- c(0.55, 0.112, 0.619, 0.173, 0.344, 0.055, -0.009, 0.718,
 0.255, 0.017, -0.136, 0.858, 0.541, 0.057, -0.162, 0.162, 3.623,
 4.726, 0.674)
W_12 &lt;- matrix(c(1, 1, -1, 1), nrow=2)
mod12s &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12s,
                structural_pars=list(W=W_12))
qrtests12s &lt;- quantile_residual_tests(mod12s, nsim=1000)
qrtests12s

</code></pre>

<hr>
<h2 id='predict.gmvar'>DEPRECATED! USE THE FUNCTION predict.gsmvar INSTEAD! Predict method for class 'gmvar' objects</h2><span id='topic+predict.gmvar'></span>

<h3>Description</h3>

<p><code>predict.gsmvar</code> is a predict method for class <code>'gsmvar'</code> objects. The forecasts of
the GMVAR model are computed by performing independent simulations and using the
sample medians or means as point forecasts and empirical quantiles as prediction intervals.
For one-step-ahead predictions using the exact conditional mean is also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmvar'
predict(
  object,
  ...,
  n_ahead,
  n_simu = 2000,
  pi = c(0.95, 0.8),
  pi_type = c("two-sided", "upper", "lower", "none"),
  pred_type = c("median", "mean", "cond_mean"),
  plot_res = TRUE,
  mix_weights = TRUE,
  nt
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gmvar_+3A_object">object</code></td>
<td>
<p>an object of class 'gmvar'</p>
</td></tr>
<tr><td><code id="predict.gmvar_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>grid</code> (ignored if <code>plot_res==FALSE</code>) which plots
grid to the figure.</p>
</td></tr>
<tr><td><code id="predict.gmvar_+3A_n_ahead">n_ahead</code></td>
<td>
<p>how many steps ahead should be predicted?</p>
</td></tr>
<tr><td><code id="predict.gmvar_+3A_n_simu">n_simu</code></td>
<td>
<p>to how many independent simulations should the forecast be based on?</p>
</td></tr>
<tr><td><code id="predict.gmvar_+3A_pi">pi</code></td>
<td>
<p>a numeric vector specifying the confidence levels of the prediction intervals.</p>
</td></tr>
<tr><td><code id="predict.gmvar_+3A_pi_type">pi_type</code></td>
<td>
<p>should the prediction intervals be &quot;two-sided&quot;, &quot;upper&quot;, or &quot;lower&quot;?</p>
</td></tr>
<tr><td><code id="predict.gmvar_+3A_pred_type">pred_type</code></td>
<td>
<p>should the prediction be based on sample &quot;median&quot; or &quot;mean&quot;? Or should it
be one-step-ahead forecast based on the exact conditional mean (<code>"cond_mean"</code>)?
Prediction intervals won't be calculated if the exact conditional mean is used.</p>
</td></tr>
<tr><td><code id="predict.gmvar_+3A_plot_res">plot_res</code></td>
<td>
<p>should the results be plotted?</p>
</td></tr>
<tr><td><code id="predict.gmvar_+3A_mix_weights">mix_weights</code></td>
<td>
<p><code>TRUE</code> if forecasts for mixing weights should be plotted,
<code>FALSE</code> in not.</p>
</td></tr>
<tr><td><code id="predict.gmvar_+3A_nt">nt</code></td>
<td>
<p>a positive integer specifying the number of observations to be plotted
along with the prediction (ignored if <code>plot_res==FALSE</code>). Default is <code>round(nrow(data)*0.15)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a class '<code>gsmvarpred</code>' object containing, among the specifications,...
</p>

<dl>
<dt>$pred</dt><dd><p>Point forecasts</p>
</dd>
<dt>$pred_int</dt><dd><p>Prediction intervals, as <code>[, , d]</code>.</p>
</dd>
<dt>$mix_pred</dt><dd><p>Point forecasts for the mixing weights</p>
</dd>
<dt>mix_pred_int</dt><dd><p>Individual prediction intervals for mixing weights, as <code>[, , m]</code>, m=1,..,M.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.gsmvar">predict.gsmvar</a></code>
</p>

<hr>
<h2 id='predict.gsmvar'>Predict method for class 'gsmvar' objects</h2><span id='topic+predict.gsmvar'></span>

<h3>Description</h3>

<p><code>predict.gsmvar</code> is a predict method for class <code>'gsmvar'</code> objects. The forecasts of
the GMVAR, StMVAR, and G-StMVAR models are computed by performing independent simulations and using the
sample medians or means as point forecasts and empirical quantiles as prediction intervals.
For one-step-ahead predictions using the exact conditional mean is also supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmvar'
predict(
  object,
  ...,
  n_ahead,
  nsim = 2000,
  pi = c(0.95, 0.8),
  pi_type = c("two-sided", "upper", "lower", "none"),
  pred_type = c("median", "mean", "cond_mean"),
  plot_res = TRUE,
  mix_weights = TRUE,
  nt
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gsmvar_+3A_object">object</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="predict.gsmvar_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>grid</code> (ignored if <code>plot_res==FALSE</code>) which plots
grid to the figure.</p>
</td></tr>
<tr><td><code id="predict.gsmvar_+3A_n_ahead">n_ahead</code></td>
<td>
<p>how many steps ahead should be predicted?</p>
</td></tr>
<tr><td><code id="predict.gsmvar_+3A_nsim">nsim</code></td>
<td>
<p>to how many independent simulations should the forecast be based on?</p>
</td></tr>
<tr><td><code id="predict.gsmvar_+3A_pi">pi</code></td>
<td>
<p>a numeric vector specifying the confidence levels of the prediction intervals.</p>
</td></tr>
<tr><td><code id="predict.gsmvar_+3A_pi_type">pi_type</code></td>
<td>
<p>should the prediction intervals be &quot;two-sided&quot;, &quot;upper&quot;, or &quot;lower&quot;?</p>
</td></tr>
<tr><td><code id="predict.gsmvar_+3A_pred_type">pred_type</code></td>
<td>
<p>should the prediction be based on sample &quot;median&quot; or &quot;mean&quot;? Or should it
be one-step-ahead forecast based on the exact conditional mean (<code>"cond_mean"</code>)?
Prediction intervals won't be calculated if the exact conditional mean is used.</p>
</td></tr>
<tr><td><code id="predict.gsmvar_+3A_plot_res">plot_res</code></td>
<td>
<p>should the results be plotted?</p>
</td></tr>
<tr><td><code id="predict.gsmvar_+3A_mix_weights">mix_weights</code></td>
<td>
<p><code>TRUE</code> if forecasts for mixing weights should be plotted,
<code>FALSE</code> in not.</p>
</td></tr>
<tr><td><code id="predict.gsmvar_+3A_nt">nt</code></td>
<td>
<p>a positive integer specifying the number of observations to be plotted
along with the prediction (ignored if <code>plot_res==FALSE</code>). Default is <code>round(nrow(data)*0.15)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a class '<code>gsmvarpred</code>' object containing, among the specifications,...
</p>

<dl>
<dt>$pred</dt><dd><p>Point forecasts</p>
</dd>
<dt>$pred_int</dt><dd><p>Prediction intervals, as <code>[, , d]</code>.</p>
</dd>
<dt>$mix_pred</dt><dd><p>Point forecasts for the mixing weights</p>
</dd>
<dt>mix_pred_int</dt><dd><p>Individual prediction intervals for mixing weights, as <code>[, , m]</code>, m=1,..,M.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+GFEVD">GFEVD</a></code>, <code><a href="#topic+simulate.gsmvar">simulate.gsmvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(2, 2), d=2 model
params22 &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
  0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, d=2, params=params22)
p1 &lt;- predict(mod22, n_ahead=10, pred_type="median", nsim=500)
p1
p2 &lt;- predict(mod22, n_ahead=10, nt=20, lty=1, nsim=500)
p2
p3 &lt;- predict(mod22, n_ahead=10, pi=c(0.99, 0.90, 0.80, 0.70),
              nt=30, lty=0, nsim=500)
p3

# StMVAR(2, 2), d=2 model
params22t &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
  0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58, 3, 4)
mod22t &lt;- GSMVAR(gdpdef, p=2, M=2, d=2, params=params22t, model="StMVAR")
p1 &lt;- predict(mod22t, n_ahead=12, pred_type="median", nsim=500, pi=0.9)
p1
</code></pre>

<hr>
<h2 id='print_std_errors'>Print standard errors of a GMVAR, StMVAR, or G-StMVAR model in the same form as the model estimates are printed</h2><span id='topic+print_std_errors'></span>

<h3>Description</h3>

<p><code>print_std_errors</code> prints the approximate standard errors of a GMVAR, StMVAR, or G-StMVAR model in the
same form as the parameters of objects of class <code>'gsmvar'</code> are printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_std_errors(gsmvar, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_std_errors_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="print_std_errors_+3A_digits">digits</code></td>
<td>
<p>how many digits should be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of <code>print_std_errors</code> is to provide a convenient tool to match the standard
errors to certain parameter estimates. Note that if the model is intercept parametrized, there won't
be standard errors for the unconditional means, and vice versa. Also, there is no standard error for the
last mixing weight alpha_M because it is not parametrized.
</p>
<p>Note that if linear constraints are imposed and they involve summations or multiplications, then the AR
parameter standard errors are printed separately as they don't correspond one-to-one to the model parameter
standard errors.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+print.gsmvar">print.gsmvar</a></code>,
<code><a href="#topic+swap_parametrization">swap_parametrization</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMVAR(1,2) model
fit12 &lt;- fitGSMVAR(gdpdef, p=1, M=2, ncalls=1, seeds=1)
fit12
print_std_errors(fit12)

</code></pre>

<hr>
<h2 id='print.gmvar'>Deprecated S3 methods for the deprecated class 'gmvar'</h2><span id='topic+print.gmvar'></span><span id='topic+summary.gmvar'></span><span id='topic+plot.gmvar'></span><span id='topic+logLik.gmvar'></span><span id='topic+residuals.gmvar'></span>

<h3>Description</h3>

<p>Deprecated S3 methods for the deprecated class 'gmvar'. From
the gmvarkit version 2.0.0 onwards, class 'gsmvar' is used instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmvar'
print(x, ..., digits = 2)

## S3 method for class 'gmvar'
summary(object, ..., digits)

## S3 method for class 'gmvar'
plot(x, ...)

## S3 method for class 'gmvar'
logLik(object, ...)

## S3 method for class 'gmvar'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gmvar_+3A_x">x</code></td>
<td>
<p>a class 'gmvar' object. THIS CLASS IS DEPRECATED FROM THE VERSION
2.0.0 ONWARDS.</p>
</td></tr>
<tr><td><code id="print.gmvar_+3A_...">...</code></td>
<td>
<p>See the usage from the documentation of the appropriate class 'gsmvar' S3 method.</p>
</td></tr>
<tr><td><code id="print.gmvar_+3A_digits">digits</code></td>
<td>
<p>number of digits to be printed.</p>
</td></tr>
<tr><td><code id="print.gmvar_+3A_object">object</code></td>
<td>
<p>object of class <code>'gmvar'</code>. THIS CLASS IS DEPRECATED FROM THE VERSION
2.0.0 ONWARDS.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods exist so that models estimated with earlier versions
of the package can be used normally.
</p>

<hr>
<h2 id='print.gmvarsum'>Summary print method from objects of class 'gmvarsum'</h2><span id='topic+print.gmvarsum'></span>

<h3>Description</h3>

<p><code>print.gmvarsum</code> is a print method for object <code>'gmvarsum'</code>.
EXISTS FOR BACKWARD COMPATIBILITY. CLASS 'gmvarsum' IS DEPRECATED FROM THE VERSION
2.0.0. ONWARDS. NOW, WE USE THE CLASS 'gsmvarsum'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmvarsum'
print(x, ..., digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gmvarsum_+3A_x">x</code></td>
<td>
<p>object of class 'gsmvarsum' generated by <code>summary.gsmvar</code>.</p>
</td></tr>
<tr><td><code id="print.gmvarsum_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="print.gmvarsum_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
</table>

<hr>
<h2 id='print.gsmvarpred'>Print method for class 'gsmvarpred' objects</h2><span id='topic+print.gsmvarpred'></span>

<h3>Description</h3>

<p><code>print.gsmvarpred</code> is a print method for object generated
by <code>predict.gsmvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmvarpred'
print(x, ..., digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gsmvarpred_+3A_x">x</code></td>
<td>
<p>object of class <code>'gsmvarpred'</code> generated by <code>predict.gsmvar</code>.</p>
</td></tr>
<tr><td><code id="print.gsmvarpred_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="print.gsmvarpred_+3A_digits">digits</code></td>
<td>
<p>the number of decimals to print</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(2, 2), d=2 model;
params22 &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22)
pred22 &lt;- predict(mod22, n_ahead=3, plot_res=FALSE)
print(pred22)
print(pred22, digits=3)
</code></pre>

<hr>
<h2 id='print.gsmvarsum'>Summary print method from objects of class 'gsmvarsum'</h2><span id='topic+print.gsmvarsum'></span>

<h3>Description</h3>

<p><code>print.gsmvarsum</code> is a print method for object <code>'gsmvarsum'</code> generated
by <code>summary.gsmvar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmvarsum'
print(x, ..., digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gsmvarsum_+3A_x">x</code></td>
<td>
<p>object of class 'gsmvarsum' generated by <code>summary.gsmvar</code>.</p>
</td></tr>
<tr><td><code id="print.gsmvarsum_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="print.gsmvarsum_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(2, 2), d=2 model;
params22 &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22)
sumry22 &lt;- summary(mod22)
print(sumry22)
</code></pre>

<hr>
<h2 id='print.hypotest'>Print method for the class hypotest</h2><span id='topic+print.hypotest'></span>

<h3>Description</h3>

<p><code>print.hypotest</code> is the print method for the class hypotest
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hypotest'
print(x, ..., digits = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.hypotest_+3A_x">x</code></td>
<td>
<p>object of class <code>'hypotest'</code> generated by the function <code>Wald_test</code> or <code>LR_test</code>.</p>
</td></tr>
<tr><td><code id="print.hypotest_+3A_...">...</code></td>
<td>
<p>currently not in use.</p>
</td></tr>
<tr><td><code id="print.hypotest_+3A_digits">digits</code></td>
<td>
<p>how many significant digits to print?</p>
</td></tr>
</table>

<hr>
<h2 id='profile_logliks'>Plot profile log-likehoods around the estimates</h2><span id='topic+profile_logliks'></span>

<h3>Description</h3>

<p><code>profile_logliks</code> plots profile log-likelihoods around the estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile_logliks(
  gsmvar,
  which_pars,
  scale = 0.02,
  nrows,
  ncols,
  precision = 200,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile_logliks_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_which_pars">which_pars</code></td>
<td>
<p>the profile log-likelihood function of which parameters should be plotted? An integer
vector specifying the positions of the parameters in the parameter vector. The parameter vector has the
form...
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+1)-1)x1)</code> and have form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1}</code>), where:
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+1)+q-1)x1)</code> and have form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code></strong>
<code class="reqn">,\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1})</code>, where:
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>. Here <strong><code class="reqn">C</code></strong> is <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>:th coefficient matrix of the <code class="reqn">m</code>:th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter.
</p>
<p>The default is that profile log-likelihood functions for all parameters are plotted.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_scale">scale</code></td>
<td>
<p>a numeric scalar specifying the interval plotted for each estimate:
the estimate plus-minus <code>abs(scale*estimate)</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_nrows">nrows</code></td>
<td>
<p>how many rows should be in the plot-matrix? The default is <code>max(ceiling(log2(length(which_pars)) - 1), 1)</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_ncols">ncols</code></td>
<td>
<p>how many columns should be in the plot-matrix? The default is <code>ceiling(length(which_pars)/nrows)</code>.
Note that <code>nrows*ncols</code> should not be smaller than the length of <code>which_pars</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_precision">precision</code></td>
<td>
<p>at how many points should each profile log-likelihood be evaluated at?</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the number of parameters is large, it might be better to plot a smaller number of profile
log-likelihood functions at a time using the argument <code>which_pars</code>.
</p>
<p>The red vertical line points the estimate.
</p>


<h3>Value</h3>

<p>Only plots to a graphical device and doesn't return anything.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+get_soc">get_soc</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>,
<code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Running all the below examples takes approximately 2 minutes.

# GMVAR(1,2) model
fit12 &lt;- fitGSMVAR(gdpdef, p=1, M=2, ncalls=1, seeds=1)
fit12
profile_logliks(fit12)

# Structural GMVAR(1,2) model identified with sign
# constraints: model build based on inaccurate hand-given estimates.
W_122 &lt;- matrix(c(1, 1, -1, 1), nrow=2)
params12s &lt;- c(0.55, 0.11, 0.62, 0.17, 0.34, 0.05, -0.01, 0.72, 0.25,
 0.02, -0.14, 0.86, 0.54, 0.06, -0.16, 0.16, 3.62, 4.73, 0.67)
mod12s &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12s,
                structural_pars=list(W=W_122))
profile_logliks(mod12s)

#' # G-StMVAR(2, 1, 1), d=2 model:
params22gs &lt;- c(0.697, 0.154, 0.049, 0.374, 0.476, 0.318, -0.645, -0.302,
 -0.222, 0.193, 0.042, -0.013, 0.048, 0.554, 0.033, 0.184, 0.005, -0.186,
  0.683, 0.256, 0.031, 0.026, 0.204, 0.583, -0.002, 0.048, 0.182, 4.334)
mod22gs &lt;- GSMVAR(gdpdef, p=2, M=c(1, 1), params=params22gs, model="G-StMVAR")
profile_logliks(mod22gs, which_pars=c(1, 3, 28))

</code></pre>

<hr>
<h2 id='quantile_residuals'>Calculate multivariate quantile residuals of a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+quantile_residuals'></span>

<h3>Description</h3>

<p><code>quantile_residuals</code> calculates multivariate quantile residuals
(proposed by <em>Kalliovirta and Saikkonen 2010</em>) for a GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_residuals(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_residuals_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code class="reqn">((n_obs-p) x d)</code> matrix containing the multivariate quantile residuals,
<code class="reqn">j</code>:th column corresponds to the time series in the <code class="reqn">j</code>:th column of the data. The multivariate
quantile residuals are calculated so that the first column quantile residuals are the &quot;unconditioned ones&quot;
and the rest condition on all the previous ones in numerical order. Read the cited article by
<em>Kalliovirta and Saikkonen 2010</em> for details.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>,
<code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+predict.gsmvar">predict.gsmvar</a></code>, <code><a href="#topic+profile_logliks">profile_logliks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(1,2), d=2 model:
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005, 0.03,
 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012, 0.136, 0.674)
mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)
quantile_residuals(mod12)

# GMVAR(2,2), d=2 model with mean-parametrization:
params22 &lt;- c(0.869, 0.549, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
 0.083, 0.299, 0.215, 0.002, 0.03, 0.576, 1.168, 0.218, 0.02, -0.119,
 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22, parametrization="mean")
quantile_residuals(mod22)

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
 0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
 0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22s, structural_pars=list(W=W_22))
quantile_residuals(mod22s)
</code></pre>

<hr>
<h2 id='quantile_residuals_int'>Calculate multivariate quantile residuals of GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+quantile_residuals_int'></span>

<h3>Description</h3>

<p><code>quantile_residuals_int</code> is a wrapper for <code>quantile_residuals</code> to compute
quantile residuals using parameter values instead of class <code>gsmvar</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_residuals_int(
  data,
  p,
  M,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  conditional,
  parametrization,
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_residuals_int_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function
should be used.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code class="reqn">((n_obs-p) x d)</code> matrix containing the multivariate quantile residuals,
<code class="reqn">j</code>:th column corresponds to the time series in the <code class="reqn">j</code>:th column of the data. The multivariate
quantile residuals are calculated so that the first column quantile residuals are the &quot;unconditioned ones&quot;
and the rest condition on all the previous ones in numerical order. Read the cited article by
<em>Kalliovirta and Saikkonen 2010</em> for details.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>


<hr>
<h2 id='random_coefmats'>Create random VAR-model <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code>.</h2><span id='topic+random_coefmats'></span>

<h3>Description</h3>

<p><code>random_coefmats</code> generates random VAR model coefficient matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_coefmats(d, how_many, scale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_coefmats_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="random_coefmats_+3A_how_many">how_many</code></td>
<td>
<p>how many <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code> should be drawn?</p>
</td></tr>
<tr><td><code id="random_coefmats_+3A_scale">scale</code></td>
<td>
<p>non-diagonal elements will be drawn from mean zero normal distribution
with <code>sd=0.3/scale</code> and diagonal elements from one with <code>sd=0.6/scale</code>.
Larger scale will hence more likely result stationary coefficient matrices, but
will explore smaller area of the parameter space. Can be for example
<code>1 + log(2*mean(c((p-0.2)^(1.25), d)))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code class="reqn">((how_many*d^2)x1)</code> vector containing vectorized coefficient
matrices <code class="reqn">(vec(A_{1}),...,vec(A_{how_many}))</code>. Note that if <code>how_many==p</code>,
then the returned vector equals <strong><code class="reqn">\phi_{m}</code></strong>.
</p>

<hr>
<h2 id='random_coefmats2'>Create random stationary VAR model <code class="reqn">(dxd)</code> coefficient matrices <code class="reqn">A</code>.</h2><span id='topic+random_coefmats2'></span>

<h3>Description</h3>

<p><code>random_coefmats2</code> generates random VAR model coefficient matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_coefmats2(p, d, ar_scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_coefmats2_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="random_coefmats2_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="random_coefmats2_+3A_ar_scale">ar_scale</code></td>
<td>
<p>a positive real number between zero and one. Larger values will typically result
larger AR coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficient matrices are generated using the algorithm proposed by Ansley
and Kohn (1986) which forces stationarity. It's not clear in detail how <code>ar_scale</code>
affects the coefficient matrices. Read the cited article by Ansley and Kohn (1986) and
the source code for more information.
</p>
<p>Note that when using large <code>ar_scale</code> with large <code>p</code> or <code>d</code>, numerical
inaccuracies caused by the imprecision of the float-point presentation may result in errors
or nonstationary AR-matrices. Using smaller <code>ar_scale</code> facilitates the usage of larger
<code>p</code> or <code>d</code>.
</p>


<h3>Value</h3>

<p>Returns <code class="reqn">((pd^2)x1)</code> vector containing stationary vectorized coefficient
matrices <code class="reqn">(vec(A_{1}),...,vec(A_{p})</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity.
<em>Journal of statistical computation and simulation</em>, <strong>24</strong>:2, 99-106.
</p>
</li></ul>


<hr>
<h2 id='random_covmat'>Create random VAR model error term covariance matrix</h2><span id='topic+random_covmat'></span>

<h3>Description</h3>

<p><code>random_covmat</code> generates random VAR model <code class="reqn">(dxd)</code> error term covariance matrix <code class="reqn">\Omega</code>
from (scaled) Wishart distribution for reduced form models and the parameters <code class="reqn">W</code>,<code class="reqn">\lambda_1,...,\lambda_M</code>
for structural models (from normal distributions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_covmat(d, M, omega_scale, W_scale, lambda_scale, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_covmat_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="random_covmat_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="random_covmat_+3A_omega_scale">omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
structural model is considered.</p>
</td></tr>
<tr><td><code id="random_covmat_+3A_w_scale">W_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector partly specifying the scale and variability of the
random covariance matrices in random mutations. The elements of the matrix <code class="reqn">W</code> are drawn independently
from such normal distributions that the expectation of the main <strong>diagonal</strong> elements of the first
regime's error term covariance matrix <code class="reqn">\Omega_1 = WW'</code> is <code>W_scale</code>. The distribution of <code class="reqn">\Omega_1</code>
will be in some sense like a Wishart distribution but with the columns (elements) of <code class="reqn">W</code> obeying the given
constraints. The constraints are accounted for by setting the element to be always zero if it is subject to a zero
constraint and for sign constraints the absolute value or negative the absolute value are taken, and then the
variances of the elements of <code class="reqn">W</code> are adjusted accordingly. This argument is ignored if reduced form model
is considered.</p>
</td></tr>
<tr><td><code id="random_covmat_+3A_lambda_scale">lambda_scale</code></td>
<td>
<p>a length <code class="reqn">M - 1</code> vector specifying the <strong>standard deviation</strong> of the mean zero normal
distribution from which the eigenvalue <code class="reqn">\lambda_{mi}</code> parameters are drawn from in random mutations.
As the eigenvalues should always be positive, the absolute value is taken. The elements of <code>lambda_scale</code>
should be strictly positive real numbers with the <code class="reqn">m-1</code>th element giving the degrees of freedom for the <code class="reqn">m</code>th
regime. The expected value of the main <strong>diagonal</strong> elements <code class="reqn">ij</code> of the <code class="reqn">m</code>th <code class="reqn">(m&gt;1)</code> error term covariance
matrix will be <code>W_scale[i]*(d - n_i)^(-1)*sum(lambdas*ind_fun)</code> where the <code class="reqn">(d x 1)</code> vector <code>lambdas</code> is
drawn from the absolute value of the t-distribution, <code>n_i</code> is the number of zero constraints in the <code class="reqn">i</code>th
row of <code class="reqn">W</code> and <code>ind_fun</code> is an indicator function that takes the value one iff the <code class="reqn">ij</code>th element of
<code class="reqn">W</code> is not constrained to zero. Basically, larger lambdas (or smaller degrees of freedom) imply larger variance.
</p>
<p>If the lambda parameters are <strong>constrained</strong> with the <code class="reqn">(d(M - 1) x r)</code> constraint matrix <code class="reqn">C_lambda</code>,
then provide a length <code class="reqn">r</code> vector specifying the standard deviation of the (absolute value of the) mean zero
normal distribution each of the <code class="reqn">\gamma</code> parameters are drawn from (the <code class="reqn">\gamma</code> is a <code class="reqn">(r x 1)</code> vector).
The expected value of the main diagonal elements of the covariance matrices then depend on the constraints.
</p>
<p>This argument is ignored if <code class="reqn">M==1</code> or a reduced form model is considered. Default is <code>rep(3, times=M-1)</code>
if lambdas are not constrained and <code>rep(3, times=r)</code> if lambdas are constrained.
</p>
<p>As with omega_scale and W_scale, this argument should be adjusted carefully if specified by hand. <strong>NOTE</strong>
that if lambdas are constrained in some other way than restricting some of them to be identical, this parameter
should be adjusted accordingly in order to the estimation succeed!</p>
</td></tr>
<tr><td><code id="random_covmat_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for StMVAR type regimes, the error term covariance matrix is consists of an ARCH type scalar that
multiplies a constant covariance matrix. This function generates the constant covariance matrix part of the
error term covariance matrix.
</p>


<h3>Value</h3>


<dl>
<dt>For <strong>reduced form models</strong>:</dt><dd><p>Returns a <code class="reqn">(d(d+1)/2x1)</code> vector containing vech-vectorized covariance matrix
<code class="reqn">\Omega</code>.</p>
</dd>
<dt>For <strong>structural models</strong>:</dt><dd><p>Returns a length <code class="reqn">d^2 - n_zeros - d*(M - 1)</code> vector of the form
<code class="reqn">(Wvec(W),\lambda_2,...,\lambda_M)</code> where <code class="reqn">\lambda_m=(\lambda_{m1},...,\lambda_{md})</code>
contains the eigenvalue parameters of the <code class="reqn">m</code>th regime <code class="reqn">(m&gt;1)</code> and <code class="reqn">n_zeros</code> is the number of zero constraints
in <code class="reqn">W</code>. If lambdas are <code>C_lambda</code> constrained, replace <code class="reqn">d*(M - 1)</code> in the length with <code class="reqn">r</code> and
<code class="reqn">\lambda_2,...,\lambda_M)</code> with <strong><code class="reqn">\gamma</code></strong>. If <code>fixed_lambdas</code> are used, the <code class="reqn">\lambda_{mi}</code> parameters
are not included. The operator <code class="reqn">Wvec()</code> vectorizes a matrix and removes zeros.</p>
</dd>
</dl>


<hr>
<h2 id='random_df'>Create random degrees of freedom parameter values</h2><span id='topic+random_df'></span>

<h3>Description</h3>

<p><code>random_df</code> generates random <code>M2</code> degrees of freedom parameter values, where
<code>M2</code> is number of StMVAR type regimes in the model-
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_df(M, model = c("GMVAR", "StMVAR", "G-StMVAR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_df_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="random_df_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><strong>GMVAR models</strong>:</dt><dd><p>a numeric vector of length zero.</p>
</dd>
<dt><strong>StMVAR models</strong>:</dt><dd><p>a numeric vector of length <code>M</code> with random entries strictly larger than two.</p>
</dd>
<dt><strong>G-StMVAR models</strong>:</dt><dd><p>a numeric vector of length <code>M2</code> with random entries strictly larger than two.</p>
</dd>
</dl>


<hr>
<h2 id='random_ind'>Create random mean-parametrized parameter vector of a GMVAR, StMVAR, or G-StMVAR model that may not be stationary</h2><span id='topic+random_ind'></span>

<h3>Description</h3>

<p><code>random_ind</code> generates random mean-parametrized parameter vector that may not be stationary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_ind(
  p,
  M,
  d,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  mu_scale,
  mu_scale2,
  omega_scale,
  W_scale,
  lambda_scale,
  ar_scale2 = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_ind_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="random_ind_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="random_ind_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="random_ind_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_mu_scale2">mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>2*sd(data[,i]), i=1,..,d</code>.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_omega_scale">omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
structural model is considered.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_w_scale">W_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector partly specifying the scale and variability of the
random covariance matrices in random mutations. The elements of the matrix <code class="reqn">W</code> are drawn independently
from such normal distributions that the expectation of the main <strong>diagonal</strong> elements of the first
regime's error term covariance matrix <code class="reqn">\Omega_1 = WW'</code> is <code>W_scale</code>. The distribution of <code class="reqn">\Omega_1</code>
will be in some sense like a Wishart distribution but with the columns (elements) of <code class="reqn">W</code> obeying the given
constraints. The constraints are accounted for by setting the element to be always zero if it is subject to a zero
constraint and for sign constraints the absolute value or negative the absolute value are taken, and then the
variances of the elements of <code class="reqn">W</code> are adjusted accordingly. This argument is ignored if reduced form model
is considered.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_lambda_scale">lambda_scale</code></td>
<td>
<p>a length <code class="reqn">M - 1</code> vector specifying the <strong>standard deviation</strong> of the mean zero normal
distribution from which the eigenvalue <code class="reqn">\lambda_{mi}</code> parameters are drawn from in random mutations.
As the eigenvalues should always be positive, the absolute value is taken. The elements of <code>lambda_scale</code>
should be strictly positive real numbers with the <code class="reqn">m-1</code>th element giving the degrees of freedom for the <code class="reqn">m</code>th
regime. The expected value of the main <strong>diagonal</strong> elements <code class="reqn">ij</code> of the <code class="reqn">m</code>th <code class="reqn">(m&gt;1)</code> error term covariance
matrix will be <code>W_scale[i]*(d - n_i)^(-1)*sum(lambdas*ind_fun)</code> where the <code class="reqn">(d x 1)</code> vector <code>lambdas</code> is
drawn from the absolute value of the t-distribution, <code>n_i</code> is the number of zero constraints in the <code class="reqn">i</code>th
row of <code class="reqn">W</code> and <code>ind_fun</code> is an indicator function that takes the value one iff the <code class="reqn">ij</code>th element of
<code class="reqn">W</code> is not constrained to zero. Basically, larger lambdas (or smaller degrees of freedom) imply larger variance.
</p>
<p>If the lambda parameters are <strong>constrained</strong> with the <code class="reqn">(d(M - 1) x r)</code> constraint matrix <code class="reqn">C_lambda</code>,
then provide a length <code class="reqn">r</code> vector specifying the standard deviation of the (absolute value of the) mean zero
normal distribution each of the <code class="reqn">\gamma</code> parameters are drawn from (the <code class="reqn">\gamma</code> is a <code class="reqn">(r x 1)</code> vector).
The expected value of the main diagonal elements of the covariance matrices then depend on the constraints.
</p>
<p>This argument is ignored if <code class="reqn">M==1</code> or a reduced form model is considered. Default is <code>rep(3, times=M-1)</code>
if lambdas are not constrained and <code>rep(3, times=r)</code> if lambdas are constrained.
</p>
<p>As with omega_scale and W_scale, this argument should be adjusted carefully if specified by hand. <strong>NOTE</strong>
that if lambdas are constrained in some other way than restricting some of them to be identical, this parameter
should be adjusted accordingly in order to the estimation succeed!</p>
</td></tr>
<tr><td><code id="random_ind_+3A_ar_scale2">ar_scale2</code></td>
<td>
<p>a positive real number adjusting how large AR parameter values are typically proposed in some
random mutations (if AR constraints are employed, in all random mutations): larger value implies <strong>smaller</strong> coefficients
(in absolute value). <strong>Values larger than 1 can be used if the AR coefficients are expected to be very small.
If set smaller than 1, be careful as it might lead to failure in the creation of stationary parameter candidates</strong></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns random mean-parametrized parameter vector that has the same form as the argument <code>params</code>
in the other functions, for instance, in the function <code>loglikelihood</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='random_ind2'>Create somewhat random parameter vector of a GMVAR, StMVAR, or G-StMVAR model that is always stationary</h2><span id='topic+random_ind2'></span>

<h3>Description</h3>

<p><code>random_ind2</code> generates random mean-parametrized parameter vector
that is always stationary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_ind2(
  p,
  M,
  d,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  mu_scale,
  mu_scale2,
  omega_scale,
  ar_scale = 1,
  W_scale,
  lambda_scale
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_ind2_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="random_ind2_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="random_ind2_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_mu_scale2">mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>2*sd(data[,i]), i=1,..,d</code>.</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_omega_scale">omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
structural model is considered.</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_ar_scale">ar_scale</code></td>
<td>
<p>a positive real number between zero and one, adjusting how large AR parameter values are typically
proposed in construction of the initial population: larger value implies larger coefficients (in absolute value).
After construction of the initial population, a new scale is drawn from <code>(0, upper_ar_scale)</code> uniform
distribution in each iteration. With large <code>p</code> or <code>d</code>, <code>ar_scale</code> is restricted from above,
see the details section.</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_w_scale">W_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector partly specifying the scale and variability of the
random covariance matrices in random mutations. The elements of the matrix <code class="reqn">W</code> are drawn independently
from such normal distributions that the expectation of the main <strong>diagonal</strong> elements of the first
regime's error term covariance matrix <code class="reqn">\Omega_1 = WW'</code> is <code>W_scale</code>. The distribution of <code class="reqn">\Omega_1</code>
will be in some sense like a Wishart distribution but with the columns (elements) of <code class="reqn">W</code> obeying the given
constraints. The constraints are accounted for by setting the element to be always zero if it is subject to a zero
constraint and for sign constraints the absolute value or negative the absolute value are taken, and then the
variances of the elements of <code class="reqn">W</code> are adjusted accordingly. This argument is ignored if reduced form model
is considered.</p>
</td></tr>
<tr><td><code id="random_ind2_+3A_lambda_scale">lambda_scale</code></td>
<td>
<p>a length <code class="reqn">M - 1</code> vector specifying the <strong>standard deviation</strong> of the mean zero normal
distribution from which the eigenvalue <code class="reqn">\lambda_{mi}</code> parameters are drawn from in random mutations.
As the eigenvalues should always be positive, the absolute value is taken. The elements of <code>lambda_scale</code>
should be strictly positive real numbers with the <code class="reqn">m-1</code>th element giving the degrees of freedom for the <code class="reqn">m</code>th
regime. The expected value of the main <strong>diagonal</strong> elements <code class="reqn">ij</code> of the <code class="reqn">m</code>th <code class="reqn">(m&gt;1)</code> error term covariance
matrix will be <code>W_scale[i]*(d - n_i)^(-1)*sum(lambdas*ind_fun)</code> where the <code class="reqn">(d x 1)</code> vector <code>lambdas</code> is
drawn from the absolute value of the t-distribution, <code>n_i</code> is the number of zero constraints in the <code class="reqn">i</code>th
row of <code class="reqn">W</code> and <code>ind_fun</code> is an indicator function that takes the value one iff the <code class="reqn">ij</code>th element of
<code class="reqn">W</code> is not constrained to zero. Basically, larger lambdas (or smaller degrees of freedom) imply larger variance.
</p>
<p>If the lambda parameters are <strong>constrained</strong> with the <code class="reqn">(d(M - 1) x r)</code> constraint matrix <code class="reqn">C_lambda</code>,
then provide a length <code class="reqn">r</code> vector specifying the standard deviation of the (absolute value of the) mean zero
normal distribution each of the <code class="reqn">\gamma</code> parameters are drawn from (the <code class="reqn">\gamma</code> is a <code class="reqn">(r x 1)</code> vector).
The expected value of the main diagonal elements of the covariance matrices then depend on the constraints.
</p>
<p>This argument is ignored if <code class="reqn">M==1</code> or a reduced form model is considered. Default is <code>rep(3, times=M-1)</code>
if lambdas are not constrained and <code>rep(3, times=r)</code> if lambdas are constrained.
</p>
<p>As with omega_scale and W_scale, this argument should be adjusted carefully if specified by hand. <strong>NOTE</strong>
that if lambdas are constrained in some other way than restricting some of them to be identical, this parameter
should be adjusted accordingly in order to the estimation succeed!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficient matrices are generated using the algorithm proposed by Ansley
and Kohn (1986) which forces stationarity. It's not clear in detail how <code>ar_scale</code>
exactly affects the coefficient matrices but larger <code>ar_scale</code> seems to result in larger
AR coefficients. Read the cited article by Ansley and Kohn (1986) and the source code
for more information.
</p>
<p>The covariance matrices are generated from (scaled) Wishart distribution.
</p>
<p>Models with AR parameters constrained are not supported!
</p>


<h3>Value</h3>

<p>Returns random mean-parametrized parameter vector that has the same form as the argument <code>params</code>
in the other functions, for instance, in the function <code>loglikelihood</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Ansley C.F., Kohn R. 1986. A note on reparameterizing a vector autoregressive
moving average model to enforce stationarity.
<em>Journal of statistical computation and simulation</em>, <strong>24</strong>:2, 99-106.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='Rao_test'>Perform Rao's score test for a GSMVAR model</h2><span id='topic+Rao_test'></span>

<h3>Description</h3>

<p><code>Rao_test</code> performs Rao's score test for a GSMVAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rao_test(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rao_test_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code> generated by <code>fitGSMVAR</code> or <code>GSMVAR</code>, containing
the model specified by the null hypothesis (i.e., <strong>the constrained model</strong>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests the constraints imposed in the model given in the argument <code>GSMVAR</code>.
This implementation uses the outer product of gradients approximation in the test statistic.
</p>


<h3>Value</h3>

<p>A list with class &quot;hypotest&quot; containing the test results and arguments used to calculate the test.
</p>


<h3>References</h3>


<ul>
<li><p> Buse A. (1982). The Likelihood Ratio, Wald, and Lagrange Multiplier Tests: An Expository Note.
<em>The American Statistician</em>, 36(3a), 153-157.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples that use parallel computing!
## The below examples take around 30 seconds to run.

# Structural GMVAR(2, 2), d=2 model with recursive identification
# with the AR matrices  restricted to be the identical across the regimes:
W22 &lt;- matrix(c(1, NA, 0, 1), nrow=2, byrow=FALSE)
C_mat &lt;- rbind(diag(2*2^2), diag(2*2^2))
fit22sc &lt;- fitGSMVAR(gdpdef, p=2, M=2, constraints=C_mat,
                     structural_pars=list(W=W22), ncalls=1, seeds=1)

# Test the null:
Rao_test(fit22sc)

</code></pre>

<hr>
<h2 id='redecompose_Omegas'>In the decomposition of the covariance matrices (Muirhead, 1982, Theorem A9.9), change
the order of the covariance matrices.</h2><span id='topic+redecompose_Omegas'></span>

<h3>Description</h3>

<p><code>redecompose_Omegas</code> exchanges the order of the covariance matrices in
the decomposition of Muirhead (1982, Theorem A9.9) and returns the new decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redecompose_Omegas(M, d, W, lambdas, perm = 1:sum(M))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redecompose_Omegas_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="redecompose_Omegas_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="redecompose_Omegas_+3A_w">W</code></td>
<td>
<p>a length <code>d^2</code> vector containing the vectorized W matrix.</p>
</td></tr>
<tr><td><code id="redecompose_Omegas_+3A_lambdas">lambdas</code></td>
<td>
<p>a length <code>d*(M-1)</code> vector of the form <strong><code class="reqn">\lambda_{2}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\lambda_{M}</code></strong>
where <strong><code class="reqn">\lambda_{m}</code></strong><code class="reqn">=(\lambda_{m1},...,\lambda_{md})</code></p>
</td></tr>
<tr><td><code id="redecompose_Omegas_+3A_perm">perm</code></td>
<td>
<p>a vector of length <code>M</code> giving the new order of the covarince matrices
(relative to the current order)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider the following decomposition of positive definite covariannce matrices:
<code class="reqn">\Omega_1 = WW'</code>, <code class="reqn">\Omega_m = W\Lambda_{m}W'</code>, <code class="reqn">m=2,..,M</code> where <code class="reqn">\Lambda_{m} = diag(\lambda_{m1},...,\lambda_{md})</code>
contains the strictly postive eigenvalues of <code class="reqn">\Omega_m\Omega_1^{-1}</code> and the column of the invertible <code class="reqn">W</code> are the
corresponding eigenvectors. Note that this decomposition does not necessarily exists for <code class="reqn">M &gt; 2</code>.
</p>
<p>See Muirhead (1982), Theorem A9.9 for more details on the decomposition and the source code for more details on the reparametrization.
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">d^2 + (M - 1)*d x 1</code> vector of the form <code>c(vec(new_W), new_lambdas)</code>
where the lambdas parameters are in the regimewise order (first regime 2, then 3, etc) and the
&quot;new W&quot; and &quot;new lambdas&quot; are constitute the new decomposition with the order of the covariance
matrices given by the argument <code>perm</code>. Notice that if the first element of <code>perm</code>
is one, the W matrix will be the same and the lambdas are just re-ordered.
</p>
<p><strong>Note that unparametrized zero elements ARE present in the returned W!</strong>
</p>


<h3>Warning</h3>

<p>No argument checks! Does not work with dimension <code class="reqn">d=1</code> or with only
one mixture component <code class="reqn">M=1</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Muirhead R.J. 1982. Aspects of Multivariate Statistical Theory, <em>Wiley</em>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> d &lt;- 2
 M &lt;- 2
 Omega1 &lt;- matrix(c(2, 0.5, 0.5, 2), nrow=d)
 Omega2 &lt;- matrix(c(1, -0.2, -0.2, 1), nrow=d)

 # Decomposition with Omega1 as the first covariance matrix:
 decomp1 &lt;- diag_Omegas(Omega1, Omega2)
 W &lt;- matrix(decomp1[1:d^2], nrow=d, ncol=d)
 lambdas &lt;- decomp1[(d^2 + 1):length(decomp1)]
 tcrossprod(W) # = Omega1
 W%*%tcrossprod(diag(lambdas), W) # = Omega2

 # Reorder the covariance matrices in the decomposition so that now
 # the first covariance matrix is Omega2:
 decomp2 &lt;- redecompose_Omegas(M=M, d=d, W=as.vector(W), lambdas=lambdas,
                               perm=2:1)
 new_W &lt;- matrix(decomp2[1:d^2], nrow=d, ncol=d)
 new_lambdas &lt;- decomp2[(d^2 + 1):length(decomp2)]
 tcrossprod(new_W) # = Omega2
 new_W%*%tcrossprod(diag(new_lambdas), new_W) # = Omega1
</code></pre>

<hr>
<h2 id='reform_constrained_pars'>Reform constrained parameter vector into the &quot;standard&quot; form</h2><span id='topic+reform_constrained_pars'></span>

<h3>Description</h3>

<p><code>reform_constrained_pars</code> reforms constrained parameter vector
into the form that corresponds to unconstrained parameter vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reform_constrained_pars(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  change_na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reform_constrained_pars_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_change_na">change_na</code></td>
<td>
<p>change NA parameter values of constrained models to -9.999?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns &quot;regular model&quot; parameter vector corresponding to the constraints.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='reform_data'>Reform data</h2><span id='topic+reform_data'></span>

<h3>Description</h3>

<p><code>reform_data</code> reforms the data into a form that is
easier to use when calculating log-likelihood values etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reform_data(data, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reform_data_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="reform_data_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the data reformed into a <code class="reqn">((n_obs-p+1)x(dp))</code> matrix. The i:th row
of the matrix contains the vector <code class="reqn">(y_{i-1}',...,y_{i-p}')</code> <code class="reqn">((dp)x1)</code>, where
<code class="reqn">y_{i}=(y_{1i},...,y_{di})</code> <code class="reqn">(dx1)</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='reform_structural_pars'>Reform structural parameter vector into the &quot;standard&quot; form</h2><span id='topic+reform_structural_pars'></span>

<h3>Description</h3>

<p><code>reform_structural_pars</code> reforms (unconstrained) structural
parameter vector into the form that corresponds to reduced form parameter vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reform_structural_pars(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  structural_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reform_structural_pars_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="reform_structural_pars_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reform_structural_pars_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="reform_structural_pars_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="reform_structural_pars_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="reform_structural_pars_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the structural parameter vector is a constrained one, use
<code>reform_constrained_pars</code> first to remove the constraints.
</p>


<h3>Value</h3>

<p>Returns (unconstrained) &quot;reduced form model&quot; parameter vector.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='regime_distance'>Calculate &quot;distance&quot; between two (scaled) regimes
<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code></h2><span id='topic+regime_distance'></span>

<h3>Description</h3>

<p><code>regime_distance</code> calculates &quot;distance&quot; between two scaled regimes. This is used in
the genetic algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regime_distance(regime_pars1, regime_pars2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regime_distance_+3A_regime_pars1">regime_pars1</code></td>
<td>
<p>a length <code class="reqn">pd^2+d+d(d+1)/2</code> vector
<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code>.</p>
</td></tr>
<tr><td><code id="regime_distance_+3A_regime_pars2">regime_pars2</code></td>
<td>
<p>a length <code class="reqn">pd^2+d+d(d+1)/2</code> vector
<strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m})</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns &quot;distance&quot; between <code>regime_pars1</code> and <code>regime_pars2</code>. Values are scaled
before calculating the &quot;distance&quot;. Read the source code for more details.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='reorder_W_columns'>Reorder columns of the W-matrix and lambda parameters of a structural GMVAR, StMVAR, or G-StMVAR model.</h2><span id='topic+reorder_W_columns'></span>

<h3>Description</h3>

<p><code>reorder_W_columns</code> reorder columns of the W-matrix and lambda parameters
of a structural GMVAR, StMVAR, or G-StMVAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_W_columns(gsmvar, perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder_W_columns_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="reorder_W_columns_+3A_perm">perm</code></td>
<td>
<p>an integer vector of length <code class="reqn">d</code> specifying the new order of the columns of <code class="reqn">W</code>.
Also lambda parameters of each regime will be reordered accordingly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the columns of <code class="reqn">W</code> can be changed without changing the implied reduced
form model as long as the order of lambda parameters is also changed accordingly. Note that the
constraints imposed on <code class="reqn">W</code> (or the B-matrix) will also be modified accordingly.
</p>
<p>This function does not support models with constraints imposed on the lambda parameters!
</p>
<p>Also all signs in any column of <code class="reqn">W</code> can be swapped (without changing the implied reduced form model)
with the function <code>swap_W_signs</code> but this obviously also swaps the sign constraints in the
corresponding columns of <code class="reqn">W</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining a structural GMVAR, StMVAR, or G-StMVAR model with the modified
structural parameters and constraints.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>,
<code><a href="#topic+stmvar_to_gstmvar">stmvar_to_gstmvar</a></code>, <code><a href="#topic+swap_W_signs">swap_W_signs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
  0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
  0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(p=2, M=2, d=2, params=params22s, structural_pars=list(W=W_22))
mod22s

# The same reduced form model, reordered W and lambda in the structual model:
mod22s_2 &lt;- reorder_W_columns(mod22s, perm=2:1)
mod22s_2

# Structural StMVAR(2, 2), d=2 model identified with sign-constraints:
mod22ts &lt;- GSMVAR(p=2, M=2, d=2, params=c(params22s, 10, 20), model="StMVAR",
                 structural_pars=list(W=W_22))
mod22ts

# The same reduced form model, reordered W and lambda in the structual model:
mod22ts_2 &lt;- reorder_W_columns(mod22ts, perm=2:1)
mod22ts_2
</code></pre>

<hr>
<h2 id='simulate.gsmvar'>Simulate method for class 'gsmvar' objects</h2><span id='topic+simulate.gsmvar'></span>

<h3>Description</h3>

<p><code>simulate.gsmvar</code> is a simulate method for class 'gsmvar' objects.
It allows to simulate observations from a GMVAR, StMVAR, or G-StMVAR process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmvar'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  ...,
  init_values = NULL,
  init_regimes = 1:sum(gsmvar$model$M),
  ntimes = 1,
  drop = TRUE,
  girf_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.gsmvar_+3A_object">object</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="simulate.gsmvar_+3A_nsim">nsim</code></td>
<td>
<p>number of observations to be simulated.</p>
</td></tr>
<tr><td><code id="simulate.gsmvar_+3A_seed">seed</code></td>
<td>
<p>set seed for the random number generator?</p>
</td></tr>
<tr><td><code id="simulate.gsmvar_+3A_...">...</code></td>
<td>
<p>currently not in use.</p>
</td></tr>
<tr><td><code id="simulate.gsmvar_+3A_init_values">init_values</code></td>
<td>
<p>a size <code class="reqn">(pxd)</code> matrix specifying the initial values, where d is the number
of time series in the system. The <strong>last</strong> row will be used as initial values for the first lag,
the second last row for second lag etc. If not specified, initial values will be drawn according to
mixture distribution specifed by the argument <code>init_regimes</code>.</p>
</td></tr>
<tr><td><code id="simulate.gsmvar_+3A_init_regimes">init_regimes</code></td>
<td>
<p>a numeric vector of length at most <code class="reqn">M</code> and elements
in <code class="reqn">1,...,M</code> specifying the regimes from which the initial values
should be generated from. The initial values will be generated from a
mixture distribution with the mixture components being the stationary
distributions of the specific regimes and the (proportional) mixing weights
given by the mixing weight parameters of those regimes. Note that if
<code>init_regimes=1:M</code>, the initial values are generated from the
stationary distribution of the process and if <code>init_regimes=m</code>, the
initial value are generated from the stationary distribution of the
<code class="reqn">m</code>th regime. Ignored if the argument <code>init_values</code> is specified.</p>
</td></tr>
<tr><td><code id="simulate.gsmvar_+3A_ntimes">ntimes</code></td>
<td>
<p>how many sets of simulations should be performed?</p>
</td></tr>
<tr><td><code id="simulate.gsmvar_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> (default) then the components of the returned list are coerced to lower dimension if <code>ntimes==1</code>, i.e.,
<code>$sample</code> and <code>$mixing_weights</code> will be matrices, and <code>$component</code> will be vector.</p>
</td></tr>
<tr><td><code id="simulate.gsmvar_+3A_girf_pars">girf_pars</code></td>
<td>
<p>This argument is used internally in the estimation of generalized impulse response functions (see <code>?GIRF</code>).
You should ignore it (specifying something else than null to it will change how the function behaves).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>ntimes</code> is intended for forecasting: a GMVAR, StMVAR, or G-StMVAR process can be forecasted by simulating
its possible future values. One can easily perform a large number simulations and calculate the sample quantiles from the simulated
values to obtain prediction intervals (see the forecasting example).
</p>


<h3>Value</h3>

<p>If <code>drop==TRUE</code> and <code>ntimes==1</code> (default): <code>$sample</code>, <code>$component</code>, and <code>$mixing_weights</code> are matrices.
Otherwise, returns a list with...
</p>

<dl>
<dt><code>$sample</code></dt><dd><p>a size (<code>nsim</code><code class="reqn"> x d x </code><code>ntimes</code>) array containing the samples: the dimension <code>[t, , ]</code> is
the time index, the dimension <code>[, d, ]</code> indicates the marginal time series, and the dimension <code>[, , i]</code> indicates
the i:th set of simulations.</p>
</dd>
<dt><code>$component</code></dt><dd><p>a size (<code>nsim</code><code class="reqn"> x </code><code>ntimes</code>) matrix containing the information from which mixture component
each value was generated from.</p>
</dd>
<dt><code>$mixing_weights</code></dt><dd><p>a size (<code>nsim</code><code class="reqn"> x M x </code><code>ntimes</code>) array containing the mixing weights corresponding to
the sample: the dimension <code>[t, , ]</code> is the time index, the dimension <code>[, m, ]</code> indicates the regime, and the dimension
<code>[, , i]</code> indicates the i:th set of simulations.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+predict.gsmvar">predict.gsmvar</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+GFEVD">GFEVD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # GMVAR(1,2), d=2 process, initial values from the stationary
 # distribution
 params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005,
  0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012, 0.136,
  0.674)
 mod12 &lt;- GSMVAR(p=1, M=2, d=2, params=params12)
 set.seed(1)
 sim12 &lt;- simulate(mod12, nsim=500)
 plot.ts(sim12$sample)
 ts.plot(sim12$mixing_weights, col=c("blue", "red"), lty=2)
 plot(sim12$component, type="l")

 # StMVAR(2, 2), d=2 model
 params22t &lt;- c(0.554, 0.033, 0.184, 0.005, -0.186, 0.683, 0.256, 0.031,
  0.026, 0.204, 0.583, -0.002, 0.048, 0.697, 0.154, 0.049, 0.374, 0.476,
   0.318, -0.645, -0.302, -0.222, 0.193, 0.042, -0.013, 0.048, 0.818,
    4.334, 20)
 mod22t &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22t, model="StMVAR")
 sim22t &lt;- simulate(mod22t, nsim=100)
 plot.ts(sim22t$mixing_weights)

 ## FORECASTING EXAMPLE ##
 # Forecast 5-steps-ahead, 500 sets of simulations with initial
 # values from the data:
 # GMVAR(2,2), d=2 model
 params22 &lt;- c(0.36, 0.121, 0.223, 0.059, -0.151, 0.395, 0.406, -0.005,
  0.083, 0.299, 0.215, 0.002, 0.03, 0.484, 0.072, 0.218, 0.02, -0.119,
   0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004, 0.105, 0.58)
 mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22)
 sim22 &lt;- simulate(mod22, nsim=5, ntimes=500)

 # Point forecast + 95% prediction intervals:
 apply(sim22$sample, MARGIN=1:2, FUN=quantile, probs=c(0.025, 0.5, 0.972))

 # Similar forecast for the mixing weights:
 apply(sim22$mixing_weights, MARGIN=1:2, FUN=quantile,
       probs=c(0.025, 0.5, 0.972))
</code></pre>

<hr>
<h2 id='simulateGMVAR'>DEPRECATED! USE THE FUNCTION simulate.gsmvar INSTEAD! Simulate from GMVAR process</h2><span id='topic+simulateGMVAR'></span>

<h3>Description</h3>

<p>DEPRECATED! USE THE FUNCTION simulate.gsmvar INSTEAD!
<code>simulateGMVAR</code> simulates observations from a GMVAR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateGMVAR(
  gmvar,
  nsimu,
  init_values = NULL,
  ntimes = 1,
  drop = TRUE,
  seed = NULL,
  girf_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateGMVAR_+3A_gmvar">gmvar</code></td>
<td>
<p>object of class 'gmvar'</p>
</td></tr>
<tr><td><code id="simulateGMVAR_+3A_nsimu">nsimu</code></td>
<td>
<p>number of observations to be simulated.</p>
</td></tr>
<tr><td><code id="simulateGMVAR_+3A_init_values">init_values</code></td>
<td>
<p>a size <code class="reqn">(pxd)</code> matrix specifying the initial values, where d is the number
of time series in the system. The <strong>last</strong> row will be used as initial values for the first lag,
the second last row for second lag etc. If not specified, initial values will be drawn according to
mixture distribution specifed by the argument <code>init_regimes</code>.</p>
</td></tr>
<tr><td><code id="simulateGMVAR_+3A_ntimes">ntimes</code></td>
<td>
<p>how many sets of simulations should be performed?</p>
</td></tr>
<tr><td><code id="simulateGMVAR_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> (default) then the components of the returned list are coerced to lower dimension if <code>ntimes==1</code>, i.e.,
<code>$sample</code> and <code>$mixing_weights</code> will be matrices, and <code>$component</code> will be vector.</p>
</td></tr>
<tr><td><code id="simulateGMVAR_+3A_seed">seed</code></td>
<td>
<p>set seed for the random number generator?</p>
</td></tr>
<tr><td><code id="simulateGMVAR_+3A_girf_pars">girf_pars</code></td>
<td>
<p>This argument is used internally in the estimation of generalized impulse response functions (see <code>?GIRF</code>).
You should ignore it (specifying something else than null to it will change how the function behaves).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>ntimes</code> is intended for forecasting: a GMVAR, StMVAR, or G-StMVAR process can be forecasted by simulating
its possible future values. One can easily perform a large number simulations and calculate the sample quantiles from the simulated
values to obtain prediction intervals (see the forecasting example).
</p>


<h3>Value</h3>

<p>If <code>drop==TRUE</code> and <code>ntimes==1</code> (default): <code>$sample</code>, <code>$component</code>, and <code>$mixing_weights</code> are matrices.
Otherwise, returns a list with...
</p>

<dl>
<dt><code>$sample</code></dt><dd><p>a size (<code>nsim</code><code class="reqn"> x d x </code><code>ntimes</code>) array containing the samples: the dimension <code>[t, , ]</code> is
the time index, the dimension <code>[, d, ]</code> indicates the marginal time series, and the dimension <code>[, , i]</code> indicates
the i:th set of simulations.</p>
</dd>
<dt><code>$component</code></dt><dd><p>a size (<code>nsim</code><code class="reqn"> x </code><code>ntimes</code>) matrix containing the information from which mixture component
each value was generated from.</p>
</dd>
<dt><code>$mixing_weights</code></dt><dd><p>a size (<code>nsim</code><code class="reqn"> x M x </code><code>ntimes</code>) array containing the mixing weights corresponding to
the sample: the dimension <code>[t, , ]</code> is the time index, the dimension <code>[, m, ]</code> indicates the regime, and the dimension
<code>[, , i]</code> indicates the i:th set of simulations.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+simulate.gsmvar">simulate.gsmvar</a></code>
</p>

<hr>
<h2 id='smart_covmat'>Create random VAR-model <code class="reqn">(dxd)</code> error term covariance matrix <code class="reqn">\Omega</code>
fairly close to a given <strong>positive definite</strong> covariance matrix using (scaled)
Wishart distribution</h2><span id='topic+smart_covmat'></span>

<h3>Description</h3>

<p><code>random_covmat</code> generates random VAR model <code class="reqn">(dxd)</code> error term covariance matrix <code class="reqn">\Omega</code>
from (scaled) Wishart distribution that is fairly close to the given matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_covmat(d, M, Omega, W_and_lambdas, accuracy, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smart_covmat_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="smart_covmat_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="smart_covmat_+3A_omega">Omega</code></td>
<td>
<p>a symmetric positive definite <code class="reqn">(dxd)</code> covariance matrix specifying
expected value of the matrix to be generated.</p>
</td></tr>
<tr><td><code id="smart_covmat_+3A_w_and_lambdas">W_and_lambdas</code></td>
<td>
<p>the mean of the normal distribution the new parameters are generated
from.
</p>

<dl>
<dt>If lambdas are <strong>not constrained</strong>:</dt><dd><p>a size <code class="reqn">(d^2 - n_zeros + d*(M - 1))</code> vector
<code class="reqn">(Wvec(W),\lambda_{2},...,\lambda{M})</code>, where <code class="reqn">n_zeros</code> is the number of zero constraints
in <code class="reqn">W</code> and <code class="reqn">\lambda_m=(\lambda_{m1},...,\lambda_{md})</code>.</p>
</dd>
<dt>If lambdas are <strong>constrained</strong>:</dt><dd><p>a size <code class="reqn">(d^2 - n_zeros + r)</code> vector
<code class="reqn">(Wvec(W),\gamma)</code>, where <code class="reqn">C_{\lambda}\gamma =(\lambda_2,....,\lambda_M)</code>, <code class="reqn">\gamma</code>
is of the size <code class="reqn">(r x 1)</code>, and <code class="reqn">C_{\lambda}</code> of the size <code class="reqn">(d*(M - 1) x r</code>).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="smart_covmat_+3A_accuracy">accuracy</code></td>
<td>
<p>a positive real number adjusting how close to the given covariance matrix
the returned individual should be.
</p>
<p>For <strong>reduced form models</strong> standard deviation of each diagonal element is for reduced form
models
</p>

<ul>
<li> <p><code class="reqn">\omega_{i,i}/</code><code>accuracy</code> when <code>accuracy &gt; d/2</code>
</p>
</li>
<li><p> and <code>sqrt(2/d)*</code><code class="reqn">\omega_{i,i}</code> when <code>accuracy &lt;= d/2</code>.
</p>
</li></ul>

<p>Wishart distribution is used for reduced form models, but for more details read the source code.
</p>
<p>For <strong>structural models</strong>, the parameters are generated from normal distribution with mean given
by the argument <code>W_and_lambdas</code> and the standard deviation is <code>sqrt(abs(W_and_lambdas)/(d + accuracy))</code>.</p>
</td></tr>
<tr><td><code id="smart_covmat_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>For <strong>reduced form models</strong>:</dt><dd><p>Returns a <code class="reqn">(d(d+1)/2x1)</code> vector containing vech-vectorized covariance matrix
<code class="reqn">\Omega</code>.</p>
</dd>
<dt>For <strong>structural models</strong>:</dt><dd><p>Returns a length <code class="reqn">d^2 - n_zeros - d*(M - 1)</code> vector of the form
<code class="reqn">(Wvec(W),\lambda_2,...,\lambda_M)</code> where <code class="reqn">\lambda_m=(\lambda_{m1},...,\lambda_{md})</code>
contains the eigenvalue parameters of the <code class="reqn">m</code>th regime <code class="reqn">(m&gt;1)</code> and <code class="reqn">n_zeros</code> is the number of zero constraints
in <code class="reqn">W</code>. If lambdas are <code>C_lambda</code> constrained, replace <code class="reqn">d*(M - 1)</code> in the length with <code class="reqn">r</code> and
<code class="reqn">\lambda_2,...,\lambda_M)</code> with <strong><code class="reqn">\gamma</code></strong>. If <code>fixed_lambdas</code> are used, the <code class="reqn">\lambda_{mi}</code> parameters
are not included. The operator <code class="reqn">Wvec()</code> vectorizes a matrix and removes zeros.</p>
</dd>
</dl>


<hr>
<h2 id='smart_df'>Create random degrees of freedom parameter values close to given values</h2><span id='topic+smart_df'></span>

<h3>Description</h3>

<p><code>random_df</code> generates random <code>M2</code> degrees of freedom parameter values
close to given values, where <code>M2</code> is number of StMVAR type regimes in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_df(
  M,
  df,
  accuracy,
  which_random = numeric(0),
  model = c("GMVAR", "StMVAR", "G-StMVAR")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smart_df_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="smart_df_+3A_df">df</code></td>
<td>
<p>the old degrees of freedom parameters (of all regimes)</p>
</td></tr>
<tr><td><code id="smart_df_+3A_accuracy">accuracy</code></td>
<td>
<p>a positive real number adjusting how close to the given degrees of freedom parameters
the returned df should be.</p>
</td></tr>
<tr><td><code id="smart_df_+3A_which_random">which_random</code></td>
<td>
<p>a vector with length between 1 and M specifying the mixture components that should be random instead of
close to the given degrees of freedom.</p>
</td></tr>
<tr><td><code id="smart_df_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><strong>GMVAR models</strong>:</dt><dd><p>a numeric vector of length zero.</p>
</dd>
<dt><strong>StMVAR models</strong>:</dt><dd><p>a numeric vector of length <code>M</code> with random entries strictly larger than two.</p>
</dd>
<dt><strong>G-StMVAR models</strong>:</dt><dd><p>a numeric vector of length <code>M2</code> with random entries strictly larger than two.</p>
</dd>
</dl>


<hr>
<h2 id='smart_ind'>Create random parameter vector of a GMVAR, StMVAR, or G-StMVAR model fairly close to a given
parameter vector</h2><span id='topic+smart_ind'></span>

<h3>Description</h3>

<p><code>smart_ind</code> creates random mean-parametrized parameter vector of a GMVAR, StMVAR, or G-StMVAR
model fairly close to a given parameter vector. The result may not be stationary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smart_ind(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  accuracy = 1,
  which_random = numeric(0),
  mu_scale,
  mu_scale2,
  omega_scale,
  ar_scale = 1,
  ar_scale2 = 1,
  W_scale,
  lambda_scale
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smart_ind_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="smart_ind_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="smart_ind_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_accuracy">accuracy</code></td>
<td>
<p>a positive real number adjusting how close to the given parameter vector the returned individual should be.
Larger number means larger accuracy. Read the source code for details.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_which_random">which_random</code></td>
<td>
<p>a vector with length between 1 and M specifying the mixture components that should be random instead of
close to the given parameter vector. This does not consider constrained AR or lambda parameters.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> vector defining <strong>means</strong> of the normal distributions from which each
mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations. Default is <code>colMeans(data)</code>. Note that
mean-parametrization is always used for optimization in <code>GAfit</code> - even when <code>parametrization=="intercept"</code>.
However, input (in <code>initpop</code>) and output (return value) parameter vectors can be intercept-parametrized.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_mu_scale2">mu_scale2</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector defining <strong>standard deviations</strong> of the normal
distributions from which each mean parameter <code class="reqn">\mu_{m}</code> is drawn from in random mutations.
Default is <code>2*sd(data[,i]), i=1,..,d</code>.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_omega_scale">omega_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector specifying the scale and variability of the
random covariance matrices in random mutations. The covariance matrices are drawn from (scaled) Wishart
distribution. Expected values of the random covariance matrices are <code>diag(omega_scale)</code>. Standard
deviations of the diagonal elements are <code>sqrt(2/d)*omega_scale[i]</code>
and for non-diagonal elements they are <code>sqrt(1/d*omega_scale[i]*omega_scale[j])</code>.
Note that for <code>d&gt;4</code> this scale may need to be chosen carefully. Default in <code>GAfit</code> is
<code>var(stats::ar(data[,i], order.max=10)$resid, na.rm=TRUE), i=1,...,d</code>. This argument is ignored if
structural model is considered.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_ar_scale">ar_scale</code></td>
<td>
<p>a positive real number between zero and one, adjusting how large AR parameter values are typically
proposed in construction of the initial population: larger value implies larger coefficients (in absolute value).
After construction of the initial population, a new scale is drawn from <code>(0, upper_ar_scale)</code> uniform
distribution in each iteration. With large <code>p</code> or <code>d</code>, <code>ar_scale</code> is restricted from above,
see the details section.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_ar_scale2">ar_scale2</code></td>
<td>
<p>a positive real number adjusting how large AR parameter values are typically proposed in some
random mutations (if AR constraints are employed, in all random mutations): larger value implies <strong>smaller</strong> coefficients
(in absolute value). <strong>Values larger than 1 can be used if the AR coefficients are expected to be very small.
If set smaller than 1, be careful as it might lead to failure in the creation of stationary parameter candidates</strong></p>
</td></tr>
<tr><td><code id="smart_ind_+3A_w_scale">W_scale</code></td>
<td>
<p>a size <code class="reqn">(dx1)</code> strictly positive vector partly specifying the scale and variability of the
random covariance matrices in random mutations. The elements of the matrix <code class="reqn">W</code> are drawn independently
from such normal distributions that the expectation of the main <strong>diagonal</strong> elements of the first
regime's error term covariance matrix <code class="reqn">\Omega_1 = WW'</code> is <code>W_scale</code>. The distribution of <code class="reqn">\Omega_1</code>
will be in some sense like a Wishart distribution but with the columns (elements) of <code class="reqn">W</code> obeying the given
constraints. The constraints are accounted for by setting the element to be always zero if it is subject to a zero
constraint and for sign constraints the absolute value or negative the absolute value are taken, and then the
variances of the elements of <code class="reqn">W</code> are adjusted accordingly. This argument is ignored if reduced form model
is considered.</p>
</td></tr>
<tr><td><code id="smart_ind_+3A_lambda_scale">lambda_scale</code></td>
<td>
<p>a length <code class="reqn">M - 1</code> vector specifying the <strong>standard deviation</strong> of the mean zero normal
distribution from which the eigenvalue <code class="reqn">\lambda_{mi}</code> parameters are drawn from in random mutations.
As the eigenvalues should always be positive, the absolute value is taken. The elements of <code>lambda_scale</code>
should be strictly positive real numbers with the <code class="reqn">m-1</code>th element giving the degrees of freedom for the <code class="reqn">m</code>th
regime. The expected value of the main <strong>diagonal</strong> elements <code class="reqn">ij</code> of the <code class="reqn">m</code>th <code class="reqn">(m&gt;1)</code> error term covariance
matrix will be <code>W_scale[i]*(d - n_i)^(-1)*sum(lambdas*ind_fun)</code> where the <code class="reqn">(d x 1)</code> vector <code>lambdas</code> is
drawn from the absolute value of the t-distribution, <code>n_i</code> is the number of zero constraints in the <code class="reqn">i</code>th
row of <code class="reqn">W</code> and <code>ind_fun</code> is an indicator function that takes the value one iff the <code class="reqn">ij</code>th element of
<code class="reqn">W</code> is not constrained to zero. Basically, larger lambdas (or smaller degrees of freedom) imply larger variance.
</p>
<p>If the lambda parameters are <strong>constrained</strong> with the <code class="reqn">(d(M - 1) x r)</code> constraint matrix <code class="reqn">C_lambda</code>,
then provide a length <code class="reqn">r</code> vector specifying the standard deviation of the (absolute value of the) mean zero
normal distribution each of the <code class="reqn">\gamma</code> parameters are drawn from (the <code class="reqn">\gamma</code> is a <code class="reqn">(r x 1)</code> vector).
The expected value of the main diagonal elements of the covariance matrices then depend on the constraints.
</p>
<p>This argument is ignored if <code class="reqn">M==1</code> or a reduced form model is considered. Default is <code>rep(3, times=M-1)</code>
if lambdas are not constrained and <code>rep(3, times=r)</code> if lambdas are constrained.
</p>
<p>As with omega_scale and W_scale, this argument should be adjusted carefully if specified by hand. <strong>NOTE</strong>
that if lambdas are constrained in some other way than restricting some of them to be identical, this parameter
should be adjusted accordingly in order to the estimation succeed!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns random mean-parametrized parameter vector that has the same form as the argument <code>params</code>
in the other functions, for instance, in the function <code>loglikelihood</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='sort_and_standardize_alphas'>Sort mixing weight parameters in a decreasing order and standardize them
to sum to one. For G-StMVAR models, the mixing weight parameters are sorted
to a decreasing order for GMVAR and StMVAR type regimes separately.</h2><span id='topic+sort_and_standardize_alphas'></span>

<h3>Description</h3>

<p><code>sort_and_standardize_alphas</code> sorts mixing weight parameters in a decreasing
order and standardizes them to sum to one. For G-StMVAR models, the mixing weight parameters are sorted
to a decreasing order for GMVAR and StMVAR type regimes separately. Does not sort if AR constraints,
lambda constraints, or same means are employed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_and_standardize_alphas(
  alphas,
  M,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_and_standardize_alphas_+3A_alphas">alphas</code></td>
<td>
<p>mixing weights parameters alphas, <strong>INCLUDING</strong> the one for the M:th regime (that is
not parametrized in the model). Don't need to be standardized to sum to one.</p>
</td></tr>
<tr><td><code id="sort_and_standardize_alphas_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sort_and_standardize_alphas_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="sort_and_standardize_alphas_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="sort_and_standardize_alphas_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="sort_and_standardize_alphas_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="sort_and_standardize_alphas_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the given alphas in a (M x 1) vector sorted in decreasing order and their sum standardized to one.
If AR constraints, lambda constraints, or same means are employed, does not sort but standardizes the alphas
to sum to one. If <code>weight_constraints</code> are used, gives an error.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='sort_components'>Sort components in parameter vector according to mixing weights into a decreasing order</h2><span id='topic+sort_components'></span>

<h3>Description</h3>

<p><code>sort_components</code> sorts mixture components in the parameter vector according
to mixing weights into a decreasing order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_components(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  structural_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_components_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="sort_components_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sort_components_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="sort_components_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="sort_components_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constrained parameter vectors are not supported (expect for constraints in W but including
constraining some mean parameters to be the same among different regimes)!
For structural models, sorting the regimes in a decreasing order requires re-parametrizing the
decomposition of the covariance matrices if the first regime changes. As a result, the sorted
parameter vector will differ from the given one not only by the ordering of the elements but
also by some of the parameter values.
</p>


<h3>Value</h3>

<p>Returns sorted parameter vector of the form described for the argument <code>params</code>,
with the mixture components sorted so that <code class="reqn">\alpha_{1}&gt;...&gt;\alpha_{M}</code> for GMVAR and StMVAR
models, and <code class="reqn">\alpha_{1}&gt;...&gt;\alpha_{M1}</code> and <code class="reqn">\alpha_{M1+1}&gt;...&gt;\alpha_{M}</code> for G-StMVAR models.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='sort_W_and_lambdas'>Sort the columns of W matrix by sorting the lambda parameters of the second regime to increasing order</h2><span id='topic+sort_W_and_lambdas'></span>

<h3>Description</h3>

<p><code>sort_W_and_lambdas</code> sorts the columns of W matrix by sorting the lambda parameters of
the second regime to increasing order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_W_and_lambdas(p, M, d, params, model = c("GMVAR", "StMVAR", "G-StMVAR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_W_and_lambdas_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="sort_W_and_lambdas_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sort_W_and_lambdas_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="sort_W_and_lambdas_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For reduced form models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For structural model:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong>
# should be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only structural models are supported (but there is no need to provide
structural_pars).
<strong>This function does not sort the constraints of the W matrix but just sorts
the columns of the W matrix and the lambda parameters.</strong> It is mainly used in the genetic
algorithm to assist estimation with better identification when the constraints are not
itself strong for identification of the parameters (but are invariant to different orderings
of the columns of the W matrix).
</p>
<p>Before using this function, make sure the parameter vector is sortable: the constraints on
the W matrix is invariant to different orderings of the columns, there are no zero restrictions,
and there are no constraints on the lambda parameters.
</p>


<h3>Value</h3>

<p>Returns the sorted parameter vector (that implies the same reduced form model).
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>


<hr>
<h2 id='standard_errors'>Calculate standard errors for estimates of a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+standard_errors'></span>

<h3>Description</h3>

<p><code>standard_errors</code> calculates approximate standard errors for the GMVAR,
StMVAR, or G-StMVAR model using square roots of the diagonal of inverse of observed information matrix
and central-difference approximation for the differentiation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard_errors(
  data,
  p,
  M,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  minval,
  custom_h = NULL,
  stat_tol = 0.001,
  posdef_tol = 1e-08,
  df_tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standard_errors_+3A_data">data</code></td>
<td>
<p>a matrix or class <code>'ts'</code> object with <code>d&gt;1</code> columns. Each column is taken to represent
a univariate time series. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="standard_errors_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function
should be used.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="standard_errors_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_minval">minval</code></td>
<td>
<p>the value that will be returned if the parameter vector does not lie in the parameter space
(excluding the identification condition).</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_custom_h">custom_h</code></td>
<td>
<p>A numeric vector with same the length as the parameter vector: i:th element of custom_h is the difference
used in central difference approximation for partial differentials of the log-likelihood function for the i:th parameter.
If <code>NULL</code> (default), then the difference used for differentiating overly large degrees of freedom parameters
is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other parameters.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the approximate standard errors of the estimates.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>

<hr>
<h2 id='stmvar_to_gstmvar'>Estimate a G-StMVAR model based on a StMVAR model that has large degrees of freedom parameters</h2><span id='topic+stmvar_to_gstmvar'></span>

<h3>Description</h3>

<p><code>stmvar_to_gstmvar</code> estimates a G-StMVAR model based on a StMVAR model that has
large degrees of freedom parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stmvar_to_gstmvar(
  gsmvar,
  estimate,
  calc_std_errors = estimate,
  maxdf = 100,
  maxit = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stmvar_to_gstmvar_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="stmvar_to_gstmvar_+3A_estimate">estimate</code></td>
<td>
<p>set <code>TRUE</code> if the new model should be estimated with a variable metric algorithm
using the StMAR model parameter value as the initial value. By default <code>TRUE</code> iff the model
contains data.</p>
</td></tr>
<tr><td><code id="stmvar_to_gstmvar_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>set <code>TRUE</code> if the approximate standard errors should be calculated.</p>
</td></tr>
<tr><td><code id="stmvar_to_gstmvar_+3A_maxdf">maxdf</code></td>
<td>
<p>regimes with degrees of freedom parameter value larger than this will be turned into
GMVAR type.</p>
</td></tr>
<tr><td><code id="stmvar_to_gstmvar_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations for the variable metric algorithm. Ignored if <code>estimate==FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a StMVAR model contains large estimates for the degrees of freedom parameters,
one should consider switching to the corresponding G-StMAR model that lets the corresponding
regimes to be GMVAR type. <code>stmvar_to_gstmvar</code> does this switch conveniently. Also G-StMVAR models
are supported if some of the StMVAR type regimes have large degrees of freedom paraters.
</p>
<p>Note that if the model imposes constraints on the autoregressive parameters, or if a structural model imposes
constraints on the lambda parameters, and the ordering the regimes changes, the constraints are removed from
the model. This is because of the form of the constraints that does not generally allow to switch the ordering
of the regimes. If you wish to keep the constraints, you may construct the resulting G-StMVAR model parameter
vector by hand, redefine your constraints accordingly, build the model with the function <code>GSMVAR</code>, and then
estimate it with the function <code>iterate_more</code>. Alternatively, you can always directly estimate the constrained
G-StMVAR model with the function <code>fitGSMVAR</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining a G-StMVAR model based on the provided StMVAR (or G-StMVAR)
model with the regimes that had large degrees of freedom parameters changed to GMVAR type.
</p>


<h3>References</h3>


<ul>
<li><p> Muirhead R.J. 1982. Aspects of Multivariate Statistical Theory, <em>Wiley</em>.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+reorder_W_columns">reorder_W_columns</a></code>,
<code><a href="#topic+swap_W_signs">swap_W_signs</a></code>, <code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# StMVAR(1, 2), d=2 model:
params12t &lt;- c(0.5453, 0.1157, 0.331, 0.0537, -0.0422, 0.7089, 0.4181, 0.0018,
  0.0413, 1.6004, 0.4843, 0.1256, -0.0311, -0.6139, 0.7221, 1.2123, -0.0357,
  0.1381, 0.8337, 7.5564, 90000)
mod12t &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12t, model="StMVAR")
mod12t

# Switch to the G-StMVAR model:
mod12gs &lt;- stmvar_to_gstmvar(mod12t)
mod12gs

</code></pre>

<hr>
<h2 id='stmvarpars_to_gstmvar'>Transform a StMVAR (or G-StMVAR) model parameter vector to the corresponding G-StMVAR model parameter vector
with the large df parameters removed.</h2><span id='topic+stmvarpars_to_gstmvar'></span>

<h3>Description</h3>

<p><code>stmvarpars_to_gstmvar</code> transforms a StMVAR (or G-StMVAR) model parameter vector to the corresponding
G-StMVAR model parameter vector with the large df parameters removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stmvarpars_to_gstmvar(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL,
  maxdf = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stmvarpars_to_gstmvar_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="stmvarpars_to_gstmvar_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stmvarpars_to_gstmvar_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="stmvarpars_to_gstmvar_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="stmvarpars_to_gstmvar_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="stmvarpars_to_gstmvar_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="stmvarpars_to_gstmvar_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="stmvarpars_to_gstmvar_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
<tr><td><code id="stmvarpars_to_gstmvar_+3A_maxdf">maxdf</code></td>
<td>
<p>regimes with degrees of freedom parameter value larger than this will be turned into
GMVAR type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If constraints are employed on the autoregressive parameters, the regimes cannot be sorted due to the
</p>


<h3>Value</h3>

<p>Returns a list with six elements: <code>$params</code> contains the corresponding G-StMVAR model
parameter vector, <code>$reg_order</code> contains the permutation that was applied to the regimes
(GMVAR type regimes first, and decreasing ordering by mixing weight parameters),
<code>$M</code> a vector of length two containing the number of GMVAR type regimes in the first element
and the number of StMVAR type regimes in the second, <code>$same_means</code> contains the <code>same_mean</code>
constraints of the new model. Finally <code>$weight_constraints</code> contains the <code>weight_constraints</code> and
<code>$fixed_lambdas</code> the <code>structural_pars$fixed_lambdas</code>  of the new model
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='swap_parametrization'>Swap the parametrization of a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+swap_parametrization'></span>

<h3>Description</h3>

<p><code>swap_parametrization</code> swaps the parametrization of a GMVAR, StMVAR or G-StMVAR, model
to <code>"mean"</code> if the current parametrization is <code>"intercept"</code>, and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_parametrization(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_parametrization_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>swap_parametrization</code> is a convenient tool if you have estimated the model in
&quot;intercept&quot;-parametrization, but wish to work with &quot;mean&quot;-parametrization in the future, or vice versa.
In <code>gmvarkit</code>, the approximate standard errors are only available for parametrized parameters.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining the specified reduced form or structural GMVAR,
StMVAR, or G-StMVAR model. Can be used to work with other functions provided in <code>gmvarkit</code>.
</p>
<p>Note that the first autocovariance/correlation matrix in <code>$uncond_moments</code> is for the lag zero,
the second one for the lag one, etc.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Kalliovirta L. and Saikkonen P. 2010. Reliable Residuals for Multivariate Nonlinear
Time Series Models. <em>Unpublished Revision of HECER Discussion Paper No. 247</em>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+update_numtols">update_numtols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMVAR(2, 2), d=2 model with mean-parametrization:
params22 &lt;- c(0.869, 0.549, 0.223, 0.059, -0.151, 0.395, 0.406,
 -0.005, 0.083, 0.299, 0.215, 0.002, 0.03, 0.576, 1.168, 0.218,
 0.02, -0.119, 0.722, 0.093, 0.032, 0.044, 0.191, 1.101, -0.004,
 0.105, 0.58)
mod22 &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22, parametrization="mean")
mod22 # mean parametrization

mod22_2 &lt;- swap_parametrization(mod22)
mod22_2 # intercept parametrization

# G-StMVAR(2, 1, 1), d=2 model with mean-parametrization:
mod22gs &lt;- GSMVAR(gdpdef, p=2, M=c(1, 1), params=c(params22, 10), model="G-StMVAR",
                  parametrization="mean")
mod22gs # mean parametrization

mod22gs_2 &lt;- swap_parametrization(mod22gs)
mod22gs_2 # intercept parametrization

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
  0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
  0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(p=2, M=2, d=2, params=params22s, structural_pars=list(W=W_22))
mod22s # intercept parametrization

mod22s_2 &lt;- swap_parametrization(mod22s)
mod22s_2 # mean parametrization

</code></pre>

<hr>
<h2 id='swap_W_signs'>Swap all signs in pointed columns a the <code class="reqn">W</code> matrix of a structural GMVAR, StMVAR, or G-StMVAR model.</h2><span id='topic+swap_W_signs'></span>

<h3>Description</h3>

<p><code>swap_W_signs</code> swaps all signs in pointed columns a the <code class="reqn">W</code> matrix
of a structural GMVAR, StMVAR, or G-StMVAR model. Consequently, signs in the columns of the B-matrix are also swapped
accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_W_signs(gsmvar, which_to_swap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_W_signs_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="swap_W_signs_+3A_which_to_swap">which_to_swap</code></td>
<td>
<p>a numeric vector of length at most <code class="reqn">d</code> and elemnts in <code class="reqn">1,..,d</code>
specifying the columns of <code class="reqn">W</code> whose sign should be swapped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All signs in any column of <code class="reqn">W</code> can be swapped without changing the implied reduced form model.
Consequently, also the signs in the columns of the B-matrix are swapped. Note that the sign constraints
imposed on <code class="reqn">W</code> (or the B-matrix) are also swapped in the corresponding columns accordingly.
</p>
<p>Also the order of the columns of <code class="reqn">W</code> can be changed (without changing the implied reduced
form model) as long as the order of lambda parameters is also changed accordingly. This can be
done with the function <code>reorder_W_columns</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining a structural GMVAR, StMVAR, or G-StMVAR model with the modified
structural parameters and constraints.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+reorder_W_columns">reorder_W_columns</a></code>,
<code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>, <code><a href="#topic+stmvar_to_gstmvar">stmvar_to_gstmvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
  0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
  0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(p=2, M=2, d=2, params=params22s, structural_pars=list(W=W_22))
mod22s

# The same reduced form model, with signs in the second column of W swapped:
swap_W_signs(mod22s, which_to_swap=2)

# The same reduced form model, with signs in both column of W swapped:
swap_W_signs(mod22s, which_to_swap=1:2)

#' # Structural G-StMVAR(2, 1, 1), d=2 model identified with sign-constraints:
mod22gss &lt;- GSMVAR(p=2, M=c(1, 1), d=2, params=c(params22s, 10), model="G-StMVAR",
                   structural_pars=list(W=W_22))
mod22gss

# The same reduced form model, with signs in the first column of W swapped:
swap_W_signs(mod22gss, which_to_swap=1)
</code></pre>

<hr>
<h2 id='uncond_moments'>Calculate the unconditional mean, variance, the first p autocovariances, and the first p autocorrelations
of a GMVAR, StMVAR, or G-StMVAR process</h2><span id='topic+uncond_moments'></span>

<h3>Description</h3>

<p><code>uncond_moments</code> calculates the unconditional mean, variance, the first p autocovariances,
and the first p autocorrelations of the given GMVAR, StMVAR, or G-StMVAR process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncond_moments(gsmvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncond_moments_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The unconditional moments are based on the stationary distribution of the process.
</p>


<h3>Value</h3>

<p>Returns a list with three components:
</p>

<dl>
<dt><code>$uncond_mean</code></dt><dd><p>a length d vector containing the unconditional mean of the process.</p>
</dd>
<dt><code>$autocovs</code></dt><dd><p>an <code class="reqn">(d x d x p+1)</code> array containing the lag 0,1,...,p autocovariances of
the process. The subset <code>[, , j]</code> contains the lag <code>j-1</code> autocovariance matrix (lag zero for the variance).</p>
</dd>
<dt><code>$autocors</code></dt><dd><p>the autocovariance matrices scaled to autocorrelation matrices.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other moment functions: 
<code><a href="#topic+cond_moments">cond_moments</a>()</code>,
<code><a href="#topic+get_regime_autocovs">get_regime_autocovs</a>()</code>,
<code><a href="#topic+get_regime_means">get_regime_means</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMVAR(1,2), d=2 model:
params12 &lt;- c(0.55, 0.112, 0.344, 0.055, -0.009, 0.718, 0.319, 0.005,
 0.03, 0.619, 0.173, 0.255, 0.017, -0.136, 0.858, 1.185, -0.012,
 0.136, 0.674)
mod12 &lt;- GSMVAR(gdpdef, p=1, M=2, params=params12)
uncond_moments(mod12)

# Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
 0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
 0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(gdpdef, p=2, M=2, params=params22s, structural_pars=list(W=W_22))
mod22s
uncond_moments(mod22s)
</code></pre>

<hr>
<h2 id='uncond_moments_int'>Calculate the unconditional mean, variance, the first p autocovariances, and the first p autocorrelations
of a GMVAR, StMVAR, or G-StMVAR process</h2><span id='topic+uncond_moments_int'></span>

<h3>Description</h3>

<p><code>uncond_moments_int</code> calculates the unconditional mean, variance, the first p autocovariances,
and the first p autocorrelations of the specified GMVAR, StMVAR, or G-StMVAR process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncond_moments_int(
  p,
  M,
  d,
  params,
  model = c("GMVAR", "StMVAR", "G-StMVAR"),
  parametrization = c("intercept", "mean"),
  constraints = NULL,
  same_means = NULL,
  weight_constraints = NULL,
  structural_pars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncond_moments_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_parametrization">parametrization</code></td>
<td>
<p><code>"intercept"</code> or <code>"mean"</code> determining whether the model is parametrized with intercept
parameters <code class="reqn">\phi_{m,0}</code> or regime means <code class="reqn">\mu_{m}</code>, m=1,...,M.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_constraints">constraints</code></td>
<td>
<p>a size <code class="reqn">(Mpd^2 x q)</code> constraint matrix <strong><code class="reqn">C</code></strong> specifying general linear constraints
to the autoregressive parameters. We consider constraints of form
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) = </code><strong><code class="reqn">C \psi</code></strong>,
where <strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p}) (pd^2 x 1), m=1,...,M</code>,
contains the coefficient matrices and <strong><code class="reqn">\psi</code></strong> <code class="reqn">(q x 1)</code> contains the related parameters.
For example, to restrict the AR-parameters to be the same for all regimes, set <strong><code class="reqn">C</code></strong>=
[<code>I:...:I</code>]<strong>'</strong> <code class="reqn">(Mpd^2 x pd^2)</code> where <code>I = diag(p*d^2)</code>.
Ignore (or set to <code>NULL</code>) if linear constraints should <strong>not</strong> be employed.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_same_means">same_means</code></td>
<td>
<p>Restrict the mean parameters of some regimes to be the same? Provide a list of numeric vectors
such that each numeric vector contains the regimes that should share the common mean parameters. For instance, if
<code>M=3</code>, the argument <code>list(1, 2:3)</code> restricts the mean parameters of the second and third regime to be
the same but the first regime has freely estimated (unconditional) mean. Ignore or set to <code>NULL</code> if mean parameters
should not be restricted to be the same among any regimes. <strong>This constraint is available only for mean parametrized models;
that is, when <code>parametrization="mean"</code>.</strong></p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_weight_constraints">weight_constraints</code></td>
<td>
<p>a numeric vector of length <code class="reqn">M-1</code> specifying fixed parameter values for the mixing weight parameters
<code class="reqn">\alpha_m, \ m=1,...,M-1</code>. Each element should be strictly between zero and one, and the sum of all the elements should
be strictly less than one.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The unconditional moments are based on the stationary distribution of the process.
</p>


<h3>Value</h3>

<p>Returns a list with three components:
</p>

<dl>
<dt><code>$uncond_mean</code></dt><dd><p>a length d vector containing the unconditional mean of the process.</p>
</dd>
<dt><code>$autocovs</code></dt><dd><p>an <code class="reqn">(d x d x p+1)</code> array containing the lag 0,1,...,p autocovariances of
the process. The subset <code>[, , j]</code> contains the lag <code>j-1</code> autocovariance matrix (lag zero for the variance).</p>
</dd>
<dt><code>$autocors</code></dt><dd><p>the autocovariance matrices scaled to autocorrelation matrices.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis,
<em>Springer</em>.
</p>
</li>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>


<hr>
<h2 id='unvec'>Reverse vectorization operator</h2><span id='topic+unvec'></span>

<h3>Description</h3>

<p><code>unvec</code> forms a square matrix from a vector of
stacked columns, stacked by <code>vec</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvec(d, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unvec_+3A_d">d</code></td>
<td>
<p>the number of rows in the square matrix to be formed.</p>
</td></tr>
<tr><td><code id="unvec_+3A_a">a</code></td>
<td>
<p>a size <code class="reqn">(d^2x1)</code> vector to be unvectorized into a <code class="reqn">(dxd)</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of size <code class="reqn">(dxd)</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='unvech'>Reverse operator of the parsimonious vectorization operator <code>vech</code></h2><span id='topic+unvech'></span>

<h3>Description</h3>

<p><code>unvech</code> creates a symmetric matrix from the given vector by
copying the lower triangular part to be the upper triangular part as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unvech(d, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unvech_+3A_d">d</code></td>
<td>
<p>number of rows the square matrix to be formed.</p>
</td></tr>
<tr><td><code id="unvech_+3A_a">a</code></td>
<td>
<p>a size <code class="reqn">(d(d+1)/2x1)</code> vector to be unvectorized into a symmetric <code class="reqn">(dxd)</code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric matrix of size <code class="reqn">(dxd)</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='unWvec'>Reverse vectorization operator that restores zeros</h2><span id='topic+unWvec'></span>

<h3>Description</h3>

<p><code>unWvec</code> forms a square matrix from a vector of
stacked columns where zeros are removed according to structural
parameter constaints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unWvec(Wvector, d, structural_pars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unWvec_+3A_wvector">Wvector</code></td>
<td>
<p>a length <code class="reqn">d^2 - n_zeros</code> vector where <code class="reqn">n_zeros</code> is the
number of zero entries in the matrix <code>W</code>.</p>
</td></tr>
<tr><td><code id="unWvec_+3A_d">d</code></td>
<td>
<p>the number of rows in the square matrix to be formed.</p>
</td></tr>
<tr><td><code id="unWvec_+3A_structural_pars">structural_pars</code></td>
<td>
<p>If <code>NULL</code> a reduced form model is considered. Reduced models can be used directly as recursively
identified structural models. For a structural model identified by conditional heteroskedasticity, should be a list containing
at least the first one of the following elements:
</p>

<ul>
<li> <p><code>W</code> - a <code class="reqn">(dxd)</code> matrix with its entries imposing constraints on <code class="reqn">W</code>: <code>NA</code> indicating that the element is
unconstrained, a positive value indicating strict positive sign constraint, a negative value indicating strict
negative sign constraint, and zero indicating that the element is constrained to zero.
</p>
</li>
<li> <p><code>C_lambda</code> - a <code class="reqn">(d(M-1) x r)</code> constraint matrix that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <strong><code class="reqn">\gamma</code></strong> is the new <code class="reqn">(r x 1)</code>
parameter subject to which the model is estimated (similarly to AR parameter constraints). The entries of <code>C_lambda</code>
must be either <strong>positive</strong> or <strong>zero</strong>. Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code>
should not be constrained.
</p>
</li>
<li> <p><code>fixed_lambdas</code> - a length <code class="reqn">d(M-1)</code> numeric vector (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M})</code> with elements strictly larger than zero specifying the fixed parameter values for the
parameters <code class="reqn">\lambda_{mi}</code> should be constrained to. This constraint is alternative <code>C_lambda</code>.
Ignore (or set to <code>NULL</code>) if the eigenvalues <code class="reqn">\lambda_{mi}</code> should not be constrained.
</p>
</li></ul>

<p>See Virolainen (forthcoming) for the conditions required to identify the shocks and for the B-matrix as well (it is <code class="reqn">W</code> times
a time-varying diagonal matrix with positive diagonal entries).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code class="reqn">(d x d)</code> matrix <code class="reqn">W</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='update_numtols'>Update the stationarity and positive definiteness numerical tolerances of an
existing class 'gsmvar' model.</h2><span id='topic+update_numtols'></span>

<h3>Description</h3>

<p><code>update_numtols</code> updates the stationarity and positive definiteness
numerical tolerances of an existing class 'gsmvar' model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_numtols(gsmvar, stat_tol = 0.001, posdef_tol = 1e-08, df_tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_numtols_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="update_numtols_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="update_numtols_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="update_numtols_+3A_df_tol">df_tol</code></td>
<td>
<p>the parameter vector is considered to be outside the parameter space if all degrees of
freedom parameters are not larger than <code>2 + df_tol</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All signs in any column of <code class="reqn">W</code> can be swapped without changing the implied reduced form model.
Consequently, also the signs in the columns of the B-matrix are swapped. Note that the sign constraints
imposed on <code class="reqn">W</code> (or the B-matrix) are also swapped in the corresponding columns accordingly.
</p>
<p>Also the order of the columns of <code class="reqn">W</code> can be changed (without changing the implied reduced
form model) as long as the order of lambda parameters is also changed accordingly. This can be
done with the function <code>reorder_W_columns</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmvar'</code> defining a structural GSMVAR model with the modified
structural parameters and constraints.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2016. Gaussian mixture vector autoregression.
<em>Journal of Econometrics</em>, <strong>192</strong>, 485-498.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Virolainen S. 2022. Gaussian and Student's t mixture vector autoregressive model with application to the
asymmetric effects of monetary policy shocks in the Euro area. Unpublished working
paper, available as arXiv:2109.13648.
</p>
</li></ul>

<p>@keywords internal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+GIRF">GIRF</a></code>, <code><a href="#topic+reorder_W_columns">reorder_W_columns</a></code>,
<code><a href="#topic+gsmvar_to_sgsmvar">gsmvar_to_sgsmvar</a></code>, <code><a href="#topic+stmvar_to_gstmvar">stmvar_to_gstmvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Structural GMVAR(2, 2), d=2 model identified with sign-constraints:
params22s &lt;- c(0.36, 0.121, 0.484, 0.072, 0.223, 0.059, -0.151, 0.395,
  0.406, -0.005, 0.083, 0.299, 0.218, 0.02, -0.119, 0.722, 0.093, 0.032,
  0.044, 0.191, 0.057, 0.172, -0.46, 0.016, 3.518, 5.154, 0.58)
W_22 &lt;- matrix(c(1, 1, -1, 1), nrow=2, byrow=FALSE)
mod22s &lt;- GSMVAR(p=2, M=2, d=2, params=params22s, structural_pars=list(W=W_22))
mod22s

# Update numerical tolerances:
mod22s &lt;- update_numtols(mod22s, stat_tol=1e-4, posdef_tol=1e-9, df_tol=1e-10)
mod22s # The same model
</code></pre>

<hr>
<h2 id='usamon'>A quarterly U.S. data covering the period from 1954Q3 to 2021Q4 (270 observations) and consisting four variables:
the log-difference of real GDP, the log-difference of GDP implicit price deflator, the log-difference of producer
price index (all commodities), and an interest rate variable. The interest rate variable is the effective federal funds
rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate, which is not constrained by the zero lower
bound and also quantifies unconventional monetary policy measures. The log-differences of the GDP, GDP deflator,
and producer price index are multiplied by hundred. This data is used in Virolainen (forthcoming).</h2><span id='topic+usamon'></span>

<h3>Description</h3>

<p>A quarterly U.S. data covering the period from 1954Q3 to 2021Q4 (270 observations) and consisting four variables:
the log-difference of real GDP, the log-difference of GDP implicit price deflator, the log-difference of producer
price index (all commodities), and an interest rate variable. The interest rate variable is the effective federal funds
rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate, which is not constrained by the zero lower
bound and also quantifies unconventional monetary policy measures. The log-differences of the GDP, GDP deflator,
and producer price index are multiplied by hundred. This data is used in Virolainen (forthcoming).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usamon
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of class <code>'ts'</code> with 270 rows and 4 columns with one time series in each column:
</p>

<dl>
<dt>First column (GDP):</dt><dd><p>The log-difference of real GDP, <a href="https://fred.stlouisfed.org/series/GDPC1">https://fred.stlouisfed.org/series/GDPC1</a>.</p>
</dd>
<dt>Second column (GDPDEF):</dt><dd><p>The log-difference of GDP implicit price deflator, <a href="https://fred.stlouisfed.org/series/GDPDEF">https://fred.stlouisfed.org/series/GDPDEF</a>.</p>
</dd>
<dt>Third column (PPI):</dt><dd><p>The log-difference of producer price index (all commodities), <a href="https://fred.stlouisfed.org/series/PPIACO">https://fred.stlouisfed.org/series/PPIACO</a>.</p>
</dd>
<dt>Third column (RATE):</dt><dd><p>The Federal funds rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate,
<a href="https://fred.stlouisfed.org/series/FEDFUNDS">https://fred.stlouisfed.org/series/FEDFUNDS</a>, <a href="https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate">https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate</a>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Federal Reserve Bank of St. Louis database and the Federal Reserve Bank of Atlanta's website
</p>


<h3>References</h3>


<ul>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Wu J. and Xia F. 2016. Measuring the macroeconomic impact of monetary policy at the zero lower bound.
<em>Journal of Money, Credit and Banking</em>, 48(2-3): 253-291.
</p>
</li></ul>


<hr>
<h2 id='usamone'>A quarterly U.S. data covering the period from 1954Q3 to 2021Q4 (270 observations) and consisting four variables:
cyclical component of the log of real GDP, the log-difference of GDP implicit price deflator, the log-difference of producer
price index (all commodities), and an interest rate variable. The interest rate variable is the effective federal funds
rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate, which is not constrained by the zero lower
bound and also quantifies unconventional monetary policy measures. The log-differences of the GDP deflator and producer price
index are multiplied by hundred.</h2><span id='topic+usamone'></span>

<h3>Description</h3>

<p>The cyclical component of the log of real GDP was obtained by applying a one-sided Hodrick-Prescott (HP) filter with the
standard smoothing parameter lambda=1600. The one-sided filter was obtained from the two-sided HP filter by applying the
filter up to horizon t, taking the last observation, and repeating this procedure for the full sample t=1,...,T.
In order to allow the series to start from any phase of the cycle, we applied the one-sided filter to the full available
sample from 1947Q1 to 2021Q1 before extracting our sample period from it. We computed the two-sided HP filters with the R
package lpirfs (Admmer, 2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usamone
</code></pre>


<h3>Format</h3>

<p>A numeric matrix of class <code>'ts'</code> with 270 rows and 4 columns with one time series in each column:
</p>

<dl>
<dt>First column (GDP):</dt><dd><p>The cyclical component of the log of real GDP, <a href="https://fred.stlouisfed.org/series/GDPC1">https://fred.stlouisfed.org/series/GDPC1</a>.</p>
</dd>
<dt>Second column (GDPDEF):</dt><dd><p>The log-difference of GDP implicit price deflator, <a href="https://fred.stlouisfed.org/series/GDPDEF">https://fred.stlouisfed.org/series/GDPDEF</a>.</p>
</dd>
<dt>Third column (PPI):</dt><dd><p>The log-difference of producer price index (all commodities), <a href="https://fred.stlouisfed.org/series/PPIACO">https://fred.stlouisfed.org/series/PPIACO</a>.</p>
</dd>
<dt>Third column (RATE):</dt><dd><p>The Federal funds rate from 1954Q3 to 2008Q2 and after that the Wu and Xia (2016) shadow rate,
<a href="https://fred.stlouisfed.org/series/FEDFUNDS">https://fred.stlouisfed.org/series/FEDFUNDS</a>, <a href="https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate">https://www.atlantafed.org/cqer/research/wu-xia-shadow-federal-funds-rate</a>.</p>
</dd>
</dl>



<h3>Source</h3>

<p>The Federal Reserve Bank of St. Louis database and the Federal Reserve Bank of Atlanta's website
</p>


<h3>References</h3>


<ul>
<li><p> Admmer P. 2021. lprfs: Local Projections Impulse Response Functions. R package version: 0.2.0,
<a href="https://CRAN.R-project.org/package=lpirfs">https://CRAN.R-project.org/package=lpirfs</a>.
</p>
</li>
<li><p> Virolainen S. (forthcoming). A statistically identified structural vector autoregression with endogenously
switching volatility regime. <em>Journal of Business &amp; Economic Statistics</em>.
</p>
</li>
<li><p> Wu J. and Xia F. 2016. Measuring the macroeconomic impact of monetary policy at the zero lower bound.
<em>Journal of Money, Credit and Banking</em>, 48(2-3): 253-291.
</p>
</li></ul>


<hr>
<h2 id='VAR_pcovmat'>Calculate the dp-dimensional covariance matrix of p consecutive
observations of a VAR process</h2><span id='topic+VAR_pcovmat'></span>

<h3>Description</h3>

<p><code>VAR_pcovmat</code> calculate the dp-dimensional covariance matrix of p consecutive
observations of a VAR process with the algorithm proposed by McElroy (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VAR_pcovmat(p, d, all_Am, Omega_m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VAR_pcovmat_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="VAR_pcovmat_+3A_d">d</code></td>
<td>
<p>the number of time series in the system.</p>
</td></tr>
<tr><td><code id="VAR_pcovmat_+3A_all_am">all_Am</code></td>
<td>
<p><code>[d, d, p]</code> array containing the AR coefficient matrices</p>
</td></tr>
<tr><td><code id="VAR_pcovmat_+3A_omega_m">Omega_m</code></td>
<td>
<p>the dxd error term covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the code in this function is adapted from the one provided in the
supplementary material of McElroy (2017). Reproduced under GNU General
Public License, Copyright (2015) Tucker McElroy.
</p>


<h3>Value</h3>

<p>Returns the (dp x dp) covariance matrix.
</p>


<h3>References</h3>


<ul>
<li><p> McElroy T. 2017. Computation of vector ARMA autocovariances.
<em>Statistics and Probability Letters</em>, <strong>124</strong>, 92-96.
</p>
</li></ul>


<hr>
<h2 id='vec'>Vectorization operator</h2><span id='topic+vec'></span>

<h3>Description</h3>

<p><code>vec</code> stacks columns of the given matrix to form a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_+3A_a">A</code></td>
<td>
<p>a size <code class="reqn">(dxd)</code> square matrix to be vectorized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of size <code class="reqn">(d^2x1)</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='vech'>Parsimonious vectorization operator for symmetric matrices</h2><span id='topic+vech'></span>

<h3>Description</h3>

<p><code>vech</code> stacks columns of the given matrix from
the principal diagonal downwards (including elements on the diagonal) to form a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vech_+3A_a">A</code></td>
<td>
<p>a size <code class="reqn">(dxd)</code> symmetric matrix to be vectorized parsimoniously.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of size <code class="reqn">(d(d+1)/2x1)</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

<hr>
<h2 id='Wald_test'>Perform Wald test for a GMVAR, StMVAR, or G-StMVAR model</h2><span id='topic+Wald_test'></span>

<h3>Description</h3>

<p><code>Wald_test</code> performs a Wald test for a GMVAR, StMVAR, or G-StMVAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wald_test(gsmvar, A, c, custom_h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wald_test_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_a">A</code></td>
<td>
<p>a size <code class="reqn">(k x n_params)</code> matrix with full row rank specifying part of the null hypothesis
where <code class="reqn">n_params</code> is the number of parameters in the (unconstrained) model.
See details for more information.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_c">c</code></td>
<td>
<p>a length <code class="reqn">k</code> vector specifying part of the null hypothesis. See details for more information.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_custom_h">custom_h</code></td>
<td>
<p>a numeric vector with the same length as <code>x</code> specifying the difference <code>h</code>
for each dimension separately. If <code>NULL</code> (default), then the difference <code>1e-6</code> used for
all but overly large degrees of freedom parameters. For them, the difference is adjusted to avoid
numerical problems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denoting the true parameter value by <code class="reqn">\theta_{0}</code>, we test the null hypothesis <code class="reqn">A\theta_{0}=c</code>.
Under the null, the test statistic is asymptotically <code class="reqn">\chi^2</code>-distributed with <code class="reqn">k</code>
(<code>=nrow(A)</code>) degrees of freedom. The parameter <code class="reqn">\theta_{0}</code> is assumed to have the same form as in
the model supplied in the argument <code>gsmvar</code> and it is presented in the documentation of the argument
<code>params</code> in the function <code>GSMVAR</code> (see <code>?GSMVAR</code>).
</p>
<p>Finally, note that this function does <strong>not</strong> check whether the specified constraints are feasible (e.g. whether
the implied constrained model would be stationary or have positive definite error term covariance matrices).
</p>


<h3>Value</h3>

<p>A list with class &quot;hypotest&quot; containing the test results and arguments used to calculate the test.
</p>


<h3>References</h3>


<ul>
<li><p> Buse A. (1982). The Likelihood Ratio, Wald, and Lagrange Multiplier Tests: An Expository Note.
<em>The American Statistician</em>, 36(3a), 153-157.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Rao_test">Rao_test</a></code>, <code><a href="#topic+fitGSMVAR">fitGSMVAR</a></code>, <code><a href="#topic+GSMVAR">GSMVAR</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Structural GMVAR(2, 2), d=2 model with recursive identification
 W22 &lt;- matrix(c(1, NA, 0, 1), nrow=2, byrow=FALSE)
 fit22s &lt;- fitGSMVAR(gdpdef, p=2, M=2, structural_pars=list(W=W22),
                    ncalls=1, seeds=2)
 fit22s

 # Test whether the lambda parameters (of the second regime) are identical
 # (due to the zero constraint, the model is identified under the null):
 # fit22s has parameter vector of length 26 with the lambda parameters
 # in elements 24 and 25.
 A &lt;- matrix(c(rep(0, times=23), 1, -1, 0), nrow=1, ncol=26)
 c &lt;- 0
 Wald_test(fit22s, A=A, c=c)

 # Test whether the off-diagonal elements of the first regime's first
 # AR coefficient matrix (A_11) are both zero:
 # fit22s has parameter vector of length 26 and the off-diagonal elements
 # of the 1st regime's 1st AR coefficient matrix are in the elements 6 and 7.
 A &lt;- rbind(c(rep(0, times=5), 1, rep(0, times=20)),
            c(rep(0, times=6), 1, rep(0, times=19)))
 c &lt;- c(0, 0)
 Wald_test(fit22s, A=A, c=c)

</code></pre>

<hr>
<h2 id='warn_df'>Warn about large degrees of freedom parameter values</h2><span id='topic+warn_df'></span>

<h3>Description</h3>

<p><code>warn_df</code> warns if the model contains large degrees of freedom parameter values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn_df(gsmvar, p, M, params, model = c("GMVAR", "StMVAR", "G-StMVAR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warn_df_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="warn_df_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="warn_df_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMVAR</strong> and <strong>StMVAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMVAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMVAR type</em> components <code>M1</code>
in the first element and <em>StMVAR type</em> components <code>M2</code> in the second element. The total number of mixture components
is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="warn_df_+3A_params">params</code></td>
<td>
<p>a real valued vector specifying the parameter values.
</p>

<dl>
<dt><strong>For unconstrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(pd^2+d+d(d+1)/2+2)-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = </code>(<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{1}</code>,
...,<strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{M}</code>, <code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon</code></strong><code class="reqn">_{m}</code> <code class="reqn"> = (\phi_{m,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn">,\sigma_{m})</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi</code></strong><code class="reqn">_{m}</code><code class="reqn"> = (vec(A_{m,1}),...,vec(A_{m,p})</code>
</p>
</li>
<li><p> and <code class="reqn">\sigma_{m} = vech(\Omega_{m})</code>, m=1,...,M,
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMVAR type regimes.
</p>
</li></ul>

</dd>
<dt><strong>For constrained models:</strong></dt><dd>
<p>Should be size <code class="reqn">((M(d+d(d+1)/2+2)+q-M1-1)x1)</code> and have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where
</p>

<ul>
<li> <p><strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong> where <strong><code class="reqn">C</code></strong> is a <code class="reqn">(Mpd^2xq)</code>
constraint matrix.
</p>
</li></ul>

</dd>
<dt><strong>For same_means models:</strong></dt><dd>
<p>Should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (</code><strong><code class="reqn">\mu</code>,</strong><strong><code class="reqn">\psi</code>,</strong>
<code class="reqn">\sigma_{1},...,\sigma_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>, where
</p>

<ul>
<li> <p><strong><code class="reqn">\mu</code></strong><code class="reqn">= (\mu_{1},...,\mu_{g})</code> where
<code class="reqn">\mu_{i}</code> is the mean parameter for group <code class="reqn">i</code> and
<code class="reqn">g</code> is the number of groups.
</p>
</li>
<li><p> If AR constraints are employed, <strong><code class="reqn">\psi</code></strong> is as for constrained
models, and if AR constraints are not employed, <strong><code class="reqn">\psi</code></strong><code class="reqn"> = </code>
(<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M})</code>.
</p>
</li></ul>

</dd>
<dt><strong>For models with weight_constraints:</strong></dt><dd><p>Drop <code class="reqn">\alpha_1,...,\alpha_{M-1}</code> from
the parameter vector.</p>
</dd>
<dt><strong>For structural models:</strong></dt><dd>
<p>Reduced form models can be directly used as recursively identified structural models. If the structural model is
identified by conditional heteroskedasticity, the parameter vector should have the form
<strong><code class="reqn">\theta</code></strong><code class="reqn"> = (\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{1},...,</code><strong><code class="reqn">\phi</code></strong><code class="reqn">_{M},
      vec(W),</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M},\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong><code class="reqn">)</code>,
where
</p>

<ul>
<li><p><strong><code class="reqn">\lambda</code></strong><code class="reqn">_{m}=(\lambda_{m1},...,\lambda_{md})</code> contains the eigenvalues of the <code class="reqn">m</code>th mixture component.
</p>
</li></ul>


<dl>
<dt><strong>If AR parameters are constrained: </strong></dt><dd><p>Replace <strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\psi</code></strong> <code class="reqn">(qx1)</code> that satisfies (<strong><code class="reqn">\phi</code></strong><code class="reqn">_{1}</code><code class="reqn">,...,</code>
<strong><code class="reqn">\phi</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C \psi</code></strong>, as above.</p>
</dd>
<dt><strong>If same_means: </strong></dt><dd><p>Replace <code class="reqn">(\phi_{1,0},...,\phi_{M,0})</code> with <code class="reqn">(\mu_{1},...,\mu_{g})</code>,
as above.</p>
</dd>
<dt><strong>If <code class="reqn">W</code> is constrained:</strong></dt><dd><p>Remove the zeros from <code class="reqn">vec(W)</code> and make sure the other entries satisfy
the sign constraints.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>C_lambda</code>:</strong></dt><dd><p>Replace <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> with <strong><code class="reqn">\gamma</code></strong> <code class="reqn">(rx1)</code> that satisfies (<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2}</code>
<code class="reqn">,...,</code> <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}) =</code> <strong><code class="reqn">C_{\lambda} \gamma</code></strong> where <code class="reqn">C_{\lambda}</code> is
a <code class="reqn">(d(M-1) x r)</code> constraint matrix.</p>
</dd>
<dt><strong>If <code class="reqn">\lambda_{mi}</code> are constrained via <code>fixed_lambdas</code>:</strong></dt><dd><p>Drop <strong><code class="reqn">\lambda</code></strong><code class="reqn">_{2},...,</code>
<strong><code class="reqn">\lambda</code></strong><code class="reqn">_{M}</code> from the parameter vector.</p>
</dd>
</dl>

</dd>
</dl>

<p>Above, <code class="reqn">\phi_{m,0}</code> is the intercept parameter, <code class="reqn">A_{m,i}</code> denotes the <code class="reqn">i</code>th coefficient matrix of the <code class="reqn">m</code>th
mixture component, <code class="reqn">\Omega_{m}</code> denotes the error term covariance matrix of the <code class="reqn">m</code>:th mixture component, and
<code class="reqn">\alpha_{m}</code> is the mixing weight parameter. The <code class="reqn">W</code> and <code class="reqn">\lambda_{mi}</code> are structural parameters replacing the
error term covariance matrices (see Virolainen, 2022). If <code class="reqn">M=1</code>, <code class="reqn">\alpha_{m}</code> and <code class="reqn">\lambda_{mi}</code> are dropped.
If <code>parametrization=="mean"</code>, just replace each <code class="reqn">\phi_{m,0}</code> with regimewise mean <code class="reqn">\mu_{m}</code>.
<code class="reqn">vec()</code> is vectorization operator that stacks columns of a given matrix into a vector. <code class="reqn">vech()</code> stacks columns
of a given matrix from the principal diagonal downwards (including elements on the diagonal) into a vector.
</p>
<p>In the <strong>GMVAR model</strong>, <code class="reqn">M1=M</code> and <strong><code class="reqn">\nu</code></strong> is dropped from the parameter vector. In the <strong>StMVAR</strong> model,
<code class="reqn">M1=0</code>. In the <strong>G-StMVAR</strong> model, the first <code>M1</code> regimes are <em>GMVAR type</em> and the rest <code>M2</code> regimes are
<em>StMVAR type</em>. In <strong>StMVAR</strong> and <strong>G-StMVAR</strong> models, the degrees of freedom parameters in <strong><code class="reqn">\nu</code></strong> should
be strictly larger than two.
</p>
<p>The notation is similar to the cited literature.</p>
</td></tr>
<tr><td><code id="warn_df_+3A_model">model</code></td>
<td>
<p>is &quot;GMVAR&quot;, &quot;StMVAR&quot;, or &quot;G-StMVAR&quot; model considered? In the G-StMVAR model, the first <code>M1</code> components
are GMVAR type and the rest <code>M2</code> components are StMVAR type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warns if, for some regime, the degrees of freedom parameter value is larger than 100.
</p>


<h3>Value</h3>

<p>Doesn't return anything.
</p>

<hr>
<h2 id='warn_eigens'>Warn about near-unit-roots in some regimes</h2><span id='topic+warn_eigens'></span>

<h3>Description</h3>

<p><code>warn_ar_roots</code> warns if the model contains near-unit-roots in some regimes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn_eigens(gsmvar, stat_tol = 0.0015, posdef_tol = 2e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warn_eigens_+3A_gsmvar">gsmvar</code></td>
<td>
<p>an object of class <code>'gsmvar'</code>, typically created with <code>fitGSMVAR</code> or <code>GSMVAR</code>.</p>
</td></tr>
<tr><td><code id="warn_eigens_+3A_stat_tol">stat_tol</code></td>
<td>
<p>numerical tolerance for stationarity of the AR parameters: if the &quot;bold A&quot; matrix of any regime
has eigenvalues larger that <code>1 - stat_tol</code> the model is classified as non-stationary. Note that if the
tolerance is too small, numerical evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
<tr><td><code id="warn_eigens_+3A_posdef_tol">posdef_tol</code></td>
<td>
<p>numerical tolerance for positive definiteness of the error term covariance matrices: if
the error term covariance matrix of any regime has eigenvalues smaller than this, the model is classified
as not satisfying positive definiteness assumption. Note that if the tolerance is too small, numerical
evaluation of the log-likelihood might fail and cause error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warns if, for some regime, some moduli of &quot;bold A&quot; eigenvalues are larger than <code>1 - stat_tol</code> or
some eigenvalue of the error term covariance matrix is smaller than <code>podef_tol</code>.
</p>


<h3>Value</h3>

<p>Doesn't return anything.
</p>

<hr>
<h2 id='Wvec'>Vectorization operator that removes zeros</h2><span id='topic+Wvec'></span>

<h3>Description</h3>

<p><code>Wvec</code> stacks columns of the given matrix to form a vector
and removes elements that are zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wvec(W)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wvec_+3A_w">W</code></td>
<td>
<p>a size <code class="reqn">(dxd)</code> square matrix to be vectorized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length <code class="reqn">d^2 - n_zeros</code> where <code class="reqn">n_zeros</code> is the
number of zero entries in the matrix <code>W</code>.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
