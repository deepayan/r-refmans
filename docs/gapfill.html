<!DOCTYPE html><html lang="en"><head><title>Help for package gapfill</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gapfill}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gapfill-package'><p>Overview</p></a></li>
<li><a href='#Array2Matrix'><p>Convert an Array with 4 Dimensions into a Matrix</p></a></li>
<li><a href='#ArrayAround'><p>Subset an Array with 4 dimensions</p></a></li>
<li><a href='#EstimateQuantile'><p>Estimate the Quantile of a Missing Value</p></a></li>
<li><a href='#Extend'><p>Implement an Alternative Gap-fill Algorithm</p></a></li>
<li><a href='#Gapfill'><p>Main Function for Gap-Filling</p></a></li>
<li><a href='#Image'><p>Image Panels</p></a></li>
<li><a href='#Index'><p>Index Conversions</p></a></li>
<li><a href='#ndvi'><p>NDVI Data from Alaska</p></a></li>
<li><a href='#Score'><p>Score Columns of a Matrix Containing NAs by its Values</p></a></li>
<li><a href='#Subset-Predict'><p>Subset and Predict Functions</p></a></li>
<li><a href='#Validate'><p>Validation with RMSE</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fill Missing Values in Satellite Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.6-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-11</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Gerber &lt;flora.fauna.gerber@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to fill missing values in satellite data and to develop new
    gap-fill algorithms. The methods are tailored to data (images) observed
    at equally-spaced points in time. The package is illustrated with MODIS
    NDVI data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/florafauna/gapfill">https://github.com/florafauna/gapfill</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/florafauna/gapfill/issues">https://github.com/florafauna/gapfill/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1), ggplot2 (&ge; 2.2.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields, foreach (&ge; 1.4), Rcpp (&ge; 0.12.1), quantreg (&ge; 5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>roxygen2, spam, testthat, abind</td>
</tr>
<tr>
<td>Enhances:</td>
<td>raster, doParallel, doMPI</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-11 17:06:22 UTC; fl</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Gerber <a href="https://orcid.org/0000-0001-8545-5263"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-12 10:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='gapfill-package'>Overview</h2><span id='topic+gapfill-package'></span><span id='topic+Gapfill-Package'></span><span id='topic+Gapfill-package'></span><span id='topic+gapfill-Package'></span>

<h3>Description</h3>

<p>The package provides tools to fill-in missing values in satellite data.
It can be used to gap-fill, e.g., MODIS NDVI data and
is helpful when developing new gap-fill algorithms.
The methods are tailored to data (images) observed at equally-spaced points in time. 
This is typically the case for MODIS land surface products and AVHRR NDVI data, among others. <br />
The predictions of the missing values are based on a subset-predict procedure, i.e.,
each missing value is predicted separately by
(1) selecting subsets of the data that are in a neighborhood around the missing point and
(2) predicting the missing value based on the subset.<br />
The main function of the package is <code><a href="#topic+Gapfill">Gapfill</a></code>.
</p>


<h3>Features</h3>


<ul>
<li><p> Gap-filling can be executed in parallel. 
</p>
</li>
<li><p> Users may define new <code><a href="#topic+Subset">Subset</a></code> and <code><a href="#topic+Predict">Predict</a></code> functions
and run alternative prediction algorithms with little effort.
See <a href="#topic+Extend">Extend</a> for more information and examples.  
</p>
</li>
<li><p> Visualization of space-time data are simplified through the <code>ggplot2</code>-based
function <code><a href="#topic+Image">Image</a></code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>References</h3>

<p>F. Gerber, R. de Jong, M. E. Schaepman, G. Schaepman-Strub, and R. Furrer (2018)
in IEEE Transactions on Geoscience and Remote Sensing, pp. 1-13, doi: <a href="https://doi.org/10.1109/TGRS.2017.2785240">10.1109/TGRS.2017.2785240</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gapfill">Gapfill</a></code>, <code><a href="#topic+Subset-Predict">Subset-Predict</a></code>, <code><a href="#topic+Extend">Extend</a></code>, <code><a href="#topic+Image">Image</a></code>.
</p>

<hr>
<h2 id='Array2Matrix'>Convert an Array with 4 Dimensions into a Matrix</h2><span id='topic+Array2Matrix'></span>

<h3>Description</h3>

<p>Converts the array, <code>a</code>, with 4 dimensions, <code>c(d1, d2, d3, d4)</code>,
into a matrix with <code>d1*d2</code> rows and <code>d3*d4</code> columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Array2Matrix(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Array2Matrix_+3A_a">a</code></td>
<td>
<p>Array with 4 dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix. If <code>a</code> has the attribute <code>mp</code>, the transformed attribute is returned as well.
See <code><a href="#topic+ArrayAround">ArrayAround</a></code> for more information about <code>mp</code>.
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><a href="#topic+Index">Index</a>, <code><a href="#topic+ArrayAround">ArrayAround</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(data = 1:16, dim = c(2, 2, 2, 2))
Array2Matrix(a = a)
attr(a, "mp") &lt;- c(1, 2, 2, 1)
Array2Matrix(a = a)

Array2Matrix(ArrayAround(data = a, mp = c(1, 1, 1, 1),
                         size = c(1, 1, 2, 2))) 
</code></pre>

<hr>
<h2 id='ArrayAround'>Subset an Array with 4 dimensions</h2><span id='topic+ArrayAround'></span><span id='topic+ArrayAroundRandom'></span>

<h3>Description</h3>

<p>Given an array <code>data</code> with 4 dimensions,
a subset around the element with coordinates <code>mp</code> (&quot;missing position&quot;) is extracted.
The size of the subset in all four directions
from <code>mp</code> is specified by <code>size</code>. <br />
<code>ArrayAroundRandom</code> returns a subset around a
random location in <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ArrayAround(data, mp, size)

ArrayAroundRandom(
  data,
  size = c(0L, 0L, 0L, 0L),
  target = c("all", "missing", "observed"),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ArrayAround_+3A_data">data</code></td>
<td>
<p>Array with 4 dimensions.</p>
</td></tr>
<tr><td><code id="ArrayAround_+3A_mp">mp</code></td>
<td>
<p>Integer vector of length 4
indexing an element in <code>data</code>.</p>
</td></tr>
<tr><td><code id="ArrayAround_+3A_size">size</code></td>
<td>
<p>Integer vector of length 4, that provides
the size of the subset in all four dimensions
(around <code>mp</code>).</p>
</td></tr>
<tr><td><code id="ArrayAround_+3A_target">target</code></td>
<td>
<p>One of 
<code>c("all", "missing", "observed")</code>.
Indicates from which subset of <code>data</code> a random
location is sampled.</p>
</td></tr>
<tr><td><code id="ArrayAround_+3A_verbose">verbose</code></td>
<td>
<p>Logical vector of length 1.
If <code>TRUE</code>, messages are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array with 4 dimensions corresponding to the specified subset.
The attribute <code>mp</code> of the returned array is an integer vector
of length 4 giving <code>mp</code> relative to the
returned array.
</p>


<h3>Note</h3>

<p>When <code>size = c(0, 0, 0, 0)</code>, the returned subset consists of one value
(the value of <code>data</code> indexed with <code>mp</code>.) <br />
When <code>mp</code> is near the boundaries of <code>data</code>,
the returned subset may be smaller than indicated by the argument <code>size</code>
and the attribute <code>mp</code> may indicate an element near the boundaries of the subset.
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(1:16, c(2, 2, 2, 2))
ArrayAround(data = a, mp = c(1, 1, 1, 1), size = c(0, 0, 0, 0))
## returns the first element a[1,1,1,1]

ArrayAround(data = a, mp = c(2, 2, 2, 2), size = c(0, 0, 0, 0))
## returns the last element a[2,2,2,2]

ArrayAround(data = a, mp = c(1, 1, 1, 1), size = c(1, 0, 0, 0))
## returns a[1:2,1,1,1]

ArrayAround(data = a, mp = c(1, 1, 1, 1), size = c(1, 1, 1, 1))
## returns a


ArrayAroundRandom(a)
ArrayAroundRandom(a, size = c(1, 2, 1, 2))
</code></pre>

<hr>
<h2 id='EstimateQuantile'>Estimate the Quantile of a Missing Value</h2><span id='topic+EstimateQuantile'></span>

<h3>Description</h3>

<p>Helper function for <code><a href="#topic+Predict">Predict</a></code>.
The function estimates the quantile of the missing value at position <code>mp</code> from the
data <code>a</code> relative to its image a[,,mp[3],mp[4]].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EstimateQuantile(a, mp, nQuant, predictionInterval = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EstimateQuantile_+3A_a">a</code></td>
<td>
<p>Numeric array with 4 dimensions.</p>
</td></tr>
<tr><td><code id="EstimateQuantile_+3A_mp">mp</code></td>
<td>
<p>Integer vector of length 4 indexing the position of the
missing value to predict.</p>
</td></tr>
<tr><td><code id="EstimateQuantile_+3A_nquant">nQuant</code></td>
<td>
<p>Integer vector of length 1. Minimum number of non-missing values in <code>a[mp[1], mp[2],,]</code> required to estimate the quantile.
If <code>a[mp[1], mp[2],,]</code> contains less non-missing values, the neighboring values of <code>a[mp[1], mp[2],,]</code> are also taken into account.</p>
</td></tr>
<tr><td><code id="EstimateQuantile_+3A_predictioninterval">predictionInterval</code></td>
<td>
<p>Logical vector of length 1.
If <code>TRUE</code>, the estimated quantile together with lower and upper bounds of an approximate 90% uncertainty interval
is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>predictionInterval</code> is <code>FALSE</code>, a numeric vector of length 1 being the estimated quantile of the missing value
<code>a[mp[1], mp[2], mp[3], mp[4]]</code> is returned.
Otherwise, a numeric vector of length 3 containing the estimated quantile and the lower and upper bounds of an
approximate 90% uncertainty interval is returned.
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>References</h3>

<p>F. Gerber, R. de Jong, M. E. Schaepman, G. Schaepman-Strub, and R. Furrer (2018)
in IEEE Transactions on Geoscience and Remote Sensing, pp. 1-13, doi: <a href="https://doi.org/10.1109/TGRS.2017.2785240">10.1109/TGRS.2017.2785240</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Predict">Predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- Subset(data = ndvi, mp = c(1, 3, 1, 2), i = 0)
EstimateQuantile(a = a, mp = attr(a, "mp"), nQuant = 2)

</code></pre>

<hr>
<h2 id='Extend'>Implement an Alternative Gap-fill Algorithm</h2><span id='topic+Extend'></span><span id='topic+extend'></span><span id='topic+alternative'></span>

<h3>Description</h3>

<p>By default, the <code><a href="#topic+Gapfill">Gapfill</a></code> function uses the <code><a href="#topic+Subset">Subset</a></code>
and <code><a href="#topic+Predict">Predict</a></code> functions to predict missing values.
To implement alternative gap-fill procedures, these functions can be replaced
by user defined ones and passed to the <code><a href="#topic+Gapfill">Gapfill</a></code> function via the arguments
<code>fnSubset</code> and <code>fnPredict</code>.<br /> 
The example section below gives two such extensions:
</p>
<dl>
<dt>Example 1: </dt><dd><p>Illustration of the concept.
The prediction is the mean of the subset around a missing value.</p>
</dd>
<dt>Example 2: </dt><dd><p>An algorithm using the <code><a href="#topic+Score">Score</a></code> and the <code><a href="stats.html#topic+lm">lm</a></code> functions.</p>
</dd>
</dl>



<h3>Details</h3>

<p>To work properly the user-defined <code>Subset</code> function needs to have the arguments:
</p>
<dl>
<dt><code>data</code>: </dt><dd><p>The input data array.</p>
</dd>
<dt><code>mp</code>: </dt><dd><p>Numeric vector of length 4 specifying the index of the
currently treated missing value.</p>
</dd>
<dt><code>i</code>: </dt><dd><p>Integer vector of length 1. Number of non-successfully tried subsets.</p>
</dd>
</dl>

<p>The function user-defined <code><a href="#topic+Predict">Predict</a></code> function, needs to have the arguments:
</p>

<dl>
<dt><code>a</code>: </dt><dd><p>Return value of the <code>Subset</code> function.</p>
</dd>
<dt><code>i</code>: </dt><dd><p>Integer vector of length 1. Number of non-successfully tried subsets.</p>
</dd>
</dl>

<p>Both functions may take additional arguments.
The default values of these arguments can be changed via
the <code>...</code> arguments of <code><a href="#topic+Gapfill">Gapfill</a></code>.
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>References</h3>

<p>F. Gerber, R. de Jong, M. E. Schaepman, G. Schaepman-Strub, and R. Furrer (2018)
in IEEE Transactions on Geoscience and Remote Sensing, pp. 1-13, doi: <a href="https://doi.org/10.1109/TGRS.2017.2785240">10.1109/TGRS.2017.2785240</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gapfill">Gapfill</a></code>, <code><a href="#topic+Subset-Predict">Subset-Predict</a></code>, <code><a href="#topic+Score">Score</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Example 1: mean ----------------------------------
## define a predict function
PredictMean &lt;- function (a, i) mean(a, na.rm = TRUE)

out1 &lt;- Gapfill(data = ndvi, fnPredict = PredictMean)
Image(out1$fill)

## start with a smaller subset
args(Subset)
out2 &lt;- Gapfill(data = ndvi, fnPredict = PredictMean,
                initialSize = c(0, 0, 1, 6))
Image(out2$fill)

## require at least "nNotNA" non-NA values
## return predicted value and number of iterations i
PredictMean2 &lt;- function (a, i, nNotNA) {
    if (sum(!is.na(a)) &lt; nNotNA)
        return (c(NA, NA))
    c(mean(a, na.rm = TRUE), i)
}
out3 &lt;- Gapfill(data = ndvi, fnPredict = PredictMean2, nPredict = 2,
                initialSize = c(0, 0, 1, 6), nNotNA = 0)
stopifnot(identical(c(out2$fill), c(out3$fill[,,,,1])))
Image(out3$fill[,,,,2])  # number of used iterations i

out4 &lt;- Gapfill(data = ndvi, fnPredict = PredictMean2, nPredict = 2,
                initialSize = c(0, 0, 1, 6), nNotNA = 50)
Image(out4$fill[,,,,1])  # fill values
Image(out4$fill[,,,,2])  # number of used iterations i


## Example 2: Score() and lm() ----------------------
PredictLm &lt;- function (a, i, nNotNA = 50, minScores = 2){
    if (sum(!is.na(a)) &lt; nNotNA)
        return (NA)
    am &lt;- Array2Matrix(a)
    sx &lt;- Score(t(am))
    lsx &lt;- length(sx)
    if (lsx &lt; minScores)
        return (NA)
    sy &lt;- Score(am)
    lsy &lt;- unique(length(sy))
    if (lsy &lt; minScores)
        return (NA)
    df &lt;- data.frame(z = c(am),
                     sx = rep(sx, ncol(am)),
                     sy = rep(sy, each = nrow(am)))
    newdata &lt;- df[IndexTwoOne(attr(am, "mp"), dim(am)),]
    m &lt;- lm(z ~ sx * sy, data = df)
    predict(m, newdata = newdata)
}

## test PredictLm() by running it
## manually for one missing value
mp &lt;- IndexOneFour(which(is.na(ndvi))[1], dim(ndvi))
a &lt;- Subset(data = ndvi, mp = mp, i = 0)
PredictLm(a = a, i = 0)

## run PredictLm() on ndvi data
out5 &lt;- Gapfill(data = ndvi, fnPredict = PredictLm,
                nNotNA = 50)
Image(out5$fill)

## End(Not run)
</code></pre>

<hr>
<h2 id='Gapfill'>Main Function for Gap-Filling</h2><span id='topic+Gapfill'></span><span id='topic+gapfill'></span><span id='topic+gap-fill'></span><span id='topic+Gap-fill'></span>

<h3>Description</h3>

<p>The function fills (predicts) missing values in satellite data.
We illustrate it with MODIS NDVI data,
but it can also be applied to other data, that is recorded at equally spaced points in time.
Moreover, the function provides infrastructure for the development of new gap-fill algorithms.
The predictions of the missing values are based on a subset-predict procedure, i.e.,
each missing value is predicted separately by
(1) selecting a subset of the data to a neighborhood around the missing value and
(2) predicting the values based on that subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gapfill(
  data,
  fnSubset = Subset,
  fnPredict = Predict,
  iMax = Inf,
  nPredict = 1L,
  subset = "missing",
  clipRange = c(-Inf, Inf),
  dopar = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Gapfill_+3A_data">data</code></td>
<td>
<p>Numeric array with four dimensions. The input (satellite) data to be gap-filled.
Missing values should be encoded as <code>NA</code>. When using the default <code><a href="#topic+Subset">Subset</a></code> and <code><a href="#topic+Predict">Predict</a></code>
functions, the data should have the dimensions: x coordinate, y coordinate, seasonal index (e.g., day of the year), and year.
See the <code><a href="#topic+ndvi">ndvi</a></code> dataset for an example.</p>
</td></tr>
<tr><td><code id="Gapfill_+3A_fnsubset">fnSubset</code></td>
<td>
<p>Function to subset the <code>data</code> around a missing value.
See <code><a href="#topic+Subset">Subset</a></code> and <a href="#topic+Extend">Extend</a> for more information.</p>
</td></tr>
<tr><td><code id="Gapfill_+3A_fnpredict">fnPredict</code></td>
<td>
<p>Function to predict a missing value based on the return value of <code>fnSubset</code>.
See <code><a href="#topic+Predict">Predict</a></code> and <a href="#topic+Extend">Extend</a> for more information.</p>
</td></tr>
<tr><td><code id="Gapfill_+3A_imax">iMax</code></td>
<td>
<p>Integer vector of length 1.
The maximum number of iterations until <code>NA</code> is returned as predicted value.</p>
</td></tr>
<tr><td><code id="Gapfill_+3A_npredict">nPredict</code></td>
<td>
<p>Integer vector of length 1. Specifies the length of the vector returned from <code>fnPredict</code>.
Values larger than 1 may increase memory usage considerably.</p>
</td></tr>
<tr><td><code id="Gapfill_+3A_subset">subset</code></td>
<td>
<p>If <code>"missing"</code> (default), all missing values of <code>data</code> are replaced by predictions. 
If <code>"observed"</code>, all observed values of <code>data</code> are replaced by predictions.
If a logical array of dimension <code>dim(data)</code> or 
a vector with positive integers, the elements <code>data[subset]</code> are replaced by predictions.
Note that independently of the specified subset all provided values in <code>data</code> are used to inform the predictions.</p>
</td></tr>
<tr><td><code id="Gapfill_+3A_cliprange">clipRange</code></td>
<td>
<p>Numeric vector of length 2.
Specifies the lower and the upper bound of the filled data.
Values outside this range are clipped accordingly.
If <code>nPredict</code> is larger than 2, only the first return value of <code>fnPredict</code> will be clipped.</p>
</td></tr>
<tr><td><code id="Gapfill_+3A_dopar">dopar</code></td>
<td>
<p>Logical vector of length 1.
If <code>TRUE</code>, the <code>%dopar%</code> construct from the R package foreach is used.
This allows the function to predict several missing values in parallel,
if a parallel back-end (e.g., from the R package doParallel or doMpi) is available.
See the example below and <code><a href="foreach.html#topic+foreach">foreach</a></code> for more information.</p>
</td></tr>
<tr><td><code id="Gapfill_+3A_verbose">verbose</code></td>
<td>
<p>Logical vector of length 1.
If <code>TRUE</code> (default), messages are printed.</p>
</td></tr>
<tr><td><code id="Gapfill_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>fnSubset</code> and <code>fnPredict</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predictions of the missing values are based on a subset-predict procedure, i.e.,
each missing value is predicted separately by
(1) selecting a subset of the data to a
neighborhood around it and (2) predicting the values based on
that subset. The following gives more information on this subset-predict strategy.<br />
Missing values are often unevenly distributed in <code>data</code>.
Therefore, the size of a reasonable subset may be different depending on the position of the considered missing value.  
The search strategy to find that subset is encoded in <code>fnSubset</code>.
The function returns different subsets depending on the argument <code>i</code>.
The decision whether a subset is suitable and the prediction itself is
implemented in <code>fnPredict</code>.
To be more specific, the subset-predict procedure loops over the following two steps to predict one missing value:
</p>

<dl>
<dt>(1) </dt><dd><p>The function <code>fnSubset</code> is provided with the argument <code>i = i</code> (where <code>i &lt;- 0</code> in the first iteration) and
returns a subset around the missing value.</p>
</dd>
<dt>(2) </dt><dd><p>The function <code>fnPredict</code> decides whether the subset contains enough information to predict the missing value.
If so, the predicted value is returned.
Otherwise, the function returns <code>NA</code> and the algorithm increases <code>i</code> by one (<code>i &lt;- i + 1</code>)
before continuing with step (1).</p>
</dd>
</dl>

<p>The procedure stops if one of the following criteria is met:
</p>

<ul>
<li> <p><code>fnPredict</code> returns a non-<code>NA</code> value,
</p>
</li>
<li> <p><code>iMax</code> tries have been completed,
</p>
</li>
<li> <p><code>fnSubset</code> returns the same subset two times in a row. 
</p>
</li></ul>



<h3>Value</h3>

<p>List of length 4 with the entries:
</p>

<ul>
<li><p><code>fill</code> contains the gap-filled data.
If <code>nPredict = 1</code>, <code>fill</code> is an array of dimension <code>dim(data)</code>,
otherwise the array is of dimension <code>c(dim(data), nPredict)</code>.
</p>
</li>
<li><p><code>mps</code> integer vector of length equaling the number of predicted values.
Contains the (1 dimensional) indices of the predicted values.
</p>
</li>
<li><p><code>time</code> list of length 4 containing timing information.
</p>
<ul>
<li><p><code>start</code> start date and time.
</p>
</li>
<li><p><code>end</code> end date and time.
</p>
</li>
<li><p><code>elapsedMins</code> elapsed minutes.
</p>
</li>
<li><p><code>elapsedSecsPerNA</code> elapsed seconds per predicted value.
</p>
</li></ul>


</li>
<li><p><code>call</code> call used to produce the object.
</p>
</li></ul>



<h3>Note</h3>

<p>The default <code><a href="#topic+Predict">Predict</a></code> function implements the prediction of the missing value
and can also return lower and upper bounds of an approximated 90% prediction interval.
See the help page of <code><a href="#topic+Predict">Predict</a></code> for more information on the prediction interval.
The example section below shows how the prediction interval can be calculated and displayed.  
</p>
<p>To tailor the procedure to a specific dataset, it might be necessary to
adapt the subset and/or the prediction strategy.
On the one hand, this can be done by changing the default arguments of <code><a href="#topic+Subset">Subset</a></code> and
<code><a href="#topic+Predict">Predict</a></code> through the argument <code>...</code> of <code>Gapfill</code>.
See the help of the corresponding functions for more information about their arguments.
On the other hand, the user can define a new subset and predict functions, and pass them to <code>Gapfill</code>
through the arguments <code>fnSubset</code> and <code>fnPredict</code>.
See <a href="#topic+Extend">Extend</a> for more information. 
</p>
<p>The current implementation of <code><a href="#topic+Subset">Subset</a></code> does not take into account
that values at the boundaries of <code>data</code> can be neighboring to each other.
For example, if global data (entire sphere) are considered,
<code>data[1,1,,]</code> is a neighbor of <code>data[dim(data)[1], dim(data)[2],,]</code>.
Similar considerations apply when data are available for an entire year. 
To take this into account, the <code>Subset</code> function can be redefined accordingly or
the data can be augmented.
</p>
<p>There are two strategies to run the gap-filling in parallel.
The first one is to set the argument <code>dopar</code> of <code>Gapfill</code> to <code>TRUE</code> and
to use an openMP or MPI parallel back-end.
The parallel back-end needs to be setup before the call to <code>Gapfill</code>.
An example using the R package <code>doParallel</code> is given below.
Note that there exist other parallel back-ends implemented in other packages; such as, e.g., the package <code>doMpi</code>.
Some parallel back-ends are platform dependent. 
While this approach shortens the process time by distributing the computational workload,
it does not reduce the memory footprint of the procedure.
The second strategy, which also reduces memory usage, is to split the <code>data</code> into several independent chunks.
Whether data chunks are independent or not depends on the function provided to <code>fnSubset</code>. 
For example, the default <code><a href="#topic+Subset">Subset</a></code> function never includes data that
is further apart from the missing value than 1 seasonal index.
Hence, <code>data[,,1:3,]</code> can be used to gap-fill <code>data[,,2,]</code>.<br />
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>References</h3>

<p>F. Gerber, R. de Jong, M. E. Schaepman, G. Schaepman-Strub, and R. Furrer (2018)
in IEEE Transactions on Geoscience and Remote Sensing, pp. 1-13, doi: <a href="https://doi.org/10.1109/TGRS.2017.2785240">10.1109/TGRS.2017.2785240</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Extend">Extend</a></code>, <code><a href="#topic+Subset-Predict">Subset-Predict</a></code>, <code><a href="#topic+Image">Image</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out &lt;- Gapfill(ndvi, clipRange = c(0, 1))

## look at input and output
str(ndvi)
str(out)
Image(ndvi)
Image(out$fill)

## run on 2 cores in parallel
if(require(doParallel)){
  registerDoParallel(2)
  out &lt;- Gapfill(ndvi, dopar = TRUE)
}

## return also the prediction interval
out &lt;- Gapfill(ndvi, nPredict = 3, predictionInterval = TRUE)

## dimension has changed according to 'nPredict = 3'
dim(out$fill)

## clip values outside the valid parameter space [0,1].
out$fill[out$fill &lt; 0] &lt;- 0
out$fill[out$fill &gt; 1] &lt;- 1

## images of the output:
## predicted NDVI
Image(out$fill[,,,,1])
## lower bound of the prediction interval
Image(out$fill[,,,,2])
## upper bound of the prediction interval
Image(out$fill[,,,,3])
## prediction interval length
Image(out$fill[,,,,3] - out$fill[,,,,2])


## End(Not run)
</code></pre>

<hr>
<h2 id='Image'>Image Panels</h2><span id='topic+Image'></span>

<h3>Description</h3>

<p>Creates an image panel to visualize data in 4, 3 or 2 dimensional arrays (e.g., space-time data). 
The function returns a <code>ggplot2</code> object, which 
can be modified using ggplot2 (and/or grid) syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Image(
  x = NULL,
  zlim = range(x, na.rm = TRUE),
  col = fields::tim.colors(1000),
  theme = TRUE,
  guides = TRUE,
  na.value = "black",
  panelsByrow = TRUE,
  asRaster = TRUE,
  xlab = "",
  ylab = "",
  colbarTitle = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Image_+3A_x">x</code></td>
<td>
<p>Numeric array with 4, 3, or 2 dimensions
containing the data to be plotted.</p>
</td></tr>
<tr><td><code id="Image_+3A_zlim">zlim</code></td>
<td>
<p>Numeric vector of length 2.
Gives the upper and lower bound of the plotted values.</p>
</td></tr>
<tr><td><code id="Image_+3A_col">col</code></td>
<td>
<p>Vector of colors.</p>
</td></tr>
<tr><td><code id="Image_+3A_theme">theme</code></td>
<td>
<p>Logical vector of length one.
Should the ggplot2 theme be modified?</p>
</td></tr>
<tr><td><code id="Image_+3A_guides">guides</code></td>
<td>
<p>Logical vector of length one.
Should ggplot2 guides be modified?</p>
</td></tr>
<tr><td><code id="Image_+3A_na.value">na.value</code></td>
<td>
<p>Vector of length one.
The color to be used for NA values.</p>
</td></tr>
<tr><td><code id="Image_+3A_panelsbyrow">panelsByrow</code></td>
<td>
<p>Logical vector of length one.
Indicates the ordering of the panels.</p>
</td></tr>
<tr><td><code id="Image_+3A_asraster">asRaster</code></td>
<td>
<p>Logical vector of length one.
If <code>TRUE</code>, the ordering of the pixel within images is similar to the plot method of the raster package.
Otherwise, the ordering is similar to <code><a href="graphics.html#topic+image">image</a></code>.</p>
</td></tr>
<tr><td><code id="Image_+3A_xlab">xlab</code></td>
<td>
<p>Character vector (or expression) of length one giving the x-axis label.</p>
</td></tr>
<tr><td><code id="Image_+3A_ylab">ylab</code></td>
<td>
<p>Character vector (or expression) of length one giving the y-axis label.</p>
</td></tr>
<tr><td><code id="Image_+3A_colbartitle">colbarTitle</code></td>
<td>
<p>Character vector (or expression) of length one giving the colorbar label.</p>
</td></tr>
<tr><td><code id="Image_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code>ggplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object (plot) of class <code>c("gg", "ggplot2")</code>.
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ndvi">ndvi</a></code>, <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("abind")
t1 &lt;- array(rep(c(1,0), each = 5), c(5,5))
t1[5,3] &lt;- 2 
t2 &lt;- abind(t1, t1, along = 3)
t3 &lt;- abind(t2, t2, along = 4)
Image(t1)
Image(t2)
Image(t3)

## Not run: 
Image(ndvi)

p1 &lt;- Image(ndvi, colbarTitle = "NDVI", xlab = "Year", ylab = "DOY",
            panelsByrow  = FALSE)
p1

p2 &lt;- Image(ndvi[,,3,2], na.value = "white", colbarTitle = "NDVI") +
      theme(strip.text.x = element_blank(),
            strip.text.y = element_blank(),
            panel.border = element_rect(fill = NA, size = 1))
p2

## place modified color bar left
p2 + guides(fill = guide_colorbar(title = "NDVI", 
                                  barwidth = 1,
                                  barheight = 20,
                                  label.position = "right", 
                                  legend.position = c(0, 0))) +
     theme(legend.position = "right")

## place color bar at bottom
p2 + guides(fill = guide_colorbar(title = "NDVI", 
                                  barwidth = 7,
                                  barheight = .7,
                                  label.position = "bottom", 
                                  legend.position = c(0, 0)),
                                  direction = "horizontal") +
     theme(legend.position = "bottom")

## End(Not run)
</code></pre>

<hr>
<h2 id='Index'>Index Conversions</h2><span id='topic+Index'></span><span id='topic+IndexTwoOne'></span><span id='topic+IndexOneFour'></span>

<h3>Description</h3>

<p>Converts an index from the first length to the second length.
For example, assume that <code>c(2, 2)</code> indexes an element in a matrix with 2 rows and 5 columns.
If the matrix is transformed to a vector,
the same element can be accessed with the index <code>IndexTwoOne(c(2, 2), c(2, 5))</code> (=4).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndexTwoOne(index, dimTwo)

IndexOneFour(index, dimFour)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Index_+3A_index">index</code></td>
<td>
<p>Integer vector of length 2 for
<code>IndexTwoOne()</code> and length 1 for <code>IndexOneFour()</code>.</p>
</td></tr>
<tr><td><code id="Index_+3A_dimtwo">dimTwo</code></td>
<td>
<p>Integer vector of length 2
indicating the dimension of the 2 dimensional array.</p>
</td></tr>
<tr><td><code id="Index_+3A_dimfour">dimFour</code></td>
<td>
<p>Integer vector of length 4
indicating the dimension of the 4 dimensional array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length 1 for <code>IndexTwoOne()</code> and
length 4 for <code>IndexOneFour()</code>.
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## IndexTwoOne
IndexTwoOne(c(2, 2), c(2, 5))
v &lt;- 1:10
dimTwo &lt;- c(2, 5)
m &lt;- array(v, dimTwo)
stopifnot(v[IndexTwoOne(c(2, 2), dimTwo)] == m[2,2])

 
## IndexOneFour
IndexOneFour(13, c(2, 2, 2, 2))
w &lt;- 1:16
dimFour &lt;- c(2, 2, 2, 2)
a &lt;- array(w, dimFour)
stopifnot(a[1,1,2,2] == w[13])

</code></pre>

<hr>
<h2 id='ndvi'>NDVI Data from Alaska</h2><span id='topic+ndvi'></span>

<h3>Description</h3>

<p>The dataset was created to test gap-fill algorithms.
It mimics a subset of the MODIS NDVI data (product MOD13A1) in the region of Alaska.
The data product features one image per 16-day time interval, i.e., 24 images per year.  
The indicated images (see <code>Image(ndvi)</code>) were downloaded and stored as a 4 dimensional array.
Its dimensions correspond to longitude, latitude, day of the year, and year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndvi
</code></pre>


<h3>Format</h3>

<p>Numeric array with 4 dimensions. As indicated by the dimnames of the array:
</p>

<ul>
<li><p>dim 1: longitude,
</p>
</li>
<li><p>dim 2: latitude,
</p>
</li>
<li><p>dim 3: day of the year,
</p>
</li>
<li><p>dim 4: year.
</p>
</li></ul>

<p>The values are NDVI values, and hence, between 0 and 1. Missing values are encoded as <code>NA</code>.
</p>


<h3>Source</h3>

<p>The actual MOD13A data product is available from NASA EOSDIS Land Processes DAAC,
USGS Earth Resources Observation and Science (EROS) Center, Sioux Falls, South Dakota <a href="https://lpdaac.usgs.gov">https://lpdaac.usgs.gov</a>.
MODIS data can be downloaded with the R package MODIS <a href="https://r-forge.r-project.org/projects/modis/">https://r-forge.r-project.org/projects/modis/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(ndvi)
Image(ndvi)
</code></pre>

<hr>
<h2 id='Score'>Score Columns of a Matrix Containing NAs by its Values</h2><span id='topic+Score'></span>

<h3>Description</h3>

<p>Helper function for <code><a href="#topic+Predict">Predict</a></code> used to
score the columns of a matrix according to their values.  
The scoring of a given column is done by pair-wise comparisons with all other columns.
The comparison of columns is done by pair-wise comparisons of the non-missing values.
This procedure is robust to missing values, if all columns of the matrix
have a similar (potentially shifted) distribution of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Score(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Score_+3A_mat">mat</code></td>
<td>
<p>Numeric matrix. May contain <code>NA</code> values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of length <code>ncol(mat)</code>.
</p>


<h3>Note</h3>

<p>Interfaces a C++ function. The R package Rcpp is used.
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>References</h3>

<p>F. Gerber, R. de Jong, M. E. Schaepman, G. Schaepman-Strub, and R. Furrer (2018)
in IEEE Transactions on Geoscience and Remote Sensing, pp. 1-13, doi: <a href="https://doi.org/10.1109/TGRS.2017.2785240">10.1109/TGRS.2017.2785240</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- rbind(c( 1,  2, NA),
             c(NA, NA,  1),
             c( 2, NA,  3),
             c( 1,  5, NA),
             c(NA,  2,  5))
s &lt;- Score(mat)

## manual calculation in R
Mean &lt;- function(x) mean(x, na.rm = TRUE)
sByHand &lt;- c(Mean(c(Mean(mat[,1] &gt; mat[,2]),
                    Mean(mat[,1] &gt; mat[,3]))),
             Mean(c(Mean(mat[,2] &gt; mat[,1]),
                    Mean(mat[,2] &gt; mat[,3]))),
             Mean(c(Mean(mat[,3] &gt; mat[,1]),
                    Mean(mat[,3] &gt; mat[,2]))))
stopifnot(identical(s, sByHand))

</code></pre>

<hr>
<h2 id='Subset-Predict'>Subset and Predict Functions</h2><span id='topic+Subset-Predict'></span><span id='topic+Subset'></span><span id='topic+Predict'></span><span id='topic+fnSubset'></span><span id='topic+fnPredict'></span>

<h3>Description</h3>

<p>The <code>Subset</code> and <code>Predict</code> function used in the default configuration of <code><a href="#topic+Gapfill">Gapfill</a></code>.
To predict a missing value, the two function are called sequentially as described the help page of <code><a href="#topic+Gapfill">Gapfill</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Subset(data, mp, i, initialSize = c(10L, 10L, 1L, 5L))

Predict(
  a,
  i,
  nTargetImage = 5,
  nImages = 4,
  nQuant = 2,
  predictionInterval = FALSE,
  qrErrorToNA = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Subset-Predict_+3A_data">data</code></td>
<td>
<p>Numeric array with four dimensions. The input (satellite) data to be gap-filled.
Missing values should be encoded as <code>NA</code>.
The data should have the dimensions: x coordinate, y coordinate, seasonal index (e.g., day of the year), and year.
See the <code>ndvi</code> dataset for an example.</p>
</td></tr>
<tr><td><code id="Subset-Predict_+3A_mp">mp</code></td>
<td>
<p>Integer vector of length 4 encoding the position of the missing value in <code>data</code> to predict.</p>
</td></tr>
<tr><td><code id="Subset-Predict_+3A_i">i</code></td>
<td>
<p>Integer vector of length 1. The number of tried subsets that lead to a <code>NA</code> return value from <code>Predict</code>.</p>
</td></tr>
<tr><td><code id="Subset-Predict_+3A_initialsize">initialSize</code></td>
<td>
<p>Integer vector of length 4, that provides the size of the subset for <code>i = 0</code>.</p>
</td></tr>
<tr><td><code id="Subset-Predict_+3A_a">a</code></td>
<td>
<p>Return value of <code>Subset()</code>.</p>
</td></tr>
<tr><td><code id="Subset-Predict_+3A_ntargetimage">nTargetImage</code></td>
<td>
<p>Integer vector of length 1. Minimum number of non-NA values in the image containing the missing value.
If the criterion is not met, <code>NA</code> is returned.</p>
</td></tr>
<tr><td><code id="Subset-Predict_+3A_nimages">nImages</code></td>
<td>
<p>Integer vector of length 1. Minimum number of non-empty images.
If the criterion is not met, <code>NA</code> is returned.</p>
</td></tr>
<tr><td><code id="Subset-Predict_+3A_nquant">nQuant</code></td>
<td>
<p>Integer vector of length 1. Parameter passed to <code><a href="#topic+EstimateQuantile">EstimateQuantile</a></code>.</p>
</td></tr>
<tr><td><code id="Subset-Predict_+3A_predictioninterval">predictionInterval</code></td>
<td>
<p>Logical vector of length 1.
If <code>FALSE</code> (default), no prediction interval is returned.
If <code>TRUE</code>, the predicted value together with the lower and upper bounds
of an approximated 90% prediction interval are returned.
In that case, the function returns 3 values, and hence,
the argument <code>nPredict</code> of <code><a href="#topic+gapfill">gapfill</a></code> has to be set to 3 in order to store all returned values.</p>
</td></tr>
<tr><td><code id="Subset-Predict_+3A_qrerrortona">qrErrorToNA</code></td>
<td>
<p>Logical vector of length 1.
If <code>TRUE</code> (default), an error in the quentile regression fitting leads to a <code>NA</code> return value.
If <code>FALSE</code>, an error in the quentile regression fitting leads to an error and stops the prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Subset</code> function defines the search strategy to find a
relevant subset by calling the function <code><a href="#topic+ArrayAround">ArrayAround</a></code>.
The size of the initial subset is given by the argument <code>initialSize</code>.
Its default values is <code>c(5L, 5L, 1L, 5L)</code>, which corresponds to a spatial extend of 5 pixels
in each direction from the missing value and includes time points having the previous, the same or the next seasonal index and
are not further apart than 5 years.
With an increase of the argument <code>i</code>, the spatial extent of the subset increases.
</p>
<p>The <code>Predict</code> function decides whether the subset <code>a</code> is suitable and
calculates the prediction (fill value) when a suitable subset is provided.
To formulate the conditions that are used to decide if a subset is suitable,
consider the subset <code>a</code> as a collection of images.
More precisely, if <code>dim(a)</code> <code>=</code> <code>c(d1, d2, d3, d4)</code>,
it can be seen as a collection of <code>d3*d4</code> images with an extent of <code>d1</code> by <code>d2</code> pixels.    
Using this terminology, we require the following conditions to be fulfilled
in order to predict the missing value:
</p>

<ul>
<li> <p><code>a</code> contains at least <code>nTargetImage</code> non-NA values in the image containing the missing value,
</p>
</li>
<li> <p><code>a</code> contains at least <code>nImages</code> non-empty images.
</p>
</li></ul>

<p>The prediction itself is based on sorting procedures (see <code><a href="#topic+Score">Score</a></code> and
<code><a href="#topic+EstimateQuantile">EstimateQuantile</a></code>) and the quantile regression function <code><a href="quantreg.html#topic+rq">rq</a></code>.
</p>
<p>If the argument <code>predictionInterval</code> is <code>TRUE</code> the <code>Predict</code> functions returns
the predicted value together with the lower and upper bounds of an approximated 90% prediction interval.
The interval combines the uncertainties introduced by <code><a href="#topic+Score">Score</a></code>
and <code><a href="#topic+EstimateQuantile">EstimateQuantile</a></code>.
</p>


<h3>Value</h3>

<p><code>Subset</code> returns an array with 4 dimensions containing the missing value
at the position indicated by the attribute <code>mp</code>.
</p>
<p><code>Predict</code> returns a numeric vector containing the predicted value
(and if <code>predictionInterval</code> is <code>TRUE</code>, the lower and upper bounds of the prediction interval),
or <code>NA</code>, if no prediction was feasible.
</p>


<h3>Note</h3>

<p>The current implementation of <code>Subset</code> does not take into account
that locations at the boundary of <code>data</code> can be neighboring to each other.
For example, if global data (entire sphere) are considered, the location
<code>data[1,1,,]</code> is a neighbor of <code>data[dim(data)[1], dim(data)[2],,]</code>.
Similar considerations apply when data are available for an entire year. 
To take this into account, the <code>Subset</code> function can be redefined accordingly or
the data can be augmented.
</p>


<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>References</h3>

<p>F. Gerber, R. de Jong, M. E. Schaepman, G. Schaepman-Strub, and R. Furrer (2018)
in IEEE Transactions on Geoscience and Remote Sensing, pp. 1-13, doi: <a href="https://doi.org/10.1109/TGRS.2017.2785240">10.1109/TGRS.2017.2785240</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Gapfill">Gapfill</a></code>, <code><a href="#topic+Extend">Extend</a></code>,
<code><a href="#topic+EstimateQuantile">EstimateQuantile</a></code>, <code><a href="#topic+Score">Score</a></code>, <code><a href="#topic+ndvi">ndvi</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Assume we choose c(5, 5, 1, 5) as initalSize of the subset
iS &lt;- c(5, 5, 1, 5)
## case 1: initial subset leads to prediction -------
i &lt;- 0
a &lt;- Subset(data = ndvi, mp = c(1, 3, 1, 2), i = i, initialSize = iS)
p &lt;- Predict(a = a, i = i)
p
stopifnot(identical(a, ArrayAround(data = ndvi, mp = c(1, 3, 1, 2),
                                   size = c(5 + i, 5 + i, 1, 5))))
stopifnot(identical(p, Gapfill(data = ndvi, subset = 1807,
                               initialSize = iS, verbose = FALSE)$fill[1807]))

## case 2: two tries are necessary ------------------
i &lt;- 0
a &lt;- Subset(data = ndvi, mp = c(20, 1, 1, 2), i = i, initialSize = iS)
p &lt;- Predict(a = a, i = i)
p

## Increase i and try again.
i &lt;- i + 1
a &lt;- Subset(data = ndvi, mp = c(20, 1, 1, 2), i = i, initialSize = iS)
p &lt;- Predict(a = a, i = i)
p
stopifnot(identical(a, ArrayAround(data = ndvi, mp = c(20, 1, 1, 2),
                                   size = c(5 + i, 5 + i, 1, 6))))
stopifnot(identical(p, Gapfill(data = ndvi, subset = 1784,
                               initialSize = iS, verbose = FALSE)$fill[1784]))
</code></pre>

<hr>
<h2 id='Validate'>Validation with RMSE</h2><span id='topic+Validate'></span><span id='topic+validate'></span>

<h3>Description</h3>

<p>The function summarizes the validation scenario and
returns the root mean squared error (RMSE) of the predictions.
The typical validation procedure is: start with the <code>trueData</code>.
Remove some validation points to obtain artificially generated <code>dataObserved</code>.
Predicting the validation points based on <code>dataObserved</code> leads to <code>dataFilled</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Validate(
  dataObserved,
  dataFilled,
  dataTrue,
  include = rep(TRUE, length(dataObserved))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Validate_+3A_dataobserved">dataObserved</code></td>
<td>
<p>Numeric vector containing the observed data.</p>
</td></tr>
<tr><td><code id="Validate_+3A_datafilled">dataFilled</code></td>
<td>
<p>Numeric vector containing the filled (predicted) data.
Needs to have the same length as <code>dataObserved</code>.</p>
</td></tr>
<tr><td><code id="Validate_+3A_datatrue">dataTrue</code></td>
<td>
<p>Numeric vector containing the true data.
Needs to have the same length as <code>dataObserved</code>.</p>
</td></tr>
<tr><td><code id="Validate_+3A_include">include</code></td>
<td>
<p>Logical vector indicating which element to include in the
calculation of the RMSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix with one 1 row and 6 columns having the entries:
</p>

<ul>
<li> <p><code>nNA</code>: number of missing values in <code>dataObserved</code>,
</p>
</li>
<li> <p><code>nFilled</code>: number of predicted values,
</p>
</li>
<li> <p><code>nNotFilled</code>: number of not predicted missing values,
</p>
</li>
<li> <p><code>ratioFilled</code>: ratio: <code>nFilled</code> / <code>nNA</code>,
</p>
</li>
<li> <p><code>nCrossvali</code>: number of values for validation,
</p>
</li>
<li> <p><code>RMSE</code>: root mean squared error.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Florian Gerber, <a href="mailto:flora.fauna.gerber@gmail.com">flora.fauna.gerber@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Validate(c(1, NA, 2, NA), c(1, 2, 2, NA), c(1, 1, 2, 2))

## validate gap-fill predictions: consider the ndvi data
Image(ndvi)

## define some validation points vp
## in the image of the day 145 of the year 2004
vp &lt;- 300 + c(5:10) + rep(21 * c(0:5), each = 6)

## remove the vp values from the data
nn &lt;- ndvi
nn[vp] &lt;- NA
Image(nn)

## predict the vp values 
out &lt;- Gapfill(nn, subset = vp)
Validate(dataObserved = nn, dataFilled = out$fill,
         dataTrue = ndvi)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
