<!DOCTYPE html><html><head><title>Help for package TDA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TDA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#TDA-package'>
<p>Statistical Tools for Topological Data Analysis</p></a></li>
<li><a href='#alphaComplexDiag'>
<p>Alpha Complex Persistence Diagram</p></a></li>
<li><a href='#alphaComplexFiltration'>
<p>Alpha Complex Filtration</p></a></li>
<li><a href='#alphaShapeDiag'>
<p>Persistence Diagram of Alpha Shape in 3d</p></a></li>
<li><a href='#alphaShapeFiltration'>
<p>Alpha Shape Filtration in 3d</p></a></li>
<li><a href='#bootstrapBand'>
<p>Bootstrap Confidence Band</p></a></li>
<li><a href='#bootstrapDiagram'>
<p>Bootstrapped Confidence Set for a Persistence Diagram, using the Bottleneck Distance (or the Wasserstein distance).</p></a></li>
<li><a href='#bottleneck'>
<p>Bottleneck distance between two persistence diagrams</p></a></li>
<li><a href='#circleUnif'>
<p>Uniform Sample From The Circle</p></a></li>
<li><a href='#clusterTree'>
<p>Density clustering: the cluster tree</p></a></li>
<li><a href='#distFct'>
<p>Distance function</p></a></li>
<li><a href='#dtm'>
<p>Distance to Measure Function</p></a></li>
<li><a href='#filtrationDiag'>
<p>Persistence Diagram of Filtration</p></a></li>
<li><a href='#funFiltration'>
<p>Filtration from function values</p></a></li>
<li><a href='#gridDiag'>
<p>Persistence Diagram of a function over a Grid</p></a></li>
<li><a href='#gridFiltration'>
<p>Persistence Diagram of a function over a Grid</p></a></li>
<li><a href='#hausdInterval'>
<p>Subsampling Confidence Interval for the Hausdorff Distance between a Manifold and a Sample</p></a></li>
<li><a href='#kde'>
<p>Kernel Density Estimator over a Grid of Points</p></a></li>
<li><a href='#kernelDist'>
<p>Kernel distance over a Grid of Points</p></a></li>
<li><a href='#knnDE'>
<p>k Nearest Neighbors Density Estimator over a Grid of Points</p></a></li>
<li><a href='#landscape'>
<p>The Persistence Landscape Function</p></a></li>
<li><a href='#maxPersistence'>
<p>Maximal Persistence Method</p></a></li>
<li><a href='#multipBootstrap'>
<p>Multiplier Bootstrap for Persistence Landscapes and Silhouettes</p></a></li>
<li><a href='#plot.clusterTree'>
<p>Plots the Cluster Tree</p></a></li>
<li><a href='#plot.diagram'>
<p>Plot the Persistence Diagram</p></a></li>
<li><a href='#plot.maxPersistence'>
<p>Summary plot for the maxPersistence function</p></a></li>
<li><a href='#ripsDiag'>
<p>Rips Persistence Diagram</p></a></li>
<li><a href='#ripsFiltration'>
<p>Rips Filtration</p></a></li>
<li><a href='#silhouette'>
<p>The Persistence Silhouette Function</p></a></li>
<li><a href='#sphereUnif'>
<p>Uniform Sample From The Sphere <code class="reqn">S^d</code></p></a></li>
<li><a href='#summary.diagram'>
<p><code>print</code> and <code>summary</code> for <code>diagram</code></p></a></li>
<li><a href='#TDA-internal'>
<p>Internal TDA functions</p></a></li>
<li><a href='#torusUnif'>
<p>Uniform Sample From The 3D Torus</p></a></li>
<li><a href='#wasserstein'>
<p>Wasserstein distance between two persistence diagrams</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Tools for Topological Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Brittany T. Fasy, Jisu Kim, Fabrizio Lecci, Clement Maria,
    David L. Millman, Vincent Rouvreau.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jisu Kim &lt;jkim82133@snu.ac.kr&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>See inst/COPYRIGHTS</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for the statistical analysis of persistent homology and for
    density clustering. For that, this package provides an R interface for the
    efficient algorithms of the C++ libraries 'GUDHI' <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>, 'Dionysus' <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>, and 'PHAT' <a href="https://bitbucket.org/phat-code/phat/">https://bitbucket.org/phat-code/phat/</a>. This package also implements the methods in Fasy et al. (2014) &lt;<a href="https://doi.org/10.1214%2F14-AOS1252">doi:10.1214/14-AOS1252</a>&gt; and Chazal et al. (2014) &lt;<a href="https://doi.org/10.1145%2F2582112.2582128">doi:10.1145/2582112.2582128</a>&gt;  for analyzing the statistical significance of persistent homology features.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, Rcpp (&ge; 0.11.0), igraph, parallel, scales</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, lintr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.81.0-1), Rcpp, RcppEigen</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>gmp, GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 19:41:21 UTC; jiskim</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-24 15:42:47 UTC</td>
</tr>
</table>
<hr>
<h2 id='TDA-package'>
Statistical Tools for Topological Data Analysis
</h2><span id='topic+TDA-package'></span><span id='topic+TDA'></span>

<h3>Description</h3>

<p>Tools for Topological Data Analysis. In particular it provides functions for the statistical analysis of persistent homology and for density clustering. For that, this package provides an R interface for the efficient algorithms of the C++ libraries <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>, <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a> and <a href="https://bitbucket.org/phat-code/phat/">PHAT</a>.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> TDA</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.9.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-23</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Brittany Terese Fasy, Jisu Kim, Fabrizio Lecci, Clement Maria, David L. Millman, and Vincent Rouvreau
</p>
<p>Maintainer: Jisu Kim &lt;jisu.kim@inria.fr&gt;
</p>


<h3>References</h3>

<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>
<p>Fasy BT, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). &quot;Statistical Inference For Persistent Homology: Confidence Sets for Persistence Diagrams&quot;, (arXiv:1303.7117). To appear, Annals of Statistics.
</p>
<p>Chazal F, Fasy BT, Lecci F, Michel B, Rinaldo A, Wasserman L (2014). &quot;Robust Topological Inference: Distance-To-a-Measure and Kernel Distance.&quot; Technical Report.	
</p>
<p>Chazal F, Fasy BT, Lecci F, Rinaldo A, Wasserman L (2014). &quot;Stochastic Convergence of Persistence Landscapes and Silhouettes.&quot; Proceedings of the 30th Symposium of Computational Geometry (SoCG). (arXiv:1312.0308)
</p>
<p>Chazal F, Fasy BT, Lecci F, Michel B, Rinaldo A, Wasserman L (2014). &quot;Subsampling Methods for Persistent Homology.&quot; (arXiv:1406.1901)
</p>
<p>Maria C (2014). &quot;GUDHI, Simplicial Complexes and Persistent Homology Packages.&quot; <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>.
</p>
<p>Morozov D (2007). &quot;Dionysus, a C++ library for computing persistent homology.&quot; <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>.
</p>
<p>Bauer U, Kerber M, Reininghaus J (2012). &quot;PHAT, a software library for persistent homology&quot;. <a href="https://bitbucket.org/phat-code/phat/">https://bitbucket.org/phat-code/phat/</a>.
</p>

<hr>
<h2 id='alphaComplexDiag'>
Alpha Complex Persistence Diagram
</h2><span id='topic+alphaComplexDiag'></span>

<h3>Description</h3>

<p>The function <code>alphaComplexDiag</code> computes the persistence diagram of the alpha complex filtration built on top of a point cloud.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphaComplexDiag(
    X, maxdimension = NCOL(X) - 1, library = "GUDHI",
	location = FALSE, printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphaComplexDiag_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, used by the function <code>FUN</code>, where <code class="reqn">n</code> is the number of points stored in <code>X</code> and <code class="reqn">d</code> is the dimension of the space.
</p>
</td></tr>
<tr><td><code id="alphaComplexDiag_+3A_maxdimension">maxdimension</code></td>
<td>

<p>integer: max dimension of the homological features to be computed. (e.g. 0 for connected components, 1 for connected components and loops, 2 for connected components, loops, voids, etc.)
</p>
</td></tr>
<tr><td><code id="alphaComplexDiag_+3A_library">library</code></td>
<td>

<p>either a string or a vector of length two. When a vector is given, the first element specifies which library to compute the Alpha Complex filtration, and the second element specifies which library to compute the persistence diagram. If a string is used, then the same library is used. For computing the Alpha Complex filtration, the user can use the library <code>"GUDHI"</code>, and is also the default value. For computing the persistence diagram, the user can choose either the library <code>"GUDHI"</code>, <code>"Dionysus"</code>, or <code>"PHAT"</code>. The default value is <code>"GUDHI"</code>.
</p>
</td></tr>
<tr><td><code id="alphaComplexDiag_+3A_location">location</code></td>
<td>

<p>if <code>TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram, location of birth point and death point of each homological feature is returned. Additionaly if <code>library="Dionysus"</code>, location of representative cycles of each homological feature is also returned. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="alphaComplexDiag_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>alphaComplexDiag</code> constructs the Alpha Complex filtration, using the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>.
Then for computing the persistence diagram from the Alpha Complex filtration, the user can use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>, <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>, or <a href="https://bitbucket.org/phat-code/phat/">PHAT</a>.
See refereneces.
</p>


<h3>Value</h3>

<p>The function <code>alphaComplexDiag</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>diagram</code></td>
<td>

<p>an object of class <code>diagram</code>, a <code class="reqn">P</code> by 3 matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. The first column stores the dimension of each feature (0 for components, 1 for loops, 2 for voids, etc). Second and third columns are Birth and Death of the features.
</p>
</td></tr>
<tr><td><code>birthLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the grid point completing the simplex that gives birth to an homological feature.
</p>
</td></tr>
<tr><td><code>deathLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the grid point completing the simplex that kills an homological feature.
</p>
</td></tr>
<tr><td><code>cycleLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> is used for computing the persistence diagram: a list of length <code class="reqn">P</code>, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each element is a <code class="reqn">P_i</code> by <code class="reqn">h_i +1</code> by <code class="reqn">d</code> array for <code class="reqn">h_i</code> dimensional homological feature. It represents location of <code class="reqn">h_i +1</code> vertices of <code class="reqn">P_i</code> simplices, where <code class="reqn">P_i</code> simplices constitutes the <code class="reqn">h_i</code> dimensional homological feature.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jisu Kim and Vincent Rouvreau
</p>


<h3>References</h3>

<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>
<p>Rouvreau V (2015). &quot;Alpha complex.&quot; In GUDHI User and Reference Manual. GUDHI Editorial Board. <a href="https://gudhi.inria.fr/doc/latest/group__alpha__complex.html">https://gudhi.inria.fr/doc/latest/group__alpha__complex.html</a>
</p>
<p>Edelsbrunner H, Kirkpatrick G, Seidel R (1983). &quot;On the shape of a set
of points in the plane.&quot; IEEE Trans. Inform. Theory.
</p>
<p>Maria C (2014). &quot;GUDHI, Simplicial Complexes and Persistent Homology Packages.&quot; <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.diagram">summary.diagram</a></code>, <code><a href="#topic+plot.diagram">plot.diagram</a></code>, <code><a href="#topic+alphaShapeDiag">alphaShapeDiag</a></code>, <code><a href="#topic+gridDiag">gridDiag</a></code>, <code><a href="#topic+ripsDiag">ripsDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># input data generated from a circle
X &lt;- circleUnif(n = 30)

# persistence diagram of alpha complex
DiagAlphaCmplx &lt;- alphaComplexDiag(
    X = X, library = c("GUDHI", "Dionysus"), location = TRUE,
    printProgress = TRUE)

# plot
par(mfrow = c(1, 2))
plot(DiagAlphaCmplx[["diagram"]])
one &lt;- which(DiagAlphaCmplx[["diagram"]][, 1] == 1)
one &lt;- one[which.max(
    DiagAlphaCmplx[["diagram"]][one, 3] - DiagAlphaCmplx[["diagram"]][one, 2])]
plot(X, col = 2, main = "Representative loop of data points")
for (i in seq(along = one)) {
  for (j in seq_len(dim(DiagAlphaCmplx[["cycleLocation"]][[one[i]]])[1])) {
    lines(
        DiagAlphaCmplx[["cycleLocation"]][[one[i]]][j, , ], pch = 19, cex = 1,
        col = i)
  }
}
par(mfrow = c(1, 1))

</code></pre>

<hr>
<h2 id='alphaComplexFiltration'>
Alpha Complex Filtration
</h2><span id='topic+alphaComplexFiltration'></span>

<h3>Description</h3>

<p>The function <code>alphaComplexFiltration</code> computes the alpha complex filtration built on top of a point cloud.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphaComplexFiltration(
    X, library = "GUDHI", printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphaComplexFiltration_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, used by the function <code>FUN</code>, where <code class="reqn">n</code> is the number of points stored in <code>X</code> and <code class="reqn">d</code> is the dimension of the space.
</p>
</td></tr>
<tr><td><code id="alphaComplexFiltration_+3A_library">library</code></td>
<td>

<p>a string specifying which library to compute the Alpha Complex filtration. The user can use the library <code>"GUDHI"</code>, and is also the default value.
</p>
</td></tr>
<tr><td><code id="alphaComplexFiltration_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>alphaComplexFiltration</code> constructs the alpha complex filtration, using the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>.
See refereneces.
</p>


<h3>Value</h3>

<p>The function <code>alphaComplexFiltration</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>cmplx</code></td>
<td>

<p>a list representing the complex. Its i-th element represents the vertices of i-th simplex.
</p>
</td></tr>
<tr><td><code>values</code></td>
<td>

<p>a vector representing the filtration values. Its i-th element represents the filtration value of i-th simplex.
</p>
</td></tr>
<tr><td><code>increasing</code></td>
<td>

<p>a logical variable indicating if the filtration values are in increasing order (<code>TRUE</code>) or in decreasing order (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code>coordinates</code></td>
<td>

<p>a matrix representing the coordinates of vertices. Its i-th row represents the coordinate of i-th vertex.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jisu Kim and Vincent Rouvreau
</p>


<h3>References</h3>

<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>
<p>Rouvreau V (2015). &quot;Alpha complex.&quot; In GUDHI User and Reference Manual. GUDHI Editorial Board. <a href="https://gudhi.inria.fr/doc/latest/group__alpha__complex.html">https://gudhi.inria.fr/doc/latest/group__alpha__complex.html</a>
</p>
<p>Edelsbrunner H, Kirkpatrick G, Seidel R (1983). &quot;On the shape of a set
of points in the plane.&quot; IEEE Trans. Inform. Theory.
</p>
<p>Maria C (2014). &quot;GUDHI, Simplicial Complexes and Persistent Homology Packages.&quot; <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+filtrationDiag">filtrationDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># input data generated from a circle
X &lt;- circleUnif(n = 10)

# alpha complex filtration
FltAlphaComplex &lt;- alphaComplexFiltration(X = X, printProgress = TRUE)

# plot alpha complex filtration
lim &lt;- rep(c(-1, 1), 2)
plot(NULL, type = "n", xlim = lim[1:2], ylim = lim[3:4],
    main = "Alpha Complex Filtration Plot")
for (idx in seq(along = FltAlphaComplex[["cmplx"]])) {
  polygon(FltAlphaComplex[["coordinates"]][FltAlphaComplex[["cmplx"]][[idx]], , drop = FALSE],
      col = "pink", border = NA, xlim = lim[1:2], ylim = lim[3:4])
}
for (idx in seq(along = FltAlphaComplex[["cmplx"]])) {
  polygon(FltAlphaComplex[["coordinates"]][FltAlphaComplex[["cmplx"]][[idx]], , drop = FALSE],
      col = NULL, xlim = lim[1:2], ylim = lim[3:4])
}  
points(FltAlphaComplex[["coordinates"]], pch = 16)
</code></pre>

<hr>
<h2 id='alphaShapeDiag'>
Persistence Diagram of Alpha Shape in 3d
</h2><span id='topic+alphaShapeDiag'></span>

<h3>Description</h3>

<p>The function <code>alphaShapeDiag</code> computes the persistence diagram of the alpha shape filtration built on top of a point cloud in 3 dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphaShapeDiag(
    X, maxdimension = NCOL(X) - 1, library = "GUDHI", location = FALSE,
    printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphaShapeDiag_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, used by the function <code>FUN</code>, where <code class="reqn">n</code> is the number of points stored in <code>X</code> and <code class="reqn">d</code> is the dimension of the space.
Currently <code class="reqn">d</code> should be 3.
</p>
</td></tr>
<tr><td><code id="alphaShapeDiag_+3A_maxdimension">maxdimension</code></td>
<td>

<p>integer: max dimension of the homological features to be computed. (e.g. 0 for connected components, 1 for connected components and loops, 2 for connected components, loops, voids, etc.)
</p>
</td></tr>
<tr><td><code id="alphaShapeDiag_+3A_library">library</code></td>
<td>

<p>either a string or a vector of length two. When a vector is given, the first element specifies which library to compute the Alpha Shape filtration, and the second element specifies which library to compute the persistence diagram. If a string is used, then the same library is used. For computing the Alpha Shape filtration, the user can use the library <code>"GUDHI"</code>, and is also the default value. For computing the persistence diagram, the user can choose either the library <code>"GUDHI"</code>, <code>"Dionysus"</code>, or <code>"PHAT"</code>. The default value is <code>"GUDHI"</code>.
</p>
</td></tr>
<tr><td><code id="alphaShapeDiag_+3A_location">location</code></td>
<td>

<p>if <code>TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram, location of birth point and death point of each homological feature is returned. Additionaly if <code>library="Dionysus"</code>, location of representative cycles of each homological feature is also returned. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="alphaShapeDiag_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>alphaShapeDiag</code> constructs the Alpha Shape filtration, using the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>.
Then for computing the persistence diagram from the Alpha Shape filtration, the user can use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>, <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>, or <a href="https://bitbucket.org/phat-code/phat/">PHAT</a>.
See refereneces.
</p>


<h3>Value</h3>

<p>The function <code>alphaShapeDiag</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>diagram</code></td>
<td>

<p>an object of class <code>diagram</code>, a <code class="reqn">P</code> by 3 matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. The first column stores the dimension of each feature (0 for components, 1 for loops, 2 for voids, etc). Second and third columns are Birth and Death of the features.
</p>
</td></tr>
<tr><td><code>birthLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the grid point completing the simplex that gives birth to an homological feature.
</p>
</td></tr>
<tr><td><code>deathLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the grid point completing the simplex that kills an homological feature.
</p>
</td></tr>
<tr><td><code>cycleLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> is used for computing the persistence diagram: a list of length <code class="reqn">P</code>, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each element is a <code class="reqn">P_i</code> by <code class="reqn">h_i +1</code> by <code class="reqn">d</code> array for <code class="reqn">h_i</code> dimensional homological feature. It represents location of <code class="reqn">h_i +1</code> vertices of <code class="reqn">P_i</code> simplices, where <code class="reqn">P_i</code> simplices constitutes the <code class="reqn">h_i</code> dimensional homological feature.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jisu Kim and Vincent Rouvreau
</p>


<h3>References</h3>

<p>Fischer K (2005). &quot;Introduction to Alpha Shapes.&quot;
</p>
<p>Edelsbrunner H, Mucke EP (1994). &quot;Three-dimensional Alpha Shapes.&quot; ACM Trans. Graph.
</p>
<p>Maria C (2014). &quot;GUDHI, Simplicial Complexes and Persistent Homology Packages.&quot; <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>
</p>
<p>Morozov D (2008). &quot;Homological Illusions of Persistence and Stability.&quot;
</p>
<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.diagram">summary.diagram</a></code>, <code><a href="#topic+plot.diagram">plot.diagram</a></code>, <code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+gridDiag">gridDiag</a></code>, <code><a href="#topic+ripsDiag">ripsDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># input data generated from cylinder
n &lt;- 30
X &lt;- cbind(circleUnif(n = n), runif(n = n, min = -0.1, max = 0.1))

# persistence diagram of alpha shape
DiagAlphaShape &lt;- alphaShapeDiag(
    X = X, maxdimension = 1, library = c("GUDHI", "Dionysus"), location = TRUE,
    printProgress = TRUE)

# plot diagram and first two dimension of data
par(mfrow = c(1, 2))
plot(DiagAlphaShape[["diagram"]])
plot(X[, 1:2], col = 2, main = "Representative loop of alpha shape filtration")
one &lt;- which(DiagAlphaShape[["diagram"]][, 1] == 1)
one &lt;- one[which.max(
    DiagAlphaShape[["diagram"]][one, 3] - DiagAlphaShape[["diagram"]][one, 2])]
for (i in seq(along = one)) {
  for (j in seq_len(dim(DiagAlphaShape[["cycleLocation"]][[one[i]]])[1])) {
    lines(
        DiagAlphaShape[["cycleLocation"]][[one[i]]][j, , 1:2], pch = 19,
        cex = 1, col = i)
  }
}
par(mfrow = c(1, 1))
</code></pre>

<hr>
<h2 id='alphaShapeFiltration'>
Alpha Shape Filtration in 3d
</h2><span id='topic+alphaShapeFiltration'></span>

<h3>Description</h3>

<p>The function <code>alphaShapeFiltration</code> computes the alpha shape filtration built on top of a point cloud in 3 dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphaShapeFiltration(
    X, library = "GUDHI", printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphaShapeFiltration_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, used by the function <code>FUN</code>, where <code class="reqn">n</code> is the number of points stored in <code>X</code> and <code class="reqn">d</code> is the dimension of the space.
Currently <code class="reqn">d</code> should be 3.
</p>
</td></tr>
<tr><td><code id="alphaShapeFiltration_+3A_library">library</code></td>
<td>

<p>a string specifying which library to compute the Alpha Shape filtration. The user can use the library <code>"GUDHI"</code>, and is also the default value.
</p>
</td></tr>
<tr><td><code id="alphaShapeFiltration_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>alphaShapeFiltration</code> constructs the alpha shape filtration, using the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>.
See refereneces.
</p>


<h3>Value</h3>

<p>The function <code>alphaShapeFiltration</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>cmplx</code></td>
<td>

<p>a list representing the complex. Its i-th element represents the vertices of i-th simplex.
</p>
</td></tr>
<tr><td><code>values</code></td>
<td>

<p>a vector representing the filtration values. Its i-th element represents the filtration value of i-th simplex.
</p>
</td></tr>
<tr><td><code>increasing</code></td>
<td>

<p>a logical variable indicating if the filtration values are in increasing order (<code>TRUE</code>) or in decreasing order (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code>coordinates</code></td>
<td>

<p>a matrix representing the coordinates of vertices. Its i-th row represents the coordinate of i-th vertex.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jisu Kim and Vincent Rouvreau
</p>


<h3>References</h3>

<p>Fischer K (2005). &quot;Introduction to Alpha Shapes.&quot;
</p>
<p>Edelsbrunner H, Mucke EP (1994). &quot;Three-dimensional Alpha Shapes.&quot; ACM Trans. Graph.
</p>
<p>Maria C (2014). &quot;GUDHI, Simplicial Complexes and Persistent Homology Packages.&quot; <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>
</p>
<p>Morozov D (2008). &quot;Homological Illusions of Persistence and Stability.&quot;
</p>
<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alphaShapeDiag">alphaShapeDiag</a></code>, <code><a href="#topic+filtrationDiag">filtrationDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># input data generated from sphere
X &lt;- sphereUnif(n = 20, d = 2)

# alpha shape filtration
FltAlphaShape &lt;- alphaShapeFiltration(X = X, printProgress = TRUE)
</code></pre>

<hr>
<h2 id='bootstrapBand'>
Bootstrap Confidence Band
</h2><span id='topic+bootstrapBand'></span>

<h3>Description</h3>

<p>The function <code>bootstrapBand</code> computes a uniform symmetric confidence band around a function of the data <code>X</code>, evaluated on a <code>Grid</code>, using the bootstrap algorithm. See Details and References.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrapBand(
    X, FUN, Grid, B = 30, alpha = 0.05, parallel = FALSE,
    printProgress = FALSE, weight = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapBand_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates of points used by the function <code>FUN</code>, where <code class="reqn">n</code> is the number of points and <code class="reqn">d</code> is the dimension.
</p>
</td></tr>
<tr><td><code id="bootstrapBand_+3A_fun">FUN</code></td>
<td>

<p>a function whose inputs are an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates <code>X</code>, an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates <code>Grid</code> and returns a numeric vector of length <code class="reqn">m</code>. For example see <code><a href="#topic+distFct">distFct</a></code>, <code><a href="#topic+kde">kde</a></code>, and <code><a href="#topic+dtm">dtm</a></code>  which compute the distance function, the kernel density estimator and the distance to measure over a grid of points, using the input <code>X</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapBand_+3A_grid">Grid</code></td>
<td>

<p>an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates, where <code class="reqn">m</code> is the number of points in the grid, at which <code>FUN</code> is evaluated.
</p>
</td></tr>
<tr><td><code id="bootstrapBand_+3A_b">B</code></td>
<td>

<p>the number of bootstrap iterations.
</p>
</td></tr>
<tr><td><code id="bootstrapBand_+3A_alpha">alpha</code></td>
<td>

<p><code>bootstrapBand</code> returns a (<code>1-alpha</code>) confidence band. The default value is <code>0.05</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapBand_+3A_parallel">parallel</code></td>
<td>

<p>logical: if <code>TRUE</code> the bootstrap iterations are parallelized, using the library <code>parallel</code>. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapBand_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapBand_+3A_weight">weight</code></td>
<td>

<p>either NULL, a number, or a vector of length <code class="reqn">n</code>. If it is NULL, weight is not used. If it is a number, then same weight is applied to each points of <code>X</code>. If it is a vector, <code>weight</code> represents weights of each points of <code>X</code>. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapBand_+3A_...">...</code></td>
<td>

<p>additional parameters for the function <code>FUN</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the input function <code>FUN</code> is evaluated on the <code>Grid</code> using the original data <code>X</code>. Then, for <code>B</code> times, the bootstrap algorithm subsamples <code>n</code> points of <code>X</code> (with replacement), evaluates the function <code>FUN</code> on the <code>Grid</code> using the subsample, and computes the <code class="reqn">\ell_\infty</code> distance between the original function and the bootstrapped one. The result is a sequence of <code>B</code> values. The (<code>1-alpha</code>) confidence band is constructed by taking the (<code>1-alpha</code>) quantile of these values.
</p>


<h3>Value</h3>

<p>The function <code>bootstrapBand</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>width</code></td>
<td>

<p>number: (<code>1-alpha</code>) quantile of the values computed by the bootstrap algorithm. It corresponds to half of the width of the unfiorm confidence band; that is, <code>width</code> is the distance of the upper and lower limits of the band from the function evaluated using the original dataset <code>X</code>.
</p>
</td></tr>
<tr><td><code>fun</code></td>
<td>

<p>a numeric vector of length <code class="reqn">m</code>, storing the values of the input function <code>FUN</code>, evaluated on the <code>Grid</code> using the original data <code>X</code>.
</p>
</td></tr>
<tr><td><code>band</code></td>
<td>

<p>an <code class="reqn">m</code> by 2 matrix that stores the values of the lower limit of the confidence band (first column) and upper limit of the confidence band (second column), evaluated over the <code>Grid</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jisu Kim and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Wasserman L (2004). &quot;All of statistics: a concise course in statistical inference.&quot; Springer.
</p>
<p>Fasy BT, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). &quot;Statistical Inference For Persistent Homology: Confidence Sets for Persistence Diagrams.&quot; (arXiv:1303.7117). Annals of Statistics.
</p>
<p>Chazal F, Fasy BT, Lecci F, Michel B, Rinaldo A, Wasserman L (2014). &quot;Robust Topological Inference: Distance-To-a-Measure and Kernel Distance.&quot; Technical Report. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kde">kde</a></code>, <code><a href="#topic+dtm">dtm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from mixture of 2 normals.
n &lt;- 2000
X &lt;- c(rnorm(n / 2), rnorm(n / 2, mean = 3, sd = 1.2))

# Construct a grid of points over which we evaluate the function
by &lt;- 0.02
Grid &lt;- seq(-3, 6, by = by)

## bandwidth for kernel density estimator
h &lt;- 0.3
## Bootstrap confidence band
band &lt;- bootstrapBand(X, kde, Grid, B = 80, parallel = FALSE, alpha = 0.05,
                      h = h)

plot(Grid, band[["fun"]], type = "l", lwd = 2,
     ylim = c(0, max(band[["band"]])), main = "kde with 0.95 confidence band")
lines(Grid, pmax(band[["band"]][, 1], 0), col = 2, lwd = 2)
lines(Grid, band[["band"]][, 2], col = 2, lwd = 2)
</code></pre>

<hr>
<h2 id='bootstrapDiagram'>
Bootstrapped Confidence Set for a Persistence Diagram, using the Bottleneck Distance (or the Wasserstein distance).
</h2><span id='topic+bootstrapDiagram'></span>

<h3>Description</h3>

<p>The function <code>bootstrapDiagram</code> computes a <code>(1-alpha)</code> confidence set for the Persistence Diagram of a filtration of sublevel sets (or superlevel sets) of a function evaluated over a grid of points. The function returns the (<code>1-alpha</code>) quantile of <code>B</code> bottleneck distances (or Wasserstein distances), computed in <code>B</code> iterations of the bootstrap algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrapDiagram(
    X, FUN, lim, by, maxdimension = length(lim) / 2 - 1,
    sublevel = TRUE, library = "GUDHI", B = 30, alpha = 0.05,
    distance = "bottleneck", dimension = min(1, maxdimension),
	p = 1, parallel = FALSE, printProgress = FALSE, weight = NULL,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapDiagram_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, used by the function <code>FUN</code>, where <code class="reqn">n</code> is the number of points stored in <code>X</code> and <code class="reqn">d</code> is the dimension of the space.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_fun">FUN</code></td>
<td>

<p>a function whose inputs are 1) an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates <code>X</code>, 2) an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates <code>Grid</code>, 3) an optional smoothing parameter, and returns a numeric vector of length <code class="reqn">m</code>. For example see <code><a href="#topic+distFct">distFct</a></code>,  <code><a href="#topic+kde">kde</a></code>, and <code><a href="#topic+dtm">dtm</a></code>  which compute the distance function, the kernel density estimator and the distance to measure, over a grid of points using the input <code>X</code>. Note that <code>Grid</code> is not an input of <code>bootstrapDiagram</code>, but is automatically computed by the function using <code>lim</code> and <code>by</code>. 
</p>
</td></tr>  
<tr><td><code id="bootstrapDiagram_+3A_lim">lim</code></td>
<td>

<p>a <code class="reqn">2</code> by <code class="reqn">d</code> matrix, where each column specifies the range of each dimension of the grid, over which the function <code>FUN</code> is evaluated.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_by">by</code></td>
<td>

<p>either a number or a vector of length <code class="reqn">d</code> specifying space between points of the grid in each dimension. If a number is given, then same space is used in each dimension.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_maxdimension">maxdimension</code></td>
<td>

<p>a number that indicates the maximum dimension to compute persistent homology to. The default value is <code class="reqn">d - 1</code>, which is (dimension of embedding space - 1).
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_sublevel">sublevel</code></td>
<td>

<p>a logical variable indicating if the Persistence Diagram should be computed for sublevel sets (<code>TRUE</code>) or superlevel sets (<code>FALSE</code>) of the function. The default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_library">library</code></td>
<td>

<p>a string specifying which library to compute the persistence diagram. The user can choose either the library <code>"GUDHI"</code>, <code>"Dionysus"</code>, or <code>"PHAT"</code>. The default value is <code>"GUDHI"</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_b">B</code></td>
<td>

<p>the number of bootstrap iterations. The default value is <code>30</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_alpha">alpha</code></td>
<td>

<p>The function <code>bootstrapDiagram</code> returns a (<code>1 - alpha</code>) quantile. The default value is <code>0.05</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_distance">distance</code></td>
<td>

<p>a string specifying the distance to be used for persistence diagrams: either <code>"bottleneck"</code> or <code>"wasserstein"</code>. The default value is <code>"bottleneck"</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_dimension">dimension</code></td>
<td>

<p><code>dimension</code> is an integer or a vector specifying the dimension of the features used to compute the bottleneck distance. <code>0</code> for connected components, <code>1</code> for loops, <code>2</code> for voids, and so on. The default value is <code>1</code> if <code class="reqn">maxdimension \ge 1</code>, and else <code>0</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_p">p</code></td>
<td>

<p>if <code>distance == "wasserstein"</code>, then <code>p</code> is an integer specifying the power to be used in the computation of the Wasserstein distance. The default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_parallel">parallel</code></td>
<td>

<p>logical: if <code>TRUE</code> the bootstrap iterations are parallelized, using the library <code>parallel</code>. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code> a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_weight">weight</code></td>
<td>

<p>either NULL, a number, or a vector of length <code class="reqn">n</code>. If it is NULL, weight is not used. If it is a number, then same weight is applied to each points of <code>X</code>. If it is a vector, <code>weight</code> represents weights of each points of <code>X</code>. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="bootstrapDiagram_+3A_...">...</code></td>
<td>

<p>additional parameters for the function <code>FUN</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>bootstrapDiagram</code> uses <code><a href="#topic+gridDiag">gridDiag</a></code> to compute the persistence diagram of the input function using the entire sample. Then the bootstrap algorithm, for <code>B</code> times, computes the bottleneck distance between the original persistence diagram and the one computed using a subsample. Finally the (<code>1-alpha</code>) quantile of these <code>B</code> values is returned. See (Chazal, Fasy, Lecci, Michel, Rinaldo, and Wasserman, 2014) for discussion of the method.
</p>


<h3>Value</h3>

<p>The function <code>bootstrapDiagram</code> returns the (<code>1-alpha</code>) quantile of the values computed by the bootstrap algorithm. 
</p>


<h3>Note</h3>

<p>The function <code>bootstrapDiagram</code> uses the C++ library <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a> for the computation of bottleneck and Wasserstein distances. See references.
</p>


<h3>Author(s)</h3>

<p>Jisu Kim and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Chazal F, Fasy BT, Lecci F, Michel B, Rinaldo A, Wasserman L (2014). &quot;Robust Topological Inference: Distance-To-a-Measure and Kernel Distance.&quot; Technical Report. 
</p>
<p>Wasserman L (2004), &quot;All of statistics: a concise course in statistical inference.&quot; Springer.
</p>
<p>Morozov D (2007). &quot;Dionysus, a C++ library for computing persistent homology.&quot; <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bottleneck">bottleneck</a></code>, <code><a href="#topic+bootstrapBand">bootstrapBand</a></code>,
<code><a href="#topic+distFct">distFct</a></code>, <code><a href="#topic+kde">kde</a></code>, <code><a href="#topic+kernelDist">kernelDist</a></code>, <code><a href="#topic+dtm">dtm</a></code>,
<code><a href="#topic+summary.diagram">summary.diagram</a></code>, <code><a href="#topic+plot.diagram">plot.diagram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## confidence set for the Kernel Density Diagram

# input data
n &lt;- 400
XX &lt;- circleUnif(n)

## Ranges of the grid
Xlim &lt;- c(-1.8, 1.8)
Ylim &lt;- c(-1.6, 1.6)
lim &lt;- cbind(Xlim, Ylim)
by &lt;- 0.05

h &lt;- .3  #bandwidth for the function kde

#Kernel Density Diagram of the superlevel sets
Diag &lt;- gridDiag(XX, kde, lim = lim, by = by, sublevel = FALSE,
                 printProgress = TRUE, h = h) 

# confidence set
B &lt;- 10       ## the number of bootstrap iterations should be higher!
              ## this is just an example
alpha &lt;- 0.05

cc &lt;- bootstrapDiagram(XX, kde, lim = lim, by = by, sublevel = FALSE, B = B,
          alpha = alpha, dimension = 1, printProgress = TRUE, h = h)

plot(Diag[["diagram"]], band = 2 * cc)
</code></pre>

<hr>
<h2 id='bottleneck'>
Bottleneck distance between two persistence diagrams
</h2><span id='topic+bottleneck'></span>

<h3>Description</h3>

<p>The function <code>bottleneck</code> computes the bottleneck distance between two persistence diagrams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bottleneck(Diag1, Diag2, dimension = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bottleneck_+3A_diag1">Diag1</code></td>
<td>

<p>an object of class <code>diagram</code> or a matrix (<code class="reqn">n</code> by 3) that stores dimension, birth and death of <code class="reqn">n</code> topological features.
</p>
</td></tr>
<tr><td><code id="bottleneck_+3A_diag2">Diag2</code></td>
<td>

<p>an object of class <code>diagram</code> or a matrix (<code class="reqn">m</code> by 3) that stores dimension, birth and death of <code class="reqn">m</code> topological features.
</p>
</td></tr>
<tr><td><code id="bottleneck_+3A_dimension">dimension</code></td>
<td>

<p>an integer or a vector specifying the dimension of the features used to compute the bottleneck distance. <code>0</code> for connected components, <code>1</code> for loops, <code>2</code> for voids and so on. The default value is <code>1</code> (loops). The default value is <code>1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bottleneck distance between two diagrams is the cost of the optimal matching between points of the two diagrams. Note that all the diagonal points are included in the persistence diagrams when computing the optimal matching. When a vector is given for <code>dimension</code>, then maximum among bottleneck distances using each element in <code>dimension</code> is returned. The function <code>bottleneck</code> is an R wrapper of the function &quot;bottleneck_distance&quot; in the C++ library <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>. See references.
</p>


<h3>Value</h3>

<p>The function <code>bottleneck</code> returns the value of the bottleneck distance between the two persistence diagrams.
</p>


<h3>Author(s)</h3>

<p>Jisu Kim and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Morozov D (2007). &quot;Dionysus, a C++ library for computing persistent homology.&quot; <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>
</p>
<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wasserstein">wasserstein</a></code>,
<code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+gridDiag">gridDiag</a></code>, <code><a href="#topic+ripsDiag">ripsDiag</a></code>,
<code><a href="#topic+plot.diagram">plot.diagram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XX1 &lt;- circleUnif(20)
XX2 &lt;- circleUnif(20, r = 0.2)

DiagLim &lt;- 5
maxdimension &lt;- 1

Diag1 &lt;- ripsDiag(XX1, maxdimension, DiagLim, printProgress = FALSE)
Diag2 &lt;- ripsDiag(XX2, maxdimension, DiagLim, printProgress = FALSE)

bottleneckDist &lt;- bottleneck(Diag1[["diagram"]], Diag2[["diagram"]],
                             dimension = 1)
print(bottleneckDist)
</code></pre>

<hr>
<h2 id='circleUnif'>
Uniform Sample From The Circle
</h2><span id='topic+circleUnif'></span>

<h3>Description</h3>

<p>The function <code>circleUnif</code> samples <code>n</code> points from the circle of radius <code>r</code>, uniformly with respect to the circumference length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  circleUnif(n, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circleUnif_+3A_n">n</code></td>
<td>

<p>an integer specifying the number of points in the sample.
</p>
</td></tr>
<tr><td><code id="circleUnif_+3A_r">r</code></td>
<td>

<p>a numeric variable specifying the radius of the circle. The default value is <code>1</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>circleUnif</code> returns an <code>n</code> by 2 matrix of coordinates.
</p>


<h3>Note</h3>

<p>Uniform sample from sphere of arbitrary dimension can be generated using <code><a href="#topic+sphereUnif">sphereUnif</a></code>.
</p>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sphereUnif">sphereUnif</a></code>, <code><a href="#topic+torusUnif">torusUnif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- circleUnif(100)
plot(X)
</code></pre>

<hr>
<h2 id='clusterTree'>
Density clustering: the cluster tree
</h2><span id='topic+clusterTree'></span><span id='topic+print.clusterTree'></span>

<h3>Description</h3>

<p>Given a point cloud, or a matrix of distances, the function <code>clusterTree</code> computes a density estimator and returns the corresponding cluster tree of superlevel sets (lambda tree and kappa tree; see references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterTree(
    X, k, h = NULL, density = "knn", dist = "euclidean", d = NULL,
    Nlambda = 100, printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterTree_+3A_x">X</code></td>
<td>

<p>If <code>dist="euclidean"</code>, then <code>X</code> is an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, where <code class="reqn">n</code> is the number of points stored in <code>X</code> and <code class="reqn">d</code> is the dimension of the space.
If <code>dist="arbitrary"</code>, then <code>X</code> is an <code class="reqn">n</code> by <code class="reqn">n</code> matrix of distances.
</p>
</td></tr>
<tr><td><code id="clusterTree_+3A_k">k</code></td>
<td>

<p>an integer value specifying the parameter of the underlying k-nearest neighbor similarity graph, used to determine connected components. If <code>density="knn"</code>, then <code>k</code> is also used to compute the k-nearest neighbor density estimator.
</p>
</td></tr>
<tr><td><code id="clusterTree_+3A_h">h</code></td>
<td>

<p>real value: if <code>density = "kde"</code>, then <code>h</code> is used to compute the kernel density estimator with bandwidth <code>h</code>. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="clusterTree_+3A_density">density</code></td>
<td>

<p>string: if <code>"knn"</code> then the k-nearest neighbor density estimator is used to compute the cluster tree;
if <code>"kde"</code> then the kernel density estimator is used to compute the cluster tree.
The default value is <code>"knn"</code>.
</p>
</td></tr>
<tr><td><code id="clusterTree_+3A_dist">dist</code></td>
<td>

<p>string: can be <code>"euclidean"</code>, when <code>X</code> is a point cloud or <code>"arbitrary"</code>, when <code>X</code> is a matrix of distances. The default value is <code>"euclidean"</code>.
</p>
</td></tr>
<tr><td><code id="clusterTree_+3A_d">d</code></td>
<td>

<p>integer: if <code>dist="arbitrary"</code>, then <code>d</code> is the dimension of the underlying space. The default value is <code>"NULL"</code>.
</p>
</td></tr>
<tr><td><code id="clusterTree_+3A_nlambda">Nlambda</code></td>
<td>

<p>integer: size of the grid of values of the density estimator, used to compute the cluster tree. High <code>Nlambda</code> (i.e. a fine grid) means a more accurate cluster Tree. The default value is <code>100</code>.
</p>
</td></tr>
<tr><td><code id="clusterTree_+3A_printprogress">printProgress</code></td>
<td>

<p>logical: if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>clusterTree</code> is an implementation of Algorithm 1 in the first reference.
</p>


<h3>Value</h3>

<p>The function <code>clusterTree</code> returns an object of class <code>clusterTree</code>, a list with the following components
</p>
<table>
<tr><td><code>density</code></td>
<td>

<p>Vector of length <code>n</code>: the values of the density estimator evaluated at each of the points stored in <code>X</code>
</p>
</td></tr>
<tr><td><code>DataPoints</code></td>
<td>

<p>A list whose elements are the points of <code>X</code> corresponding to each branch, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>The number of points stored in the input matrix <code>X</code>
</p>
</td></tr>
<tr><td><code>id</code></td>
<td>

<p>Vector: the IDs associated to the branches of the cluster tree
</p>
</td></tr>
<tr><td><code>children</code></td>
<td>

<p>A list whose elements are the IDs of the children of each branch, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>parent</code></td>
<td>

<p>Vector: the IDs of the parents of each branch, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>silo</code></td>
<td>

<p>A list whose elements are the horizontal coordinates of the silo of each branch, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>Xbase</code></td>
<td>

<p>Vector: the horiontal coordinates of the branches of the cluster tree, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>lambdaBottom</code></td>
<td>

<p>Vector: the vertical bottom coordinates of the branches of the lambda tree, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>lambdaTop</code></td>
<td>

<p>Vector: the vertical top coordinates of the branches of the lambda tree, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>rBottom</code></td>
<td>

<p>(only if <code>density="knn"</code>) Vector: the vertical bottom coordinates of the branches of the r tree, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>rTop</code></td>
<td>

<p>(only if <code>density="knn"</code>) Vector: the vertical top coordinates of the branches of the r tree, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>alphaBottom</code></td>
<td>

<p>Vector: the vertical bottom coordinates of the branches of the alpha tree, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>alphaTop</code></td>
<td>

<p>Vector: the vertical top coordinates of the branches of the alpha tree, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>Kbottom</code></td>
<td>

<p>Vector: the vertical bottom coordinates of the branches of the kappa tree, in the same order of <code>id</code>
</p>
</td></tr>
<tr><td><code>Ktop</code></td>
<td>

<p>Vector: the vertical top coordinates of the branches of the kappa tree, in the same order of <code>id</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>References</h3>

<p>Kent BP, Rinaldo A, Verstynen T (2013). &quot;DeBaCl: A Python Package for Interactive DEnsity-BAsed CLustering.&quot; arXiv:1307.8136 
</p>
<p>Lecci F, Rinaldo A, Wasserman L (2014). &quot;Metric Embeddings for Cluster Trees&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.clusterTree">plot.clusterTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate data: 3 clusters
n &lt;- 1200    #sample size
Neach &lt;- floor(n / 4) 
X1 &lt;- cbind(rnorm(Neach, 1, .8), rnorm(Neach, 5, 0.8))
X2 &lt;- cbind(rnorm(Neach, 3.5, .8), rnorm(Neach, 5, 0.8))
X3 &lt;- cbind(rnorm(Neach, 6, 1), rnorm(Neach, 1, 1))
X &lt;- rbind(X1, X2, X3)

k &lt;- 100     #parameter of knn

## Density clustering using knn and kde
Tree &lt;- clusterTree(X, k, density = "knn")
TreeKDE &lt;- clusterTree(X, k, h = 0.3, density = "kde")

par(mfrow = c(2, 3))
plot(X, pch = 19, cex = 0.6)
# plot lambda trees
plot(Tree, type = "lambda", main = "lambda Tree (knn)")
plot(TreeKDE, type = "lambda", main = "lambda Tree (kde)")
# plot clusters
plot(X, pch = 19, cex = 0.6, main = "cluster labels")
for (i in Tree[["id"]]){
  points(matrix(X[Tree[["DataPoints"]][[i]],],ncol = 2), col = i, pch = 19,
         cex = 0.6)
}
#plot kappa trees
plot(Tree, type = "kappa", main = "kappa Tree (knn)")
plot(TreeKDE, type = "kappa", main = "kappa Tree (kde)")
</code></pre>

<hr>
<h2 id='distFct'>
Distance function
</h2><span id='topic+distFct'></span>

<h3>Description</h3>

<p>The function <code>distFct</code> computes the distance between each point of a set <code>Grid</code> and the corresponding closest point of another set <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distFct(X, Grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distFct_+3A_x">X</code></td>
<td>

<p>a numeric <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates in the space, where <code class="reqn">m</code> is the number of points in <code>X</code> and <code class="reqn">d</code> is the dimension of the space. 
X is the set of points whose distance is being measured from a base grid.
</p>
</td></tr>
<tr><td><code id="distFct_+3A_grid">Grid</code></td>
<td>

<p>a numeric <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates in the space, where <code class="reqn">n</code> is the number of points in <code>Grid</code> and <code class="reqn">d</code> is the dimension of the space. 
Grid is the base set from which each point is compared to the closest point in X.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set of points <code>X</code>, the distance function computed at <code class="reqn">g</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
    d(g) = \inf_{x \in X} \| x-g \|_2
  </code>
</p>



<h3>Value</h3>

<p>The function <code>distFct</code> returns a numeric vector of length <code class="reqn">n</code>, where <code class="reqn">n</code> is the number of points stored in <code>Grid</code>. 
Each value in V corresponds to the distance between a point in G and the nearest point in X.
</p>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kde">kde</a></code>,<code><a href="#topic+kernelDist">kernelDist</a></code>, <code><a href="#topic+dtm">dtm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate Data from the unit circle
n &lt;- 300
X &lt;- circleUnif(n)

## Construct a grid of points over which we evaluate the function
interval &lt;- 0.065
Xseq &lt;- seq(-1.6, 1.6, by = interval)
Yseq &lt;- seq(-1.7, 1.7, by = interval)
Grid &lt;- expand.grid(Xseq, Yseq)

## distance fct
distance &lt;- distFct(X, Grid)
</code></pre>

<hr>
<h2 id='dtm'>
Distance to Measure Function
</h2><span id='topic+dtm'></span>

<h3>Description</h3>

<p>The function <code>dtm</code> computes the &quot;distance to measure function&quot; on a set of points <code>Grid</code>, using the uniform empirical measure on a set of points <code>X</code>. Given a probability measure <code class="reqn">P</code>, The distance to measure function, for each <code class="reqn">y \in R^d</code>, is defined by
</p>
<p style="text-align: center;"><code class="reqn">
    d_{m0}(y) = \left(\frac{1}{m0}\int_0^{m0} ( G_y^{-1}(u))^{r} du\right)^{1/r},
  </code>
</p>

<p>where <code class="reqn">G_y(t) = P( \Vert X-y \Vert \le t)</code>, and <code class="reqn">m0 \in (0,1)</code> and <code class="reqn">r \in [1,\infty)</code> are tuning parameters. As <code>m0</code> increases, DTM function becomes smoother, so <code>m0</code> can be understood as a smoothing parameter. <code>r</code> affects less but also changes DTM function as well. The DTM can be seen as a smoothed version of the distance function. See Details and References.
</p>
<p>Given <code class="reqn">X=\{x_1, \dots, x_n\}</code>, the empirical version of the distance to measure is
</p>
<p style="text-align: center;"><code class="reqn">
    \hat d_{m0}(y) = \left(\frac{1}{k} \sum_{x_i \in N_k(y)} \Vert x_i-y \Vert^{r}\right)^{1/r},
  </code>
</p>

<p>where <code class="reqn">k= \lceil m0 * n \rceil</code> and <code class="reqn">N_k(y)</code> is the set containing the <code class="reqn">k</code> nearest neighbors of <code class="reqn">y</code> among <code class="reqn">x_1, \ldots, x_n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtm(X, Grid, m0, r = 2, weight = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtm_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates of points used to construct the uniform empirical measure for the distance to measure, where <code class="reqn">n</code> is the number of points and <code class="reqn">d</code> is the dimension.
</p>
</td></tr>
<tr><td><code id="dtm_+3A_grid">Grid</code></td>
<td>

<p>an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates of points where the distance to measure is computed, where <code class="reqn">m</code> is the number of points in <code>Grid</code> and <code class="reqn">d</code> is the dimension.
</p>
</td></tr>
<tr><td><code id="dtm_+3A_m0">m0</code></td>
<td>

<p>a numeric variable for the smoothing parameter of the distance to measure. Roughly, <code>m0</code> is the the percentage of points of <code>X</code> that are considered when the distance to measure is computed for each point of <code>Grid</code>. The value of <code>m0</code> should be in <code class="reqn">(0,1)</code>.
</p>
</td></tr>
<tr><td><code id="dtm_+3A_r">r</code></td>
<td>

<p>a numeric variable for the tuning parameter of the distance to measure. The value of <code>r</code> should be in <code class="reqn">[1,\infty)</code>, and the default value is <code>2</code>.
</p>
</td></tr>
<tr><td><code id="dtm_+3A_weight">weight</code></td>
<td>

<p>either a number, or a vector of length <code class="reqn">n</code>. If it is a number, then same weight is applied to each points of <code>X</code>. If it is a vector, <code>weight</code> represents weights of each points of <code>X</code>. The default value is <code>1</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See (Chazal, Cohen-Steiner, and Merigot, 2011, Definition 3.2) and (Chazal, Massart, and Michel, 2015, Equation (2)) for a formal definition of the &quot;distance to measure&quot; function.
</p>


<h3>Value</h3>

<p>The function <code>dtm</code> returns a vector of length <code class="reqn">m</code> (the number of points stored in <code>Grid</code>) containing the value of the distance to measure function evaluated at each point of <code>Grid</code>.
</p>


<h3>Author(s)</h3>

<p>Jisu Kim and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Chazal F, Cohen-Steiner D, Merigot Q (2011). &quot;Geometric inference for probability measures.&quot; Foundations of Computational Mathematics 11.6, 733-751.
</p>
<p>Chazal F, Massart P, Michel B (2015). &quot;Rates of convergence for robust geometric inference.&quot;
</p>
<p>Chazal F, Fasy BT, Lecci F, Michel B, Rinaldo A, Wasserman L (2014). &quot;Robust Topological Inference: Distance-To-a-Measure and Kernel Distance.&quot; Technical Report. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kde">kde</a></code>, <code><a href="#topic+kernelDist">kernelDist</a></code>, <code><a href="#topic+distFct">distFct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate Data from the unit circle
n &lt;- 300
X &lt;- circleUnif(n)

## Construct a grid of points over which we evaluate the function
by &lt;- 0.065
Xseq &lt;- seq(-1.6, 1.6, by = by)
Yseq &lt;- seq(-1.7, 1.7, by = by)
Grid &lt;- expand.grid(Xseq, Yseq)

## distance to measure
m0 &lt;- 0.1
DTM &lt;- dtm(X, Grid, m0)
</code></pre>

<hr>
<h2 id='filtrationDiag'>
Persistence Diagram of Filtration
</h2><span id='topic+filtrationDiag'></span>

<h3>Description</h3>

<p>The function <code>filtrationDiag</code> computes the persistence diagram of the filtration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtrationDiag(
    filtration, maxdimension, library = "GUDHI", location = FALSE,
    printProgress = FALSE, diagLimit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filtrationDiag_+3A_filtration">filtration</code></td>
<td>

<p>a list representing the input filtration. This list consists of three components: <code>"cmplx"</code>, a list representing the complex, <code>"values"</code>, a vector representing the filtration values, and <code>"increasing"</code>, a logical variable indicating if the filtration values are in increasing order or in decreasing order.
</p>
</td></tr>
<tr><td><code id="filtrationDiag_+3A_maxdimension">maxdimension</code></td>
<td>

<p>integer: max dimension of the homological features to be computed. (e.g. 0 for connected components, 1 for connected components and loops, 2 for connected components, loops, voids, etc.)
</p>
</td></tr>
<tr><td><code id="filtrationDiag_+3A_library">library</code></td>
<td>

<p>a string specifying which library to compute the persistence diagram. The user can choose either the library <code>"GUDHI"</code> or <code>"Dionysus"</code>. The default value is <code>"GUDHI"</code>.
</p>
</td></tr>
<tr><td><code id="filtrationDiag_+3A_location">location</code></td>
<td>

<p>if <code>TRUE</code> and if <code>"Dionysus"</code> is used for computing the persistence diagram, location of birth point, death point, and representative cycles, of each homological feature is returned.
</p>
</td></tr>
<tr><td><code id="filtrationDiag_+3A_printprogress">printProgress</code></td>
<td>

<p>logical: if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="filtrationDiag_+3A_diaglimit">diagLimit</code></td>
<td>

<p>a number that replaces <code>Inf</code> in the persistence diagram. The default value is <code>NULL</code> and <code>Inf</code> value in the persistence diagram will not be replaced.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can decide to use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a> or <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>.
See refereneces.
</p>


<h3>Value</h3>

<p>The function <code>filtrationDiag</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>diagram</code></td>
<td>

<p>an object of class <code>diagram</code>, a <code class="reqn">P</code> by 3 matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. The first column contains the dimension of each feature (0 for components, 1 for loops, 2 for voids, etc.). Second and third columns are Birth and Death of the features.
</p>
</td></tr>
<tr><td><code>birthLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> is used for computing the persistence diagram: a vector of length <code class="reqn">P</code>. Each row represents the index of the vertex completing the simplex that gives birth to an homological feature.
</p>
</td></tr>
<tr><td><code>deathLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> is used for computing the persistence diagram: a vector of length <code class="reqn">P</code>. Each row represents the index of the vertex completing the simplex that kills an homological feature.
</p>
</td></tr>
<tr><td><code>cycleLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> is used for computing the persistence diagram: a <code class="reqn">P_i</code> by <code class="reqn">h_i +1</code> matrix for <code class="reqn">h_i</code> dimensional homological feature. It represents index of <code class="reqn">h_i +1</code> vertices of <code class="reqn">P_i</code> simplices on a representative cycle of the <code class="reqn">h_i</code> dimensional homological feature.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jisu Kim
</p>


<h3>References</h3>

<p>Maria C (2014). &quot;GUDHI, Simplicial Complexes and Persistent Homology Packages.&quot; <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>.
</p>
<p>Morozov D (2007). &quot;Dionysus, a C++ library for computing persistent homology&quot;. <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>
</p>
<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>
<p>Fasy B, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). &quot;Statistical Inference For Persistent Homology.&quot; (arXiv:1303.7117). Annals of Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.diagram">summary.diagram</a></code>, <code><a href="#topic+plot.diagram">plot.diagram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
X &lt;- cbind(cos(2*pi*seq_len(n)/n), sin(2*pi*seq_len(n)/n))
maxdimension &lt;- 1
maxscale &lt;- 1.5
dist &lt;- "euclidean"
library &lt;- "Dionysus"

FltRips &lt;- ripsFiltration(X = X, maxdimension = maxdimension,
               maxscale = maxscale, dist = "euclidean", library = "Dionysus",
               printProgress = TRUE)

DiagFltRips &lt;- filtrationDiag(filtration = FltRips, maxdimension = maxdimension,
                   library = "Dionysus", location = TRUE, printProgress = TRUE)

plot(DiagFltRips[["diagram"]])


FUNvalues &lt;- X[, 1] + X[, 2]

FltFun &lt;- funFiltration(FUNvalues = FUNvalues, cmplx = FltRips[["cmplx"]])

DiagFltFun &lt;- filtrationDiag(filtration = FltFun, maxdimension = maxdimension,
                             library = "Dionysus", location = TRUE, printProgress = TRUE)

plot(DiagFltFun[["diagram"]], diagLim = c(-2, 5))
</code></pre>

<hr>
<h2 id='funFiltration'>
Filtration from function values
</h2><span id='topic+funFiltration'></span>

<h3>Description</h3>

<p>The function <code>funFiltration</code> computes the filtration from the complex and the function values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funFiltration(FUNvalues, cmplx, sublevel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funFiltration_+3A_funvalues">FUNvalues</code></td>
<td>

<p>The function values on the vertices of the complex.
</p>
</td></tr>
<tr><td><code id="funFiltration_+3A_cmplx">cmplx</code></td>
<td>

<p>the complex.
</p>
</td></tr>
<tr><td><code id="funFiltration_+3A_sublevel">sublevel</code></td>
<td>

<p>a logical variable indicating if the Persistence Diagram should be computed for sublevel sets (<code>TRUE</code>) or superlevel sets (<code>FALSE</code>) of the function. The default value is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See references.
</p>


<h3>Value</h3>

<p>The function <code>funFiltration</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>cmplx</code></td>
<td>

<p>a list representing the complex. Its i-th element represents the vertices of i-th simplex.
</p>
</td></tr>
<tr><td><code>values</code></td>
<td>

<p>a vector representing the filtration values. Its i-th element represents the filtration value of i-th simplex.
</p>
</td></tr>
<tr><td><code>increasing</code></td>
<td>

<p>a logical variable indicating if the filtration values are in increasing order (<code>TRUE</code>) or in decreasing order (<code>FALSE</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jisu Kim
</p>


<h3>References</h3>

<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filtrationDiag">filtrationDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
X &lt;- cbind(cos(2*pi*seq_len(n)/n), sin(2*pi*seq_len(n)/n))
maxdimension &lt;- 1
maxscale &lt;- 1.5
dist &lt;- "euclidean"
library &lt;- "Dionysus"

FltRips &lt;- ripsFiltration(X = X, maxdimension = maxdimension,
               maxscale = maxscale, dist = "euclidean", library = "Dionysus",
               printProgress = TRUE)

FUNvalues &lt;- X[, 1] + X[, 2]

FltFun &lt;- funFiltration(FUNvalues = FUNvalues, cmplx = FltRips[["cmplx"]])
</code></pre>

<hr>
<h2 id='gridDiag'>
Persistence Diagram of a function over a Grid
</h2><span id='topic+gridDiag'></span>

<h3>Description</h3>

<p>The function <code>gridDiag</code> computes the Persistence Diagram of a filtration of sublevel sets (or superlevel sets) of a function evaluated over a grid of points in arbitrary dimension <code>d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridDiag(
    X = NULL, FUN = NULL, lim = NULL, by = NULL, FUNvalues = NULL,
    maxdimension = max(NCOL(X), length(dim(FUNvalues))) - 1,
    sublevel = TRUE, library = "GUDHI", location = FALSE,
    printProgress = FALSE, diagLimit = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridDiag_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, used by the function <code>FUN</code>, where <code class="reqn">n</code> is the number of points stored in <code>X</code> and <code class="reqn">d</code> is the dimension of the space. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_fun">FUN</code></td>
<td>

<p>a function whose inputs are 1) an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates <code>X</code>, 2) an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates <code>Grid</code>, 3) an optional smoothing parameter, and returns a numeric vector of length <code class="reqn">m</code>. For example see <code><a href="#topic+distFct">distFct</a></code>,  <code><a href="#topic+kde">kde</a></code>, and <code><a href="#topic+dtm">dtm</a></code>  which compute the distance function, the kernel density estimator and the distance to measure, over a grid of points using the input <code>X</code>. Note that <code>Grid</code> is not an input of <code>gridDiag</code>, but is automatically computed by the function using <code>lim</code>, and <code>by</code>. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_lim">lim</code></td>
<td>

<p>a <code class="reqn">2</code> by <code class="reqn">d</code> matrix, where each column specifying the range of each dimension of the grid, over which the function <code>FUN</code> is evaluated. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_by">by</code></td>
<td>

<p>either a number or a vector of length <code class="reqn">d</code> specifying space between points of the grid in each dimension. If a number is given, then same space is used in each dimension. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_funvalues">FUNvalues</code></td>
<td>

<p>an <code class="reqn">m1 * m2 * ... * md</code> array of function values over <code class="reqn">m1 * m2 * ... * md</code> grid, where <code class="reqn">mi</code> is the number of scales of grid on <code class="reqn">ith</code> dimension. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_maxdimension">maxdimension</code></td>
<td>

<p>a number that indicates the maximum dimension of the homological features to compute: <code>0</code> for connected components, <code>1</code> for loops, <code>2</code> for voids and so on. The default value is <code class="reqn">d - 1</code>, which is (dimension of embedding space - 1).
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_sublevel">sublevel</code></td>
<td>

<p>a logical variable indicating if the Persistence Diagram should be computed for sublevel sets (<code>TRUE</code>) or superlevel sets (<code>FALSE</code>) of the function. The default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_library">library</code></td>
<td>

<p>a string specifying which library to compute the persistence diagram. The user can choose either the library <code>"GUDHI"</code>, <code>"Dionysus"</code>, or <code>"PHAT"</code>. The default value is <code>"GUDHI"</code>.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_location">location</code></td>
<td>

<p>if <code>TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram, location of birth point and death point of each homological feature is returned. Additionaly if <code>library="Dionysus"</code>, location of representative cycles of each homological feature is also returned. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code> a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_diaglimit">diagLimit</code></td>
<td>

<p>a number that replaces <code>Inf</code> (if <code>sublevel</code> is <code>TRUE</code>) or <code>-Inf</code> (if <code>sublevel</code> is <code>FALSE</code>) in the Death value of the most persistent connected component. The default value is <code>NULL</code> and the max/min of the function is used.
</p>
</td></tr>
<tr><td><code id="gridDiag_+3A_...">...</code></td>
<td>

<p>additional parameters for the function <code>FUN</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the values of <code>X</code>, <code>FUN</code> are set, then <code>FUNvalues</code> should be <code>NULL</code>. In this case, <code>gridDiag</code> evaluates the function <code>FUN</code> over a grid. If the value of <code>FUNvalues</code> is set, then <code>X</code>, <code>FUN</code> should be <code>NULL</code>. In this case, <code>FUNvalues</code> is used as function values over the grid. If <code>location=TRUE</code>, then <code>lim</code>, and <code>by</code> should be set.
</p>
<p>Once function values are either computed or given, <code>gridDiag</code> constructs a filtration by triangulating the grid and considering the simplices determined by the values of the function of dimension up to <code>maxdimension+1</code>.
</p>


<h3>Value</h3>

<p>The function <code>gridDiag</code> returns a list with the following components:
</p>
<table>
<tr><td><code>diagram</code></td>
<td>

<p>an object of class <code>diagram</code>, a <code class="reqn">P</code> by 3 matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. The first column stores the dimension of each feature (0 for components, 1 for loops, 2 for voids, etc). Second and third columns are Birth and Death of the features, in case of a filtration constructed using sublevel sets (from -Inf to Inf), or Death and Birth of features, in case of a filtration constructed using superlevel sets (from Inf to -Inf).
</p>
</td></tr>
<tr><td><code>birthLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the grid point completing the simplex that gives birth to an homological feature.
</p>
</td></tr>
<tr><td><code>deathLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the grid point completing the simplex that kills an homological feature.
</p>
</td></tr>
<tr><td><code>cycleLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> is used for computing the persistence diagram: a list of length <code class="reqn">P</code>, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each element is a <code class="reqn">P_i</code> by <code class="reqn">h_i +1</code> by <code class="reqn">d</code> array for <code class="reqn">h_i</code> dimensional homological feature. It represents location of <code class="reqn">h_i +1</code> vertices of <code class="reqn">P_i</code> simplices, where <code class="reqn">P_i</code> simplices constitutes the <code class="reqn">h_i</code> dimensional homological feature.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The user can decide to use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>, <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>, or <a href="https://bitbucket.org/phat-code/phat/">PHAT</a>. See references.
</p>
<p>Since dimension of simplicial complex from grid points in <code class="reqn">R^d</code> is up to <code class="reqn">d</code>, homology of dimension <code class="reqn">\ge d</code> is trivial. Hence setting <code>maxdimension</code> with values <code class="reqn">\ge d</code> is equivalent to <code>maxdimension=d-1</code>.
</p>


<h3>Author(s)</h3>

<p>Brittany T. Fasy, Jisu Kim, and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Fasy B, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). &quot;Statistical Inference For Persistent Homology.&quot; (arXiv:1303.7117). Annals of Statistics.
</p>
<p>Morozov D (2007). &quot;Dionysus, a C++ library for computing persistent homology.&quot; <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>
</p>
<p>Bauer U, Kerber M, Reininghaus J (2012). &quot;PHAT, a software library for persistent homology.&quot; <a href="https://bitbucket.org/phat-code/phat/">https://bitbucket.org/phat-code/phat/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.diagram">summary.diagram</a></code>, <code><a href="#topic+plot.diagram">plot.diagram</a></code>,
<code><a href="#topic+distFct">distFct</a></code>, <code><a href="#topic+kde">kde</a></code>, <code><a href="#topic+kernelDist">kernelDist</a></code>, <code><a href="#topic+dtm">dtm</a></code>,
<code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+ripsDiag">ripsDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Distance Function Diagram and Kernel Density Diagram

# input data
n &lt;- 300
XX &lt;- circleUnif(n)

## Ranges of the grid
Xlim &lt;- c(-1.8, 1.8)
Ylim &lt;- c(-1.6, 1.6)
lim &lt;- cbind(Xlim, Ylim)
by &lt;- 0.05

h &lt;- .3  #bandwidth for the function kde

#Distance Function Diagram of the sublevel sets
Diag1 &lt;- gridDiag(XX, distFct, lim = lim, by = by, sublevel = TRUE,
                  printProgress = TRUE) 

#Kernel Density Diagram of the superlevel sets
Diag2 &lt;- gridDiag(XX, kde, lim = lim, by = by, sublevel = FALSE,
    library = "Dionysus", location = TRUE, printProgress = TRUE, h = h)
#plot
par(mfrow = c(2, 2))
plot(XX, cex = 0.5, pch = 19)
title(main = "Data")
plot(Diag1[["diagram"]])
title(main = "Distance Function Diagram")
plot(Diag2[["diagram"]])
title(main = "Density Persistence Diagram")
one &lt;- which(Diag2[["diagram"]][, 1] == 1)
plot(XX, col = 2, main = "Representative loop of grid points")
for (i in seq(along = one)) {
  points(Diag2[["birthLocation"]][one[i], , drop = FALSE], pch = 15, cex = 3,
      col = i)
  points(Diag2[["deathLocation"]][one[i], , drop = FALSE], pch = 17, cex = 3,
      col = i)
  for (j in seq_len(dim(Diag2[["cycleLocation"]][[one[i]]])[1])) {
    lines(Diag2[["cycleLocation"]][[one[i]]][j, , ], pch = 19, cex = 1, col = i)
  }
}
</code></pre>

<hr>
<h2 id='gridFiltration'>
Persistence Diagram of a function over a Grid
</h2><span id='topic+gridFiltration'></span>

<h3>Description</h3>

<p>The function <code>gridFiltration</code> computes the Persistence Diagram of a filtration of sublevel sets (or superlevel sets) of a function evaluated over a grid of points in arbitrary dimension <code>d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridFiltration(
    X = NULL, FUN = NULL, lim = NULL, by = NULL, FUNvalues = NULL,
    maxdimension = max(NCOL(X), length(dim(FUNvalues))) - 1,
    sublevel = TRUE, printProgress = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridFiltration_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, used by the function <code>FUN</code>, where <code class="reqn">n</code> is the number of points stored in <code>X</code> and <code class="reqn">d</code> is the dimension of the space. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridFiltration_+3A_fun">FUN</code></td>
<td>

<p>a function whose inputs are 1) an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates <code>X</code>, 2) an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates <code>Grid</code>, 3) an optional smoothing parameter, and returns a numeric vector of length <code class="reqn">m</code>. For example see <code><a href="#topic+distFct">distFct</a></code>,  <code><a href="#topic+kde">kde</a></code>, and <code><a href="#topic+dtm">dtm</a></code>  which compute the distance function, the kernel density estimator and the distance to measure, over a grid of points using the input <code>X</code>. Note that <code>Grid</code> is not an input of <code>gridFiltration</code>, but is automatically computed by the function using <code>lim</code>, and <code>by</code>. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridFiltration_+3A_lim">lim</code></td>
<td>

<p>a <code class="reqn">2</code> by <code class="reqn">d</code> matrix, where each column specifying the range of each dimension of the grid, over which the function <code>FUN</code> is evaluated. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridFiltration_+3A_by">by</code></td>
<td>

<p>either a number or a vector of length <code class="reqn">d</code> specifying space between points of the grid in each dimension. If a number is given, then same space is used in each dimension. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridFiltration_+3A_funvalues">FUNvalues</code></td>
<td>

<p>an <code class="reqn">m1 * m2 * ... * md</code> array of function values over <code class="reqn">m1 * m2 * ... * md</code> grid, where <code class="reqn">mi</code> is the number of scales of grid on <code class="reqn">ith</code> dimension. NULL if this option is not used. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gridFiltration_+3A_maxdimension">maxdimension</code></td>
<td>

<p>a number that indicates the maximum dimension of the homological features to compute: <code>0</code> for connected components, <code>1</code> for loops, <code>2</code> for voids and so on. The default value is <code class="reqn">d - 1</code>, which is (dimension of embedding space - 1).
</p>
</td></tr>
<tr><td><code id="gridFiltration_+3A_sublevel">sublevel</code></td>
<td>

<p>a logical variable indicating if the Persistence Diagram should be computed for sublevel sets (<code>TRUE</code>) or superlevel sets (<code>FALSE</code>) of the function. The default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gridFiltration_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code> a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gridFiltration_+3A_...">...</code></td>
<td>

<p>additional parameters for the function <code>FUN</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the values of <code>X</code>, <code>FUN</code> are set, then <code>FUNvalues</code> should be <code>NULL</code>. In this case, <code>gridFiltration</code> evaluates the function <code>FUN</code> over a grid. If the value of <code>FUNvalues</code> is set, then <code>X</code>, <code>FUN</code> should be <code>NULL</code>. In this case, <code>FUNvalues</code> is used as function values over the grid.
</p>
<p>Once function values are either computed or given, <code>gridFiltration</code> constructs a filtration by triangulating the grid and considering the simplices determined by the values of the function of dimension up to <code>maxdimension+1</code>.
</p>


<h3>Value</h3>

<p>The function <code>gridFiltration</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>cmplx</code></td>
<td>

<p>a list representing the complex. Its i-th element represents the vertices of i-th simplex.
</p>
</td></tr>
<tr><td><code>values</code></td>
<td>

<p>a vector representing the filtration values. Its i-th element represents the filtration value of i-th simplex.
</p>
</td></tr>
<tr><td><code>increasing</code></td>
<td>

<p>a logical variable indicating if the filtration values are in increasing order (<code>TRUE</code>) or in decreasing order (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code>coordinates</code></td>
<td>

<p>only if both <code>lim</code> and <code>by</code> are not <code>NULL</code>: a matrix representing the coordinates of vertices. Its i-th row represents the coordinate of i-th vertex.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The user can decide to use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>, <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>, or <a href="https://bitbucket.org/phat-code/phat/">PHAT</a>. See references.
</p>
<p>Since dimension of simplicial complex from grid points in <code class="reqn">R^d</code> is up to <code class="reqn">d</code>, homology of dimension <code class="reqn">\ge d</code> is trivial. Hence setting <code>maxdimension</code> with values <code class="reqn">\ge d</code> is equivalent to <code>maxdimension=d-1</code>.
</p>


<h3>Author(s)</h3>

<p>Brittany T. Fasy, Jisu Kim, and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Fasy B, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). &quot;Statistical Inference For Persistent Homology.&quot; (arXiv:1303.7117). Annals of Statistics.
</p>
<p>Morozov D (2007). &quot;Dionysus, a C++ library for computing persistent homology.&quot; <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>
</p>
<p>Bauer U, Kerber M, Reininghaus J (2012). &quot;PHAT, a software library for persistent homology.&quot; <a href="https://bitbucket.org/phat-code/phat/">https://bitbucket.org/phat-code/phat/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.diagram">summary.diagram</a></code>, <code><a href="#topic+plot.diagram">plot.diagram</a></code>,
<code><a href="#topic+distFct">distFct</a></code>, <code><a href="#topic+kde">kde</a></code>, <code><a href="#topic+kernelDist">kernelDist</a></code>, <code><a href="#topic+dtm">dtm</a></code>,
<code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+ripsDiag">ripsDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># input data
n &lt;- 10
XX &lt;- circleUnif(n)

## Ranges of the grid
Xlim &lt;- c(-1, 1)
Ylim &lt;- c(-1, 1)
lim &lt;- cbind(Xlim, Ylim)
by &lt;- 1

#Distance Function Diagram of the sublevel sets
FltGrid &lt;- gridFiltration(
  XX, distFct, lim = lim, by = by, sublevel = TRUE, printProgress = TRUE) 

</code></pre>

<hr>
<h2 id='hausdInterval'>
Subsampling Confidence Interval for the Hausdorff Distance between a Manifold and a Sample
</h2><span id='topic+hausdInterval'></span>

<h3>Description</h3>

<p><code>hausdInterval</code> computes a confidence interval for the Hausdorff distance between a point cloud <code>X</code> and the underlying manifold from which <code>X</code> was sampled. See Details and References.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hausdInterval(
    X, m, B = 30, alpha = 0.05, parallel = FALSE,
    printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hausdInterval_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates of sampled points.
</p>
</td></tr>
<tr><td><code id="hausdInterval_+3A_m">m</code></td>
<td>

<p>the size of the subsamples.
</p>
</td></tr>
<tr><td><code id="hausdInterval_+3A_b">B</code></td>
<td>

<p>the number of subsampling iterations. The default value is <code>30</code>.
</p>
</td></tr>
<tr><td><code id="hausdInterval_+3A_alpha">alpha</code></td>
<td>

<p><code>hausdInterval</code> returns a (<code>1-alpha</code>) confidence interval. The default value is <code>0.05</code>.
</p>
</td></tr>
<tr><td><code id="hausdInterval_+3A_parallel">parallel</code></td>
<td>

<p>logical: if <code>TRUE</code>, the iterations are parallelized, using the library <code>parallel</code>. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="hausdInterval_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>B</code> times, the subsampling algorithm subsamples <code>m</code> points of <code>X</code> (without replacement) and computes the Hausdorff distance between the original sample <code>X</code> and the subsample. The result is a sequence of <code>B</code> values. Let <code class="reqn">q</code> be the (<code>1-alpha</code>) quantile of these values and let <code class="reqn">c = 2 * q</code>. The interval <code class="reqn">[0, c]</code> is a valid  (<code>1-alpha</code>) confidence interval for the Hausdorff distance between <code>X</code> and the underlying manifold, as proven in (Fasy, Lecci, Rinaldo, Wasserman, Balakrishnan, and Singh, 2013, Theorem 3).
</p>


<h3>Value</h3>

 
<p>The function <code>hausdInterval</code> returns a number <code class="reqn">c</code>. The confidence interval is <code class="reqn">[0, c]</code>. 
</p>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>References</h3>

<p>Fasy BT, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). &quot;Statistical Inference For Persistent Homology: Confidence Sets for Persistence Diagrams.&quot; (arXiv:1303.7117). Annals of Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootstrapBand">bootstrapBand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- circleUnif(1000)
interval &lt;- hausdInterval(X, m = 800)
print(interval)
</code></pre>

<hr>
<h2 id='kde'>
Kernel Density Estimator over a Grid of Points
</h2><span id='topic+kde'></span>

<h3>Description</h3>

<p>Given a point cloud <code>X</code> (<code class="reqn">n</code> points), the function <code>kde</code> computes the Kernel Density Estimator over a grid of points. The kernel is a Gaussian Kernel with smoothing parameter <code>h</code>. For each <code class="reqn">x \in R^d</code>, the Kernel Density estimator is defined as
</p>
<p style="text-align: center;"><code class="reqn">
    p_X (x) = \frac{1}{n (\sqrt{2 \pi} h )^d} \sum_{i=1}^n \exp \left( \frac{- \Vert x-X_i \Vert_2^2}{2h^2} \right).
  </code>
</p>
   


<h3>Usage</h3>

<pre><code class='language-R'>kde(X, Grid, h, kertype = "Gaussian", weight = 1,
    printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kde_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates of points used in the kernel density estimation process, where <code class="reqn">n</code> is the number of points and <code class="reqn">d</code> is the dimension.
</p>
</td></tr>
<tr><td><code id="kde_+3A_grid">Grid</code></td>
<td>

<p>an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates, where <code class="reqn">m</code> is the number of points in the grid.
</p>
</td></tr>
<tr><td><code id="kde_+3A_h">h</code></td>
<td>

<p>number: the smoothing paramter of the Gaussian Kernel.
</p>
</td></tr>
<tr><td><code id="kde_+3A_kertype">kertype</code></td>
<td>

<p>string: if <code>kertype = "Gaussian"</code>, Gaussian kernel is used, and if <code>kertype = "Epanechnikov"</code>, Epanechnikov kernel is used. Defaults to <code>"Gaussian"</code>.
</p>
</td></tr>
<tr><td><code id="kde_+3A_weight">weight</code></td>
<td>

<p>either a number, or a vector of length <code class="reqn">n</code>. If it is a number, then same weight is applied to each points of <code>X</code>. If it is a vector, <code>weight</code> represents weights of each points of <code>X</code>. The default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="kde_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>kde</code> returns a vector of length <code class="reqn">m</code> (the number of points in the grid) containing the value of the kernel density estimator for each point in the grid.
</p>


<h3>Author(s)</h3>

<p>Jisu Kim and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Larry Wasserman (2004), &quot;All of statistics: a concise course in statistical inference&quot;, Springer.
</p>
<p>Brittany T. Fasy, Fabrizio Lecci, Alessandro Rinaldo, Larry Wasserman, Sivaraman Balakrishnan, and Aarti Singh. (2013), &quot;Statistical Inference For Persistent Homology: Confidence Sets for Persistence Diagrams&quot;, (arXiv:1303.7117). To appear, Annals of Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernelDist">kernelDist</a></code>, <code><a href="#topic+distFct">distFct</a></code>, <code><a href="#topic+dtm">dtm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate Data from the unit circle
n &lt;- 300
X &lt;- circleUnif(n)

## Construct a grid of points over which we evaluate the function
by &lt;- 0.065
Xseq &lt;- seq(-1.6, 1.6, by=by)
Yseq &lt;- seq(-1.7, 1.7, by=by)
Grid &lt;- expand.grid(Xseq,Yseq)

## kernel density estimator
h &lt;- 0.3
KDE &lt;- kde(X, Grid, h)
</code></pre>

<hr>
<h2 id='kernelDist'>
Kernel distance over a Grid of Points
</h2><span id='topic+kernelDist'></span>

<h3>Description</h3>

<p>Given a point cloud <code>X</code>, the function <code>kernelDist</code> computes the kernel distance over a grid of points. The kernel is a Gaussian Kernel with smoothing parameter h:
</p>
<p style="text-align: center;"><code class="reqn">
    K_h(x,y)=\exp\left( \frac{- \Vert x-y \Vert_2^2}{2h^2} \right).
  </code>
</p>

<p>For each <code class="reqn">x \in R^d</code>, the Kernel distance is defined by
</p>
<p style="text-align: center;"><code class="reqn">
    \kappa_X(x)=\sqrt{ \frac{1}{n^2} \sum_{i=1}^n\sum_{j=1}^n K_h(X_i, X_j) + K_h(x,x) - 2 \frac{1}{n} \sum_{i=1}^n K_h(x,X_i)  }. 
  </code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>kernelDist(X, Grid, h, weight = 1, printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernelDist_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates of points, where <code class="reqn">n</code> is the number of points and <code class="reqn">d</code> is the dimension.
</p>
</td></tr>
<tr><td><code id="kernelDist_+3A_grid">Grid</code></td>
<td>

<p>an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates, where <code class="reqn">m</code> is the number of points in the grid.
</p>
</td></tr>
<tr><td><code id="kernelDist_+3A_h">h</code></td>
<td>

<p>number: the smoothing paramter of the Gaussian Kernel.
</p>
</td></tr>
<tr><td><code id="kernelDist_+3A_weight">weight</code></td>
<td>

<p>either a number, or a vector of length <code class="reqn">n</code>. If it is a number, then same weight is applied to each points of <code>X</code>. If it is a vector, <code>weight</code> represents weights of each points of <code>X</code>. The default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="kernelDist_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>kernelDist</code> returns a vector of lenght <code class="reqn">m</code> (the number of points in the grid) containing the value of the Kernel distance for each point in the grid.
</p>


<h3>Author(s)</h3>

<p>Jisu Kim and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Phillips JM, Wang B, Zheng Y (2013). &quot;Geometric Inference on Kernel Density Estimates.&quot; arXiv:1307.7760.
</p>
<p>Chazal F, Fasy BT, Lecci F, Michel B, Rinaldo A, Wasserman L (2014). &quot;Robust Topological Inference: Distance-To-a-Measure and Kernel Distance.&quot; Technical Report. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kde">kde</a></code>, <code><a href="#topic+dtm">dtm</a></code>, <code><a href="#topic+distFct">distFct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate Data from the unit circle
n &lt;- 300
X &lt;- circleUnif(n)

## Construct a grid of points over which we evaluate the functions
by &lt;- 0.065
Xseq &lt;- seq(-1.6, 1.6, by = by)
Yseq &lt;- seq(-1.7, 1.7, by = by)
Grid &lt;- expand.grid(Xseq, Yseq)

## kernel distance estimator
h &lt;- 0.3
Kdist &lt;- kernelDist(X, Grid, h)
</code></pre>

<hr>
<h2 id='knnDE'>
k Nearest Neighbors Density Estimator over a Grid of Points
</h2><span id='topic+knnDE'></span>

<h3>Description</h3>

<p>Given a point cloud <code>X</code> (<code class="reqn">n</code> points), The function <code>knnDE</code> computes the k Nearest Neighbors Density Estimator over a grid of points. For each <code class="reqn">x \in R^d</code>, the knn Density Estimator is defined by
</p>
<p style="text-align: center;"><code class="reqn">
    p_X(x)=\frac{k}{n \; v_d \; r_k^d(x)},
  </code>
</p>

<p>where <code class="reqn">v_n</code> is the volume of the Euclidean <code class="reqn">d</code> dimensional unit ball and <code class="reqn">r_k^d(x)</code> is the Euclidean distance from point x to its <code class="reqn">k</code>'th closest neighbor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knnDE(X, Grid, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knnDE_+3A_x">X</code></td>
<td>

<p>an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates of points used in the density estimation process, where <code class="reqn">n</code> is the number of points and <code class="reqn">d</code> is the dimension.
</p>
</td></tr>
<tr><td><code id="knnDE_+3A_grid">Grid</code></td>
<td>

<p>an <code class="reqn">m</code> by <code class="reqn">d</code> matrix of coordinates, where <code class="reqn">m</code> is the number of points in the grid.
</p>
</td></tr>
<tr><td><code id="knnDE_+3A_k">k</code></td>
<td>

<p>number: the smoothing paramter of the k Nearest Neighbors Density Estimator.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>knnDE</code> returns a vector of length <code class="reqn">m</code> (the number of points in the grid) containing the value of the knn Density Estimator for each point in the grid.
</p>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kde">kde</a></code>, <code><a href="#topic+kernelDist">kernelDist</a></code>, <code><a href="#topic+distFct">distFct</a></code>, <code><a href="#topic+dtm">dtm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate Data from the unit circle
n &lt;- 300
X &lt;- circleUnif(n)

## Construct a grid of points over which we evaluate the function
by &lt;- 0.065
Xseq &lt;- seq(-1.6, 1.6, by = by)
Yseq &lt;- seq(-1.7, 1.7, by = by)
Grid &lt;- expand.grid(Xseq, Yseq)

## kernel density estimator
k &lt;- 50
KNN &lt;- knnDE(X, Grid, k)
</code></pre>

<hr>
<h2 id='landscape'>
The Persistence Landscape Function
</h2><span id='topic+landscape'></span>

<h3>Description</h3>

<p>The function <code>landscape</code> computes the landscape function corresponding to a given persistence diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscape(
    Diag, dimension = 1, KK = 1,
    tseq = seq(min(Diag[,2:3]), max(Diag[,2:3]), length=500))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landscape_+3A_diag">Diag</code></td>
<td>

<p>an object of class <code>diagram</code> or a <code class="reqn">P</code> by <code class="reqn">3</code> matrix, storing a persistence diagram with colnames: &quot;dimension&quot;, &quot;Birth&quot;, &quot;Death&quot;. 
</p>
</td></tr>
<tr><td><code id="landscape_+3A_dimension">dimension</code></td>
<td>

<p>the dimension of the topological features under consideration. The default value is <code>1</code> (loops).
</p>
</td></tr>
<tr><td><code id="landscape_+3A_kk">KK</code></td>
<td>

<p>a vector: the order of the landscape function. The default value is <code>1</code>. (First Landscape function).
</p>
</td></tr>
<tr><td><code id="landscape_+3A_tseq">tseq</code></td>
<td>

<p>a vector of values at which the landscape function is evaluated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>landscape</code> returns a numeric matrix with the number of row as the length of <code>tseq</code> and the number of column as the length of <code>KK</code>. The value at ith row and jth column represents the value of the <code>KK[j]</code>-th landscape function evaluated at <code>tseq[i]</code>.
</p>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>References</h3>

<p>Bubenik P (2012). &quot;Statistical topology using persistence landscapes.&quot; arXiv:1207.6437.
</p>
<p>Chazal F, Fasy BT, Lecci F, Rinaldo A, Wasserman L (2014). &quot;Stochastic Convergence of Persistence Landscapes and Silhouettes.&quot; Proceedings of the 30th Symposium of Computational Geometry (SoCG). (arXiv:1312.0308)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+silhouette">silhouette</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Diag &lt;- matrix(c(0, 0, 10, 1, 0, 3, 1, 3, 8), ncol = 3, byrow = TRUE)
DiagLim &lt;- 10
colnames(Diag) &lt;- c("dimension", "Birth", "Death")

#persistence landscape
tseq &lt;- seq(0,DiagLim, length = 1000)
Land &lt;- landscape(Diag, dimension = 1, KK = 1, tseq)

par(mfrow = c(1,2))
plot.diagram(Diag)
plot(tseq, Land, type = "l", xlab = "t", ylab = "landscape", asp = 1)
</code></pre>

<hr>
<h2 id='maxPersistence'>
Maximal Persistence Method
</h2><span id='topic+maxPersistence'></span><span id='topic+print.maxPersistence'></span><span id='topic+summary.maxPersistence'></span><span id='topic+print.summary.maxPersistence'></span>

<h3>Description</h3>

<p>Given a point cloud and a function built on top of the data, we are interested in studying the evolution of the sublevel sets (or superlevel sets) of the function, using persistent homology. The Maximal Persistence Method selects the optimal smoothing parameter of the function, by maximizing the number of significant topological features, or by maximizing the total significant persistence of the features. For each value of the smoothing parameter, the function <code>maxPersistence</code> computes a persistence diagram using <code>gridDiag</code> and returns the values of the two criteria, the dimension of detected features, their persistence, and a bootstrapped confidence band. The features that fall outside of the band are statistically significant. See References. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxPersistence(
    FUN, parameters, X, lim, by,
    maxdimension = length(lim) / 2 - 1, sublevel = TRUE,
    library = "GUDHI", B = 30, alpha = 0.05,
    bandFUN = "bootstrapBand", distance = "bottleneck",
    dimension = min(1, maxdimension), p = 1, parallel = FALSE,
    printProgress = FALSE, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxPersistence_+3A_fun">FUN</code></td>
<td>

<p>the name of a function whose inputs are: 1) <code>X</code>, a <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates of the input point cloud, where <code class="reqn">d</code> is the dimension of the space; 2) a matrix of coordinates of points forming a grid at which the function can be evaluated (note that this grid is not passed as an input, but is automatically computed by <code>maxPersistence</code>); 3) a real valued smoothing parameter. For example, see <code><a href="#topic+kde">kde</a></code>, <code><a href="#topic+dtm">dtm</a></code>, <code><a href="#topic+kernelDist">kernelDist</a></code>.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_parameters">parameters</code></td>
<td>

<p>a numerical vector, storing a sequence of values for the smoothing paramter of <code>FUN</code> among which <code>maxPersistence</code> will select the optimal ones.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_x">X</code></td>
<td>

<p>a <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates of the input point cloud, where <code class="reqn">d</code> is the dimension of the space.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_lim">lim</code></td>
<td>

<p>a <code class="reqn">2</code> by <code class="reqn">d</code> matrix, where each column specifying the range of each dimension of the grid, over which the function <code>FUN</code> is evaluated.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_by">by</code></td>
<td>

<p>either a number or a vector of length <code class="reqn">d</code> specifying space between points of the grid in each dimension. If a number is given, then same space is used in each dimension.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_maxdimension">maxdimension</code></td>
<td>

<p>a number that indicates the maximum dimension to compute persistent homology to. The default value is <code class="reqn">d - 1</code>, which is (dimension of embedding space - 1).
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_sublevel">sublevel</code></td>
<td>

<p>a logical variable indicating if the persistent homology should be computed for sublevel sets of <code>FUN</code> (<code>TRUE</code>) or superlevel sets (<code>FALSE</code>). The default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_library">library</code></td>
<td>

<p>a string specifying which library to compute the persistence diagram. The user can choose either the library <code>"GUDHI"</code>, <code>"Dionysus"</code>, or <code>"PHAT"</code>. The default value is <code>"GUDHI"</code>.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_bandfun">bandFUN</code></td>
<td>

<p>the function to be used in the computation of the confidence band. Either <code>"bootstrapDiagram"</code> or <code>"bootstrapBand"</code>.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_b">B</code></td>
<td>

<p>the number of bootstrap iterations.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_alpha">alpha</code></td>
<td>

<p>for each value store in <code>parameters</code>, <code>maxPersistence</code> computes a (<code>1-alpha</code>) confidence band.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_distance">distance</code></td>
<td>

<p>optional (if bandFUN == bootstrapDiagram): a string specifying the distance to be used for persistence diagrams: either <code>"bottleneck"</code> or <code>"wasserstein"</code>
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_dimension">dimension</code></td>
<td>

<p>optional (if bandFUN == bootstrapDiagram): an integer or a vector specifying the dimension of the features used to compute the bottleneck distance. 0 for connected components, 1 for loops, 2 for voids. The default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_p">p</code></td>
<td>

<p>optional (if bandFUN == bootstrapDiagram AND distance == &quot;wasserstein&quot;): integer specifying the power to be used in the computation of the Wasserstein distance. The default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_parallel">parallel</code></td>
<td>

<p>logical: if <code>TRUE</code>, the bootstrap iterations are parallelized, using the library <code>parallel</code>.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_printprogress">printProgress</code></td>
<td>

<p>if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="maxPersistence_+3A_weight">weight</code></td>
<td>

<p>either NULL, a number, or a vector of length <code class="reqn">n</code>. If it is NULL, weight is not used. If it is a number, then same weight is applied to each points of <code>X</code>. If it is a vector, <code>weight</code> represents weights of each points of <code>X</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>maxPersistence</code> calls the <code><a href="#topic+gridDiag">gridDiag</a></code> function, which computes the persistence diagram of sublevel (or superlevel) sets of a function, evaluated over a grid of points.
</p>


<h3>Value</h3>

<p>The function <code>maxPersistence</code> returns an object of the class &quot;maxPersistence&quot;, a list with the following components
</p>
<table>
<tr><td><code>parameters</code></td>
<td>

<p>the same vector <code>parameters</code> given in input
</p>
</td></tr>
<tr><td><code>sigNumber</code></td>
<td>

<p>a numeric vector storing the number of significant features in the persistence diagrams computed using each value in <code>parameters</code>
</p>
</td></tr>
<tr><td><code>sigPersistence</code></td>
<td>

<p>a numeric vector storing the sum of significant persistence of the features in the persistence diagrams, computed using each value in <code>parameters</code>
</p>
</td></tr>
<tr><td><code>bands</code></td>
<td>

<p>a numeric vector storing the bootstrap band's width, for each value in <code>parameters</code>
</p>
</td></tr>
<tr><td><code>Persistence</code></td>
<td>

<p>a list of the same lenght of <code>parameters</code>. Each element of the list is a <code class="reqn">P_i</code> by 2 matrix, where <code class="reqn">P_i</code> is the number of features found using the parameter <code class="reqn">i</code>: the first column stores the dimension of each feature and the second column the persistence abs(death-birth|).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jisu Kim and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Chazal F, Cisewski J, Fasy BT, Lecci F, Michel B, Rinaldo A, Wasserman L (2014). &quot;Robust Topological Inference: distance-to-a-measure and kernel distance.&quot;
</p>
<p>Fasy BT, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). &quot;Statistical Inference For Persistent Homology&quot;, (arXiv:1303.7117). Annals of Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gridDiag">gridDiag</a></code>, <code><a href="#topic+kde">kde</a></code>, <code><a href="#topic+kernelDist">kernelDist</a></code>, <code><a href="#topic+dtm">dtm</a></code>, <code><a href="#topic+bootstrapBand">bootstrapBand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## input data: circle with clutter noise
n &lt;- 600
percNoise &lt;- 0.1
XX1 &lt;- circleUnif(n)
noise &lt;- cbind(runif(percNoise * n, -2, 2), runif(percNoise * n, -2, 2))
X &lt;- rbind(XX1, noise)

## limits of the Gird at which the density estimator is evaluated
Xlim &lt;- c(-2, 2)
Ylim &lt;- c(-2, 2)
lim &lt;- cbind(Xlim, Ylim)
by &lt;- 0.2

B &lt;- 80
alpha &lt;- 0.05

## candidates
parametersKDE &lt;- seq(0.1, 0.5, by = 0.2)

maxKDE &lt;- maxPersistence(kde, parametersKDE, X, lim = lim, by = by,
                         bandFUN = "bootstrapBand", B = B, alpha = alpha,
                         parallel = FALSE, printProgress = TRUE)
print(summary(maxKDE))

par(mfrow = c(1,2))
plot(X, pch = 16, cex = 0.5, main = "Circle")
plot(maxKDE)
</code></pre>

<hr>
<h2 id='multipBootstrap'>
Multiplier Bootstrap for Persistence Landscapes and Silhouettes
</h2><span id='topic+multipBootstrap'></span>

<h3>Description</h3>

<p>The function <code>multipBootstrap</code> computes a confidence band for the average landscape (or the average silhouette) using the multiplier bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipBootstrap(
    Y, B = 30, alpha = 0.05, parallel = FALSE,
    printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multipBootstrap_+3A_y">Y</code></td>
<td>

<p>an <code class="reqn">N</code> by <code class="reqn">m</code> matrix of values of <code class="reqn">N</code> persistence landscapes (or silhouettes) evaluated over a 1 dimensional grid of length <code class="reqn">m</code>.
</p>
</td></tr>
<tr><td><code id="multipBootstrap_+3A_b">B</code></td>
<td>

<p>the number of bootstrap iterations.
</p>
</td></tr>
<tr><td><code id="multipBootstrap_+3A_alpha">alpha</code></td>
<td>

<p><code>multipBootstrap</code> returns a 1-<code>alpha</code> confidence band for the mean landscape (or silhouette).
</p>
</td></tr>
<tr><td><code id="multipBootstrap_+3A_parallel">parallel</code></td>
<td>

<p>logical: if <code>TRUE</code> the bootstrap iterations are parallelized, using the library <code>parallel</code>.
</p>
</td></tr>
<tr><td><code id="multipBootstrap_+3A_printprogress">printProgress</code></td>
<td>

<p>logical: if <code>TRUE</code> a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Algorithm 1 in the reference.
</p>


<h3>Value</h3>

<p>The function <code>multipBootstrap</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>width</code></td>
<td>

<p>number: half of the width of the unfiorm confidence band; that is, the distance of the upper and lower limits of the band from the empirical average landscape (or silhouette).
</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>

<p>a numeric vector of length <code class="reqn">m</code>, storing the values of the empirical average landscape (or silhouette) over a 1 dimensional grid of length <code class="reqn">m</code>.
</p>
</td></tr>
<tr><td><code>band</code></td>
<td>

<p>an <code class="reqn">m</code> by 2 matrix that stores the values of the lower limit of the confidence band (first column) and upper limit of the confidence band (second column), evaluated over a 1 dimensional grid of length <code class="reqn">m</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>References</h3>

<p>Chazal F, Fasy BT, Lecci F, Rinaldo A, Wasserman L (2014). &quot;Stochastic Convergence of Persistence Landscapes and Silhouettes.&quot; Proceedings of the 30th Symposium of Computational Geometry (SoCG). (arXiv:1312.0308)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landscape">landscape</a></code>, <code><a href="#topic+silhouette">silhouette</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nn &lt;- 3000  #large sample size
mm &lt;- 50    #small subsample size
NN &lt;- 5     #we will compute NN diagrams using subsamples of size mm

XX &lt;- circleUnif(nn)  ## large sample from the unit circle

DiagLim &lt;- 2
maxdimension &lt;- 1
tseq &lt;- seq(0, DiagLim, length = 1000)

Diags &lt;- list()  #here we will store the NN rips diagrams
                 #constructed using different subsamples of mm points
#here we'll store the landscapes
Lands &lt;- matrix(0, nrow = NN, ncol = length(tseq))

for (i in seq_len(NN)){
  subXX &lt;- XX[sample(seq_len(nn), mm), ]
  Diags[[i]] &lt;- ripsDiag(subXX, maxdimension, DiagLim)
  Lands[i, ] &lt;- landscape(Diags[[i]][["diagram"]], dimension = 1, KK = 1, tseq)
}

## now we use the NN landscapes to construct a confidence band
B &lt;- 50
alpha &lt;- 0.05
boot &lt;- multipBootstrap(Lands, B, alpha)

LOWband &lt;- boot[["band"]][, 1]
UPband &lt;- boot[["band"]][, 2]
MeanLand &lt;- boot[["mean"]]

plot(tseq, MeanLand, type = "l", lwd = 2, xlab = "", ylab = "",
     main = "Mean Landscape with band", ylim = c(0, 1.2))
polygon(c(tseq, rev(tseq)), c(LOWband, rev(UPband)), col = "pink")
lines(tseq, MeanLand, lwd = 1, col = 2)
</code></pre>

<hr>
<h2 id='plot.clusterTree'>
Plots the Cluster Tree
</h2><span id='topic+plot.clusterTree'></span>

<h3>Description</h3>

<p>The function <code>plot.clusterTree</code> plots the Cluster Tree stored in an object of class <code>clusterTree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clusterTree'
plot(
    x, type = "lambda", color = NULL, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.clusterTree_+3A_x">x</code></td>
<td>

<p>an object of class <code>clusterTree</code>. (see <code><a href="#topic+clusterTree">clusterTree</a></code>)
</p>
</td></tr>
<tr><td><code id="plot.clusterTree_+3A_type">type</code></td>
<td>

<p>string: if &quot;lambda&quot;, then the lambda Tree is plotted.
if &quot;r&quot;, then the r Tree is plotted.
if &quot;alpha&quot;, then the alpha Tree is plotted.
if &quot;kappa&quot;, then the kappa Tree is plotted.
</p>
</td></tr>
<tr><td><code id="plot.clusterTree_+3A_color">color</code></td>
<td>

<p>number: the color of the branches of the Cluster Tree. The default value is <code>NULL</code> and a different color is assigned to each branch.
</p>
</td></tr>
<tr><td><code id="plot.clusterTree_+3A_add">add</code></td>
<td>

<p>logical: if <code>TRUE</code>, the Tree is added to an existing plot.
</p>
</td></tr>
<tr><td><code id="plot.clusterTree_+3A_...">...</code></td>
<td>

<p>additional graphical parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>References</h3>

<p>Kent BP, Rinaldo A, Verstynen T (2013). &quot;DeBaCl: A Python Package for Interactive DEnsity-BAsed CLustering.&quot; arXiv:1307.8136 
</p>
<p>Lecci F, Rinaldo A, Wasserman L (2014). &quot;Metric Embeddings for Cluster Trees&quot;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusterTree">clusterTree</a></code>, <code><a href="#topic+print.clusterTree">print.clusterTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate data: 3 clusters
n &lt;- 1200  #sample size
Neach &lt;- floor(n / 4) 
X1 &lt;- cbind(rnorm(Neach, 1, .8), rnorm(Neach, 5, 0.8))
X2 &lt;- cbind(rnorm(Neach, 3.5, .8), rnorm(Neach, 5, 0.8))
X3 &lt;- cbind(rnorm(Neach, 6, 1), rnorm(Neach, 1, 1))
XX &lt;- rbind(X1, X2, X3)

k &lt;- 100   #parameter of knn

## Density clustering using knn and kde
Tree &lt;- clusterTree(XX, k, density = "knn")
TreeKDE &lt;- clusterTree(XX,k, h = 0.3, density = "kde")

par(mfrow = c(2, 3))
plot(XX, pch = 19, cex = 0.6)
# plot lambda trees
plot(Tree, type = "lambda", main = "lambda Tree (knn)")
plot(TreeKDE, type = "lambda", main = "lambda Tree (kde)")
# plot clusters
plot(XX, pch = 19, cex = 0.6, main = "cluster labels")
for (i in Tree[["id"]]){
  points(matrix(XX[Tree[["DataPoints"]][[i]], ], ncol = 2), col = i, pch = 19,
         cex = 0.6)
}
#plot kappa trees
plot(Tree, type = "kappa", main = "kappa Tree (knn)")
plot(TreeKDE, type = "kappa", main = "kappa Tree (kde)")
</code></pre>

<hr>
<h2 id='plot.diagram'>
Plot the Persistence Diagram
</h2><span id='topic+plot.diagram'></span>

<h3>Description</h3>

<p>The function <code>plot.diagram</code> plots the Persistence Diagram stored in an object of class <code>diagram</code>. Optionally, it can also represent the diagram as a persistence barcode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diagram'
plot(
    x, diagLim = NULL, dimension = NULL, col = NULL,
    rotated = FALSE, barcode = FALSE, band = NULL, lab.line = 2.2,
    colorBand = "pink", colorBorder = NA, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.diagram_+3A_x">x</code></td>
<td>

<p>an object of class <code>diagram</code> (as returned by the functions <code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+gridDiag">gridDiag</a></code>, or <code><a href="#topic+ripsDiag">ripsDiag</a></code>) or an <code class="reqn">n</code> by 3 matrix, where <code class="reqn">n</code> is the number of features to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_diaglim">diagLim</code></td>
<td>

<p>numeric vector of length 2, specifying the limits of the plot. If <code>NULL</code> then it is automatically computed using the lifetimes of the features.
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_dimension">dimension</code></td>
<td>

<p>number specifying the dimension of the features to be plotted. If <code>NULL</code> all the features are plotted.
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_col">col</code></td>
<td>

<p>an optional vector of length <code class="reqn">P</code> that stores the colors of the topological features to be plotted, where <code class="reqn">P</code> is the number of topological features stored in <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_rotated">rotated</code></td>
<td>

<p>logical: if <code>FALSE</code> the plotted diagram has axes (birth, death), if <code>TRUE</code> the plotted diagram has axes ((birth+death)/2,(death-birth)/2). The default value is <code>FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_barcode">barcode</code></td>
<td>

<p>logical: if <code>TRUE</code> the persistence barcode is plotted, in place of the diagram.
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_band">band</code></td>
<td>

<p>numeric: if <code>band</code>!=<code>NULL</code>, a pink band of size <code>band</code> is added around the diagonal. If also <code>barcode</code> is <code>TRUE</code>, then bars shorter than <code>band</code> are dotted. The default value is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_lab.line">lab.line</code></td>
<td>

<p>number of lines from the plot edge, where the labels will be placed. The default value is <code>2.2</code>.
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_colorband">colorBand</code></td>
<td>

<p>the color for filling the confidence band. The default value is <code>"pink"</code>. (NA leaves the band unfilled)
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_colorborder">colorBorder</code></td>
<td>

<p>the color to draw the border of the confidence band. The default value is <code>NA</code> and omits the border.
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_add">add</code></td>
<td>

<p>logical: if <code>TRUE</code>, the points of <code>x</code> are added to an existing plot.
</p>
</td></tr>
<tr><td><code id="plot.diagram_+3A_...">...</code></td>
<td>

<p>additional graphical parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>References</h3>

<p>Brittany T. Fasy, Fabrizio Lecci, Alessandro Rinaldo, Larry Wasserman, Sivaraman Balakrishnan, and Aarti Singh. (2013), &quot;Statistical Inference For Persistent Homology&quot;, (arXiv:1303.7117). To appear, Annals of Statistics.
</p>
<p>Frederic Chazal, Brittany T. Fasy, Fabrizio Lecci, Alessandro Rinaldo, and Larry Wasserman, (2014), &quot;Stochastic Convergence of Persistence Landscapes and Silhouettes&quot;, Proceedings of the 30th Symposium of Computational Geometry (SoCG). (arXiv:1312.0308)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+gridDiag">gridDiag</a></code>, <code><a href="#topic+ripsDiag">ripsDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XX1 &lt;- circleUnif(30)
XX2 &lt;- circleUnif(30, r = 2) + 3
XX &lt;- rbind(XX1, XX2)

DiagLim &lt;- 5
maxdimension &lt;- 1

## rips diagram
Diag &lt;- ripsDiag(XX, maxdimension, DiagLim, printProgress = TRUE)

#plot
par(mfrow = c(1, 3))
plot(Diag[["diagram"]])
plot(Diag[["diagram"]], rotated = TRUE)
plot(Diag[["diagram"]], barcode = TRUE)
</code></pre>

<hr>
<h2 id='plot.maxPersistence'>
Summary plot for the maxPersistence function
</h2><span id='topic+plot.maxPersistence'></span>

<h3>Description</h3>

<p>The function <code>plot.maxPersistence</code> plots an object of class <code>maxPersistence</code>, for the selection of the optimal smoothing parameter for persistent homology.
For each value of the smoothing parameter, the plot shows the number of detected features, their persistence, and a bootstrap confidence band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'maxPersistence'
plot(
    x, features = "dimension", colorBand = "pink",
    colorBorder = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.maxPersistence_+3A_x">x</code></td>
<td>

<p>an object of class <code>maxPersistence</code>, as returned by the functions <code><a href="#topic+maxPersistence">maxPersistence</a></code>
</p>
</td></tr>
<tr><td><code id="plot.maxPersistence_+3A_features">features</code></td>
<td>

<p>string: if &quot;all&quot; then all the features are plotted; if &quot;dimension&quot; then only the features of the dimension used to compute the confidence band are plotted.
</p>
</td></tr>
<tr><td><code id="plot.maxPersistence_+3A_colorband">colorBand</code></td>
<td>

<p>the color for filling the confidence band. The default is &quot;pink&quot;. (NA leaves the band unfilled)
</p>
</td></tr>
<tr><td><code id="plot.maxPersistence_+3A_colorborder">colorBorder</code></td>
<td>

<p>the color to draw the border of the confidence band. The default is NA and omits the border.
</p>
</td></tr>
<tr><td><code id="plot.maxPersistence_+3A_...">...</code></td>
<td>

<p>additional graphical parameters.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>References</h3>

<p>Chazal F, Cisewski J, Fasy BT, Lecci F, Michel B, Rinaldo A, Wasserman L (2014). &quot;Robust Topological Inference: distance-to-a-measure and kernel distance.&quot;
</p>
<p>Fasy BT, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). &quot;Statistical Inference For Persistent Homology.&quot; (arXiv:1303.7117). Annals of Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maxPersistence">maxPersistence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## input data: circle with clutter noise
n &lt;- 600
percNoise &lt;- 0.1
XX1 &lt;- circleUnif(n)
noise &lt;- cbind(runif(percNoise * n, -2, 2), runif(percNoise * n, -2, 2))
X &lt;- rbind(XX1, noise)

## limits of the Gird at which the density estimator is evaluated
Xlim &lt;- c(-2, 2)
Ylim &lt;- c(-2, 2)
lim &lt;- cbind(Xlim, Ylim)
by &lt;- 0.2

B &lt;- 80
alpha &lt;- 0.05

## candidates
parametersKDE &lt;- seq(0.1, 0.5, by = 0.2)

maxKDE &lt;- maxPersistence(kde, parametersKDE, X, lim = lim, by = by,
                         bandFUN = "bootstrapBand", B = B, alpha = alpha,
                         parallel = FALSE, printProgress = TRUE)
print(summary(maxKDE))

par(mfrow = c(1, 2))
plot(X, pch = 16, cex = 0.5, main = "Circle")
plot(maxKDE)
</code></pre>

<hr>
<h2 id='ripsDiag'>
Rips Persistence Diagram
</h2><span id='topic+ripsDiag'></span>

<h3>Description</h3>

<p>The function <code>ripsDiag</code> computes the persistence diagram of the Rips filtration built on top of a point cloud.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ripsDiag(
    X, maxdimension, maxscale, dist = "euclidean",
    library = "GUDHI", location = FALSE, printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ripsDiag_+3A_x">X</code></td>
<td>

<p>If <code>dist="euclidean"</code>, <code>X</code> is an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, where <code class="reqn">n</code> is the number of points in the <code class="reqn">d</code>-dimensional euclidean space.
If <code>dist="arbitrary"</code>, <code>X</code> is an <code class="reqn">n</code> by <code class="reqn">n</code> matrix of distances of <code class="reqn">n</code> points.
</p>
</td></tr>
<tr><td><code id="ripsDiag_+3A_maxdimension">maxdimension</code></td>
<td>

<p>integer: max dimension of the homological features to be computed. (e.g. 0 for connected components, 1 for connected components and loops, 2 for connected components, loops, voids, etc.)
Currently there is a bug for computing homological features of dimension higher than 1 when the distance is arbitrary (<code>dist = "arbitrary"</code>) and library 'GUDHI' is used (<code>library = "GUDHI"</code>).
</p>
</td></tr>
<tr><td><code id="ripsDiag_+3A_maxscale">maxscale</code></td>
<td>

<p>number: maximum value of the rips filtration.
</p>
</td></tr>
<tr><td><code id="ripsDiag_+3A_dist">dist</code></td>
<td>

<p><code>"euclidean"</code> for Euclidean distance, <code>"arbitrary"</code> for an arbitrary distance given in input as a distance matrix.
Currently there is a bug for the arbitrary distance (<code>dist = "arbitrary"</code>) when computing homological features of dimension higher than 1 and library 'GUDHI' is used (<code>library = "GUDHI"</code>).
</p>
</td></tr>
<tr><td><code id="ripsDiag_+3A_library">library</code></td>
<td>

<p>either a string or a vector of length two. When a vector is given, the first element specifies which library to compute the Rips filtration, and the second element specifies which library to compute the persistence diagram. If a string is used, then the same library is used. For computing the Rips filtration, if <code>dist = "euclidean"</code>, the user can use either the library <code>"GUDHI"</code> or <code>"Dionysus"</code>. If <code>dist = "arbitrary"</code>, the user can use either the library <code>"Dionysus"</code>. The default value is <code>"GUDHI"</code> if <code>dist = "euclidean"</code>, and <code>"Dionysus"</code> if <code>dist == "arbitrary"</code>. When <code>"GUDHI"</code> is used for <code>dist = "arbitrary"</code>, <code>"Dionysus"</code> is implicitly used. For computing the persistence diagram, the user can choose either the library <code>"GUDHI"</code>, <code>"Dionysus"</code>, or <code>"PHAT"</code>. The default value is <code>"GUDHI"</code>.
Currently there is a bug for 'GUDHI' (<code>library = "GUDHI"</code>) when computing homological features of dimension higher than 1 and the distance is arbitrary (<code>dist = "arbitrary"</code>).
</p>
</td></tr>
<tr><td><code id="ripsDiag_+3A_location">location</code></td>
<td>

<p>if <code>TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram, location of birth point and death point of each homological feature is returned. Additionaly if <code>library="Dionysus"</code>, location of representative cycles of each homological feature is also returned.
</p>
</td></tr>
<tr><td><code id="ripsDiag_+3A_printprogress">printProgress</code></td>
<td>

<p>logical: if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Rips filtration based on Euclidean distance of the input point cloud, the user can decide to use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a> or <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>.
For Rips filtration based on arbitrary distance, the user can decide to the C++ library <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>.
Then for computing the persistence diagram from the Rips filtration, the user can use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a>, <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>, or <a href="https://bitbucket.org/phat-code/phat/">PHAT</a>.
Currently there is a bug for computing homological features of dimension higher than 1 when the distance is arbitrary (<code>dist = "arbitrary"</code>) and library 'GUDHI' is used (<code>library = "GUDHI"</code>).
See refereneces.
</p>


<h3>Value</h3>

<p>The function <code>ripsDiag</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>diagram</code></td>
<td>

<p>an object of class <code>diagram</code>, a <code class="reqn">P</code> by 3 matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. The first column contains the dimension of each feature (0 for components, 1 for loops, 2 for voids, etc.). Second and third columns are Birth and Death of the features.
</p>
</td></tr>
<tr><td><code>birthLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: if <code>dist="euclidean"</code>, then <code>birthLocation</code> is a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the data point completing the simplex that gives birth to an homological feature. If <code>dist="arbitrary"</code>, then <code>birthLocation</code> is a vector of length <code class="reqn">P</code>. Each row represents the index of the data point completing the simplex that gives birth to an homological feature.
</p>
</td></tr>
<tr><td><code>deathLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> or <code>"PHAT"</code> is used for computing the persistence diagram: if <code>dist="euclidean"</code>, then <code>deathLocation</code> is a <code class="reqn">P</code> by <code class="reqn">d</code> matrix, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each row represents the location of the data point completing the simplex that kills an homological feature. If <code>dist="arbitrary"</code>, then <code>deathLocation</code> is a vector of length <code class="reqn">P</code>. Each row represents the index of the data point completing the simplex that kills an homological feature.
</p>
</td></tr>
<tr><td><code>cycleLocation</code></td>
<td>

<p>only if <code>location=TRUE</code> and if <code>"Dionysus"</code> is used for computing the persistence diagram: if <code>dist="euclidean"</code>, then <code>cycleLocation</code> is a list of length <code class="reqn">P</code>, where <code class="reqn">P</code> is the number of points in the resulting persistence diagram. Each element is a <code class="reqn">P_i</code> by <code class="reqn">h_i +1</code> by <code class="reqn">d</code> array for <code class="reqn">h_i</code> dimensional homological feature. It represents location of <code class="reqn">h_i +1</code> vertices of <code class="reqn">P_i</code> simplices, where <code class="reqn">P_i</code> simplices constitutes the <code class="reqn">h_i</code> dimensional homological feature. If <code>dist = "arbitrary"</code>, then each element is a <code class="reqn">P_i</code> by <code class="reqn">h_i +1</code> matrix for  for <code class="reqn">h_i</code> dimensional homological feature. It represents index of <code class="reqn">h_i +1</code> vertices of <code class="reqn">P_i</code> simplices on a representative cycle of the <code class="reqn">h_i</code> dimensional homological feature.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brittany T. Fasy, Jisu Kim, Fabrizio Lecci, and Clement Maria
</p>


<h3>References</h3>

<p>Maria C (2014). &quot;GUDHI, Simplicial Complexes and Persistent Homology Packages.&quot; <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>.
</p>
<p>Morozov D (2007). &quot;Dionysus, a C++ library for computing persistent homology&quot;. <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>
</p>
<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>
<p>Fasy B, Lecci F, Rinaldo A, Wasserman L, Balakrishnan S, Singh A (2013). &quot;Statistical Inference For Persistent Homology.&quot; (arXiv:1303.7117). Annals of Statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.diagram">summary.diagram</a></code>, <code><a href="#topic+plot.diagram">plot.diagram</a></code>, <code><a href="#topic+gridDiag">gridDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## EXAMPLE 1: rips diagram for circles (euclidean distance)
X &lt;- circleUnif(30)
maxscale &lt;- 5
maxdimension &lt;- 1
## note that the input X is a point cloud
DiagRips &lt;- ripsDiag(
    X = X, maxdimension = maxdimension, maxscale = maxscale,
    library = "Dionysus", location = TRUE, printProgress = TRUE)

# plot
layout(matrix(c(1, 3, 2, 2), 2, 2))
plot(X, cex = 0.5, pch = 19)
title(main = "Data")
plot(DiagRips[["diagram"]])
title(main = "rips Diagram")
one &lt;- which(
    DiagRips[["diagram"]][, 1] == 1 &amp;
    DiagRips[["diagram"]][, 3] - DiagRips[["diagram"]][, 2] &gt; 0.5)
plot(X, col = 2, main = "Representative loop of data points")
for (i in seq(along = one)) {
  for (j in seq_len(dim(DiagRips[["cycleLocation"]][[one[i]]])[1])) {
    lines(
	    DiagRips[["cycleLocation"]][[one[i]]][j, , ], pch = 19, cex = 1,
        col = i)
  }
}


## EXAMPLE 2: rips diagram with arbitrary distance
## distance matrix for triangle with edges of length: 1,2,4
distX &lt;- matrix(c(0, 1, 2, 1, 0, 4, 2, 4, 0), ncol = 3)
maxscale &lt;- 5
maxdimension &lt;- 1
## note that the input distXX is a distance matrix
DiagTri &lt;- ripsDiag(distX, maxdimension, maxscale, dist = "arbitrary",
                    printProgress = TRUE)
#points with lifetime = 0 are not shown. e.g. the loop of the triangle.
print(DiagTri[["diagram"]])
</code></pre>

<hr>
<h2 id='ripsFiltration'>
Rips Filtration
</h2><span id='topic+ripsFiltration'></span>

<h3>Description</h3>

<p>The function <code>ripsFiltration</code> computes the Rips filtration built on top of a point cloud.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ripsFiltration(
    X, maxdimension, maxscale, dist = "euclidean",
    library = "GUDHI", printProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ripsFiltration_+3A_x">X</code></td>
<td>

<p>If <code>dist="euclidean"</code>, <code>X</code> is an <code class="reqn">n</code> by <code class="reqn">d</code> matrix of coordinates, where <code class="reqn">n</code> is the number of points in the <code class="reqn">d</code>-dimensional euclidean space.
If <code>dist="arbitrary"</code>, <code>X</code> is an <code class="reqn">n</code> by <code class="reqn">n</code> matrix of distances of <code class="reqn">n</code> points.
</p>
</td></tr>
<tr><td><code id="ripsFiltration_+3A_maxdimension">maxdimension</code></td>
<td>

<p>integer: max dimension of the homological features to be computed. (e.g. 0 for connected components, 1 for connected components and loops, 2 for connected components, loops, voids, etc.)
</p>
</td></tr>
<tr><td><code id="ripsFiltration_+3A_maxscale">maxscale</code></td>
<td>

<p>number: maximum value of the rips filtration.
</p>
</td></tr>
<tr><td><code id="ripsFiltration_+3A_dist">dist</code></td>
<td>

<p><code>"euclidean"</code> for Euclidean distance, <code>"arbitrary"</code> for an arbitrary distance given in input as a distance matrix.
</p>
</td></tr>
<tr><td><code id="ripsFiltration_+3A_library">library</code></td>
<td>

<p>a string specifying which library to compute the Rips filtration. If <code>dist = "euclidean"</code>, the user can use either the library <code>"GUDHI"</code> or <code>"Dionysus"</code>. If <code>dist = "arbitrary"</code>, the user can use the library <code>"Dionysus"</code>. The default value is <code>"GUDHI"</code> if <code>dist = "euclidean"</code>, and <code>"Dionysus"</code> if <code>dist == "arbitrary"</code>. When <code>"GUDHI"</code> is used for <code>dist = "arbitrary"</code>, <code>"Dionysus"</code> is implicitly used.
</p>
</td></tr>
<tr><td><code id="ripsFiltration_+3A_printprogress">printProgress</code></td>
<td>

<p>logical: if <code>TRUE</code>, a progress bar is printed. The default value is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Rips filtration based on Euclidean distance of the input point cloud, the user can decide to use either the C++ library <a href="https://project.inria.fr/gudhi/software/">GUDHI</a> or <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>.
For Rips filtration based on arbitrary distance, the user can use the C++ library <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>.
See refereneces.
</p>


<h3>Value</h3>

<p>The function <code>ripsFiltration</code> returns a list with the following elements:
</p>
<table>
<tr><td><code>cmplx</code></td>
<td>

<p>a list representing the complex. Its i-th element represents the vertices of i-th simplex.
</p>
</td></tr>
<tr><td><code>values</code></td>
<td>

<p>a vector representing the filtration values. Its i-th element represents the filtration value of i-th simplex.
</p>
</td></tr>
<tr><td><code>increasing</code></td>
<td>

<p>a logical variable indicating if the filtration values are in increasing order (<code>TRUE</code>) or in decreasing order (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code>coordinates</code></td>
<td>

<p>only if <code>dist = "euclidean"</code>: a matrix representing the coordinates of vertices. Its i-th row represents the coordinate of i-th vertex.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jisu Kim
</p>


<h3>References</h3>

<p>Maria C (2014). &quot;GUDHI, Simplicial Complexes and Persistent Homology Packages.&quot; <a href="https://project.inria.fr/gudhi/software/">https://project.inria.fr/gudhi/software/</a>.
</p>
<p>Morozov D (2007). &quot;Dionysus, a C++ library for computing persistent homology&quot;. <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>
</p>
<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ripsDiag">ripsDiag</a></code>, <code><a href="#topic+filtrationDiag">filtrationDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
X &lt;- cbind(cos(2*pi*seq_len(n)/n), sin(2*pi*seq_len(n)/n))
maxdimension &lt;- 1
maxscale &lt;- 1.5

FltRips &lt;- ripsFiltration(X = X, maxdimension = maxdimension,
               maxscale = maxscale, dist = "euclidean", library = "GUDHI",
               printProgress = TRUE)

# plot rips filtration
lim &lt;- rep(c(-1, 1), 2)
plot(NULL, type = "n", xlim = lim[1:2], ylim = lim[3:4],
    main = "Rips Filtration Plot")
for (idx in seq(along = FltRips[["cmplx"]])) {
  polygon(FltRips[["coordinates"]][FltRips[["cmplx"]][[idx]], , drop = FALSE],
      col = "pink", border = NA, xlim = lim[1:2], ylim = lim[3:4])
}
for (idx in seq(along = FltRips[["cmplx"]])) {
  polygon(FltRips[["coordinates"]][FltRips[["cmplx"]][[idx]], , drop = FALSE],
      col = NULL, xlim = lim[1:2], ylim = lim[3:4])
}  
points(FltRips[["coordinates"]], pch = 16)
</code></pre>

<hr>
<h2 id='silhouette'>
The Persistence Silhouette Function
</h2><span id='topic+silhouette'></span>

<h3>Description</h3>

<p>The function <code>silhouette</code> computes the silhouette function corresponding to a given persistence diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>silhouette(
    Diag, p = 1, dimension = 1, 
    tseq = seq(min(Diag[, 2:3]), max(Diag[, 2:3]), length = 500))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="silhouette_+3A_diag">Diag</code></td>
<td>

<p>an object of class <code>diagram</code> or a <code class="reqn">P</code> by <code class="reqn">3</code> matrix, storing a persistence diagram with colnames: &quot;dimension&quot;, &quot;Birth&quot;, &quot;Death&quot;. 
</p>
</td></tr>
<tr><td><code id="silhouette_+3A_p">p</code></td>
<td>

<p>a vector: the power of the weights of the silhouette function. See the definition of silhouette function, Section 5 in the reference.
</p>
</td></tr>
<tr><td><code id="silhouette_+3A_dimension">dimension</code></td>
<td>

<p>the dimension of the topological features under consideration. The default value is <code>1</code> (loops).
</p>
</td></tr>
<tr><td><code id="silhouette_+3A_tseq">tseq</code></td>
<td>

<p>a vector of values at which the silhouette function is evaluated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>silhouette</code> returns a numeric matrix of with the number of row as the length of <code>tseq</code> and the number of column as the length of <code>p</code>. The value at ith row and jth column represents the value of the <code>p[j]</code>-th power silhouette function evaluated at <code>tseq[i]</code>.
</p>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>References</h3>

<p>Chazal F, Fasy BT, Lecci F, Rinaldo A, Wasserman L (2014). &quot;Stochastic Convergence of Persistence Landscapes and Silhouettes.&quot; Proceedings of the 30th Symposium of Computational Geometry (SoCG). (arXiv:1312.0308)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landscape">landscape</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Diag &lt;- matrix(c(0, 0, 10, 1, 0, 3, 1, 3, 8), ncol = 3, byrow = TRUE)
DiagLim &lt;- 10
colnames(Diag) &lt;- c("dimension", "Birth", "Death")

#persistence silhouette
tseq &lt;- seq(0, DiagLim, length = 1000)
Sil &lt;- silhouette(Diag, p = 1,  dimension = 1, tseq)

par(mfrow = c(1, 2))
plot.diagram(Diag)
plot(tseq, Sil, type = "l", xlab = "t", ylab = "silhouette", asp = 1)
</code></pre>

<hr>
<h2 id='sphereUnif'>
Uniform Sample From The Sphere <code class="reqn">S^d</code>
</h2><span id='topic+sphereUnif'></span>

<h3>Description</h3>

<p>The function <code>sphereUnif</code> samples <code>n</code> points from the sphere <code class="reqn">S^d</code> of radius <code>r</code> embedded in <code class="reqn">R^{d+1}</code>, uniformly with respect to the volume measure of the sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphereUnif(n, d, r = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphereUnif_+3A_n">n</code></td>
<td>

<p>an integer specifying the number of points in the sample.
</p>
</td></tr>
<tr><td><code id="sphereUnif_+3A_d">d</code></td>
<td>

<p>an integer specifying the dimension of the sphere <code class="reqn">S^d</code>
</p>
</td></tr>
<tr><td><code id="sphereUnif_+3A_r">r</code></td>
<td>

<p>a numeric variable specifying the radius of the sphere. The default value is <code>1</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>sphereUnif</code> returns an <code>n</code> by 2 matrix of coordinates.
</p>


<h3>Note</h3>

<p>When <code>d = 1</code>, this function is same as using <code><a href="#topic+circleUnif">circleUnif</a></code>.
</p>


<h3>Author(s)</h3>

<p>Jisu Kim
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circleUnif">circleUnif</a></code>, <code><a href="#topic+torusUnif">torusUnif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- sphereUnif(n = 100, d = 1, r = 1)
plot(X)
</code></pre>

<hr>
<h2 id='summary.diagram'>
<code>print</code> and <code>summary</code> for <code>diagram</code>
</h2><span id='topic+summary.diagram'></span><span id='topic+print.summary.diagram'></span><span id='topic+print.diagram'></span>

<h3>Description</h3>

<p>The function <code>print.diagram</code> prints a persistence diagram, a <code class="reqn">P</code> by 3 matrix, where <code class="reqn">P</code> is the number of points in the diagram. The first column contains the dimension of each feature (0 for components, 1 for loops, 2 for voids, etc.). Second and third columns are Birth and Death of the features. 
</p>
<p>The function <code>summary.diagram</code> produces basic summaries of a persistence diagrams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diagram'
print(x, ...)
## S3 method for class 'diagram'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.diagram_+3A_x">x</code></td>
<td>

<p>an object of class <code>diagram</code>
</p>
</td></tr>
<tr><td><code id="summary.diagram_+3A_object">object</code></td>
<td>

<p>an object of class <code>diagram</code>
</p>
</td></tr>
<tr><td><code id="summary.diagram_+3A_...">...</code></td>
<td>

<p>additional arguments affecting the summary produced.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.diagram">plot.diagram</a></code>,
<code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+gridDiag">gridDiag</a></code>, <code><a href="#topic+ripsDiag">ripsDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from 2 circles
XX1 &lt;- circleUnif(30)
XX2 &lt;- circleUnif(30, r = 2) + 3
XX &lt;- rbind(XX1, XX2)

DiagLim &lt;- 5         # limit of the filtration
maxdimension &lt;- 1    # computes betti0 and betti1

Diag &lt;- ripsDiag(XX, maxdimension, DiagLim, printProgress = TRUE)

print(Diag[["diagram"]])
print(summary(Diag[["diagram"]]))
</code></pre>

<hr>
<h2 id='TDA-internal'>
Internal TDA functions
</h2><span id='topic+findKtree'></span><span id='topic+gridBy'></span><span id='topic+plotRule'></span><span id='topic+rMultinom'></span><span id='topic+siloF'></span><span id='topic+AlphaComplexDiag'></span><span id='topic+AlphaShapeDiag'></span><span id='topic+Bottleneck'></span><span id='topic+Dtm'></span><span id='topic+DtmWeight'></span><span id='topic+GridDiag'></span><span id='topic+Kde'></span><span id='topic+KdeDist'></span><span id='topic+RipsDiag'></span><span id='topic+Wasserstein'></span>

<h3>Description</h3>

<p>Internal TDA functions
</p>


<h3>Details</h3>

<p>These are functions not to be called by the user, including functions generated by Rcpp.
</p>

<hr>
<h2 id='torusUnif'>
Uniform Sample From The 3D Torus
</h2><span id='topic+torusUnif'></span>

<h3>Description</h3>

<p>The function <code>torusUnif</code> samples <code>n</code> points from the 3D torus, uniformly with respect to its surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  torusUnif(n, a, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="torusUnif_+3A_n">n</code></td>
<td>

<p>an integer specifying the number of points in the sample.
</p>
</td></tr>
<tr><td><code id="torusUnif_+3A_a">a</code></td>
<td>

<p>the radius of the torus tube.
</p>
</td></tr>
<tr><td><code id="torusUnif_+3A_c">c</code></td>
<td>

<p>the radius from the center of the hole to the center of the torus tube.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function <code>torusUnif</code> is an implementation of Algorithm 1 in the reference.
</p>


<h3>Value</h3>

<p>The function <code>torusUnif</code> returns an <code>n</code> by 3 matrix of coordinates.
</p>


<h3>Author(s)</h3>

<p>Fabrizio Lecci
</p>


<h3>References</h3>

<p>Diaconis P, Holmes S, and Shahshahani M (2013). &quot;Sampling from a manifold.&quot; Advances in Modern Statistical Theory and Applications: A Festschrift in honor of Morris L. Eaton. Institute of Mathematical Statistics, 102-125.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+circleUnif">circleUnif</a></code>,<code><a href="#topic+sphereUnif">sphereUnif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- torusUnif(300, a = 1.8, c = 5)
plot(X)
</code></pre>

<hr>
<h2 id='wasserstein'>
Wasserstein distance between two persistence diagrams
</h2><span id='topic+wasserstein'></span>

<h3>Description</h3>

<p>The function <code>wasserstein</code> computes the Wasserstein distance between two persistence diagrams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  wasserstein(Diag1, Diag2, p = 1, dimension = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein_+3A_diag1">Diag1</code></td>
<td>

<p>an object of class <code>diagram</code> or a matrix (<code class="reqn">n</code> by 3) that stores dimension, birth and death of <code class="reqn">n</code> topological features.
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_diag2">Diag2</code></td>
<td>

<p>an object of class <code>diagram</code> or a matrix (<code class="reqn">m</code> by 3) that stores dimension, birth and death of <code class="reqn">m</code> topological features.
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_p">p</code></td>
<td>

<p>integer specifying the power to be used in the computation of the Wasserstein distance. The default value is <code>1</code>.
</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_dimension">dimension</code></td>
<td>

<p>an integer or a vector specifying the dimension of the features used to compute the wasserstein distance. 0 for connected components, 1 for loops, 2 for voids and so on. The default value is <code>1</code> (loops).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Wasserstein distance between two diagrams is the cost of the optimal matching between points of the two diagrams. When a vector is given for <code>dimension</code>, then maximum among bottleneck distances using each element in <code>dimension</code> is returned. This function is an R wrapper of the function &quot;wasserstein_distance&quot; in the C++ library <a href="https://www.mrzv.org/software/dionysus/">Dionysus</a>. See references.
</p>


<h3>Value</h3>

<p>The function <code>wasserstein</code> returns the value of the Wasserstein distance between the two persistence diagrams.
</p>


<h3>Author(s)</h3>

<p>Jisu Kim and Fabrizio Lecci
</p>


<h3>References</h3>

<p>Morozov D (2007). &quot;Dionysus, a C++ library for computing persistent homology&quot;. <a href="https://www.mrzv.org/software/dionysus/">https://www.mrzv.org/software/dionysus/</a>.
</p>
<p>Edelsbrunner H, Harer J (2010). &quot;Computational topology: an introduction.&quot; American Mathematical Society.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bottleneck">bottleneck</a></code>,
<code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+alphaComplexDiag">alphaComplexDiag</a></code>, <code><a href="#topic+gridDiag">gridDiag</a></code>, <code><a href="#topic+ripsDiag">ripsDiag</a></code>,
<code><a href="#topic+plot.diagram">plot.diagram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XX1 &lt;- circleUnif(20)
XX2 &lt;- circleUnif(20, r = 0.2)

DiagLim &lt;- 5
maxdimension &lt;- 1

Diag1 &lt;- ripsDiag(XX1, maxdimension, DiagLim, printProgress = FALSE)
Diag2 &lt;- ripsDiag(XX2, maxdimension, DiagLim, printProgress = FALSE)

wassersteinDist &lt;- wasserstein(Diag1[["diagram"]], Diag2[["diagram"]], p = 1,
                               dimension = 1)
print(wassersteinDist)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
