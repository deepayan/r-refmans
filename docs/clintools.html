<!DOCTYPE html><html><head><title>Help for package clintools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clintools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calcrel'><p>Calculation of reliability (calcrel)</p></a></li>
<li><a href='#cdm.fig'><p>Central data monitoring to assess deviations (cdm.fig)</p></a></li>
<li><a href='#cdm.miss'><p>Quiet any output (cdm.miss)</p></a></li>
<li><a href='#clinmon'><p>Hemodynamic Indices Calculated From Clinical Monitoring (clinmon)</p></a></li>
<li><a href='#comparerel'><p>Compare measures of reliability (comparerel)</p></a></li>
<li><a href='#danishcpr'><p>Danish CPR number to birthday and sex (danishcpr)</p></a></li>
<li><a href='#df.data1000'><p>Test-data - 1000 Hz</p></a></li>
<li><a href='#df.deleter'><p>Test-deleter</p></a></li>
<li><a href='#dilations'><p>Assess dilations from <code>PLR3000</code>-output.</p></a></li>
<li><a href='#iscus'><p>ISCUSFlex-values to dataframe  (iscus)</p></a></li>
<li><a href='#ortable'><p>Logistic regression table with Odds ratio (ortable)</p></a></li>
<li><a href='#PLR3000'><p>NeurOpticsTM PLR-3000 pupillometer file to dataframe (PLR3000)</p></a></li>
<li><a href='#questionaire'><p>Calculate scores from questionaire (questionaire)</p></a></li>
<li><a href='#quietly'><p>Quiet any output (quietly)</p></a></li>
<li><a href='#recol'><p>Reorder column (recol)</p></a></li>
<li><a href='#rowMedians'><p>find median of rows similar to rowMeans (rowMedians)</p></a></li>
<li><a href='#rrGcomp'><p>Relative risk derived by G-computation (rrGcomp)</p></a></li>
<li><a href='#sRCT'><p>simulated Randomised Clinical Trial (sRCT)</p></a></li>
<li><a href='#tbl'><p>Create a table (tbl)</p></a></li>
<li><a href='#testdata10'><p>Test-data - 10 Hz</p></a></li>
<li><a href='#TFA'><p>Transfer function analysis of dynamic cerebral autoregulation (TFA)</p></a></li>
<li><a href='#tfa_sample_data'><p>TFA sample data</p></a></li>
<li><a href='#tfa_sample_data_1'><p>TFA sample data - 1</p></a></li>
<li><a href='#tfa_sample_data_2'><p>TFA sample data - 2</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Clinical Research</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.10.1</td>
</tr>
<tr>
<td>Description:</td>
<td>
   Every research team have their own script for data management, statistics and 
   most importantly hemodynamic indices. The purpose is to standardize scripts 
   utilized in clinical research. The hemodynamic indices can be used in a long-format dataframe, 
   and add both periods of interest (trigger-periods), and delete artifacts with deleter-files. 
   Transfer function analysis (Claassen et al. (2016) &lt;<a href="https://doi.org/10.1177%2F0271678X15626425">doi:10.1177/0271678X15626425</a>&gt;) and
   Mx (Czosnyka et al. (1996) &lt;<a href="https://doi.org/10.1161%2F01.str.27.10.1829">doi:10.1161/01.str.27.10.1829</a>&gt;) can be calculated using this package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lilleoel/clintools">https://github.com/lilleoel/clintools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lilleoel/clintools/issues">https://github.com/lilleoel/clintools/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>signal (&ge; 0.7-6), xml2 (&ge; 1.3.2), lme4 (&ge; 1.1-27.1),
ggplot2 (&ge; 3.3.0), pROC (&ge; 1.18.0), irr (&ge; 0.84.1), nlme (&ge;
3.1-160), parameters (&ge; 0.19.0), stringi (&ge; 1.7.8), scales
(&ge; 1.2.1), dplyr (&ge; 1.1.2), survival (&ge; 3.4-0), pander (&ge;
0.6.5)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-09 22:19:24 UTC; MOLS0212</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Harboe Olsen [cre, aut],
  Christian Riberholt [ctb],
  Ronan Berg [ctb],
  Kirsten Moeller [ctb],
  Janus Christian Jakobsen [ctb],
  Aksel Karl Georg Jensen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Harboe Olsen &lt;oel@oelfam.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calcrel'>Calculation of reliability (calcrel)</h2><span id='topic+calcrel'></span>

<h3>Description</h3>

<p><code>calcrel()</code> is a function used to calculate different reliability measures, including Coefficient of variance, smallest real difference, intraclass correlation coefficient, and Bland-Altman plot derived bias with 95% limits of agreement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcrel(d1,d2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcrel_+3A_d1">d1</code></td>
<td>
<p>list of numbers from measurement one</p>
</td></tr>
<tr><td><code id="calcrel_+3A_d2">d2</code></td>
<td>
<p>list of numbers from measurement two (same order as for measurement one)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a nested list of reliability measures.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   d1 &lt;- rnorm(15,10,1)
   d2 &lt;- rnorm(15,10,1)
   calcrel(d1,d2)

</code></pre>

<hr>
<h2 id='cdm.fig'>Central data monitoring to assess deviations (cdm.fig)</h2><span id='topic+cdm.fig'></span>

<h3>Description</h3>

<p><code>cdm.fig()</code> is a function to assess any deviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdm.fig(df, col, site, meta_title, seedno, output, nmin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdm.fig_+3A_df">df</code></td>
<td>
<p>dateframe to be assessed for missing data</p>
</td></tr>
<tr><td><code id="cdm.fig_+3A_col">col</code></td>
<td>
<p>column to be assessed</p>
</td></tr>
<tr><td><code id="cdm.fig_+3A_site">site</code></td>
<td>
<p>column with sites</p>
</td></tr>
<tr><td><code id="cdm.fig_+3A_meta_title">meta_title</code></td>
<td>
<p>Y-axis lab, if empty then it is the column name</p>
</td></tr>
<tr><td><code id="cdm.fig_+3A_seedno">seedno</code></td>
<td>
<p>the numeric site, if empty it is just <code>Sys.Date()</code></p>
</td></tr>
<tr><td><code id="cdm.fig_+3A_output">output</code></td>
<td>
<p>if 'fig' then the figure is the output, any other will output
the blinded site table</p>
</td></tr>
<tr><td><code id="cdm.fig_+3A_nmin">nmin</code></td>
<td>
<p>minimum number of variables in site to be presented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a full markdown output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   cdm.fig(df,col="Mode of birth",
      site="maternal_trial_site")
   cdm.fig(df,col="Gestational Age at birth",
      site="maternal_trial_site")
   library(knitr)
   kable(cdm.fig(df,col="Mode of birth",
      site="maternal_trial_site",output = ""),row.names=F)

## End(Not run)

</code></pre>

<hr>
<h2 id='cdm.miss'>Quiet any output (cdm.miss)</h2><span id='topic+cdm.miss'></span>

<h3>Description</h3>

<p><code>cdm.miss()</code> is a small function which suppresses any output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdm.miss(df, id, cols, date, lostFU, filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdm.miss_+3A_df">df</code></td>
<td>
<p>dateframe to be assessed for missing data</p>
</td></tr>
<tr><td><code id="cdm.miss_+3A_id">id</code></td>
<td>
<p>column-name for unique id's</p>
</td></tr>
<tr><td><code id="cdm.miss_+3A_cols">cols</code></td>
<td>
<p>columns to be assessed for missing data</p>
</td></tr>
<tr><td><code id="cdm.miss_+3A_date">date</code></td>
<td>
<p>column with the date of follow-up, i.e. when data is missing</p>
</td></tr>
<tr><td><code id="cdm.miss_+3A_lostfu">lostFU</code></td>
<td>
<p>column for patients lost to follow up, TRUE/FALSE in the column</p>
</td></tr>
<tr><td><code id="cdm.miss_+3A_filter">filter</code></td>
<td>
<p>how many should be shown in figures - 'all' for all, 'waiting'
for those with missing or waiting for data, and 'missing' for only those
with missing data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a full markdown output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   cdm.miss(data,id=idcols[[1]],cols=missing.cols,lostFU="lostFU",
   date = "follow_up_date", filter="missing")

## End(Not run)

</code></pre>

<hr>
<h2 id='clinmon'>Hemodynamic Indices Calculated From Clinical Monitoring (clinmon)</h2><span id='topic+clinmon'></span>

<h3>Description</h3>

<p><code>clinmon()</code> uses a <em>continuous</em> recording and returns a dataframe with hemodynamic indices for every period, epoch or block depending on the input. Calculates <code>COest</code>, <code>CPPopt</code>, <code>CVRi</code>, <code>Dx</code>, <code>Mx</code>, <code>PI</code>, <code>PRx</code>, <code>PWA</code>, <code>RI</code>, and <code>Sx</code> (see <em>Hemodynamic indices</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clinmon(df, variables,
trigger = NULL, deleter = NULL,
blocksize = 3, epochsize = 20,
overlapping = FALSE, freq = 1000,
blockmin = 0.5, epochmin = 0.5,
output = "period", fast = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clinmon_+3A_df">df</code></td>
<td>
<p>Raw <em>continuous</em> recording with all numeric data and first column has to be time in seconds. (<code>dataframe</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_variables">variables</code></td>
<td>
<p>Defining the type and order of the recorded variables as a list. Middle cerebral artery blood velocity (<code>'mcav'</code>), Arterial blood pressure (<code>'abp'</code>), cerebral perfusion pressure (<code>'cpp'</code>), intracranial pressure (<code>'icp'</code>), and heart rate (<code>'hr'</code>) is currently supported. <em>It is necessary that time is the first row</em>.  (<code>list</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_trigger">trigger</code></td>
<td>
<p>Trigger with two columns: first is start, and second is end of periods to be analyzed. Every row corresponds to a period. Default is <code>NULL</code>, which results in analysis of the full dataframe. (<code>dataframe</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_deleter">deleter</code></td>
<td>
<p>Deleter with two columns: first is start and second is end of period with artefacts, which need to be deleted. Every row is a period with artefacts. Default is <code>NULL</code>. (<code>dataframe</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_blocksize">blocksize</code></td>
<td>
<p>Length of a block, in seconds. Default is <code>3</code>. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_epochsize">epochsize</code></td>
<td>
<p>Size of epochs in number of blocks. Default is <code>20</code>. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_overlapping">overlapping</code></td>
<td>
<p>The number of block which should overlap when calculating correlation based indices, and remain blank if overlapping calculations should not be utilized. Default is <code>FALSE</code>. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_freq">freq</code></td>
<td>
<p>Frequency of recorded data, in Hz. Default is <code>1000</code>. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_blockmin">blockmin</code></td>
<td>
<p>Minimum measurements required to create a block in ratio. Default is <code>0.5</code> corresponding to 50%. If the block holds less than the defined ratio the block will be omitted. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_epochmin">epochmin</code></td>
<td>
<p>Minimum number of blocks required to create an epoch in ratio. Default is <code>0.5</code> corresponding to 50%. If the epoch holds less than the defined ration the epoch will be omitted. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_output">output</code></td>
<td>
<p>Select what each row should represent in the output. Correlation based indices are not presented when selecting blocks for every row. Currently <code>'block'</code>, <code>'epoch'</code>, <code>'period'</code> or <code>'cppopt'</code> is supported. Default is <code>'period'</code>. (<code>string</code>)</p>
</td></tr>
<tr><td><code id="clinmon_+3A_fast">fast</code></td>
<td>
<p>Select if you want the data to aggregated before analysis resulting in a faster, but perhaps more imprecise run, in Hz. Default is <code>FALSE.</code> (<code>numeric</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using a <em>continuous</em> raw recording, <code>clinmon()</code> calculates hemodynamic indices for every period, epoch or block depending on the chosen output.
</p>
<div class="sourceCode"><pre>View(data)
</pre></div>
<table>
<tr>
 <td style="text-align: right;">
   <code>time</code> </td><td style="text-align: right;"> <code>abp</code> </td><td style="text-align: right;"> <code>mcav</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>7.00</code> </td><td style="text-align: right;"> <code>78</code> </td><td style="text-align: right;"> <code>45</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>7.01</code> </td><td style="text-align: right;"> <code>78</code> </td><td style="text-align: right;"> <code>46</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>301.82</code> </td><td style="text-align: right;"> <code>82</code> </td><td style="text-align: right;"> <code>70</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>301.83</code> </td><td style="text-align: right;"> <code>81</code> </td><td style="text-align: right;"> <code>69</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>To calculate the indices insert the data and select the relevant variables.
</p>
<div class="sourceCode"><pre>clinmon(df=data, variables=c("abp","mcav"))
</pre></div>
<p>See <strong>Value</strong> for output description.
</p>


<h3>Value</h3>

<p>Returns a dataframe with the results, with either
every blocks, epochs or periods as rows, depending on the chosen output.
</p>
<p>The columns of the output are:
</p>

<ul>
<li> <p><code>period</code> - The period number corresponding to the row-number in the trigger file.
</p>
</li>
<li> <p><code>epoch</code> - The epoch number, or if <code>period</code> is chosen as output it reflects the number of epochs in the period.
</p>
</li>
<li> <p><code>block</code> - The block number, or if <code>period</code> or <code>epoch</code> is chosen as output it reflects the number of blocks in the <code>period</code> or <code>epoch</code>.
</p>
</li>
<li> <p><code>time_min</code> - The minimum time value or the <code>period</code>, <code>epoch</code> or <code>block</code>.
</p>
</li>
<li> <p><code>time_max</code> - The maximum time value or the <code>period</code>, <code>epoch</code> or <code>block</code>.
</p>
</li>
<li> <p><code>missing_percent</code> - The percentage of missing data in the <code>period</code>, <code>epoch</code> or <code>block</code>.
</p>
</li>
<li> <p><code>XX_mean</code> - The mean value of each variable for the <code>period</code>, <code>epoch</code> or <code>block</code>.
</p>
</li>
<li> <p><code>XX_min</code> - The minimum value of each variable for the <code>period</code>, <code>epoch</code> or <code>block</code>.
</p>
</li>
<li> <p><code>XX_max</code> - The maximum value of each variable for the <code>period</code>, <code>epoch</code> or <code>block</code>.
</p>
</li>
<li> <p><code>YY</code> - The indices in each column.
</p>
</li></ul>



<h3>Hemodynamic indices</h3>



<h4><code>COest</code> | Estimated cardiac output</h4>

<p><em>Required variables:</em> <code>abp</code>, <code>hr</code>; <em>Required output:</em> <code>-</code>.
</p>
<p>Estimated cardiac output (<code>COest</code>) is calculated by utilizing the method described by Koenig et al. [1]:
</p>
<p style="text-align: center;"><code class="reqn">COest = PP / (SBP+DBP) * HR</code>
</p>

<p>PP: Pulse pressure; SBP: systolic blood pressure; DBP: diastolic blood pressure; HR: heart rate.
</p>



<h4><code>CPPopt</code> | Optimal cerebral perfusion pressure</h4>

<p><em>Required variables:</em> <code>abp</code>, <code>icp</code>; <em>Required output:</em> <code>period</code>.
</p>
<p>Optimal cerebral perfusion pressure (<code>CPPopt</code>) is calculated utilizing the method described by Steiner et al. [2]. The CPPopt return <code>NA</code> if CPPopt is the maximum or minimum CPP investigated. CPPopt is recommended to only be calculated after 'several hours' of recording:
</p>
<p style="text-align: center;"><code class="reqn">CPPopt = The 5 mmHg CPP Interval With Lowest Mean PRx </code>
</p>

<p>CPP: cerebral perfusion pressure; PRx: Pressure reactivity index.
</p>



<h4><code>CVRi</code> | Cardiovascular resistance index</h4>

<p><em>Required variables:</em> <code>abp</code>, <code>mcav</code>; <em>Required output:</em> <code>-</code>.
</p>
<p>Cardiovascular resistance index (<code>CVRi</code>) is calculated utilizing the method described by Fan et al. [3]:
</p>
<p style="text-align: center;"><code class="reqn">CVRi = mean ABP / mean MCAv </code>
</p>

<p>ABP: arterial blood pressure; MCAv: middle cerebral artery blood velocity.
</p>



<h4><code>Dx</code> | Diastolic flow index</h4>

<p><em>Required variables:</em> <code>cpp</code>/<code>abp</code>, <code>mcav</code>; <em>Required output:</em> <code>epoch</code>, <code>period</code>.
</p>
<p>Diastolic flow index (<code>Dx</code>) is calculated utilizing the method described by Reinhard et al. [4]:
</p>
<p style="text-align: center;"><code class="reqn">Dxc = cor( mean CPP / min MCAv ) </code>
</p>

<p style="text-align: center;"><code class="reqn">Dxa = cor( mean ABP / min MCAv ) </code>
</p>

<p>cor: correlation coefficient; CPP: cerebral perfusion pressure; ABP: arterial blood pressure; MCAv: middle cerebral artery blood velocity.
</p>



<h4><code>Mx</code> | Mean flow index</h4>

<p><em>Required variables:</em> <code>cpp</code>/<code>abp</code>, <code>mcav</code>; <em>Required output:</em> <code>epoch</code>, <code>period</code>.
</p>
<p>Mean flow index (<code>Mx</code>) is calculated utilizing the method described by Czosnyka et al. [5]:
</p>
<p style="text-align: center;"><code class="reqn">Mxc = cor( mean CPP / mean MCAv ) </code>
</p>

<p style="text-align: center;"><code class="reqn">Mxa = cor( mean ABP / mean MCAv ) </code>
</p>

<p>cor: correlation coefficient; CPP: cerebral perfusion pressure; ABP: arterial blood pressure; MCAv: middle cerebral artery blood velocity.
</p>



<h4><code>PI</code> | Gosling index of pulsatility</h4>

<p><em>Required variables:</em> <code>mcav</code>; <em>Required output:</em> <code>-</code>.
</p>
<p>Gosling index of pulsatility (<code>PI</code>) is calculated utilizing the method described by Michel et al. [6]:
</p>
<p style="text-align: center;"><code class="reqn">PI = (systolic MCAv - diastolic MCAv) / mean MCAv  </code>
</p>

<p>MCAv: middle cerebral artery blood velocity.
</p>



<h4><code>PRx</code> | Pressure reactivity index</h4>

<p><em>Required variables:</em> <code>abp</code>, <code>icp</code>; <em>Required output:</em> <code>epoch</code>, <code>period</code>.
</p>
<p>Pressure reactivity index (<code>PRx</code>) is calculated utilizing the method described by Czosnyka et al. [7]:
</p>
<p style="text-align: center;"><code class="reqn">PRx = cor( mean ABP / mean ICP ) </code>
</p>

<p>cor: correlation coefficient; CPP: cerebral perfusion pressure; ICP: intracranial pressure.
</p>



<h4><code>PWA</code> | Pulse wave amplitude</h4>

<p><em>Required variables:</em> <code>cpp</code>/<code>icp</code>/<code>abp</code>/<code>mcav</code>; <em>Required output:</em> <code>-</code>.
</p>
<p>Pulse wave amplitude (<code>PWA</code>) is calculated utilizing the method described by Norager et al. [8]:
</p>
<p style="text-align: center;"><code class="reqn">PWA = systolic - diastolic </code>
</p>




<h4><code>RI</code> | Pourcelots resistive (resistance) index</h4>

<p><em>Required variables:</em> <code>mcav</code>; <em>Required output:</em> <code>-</code>.
</p>
<p>Pourcelots resistive (resistance) index (<code>RI</code>) is calculated utilizing the method described by Forster et al. [9]:
</p>
<p style="text-align: center;"><code class="reqn">RI = (systolic MCAv - diastolic MCAv) / systolic MCAv  </code>
</p>

<p>MCAv: middle cerebral artery blood velocity.
</p>



<h4><code>Sx</code> | Systolic flow index</h4>

<p><em>Required variables:</em> <code>cpp</code>/<code>abp</code>, <code>mcav</code>; <em>Required output:</em> <code>epoch</code>, <code>period</code>.
</p>
<p>Systolic flow index (<code>Sx</code>) is calculated utilizing the method described by Czosnyka et al. [5]:
</p>
<p style="text-align: center;"><code class="reqn">Sxc = cor( mean CPP / systolic MCAv ) </code>
</p>

<p style="text-align: center;"><code class="reqn">Sxa = cor( mean ABP / systolic MCAv ) </code>
</p>

<p>cor: correlation coefficient; CPP: cerebral perfusion pressure; ABP: arterial blood pressure; MCAv: middle cerebral artery blood velocity.
</p>



<h3>References</h3>


<ol>
<li><p> Koenig et al. (2015) Biomed Sci Instrum. 2015;51:85-90. (<a href="https://pubmed.ncbi.nlm.nih.gov/25996703/">PubMed</a>)
</p>
</li>
<li><p> Steiner et al. (2002) Crit Care Med. 2002 Apr;30(4):733-8. (<a href="https://pubmed.ncbi.nlm.nih.gov/11940737/">PubMed</a>)
</p>
</li>
<li><p> Fan et al. (2018) Front Physiol. 2018 Jul 16;9:869. (<a href="https://pubmed.ncbi.nlm.nih.gov/30061839/">PubMed</a>)
</p>
</li>
<li><p> Reinhard et al. (2003) Stroke. 2003 Sep;34(9):2138-44. (<a href="https://pubmed.ncbi.nlm.nih.gov/12920261/">PubMed</a>)
</p>
</li>
<li><p> Czosnyka et al. (1996) Stroke. 1996 Oct;27(10):1829-34. (<a href="https://pubmed.ncbi.nlm.nih.gov/8841340/">PubMed</a>)
</p>
</li>
<li><p> Michel et al. (1998) Ultrasound Med Biol. 1998 May;24(4):597-9. (<a href="https://pubmed.ncbi.nlm.nih.gov/9651969/">PubMed</a>)
</p>
</li>
<li><p> Czosnyka et al. (1997) Neurosurgery. 1997 Jul;41(1):11-7; discussion 17-9. (<a href="https://pubmed.ncbi.nlm.nih.gov/9218290/">PubMed</a>)
</p>
</li>
<li><p> Norager et al. (2020) Acta Neurochir (Wien). 2020 Dec;162(12):2983-2989. (<a href="https://pubmed.ncbi.nlm.nih.gov/32886224/">PubMed</a>)
</p>
</li>
<li><p> Forster et al. (2017) J Paediatr Child Health. 2018 Jan;54(1):61-68. (<a href="https://pubmed.ncbi.nlm.nih.gov/28845537/">PubMed</a>)
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
data(testdata)
clinmon(df.data10, variables=c('abp','mcav','hr'), freq=10)

</code></pre>

<hr>
<h2 id='comparerel'>Compare measures of reliability (comparerel)</h2><span id='topic+comparerel'></span>

<h3>Description</h3>

<p><code>comparerel()</code> is a function which compares measures from calcrel using bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparerel(d1,d2,d3,d4,n_boot,seedno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparerel_+3A_d1">d1</code></td>
<td>
<p>list of numbers from measurement one of sample 1</p>
</td></tr>
<tr><td><code id="comparerel_+3A_d2">d2</code></td>
<td>
<p>list of numbers from measurement two of sample 1 (same order as for d1)</p>
</td></tr>
<tr><td><code id="comparerel_+3A_d3">d3</code></td>
<td>
<p>list of numbers from measurement one of sample 2</p>
</td></tr>
<tr><td><code id="comparerel_+3A_d4">d4</code></td>
<td>
<p>list of numbers from measurement two of sample 2 (same order as for d2)</p>
</td></tr>
<tr><td><code id="comparerel_+3A_n_boot">n_boot</code></td>
<td>
<p>numbers of iterations (default is 1000)</p>
</td></tr>
<tr><td><code id="comparerel_+3A_seedno">seedno</code></td>
<td>
<p>the seed number used for bootstrapping (default is)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a nested list of difference between reliability measures using bootstrapping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   d1 &lt;- rnorm(15,10,1)
   d2 &lt;- rnorm(15,10,1)
   d3 &lt;- rnorm(15,10,1)
   d4 &lt;- rnorm(15,10,1)
   comparerel(d1,d2,d3,d4)

## End(Not run)
</code></pre>

<hr>
<h2 id='danishcpr'>Danish CPR number to birthday and sex (danishcpr)</h2><span id='topic+danishcpr'></span>

<h3>Description</h3>

<p><code>danishcpr()</code> converts a list of CPR-numbers to a corresponding list birthday and sex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>danishcpr(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="danishcpr_+3A_code">code</code></td>
<td>
<p>list of CPR numbers (<code>list</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with $birthday which is a list of dates, and $sex which is a list of Male/Female.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   cpr &lt;- danishcpr(code)
   birthdays &lt;- cpr$birthday
   sex &lt;- cpr$sex

## End(Not run)

</code></pre>

<hr>
<h2 id='df.data1000'>Test-data - 1000 Hz</h2><span id='topic+df.data1000'></span>

<h3>Description</h3>

<p>Recording with four columns: time (<code>t</code>), non-invasive arterial
blood pressure (<code>abp</code>), middle cerebral artery velocity measured
using transcranial Doppler (<code>mcav</code>), and heart rate (<code>hr</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(testdata)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"dataframe"</code>; an example of the
usage in <code><a href="#topic+clinmon">clinmon</a></code>-function.
</p>


<h3>References</h3>

<p>Olsen MH et al. (Unpublished data, 2020)
(<a href="https://github.com/lilleoel/clintools">GitHub</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(testdata)
variables &lt;- c("abp","mcav","hr")
clinmon(df.data1000,variables,fast=50)
</code></pre>

<hr>
<h2 id='df.deleter'>Test-deleter</h2><span id='topic+df.deleter'></span>

<h3>Description</h3>

<p>Deleter dataframe with two columns: start (<code>start</code>) and
end (<code>end</code>) of the deleter-period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(testdata)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"dataframe"</code>; an example of the
usage in <code><a href="#topic+clinmon">clinmon</a></code>-function.
</p>


<h3>References</h3>

<p>Olsen MH et al. (Unpublished data, 2020) (<a href="https://github.com/lilleoel/clintools">GitHub</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(testdata)
variables &lt;- c("abp","mcav","hr")
clinmon(df.data1000,variables,deleter=df.deleter,fast=50)
</code></pre>

<hr>
<h2 id='dilations'>Assess dilations from <code>PLR3000</code>-output.</h2><span id='topic+dilations'></span>

<h3>Description</h3>

<p><code>dilations()</code> is a function which converts longformat recording of pupillary size and uses markers to generate a dataframe, plot, and markdown output to inspect the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dilations(pupils, markers,
  remove_markers = NULL, add_markers = NULL,
  not_assess = NULL, artefacts_static = c(0.55,9.95),
  artefacts_dynamic = c(`1` = 1.5, `0.66` = 1, `0.33` = 0.5),
  time_assess = c(`1` = 10, `3` = 5),
  sig.level = 0.05, min_change = NULL,
  resting_delay = c(`3` = 0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dilations_+3A_pupils">pupils</code></td>
<td>
<p>recording of pupillary function. long format dataframe with at least three columns: record_id, time, and size.</p>
</td></tr>
<tr><td><code id="dilations_+3A_markers">markers</code></td>
<td>
<p>time of markers. long format dataframe with at least two columns: record_id and time.</p>
</td></tr>
<tr><td><code id="dilations_+3A_remove_markers">remove_markers</code></td>
<td>
<p>markers which should be removed. long format dataframe with at least two columns: record_id and time. The time column need one decimal.</p>
</td></tr>
<tr><td><code id="dilations_+3A_add_markers">add_markers</code></td>
<td>
<p>markers which should be added. long format dataframe with at least two columns: record_id and time. The time column need one decimal.</p>
</td></tr>
<tr><td><code id="dilations_+3A_not_assess">not_assess</code></td>
<td>
<p>a list of record ids which should no be assessed.</p>
</td></tr>
<tr><td><code id="dilations_+3A_artefacts_static">artefacts_static</code></td>
<td>
<p>a list of the limits of the artefacts. The first number in the list is the minimum size to be assessed and the second is the maximum size to be assessed</p>
</td></tr>
<tr><td><code id="dilations_+3A_artefacts_dynamic">artefacts_dynamic</code></td>
<td>
<p>a named list where max change in millimeter within the duration (name in list) is removed. Will use the first 1 second of the recording to create a baseline, thus suspectible to artefacts in the start of the recording.</p>
</td></tr>
<tr><td><code id="dilations_+3A_time_assess">time_assess</code></td>
<td>
<p>This named list define the number of seconds which should be used in the assessment of dilatios. The name is the number of periods-of-interest and the value is the seconds.</p>
</td></tr>
<tr><td><code id="dilations_+3A_sig.level">sig.level</code></td>
<td>
<p>This is the significance level to be used when comparing the size of the period-of-interest. The significance level corresponds to the Wilcox.test used.</p>
</td></tr>
<tr><td><code id="dilations_+3A_min_change">min_change</code></td>
<td>
<p>This is the minimum size of mm which needs to change before a dilation can be identified. Default is no minimum requirement.</p>
</td></tr>
<tr><td><code id="dilations_+3A_resting_delay">resting_delay</code></td>
<td>
<p>This can be used if the subsequent resting period to compare should be delayed, i.e. if we should wait 5 second for those investigations with three periods of interest create a named list with periods of interest as names and seconds to delay as input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a nested list one dataframe of the results ($dilations), plot ($plot$id[record id]), and a markdown output ($plot$markdown$id[record_id]). The dilations dataframe include the following columns: Record ID (record_id); Patient ID (pt_id); Date (date); pupil side (side); start of the period (min); end of the period (max); length of period (rec_length); number of measurements (n); median size (median); P value when comparing with the previous period (p_before); P value when comparing with the following period (p_after); and if dilation is identified (dilation, 1 is successful dilation and 0 is no dilation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
   recordings &lt;- PLR3000("C:/PLR3000/R_20200105_205901.xls")
   dilations &lt;- dilations(recordings$pupils,recordings$markers)

   # The dataframe of the results
   dilations$dilations

   # The plot of one of the recordings
   dilations$plot$id833

   # The markdown output of one of the recordings
   dilations$markdown$id833

 
## End(Not run)

</code></pre>

<hr>
<h2 id='iscus'>ISCUSFlex-values to dataframe  (iscus)</h2><span id='topic+iscus'></span>

<h3>Description</h3>

<p><code>iscus()</code> is a function which converts XML files extracted
from the Microdialysis-apparatur of ISCUSFlex apparatus to a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iscus(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iscus_+3A_filename">filename</code></td>
<td>
<p>path to the XML-file with the measurements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with the measurements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
   iscus("C:/ISCUSfiles/7888e844-1c7a-40af-a3f2-3bb27a8dd9e5.xml")
 
## End(Not run)

</code></pre>

<hr>
<h2 id='ortable'>Logistic regression table with Odds ratio (ortable)</h2><span id='topic+ortable'></span>

<h3>Description</h3>

<p><code>ortable()</code> is a small function which utilises the output from the glm-function to print a dataframe with odds ratio, confidence limits, and p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortable(x, d, d_p, intercept, simple)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ortable_+3A_x">x</code></td>
<td>
<p>Utilises the output from a glm-function. (<code>glm-output</code>)</p>
</td></tr>
<tr><td><code id="ortable_+3A_d">d</code></td>
<td>
<p>Refers to the number of digits for odds ratio and confidence intervals. Default is <code>2</code>. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="ortable_+3A_d_p">d_p</code></td>
<td>
<p>Refers to the number of digits for odds ratio and confidence intervals. Default is <code>3</code>. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="ortable_+3A_intercept">intercept</code></td>
<td>
<p>The intercept is presented in the table if <code>TRUE</code>. Default is <code>FALSE</code>. (<code>boolian</code>)</p>
</td></tr>
<tr><td><code id="ortable_+3A_simple">simple</code></td>
<td>
<p>Odds ratio and confidence intervals are merged into one column if <code>TRUE</code>. Default is <code>TRUE</code>. (<code>boolian</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a dataframe with with odds ratio,
confidence limits, and p-values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(outcome=sample(0:1, 100,replace=TRUE),
        var=sample(0:100,100,replace=TRUE))
ortable(glm(outcome ~ ., data=df))

</code></pre>

<hr>
<h2 id='PLR3000'>NeurOpticsTM PLR-3000 pupillometer file to dataframe (PLR3000)</h2><span id='topic+PLR3000'></span>

<h3>Description</h3>

<p><code>PLR3000()</code> is a function which converts the XLS file imported from the eurOpticsTM PLR-3000 pupillometer to a nested list with two dataframes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PLR3000(filename = NULL, df = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PLR3000_+3A_filename">filename</code></td>
<td>
<p>path to the XLS-file with the measurements</p>
</td></tr>
<tr><td><code id="PLR3000_+3A_df">df</code></td>
<td>
<p>the dataframe can also be used for the function if data is already imported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with two dataframe, one with the measurements (pupils) and one with the markers (markers).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
   PLR3000("C:/PLR3000/R_20200105_205901.xls")
 
## End(Not run)

</code></pre>

<hr>
<h2 id='questionaire'>Calculate scores from questionaire (questionaire)</h2><span id='topic+questionaire'></span>

<h3>Description</h3>

<p><code>questionaire()</code> is a function which calculates scores from a questionaire.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>questionaire(df,id,questions,scale,setting,prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="questionaire_+3A_df">df</code></td>
<td>
<p>dataframe. (<code>df</code>)</p>
</td></tr>
<tr><td><code id="questionaire_+3A_id">id</code></td>
<td>
<p>Column name of participant id (<code>string</code>)</p>
</td></tr>
<tr><td><code id="questionaire_+3A_questions">questions</code></td>
<td>
<p>Column names of ordered list of questions (<code>list</code>)</p>
</td></tr>
<tr><td><code id="questionaire_+3A_scale">scale</code></td>
<td>
<p>name of the questionaire (<code>string</code>)</p>
</td></tr>
<tr><td><code id="questionaire_+3A_setting">setting</code></td>
<td>
<p>questionaire specific settings (<code>string</code>)</p>
</td></tr>
<tr><td><code id="questionaire_+3A_prefix">prefix</code></td>
<td>
<p>prefix of column names of questionaire scores (<code>string</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns summarised information in dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

   df &lt;- df_b[,grepl("ssid|KIDSCREEN52_D_",colnames(df_b))][,c(1:53)]
   k52 &lt;- questionaire(df,id = "ssid",
   questions=colnames(df)[grepl("KIDSCREEN",colnames(df))],
   scale="Kidscreen-52",
   setting="proxy")#'

## End(Not run)

</code></pre>

<hr>
<h2 id='quietly'>Quiet any output (quietly)</h2><span id='topic+quietly'></span>

<h3>Description</h3>

<p><code>quietly()</code> is a small function which suppresses any output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quietly(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quietly_+3A_x">x</code></td>
<td>
<p>input to be suppressed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns x, but without any output
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tmp &lt;- quietly(print("hello"))

## End(Not run)
</code></pre>

<hr>
<h2 id='recol'>Reorder column (recol)</h2><span id='topic+recol'></span>

<h3>Description</h3>

<p><code>recol()</code> is a small function which can rename columns and change factors to relevant input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recol(df, old, new, factors=NULL, remove=TRUE, na=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recol_+3A_df">df</code></td>
<td>
<p>dataframe. (<code>df</code>)</p>
</td></tr>
<tr><td><code id="recol_+3A_old">old</code></td>
<td>
<p>old column name. (<code>string</code>)</p>
</td></tr>
<tr><td><code id="recol_+3A_new">new</code></td>
<td>
<p>new column name. (<code>string</code>)</p>
</td></tr>
<tr><td><code id="recol_+3A_factors">factors</code></td>
<td>
<p>Named list of factors. If no names then just in alphabetical order (<code style="white-space: pre;">&#8288;named list&#8288;</code>)</p>
</td></tr>
<tr><td><code id="recol_+3A_remove">remove</code></td>
<td>
<p>remove old column from dataframe (<code>boolian</code>)</p>
</td></tr>
<tr><td><code id="recol_+3A_na">na</code></td>
<td>
<p>the na.strings (<code>list</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the dataframe with new columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # NUMERIC VARIABLE
   df &lt;- recol(df, "X5d_55_Alcohol_127", "Alcohol")
   # FACTOR VARIABLE
   df &lt;- recol(df, "X5d_55_Alcohol_127", "Alcohol", factors=c("No","Yes"))

## End(Not run)

</code></pre>

<hr>
<h2 id='rowMedians'>find median of rows similar to rowMeans (rowMedians)</h2><span id='topic+rowMedians'></span>

<h3>Description</h3>

<p><code>rowMedians()</code> converts a dataframe to a list of row medians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMedians(x, na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMedians_+3A_x">x</code></td>
<td>
<p>a dataframe where median of row should be calculated. (<code>data.frame</code>)</p>
</td></tr>
<tr><td><code id="rowMedians_+3A_na.rm">na.rm</code></td>
<td>
<p>Should missing values be omitted fro the calculations? (<code>boolian</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the median of each row in the inputted dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   rowMedians(df[,c("test1","test2","test3")])

## End(Not run)

</code></pre>

<hr>
<h2 id='rrGcomp'>Relative risk derived by G-computation (rrGcomp)</h2><span id='topic+rrGcomp'></span><span id='topic+print.rrGcomp'></span>

<h3>Description</h3>

<p><code>rrGcomp()</code> is a small function which generates population-level (marginal) relative risks derived by G-computation. For models with random effects mixed-effects generalized linear model with a logit link with adjustment for stratification variables will be used, while those without random effects a logistic regression will be used. The code is based on the method used in the paper by Dankiewicz et al. (2021) N Engl J Med. Jun 17;384(24):2283-2294. (<a href="https://pubmed.ncbi.nlm.nih.gov/34133859/">PubMed</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrGcomp(df, outcome_col, group_col,
fixed_strata = NULL, random_strata = NULL,
nbrIter = 5000, conf_level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrGcomp_+3A_df">df</code></td>
<td>
<p>the individual participant dataframe</p>
</td></tr>
<tr><td><code id="rrGcomp_+3A_outcome_col">outcome_col</code></td>
<td>
<p>column name for the outcome column</p>
</td></tr>
<tr><td><code id="rrGcomp_+3A_group_col">group_col</code></td>
<td>
<p>column name for the group column</p>
</td></tr>
<tr><td><code id="rrGcomp_+3A_fixed_strata">fixed_strata</code></td>
<td>
<p>list of column names for the fixed effect stratification columns</p>
</td></tr>
<tr><td><code id="rrGcomp_+3A_random_strata">random_strata</code></td>
<td>
<p>list of column names for the random effect stratification columns</p>
</td></tr>
<tr><td><code id="rrGcomp_+3A_nbriter">nbrIter</code></td>
<td>
<p>number of iterations to be used in the G-computation. The original paper used 5000, which is also the default.</p>
</td></tr>
<tr><td><code id="rrGcomp_+3A_conf_level">conf_level</code></td>
<td>
<p>the confidence level to be reported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with relative risk (rr), simulated rr (simRR), lower- and upper confidence level (simLCL/simUCL), and the p-value (p_val)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- sRCT(n_sites=3,n_pop=50)
rrGcomp(df,outcome_col="outcome",group_col="Var1",random_strata="site",nbrIter=10)

</code></pre>

<hr>
<h2 id='sRCT'>simulated Randomised Clinical Trial (sRCT)</h2><span id='topic+sRCT'></span>

<h3>Description</h3>

<p><code>sRCT()</code> is a function which simulates a randomised clinical trial with a binary outcome and returns a dataframe. This version is validated to be used for analysis of interaction in a factorial design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sRCT(all_sizes = NULL, n_pop = 1000,
n_sites = 10, design = c(2,2,2),
rrr = c(0.05,0.05,0), outcome_risk = 0.492,
interaction = c(`1-2` = 0.05, `1-2-3` = -0.05),
site_re = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sRCT_+3A_all_sizes">all_sizes</code></td>
<td>
<p>Size of blocks in allocation table. If left empty the three lowest possible block sizes will be randomly assigned.</p>
</td></tr>
<tr><td><code id="sRCT_+3A_n_pop">n_pop</code></td>
<td>
<p>Number of participants included in the trial.</p>
</td></tr>
<tr><td><code id="sRCT_+3A_n_sites">n_sites</code></td>
<td>
<p>Number of sites</p>
</td></tr>
<tr><td><code id="sRCT_+3A_design">design</code></td>
<td>
<p>Number of sites as a list where each element corresponds to an intervention and the number in the element is the number of groups. So for a 2x2 factorial design <code>c(2,2)</code> should be used.</p>
</td></tr>
<tr><td><code id="sRCT_+3A_rrr">rrr</code></td>
<td>
<p>relative risk reduction for each intervention so for the abovementioned 2x2 factorial design with RRR of 0.05 and 0.10 we would use <code>c(0.05,0.10)</code>.</p>
</td></tr>
<tr><td><code id="sRCT_+3A_outcome_risk">outcome_risk</code></td>
<td>
<p>The baseline risk (probability in absolute percentage) of the dichotomous primary outcome.</p>
</td></tr>
<tr><td><code id="sRCT_+3A_interaction">interaction</code></td>
<td>
<p>Interaction between interventions with a named list. If interaction exists between intervention 1 and 2 we would use <code>1-2 = 0.05</code>.</p>
</td></tr>
<tr><td><code id="sRCT_+3A_site_re">site_re</code></td>
<td>
<p>The size of the random effect of site, default is <code>0.05</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sRCT function is continuously being developed to answer specific questions in simulation studies. sRCT will be updated and tested for each specific question. For each update the function will be validated for the current purpose and all previous purposes. sRCT is not validated for all simulation studies
</p>


<h3>Value</h3>

<p>Returns a dataframe with an individual participant data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sRCT()

</code></pre>

<hr>
<h2 id='tbl'>Create a table (tbl)</h2><span id='topic+tbl'></span>

<h3>Description</h3>

<p><code>tbl()</code> is a function which create a dataframe, which can be copied directly into
word or presented in as a summary table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl(df,strata,vars,render.numeric,
render.factor, tests, paired,
   digs_n,digs_f, digs_p, digs_s,
   only_stats, strata.fixed, strata.random,
   time.to, present.missing, markdown, caption)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_+3A_df">df</code></td>
<td>
<p>dataframe. (<code>df</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_strata">strata</code></td>
<td>
<p>Column name of stratification (<code>string</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_vars">vars</code></td>
<td>
<p>Column names of variables of interest (<code>list</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_render.numeric">render.numeric</code></td>
<td>
<p>list of presentation of numeric variables (<code>list</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_render.factor">render.factor</code></td>
<td>
<p>presentation of factors, with <code>simple</code> removing one factor when only two exists</p>
</td></tr>
<tr><td><code id="tbl_+3A_tests">tests</code></td>
<td>
<p>list of tests carried out, currently the following works: <code>t.test</code>, <code>wilcox.test</code>, <code>fisher.test</code>, <code>auc</code>, <code>lm</code>, and <code>glm</code>. (<code>list</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_paired">paired</code></td>
<td>
<p>if tests should be paired (<code>boolean</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_digs_n">digs_n</code></td>
<td>
<p>digits for numeric (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_digs_f">digs_f</code></td>
<td>
<p>digits for factors (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_digs_p">digs_p</code></td>
<td>
<p>digits for p-values (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_digs_s">digs_s</code></td>
<td>
<p>digits for statistics (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_only_stats">only_stats</code></td>
<td>
<p>if only stats should be presented (<code>booolean</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_strata.fixed">strata.fixed</code></td>
<td>
<p>list of columns which should be used as fixed stratification (<code>list</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_strata.random">strata.random</code></td>
<td>
<p>list of columns which should be used as random stratification (<code>list</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_time.to">time.to</code></td>
<td>
<p>Column name of the time column for cox regression (<code>list</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_present.missing">present.missing</code></td>
<td>
<p>default is dynamic where non-missing variables are not presented.</p>
</td></tr>
<tr><td><code id="tbl_+3A_markdown">markdown</code></td>
<td>
<p>default is true and output is pander, while false output is a dataframe (<code>boolean</code>)</p>
</td></tr>
<tr><td><code id="tbl_+3A_caption">caption</code></td>
<td>
<p>Table caption only in use when markdown is true (<code>string</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns summarised information in dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   hmm &lt;- tbl(df,strata="group",
   vars = c("Gestational Age at birth","Maternal preeclampsia"),
   tests=c("wilcox.test","glm"),only_stats=F,strata.random = "site",
   markdown=F)
   pander::pander(hmm, keep.line.breaks = TRUE,split.tables=Inf, row.names = F)

## End(Not run)

</code></pre>

<hr>
<h2 id='testdata10'>Test-data - 10 Hz</h2><span id='topic+testdata10'></span><span id='topic+df.data10'></span>

<h3>Description</h3>

<p>Recording with four columns: time (<code>t</code>), non-invasive arterial
blood pressure (<code>abp</code>), middle cerebral artery velocity measured
using transcranial Doppler (<code>mcav</code>), and heart rate (<code>hr</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(testdata)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"dataframe"</code>; an example of the
usage in <code><a href="#topic+clinmon">clinmon</a></code>-function.
</p>


<h3>References</h3>

<p>Olsen MH et al. (Unpublished data, 2020) (<a href="https://github.com/lilleoel/clintools">GitHub</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(testdata)
variables &lt;- c("abp","mcav","hr")
clinmon(df.data10,variables,freq=10)
</code></pre>

<hr>
<h2 id='TFA'>Transfer function analysis of dynamic cerebral autoregulation (TFA)</h2><span id='topic+TFA'></span>

<h3>Description</h3>

<p><code>TFA()</code> calculates dynamic cerebral autoregulation trough a transfer function analysis from a <em>continuous</em> recording. This function follows the recommendations from Claassen et al. [1] and mimicks the matlab script created by David Simpsons in 2015 (<a href="https://www.car-net.org/tools">Matlab TFA function</a>). <code>TFA()</code> also includes the possibility to analyse raw recordings with application of cyclic (beat-to-beat) average with the possiblity of utilizing interpolation. (see <strong>details</strong>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TFA(df, variables,
trigger = NULL, deleter = NULL,
freq = 1000, fast = 50, raw_data = FALSE,
interpolation = 3, output = "table",
vlf = c(0.02,0.07),lf = c(0.07,0.2),
hf = c(0.2,0.5), detrend = FALSE,
spectral_smoothing = 3,
coherence2_thresholds = cbind(c(3:15),
c(0.51,0.40,0.34,0.29,0.25,0.22,0.20,0.18,
0.17,0.15,0.14,0.13,0.12)),
apply_coherence2_threshold = TRUE,
remove_negative_phase = TRUE,
remove_negative_phase_f_cutoff = 0.1,
normalize_ABP = FALSE,
normalize_CBFV = FALSE,
window_type = 'hanning',
window_length = 102.4,
overlap = 59.99,
overlap_adjust = TRUE,
na_as_mean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TFA_+3A_df">df</code></td>
<td>
<p>Raw <em>continuous</em> recording with numeric data and first column has to be time in seconds. (<code>dataframe</code>)</p>
</td></tr>
<tr><td><code id="TFA_+3A_variables">variables</code></td>
<td>
<p>Definition of the type and order of recorded variables as a list. Middle cerebral artery blood velocity (<code>'mcav'</code>) and arterial blood pressure (<code>'abp'</code>) is currently supported. (<code>list</code>)</p>
</td></tr>
<tr><td><code id="TFA_+3A_trigger">trigger</code></td>
<td>
<p>Trigger with two columns:  first is start, and second is end of period to be analyzed. Every row is a period for analysis. Default is <code>NULL</code>, which results in analysis of the full dataframe.  (<code>dataframe</code>)</p>
</td></tr>
<tr><td><code id="TFA_+3A_deleter">deleter</code></td>
<td>
<p>Deleter with two columns: first is start and second is end of period with artefacts, which need to be deleted. Every row is a period with artefacts. Default is <code>NULL</code>. (<code>dataframe</code>)</p>
</td></tr>
<tr><td><code id="TFA_+3A_freq">freq</code></td>
<td>
<p>Frequency of recorded data, in Hz. Default is <code>1000</code>. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="TFA_+3A_fast">fast</code></td>
<td>
<p>Select if you want the data to aggregated resulting in a faster, but perhaps more imprecise run, in Hz. Default is <code>50</code> (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="TFA_+3A_raw_data">raw_data</code></td>
<td>
<p>Select <code>TRUE</code> if the data is raw and cyclic mean should be calculated. <strong>NB:</strong> this function have not been validated, why validated methods for calculating cyclic mean are preferred. Only 1 period can be analysed using raw_data. Default is <code>FALSE</code> (<code>boolian</code>)</p>
</td></tr>
<tr><td><code id="TFA_+3A_interpolation">interpolation</code></td>
<td>
<p>Select the number of beats which should be interpolated. Default is up to <code>3</code> beats and <code>0</code> results in no interpolation. (<code>numeric</code>)</p>
</td></tr>
<tr><td><code id="TFA_+3A_output">output</code></td>
<td>
<p>Select what the output should be. <code>'table'</code> results in a dataframe with values for the three frequencies defined by Claassen et al. [1]; <code>'long'</code> results in a dataframe with the results in a long format; <code>'plot'</code> results in a daframe which can help plot gain, phase and coherence; <code>'plot-peak'</code> results in a dataframe, which can be used to validate the cyclic average, and <code>'raw'</code> results in a nested list with results primarily for debugging. Default is <code>'table'</code>. (<code>string</code>)</p>
</td></tr>
<tr><td><code id="TFA_+3A_vlf">vlf</code>, <code id="TFA_+3A_lf">lf</code>, <code id="TFA_+3A_hf">hf</code>, <code id="TFA_+3A_detrend">detrend</code>, <code id="TFA_+3A_spectral_smoothing">spectral_smoothing</code>, <code id="TFA_+3A_coherence2_thresholds">coherence2_thresholds</code></td>
<td>
<p>See <strong>TFA-parameters</strong></p>
</td></tr>
<tr><td><code id="TFA_+3A_apply_coherence2_threshold">apply_coherence2_threshold</code>, <code id="TFA_+3A_remove_negative_phase">remove_negative_phase</code></td>
<td>
<p>See <strong>TFA-parameters</strong></p>
</td></tr>
<tr><td><code id="TFA_+3A_remove_negative_phase_f_cutoff">remove_negative_phase_f_cutoff</code>, <code id="TFA_+3A_normalize_abp">normalize_ABP</code></td>
<td>
<p>See <strong>TFA-parameters</strong></p>
</td></tr>
<tr><td><code id="TFA_+3A_normalize_cbfv">normalize_CBFV</code>, <code id="TFA_+3A_window_type">window_type</code>, <code id="TFA_+3A_window_length">window_length</code>, <code id="TFA_+3A_overlap">overlap</code></td>
<td>
<p>See <strong>TFA-parameters</strong></p>
</td></tr>
<tr><td><code id="TFA_+3A_overlap_adjust">overlap_adjust</code>, <code id="TFA_+3A_na_as_mean">na_as_mean</code></td>
<td>
<p>See <strong>TFA-parameters</strong></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using a <em>continuous</em> raw recording, <code>TFA()</code> calculates dynamic cerebral autoregulation trough a transfer function analysis. This function utilizes the recommendations from Claassen et al [1] and mimicks the matlab script created by David Simpsons in 2015.
</p>
<div class="sourceCode"><pre>View(data)
</pre></div>
<table>
<tr>
 <td style="text-align: right;">
   <code>time</code> </td><td style="text-align: right;"> <code>abp</code> </td><td style="text-align: right;"> <code>mcav</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>7.00</code> </td><td style="text-align: right;"> <code>78</code> </td><td style="text-align: right;"> <code>45</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>7.01</code> </td><td style="text-align: right;"> <code>78</code> </td><td style="text-align: right;"> <code>46</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>301.82</code> </td><td style="text-align: right;"> <code>82</code> </td><td style="text-align: right;"> <code>70</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>301.83</code> </td><td style="text-align: right;"> <code>81</code> </td><td style="text-align: right;"> <code>69</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>To calculate the variables insert the data and select the relevant variables.
</p>
<div class="sourceCode"><pre>TFA(df=data, variables=c("abp","mcav"))
</pre></div>
<p>See <strong>Value</strong> for output description.
</p>


<h3>Value</h3>

<p><code>TFA()</code> returns a dataframe depending on the output selected. <code>'table'</code> results in a dataframe with values for the three frequencies defined by Claassen et al. [1]; <code>'long'</code> results in a dataframe with the results in a long format; <code>'plot'</code> results in a daframe which can help plot gain, phase and coherence; <code>'plot-peak'</code> results in a dataframe, which can be used to validate the cyclic average, and <code>'raw'</code> results in a nested list with results primarily for debugging.
</p>
<p>Some generic variables are listed below:
</p>

<ul>
<li> <p><code>abp_power</code> - The blood pressure power measured in mmHg^2.
</p>
</li>
<li> <p><code>cbfv_power</code> - The cerebral blood flow velocity power measured in cm^2\*s^-2
</p>
</li>
<li> <p><code>coherence</code> - Coherence.
</p>
</li>
<li> <p><code>gain_not_normal</code> - Not normalized gain measured in cm\*s^-1\*mmHg^-1.
</p>
</li>
<li> <p><code>gain_normal</code> - Normalized gain measured in %\*mmHg^-1.
</p>
</li>
<li> <p><code>phase</code> - Phase measured in radians.
</p>
</li></ul>



<h4>output = 'table'</h4>

<p>Wide format output table with period, VLF, LF, and HF as columns, and the TFA-variables as rows.</p>

<table>
<tr>
 <td style="text-align: left;">
   <code>period</code> </td><td style="text-align: right;"> <code>variable</code> </td><td style="text-align: right;"> <code>vlf</code> </td><td style="text-align: right;"> <code>lf</code> </td><td style="text-align: right;"> <code>hf</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>1</code> </td><td style="text-align: right;"> <code>abp_power</code> </td><td style="text-align: right;"> <code>6.25</code> </td><td style="text-align: right;"> <code>1.56</code> </td><td style="text-align: right;"> <code>0.21</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>1</code> </td><td style="text-align: right;"> <code>cbfv_power</code> </td><td style="text-align: right;"> <code>3.22</code> </td><td style="text-align: right;"> <code>2.25</code> </td><td style="text-align: right;"> <code>0.30</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>3</code> </td><td style="text-align: right;"> <code>gain_normal</code> </td><td style="text-align: right;"> <code>1.04</code> </td><td style="text-align: right;"> <code>1.48</code> </td><td style="text-align: right;"> <code>1.85</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>3</code> </td><td style="text-align: right;"> <code>phase</code> </td><td style="text-align: right;"> <code>53.0</code> </td><td style="text-align: right;"> <code>25.4</code> </td><td style="text-align: right;"> <code>9.38</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h4>output = 'long'</h4>

<p>Long format output table which can be manipulated depending on the intended use, with period, interval, variables and values as columns.</p>

<table>
<tr>
 <td style="text-align: right;">
   <code>period</code> </td><td style="text-align: left;"> <code>interval</code> </td><td style="text-align: left;"> <code>variable</code> </td><td style="text-align: right;"> <code>values</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>1</code> </td><td style="text-align: left;"> <code>hf</code> </td><td style="text-align: left;"> <code>abp_power</code> </td><td style="text-align: right;"> <code>6.25</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>1</code> </td><td style="text-align: left;"> <code>hf</code> </td><td style="text-align: left;"> <code>cbfv_power</code> </td><td style="text-align: right;"> <code>3.22</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>...</code> </td><td style="text-align: left;"> <code>...</code> </td><td style="text-align: left;"> <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>2</code> </td><td style="text-align: left;"> <code>vlf</code> </td><td style="text-align: left;"> <code>gain_norm</code> </td><td style="text-align: right;"> <code>1.85</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>2</code> </td><td style="text-align: left;"> <code>vlf</code> </td><td style="text-align: left;"> <code>phase</code> </td><td style="text-align: right;"> <code>9.38</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>




<h4>output = 'plot'</h4>

<p>Plot format output table which can be used to draw figures with gain, phase and coherence depending on frequency.</p>

<table>
<tr>
 <td style="text-align: right;">
   <code>period</code> </td><td style="text-align: right;"> <code>freq</code> </td><td style="text-align: right;"> <code>gain</code> </td><td style="text-align: right;"> <code>phase</code> </td><td style="text-align: right;"> <code>coherence</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>1</code> </td><td style="text-align: right;"> <code>0.00</code> </td><td style="text-align: right;"> <code>0.16</code> </td><td style="text-align: right;"> <code>0.00</code> </td><td style="text-align: right;"> <code>0.04</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>1</code> </td><td style="text-align: right;"> <code>0.01</code> </td><td style="text-align: right;"> <code>0.29</code> </td><td style="text-align: right;"> <code>4.22</code> </td><td style="text-align: right;"> <code>0.29</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td><td style="text-align: right;"> <code>...</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>2</code> </td><td style="text-align: right;"> <code>1.55</code> </td><td style="text-align: right;"> <code>1.15</code> </td><td style="text-align: right;"> <code>-43.2</code> </td><td style="text-align: right;"> <code>0.64</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>2</code> </td><td style="text-align: right;"> <code>1.56</code> </td><td style="text-align: right;"> <code>1.16</code> </td><td style="text-align: right;"> <code>-41.1</code> </td><td style="text-align: right;"> <code>0.42</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>




<h3>TFA-paramters</h3>

<p>A series of parameters that control TFA analysis (window-length, frequency bands …). If this is not provided, default values, corresponding to those recommended in the white paper, will be used. These default values are given below for each parameter.
</p>

<ul>
<li> <p><code>vlf</code> Limits of <em>very low frequency</em> band (in Hz). This corresponds to the matematical inclusion of <code style="white-space: pre;">&#8288;[X:Y[&#8288;</code>. Default is <code>c(0.02-0.07)</code>.
</p>
</li>
<li> <p><code>lf</code> Limits of <em>low frequency</em> band (in Hz). This corresponds to the matematical inclusion of <code style="white-space: pre;">&#8288;[X:Y[&#8288;</code>. Default is <code>c(0.07-0.2)</code>.
</p>
</li>
<li> <p><code>hf</code> Limits of <em>high frequency</em> band (in Hz). This corresponds to the matematical inclusion of <code style="white-space: pre;">&#8288;[X:Y[&#8288;</code>. Default is <code>c(0.2-0.5)</code>.
</p>
</li>
<li> <p><code>detrend</code> Linear detrending of data prior to TFA-analysis (detrending is carried out as one continuous trend over the whole length of the recording, not segment-by-segment). Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>spectral_smoothing</code> The length, in samples, of the triangular spectral smoothing function. Note that this must be an odd number, to ensure that smoothing is symmetrical around the centre frequency. Default is <code>3</code>.
</p>
</li>
<li> <p><code>coherence2_thresholds</code> The critical values (alpha=5%, second column) for coherence for a number of windows (first column, here from 3 to 15). These values were obtained by Monte Carlo simulation, using the default parameter settings for the TFA-analysis (Hanning window, overlap of 50% and 3-point spectral smoothing was assumed). These values should be recalculated for different settings. Note that if <code>overlap_adjust=TRUE</code>, the overlap will vary depending on the length of data. With an overlap of 60% (see below), the critical values increase by between 0.04 (for 3 windows) and 0.02 (for 15 windows). Default is <code style="white-space: pre;">&#8288;cbind(c(3:15),c(0.51,0.40,&#8288;</code> <code style="white-space: pre;">&#8288;0.34,0.29,0.25,0.22,0.20,0.18,0.17,&#8288;</code> <code style="white-space: pre;">&#8288;0.15,0.14,0.13,0.12))&#8288;</code>.
</p>
</li>
<li> <p><code>apply_coherence2_threshold</code> Apply the thresholds given above to the TFA-estimates. All frequencies with magnitude-squared coherence below the threshold value are excluded from averaging when calculating the mean values of gain and phase across the bands. Note that low values of coherence are not excluded in the average of coherence across the bands. Default is <code>TRUE</code>.
</p>
</li>
<li> <p><code>remove_negative_phase</code> Remove (ignore) negative values of phase in averaging across bands. Negative phase values are removed only for frequencies below the frequency given below, when calculating the average phase in bands. Default is <code>TRUE</code>.
</p>
</li>
<li> <p><code>remove_negative_phase_f_cutoff</code> The cut-off frequency below-which negative phase values are neglected (only if <code>remove_negative_phase</code> is <code>TRUE</code>). Default is <code>0.1</code>.
</p>
</li>
<li> <p><code>normalize_ABP</code> Normalize ABP by dividing by the mean and multiplying by 100, to express ABP change in %. Note that mean-values are always removed from ABP prior to analysis. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>normalize_CBFV</code> Normalize CBFV by dividing by the mean and multiplying by 100, to express CBFV change in %. Note that the band-average values of gain are always calculated both with and without normalization of CBFV, in accordance with the recommendations. Note also that mean-values are always removed from CBFV prior to analysis. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>window_type</code> Chose window <code>'hanning'</code> or <code>'boxcar'</code>. Default is <code>'hanning'</code>.
</p>
</li>
<li> <p><code>window_length</code> Length of the data-window, in seconds. Default is <code>102.4</code>.
</p>
</li>
<li> <p><code>overlap</code> Overlap of the windows, in %. If <code>overlap_adjust</code> is <code>TRUE</code> (see below), then this value may be automatically reduced, to ensure that windows cover the full length of data. Default is <code style="white-space: pre;">&#8288;59.99%&#8288;</code> rather than 60%, so that with data corresponding to 5 windows of 100 s at an overlap of 50%, 5 windows are indeed chosen.
</p>
</li>
<li> <p><code>overlap_adjust</code> Ensure that the full length of data is used (i.e. the last window finishes as near as possible to the end of the recording), by adjusting the overlap up to a maximum value given by params.overlap. Default is <code>TRUE</code>.
</p>
</li>
<li> <p><code>na_as_mean</code> Changes all missing non-interpolated values to the mean value of the corresponding variable. This have not been adressed in the paper by Claassen, and to ensure the dataframes are not 'gathered' this should generate the most stable results. Default is <code>TRUE</code>.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> Claassen et al. (2016) J Cereb Blood Flow Metab. 2016 Apr;36(4):665-80. (<a href="https://pubmed.ncbi.nlm.nih.gov/26782760/">PubMed</a>)
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>data(tfa_sample_data)
TFA(tfa_sample_data[,c(1:3)], variables=c("abp","mcav"), freq=10)

</code></pre>

<hr>
<h2 id='tfa_sample_data'>TFA sample data</h2><span id='topic+tfa_sample_data'></span>

<h3>Description</h3>

<p>Dataframe with data provided by Prof. Simpsons, with time (t), arterial blood pressure (abp), left MCAv (mcav_l), right MCAv (mcav_r), and end-tidal CO2 (etco2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tfa_sample_data)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"dataframe"</code>; an example of the
usage in <code><a href="#topic+TFA">TFA</a></code>-function.
</p>


<h3>Source</h3>

<p><a href="https://github.com/lilleoel/clintools">GitHub</a>
</p>


<h3>References</h3>


<ul>
<li><p> Simpsons D (2015) (<a href="https://www.car-net.org/tools">Cerebral Autoregulation Research Network</a>)
</p>
</li>
<li><p> Claassen et al. (2016) J Cereb Blood Flow Metab. 2016 Apr;36(4):665-80. (<a href="https://pubmed.ncbi.nlm.nih.gov/26782760/">PubMed</a>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(tfa_sample_data)
TFA(tfa_sample_data[,c(1:3)], variables=c("abp","mcav"), freq=10)
</code></pre>

<hr>
<h2 id='tfa_sample_data_1'>TFA sample data - 1</h2><span id='topic+tfa_sample_data_1'></span>

<h3>Description</h3>

<p>Dataframe with data provided by Prof. Simpsons, with time (t), arterial blood pressure (abp), left MCAv (mcav_l), right MCAv (mcav_r), and end-tidal CO2 (etco2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tfa_sample_data)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"dataframe"</code>; an example of the
usage in <code><a href="#topic+TFA">TFA</a></code>-function.
</p>


<h3>Source</h3>

<p><a href="https://github.com/lilleoel/clintools">GitHub</a>
</p>


<h3>References</h3>


<ul>
<li><p> Simpsons D (2015) (<a href="https://www.car-net.org/tools">Cerebral Autoregulation Research Network</a>)
</p>
</li>
<li><p> Claassen et al. (2016) J Cereb Blood Flow Metab. 2016 Apr;36(4):665-80. (<a href="https://pubmed.ncbi.nlm.nih.gov/26782760/">PubMed</a>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(tfa_sample_data)
TFA(tfa_sample_data_1[,c(1:3)], variables=c("abp","mcav"), freq=10)
</code></pre>

<hr>
<h2 id='tfa_sample_data_2'>TFA sample data - 2</h2><span id='topic+tfa_sample_data_2'></span>

<h3>Description</h3>

<p>Dataframe with data provided by Prof. Simpsons, with time (t), arterial blood pressure (abp), left MCAv (mcav_l), right MCAv (mcav_r), and end-tidal CO2 (etco2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tfa_sample_data)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"dataframe"</code>; an example of the
usage in <code><a href="#topic+TFA">TFA</a></code>-function.
</p>


<h3>Source</h3>

<p><a href="https://github.com/lilleoel/clintools">GitHub</a>
</p>


<h3>References</h3>


<ul>
<li><p> Simpsons D (2015) (<a href="https://www.car-net.org/tools">Cerebral Autoregulation Research Network</a>)
</p>
</li>
<li><p> Claassen et al. (2016) J Cereb Blood Flow Metab. 2016 Apr;36(4):665-80. (<a href="https://pubmed.ncbi.nlm.nih.gov/26782760/">PubMed</a>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(tfa_sample_data)
TFA(tfa_sample_data_2[,c(1:3)], variables=c("abp","mcav"), freq=10)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
