<!DOCTYPE html><html lang="en-US"><head><title>Help for package mlrv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<script type="text/javascript" src="mathjax-config.js"></script>
<script type="text/javascript" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlrv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mlrv-package'><p>mlrv: Long-Run Variance Estimation in Time Series Regression</p></a></li>
<li><a href='#bregress2'><p>Simulate data from time-varying time series regression model with change points</p></a></li>
<li><a href='#gcv_cov'><p>Generalized Cross Validation</p></a></li>
<li><a href='#heter_covariate'><p>Long memory tests for non-stationary time series regression</p></a></li>
<li><a href='#heter_gradient'><p>Structural stability tests for non-stationary time series regression</p></a></li>
<li><a href='#Heter_LRV'><p>Long-run covariance matrix estimators</p></a></li>
<li><a href='#hk_data'><p>This is data to be included in my package</p></a></li>
<li><a href='#loc_constant'><p>Nonparametric smoothing</p></a></li>
<li><a href='#LocLinear'><p>Local linear Regression</p></a></li>
<li><a href='#lrv_measure'><p>Comparing bias or mse of lrv estimators based on numerical methods</p></a></li>
<li><a href='#MV_critical'><p>Statistics-adapted values for extended minimum volatility selection.</p></a></li>
<li><a href='#MV_critical_cp'><p>Statistics-adapted values for extended minimum volatility selection.</p></a></li>
<li><a href='#MV_ise_heter_critical'><p>MV method</p></a></li>
<li><a href='#Qct_reg'><p>Simulate data from time-varying time series regression model</p></a></li>
<li><a href='#Qt_data'><p>Simulate data from time-varying trend model</p></a></li>
<li><a href='#rule_of_thumb'><p>rule of thumb interval for the selection of smoothing parameter b</p></a></li>
<li><a href='#sim_T'><p>bootstrap distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Long-Run Variance Estimation in Time Series Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Plug-in and difference-based long-run covariance matrix estimation for time series regression. Two applications of hypothesis testing are also provided. The first one is for testing for structural stability in coefficient functions. The second one is aimed at detecting long memory in time series regression. Lujia Bai and Weichi Wu (2024)&lt;<a href="https://doi.org/10.3150%2F23-BEJ1680">doi:10.3150/23-BEJ1680</a>&gt; Zhou Zhou and Wei Biao Wu(2010)&lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2010.00743.x">doi:10.1111/j.1467-9868.2010.00743.x</a>&gt; Jianqing Fan and Wenyang Zhang&lt;<a href="https://doi.org/10.1214%2Faos%2F1017939139">doi:10.1214/aos/1017939139</a>&gt; Lujia Bai and Weichi Wu(2024)&lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasae013">doi:10.1093/biomet/asae013</a>&gt; Dimitris N. Politis, Joseph P. Romano, Michael Wolf(1999)&lt;<a href="https://doi.org/10.1007%2F978-1-4612-1554-7">doi:10.1007/978-1-4612-1554-7</a>&gt; Weichi Wu and Zhou Zhou(2018)&lt;<a href="https://doi.org/10.1214%2F17-AOS1582">doi:10.1214/17-AOS1582</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, numDeriv, magrittr, foreach, doParallel, RcppArmadillo,
mathjaxr, xtable, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, spelling, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-30 13:26:29 UTC; bailujia</td>
</tr>
<tr>
<td>Author:</td>
<td>Lujia Bai [aut, cre],
  Weichi Wu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lujia Bai &lt;bailujia98@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-30 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mlrv-package'>mlrv: Long-Run Variance Estimation in Time Series Regression</h2><span id='topic+mlrv'></span><span id='topic+mlrv-package'></span>

<h3>Description</h3>

<p>Plug-in and difference-based long-run covariance matrix estimation for time series regression. Two applications of hypothesis testing are also provided. The first one is for testing for structural stability in coefficient functions. The second one is aimed at detecting long memory in time series regression. Lujia Bai and Weichi Wu (2024)<a href="https://doi.org/10.3150/23-BEJ1680">doi:10.3150/23-BEJ1680</a> Zhou Zhou and Wei Biao Wu(2010)<a href="https://doi.org/10.1111/j.1467-9868.2010.00743.x">doi:10.1111/j.1467-9868.2010.00743.x</a> Jianqing Fan and Wenyang Zhang<a href="https://doi.org/10.1214/aos/1017939139">doi:10.1214/aos/1017939139</a> Lujia Bai and Weichi Wu(2024)<a href="https://doi.org/10.1093/biomet/asae013">doi:10.1093/biomet/asae013</a> Dimitris N. Politis, Joseph P. Romano, Michael Wolf(1999)<a href="https://doi.org/10.1007/978-1-4612-1554-7">doi:10.1007/978-1-4612-1554-7</a> Weichi Wu and Zhou Zhou(2018)<a href="https://doi.org/10.1214/17-AOS1582">doi:10.1214/17-AOS1582</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lujia Bai <a href="mailto:bailujia98@gmail.com">bailujia98@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Weichi Wu <a href="mailto:wuweichi@mail.tsinghua.edu.cn">wuweichi@mail.tsinghua.edu.cn</a> [contributor]
</p>
</li></ul>


<hr>
<h2 id='bregress2'>Simulate data from time-varying time series regression model with change points</h2><span id='topic+bregress2'></span>

<h3>Description</h3>

<p>Simulate data from time-varying time series regression model with change points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bregress2(nn, cp = 0, delta = 0, type = "norm")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bregress2_+3A_nn">nn</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="bregress2_+3A_cp">cp</code></td>
<td>
<p>number of change points. If cp is between 0 and 1, it specifies the location of the single change point</p>
</td></tr>
<tr><td><code id="bregress2_+3A_delta">delta</code></td>
<td>
<p>double, magnitude of the jump</p>
</td></tr>
<tr><td><code id="bregress2_+3A_type">type</code></td>
<td>
<p>type of distributions of the innovations, default normal. It can also be &quot;t4&quot;, &quot;t5&quot; and &quot;t6&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data, x covariates, y response and e error.
n = 300
data = bregress2(n, 2, 1) # time series regression model with 2 changes points
</p>

<hr>
<h2 id='gcv_cov'>Generalized Cross Validation</h2><span id='topic+gcv_cov'></span>

<h3>Description</h3>

<p>Given a bandwidth, compute its corresponding GCV value <script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcv_cov(bw, t, y, X, verbose = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gcv_cov_+3A_bw">bw</code></td>
<td>
<p>double, bandwidth</p>
</td></tr>
<tr><td><code id="gcv_cov_+3A_t">t</code></td>
<td>
<p>vector, scaled time \([0,1]\)</p>
</td></tr>
<tr><td><code id="gcv_cov_+3A_y">y</code></td>
<td>
<p>vector, response</p>
</td></tr>
<tr><td><code id="gcv_cov_+3A_x">X</code></td>
<td>
<p>matrix, covariates matrix</p>
</td></tr>
<tr><td><code id="gcv_cov_+3A_verbose">verbose</code></td>
<td>
<p>bool, whether to print the  numerator and denominator in GCV value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generalized cross validation value is defined as
\[n^{-1}| Y-\hat{Y}|^2/[1- \mathrm{tr}(Q(b)) / n]^2\]
When computing \(\mathrm{tr}(Q(b))\),
we use the fact that the first derivative of coefficient function is zero at central point
The ith diagonal value of \(Q(b)\) is actually \(x^T(t_i)S^{-1}_{n}x(t_i)\)
where \(S^{-1}_{n}\) means the top left p-dimension square matrix of
\(S_{n}(t_i) = X^T W(t_i) X\), \(W(t_i)\) is the kernel weighted matrix. Details on
the computation of \(S_n\) could be found in <code>LocLinear</code> and its reference
</p>


<h3>Value</h3>

<p>GCV value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param = list(d = -0.2, heter = 2, tvd = 0,
 tw = 0.8, rate = 0.1, cur = 1, center = 0.3,
  ma_rate =  0, cov_tw =  0.2, cov_rate = 0.1,
   cov_center = 0.1, all_tw  = 1, cov_trend = 0.7)
data = Qct_reg(1000, param)
value &lt;- gcv_cov(0.2, (1:1000)/1000, data$y, data$x)
</code></pre>

<hr>
<h2 id='heter_covariate'>Long memory tests for non-stationary time series regression</h2><span id='topic+heter_covariate'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p> Test for long memory of \(e_i\) in the time series regression </p>
<p style="text-align: center;"><i>y_i = x_i &beta;_i + e_i, 1&le; i &le; n</i></p>
<p> where \(x_i\) is the multivariate covariate process with first component 1, \(\beta_i\) is the functional coefficient, \(e_i\) is the error term which can be long memory. In particular,covariates and the error term are allowed to be dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heter_covariate(
  data,
  param = list(B = 2000, lrvmethod = 1, gcv = 1, neighbour = 1, lb = 3, ub = 11, tau_n =
    0.3, type = "KPSS"),
  mvselect = -1,
  bw = 0.2,
  shift = 1,
  verbose_dist = FALSE,
  hyper = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heter_covariate_+3A_data">data</code></td>
<td>
<p>a list with the vector y and the matrix x, for example, list(x=...,y=...).</p>
</td></tr>
<tr><td><code id="heter_covariate_+3A_param">param</code></td>
<td>
<p>a list of parameters, list(B =..., lrvmethod =...,gcv = ..., neighbour =..., lb = ..., ub = ..., tau_n = ..., type = ..., ind = ...)</p>
</td></tr>
<tr><td><code id="heter_covariate_+3A_mvselect">mvselect</code></td>
<td>
<p>the value of moving window parameter \(m\). In addition, mvselect=-1 provides data-driven smoothing parameters via Minimum Volatility of the long-run covariance estimator as proposed in Chapter 9 of Politis et al.(1999), while mvselect = -2 provides data-driven smoothing parameters via Minimum Volatility of the bootstrap statistics, see Bai and Wu (2024a).</p>
</td></tr>
<tr><td><code id="heter_covariate_+3A_bw">bw</code></td>
<td>
<p>the bandwidth parameter in the local linear regression, default 0.2.</p>
</td></tr>
<tr><td><code id="heter_covariate_+3A_shift">shift</code></td>
<td>
<p>modify bw by a factor, default 1.</p>
</td></tr>
<tr><td><code id="heter_covariate_+3A_verbose_dist">verbose_dist</code></td>
<td>
<p>whether to print intermediate results, i.e., the bootstrap distribution and statistics, default FALSE.</p>
</td></tr>
<tr><td><code id="heter_covariate_+3A_hyper">hyper</code></td>
<td>
<p>whether to only print the selected values of the smoothing parameters,\(m\) and \(\tau_n\), default FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>param
</p>

<ul>
<li><p> B, the number of bootstrap simulation, say 2000
*lrvmethod,  the method of long-run variance estimation, lrvmethod = 0 uses the plug-in estimator in Zhou (2010), lrvmethod = 1 offers the debias difference-based estimator in Bai and Wu (2024b), lrvmethod = 2 provides the plug-in estimator using the \(\breve{\beta}\), the pilot estimator proposed in Bai and Wu (2024b)
</p>
</li>
<li><p> gcv,  1 or 0, whether to use Generalized Cross Validation for the selection of \(b\), the bandwidth parameter in the local linear regression
</p>
</li>
<li><p> neighbour, the number of neighbours in the extended minimum volatility, for example 1,2 or 3
</p>
</li>
<li><p> lb, the lower bound of the range of \(m\) in the extended minimum volatility Selection
</p>
</li>
<li><p> ub,  the upper bound of the range of \(m\) in the extended minimum volatility Selection
</p>
</li>
<li><p> bw_set, the proposed grid of the range of bandwidth selection. if not presented, a rule of thumb method will be used for the data-driven range
</p>
</li>
<li><p> tau_n,  the value of \(\tau\) when no data-driven selection is used. if \(\tau\) is set to \(0\), the rule of thumb \(n^{-2/15}\) will be used
</p>
</li>
<li><p> type, c( &quot;KPSS&quot;,&quot;RS&quot;,&quot;VS&quot;,&quot;KS&quot;) type of tests, see  Bai and Wu (2024a).
</p>
</li>
<li><p> ind,  types of kernels
</p>
</li>
<li><p> 1 Triangular \(1-|u|\), \(u \le 1\)
</p>
</li>
<li><p> 2 Epanechnikov kernel \(3/4(1 - u^{2})\), \(u \le 1\)
</p>
</li>
<li><p> 3 Quartic \(15/16(1 - u^{2})^{2}\), \(u \le 1\)
</p>
</li>
<li><p> 4 Triweight \(35/32(1 - u^{2})^{3}\), \(u \le 1\)
</p>
</li>
<li><p> 5 Tricube  \(70/81(1 - |u|^{3})^{3}\), \(u \le 1\)
</p>
</li></ul>



<h3>Value</h3>

<p>p-value of the long memory test
</p>


<h3>mlrv functions</h3>

<p>Heter_LRV, heter_covariate, heter_gradient, gcv_cov, MV_critical
</p>


<h3>References</h3>

<p>Bai, L., &amp; Wu, W. (2024a). Detecting long-range dependence for time-varying linear models. Bernoulli, 30(3), 2450-2474.
</p>
<p>Bai, L., &amp; Wu, W. (2024b). Difference-based covariance matrix estimation in time series nonparametric regression with application to specification tests. Biometrika, asae013.
</p>
<p>Zhou, Z. and Wu, W. B. (2010). Simultaneous inference of linear models with time varying coefficients.J. R. Stat. Soc. Ser. B. Stat. Methodol., 72(4):513–531.
</p>
<p>Politis, D. N., Romano, J. P., and Wolf, M. (1999). Subsampling. Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param = list(d = -0.2, heter = 2, tvd = 0,
 tw = 0.8, rate = 0.1, cur = 1,
 center = 0.3, ma_rate =  0, cov_tw =  0.2,
 cov_rate = 0.1, cov_center = 0.1, all_tw  = 1, cov_trend = 0.7)
data = Qct_reg(1000, param)
### KPSS test B
heter_covariate(data, list(B=20, lrvmethod = 1,
gcv = 1, neighbour = 1, lb = 3, ub = 11, type = "KPSS"), mvselect = -2, verbose_dist = TRUE)
</code></pre>

<hr>
<h2 id='heter_gradient'>Structural stability tests for non-stationary time series regression</h2><span id='topic+heter_gradient'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p> Test for long memory of \(e_i\) in the time series regression \[y_i = x_i \beta_i + e_i, 1\leq i \leq n\] where \(x_i\) is the multivariate covariate process with first component 1, \(\beta_i\) is the coefficient, \(e_i\) is the error term which can be long memory. The goal is to test whether the null hypothesis  \[\beta_1 = \ldots = \beta_n = \beta\] holds. The alternative hypothesis is that the coefficient function \(\beta_i\) is time-varying.  Covariates and the error term are allowed to be dependent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heter_gradient(data, param, mvselect = -1, verbose_dist = FALSE, hyper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heter_gradient_+3A_data">data</code></td>
<td>
<p>a list with the vector y (response) and the matrix x (covariates), for example, list(x=...,y=...).</p>
</td></tr>
<tr><td><code id="heter_gradient_+3A_param">param</code></td>
<td>
<p>a list of parameters, list(B =..., lrvmethod =...,gcv = ..., neighbour =..., lb = ..., ub = ..., tau_n = ..., type = ..., ind = ...)</p>
</td></tr>
<tr><td><code id="heter_gradient_+3A_mvselect">mvselect</code></td>
<td>
<p>the value of moving window parameter \(m\). In addition, mvselect=-1 provides data-driven smoothing parameters via Minimum Volatility of the long-run covariance estimator, while mvselect = -2 provides data-driven smoothing parameters via Minimum Volatility of the bootstrap statistics.</p>
</td></tr>
<tr><td><code id="heter_gradient_+3A_verbose_dist">verbose_dist</code></td>
<td>
<p>whether to print intermediate results, i.e., the bootstrap distribution and statistics, default FALSE.</p>
</td></tr>
<tr><td><code id="heter_gradient_+3A_hyper">hyper</code></td>
<td>
<p>whether to only print the selected values of the smoothing parameters,\(m\) and \(\tau_n\), default FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>param
</p>

<ul>
<li><p> B, the number of bootstrap simulation, say 2000
</p>
</li>
<li><p> lrvmethod  the method of long-run variance estimation, lrvmethod = -1 uses the ols plug-in estimator as in Wu and Zhou (2018), lrvmethod = 0 uses the plug-in estimator in Zhou (2010), lrvmethod = 1 offers the debias difference-based estimator in Bai and Wu (2024), lrvmethod = 2 provides the plug-in estimator using the \(\breve{\beta}\), the pilot estimator proposed in Bai and Wu (2024)
</p>
</li>
<li><p> gcv,  1 or 0, whether to use Generalized Cross Validation for the selection of \(b\), the bandwidth parameter in the local linear regression, which will not be used when lrvmethod is -1, 1 or 2.
</p>
</li>
<li><p> neighbour, the number of neighbours in the extended minimum volatility, for example 1,2 or 3
</p>
</li>
<li><p> lb, the lower bound of the range of \(m\) in the extended minimum volatility Selection
</p>
</li>
<li><p> ub,  the upper bound of the range of \(m\) in the extended minimum volatility Selection
</p>
</li>
<li><p> bw_set, the proposed grid of the range of bandwidth selection, which is only useful when lrvmethod = 1. if not presented, a rule of thumb method will be used for the data-driven range.
</p>
</li>
<li><p> tau_n,  the value of \(\tau\) when no data-driven selection is used. if \(tau\) is set to \(0\), the rule of thumb \(n^{-1/5}\) will be used
</p>
</li>
<li><p> type, default 0, uses the residual-based statistic proposed in Wu and Zhou (2018). &ldquo;type&rdquo; can also be set to -1, using the coefficient-based statistic in Wu and Zhou (2018).
</p>
</li>
<li><p> ind,  types of kernels
</p>
</li>
<li><p> 1 Triangular \(1-|u|\), \(u \le 1\)
</p>
</li>
<li><p> 2 Epanechnikov kernel \(3/4(1 - u^{2})\), \(u \le 1\)
</p>
</li>
<li><p> 3 Quartic \(15/16(1 - u^{2})^{2}\), \(u \le 1\)
</p>
</li>
<li><p> 4 Triweight \(35/32(1 - u^{2})^{3}\), \(u \le 1\)
</p>
</li>
<li><p> 5 Tricube  \(70/81(1 - |u|^{3})^{3}\), \(u \le 1\)
</p>
</li></ul>



<h3>Value</h3>

<p>p-value of the structural stability test
</p>


<h3>References</h3>

<p>Bai, L., &amp; Wu, W. (2024). Difference-based covariance matrix estimation in time series nonparametric regression with application to specification tests. Biometrika, asae013.
</p>
<p>Wu, W., and Zhou, Z. (2018). Gradient-based structural change detection for nonstationary time series M-estimation. The Annals of Statistics, 46(3), 1197-1224.
</p>
<p>Politis, D. N., Romano, J. P., and Wolf, M. (1999). Subsampling. Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># choose a small B for tests
param = list(B = 50, bw_set = c(0.15, 0.25), gcv =1, neighbour = 1, lb = 10, ub = 20, type = 0)
n = 300
data = bregress2(n, 2, 1) # time series regression model with 2 changes points
param$lrvmethod = 0 # plug-in
heter_gradient(data, param, 4, 1)
param$lrvmethod = 1 # difference based
heter_gradient(data, param, 4, 1)
</code></pre>

<hr>
<h2 id='Heter_LRV'>Long-run covariance matrix estimators</h2><span id='topic+Heter_LRV'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script><p> The function provides a wide range of estimators for the long-run covariance matrix estimation in non-stationary time series with covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Heter_LRV(
  e,
  X,
  m,
  tau_n = 0,
  lrv_method = 1L,
  ind = 2L,
  print_deg = 0L,
  rescale = 0L,
  ncp = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Heter_LRV_+3A_e">e</code></td>
<td>
<p>vector, if the plug-in estimator is used, e should be the vector of residuals, OLS or nonparametric ones. If the difference-based debiased method is adopted, e should be the response time series, i.e., \(y\). Specially, e should also be the response time series, i.e., \(y\), if the plug-in estimator using the \(\breve{\beta}\), the pilot estimator proposed in Bai and Wu (2024).</p>
</td></tr>
<tr><td><code id="Heter_LRV_+3A_x">X</code></td>
<td>
<p>a matrix \(n\times p\)</p>
</td></tr>
<tr><td><code id="Heter_LRV_+3A_m">m</code></td>
<td>
<p>integer, the window size.</p>
</td></tr>
<tr><td><code id="Heter_LRV_+3A_tau_n">tau_n</code></td>
<td>
<p>double, the smoothing parameter in the estimator. If tau_n is 0, a rule-of-thumb value will be automatically used.</p>
</td></tr>
<tr><td><code id="Heter_LRV_+3A_lrv_method">lrv_method</code></td>
<td>
<p>the method of long-run variance estimation, lrvmethod = 0 uses the plug-in estimator in Zhou (2010), lrvmethod = 1 offers the debias difference-based estimator in Bai and Wu (2024), lrvmethod = 2 provides the plug-in estimator using the \(\breve{\beta}\), the pilot estimator proposed in Bai and Wu (2024)</p>
</td></tr>
<tr><td><code id="Heter_LRV_+3A_ind">ind</code></td>
<td>
<p>types of kernels</p>
</td></tr>
<tr><td><code id="Heter_LRV_+3A_print_deg">print_deg</code></td>
<td>
<p>bool, whether to print information of non-positiveness, default 0\(n\times p\)</p>
</td></tr>
<tr><td><code id="Heter_LRV_+3A_rescale">rescale</code></td>
<td>
<p>bool, whether to use rescaling to correct the negative eigenvalues, default 0</p>
</td></tr>
<tr><td><code id="Heter_LRV_+3A_ncp">ncp</code></td>
<td>
<p>1 no change points, 0 possible change points
</p>

<ul>
<li><p> 1 Triangular \(1-|u|\), \(u \le 1\)
</p>
</li>
<li><p> 2 Epanechnikov kernel \(3/4(1-u^{2})\), \(u \le 1\)
</p>
</li>
<li><p> 3 Quartic \(15/16(1-u^{2})^{2}\), \(u \le 1\)
</p>
</li>
<li><p> 4 Triweight \(35/32(1-u^{2})^{3}\), \(u \le 1\)
</p>
</li>
<li><p> 5 Tricube  \(70/81(1-|u|^{3})^{3}\), \(u \le 1\)
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a cube. The time-varying long-run covariance matrix \(p \times p \times n\), where <i>p</i> is the dimension of the time series vector, and <i>n</i> is the sample size.
</p>


<h3>References</h3>

<p>Bai, L., &amp; Wu, W. (2024). Difference-based covariance matrix estimation in time series nonparametric regression with application to specification tests. Biometrika, asae013.
</p>
<p>Zhou, Z. and Wu, W. B. (2010). Simultaneous inference of linear models with time varying coefficients.J. R. Stat. Soc. Ser. B. Stat. Methodol., 72(4):513–531.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param = list(d = -0.2, heter = 2, tvd = 0,
tw = 0.8, rate = 0.1, cur = 1, center = 0.3,
ma_rate =  0, cov_tw =  0.2, cov_rate = 0.1,
cov_center = 0.1, all_tw  = 1, cov_trend = 0.7)
data = Qct_reg(1000, param)
sigma = Heter_LRV(data$y, data$x, 3, 0.3, lrv_method = 1)
</code></pre>

<hr>
<h2 id='hk_data'>This is data to be included in my package</h2><span id='topic+hk_data'></span>

<h3>Description</h3>

<p>This is data to be included in my package
</p>


<h3>Author(s)</h3>

<p>T. S. Lau
</p>


<h3>References</h3>

<p>Fan, J., and Zhang, W. (1999). Statistical estimation in varying coefficient models. The annals of Statistics, 27(5), 1491-1518.
</p>

<hr>
<h2 id='loc_constant'>Nonparametric smoothing</h2><span id='topic+loc_constant'></span>

<h3>Description</h3>

<p>Nonparametric smoothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loc_constant(bw, x, y, db_kernel = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loc_constant_+3A_bw">bw</code></td>
<td>
<p>double, bandwidth, between 0 and 1.</p>
</td></tr>
<tr><td><code id="loc_constant_+3A_x">x</code></td>
<td>
<p>vector, covariates</p>
</td></tr>
<tr><td><code id="loc_constant_+3A_y">y</code></td>
<td>
<p>matrix, response variables</p>
</td></tr>
<tr><td><code id="loc_constant_+3A_db_kernel">db_kernel</code></td>
<td>
<p>bool, whether to use jackknife kernel, default 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of smoothed values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 800
p &lt;- 3
t &lt;- (1:n)/n
V &lt;-  matrix(rnorm(n * p), nrow = p)
V3 &lt;- loc_constant(0.2, t, V,1)
</code></pre>

<hr>
<h2 id='LocLinear'>Local linear Regression</h2><span id='topic+LocLinear'></span>

<h3>Description</h3>

<p>Local linear estimates for time varying coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocLinear(bw, t, y, X, db_kernel = 0L, deriv2 = 0L, scb = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LocLinear_+3A_bw">bw</code></td>
<td>
<p>double, bandwidth</p>
</td></tr>
<tr><td><code id="LocLinear_+3A_t">t</code></td>
<td>
<p>vector, time, 1:n/n</p>
</td></tr>
<tr><td><code id="LocLinear_+3A_y">y</code></td>
<td>
<p>vector, response series to be tested for long memory in the next step</p>
</td></tr>
<tr><td><code id="LocLinear_+3A_x">X</code></td>
<td>
<p>matrix, covariates matrix</p>
</td></tr>
<tr><td><code id="LocLinear_+3A_db_kernel">db_kernel</code></td>
<td>
<p>bool, whether to use jackknife kernel, default 0</p>
</td></tr>
<tr><td><code id="LocLinear_+3A_deriv2">deriv2</code></td>
<td>
<p>bool,whether to return second-order derivative, default 0</p>
</td></tr>
<tr><td><code id="LocLinear_+3A_scb">scb</code></td>
<td>
<p>bool, whether to use the result for further calculation of simultaneous confidence bands.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The time varying coefficients are estimated by
\[(\hat{\boldsymbol{\beta}}_{b_{n}}(t), \hat{\boldsymbol{\beta}}_{b_{n}}^{\prime}(t)) = \mathbf{arg min}_{\eta_{0},\eta_{1}}[\sum_{i=1}^{n}{y_{i}-\mathbf{x}_{i}^{\mathrm{T}}\eta_{0}-\mathbf{x}_{i}^{\mathrm{T}} \eta_{1}(t_{i}-t)}^{2} \boldsymbol{K}_{b_{n}}(t_{i}-t)]\]
where beta0 is \(\hat{\boldsymbol{\beta}}_{b_{n}}(t)\), mu is \(X^T \hat{\boldsymbol{\beta}}_{b_{n}}(t)\)
</p>


<h3>Value</h3>

<p>a list of results
</p>

<ul>
<li><p> mu: the estimated trend
</p>
</li>
<li><p> beta0: time varying coefficient
</p>
</li>
<li><p> X_reg: a matrix whose j'th row is \(x_j^T\hat{M}(t_j)\)
</p>
</li>
<li><p> t: 1:n/n
</p>
</li>
<li><p> bw: bandwidth used
</p>
</li>
<li><p> X: covariates matrix
</p>
</li>
<li><p> y: response
</p>
</li>
<li><p> n: sample size
</p>
</li>
<li><p> p: dimension of covariates including the intercept
</p>
</li>
<li><p> invM: inversion of M matrix, when scb = 1
</p>
</li></ul>



<h3>References</h3>

<p>Zhou, Z., &amp; Wu, W. B. (2010). Simultaneous inference of linear models with time varying coefficients. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 72(4), 513-531.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param = list(d = -0.2, heter = 2, tvd = 0,
 tw = 0.8, rate = 0.1, cur = 1, center = 0.3,
  ma_rate =  0, cov_tw =  0.2, cov_rate = 0.1,
   cov_center = 0.1, all_tw  = 1, cov_trend = 0.7)
n = 500
t = (1:n)/n
data = Qct_reg(n, param)
result = LocLinear(0.2, t, data$y, data$x)
</code></pre>

<hr>
<h2 id='lrv_measure'>Comparing bias or mse of lrv estimators based on numerical methods</h2><span id='topic+lrv_measure'></span>

<h3>Description</h3>

<p>Comparing bias or mse of lrv estimators based on numerical methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrv_measure(
  data,
  param,
  lrvmethod,
  mvselect = -1,
  tau = 0,
  verbose_dist = FALSE,
  mode = "mse"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lrv_measure_+3A_data">data</code></td>
<td>
<p>a list of data</p>
</td></tr>
<tr><td><code id="lrv_measure_+3A_param">param</code></td>
<td>
<p>a list of parameters</p>
</td></tr>
<tr><td><code id="lrv_measure_+3A_lrvmethod">lrvmethod</code></td>
<td>
<p>int, method of long-run variance estimation</p>
</td></tr>
<tr><td><code id="lrv_measure_+3A_mvselect">mvselect</code></td>
<td>
<p>int, method of MV selection</p>
</td></tr>
<tr><td><code id="lrv_measure_+3A_tau">tau</code></td>
<td>
<p>double, value of tau. If tau is 0, a rule-of-thunk value will be applied</p>
</td></tr>
<tr><td><code id="lrv_measure_+3A_verbose_dist">verbose_dist</code></td>
<td>
<p>bool, whether to output distributional information</p>
</td></tr>
<tr><td><code id="lrv_measure_+3A_mode">mode</code></td>
<td>
<p>default &quot;mse&quot;, It can be set as &quot;bias&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>empirical MSE of the estimator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 300
param = list(gcv = 1, neighbour = 1,lb = 6, ub = 13, ind = 2)    # covariates heterskadecity
data = bregress2(n, 2, 1) # with 2 change pointa
lrv_measure(data, param, lrvmethod = -1, mvselect = -2) #ols plug-in
#debiased difference-based
lrv_measure(data, param, lrvmethod = 1, mvselect = -2)
</code></pre>

<hr>
<h2 id='MV_critical'>Statistics-adapted values for extended minimum volatility selection.</h2><span id='topic+MV_critical'></span>

<h3>Description</h3>

<p>Calculation of the variance of the bootstrap statistics for the extended minimum volatility selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MV_critical(
  y,
  data,
  R,
  gridm,
  gridtau,
  type = 1L,
  cvalue = 0.1,
  B = 100L,
  lrvmethod = 1L,
  ind = 2L,
  rescale = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MV_critical_+3A_y">y</code></td>
<td>
<p>vector, as used in the Heter_LRV</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_data">data</code></td>
<td>
<p>list, a list of data</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_r">R</code></td>
<td>
<p>a cube of standard.normal random variables.</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_gridm">gridm</code></td>
<td>
<p>vector, a grid of candidate m's.</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_gridtau">gridtau</code></td>
<td>
<p>vector, a grid of candidate tau's.</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_type">type</code></td>
<td>
<p>integer, 1 KPSS 2 RS 3 VS 4 KS</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_cvalue">cvalue</code></td>
<td>
<p>double, 1-quantile for the calculation of bootstrap variance, default 0.1.</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_b">B</code></td>
<td>
<p>integer, number of iterations for the calculation of bootstrap variance</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_lrvmethod">lrvmethod</code></td>
<td>
<p>integer, see also Heter_LRV</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_ind">ind</code></td>
<td>
<p>integer, the type of kernel,  see also Heter_LRV</p>
</td></tr>
<tr><td><code id="MV_critical_+3A_rescale">rescale</code></td>
<td>
<p>bool, whether to rescale when positiveness of the matrix is not obtained. default 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of critical values
</p>


<h3>References</h3>

<p>Bai, L., &amp; Wu, W. (2024). Difference-based covariance matrix estimation in time series nonparametric regression with application to specification tests. Biometrika, asae013.
</p>


<h3>See Also</h3>

<p>Heter_LRV
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###with Long memory parameter 0.2
param = list(d = -0.2, heter = 2,
 tvd = 0, tw = 0.8, rate = 0.1, cur = 1,
  center = 0.3, ma_rate =  0, cov_tw =  0.2,
  cov_rate = 0.1, cov_center = 0.1,
  all_tw  = 1, cov_trend = 0.7)
n = 1000
data = Qct_reg(n, param)
p = ncol(data$x)
t = (1:n)/n
B_c = 100 ##small value for testing
Rc = array(rnorm(n*p*B_c),dim = c(p,B_c,n))
result1 = LocLinear(0.2, t, data$y, data$x)
critical &lt;- MV_critical(data$y, result1, Rc, c(3,4,5), c(0.2, 0.25, 0.3))
</code></pre>

<hr>
<h2 id='MV_critical_cp'>Statistics-adapted values for extended minimum volatility selection.</h2><span id='topic+MV_critical_cp'></span>

<h3>Description</h3>

<p>Smoothing parameter selection for bootstrap tests for change point tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MV_critical_cp(
  y,
  X,
  t,
  gridm,
  gridtau,
  cvalue = 0.1,
  B = 100L,
  lrvmethod = 1L,
  ind = 2L,
  rescale = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MV_critical_cp_+3A_y">y</code></td>
<td>
<p>vector, as used in the Heter_LRV</p>
</td></tr>
<tr><td><code id="MV_critical_cp_+3A_x">X</code></td>
<td>
<p>matrix, covariates</p>
</td></tr>
<tr><td><code id="MV_critical_cp_+3A_t">t</code></td>
<td>
<p>vector, time points.</p>
</td></tr>
<tr><td><code id="MV_critical_cp_+3A_gridm">gridm</code></td>
<td>
<p>vector, a grid of candidate m's.</p>
</td></tr>
<tr><td><code id="MV_critical_cp_+3A_gridtau">gridtau</code></td>
<td>
<p>vector, a grid of candidate tau's.</p>
</td></tr>
<tr><td><code id="MV_critical_cp_+3A_cvalue">cvalue</code></td>
<td>
<p>double, 1-quantile for the calculation of bootstrap variance, default 0.1.</p>
</td></tr>
<tr><td><code id="MV_critical_cp_+3A_b">B</code></td>
<td>
<p>integer, number of iterations for the calculation of bootstrap variance</p>
</td></tr>
<tr><td><code id="MV_critical_cp_+3A_lrvmethod">lrvmethod</code></td>
<td>
<p>integer, see also Heter_LRV</p>
</td></tr>
<tr><td><code id="MV_critical_cp_+3A_ind">ind</code></td>
<td>
<p>integer, the type of kernel,  see also Heter_LRV</p>
</td></tr>
<tr><td><code id="MV_critical_cp_+3A_rescale">rescale</code></td>
<td>
<p>bool, whether to rescale when positiveness of the matrix is not obtained. default 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of critical values
</p>


<h3>References</h3>

<p>Bai, L., &amp; Wu, W. (2024). Difference-based covariance matrix estimation in time series nonparametric regression with application to specification tests. Biometrika, asae013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 300
t = (1:n)/n
data = bregress2(n, 2, 1) # time series regression model with 2 changes points
critical = MV_critical_cp(data$y, data$x,t,  c(3,4,5), c(0.2,0.25, 0.3))
</code></pre>

<hr>
<h2 id='MV_ise_heter_critical'>MV method</h2><span id='topic+MV_ise_heter_critical'></span>

<h3>Description</h3>

<p>Selection of smoothing parameters for bootstrap tests by choosing the index minimizing the volatility of bootstrap statistics or long-run variance estimators in the neighborhood computed before.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MV_ise_heter_critical(critical, neighbour)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MV_ise_heter_critical_+3A_critical">critical</code></td>
<td>
<p>a matrix of critical values</p>
</td></tr>
<tr><td><code id="MV_ise_heter_critical_+3A_neighbour">neighbour</code></td>
<td>
<p>integer, number of neighbours</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of results,
</p>

<ul>
<li><p> minp: optimal row number
</p>
</li>
<li><p> minq: optimal column number
</p>
</li>
<li><p> min_ise: optimal value
</p>
</li></ul>



<h3>References</h3>

<p>Bai, L., &amp; Wu, W. (2024). Difference-based covariance matrix estimation in time series nonparametric regression with application to specification tests. Biometrika, asae013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param = list(d = -0.2, heter = 2,
 tvd = 0, tw = 0.8, rate = 0.1,
 cur = 1, center = 0.3, ma_rate =  0,
 cov_tw =  0.2, cov_rate = 0.1,
 cov_center = 0.1, all_tw  = 1, cov_trend = 0.7)
n = 1000
data = Qct_reg(n, param)
p = ncol(data$x)
t = (1:n)/n
B_c = 100 ##small value for testing
Rc = array(rnorm(n*p*B_c),dim = c(p,B_c,n))
result1 = LocLinear(0.2, t, data$y, data$x)
gridm = c(3,4,5)
gridtau = c(0.2, 0.25, 0.3)
critical &lt;- MV_critical(data$y, result1, Rc, gridm, gridtau)
mv_result = MV_ise_heter_critical(critical,  1)
m = gridm[mv_result$minp + 1]
tau_n = gridtau[mv_result$minq + 1]
</code></pre>

<hr>
<h2 id='Qct_reg'>Simulate data from time-varying time series regression model</h2><span id='topic+Qct_reg'></span>

<h3>Description</h3>

<p>Simulate data from time-varying time series regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qct_reg(T_n, param, type = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qct_reg_+3A_t_n">T_n</code></td>
<td>
<p>int, sample size</p>
</td></tr>
<tr><td><code id="Qct_reg_+3A_param">param</code></td>
<td>
<p>list, a list of parameters</p>
</td></tr>
<tr><td><code id="Qct_reg_+3A_type">type</code></td>
<td>
<p>type = 1 means the long memory expansion begins from its infinite past, type = 2 means the long memory expansion begins from t = 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, a list of data, covariates, response and errors.(before and after fractional difference)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param = list(d = -0.2, heter = 2, tvd = 0,
tw = 0.8, rate = 0.1, cur = 1, center = 0.3,
ma_rate =  0, cov_tw =  0.2, cov_rate = 0.1,
cov_center = 0.1, all_tw  = 1, cov_trend = 0.7)
n = 500
data = Qct_reg(n, param)
</code></pre>

<hr>
<h2 id='Qt_data'>Simulate data from time-varying trend model</h2><span id='topic+Qt_data'></span>

<h3>Description</h3>

<p>Simulate data from time-varying trend model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qt_data(T_n, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qt_data_+3A_t_n">T_n</code></td>
<td>
<p>integer, sample size</p>
</td></tr>
<tr><td><code id="Qt_data_+3A_param">param</code></td>
<td>
<p>a list of parameters
</p>

<ul>
<li><p> tw double, squared root of  variance  of the innovations
</p>
</li>
<li><p> rate double, magnitude of non-stationarity
</p>
</li>
<li><p> center double, the center of the ar coefficient
</p>
</li>
<li><p> ma_rate double, ma coefficient
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of non-stationary time series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param = list(d = -0.2,  tvd = 0, tw = 0.8, rate = 0.1, center = 0.3, ma_rate =  0, cur = 1)
data = Qt_data(300, param)
</code></pre>

<hr>
<h2 id='rule_of_thumb'>rule of thumb interval for the selection of smoothing parameter b</h2><span id='topic+rule_of_thumb'></span>

<h3>Description</h3>

<p>The function will compute a data-driven interval for the Generalized Cross Validation performed later, see also Bai and Wu (2024) .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rule_of_thumb(y, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rule_of_thumb_+3A_y">y</code></td>
<td>
<p>a vector, the response variable.</p>
</td></tr>
<tr><td><code id="rule_of_thumb_+3A_x">x</code></td>
<td>
<p>a matrix of covariates. If the intercept should be includes, the elements of the first column should be 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>c(left, right), the vector with the left and right points of the interval
</p>


<h3>References</h3>

<p>Bai, L., &amp; Wu, W. (2024). Detecting long-range dependence for time-varying linear models. Bernoulli, 30(3), 2450-2474.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param = list(d = -0.2, heter = 2, tvd = 0,
tw = 0.8, rate = 0.1, cur = 1, center = 0.3,
 ma_rate =  0, cov_tw =  0.2, cov_rate = 0.1,
 cov_center = 0.1, all_tw  = 1, cov_trend = 0.7)
data = Qct_reg(1000, param)
rule_of_thumb(data$y, data$x)
</code></pre>

<hr>
<h2 id='sim_T'>bootstrap distribution</h2><span id='topic+sim_T'></span>

<h3>Description</h3>

<p>bootstrap distribution of the gradient based structural stability test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_T(X, t, sigma, m, B, type = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_T_+3A_x">X</code></td>
<td>
<p>matrix of covariates</p>
</td></tr>
<tr><td><code id="sim_T_+3A_t">t</code></td>
<td>
<p>vector of time points</p>
</td></tr>
<tr><td><code id="sim_T_+3A_sigma">sigma</code></td>
<td>
<p>a cube of long-run covariance function.</p>
</td></tr>
<tr><td><code id="sim_T_+3A_m">m</code></td>
<td>
<p>int value of window size</p>
</td></tr>
<tr><td><code id="sim_T_+3A_b">B</code></td>
<td>
<p>int, number of iteration</p>
</td></tr>
<tr><td><code id="sim_T_+3A_type">type</code></td>
<td>
<p>type of tests, residual-based or coefficient-based</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of bootstrap statistics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>param = list(B = 50, bw_set = c(0.15, 0.25), gcv =1, neighbour = 1, lb = 10, ub = 20, type = 0)
n = 300
data = bregress2(n, 2, 1) # time series regression model with 2 changes points
sigma = Heter_LRV(data$y, data$x, 3, 0.3, lrv_method = 1)
bootstrap = sim_T(data$x, (1:n)/n, sigma, 3, 20) ### 20 iterations
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
