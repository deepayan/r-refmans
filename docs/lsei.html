<!DOCTYPE html><html><head><title>Help for package lsei</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lsei}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hfti'><p>Least Squares Solution using Householder Transformation</p></a></li>
<li><a href='#indx'><p>Index-finding in a Sorted Vector</p></a></li>
<li><a href='#lsei'><p>Least Squares and Quadratic Programming under Equality and Inequality Constraints</p></a></li>
<li><a href='#matMaxs'><p>Row or Column Maximum Values of a Matrix</p></a></li>
<li><a href='#nnls'><p>Least Squares and Quadratic Programming under Nonnegativity</p>
Constraints</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Solving Least Squares or Quadratic Programming Problems under
Equality/Inequality Constraints</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-09-07</td>
</tr>
<tr>
<td>Description:</td>
<td>It contains functions that solve least squares linear
	     regression problems under linear equality/inequality
	     constraints. Functions for solving quadratic programming
	     problems are also available, which transform such problems
	     into least squares ones first. It is developed based on the
	     'Fortran' program of Lawson and Hanson (1974, 1995), which is
	     public domain and available at
	     <a href="http://www.netlib.org/lawson-hanson/">http://www.netlib.org/lawson-hanson/</a>.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.stat.auckland.ac.nz/~yongwang/">https://www.stat.auckland.ac.nz/~yongwang/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-06 21:47:31 UTC; yong</td>
</tr>
<tr>
<td>Author:</td>
<td>Yong Wang [aut, cre],
  Charles L. Lawson [aut],
  Richard J. Hanson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yong Wang &lt;yongwang@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-17 08:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='hfti'>Least Squares Solution using Householder Transformation</h2><span id='topic+hfti'></span>

<h3>Description</h3>

<p>Solves the least squares problem using Householder forward triangulation
with column interchanges. It is an R interface to the HFTI function that is
described in Lawson and Hanson (1974, 1995). Its Fortran implementation is
public domain and is available at <a href="http://www.netlib.org/lawson-hanson/">http://www.netlib.org/lawson-hanson/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hfti(a, b, tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hfti_+3A_a">a</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="hfti_+3A_b">b</code></td>
<td>
<p>Response vector or matrix.</p>
</td></tr>
<tr><td><code id="hfti_+3A_tol">tol</code></td>
<td>
<p>Tolerance for determining the pseudorank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given matrix <code>a</code> and vector <code>b</code>, <code>hfti</code> solves the least
squares problem:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{minimize\ \ } || a x - b ||.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>b</code></td>
<td>
<p>first <code>krank</code> elements contains the solution</p>
</td></tr>
<tr><td><code>krank</code></td>
<td>
<p>psuedo-rank</p>
</td></tr> <tr><td><code>rnorm</code></td>
<td>
<p>Euclidean norm of the residual
vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yong Wang &lt;yongwang@auckland.ac.nz&gt;
</p>


<h3>References</h3>

<p>Lawson and Hanson (1974, 1995). Solving least squares problems.
Englewood Cliffs, N.J., Prentice-Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsei">lsei</a></code>, <code><a href="#topic+nnls">nnls</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = matrix(rnorm(10*4), nrow=10)
b = a %*% c(0,1,-1,1) + rnorm(10)
hfti(a, b)

</code></pre>

<hr>
<h2 id='indx'>Index-finding in a Sorted Vector</h2><span id='topic+indx'></span>

<h3>Description</h3>

<p>For each of given values, <code>indx</code> finds the index of the value in a
vector sorted in ascending order that the given value is barely greater than
or equal to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indx(x, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indx_+3A_x">x</code></td>
<td>
<p>vector of numeric values, the indices of which are to be found.</p>
</td></tr>
<tr><td><code id="indx_+3A_v">v</code></td>
<td>
<p>vector of numeric values sorted in ascending order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each x[i], the function returns integer j such that </p>
<p style="text-align: center;"><code class="reqn">v_j \le x_i &lt;
v_{j+1}</code>
</p>
<p> where <code class="reqn">v_0 = - \infty \mathrm{ and }
v_{n+1} = \infty</code>.
</p>


<h3>Value</h3>

<p>Returns a vector of integers, that are indices of x-values in vector
v.
</p>


<h3>Author(s)</h3>

<p>Yong Wang &lt;yongwang@auckland.ac.nz&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
indx(0:6,c(1:5,5))
indx(sort(rnorm(5)),-2:2)

</code></pre>

<hr>
<h2 id='lsei'>Least Squares and Quadratic Programming under Equality and Inequality Constraints</h2><span id='topic+lsei'></span><span id='topic+lsi'></span><span id='topic+ldp'></span><span id='topic+qp'></span>

<h3>Description</h3>

<p>These functions can be used for solving least squares or quadratic
programming problems under general equality and/or inequality
constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsei(a, b, c=NULL, d=NULL, e=NULL, f=NULL, lower=-Inf, upper=Inf)
lsi(a, b, e=NULL, f=NULL, lower=-Inf, upper=Inf)
ldp(e, f)
qp(q, p, c=NULL, d=NULL, e=NULL, f=NULL, lower=-Inf, upper=Inf, tol=1e-15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsei_+3A_a">a</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="lsei_+3A_b">b</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="lsei_+3A_c">c</code></td>
<td>
<p>Matrix of numeric coefficients on the left-hand sides of equality
constraints. If it is NULL, <code>c</code> and <code>d</code> are ignored.</p>
</td></tr>
<tr><td><code id="lsei_+3A_d">d</code></td>
<td>
<p>Vector of numeric values on the right-hand sides of equality
constraints.</p>
</td></tr>
<tr><td><code id="lsei_+3A_e">e</code></td>
<td>
<p>Matrix of numeric coefficients on the left-hand sides of inequality
constraints. If it is NULL, <code>e</code> and <code>f</code> are ignored.</p>
</td></tr>
<tr><td><code id="lsei_+3A_f">f</code></td>
<td>
<p>Vector of numeric values on the right-hand sides of inequality
constraints.</p>
</td></tr>
<tr><td><code id="lsei_+3A_lower">lower</code>, <code id="lsei_+3A_upper">upper</code></td>
<td>
<p>Bounds on the solutions, as a way to specify such simple
inequality constraints.</p>
</td></tr>
<tr><td><code id="lsei_+3A_q">q</code></td>
<td>
<p>Matrix of numeric values for the quadratic term of a quadratic
programming problem.</p>
</td></tr>
<tr><td><code id="lsei_+3A_p">p</code></td>
<td>
<p>Vector of numeric values for the linear term of a quadratic
programming problem.</p>
</td></tr>
<tr><td><code id="lsei_+3A_tol">tol</code></td>
<td>
<p>Tolerance, for calculating pseudo-rank in <code>qp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>lsei</code> function solves a least squares problem under both equality
and inequality constraints. It is an implementation of the LSEI algorithm
described in Lawson and Hanson (1974, 1995).
</p>
<p>The <code>lsi</code> function solves a least squares problem under inequality
constraints. It is an implementation of the LSI algorithm described in
Lawson and Hanson (1974, 1995).
</p>
<p>The <code>ldp</code> function solves a least distance programming problem under
inequality constraints. It is an R wrapper of the LDP function which is in
Fortran, as described in Lawson and Hanson (1974, 1995).
</p>
<p>The <code>qp</code> function solves a quadratic programming problem, by
transforming the problem into a least squares one under the same equality
and inequality constraints, which is then solved by function <code>lsei</code>.
</p>
<p>The NNLS and LDP Fortran implementations used internally is downloaded from
<a href="http://www.netlib.org/lawson-hanson/">http://www.netlib.org/lawson-hanson/</a>.
</p>
<p>Given matrices <code>a</code>, <code>c</code> and <code>e</code>, and vectors <code>b</code>,
<code>d</code> and <code>f</code>, function <code>lsei</code> solves the least squares problem
under both equality and inequality constraints:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{minimize\ \ } || a x - b ||,</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathrm{subject\ to\ \ } c x = d, e x \ge f.</code>
</p>

<p>Function <code>lsi</code> solves the least squares problem under inequality
constraints:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{minimize\ \ } || a x - b ||,</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathrm{\ \ \ subject\ to\ \ } e x \ge f.</code>
</p>

<p>Function <code>ldp</code> solves the least distance programming problem under
inequality constraints:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{minimize\ \ } || x ||,</code>
</p>
 <p style="text-align: center;"><code class="reqn">\mathrm{\ \ \
subject\ to\ \ } e x \ge f.</code>
</p>

<p>Function <code>qp</code> solves the quadratic programming problem:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{minimize\ \ } \frac12 x^T q x + p^T x,</code>
</p>
 <p style="text-align: center;"><code class="reqn">\mathrm{subject\ to\ \ } c x = d, e x \ge f.</code>
</p>



<h3>Value</h3>

<p>A vector of the solution values
</p>


<h3>Author(s)</h3>

<p>Yong Wang &lt;yongwang@auckland.ac.nz&gt;
</p>


<h3>References</h3>

<p>Lawson and Hanson (1974, 1995). Solving least squares problems.
Englewood Cliffs, N.J., Prentice-Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nnls">nnls</a></code>,<code><a href="#topic+hfti">hfti</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
beta = c(rnorm(2), 1)
beta[beta&lt;0] = 0
beta = beta / sum(beta)
a = matrix(rnorm(18), ncol=3)
b = a %*% beta + rnorm(3,sd=.1)
c = t(rep(1, 3))
d = 1
e = diag(1,3)
f = rep(0,3)
lsei(a, b)                        # under no constraint
lsei(a, b, c, d)                  # under eq. constraints
lsei(a, b, e=e, f=f)              # under ineq. constraints
lsei(a, b, c, d, e, f)            # under eq. and ineq. constraints
lsei(a, b, rep(1,3), 1, lower=0)  # same solution
q = crossprod(a)
p = -drop(crossprod(b, a))
qp(q, p, rep(1,3), 1, lower=0)    # same solution

## Example from Lawson and Hanson (1974), p.140
a = cbind(c(.4302,.6246), c(.3516,.3384))
b = c(.6593, .9666)
c = c(.4087, .1593)
d = .1376
lsei(a, b, c, d)   # Solution: -1.177499  3.884770

## Example from Lawson and Hanson (1974), p.170
a = cbind(c(.25,.5,.5,.8),rep(1,4))
b = c(.5,.6,.7,1.2)
e = cbind(c(1,0,-1),c(0,1,-1))
f = c(0,0,-1)
lsi(a, b, e, f)      # Solution: 0.6213152 0.3786848

## Example from Lawson and Hanson (1974), p.171:
e = cbind(c(-.207,-.392,.599), c(2.558, -1.351, -1.206))
f = c(-1.3,-.084,.384)
ldp(e, f)            # Solution: 0.1268538 -0.2554018

</code></pre>

<hr>
<h2 id='matMaxs'>Row or Column Maximum Values of a Matrix</h2><span id='topic+matMaxs'></span>

<h3>Description</h3>

<p>Finds either row or column maximum values of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matMaxs(x, dim = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matMaxs_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="matMaxs_+3A_dim">dim</code></td>
<td>
<p><code>=1</code>, for row maximum values; <code>=2</code>, for column maximum
values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matrix <code>x</code> may contain <code>Inf</code> or <code>-Inf</code>, but not <code>NA</code> or
<code>NaN</code>.
</p>


<h3>Value</h3>

<p>Returns a numeric vector with row or column maximum values.
</p>
<p>The function is very much the same as using <code>apply(x, 1, max)</code> or
<code>apply(x, 2, max)</code>, but faster.
</p>


<h3>Author(s)</h3>

<p>Yong Wang &lt;yongwang@auckland.ac.nz&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = cbind(c(1:4,Inf), 5:1)
matMaxs(x)
matMaxs(x, 2)

</code></pre>

<hr>
<h2 id='nnls'>Least Squares and Quadratic Programming under Nonnegativity
Constraints</h2><span id='topic+nnls'></span><span id='topic+pnnls'></span><span id='topic+pnnqp'></span>

<h3>Description</h3>

<p>These functions are particularly useful for solving least squares
or quadratic programming problems when some or all of the solution
values are subject to nonnegativity constraint. One may further
restrict the NN-restricted coefficients to have a fixed positive
sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnls(a, b) 
pnnls(a, b, k=0, sum=NULL) 
pnnqp(q, p, k=0, sum=NULL, tol=1e-20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnls_+3A_a">a</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="nnls_+3A_b">b</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="nnls_+3A_k">k</code></td>
<td>
<p>Integer, meaning that the first <code>k</code> coefficients are not
NN-restricted.</p>
</td></tr>
<tr><td><code id="nnls_+3A_sum">sum</code></td>
<td>
<p>= NULL, if NN-restricted coefficients are not further restricted
to have a fixed sum;
</p>
<p>= a positive value, if NN-restricted coefficients are further restricted to
have a fixed positive sum.</p>
</td></tr>
<tr><td><code id="nnls_+3A_q">q</code></td>
<td>
<p>Positive semidefinite matrix of numeric values for the quadratic
term of a quadratic programming problem.</p>
</td></tr>
<tr><td><code id="nnls_+3A_p">p</code></td>
<td>
<p>Vector of numeric values for the linear term of a quadratic
programming problem.</p>
</td></tr>
<tr><td><code id="nnls_+3A_tol">tol</code></td>
<td>
<p>Tolerance used for calculating pseudo-rank of <code>q</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>nnls</code> solves the least squares problem under
nonnegativity (NN) constraints. It is an R interface to the NNLS
function that is described in Lawson and Hanson (1974, 1995). Its
Fortran implementation is public domain and available at
<a href="http://www.netlib.org/lawson-hanson/">http://www.netlib.org/lawson-hanson/</a> (with slight
modifications by Yong Wang for compatibility with the lastest
Fortran compiler.)
</p>
<p>Given matrix <code>a</code> and vector <code>b</code>, <code>nnls</code> solves the
nonnegativity least squares problem:
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{minimize \ \ } || a x - b ||,</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathrm{\ \ \ subject\ to\ \ } x \ge 0.</code>
</p>

<p>Function <code>pnnls</code> also solves the above nonnegativity least
squares problem when <code>k=0</code>, but it may also leave the first
<code>k</code> coefficients unrestricted. The output value of <code>k</code>
can be smaller than the input one, if <code>a</code> has linearly
dependent columns. If <code>sum</code> is a positive value, <code>pnnls</code>
solves the problem by further restricting that the NN-restricted
coefficients must sum to the given value.
</p>
<p>Function <code>pnnqp</code> solves the quadratic programming problem
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{minimize\ \ } \frac12 x^T q x + p^T x,</code>
</p>

<p>when only some or all coefficients are restricted by
nonnegativity. The quadratic programming problem is solved by
transforming the problem into a least squares one under the same
constraints, which is then solved by function
<code>pnnls</code>. Arguments <code>k</code> and <code>sum</code> have the same
meanings as for <code>pnnls</code>.
</p>
<p>Functions <code>nnls</code>, <code>pnnls</code> and <code>pnnqp</code> are able to
return any zero-valued solution as 0 exactly. This differs from
functions <code>lsei</code> and <code>qp</code>, which may produce very small
values for exactly 0s, thanks to numerical errors.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Solution</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The upper-triangular matrix <code>Q*a</code>, pivoted by variables in the
order of <code>index</code>, when <code>sum=NULL</code>. If <code>sum &gt; 0</code>, <code>r</code> is
for the transformed <code>a</code>.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The vector <code>Q*b</code>, pivoted by variables in the order of
<code>index</code>, when <code>sum=NULL</code>. If <code>sum &gt; 0</code>, <code>b</code> is for the
transformed <code>b</code>.</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>Indices of the columns of <code>r</code>; those unrestricted and in
the positive set are first given, and then those in the zero set.</p>
</td></tr>
<tr><td><code>rnorm</code></td>
<td>
<p>Euclidean norm of the residual vector.</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>
<p>= 1, successful computation;
</p>
<p>= 2, bad dimensions of the problem;
</p>
<p>= 3, iteration count exceeded (more than 3 times the number of variables
iterations).</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of the first few coefficients that are truly not
NN-restricted.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yong Wang &lt;yongwang@auckland.ac.nz&gt;
</p>


<h3>References</h3>

<p>Lawson and Hanson (1974, 1995). Solving Least Squares Problems. Englewood
Cliffs, N.J., Prentice-Hall.
</p>
<p>Dax (1990). The smallest point of a polytope. Journal of Optimization Theory
and Applications, 64, pp. 429-432.
</p>
<p>Wang (2010). Fisher scoring: An interpolation family and its Monte Carlo
implementations. Computational Statistics and Data Analysis, 54, pp.
1744-1755.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lsei">lsei</a></code>, <code><a href="#topic+hfti">hfti</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a = matrix(rnorm(40), nrow=10)
b = drop(a %*% c(0,1,-1,1)) + rnorm(10)
nnls(a, b)$x                     # constraint x &gt;= 0
pnnls(a, b, k=0)$x               # same as nnls(a, b)
pnnls(a, b, k=2)$x               # first two coeffs are not NN-constrained
pnnls(a, b, k=2, sum=1)$x        # NN-constrained coeffs must sum to 1
pnnls(a, b, k=2, sum=2)$x        # NN-constrained coeffs must sum to 2
q = crossprod(a)
p = -drop(crossprod(b, a))
pnnqp(q, p, k=2, sum=2)$x        # same solution

pnnls(a, b, sum=1)$x             # zeros found exactly
pnnqp(q, p, sum=1)$x             # zeros found exactly
lsei(a, b, rep(1,4), 1, lower=0) # zeros not so exact

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
