<!DOCTYPE html><html><head><title>Help for package SBCK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SBCK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AR2D2'><p>AR2D2 (Analogues Rank Resampling for Distributions and Dependences) method</p></a></li>
<li><a href='#bin_width_estimator'><p>bin_width_estimator method</p></a></li>
<li><a href='#CDFt'><p>CDFt method (Cumulative Distribution Function transfer)</p></a></li>
<li><a href='#chebyshev'><p>Chebyshev distance</p></a></li>
<li><a href='#cpp_pairwise_distances_XCall'><p>cpp_pairwise_distances_XCall</p></a></li>
<li><a href='#cpp_pairwise_distances_Xstr'><p>cpp_pairwise_distances_Xstr</p></a></li>
<li><a href='#cpp_pairwise_distances_XYCall'><p>cpp_pairwise_distances_XYCall</p></a></li>
<li><a href='#cpp_pairwise_distances_XYstr'><p>cpp_pairwise_distances_XYstr</p></a></li>
<li><a href='#data_to_hist'><p>data_to_hist</p></a></li>
<li><a href='#dataset_bimodal_reverse_2d'><p>dataset_bimodal_reverse_2d</p></a></li>
<li><a href='#dataset_gaussian_2d'><p>dataset_gaussian_2d</p></a></li>
<li><a href='#dataset_gaussian_exp_2d'><p>dataset_gaussian_exp_2d</p></a></li>
<li><a href='#dataset_gaussian_exp_mixture_1d'><p>dataset_gaussian_exp_mixture_1d</p></a></li>
<li><a href='#dataset_gaussian_L_2d'><p>dataset_gaussian_L_2d</p></a></li>
<li><a href='#dataset_gaussian_VS_exp_1d'><p>dataset_gaussian_VS_exp_1d</p></a></li>
<li><a href='#dataset_like_tas_pr'><p>dataset_like_tas_pr</p></a></li>
<li><a href='#DistHelper'><p>Dist Helper</p></a></li>
<li><a href='#dOTC'><p>dOTC (dynamical Optimal Transport Correction) method</p></a></li>
<li><a href='#dTSMBC'><p>dTSMBC (dynamical Time Shifted Multivariate Bias Correction)</p></a></li>
<li><a href='#ECBC'><p>ECBC (Empirical Copula Bias Correction) method</p></a></li>
<li><a href='#energy'><p>Energy distance</p></a></li>
<li><a href='#euclidean'><p>Euclidean distance</p></a></li>
<li><a href='#IdBC'><p>IdBC (Identity Bias Correction) method</p></a></li>
<li><a href='#manhattan'><p>Manhattan distance</p></a></li>
<li><a href='#MBCn'><p>MBCn (Multivariate Bias Correction)</p></a></li>
<li><a href='#minkowski'><p>Minkowski distance</p></a></li>
<li><a href='#MRec'><p>MRec (Matrix Recorrelation) method</p></a></li>
<li><a href='#MVQuantilesShuffle'><p>MVQuantilesShuffle</p></a></li>
<li><a href='#MVRanksShuffle'><p>MVRanksShuffle</p></a></li>
<li><a href='#OTC'><p>OTC (Optimal Transport Correction) method</p></a></li>
<li><a href='#OTHist'><p>Optimal Transport Histogram</p></a></li>
<li><a href='#OTNetworkSimplex'><p>Optimal Transport Network Simplex solver</p></a></li>
<li><a href='#pairwise_distances'><p>Pairwise distances</p></a></li>
<li><a href='#PPPDiffRef'><p>PPPDiffRef</p></a></li>
<li><a href='#PPPFunctionLink'><p>PPPFunctionLink</p></a></li>
<li><a href='#PPPLogLinLink'><p>PPPLogLinLink</p></a></li>
<li><a href='#PPPPreserveOrder'><p>PPPPreserveOrder</p></a></li>
<li><a href='#PPPSquareLink'><p>PPPSquareLink</p></a></li>
<li><a href='#PPPSSR'><p>PPPSSR</p></a></li>
<li><a href='#PrePostProcessing'><p>PrePostProcessing base class</p></a></li>
<li><a href='#QDM'><p>QDM (Quantile delta mapping method)</p></a></li>
<li><a href='#QM'><p>Quantile Mapping method</p></a></li>
<li><a href='#QMrs'><p>Quantile Mapping RankShuffle method</p></a></li>
<li><a href='#R2D2'><p>R2D2 (Rank Resampling for Distributions and Dependences) method</p></a></li>
<li><a href='#RBC'><p>RBC (Random Bias Correction) method</p></a></li>
<li><a href='#SBCK'><p>SBCK</p></a></li>
<li><a href='#schaake_shuffle'><p>schaake_shuffle function</p></a></li>
<li><a href='#SchaakeShuffle'><p>ShaakeShuffle class</p></a></li>
<li><a href='#SchaakeShuffleMultiRef'><p>ShaakeShuffleMultiRef class</p></a></li>
<li><a href='#SchaakeShuffleRef'><p>ShaakeShuffleRef class</p></a></li>
<li><a href='#Shift'><p>Shift</p></a></li>
<li><a href='#SlopeStoppingCriteria'><p>Slope stopping criteria</p></a></li>
<li><a href='#SparseHist'><p>SparseHist</p></a></li>
<li><a href='#TSMBC'><p>TSMBC (Time Shifted Multivariate Bias Correction)</p></a></li>
<li><a href='#wasserstein'><p>wasserstein distance</p></a></li>
<li><a href='#where'><p>where function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Bias Correction Kit</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of several recent multivariate bias correction
			 methods with a unified interface to facilitate their use. A
			 description and comparison between methods can be found
			 in &lt;<a href="https://doi.org/10.5194%2Fesd-11-537-2020">doi:10.5194/esd-11-537-2020</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yrobink/SBCK">https://github.com/yrobink/SBCK</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, methods, R6, ROOPSD (&ge; 0.3.5), transport</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>SBCK_cpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 07:05:53 UTC; yrobin</td>
</tr>
<tr>
<td>Author:</td>
<td>Yoann Robin [aut, cre],
  Mathieu Vrac [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yoann Robin &lt;yoann.robin.k@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-11 11:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='AR2D2'>AR2D2 (Analogues Rank Resampling for Distributions and Dependences) method</h2><span id='topic+AR2D2'></span>

<h3>Description</h3>

<p>Perform a multivariate (non stationary) bias correction.
</p>


<h3>Details</h3>

<p>Use Quantiles shuffle in calibration and projection period with CDFt
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>mvq</code></dt><dd><p>[MVQuantilesShuffle] Class to transform dependance structure</p>
</dd>
<dt><code>bc_method</code></dt><dd><p>[SBCK::] Bias correction method</p>
</dd>
<dt><code>bckwargs</code></dt><dd><p>[list] List of arguments of bias correction</p>
</dd>
<dt><code>bcm_</code></dt><dd><p>[SBCK::] Instancied bias correction method</p>
</dd>
<dt><code>reverse</code></dt><dd><p>[bool] If we apply bc_method first and then shuffle, or reverse</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-AR2D2-new"><code>AR2D2$new()</code></a>
</p>
</li>
<li> <p><a href="#method-AR2D2-fit"><code>AR2D2$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-AR2D2-predict"><code>AR2D2$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-AR2D2-clone"><code>AR2D2$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-AR2D2-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new AR2D2 object.
</p>


<h5>Usage</h5>

<div class="r"><pre>AR2D2$new(
  col_cond = base::c(1),
  lag_search = 1,
  lag_keep = 1,
  bc_method = SBCK::CDFt,
  shuffle = "quantile",
  reverse = FALSE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col_cond</code></dt><dd><p>Conditionning colum</p>
</dd>
<dt><code>lag_search</code></dt><dd><p>Number of lags to transform the dependence structure</p>
</dd>
<dt><code>lag_keep</code></dt><dd><p>Number of lags to keep</p>
</dd>
<dt><code>bc_method</code></dt><dd><p>Bias correction method</p>
</dd>
<dt><code>shuffle</code></dt><dd><p>Shuffle method used, can be quantile or rank</p>
</dd>
<dt><code>reverse</code></dt><dd><p>If we apply bc_method first and then shuffle, or reverse</p>
</dd>
<dt><code>...</code></dt><dd><p>Others named arguments passed to bc_method$new</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'AR2D2' object.
</p>


<hr>
<a id="method-AR2D2-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method. If X1 is NULL, the method is considered
as stationary
</p>


<h5>Usage</h5>

<div class="r"><pre>AR2D2$fit(Y0, X0, X1 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-AR2D2-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>AR2D2$predict(X1 = NULL, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL (and vice-versa), else return a list
containing Z1 and Z0, the corrections of X1 and X0
</p>


<hr>
<a id="method-AR2D2-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>AR2D2$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Vrac, M. et S. Thao (2020). “R2 D2 v2.0 : accounting for temporal
dependences in multivariate bias correction via analogue rank
resampling”. In : Geosci. Model Dev. 13.11, p. 5367-5387.
doi :10.5194/gmd-13-5367-2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Three 4-variate random variables
Y0 = matrix( stats::rnorm( n = 1000 ) , ncol = 4 ) ## Biased in calibration period
X0 = matrix( stats::rnorm( n = 1000 ) , ncol = 4 ) / 2 + 3 ## Reference in calibration period
X1 = matrix( stats::rnorm( n = 1000 ) , ncol = 4 ) * 2 + 6 ## Biased in projection period

## Bias correction
cond_col = base::c(2,4)
lag_search = 6
lag_keep = 3
## Step 1 : construction of the class AR2D2 
ar2d2 = SBCK::AR2D2$new( cond_col , lag_search , lag_keep ) 
## Step 2 : Fit the bias correction model
ar2d2$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction
Z = ar2d2$predict(X1,X0) 

</code></pre>

<hr>
<h2 id='bin_width_estimator'>bin_width_estimator method</h2><span id='topic+bin_width_estimator'></span>

<h3>Description</h3>

<p>Lenght of cell to compute an histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_width_estimator(X, method = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_width_estimator_+3A_x">X</code></td>
<td>
<p>[matrix] A matrix containing data, nrow = n_samples,
ncol = n_features</p>
</td></tr>
<tr><td><code id="bin_width_estimator_+3A_method">method</code></td>
<td>
<p>[string] Method to estimate bin_width, values are &quot;auto&quot;, &quot;FD&quot;
(Friedman Draconis, robust over outliners) or &quot;Sturges&quot;. If &quot;auto&quot; is
used and if nrow(X) &lt; 1000, &quot;Sturges&quot; is used, else &quot;FD&quot; is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[vector] Lenght of bins
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = base::cbind( stats::rnorm( n = 2000 ) , stats::rexp(2000) )
## Friedman Draconis is used
binw_width = SBCK::bin_width_estimator( X , method = "auto" ) 
X = stats::rnorm( n = 500 )
## Sturges is used
binw_width = SBCK::bin_width_estimator( X , method = "auto" ) 

</code></pre>

<hr>
<h2 id='CDFt'>CDFt method (Cumulative Distribution Function transfer)</h2><span id='topic+CDFt'></span>

<h3>Description</h3>

<p>Perform an univariate bias correction of X with respect to Y.
</p>


<h3>Details</h3>

<p>Correction is applied margins by margins.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n_features</code></dt><dd><p>[integer] Number of features</p>
</dd>
<dt><code>tol</code></dt><dd><p>[double] Floatting point tolerance</p>
</dd>
<dt><code>distY0</code></dt><dd><p>[ROOPSD distribution or a list of them] Describe the law of
each margins. A list permit to use different laws for each
margins. Default is ROOPSD::rv_histogram.</p>
</dd>
<dt><code>distY1</code></dt><dd><p>[ROOPSD distribution or a list of them] Describe the law of
each margins. A list permit to use different laws for each
margins. Default is ROOPSD::rv_histogram.</p>
</dd>
<dt><code>distX0</code></dt><dd><p>[ROOPSD distribution or a list of them] Describe the law of
each margins. A list permit to use different laws for each
margins. Default is ROOPSD::rv_histogram.</p>
</dd>
<dt><code>distX1</code></dt><dd><p>[ROOPSD distribution or a list of them] Describe the law of
each margins. A list permit to use different laws for each
margins. Default is ROOPSD::rv_histogram.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CDFt-new"><code>CDFt$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CDFt-fit"><code>CDFt$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-CDFt-predict"><code>CDFt$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-CDFt-clone"><code>CDFt$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CDFt-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new CDFt object.
</p>


<h5>Usage</h5>

<div class="r"><pre>CDFt$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Optional arguments are:
- distX0, distX1, models in calibration and projection period, see ROOPSD
- distY0, distY1, observations in calibration and projection period, see ROOPSD
- kwargsX0, kwargsX1, list of arguments for each respective distribution
- kwargsY0, kwargsY1, list of arguments for each respective distribution
- scale_left_tail [float]  Scale applied on the left support
(min to median) between calibration and projection period. If
NULL (default), it is determined during the fit. If == 1,
equivalent to the original algorithm of CDFt.
- scale_right_tail [float]  Scale applied on the right support
(median to max) between calibration and projection period. If
NULL (default), it is determined during the fit. If == 1,
equivalent to the original algorithm of CDFt.
- normalize_cdf [bool or vector of bool] If a normalization
is applied to the data to maximize the overlap of the
support. Can be a bool (True or False, applied for all
colums), or a list of bool of size 'n_features' to
distinguished each columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'CDFt' object.
</p>


<hr>
<a id="method-CDFt-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>CDFt$fit(Y0, X0, X1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-CDFt-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>CDFt$predict(X1, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL, else return a list containing Z1 and Z0,
the corrections of X1 and X0
</p>


<hr>
<a id="method-CDFt-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CDFt$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Michelangeli, P.-A., Vrac, M., and Loukos, H.: Probabilistic 
downscaling approaches: Application to wind cumulative 
distribution functions, Geophys. Res. Lett., 36, L11708, 
https://doi.org/10.1029/2009GL038401, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period
X1 = XY$X1 ## Biased in projection period

## Bias correction
## Step 1 : construction of the class CDFt 
cdft = SBCK::CDFt$new() 
## Step 2 : Fit the bias correction model
cdft$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction, Z is a list containing
## corrections
Z = cdft$predict(X1,X0) 
Z$Z0 ## Correction in calibration period
Z$Z1 ## Correction in projection period
</code></pre>

<hr>
<h2 id='chebyshev'>Chebyshev distance</h2><span id='topic+chebyshev'></span>

<h3>Description</h3>

<p>Compute Chebyshev distance between two dataset or SparseHist X and Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chebyshev(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chebyshev_+3A_x">X</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
<tr><td><code id="chebyshev_+3A_y">Y</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[float] value of distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = base::cbind( stats::rnorm(2000) , stats::rnorm(2000)  )
Y = base::cbind( stats::rnorm(2000,mean=2)  , stats::rnorm(2000) )
bw = base::c(0.1,0.1)
muX = SBCK::SparseHist( X , bw )
muY = SBCK::SparseHist( Y , bw )

## The four are equals
d = SBCK::chebyshev(  X ,   Y )
d = SBCK::chebyshev(muX ,   Y )
d = SBCK::chebyshev(  X , muY )
d = SBCK::chebyshev(muX , muY )

</code></pre>

<hr>
<h2 id='cpp_pairwise_distances_XCall'>cpp_pairwise_distances_XCall</h2><span id='topic+cpp_pairwise_distances_XCall'></span>

<h3>Description</h3>

<p>Pairwise distances between X and themselves with a R function (metric).
DO NOT USE, use SBCK::pairwise_distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_pairwise_distances_XCall(X,metric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_pairwise_distances_XCall_+3A_x">X</code></td>
<td>
<p>[Rcpp::NumericMatrix] Matrix</p>
</td></tr>
<tr><td><code id="cpp_pairwise_distances_XCall_+3A_metric">metric</code></td>
<td>
<p>[Rcpp::Function] R function</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_pairwise_distances_Xstr'>cpp_pairwise_distances_Xstr</h2><span id='topic+cpp_pairwise_distances_Xstr'></span>

<h3>Description</h3>

<p>Pairwise distances between X and themselves with a compiled 
str_metric. DO NOT USE, use SBCK::pairwise_distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_pairwise_distances_Xstr(X,str_metric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_pairwise_distances_Xstr_+3A_x">X</code></td>
<td>
<p>[Rcpp::NumericMatrix] Matrix</p>
</td></tr>
<tr><td><code id="cpp_pairwise_distances_Xstr_+3A_str_metric">str_metric</code></td>
<td>
<p>[std::string] c++ string</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_pairwise_distances_XYCall'>cpp_pairwise_distances_XYCall</h2><span id='topic+cpp_pairwise_distances_XYCall'></span>

<h3>Description</h3>

<p>Pairwise distances between X  and Y with a R function (metric).
DO NOT USE, use SBCK::pairwise_distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_pairwise_distances_XYCall(X,Y,metric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_pairwise_distances_XYCall_+3A_x">X</code></td>
<td>
<p>[Rcpp::NumericMatrix] Matrix</p>
</td></tr>
<tr><td><code id="cpp_pairwise_distances_XYCall_+3A_y">Y</code></td>
<td>
<p>[Rcpp::NumericMatrix] Matrix</p>
</td></tr>
<tr><td><code id="cpp_pairwise_distances_XYCall_+3A_metric">metric</code></td>
<td>
<p>[Rcpp::Function] R function</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_pairwise_distances_XYstr'>cpp_pairwise_distances_XYstr</h2><span id='topic+cpp_pairwise_distances_XYstr'></span>

<h3>Description</h3>

<p>Pairwise distances between two differents matrix X and Y with a 
compiled str_metric. DO NOT USE, use SBCK::pairwise_distances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_pairwise_distances_XYstr(X,Y,str_metric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_pairwise_distances_XYstr_+3A_x">X</code></td>
<td>
<p>[Rcpp::NumericMatrix] Matrix</p>
</td></tr>
<tr><td><code id="cpp_pairwise_distances_XYstr_+3A_y">Y</code></td>
<td>
<p>[Rcpp::NumericMatrix] Matrix</p>
</td></tr>
<tr><td><code id="cpp_pairwise_distances_XYstr_+3A_str_metric">str_metric</code></td>
<td>
<p>[std::string] c++ string</p>
</td></tr>
</table>

<hr>
<h2 id='data_to_hist'>data_to_hist</h2><span id='topic+data_to_hist'></span>

<h3>Description</h3>

<p>Just a function to transform two datasets into SparseHist, if X or Y (or the
both) are already a SparseHist, update just the second
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_to_hist(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_to_hist_+3A_x">X</code></td>
<td>
<p>[matrix or SparseHist]</p>
</td></tr>
<tr><td><code id="data_to_hist_+3A_y">Y</code></td>
<td>
<p>[matrix or SparseHist]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[list(muX,muY)] a list with the two SparseHist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = base::cbind( stats::rnorm(2000) , stats::rexp(2000)  )
Y = base::cbind( stats::rexp(2000)  , stats::rnorm(2000) )

bw = base::c(0.1,0.1)
muX = SBCK::SparseHist( X , bw )
muY = SBCK::SparseHist( Y , bw )

## The four give the same result
SBCK::data_to_hist( X   , Y )
SBCK::data_to_hist( muX , Y )
SBCK::data_to_hist( X   , muY )
SBCK::data_to_hist( muX , muY )

</code></pre>

<hr>
<h2 id='dataset_bimodal_reverse_2d'>dataset_bimodal_reverse_2d</h2><span id='topic+dataset_bimodal_reverse_2d'></span>

<h3>Description</h3>

<p>Generate a testing dataset from bimodale random bivariate Gaussian distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_bimodal_reverse_2d(n_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_bimodal_reverse_2d_+3A_n_samples">n_samples</code></td>
<td>
<p>[integer] numbers of samples drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[list] a list containing X0, X1 (biased in calibration/projection)
and Y0 (reference in calibration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY = SBCK::dataset_bimodal_reverse_2d(2000)
XY$X0 ## Biased in calibration period
XY$Y0 ## Reference in calibration period
XY$X1 ## Biased in projection period

</code></pre>

<hr>
<h2 id='dataset_gaussian_2d'>dataset_gaussian_2d</h2><span id='topic+dataset_gaussian_2d'></span>

<h3>Description</h3>

<p>Generate a testing dataset from random bivariate Gaussian distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_gaussian_2d(n_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_gaussian_2d_+3A_n_samples">n_samples</code></td>
<td>
<p>[integer] numbers of samples drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[list] a list containing X0, X1 (biased in calibration/projection)
and Y0 (reference in calibration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY = SBCK::dataset_gaussian_2d(2000)
XY$X0 ## Biased in calibration period
XY$Y0 ## Reference in calibration period
XY$X1 ## Biased in projection period

</code></pre>

<hr>
<h2 id='dataset_gaussian_exp_2d'>dataset_gaussian_exp_2d</h2><span id='topic+dataset_gaussian_exp_2d'></span>

<h3>Description</h3>

<p>Generate a testing dataset such that the biased dataset is a distribution
of the the form Normal x Exp and the reference of the the form Exp x Normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_gaussian_exp_2d(n_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_gaussian_exp_2d_+3A_n_samples">n_samples</code></td>
<td>
<p>[integer] numbers of samples drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[list] a list containing X0, X1 (biased in calibration/projection) 
and Y0 (reference in calibration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY = SBCK::dataset_gaussian_exp_2d(2000)
XY$X0 ## Biased in calibration period
XY$Y0 ## Reference in calibration period
XY$X1 ## Biased in projection period

</code></pre>

<hr>
<h2 id='dataset_gaussian_exp_mixture_1d'>dataset_gaussian_exp_mixture_1d</h2><span id='topic+dataset_gaussian_exp_mixture_1d'></span>

<h3>Description</h3>

<p>Generate a univariate testing dataset from a mixture of gaussian and
exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_gaussian_exp_mixture_1d(n_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_gaussian_exp_mixture_1d_+3A_n_samples">n_samples</code></td>
<td>
<p>[integer] numbers of samples drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[list] a list containing X0, X1 (biased in calibration/projection)
and Y0 (reference in calibration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY = SBCK::dataset_gaussian_exp_mixture_1d(2000)
XY$X0 ## Biased in calibration period
XY$Y0 ## Reference in calibration period
XY$X1 ## Biased in projection period

</code></pre>

<hr>
<h2 id='dataset_gaussian_L_2d'>dataset_gaussian_L_2d</h2><span id='topic+dataset_gaussian_L_2d'></span>

<h3>Description</h3>

<p>Generate a testing dataset such that the biased dataset is a normal
distribution and reference a mixture a normal with a form in &quot;L&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_gaussian_L_2d(n_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_gaussian_L_2d_+3A_n_samples">n_samples</code></td>
<td>
<p>[integer] numbers of samples drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[list] a list containing X0, X1 (biased in calibration/projection)
and Y0 (reference in calibration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY = SBCK::dataset_gaussian_L_2d(2000)
XY$X0 ## Biased in calibration period
XY$Y0 ## Reference in calibration period
XY$X1 ## Biased in projection period

</code></pre>

<hr>
<h2 id='dataset_gaussian_VS_exp_1d'>dataset_gaussian_VS_exp_1d</h2><span id='topic+dataset_gaussian_VS_exp_1d'></span>

<h3>Description</h3>

<p>Generate a univariate testing dataset such that biased data follow an
exponential law whereas reference follow a normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_gaussian_VS_exp_1d(n_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_gaussian_VS_exp_1d_+3A_n_samples">n_samples</code></td>
<td>
<p>[integer] numbers of samples drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[list] a list containing X0, X1 (biased in calibration/projection)
and Y0 (reference in calibration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY = SBCK::dataset_gaussian_VS_exp_1d(2000)
XY$X0 ## Biased in calibration period
XY$Y0 ## Reference in calibration period
XY$X1 ## Biased in projection period

</code></pre>

<hr>
<h2 id='dataset_like_tas_pr'>dataset_like_tas_pr</h2><span id='topic+dataset_like_tas_pr'></span>

<h3>Description</h3>

<p>Generate a testing dataset similar to temperature and precipitation.
The method is the following:
- Data from a multivariate normal law (dim = 2) are drawn
- The quantile mapping is used to map the last column into the exponential law
- Values lower than a fixed quantile are replaced by 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataset_like_tas_pr(n_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataset_like_tas_pr_+3A_n_samples">n_samples</code></td>
<td>
<p>[integer] numbers of samples drawn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[list] a list containing X0, X1 (biased in calibration/projection)
and Y0 (reference in calibration)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>XY = SBCK::dataset_like_tas_pr(2000)
XY$X0 ## Biased in calibration period
XY$Y0 ## Reference in calibration period
XY$X1 ## Biased in projection period

</code></pre>

<hr>
<h2 id='DistHelper'>Dist Helper</h2><span id='topic+DistHelper'></span>

<h3>Description</h3>

<p>Class used by CDFt and QM to facilitate fit, do not use
</p>


<h3>Details</h3>

<p>Used to parallel work for margins
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>dist</code></dt><dd><p>[ROOPSD distribution] name of class</p>
</dd>
<dt><code>law</code></dt><dd><p>[ROOPSD distribution] class set</p>
</dd>
<dt><code>kwargs</code></dt><dd><p>[list] arguments of dist</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DistHelper-new"><code>DistHelper$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DistHelper-set_features"><code>DistHelper$set_features()</code></a>
</p>
</li>
<li> <p><a href="#method-DistHelper-fit"><code>DistHelper$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-DistHelper-is_frozen"><code>DistHelper$is_frozen()</code></a>
</p>
</li>
<li> <p><a href="#method-DistHelper-is_parametric"><code>DistHelper$is_parametric()</code></a>
</p>
</li>
<li> <p><a href="#method-DistHelper-clone"><code>DistHelper$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DistHelper-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new DistHelper object.
</p>


<h5>Usage</h5>

<div class="r"><pre>DistHelper$new(dist, kwargs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dist</code></dt><dd><p>[ROOPSD distribution or list] statistical law</p>
</dd>
<dt><code>kwargs</code></dt><dd><p>[list] arguments passed to dist</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'DistHelper' object.
</p>


<hr>
<a id="method-DistHelper-set_features"></a>



<h4>Method <code>set_features()</code></h4>

<p>set the number of features
</p>


<h5>Usage</h5>

<div class="r"><pre>DistHelper$set_features(n_features)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n_features</code></dt><dd><p>[integer] numbers of features</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-DistHelper-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>fit the laws
</p>


<h5>Usage</h5>

<div class="r"><pre>DistHelper$fit(X, i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>[matrix] dataset to fit</p>
</dd>
<dt><code>i</code></dt><dd><p>[integer] margins to fit</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-DistHelper-is_frozen"></a>



<h4>Method <code>is_frozen()</code></h4>

<p>Test if margins i is frozen
</p>


<h5>Usage</h5>

<div class="r"><pre>DistHelper$is_frozen(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>[integer] margins to fit</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[bool]
</p>


<hr>
<a id="method-DistHelper-is_parametric"></a>



<h4>Method <code>is_parametric()</code></h4>

<p>Test if margins i is parametric
</p>


<h5>Usage</h5>

<div class="r"><pre>DistHelper$is_parametric(i)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>i</code></dt><dd><p>[integer] margins to fit</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[bool]
</p>


<hr>
<a id="method-DistHelper-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DistHelper$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## 
</code></pre>

<hr>
<h2 id='dOTC'>dOTC (dynamical Optimal Transport Correction) method</h2><span id='topic+dOTC'></span>

<h3>Description</h3>

<p>Perform a multivariate (non stationary) bias correction.
</p>


<h3>Details</h3>

<p>Three random variables are needed, Y0, X0 and X1. The dynamic between X0 and
X1 is estimated, and applied to Y0 to estimate Y1. Finally, OTC is used
between X1 and the Y1 estimated.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+OTC">SBCK::OTC</a></code> -&gt; <code>dOTC</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-dOTC-new"><code>dOTC$new()</code></a>
</p>
</li>
<li> <p><a href="#method-dOTC-fit"><code>dOTC$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-dOTC-predict"><code>dOTC$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-dOTC-clone"><code>dOTC$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-dOTC-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new dOTC object.
</p>


<h5>Usage</h5>

<div class="r"><pre>dOTC$new(
  bin_width = NULL,
  bin_origin = NULL,
  cov_factor = "std",
  ot = SBCK::OTNetworkSimplex$new()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bin_width</code></dt><dd><p>[vector or NULL] A vector of lengths of the cells
discretizing R^numbers of variables. If NULL, it is estimating
during the fit</p>
</dd>
<dt><code>bin_origin</code></dt><dd><p>[vector or NULL] Coordinate of lower corner of one
cell. If NULL, c(0,...,0) is used</p>
</dd>
<dt><code>cov_factor</code></dt><dd><p>[string or matrix] Covariance factor to correct the
dynamic transferred between X0 and Y0. For string, available
values are &quot;std&quot; and &quot;cholesky&quot;</p>
</dd>
<dt><code>ot</code></dt><dd><p>[OTSolver] Optimal Transport solver, default is the network
simplex</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'dOTC' object.
</p>


<hr>
<a id="method-dOTC-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>dOTC$fit(Y0, X0, X1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-dOTC-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>
<p>Note: Only the center of the bins associated to the corrected points are
returned, but all corrections of the form:
&gt;&gt; bw = dotc$bin_width / 2
&gt;&gt; n  = base::prod(base::dim(X1))
&gt;&gt; Z1 = dotc$predict(X1)
&gt;&gt; Z1 = Z1 + t(matrix(stats::runif( n = n min = - bw , max = bw ) , ncol = dim(X1)[1] ))
are equivalent for OTC.
</p>


<h5>Usage</h5>

<div class="r"><pre>dOTC$predict(X1, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL, else return a list containing Z1 and Z0,
the corrections of X1 and X0
</p>


<hr>
<a id="method-dOTC-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>dOTC$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Robin, Y., Vrac, M., Naveau, P., Yiou, P.: Multivariate
stochastic bias corrections with optimal transport, Hydrol. Earth
Syst. Sci., 23, 773–786, 2019,
https://doi.org/10.5194/hess-23-773-2019
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period
X1 = XY$X1 ## Biased in projection period

## Bin length
bin_width = c(0.2,0.2)

## Bias correction
## Step 1 : construction of the class dOTC 
dotc = SBCK::dOTC$new( bin_width ) 
## Step 2 : Fit the bias correction model
dotc$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction, Z is a list containing
## corrections
Z = dotc$predict(X1,X0) 
Z$Z0 ## Correction in calibration period
Z$Z1 ## Correction in projection period

</code></pre>

<hr>
<h2 id='dTSMBC'>dTSMBC (dynamical Time Shifted Multivariate Bias Correction)</h2><span id='topic+dTSMBC'></span>

<h3>Description</h3>

<p>Perform a bias correction of auto-correlation
</p>


<h3>Details</h3>

<p>Correct auto-correlation with a shift approach, taking into account of non
stationarity.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>shift</code></dt><dd><p>[Shift class] Shift class to shift data.</p>
</dd>
<dt><code>bc_method</code></dt><dd><p>[SBCK::BC_method] Underlying bias correction method.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>method</code></dt><dd><p>[character] If inverse is by row or column, see class Shift</p>
</dd>
<dt><code>ref</code></dt><dd><p>[integer] reference column/row to inverse shift, see class
Shift. Default is 0.5 * (lag+1)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-dTSMBC-new"><code>dTSMBC$new()</code></a>
</p>
</li>
<li> <p><a href="#method-dTSMBC-fit"><code>dTSMBC$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-dTSMBC-predict"><code>dTSMBC$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-dTSMBC-clone"><code>dTSMBC$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-dTSMBC-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new dTSMBC object.
</p>


<h5>Usage</h5>

<div class="r"><pre>dTSMBC$new(lag, bc_method = dOTC, method = "row", ref = "middle", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lag</code></dt><dd><p>[integer] max lag of autocorrelation</p>
</dd>
<dt><code>bc_method</code></dt><dd><p>[SBCK::BC_METHOD] bias correction method to use after 
shift of data, default is OTC</p>
</dd>
<dt><code>method</code></dt><dd><p>[character] If inverse is by row or column, see class Shift</p>
</dd>
<dt><code>ref</code></dt><dd><p>[integer] reference column/row to inverse shift, see class
Shift. Default is 0.5 * (lag+1)</p>
</dd>
<dt><code>...</code></dt><dd><p>[] All others arguments are passed to bc_method</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'dTSMBC' object.
</p>


<hr>
<a id="method-dTSMBC-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>dTSMBC$fit(Y0, X0, X1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-dTSMBC-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>dTSMBC$predict(X1, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL, else return a list containing Z1 and Z0,
the corrections of X1 and X0
</p>


<hr>
<a id="method-dTSMBC-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>dTSMBC$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Robin, Y. and Vrac, M.: Is time a variable like the others in
multivariate statistical downscaling and bias correction?, Earth
Syst. Dynam. Discuss. [preprint],
https://doi.org/10.5194/esd-2021-12, in review, 2021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## arima model parameters
modelX0 = list( ar = base::c(  0.6 , 0.2 , -0.1 ) )
modelX1 = list( ar = base::c(  0.4 , 0.1 , -0.3 ) )
modelY0 = list( ar = base::c( -0.3 , 0.4 , -0.2 ) )

## arima random generator
rand.genX0 = function(n){ return(stats::rnorm( n , mean = 0.2 , sd = 1   )) }
rand.genX1 = function(n){ return(stats::rnorm( n , mean = 0.8 , sd = 1   )) }
rand.genY0 = function(n){ return(stats::rnorm( n , mean = 0   , sd = 0.7 )) }

## Generate two AR processes
X0 = stats::arima.sim( n = 1000 , model = modelX0 , rand.gen = rand.genX0 )
X1 = stats::arima.sim( n = 1000 , model = modelX1 , rand.gen = rand.genX1 )
Y0 = stats::arima.sim( n = 1000 , model = modelY0 , rand.gen = rand.genY0 )
X0 = as.vector( X0 )
X1 = as.vector( X1 )
Y0 = as.vector( Y0 + 5 )

## And correct it with 30 lags
dtsbc = SBCK::dTSMBC$new( 30 )
dtsbc$fit( Y0 , X0 , X1 )
Z = dtsbc$predict(X1,X0)

</code></pre>

<hr>
<h2 id='ECBC'>ECBC (Empirical Copula Bias Correction) method</h2><span id='topic+ECBC'></span>

<h3>Description</h3>

<p>Perform a multivariate (non stationary) bias correction.
</p>


<h3>Details</h3>

<p>use Schaake shuffle
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CDFt">SBCK::CDFt</a></code> -&gt; <code>ECBC</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ECBC-new"><code>ECBC$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ECBC-fit"><code>ECBC$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-ECBC-predict"><code>ECBC$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-ECBC-clone"><code>ECBC$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ECBC-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new ECBC object.
</p>


<h5>Usage</h5>

<div class="r"><pre>ECBC$new(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>This class is based to CDFt, and takes the same arguments.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'ECBC' object.
</p>


<hr>
<a id="method-ECBC-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>ECBC$fit(Y0, X0, X1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-ECBC-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>ECBC$predict(X1, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL, else return a list containing Z1 and Z0,
the corrections of X1 and X0
</p>


<hr>
<a id="method-ECBC-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ECBC$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Vrac, M. and P. Friederichs, 2015: Multivariate—Intervariable,
Spatial, and Temporal—Bias Correction. J. Climate, 28, 218–237,
https://doi.org/10.1175/JCLI-D-14-00059.1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period
X1 = XY$X1 ## Biased in projection period


## Bias correction
## Step 1 : construction of the class ECBC
ecbc = SBCK::ECBC$new() 
## Step 2 : Fit the bias correction model
ecbc$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction
Z = ecbc$predict(X1,X0) 

</code></pre>

<hr>
<h2 id='energy'>Energy distance</h2><span id='topic+energy'></span>

<h3>Description</h3>

<p>Compute Energy distance between two dataset or SparseHist X and Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>energy(X, Y, p = 2, metric = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="energy_+3A_x">X</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
<tr><td><code id="energy_+3A_y">Y</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
<tr><td><code id="energy_+3A_p">p</code></td>
<td>
<p>[float] power of energy distance, default is 2.</p>
</td></tr>
<tr><td><code id="energy_+3A_metric">metric</code></td>
<td>
<p>[str or function] metric for pairwise distance, default is
&quot;euclidean&quot;, see SBCK::pairwise_distances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[float] value of distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = base::cbind( stats::rnorm(2000) , stats::rnorm(2000)  )
Y = base::cbind( stats::rnorm(2000,mean=10)  , stats::rnorm(2000) )
bw = base::c(0.1,0.1)
muX = SBCK::SparseHist( X , bw )
muY = SBCK::SparseHist( Y , bw )

## The four are equals
w2 = SBCK::energy(X,Y)
w2 = SBCK::energy(muX,Y)
w2 = SBCK::energy(X,muY)
w2 = SBCK::energy(muX,muY)

</code></pre>

<hr>
<h2 id='euclidean'>Euclidean distance</h2><span id='topic+euclidean'></span>

<h3>Description</h3>

<p>Compute Euclidean distance between two dataset or SparseHist X and Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euclidean(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidean_+3A_x">X</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
<tr><td><code id="euclidean_+3A_y">Y</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[float] value of distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = base::cbind( stats::rnorm(2000) , stats::rnorm(2000)  )
Y = base::cbind( stats::rnorm(2000,mean=2)  , stats::rnorm(2000) )
bw = base::c(0.1,0.1)
muX = SBCK::SparseHist( X , bw )
muY = SBCK::SparseHist( Y , bw )

## The four are equals
d = SBCK::euclidean(  X ,   Y )
d = SBCK::euclidean(muX ,   Y )
d = SBCK::euclidean(  X , muY )
d = SBCK::euclidean(muX , muY )

</code></pre>

<hr>
<h2 id='IdBC'>IdBC (Identity Bias Correction) method</h2><span id='topic+IdBC'></span>

<h3>Description</h3>

<p>Always return X1 / X0 as correction.
</p>


<h3>Details</h3>

<p>Only for comparison.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-IdBC-new"><code>IdBC$new()</code></a>
</p>
</li>
<li> <p><a href="#method-IdBC-fit"><code>IdBC$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-IdBC-predict"><code>IdBC$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-IdBC-clone"><code>IdBC$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-IdBC-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new IdBC object.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdBC$new()</pre></div>



<h5>Returns</h5>

<p>A new 'IdBC' object.
</p>


<hr>
<a id="method-IdBC-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>IdBC$fit(Y0, X0, X1 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection, can be
NULL for stationary BC method</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-IdBC-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction. Use named keywords to use stationary or
non-stationary method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdBC$predict(X1 = NULL, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return X1 and / or X0
</p>


<hr>
<a id="method-IdBC-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IdBC$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period
X1 = XY$X1 ## Biased in projection period


## Bias correction
## Step 1 : construction of the class IdBC
idbc = SBCK::IdBC$new() 
## Step 2 : Fit the bias correction model
idbc$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction
Z = idbc$predict(X1,X0) 
## Z$Z0 # == X0
## Z$Z1 # == X1
</code></pre>

<hr>
<h2 id='manhattan'>Manhattan distance</h2><span id='topic+manhattan'></span>

<h3>Description</h3>

<p>Compute Manhattan distance between two dataset or SparseHist X and Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattan(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manhattan_+3A_x">X</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
<tr><td><code id="manhattan_+3A_y">Y</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[float] value of distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = base::cbind( stats::rnorm(2000) , stats::rnorm(2000)  )
Y = base::cbind( stats::rnorm(2000,mean=2)  , stats::rnorm(2000) )
bw = base::c(0.1,0.1)
muX = SBCK::SparseHist( X , bw )
muY = SBCK::SparseHist( Y , bw )

## The four are equals
d = SBCK::manhattan(  X ,   Y )
d = SBCK::manhattan(muX ,   Y )
d = SBCK::manhattan(  X , muY )
d = SBCK::manhattan(muX , muY )

</code></pre>

<hr>
<h2 id='MBCn'>MBCn (Multivariate Bias Correction)</h2><span id='topic+MBCn'></span>

<h3>Description</h3>

<p>Perform a multivariate bias correction.
</p>


<h3>Details</h3>

<p>BC is performed with an alternance of rotation and univariate BC.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n_features</code></dt><dd><p>[integer] Numbers of features</p>
</dd>
<dt><code>bc</code></dt><dd><p>[BC class] Univariate BC method</p>
</dd>
<dt><code>metric</code></dt><dd><p>[function] distance between two datasets</p>
</dd>
<dt><code>iter_slope</code></dt><dd><p>[Stopping class criteria] class used to test when stop</p>
</dd>
<dt><code>bc_params</code></dt><dd><p>[list] Parameters of bc</p>
</dd>
<dt><code>ortho_mat</code></dt><dd><p>[array] Array of orthogonal matrix</p>
</dd>
<dt><code>tips</code></dt><dd><p>[array] Array which contains the product of ortho and inverse
of next</p>
</dd>
<dt><code>lbc</code></dt><dd><p>[list] list of BC method used.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MBCn-new"><code>MBCn$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MBCn-fit"><code>MBCn$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-MBCn-predict"><code>MBCn$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-MBCn-clone"><code>MBCn$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MBCn-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new MBCn object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MBCn$new(
  bc = QDM,
  metric = wasserstein,
  stopping_criteria = SlopeStoppingCriteria,
  stopping_criteria_params = list(minit = 20, maxit = 100, tol = 0.001),
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bc</code></dt><dd><p>[BC class] Univariate bias correction method</p>
</dd>
<dt><code>metric</code></dt><dd><p>[function] distance between two datasets</p>
</dd>
<dt><code>stopping_criteria</code></dt><dd><p>[Stopping class criteria] class use to test when
to stop the iterations</p>
</dd>
<dt><code>stopping_criteria_params</code></dt><dd><p>[list] parameters passed to
stopping_criteria class</p>
</dd>
<dt><code>...</code></dt><dd><p>[] Others arguments passed to bc.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'MBCn' object.
</p>


<hr>
<a id="method-MBCn-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>MBCn$fit(Y0, X0, X1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-MBCn-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>MBCn$predict(X1, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL, else return a list containing Z1 and Z0,
the corrections of X1 and X0
</p>


<hr>
<a id="method-MBCn-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MBCn$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Cannon, A. J., Sobie, S. R., and Murdock, T. Q.: Bias correction
of simulated precipitation by quantile mapping: how well do
methods preserve relative changes in quantiles and extremes?, J.
Climate, 28, 6938–6959,
https://doi.org/10.1175/JCLI-D-14- 00754.1, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(200)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period
X1 = XY$X1 ## Biased in projection period

## Bias correction
## Step 1 : construction of the class MBCn
mbcn = SBCK::MBCn$new() 
## Step 2 : Fit the bias correction model
mbcn$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction, Z is a list containing
## corrections
Z = mbcn$predict(X1,X0) 
Z$Z0 ## Correction in calibration period
Z$Z1 ## Correction in projection period

</code></pre>

<hr>
<h2 id='minkowski'>Minkowski distance</h2><span id='topic+minkowski'></span>

<h3>Description</h3>

<p>Compute Minkowski distance between two dataset or SparseHist X and Y. If
p = 2, it is the Euclidean distance, for p = 1, it is the manhattan distance,
if p = Inf, chebyshev distance is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minkowski(X, Y, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minkowski_+3A_x">X</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
<tr><td><code id="minkowski_+3A_y">Y</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
<tr><td><code id="minkowski_+3A_p">p</code></td>
<td>
<p>[float] power of distance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[float] value of distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = base::cbind( stats::rnorm(2000) , stats::rnorm(2000)  )
Y = base::cbind( stats::rnorm(2000,mean=2)  , stats::rnorm(2000) )
bw = base::c(0.1,0.1)
muX = SBCK::SparseHist( X , bw )
muY = SBCK::SparseHist( Y , bw )

## The four are equals
d = SBCK::minkowski(  X ,   Y , p = 3 )
d = SBCK::minkowski(muX ,   Y , p = 3 )
d = SBCK::minkowski(  X , muY , p = 3 )
d = SBCK::minkowski(muX , muY , p = 3 )

</code></pre>

<hr>
<h2 id='MRec'>MRec (Matrix Recorrelation) method</h2><span id='topic+MRec'></span>

<h3>Description</h3>

<p>Perform a multivariate bias correction with Gaussian assumption.
</p>


<h3>Details</h3>

<p>Only pearson correlations are corrected.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>n_features</code></dt><dd><p>[integer] Numbers of features</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MRec-new"><code>MRec$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MRec-fit"><code>MRec$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-MRec-predict"><code>MRec$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-MRec-clone"><code>MRec$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MRec-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new MRec object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MRec$new(distY = NULL, distX = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>distY</code></dt><dd><p>[A list of ROOPSD distribution or NULL] Describe the law of
each margins. A list permit to use different laws for each
margins. Default is empirical.</p>
</dd>
<dt><code>distX</code></dt><dd><p>[A list of ROOPSD distribution or NULL] Describe the law of
each margins. A list permit to use different laws for each
margins. Default is empirical.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'MRec' object.
</p>


<hr>
<a id="method-MRec-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>MRec$fit(Y0, X0, X1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-MRec-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>MRec$predict(X1, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL, else return a list containing Z1 and Z0,
the corrections of X1 and X0
</p>


<hr>
<a id="method-MRec-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MRec$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Bárdossy, A. and Pegram, G.: Multiscale spatial recorrelation of
RCM precipitation to produce unbiased climate change scenarios
over large areas and small, Water Resources Research, 48, 9502–,
https://doi.org/10.1029/2011WR011524, 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period
X1 = XY$X1 ## Biased in projection period

## Bias correction
## Step 1 : construction of the class MRec 
mrec = SBCK::MRec$new() 
## Step 2 : Fit the bias correction model
mrec$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction, Z is a list containing corrections.
Z = mrec$predict(X1,X0) ## X0 is optional, in this case Z0 is NULL
Z$Z0 ## Correction in calibration period
Z$Z1 ## Correction in projection period

</code></pre>

<hr>
<h2 id='MVQuantilesShuffle'>MVQuantilesShuffle</h2><span id='topic+MVQuantilesShuffle'></span>

<h3>Description</h3>

<p>Multivariate Schaake shuffle using the quantiles.
</p>


<h3>Details</h3>

<p>Used to reproduce the dependence structure of a dataset to another dataset
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>col_cond</code></dt><dd><p>[vector] Conditionning columns</p>
</dd>
<dt><code>col_ucond</code></dt><dd><p>[vector] Un-conditionning columns</p>
</dd>
<dt><code>lag_search</code></dt><dd><p>[integer] Number of lags to transform the dependence structure</p>
</dd>
<dt><code>lag_keep</code></dt><dd><p>[integer] Number of lags to keep</p>
</dd>
<dt><code>n_features</code></dt><dd><p>[integer] Number of features (dimensions), internal</p>
</dd>
<dt><code>qY</code></dt><dd><p>[matrix] Quantile structure fitted, internal</p>
</dd>
<dt><code>bsYc</code></dt><dd><p>[matrix] Block search fitted, internal</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MVQuantilesShuffle-new"><code>MVQuantilesShuffle$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MVQuantilesShuffle-fit"><code>MVQuantilesShuffle$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-MVQuantilesShuffle-transform"><code>MVQuantilesShuffle$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-MVQuantilesShuffle-clone"><code>MVQuantilesShuffle$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MVQuantilesShuffle-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new MVQuantilesShuffle object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MVQuantilesShuffle$new(col_cond = base::c(1), lag_search = 1, lag_keep = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col_cond</code></dt><dd><p>Conditionning colum</p>
</dd>
<dt><code>lag_search</code></dt><dd><p>Number of lags to transform the dependence structure</p>
</dd>
<dt><code>lag_keep</code></dt><dd><p>Number of lags to keep</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'MVQuantilesShuffle' object.
</p>


<hr>
<a id="method-MVQuantilesShuffle-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit method
</p>


<h5>Usage</h5>

<div class="r"><pre>MVQuantilesShuffle$fit(Y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y</code></dt><dd><p>[vector] Dataset to infer the dependance structure</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-MVQuantilesShuffle-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transform method
</p>


<h5>Usage</h5>

<div class="r"><pre>MVQuantilesShuffle$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>[vector] Dataset to match the dependance structure with the Y fitted</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Z The X with the quantiles structure of Y
</p>


<hr>
<a id="method-MVQuantilesShuffle-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MVQuantilesShuffle$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Vrac, M. et S. Thao (2020). “R2 D2 v2.0 : accounting for temporal
dependences in multivariate bias correction via analogue rank
resampling”. In : Geosci. Model Dev. 13.11, p. 5367-5387.
doi :10.5194/gmd-13-5367-2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate sample
X = matrix( stats::rnorm( n = 100 ) , ncol = 4 )
Y = matrix( stats::rnorm( n = 100 ) , ncol = 4 )

## Fit dependence structure
## Assume that the link beween column 2 and 4 is correct, and change also
## the auto-correlation structure until lag 3 = lag_keep - 1
mvq = MVQuantilesShuffle$new( base::c(2,4) , lag_search = 6 , lag_keep = 4 )
mvq$fit(Y)
Z = mvq$transform(X)

</code></pre>

<hr>
<h2 id='MVRanksShuffle'>MVRanksShuffle</h2><span id='topic+MVRanksShuffle'></span>

<h3>Description</h3>

<p>Multivariate Schaake shuffle using the ranks.
</p>


<h3>Details</h3>

<p>Used to reproduce the dependence structure of a dataset to another dataset
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>col_cond</code></dt><dd><p>[vector] Conditionning columns</p>
</dd>
<dt><code>col_ucond</code></dt><dd><p>[vector] Un-conditionning columns</p>
</dd>
<dt><code>lag_search</code></dt><dd><p>[integer] Number of lags to transform the dependence structure</p>
</dd>
<dt><code>lag_keep</code></dt><dd><p>[integer] Number of lags to keep</p>
</dd>
<dt><code>n_features</code></dt><dd><p>[integer] Number of features (dimensions), internal</p>
</dd>
<dt><code>qY</code></dt><dd><p>[matrix] Ranks structure fitted, internal</p>
</dd>
<dt><code>bsYc</code></dt><dd><p>[matrix] Block search fitted, internal</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MVRanksShuffle-new"><code>MVRanksShuffle$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MVRanksShuffle-fit"><code>MVRanksShuffle$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-MVRanksShuffle-transform"><code>MVRanksShuffle$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-MVRanksShuffle-clone"><code>MVRanksShuffle$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MVRanksShuffle-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new MVRanksShuffle object.
</p>


<h5>Usage</h5>

<div class="r"><pre>MVRanksShuffle$new(col_cond = base::c(1), lag_search = 1, lag_keep = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col_cond</code></dt><dd><p>Conditionning colum</p>
</dd>
<dt><code>lag_search</code></dt><dd><p>Number of lags to transform the dependence structure</p>
</dd>
<dt><code>lag_keep</code></dt><dd><p>Number of lags to keep</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'MVRanksShuffle' object.
</p>


<hr>
<a id="method-MVRanksShuffle-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit method
</p>


<h5>Usage</h5>

<div class="r"><pre>MVRanksShuffle$fit(Y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y</code></dt><dd><p>[vector] Dataset to infer the dependance structure</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-MVRanksShuffle-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transform method
</p>


<h5>Usage</h5>

<div class="r"><pre>MVRanksShuffle$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>[vector] Dataset to match the dependance structure with the Y fitted</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Z The X with the quantiles structure of Y
</p>


<hr>
<a id="method-MVRanksShuffle-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MVRanksShuffle$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Vrac, M. et S. Thao (2020). “R2 D2 v2.0 : accounting for temporal
dependences in multivariate bias correction via analogue rank
resampling”. In : Geosci. Model Dev. 13.11, p. 5367-5387.
doi :10.5194/gmd-13-5367-2020.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate sample
X = matrix( stats::rnorm( n = 100 ) , ncol = 4 )
Y = matrix( stats::rnorm( n = 100 ) , ncol = 4 )

## Fit dependence structure
## Assume that the link beween column 2 and 4 is correct, and change also
## the auto-correlation structure until lag 3 = lag_keep - 1
mvr = MVRanksShuffle$new( base::c(2,4) , lag_search = 6 , lag_keep = 4 )
mvr$fit(Y)
Z = mvr$transform(X)

</code></pre>

<hr>
<h2 id='OTC'>OTC (Optimal Transport Correction) method</h2><span id='topic+OTC'></span>

<h3>Description</h3>

<p>Perform a multivariate bias correction of X0 with respect to Y0.
</p>


<h3>Details</h3>

<p>Joint distribution, i.e. all dependence are corrected.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>bin_width</code></dt><dd><p>[vector or NULL] A vector of lengths of the cells
discretizing R^numbers of variables. If NULL, it is estimating
during the fit</p>
</dd>
<dt><code>bin_origin</code></dt><dd><p>[vector or NULL] Coordinate of lower corner of one
cell. If NULL, c(0,...,0) is used</p>
</dd>
<dt><code>muX</code></dt><dd><p>[SparseHist] Histogram of the data from the model</p>
</dd>
<dt><code>muY</code></dt><dd><p>[SparseHist] Histogram of the data from the observations</p>
</dd>
<dt><code>ot</code></dt><dd><p>[OTSolver] Optimal Transport solver, default is the network
simplex</p>
</dd>
<dt><code>plan</code></dt><dd><p>[matrix] The plan computed by the ot solver.</p>
</dd>
<dt><code>n_features</code></dt><dd><p>[integer] Numbers of features</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OTC-new"><code>OTC$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OTC-fit"><code>OTC$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-OTC-predict"><code>OTC$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-OTC-clone"><code>OTC$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-OTC-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new OTC object.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTC$new(bin_width = NULL, bin_origin = NULL, ot = SBCK::OTNetworkSimplex$new())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bin_width</code></dt><dd><p>[vector or NULL] A vector of lengths of the cells
discretizing R^numbers of variables. If NULL, it is estimating
during the fit</p>
</dd>
<dt><code>bin_origin</code></dt><dd><p>[vector or NULL] Coordinate of lower corner of one
cell. If NULL, c(0,...,0) is used</p>
</dd>
<dt><code>ot</code></dt><dd><p>[OTSolver] Optimal Transport solver, default is the network
simplex</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'OTC' object.
</p>


<hr>
<a id="method-OTC-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>OTC$fit(Y0, X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-OTC-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>
<p>Note: Only the center of the bins associated to the corrected points are
returned, but all corrections of the form:
&gt;&gt; bw = otc$bin_width / 2
&gt;&gt; n  = base::prod(base::dim(X0))
&gt;&gt; Z0 = otc$predict(X0)
&gt;&gt; Z0 = Z0 + t(matrix(stats::runif( n = n min = - bw , max = bw ) , ncol = dim(X0)[1] ))
are equivalent for OTC.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTC$predict(X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix] Return the corrections of X0
</p>


<hr>
<a id="method-OTC-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTC$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Robin, Y., Vrac, M., Naveau, P., Yiou, P.: Multivariate
stochastic bias corrections with optimal transport, Hydrol. Earth
Syst. Sci., 23, 773–786, 2019,
https://doi.org/10.5194/hess-23-773-2019
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two bivariate random variables (rnorm and rexp are inverted between ref 
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period

## Bin length
bin_width = SBCK::bin_width_estimator( list(X0,Y0) )

## Bias correction
## Step 1 : construction of the class OTC 
otc = SBCK::OTC$new( bin_width ) 
## Step 2 : Fit the bias correction model
otc$fit( Y0 , X0 )
## Step 3 : perform the bias correction, Z0 is the correction of
## X0 with respect to the estimation of Y0
Z0 = otc$predict(X0)

</code></pre>

<hr>
<h2 id='OTHist'>Optimal Transport Histogram</h2><span id='topic+OTHist'></span>

<h3>Description</h3>

<p>Histogram
</p>


<h3>Details</h3>

<p>Just a generic class which contains two arguments, p (probability) and c
(center of bins)
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>[vector] Vector of probability</p>
</dd>
<dt><code>c</code></dt><dd><p>[matrix] Vector of center of bins, with nrow = n_samples and ncol = n_features</p>
</dd>
<dt><code>bin_width</code></dt><dd><p>[vector or NULL] A vector of lengths of the cells
discretizing R^numbers of variables. If NULL, it is estimating
during the fit</p>
</dd>
<dt><code>bin_origin</code></dt><dd><p>[vector or NULL] Coordinate of lower corner of one
cell. If NULL, c(0,...,0) is used</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OTHist-new"><code>OTHist$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OTHist-clone"><code>OTHist$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-OTHist-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new OTHist object.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTHist$new(p, c)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p</code></dt><dd><p>[vector] Vector of probability</p>
</dd>
<dt><code>c</code></dt><dd><p>[matrix] Vector of center of bins, with nrow = n_samples and ncol = n_features</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'OTHist' object.
</p>


<hr>
<a id="method-OTHist-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTHist$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Build a random discrete probability distribution
p = stats::rnorm(100)
p = p / base::sum(p)
c = base::seq( -1 , 1 , length = 100 )
mu = OTHist$new( p , c )

</code></pre>

<hr>
<h2 id='OTNetworkSimplex'>Optimal Transport Network Simplex solver</h2><span id='topic+OTNetworkSimplex'></span>

<h3>Description</h3>

<p>Solve the optimal transport problem with the package 'transport'
</p>


<h3>Details</h3>

<p>use the network simplex algorithm
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>[double] Power of the plan</p>
</dd>
<dt><code>plan</code></dt><dd><p>[matrix] transport plan</p>
</dd>
<dt><code>success</code></dt><dd><p>[bool] If the fit is a success or not</p>
</dd>
<dt><code>C</code></dt><dd><p>[matrix] Cost matrix</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OTNetworkSimplex-new"><code>OTNetworkSimplex$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OTNetworkSimplex-fit"><code>OTNetworkSimplex$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-OTNetworkSimplex-clone"><code>OTNetworkSimplex$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-OTNetworkSimplex-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new OTNetworkSimplex object.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTNetworkSimplex$new(p = 2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p</code></dt><dd><p>[double] Power of the plan</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'OTNetworkSimplex' object.
</p>


<hr>
<a id="method-OTNetworkSimplex-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the OT plan
</p>


<h5>Usage</h5>

<div class="r"><pre>OTNetworkSimplex$fit(muX0, muX1, C = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>muX0</code></dt><dd><p>[SparseHist or OTHist] Source histogram to move</p>
</dd>
<dt><code>muX1</code></dt><dd><p>[SparseHist or OTHist] Target histogram</p>
</dd>
<dt><code>C</code></dt><dd><p>[matrix or NULL] Cost matrix (without power p) between muX0 and
muX1, if NULL pairwise_distances is called with Euclidean distance.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-OTNetworkSimplex-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OTNetworkSimplex$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Bazaraa, M. S., Jarvis, J. J., and Sherali, H. D.: Linear
Programming and Network Flows, 4th edn., John Wiley &amp; Sons, 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Define two dataset
X = stats::rnorm(2000)
Y = stats::rnorm(2000 , mean = 5 )
bw = base::c(0.1)
muX = SBCK::SparseHist( X , bw )
muY = SBCK::SparseHist( Y , bw )

## Find solution
ot = OTNetworkSimplex$new()
ot$fit( muX , muY )

print( sum(ot$plan) ) ## Must be equal to 1
print( ot$success )   ## If solve is success
print( sqrt(sum(ot$plan * ot$C)) ) ## Cost of plan

</code></pre>

<hr>
<h2 id='pairwise_distances'>Pairwise distances</h2><span id='topic+pairwise_distances'></span>

<h3>Description</h3>

<p>Compute the matrix of pairwise distances between a matrix X and a matrix Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise_distances(X,Y,metric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise_distances_+3A_x">X</code></td>
<td>
<p>[matrix] A first matrix (samples in row, features in columns).</p>
</td></tr>
<tr><td><code id="pairwise_distances_+3A_y">Y</code></td>
<td>
<p>[matrix] A second matrix (samples in row, features in columns).
If Y = NULL, then pairwise distances is computed between X and X</p>
</td></tr>
<tr><td><code id="pairwise_distances_+3A_metric">metric</code></td>
<td>
<p>[string or callable] The metric used. If metric is a string,
then metric is compiled (so faster). Available string are:
&quot;euclidean&quot;, &quot;sqeuclidean&quot; (Square of Euclidean distance),
&quot;logeulidean&quot; (log of the Euclidean distance) and &quot;chebyshev&quot; (max). 
Callable must be a function taking two vectors and returning a double.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distXY [matrix] Pairwise distances. distXY[i,j] is the distance 
between X[i,] and Y[j,]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = matrix( stats::rnorm(200) , ncol = 100 , nrow = 2 )
Y = matrix( stats::rexp(300)  , ncol = 150 , nrow = 2 )

distXY = SBCK::pairwise_distances( X , Y ) 

</code></pre>

<hr>
<h2 id='PPPDiffRef'>PPPDiffRef</h2><span id='topic+PPPDiffRef'></span>

<h3>Description</h3>

<p>Apply the diff w.r.t. a ref transformation.
</p>


<h3>Details</h3>

<p>Transform a dataset such that all 'lower' dimensions are replaced by
the 'ref' dimension minus the 'lower'; and all 'upper' dimensions are
replaced by 'upper' minus 'ref'.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PrePostProcessing">SBCK::PrePostProcessing</a></code> -&gt; <code>PPPDiffRef</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ref</code></dt><dd><p>[integer] The reference column</p>
</dd>
<dt><code>lower</code></dt><dd><p>[vector integer] Dimensions lower than ref</p>
</dd>
<dt><code>upper</code></dt><dd><p>[vector integer] Dimensions upper than ref</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PPPDiffRef-new"><code>PPPDiffRef$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPDiffRef-transform"><code>PPPDiffRef$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPDiffRef-itransform"><code>PPPDiffRef$itransform()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPDiffRef-clone"><code>PPPDiffRef$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="fit"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-fit'><code>SBCK::PrePostProcessing$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="predict"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-predict'><code>SBCK::PrePostProcessing$predict()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PPPDiffRef-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new PPPDiffRef object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPDiffRef$new(ref, lower = NULL, upper = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ref</code></dt><dd><p>The reference column</p>
</dd>
<dt><code>lower</code></dt><dd><p>Dimensions lower than ref</p>
</dd>
<dt><code>upper</code></dt><dd><p>Dimensions upper than ref</p>
</dd>
<dt><code>...</code></dt><dd><p>Others arguments are passed to PrePostProcessing</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'PPPDiffRef' object.
</p>


<hr>
<a id="method-PPPDiffRef-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Apply the DiffRef transform.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPDiffRef$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Data to transform</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Xt a transformed matrix
</p>


<hr>
<a id="method-PPPDiffRef-itransform"></a>



<h4>Method <code>itransform()</code></h4>

<p>Apply the DiffRef inverse transform.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPDiffRef$itransform(Xt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xt</code></dt><dd><p>Data to transform</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>X a transformed matrix
</p>


<hr>
<a id="method-PPPDiffRef-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPDiffRef$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Parameters
size  = 2000
nfeat = 5
sign  = base::sample( base::c(-1,1) , nfeat - 1 , replace = TRUE )

## Build data
X     = matrix( stats::rnorm( n = size ) , ncol = 1 )
for( s in sign )
{
	X = base::cbind( X , X[,1] + s * base::abs(matrix( stats::rnorm(n = size) , ncol = 1 )) )
}

## PPP
lower = which( sign ==  1 ) + 1
upper = which( sign == -1 ) + 1
ppp   = SBCK::PPPDiffRef$new( ref = 1 , lower = lower , upper = upper )
Xt    = ppp$transform(X)
Xti   = ppp$itransform(Xt)

print( base::max( base::abs( X - Xti ) ) )

</code></pre>

<hr>
<h2 id='PPPFunctionLink'>PPPFunctionLink</h2><span id='topic+PPPFunctionLink'></span>

<h3>Description</h3>

<p>Base class to build link function pre-post processing class. See also
the PrePostProcessing documentation
</p>


<h3>Details</h3>

<p>This class is used to define pre/post processing class with a link function
and its inverse. See example.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PrePostProcessing">SBCK::PrePostProcessing</a></code> -&gt; <code>PPPFunctionLink</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PPPFunctionLink-new"><code>PPPFunctionLink$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPFunctionLink-transform"><code>PPPFunctionLink$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPFunctionLink-itransform"><code>PPPFunctionLink$itransform()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPFunctionLink-clone"><code>PPPFunctionLink$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="fit"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-fit'><code>SBCK::PrePostProcessing$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="predict"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-predict'><code>SBCK::PrePostProcessing$predict()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PPPFunctionLink-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new PPPFunctionLink object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPFunctionLink$new(transform_, itransform_, cols = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>transform_</code></dt><dd><p>The transform function</p>
</dd>
<dt><code>itransform_</code></dt><dd><p>The inverse transform function</p>
</dd>
<dt><code>cols</code></dt><dd><p>Columns to apply the link function</p>
</dd>
<dt><code>...</code></dt><dd><p>Others arguments are passed to PrePostProcessing</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'PPPFunctionLink' object.
</p>


<hr>
<a id="method-PPPFunctionLink-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Apply the transform.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPFunctionLink$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Data to transform</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Xt a transformed matrix
</p>


<hr>
<a id="method-PPPFunctionLink-itransform"></a>



<h4>Method <code>itransform()</code></h4>

<p>Apply the inverse transform.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPFunctionLink$itransform(Xt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xt</code></dt><dd><p>Data to transform</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>X a transformed matrix
</p>


<hr>
<a id="method-PPPFunctionLink-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPFunctionLink$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Start with data
XY = SBCK::dataset_like_tas_pr(2000)
X0 = XY$X0
X1 = XY$X1
Y0 = XY$Y0

## Define the link function
transform  = function(x) { return(x^3) }
itransform = function(x) { return(x^(1/3)) }

## And the PPP method
ppp = PPPFunctionLink$new( bc_method = CDFt , transform = transform ,
                                             itransform = itransform )

## And now the correction
## Bias correction
ppp$fit(Y0,X0,X1)
Z = ppp$predict(X1,X0)

</code></pre>

<hr>
<h2 id='PPPLogLinLink'>PPPLogLinLink</h2><span id='topic+PPPLogLinLink'></span>

<h3>Description</h3>

<p>Log linear link function. See also the PrePostProcessing documentation.
</p>


<h3>Details</h3>

<p>Log linear link function. The transform is log(x) if 0 &lt; x &lt; 1, else x -1,
and the inverse transform exp(x) if x &lt; 0, else x + 1.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+PrePostProcessing">SBCK::PrePostProcessing</a></code> -&gt; <code><a href="#topic+PPPFunctionLink">SBCK::PPPFunctionLink</a></code> -&gt; <code>PPPLogLinLink</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PPPLogLinLink-new"><code>PPPLogLinLink$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPLogLinLink-clone"><code>PPPLogLinLink$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="fit"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-fit'><code>SBCK::PrePostProcessing$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="predict"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-predict'><code>SBCK::PrePostProcessing$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PPPFunctionLink" data-id="itransform"><a href='../../SBCK/html/PPPFunctionLink.html#method-PPPFunctionLink-itransform'><code>SBCK::PPPFunctionLink$itransform()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PPPFunctionLink" data-id="transform"><a href='../../SBCK/html/PPPFunctionLink.html#method-PPPFunctionLink-transform'><code>SBCK::PPPFunctionLink$transform()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PPPLogLinLink-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new PPPLogLinLink object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPLogLinLink$new(s = 1e-05, cols = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s</code></dt><dd><p>The value where the function jump from exp to linear</p>
</dd>
<dt><code>cols</code></dt><dd><p>Columns to apply the link function</p>
</dd>
<dt><code>...</code></dt><dd><p>Others arguments are passed to PrePostProcessing</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'PPPLogLinLink' object.
</p>


<hr>
<a id="method-PPPLogLinLink-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPLogLinLink$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Start with data
XY = SBCK::dataset_like_tas_pr(2000)
X0 = XY$X0
X1 = XY$X1
Y0 = XY$Y0

## Define the PPP method
ppp = PPPLogLinLink$new( bc_method = CDFt , cols = 2 ,
                         pipe = list(PPPSSR),
                         pipe_kwargs = list(list(cols=2)) )

## And now the correction
## Bias correction
ppp$fit(Y0,X0,X1)
Z = ppp$predict(X1,X0)

</code></pre>

<hr>
<h2 id='PPPPreserveOrder'>PPPPreserveOrder</h2><span id='topic+PPPPreserveOrder'></span>

<h3>Description</h3>

<p>Set an order between cols, and preserve it by swapping values after
the correction
</p>


<h3>Details</h3>

<p>Set an order between cols, and preserve it by swapping values after
the correction
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PrePostProcessing">SBCK::PrePostProcessing</a></code> -&gt; <code>PPPPreserveOrder</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PPPPreserveOrder-new"><code>PPPPreserveOrder$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPPreserveOrder-transform"><code>PPPPreserveOrder$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPPreserveOrder-itransform"><code>PPPPreserveOrder$itransform()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPPreserveOrder-clone"><code>PPPPreserveOrder$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="fit"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-fit'><code>SBCK::PrePostProcessing$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="predict"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-predict'><code>SBCK::PrePostProcessing$predict()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PPPPreserveOrder-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new PPPPreserveOrder object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPPreserveOrder$new(cols = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cols</code></dt><dd><p>The columns to keep the order</p>
</dd>
<dt><code>...</code></dt><dd><p>Others arguments are passed to PrePostProcessing</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'PPPPreserveOrder' object.
</p>


<hr>
<a id="method-PPPPreserveOrder-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>nothing occur here
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPPreserveOrder$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Data to transform</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Xt a transformed matrix
</p>


<hr>
<a id="method-PPPPreserveOrder-itransform"></a>



<h4>Method <code>itransform()</code></h4>

<p>sort along cols
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPPreserveOrder$itransform(Xt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xt</code></dt><dd><p>Data to transform</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>X a transformed matrix
</p>


<hr>
<a id="method-PPPPreserveOrder-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPPreserveOrder$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Build data
X = matrix( stats::rnorm( n = 20 ) , ncol = 2 )

## PPP
ppp   = SBCK::PPPPreserveOrder$new( cols = base::c(1,2) )
Xt    = ppp$transform(X) ## Nothing
Xti   = ppp$itransform(Xt) ## Order

</code></pre>

<hr>
<h2 id='PPPSquareLink'>PPPSquareLink</h2><span id='topic+PPPSquareLink'></span>

<h3>Description</h3>

<p>Square link function. See also the PrePostProcessing documentation.
</p>


<h3>Details</h3>

<p>Square link function. The transform is x^2, and the sign(x)*sqrt(abs(x)) its
inverse.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+PrePostProcessing">SBCK::PrePostProcessing</a></code> -&gt; <code><a href="#topic+PPPFunctionLink">SBCK::PPPFunctionLink</a></code> -&gt; <code>PPPSquareLink</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PPPSquareLink-new"><code>PPPSquareLink$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPSquareLink-clone"><code>PPPSquareLink$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="fit"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-fit'><code>SBCK::PrePostProcessing$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="predict"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-predict'><code>SBCK::PrePostProcessing$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PPPFunctionLink" data-id="itransform"><a href='../../SBCK/html/PPPFunctionLink.html#method-PPPFunctionLink-itransform'><code>SBCK::PPPFunctionLink$itransform()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PPPFunctionLink" data-id="transform"><a href='../../SBCK/html/PPPFunctionLink.html#method-PPPFunctionLink-transform'><code>SBCK::PPPFunctionLink$transform()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PPPSquareLink-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new PPPSquareLink object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPSquareLink$new(cols = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cols</code></dt><dd><p>Columns to apply the link function</p>
</dd>
<dt><code>...</code></dt><dd><p>Others arguments are passed to PrePostProcessing</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'PPPSquareLink' object.
</p>


<hr>
<a id="method-PPPSquareLink-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPSquareLink$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Start with data
XY = SBCK::dataset_like_tas_pr(2000)
X0 = XY$X0
X1 = XY$X1
Y0 = XY$Y0

## Define the PPP method
ppp = PPPSquareLink$new( bc_method = CDFt , cols = 2 )

## And now the correction
## Bias correction
ppp$fit(Y0,X0,X1)
Z = ppp$predict(X1,X0)

</code></pre>

<hr>
<h2 id='PPPSSR'>PPPSSR</h2><span id='topic+PPPSSR'></span>

<h3>Description</h3>

<p>Apply the SSR transformation.
</p>


<h3>Details</h3>

<p>Apply the SSR transformation. The SSR transformation replace the 0 by a
random values between 0 and the minimal non zero value (the threshold). The
inverse transform replace all values lower than the threshold by 0. The
threshold used for inverse transform is given by the keyword 'isaved', which
takes the value 'Y0' (reference in calibration period), or 'X0' (biased in
calibration period), or 'X1' (biased in projection period)
</p>


<h3>Super class</h3>

<p><code><a href="#topic+PrePostProcessing">SBCK::PrePostProcessing</a></code> -&gt; <code>PPPSSR</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>Xn</code></dt><dd><p>[vector] Threshold</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PPPSSR-new"><code>PPPSSR$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPSSR-transform"><code>PPPSSR$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPSSR-itransform"><code>PPPSSR$itransform()</code></a>
</p>
</li>
<li> <p><a href="#method-PPPSSR-clone"><code>PPPSSR$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="fit"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-fit'><code>SBCK::PrePostProcessing$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="SBCK" data-topic="PrePostProcessing" data-id="predict"><a href='../../SBCK/html/PrePostProcessing.html#method-PrePostProcessing-predict'><code>SBCK::PrePostProcessing$predict()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-PPPSSR-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new PPPSSR object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPSSR$new(cols = NULL, isaved = "Y0", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cols</code></dt><dd><p>Columns to apply the SSR</p>
</dd>
<dt><code>isaved</code></dt><dd><p>Choose the threshold used for the inverse transform. Can be
&quot;Y0&quot;, &quot;X0&quot; and &quot;X1&quot;.</p>
</dd>
<dt><code>...</code></dt><dd><p>Others arguments are passed to PrePostProcessing</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'PPPSSR' object.
</p>


<hr>
<a id="method-PPPSSR-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Apply the SSR transform, i.e. all 0 are replaced by random values between
0 (excluded) and the minimal non zero value.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPSSR$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Data to transform</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Xt a transformed matrix
</p>


<hr>
<a id="method-PPPSSR-itransform"></a>



<h4>Method <code>itransform()</code></h4>

<p>Apply the inverse SSR transform, i.e. all values lower than the threshold
found in the transform function are replaced by 0.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPSSR$itransform(Xt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xt</code></dt><dd><p>Data to transform</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>X a transformed matrix
</p>


<hr>
<a id="method-PPPSSR-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPPSSR$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Start with data
XY = SBCK::dataset_like_tas_pr(2000)
X0 = XY$X0
X1 = XY$X1
Y0 = XY$Y0

## Define the PPP method
ppp = PPPSSR$new( bc_method = CDFt , cols = 2 )

## And now the correction
## Bias correction
ppp$fit(Y0,X0,X1)
Z = ppp$predict(X1,X0)

</code></pre>

<hr>
<h2 id='PrePostProcessing'>PrePostProcessing base class</h2><span id='topic+PrePostProcessing'></span>

<h3>Description</h3>

<p>Base class to pre/post process data before/after a bias correction
</p>


<h3>Details</h3>

<p>This base class can be considered as the identity pre-post processing, and
is used to be herited by others pre/post processing class. The key ideas are:<br />
- A PrePostProcessing based class contains a bias correction method, initalized
by the 'bc_method' argument, always available for all herited class<br />
- The 'pipe' keyword is a list of pre/post processing class, applied one after
the other.<br />
</p>
<p>Try with an example, start with a dataset similar to tas/pr:<br />
&gt;&gt;&gt; XY = SBCK::dataset_like_tas_pr(2000)<br />
&gt;&gt;&gt; X0 = XY$X0<br />
&gt;&gt;&gt; X1 = XY$X1<br />
&gt;&gt;&gt; Y0 = XY$Y0<br />
</p>
<p>The first column is Gaussian, but the second is an exponential law with a Dirac
mass at 0, represented the 0 of precipitations. For a quantile mapping
correction in the calibration period, we just apply<br />
&gt;&gt;&gt; qm = SBCK::QM$new()<br />
&gt;&gt;&gt; qm$fit(Y0,X0)<br />
&gt;&gt;&gt; Z0 = qm$predict(X0)<br />
</p>
<p>Now, if we want to pre-post process with the SSR method (0 are replaced by
random values between 0 (excluded) and the minimal non zero value), we write:<br />
&gt;&gt;&gt; ppp = SBCK::PPPSSR$new( bc_method = QM , cols = 2 )<br />
&gt;&gt;&gt; ppp$fit(Y0,X0)<br />
&gt;&gt;&gt; Z0 = ppp$predict(X0)<br />
</p>
<p>The SSR approach is applied only on the second column (the precipitation), and
the syntax is the same than for a simple bias correction method.<br />
</p>
<p>Imagine now that we want to apply the SSR, and to ensure the positivity of CDFt
for precipitation, we also want to use the LogLinLink pre-post processing
method. This can be done with the following syntax:<br />
&gt;&gt;&gt; ppp = PPPLogLinLink$new( bc_method = CDFt , cols = 2 ,<br />
&gt;&gt;&gt;                          pipe = list(PPPSSR) , <br />
&gt;&gt;&gt;                          pipe_kwargs = list( list(cols = 2) ) )<br />
&gt;&gt;&gt; ppp$fit(Y0,X0,X1)<br />
&gt;&gt;&gt; Z = ppp$predict(X1,X0)<br />
</p>
<p>With this syntax, the pre processing operation is
PPPLogLinLink$transform(PPPSSR$transform(data)) and post processing operation
PPPSSR$itransform(PPPLogLinLink$itransform(bc_data)). So the formula can read
from right to left (as the mathematical composition). Note it is equivalent
to define:<br />
&gt;&gt;&gt; ppp = PrePostProcessing$new( bc_method = CDFt,<br />
&gt;&gt;&gt;                              pipe = list(PPPLogLinLink,PPPSSR),<br />
&gt;&gt;&gt;                              pipe_kwargs = list( list(cols=2) , list(cols=2) ) )<br />
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PrePostProcessing-new"><code>PrePostProcessing$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-transform"><code>PrePostProcessing$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-itransform"><code>PrePostProcessing$itransform()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-fit"><code>PrePostProcessing$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-predict"><code>PrePostProcessing$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-PrePostProcessing-clone"><code>PrePostProcessing$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PrePostProcessing-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new PrePostProcessing object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$new(
  bc_method = NULL,
  bc_method_kwargs = list(),
  pipe = list(),
  pipe_kwargs = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>bc_method</code></dt><dd><p>The bias correction method</p>
</dd>
<dt><code>bc_method_kwargs</code></dt><dd><p>Dict of keyword arguments passed to bc_method</p>
</dd>
<dt><code>pipe</code></dt><dd><p>list of others PrePostProcessing class to pipe</p>
</dd>
<dt><code>pipe_kwargs</code></dt><dd><p>list of list of keyword arguments passed to each
elements of pipe</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'PrePostProcessing' object.
</p>


<hr>
<a id="method-PrePostProcessing-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Transformation applied to data before the bias correction. Just the
identity for this class
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>[matrix: n_samples * n_features]</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Xt [matrix: n_samples * n_features]
</p>


<hr>
<a id="method-PrePostProcessing-itransform"></a>



<h4>Method <code>itransform()</code></h4>

<p>Transformation applied to data after the bias correction. Just the
identity for this class
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$itransform(Xt)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xt</code></dt><dd><p>[matrix: n_samples * n_features]</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>X [matrix: n_samples * n_features]
</p>


<hr>
<a id="method-PrePostProcessing-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Apply the pre processing and fit the bias correction method. If X1 is
NULL, the method is considered as stationary
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$fit(Y0, X0, X1 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-PrePostProcessing-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction, apply pre-processing before, and post-processing
after
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$predict(X1 = NULL, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL (and vice-versa), else return a list
containing Z1 and Z0, the corrections of X1 and X0
</p>


<hr>
<a id="method-PrePostProcessing-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PrePostProcessing$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Start with data
XY = SBCK::dataset_like_tas_pr(2000)
X0 = XY$X0
X1 = XY$X1
Y0 = XY$Y0

## Define pre/post processing method
ppp = PrePostProcessing$new( bc_method = CDFt,
                             pipe = list(PPPLogLinLink,PPPSSR),
                             pipe_kwargs = list( list(cols=2) , list(cols=2) ) )

## Bias correction
ppp$fit(Y0,X0,X1)
Z = ppp$predict(X1,X0)

</code></pre>

<hr>
<h2 id='QDM'>QDM (Quantile delta mapping method)</h2><span id='topic+QDM'></span>

<h3>Description</h3>

<p>Perform a bias correction.
</p>


<h3>Details</h3>

<p>Mix of delta and quantile method
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-QDM-new"><code>QDM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-QDM-fit"><code>QDM$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-QDM-predict"><code>QDM$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-QDM-clone"><code>QDM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-QDM-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new QDM object.
</p>


<h5>Usage</h5>

<div class="r"><pre>QDM$new(delta = "additive", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>delta</code></dt><dd><p>[character or list] If character : &quot;additive&quot; or
&quot;multiplicative&quot;. If a list is given, delta[[1]] is the delta
transform operator, and delta[[2]] its inverse.</p>
</dd>
<dt><code>...</code></dt><dd><p>[] Named arguments passed to quantile mapping</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'QDM' object.
</p>


<hr>
<a id="method-QDM-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>QDM$fit(Y0, X0, X1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-QDM-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>QDM$predict(X1, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL, else return a list containing Z1 and Z0,
the corrections of X1 and X0
</p>


<hr>
<a id="method-QDM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QDM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Cannon, A. J., Sobie, S. R., and Murdock, T. Q.: Bias correction
of simulated precipitation by quantile mapping: how well do
methods preserve relative changes in quantiles and extremes?, J.
Climate, 28, 6938–6959,
https://doi.org/10.1175/JCLI-D-14- 00754.1, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period
X1 = XY$X1 ## Biased in projection period

## Bias correction
## Step 1 : construction of the class QDM
qdm = SBCK::QDM$new() 
## Step 2 : Fit the bias correction model
qdm$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction, Z is a list containing
## corrections
Z = qdm$predict(X1,X0) 
Z$Z0 ## Correction in calibration period
Z$Z1 ## Correction in projection period

</code></pre>

<hr>
<h2 id='QM'>Quantile Mapping method</h2><span id='topic+QM'></span>

<h3>Description</h3>

<p>Perform an univariate bias correction of X0 with respect to Y0
</p>


<h3>Details</h3>

<p>Correction is applied margins by margins.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>distX0</code></dt><dd><p>[ROOPSD distribution or a list of them] Describe the law of
each margins. A list permit to use different laws for each
margins. Default is ROOPSD::rv_histogram.</p>
</dd>
<dt><code>distY0</code></dt><dd><p>[ROOPSD distribution or a list of them] Describe the law of
each margins. A list permit to use different laws for each
margins. Default is ROOPSD::rv_histogram.</p>
</dd>
<dt><code>n_features</code></dt><dd><p>[integer] Numbers of features</p>
</dd>
<dt><code>tol</code></dt><dd><p>[double] Floatting point tolerance</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-QM-new"><code>QM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-QM-fit"><code>QM$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-QM-predict"><code>QM$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-QM-clone"><code>QM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-QM-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new QM object.
</p>


<h5>Usage</h5>

<div class="r"><pre>QM$new(distX0 = ROOPSD::rv_histogram, distY0 = ROOPSD::rv_histogram, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>distX0</code></dt><dd><p>[ROOPSD distribution or a list of them] Describe the law of
model</p>
</dd>
<dt><code>distY0</code></dt><dd><p>[ROOPSD distribution or a list of them] Describe the law of
observations</p>
</dd>
<dt><code>...</code></dt><dd><p>[] kwargsX0 or kwargsY0, arguments passed to distX0 and distY0</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'QM' object.
</p>


<hr>
<a id="method-QM-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>QM$fit(Y0 = NULL, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-QM-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>QM$predict(X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix] Return the corrections of X0
</p>


<hr>
<a id="method-QM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Panofsky, H. A. and Brier, G. W.: Some applications of statistics
to meteorology, Mineral Industries Extension Services, College of
Mineral Industries, Pennsylvania State University, 103 pp., 1958.
</p>
<p>Wood, A. W., Leung, L. R., Sridhar, V., and Lettenmaier, D. P.:
Hydrologic Implications of Dynamical and Statistical Approaches
to Downscaling Climate Model Outputs, Clim. Change, 62, 189–216,
https://doi.org/10.1023/B:CLIM.0000013685.99609.9e, 2004.
</p>
<p>Déqué, M.: Frequency of precipitation and temperature extremes
over France in an anthropogenic scenario: Model results and
statistical correction according to observed values, Global
Planet. Change, 57, 16–26,
https://doi.org/10.1016/j.gloplacha.2006.11.030, 2007.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period

## Bias correction
## Step 1 : construction of the class QM 
qm = SBCK::QM$new() 
## Step 2 : Fit the bias correction model
qm$fit( Y0 , X0 )
## Step 3 : perform the bias correction, Z0 is the correction of
## X0 with respect to the estimation of Y0
Z0 = qm$predict(X0)

# ## But in fact the laws are known, we can fit parameters:
distY0 = list( ROOPSD::Exponential , ROOPSD::Normal )
distX0 = list( ROOPSD::Normal , ROOPSD::Exponential )
qm_fix = SBCK::QM$new( distY0 = distY0 , distX0 = distX0 )
qm_fix$fit( Y0 , X0 )
Z0 = qm_fix$predict(X0) 
</code></pre>

<hr>
<h2 id='QMrs'>Quantile Mapping RankShuffle method</h2><span id='topic+QMrs'></span>

<h3>Description</h3>

<p>Perform a multivariate bias correction of X with respect to Y
</p>


<h3>Details</h3>

<p>Dependence is corrected with multi_schaake_shuffle.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+QM">SBCK::QM</a></code> -&gt; <code>QMrs</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>irefs</code></dt><dd><p>[vector of int] Indexes for shuffle. Defaults is base::c(1)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-QMrs-new"><code>QMrs$new()</code></a>
</p>
</li>
<li> <p><a href="#method-QMrs-fit"><code>QMrs$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-QMrs-predict"><code>QMrs$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-QMrs-clone"><code>QMrs$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-QMrs-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new QMrs object.
</p>


<h5>Usage</h5>

<div class="r"><pre>QMrs$new(irefs = base::c(1), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>irefs</code></dt><dd><p>[vector of int] Indexes for shuffle. Defaults is base::c(1)
model</p>
</dd>
<dt><code>...</code></dt><dd><p>[] all others arguments are passed to QM class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'QMrs' object.
</p>


<hr>
<a id="method-QMrs-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>QMrs$fit(Y0, X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-QMrs-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>QMrs$predict(X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix] Return the corrections of X0
</p>


<hr>
<a id="method-QMrs-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QMrs$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Vrac, M.: Multivariate bias adjustment of high-dimensional
climate simulations: the Rank Resampling for Distributions and
Dependences (R2 D2 ) bias correction, Hydrol. Earth Syst. Sci.,
22, 3175–3196, https://doi.org/10.5194/hess-22-3175-2018, 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period

## Bias correction
## Step 1 : construction of the class QMrs 
qmrs = SBCK::QMrs$new() 
## Step 2 : Fit the bias correction model
qmrs$fit( Y0 , X0 )
## Step 3 : perform the bias correction
Z0 = qmrs$predict(X0)

</code></pre>

<hr>
<h2 id='R2D2'>R2D2 (Rank Resampling for Distributions and Dependences) method</h2><span id='topic+R2D2'></span>

<h3>Description</h3>

<p>Perform a multivariate (non stationary) bias correction.
</p>


<h3>Details</h3>

<p>Use rankshuffle in calibration and projection period with CDFt
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CDFt">SBCK::CDFt</a></code> -&gt; <code>R2D2</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>irefs</code></dt><dd><p>[vector of int] Indexes for shuffle. Defaults is base::c(1)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-R2D2-new"><code>R2D2$new()</code></a>
</p>
</li>
<li> <p><a href="#method-R2D2-fit"><code>R2D2$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-R2D2-predict"><code>R2D2$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-R2D2-clone"><code>R2D2$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-R2D2-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new R2D2 object.
</p>


<h5>Usage</h5>

<div class="r"><pre>R2D2$new(irefs = base::c(1), ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>irefs</code></dt><dd><p>[vector of int] Indexes for shuffle. Defaults is base::c(1)
model</p>
</dd>
<dt><code>...</code></dt><dd><p>[] all others arguments are passed to CDFt class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'R2D2' object.
</p>


<hr>
<a id="method-R2D2-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>R2D2$fit(Y0, X0, X1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-R2D2-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>R2D2$predict(X1, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL, else return a list containing Z1 and Z0,
the corrections of X1 and X0
</p>


<hr>
<a id="method-R2D2-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>R2D2$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Vrac, M.: Multivariate bias adjustment of high-dimensional
climate simulations: the Rank Resampling for Distributions and
Dependences (R2 D2 ) bias correction, Hydrol. Earth Syst. Sci.,
22, 3175–3196, https://doi.org/10.5194/hess-22-3175-2018, 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period
X1 = XY$X1 ## Biased in projection period

## Bias correction
## Step 1 : construction of the class R2D2 
r2d2 = SBCK::R2D2$new() 
## Step 2 : Fit the bias correction model
r2d2$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction
Z = r2d2$predict(X1,X0) 

</code></pre>

<hr>
<h2 id='RBC'>RBC (Random Bias Correction) method</h2><span id='topic+RBC'></span>

<h3>Description</h3>

<p>Perform a multivariate bias correction of X with respect to Y randomly.
</p>


<h3>Details</h3>

<p>Only for comparison.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RBC-new"><code>RBC$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RBC-fit"><code>RBC$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-RBC-predict"><code>RBC$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-RBC-clone"><code>RBC$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RBC-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new RBC object.
</p>


<h5>Usage</h5>

<div class="r"><pre>RBC$new()</pre></div>



<h5>Returns</h5>

<p>A new 'RBC' object.
</p>


<hr>
<a id="method-RBC-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>RBC$fit(Y0, X0, X1 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features] Model in projection, can be
NULL for stationary BC method</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-RBC-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction. Use named keywords to use stationary or
non-stationary method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RBC$predict(X1 = NULL, X0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X1</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in projection</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix or list] Return the matrix of correction of X1 if X0 is
NULL, else return a list containing Z1 and Z0,
the corrections of X1 and X0
</p>


<hr>
<a id="method-RBC-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RBC$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Three bivariate random variables (rnorm and rexp are inverted between ref
## and bias)
XY = SBCK::dataset_gaussian_exp_2d(2000)
X0 = XY$X0 ## Biased in calibration period
Y0 = XY$Y0 ## Reference in calibration period
X1 = XY$X1 ## Biased in projection period


## Bias correction
## Step 1 : construction of the class RBC
rbc = SBCK::RBC$new() 
## Step 2 : Fit the bias correction model
rbc$fit( Y0 , X0 , X1 )
## Step 3 : perform the bias correction
Z = rbc$predict(X1,X0) 
## Z$Z0 # BC of X0
## Z$Z1 # BC of X1
</code></pre>

<hr>
<h2 id='SBCK'>SBCK</h2><span id='topic+SBCK'></span>

<h3>Description</h3>

<p>Statistical Bias Correction Kit
</p>


<h3>Author(s)</h3>

<p>Yoann Robin Maintainer: Yoann Robin &lt;yoann.robin.k@gmail.com&gt;
</p>

<hr>
<h2 id='schaake_shuffle'>schaake_shuffle function</h2><span id='topic+schaake_shuffle'></span>

<h3>Description</h3>

<p>Apply the Schaake shuffle to transform the rank of X0 such that its
correspond to the rank of Y0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schaake_shuffle(Y0,X0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schaake_shuffle_+3A_y0">Y0</code></td>
<td>
<p>[vector] The reference vector</p>
</td></tr>
<tr><td><code id="schaake_shuffle_+3A_x0">X0</code></td>
<td>
<p>[vector] The vector to transform the rank</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Z0 [vector] X shuffled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X0 = stats::runif(10)
Y0 = stats::runif(10)
Z0 = SBCK::schaake_shuffle( Y0 , X0 )

</code></pre>

<hr>
<h2 id='SchaakeShuffle'>ShaakeShuffle class</h2><span id='topic+SchaakeShuffle'></span>

<h3>Description</h3>

<p>Perform the Schaake Shuffle
</p>


<h3>Details</h3>

<p>as fit/predict mode
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SchaakeShuffle-new"><code>SchaakeShuffle$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SchaakeShuffle-fit"><code>SchaakeShuffle$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-SchaakeShuffle-predict"><code>SchaakeShuffle$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-SchaakeShuffle-clone"><code>SchaakeShuffle$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SchaakeShuffle-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new ShaakeShuffle object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffle$new(Y0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[vector] The reference vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'ShaaleShuffle' object.
</p>


<hr>
<a id="method-SchaakeShuffle-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the model
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffle$fit(Y0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[vector] The reference vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-SchaakeShuffle-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Fit the model
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffle$predict(X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X0</code></dt><dd><p>[vector] The vector to apply shuffle</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Z0 [vector] data shuffled
</p>


<hr>
<a id="method-SchaakeShuffle-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffle$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>X0 = matrix( stats::runif(20) , ncol = 2 )
Y0 = matrix( stats::runif(20) , ncol = 2 )
ss = SchaakeShuffle$new()
ss$fit(Y0)
Z0 = ss$predict(X0)

</code></pre>

<hr>
<h2 id='SchaakeShuffleMultiRef'>ShaakeShuffleMultiRef class</h2><span id='topic+SchaakeShuffleMultiRef'></span>

<h3>Description</h3>

<p>Match the rank structure of X with them of Y by reordering X.
</p>


<h3>Details</h3>

<p>Can keep multiple features to keep the structure of X.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>cond_cols</code></dt><dd><p>[vector of integer] The conditioning columns</p>
</dd>
<dt><code>lag_search</code></dt><dd><p>[integer] Number of lag to take into account</p>
</dd>
<dt><code>lag_keep</code></dt><dd><p>[integer] Number of lag to keep</p>
</dd>
<dt><code>Y0</code></dt><dd><p>[matrix] Reference data</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SchaakeShuffleMultiRef-new"><code>SchaakeShuffleMultiRef$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SchaakeShuffleMultiRef-fit"><code>SchaakeShuffleMultiRef$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-SchaakeShuffleMultiRef-predict"><code>SchaakeShuffleMultiRef$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-SchaakeShuffleMultiRef-clone"><code>SchaakeShuffleMultiRef$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SchaakeShuffleMultiRef-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new ShaakeShuffleMultiRef object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffleMultiRef$new(lag_search, lag_keep, cond_cols = base::c(1))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lag_search</code></dt><dd><p>[integer] Number of lag to take into account</p>
</dd>
<dt><code>lag_keep</code></dt><dd><p>[integer] Number of lag to keep</p>
</dd>
<dt><code>cond_cols</code></dt><dd><p>[vector of integer] The conditioning columns</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'ShaaleShuffleMultiRef' object.
</p>


<hr>
<a id="method-SchaakeShuffleMultiRef-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the model
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffleMultiRef$fit(Y0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[vector] The reference vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-SchaakeShuffleMultiRef-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Fit the model
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffleMultiRef$predict(X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X0</code></dt><dd><p>[vector] The vector to apply shuffle</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Z0 [vector] data shuffled
</p>


<hr>
<a id="method-SchaakeShuffleMultiRef-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffleMultiRef$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>X0 = matrix( stats::runif(50) , ncol = 2 )
Y0 = matrix( stats::runif(50) , ncol = 2 )
ssmr = SchaakeShuffleMultiRef$new( lag_search = 3 , lag_keep = 1 , cond_cols = 1 )
ssmr$fit(Y0)
Z0 = ssmr$predict(X0)

</code></pre>

<hr>
<h2 id='SchaakeShuffleRef'>ShaakeShuffleRef class</h2><span id='topic+SchaakeShuffleRef'></span>

<h3>Description</h3>

<p>Match the rank structure of X with them of Y by reordering X.
</p>


<h3>Details</h3>

<p>Fix one features to keep the structure of X.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SchaakeShuffle">SBCK::SchaakeShuffle</a></code> -&gt; <code>SchaakeShuffleRef</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ref</code></dt><dd><p>[integer] Reference</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SchaakeShuffleRef-new"><code>SchaakeShuffleRef$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SchaakeShuffleRef-fit"><code>SchaakeShuffleRef$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-SchaakeShuffleRef-predict"><code>SchaakeShuffleRef$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-SchaakeShuffleRef-clone"><code>SchaakeShuffleRef$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SchaakeShuffleRef-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new ShaakeShuffleRef object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffleRef$new(ref, Y0 = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ref</code></dt><dd><p>[integer] Reference</p>
</dd>
<dt><code>Y0</code></dt><dd><p>[vector] The reference vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'ShaaleShuffleRef' object.
</p>


<hr>
<a id="method-SchaakeShuffleRef-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the model
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffleRef$fit(Y0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[vector] The reference vector</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-SchaakeShuffleRef-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Fit the model
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffleRef$predict(X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X0</code></dt><dd><p>[vector] The vector to apply shuffle</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Z0 [vector] data shuffled
</p>


<hr>
<a id="method-SchaakeShuffleRef-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SchaakeShuffleRef$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>X0 = matrix( stats::runif(20) , ncol = 2 )
Y0 = matrix( stats::runif(20) , ncol = 2 )
ss = SchaakeShuffleRef$new( ref = 1 )
ss$fit(Y0)
Z0 = ss$predict(X0)

</code></pre>

<hr>
<h2 id='Shift'>Shift</h2><span id='topic+Shift'></span>

<h3>Description</h3>

<p>Class to shift a dataset.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>Transform autocorrelations to intervariables correlations
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code>
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(lag,method,ref,)</code></dt><dd><p>This method is used to create object of this class with <code>Shift</code></p>
</dd>
<dt><code>transform(X)</code></dt><dd><p>Method to shift a dataset</p>
</dd>
<dt><code>inverse(Xs)</code></dt><dd><p>Method to inverse the shift of a dataset</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>lag</code></dt><dd><p>[integer] max lag for autocorrelations</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>method</code></dt><dd><p>[character] If inverse is by row or column.</p>
</dd>
<dt><code>ref</code></dt><dd><p>[integer] reference column/row to inverse shift.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Shift-new"><code>Shift$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Shift-transform"><code>Shift$transform()</code></a>
</p>
</li>
<li> <p><a href="#method-Shift-inverse"><code>Shift$inverse()</code></a>
</p>
</li>
<li> <p><a href="#method-Shift-clone"><code>Shift$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Shift-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Shift object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Shift$new(lag, method = "row", ref = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lag</code></dt><dd><p>[integer] max lag for autocorrelations</p>
</dd>
<dt><code>method</code></dt><dd><p>[character] If &quot;row&quot; inverse by row, else by column</p>
</dd>
<dt><code>ref</code></dt><dd><p>[integer] starting point for inverse transform</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'Shift' object.
</p>


<hr>
<a id="method-Shift-transform"></a>



<h4>Method <code>transform()</code></h4>

<p>Shift the data
</p>


<h5>Usage</h5>

<div class="r"><pre>Shift$transform(X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>[matrix: n_samples * n_features] Data to shift</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix] Matrix shifted
</p>


<hr>
<a id="method-Shift-inverse"></a>



<h4>Method <code>inverse()</code></h4>

<p>Inverse the shift of the data
</p>


<h5>Usage</h5>

<div class="r"><pre>Shift$inverse(Xs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xs</code></dt><dd><p>[matrix] Data Shifted</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix] Matrix un shifted
</p>


<hr>
<a id="method-Shift-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Shift$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>X = base::t(matrix( 1:20 , nrow = 2 , ncol = 10 ))

sh = Shift$new(1)
Xs = sh$transform(X)
Xi = sh$inverse(Xs)

</code></pre>

<hr>
<h2 id='SlopeStoppingCriteria'>Slope stopping criteria</h2><span id='topic+SlopeStoppingCriteria'></span>

<h3>Description</h3>

<p>Class which send a stop signal when a time series stay constant.
</p>


<h3>Details</h3>

<p>Test the slope.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>minit</code></dt><dd><p>[integer] Minimal number of iterations. At least 3.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>[integer] Maximal number of iterations.</p>
</dd>
<dt><code>nit</code></dt><dd><p>[integer] Number of iterations.</p>
</dd>
<dt><code>tol</code></dt><dd><p>[float] Tolerance to control if slope is close to zero</p>
</dd>
<dt><code>stop</code></dt><dd><p>[bool] If we stop</p>
</dd>
<dt><code>criteria</code></dt><dd><p>[vector] State of criteria</p>
</dd>
<dt><code>slope</code></dt><dd><p>[vector] Values of slope</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SlopeStoppingCriteria-new"><code>SlopeStoppingCriteria$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SlopeStoppingCriteria-reset"><code>SlopeStoppingCriteria$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-SlopeStoppingCriteria-append"><code>SlopeStoppingCriteria$append()</code></a>
</p>
</li>
<li> <p><a href="#method-SlopeStoppingCriteria-clone"><code>SlopeStoppingCriteria$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SlopeStoppingCriteria-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new SlopeStoppingCriteria object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SlopeStoppingCriteria$new(minit, maxit, tol)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>minit</code></dt><dd><p>[integer] Minimal number of iterations. At least 3.</p>
</dd>
<dt><code>maxit</code></dt><dd><p>[integer] Maximal number of iterations.</p>
</dd>
<dt><code>tol</code></dt><dd><p>[float] Tolerance to control if slope is close to zero</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'SlopeStoppingCriteria' object.
</p>


<hr>
<a id="method-SlopeStoppingCriteria-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the class
</p>


<h5>Usage</h5>

<div class="r"><pre>SlopeStoppingCriteria$reset()</pre></div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-SlopeStoppingCriteria-append"></a>



<h4>Method <code>append()</code></h4>

<p>Add a new value
</p>


<h5>Usage</h5>

<div class="r"><pre>SlopeStoppingCriteria$append(value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>value</code></dt><dd><p>[double] New metrics</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-SlopeStoppingCriteria-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SlopeStoppingCriteria$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>stop_slope = SlopeStoppingCriteria$new( 20 , 500 , 1e-3 )
x = 0
while(!stop_slope$stop)
{
	stop_slope$append(base::exp(-x))
	x = x + 0.1
}
print(stop_slope$nit)
</code></pre>

<hr>
<h2 id='SparseHist'>SparseHist</h2><span id='topic+SparseHist'></span>

<h3>Description</h3>

<p>Return the Rcpp Class SparseHistBase initialized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseHist(X, bin_width = NULL, bin_origin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseHist_+3A_x">X</code></td>
<td>
<p>[matrix] Dataset to find the SparseHist</p>
</td></tr>
<tr><td><code id="SparseHist_+3A_bin_width">bin_width</code></td>
<td>
<p>[vector] Width of a bin for each dimension</p>
</td></tr>
<tr><td><code id="SparseHist_+3A_bin_origin">bin_origin</code></td>
<td>
<p>[vector] Coordinate of the &quot;0&quot; bin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[SparseHist] SparseHist class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Data
X = base::matrix( stats::rnorm( n = 10000 ) , nrow = 5000 , ncol = 2 )
muX = SparseHist(X)

print(muX$p) ## Vector of probabilities
print(muX$c) ## Matrix of coordinates of each bins
print(muX$argwhere(X)) ## Index of bins of dataset X

</code></pre>

<hr>
<h2 id='TSMBC'>TSMBC (Time Shifted Multivariate Bias Correction)</h2><span id='topic+TSMBC'></span>

<h3>Description</h3>

<p>Perform a bias correction of auto-correlation
</p>


<h3>Details</h3>

<p>Correct auto-correlation with a shift approach.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>shift</code></dt><dd><p>[Shift class] Shift class to shift data.</p>
</dd>
<dt><code>bc_method</code></dt><dd><p>[SBCK::BC_method] Underlying bias correction method.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>method</code></dt><dd><p>[character] If inverse is by row or column, see class Shift</p>
</dd>
<dt><code>ref</code></dt><dd><p>[integer] reference column/row to inverse shift, see class</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TSMBC-new"><code>TSMBC$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TSMBC-fit"><code>TSMBC$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-TSMBC-predict"><code>TSMBC$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-TSMBC-clone"><code>TSMBC$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-TSMBC-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new TSMBC object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TSMBC$new(lag, bc_method = OTC, method = "row", ref = "middle", ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lag</code></dt><dd><p>[integer] max lag of autocorrelation</p>
</dd>
<dt><code>bc_method</code></dt><dd><p>[SBCK::BC_METHOD] bias correction method to use after 
shift of data, default is OTC</p>
</dd>
<dt><code>method</code></dt><dd><p>[character] If inverse is by row or column, see class Shift</p>
</dd>
<dt><code>ref</code></dt><dd><p>[integer] reference column/row to inverse shift, see class
Shift. Default is 0.5 * (lag+1)</p>
</dd>
<dt><code>...</code></dt><dd><p>[] All others arguments are passed to bc_method</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new 'TSMBC' object.
</p>


<hr>
<a id="method-TSMBC-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the bias correction method
</p>


<h5>Usage</h5>

<div class="r"><pre>TSMBC$fit(Y0, X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Y0</code></dt><dd><p>[matrix: n_samples * n_features] Observations in calibration</p>
</dd>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>NULL
</p>


<hr>
<a id="method-TSMBC-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict the correction
</p>


<h5>Usage</h5>

<div class="r"><pre>TSMBC$predict(X0)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X0</code></dt><dd><p>[matrix: n_samples * n_features or NULL] Model in calibration</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>[matrix] Return the corrections of X0
</p>


<hr>
<a id="method-TSMBC-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TSMBC$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Robin, Y. and Vrac, M.: Is time a variable like the others in
multivariate statistical downscaling and bias correction?, Earth
Syst. Dynam. Discuss. [preprint],
https://doi.org/10.5194/esd-2021-12, in review, 2021.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## arima model parameters
modelX0 = list( ar = base::c(  0.6 , 0.2 , -0.1 ) )
modelY0 = list( ar = base::c( -0.3 , 0.4 , -0.2 ) )

## arima random generator
rand.genX0 = function(n){ return(stats::rnorm( n , mean = 0.2 , sd = 1   )) }
rand.genY0 = function(n){ return(stats::rnorm( n , mean = 0   , sd = 0.7 )) }

## Generate two AR processes
X0 = stats::arima.sim( n = 1000 , model = modelX0 , rand.gen = rand.genX0 )
Y0 = stats::arima.sim( n = 1000 , model = modelY0 , rand.gen = rand.genY0 )
X0 = as.vector( X0 )
Y0 = as.vector( Y0 + 5 )

## And correct it with 30 lags
tsbc = SBCK::TSMBC$new( 30 )
tsbc$fit( Y0 , X0 )
Z0 = tsbc$predict(X0)

</code></pre>

<hr>
<h2 id='wasserstein'>wasserstein distance</h2><span id='topic+wasserstein'></span>

<h3>Description</h3>

<p>Compute wasserstein distance between two dataset or SparseHist X and Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wasserstein(X, Y, p = 2, ot = SBCK::OTNetworkSimplex$new())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wasserstein_+3A_x">X</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_y">Y</code></td>
<td>
<p>[matrix or SparseHist] If matrix, dim = ( nrow = n_samples, ncol =
n_features)</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_p">p</code></td>
<td>
<p>[float]
Power of the metric (default = 2)</p>
</td></tr>
<tr><td><code id="wasserstein_+3A_ot">ot</code></td>
<td>
<p>[Optimal transport solver]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>[float] value of distance
</p>


<h3>References</h3>

<p>Wasserstein, L. N. (1969). Markov processes over denumerable
products of spaces describing large systems of automata. Problems
of Information Transmission, 5(3), 47-52.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = base::cbind( stats::rnorm(2000) , stats::rnorm(2000)  )
Y = base::cbind( stats::rnorm(2000,mean=10)  , stats::rnorm(2000) )
bw = base::c(0.1,0.1)
muX = SBCK::SparseHist( X , bw )
muY = SBCK::SparseHist( Y , bw )

## The four are equals
w2 = SBCK::wasserstein(X,Y)
w2 = SBCK::wasserstein(muX,Y)
w2 = SBCK::wasserstein(X,muY)
w2 = SBCK::wasserstein(muX,muY)

</code></pre>

<hr>
<h2 id='where'>where function</h2><span id='topic+where'></span>

<h3>Description</h3>

<p>This function return a vector / matrix / array of the same shape than
cond / x / y such that if(cond) values are x, and else y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where(cond,x,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where_+3A_cond">cond</code></td>
<td>
<p>[vector/matrix/array] Boolean values</p>
</td></tr>
<tr><td><code id="where_+3A_x">x</code></td>
<td>
<p>[vector/matrix/array] Values if cond is TRUE</p>
</td></tr>
<tr><td><code id="where_+3A_y">y</code></td>
<td>
<p>[vector/matrix/array] Values if cond is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>z [vector/matrix/array].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = base::seq( -2 , 2 , length = 100 )
y = where( x &lt; 1 , x , exp(x) ) ## y = x if x &lt; 1, else exp(x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
