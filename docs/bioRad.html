<!DOCTYPE html><html><head><title>Help for package bioRad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bioRad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bioRad-package'><p>bioRad: Biological Analysis and Visualization of Weather Radar Data</p></a></li>
<li><a href='#+5B.ppi'><p>Subset a plan position indicator (<code>ppi</code>)</p></a></li>
<li><a href='#add_expected_eta_to_scan'><p>Adds expected eta to a scan</p></a></li>
<li><a href='#apply_mistnet'><p>Apply MistNet segmentation to a polar volume</p></a></li>
<li><a href='#as.data.frame.vp'><p>Convert a vertical profile (<code>vp</code>) or time series of vertical profiles</p>
(<code>vpts</code>) to a data frame</a></li>
<li><a href='#as.vpts'><p>Convert a dataframe into a vpts object</p></a></li>
<li><a href='#attribute_table'><p>Extract a volume coverage pattern table with all attributes</p></a></li>
<li><a href='#beam_distance'><p>Calculate radar beam distance</p></a></li>
<li><a href='#beam_height'><p>Calculate radar beam height</p></a></li>
<li><a href='#beam_profile'><p>Calculate vertical radiation profile</p></a></li>
<li><a href='#beam_profile_overlap'><p>Calculate overlap between a vertical profile ('vp') and the vertical</p>
radiation profile emitted by the radar</a></li>
<li><a href='#beam_range'><p>Calculate radar beam range</p></a></li>
<li><a href='#beam_width'><p>Calculate radar beam width</p></a></li>
<li><a href='#bind_into_vpts'><p>Bind vertical profiles (<code>vp</code>) into time series (<code>vpts</code>)</p></a></li>
<li><a href='#bioRad-deprecated'><p>Deprecated bioRad functions and data</p></a></li>
<li><a href='#c.vp'><p>Concatenate vertical profiles (<code>vp</code>) into a list of vertical profiles</p></a></li>
<li><a href='#calculate_param'><p>Calculate a new scan parameter</p></a></li>
<li><a href='#calculate_vp'><p>Calculate a vertical profile (<code>vp</code>) from a polar volume (<code>pvol</code>) file</p></a></li>
<li><a href='#check_date_format'><p>Check if character date is in specific format</p></a></li>
<li><a href='#check_night'><p>Check if it is night at a given time and place</p></a></li>
<li><a href='#check_radar_codes'><p>Check if radar codes are exactly 5 characters</p></a></li>
<li><a href='#composite_ppi'><p>Create a composite of multiple plan position indicators (<code>ppi</code>)</p></a></li>
<li><a href='#convert_legacy'><p>Convert legacy bioRad objects</p></a></li>
<li><a href='#dbz_to_eta'><p>Convert reflectivity factor (dBZ) to reflectivity (eta)</p></a></li>
<li><a href='#download_pvolfiles'><p>Download polar volume (<code>pvol</code>) files from the NEXRAD archive</p></a></li>
<li><a href='#download_vpfiles'><p>Download vertical profile (<code>vp</code>) files from the ENRAM data repository</p></a></li>
<li><a href='#doy_noy'><p>Look up day of year (doy) or night of year (noy)</p></a></li>
<li><a href='#eta_to_dbz'><p>Convert reflectivity (eta) to reflectivity factor (dBZ)</p></a></li>
<li><a href='#example_scan'><p>Scan (<code>scan</code>) example</p></a></li>
<li><a href='#example_vp'><p>Vertical profile (<code>vp</code>) example</p></a></li>
<li><a href='#example_vpts'><p>Time series of vertical profiles (<code>vpts</code>) example</p></a></li>
<li><a href='#extract_string'><p>extract strings from a vector using regex, analog to stringr::str_extract</p></a></li>
<li><a href='#filter_vpts'><p>Filter a time series of vertical profiles ('vpts') by a start and end time.</p>
Use argument night = TRUE to select only time stamps between sunset and sunrise,
or night = FALSE to select daytime (sunrise to sunset). Selection for night and day uses
<code>check_night()</code>.</a></li>
<li><a href='#gaussian_beam_profile'><p>Gaussian beam profile as a function of height</p></a></li>
<li><a href='#get_elevation_angles'><p>Get elevation angles of a polar volume (<code>pvol</code>), scan (<code>scan</code>) or parameter</p>
(<code>param</code>)</a></li>
<li><a href='#get_iris_raw_task'><p>Check the <code>task</code> type of an IRIS RAW file</p></a></li>
<li><a href='#get_odim_object_type'><p>Check the <code>data</code> type of an ODIM HDF5 file</p></a></li>
<li><a href='#get_param'><p>Get a parameter (<code>param</code>) from a scan (<code>scan</code>)</p></a></li>
<li><a href='#get_quantity'><p>Get a quantity from a vertical profile (<code>vp</code>) or time series of vertical</p>
profiles (<code>vpts</code>)</a></li>
<li><a href='#get_scan'><p>Get a scan (<code>scan</code>) from a polar volume (<code>pvol</code>)</p></a></li>
<li><a href='#integrate_profile'><p>Vertically integrate profiles (<code>vp</code> or <code>vpts</code>) into an</p>
integrated profile (<code>vpi</code>)</a></li>
<li><a href='#integrate_to_ppi'><p>Calculate a plan position indicator (<code>ppi</code>) of vertically integrated density</p>
adjusted for range effects</a></li>
<li><a href='#is.nan.data.frame'><p>Identify <code>NaN</code> in a dataframe</p></a></li>
<li><a href='#is.pvolfile'><p>Check if a file is a polar volume (<code>pvol</code>)</p></a></li>
<li><a href='#is.vpfile'><p>Check if a file is a vertical profile (<code>vp</code>)</p></a></li>
<li><a href='#list_vpts_aloft'><p>List aloft urls for time series of vertical profiles (<code>vpts</code>) of radar</p>
stations</a></li>
<li><a href='#map'><p>Map a plan position indicator (<code>ppi</code>) on a map</p></a></li>
<li><a href='#match_filenames'><p>Match a set of regular expressions to a list of files</p></a></li>
<li><a href='#Math.scan'><p>Mathematical and arithmetic operations on param's, scan's and pvol's</p></a></li>
<li><a href='#nexrad_to_odim'><p>Convert a NEXRAD polar volume file to an ODIM polar volume file</p></a></li>
<li><a href='#nyquist_velocity'><p>Calculate Nyquist velocity for a given pulse repetition frequency (PRF)</p></a></li>
<li><a href='#plot.ppi'><p>Plot a plan position indicator (<code>ppi</code>)</p></a></li>
<li><a href='#plot.scan'><p>Plot a scan (<code>scan</code>) in polar coordinates</p></a></li>
<li><a href='#plot.vp'><p>Plot a vertical profile (<code>vp</code>)</p></a></li>
<li><a href='#plot.vpi'><p>Plot an integrated profile (<code>vpi</code>)</p></a></li>
<li><a href='#plot.vpts'><p>Plot a time series of vertical profiles (<code>vpts</code>)</p></a></li>
<li><a href='#proj_to_wgs'><p>A wrapper for <code>spTransform()</code>.</p>
Converts projected coordinates to geographic (WGS84) coordinates.</a></li>
<li><a href='#project_as_ppi'><p>Project a scan (<code>scan</code>) or parameter (<code>param</code>) to a plan</p>
position indicator (<code>ppi</code>)</a></li>
<li><a href='#rcs'><p>Get radar cross section</p></a></li>
<li><a href='#rcs+26lt+3B-'><p>Set radar cross section</p></a></li>
<li><a href='#read_cajun'><p>Read a vertical profile (<code>vp</code>) from UMASS Cajun text file</p></a></li>
<li><a href='#read_pvolfile'><p>Read a polar volume (<code>pvol</code>) from file</p></a></li>
<li><a href='#read_stdout'><p>Read a time series of vertical profiles (<code>vpts</code>) from file</p></a></li>
<li><a href='#read_vp'><p>Read a vertical profile (<code>vp</code>) from file</p></a></li>
<li><a href='#read_vpfiles'><p>Read a vertical profile (<code>vp</code>) or a list of vertical profiles</p>
(<code>vp</code>) from files</a></li>
<li><a href='#read_vpts'><p>Read time series of vertical profiles (<code>vpts</code>) from file(s)</p></a></li>
<li><a href='#regularize_vpts'><p>Regularize a time series of vertical profiles (<code>vpts</code>) on a</p>
regular time grid</a></li>
<li><a href='#scan_to_raster'><p>convert a polar scan into a raster</p></a></li>
<li><a href='#scan_to_spatial'><p>convert a polar scan into a spatial object.</p></a></li>
<li><a href='#sd_vvp_threshold'><p>Get threshold of the radial velocity standard deviation</p></a></li>
<li><a href='#sd_vvp_threshold+26lt+3B-'><p>Set threshold of the radial velocity standard deviation</p></a></li>
<li><a href='#select_vpfiles'><p>Select vertical profile (<code>vp</code>) files from computer</p></a></li>
<li><a href='#skip_if_no_mistnet'><p>Skip test if no mistnet</p></a></li>
<li><a href='#skip_if_no_vol2birdR'><p>Skip test if vol2birdR not installed</p></a></li>
<li><a href='#summary.param'><p>Inspect a parameter (<code>param</code>)</p></a></li>
<li><a href='#summary.ppi'><p>Inspect a plan position indicator (<code>ppi</code>)</p></a></li>
<li><a href='#summary.pvol'><p>Inspect a polar volume (<code>pvol</code>)</p></a></li>
<li><a href='#summary.scan'><p>Inspect a scan (<code>scan</code>)</p></a></li>
<li><a href='#summary.vp'><p>Inspect a vertical profile (<code>vp</code>)</p></a></li>
<li><a href='#summary.vpi'><p>Inspect an integrated profile (<code>vpi</code>)</p></a></li>
<li><a href='#summary.vpts'><p>Inspect a time series of vertical profiles (<code>vpts</code>)</p></a></li>
<li><a href='#sunrise_sunset'><p>Calculate sunrise or sunset for a time and place</p></a></li>
<li><a href='#vplist_to_vpts'><p>Bind vertical profiles (<code>vp</code>) into time series (<code>vpts</code>)</p></a></li>
<li><a href='#wgs_to_proj'><p>A wrapper for <code>spTransform()</code>.</p>
Converts geographic (WGS84) coordinates to a specified projection</a></li>
<li><a href='#write_pvolfile'><p>Write a polar volume (<code>pvol</code>) object to ODIM HDF5 file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Biological Analysis and Visualization of Weather Radar Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Extract, visualize and summarize aerial movements of birds and
    insects from weather radar data. See Dokter, A. M. et al. (2018) 
    "bioRad: biological analysis and visualization of weather radar data" &lt;<a href="https://doi.org/10.1111%2Fecog.04028">doi:10.1111/ecog.04028</a>&gt;
    for a software paper describing package and methodologies.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/adokter/bioRad/">https://github.com/adokter/bioRad/</a>,
<a href="https://adriaandokter.com/bioRad/">https://adriaandokter.com/bioRad/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/adokter/bioRad/issues">https://github.com/adokter/bioRad/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, curl, dplyr (&ge; 1.1.0), fields, frictionless,
ggplot2, glue, graphics, jsonlite, lubridate, lutz, methods,
raster, readr, rhdf5, rlang, sp, stats, suntools, tidyr, utils,
viridis, viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>aws.s3, ggspatial, knitr, prettymapr, rmarkdown, rosm, sf,
testthat (&ge; 3.0.0), tidyselect, vdiffr, vol2birdR</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-20 02:23:41 UTC; amd427</td>
</tr>
<tr>
<td>Author:</td>
<td>Adriaan M. Dokter <a href="https://orcid.org/0000-0001-6573-066X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Peter Desmet <a href="https://orcid.org/0000-0002-8442-8025"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bart Kranstauber <a href="https://orcid.org/0000-0001-8303-780X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Cecilia Nilsson <a href="https://orcid.org/0000-0001-8957-4411"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Stijn Van Hoey <a href="https://orcid.org/0000-0001-6413-3185"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bart Hoekstra <a href="https://orcid.org/0000-0002-7085-3805"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Pieter Huybrechts <a href="https://orcid.org/0000-0002-6658-6062"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Hidde Leijnse <a href="https://orcid.org/0000-0001-7835-4480"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Nicolas Noé <a href="https://orcid.org/0000-0002-9503-4750"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Raphaël Nussbaumer
    <a href="https://orcid.org/0000-0002-8185-1020"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Jurriaan Spaaks [ctb],
  Alexander Tedeschi
    <a href="https://orcid.org/0000-0003-0772-6931"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Lourens Veen [ctb],
  Liesbeth Verlinden
    <a href="https://orcid.org/0000-0003-1744-9325"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adriaan M. Dokter &lt;amd427@cornell.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-20 11:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='bioRad-package'>bioRad: Biological Analysis and Visualization of Weather Radar Data</h2><span id='topic+bioRad'></span><span id='topic+bioRad-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Extract, visualize and summarize aerial movements of birds and insects from weather radar data. See Dokter, A. M. et al. (2018) &quot;bioRad: biological analysis and visualization of weather radar data&quot; <a href="https://doi.org/10.1111/ecog.04028">doi:10.1111/ecog.04028</a> for a software paper describing package and methodologies.
</p>


<h3>Details</h3>

<p>To get started, see:
</p>

<ul>
<li><p> Dokter et al. (2019) <a href="https://doi.org/10.1111/ecog.04028">doi:10.1111/ecog.04028</a>: a paper describing the
package.
</p>
</li>
<li> <p><a href="https://adriaandokter.com/bioRad/articles/bioRad.html">bioRad vignette</a>:
an introduction to bioRad's main functionalities.
</p>
</li>
<li> <p><a href="https://adriaandokter.com/bioRad/reference/index.html">Function reference</a>
: an overview of all bioRad functions.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Adriaan M. Dokter <a href="mailto:amd427@cornell.edu">amd427@cornell.edu</a> (<a href="https://orcid.org/0000-0001-6573-066X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Peter Desmet <a href="mailto:peter.desmet@inbo.be">peter.desmet@inbo.be</a> (<a href="https://orcid.org/0000-0002-8442-8025">ORCID</a>)
</p>
</li>
<li><p> Bart Kranstauber <a href="mailto:b.kranstauber@uva.nl">b.kranstauber@uva.nl</a> (<a href="https://orcid.org/0000-0001-8303-780X">ORCID</a>)
</p>
</li>
<li><p> Cecilia Nilsson <a href="mailto:cecilia.nilsson709@gmail.com">cecilia.nilsson709@gmail.com</a> (<a href="https://orcid.org/0000-0001-8957-4411">ORCID</a>)
</p>
</li>
<li><p> Stijn Van Hoey <a href="mailto:stijnvanhoey@gmail.com">stijnvanhoey@gmail.com</a> (<a href="https://orcid.org/0000-0001-6413-3185">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Bart Hoekstra <a href="mailto:b.d.hoekstra@uva.nl">b.d.hoekstra@uva.nl</a> (<a href="https://orcid.org/0000-0002-7085-3805">ORCID</a>) [contributor]
</p>
</li>
<li><p> Pieter Huybrechts <a href="mailto:pieter.huybrechts@inbo.be">pieter.huybrechts@inbo.be</a> (<a href="https://orcid.org/0000-0002-6658-6062">ORCID</a>) [contributor]
</p>
</li>
<li><p> Hidde Leijnse <a href="mailto:hidde.leijnse@knmi.nl">hidde.leijnse@knmi.nl</a> (<a href="https://orcid.org/0000-0001-7835-4480">ORCID</a>) [contributor]
</p>
</li>
<li><p> Nicolas Noé <a href="mailto:nicolas@niconoe.eu">nicolas@niconoe.eu</a> (<a href="https://orcid.org/0000-0002-9503-4750">ORCID</a>) [contributor]
</p>
</li>
<li><p> Raphaël Nussbaumer <a href="mailto:rafnuss@gmail.com">rafnuss@gmail.com</a> (<a href="https://orcid.org/0000-0002-8185-1020">ORCID</a>) [contributor]
</p>
</li>
<li><p> Jurriaan Spaaks <a href="mailto:j.spaaks@esciencecenter.nl">j.spaaks@esciencecenter.nl</a> [contributor]
</p>
</li>
<li><p> Alexander Tedeschi <a href="mailto:alexander.tedeschi@cornell.edu">alexander.tedeschi@cornell.edu</a> (<a href="https://orcid.org/0000-0003-0772-6931">ORCID</a>) [contributor]
</p>
</li>
<li><p> Lourens Veen <a href="mailto:l.veen@esciencecenter.nl">l.veen@esciencecenter.nl</a> [contributor]
</p>
</li>
<li><p> Liesbeth Verlinden <a href="mailto:l.verlinden@uva.nl">l.verlinden@uva.nl</a> (<a href="https://orcid.org/0000-0003-1744-9325">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/adokter/bioRad/">https://github.com/adokter/bioRad/</a>
</p>
</li>
<li> <p><a href="https://adriaandokter.com/bioRad/">https://adriaandokter.com/bioRad/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/adokter/bioRad/issues">https://github.com/adokter/bioRad/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.ppi'>Subset a plan position indicator (<code>ppi</code>)</h2><span id='topic++5B.ppi'></span>

<h3>Description</h3>

<p>Select parameters (<code>param</code>) or derived quantities by index from a plan
position indicator (<code>ppi</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppi'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.ppi_+3A_x">x</code></td>
<td>
<p>A <code>ppi</code> object.</p>
</td></tr>
<tr><td><code id="+2B5B.ppi_+3A_i">i</code></td>
<td>
<p>Integer. Index/indices specifying which parameters (<code>param</code>) or
derived quantities to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ppi</code> object containing a subset of parameters (<code>param</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Project a scan as a ppi
ppi &lt;- project_as_ppi(example_scan)

# This ppi contains 5 parameters (DBZH VRADH ZDR RHOHV PHIDP)
ppi

# Subset ppi to one containing only the first parameter (DBZH)
ppi[1]

# Subset ppi to one containing the first three parameters (DBZH, VRADH, ZDR)
ppi[1:3]

# Subset ppi to one without the first 2 parameters (ZDR RHOHV PHIDP)
ppi[-1:-2]
</code></pre>

<hr>
<h2 id='add_expected_eta_to_scan'>Adds expected eta to a scan</h2><span id='topic+add_expected_eta_to_scan'></span>

<h3>Description</h3>

<p>Adds expected eta to a scan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_expected_eta_to_scan(
  scan,
  vp,
  quantity = "dens",
  param = "DBZH",
  lat,
  lon,
  antenna,
  beam_angle = 1,
  k = 4/3,
  re = 6378,
  rp = 6357
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_expected_eta_to_scan_+3A_scan">scan</code></td>
<td>
<p>a scan (sweep) of class scan</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_vp">vp</code></td>
<td>
<p>A <code>vp</code> object</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_quantity">quantity</code></td>
<td>
<p>Character. Profile quantity on which to base range
corrections, either <code>eta</code> or <code>dens</code>.</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_param">param</code></td>
<td>
<p>reflectivity Character. Scan parameter on which to base range
corrections. Typically the same parameter from which animal densities are
estimated in <code>vp</code>. Either <code>DBZH</code>, <code>DBZV</code>, <code>DBZ</code>, <code>TH</code>, or <code>TV</code>.</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_lat">lat</code></td>
<td>
<p>Latitude of the radar, in degrees. If missing taken from <code>pvol</code>.</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_lon">lon</code></td>
<td>
<p>Latitude of the radar, in degrees. If missing taken from <code>pvol</code>.</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_antenna">antenna</code></td>
<td>
<p>Numeric. Radar antenna height, in m. Default to antenna height
in <code>vp</code>.</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_beam_angle">beam_angle</code></td>
<td>
<p>Numeric. Beam opening angle in degrees, typically the
angle between the half-power (-3 dB) points of the main lobe.</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="add_expected_eta_to_scan_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scan</code> object.
</p>

<hr>
<h2 id='apply_mistnet'>Apply MistNet segmentation to a polar volume</h2><span id='topic+apply_mistnet'></span>

<h3>Description</h3>

<p>Applies the MistNet segmentation model to a polar volume file on disk and
loads the resultant segmentation as a polar volume (<code>pvol</code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_mistnet(
  file,
  pvolfile_out,
  verbose = FALSE,
  mount = dirname(file),
  load = TRUE,
  mistnet_elevations = c(0.5, 1.5, 2.5, 3.5, 4.5),
  local_install,
  local_mistnet
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_mistnet_+3A_file">file</code></td>
<td>
<p>Character. Path to a polar volume (<code>pvol</code>) file.</p>
</td></tr>
<tr><td><code id="apply_mistnet_+3A_pvolfile_out">pvolfile_out</code></td>
<td>
<p>Character. (optional) File name. When provided, writes a
polar volume (<code>pvol</code>) file to disk that includes the Mistnet segmentation
results.</p>
</td></tr>
<tr><td><code id="apply_mistnet_+3A_verbose">verbose</code></td>
<td>
<p>Logical. When <code>TRUE</code>, vol2bird <code>stdout</code> is piped to the R
console.</p>
</td></tr>
<tr><td><code id="apply_mistnet_+3A_mount">mount</code></td>
<td>
<p>Character. Directory path of the mount point for the Docker
container (deprecated).</p>
</td></tr>
<tr><td><code id="apply_mistnet_+3A_load">load</code></td>
<td>
<p>Logical. When <code>TRUE</code>, returns a <code>pvol</code> object.</p>
</td></tr>
<tr><td><code id="apply_mistnet_+3A_mistnet_elevations">mistnet_elevations</code></td>
<td>
<p>Numeric vector of length 5. Elevation angles to
feed to the MistNet segmentation model, which expects exactly 5 elevation
scans at 0.5, 1.5, 2.5, 3.5 and 4.5 degrees. Specifying different elevation
angles may compromise segmentation results.</p>
</td></tr>
<tr><td><code id="apply_mistnet_+3A_local_install">local_install</code></td>
<td>
<p>Character. Path to local vol2bird installation (e.g.
<code>your/vol2bird_install_directory/vol2bird/bin/vol2bird</code>) to use instead of
the Docker container.</p>
</td></tr>
<tr><td><code id="apply_mistnet_+3A_local_mistnet">local_mistnet</code></td>
<td>
<p>Character. Path to local MistNet segmentation model in
PyTorch format (e.g. <code style="white-space: pre;">&#8288;/your/path/mistnet_nexrad.pt&#8288;</code>) to use instead of the
Docker container.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MistNet (Lin et al. 2019) is a deep convolutional neural network that has
been trained using labels derived from S-band dual-polarization data across
the US NEXRAD network. Its purpose is to screen out areas of precipitation in
weather radar data, primarily legacy data for which dual-polarization data
are not available. Because the network has been trained on S-band data, it
may not perform as well on C-band.
</p>
<p>MistNet requires three single-polarization parameters as input: reflectivity
(<code>DBZH</code>), radial velocity (<code>VRADH</code>), and spectrum width (<code>WRADH</code>), at 5
specific elevation angles (0.5, 1.5, 2.5, 3.5 and 4.5 degrees). Based on
these data it can estimate a segmentation mask that identifies pixels with
weather that should be removed when interested in biological data only.
</p>
<p>MistNet will calculate three class probabilities (from 0 to 1, with 1
corresponding to a 100% probability) as additional scan parameters to the
polar volume:
</p>

<ul>
<li> <p><code>BACKGROUND</code>: Class probability that no signal was detected above the noise
level of the radar.
</p>
</li>
<li> <p><code>WEATHER</code>: Class probability that weather was detected.
</p>
</li>
<li> <p><code>BIOLOGY</code>: Class probability that biological scatterers were detected.
</p>
</li></ul>

<p>MistNet will calculate three class probabilities (from 0 to 1, with 1 corresponding
to a 100% probability) as additional scan parameters to the polar volume:
</p>

<ul>
<li> <p><code>BACKGROUND</code>: Class probability that no signal was detected above the noise
level of the radar
</p>
</li>
<li> <p><code>WEATHER</code>: Class probability that weather was detected
</p>
</li>
<li> <p><code>BIOLOGY</code>: Class probability that biological scatterers were detected
</p>
</li></ul>

<p>These class probabilities are only available for the 5 input elevations used
as input for the MistNet model. Based on all the class probabilities a final
weather segmentation map is calculated, stored as scan parameter <code>CELL</code>,
which is available for all elevation scans.
</p>

<ul>
<li> <p><code>CELL</code>: Final weather segmentation, with values &gt; 1 indicating pixels
classified as weather and values equal to 1 indicating pixels that are
located within 5 km distance of a weather pixels.
</p>
</li></ul>

<p>A pixel is classified as weather if the class probability <code>WEATHER</code> &gt; 0.45 or
when the average class probability for rain across all five MistNet elevation
scans at that spatial location &gt; 0.45.
</p>
<p>MistNet may run more slowly on Windows than on Linux or Mac OS X.
</p>


<h3>Value</h3>

<p>When <code>load</code> is <code>TRUE</code>, a polar volume (<code>pvol</code>) object with the
Mistnet segmentation results. When <code>load</code> is <code>FALSE</code>, <code>TRUE</code> on success.
</p>


<h3>References</h3>

<p>Please cite this publication when using MistNet:
</p>

<ul>
<li><p> Lin T-Y, Winner K, Bernstein G, Mittal A, Dokter AM, Horton KG, Nilsson C,
Van Doren BM, Farnsworth A, La Sorte FA, Maji S, Sheldon D (2019) MistNet:
Measuring historical bird migration in the US using archived weather radar
data and convolutional neural networks. Methods in Ecology and Evolution 10
(11), pp. 1908-22. <a href="https://doi.org/10.1111/2041-210X.13280">doi:10.1111/2041-210X.13280</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+check_docker">check_docker()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+calculate_vp">calculate_vp()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# make sure you have installed the MistNet libraries and model, using:
if(!vol2birdR::mistnet_exists()){
   vol2birdR::install_mistnet()
   vol2birdR::install_mistnet_model()
}
# start a temporary file to store polar volume
tempfile=tempfile("KBGM_example")
# Download a NEXRAD file and save as KBGM_example
download.file(
  "https://noaa-nexrad-level2.s3.amazonaws.com/2019/10/01/KBGM/KBGM20191001_000542_V06",
  method="libcurl", mode="wb", tempfile
)

# Calculate MistNet segmentation
mistnet_pvol &lt;- apply_mistnet(tempfile)

# Print summary info for the segmented elevation scan at the 0.5 degree,
# verify new parameters BIOLOGY, WEATHER, BACKGROUND and CELL have been added
scan &lt;- get_scan(mistnet_pvol, 0.5)
scan

# Project the scan as a ppi
ppi &lt;- project_as_ppi(scan, range_max = 100000)

# Plot the reflectivity parameter
plot(ppi, param = "DBZH")

# Plot the MistNet class probability [0-1] for weather
plot(ppi, param = "WEATHER")

# Plot the MistNet class probability [0-1] for biology
plot(ppi, param = "BIOLOGY")

# Plot the final segmentation result, with values &gt;1 indicating
# areas classified as weather, and value 1 pixels that fall within an
# additional 5 km fringe around weather areas
plot(ppi, param = "CELL")

# Remove file
file.remove(tempfile)

</code></pre>

<hr>
<h2 id='as.data.frame.vp'>Convert a vertical profile (<code>vp</code>) or time series of vertical profiles
(<code>vpts</code>) to a data frame</h2><span id='topic+as.data.frame.vp'></span><span id='topic+as.data.frame.vpts'></span>

<h3>Description</h3>

<p>Converts a vertical profile (<code>vp</code>) or a time series of vertical profiles
(<code>vpts</code>) to a data frame containing all quantities per datetime and height.
Has options to include latitude/longitude/antenna height (parameter <code>geo</code>)
and day/sunrise/sunset (parameter <code>suntime</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vp'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  geo = TRUE,
  suntime = TRUE,
  lat = NULL,
  lon = NULL,
  elev = -0.268,
  ...
)

## S3 method for class 'vpts'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  geo = TRUE,
  suntime = TRUE,
  lat = NULL,
  lon = NULL,
  elev = -0.268,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.vp_+3A_x">x</code></td>
<td>
<p>A <code>vp</code> or <code>vpts</code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.vp_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row names for the
data frame. Missing values are not allowed. See <code><a href="base.html#topic+as.data.frame">base::as.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.vp_+3A_optional">optional</code></td>
<td>
<p>Logical. If <code>FALSE</code> then the names of the variables in the
data frame are checked to ensure that they are syntactically valid variable
names and are not duplicated. See <code><a href="base.html#topic+as.data.frame">base::as.data.frame()</a></code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.vp_+3A_geo">geo</code></td>
<td>
<p>Logical. When <code>TRUE</code>, adds latitude (<code>lat</code>), longitude (<code>lon</code>) and
antenna height of the radar (<code>height_antenna</code>) to each row.</p>
</td></tr>
<tr><td><code id="as.data.frame.vp_+3A_suntime">suntime</code></td>
<td>
<p>Logical. When <code>TRUE</code>, adds whether it is daytime (<code>day</code>) and
the datetime of <code>sunrise</code> and <code>sunset</code> to each row.</p>
</td></tr>
<tr><td><code id="as.data.frame.vp_+3A_lat">lat</code></td>
<td>
<p>Numeric. Radar latitude in decimal degrees. When set, overrides
the latitude stored in <code>x</code> for <code><a href="#topic+sunrise">sunrise()</a></code>/<code><a href="#topic+sunset">sunset()</a></code> calculations.</p>
</td></tr>
<tr><td><code id="as.data.frame.vp_+3A_lon">lon</code></td>
<td>
<p>Numeric. Radar longitude in decimal degrees. When set, overrides
the longitude stored in <code>x</code> for <code><a href="#topic+sunrise">sunrise()</a></code>/<code><a href="#topic+sunset">sunset()</a></code> calculations.</p>
</td></tr>
<tr><td><code id="as.data.frame.vp_+3A_elev">elev</code></td>
<td>
<p>Numeric. Sun elevation in degrees, used for
<code><a href="#topic+sunrise">sunrise()</a></code>/<code><a href="#topic+sunset">sunset()</a></code> calculations.</p>
</td></tr>
<tr><td><code id="as.data.frame.vp_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that only the <code>dens</code> quantity is thresholded for radial velocity
standard deviation by <code><a href="#topic+sd_vvp_threshold">sd_vvp_threshold()</a></code>. This is different from the
default <code><a href="#topic+plot.vp">plot.vp()</a></code>, <code><a href="#topic+plot.vpts">plot.vpts()</a></code> and <code><a href="#topic+get_quantity">get_quantity()</a></code> functions, where
quantities <code>eta</code>, <code>dbz</code>, <code>ff</code>, <code>u</code>, <code>v</code>, <code>w</code>, <code>dd</code> are all thresholded by
<code><a href="#topic+sd_vvp_threshold">sd_vvp_threshold()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> object, containing radar, datetime and height as rows
and all profile quantities as columns, complemented with some oft-used
additional information (columns <code>lat</code>, <code>lon</code>, <code>height_antenna</code>, <code>day</code>,
<code>sunrise</code>, <code>sunset</code>).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.vpts">summary.vpts()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Convert vp object to a data.frame
vp_df &lt;- as.data.frame(example_vp)

# Print data.frame
vp_df

# Convert vpts object to a data.frame
vpts_df &lt;- as.data.frame(example_vpts)

# Print the first 5 rows of the data.frame
vpts_df[1:5, ]

# Do not add lat/lon/height_antenna information
vpts_df &lt;- as.data.frame(example_vpts, geo = FALSE)

# Do not add day/sunrise/sunset information
vpts_df &lt;- as.data.frame(example_vpts, suntime = FALSE)

# Override the latitude/longitude information stored in the object when
# calculating sunrise/sunset information
vpts_df &lt;- as.data.frame(example_vpts, lat = 50, lon = 4)
</code></pre>

<hr>
<h2 id='as.vpts'>Convert a dataframe into a vpts object</h2><span id='topic+as.vpts'></span>

<h3>Description</h3>

<p>Convert a dataframe into a vpts object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.vpts(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.vpts_+3A_data">data</code></td>
<td>
<p>a dataframe created from a VPTS CSV file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a bioRad vpts object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># locate example file in VPTS CSV format:
df &lt;- read.csv(system.file("extdata", "example_vpts.csv", package = "bioRad"))
# convert the data.frame to a vpts object:
as.vpts(df)
</code></pre>

<hr>
<h2 id='attribute_table'>Extract a volume coverage pattern table with all attributes</h2><span id='topic+attribute_table'></span>

<h3>Description</h3>

<p>Extract a volume coverage pattern table with all attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attribute_table(
  x,
  select = c("how.lowprf", "how.midprf", "how.highprf", "where.elangle", "where.nbins",
    "where.nrays", "where.rscale", "how.NI"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attribute_table_+3A_x">x</code></td>
<td>
<p>Either a pvol or scan for which the table should be created.</p>
</td></tr>
<tr><td><code id="attribute_table_+3A_select">select</code></td>
<td>
<p>A character vector which the column names that should be returned when NULL all attributes are to be returned</p>
</td></tr>
<tr><td><code id="attribute_table_+3A_...">...</code></td>
<td>
<p>Currently not used
</p>
<p>This function tabulates the attributes of one scan or all scans of a pvol.
Attributes that have a length longer then one are presented as a list column.
By default the function returns a limited set of columns to keep the output clear.
It is important to note that attributes of the full polar volume can contain additional information on processing that is not included in the resulting table.
This function only tabulates attributes of the scans.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the attributes of the scan(s)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_scan)
attribute_table(example_scan)

pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")
example_pvol &lt;- read_pvolfile(pvolfile)
attribute_table(example_pvol)
</code></pre>

<hr>
<h2 id='beam_distance'>Calculate radar beam distance</h2><span id='topic+beam_distance'></span>

<h3>Description</h3>

<p>Calculates the distance as measured over the earth's surface (the down range)
for a given beam elevation and slant range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beam_distance(range, elev, k = 4/3, lat = 35, re = 6378, rp = 6357)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beam_distance_+3A_range">range</code></td>
<td>
<p>Numeric. Slant range, i.e. the length of the skywave path
between target and the radar antenna, in m.</p>
</td></tr>
<tr><td><code id="beam_distance_+3A_elev">elev</code></td>
<td>
<p>Numeric. Beam elevation, in degrees.</p>
</td></tr>
<tr><td><code id="beam_distance_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="beam_distance_+3A_lat">lat</code></td>
<td>
<p>Numeric. Geodetic latitude of the radar, in degrees.</p>
</td></tr>
<tr><td><code id="beam_distance_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="beam_distance_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>depends on <a href="#topic+beam_height">beam_height</a> to calculate beam height.
</p>


<h3>Value</h3>

<p>Beam distance (down range), in m.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+beam_height">beam_height()</a></code>
</p>
</li></ul>

<p>Other beam_functions: 
<code><a href="#topic+beam_height">beam_height</a>()</code>,
<code><a href="#topic+beam_profile_overlap">beam_profile_overlap</a>()</code>,
<code><a href="#topic+beam_profile">beam_profile</a>()</code>,
<code><a href="#topic+beam_range">beam_range</a>()</code>,
<code><a href="#topic+beam_width">beam_width</a>()</code>,
<code><a href="#topic+gaussian_beam_profile">gaussian_beam_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Down range of the 5 degree elevation beam at a slant range of 100 km:
beam_distance(100000, 5)
</code></pre>

<hr>
<h2 id='beam_height'>Calculate radar beam height</h2><span id='topic+beam_height'></span>

<h3>Description</h3>

<p>Calculates the height of a radar beam as a function of elevation and range,
assuming the beam is emitted at surface level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beam_height(range, elev, k = 4/3, lat = 35, re = 6378, rp = 6357)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beam_height_+3A_range">range</code></td>
<td>
<p>Numeric. Slant range, i.e. the length of the skywave path
between target and the radar antenna, in m.</p>
</td></tr>
<tr><td><code id="beam_height_+3A_elev">elev</code></td>
<td>
<p>Numeric. Beam elevation, in degrees.</p>
</td></tr>
<tr><td><code id="beam_height_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="beam_height_+3A_lat">lat</code></td>
<td>
<p>Numeric. Geodetic latitude of the radar, in degrees.</p>
</td></tr>
<tr><td><code id="beam_height_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="beam_height_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To account for refraction of the beam towards the earth's surface, an
effective earth's radius of <code>k</code> * (true radius) is assumed, with <code>k</code> = 4/3.
</p>
<p>The earth's radius is approximated as a point on a spheroid surface, with
<code>re</code> the longer equatorial radius, and <code>rp</code> the shorter polar
radius. Typically uncertainties in refraction coefficient are relatively
large, making oblateness of the earth and the dependence of earth radius with
latitude only a small correction. Using default values assumes an average
earth's radius of 6371 km.
</p>


<h3>Value</h3>

<p>numeric. Beam height in m.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+beam_width">beam_width()</a></code>
</p>
</li></ul>

<p>Other beam_functions: 
<code><a href="#topic+beam_distance">beam_distance</a>()</code>,
<code><a href="#topic+beam_profile_overlap">beam_profile_overlap</a>()</code>,
<code><a href="#topic+beam_profile">beam_profile</a>()</code>,
<code><a href="#topic+beam_range">beam_range</a>()</code>,
<code><a href="#topic+beam_width">beam_width</a>()</code>,
<code><a href="#topic+gaussian_beam_profile">gaussian_beam_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Beam height in meters at 10 km range for a 1 degree elevation beam:
beam_height(10000, 1)

# Beam height in meters at 10 km range for a 3 and 5 degree elevation beam:
beam_height(10000, c(3, 5))

# Define ranges from 0 to 1000000 m (100 km), in steps of 100 m:
range &lt;- seq(0, 100000, 100)

# Plot the beam height of the 0.5 degree elevation beam:
plot(range, beam_height(range, 0.5), ylab = "beam height [m]", xlab = "range [m]")
</code></pre>

<hr>
<h2 id='beam_profile'>Calculate vertical radiation profile</h2><span id='topic+beam_profile'></span>

<h3>Description</h3>

<p>Calculates for a set of beam elevations (<code>elev</code>) the altitudinal normalized
distribution of radiated energy by those beams. Is a function of altitude
(<code>height</code>) at a given distance (<code>distance</code>) from the radar, assuming the
beams are emitted at antenna level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beam_profile(
  height,
  distance,
  elev,
  antenna = 0,
  beam_angle = 1,
  k = 4/3,
  lat = 35,
  re = 6378,
  rp = 6357
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beam_profile_+3A_height">height</code></td>
<td>
<p>Numeric. Height in m.</p>
</td></tr>
<tr><td><code id="beam_profile_+3A_distance">distance</code></td>
<td>
<p>Numeric. Distance from the radar as measured along sea level
(down range), in m.</p>
</td></tr>
<tr><td><code id="beam_profile_+3A_elev">elev</code></td>
<td>
<p>Numeric vector. Beam elevation(s), in degrees.</p>
</td></tr>
<tr><td><code id="beam_profile_+3A_antenna">antenna</code></td>
<td>
<p>Numeric. Height of the centre of the radar antenna, in m.</p>
</td></tr>
<tr><td><code id="beam_profile_+3A_beam_angle">beam_angle</code></td>
<td>
<p>Numeric. Beam opening angle in degrees, typically the
angle between the half-power (-3 dB) points of the main lobe.</p>
</td></tr>
<tr><td><code id="beam_profile_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="beam_profile_+3A_lat">lat</code></td>
<td>
<p>Numeric. Geodetic latitude of the radar, in degrees.</p>
</td></tr>
<tr><td><code id="beam_profile_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="beam_profile_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beam profile is calculated using <a href="#topic+beam_height">beam_height</a> and
<a href="#topic+beam_width">beam_width</a>. Returns a beam profile as a function of height relative
to ground level.
</p>
<p>Returns the normalized altitudinal pattern of radiated energy as a function
of altitude at a given distance from the radar, assuming the beams are
emitted at antenna level.
</p>


<h3>Value</h3>

<p>Numeric vector. Normalized radiated energy at each of the specified
heights.
</p>


<h3>See Also</h3>

<p>Other beam_functions: 
<code><a href="#topic+beam_distance">beam_distance</a>()</code>,
<code><a href="#topic+beam_height">beam_height</a>()</code>,
<code><a href="#topic+beam_profile_overlap">beam_profile_overlap</a>()</code>,
<code><a href="#topic+beam_range">beam_range</a>()</code>,
<code><a href="#topic+beam_width">beam_width</a>()</code>,
<code><a href="#topic+gaussian_beam_profile">gaussian_beam_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot the beam profile, for a 0.5 degree elevation beam at 50 km distance
# from the radar:
plot(beam_profile(height = 0:4000, 50000, 0.5), 0:4000,
  xlab = "normalized radiated energy",
  ylab = "height [m]", main = "beam elevation: 0.5 deg, distance=50km"
)

# Plot the beam profile, for a 2 degree elevation beam at 50 km distance
# from the radar:
plot(beam_profile(height = 0:4000, 50000, 2), 0:4000,
  xlab = "normalized radiated energy",
  ylab = "height [m]", main = "beam elevation: 2 deg, distance=50km"
)

# Plot the combined beam profile for a 0.5 and 2.0 degree elevation beam
# at 50 km distance from the radar:
plot(beam_profile(height = 0:4000, 50000, c(0.5, 2)), 0:4000,
  xlab = "normalized radiated energy",
  ylab = "height [m]", main = "beam elevations: 0.5,2 deg, distance=50km"
)
</code></pre>

<hr>
<h2 id='beam_profile_overlap'>Calculate overlap between a vertical profile ('vp') and the vertical
radiation profile emitted by the radar</h2><span id='topic+beam_profile_overlap'></span>

<h3>Description</h3>

<p>Calculates the distribution overlap between a vertical profile ('vp') and the
vertical radiation profile of a set of emitted radar beams at various
elevation angles as given by <a href="#topic+beam_profile">beam_profile</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beam_profile_overlap(
  vp,
  elev,
  distance,
  antenna,
  zlim = c(0, 4000),
  noise_floor = -Inf,
  noise_floor_ref_range = 1,
  steps = 500,
  quantity = "dens",
  normalize = TRUE,
  beam_angle = 1,
  k = 4/3,
  lat,
  re = 6378,
  rp = 6357
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beam_profile_overlap_+3A_vp">vp</code></td>
<td>
<p>A <code>vp</code> object.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_elev">elev</code></td>
<td>
<p>Numeric vector. Beam elevation(s), in degrees.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_distance">distance</code></td>
<td>
<p>Numeric. The distance(s) from the radar along sea level (down
range) for which to calculate the overlap, in m.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_antenna">antenna</code></td>
<td>
<p>Numeric. Radar antenna height, in m. Default to antenna height
in <code>vp</code>.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_zlim">zlim</code></td>
<td>
<p>Numeric vector of length two. Altitude range, in m</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_noise_floor">noise_floor</code></td>
<td>
<p>Numeric. The system noise floor in dBZ. The total system
noise expressed as the reflectivity factor it would represent at a distance
<code>noise_floor_ref_range</code> from the radar. NOT YET IMPLEMENTED</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_noise_floor_ref_range">noise_floor_ref_range</code></td>
<td>
<p>Numeric. The reference distance from the radar
at which <code>noise_floor</code> is expressed. NOT YET IMPLEMENTED.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_steps">steps</code></td>
<td>
<p>Numeric. Number of integration steps over altitude range <code>zlim</code>,
defining altitude grid size used for numeric integration.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_quantity">quantity</code></td>
<td>
<p>Character. Profile quantity (<code>dens</code> or <code>eta</code>) to use for the
altitude distribution.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, normalize the radiation coverage pattern
over the altitude range specified by <code>zlim</code>.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_beam_angle">beam_angle</code></td>
<td>
<p>Numeric. Beam opening angle in degrees, typically the
angle between the half-power (-3 dB) points of the main lobe.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_lat">lat</code></td>
<td>
<p>Numeric. Radar latitude. Defaults to latitude in <code>vp</code>.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="beam_profile_overlap_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function also calculates the <code>overlap</code> quantity in the output of
<a href="#topic+integrate_to_ppi">integrate_to_ppi</a>.
</p>
<p>Overlap is calculated as the <a href="https://en.wikipedia.org/wiki/Bhattacharyya_distance">Bhattacharyya coefficient</a> (i.e.
distribution overlap) between the (normalized) vertical profile (<code>vp</code>) and
the (normalized) radiation coverage pattern as calculated by
<code><a href="#topic+beam_profile">beam_profile()</a></code>. In the calculation of this overlap metric, <code>NA</code> and <code>NaN</code>
values in the profile quantity specified by <code>quantity</code> are replaced with
zeros.
</p>
<p>The current implementation does not (yet) take into account the system noise
floor when calculating the overlap.
</p>
<p>In the ODIM data model the attribute <code style="white-space: pre;">&#8288;/how/NEZ&#8288;</code> or <code style="white-space: pre;">&#8288;/how/NEZH&#8288;</code> specifies the
system noise floor (the Noise Equivalent Z or noise equivalent reflectivity
factor. the H refers to the horizontal channel of a dual-polarization radar).
In addition, the attribute <code style="white-space: pre;">&#8288;/how/LOG&#8288;</code> gives &quot;security distance above mean
noise level (dB) threshold value&quot;. This is equivalent to the log receiver
signal-to-noise ratio, i.e. the dB above the noise floor for the signal
processor to report a valid reflectivity value. We recommend using <code>NEZH + LOG</code> for <code>noise_floor</code>, as this is the effective noise floor of the system
below which no data will be reported by the radar signal processor.
</p>
<p>Typical values are <code>NEZH</code> = -45 to -50 dBZ at 1 km from the radar. <code>LOG</code> is
typically around 1 dB.
</p>
<p>Need to evaluate beam by beam the returned signal relative to a uniform beam
filling of at least <code>NEZH + LOG</code> If returned signal is lower, the gate is
below noise level.
</p>


<h3>Value</h3>

<p>A data.frame with columns <code>distance</code> and <code>overlap</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+beam_height">beam_height()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+beam_width">beam_width()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+beam_profile">beam_profile()</a></code>
</p>
</li></ul>

<p>Other beam_functions: 
<code><a href="#topic+beam_distance">beam_distance</a>()</code>,
<code><a href="#topic+beam_height">beam_height</a>()</code>,
<code><a href="#topic+beam_profile">beam_profile</a>()</code>,
<code><a href="#topic+beam_range">beam_range</a>()</code>,
<code><a href="#topic+beam_width">beam_width</a>()</code>,
<code><a href="#topic+gaussian_beam_profile">gaussian_beam_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Read the polar volume example file
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")

# Read the corresponding vertical profile example
pvol &lt;- read_pvolfile(pvolfile)

# let us use this example vertical profile:
data(example_vp)
example_vp

# Calculate overlap between vertical profile of birds and the vertical
# radiation profile emitted by the radar
bpo &lt;- beam_profile_overlap(
  example_vp,
  get_elevation_angles(pvol), seq(0, 100000, 1000)
)

# Plot the calculated overlap:
plot(bpo)
</code></pre>

<hr>
<h2 id='beam_range'>Calculate radar beam range</h2><span id='topic+beam_range'></span>

<h3>Description</h3>

<p>Calculates the range (i.e. slant range) given a distance measured along the
earth's surface (i.e. down range) and beam elevation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beam_range(distance, elev, k = 4/3, lat = 35, re = 6378, rp = 6357)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beam_range_+3A_distance">distance</code></td>
<td>
<p>Numeric. Distance from the radar as measured along sea level
(down range), in m.</p>
</td></tr>
<tr><td><code id="beam_range_+3A_elev">elev</code></td>
<td>
<p>Numeric. Beam elevation, in degrees.</p>
</td></tr>
<tr><td><code id="beam_range_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="beam_range_+3A_lat">lat</code></td>
<td>
<p>Numeric. Geodetic latitude of the radar, in degrees.</p>
</td></tr>
<tr><td><code id="beam_range_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="beam_range_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>depends on <a href="#topic+beam_height">beam_height</a> to calculate beam height.
</p>


<h3>Value</h3>

<p>Beam range (slant range), in m.
</p>


<h3>See Also</h3>

<p>Other beam_functions: 
<code><a href="#topic+beam_distance">beam_distance</a>()</code>,
<code><a href="#topic+beam_height">beam_height</a>()</code>,
<code><a href="#topic+beam_profile_overlap">beam_profile_overlap</a>()</code>,
<code><a href="#topic+beam_profile">beam_profile</a>()</code>,
<code><a href="#topic+beam_width">beam_width</a>()</code>,
<code><a href="#topic+gaussian_beam_profile">gaussian_beam_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Slant range of the 5 degree elevation beam at a down range of 100 km
beam_range(100000, 5)
</code></pre>

<hr>
<h2 id='beam_width'>Calculate radar beam width</h2><span id='topic+beam_width'></span>

<h3>Description</h3>

<p>Calculates the width of a radar beam as a function of range and beam angle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beam_width(range, beam_angle = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beam_width_+3A_range">range</code></td>
<td>
<p>Numeric. Range, i.e. distance from the radar antenna, in m.</p>
</td></tr>
<tr><td><code id="beam_width_+3A_beam_angle">beam_angle</code></td>
<td>
<p>Numeric. Beam opening angle in degrees, typically the
angle between the half-power (-3 dB) points of the main lobe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. Beam width in m, typically the full width at half maximum (FWHM).
</p>


<h3>See Also</h3>

<p>Other beam_functions: 
<code><a href="#topic+beam_distance">beam_distance</a>()</code>,
<code><a href="#topic+beam_height">beam_height</a>()</code>,
<code><a href="#topic+beam_profile_overlap">beam_profile_overlap</a>()</code>,
<code><a href="#topic+beam_profile">beam_profile</a>()</code>,
<code><a href="#topic+beam_range">beam_range</a>()</code>,
<code><a href="#topic+gaussian_beam_profile">gaussian_beam_profile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Beam width in meters at 10 km range:
beam_width(10000)

# Define ranges from 0 to 1000000 m (100 km), in steps of 100 m:
range &lt;- seq(0, 100000, 100)

# Plot the beam width as a function of range:
plot(range, beam_width(range), ylab = "beam width [m]", xlab = "range [m]")
</code></pre>

<hr>
<h2 id='bind_into_vpts'>Bind vertical profiles (<code>vp</code>) into time series (<code>vpts</code>)</h2><span id='topic+bind_into_vpts'></span><span id='topic+bind_into_vpts.vp'></span><span id='topic+bind_into_vpts.list'></span><span id='topic+bind_into_vpts.vpts'></span>

<h3>Description</h3>

<p>Binds vertical profiles (<code>vp</code>) into a vertical profile time series
(<code>vpts</code>), sorted on datetime. Can also bind multiple <code>vpts</code> of a
single radar into one <code>vpts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_into_vpts(x, ...)

## S3 method for class 'vp'
bind_into_vpts(...)

## S3 method for class 'list'
bind_into_vpts(x, ...)

## S3 method for class 'vpts'
bind_into_vpts(..., attributes_from = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_into_vpts_+3A_x">x</code></td>
<td>
<p>A <code>vp</code>, <code>vpts</code> object or a vector of these.</p>
</td></tr>
<tr><td><code id="bind_into_vpts_+3A_...">...</code></td>
<td>
<p>A <code>vp</code>, <code>vpts</code> object or a vector of these.</p>
</td></tr>
<tr><td><code id="bind_into_vpts_+3A_attributes_from">attributes_from</code></td>
<td>
<p>Integer. Which <code>vpts</code> to copy attributes from
(default: first).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bind_into_vpts()</code> currently requires profiles to have aligning altitude
layers that are of equal width. Profiles are allowed to differ in the number
of altitude layers, i.e. the maximum altitude.
</p>


<h3>Value</h3>

<p>A <code>vpts</code> for a single radar or a list of <code>vpts</code> for multiple radars.
Input <code>vp</code> are sorted on datetime in the output <code>vpts</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>bind_into_vpts(vp)</code>: Bind multiple <code>vp</code> into a <code>vpts</code>.
If <code>vp</code> for multiple radars are provided, a list is returned containing
a <code>vpts</code> for each radar.
</p>
</li>
<li> <p><code>bind_into_vpts(list)</code>: Bind multiple <code>vp</code> objects into a
<code>vpts</code>. If data for multiple radars is provided, a list is returned
containing a <code>vpts</code> for each radar.
</p>
</li>
<li> <p><code>bind_into_vpts(vpts)</code>: Bind multiple <code>vpts</code> into a single
<code>vpts</code>. Requires the input <code>vpts</code> to be from the same radar.
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.vp">summary.vp()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summary.vpts">summary.vpts()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Split the example vpts into two separate time series, one containing
# profile 1-10 and a second containing profile 11-20
vpts1 &lt;- example_vpts[1:10]
vpts2 &lt;- example_vpts[11:20]

# Bind the two vpts together
vpts1_and_2 &lt;- bind_into_vpts(vpts1, vpts2)

# Verify that the binded vpts now has 20 profiles, 10 from vpts1 and 10 from
# vpts2
summary(vpts1_and_2)

# Extract two profiles
vp1 &lt;- example_vpts[1]
vp1
vp2 &lt;- example_vpts[2]
vp2

# Bind the two profiles back into a vpts:
bind_into_vpts(vp1, vp2)
</code></pre>

<hr>
<h2 id='bioRad-deprecated'>Deprecated bioRad functions and data</h2><span id='topic+bioRad-deprecated'></span><span id='topic+check_docker'></span><span id='topic+update_docker'></span><span id='topic+vol2bird_version'></span><span id='topic+download_basemap'></span>

<h3>Description</h3>

<p>The functions and data listed below are deprecated or renamed and will be
defunct in the near future. When possible, alternative functions with similar
functionality are mentioned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_docker(...)

update_docker(...)

vol2bird_version(...)

download_basemap(...)
</code></pre>


<h3>Value</h3>

<p><code>TRUE</code>
</p>
<p>No return value, called for warning message side effect only
</p>
<p>an object of class <a href="base.html#topic+numeric_version">numeric_version</a>
</p>
<p>No return value, called for warning message side effect only
</p>


<h3>check_docker</h3>

<p>This function has been removed and always returns TRUE
</p>


<h3>update_docker</h3>

<p>This function has been deprecated
</p>


<h3>vol2bird_version</h3>

<p>This function has been moved to package vol2birdR
</p>


<h3>download_basemap</h3>

<p>This function has been deprecated
ggmap has been replaced by ggspatial which no longer requires a pre-downloaded raster basemap
</p>

<hr>
<h2 id='c.vp'>Concatenate vertical profiles (<code>vp</code>) into a list of vertical profiles</h2><span id='topic+c.vp'></span>

<h3>Description</h3>

<p>Concatenates vertical profiles (<code>vp</code>) into a list of vertical profiles
(<code>c(vp, vp, vp)</code>) and warns if they are not from a single radar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vp'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.vp_+3A_...">...</code></td>
<td>
<p><code>vp</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>vp</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bind_into_vpts">bind_into_vpts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># concatenate vp objects into a list:
c(example_vp, example_vp)

</code></pre>

<hr>
<h2 id='calculate_param'>Calculate a new scan parameter</h2><span id='topic+calculate_param'></span><span id='topic+calculate_param.pvol'></span><span id='topic+calculate_param.ppi'></span><span id='topic+calculate_param.scan'></span>

<h3>Description</h3>

<p>Calculate a new parameter (<code>param</code>) for a scan (<code>scan</code>) or polar volume
(<code>pvol</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_param(x, ...)

## S3 method for class 'pvol'
calculate_param(x, ...)

## S3 method for class 'ppi'
calculate_param(x, ...)

## S3 method for class 'scan'
calculate_param(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_param_+3A_x">x</code></td>
<td>
<p>A <code>pvol</code> or <code>scan</code> object.</p>
</td></tr>
<tr><td><code id="calculate_param_+3A_...">...</code></td>
<td>
<p>An expression defining the new scan parameter in terms of existing
scan parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates a new scan parameter (<code>param</code>) from a combination of existing scan
parameters. Useful for calculating quantities that are defined in terms of
other basic radar moments, like linear reflectivity eta, depolarization ratio
(Kilambi et al. 2018), or for applying clutter corrections (<code>CCORH</code>) to
uncorrected reflectivity moments (<code>TH</code>) as <code>TH + CCORH</code>.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>, either a <code>pvol</code> or <code>scan</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>calculate_param(pvol)</code>: Calculate a new parameter (<code>param</code>) for all scans
in a polar volume (<code>pvol</code>).
</p>
</li>
<li> <p><code>calculate_param(ppi)</code>: Calculate a new parameter (<code>param</code>) for a plan
position indicator (<code>ppi</code>).
</p>
</li>
<li> <p><code>calculate_param(scan)</code>: Calculate a new parameter (<code>param</code>) for a scan
(<code>scan</code>).
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Kilambi A, Fabry F, Meunier V (2018) A simple and effective method for
separating meteorological from nonmeteorological targets using
dual-polarization data. Journal of Atmospheric and Oceanic Technology 35, pp.
1415–1424. <a href="https://doi.org/10.1175/JTECH-D-17-0175.1">doi:10.1175/JTECH-D-17-0175.1</a>
</p>
</li></ul>


<ul>
<li><p> Kilambi, A., Fabry, F., and Meunier, V., 2018. A simple and effective
method for separating meteorological from nonmeteorological targets using
dual-polarization data. Journal of Atmospheric and Oceanic Technology, 35,
1415–1424. <a href="https://doi.org/10.1175/JTECH-D-17-0175.1">doi:10.1175/JTECH-D-17-0175.1</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_param">get_param()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Locate and read the polar volume example file
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")
pvol &lt;- read_pvolfile(pvolfile)

# Calculate linear reflectivity ETA from reflectivity factor DBZH
radar_wavelength &lt;- pvol$attributes$how$wavelength
pvol &lt;- calculate_param(pvol, ETA = dbz_to_eta(DBZH, radar_wavelength))

# Add depolarization ratio (DR) as a scan parameter (see Kilambi 2018)
pvol &lt;- calculate_param(pvol, DR = 10 * log10((ZDR + 1 - 2 * ZDR^0.5 * RHOHV) /
  (ZDR + 1 + 2 * ZDR^0.5 * RHOHV)))

# The function also works on scan and ppi objects
calculate_param(example_scan, DR = 10 * log10((ZDR + 1 - 2 * ZDR^0.5 * RHOHV) /
  (ZDR + 1 + 2 * ZDR^0.5 * RHOHV)))

# it also works for ppis
ppi &lt;- project_as_ppi(example_scan)
calculate_param(ppi, exp(DBZH))

</code></pre>

<hr>
<h2 id='calculate_vp'>Calculate a vertical profile (<code>vp</code>) from a polar volume (<code>pvol</code>) file</h2><span id='topic+calculate_vp'></span>

<h3>Description</h3>

<p>Calculates a vertical profile of biological scatterers (<code>vp</code>) from a polar
volume (<code>pvol</code>) file using the algorithm
<a href="https://github.com/adokter/vol2bird/">vol2bird</a> (Dokter et al.
2011 <a href="https://doi.org/10.1098/rsif.2010.0116">doi:10.1098/rsif.2010.0116</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_vp(
  file,
  vpfile = "",
  pvolfile_out = "",
  autoconf = FALSE,
  verbose = FALSE,
  warnings = TRUE,
  mount,
  sd_vvp_threshold,
  rcs = 11,
  dual_pol = TRUE,
  rho_hv = 0.95,
  single_pol = TRUE,
  elev_min = 0,
  elev_max = 90,
  azim_min = 0,
  azim_max = 360,
  range_min = 5000,
  range_max = 35000,
  n_layer = 20,
  h_layer = 200,
  dealias = TRUE,
  nyquist_min = if (dealias) 5 else 25,
  dbz_quantity = "DBZH",
  mistnet = FALSE,
  mistnet_elevations = c(0.5, 1.5, 2.5, 3.5, 4.5),
  local_install,
  local_mistnet
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_vp_+3A_file">file</code></td>
<td>
<p>Character (vector). Either a path to a single radar polar volume
(<code>pvol</code>) file containing multiple scans/sweeps, or multiple paths to scan
files containing a single scan/sweep. Or a single <code>pvol</code> object. The file data format should be either 1)
<a href="https://github.com/adokter/vol2bird/blob/master/doc/OPERA2014_O4_ODIM_H5-v2.2.pdf">ODIM</a>
format, which is the implementation of the OPERA data information model in
the <a href="https://support.hdfgroup.org/HDF5/">HDF5</a> format, 2) a format
supported by the <a href="https://trmm-fc.gsfc.nasa.gov/trmm_gv/software/rsl/">RSL library</a> or 3) Vaisala
IRIS (IRIS RAW) format.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_vpfile">vpfile</code></td>
<td>
<p>Character. File name. When provided, writes a vertical profile
file (<code>vpfile</code>) either in the VPTS CSV or ODIM HDF5 format to disk.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_pvolfile_out">pvolfile_out</code></td>
<td>
<p>Character. File name. When provided, writes a polar
volume (<code>pvol</code>) file in the ODIM HDF5 format to disk. Useful for converting
RSL formats to ODIM.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_autoconf">autoconf</code></td>
<td>
<p>Logical. When <code>TRUE</code>, default optimal configuration settings
are selected automatically and other user settings are ignored.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_verbose">verbose</code></td>
<td>
<p>Logical. When <code>TRUE</code>, vol2bird <code>stdout</code> is piped to the R
console.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_warnings">warnings</code></td>
<td>
<p>Logical. When <code>TRUE</code>, vol2bird warnings are piped to the R
console.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_mount">mount</code></td>
<td>
<p>Character. Directory path of the mount point for the Docker
container (deprecated).</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_sd_vvp_threshold">sd_vvp_threshold</code></td>
<td>
<p>Numeric. Lower threshold for the radial velocity
standard deviation (profile quantity <code>sd_vvp</code>) in m/s. Biological signals
with <code>sd_vvp &lt; sd_vvp_threshold</code> are set to zero. Defaults to 2 m/s for
C-band radars and 1 m/s for S-band radars.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_rcs">rcs</code></td>
<td>
<p>Numeric. Radar cross section per bird to use, in cm^2.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_dual_pol">dual_pol</code></td>
<td>
<p>Logical. When <code>TRUE</code>, uses dual-pol mode, in which
meteorological echoes are filtered using the correlation coefficient
threshold <code>rho_hv</code>.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_rho_hv">rho_hv</code></td>
<td>
<p>Numeric. Lower threshold in correlation coefficient to use for
filtering meteorological scattering.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_single_pol">single_pol</code></td>
<td>
<p>Logical. When <code>TRUE</code>, uses precipitation filtering in single
polarization mode based on reflectivity and radial velocity quantities.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_elev_min">elev_min</code></td>
<td>
<p>Numeric. Minimum elevation angle to include, in degrees.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_elev_max">elev_max</code></td>
<td>
<p>Numeric. Maximum elevation angle to include, in degrees.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_azim_min">azim_min</code></td>
<td>
<p>Numeric. Minimum azimuth to include, in degrees clockwise
from north.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_azim_max">azim_max</code></td>
<td>
<p>Numeric. Maximum azimuth to include, in degrees clockwise
from north.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_range_min">range_min</code></td>
<td>
<p>Numeric. Minimum range to include, in m.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_range_max">range_max</code></td>
<td>
<p>Numeric. Maximum range to include, in m.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_n_layer">n_layer</code></td>
<td>
<p>Numeric. Number of altitude layers to use in generated
profile.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_h_layer">h_layer</code></td>
<td>
<p>Numeric. Width of altitude layers to use in generated profile,
in m.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_dealias">dealias</code></td>
<td>
<p>Logical. Whether to dealias radial velocities. This should
typically be done when the scans in the polar volume have low Nyquist
velocities (below 25 m/s).</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_nyquist_min">nyquist_min</code></td>
<td>
<p>Numeric. Minimum Nyquist velocity of scans to include, in
m/s.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_dbz_quantity">dbz_quantity</code></td>
<td>
<p>Name of the available reflectivity factor to use if not
<code>DBZH</code> (e.g. <code>DBZV</code>, <code>TH</code>, <code>TV</code>).</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_mistnet">mistnet</code></td>
<td>
<p>Logical. Whether to use the MistNet segmentation model.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_mistnet_elevations">mistnet_elevations</code></td>
<td>
<p>Numeric vector of length 5. Elevation angles to
feed to the MistNet segmentation model, which expects exactly 5 elevation
scans at 0.5, 1.5, 2.5, 3.5 and 4.5 degrees. Specifying different elevation
angles may compromise segmentation results.</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_local_install">local_install</code></td>
<td>
<p>Character. Path to local vol2bird installation (e.g.
<code>your/vol2bird_install_directory/vol2bird/bin/vol2bird.sh</code>). (deprecated)</p>
</td></tr>
<tr><td><code id="calculate_vp_+3A_local_mistnet">local_mistnet</code></td>
<td>
<p>Character. Path to local MistNet segmentation model in
PyTorch format (e.g. <code style="white-space: pre;">&#8288;/your/path/mistnet_nexrad.pt&#8288;</code>).</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Typical use</h4>

<p>Common arguments set by users are <code>file</code>, <code>vpfile</code> and <code>autoconf</code>.
Turn on <code>autoconf</code> to automatically select the optimal parameters for a given
radar file. The default for C-band data is to apply rain-filtering in single
polarization mode and dual polarization mode when available. The default for
S-band data is to apply precipitation filtering in dual-polarization mode
only.
</p>
<p>Arguments that sometimes require non-default values are: <code>rcs</code>,
<code>sd_vvp_threshold</code>, <code>range_max</code>, <code>dual_pol</code>, <code>dealias</code>. Other arguments are
typically left at their defaults.
</p>



<h4>sd_vvp_threshold</h4>

<p>For altitude layers with a VVP-retrieved radial velocity standard deviation
value below the threshold <code>sd_vvp_threshold</code>, the bird density <code>dens</code> is set
to zero (see vertical profile <code><a href="#topic+summary.vp">vp</a></code> class). This threshold
might be dependent on radar processing settings. Results from validation
campaigns so far indicate that 2 m/s is the best choice for this parameter
for most C-band weather radars, which is used as the C-band default. For
S-band, the default threshold is 1 m/s.
</p>



<h4>rcs</h4>

<p>The default radar cross section (<code>rcs</code>) (11 cm^2) corresponds to the average
value found by Dokter et al. (2011) in a calibration campaign of a full
migration autumn season in western Europe at C-band. Its value may depend on
radar wavelength. <code>rcs</code> will scale approximately <code class="reqn">M^{2/3}</code> with <code>M</code> the
bird's mass.
</p>



<h4>dual_pol</h4>

<p>For S-band (radar wavelength ~ 10 cm), currently only <code>dual_pol = TRUE</code> mode
is recommended.
</p>



<h4>azim_min / azim_max</h4>

<p><code>azim_min</code> and <code>azim_max</code> only affects reflectivity-derived estimates in the
profile (<code>DBZH</code>, <code>eta</code>, <code>dens</code>), not radial-velocity derived estimates (<code>u</code>,
<code>v</code>, <code>w</code>, <code>ff</code>, <code>dd</code>, <code>sd_vvp</code>), which are estimated on all azimuths at all
times. <code>azim_min</code>, <code>azim_max</code> may be set to exclude an angular sector with
high ground clutter.
</p>



<h4>range_min / range_max</h4>

<p>Using default values of <code>range_min</code> and <code>range_max</code> is recommended. Ranges
closer than 5 km tend to be contaminated by ground clutter, while range gates
beyond 35 km become too wide to resolve the default altitude layer width of
200 meter (see <code><a href="#topic+beam_width">beam_width()</a></code>). <code>range_max</code> may be extended up to 40 km
(<code>40000</code>) for volumes with low elevations only, in order to extend coverage
to higher altitudes.
</p>



<h4>h_layer</h4>

<p>The algorithm has been tested and developed for altitude layers with <code>h_layer = 200</code>m. Smaller widths than 100 m are not recommended as they may cause
instabilities of the volume velocity profiling (VVP) and dealiasing routines,
and effectively lead to pseudo-replicated altitude data, since altitudinal
patterns smaller than the beam width cannot be resolved.
</p>



<h4>dealias</h4>

<p>Dealiasing uses the torus mapping method by Haase et al. (2004).
</p>



<h4>Local installation</h4>

<p>You may point parameter <code>local_mistnet</code> to a local download of the MistNet segmentation model in
PyTorch format, e.g. <code style="white-space: pre;">&#8288;/your/path/mistnet_nexrad.pt&#8288;</code>. The MistNet model can
be downloaded at <a href="https://s3.amazonaws.com/mistnet/mistnet_nexrad.pt">https://s3.amazonaws.com/mistnet/mistnet_nexrad.pt</a>.
</p>



<h3>Value</h3>

<p>A vertical profile object of class <code>vp</code>. When defined, output files
<code>vpfile</code> and <code>pvolfile_out</code> are saved to disk.
</p>


<h3>References</h3>

<p>Dokter et al. (2011) is the main reference for the profiling algorithm
(vol2bird) underlying this function. When using the <code>mistnet</code> option, please
also cite Lin et al. (2019). When dealiasing data (<code>dealias</code>), please also
cite Haase et al. (2004).
</p>

<ul>
<li><p> Dokter AM, Liechti F, Stark H, Delobbe L,Tabary P, Holleman I (2011) Bird
migration flight altitudes studied by a network of operational weather
radars, Journal of the Royal Society Interface 8 (54), pp. 30-43.
<a href="https://doi.org/10.1098/rsif.2010.0116">doi:10.1098/rsif.2010.0116</a>
</p>
</li>
<li><p> Haase G &amp; Landelius T (2004)
Dealiasing of Doppler radar velocities using a torus mapping. Journal of
Atmospheric and Oceanic Technology 21(10), pp. 1566-1573.
<a href="https://doi.org/10.1175/1520-0426%282004%29021%3C1566%3ADODRVU%3E2.0.CO%3B2">doi:10.1175/1520-0426(2004)021&lt;1566:DODRVU&gt;2.0.CO;2</a>
</p>
</li>
<li><p> Lin T-Y, Winner K, Bernstein G, Mittal A, Dokter AM, Horton KG, Nilsson C,
Van Doren BM, Farnsworth A, La Sorte FA, Maji S, Sheldon D (2019) MistNet:
Measuring historical bird migration in the US using archived weather radar
data and convolutional neural networks. Methods in Ecology and Evolution 10
(11), pp. 1908-22. <a href="https://doi.org/10.1111/2041-210X.13280">doi:10.1111/2041-210X.13280</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.pvol">summary.pvol()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summary.vp">summary.vp()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Locate and read the polar volume example file
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")

# Copy the file to a home directory with read/write permissions
file.copy(pvolfile, "~/volume.h5")

# Calculate the profile
vp &lt;- calculate_vp("~/volume.h5")

# Get summary info
vp

# Clean up
file.remove("~/volume.h5")
</code></pre>

<hr>
<h2 id='check_date_format'>Check if character date is in specific format</h2><span id='topic+check_date_format'></span>

<h3>Description</h3>

<p>Check if character date is in specific format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_date_format(date, format)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_date_format_+3A_date">date</code></td>
<td>
<p>character. Character representation of a date, e.g.
<code>"2018-12-13"</code>.</p>
</td></tr>
<tr><td><code id="check_date_format_+3A_format">format</code></td>
<td>
<p>character. strptime format the date should have, e.g.
<code>"\%Y-\%m-\%d"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. Will stop and show error message if date does not have correct
date format.
</p>

<hr>
<h2 id='check_night'>Check if it is night at a given time and place</h2><span id='topic+check_night'></span><span id='topic+check_night.default'></span><span id='topic+check_night.vp'></span><span id='topic+check_night.list'></span><span id='topic+check_night.vpts'></span><span id='topic+check_night.vpi'></span><span id='topic+check_night.pvol'></span>

<h3>Description</h3>

<p>Checks if it is night (<code>TRUE</code>/<code>FALSE</code>) for a combination of
latitude, longitude, date and sun elevation. When used on a bioRad object
(<code>pvol</code>, <code>vp</code>, <code>vpts</code>, <code>vpi</code>) this information is extracted from the
bioRad object directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_night(x, ..., elev = -0.268, offset = 0)

## Default S3 method:
check_night(x, lon, lat, ..., tz = "UTC", elev = -0.268, offset = 0)

## S3 method for class 'vp'
check_night(x, ..., elev = -0.268, offset = 0)

## S3 method for class 'list'
check_night(x, ..., elev = -0.268, offset = 0)

## S3 method for class 'vpts'
check_night(x, ..., elev = -0.268, offset = 0)

## S3 method for class 'vpi'
check_night(x, ..., elev = -0.268, offset = 0)

## S3 method for class 'pvol'
check_night(x, ..., elev = -0.268, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_night_+3A_x">x</code></td>
<td>
<p>A <code>pvol</code>, <code>vp</code>, <code>vpts</code>, <code>vpi</code> object, a POSIXct date or a string
interpretable by <code><a href="base.html#topic+as.POSIXlt">base::as.POSIXct()</a></code>.</p>
</td></tr>
<tr><td><code id="check_night_+3A_...">...</code></td>
<td>
<p>Optional lat, lon arguments.</p>
</td></tr>
<tr><td><code id="check_night_+3A_elev">elev</code></td>
<td>
<p>Numeric (vector). Sun elevation in degrees defining nighttime.
May also be a numeric vector of length two, with first element giving
sunset elevation, and second element sunrise elevation.</p>
</td></tr>
<tr><td><code id="check_night_+3A_offset">offset</code></td>
<td>
<p>Numeric (vector). Time duration in seconds by which to shift
the start and end of nighttime. May also be a numeric vector of length two,
with first element added to moment of sunset and second element added to
moment of sunrise.</p>
</td></tr>
<tr><td><code id="check_night_+3A_lon">lon</code></td>
<td>
<p>Numeric. Longitude, in decimal degrees.</p>
</td></tr>
<tr><td><code id="check_night_+3A_lat">lat</code></td>
<td>
<p>Numeric. Latitude, in decimal degrees.</p>
</td></tr>
<tr><td><code id="check_night_+3A_tz">tz</code></td>
<td>
<p>Character. Time zone. Ignored when <code>date</code> already has an associated
time zone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>check_night()</code> evaluates to <code>FALSE</code> when the sun has a higher
elevation than parameter <code>elev</code>, otherwise <code>TRUE</code>.
</p>
<p>Approximate astronomical formula are used, therefore the day/night
transition may be off by a few minutes.
</p>
<p>The angular diameter of the sun is about 0.536 degrees, therefore the moment
of sunrise/sunset corresponds to half that elevation at -0.268 degrees.
Approximate astronomical formula are used, therefore the day/night transition
may be off by a few minutes.
</p>
<p><code>offset</code> can be used to shift the moment of sunset and sunrise by a temporal
offset, for example, <code>offset = c(600,-900)</code> will assume nighttime starts 600
seconds after sunset (as defined by <code>elev</code>) and stops 900 seconds before
sunrise.
</p>


<h3>Value</h3>

<p><code>TRUE</code> when night, <code>FALSE</code> when day, <code>NA</code> if unknown
(either datetime or geographic location missing). For <code>vpts</code> a
vector of <code>TRUE</code>/<code>FALSE</code> values is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Check if it is night at UTC midnight in the Netherlands on January 1st:
check_night("2016-01-01 00:00", 5, 53)

# Check on bioRad objects directly:
check_night(example_vp)

check_night(example_vpts)

# Select nighttime profiles that are between 3 hours after sunset
# and 2 hours before sunrise:
index &lt;- check_night(example_vpts, offset = c(3,-2)*3600)
example_vpts[index]
</code></pre>

<hr>
<h2 id='check_radar_codes'>Check if radar codes are exactly 5 characters</h2><span id='topic+check_radar_codes'></span>

<h3>Description</h3>

<p>Check if radar codes are exactly 5 characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_radar_codes(radars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_radar_codes_+3A_radars">radars</code></td>
<td>
<p>character vector. Radar codes to check, e.g. <code>c("bejab", "bewideu")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. Will stop and show error message if at least one of the
provided radar codes is not exactly 5 characters.
</p>

<hr>
<h2 id='composite_ppi'>Create a composite of multiple plan position indicators (<code>ppi</code>)</h2><span id='topic+composite_ppi'></span>

<h3>Description</h3>

<p>Combines multiple plan position indicators (<code>ppi</code>) into a single
<code>ppi</code>. Can be used to make a composite of <code>ppi</code>'s from multiple
radars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>composite_ppi(
  x,
  param = "all",
  nx = 100,
  ny = 100,
  xlim,
  ylim,
  res,
  crs,
  raster = NA,
  method = "max",
  idp = 2,
  idw_max_distance = NA,
  coverage = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="composite_ppi_+3A_x">x</code></td>
<td>
<p>A list of <code>ppi</code> objects.</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_param">param</code></td>
<td>
<p>Character (vector). One or more parameter name(s) to composite.
To composite all available scan parameters use <code>all</code> (default).</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_nx">nx</code></td>
<td>
<p>number of raster pixels in the x (longitude) dimension</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_ny">ny</code></td>
<td>
<p>number of raster pixels in the y (latitude) dimension</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_xlim">xlim</code></td>
<td>
<p>x (longitude) range</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_ylim">ylim</code></td>
<td>
<p>y (latitude) range</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_res">res</code></td>
<td>
<p>numeric vector of length 1 or 2 to set the resolution of the raster (see <a href="raster.html#topic+resolution">res</a>).
If this argument is used, arguments <code>nx</code> and <code>ny</code> are ignored. Unit is identical to <code>xlim</code> and <code>ylim</code>.</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_crs">crs</code></td>
<td>
<p>character or object of class CRS. PROJ.4 type description of a Coordinate Reference System (map projection).
When 'NA' (default), an azimuthal equidistant projection with origin at the radar location is used.
To use a WSG84 (lat,lon) projection, use crs=&quot;+proj=longlat +datum=WGS84&quot;</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_raster">raster</code></td>
<td>
<p>(optional) RasterLayer with a CRS. When specified this raster topology is used for the output, and nx, ny, res
arguments are ignored.</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_method">method</code></td>
<td>
<p>Character (vector). Compositing method(s), either <code>mean</code>,
<code>min</code>, <code>max</code> or <code>idw</code>. To apply different methods for each of the
parameters, provide a vector with the same length as <code>param</code>.</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_idp">idp</code></td>
<td>
<p>Numeric. Inverse distance weighting power.</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_idw_max_distance">idw_max_distance</code></td>
<td>
<p>Numeric. Maximum distance from the radar to consider
in inverse distance weighting. Measurements beyond this distance will have
a weighting factor of zero.</p>
</td></tr>
<tr><td><code id="composite_ppi_+3A_coverage">coverage</code></td>
<td>
<p>Logical. When <code>TRUE</code>, adds an additional <code>coverage</code> parameter
to the <code>ppi</code> indicating the number of <code>ppi</code>s covering a single composite
pixel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can combine multiple <code>ppi</code>s of different scan elevations of the
same radar or <code>ppi</code>s of different radars. The coordinates of the returned
<code>ppi</code> object are in the WGS84 datum, unless a different <code>crs</code> is provided. If
only <code>res</code> is provided, but no <code>crs</code> is set, <code>res</code> is in meters and the
origin of the composite <code>ppi</code> is set to the mean(lat, lon) location.
</p>
<p>The <code>method</code> parameter determines how values of different <code>ppi</code>s at the same
geographic location are combined:
</p>

<ul>
<li> <p><code>mean</code>: Compute the average value.
</p>
</li>
<li> <p><code>max</code>: Compute the maximum value. If <code>ppi</code>s are of the same radar and the
same polar volume, this computes a max product, showing the maximum detected
signal at that geographic location.
</p>
</li>
<li> <p><code>min</code>: Compute the minimum value.
</p>
</li>
<li> <p><code>idw</code>: This option is useful primarily when compositing <code>ppi</code>s of multiple
radars. Performs an inverse distance weighting, where values are weighted
according to 1/(distance from the radar)^<code>idp</code>.
</p>
</li></ul>

<p>Argument <code>method</code> determines how values of different ppi's at the same
geographic location are combined.
</p>

<ul>
<li> <p><code>mean</code>: Compute the average value
</p>
</li>
<li> <p><code>max</code>: Compute the maximum value. If ppi's are of the same radar and the
same polar volume, this computes a max product, showing the maximum
detected signal at that geographic location.
</p>
</li>
<li> <p><code>min</code>: Compute the minimum value
</p>
</li>
<li> <p><code>idw</code>: This option is useful primarily when compositing ppi's of multiple
radars. Performs an inverse distance weighting, where values are weighted
according to 1/(distance from the radar)^<code>idp</code>
</p>
</li></ul>

<p>The coordinates system of the returned <code>ppi</code> is a WGS84
(lat, lon) datum, unless a different <code>crs</code> is provided. If only
<code>res</code> is provided, but no <code>crs</code> is set, <code>res</code> is in
meter units and the origin of the composite <code>ppi</code> is set to the
mean (lat, lon) location.
</p>
<p>This function is a prototype and under active development
</p>


<h3>Value</h3>

<p>A <code>ppi</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Locate and read the polar volume example file

pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")
pvol &lt;- read_pvolfile(pvolfile)

# Calculate a ppi for each elevation scan, 1000m grid resolution
ppis &lt;- lapply(pvol$scans, project_as_ppi, grid_size=1000)

# Overlay the ppis, calculating the maximum value observed
# across the available scans at each geographic location
composite &lt;- composite_ppi(ppis, method = "max", res=1000)

# Plot the calculated max product on the basemap
map(composite)

</code></pre>

<hr>
<h2 id='convert_legacy'>Convert legacy bioRad objects</h2><span id='topic+convert_legacy'></span><span id='topic+convert_legacy.vp'></span><span id='topic+convert_legacy.vpts'></span>

<h3>Description</h3>

<p>Convert legacy bioRad objects (<code>vp</code>, <code>vpts</code>) and make them compatible with
the current bioRad version. Conversion includes renaming <code>HGHT</code> to <code>height</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_legacy(x)

## S3 method for class 'vp'
convert_legacy(x)

## S3 method for class 'vpts'
convert_legacy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_legacy_+3A_x">x</code></td>
<td>
<p>A <code>vp</code> or <code>vpts</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated object of the same class as the input.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.vp">summary.vp()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+summary.vpts">summary.vpts()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Convert a vp object
vp &lt;- convert_legacy(example_vp)

# Convert a vpts object
vpts &lt;- convert_legacy(example_vpts)
</code></pre>

<hr>
<h2 id='dbz_to_eta'>Convert reflectivity factor (dBZ) to reflectivity (eta)</h2><span id='topic+dbz_to_eta'></span>

<h3>Description</h3>

<p>Converts reflectivity factor (dBZ) to reflectivity (eta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbz_to_eta(dbz, wavelength, K = 0.93)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbz_to_eta_+3A_dbz">dbz</code></td>
<td>
<p>Numeric. Reflectivity factor, in dBZ.</p>
</td></tr>
<tr><td><code id="dbz_to_eta_+3A_wavelength">wavelength</code></td>
<td>
<p>Numeric. Radar wavelength, in cm.</p>
</td></tr>
<tr><td><code id="dbz_to_eta_+3A_k">K</code></td>
<td>
<p>Numeric. Norm of the complex refractive index of water.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reflectivity, in cm^2/km^3.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+eta_to_dbz">eta_to_dbz()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Calculate eta for a 7 dBZ reflectivity factor at C-band:
dbz_to_eta(7, 5)

# Calculate eta for a 7 dBZ reflectivity factor at S-band:
dbz_to_eta(7, 10)

# Calculate animal density for a 5 dBZ reflectivity factor, assuming a
# radar cross section of 11 cm^2 per individual
dbz_to_eta(7, 5) / 11 # C-band
dbz_to_eta(7, 10) / 11 # S-band
</code></pre>

<hr>
<h2 id='download_pvolfiles'>Download polar volume (<code>pvol</code>) files from the NEXRAD archive</h2><span id='topic+download_pvolfiles'></span>

<h3>Description</h3>

<p>Download a selection of polar volume (<code>pvol</code>) files from the
<a href="https://registry.opendata.aws/noaa-nexrad/">NEXRAD Level II archive data</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_pvolfiles(
  date_min,
  date_max,
  radar,
  directory = ".",
  overwrite = FALSE,
  bucket = "noaa-nexrad-level2"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_pvolfiles_+3A_date_min">date_min</code></td>
<td>
<p>POSIXct. Start date of file selection. If no timezone are
provided, it will be assumed to be UTC.</p>
</td></tr>
<tr><td><code id="download_pvolfiles_+3A_date_max">date_max</code></td>
<td>
<p>POSIXct. End date of file selection.If no timezone are
provided, it will be assumed to be UTC.</p>
</td></tr>
<tr><td><code id="download_pvolfiles_+3A_radar">radar</code></td>
<td>
<p>character (vector). 4-letter radar code(s) (e.g. &quot;KAMA&quot;)</p>
</td></tr>
<tr><td><code id="download_pvolfiles_+3A_directory">directory</code></td>
<td>
<p>character. Path to local directory where files should be
downloaded</p>
</td></tr>
<tr><td><code id="download_pvolfiles_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. TRUE for re-downloading and overwriting previously
downloaded files of the same names.</p>
</td></tr>
<tr><td><code id="download_pvolfiles_+3A_bucket">bucket</code></td>
<td>
<p>character. Bucket name to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. The function's primary effect is to download selected polar volume
files from the NEXRAD Level II archive to a specified local directory, and to provide
a message and a progress bar in the console indicating the download status.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create temporary directory
temp_dir &lt;- paste0(tempdir(),"/bioRad_tmp_files")
dir.create(temp_dir)
download_pvolfiles(
  date_min = as.POSIXct("2002-10-01 00:00", tz = "UTC"),
  date_max = as.POSIXct("2002-10-01 00:05", tz = "UTC"),
  radar = "KBRO",
  directory = temp_dir,
  overwrite = TRUE
)
# Clean up
unlink(temp_dir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='download_vpfiles'>Download vertical profile (<code>vp</code>) files from the ENRAM data repository</h2><span id='topic+download_vpfiles'></span>

<h3>Description</h3>

<p>Download and unzip a selection of vertical profile (<code>vp</code>) files from the
<a href="https://aloftdata.eu/">ENRAM data repository</a>, where
these are stored as monthly zips per radar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download_vpfiles(
  date_min,
  date_max,
  radars,
  directory = ".",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="download_vpfiles_+3A_date_min">date_min</code></td>
<td>
<p>Character. Start date of file selection, in <code>YYYY-MM-DD</code>
format. Days will be ignored.</p>
</td></tr>
<tr><td><code id="download_vpfiles_+3A_date_max">date_max</code></td>
<td>
<p>Character. End date of file selection, in <code>YYYY-MM-DD</code>
format. Days will be ignored.</p>
</td></tr>
<tr><td><code id="download_vpfiles_+3A_radars">radars</code></td>
<td>
<p>Character (vector). 5-letter country/radar code(s) to include
in file selection.</p>
</td></tr>
<tr><td><code id="download_vpfiles_+3A_directory">directory</code></td>
<td>
<p>Character. Path to local directory where files should be
downloaded and unzipped.</p>
</td></tr>
<tr><td><code id="download_vpfiles_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. When <code>TRUE</code>, re-download and overwrite previously
downloaded files of the same names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. The function's primary effect is to download selected vertical profiles
files from ENRAM data repository to a specified local directory, and to provide
a message and a progress bar in the console indicating the download status. Message will show
a 404 error for files that are not available.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+select_vpfiles">select_vpfiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_vpfiles">read_vpfiles()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Download (and overwrite) data from radars "bejab" and "bewid".
download_vpfiles(
  date_min = "2016-10-01",
  date_max = "2016-10-31",
  radars = c("bejab", "bewid"),
  directory = tempdir(),
  overwrite = TRUE
)

</code></pre>

<hr>
<h2 id='doy_noy'>Look up day of year (doy) or night of year (noy)</h2><span id='topic+doy_noy'></span><span id='topic+doy'></span><span id='topic+noy'></span><span id='topic+doy.default'></span><span id='topic+noy.default'></span><span id='topic+doy.vp'></span><span id='topic+noy.vp'></span><span id='topic+doy.vpts'></span><span id='topic+noy.vpts'></span><span id='topic+doy.vpi'></span><span id='topic+noy.vpi'></span><span id='topic+doy.pvol'></span><span id='topic+noy.pvol'></span>

<h3>Description</h3>

<p>Returns the day of year (<code>doy</code>) or night of year (<code>noy</code>) number for datetimes
and various bioRad objects. The first night of the year is the night with
datetime Jan 01 00:00:00 in the local time zone, so sunset on Jan 1 occurs
on the second night of the year and New Years Eve on Dec 31 occurs on the
first night of the new year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doy(x, ..., method = "fast")

noy(x, ..., method = "fast")

## Default S3 method:
doy(x, lon, lat, ..., method = "fast")

## Default S3 method:
noy(x, lon, lat, ..., method = "fast")

## S3 method for class 'vp'
doy(x, ..., method = "fast")

## S3 method for class 'vp'
noy(x, ..., method = "fast")

## S3 method for class 'vpts'
doy(x, ..., method = "fast")

## S3 method for class 'vpts'
noy(x, ..., method = "fast")

## S3 method for class 'vpi'
doy(x, ..., method = "fast")

## S3 method for class 'vpi'
noy(x, ..., method = "fast")

## S3 method for class 'pvol'
doy(x, ..., method = "fast")

## S3 method for class 'pvol'
noy(x, ..., method = "fast")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doy_noy_+3A_x">x</code></td>
<td>
<p>A <code>pvol</code>, <code>vp</code>, <code>vpts</code>, or <code>vpi</code> object, or a <a href="base.html#topic+as.POSIXlt">base::as.POSIXct</a>
datetime.</p>
</td></tr>
<tr><td><code id="doy_noy_+3A_...">...</code></td>
<td>
<p>Optional lat, lon arguments.</p>
</td></tr>
<tr><td><code id="doy_noy_+3A_method">method</code></td>
<td>
<p>Method by which to do the time zone lookup. Either <code>fast</code>
(default) or <code>accurate</code>. See <a href="lutz.html#topic+tz_lookup_coords">lutz::tz_lookup_coords</a>].</p>
</td></tr>
<tr><td><code id="doy_noy_+3A_lon">lon</code></td>
<td>
<p>Numeric. Longitude in decimal degrees.</p>
</td></tr>
<tr><td><code id="doy_noy_+3A_lat">lat</code></td>
<td>
<p>Numeric. Latitude in decimal degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer representing the ordinal day of year or night of year.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get day of year of a vp object
noy(example_vp)

# Get night of year of a vp object
noy(example_vp)

# Get night of year of a vpts object
noy(example_vpts)
</code></pre>

<hr>
<h2 id='eta_to_dbz'>Convert reflectivity (eta) to reflectivity factor (dBZ)</h2><span id='topic+eta_to_dbz'></span>

<h3>Description</h3>

<p>Converts reflectivity (eta) to reflectivity factor (dBZ).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eta_to_dbz(eta, wavelength, K = 0.93)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eta_to_dbz_+3A_eta">eta</code></td>
<td>
<p>Numeric. Reflectivity, in cm^2/km^3.</p>
</td></tr>
<tr><td><code id="eta_to_dbz_+3A_wavelength">wavelength</code></td>
<td>
<p>Numeric. Radar wavelength, in cm.</p>
</td></tr>
<tr><td><code id="eta_to_dbz_+3A_k">K</code></td>
<td>
<p>Numeric. Norm of the complex refractive index of water.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Reflectivity factor, in dBZ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate dBZ for a 10000 cm^2/km^3 eta reflectivity at C-band
eta_to_dbz(10000, 5)

# Calculate dBZ for a 10000 cm^2/km^3 eta reflectivity at S-band
eta_to_dbz(10000, 10)

# Calculate dBZ for an animal density of 1000 individuals/km^3 and a radar
# cross section of 11 cm^2 per individual
eta_to_dbz(1000 * 11, 5) # C-band
eta_to_dbz(1000 * 11, 10) # S-band
</code></pre>

<hr>
<h2 id='example_scan'>Scan (<code>scan</code>) example</h2><span id='topic+example_scan'></span>

<h3>Description</h3>

<p>Example of a <code><a href="#topic+summary.scan">scan</a></code> object with name <code>example_scan</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_scan
</code></pre>


<h3>Format</h3>

<p>An object of class <code>scan</code> of dimension 5 x 480 x 360.
</p>


<h3>Value</h3>

<p>An example object of type <code>scan</code> which represents a single scan from a weather radar.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.scan">summary.scan()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Reload example_scan from package (e.g. in case it was altered)
data(example_scan)

# Get summary info
example_scan
</code></pre>

<hr>
<h2 id='example_vp'>Vertical profile (<code>vp</code>) example</h2><span id='topic+example_vp'></span>

<h3>Description</h3>

<p>Example of a <code><a href="#topic+summary.vp">vp</a></code> object with name <code>example_vp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_vp
</code></pre>


<h3>Format</h3>

<p>An object of class <code>vp</code> with 25 rows and 16 columns.
</p>


<h3>Value</h3>

<p>An example object of type <code>vp</code> which represents a vertical profile.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.vp">summary.vp()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Reload example_vp from package (e.g. in case it was altered)
data(example_vp)

# Get summary info
example_vp
</code></pre>

<hr>
<h2 id='example_vpts'>Time series of vertical profiles (<code>vpts</code>) example</h2><span id='topic+example_vpts'></span>

<h3>Description</h3>

<p>Example of a <code><a href="#topic+summary.vpts">vpts</a></code> object with name <code>example_vpts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_vpts
</code></pre>


<h3>Format</h3>

<p>An object of class <code>vpts</code> of dimension 1934 x 25 x 15.
</p>


<h3>Value</h3>

<p>An example object of type <code>vpts</code> which represents a time series of vertical profiles.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.vpts">summary.vpts()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Reload example_vpts from package (e.g. in case it was altered)
data(example_vpts)

# Get summary info
example_vpts
</code></pre>

<hr>
<h2 id='extract_string'>extract strings from a vector using regex, analog to stringr::str_extract</h2><span id='topic+extract_string'></span>

<h3>Description</h3>

<p>extract strings from a vector using regex, analog to stringr::str_extract
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_string(string, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_string_+3A_string">string</code></td>
<td>
<p>Input vector. A character vector.</p>
</td></tr>
<tr><td><code id="extract_string_+3A_pattern">pattern</code></td>
<td>
<p>Regex pattern to look for</p>
</td></tr>
<tr><td><code id="extract_string_+3A_...">...</code></td>
<td>
<p>passed on to <code>regexpr()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with matches only, possibly of different length as
<code>string</code>
</p>

<hr>
<h2 id='filter_vpts'>Filter a time series of vertical profiles ('vpts') by a start and end time.
Use argument night = TRUE to select only time stamps between sunset and sunrise,
or night = FALSE to select daytime (sunrise to sunset). Selection for night and day uses
<code><a href="#topic+check_night">check_night()</a></code>.</h2><span id='topic+filter_vpts'></span>

<h3>Description</h3>

<p>Filter a time series of vertical profiles ('vpts') by a start and end time.
Use argument night = TRUE to select only time stamps between sunset and sunrise,
or night = FALSE to select daytime (sunrise to sunset). Selection for night and day uses
<code><a href="#topic+check_night">check_night()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_vpts(x, min, max, nearest, night, elev = -0.268, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_vpts_+3A_x">x</code></td>
<td>
<p>A <code>vpts</code> object.</p>
</td></tr>
<tr><td><code id="filter_vpts_+3A_min">min</code></td>
<td>
<p>POSIXct date or character. Minimum datetime to be included.</p>
</td></tr>
<tr><td><code id="filter_vpts_+3A_max">max</code></td>
<td>
<p>POSIXct date or character. Datetime up to this maximum included.</p>
</td></tr>
<tr><td><code id="filter_vpts_+3A_nearest">nearest</code></td>
<td>
<p>POSIXct date or character. If specified, <code>min</code> and <code>max</code> are
ignored and the profile (<code>vp</code>) nearest to the specified datetime is
returned that matches the day/night selection criteria.</p>
</td></tr>
<tr><td><code id="filter_vpts_+3A_night">night</code></td>
<td>
<p>When <code>TRUE</code> selects only nighttime profiles, when <code>FALSE</code>
selects only daytime profiles, as classified by <code><a href="#topic+check_night">check_night()</a></code>.</p>
</td></tr>
<tr><td><code id="filter_vpts_+3A_elev">elev</code></td>
<td>
<p>Numeric (vector). Sun elevation in degrees defining nighttime.
May also be a numeric vector of length two, with first element giving
sunset elevation, and second element sunrise elevation.</p>
</td></tr>
<tr><td><code id="filter_vpts_+3A_offset">offset</code></td>
<td>
<p>Numeric (vector). Time duration in seconds by which to shift
the start and end of nighttime. May also be a numeric vector of length two,
with first element added to moment of sunset and second element added to
moment of sunrise. See <code><a href="#topic+check_night">check_night()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns profiles for which min &lt;= timestamp profile &lt; max. Selection for night and day
occurs by <a href="#topic+check_night">check_night</a>.
</p>


<h3>Value</h3>

<p>A <code>vpts</code> object, or a <code>vp</code> object when <code>nearest</code> is specified.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.vpts">summary.vpts()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+check_night">check_night()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Select profiles later than 02 Sep 2016

# Select the profile nearest to 2016-09-01 03:00 UTC
filter_vpts(example_vpts, nearest = "2016-09-01 03:00")

# Select profiles between than 01:00 and 03:00 UTC on 02 Sep 2016
filter_vpts(example_vpts, min = "2016-09-02 01:00", max = "2016-09-02 03:00")

# Select daytime profiles (i.e. profiles between sunrise and sunset)
filter_vpts(example_vpts, night = FALSE)

# Select nighttime profiles, with nights starting and ending at
# civil twilight (when the sun is 6 degrees below the horizon)
filter_vpts(example_vpts, night = TRUE, elev = -6)

# Select nighttime profiles from 3h after sunset to 2h before sunrise
filter_vpts(example_vpts, night = TRUE, offset = c(3, -2)*3600)

</code></pre>

<hr>
<h2 id='gaussian_beam_profile'>Gaussian beam profile as a function of height</h2><span id='topic+gaussian_beam_profile'></span>

<h3>Description</h3>

<p>Normalized altitudinal pattern of radiated energy as a function of altitude
at a given distance from the radar. <code>antenna</code> and <code>height</code> should be given in
reference to the same reference plane (e.g. ground level or sea level).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_beam_profile(
  height,
  range,
  elev,
  antenna = 0,
  beam_angle = 1,
  k = 4/3,
  lat = 35,
  re = 6378,
  rp = 6357
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_beam_profile_+3A_height">height</code></td>
<td>
<p>Numeric. Height in m.</p>
</td></tr>
<tr><td><code id="gaussian_beam_profile_+3A_range">range</code></td>
<td>
<p>Numeric. Slant range, i.e. the length of the skywave path
between target and the radar antenna, in m.</p>
</td></tr>
<tr><td><code id="gaussian_beam_profile_+3A_elev">elev</code></td>
<td>
<p>Numeric. Beam elevation, in degrees.</p>
</td></tr>
<tr><td><code id="gaussian_beam_profile_+3A_antenna">antenna</code></td>
<td>
<p>Numeric. Height of the centre of the radar antenna, in m.</p>
</td></tr>
<tr><td><code id="gaussian_beam_profile_+3A_beam_angle">beam_angle</code></td>
<td>
<p>Numeric. Beam opening angle in degrees, typically the
angle between the half-power (-3 dB) points of the main lobe.</p>
</td></tr>
<tr><td><code id="gaussian_beam_profile_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="gaussian_beam_profile_+3A_lat">lat</code></td>
<td>
<p>Numeric. Geodetic latitude of the radar, in degrees.</p>
</td></tr>
<tr><td><code id="gaussian_beam_profile_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="gaussian_beam_profile_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beam profile is calculated using <a href="#topic+beam_height">beam_height</a> and <a href="#topic+beam_width">beam_width</a>. <code>height</code> and
<code>antenna</code> should be given in reference to the same reference plane (e.g. ground level or sea level)
</p>


<h3>Value</h3>

<p>numeric.
</p>


<h3>See Also</h3>

<p>Other beam_functions: 
<code><a href="#topic+beam_distance">beam_distance</a>()</code>,
<code><a href="#topic+beam_height">beam_height</a>()</code>,
<code><a href="#topic+beam_profile_overlap">beam_profile_overlap</a>()</code>,
<code><a href="#topic+beam_profile">beam_profile</a>()</code>,
<code><a href="#topic+beam_range">beam_range</a>()</code>,
<code><a href="#topic+beam_width">beam_width</a>()</code>
</p>

<hr>
<h2 id='get_elevation_angles'>Get elevation angles of a polar volume (<code>pvol</code>), scan (<code>scan</code>) or parameter
(<code>param</code>)</h2><span id='topic+get_elevation_angles'></span><span id='topic+get_elevation_angles.pvol'></span><span id='topic+get_elevation_angles.scan'></span><span id='topic+get_elevation_angles.param'></span>

<h3>Description</h3>

<p>Returns the elevation angles in degrees of all scans within a polar volume
(<code>pvol</code>) or the elevation angle of a single scan (<code>scan</code>) or scan parameter
(<code>param</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_elevation_angles(x)

## S3 method for class 'pvol'
get_elevation_angles(x)

## S3 method for class 'scan'
get_elevation_angles(x)

## S3 method for class 'param'
get_elevation_angles(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_elevation_angles_+3A_x">x</code></td>
<td>
<p>A <code>pvol</code>, <code>scan</code> or <code>param</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The elevation angle(s) in degrees.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_scan">get_scan()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Locate and read the polar volume example file
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")
example_pvol &lt;- read_pvolfile(pvolfile)

# Get the elevations angles of the scans in the pvol
get_elevation_angles(example_pvol)

# Extract the first scan
scan &lt;- example_pvol$scans[[1]]

# Get the elevation angle of that scan
get_elevation_angles(scan)
</code></pre>

<hr>
<h2 id='get_iris_raw_task'>Check the <code>task</code> type of an IRIS RAW file</h2><span id='topic+get_iris_raw_task'></span>

<h3>Description</h3>

<p>Checks what type of <code>task</code>(s), i.e. polar volume types, are contained in an
IRIS RAW file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_iris_raw_task(
  file,
  header_size = 50,
  task = c("WIND", "SURVEILLANCE", "VOL_A", "VOL_B")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_iris_raw_task_+3A_file">file</code></td>
<td>
<p>Character. Path to a polar volume file in IRIS RAW format.</p>
</td></tr>
<tr><td><code id="get_iris_raw_task_+3A_header_size">header_size</code></td>
<td>
<p>Integer. Number of header bytes to search.</p>
</td></tr>
<tr><td><code id="get_iris_raw_task_+3A_task">task</code></td>
<td>
<p>Character (vector). Task names to search for in the file header.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Specified <code>task</code> names found in the header or <code>NA</code> if none of the
task names were found.
</p>

<hr>
<h2 id='get_odim_object_type'>Check the <code>data</code> type of an ODIM HDF5 file</h2><span id='topic+get_odim_object_type'></span>

<h3>Description</h3>

<p>Checks what type of <code>data</code> object is contained in an ODIM HDF5 file. See
<a href="https://github.com/adokter/vol2bird/blob/master/doc/OPERA2014_O4_ODIM_H5-v2.2.pdf">ODIM specification</a>,
Table 2 for a full list of existing ODIM file object types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_odim_object_type(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_odim_object_type_+3A_file">file</code></td>
<td>
<p>Character. Path of the file to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character. <code>PVOL</code> for polar volume, <code>VP</code> for vertical profile,
otherwise <code>NA</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+is.pvolfile">is.pvolfile()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+is.vpfile">is.vpfile()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Locate the polar volume example file
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")

# Check the data type
get_odim_object_type(pvolfile)
</code></pre>

<hr>
<h2 id='get_param'>Get a parameter (<code>param</code>) from a scan (<code>scan</code>)</h2><span id='topic+get_param'></span>

<h3>Description</h3>

<p>Returns the selected parameter (<code>param</code>) from a scan (<code>scan</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_param(x, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_param_+3A_x">x</code></td>
<td>
<p>A <code>scan</code> object.</p>
</td></tr>
<tr><td><code id="get_param_+3A_param">param</code></td>
<td>
<p>Character. A scan parameter, such as <code>DBZH</code> or <code>VRADH</code>. See
<code><a href="#topic+summary.param">summary.param()</a></code> for commonly available parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>param</code> object.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.param">summary.param()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Get summary info for a scan (including parameters)
example_scan

# Extract the VRADH scan parameter
param &lt;- get_param(example_scan, "VRADH")

# Get summary info for this parameter
param
</code></pre>

<hr>
<h2 id='get_quantity'>Get a quantity from a vertical profile (<code>vp</code>) or time series of vertical
profiles (<code>vpts</code>)</h2><span id='topic+get_quantity'></span><span id='topic+get_quantity.vp'></span><span id='topic+get_quantity.list'></span><span id='topic+get_quantity.vpts'></span>

<h3>Description</h3>

<p>Returns values for the selected quantity from a vertical profile (<code>vp</code>),
list, or time series of vertical profiles (<code>vpts</code>). Values are organized per
height bin. Values for <code>eta</code> are set to <code>0</code>, <code>dbz</code> to <code>-Inf</code> and <code>ff</code>, <code>u</code>,
<code>v</code>, <code>w</code>, <code>dd</code> to <code>NaN</code> when the <code>sd_vvp</code> for that height bin is below the
<code><a href="#topic+sd_vvp_threshold">sd_vvp_threshold()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_quantity(x, quantity)

## S3 method for class 'vp'
get_quantity(x, quantity = "dens")

## S3 method for class 'list'
get_quantity(x, quantity = "dens")

## S3 method for class 'vpts'
get_quantity(x, quantity = "dens")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_quantity_+3A_x">x</code></td>
<td>
<p>A <code>vp</code>, list of <code>vp</code> or <code>vpts</code> object.</p>
</td></tr>
<tr><td><code id="get_quantity_+3A_quantity">quantity</code></td>
<td>
<p>Character. A (case sensitive) profile quantity, one of:
</p>

<ul>
<li> <p><code>height</code>: Height bin (lower bound) in m above sea level.
</p>
</li>
<li> <p><code>u</code>: Ground speed component west to east in m/s.
</p>
</li>
<li> <p><code>v</code>: Ground speed component south to north in m/s.
</p>
</li>
<li> <p><code>w</code>: Vertical speed (unreliable!) in m/s.
</p>
</li>
<li> <p><code>ff</code>: Horizontal speed in m/s.
</p>
</li>
<li> <p><code>dd</code>: Direction in degrees clockwise from north.
</p>
</li>
<li> <p><code>sd_vvp</code>: VVP radial velocity standard deviation in m/s.
</p>
</li>
<li> <p><code>gap</code>: Angular data gap detected in T/F.
</p>
</li>
<li> <p><code>dbz</code>: Animal reflectivity factor in dBZ.
</p>
</li>
<li> <p><code>eta</code>: Animal reflectivity in cm^2/km^3.
</p>
</li>
<li> <p><code>dens</code>: Animal density in animals/km^3.
</p>
</li>
<li> <p><code>DBZH</code>: Total reflectivity factor (bio + meteo scattering) in dBZ.
</p>
</li>
<li> <p><code>n</code>: Number of data points used for the ground speed estimates
(quantities <code>u</code>, <code>v</code>, <code>w</code>, <code>ff</code>, <code>dd</code>).
</p>
</li>
<li> <p><code>n_all</code>: Number of data points used for the radial velocity standard
deviation estimate (quantity <code>sd_vvp</code>).
</p>
</li>
<li> <p><code>n_dbz</code>: Number of data points used for reflectivity-based estimates
(quantities <code>dbz</code>, <code>eta</code>, <code>dens</code>).
</p>
</li>
<li> <p><code>n_dbz_all</code>: Number of data points used for the total reflectivity
estimate (quantity <code>DBZH</code>).
</p>
</li>
<li> <p><code>attributes</code>: List of the vertical profile's <code>what</code>, <code>where</code> and <code>how</code>
attributes.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of a specific profile quantity specified in <code>quantity</code>.
</p>
<p>For a <code>vp</code> object: a named (height bin) vector with values for the
selected quantity.
</p>
<p>For a <code>list</code> object: a list of named (height bin) vectors with values
for the selected quantity.
</p>
<p>For a <code>vpts</code> object: a (height bin * datetime) matrix with values for
the selected quantity.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.vp">summary.vp()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+sd_vvp_threshold+3C-">sd_vvp_threshold()&lt;-</a></code> for setting the <code>sd_vvp</code>
threshold of an object.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Extract the animal density (dens) quantity from a vp object
get_quantity(example_vp, "dens")

# Extract the horizontal ground speed (ff) quantity from a vpts object and show the
# first two datetimes
get_quantity(example_vpts, "ff")[,1:2]
</code></pre>

<hr>
<h2 id='get_scan'>Get a scan (<code>scan</code>) from a polar volume (<code>pvol</code>)</h2><span id='topic+get_scan'></span>

<h3>Description</h3>

<p>Returns the scan (<code>scan</code>) from a polar volume (<code>pvol</code>) with elevation angle
closest to <code>elev</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_scan(x, elev, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_scan_+3A_x">x</code></td>
<td>
<p>A <code>pvol</code> object.</p>
</td></tr>
<tr><td><code id="get_scan_+3A_elev">elev</code></td>
<td>
<p>Numeric. Elevation angle in degrees.</p>
</td></tr>
<tr><td><code id="get_scan_+3A_all">all</code></td>
<td>
<p>Logical. Return the first scan in the <code>pvol</code> object
closest to the requested elevation (<code>FALSE</code>), or a list with
all scans equally close to the requested elevation (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In cases where <code>elev</code> is exactly in between two
scan elevation angles, the lower elevation angle scan is returned.
</p>


<h3>Value</h3>

<p>A <code>scan</code> object when <code>all</code> equals <code>FALSE</code> (default), or a list of <code>scan</code> objects if <code>all</code> equals <code>TRUE</code>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.scan">summary.scan()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_elevation_angles">get_elevation_angles()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Locate and read the polar volume example file
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")
pvol &lt;- read_pvolfile(pvolfile)

# Get elevation angles
get_elevation_angles(pvol)

# Extract the scan closest to 3 degrees elevation (2.5 degree scan)
scan &lt;- get_scan(pvol, 3)

# Get summary info
scan

# Extract all scans closest to 3 degrees elevation (2.5 degree scan)
# Always returns a list with scan object(s), containing multiple scans
# if the pvol contains multiple scans at the same closest elevation.
scan_list &lt;- get_scan(pvol, 3)
scan_list
</code></pre>

<hr>
<h2 id='integrate_profile'>Vertically integrate profiles (<code>vp</code> or <code>vpts</code>) into an
integrated profile (<code>vpi</code>)</h2><span id='topic+integrate_profile'></span><span id='topic+integrate_profile.vp'></span><span id='topic+integrate_profile.list'></span><span id='topic+integrate_profile.vpts'></span>

<h3>Description</h3>

<p>Performs a vertical integration of density, reflectivity and migration
traffic rate, and a vertical averaging of ground speed and direction weighted
by density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_profile(
  x,
  alt_min,
  alt_max,
  alpha = NA,
  interval_max = 3600,
  interval_replace = NA,
  height_quantile = NA
)

## S3 method for class 'vp'
integrate_profile(
  x,
  alt_min = 0,
  alt_max = Inf,
  alpha = NA,
  interval_max = 3600,
  interval_replace = NA,
  height_quantile = NA
)

## S3 method for class 'list'
integrate_profile(
  x,
  alt_min = 0,
  alt_max = Inf,
  alpha = NA,
  interval_max = 3600,
  interval_replace = NA,
  height_quantile = NA
)

## S3 method for class 'vpts'
integrate_profile(
  x,
  alt_min = 0,
  alt_max = Inf,
  alpha = NA,
  interval_max = 3600,
  interval_replace = NA,
  height_quantile = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_profile_+3A_x">x</code></td>
<td>
<p>A <code>vp</code> or <code>vpts</code> object.</p>
</td></tr>
<tr><td><code id="integrate_profile_+3A_alt_min">alt_min</code></td>
<td>
<p>Minimum altitude in m. <code>"antenna"</code> can be used to set the
minimum altitude to the height of the antenna.</p>
</td></tr>
<tr><td><code id="integrate_profile_+3A_alt_max">alt_max</code></td>
<td>
<p>Maximum altitude in m.</p>
</td></tr>
<tr><td><code id="integrate_profile_+3A_alpha">alpha</code></td>
<td>
<p>Migratory direction in clockwise degrees from north.</p>
</td></tr>
<tr><td><code id="integrate_profile_+3A_interval_max">interval_max</code></td>
<td>
<p>Maximum time interval belonging to a single profile in
seconds. Traffic rates are set to zero at times <code>t</code> for which no
profiles can be found within the period <code>t-interval_max/2</code> to
<code>t+interval_max/2</code>. Ignored for single profiles of class <code>vp</code>.</p>
</td></tr>
<tr><td><code id="integrate_profile_+3A_interval_replace">interval_replace</code></td>
<td>
<p>Time interval to use for any interval &gt; interval_max.
By default the mean of all intervals &lt;= interval_max</p>
</td></tr>
<tr><td><code id="integrate_profile_+3A_height_quantile">height_quantile</code></td>
<td>
<p>For default <code>NA</code> the calculated height equals
the mean flight altitude. Otherwise a number between 0 and 1 specifying a
quantile of the height distribution.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Available quantities</h4>

<p>The function generates a specially classed data frame with the following
quantities:
</p>

<ul>
<li> <p><code>datetime</code>: POSIXct date of each profile in UTC
</p>
</li>
<li> <p><code>vid</code>: Vertically Integrated Density in individuals/km^2.
<code>vid</code> is a surface density, whereas <code>dens</code> in <code>vp</code> objects is a volume
density.
</p>
</li>
<li> <p><code>vir</code>: Vertically Integrated Reflectivity in cm^2/km^2
</p>
</li>
<li> <p><code>mtr</code>: Migration Traffic Rate in individuals/km/h
</p>
</li>
<li> <p><code>rtr</code>: Reflectivity Traffic Rate in cm^2/km/h
</p>
</li>
<li> <p><code>mt</code>: Migration Traffic in individuals/km, cumulated from the start of the
time series up to <code>datetime</code>
</p>
</li>
<li> <p><code>rt</code>: Reflectivity Traffic in cm^2/km, cumulated from the start of the time
series up to <code>datetime</code>
</p>
</li>
<li> <p><code>ff</code>: Horizontal ground speed in m/s
</p>
</li>
<li> <p><code>dd</code>: Direction of the horizontal ground speed in degrees
</p>
</li>
<li> <p><code>u</code>: Ground speed component west to east in m/s
</p>
</li>
<li> <p><code>v</code>: Ground speed component south to north in m/s
</p>
</li>
<li> <p><code>height</code>: Mean flight height (height weighted by eta) in m above sea level
</p>
</li></ul>

<p>Vertically integrated density and reflectivity are related according to
<code class="reqn">vid=vir/rcs(x)</code>, with <a href="#topic+rcs">rcs</a> the assumed radar cross section per
individual. Similarly, migration traffic rate and reflectivity traffic rate
are related according to <code class="reqn">mtr=rtr/rcs(x)</code>
</p>



<h4>Migration traffic rate (mtr) and reflectivity traffic rate (rtr)</h4>

<p>Migration traffic rate (mtr) for an altitude layer is a flux measure, defined
as the number of targets crossing a unit of transect per hour.
</p>
<p>Column mtr of the output dataframe gives migration traffic rates in individuals/km/hour.
</p>
<p>The transect direction is set by the angle <code>alpha</code>. When
<code>alpha=NA</code>, the transect runs perpendicular to the measured migratory
direction. <code>mtr</code> then equals the number of crossing targets per km
transect per hour, for a transect kept perpendicular to the measured
migratory movement at all times and altitudes. In this case <code>mtr</code> is
always a positive quantity, defined as:
</p>
<p style="text-align: center;"><code class="reqn">mtr = 3.6 \sum_i \mathit{dens}_i \mathit{ff}_i \Delta h</code>
</p>

<p>with the sum running over all altitude layers between <code>alt_min</code> and
<code>alt_max</code>, <code class="reqn">\mathit{dens}_i</code> the bird density, <code class="reqn">\mathit{ff}_i</code> the ground speed at
altitude layer i, and <code class="reqn">\Delta h</code> the altitude layer width. The factor 3.6
refers to a unit conversion of speeds <code class="reqn">\mathit{ff}_i</code> from m/s to km/h.
</p>
<p>If <code>alpha</code> is given a numeric value, the transect is taken perpendicular
to the direction <code>alpha</code>, and the number of crossing targets per hour
per km transect is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">mtr = 3.6 \sum_i \mathit{dens}_i \mathit{ff}_i \cos((dd_i-\alpha) \pi/180) \Delta h</code>
</p>

<p>with <code class="reqn">dd_i</code> the migratory direction at altitude i.
</p>
<p>Note that this equation evaluates to the previous equation when <code>alpha</code> equals <code class="reqn">dd_i</code>.
Also note we can rewrite this equation using trigonometry as:
</p>
<p style="text-align: center;"><code class="reqn">mtr = 3.6 \sum_i \mathit{dens}_i (u_i \sin(\alpha \pi/180) + v_i \cos(\alpha \pi/180)) \Delta h</code>
</p>

<p>with <code class="reqn">u_i</code> and <code class="reqn">v_i</code> the u and v ground speed components at altitude i.
</p>
<p>In this definition <code>mtr</code> is a traditional flux into a direction of
interest. Targets moving into the direction <code>alpha</code> contribute
positively to <code>mtr</code>, while targets moving in the opposite direction
contribute negatively to <code>mtr</code>. Therefore <code>mtr</code> can be both
positive or negative, depending on the definition of alpha.
</p>
<p>Note that <code>mtr</code> for a given value of <code>alpha</code> can also be calculated from
the vertically integrated density <code>vid</code> and the height-integrated velocity
components <code>u</code> and <code>v</code> as follows:
</p>
<p style="text-align: center;"><code class="reqn">mtr = 3.6 (u \sin(\alpha \pi/180) + v \cos(\alpha \pi/180)) vid</code>
</p>

<p>Formula for reflectivity traffic rate <code>rtr</code> are found by replacing
<code>dens</code> with <code>eta</code> and <code>vid</code> with <code>vir</code> in the formula for <code>mtr</code>.
Reflectivity traffic rate gives the cross-sectional area
passing the radar per km transect perpendicular to the migratory direction per hour.
<code>mtr</code> values are conditional on settings of <a href="#topic+rcs">rcs</a>, while <code>rtr</code> values are not.
</p>



<h4>Migration traffic (mt) and reflectivity traffic (rt)</h4>

<p>Migration traffic is calculated by time-integration of
migration traffic rates. Migration traffic gives the number of individuals
that have passed per km perpendicular to the migratory direction at the
position of the radar for the full period of the time series within the
specified altitude band.
</p>
<p>Reflectivity traffic is calculated by time-integration of
reflectivity traffic rates. Reflectivity traffic gives the total cross-sectional area
that has passed per km perpendicular to the migratory direction at the
position of the radar for the full period of the time series within the
specified altitude band.
</p>
<p><code>mt</code> values are conditional on settings of <a href="#topic+rcs">rcs</a>, while <code>rt</code> values are not.
</p>
<p>Columns mt and rt in the output dataframe provides migration traffic as a numeric value equal to
migration traffic and reflectivity traffic from the start of the time series up till the moment of the time stamp
of the respective row.
</p>


<h5>Ground speed (ff) and ground speed components (u,v)</h5>

<p>The height-averaged ground speed is defined as:
</p>
<p style="text-align: center;"><code class="reqn">\mathit{ff} = \sum_i \mathit{dens}_i \mathit{ff}_i / \sum_i \mathit{dens}_i</code>
</p>

<p>with the sum running over all altitude layers between <code>alt_min</code> and
<code>alt_max</code>, <code class="reqn">\mathit{dens}_i</code> the bird density, <code class="reqn">\mathit{ff}_i</code> the ground speed at
altitude layer i.
</p>
<p>the height-averaged u component (west to east) is defined as:
</p>
<p style="text-align: center;"><code class="reqn">u = \sum_i \mathit{dens}_i u_i / \sum_i \mathit{dens}_i</code>
</p>

<p>the height-averaged v component (south to north) is defined as:
</p>
<p style="text-align: center;"><code class="reqn">v = \sum_i \mathit{dens}_i v_i / \sum_i \mathit{dens}_i</code>
</p>


<p>Note that <code class="reqn">\mathit{ff}_i=\sqrt(u_i^2 + v_i^2)</code>, but the same does not hold for the
height-integrated speeds, i.e. <code class="reqn">\mathit{ff} \neq \sqrt(u^2 + v^2)</code> as soon as the
ground speed directions vary with altitude.
</p>



<h3>Value</h3>

<p>an object of class <code>vpi</code>, a data frame with vertically
integrated profile quantities
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>integrate_profile(vp)</code>: Vertically integrate a vertical profile (<code>vp</code>).
</p>
</li>
<li> <p><code>integrate_profile(list)</code>: Vertically integrate a list of vertical
profiles (<code>vp</code>).
</p>
</li>
<li> <p><code>integrate_profile(vpts)</code>: Vertically integrate a time series of
vertical profiles (<code>vpts</code>).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate migration traffic rates for a single vp
integrate_profile(example_vp)

# Calculate migration traffic rates for a list of vps
integrate_profile(c(example_vp, example_vp))

# Calculate migration traffic rates for a vpts
vpi &lt;- integrate_profile(example_vpts)

# Plot migration traffic rate (mtr) for the full air column
plot(integrate_profile(example_vpts))

# Plot migration traffic rate (mtr) for altitudes &gt; 1 km above sea level
plot(integrate_profile(example_vpts, alt_min = 1000))

# Plot cumulative migration traffic rates (mt)
plot(integrate_profile(example_vpts), quantity = "mt")
# calculate median flight altitude (instead of default mean)
integrate_profile(example_vp, height_quantile=.5)
# calculate the 90% percentile of the flight altitude distribution
integrate_profile(example_vpts, height_quantile=.9)
</code></pre>

<hr>
<h2 id='integrate_to_ppi'>Calculate a plan position indicator (<code>ppi</code>) of vertically integrated density
adjusted for range effects</h2><span id='topic+integrate_to_ppi'></span>

<h3>Description</h3>

<p>Estimates a spatial image of vertically integrated density (<code>vid</code>) based on
all elevation scans of the radar, while accounting for the changing overlap
between the radar beams as a function of range. The resulting <code>ppi</code> is a
vertical integration over the layer of biological scatterers based on all
available elevation scans, corrected for range effects due to partial beam
overlap with the layer of biological echoes (overshooting) at larger
distances from the radar. The methodology is described in detail in
Kranstauber et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrate_to_ppi(
  pvol,
  vp,
  nx = 100,
  ny = 100,
  xlim,
  ylim,
  zlim = c(0, 4000),
  res,
  quantity = "eta",
  param = "DBZH",
  raster = NA,
  lat,
  lon,
  antenna,
  beam_angle = 1,
  crs,
  param_ppi = c("VIR", "VID", "R", "overlap", "eta_sum", "eta_sum_expected"),
  k = 4/3,
  re = 6378,
  rp = 6357
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrate_to_ppi_+3A_pvol">pvol</code></td>
<td>
<p>A <code>pvol</code> object.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_vp">vp</code></td>
<td>
<p>A <code>vp</code> object</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_nx">nx</code></td>
<td>
<p>number of raster pixels in the x (longitude) dimension</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_ny">ny</code></td>
<td>
<p>number of raster pixels in the y (latitude) dimension</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_xlim">xlim</code></td>
<td>
<p>x (longitude) range</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_ylim">ylim</code></td>
<td>
<p>y (latitude) range</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_zlim">zlim</code></td>
<td>
<p>Numeric vector of length two. Altitude range, in m</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_res">res</code></td>
<td>
<p>numeric vector of length 1 or 2 to set the resolution of the raster (see <a href="raster.html#topic+resolution">res</a>).
If this argument is used, arguments <code>nx</code> and <code>ny</code> are ignored. Unit is identical to <code>xlim</code> and <code>ylim</code>.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_quantity">quantity</code></td>
<td>
<p>Character. Profile quantity on which to base range
corrections, either <code>eta</code> or <code>dens</code>.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_param">param</code></td>
<td>
<p>reflectivity Character. Scan parameter on which to base range
corrections. Typically the same parameter from which animal densities are
estimated in <code>vp</code>. Either <code>DBZH</code>, <code>DBZV</code>, <code>DBZ</code>, <code>TH</code>, or <code>TV</code>.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_raster">raster</code></td>
<td>
<p>(optional) RasterLayer with a CRS. When specified this raster topology is used for the output, and nx, ny, res
arguments are ignored.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_lat">lat</code></td>
<td>
<p>Latitude of the radar, in degrees. If missing taken from <code>pvol</code>.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_lon">lon</code></td>
<td>
<p>Latitude of the radar, in degrees. If missing taken from <code>pvol</code>.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_antenna">antenna</code></td>
<td>
<p>Numeric. Radar antenna height, in m. Default to antenna height
in <code>vp</code>.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_beam_angle">beam_angle</code></td>
<td>
<p>Numeric. Beam opening angle in degrees, typically the
angle between the half-power (-3 dB) points of the main lobe.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_crs">crs</code></td>
<td>
<p>character or object of class CRS. PROJ.4 type description of a Coordinate Reference System (map projection).
When 'NA' (default), an azimuthal equidistant projection with origin at the radar location is used.
To use a WSG84 (lat,lon) projection, use crs=&quot;+proj=longlat +datum=WGS84&quot;</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_param_ppi">param_ppi</code></td>
<td>
<p>Character (vector). One or multiple of <code>VIR</code>, <code>VID</code>, <code>R</code>,
<code>overlap</code>, <code>eta_sum</code> or <code>eta_sum_expected</code>.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="integrate_to_ppi_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires:
</p>

<ul>
<li><p> A polar volume, containing one or multiple scans (<code>pvol</code>).
</p>
</li>
<li><p> A vertical profile (of birds) calculated for that same polar volume (<code>vp</code>).
</p>
</li>
<li><p> A grid defined on the earth's surface, on which we will calculate the range
corrected image (defined by <code>raster</code>, or a combination of <code>nx</code>, <code>ny</code>,<code>res</code>
arguments).
</p>
</li></ul>

<p>The pixel locations on the ground are easily translated into a corresponding
azimuth and range of the various scans (see <code><a href="#topic+beam_range">beam_range()</a></code>).
</p>
<p>For each scan within the polar volume, the function calculates:
</p>

<ul>
<li><p> the vertical radiation profile for each ground surface pixel for that
particular scan, using <a href="#topic+beam_profile">beam_profile</a>.
</p>
</li>
<li><p> the reflectivity expected for each ground surface pixel
(<code class="reqn">\eta_{expected}</code>), given the vertical profile (of biological
scatterers) and the part of the profile radiated by the beam.
This <code class="reqn">\eta_{expected}</code> is simply the average of (linear) <code>eta</code> in the
profile, weighted by the vertical radiation profile.
</p>
</li>
<li><p> the observed eta at each pixel <code class="reqn">\eta_{observed}</code>, which is converted
form <code>DBZH</code> using function <a href="#topic+dbz_to_eta">dbz_to_eta</a>, with <code>DBZH</code> the reflectivity
factor measured at the pixel's distance from the radar.
</p>
</li>
<li><p> The vertical radiation profile for each ground surface pixel for that
particular scan, using <code><a href="#topic+beam_profile">beam_profile()</a></code>.
</p>
</li>
<li><p> The reflectivity expected for each ground surface pixel
(<code class="reqn">\eta_{expected}</code>), given the vertical profile (of biological
scatterers) and the part of the profile radiated by the beam. This
<code class="reqn">\eta_{expected}</code> is simply the average of (linear) <code>eta</code> in the profile,
weighted by the vertical radiation profile.
</p>
</li>
<li><p> The observed <code>eta</code> at each pixel <code class="reqn">\eta_{observed}</code>,
which is converted form <code>DBZH</code> using <code><a href="#topic+dbz_to_eta">dbz_to_eta()</a></code>, with <code>DBZH</code> the
reflectivity factor measured at the pixel's distance from the radar.
</p>
</li></ul>

<p>If one of <code>lat</code> or <code>lon</code> is missing, the extent of the <code>ppi</code> is taken equal
to the extent of the data in the first scan of the polar volume.
</p>
<p>To arrive at the final PPI image, the function calculates
</p>

<ul>
<li><p> the vertically integrated density (<code>vid</code>) and vertically integrated
reflectivity (<code>vir</code>) for the profile, using the function
<a href="#topic+integrate_profile">integrate_profile</a>.
</p>
</li>
<li><p> the spatial range-corrected PPI for <code>VID</code>, defined as the adjustment
factor image (<code>R</code>), multiplied by the <code>vid</code> calculated for the profile
</p>
</li>
<li><p> the spatial range-corrected PPI for <code>VIR</code>, defined as the adjustment
factor <code>R</code>, multiplied by the <code>vir</code> calculated for the profile.
</p>
</li></ul>

<p>Scans at 90 degree beam elevation (e.g. birdbath scans) are ignored.
</p>
<p>#' @seealso
</p>

<ul>
<li> <p><code><a href="#topic+summary.ppi">summary.ppi()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+beam_profile">beam_profile()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+beam_range">beam_range()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+integrate_profile">integrate_profile()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>ppi</code> object.
</p>


<h3>References</h3>


<ul>
<li><p> Kranstauber B, Bouten W, Leijnse H, Wijers B, Verlinden L, Shamoun-Baranes
J, Dokter AM (2020) High-Resolution Spatial Distribution of Bird Movements
Estimated from a Weather Radar Network. Remote Sensing 12 (4), 635.
<a href="https://doi.org/10.3390/rs12040635">doi:10.3390/rs12040635</a>
</p>
</li>
<li><p> Buler JJ &amp; Diehl RH (2009) Quantifying bird density during migratory
stopover using weather surveillance radar. IEEE Transactions on Geoscience
and Remote Sensing 47: 2741-2751.
<a href="https://doi.org/10.1109/TGRS.2009.2014463">doi:10.1109/TGRS.2009.2014463</a>
</p>
</li></ul>


<ul>
<li><p> Kranstauber B, Bouten W, Leijnse H, Wijers B, Verlinden L, Shamoun-Baranes
J, Dokter AM (2020) High-Resolution Spatial Distribution of Bird
Movements Estimated from a Weather Radar Network. Remote Sensing 12 (4),
635. <a href="https://doi.org/10.3390/rs12040635">doi:10.3390/rs12040635</a>
</p>
</li>
<li><p> Buler JJ &amp; Diehl RH (2009) Quantifying bird density during migratory
stopover using weather surveillance radar. IEEE Transactions on Geoscience
and Remote Sensing 47: 2741-2751.
<a href="https://doi.org/10.1109/TGRS.2009.2014463">doi:10.1109/TGRS.2009.2014463</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Locate and read the polar volume example file
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")

# load polar volume
pvol &lt;- read_pvolfile(pvolfile)

# Read the corresponding vertical profile example
data(example_vp)

# Calculate the range-corrected ppi on a 50x50 pixel raster
ppi &lt;- integrate_to_ppi(pvol, example_vp, nx = 50, ny = 50)

# Plot the vertically integrated reflectivity (VIR) using a
# 0-2000 cm^2/km^2 color scale
plot(ppi, zlim = c(0, 2000))

# Calculate the range-corrected ppi on finer 2000m x 2000m pixel raster
ppi &lt;- integrate_to_ppi(pvol, example_vp, res = 2000)

# Plot the vertically integrated density (VID) using a
# 0-200 birds/km^2 color scale
plot(ppi, param = "VID", zlim = c(0, 200))

# Download a basemap and map the ppi
map(ppi)

# The ppi can also be projected on a user-defined raster, as follows:

# First define the raster
template_raster &lt;- raster::raster(
  raster::extent(12, 13, 56, 57),
  crs = sp::CRS("+proj=longlat")
)

# Project the ppi on the defined raster
ppi &lt;- integrate_to_ppi(pvol, example_vp, raster = template_raster)

# Extract the raster data from the ppi object
raster::brick(ppi$data)

# Calculate the range-corrected ppi on an even finer 500m x 500m pixel raster,
# cropping the area up to 50000 meter from the radar
ppi &lt;- integrate_to_ppi(
  pvol, example_vp, res = 500,
  xlim = c(-50000, 50000), ylim = c(-50000, 50000)
)
plot(ppi, param = "VID", zlim = c(0, 200))

</code></pre>

<hr>
<h2 id='is.nan.data.frame'>Identify <code>NaN</code> in a dataframe</h2><span id='topic+is.nan.data.frame'></span>

<h3>Description</h3>

<p>Identify cells with <code>NaN</code> (not a number) in a data frame. Improves on the
default<code><a href="base.html#topic+is.finite">base::is.nan()</a></code> function, which only works on vectors, by allowing
data frames as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
is.nan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.nan.data.frame_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimension as <code>x</code>, with <code>TRUE</code>/<code>FALSE</code> values for
whether each cell in the original data frame is a number or not.
</p>

<hr>
<h2 id='is.pvolfile'>Check if a file is a polar volume (<code>pvol</code>)</h2><span id='topic+is.pvolfile'></span>

<h3>Description</h3>

<p>Checks whether a file is a polar volume (<code>pvol</code>) in the ODIM HDF5 format that
can be read with bioRad. Evaluates to <code>FALSE</code> for NEXRAD and IRIS RAW polar
volume file (see <code><a href="#topic+nexrad_to_odim">nexrad_to_odim()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.pvolfile(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.pvolfile_+3A_file">file</code></td>
<td>
<p>Character. Path of the file to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for a polar volume file in readable format, otherwise <code>FALSE</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+read_pvolfile">read_pvolfile()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_odim_object_type">get_odim_object_type()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+is.pvol">is.pvol()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Locate the polar volume example file
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")

# Check if it is a pvolfile
is.pvolfile(pvolfile)
</code></pre>

<hr>
<h2 id='is.vpfile'>Check if a file is a vertical profile (<code>vp</code>)</h2><span id='topic+is.vpfile'></span>

<h3>Description</h3>

<p>Checks whether a file is a vertical profile (<code>vp</code>) in the ODIM HDF5 format
that can be read with bioRad.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.vpfile(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.vpfile_+3A_file">file</code></td>
<td>
<p>Character. Path of the file to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> for a vertical profile file in readable format, otherwise
<code>FALSE</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+read_vpfiles">read_vpfiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_odim_object_type">get_odim_object_type()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+is.vp">is.vp()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Locate the vertical profile example file
vpfile &lt;- system.file("extdata", "profile.h5", package = "bioRad")

# Check if it is a vpfile
is.vpfile(vpfile)
</code></pre>

<hr>
<h2 id='list_vpts_aloft'>List aloft urls for time series of vertical profiles (<code>vpts</code>) of radar
stations</h2><span id='topic+list_vpts_aloft'></span>

<h3>Description</h3>

<p>List aloft urls for time series of vertical profiles (<code>vpts</code>) of radar
stations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_vpts_aloft(
  date_min = NULL,
  date_max = NULL,
  radars = NULL,
  format = "csv",
  source = "baltrad",
  show_warnings = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_vpts_aloft_+3A_date_min">date_min</code></td>
<td>
<p>Character, the first date to return urls for. In the shape of
YYYY-MM-DD.</p>
</td></tr>
<tr><td><code id="list_vpts_aloft_+3A_date_max">date_max</code></td>
<td>
<p>Character, the last date to return urls for. In the shape of
YYYY-MM-DD.</p>
</td></tr>
<tr><td><code id="list_vpts_aloft_+3A_radars">radars</code></td>
<td>
<p>Character vector, radar stations to return urls for.</p>
</td></tr>
<tr><td><code id="list_vpts_aloft_+3A_format">format</code></td>
<td>
<p>Character, the format of archive urls to return, either csv or
hdf5. Currently only csv urls are supported.</p>
</td></tr>
<tr><td><code id="list_vpts_aloft_+3A_source">source</code></td>
<td>
<p>Character, either <code>baltrad</code> or <code>ecog-04003</code></p>
</td></tr>
<tr><td><code id="list_vpts_aloft_+3A_show_warnings">show_warnings</code></td>
<td>
<p>Logical, whether to print warnings for dates or radar
stations for which no data was found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of aloft urls
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list_vpts_aloft(radars = "bejab")
</code></pre>

<hr>
<h2 id='map'>Map a plan position indicator (<code>ppi</code>) on a map</h2><span id='topic+map'></span><span id='topic+map.ppi'></span>

<h3>Description</h3>

<p>Plots a plan position indicator (<code>ppi</code>) on a base layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(x, ...)

## S3 method for class 'ppi'
map(
  x,
  map = "cartolight",
  param,
  alpha = 0.7,
  xlim,
  ylim,
  zlim = c(-20, 20),
  ratio,
  radar_size = 3,
  radar_color = "#202020",
  n_color = 1000,
  palette = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_+3A_x">x</code></td>
<td>
<p>A <code>ppi</code> object.</p>
</td></tr>
<tr><td><code id="map_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>.</p>
</td></tr>
<tr><td><code id="map_+3A_map">map</code></td>
<td>
<p>Basemap to use, one of <code>rosm::osm.types()</code></p>
</td></tr>
<tr><td><code id="map_+3A_param">param</code></td>
<td>
<p>Character. Scan parameter to plot, e.g. <code>DBZH</code> or <code>VRADH</code>. See
<code><a href="#topic+summary.param">summary.param()</a></code> for commonly available parameters.</p>
</td></tr>
<tr><td><code id="map_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. Transparency of the data, value between 0 and 1.</p>
</td></tr>
<tr><td><code id="map_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length 2. Range of x values (degrees longitude)
to plot.</p>
</td></tr>
<tr><td><code id="map_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2. Range of y values (degrees latitude)
to plot.</p>
</td></tr>
<tr><td><code id="map_+3A_zlim">zlim</code></td>
<td>
<p>Numeric vector of length 2. The range of values to plot.</p>
</td></tr>
<tr><td><code id="map_+3A_ratio">ratio</code></td>
<td>
<p>Numeric. Aspect ratio between x and y scale, by default
<code class="reqn">1/cos(latitude radar * pi/180)</code>.</p>
</td></tr>
<tr><td><code id="map_+3A_radar_size">radar_size</code></td>
<td>
<p>Numeric. Size of the symbol indicating the radar position.</p>
</td></tr>
<tr><td><code id="map_+3A_radar_color">radar_color</code></td>
<td>
<p>Character. Color of the symbol indicating the radar
position.</p>
</td></tr>
<tr><td><code id="map_+3A_n_color">n_color</code></td>
<td>
<p>Numeric. Number of colors (&gt;=1) to use in the palette.</p>
</td></tr>
<tr><td><code id="map_+3A_palette">palette</code></td>
<td>
<p>Character vector. Hexadecimal color values defining the plot
color scale, e.g. output from <code><a href="viridisLite.html#topic+viridis">viridisLite::viridis()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available scan parameters for mapping can by printed to screen by
<code>summary(x)</code>. Commonly available parameters are:
</p>

<ul>
<li> <p><code>DBZH</code>, <code>DBZ</code>: (Logged) reflectivity factor (dBZ)
</p>
</li>
<li> <p><code>TH</code>, <code>T</code>: (Logged) uncorrected reflectivity factor (dBZ)
</p>
</li>
<li> <p><code>VRADH</code>, <code>VRAD</code>: Radial velocity (m/s). Radial velocities towards the radar
are negative, while radial velocities away from the radar are positive
</p>
</li>
<li> <p><code>RHOHV</code>: Correlation coefficient (unitless) Correlation between vertically
polarized and horizontally polarized reflectivity factor
</p>
</li>
<li> <p><code>PHIDP</code>: Differential phase (degrees)
</p>
</li>
<li> <p><code>ZDR</code>: (Logged) differential reflectivity (dB)
The scan parameters are named according to the OPERA data information
model (ODIM), see Table 16 in the
<a href="https://github.com/adokter/vol2bird/blob/master/doc/OPERA2014_O4_ODIM_H5-v2.2.pdf">ODIM specification</a>.
</p>
</li></ul>



<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>map(ppi)</code>: Plot a <code>ppi</code> object on a map.
</p>
</li></ul>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+project_as_ppi">project_as_ppi()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Project a scan as a ppi
ppi &lt;- project_as_ppi(example_scan)

# Choose a basemap
basemap &lt;- rosm::osm.types()[1]

# Map the radial velocity of the ppi onto the basemap
map(ppi, map = basemap, param = "VRADH")

# Extend the plotting range of velocities, from -50 to 50 m/s
map(ppi, map = basemap, param = "VRADH", zlim = c(-50, 50))

# Map the reflectivity
map(ppi, map = basemap, param = "DBZH")

# Change the color palette to Viridis colors
map(ppi, map = basemap, param = "DBZH", palette = viridis::viridis(100), zlim=c(-10,10))

# Give the data more transparency
map(ppi, map = basemap, param = "DBZH", alpha = 0.3)

# Change the appearance of the symbol indicating the radar location
map(ppi, map = basemap, radar_size = 5, radar_color = "blue")

# Crop the map
map(ppi, map = basemap, xlim = c(12.4, 13.2), ylim = c(56, 56.5))

</code></pre>

<hr>
<h2 id='match_filenames'>Match a set of regular expressions to a list of files</h2><span id='topic+match_filenames'></span>

<h3>Description</h3>

<p>Match a set of regular expressions to a list of files and return those
filenames that comply to any of the provided regular expressions. This
function basically wraps a grep to make it work on vectors by combining the
vector of regex options as possible options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_filenames(file_list, regex_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_filenames_+3A_file_list">file_list</code></td>
<td>
<p>character vector. Haystack of filenames/filepaths.</p>
</td></tr>
<tr><td><code id="match_filenames_+3A_regex_list">regex_list</code></td>
<td>
<p>character vector. Needle of regular expressions to which
filenames should comply.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector. Subset of filenames from the file_list that comply
to the provided regular expressions in regex_list.
</p>

<hr>
<h2 id='Math.scan'>Mathematical and arithmetic operations on param's, scan's and pvol's</h2><span id='topic+Math.scan'></span><span id='topic+Math.pvol'></span><span id='topic+Ops.param'></span><span id='topic+Ops.scan'></span><span id='topic+Ops.pvol'></span>

<h3>Description</h3>

<p>Mathematical and arithmetic operations on param's, scan's and pvol's
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scan'
Math(x, ...)

## S3 method for class 'pvol'
Math(x, ...)

## S3 method for class 'param'
Ops(e1, e2)

## S3 method for class 'scan'
Ops(e1, e2)

## S3 method for class 'pvol'
Ops(e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math.scan_+3A_x">x</code></td>
<td>
<p>object of class <code>scan</code>, or <code>pvol</code></p>
</td></tr>
<tr><td><code id="Math.scan_+3A_...">...</code></td>
<td>
<p>objects passed on to the Math functions</p>
</td></tr>
<tr><td><code id="Math.scan_+3A_e1">e1</code></td>
<td>
<p>object of class <code>param</code>, <code>scan</code>, <code>pvol</code> or a number</p>
</td></tr>
<tr><td><code id="Math.scan_+3A_e2">e2</code></td>
<td>
<p>object of class <code>param</code>, <code>scan</code>, <code>pvol</code> or a number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use caution when applying these manipulations, as there are no
consistency checks if the operations lead to interpretable outcomes.
For example, when averaging scans with logarithmic values (e.g. DBZ), it might be required
to first exponentiate the data before summing.
</p>
<p>Attributes are taken from the first object in the operation.
</p>
<p>When a <code>pvol</code> is multiplied by a list, in which case arguments are taken from the list per scan.
this requires the list to have the same length as the number of scans.
</p>


<h3>Value</h3>

<p>an object of the input class
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+calculate_param">calculate_param()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Locate and read the polar volume example file
scan1 &lt;- example_scan

#add a value of 1 to all scan parameters:
scan2 &lt;- example_scan + 1

# average the scan parameters of two scans:
# NB: requires identical scan parameter names and order!
(scan1 + scan2)/2
</code></pre>

<hr>
<h2 id='nexrad_to_odim'>Convert a NEXRAD polar volume file to an ODIM polar volume file</h2><span id='topic+nexrad_to_odim'></span>

<h3>Description</h3>

<p>Convert a NEXRAD polar volume file to an ODIM polar volume file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexrad_to_odim(pvolfile_nexrad, pvolfile_odim, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexrad_to_odim_+3A_pvolfile_nexrad">pvolfile_nexrad</code></td>
<td>
<p>Character (vector). Either a path to a single radar polar volume
(<code>pvol</code>) file containing multiple scans/sweeps, or multiple paths to scan
files containing a single scan/sweep. Or a single <code>pvol</code> object. The file data format should be either 1)
<a href="https://github.com/adokter/vol2bird/blob/master/doc/OPERA2014_O4_ODIM_H5-v2.2.pdf">ODIM</a>
format, which is the implementation of the OPERA data information model in
the <a href="https://support.hdfgroup.org/HDF5/">HDF5</a> format, 2) a format
supported by the <a href="https://trmm-fc.gsfc.nasa.gov/trmm_gv/software/rsl/">RSL library</a> or 3) Vaisala
IRIS (IRIS RAW) format.</p>
</td></tr>
<tr><td><code id="nexrad_to_odim_+3A_pvolfile_odim">pvolfile_odim</code></td>
<td>
<p>Filename for the polar volume in ODIM HDF5 format to be
generated.</p>
</td></tr>
<tr><td><code id="nexrad_to_odim_+3A_verbose">verbose</code></td>
<td>
<p>Logical. When <code>TRUE</code>, vol2bird <code>stdout</code> is piped to the R
console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> on success
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# download a NEXRAD file, save as KBGM_example
path = file.path(tempdir(), "KBGM_example")

download.file(paste0("https://noaa-nexrad-level2.s3.amazonaws.com/",
  "2019/10/01/KBGM/KBGM20191001_000542_V06"), path, method="libcurl", mode="wb")

# convert to ODIM format

new_path = file.path(tempdir(), "KBGM_example.h5")

nexrad_to_odim(path, new_path)

# verify that we have generated a polar volume in ODIM HDF5 format
get_odim_object_type(new_path)

# clean up
file.remove(path, new_path)

</code></pre>

<hr>
<h2 id='nyquist_velocity'>Calculate Nyquist velocity for a given pulse repetition frequency (PRF)</h2><span id='topic+nyquist_velocity'></span>

<h3>Description</h3>

<p>Calculates the Nyquist velocity given a radar's pulse repetition frequency
(PRF) and wavelength. When specifying two PRFs, the extended Nyquist velocity
is given for a radar using the dual-PRF technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nyquist_velocity(wavelength, prf1, prf2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nyquist_velocity_+3A_wavelength">wavelength</code></td>
<td>
<p>Numeric. Radar wavelength, in cm.</p>
</td></tr>
<tr><td><code id="nyquist_velocity_+3A_prf1">prf1</code></td>
<td>
<p>Numeric. Radar pulse repetition frequency, in Hz.</p>
</td></tr>
<tr><td><code id="nyquist_velocity_+3A_prf2">prf2</code></td>
<td>
<p>Numeric. Alternate radar pulse repetition frequency for a radar
operating in dual-PRF mode, in Hz.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nyquist velocity, in m/s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get Nyquist velocity at C-band (5.3 cm wavelength) and a PRF of 2000 Hz

# Get extended Nyquist velocity in a dual-PRF scheme using 2000 Hz and
# 1500 Hz PRFs
nyquist_velocity(5.3, 2000, 1500)
</code></pre>

<hr>
<h2 id='plot.ppi'>Plot a plan position indicator (<code>ppi</code>)</h2><span id='topic+plot.ppi'></span>

<h3>Description</h3>

<p>Plot a plan position indicator (PPI) generated with <code>project_to_ppi</code>
using <a href="ggplot2.html#topic+ggplot">ggplot</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppi'
plot(
  x,
  param,
  xlim,
  ylim,
  zlim = c(-20, 20),
  ratio = 1,
  na.value = "transparent",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ppi_+3A_x">x</code></td>
<td>
<p>An object of class <code>ppi</code>.</p>
</td></tr>
<tr><td><code id="plot.ppi_+3A_param">param</code></td>
<td>
<p>The scan parameter to plot, see details below.</p>
</td></tr>
<tr><td><code id="plot.ppi_+3A_xlim">xlim</code></td>
<td>
<p>Range of x values to plot.</p>
</td></tr>
<tr><td><code id="plot.ppi_+3A_ylim">ylim</code></td>
<td>
<p>Range of y values to plot.</p>
</td></tr>
<tr><td><code id="plot.ppi_+3A_zlim">zlim</code></td>
<td>
<p>The range of parameter values to plot. Defaults
to parameter specific limits for plotting, not full range of data.</p>
</td></tr>
<tr><td><code id="plot.ppi_+3A_ratio">ratio</code></td>
<td>
<p>Aspect ratio between x and y scale.</p>
</td></tr>
<tr><td><code id="plot.ppi_+3A_na.value">na.value</code></td>
<td>
<p><a href="ggplot2.html#topic+ggplot">ggplot</a> argument setting the plot color of NA values</p>
</td></tr>
<tr><td><code id="plot.ppi_+3A_...">...</code></td>
<td>
<p>Arguments passed to low level <a href="ggplot2.html#topic+ggplot">ggplot</a> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available scan parameters for plotting can by printed to screen
by <code>summary(x)</code>. Commonly available parameters are:
</p>

<ul>
<li> <p><code>DBZH</code>, <code>DBZ</code>: (Logged) reflectivity factor (dBZ)
</p>
</li>
<li> <p><code>TH</code>, <code>T</code>: (Logged) uncorrected reflectivity factor (dBZ)
</p>
</li>
<li> <p><code>VRADH</code>, <code>VRAD</code>: Radial velocity (m/s). Radial velocities towards the radar
are negative, while radial velocities away from the radar are positive
</p>
</li>
<li> <p><code>RHOHV</code>: Correlation coefficient (unitless). Correlation between vertically
polarized and horizontally polarized reflectivity factor
</p>
</li>
<li> <p><code>PHIDP</code>: Differential phase (degrees)
</p>
</li>
<li> <p><code>ZDR</code>: (Logged) differential reflectivity (dB)
The scan parameters are named according to the OPERA data information
model (ODIM), see Table 16 in the
<a href="https://github.com/adokter/vol2bird/blob/master/doc/OPERA2014_O4_ODIM_H5-v2.2.pdf">ODIM specification</a>.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value, side effect is a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load an example scan:
data(example_scan)

# print to screen the available scan parameters:
summary(example_scan)

# make ppi for the scan
ppi &lt;- project_as_ppi(example_scan)

# plot the default scan parameter, which is reflectivity "DBZH":
plot(ppi)

# plot the radial velocity parameter:
plot(ppi, param = "VRADH")

# change the range of reflectivities to plot, from -10 to 10 dBZ:
plot(ppi, param = "DBZH", zlim = c(-10, 10))

# change the scale name and colour scheme, using viridis colors:
plot(ppi, param = "DBZH", zlim = c(-10, 10)) + viridis::scale_fill_viridis(name = "dBZ")

</code></pre>

<hr>
<h2 id='plot.scan'>Plot a scan (<code>scan</code>) in polar coordinates</h2><span id='topic+plot.scan'></span>

<h3>Description</h3>

<p>Plots a scan (<code>scan</code>) in polar coordinates. To plot in Cartesian coordinates,
see <code><a href="#topic+project_as_ppi">project_as_ppi()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scan'
plot(
  x,
  param,
  xlim = c(0, 1e+05),
  ylim = c(0, 360),
  zlim = c(-20, 20),
  na.value = "transparent",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.scan_+3A_x">x</code></td>
<td>
<p>A <code>scan</code> object.</p>
</td></tr>
<tr><td><code id="plot.scan_+3A_param">param</code></td>
<td>
<p>Character. Scan parameter to plot, e.g. <code>DBZH</code> or <code>VRADH</code>. See
<code><a href="#topic+summary.param">summary.param()</a></code> for commonly available parameters.</p>
</td></tr>
<tr><td><code id="plot.scan_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector of length 2. Range of x values (range, distance to
radar) to plot.</p>
</td></tr>
<tr><td><code id="plot.scan_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector of length 2. Range of y values (azimuth) to plot.</p>
</td></tr>
<tr><td><code id="plot.scan_+3A_zlim">zlim</code></td>
<td>
<p>Numeric vector of length 2. The range of parameter values to
plot. Defaults to parameter specific limits for plotting, not full range of data.</p>
</td></tr>
<tr><td><code id="plot.scan_+3A_na.value">na.value</code></td>
<td>
<p>Character. <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> parameter to set the color of
<code>NA</code> values.</p>
</td></tr>
<tr><td><code id="plot.scan_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available scan parameters for plotting can by printed to screen
by <code>summary(x)</code>. Commonly available parameters are:
</p>

<ul>
<li> <p><code>DBZH</code>, <code>DBZ</code>: (Logged) reflectivity factor (dBZ)
</p>
</li>
<li> <p><code>TH</code>, <code>T</code>: (Logged) uncorrected reflectivity factor (dBZ)
</p>
</li>
<li> <p><code>VRADH</code>, <code>VRAD</code>: Radial velocity (m/s). Radial velocities towards the radar
are negative, while radial velocities away from the radar are positive
</p>
</li>
<li> <p><code>RHOHV</code>: Correlation coefficient (unitless). Correlation between vertically
polarized and horizontally polarized reflectivity factor
</p>
</li>
<li> <p><code>PHIDP</code>: Differential phase (degrees)
</p>
</li>
<li> <p><code>ZDR</code>: (Logged) differential reflectivity (dB)
The scan parameters are named according to the OPERA data information
model (ODIM), see Table 16 in the
<a href="https://github.com/adokter/vol2bird/blob/master/doc/OPERA2014_O4_ODIM_H5-v2.2.pdf">ODIM specification</a>.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value, side effect is a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot reflectivity
plot(example_scan, param = "DBZH")


# Change the range of reflectivities to plot, from -10 to 10 dBZ
plot(example_scan, param = "DBZH", zlim = c(-10, 10))

# Change the scale name, change the color palette to Viridis colors
plot(example_scan, param = "DBZH", zlim = c(-10, 10)) +
  viridis::scale_fill_viridis(name = "dBZ")

</code></pre>

<hr>
<h2 id='plot.vp'>Plot a vertical profile (<code>vp</code>)</h2><span id='topic+plot.vp'></span>

<h3>Description</h3>

<p>Plot a vertical profile (<code>vp</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vp'
plot(
  x,
  quantity = "dens",
  xlab = expression("volume density [#/km"^3 * "]"),
  ylab = "height [km]",
  line_col = "red",
  line_lwd = 1,
  line.col = "red",
  line.lwd = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.vp_+3A_x">x</code></td>
<td>
<p>A <code>vp</code> class object.</p>
</td></tr>
<tr><td><code id="plot.vp_+3A_quantity">quantity</code></td>
<td>
<p>Character string with the quantity to plot. See
<a href="#topic+summary.vp">vp</a> for list of available quantities.
</p>

<ul>
<li><p> Aerial density related : <code>dens</code>, <code>eta</code>, <code>dbz</code>, <code>DBZH</code> for density,
reflectivity, reflectivity factor and total reflectivity factor,
respectively.
</p>
</li>
<li><p> Ground speed related : <code>ff</code>, <code>dd</code>, for ground speed and direction,
respectively.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.vp_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.vp_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.vp_+3A_line_col">line_col</code></td>
<td>
<p>Color of the plotted curve.</p>
</td></tr>
<tr><td><code id="plot.vp_+3A_line_lwd">line_lwd</code></td>
<td>
<p>Line width of the plotted curve.</p>
</td></tr>
<tr><td><code id="plot.vp_+3A_line.col">line.col</code></td>
<td>
<p>Deprecated argument, use line_col instead.</p>
</td></tr>
<tr><td><code id="plot.vp_+3A_line.lwd">line.lwd</code></td>
<td>
<p>Deprecated argument, use line_lwd instead.</p>
</td></tr>
<tr><td><code id="plot.vp_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level
<a href="graphics.html#topic+plot.default">plot</a> plotting function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, side effect is a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example vp object:
data(example_vp)

# plot the animal density:
plot(example_vp, quantity = "dens")

# change the line color:
plot(example_vp, line_col = "blue")

# plot the ground speed:
plot(example_vp, quantity = "ff")

# plot the reflectivity factor of
# all scatterers (including precipitation):
plot(example_vp, quantity = "DBZH")
</code></pre>

<hr>
<h2 id='plot.vpi'>Plot an integrated profile (<code>vpi</code>)</h2><span id='topic+plot.vpi'></span>

<h3>Description</h3>

<p>Plot an object of class <code>vpi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vpi'
plot(
  x,
  quantity = "mtr",
  xlab = "time",
  ylab = "migration traffic rate [#/km/h]",
  main = "MTR",
  night_shade = TRUE,
  elev = -0.268,
  lat = NULL,
  lon = NULL,
  ylim = NULL,
  nightshade = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.vpi_+3A_x">x</code></td>
<td>
<p>1 class object inheriting from class <code>vpi</code>, typically a
call to <a href="#topic+integrate_profile">integrate_profile</a>.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_quantity">quantity</code></td>
<td>
<p>Character string with the quantity to plot, one of
</p>

<ul>
<li> <p><code>vid</code> (vertically integrated density),
</p>
</li>
<li> <p><code>vir</code> (vertically integrated reflectivity),
</p>
</li>
<li> <p><code>mtr</code> (migration traffic rate),
</p>
</li>
<li> <p><code>rtr</code> (reflectivity traffic rate),
</p>
</li>
<li> <p><code>mt</code> ((cumulative) migration traffic),
</p>
</li>
<li> <p><code>rt</code> ((cumulative) reflectivity traffic),
</p>
</li>
<li> <p><code>ff</code> (height-averaged ground speed)
</p>
</li>
<li> <p><code>dd</code> (height-averaged direction)
</p>
</li>
<li> <p><code>u</code> (height-averaged u-component of ground speed),
</p>
</li>
<li> <p><code>v</code> (height-averaged v-component of ground speed).
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.vpi_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_night_shade">night_shade</code></td>
<td>
<p>Logical, whether to plot night time shading.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_elev">elev</code></td>
<td>
<p>Numeric, sun elevation to use for day/night transition,
see <a href="#topic+sunrise">sunrise</a>.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_lat">lat</code></td>
<td>
<p>(optional) Latitude in decimal degrees. Overrides the lat
attribute of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_lon">lon</code></td>
<td>
<p>(optional) Longitude in decimal degrees. Overrides the lon
attribute of <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_ylim">ylim</code></td>
<td>
<p>y-axis plot range, numeric atomic vector of length 2.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_nightshade">nightshade</code></td>
<td>
<p>Deprecated argument, use night_shade instead.</p>
</td></tr>
<tr><td><code id="plot.vpi_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level
<a href="graphics.html#topic+plot.default">plot</a> plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The integrated profiles can be visualized in various related quantities, as specified by
argument <code>quantity</code>:
</p>

<ul>
<li> <p><code>vid</code>: Vertically Integrated Density, i.e. the aerial surface density of
individuals. This quantity is dependent on the assumed radar cross section
per individual (RCS)
</p>
</li>
<li> <p><code>vir</code>: Vertically Integrated Reflectivity. This quantity is independent of
the value of individual's radar cross section
</p>
</li>
<li> <p><code>mtr</code>: Migration Traffic Rate. This quantity is dependent on the assumed
radar cross section (RCS)
</p>
</li>
<li> <p><code>rtr</code>: Reflectivity Traffic Rate. This quantity is independent on the
assumed radar cross section (RCS)
</p>
</li>
<li> <p><code>mt</code>: Migration Traffic. This quantity is dependent on the assumed radar
cross section (RCS)
</p>
</li>
<li> <p><code>rt</code>: Reflectivity Traffic. This quantity is independent on the assumed
radar cross section (RCS)
</p>
</li>
<li> <p><code>ff</code>: Horizontal ground speed in m/s
</p>
</li>
<li> <p><code>dd</code>: Horizontal ground speed direction in degrees
</p>
</li>
<li> <p><code>u</code>: Ground speed component west to east in m/s
</p>
</li>
<li> <p><code>v</code>: Ground speed component south to north in m/s
</p>
</li>
<li> <p><code>height</code>: Mean flight height (height weighted by reflectivity eta) in m
above sea level
The height-averaged ground speed quantities (ff,dd,u,v) and height are weighted averages by reflectivity eta.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value, side effect is a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># vertically integrate a vpts object:
vpi &lt;- integrate_profile(example_vpts)
# plot the migration traffic rates
plot(vpi)
# plot the vertically integrated densities, without night shading:
plot(vpi, quantity = "vid", night_shade = FALSE)
</code></pre>

<hr>
<h2 id='plot.vpts'>Plot a time series of vertical profiles (<code>vpts</code>)</h2><span id='topic+plot.vpts'></span>

<h3>Description</h3>

<p>Plot a time series of vertical profiles  of class <code>vpts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vpts'
plot(
  x,
  xlab = "time",
  ylab = "height [m]",
  quantity = "dens",
  log = NA,
  barbs = TRUE,
  barbs_height = 10,
  barbs_time = 20,
  barbs_dens_min = 5,
  zlim,
  legend_ticks,
  legend.ticks,
  main,
  barbs.h = 10,
  barbs.t = 20,
  barbs.dens = 5,
  na_color = "#C8C8C8",
  nan_color = "white",
  n_color = 1000,
  palette = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.vpts_+3A_x">x</code></td>
<td>
<p>A vp class object inheriting from class <code>vpts</code>.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_xlab">xlab</code></td>
<td>
<p>A title for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_ylab">ylab</code></td>
<td>
<p>A title for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_quantity">quantity</code></td>
<td>
<p>Character string with the quantity to plot,
one of '<code>dens</code>','<code>eta</code>','<code>dbz</code>','<code>DBZH</code>' for density,
reflectivity, reflectivity factor and total reflectivity factor,
respectively.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_log">log</code></td>
<td>
<p>Logical, whether to display <code>quantity</code> data on a
logarithmic scale.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_barbs">barbs</code></td>
<td>
<p>Logical, whether to overlay speed barbs.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_barbs_height">barbs_height</code></td>
<td>
<p>Integer, number of barbs to plot in altitudinal dimension.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_barbs_time">barbs_time</code></td>
<td>
<p>Integer, number of barbs to plot in temporal dimension.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_barbs_dens_min">barbs_dens_min</code></td>
<td>
<p>Numeric, lower threshold in aerial density of individuals
for plotting speed barbs in individuals/km^3.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_zlim">zlim</code></td>
<td>
<p>Optional numerical atomic vector of length 2, specifying the
range of <code>quantity</code> values to plot.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_legend_ticks">legend_ticks</code></td>
<td>
<p>Numeric atomic vector specifying the ticks on the
color bar.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_legend.ticks">legend.ticks</code></td>
<td>
<p>Deprecated argument, use legend_ticks instead.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_barbs.h">barbs.h</code></td>
<td>
<p>Deprecated argument, use barbs_height instead.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_barbs.t">barbs.t</code></td>
<td>
<p>Deprecated argument, use barbs_time instead.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_barbs.dens">barbs.dens</code></td>
<td>
<p>Deprecated argument, use barbs_dens_min instead.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_na_color">na_color</code></td>
<td>
<p>Color to use for NA values, see class <code><a href="#topic+summary.vpts">vpts()</a></code> conventions.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_nan_color">nan_color</code></td>
<td>
<p>Color to use for NaN values, see class <code><a href="#topic+summary.vpts">vpts()</a></code> conventions.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_n_color">n_color</code></td>
<td>
<p>The number of colors (&gt;=1) to be in the palette.</p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_palette">palette</code></td>
<td>
<p>(Optional) character vector of hexadecimal color values defining
the plot color scale, e.g. output from <a href="viridisLite.html#topic+viridis">viridis</a></p>
</td></tr>
<tr><td><code id="plot.vpts_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level
<a href="graphics.html#topic+image">image</a> plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aerial abundances can be visualized in four related quantities, as specified
by argument <code>quantity</code>:
</p>

<ul>
<li> <p><code>dens</code>: the aerial density of individuals. This quantity is dependent on
the assumed radar cross section (RCS) in the <code>x$attributes$how$rcs_bird</code>
attribute
</p>
</li>
<li> <p><code>eta</code>: reflectivity. This quantity is independent of the value of the
<code>rcs_bird</code> attribute
</p>
</li>
<li> <p><code>dbz</code>: reflectivity factor. This quantity is independent of the value of
the <code>rcs_bird</code> attribute, and corresponds to the dBZ scale commonly used in
weather radar meteorology. Bioscatter by birds tends to occur at much
higher reflectivity factors at S-band than at C-band
</p>
</li>
<li> <p><code>DBZH</code>: total reflectivity factor. This quantity equals the reflectivity
factor of all scatterers (biological and meteorological scattering
combined)
</p>
</li></ul>

<p>Aerial velocities can be visualized in three related quantities, as specified
by argument <code>quantity</code>:
</p>

<ul>
<li> <p><code>ff</code>: ground speed. The aerial velocity relative to the ground surface in
m/s.
</p>
</li>
<li> <p><code>u</code>: eastward ground speed component in m/s.
</p>
</li>
<li> <p><code>v</code>: northward ground speed component in m/s.
</p>
</li></ul>



<h4>barbs</h4>

<p>In the speed barbs, each half flag represents 2.5 m/s, each full flag 5 m/s,
each pennant (triangle) 25 m/s
</p>



<h4>legend_ticks / zlim</h4>

<p>Default legend ticks and plotting range are specified based on <code>quantity</code>,
radar wavelength (S- vs C-band), and value of <code>log</code>
</p>



<h4>log</h4>

<p>Quantities <code>u</code> and <code>v</code> cannot be plotted on a logarithmic scale, because
these quantities assume negative values.  For quantities <code>DBZH</code> and <code>dbz</code>
<code>log=TRUE</code> is ignored, because these quantities are already logarithmic.
</p>



<h3>Value</h3>

<p>No return value, side effect is a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># locate example file:
ts &lt;- example_vpts
# plot density of individuals for the first 500 time steps, in the altitude
# layer 0-3000 m.
plot(ts[1:500], ylim = c(0, 3000))
# plot total reflectivity factor (rain, birds, insects together):
plot(ts[1:500], ylim = c(0, 3000), quantity = "DBZH")
# regularize the time grid, which includes empty (NA) profiles at
# time steps without data:
ts_regular &lt;- regularize_vpts(ts)
plot(ts_regular)
# change the color of missing NA data to red
plot(ts_regular, na_color="red")
# change the color palette:
plot(ts_regular[1:1000], ylim = c(0, 3000), palette=viridis::viridis(1000))
# change and inverse the color palette:
plot(ts_regular[1:1000], ylim = c(0, 3000), palette=rev(viridis::viridis(1000, option="A")))
# plot the speed profile:
plot(ts_regular[1:1000], quantity="ff")
# plot the northward speed component:
plot(ts_regular[1:1000], quantity="v")
# plot speed profile with more legend ticks,
plot(ts_regular[1:1000], quantity="ff", legend_ticks=seq(0,20,2), zlim=c(0,20))
</code></pre>

<hr>
<h2 id='proj_to_wgs'>A wrapper for <code><a href="sp.html#topic+spTransform">spTransform()</a></code>.
Converts projected coordinates to geographic (WGS84) coordinates.</h2><span id='topic+proj_to_wgs'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="sp.html#topic+spTransform">spTransform()</a></code>.
Converts projected coordinates to geographic (WGS84) coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj_to_wgs(x, y, proj4string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj_to_wgs_+3A_x">x</code></td>
<td>
<p>The x-coordinate in the projected system.</p>
</td></tr>
<tr><td><code id="proj_to_wgs_+3A_y">y</code></td>
<td>
<p>The y-coordinate in the projected system.</p>
</td></tr>
<tr><td><code id="proj_to_wgs_+3A_proj4string">proj4string</code></td>
<td>
<p>An object of class 'CRS', as defined in package <code>sp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SpatialPoints</code>.
</p>

<hr>
<h2 id='project_as_ppi'>Project a scan (<code>scan</code>) or parameter (<code>param</code>) to a plan
position indicator (<code>ppi</code>)</h2><span id='topic+project_as_ppi'></span><span id='topic+project_as_ppi.param'></span><span id='topic+project_as_ppi.scan'></span>

<h3>Description</h3>

<p>Make a plan position indicator (ppi)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_as_ppi(
  x,
  grid_size = 500,
  range_max = 50000,
  project = TRUE,
  ylim = NULL,
  xlim = NULL,
  raster = NA,
  k = 4/3,
  re = 6378,
  rp = 6357
)

## S3 method for class 'param'
project_as_ppi(
  x,
  grid_size = 500,
  range_max = 50000,
  project = TRUE,
  ylim = NULL,
  xlim = NULL,
  raster = NA,
  k = 4/3,
  re = 6378,
  rp = 6357
)

## S3 method for class 'scan'
project_as_ppi(
  x,
  grid_size = 500,
  range_max = 50000,
  project = TRUE,
  ylim = NULL,
  xlim = NULL,
  raster = NA,
  k = 4/3,
  re = 6378,
  rp = 6357
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_as_ppi_+3A_x">x</code></td>
<td>
<p>An object of class <code>param</code> or <code>scan</code>.</p>
</td></tr>
<tr><td><code id="project_as_ppi_+3A_grid_size">grid_size</code></td>
<td>
<p>Cartesian grid size in m.</p>
</td></tr>
<tr><td><code id="project_as_ppi_+3A_range_max">range_max</code></td>
<td>
<p>Maximum range in m.</p>
</td></tr>
<tr><td><code id="project_as_ppi_+3A_project">project</code></td>
<td>
<p>Whether to vertically project onto earth's surface.</p>
</td></tr>
<tr><td><code id="project_as_ppi_+3A_ylim">ylim</code></td>
<td>
<p>The range of latitudes to include.</p>
</td></tr>
<tr><td><code id="project_as_ppi_+3A_xlim">xlim</code></td>
<td>
<p>The range of longitudes to include.</p>
</td></tr>
<tr><td><code id="project_as_ppi_+3A_raster">raster</code></td>
<td>
<p>(optional) RasterLayer with a CRS. When specified this raster topology is used for the output,
and <code>grid_size</code>, <code>range_max</code>, <code>xlim</code>, <code>ylim</code> are ignored.</p>
</td></tr>
<tr><td><code id="project_as_ppi_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="project_as_ppi_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="project_as_ppi_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned PPI is in Azimuthal Equidistant Projection.
</p>


<h3>Value</h3>

<p>An object of class '<a href="#topic+summary.ppi">ppi</a>'.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>project_as_ppi(param)</code>: Project as <code>ppi</code> for a single scan parameter.
</p>
</li>
<li> <p><code>project_as_ppi(scan)</code>: Project multiple <code>ppi</code>'s for all scan
parameters in a scan
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># load a polar scan example object:
data(example_scan)
example_scan

# plot the scan:
plot(example_scan)

# make PPIs for all scan parameters in the scan:
ppi &lt;- project_as_ppi(example_scan)

# print summary info for the ppi:
ppi

# plot the ppi:
plot(ppi)

# extract the DBZH scan parameter of the volume to a new
# object 'param':
param &lt;- get_param(example_scan, "VRADH")

# make a ppi for the new 'param' object:
ppi &lt;- project_as_ppi(param)

# print summary info for this ppi:
ppi

# plot the ppi:
plot(ppi)
</code></pre>

<hr>
<h2 id='rcs'>Get radar cross section</h2><span id='topic+rcs'></span><span id='topic+rcs.vp'></span><span id='topic+rcs.list'></span><span id='topic+rcs.vpts'></span><span id='topic+rcs.vpi'></span>

<h3>Description</h3>

<p>Returns the currently assumed radar cross section of an object in cm^2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcs(x)

## S3 method for class 'vp'
rcs(x)

## S3 method for class 'list'
rcs(x)

## S3 method for class 'vpts'
rcs(x)

## S3 method for class 'vpi'
rcs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcs_+3A_x">x</code></td>
<td>
<p>A <code>vp</code>, list of <code>vp</code>, <code>vpts</code> or <code>vpi</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The radar cross section in cm^2.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+rcs+3C-">rcs()&lt;-</a></code> for setting the radar cross section of an object.
</p>
</li>
<li> <p><code><a href="#topic+sd_vvp_threshold">sd_vvp_threshold()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Get the radar cross section for a vp
rcs(example_vp)

# Get the radar cross section for a vpts
rcs(example_vpts)

# Get the radar cross section for a vpi
vpi &lt;- integrate_profile(example_vpts)
rcs(vpi)
</code></pre>

<hr>
<h2 id='rcs+26lt+3B-'>Set radar cross section</h2><span id='topic+rcs+3C-'></span><span id='topic+rcs+3C-.vp'></span><span id='topic+rcs+3C-.list'></span><span id='topic+rcs+3C-.vpts'></span><span id='topic+rcs+3C-.vpi'></span>

<h3>Description</h3>

<p>Sets the assumed radar cross section of an object in cm^2. This function also
updates the migration densities in <code>x$data$dens</code> to <code>eta</code>/<code>rcs</code> when above
<code>sd_vvp_threshold</code> and <code>0</code> if below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcs(x) &lt;- value

## S3 replacement method for class 'vp'
rcs(x) &lt;- value

## S3 replacement method for class 'list'
rcs(x) &lt;- value

## S3 replacement method for class 'vpts'
rcs(x) &lt;- value

## S3 replacement method for class 'vpi'
rcs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcs+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A <code>vp</code>, list of <code>vp</code>, <code>vpts</code> or <code>vpi</code> object.</p>
</td></tr>
<tr><td><code id="rcs+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Numeric. The radar cross section value to assign in cm^2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object with updated density <code>x$data$dens</code> and updated radar cross section attribute.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+rcs">rcs()</a></code> for getting the radar cross section of an object.
</p>
</li>
<li> <p><code><a href="#topic+sd_vvp_threshold+3C-">sd_vvp_threshold()&lt;-</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Set the radar cross section for a vp
vp &lt;- example_vp
rcs(vp) &lt;- 11

# Set the radar cross section for a vpts
vpts &lt;- example_vpts
rcs(vpts) &lt;- 11

# Set the radar cross section for a vpi
vpi &lt;- integrate_profile(example_vpts)
rcs(vpi) &lt;- 11
</code></pre>

<hr>
<h2 id='read_cajun'>Read a vertical profile (<code>vp</code>) from UMASS Cajun text file</h2><span id='topic+read_cajun'></span>

<h3>Description</h3>

<p>Read a vertical profile (<code>vp</code>) from UMASS Cajun text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_cajun(file, rcs = 11, wavelength = "S")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_cajun_+3A_file">file</code></td>
<td>
<p>Character. Path to a text file containing the standard output
(<code>stdout</code>) generated by UMASS Cajun pipeline.</p>
</td></tr>
<tr><td><code id="read_cajun_+3A_rcs">rcs</code></td>
<td>
<p>Numeric. Radar cross section per bird in cm^2.</p>
</td></tr>
<tr><td><code id="read_cajun_+3A_wavelength">wavelength</code></td>
<td>
<p>Character or numeric. Radar wavelength, either <code>C</code> for
C-band (5.3 cm), <code>S</code> for S-band (10.6 cm) or in cm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vp</code> object.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+summary.vp">summary.vp()</a></code>
</p>
</li></ul>


<hr>
<h2 id='read_pvolfile'>Read a polar volume (<code>pvol</code>) from file</h2><span id='topic+read_pvolfile'></span>

<h3>Description</h3>

<p>Read a polar volume (<code>pvol</code>) from file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pvolfile(
  file,
  param = c("DBZH", "DBZ", "VRADH", "VRAD", "WRADH", "WRAD", "TH", "T", "RHOHV", "ZDR",
    "PHIDP", "CELL", "BIOLOGY", "WEATHER", "BACKGROUND"),
  sort = TRUE,
  lat,
  lon,
  height,
  elev_min = 0,
  elev_max = 90,
  verbose = TRUE,
  mount = dirname(file),
  local_install
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_pvolfile_+3A_file">file</code></td>
<td>
<p>A string containing the path to a polar volume file</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_param">param</code></td>
<td>
<p>An atomic vector of character strings, containing the names
of scan parameters to read. To read all scan parameters use 'all'.</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_sort">sort</code></td>
<td>
<p>A logical value, when <code>TRUE</code> sort scans ascending
by elevation.</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_lat">lat</code></td>
<td>
<p>Latitude in decimal degrees of the radar position. If not
specified, value stored in file is used. If specified, value stored in
file is overwritten.</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_lon">lon</code></td>
<td>
<p>Longitude in decimal degrees of the radar position. If not
specified, value stored in file is used. If specified, value stored in
file is overwritten.</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_height">height</code></td>
<td>
<p>Height of the center of the antenna in meters above sea
level. If not specified, value stored in file is used. If specified, value
stored in file is overwritten.</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_elev_min">elev_min</code></td>
<td>
<p>Minimum scan elevation to read in degrees.</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_elev_max">elev_max</code></td>
<td>
<p>Maximum scan elevation to read in degrees.</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_verbose">verbose</code></td>
<td>
<p>A logical value, whether to print messages (<code>TRUE</code>)
to console.</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_mount">mount</code></td>
<td>
<p>(deprecated) A character string with the mount point (a directory path)
for the Docker container.</p>
</td></tr>
<tr><td><code id="read_pvolfile_+3A_local_install">local_install</code></td>
<td>
<p>(deprecated) String with path to local vol2bird installation,
to use local installation instead of Docker container</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Scan parameters are named according to the OPERA data information
model (ODIM), see Table 16 in the
<a href="https://github.com/adokter/vol2bird/blob/master/doc/OPERA2014_O4_ODIM_H5-v2.2.pdf">ODIM specification</a>.
Commonly available parameters are:
</p>

<ul>
<li> <p><code>DBZH</code>, <code>DBZ</code>: (Logged) reflectivity factor (dBZ)
</p>
</li>
<li> <p><code>TH</code>, <code>T</code>: (Logged) uncorrected reflectivity factor (dBZ)
</p>
</li>
<li> <p><code>VRADH</code>, <code>VRAD</code>: Radial velocity (m/s). Radial
velocities towards the radar are negative, while radial velocities away
from the radar are positive
</p>
</li>
<li> <p><code>RHOHV</code>: Correlation coefficient (unitless). Correlation
between vertically polarized and horizontally polarized reflectivity
factor
</p>
</li>
<li> <p><code>PHIDP</code>: Differential phase (degrees)
</p>
</li>
<li> <p><code>ZDR</code>: (Logged) differential reflectivity (dB)
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <a href="#topic+summary.pvol">pvol</a>, which is a list
containing polar scans, i.e. objects of class <code>scan</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># locate example volume file:
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")

# print the local path of the volume file:
pvolfile

# load the file:
example_pvol &lt;- read_pvolfile(pvolfile)

# print summary info for the loaded polar volume:
example_pvol

# print summary info for the scans in the polar volume:
example_pvol$scans

# copy the first scan to a new object 'scan'
scan &lt;- example_pvol$scans[[1]]

# print summary info for the new object:
scan
</code></pre>

<hr>
<h2 id='read_stdout'>Read a time series of vertical profiles (<code>vpts</code>) from file</h2><span id='topic+read_stdout'></span>

<h3>Description</h3>

<p>Read a time series of vertical profiles (<code>vpts</code>) from file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_stdout(file, radar, lat, lon, height, wavelength = "C", sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_stdout_+3A_file">file</code></td>
<td>
<p>A text file containing the standard output (stdout) generated
by vol2bird (or the package function <code>calculate_vp</code>).</p>
</td></tr>
<tr><td><code id="read_stdout_+3A_radar">radar</code></td>
<td>
<p>A string containing a radar identifier.</p>
</td></tr>
<tr><td><code id="read_stdout_+3A_lat">lat</code></td>
<td>
<p>numeric. Latitude of the radar in decimal degrees.</p>
</td></tr>
<tr><td><code id="read_stdout_+3A_lon">lon</code></td>
<td>
<p>numeric. Longitude of the radar in decimal degrees.</p>
</td></tr>
<tr><td><code id="read_stdout_+3A_height">height</code></td>
<td>
<p>numeric. Height above sea level of the radar antenna in meters.</p>
</td></tr>
<tr><td><code id="read_stdout_+3A_wavelength">wavelength</code></td>
<td>
<p>Radar wavelength in cm, or one of 'C' or 'S' for C-band
and S-band radar, respectively, in which case C-band wavelength is assumed
to be 5.3 cm and S-band wavelength 10.6 cm</p>
</td></tr>
<tr><td><code id="read_stdout_+3A_sep">sep</code></td>
<td>
<p>the field separator character, see <a href="utils.html#topic+read.table">utils::read.table</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object inheriting from class <code>vpts</code>, see
<code><a href="#topic+summary.vpts">vpts()</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># locate example file:
stdout_file &lt;- system.file("extdata", "example_vpts.txt", package = "bioRad")
# load time series:
ts &lt;- read_stdout(stdout_file, radar = "KBGM", wavelength = "S")
ts
</code></pre>

<hr>
<h2 id='read_vp'>Read a vertical profile (<code>vp</code>) from file</h2><span id='topic+read_vp'></span>

<h3>Description</h3>

<p>Read a vertical profile (<code>vp</code>) from file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_vp(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_vp_+3A_file">file</code></td>
<td>
<p>A string containing the path to a vertical profile
generated by <a href="#topic+calculate_vp">calculate_vp</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+summary.vp">summary.vp()</a></code>.
</p>

<hr>
<h2 id='read_vpfiles'>Read a vertical profile (<code>vp</code>) or a list of vertical profiles
(<code>vp</code>) from files</h2><span id='topic+read_vpfiles'></span>

<h3>Description</h3>

<p>Read a vertical profile (<code>vp</code>) or a list of vertical profiles
(<code>vp</code>) from files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_vpfiles(files)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_vpfiles_+3A_files">files</code></td>
<td>
<p>A character vector containing the file names of
vertical profiles in ODIM HDF5 format generated by <a href="#topic+calculate_vp">calculate_vp</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single <code>vp</code> object or a list of <code>vp</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># locate example profile file:
vpfile &lt;- system.file("extdata", "profile.h5", package = "bioRad")

# print the local path of the profile file:
vpfile

# load the file:
read_vpfiles(vpfile)

# to load multiple files at once:
read_vpfiles(c(vpfile, vpfile))
</code></pre>

<hr>
<h2 id='read_vpts'>Read time series of vertical profiles (<code>vpts</code>) from file(s)</h2><span id='topic+read_vpts'></span>

<h3>Description</h3>

<p>Reads <code>vpts</code> data from one or more files.
The following file formats are supported (but cannot be mixed):
</p>

<ul>
<li> <p><a href="https://aloftdata.eu/vpts-csv/">VPTS CSV</a>.
</p>
</li>
<li> <p><a href="https://github.com/adokter/vol2bird/wiki/ODIM-bird-profile-format-specification">ODIM bird profile</a>.
</p>
</li>
<li><p> vol2bird standard output (see example below).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>read_vpts(files, data_frame = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_vpts_+3A_files">files</code></td>
<td>
<p>Path(s) to one or more files containing vpts data.</p>
</td></tr>
<tr><td><code id="read_vpts_+3A_data_frame">data_frame</code></td>
<td>
<p>When <code>FALSE</code> (default) output a <code>vpts</code> object, when <code>TRUE</code> output a data.frame</p>
</td></tr>
<tr><td><code id="read_vpts_+3A_...">...</code></td>
<td>
<p>Additional arguments for backward compatibility, passed to <code>read_stdout</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vpts</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read a vertical profile time series in VPTS CSV format:
vptsfile &lt;- system.file("extdata", "example_vpts.csv", package = "bioRad")
read_vpts(vptsfile)
# read a single vertical profile file in ODIM h5 format:
vpfile &lt;- system.file("extdata", "profile.h5", package = "bioRad")
read_vpts(vpfile)
# read a vertical profile time series in `vol2bird` stdout format:
stdout_file &lt;- system.file("extdata", "example_vpts.txt", package = "bioRad")
read_vpts(stdout_file, radar = "KBGM", wavelength = "S")
</code></pre>

<hr>
<h2 id='regularize_vpts'>Regularize a time series of vertical profiles (<code>vpts</code>) on a
regular time grid</h2><span id='topic+regularize_vpts'></span>

<h3>Description</h3>

<p>Projects objects of class <code>vpts</code> on a regular time grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regularize_vpts(
  ts,
  interval = "auto",
  date_min,
  date_max,
  units = "secs",
  fill = TRUE,
  verbose = TRUE,
  keep_datetime = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regularize_vpts_+3A_ts">ts</code></td>
<td>
<p>An object inheriting from class <code>vpts</code>, see
<code><a href="#topic+summary.vpts">vpts()</a></code> for details.</p>
</td></tr>
<tr><td><code id="regularize_vpts_+3A_interval">interval</code></td>
<td>
<p>Time interval grid to project on. When '<code>auto</code>' the
median interval in the time series is used.</p>
</td></tr>
<tr><td><code id="regularize_vpts_+3A_date_min">date_min</code></td>
<td>
<p>Start time of the projected time series, as a POSIXct object.
Taken from <code>ts</code> by default'.</p>
</td></tr>
<tr><td><code id="regularize_vpts_+3A_date_max">date_max</code></td>
<td>
<p>End time of the projected time series, as a POSIXct object.
Taken from <code>ts</code> by default.</p>
</td></tr>
<tr><td><code id="regularize_vpts_+3A_units">units</code></td>
<td>
<p>Optional units of <code>interval</code> and <code>fill</code>, one of 'secs', 'mins',
'hours','days', 'weeks'. Defaults to 'mins'.</p>
</td></tr>
<tr><td><code id="regularize_vpts_+3A_fill">fill</code></td>
<td>
<p>Numeric or Logical. fill each regularized timestep with the closest
original profile found within a time window of +/- <code>fill</code>.
When <code>TRUE</code>, <code>fill</code> maps to <code>interval</code>, filling single missing
timesteps. When <code>FALSE</code>, <code>fill</code>  maps to 0, disabling filling.</p>
</td></tr>
<tr><td><code id="regularize_vpts_+3A_verbose">verbose</code></td>
<td>
<p>Logical, when <code>TRUE</code> prints text to console.</p>
</td></tr>
<tr><td><code id="regularize_vpts_+3A_keep_datetime">keep_datetime</code></td>
<td>
<p>Logical, when <code>TRUE</code> keep original radar acquisition timestamps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Projects objects of class <code>vpts</code> on a regular time grid, and fills
temporal gaps by nearest neighbor interpolation.
</p>
<p>Irregular time series of profiles are typically aligned on a
regular time grid with the expected time interval at which a radar provides
data. Alignment is performed using a nearest neighbor interpolation limited to
neighboring profiles that fall within +/- <code>fill</code> (centered) of an original profile.
</p>
<p>In plots of regular time series (see <code><a href="#topic+plot.vpts">plot.vpts()</a></code>) temporal gaps of
missing profiles (e.g. due to radar down time) become visible. In irregular
time series data points in the plot are carried through until the time series
continues, and temporal data gaps are filled up visually.
</p>


<h3>Value</h3>

<p>An object of class <code>vpts</code> with regular time steps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># start form example vpts object:
data(example_vpts)
ts &lt;- example_vpts

# regularize the time series on a 5 minute interval grid
tsRegular &lt;- regularize_vpts(ts, interval = 300)

# regularize the time series on a 10 minute interval grid,
# and fill data gaps smaller than 1 hour by nearest neighbor interpolation
tsRegular &lt;- regularize_vpts(ts, interval = 600, fill = 3600)
</code></pre>

<hr>
<h2 id='scan_to_raster'>convert a polar scan into a raster</h2><span id='topic+scan_to_raster'></span>

<h3>Description</h3>

<p>convert an object of class 'scan' into a raster of class 'RasterBrick'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_to_raster(
  scan,
  nx = 100,
  ny = 100,
  xlim,
  ylim,
  res = NA,
  param,
  raster = NA,
  lat,
  lon,
  crs = NA,
  k = 4/3,
  re = 6378,
  rp = 6357
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_to_raster_+3A_scan">scan</code></td>
<td>
<p>a scan (sweep) of class scan</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_nx">nx</code></td>
<td>
<p>number of raster pixels in the x (longitude) dimension</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_ny">ny</code></td>
<td>
<p>number of raster pixels in the y (latitude) dimension</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_xlim">xlim</code></td>
<td>
<p>x (longitude) range</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_ylim">ylim</code></td>
<td>
<p>y (latitude) range</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_res">res</code></td>
<td>
<p>numeric vector of length 1 or 2 to set the resolution of the raster (see <a href="raster.html#topic+resolution">res</a>).
If this argument is used, arguments <code>nx</code> and <code>ny</code> are ignored. Unit is identical to <code>xlim</code> and <code>ylim</code>.</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_param">param</code></td>
<td>
<p>scan parameters to include. If <code>NA</code> include all scan parameters. Reducing the number
of scan parameters speeds up evaluation.</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_raster">raster</code></td>
<td>
<p>(optional) RasterLayer with a CRS. When specified this raster topology is used for the output, and nx, ny, res
arguments are ignored.</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_lat">lat</code></td>
<td>
<p>Geodetic latitude of the radar in degrees. If missing taken from <code>scan</code>.</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_lon">lon</code></td>
<td>
<p>Geodetic longitude of the radar in degrees. If missing taken from <code>scan</code>.</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_crs">crs</code></td>
<td>
<p>character or object of class CRS. PROJ.4 type description of a Coordinate Reference System (map projection).
When 'NA' (default), an azimuthal equidistant projection with origin at the radar location is used.
To use a WSG84 (lat,lon) projection, use crs=&quot;+proj=longlat +datum=WGS84&quot;</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="scan_to_raster_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>uses <a href="#topic+scan_to_spatial">scan_to_spatial</a> to georeference the scan's pixels. If multiple scan pixels fall within
the same raster pixel, the last added pixel is given (see <a href="raster.html#topic+rasterize">rasterize</a> for details).
</p>


<h3>Value</h3>

<p>a RasterBrick
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# default projects full extent on 100x100 pixel raster:
scan_to_raster(example_scan)

# crop the scan and project at a resolution of 0.1 degree:
scan_to_raster(example_scan, ylim = c(55, 57), xlim = c(12, 13), res = .1)

# using a template raster
template_raster &lt;- raster::raster(raster::extent(12, 13, 56, 58), crs = sp::CRS("+proj=longlat"))
scan_to_raster(example_scan, raster = template_raster)

</code></pre>

<hr>
<h2 id='scan_to_spatial'>convert a polar scan into a spatial object.</h2><span id='topic+scan_to_spatial'></span>

<h3>Description</h3>

<p>Georeferences the center of  pixels for a scan into a SpatialPointsDataFrame object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_to_spatial(scan, lat, lon, k = 4/3, re = 6378, rp = 6357)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_to_spatial_+3A_scan">scan</code></td>
<td>
<p>a scan (sweep) of class scan</p>
</td></tr>
<tr><td><code id="scan_to_spatial_+3A_lat">lat</code></td>
<td>
<p>Geodetic latitude of the radar in degrees. If missing taken from <code>scan</code>.</p>
</td></tr>
<tr><td><code id="scan_to_spatial_+3A_lon">lon</code></td>
<td>
<p>Geodetic longitude of the radar in degrees. If missing taken from <code>scan</code>.</p>
</td></tr>
<tr><td><code id="scan_to_spatial_+3A_k">k</code></td>
<td>
<p>Numeric. Standard refraction coefficient.</p>
</td></tr>
<tr><td><code id="scan_to_spatial_+3A_re">re</code></td>
<td>
<p>Numeric. Earth equatorial radius, in km.</p>
</td></tr>
<tr><td><code id="scan_to_spatial_+3A_rp">rp</code></td>
<td>
<p>Numeric. Earth polar radius, in km.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beam altitude accounts for the curvature of the earth, using <a href="#topic+beam_height">beam_height</a>.
Distance from the radar over the earth's surface is calculated using <a href="#topic+beam_distance">beam_distance</a>.
</p>


<h3>Value</h3>

<p>a SpatialPointsDataFrame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example scan:
data(example_scan)

# convert to a SpatialPointsDataFrame:
scan_to_spatial(example_scan)
</code></pre>

<hr>
<h2 id='sd_vvp_threshold'>Get threshold of the radial velocity standard deviation</h2><span id='topic+sd_vvp_threshold'></span><span id='topic+sd_vvp_threshold.vp'></span><span id='topic+sd_vvp_threshold.list'></span><span id='topic+sd_vvp_threshold.vpts'></span>

<h3>Description</h3>

<p>Returns the current threshold of the radial velocity standard deviation
(<code>sd_vvp</code>) of an object in m/s, retrieved by velocity volume processing
(VVP).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_vvp_threshold(x)

## S3 method for class 'vp'
sd_vvp_threshold(x)

## S3 method for class 'list'
sd_vvp_threshold(x)

## S3 method for class 'vpts'
sd_vvp_threshold(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_vvp_threshold_+3A_x">x</code></td>
<td>
<p>A <code>vp</code>, list of <code>vp</code> or <code>vpts</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>sd_vvp</code> threshold in m/s.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+sd_vvp_threshold+3C-">sd_vvp_threshold()&lt;-</a></code> for setting the <code>sd_vvp</code>
threshold of an object.
</p>
</li>
<li> <p><code><a href="#topic+rcs">rcs()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Get the sd_vvp threshold for a vp
sd_vvp_threshold(example_vp)

# Get the sd_vvp threshold for a vpts
sd_vvp_threshold(example_vpts)
</code></pre>

<hr>
<h2 id='sd_vvp_threshold+26lt+3B-'>Set threshold of the radial velocity standard deviation</h2><span id='topic+sd_vvp_threshold+3C-'></span><span id='topic+sd_vvp_threshold+3C-.vp'></span><span id='topic+sd_vvp_threshold+3C-.list'></span><span id='topic+sd_vvp_threshold+3C-.vpts'></span>

<h3>Description</h3>

<p>Sets the threshold of radial velocity standard deviation (<code>sd_vvp</code>) of an
object in m/s. Altitude layers with <code>sd_vvp</code> below this threshold are assumed
to have an aerial density of zero individuals. This function also updates the
migration densities in <code>x$data$dens</code> to <code>eta</code>/<code>rcs</code> when above
<code>sd_vvp_threshold</code> and <code>0</code> if below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_vvp_threshold(x) &lt;- value

## S3 replacement method for class 'vp'
sd_vvp_threshold(x) &lt;- value

## S3 replacement method for class 'list'
sd_vvp_threshold(x) &lt;- value

## S3 replacement method for class 'vpts'
sd_vvp_threshold(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_vvp_threshold+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>A <code>vp</code>, list of <code>vp</code> or <code>vpts</code> object.</p>
</td></tr>
<tr><td><code id="sd_vvp_threshold+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Numeric. The <code>sd_vvp</code> threshold value to assign in m/s.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object with updated density <code>x$data$dens</code> and <code>sd_vvp_thresh</code> attribute.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+sd_vvp_threshold">sd_vvp_threshold()</a></code> for getting the <code>sd_vvp</code> threshold of an object.
</p>
</li>
<li> <p><code><a href="#topic+rcs+3C-">rcs()&lt;-</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Set the sd_vvp threshold for a vp
vp &lt;- example_vp
sd_vvp_threshold(vp) &lt;- 2

# Set the sd_vvp threshold for a vpts
vpts &lt;- example_vpts
sd_vvp_threshold(vpts) &lt;- 2
</code></pre>

<hr>
<h2 id='select_vpfiles'>Select vertical profile (<code>vp</code>) files from computer</h2><span id='topic+select_vpfiles'></span>

<h3>Description</h3>

<p>Create a list of vertical profile (<code>vp</code>) files from a local directory
that match a specific date and radar range. Files are selected based on their
file name (not directory structure), which should be of format
<code style="white-space: pre;">&#8288;radar_vp_yyyymmdd*.*&#8288;</code>, such as <code>bewid_vp_20171123T1900Z_0x5.h5</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_vpfiles(
  date_min = NULL,
  date_max = NULL,
  radars = NULL,
  directory = "."
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_vpfiles_+3A_date_min">date_min</code></td>
<td>
<p>character. YYYY-MM-DD start date of file selection.</p>
</td></tr>
<tr><td><code id="select_vpfiles_+3A_date_max">date_max</code></td>
<td>
<p>character. YYYY-MM-DD end date of file selection.</p>
</td></tr>
<tr><td><code id="select_vpfiles_+3A_radars">radars</code></td>
<td>
<p>character (vector). 5-letter country/radar code(s) (e.g.
<code>bejab</code>) of radars to include in file selection.</p>
</td></tr>
<tr><td><code id="select_vpfiles_+3A_directory">directory</code></td>
<td>
<p>character. Path to local directory where files should be
looked for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of file paths that comply to the given date and
radar range.
</p>


<h3>See Also</h3>

<p>download_vpfiles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>select_vpfiles(
  date_min = "2016-10-03",
  date_max = "2016-10-05",
  radars = "bejab",
  directory = "my_data"
)
</code></pre>

<hr>
<h2 id='skip_if_no_mistnet'>Skip test if no mistnet</h2><span id='topic+skip_if_no_mistnet'></span>

<h3>Description</h3>

<p>Some functions require MistNet to be enabled in package vol2birdR.
This helper function allows to skip a test if MistNet is not available, e.g. when running in CI.
Inspired by <a href="https://testthat.r-lib.org/articles/skipping.html#helpers">https://testthat.r-lib.org/articles/skipping.html#helpers</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skip_if_no_mistnet()
</code></pre>


<h3>Value</h3>

<p>Invisibly returns TRUE if MistNet is available, otherwise skips the test with a message &quot;No MistNet&quot;.
</p>

<hr>
<h2 id='skip_if_no_vol2birdR'>Skip test if vol2birdR not installed</h2><span id='topic+skip_if_no_vol2birdR'></span>

<h3>Description</h3>

<p>Some functions require suggested package vol2birdR to be installed.
This helper function allows to skip a test if vol2birdR is not available, e.g. when running in CI.
Inspired by <a href="https://testthat.r-lib.org/articles/skipping.html#helpers">https://testthat.r-lib.org/articles/skipping.html#helpers</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skip_if_no_vol2birdR()
</code></pre>


<h3>Value</h3>

<p>Invisibly returns TRUE if vol2birdR is installed, otherwise skips the test with
a message &quot;Package vol2birdR not installed&quot;.
</p>

<hr>
<h2 id='summary.param'>Inspect a parameter (<code>param</code>)</h2><span id='topic+summary.param'></span><span id='topic+is.param'></span>

<h3>Description</h3>

<p>R base functions for inspecting a parameter (<code>param</code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'param'
summary(object, ...)

is.param(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.param_+3A_object">object</code></td>
<td>
<p>A <code>param</code> object.</p>
</td></tr>
<tr><td><code id="summary.param_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
<tr><td><code id="summary.param_+3A_x">x</code></td>
<td>
<p>A <code>param</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A parameter is a quantity/variable measured by the radar during a scan (or
sweep). These are organized along radar range (bins) and azimuth (rays). Scan
parameters are named according to the OPERA data information model (ODIM),
see Table 16 in the <a href="https://github.com/adokter/vol2bird/blob/master/doc/OPERA2014_O4_ODIM_H5-v2.2.pdf">ODIM specification</a>.
</p>
<p>Commonly available parameters are:
</p>

<ul>
<li> <p><code>DBZH</code>, <code>DBZ</code>: (Logged) reflectivity factor in dBZ.
</p>
</li>
<li> <p><code>TH</code>, <code>T</code>: (Logged) uncorrected reflectivity factor in dBZ.
</p>
</li>
<li> <p><code>VRADH</code>, <code>VRAD</code>: Radial velocity in m/s. Radial velocities towards the
radar are negative, while radial velocities away from the radar are positive.
</p>
</li>
<li> <p><code>RHOHV</code>: Correlation coefficient (unitless). Correlation between the
vertically and horizontally polarized reflectivity factor.
</p>
</li>
<li> <p><code>PHIDP</code>: Differential phase in degrees.
</p>
</li>
<li> <p><code>ZDR</code>: (Logged) differential reflectivity in dB.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code><a href="#topic+is.param">is.param()</a></code>: <code>TRUE</code> for an object of class <code>param</code>, otherwise
<code>FALSE</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_param">get_param()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Extract the DBZH parameter from a scan
param &lt;- get_param(example_scan, "DBZH")

# Check if it is an object of class param
is.param(param)

# Get summary info for this parameter
param # Same as summary(param) or print(param)
</code></pre>

<hr>
<h2 id='summary.ppi'>Inspect a plan position indicator (<code>ppi</code>)</h2><span id='topic+summary.ppi'></span><span id='topic+is.ppi'></span><span id='topic+dim.ppi'></span>

<h3>Description</h3>

<p>R base functions for inspecting a plan position indicator (<code>ppi</code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ppi'
summary(object, ...)

is.ppi(x)

## S3 method for class 'ppi'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ppi_+3A_object">object</code></td>
<td>
<p>A <code>ppi</code> object.</p>
</td></tr>
<tr><td><code id="summary.ppi_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
<tr><td><code id="summary.ppi_+3A_x">x</code></td>
<td>
<p>A <code>ppi</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plan position indicator is a projection of radar data onto the earth's
surface, generated from a single scan (<code>scan</code>) with <code><a href="#topic+project_as_ppi">project_as_ppi()</a></code>, a
polar volume (<code>pvol</code>) with <code><a href="#topic+integrate_to_ppi">integrate_to_ppi()</a></code> or multiple plan position
indicators (<code>ppi</code>) with <code><a href="#topic+composite_ppi">composite_ppi()</a></code>. A plan position indicator (<code>ppi</code>)
object is a list containing:
</p>

<ul>
<li> <p><code>radar</code>: Radar identifier.
</p>
</li>
<li> <p><code>datetime</code>: Nominal time of the volume to which the scan belongs in UTC.
</p>
</li>
<li> <p><code>data</code>: A <code><a href="sp.html#topic+SpatialGridDataFrame">sp::SpatialGridDataFrame</a></code> containing the georeferenced data.
See <code><a href="#topic+summary.param">summary.param()</a></code> for commonly available parameters, such as <code>DBZH</code>.
</p>
</li>
<li> <p><code>geo</code>: List of the scan's geographic properties (see the <code>geo</code> element in
<code><a href="#topic+summary.scan">summary.scan()</a></code>), with two additional properties:
</p>

<ul>
<li> <p><code>bbox</code>: Bounding box for the plan position indicator in decimal degrees.
</p>
</li>
<li> <p><code>merged</code>: Logical. Flag to indicate if a plan position indicator is a
composite of multiple scans. <code>TRUE</code> if generated with <code><a href="#topic+integrate_to_ppi">integrate_to_ppi()</a></code>
or <code><a href="#topic+composite_ppi">composite_ppi()</a></code>.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>For <code><a href="#topic+is.ppi">is.ppi()</a></code>: <code>TRUE</code> for an object of class <code>ppi</code>, otherwise
<code>FALSE</code>.
</p>
<p>For <code><a href="#topic+dim.ppi">dim.ppi()</a></code>: number of parameters (<code>param</code>), x and y pixels in a
plan position indicator (<code>ppi</code>).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+project_as_ppi">project_as_ppi()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+integrate_to_ppi">integrate_to_ppi()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.ppi">plot.ppi()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+map">map()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+composite_ppi">composite_ppi()</a></code>
</p>
</li>
<li> <p><code><a href="#topic++5B.ppi">[ppi()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Project a scan as a ppi
ppi &lt;- project_as_ppi(example_scan)

# Check if it is an object of class ppi
is.ppi(ppi)

# Get summary info
ppi # Same as summary(ppi) or print(ppi)

# Get dimensions
dim(ppi)
</code></pre>

<hr>
<h2 id='summary.pvol'>Inspect a polar volume (<code>pvol</code>)</h2><span id='topic+summary.pvol'></span><span id='topic+is.pvol'></span><span id='topic+dim.pvol'></span>

<h3>Description</h3>

<p>R base functions for inspecting a polar volume (<code>pvol</code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pvol'
summary(object, ...)

is.pvol(x)

## S3 method for class 'pvol'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pvol_+3A_object">object</code></td>
<td>
<p>A <code>pvol</code> object.</p>
</td></tr>
<tr><td><code id="summary.pvol_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
<tr><td><code id="summary.pvol_+3A_x">x</code></td>
<td>
<p>A <code>pvol</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A polar volume consists of a number of scans (or sweeps) made by the radar at
different elevation angles. A polar volume (<code>pvol</code>) object is a list
containing:
</p>

<ul>
<li> <p><code>radar</code>: Radar identifier.
</p>
</li>
<li> <p><code>datetime</code>: Nominal time of the volume in UTC.
</p>
</li>
<li> <p><code>scans</code>: List of scans (<code>scan</code>) at different elevation angles.
</p>
</li>
<li> <p><code>attributes</code>: List of the volume's <code>what</code>, <code>where</code> and <code>how</code>
attributes.
</p>
</li>
<li> <p><code>geo</code>: List of the volume's geographic properties:
</p>

<ul>
<li> <p><code>lat</code>: Latitude of the radar in decimal degrees.
</p>
</li>
<li> <p><code>lon</code>: Longitude of the radar in decimal degrees.
</p>
</li>
<li> <p><code>height</code>: Height of the radar antenna in meters above sea level.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>For <code><a href="#topic+is.pvol">is.pvol()</a></code>: <code>TRUE</code> for an object of class <code>pvol</code>, otherwise
<code>FALSE</code>.
</p>
<p>For <code><a href="#topic+dim.pvol">dim.pvol()</a></code>: number of scans (<code>scan</code>) in a polar volume
(<code>pvol</code>).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+read_pvolfile">read_pvolfile()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_elevation_angles">get_elevation_angles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_scan">get_scan()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Locate and read the polar volume example file
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")
pvol &lt;- read_pvolfile(pvolfile)

# Check if it is an object of class pvol
is.pvol(pvol)

# Get summary info
pvol # Same as summary(pvol) or print(pvol)

# Get dimensions
dim(pvol)

# Get summary info for the scans in the polar volume
pvol$scans
</code></pre>

<hr>
<h2 id='summary.scan'>Inspect a scan (<code>scan</code>)</h2><span id='topic+summary.scan'></span><span id='topic+is.scan'></span><span id='topic+dim.scan'></span>

<h3>Description</h3>

<p>R base functions for inspecting a scan (<code>scan</code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'scan'
summary(object, ...)

is.scan(x)

## S3 method for class 'scan'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.scan_+3A_object">object</code></td>
<td>
<p>A <code>scan</code> object.</p>
</td></tr>
<tr><td><code id="summary.scan_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
<tr><td><code id="summary.scan_+3A_x">x</code></td>
<td>
<p>A <code>scan</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A scan (or sweep) is made by the radar at a certain elevation angle. The
resulting parameter data (<code>param</code>) are organized along radar range (bins) and
azimuth (rays). A scan (<code>scan</code>) object is a list containing:
</p>

<ul>
<li> <p><code>radar</code>: Radar identifier.
</p>
</li>
<li> <p><code>datetime</code>: Nominal time of the volume to which the scan belongs in UTC.
</p>
</li>
<li> <p><code>params</code>: List of scan parameters (<code>param</code>).
</p>
</li>
<li> <p><code>attributes</code>: List of the scan's <code>what</code>, <code>where</code> and <code>how</code>
attributes.
</p>
</li>
<li> <p><code>geo</code>: List of the scan's geographic properties:
</p>

<ul>
<li> <p><code>lat</code>: Latitude of the radar in decimal degrees.
</p>
</li>
<li> <p><code>lon</code>: Longitude of the radar in decimal degrees.
</p>
</li>
<li> <p><code>height</code>: Height of the radar antenna in meters above sea level.
</p>
</li>
<li> <p><code>elange</code>: Elevation angle of the radar beam for that scan in degrees.
</p>
</li>
<li> <p><code>rscale</code>: Range bin size for that scan in m (e.g. 500 m * 480 bins equals
240 km range).
</p>
</li>
<li> <p><code>ascale</code>: Azimuth bin size for that scan in degrees (e.g. 1 degree * 360
rays equals full circle).
</p>
</li>
<li> <p><code>rstart</code>: The range where the first range gate starts in meters (note ODIM stores it as kilometers)
</p>
</li>
<li> <p><code>astart</code>: The start of the first ray.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>For <code><a href="#topic+summary.scan">summary.scan()</a></code>: prints a summary of the <code>scan</code> object
</p>
<p>For <code><a href="#topic+is.scan">is.scan()</a></code>: <code>TRUE</code> for an object of class <code>scan</code>, otherwise
<code>FALSE</code>.
</p>
<p>For <code><a href="#topic+dim.scan">dim.scan()</a></code>: number of parameters (<code>param</code>), bins and rays in a
scan (<code>scan</code>).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_scan">get_scan()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+example_scan">example_scan</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.scan">plot.scan()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_param">get_param()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Check if an object is of class scan
is.scan(example_scan)

# Get summary info
example_scan # Same as summary(example_scan) or print(example_scan)

# Get dimensions
dim(example_scan)

# Get summary info for the parameters in the scan
example_scan$params
</code></pre>

<hr>
<h2 id='summary.vp'>Inspect a vertical profile (<code>vp</code>)</h2><span id='topic+summary.vp'></span><span id='topic+is.vp'></span><span id='topic+dim.vp'></span>

<h3>Description</h3>

<p>R base functions for inspecting a vertical profile of biological targets
(<code>vp</code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vp'
summary(object, ...)

is.vp(x)

## S3 method for class 'vp'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.vp_+3A_object">object</code></td>
<td>
<p>A <code>vp</code> object.</p>
</td></tr>
<tr><td><code id="summary.vp_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
<tr><td><code id="summary.vp_+3A_x">x</code></td>
<td>
<p>A <code>vp</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vertical profile of biological targets contains a collection of quantities,
organized in different (typically equally spaced) altitude layers (height
bins) above the earth's surface. A vertical profile (<code>vp</code>) object is a list
containing:
</p>

<ul>
<li> <p><code>radar</code>: Radar identifier.
</p>
</li>
<li> <p><code>datetime</code>: Nominal time of the volume to which the scan belongs in UTC.
</p>
</li>
<li> <p><code>data</code>: A data.frame with the profile's quantities organized per height
bin. Use <code><a href="#topic+get_quantity">get_quantity()</a></code> to access these:
</p>

<ul>
<li> <p><code>height</code>: Height bin (lower bound) in m above sea level.
</p>
</li>
<li> <p><code>u</code>: Ground speed component west to east in m/s.
</p>
</li>
<li> <p><code>v</code>: Ground speed component south to north in m/s.
</p>
</li>
<li> <p><code>w</code>: Vertical speed (unreliable!) in m/s.
</p>
</li>
<li> <p><code>ff</code>: Horizontal ground speed in m/s.
</p>
</li>
<li> <p><code>dd</code>: Ground speed direction in degrees clockwise from north.
</p>
</li>
<li> <p><code>sd_vvp</code>: VVP radial velocity standard deviation in m/s.
</p>
</li>
<li> <p><code>gap</code>: Angular data gap detected in T/F.
</p>
</li>
<li> <p><code>dbz</code>: Animal reflectivity factor in dBZ.
</p>
</li>
<li> <p><code>eta</code>: Animal reflectivity in cm^2/km^3.
</p>
</li>
<li> <p><code>dens</code>: Animal density in animals/km^3.
</p>
</li>
<li> <p><code>DBZH</code>: Total reflectivity factor (bio + meteo scattering) in dBZ.
</p>
</li>
<li> <p><code>n</code>: Number of data points used for the ground speed estimates
(quantities <code>u</code>, <code>v</code>, <code>w</code>, <code>ff</code>, <code>dd</code>).
</p>
</li>
<li> <p><code>n_all</code>: Number of data points used for the radial velocity standard
deviation estimate (quantity <code>sd_vvp</code>).
</p>
</li>
<li> <p><code>n_dbz</code>: Number of data points used for reflectivity-based estimates
(quantities <code>dbz</code>, <code>eta</code>, <code>dens</code>).
</p>
</li>
<li> <p><code>n_dbz_all</code>: Number of data points used for the total reflectivity
estimate (quantity <code>DBZH</code>).
</p>
</li></ul>

</li>
<li> <p><code>attributes</code>: List of the vertical profile's <code>what</code>, <code>where</code> and <code>how</code>
attributes.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code><a href="#topic+summary.vp">summary.vp()</a></code>: prints summary of the <code>vp</code> object.
</p>
<p>For <code><a href="#topic+is.vp">is.vp()</a></code>: <code>TRUE</code> for an object of class <code>vp</code>, otherwise
<code>FALSE</code>.
</p>
<p>For <code><a href="#topic+dim.vp">dim.vp()</a></code>: number of heights and quantities in a vertical
profile (<code>vp</code>).
</p>


<h3>Conventions</h3>


<ul>
<li> <p><code>NA</code>: Maps to <code>nodata</code> in the ODIM convention: value to denote areas void
of data (never radiated).
</p>
</li>
<li> <p><code>NaN</code>: Maps to <code>undetect</code> in the ODIM convention: denote areas below the
measurement detection threshold (radiated but nothing detected). The value is
also used when there are too few datapoints to calculate a quantity.
</p>
</li>
<li> <p><code>0</code>: Maps to <code>0</code> in the ODIM convention: denote areas where the quantity
has a measured value of zero (radiated and value zero detected or inferred).
</p>
</li></ul>

<p>It depends on a radar's detection threshold or signal to noise ratio whether
it safe to assume an <code>undetect</code> is equivalent to zero. When dealing with
close range data only (within 35 km), it is typically safe to assume aerial
densities (<code>dens</code>) and reflectivities (<code>eta</code>) are in fact zero in case of
undetects.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+calculate_vp">calculate_vp()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_vpfiles">read_vpfiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+example_vp">example_vp</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_quantity">get_quantity()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.vp">plot.vp()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.vp">as.data.frame.vp()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bind_into_vpts">bind_into_vpts()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Check if an object is of class vp
is.vp(example_vp)

# Get summary info
example_vp # Same as summary(example_vp) or print(example_vp)

# Get dimensions
dim(example_vp)
</code></pre>

<hr>
<h2 id='summary.vpi'>Inspect an integrated profile (<code>vpi</code>)</h2><span id='topic+summary.vpi'></span><span id='topic+is.vpi'></span>

<h3>Description</h3>

<p>R base functions for inspecting an integrated profile of biological targets
(<code>vpi</code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vpi'
summary(object, ...)

is.vpi(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.vpi_+3A_object">object</code></td>
<td>
<p>A <code>vpi</code> object.</p>
</td></tr>
<tr><td><code id="summary.vpi_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
<tr><td><code id="summary.vpi_+3A_x">x</code></td>
<td>
<p>A <code>vpi</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A integrated profile of biological targets is a specially classed
<code>data.frame</code> generated by the function <code><a href="#topic+integrate_profile">integrate_profile()</a></code> with the
following quantities:
</p>

<ul>
<li> <p><code>radar</code>: Radar identifier.
</p>
</li>
<li> <p><code>datetime</code>: POSIXct date of each profile in UTC.
</p>
</li>
<li> <p><code>vid</code>: Vertically Integrated Density in individuals/km^2. <code>vid</code> is a
surface density, whereas <code>dens</code> in <code>vp</code> objects is a volume density.
</p>
</li>
<li> <p><code>vir</code>: Vertically Integrated Reflectivity in cm^2/km^2.
</p>
</li>
<li> <p><code>mtr</code>: Migration Traffic Rate in individuals/km/h.
</p>
</li>
<li> <p><code>rtr</code>: Reflectivity Traffic Rate in cm^2/km/h.
</p>
</li>
<li> <p><code>mt</code>: Migration Traffic in individuals/km, cumulated from the start of the
time series up to <code>datetime</code>.
</p>
</li>
<li> <p><code>rt</code>: Reflectivity Traffic in cm^2/km, cumulated from the start of the
time series up to <code>datetime</code>.
</p>
</li>
<li> <p><code>ff</code>: Horizontal ground speed in m/s.
</p>
</li>
<li> <p><code>dd</code>: Horizontal ground speed direction in degrees.
</p>
</li>
<li> <p><code>u</code>: Ground speed component west to east in m/s.
</p>
</li>
<li> <p><code>v</code>: Ground speed component south to north in m/s.
</p>
</li>
<li> <p><code>height</code>: Mean flight height (height weighted by eta) in m above sea level.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code><a href="#topic+summary.vpi">summary.vpi()</a></code>: prints summary of the <code>vpi</code> object.
</p>
<p>For <code><a href="#topic+is.vpi">is.vpi()</a></code>: <code>TRUE</code> for an object of class <code>vpi</code>, otherwise
<code>FALSE</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+integrate_profile">integrate_profile()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.vpi">plot.vpi()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load the example vertical profile time series and integrate to a vpi
vpi &lt;- integrate_profile(example_vpts)

# Check if it is an object of class vpi
is.vpi(vpi)

# Get summary info
summary(vpi)
</code></pre>

<hr>
<h2 id='summary.vpts'>Inspect a time series of vertical profiles (<code>vpts</code>)</h2><span id='topic+summary.vpts'></span><span id='topic+print.vpts'></span><span id='topic+is.vpts'></span><span id='topic+dim.vpts'></span><span id='topic++5B.vpts'></span>

<h3>Description</h3>

<p>R base functions for inspecting a time series of vertical profiles (<code>vpts</code>)
object.
</p>
<p>Select a vertical profile (<code>vp</code>) or a time series of vertical profiles
(<code>vpts</code>) by index from a <code>vpts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vpts'
summary(object, ...)

## S3 method for class 'vpts'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

is.vpts(x)

## S3 method for class 'vpts'
dim(x)

## S3 method for class 'vpts'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.vpts_+3A_object">object</code></td>
<td>
<p>A <code>vpts</code> object.</p>
</td></tr>
<tr><td><code id="summary.vpts_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
<tr><td><code id="summary.vpts_+3A_x">x</code></td>
<td>
<p>A <code>vpts</code> object.</p>
</td></tr>
<tr><td><code id="summary.vpts_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use when printing. Defaults to <code>max(3L, getOption("digits") - 3L)</code>.</p>
</td></tr>
<tr><td><code id="summary.vpts_+3A_i">i</code></td>
<td>
<p>Integer. Index/indices specifying which range of vertical profiles
to extract.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A time series of vertical profiles contains time-ordered vertical profiles
(<code style="white-space: pre;">&#8288;vp)&#8288;</code> of a single radar. This time series can be <strong>regular</strong> (<code>vp</code> are
equally spaced in time) or <strong>irregular</strong> (time steps between <code>vp</code> are of
unequal length), indicated in the field <code>regular</code>. Irregular time series can
be projected onto a regular time grid with <code><a href="#topic+regularize_vpts">regularize_vpts()</a></code>. A time series
of vertical profile (<code>vp</code>) object is a list containing:
</p>

<ul>
<li> <p><code>radar</code>: Radar identifier.
</p>
</li>
<li> <p><code>datetime</code>: Nominal times of the profiles (named <code>dates</code> in bioRad &lt;
0.4.0) in UTC.
</p>
</li>
<li> <p><code>height</code>: Lowest height of the height bins in the profiles in m above sea
level.
</p>
</li>
<li> <p><code>daterange</code>: Minimum and maximum nominal time of the profiles in UTC.
</p>
</li>
<li> <p><code>timesteps</code>: Time differences between the profiles. Element <code>i</code> gives the
difference between profile <code>i</code> and <code>i+1</code>.
</p>
</li>
<li> <p><code>data</code>: A list of quantities, each containing a <code>datetime</code> by <code>height</code>
matrix with the values. Use <code><a href="#topic+get_quantity">get_quantity()</a></code> to access these and see
<code><a href="#topic+summary.vp">summary.vp()</a></code> for a description of available quantities.
</p>
</li>
<li> <p><code>attributes</code>: List of the vertical profile's <code>what</code>, <code>where</code>, and <code>how</code>
attributes, copied from the first profile.
</p>
</li>
<li> <p><code>regular</code>: Logical indicating whether the time series is regular or not.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code><a href="#topic+summary.vpts">summary.vpts()</a></code>: prints the summary of the<code>vpts</code> object.
</p>
<p>For <code><a href="#topic+print.vpts">print.vpts()</a></code>: prints the summary of the <code>vpts</code> object.
</p>
<p>For <code><a href="#topic+is.vpts">is.vpts()</a></code>: <code>TRUE</code> for an object of class <code>vpts</code>, otherwise
<code>FALSE</code>.
</p>
<p>For <code><a href="#topic+dim.vpts">dim.vpts()</a></code>: number of datetimes, heights and quantities in a
time series of vertical profiles (<code>vpts</code>).
</p>
<p>For <code style="white-space: pre;">&#8288;[.vpts&#8288;</code>: A <code>vpts</code> object containing a subset of vertical profiles (<code>vp</code>) or a
<code>vp</code> object when subsetting a single vertical profile (<code>vp</code>).
</p>


<h3>Conventions</h3>


<ul>
<li> <p><code>NA</code>: Maps to <code>nodata</code> in the ODIM convention: value to denote areas void
of data (never radiated).
</p>
</li>
<li> <p><code>NaN</code>: Maps to <code>undetect</code> in the ODIM convention: denote areas below the
measurement detection threshold (radiated but nothing detected). The value is
also used when there are too few datapoints to calculate a quantity.
</p>
</li>
<li> <p><code>0</code>: Maps to <code>0</code> in the ODIM convention: denote areas where the quantity
has a measured value of zero (radiated and value zero detected or inferred).
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bind_into_vpts">bind_into_vpts()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+read_vpts">read_vpts()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+filter_vpts">filter_vpts()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+regularize_vpts">regularize_vpts()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+example_vpts">example_vpts</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_quantity">get_quantity()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.vp">plot.vp()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.vpts">as.data.frame.vpts()</a></code>
</p>
</li>
<li> <p><code><a href="#topic++5B.vpts">[vpts()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Check if an object is of class vpts
is.vpts(example_vpts)

# Get summary info
example_vpts # Same as summary(example_vpts) or print(example_vpts)

# Get dimensions
dim(example_vpts)
# The example vpts contains 1934 profiles (i.e. datetimes)
dim(example_vpts)

# Subset vpts to extract 10th profile
example_vpts[10] # A vp object

# Subset vpts to extract the 20th to 100th profile
example_vpts[20:100] # A vpts object with 81 profiles

# Subset vpts to remove the first 10 profiles
example_vpts[-1:-10] # A vpts object with 10 less profiles
</code></pre>

<hr>
<h2 id='sunrise_sunset'>Calculate sunrise or sunset for a time and place</h2><span id='topic+sunrise_sunset'></span><span id='topic+sunrise'></span><span id='topic+sunset'></span>

<h3>Description</h3>

<p>Calculate sunrise or sunset for a time and place
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sunrise(date, lon, lat, elev = -0.268, tz = "UTC", force_tz = FALSE)

sunset(date, lon, lat, elev = -0.268, tz = "UTC", force_tz = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sunrise_sunset_+3A_date">date</code></td>
<td>
<p>POSIXct. Date interpretable by <code><a href="base.html#topic+as.Date">base::as.Date()</a></code>.</p>
</td></tr>
<tr><td><code id="sunrise_sunset_+3A_lon">lon</code></td>
<td>
<p>Numeric. Longitude in decimal degrees.</p>
</td></tr>
<tr><td><code id="sunrise_sunset_+3A_lat">lat</code></td>
<td>
<p>Numeric. Latitude in decimal degrees.</p>
</td></tr>
<tr><td><code id="sunrise_sunset_+3A_elev">elev</code></td>
<td>
<p>Numeric. Sun elevation in degrees.</p>
</td></tr>
<tr><td><code id="sunrise_sunset_+3A_tz">tz</code></td>
<td>
<p>Character. Time zone of <code>date</code>, ignored if <code>date</code> already has an
associated time zone.</p>
</td></tr>
<tr><td><code id="sunrise_sunset_+3A_force_tz">force_tz</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the output is converted to the timezone
set by <code>tz</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The day for which sunrise and sunset are calculated is given by the input date.
Sunrise and sunset are calculated relative to the moment of solar noon for that date,
i.e. the first sunrise before the moment of solar noon, and the first sunset after the
moment of solar noon. Therefore, depending on the timezone provided, it is possible that
the nearest sunrise prior to solar noon occurs a day earlier than the input date.
Similarly, sunset may occur a day later than the input date. See examples for details.
</p>
<p>The angular diameter of the sun is about 0.536 degrees,
therefore the moment of sunrise/sunset corresponds to half that elevation
at -0.268 degrees.
</p>
<p>This is a convenience function mapping to <a href="suntools.html#topic+crepuscule">suntools::crepuscule</a>.
</p>
<p>Approximate astronomical formula are used, therefore the moment of
sunrise / sunset may be off by a few minutes
</p>
<p>If <code>force_tz</code> is <code>TRUE</code>, the output is converted to the timezone
set by <code>tz</code>
</p>
<p>The day for which sunrise and sunset are calculated is given by the input date.
Sunrise and sunset are calculated relative to the moment of solar noon for that date,
i.e. the first sunrise before the moment of solar noon, and the first sunset after the
moment of solar noon. Therefore, depending on the timezone provided, it is possible that
the nearest sunrise prior to solar noon occurs a day earlier than the input date.
Similarly, sunset may occur a day later than the input date. See examples for details.
</p>
<p>The angular diameter of the sun is about 0.536 degrees,
therefore the moment of sunrise/sunset corresponds to half that elevation
at -0.268 degrees.
</p>
<p>This is a convenience function mapping to <a href="suntools.html#topic+crepuscule">suntools::crepuscule</a>.
</p>
<p>Approximate astronomical formula are used, therefore the moment of
sunrise / sunset may be off by a few minutes
</p>
<p>If <code>force_tz</code> is <code>TRUE</code>, the output is converted to the timezone
set by <code>tz</code>
</p>


<h3>Value</h3>

<p>The moment of sunrise or sunset for the date set by <code>date</code>and time zone as specified
(by <code>date</code> and <code>tz</code>) or in UTC if not specified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sunrise in the Netherlands
sunrise("2016-01-01", 5, 53)

# sunset in the Netherlands
sunset("2016-01-01", 5, 53)

# civil twilight in Ithaca, NY
sunrise("2016-01-01", -76.5, 42.4, elev = -6)

# next sunset in South Dakota, USA
sunset("2016-11-15", -98, 45)

# Beware that some days have two sunsets, or
# two sunrises! E.g. on 5 Oct (local timezone) at
# this location  sunset is actually on the 6 Oct
# in UTC time zone, i.e. the next day
sunset("2016-10-5", -98, 45)
# One day later, sunset is again on 6 Oct:
sunset("2016-10-6", -98, 45)

# working in local time zones typically avoids such ambiguities:
sunset(lubridate::as_datetime("2016-06-05",tz="America/Chicago"), -98, 45)
sunset(lubridate::as_datetime("2016-06-06",tz="America/Chicago"), -98, 45)

# use force_tz to force output to a specific time zone, by default UTC:
sunset(lubridate::as_datetime("2016-06-05",tz="America/Chicago"), -98, 45, force_tz=TRUE)
sunset(lubridate::as_datetime("2016-06-06",tz="America/Chicago"), -98, 45, force_tz=TRUE)

# Also beware of jumps in sunrise and sunset date with longitude:
sunrise("2016-11-01", 100, 45)
sunrise("2016-11-01", 102, 45)

# Sunrise in the Netherlands
sunrise("2016-01-01", 5, 53)

# Sunset in the Netherlands
sunset("2016-01-01", 5, 53)

# Civil twilight in Ithaca, NY
sunrise("2016-01-01", -76.5, 42.4, elev = -6)

# Next sunset in South Dakota, USA
sunset("2016-11-15", -98, 45)

# Beware that some days have two sunsets, or two sunrises! E.g. on 5 Oct
# (local timezone) at this location sunset is actually on the 6 Oct in UTC,
# i.e. the next day
sunset("2016-10-5", -98, 45)
# One day later, sunset is again on 6 Oct
sunset("2016-10-6", -98, 45)

# Working in local time zones typically avoids such ambiguities
sunset(lubridate::as_datetime("2016-06-05", tz = "America/Chicago"), -98, 45)
sunset(lubridate::as_datetime("2016-06-06", tz = "America/Chicago"), -98, 45)

# Use force_tz to force output to a specific time zone, by default UTC
sunset(lubridate::as_datetime("2016-06-05", tz = "America/Chicago"), -98, 45, force_tz = TRUE)
sunset(lubridate::as_datetime("2016-06-06", tz = "America/Chicago"), -98, 45, force_tz = TRUE)

# Also beware of jumps in sunrise and sunset date with longitude
sunrise("2016-11-01", 100, 45)
sunrise("2016-11-01", 102, 45)
</code></pre>

<hr>
<h2 id='vplist_to_vpts'>Bind vertical profiles (<code>vp</code>) into time series (<code>vpts</code>)</h2><span id='topic+vplist_to_vpts'></span>

<h3>Description</h3>

<p>Used as helper function for the method dispatched <code>bind_into_vpts</code> and
keeping backward compatibility with the <code>vpts</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vplist_to_vpts(x, radar = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vplist_to_vpts_+3A_x">x</code></td>
<td>
<p>A list of <code>vp</code> objects, usually a result of a call
to <a href="#topic+read_vpfiles">read_vpfiles</a>.</p>
</td></tr>
<tr><td><code id="vplist_to_vpts_+3A_radar">radar</code></td>
<td>
<p>optional string containing the radar identifier to generate
time series for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <a href="#topic+summary.vpts">vpts</a> when <code>list</code>
contains profiles of a single radar. A list of objects of class
<a href="#topic+summary.vpts">vpts</a> in case when <code>list</code> contains profiles of
multiple radars, containing <a href="#topic+summary.vpts">vpts</a> objects for each radar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vpfile1 &lt;- system.file("extdata", "profile.h5", package = "bioRad")
vpfile2 &lt;- vpfile1
vps &lt;- read_vpfiles(c(vpfile1,vpfile2))
ts &lt;- bind_into_vpts(vps)
</code></pre>

<hr>
<h2 id='wgs_to_proj'>A wrapper for <code><a href="sp.html#topic+spTransform">spTransform()</a></code>.
Converts geographic (WGS84) coordinates to a specified projection</h2><span id='topic+wgs_to_proj'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="sp.html#topic+spTransform">spTransform()</a></code>.
Converts geographic (WGS84) coordinates to a specified projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wgs_to_proj(lon, lat, proj4string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wgs_to_proj_+3A_lon">lon</code></td>
<td>
<p>Longitude</p>
</td></tr>
<tr><td><code id="wgs_to_proj_+3A_lat">lat</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code id="wgs_to_proj_+3A_proj4string">proj4string</code></td>
<td>
<p>An object of class 'CRS', as defined in package <code>sp</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>SpatialPoints</code>.
</p>

<hr>
<h2 id='write_pvolfile'>Write a polar volume (<code>pvol</code>) object to ODIM HDF5 file</h2><span id='topic+write_pvolfile'></span>

<h3>Description</h3>

<p>Write a polar volume (<code>pvol</code>) object to ODIM HDF5 file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_pvolfile(pvol, file, overwrite = FALSE, infer_dtype = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_pvolfile_+3A_pvol">pvol</code></td>
<td>
<p>An object of class <code>pvol</code>.</p>
</td></tr>
<tr><td><code id="write_pvolfile_+3A_file">file</code></td>
<td>
<p>string. A filepath to write the <code>pvol</code> object to.</p>
</td></tr>
<tr><td><code id="write_pvolfile_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. Overwrites existing file when TRUE.</p>
</td></tr>
<tr><td><code id="write_pvolfile_+3A_infer_dtype">infer_dtype</code></td>
<td>
<p>logical. By default (infer_dtype = FALSE) writes 'params'
back into ODIM HDF5 files with data stored in original data types. When TRUE
infers data type from the R object data type, at the cost of (heavily) inflated file sizes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>0 on success. A <code>pvol</code> object will be written to file in ODIM H5 format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># locate example volume file:
pvolfile &lt;- system.file("extdata", "volume.h5", package = "bioRad")

# load the file:
example_pvol &lt;- read_pvolfile(pvolfile)

# write the file:
pvolfile_out &lt;- paste0(tempdir(),"pvolfile_out.h5")
write_pvolfile(example_pvol, pvolfile_out)

# clean up
file.remove(pvolfile_out)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
